 &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_ConferenceResponse(dd, &(val)->u.conferenceResponse))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ResponseMessage(ResponseMessage *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardMessage(&(val)->u.nonStandard);
	    break;
	case 6:
	    ASN1Free_OpenLogicalChannelAck(&(val)->u.openLogicalChannelAck);
	    break;
	case 11:
	    ASN1Free_MultiplexEntrySendAck(&(val)->u.multiplexEntrySendAck);
	    break;
	case 12:
	    ASN1Free_MultiplexEntrySendReject(&(val)->u.multiplexEntrySendReject);
	    break;
	case 13:
	    ASN1Free_RequestMultiplexEntryAck(&(val)->u.requestMultiplexEntryAck);
	    break;
	case 14:
	    ASN1Free_RequestMultiplexEntryReject(&(val)->u.requestMultiplexEntryReject);
	    break;
	case 20:
	    ASN1Free_CommunicationModeResponse(&(val)->u.communicationModeResponse);
	    break;
	case 21:
	    ASN1Free_ConferenceResponse(&(val)->u.conferenceResponse);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_FastConnectOLC(ASN1encoding_t enc, FastConnectOLC *val)
{
    if (!ASN1Enc_OpenLogicalChannel(enc, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_FastConnectOLC(ASN1decoding_t dec, FastConnectOLC *val)
{
    if (!ASN1Dec_OpenLogicalChannel(dec, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_FastConnectOLC(FastConnectOLC *val)
{
    if (val) {
	ASN1Free_OpenLogicalChannel(val);
    }
}

static int ASN1CALL ASN1Enc_FunctionNotUnderstood(ASN1encoding_t enc, FunctionNotUnderstood *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_RequestMessage(enc, &(val)->u.request))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_ResponseMessage(enc, &(val)->u.response))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_CommandMessage(enc, &(val)->u.command))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_FunctionNotUnderstood(ASN1decoding_t dec, FunctionNotUnderstood *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_RequestMessage(dec, &(val)->u.request))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_ResponseMessage(dec, &(val)->u.response))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_CommandMessage(dec, &(val)->u.command))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_FunctionNotUnderstood(FunctionNotUnderstood *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_RequestMessage(&(val)->u.request);
	    break;
	case 2:
	    ASN1Free_ResponseMessage(&(val)->u.response);
	    break;
	case 3:
	    ASN1Free_CommandMessage(&(val)->u.command);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_IndicationMessage(ASN1encoding_t enc, IndicationMessage *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 4, 14))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardMessage(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_FunctionNotUnderstood(enc, &(val)->u.functionNotUnderstood))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_MasterSlaveDeterminationRelease(enc, &(val)->u.masterSlaveDeterminationRelease))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_TerminalCapabilitySetRelease(enc, &(val)->u.terminalCapabilitySetRelease))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_OpenLogicalChannelConfirm(enc, &(val)->u.openLogicalChannelConfirm))
	    return 0;
	break;
    case 6:
	if (!ASN1Enc_RequestChannelCloseRelease(enc, &(val)->u.requestChannelCloseRelease))
	    return 0;
	break;
    case 7:
	if (!ASN1Enc_MultiplexEntrySendRelease(enc, &(val)->u.multiplexEntrySendRelease))
	    return 0;
	break;
    case 8:
	if (!ASN1Enc_RequestMultiplexEntryRelease(enc, &(val)->u.requestMultiplexEntryRelease))
	    return 0;
	break;
    case 9:
	if (!ASN1Enc_RequestModeRelease(enc, &(val)->u.requestModeRelease))
	    return 0;
	break;
    case 10:
	if (!ASN1Enc_MiscellaneousIndication(enc, &(val)->u.miscellaneousIndication))
	    return 0;
	break;
    case 11:
	if (!ASN1Enc_JitterIndication(enc, &(val)->u.jitterIndication))
	    return 0;
	break;
    case 12:
	if (!ASN1Enc_H223SkewIndication(enc, &(val)->u.h223SkewIndication))
	    return 0;
	break;
    case 13:
	if (!ASN1Enc_NewATMVCIndication(enc, &(val)->u.newATMVCIndication))
	    return 0;
	break;
    case 14:
	if (!ASN1Enc_UserInputIndication(enc, &(val)->u.userInput))
	    return 0;
	break;
    case 15:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_H2250MaximumSkewIndication(ee, &(val)->u.h2250MaximumSkewIndication))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 16:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_MCLocationIndication(ee, &(val)->u.mcLocationIndication))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 17:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_ConferenceIndication(ee, &(val)->u.conferenceIndication))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 18:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_VendorIdentification(ee, &(val)->u.vendorIdentification))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 19:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_FunctionNotSupported(ee, &(val)->u.functionNotSupported))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_IndicationMessage(ASN1decoding_t dec, IndicationMessage *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 4, 14))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardMessage(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_FunctionNotUnderstood(dec, &(val)->u.functionNotUnderstood))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_MasterSlaveDeterminationRelease(dec, &(val)->u.masterSlaveDeterminationRelease))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_TerminalCapabilitySetRelease(dec, &(val)->u.terminalCapabilitySetRelease))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_OpenLogicalChannelConfirm(dec, &(val)->u.openLogicalChannelConfirm))
	    return 0;
	break;
    case 6:
	if (!ASN1Dec_RequestChannelCloseRelease(dec, &(val)->u.requestChannelCloseRelease))
	    return 0;
	break;
    case 7:
	if (!ASN1Dec_MultiplexEntrySendRelease(dec, &(val)->u.multiplexEntrySendRelease))
	    return 0;
	break;
    case 8:
	if (!ASN1Dec_RequestMultiplexEntryRelease(dec, &(val)->u.requestMultiplexEntryRelease))
	    return 0;
	break;
    case 9:
	if (!ASN1Dec_RequestModeRelease(dec, &(val)->u.requestModeRelease))
	    return 0;
	break;
    case 10:
	if (!ASN1Dec_MiscellaneousIndication(dec, &(val)->u.miscellaneousIndication))
	    return 0;
	break;
    case 11:
	if (!ASN1Dec_JitterIndication(dec, &(val)->u.jitterIndication))
	    return 0;
	break;
    case 12:
	if (!ASN1Dec_H223SkewIndication(dec, &(val)->u.h223SkewIndication))
	    return 0;
	break;
    case 13:
	if (!ASN1Dec_NewATMVCIndication(dec, &(val)->u.newATMVCIndication))
	    return 0;
	break;
    case 14:
	if (!ASN1Dec_UserInputIndication(dec, &(val)->u.userInput))
	    return 0;
	break;
    case 15:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_H2250MaximumSkewIndication(dd, &(val)->u.h2250MaximumSkewIndication))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 16:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_MCLocationIndication(dd, &(val)->u.mcLocationIndication))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 17:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_ConferenceIndication(dd, &(val)->u.conferenceIndication))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 18:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_VendorIdentification(dd, &(val)->u.vendorIdentification))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 19:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_FunctionNotSupported(dd, &(val)->u.functionNotSupported))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_IndicationMessage(IndicationMessage *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardMessage(&(val)->u.nonStandard);
	    break;
	case 2:
	    ASN1Free_FunctionNotUnderstood(&(val)->u.functionNotUnderstood);
	    break;
	case 7:
	    ASN1Free_MultiplexEntrySendRelease(&(val)->u.multiplexEntrySendRelease);
	    break;
	case 8:
	    ASN1Free_RequestMultiplexEntryRelease(&(val)->u.requestMultiplexEntryRelease);
	    break;
	case 10:
	    ASN1Free_MiscellaneousIndication(&(val)->u.miscellaneousIndication);
	    break;
	case 14:
	    ASN1Free_UserInputIndication(&(val)->u.userInput);
	    break;
	case 16:
	    ASN1Free_MCLocationIndication(&(val)->u.mcLocationIndication);
	    break;
	case 18:
	    ASN1Free_VendorIdentification(&(val)->u.vendorIdentification);
	    break;
	case 19:
	    ASN1Free_FunctionNotSupported(&(val)->u.functionNotSupported);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_MultimediaSystemControlMessage(ASN1encoding_t enc, MultimediaSystemControlMessage *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_RequestMessage(enc, &(val)->u.request))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_ResponseMessage(enc, &(val)->u.response))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_CommandMessage(enc, &(val)->u.command))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_IndicationMessage(enc, &(val)->u.indication))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MultimediaSystemControlMessage(ASN1decoding_t dec, MultimediaSystemControlMessage *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_RequestMessage(dec, &(val)->u.request))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_ResponseMessage(dec, &(val)->u.response))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_CommandMessage(dec, &(val)->u.command))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_IndicationMessage(dec, &(val)->u.indication))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MultimediaSystemControlMessage(MultimediaSystemControlMessage *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_RequestMessage(&(val)->u.request);
	    break;
	case 2:
	    ASN1Free_ResponseMessage(&(val)->u.response);
	    break;
	case 3:
	    ASN1Free_CommandMessage(&(val)->u.command);
	    break;
	case 4:
	    ASN1Free_IndicationMessage(&(val)->u.indication);
	    break;
	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\h245com.h ===
/******************************************************************************
 *
 *   INTEL Corporation Proprietary Information				   
 *   Copyright (c) 1994, 1995, 1996 Intel Corporation.			
 *									   
 *   This listing is supplied under the terms of a license agreement	   
 *   with INTEL Corporation and may not be used, copied, nor disclosed	   
 *   except in accordance with the terms of that agreement.		   
 *
 *****************************************************************************/

/******************************************************************************
 *									   
 *  $Workfile:   h245com.h  $						
 *  $Revision:   1.6  $							
 *  $Modtime:   Mar 04 1997 17:38:42  $					
 *  $Log:   S:/STURGEON/SRC/H245/INCLUDE/VCS/h245com.h_v  $	
 * 
 *    Rev 1.6   Mar 04 1997 17:53:24   tomitowx
 * process detach fix
 * 
 *    Rev 1.5   12 Dec 1996 15:53:48   EHOWARDX
 * 
 * Master Slave Determination kludge.
 * 
 *    Rev 1.4   10 Jun 1996 16:51:20   EHOWARDX
 * Added Configuration parameter to InstanceCreate().
 * 
 *    Rev 1.3   04 Jun 1996 13:24:38   EHOWARDX
 * Fixed warnings in Release build.
 * 
 *    Rev 1.2   29 May 1996 15:21:30   EHOWARDX
 * No change.
 * 
 *    Rev 1.1   28 May 1996 14:10:00   EHOWARDX
 * Tel Aviv update.
 * 
 *    Rev 1.0   09 May 1996 21:04:48   EHOWARDX
 * Initial revision.
 * 
 *    Rev 1.17   09 May 1996 19:38:10   EHOWARDX
 * Redesigned locking logic and added new functionality.
 * 
 *    Rev 1.16   04 Apr 1996 18:06:30   cjutzi
 * - added shutdown lock
 * 
 *    Rev 1.15   26 Mar 1996 13:39:56   cjutzi
 * - fixed ASSERT warning message
 * 
 *    Rev 1.14   26 Mar 1996 13:24:26   cjutzi
 * 
 * - added pragma for release code.. to disable warning messages
 *   from H245TRACE
 * 
 *    Rev 1.13   26 Mar 1996 09:49:34   cjutzi
 * 
 * - ok.. Added Enter&Leave&Init&Delete Critical Sections for Ring 0
 * 
 *    Rev 1.12   26 Mar 1996 08:40:44   cjutzi
 * 
 * 
 *    Rev 1.11   25 Mar 1996 17:54:44   cjutzi
 * 
 * - broke build.. backstep
 * 
 *    Rev 1.10   25 Mar 1996 17:21:32   cjutzi
 * 
 * - added h245sys.x to the global includes for the enter critical 
 *   section stuff
 * 
 *    Rev 1.9   18 Mar 1996 09:14:10   cjutzi
 * 
 * - sorry.. removed timer lock.. not needed. 
 * 
 *    Rev 1.8   18 Mar 1996 08:48:38   cjutzi
 * - added timer lock
 * 
 *    Rev 1.7   13 Mar 1996 14:08:20   cjutzi
 * - removed ASSERT when NDEBUG is defined
 * 
 * 
 *    Rev 1.6   13 Mar 1996 09:50:16   dabrown1
 * added winspox.h for CRITICAL_SECTION definition
 * 
 *    Rev 1.5   12 Mar 1996 15:48:24   cjutzi
 * 
 * - added instance table lock
 * 
 *    Rev 1.4   28 Feb 1996 09:36:22   cjutzi
 * 
 * - added ossGlobal p_ossWorld for debug PDU tracing and PDU verification
 * 
 *    Rev 1.3   21 Feb 1996 12:18:52   EHOWARDX
 * Added parenthesis around n in H245ASSERT() macro.
 * Note: Logical not (!) has higher operator precedence than equal/not equal
 * (== or !=). Therefore, in many places this ASSERT was not acting as the
 * author intended. It is always a good idea to fully parenthesize expressions
 * in macros!
 * 
 *    Rev 1.2   09 Feb 1996 16:19:52   cjutzi
 * 
 * - Added export InstanceTbl to module.. from h245init.x
 * - added trace
 * - added Assert define's
 *  $Ident$
 *
 *****************************************************************************/

#ifndef _H245COM_H_
#define _H245COM_H_
#include "h245api.h"
#include "h245sys.x"		/* critical section stuff */
#include "api.h"		/* api includes */
#include "sendrcv.x"
#include "h245fsm.h"

#ifndef OIL
# define RESULT unsigned long
#endif

void H245Panic  (LPSTR, int);
#ifndef NDEBUG
#define H245PANIC()   { H245Panic(__FILE__,__LINE__); }
#else
#define H245PANIC()
#endif

/*
 * Trace Level Definitions:
 * 
 *	0 - no trace on at all
 *	1 - only errors
 *	2 - PDU tracking
 *	3 - PDU and SendReceive packet tracing
 *	4 - Main API Module level tracing
 *	5 - Inter Module level tacing #1
 *	6 - Inter Module level tacing #2
 *	7 - <Undefined>
 *	8 - <Undefined>
 *	9 - <Undefined>
 *	10- and above.. free for all
 */
#ifndef NDEBUG
void H245TRACE (H245_INST_T inst, DWORD level, LPSTR format, ...);
#else
/* disable H245TRACE warning message too may parameters for macro */
#pragma warning (disable:4002)
#define H245TRACE()
#endif

#define MAXINST	16

extern  DWORD TraceLevel;

typedef struct TimerList 
{
  struct TimerList    * pNext;
  void		      * pContext;
  H245TIMERCALLBACK     pfnCallBack;
  DWORD                 dwAlarm;

} TimerList_T;

typedef struct InstanceStruct 
{
  DWORD		    dwPhysId;           // Physical Identifier
  DWORD		    dwInst;             // H.245 client instance Identifier
  H245_CONFIG_T	    Configuration;      // Client type
  ASN1_CODER_INFO *pWorld;	        // Context for ASN.1 encode/decode

  /* context for subsystems */
  API_STRUCT_T      API;                // API subsystem substructure
  hSRINSTANCE       SendReceive;        // Send/Receive subsystem substructure
  Fsm_Struct_t      StateMachine;       // State Machine subsystem substructure

  TimerList_T      *pTimerList;         // Linked list of running timeout timers
  char              fDelete;            // TRUE to delete instance
  char              LockCount;          // Nested critical section count
  char              bMasterSlaveKludge; // TRUE if remote is same version
  char              bReserved;
};

struct InstanceStruct * InstanceCreate(DWORD dwPhysId, H245_CONFIG_T Configuration);
struct InstanceStruct * InstanceLock(H245_INST_T dwInst);
int InstanceUnlock(struct InstanceStruct *pInstance);
int InstanceDelete(struct InstanceStruct *pInstance);
int InstanceUnlock_ProcessDetach(struct InstanceStruct *pInstance, BOOL fProcessDetach);

BOOL H245SysInit();
VOID H245SysDeInit();
#endif /* _H245COM_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\h245main.c ===
//---------------------------------------------------------------------------
//  File:  H245Main.C
//
//  This file contains the DLL's entry and exit points.
//
// INTEL Corporation Proprietary Information
// This listing is supplied under the terms of a license agreement with 
// Intel Corporation and may not be copied nor disclosed except in 
// accordance with the terms of that agreement.
// Copyright (c) 1995 Intel Corporation. 
//---------------------------------------------------------------------------

#ifndef STRICT 
#define STRICT 
#endif

#include "precomp.h"


#define H245DLL_EXPORT
#include "h245com.h"

#if defined(_DEBUG) || defined(PCS_COMPLIANCE)
#include "interop.h"
#include "h245plog.h"
LPInteropLogger H245Logger = NULL;
#endif  // (PCS_COMPLIANCE)

extern CRITICAL_SECTION         TimerLock;
extern CRITICAL_SECTION         InstanceCreateLock;
extern CRITICAL_SECTION         InstanceLocks[MAXINST];
extern struct InstanceStruct *  InstanceTable[MAXINST];

BOOL H245SysInit()
{
    register unsigned int           uIndex;

    /* initialize memory resources */
    H245TRACE(0, 0, "***** Loading H.245 DLL %s - %s",  
              __DATE__, __TIME__);
#if defined(_DEBUG) || defined(PCS_COMPLIANCE)
    H245Logger = InteropLoad(H245LOG_PROTOCOL);
#endif  // (PCS_COMPLIANCE)
    InitializeCriticalSection(&TimerLock);
    InitializeCriticalSection(&InstanceCreateLock);
    for (uIndex = 0; uIndex < MAXINST; ++uIndex)
    {
      InitializeCriticalSection(&InstanceLocks[uIndex]);
    }
    return TRUE;
}
VOID H245SysDeInit()
{
    register unsigned int           uIndex;
    H245TRACE(0, 0, "***** Unloading H.245 DLL");

    for (uIndex = 0; uIndex < MAXINST; ++uIndex)
    {
      if (InstanceTable[uIndex])
      {
        register struct InstanceStruct *pInstance = InstanceLock(uIndex + 1);
        if (pInstance)
        {
          H245TRACE(uIndex+1,0,"DLLMain: Calling H245ShutDown");
          H245ShutDown(uIndex + 1);
		  InstanceUnlock_ProcessDetach(pInstance,TRUE);
        }
      }
      ASSERT(InstanceTable[uIndex] == NULL);
      DeleteCriticalSection(&InstanceLocks[uIndex]);
    }
    DeleteCriticalSection(&InstanceCreateLock);
    DeleteCriticalSection(&TimerLock);
#if defined(_DEBUG) || defined(PCS_COMPLIANCE)
    if (H245Logger)
    {
      H245TRACE(0, 4, "Unloading interop logger");
      InteropUnload(H245Logger);
      H245Logger = NULL;
    }
#endif  // (PCS_COMPLIANCE)
}
#if(0)
//---------------------------------------------------------------------------
// Function: dllmain
//
// Description: DLL entry/exit points.
//
//	Inputs:
//    			hInstDll	: DLL instance.
//    			fdwReason	: Reason the main function is called.
//    			lpReserved	: Reserved.
//
//	Return: 	TRUE		: OK
//			FALSE		: Error, DLL won't load
//---------------------------------------------------------------------------
BOOL WINAPI DllMain (HINSTANCE hInstDll, DWORD fdwReason, LPVOID lpvReserved)
{
  extern CRITICAL_SECTION         TimerLock;
  extern CRITICAL_SECTION         InstanceCreateLock;
  extern CRITICAL_SECTION         InstanceLocks[MAXINST];
  extern struct InstanceStruct *  InstanceTable[MAXINST];
  register unsigned int           uIndex;

  switch (fdwReason)
  {
  case DLL_PROCESS_ATTACH:
    DBG_INIT_MEMORY_TRACKING(hInstDll);

    /* initialize memory resources */
    H245TRACE(0, 0, "***** Loading H.245 DLL %s - %s",  
              __DATE__, __TIME__);
#if defined(_DEBUG) || defined(PCS_COMPLIANCE)
    H245Logger = InteropLoad(H245LOG_PROTOCOL);
#endif  // (PCS_COMPLIANCE)
    InitializeCriticalSection(&TimerLock);
    InitializeCriticalSection(&InstanceCreateLock);
    for (uIndex = 0; uIndex < MAXINST; ++uIndex)
    {
      InitializeCriticalSection(&InstanceLocks[uIndex]);
    }
   break;

  case DLL_PROCESS_DETACH:
    /* release memory resources */
    H245TRACE(0, 0, "***** Unloading H.245 DLL");
    H245TRACE(0, 0, "***** fProcessDetach = TRUE");

    for (uIndex = 0; uIndex < MAXINST; ++uIndex)
    {
      if (InstanceTable[uIndex])
      {
        register struct InstanceStruct *pInstance = InstanceLock(uIndex + 1);
        if (pInstance)
        {
          H245TRACE(uIndex+1,0,"DLLMain: Calling H245ShutDown");
          H245ShutDown(uIndex + 1);
		  InstanceUnlock_ProcessDetach(pInstance,TRUE);
        }
      }
      ASSERT(InstanceTable[uIndex] == NULL);
      DeleteCriticalSection(&InstanceLocks[uIndex]);
    }
    DeleteCriticalSection(&InstanceCreateLock);
    DeleteCriticalSection(&TimerLock);
#if defined(_DEBUG) || defined(PCS_COMPLIANCE)
    if (H245Logger)
    {
      H245TRACE(0, 4, "Unloading interop logger");
      InteropUnload(H245Logger);
      H245Logger = NULL;
    }
#endif  // (PCS_COMPLIANCE)

    DBG_CHECK_MEMORY_TRACKING(hInstDll);
    break;
  }

  return TRUE;
}
#endif // if(0)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\h245man.h ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/CALLCONT/VCS/h245man.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1994 Intel Corporation.
 *
 *	$Revision:   1.13  $
 *	$Date:   Aug 27 1996 11:07:30  $
 *	$Author:   mandrews  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *		
 *
 *	Notes:
 *
 ***************************************************************************/

HRESULT InitH245Manager();

HRESULT DeInitH245Manager();

HRESULT MakeH245PhysicalID(			DWORD					*pdwH245PhysicalID);

HRESULT H245Callback(				H245_CONF_IND_T			*pH245ConfIndData,
									void					*pMisc);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\h245fsm.h ===
/***********************************************************************
 *                                                                     *
 * Filename: h245fsm.h                                                 *
 * Module:   H245 Finite State Machine Subsystem                       *
 *                                                                     *
 ***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *                                                                     *
 * $Workfile:   H245FSM.H  $
 * $Revision:   1.6  $
 * $Modtime:   09 Dec 1996 13:40:40  $
 * $Log:   S:/STURGEON/SRC/H245/INCLUDE/VCS/H245FSM.H_v  $
 *
 *    Rev 1.6   09 Dec 1996 13:40:52   EHOWARDX
 * Updated copyright notice.
 *
 *    Rev 1.5   29 Jul 1996 16:57:14   EHOWARDX
 * Added H.223 Annex A Reconfiguration events.
 *
 *    Rev 1.4   01 Jul 1996 22:08:32   EHOWARDX
 *
 * Updated stateless events.
 *
 *    Rev 1.3   30 May 1996 23:38:20   EHOWARDX
 * Cleanup.
 *
 *    Rev 1.2   29 May 1996 15:21:34   EHOWARDX
 * Change to use HRESULT.
 *
 *    Rev 1.1   28 May 1996 14:10:04   EHOWARDX
 * Tel Aviv update.
 *
 *    Rev 1.0   09 May 1996 21:04:50   EHOWARDX
 * Initial revision.
 *
 *    Rev 1.12.1.3   09 May 1996 19:43:58   EHOWARDX
 * Eliminated two events for B-LCSE gratuitous state and changed
 * 2 macros.
 *
 *    Rev 1.12.1.2   15 Apr 1996 10:43:34   EHOWARDX
 * Update.
 *
 *    Rev 1.12.1.1   10 Apr 1996 21:06:10   EHOWARDX
 * Added 5 new state entitys.
 *
 *    Rev 1.12.1.0   05 Apr 1996 11:47:14   EHOWARDX
 * Branched.
 *                                                                     *
 ***********************************************************************/

#ifndef H245FSM_H
#define H245FSM_H

#include <stdlib.h>
#include "fsmexpor.h"
#include "sr_api.h"

#define MAXSTATES  4

#define SUCCESS 0
#define FAIL   -1

#define BAD                 (Output_t) -1
#ifdef IGNORE
#undef IGNORE
#endif
#define IGNORE              (Output_t) NUM_OUTPUTS

typedef MltmdSystmCntrlMssg PDU_t;



// Signalling Entity definitions
typedef unsigned char Entity_t;

// Per-channel Signalling Entities
#define LCSE_OUT    (Entity_t) 0 // Uni-directional Logical Channel signalling Signalling Entity - Out-going
#define LCSE_IN     (Entity_t) 1 // Uni-directional Logical Channel signalling Signalling Entity - In-coming
#define BLCSE_OUT   (Entity_t) 2 // Bi-directional  Logical Channel signalling Signalling Entity - Out-going
#define BLCSE_IN    (Entity_t) 3 // Bi-directional  Logical Channel signalling Signalling Entity - In-coming
#define CLCSE_OUT   (Entity_t) 4 // Close           Logical Channel signalling Signalling Entity - Out-going
#define CLCSE_IN    (Entity_t) 5 // Close           Logical Channel signalling Signalling Entity - In-coming

// Per H.245 Instance Signalling Entities
#define CESE_OUT    (Entity_t) 6 // Capability Exchange Signalling Entity - Out-going
#define CESE_IN     (Entity_t) 7 // Capability Exchange Signalling Entity - In-coming
#define MTSE_OUT    (Entity_t) 8 // Multiplex Table Signalling Entity - Out-going
#define MTSE_IN     (Entity_t) 9 // Multiplex Table Signalling Entity - In-coming
#define RMESE_OUT   (Entity_t)10 // Request Multiplex Entry Signalling Entity - Out-going
#define RMESE_IN    (Entity_t)11 // Request Multiplex Entry Signalling Entity - In-coming
#define MRSE_OUT    (Entity_t)12 // Mode Request Signalling Entity - Out-going
#define MRSE_IN     (Entity_t)13 // Mode Request Signalling Entity - In-coming
#define MLSE_OUT    (Entity_t)14 // Maintenance Loop Signalling Entity - Out-going
#define MLSE_IN     (Entity_t)15 // Maintenance Loop Signalling Entity - In-coming
#define MSDSE       (Entity_t)16 // Master Slave Determination Signalling Entity
#define RTDSE       (Entity_t)17 // Round Trip Delay Signalling Entity
#define STATELESS   (Entity_t)18 // No state machine associated with PDU

#define NUM_ENTITYS           19



// Event definitions
typedef unsigned int Event_t;

// Out-going Uni-directional Logical Channel (LCSE_OUT) events
#define ReqUEstablish                   (Event_t)  0
#define OpenUChAckPDU                   (Event_t)  1
#define OpenUChRejectPDU                (Event_t)  2
#define CloseUChAckPDU                  (Event_t)  3
#define ReqURelease                     (Event_t)  4
#define T103Expiry                      (Event_t)  5

// In-coming Uni-directional Logical Channel (LCSE_IN) events
#define OpenUChPDU                      (Event_t)  6
#define CloseUChPDU                     (Event_t)  7
#define ResponseUEstablish              (Event_t)  8
#define EstablishUReject                (Event_t)  9

// Out-going Bi-directional Logical Channel (BLCSE_OUT) events
#define ReqBEstablish                   (Event_t) 10
#define OpenBChAckPDU                   (Event_t) 11
#define OpenBChRejectPDU                (Event_t) 12
#define CloseBChAckPDU                  (Event_t) 13
#define ReqClsBLCSE                     (Event_t) 14
#define RspConfirmBLCSE                 (Event_t) 15
#define T103OutExpiry                   (Event_t) 16

// In-coming Bi-directional Logical Channel (BLCSE_IN) events
#define OpenBChPDU                      (Event_t) 17
#define CloseBChPDU                     (Event_t) 18
#define ResponseBEstablish              (Event_t) 19
#define OpenBChConfirmPDU               (Event_t) 20
#define OpenRejectBLCSE                 (Event_t) 21
#define T103InExpiry                    (Event_t) 22

// Out-going Request Close Logical Channel (CLCSE_OUT) events
#define ReqClose                        (Event_t) 23
#define ReqChCloseAckPDU                (Event_t) 24
#define ReqChCloseRejectPDU             (Event_t) 25
#define T108Expiry                      (Event_t) 26

// In-coming Request Close Logical Channel (CLCSE_IN) events
#define ReqChClosePDU                   (Event_t) 27
#define ReqChCloseReleasePDU            (Event_t) 28
#define CLCSE_CLOSE_response            (Event_t) 29
#define CLCSE_REJECT_request            (Event_t) 30

// Out-going Terminal Capablity Exchange (CESE_OUT) events
#define TransferCapRequest              (Event_t) 31
#define TermCapSetAckPDU                (Event_t) 32
#define TermCapSetRejectPDU             (Event_t) 33
#define T101Expiry                      (Event_t) 34

// In-coming Terminal Capablity Exchange (CESE_IN) events
#define TermCapSetPDU                   (Event_t) 35
#define TermCapSetReleasePDU            (Event_t) 36
#define CESE_TRANSFER_response          (Event_t) 37
#define CESE_REJECT_request             (Event_t) 38

// Out-going Multiplex Table (MTSE_OUT) events
#define MTSE_TRANSFER_request           (Event_t) 39
#define MultiplexEntrySendAckPDU        (Event_t) 40
#define MultiplexEntrySendRejectPDU     (Event_t) 41
#define T104Expiry                      (Event_t) 42

// In-coming Multiplex Table (MTSE_IN) events
#define MultiplexEntrySendPDU           (Event_t) 43
#define MultiplexEntrySendReleasePDU    (Event_t) 44
#define MTSE_TRANSFER_response          (Event_t) 45
#define MTSE_REJECT_request             (Event_t) 46

// Out-going Request Multiplex Entry (RMESE_OUT) events
#define RMESE_SEND_request              (Event_t) 47
#define RequestMultiplexEntryAckPDU     (Event_t) 48
#define RequestMultiplexEntryRejectPDU  (Event_t) 49
#define T107Expiry                      (Event_t) 50

// In-coming Request Multiplex Entry (RMESE_IN) events
#define RequestMultiplexEntryPDU        (Event_t) 51
#define RequestMultiplexEntryReleasePDU (Event_t) 52
#define RMESE_SEND_response             (Event_t) 53
#define RMESE_REJECT_request            (Event_t) 54

// Out-going Mode Request (MRSE_OUT) events
#define MRSE_TRANSFER_request           (Event_t) 55
#define RequestModeAckPDU               (Event_t) 56
#define RequestModeRejectPDU            (Event_t) 57
#define T109Expiry                      (Event_t) 58

// In-coming Mode Request (MRSE_IN) events
#define RequestModePDU                  (Event_t) 59
#define RequestModeReleasePDU           (Event_t) 60
#define MRSE_TRANSFER_response          (Event_t) 61
#define MRSE_REJECT_request             (Event_t) 62

// Out-going Maintenance Loop (MLSE_OUT) events
#define MLSE_LOOP_request               (Event_t) 63
#define MLSE_OUT_RELEASE_request        (Event_t) 64
#define MaintenanceLoopAckPDU           (Event_t) 65
#define MaintenanceLoopRejectPDU        (Event_t) 66
#define T102Expiry                      (Event_t) 67

// In-coming Maintenance Loop (MLSE_IN) events
#define MaintenanceLoopRequestPDU       (Event_t) 68
#define MaintenanceLoopOffCommandPDU    (Event_t) 69
#define MLSE_LOOP_response              (Event_t) 70
#define MLSE_IN_RELEASE_request         (Event_t) 71

// Master Slave Determination (MSDSE) events
#define MSDetReq                        (Event_t) 72
#define MSDetPDU                        (Event_t) 73
#define MSDetAckPDU                     (Event_t) 74
#define MSDetRejectPDU                  (Event_t) 75
#define MSDetReleasePDU                 (Event_t) 76
#define T106Expiry                      (Event_t) 77

// Round Trip Delay Delay (RTDSE) events
#define RTDSE_TRANSFER_request          (Event_t) 78
#define RoundTripDelayRequestPDU        (Event_t) 79
#define RoundTripDelayResponsePDU       (Event_t) 80
#define T105Expiry                      (Event_t) 81

#define NUM_STATE_EVENTS                          82

// Events with no associated state entity
#define NonStandardRequestPDU           (Event_t) 82
#define NonStandardResponsePDU          (Event_t) 83
#define NonStandardCommandPDU           (Event_t) 84
#define NonStandardIndicationPDU        (Event_t) 85
#define MiscellaneousCommandPDU         (Event_t) 86
#define MiscellaneousIndicationPDU      (Event_t) 87
#define CommunicationModeRequestPDU     (Event_t) 88
#define CommunicationModeResponsePDU    (Event_t) 89
#define CommunicationModeCommandPDU     (Event_t) 90
#define ConferenceRequestPDU            (Event_t) 91
#define ConferenceResponsePDU           (Event_t) 92
#define ConferenceCommandPDU            (Event_t) 93
#define ConferenceIndicationPDU         (Event_t) 94
#define SendTerminalCapabilitySetPDU    (Event_t) 95
#define EncryptionCommandPDU            (Event_t) 96
#define FlowControlCommandPDU           (Event_t) 97
#define EndSessionCommandPDU            (Event_t) 98
#define FunctionNotUnderstoodPDU        (Event_t) 99
#define JitterIndicationPDU             (Event_t)100
#define H223SkewIndicationPDU           (Event_t)101
#define NewATMVCIndicationPDU           (Event_t)102
#define UserInputIndicationPDU          (Event_t)103
#define H2250MaximumSkewIndicationPDU   (Event_t)104
#define MCLocationIndicationPDU         (Event_t)105
#define VendorIdentificationPDU         (Event_t) 106
#define FunctionNotSupportedPDU         (Event_t) 107
#define H223ReconfigPDU                 (Event_t)108
#define H223ReconfigAckPDU              (Event_t)109
#define H223ReconfigRejectPDU           (Event_t)110

#define NUM_EVENTS                               111



// Output function definitions
typedef unsigned char Output_t;

// Out-going Open Uni-directional Logical Channel (LCSE_OUT) state functions
#define EstablishReleased               (Output_t)  0
#define OpenAckAwaitingE                (Output_t)  1
#define OpenRejAwaitingE                (Output_t)  2
#define ReleaseAwaitingE                (Output_t)  3
#define T103AwaitingE                   (Output_t)  4
#define ReleaseEstablished              (Output_t)  5
#define OpenRejEstablished              (Output_t)  6
#define CloseAckEstablished             (Output_t)  7
#define CloseAckAwaitingR               (Output_t)  8
#define OpenRejAwaitingR                (Output_t)  9
#define T103AwaitingR                   (Output_t) 10
#define EstablishAwaitingR              (Output_t) 11

// In-coming Open Uni-directional Logical Channel (LCSE_IN) state functions
#define OpenReleased                    (Output_t) 12
#define CloseReleased                   (Output_t) 13
#define ResponseAwaiting                (Output_t) 14
#define ReleaseAwaiting                 (Output_t) 15
#define CloseAwaiting                   (Output_t) 16
#define OpenAwaiting                    (Output_t) 17
#define CloseEstablished                (Output_t) 18
#define OpenEstablished                 (Output_t) 19

// Out-going Open Bi-directional Logical Channel (BLCSE_OUT) state functions
#define EstablishReqBReleased           (Output_t) 20
#define OpenChannelAckBAwaitingE        (Output_t) 21
#define OpenChannelRejBAwaitingE        (Output_t) 22
#define ReleaseReqBOutAwaitingE         (Output_t) 23
#define T103ExpiryBAwaitingE            (Output_t) 24
#define ReleaseReqBEstablished          (Output_t) 25
#define OpenChannelRejBEstablished      (Output_t) 26
#define CloseChannelAckBEstablished     (Output_t) 27
#define CloseChannelAckAwaitingR        (Output_t) 28
#define OpenChannelRejBAwaitingR        (Output_t) 29
#define T103ExpiryBAwaitingR            (Output_t) 30
#define EstablishReqAwaitingR           (Output_t) 31

// In-coming Open Bi-directional Logical Channel (BLCSE_IN) state functions
#define OpenChannelBReleased            (Output_t) 32
#define CloseChannelBReleased           (Output_t) 33
#define EstablishResBAwaitingE          (Output_t) 34
#define ReleaseReqBInAwaitingE          (Output_t) 35
#define CloseChannelBAwaitingE          (Output_t) 36
#define OpenChannelBAwaitingE           (Output_t) 37
#define OpenChannelConfirmBAwaitingE    (Output_t) 38
#define T103ExpiryBAwaitingC            (Output_t) 39
#define OpenChannelConfirmBAwaitingC    (Output_t) 40
#define CloseChannelBAwaitingC          (Output_t) 41
#define OpenChannelBAwaitingC           (Output_t) 42
#define CloseChannelBEstablished        (Output_t) 43
#define OpenChannelBEstablished         (Output_t) 44

// Out-going Request Close Logical Channel (CLCSE_OUT) state functions
#define CloseRequestIdle                (Output_t) 45
#define RequestCloseAckAwaitingR        (Output_t) 46
#define RequestCloseRejAwaitingR        (Output_t) 47
#define T108ExpiryAwaitingR             (Output_t) 48

// In-coming Request Close Logical Channel (CLCSE_IN) state functions
#define RequestCloseIdle                (Output_t) 49
#define CloseResponseAwaitingR          (Output_t) 50
#define RejectRequestAwaitingR          (Output_t) 51
#define RequestCloseReleaseAwaitingR    (Output_t) 52
#define RequestCloseAwaitingR           (Output_t) 53

// Out-going Terminal Capability Exchange (CESE_OUT) state functions
#define RequestCapIdle                  (Output_t) 54
#define TermCapAckAwaiting              (Output_t) 55
#define TermCapRejAwaiting              (Output_t) 56
#define T101ExpiryAwaiting              (Output_t) 57

// In-coming Terminal Capability Exchange (CESE_IN) state functions
#define TermCapSetIdle                  (Output_t) 58
#define ResponseCapAwaiting             (Output_t) 59
#define RejectCapAwaiting               (Output_t) 60
#define TermCapReleaseAwaiting          (Output_t) 61
#define TermCapSetAwaiting              (Output_t) 62

// Out-going Multiplex Table (MTSE_OUT) state functions
#define MTSE0_TRANSFER_request          (Output_t) 63
#define MTSE1_TRANSFER_request          (Output_t) 64
#define MTSE1_MultiplexEntrySendAck     (Output_t) 65
#define MTSE1_MultiplexEntrySendRej     (Output_t) 66
#define MTSE1_T104Expiry                (Output_t) 67

// In-coming Multiplex Table (MTSE_IN) state functions
#define MTSE0_MultiplexEntrySend        (Output_t) 68
#define MTSE1_MultiplexEntrySend        (Output_t) 69
#define MTSE1_MultiplexEntrySendRelease (Output_t) 70
#define MTSE1_TRANSFER_response         (Output_t) 71
#define MTSE1_REJECT_request            (Output_t) 72

// Out-going Request Multiplex Entry (RMESE_OUT) state functions
#define RMESE0_SEND_request             (Output_t) 73
#define RMESE1_SEND_request             (Output_t) 74
#define RMESE1_RequestMuxEntryAck       (Output_t) 75
#define RMESE1_RequestMuxEntryRej       (Output_t) 76
#define RMESE1_T107Expiry               (Output_t) 77

// In-coming Request Multiplex Entry (RMESE_IN) state functions
#define RMESE0_RequestMuxEntry          (Output_t) 78
#define RMESE1_RequestMuxEntry          (Output_t) 79
#define RMESE1_RequestMuxEntryRelease   (Output_t) 80
#define RMESE1_SEND_response            (Output_t) 81
#define RMESE1_REJECT_request           (Output_t) 82

// Out-going Request Mode (MRSE_OUT) state functions
#define MRSE0_TRANSFER_request          (Output_t) 83
#define MRSE1_TRANSFER_request          (Output_t) 84
#define MRSE1_RequestModeAck            (Output_t) 85
#define MRSE1_RequestModeRej            (Output_t) 86
#define MRSE1_T109Expiry                (Output_t) 87

// In-coming Request Mode (MRSE_OUT) state functions
#define MRSE0_RequestMode               (Output_t) 88
#define MRSE1_RequestMode               (Output_t) 89
#define MRSE1_RequestModeRelease        (Output_t) 90
#define MRSE1_TRANSFER_response         (Output_t) 91
#define MRSE1_REJECT_request            (Output_t) 92

// Out-going Request Mode (MLSE_OUT) state functions
#define MLSE0_LOOP_request              (Output_t) 93
#define MLSE1_MaintenanceLoopAck        (Output_t) 94
#define MLSE1_MaintenanceLoopRej        (Output_t) 95
#define MLSE1_OUT_RELEASE_request       (Output_t) 96
#define MLSE1_T102Expiry                (Output_t) 97
#define MLSE2_MaintenanceLoopRej        (Output_t) 98
#define MLSE2_OUT_RELEASE_request       (Output_t) 99

// In-coming Request Mode (MLSE_IN) state functions
#define MLSE0_MaintenanceLoopRequest    (Output_t)100
#define MLSE1_MaintenanceLoopRequest    (Output_t)101
#define MLSE1_MaintenanceLoopOffCommand (Output_t)102
#define MLSE1_LOOP_response             (Output_t)103
#define MLSE1_IN_RELEASE_request        (Output_t)104
#define MLSE2_MaintenanceLoopRequest    (Output_t)105
#define MLSE2_MaintenanceLoopOffCommand (Output_t)106

// Master Slave Determination (MSDSE) state functions
#define DetRequestIdle                  (Output_t)107
#define MSDetIdle                       (Output_t)108
#define MSDetAckOutgoing                (Output_t)109
#define MSDetOutgoing                   (Output_t)110
#define MSDetRejOutgoing                (Output_t)111
#define MSDetReleaseOutgoing            (Output_t)112
#define T106ExpiryOutgoing              (Output_t)113
#define MSDetAckIncoming                (Output_t)114
#define MSDetIncoming                   (Output_t)115
#define MSDetRejIncoming                (Output_t)116
#define MSDetReleaseIncoming            (Output_t)117
#define T106ExpiryIncoming              (Output_t)118

// Round Trip Delay (RTDSE) state functions
#define RTDSE0_TRANSFER_request         (Output_t)119
#define RTDSE0_RoundTripDelayRequest    (Output_t)120
#define RTDSE1_TRANSFER_request         (Output_t)121
#define RTDSE1_RoundTripDelayRequest    (Output_t)122
#define RTDSE1_RoundTripDelayResponse   (Output_t)123
#define RTDSE1_T105Expiry               (Output_t)124

#define NUM_OUTPUTS                               125



// State definitions
typedef unsigned char State_t;



// Lookup Key definition
typedef unsigned long Key_t;



typedef enum
{
    INDETERMINATE,
    MASTER,
    SLAVE
} MS_Status_t;

typedef struct Object_tag
{
    struct Object_tag *pNext;           // Linked list pointer
    struct InstanceStruct *pInstance;   // H.245 instance structure pointer
    DWORD           dwInst;             // H.245 instance identifier
    unsigned int    uNestLevel;         // StateMachine recursive calls
    DWORD_PTR       dwTransId;          // Transaction Id from API
    DWORD_PTR       dwTimerId;          // Associated timer id
    Key_t           Key;                // Lookup key, e.g. channel number
    Entity_t        Entity;             // State Entity type, e.g. LCSE_OUT
    State_t         State;              // Current Entity state
    unsigned char   byInSequence;       // In-coming sequence number
    union
    {
        struct
        {
            unsigned short  wLoopType;
        } mlse;
        struct
        {
            unsigned int    sv_SDNUM;
            unsigned int    sv_NCOUNT;
        } msdse;
        MultiplexEntrySendRelease       mtse;
        RequestMultiplexEntryRelease    rmese;
    } u;                                // Entity-specific data
} Object_t;



/*  an instance will carry a table of object pointers     */
/*  to be allocated in fsminit by calloc.                 */
/*  Each dwInst passed from API or SRP should invoke the  */
/*  appropriate instance that contain the object table of */
/*  the protocol entities for this H.245 instance       */

typedef struct Fsm_Struct_tag
{
    Object_t *          Object_tbl[NUM_ENTITYS];// H.245 Signalling Entities
    DWORD               dwInst;                 // H.245 Instance Identifier
    MS_Status_t         sv_STATUS;              // MSDSE Status
    unsigned char       sv_TT;                  // MSDSE Terminal Type
    unsigned char       byCeseOutSequence;      // CESE_OUT sequence number
    unsigned char       byMtseOutSequence;      // MTSE_OUT sequence number
    unsigned char       byMrseOutSequence;      // MRSE_OUT sequence number
    unsigned char       byRtdseSequence;        // RTDSE sequence number
} Fsm_Struct_t;



/* FSM function prototypes */

HRESULT
PduParseOutgoing(struct InstanceStruct *pInstance, PDU_t *pPdu,
               Entity_t *pEntity, Event_t *pEvent, Key_t *pKey, int *pbCreate);

HRESULT
PduParseIncoming(struct InstanceStruct *pInstance, PDU_t *pPdu,
               Entity_t *pEntity, Event_t *pEvent, Key_t *pKey, int *pbCreate);

int
ObjectDestroy    (Object_t *pObject);

Object_t *
ObjectFind(struct InstanceStruct *pInstance, Entity_t Entity, Key_t Key);

HRESULT
StateMachine     (Object_t *pObject, PDU_t *pPdu, Event_t Event);

HRESULT
FsmTimerEvent(struct InstanceStruct *pInstance, DWORD_PTR dwTimerId, Object_t *pObject, Event_t Event);

#define FsmStartTimer(pObject,pfnCallback,uTicks) \
    {ASSERT((pObject)->dwTimerId == 0);       \
     (pObject)->dwTimerId=H245StartTimer((pObject)->pInstance,pObject,pfnCallback,uTicks);}

#define FsmStopTimer(pObject) \
    {H245StopTimer((pObject)->pInstance,(pObject)->dwTimerId); (pObject)->dwTimerId = 0;}

#endif // H245FSM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\h245deb.c ===
/******************************************************************************
 *
 *   INTEL Corporation Proprietary Information				   
 *   Copyright (c) 1994, 1995, 1996 Intel Corporation.				   
 *									   
 *   This listing is supplied under the terms of a license agreement	   
 *   with INTEL Corporation and may not be used, copied, nor disclosed	   
 *   except in accordance with the terms of that agreement.		   
 *
 *****************************************************************************/

/******************************************************************************
 *									   
 *  $Workfile:   h245deb.c  $						
 *  $Revision:   1.5  $							
 *  $Modtime:   14 Oct 1996 13:25:50  $					
 *  $Log:   S:/STURGEON/SRC/H245/SRC/VCS/h245deb.c_v  $	
 * 
 *    Rev 1.5   14 Oct 1996 14:01:32   EHOWARDX
 * Unicode changes.
 * 
 *    Rev 1.4   14 Oct 1996 12:08:08   EHOWARDX
 * Backed out Mike's changes.
 * 
 *    Rev 1.3   01 Oct 1996 11:05:54   MANDREWS
 * Removed ISR_ trace statements for operation under Windows NT.
 * 
 *    Rev 1.2   01 Jul 1996 16:13:34   EHOWARDX
 * Changed to use wvsprintf to stop bounds checker from complaining
 * about too many arguements.
 * 
 *    Rev 1.1   28 May 1996 14:25:46   EHOWARDX
 * Tel Aviv update.
 * 
 *    Rev 1.0   09 May 1996 21:06:20   EHOWARDX
 * Initial revision.
 * 
 *    Rev 1.12.1.3   09 May 1996 19:40:10   EHOWARDX
 * Changed trace to append linefeeds so trace string need not include them.
 * 
 *    Rev 1.13   29 Apr 1996 12:54:48   EHOWARDX
 * Added timestamps and instance-specific short name.
 * 
 *    Rev 1.12.1.2   25 Apr 1996 20:05:08   EHOWARDX
 * Changed mapping between H.245 trace level and ISRDBG32 trace level.
 * 
 *    Rev 1.12.1.1   15 Apr 1996 15:16:16   unknown
 * Updated.
 * 
 *    Rev 1.12.1.0   02 Apr 1996 15:34:02   EHOWARDX
 * Changed to use ISRDBG32 if not _IA_SPOX_.
 * 
 *    Rev 1.12   01 Apr 1996 08:47:30   cjutzi
 * 
 * - fixed NDEBUG build problem
 * 
 *    Rev 1.11   18 Mar 1996 14:59:00   cjutzi
 * 
 * - fixed and verified ring zero tracking.. 
 * 
 *    Rev 1.10   18 Mar 1996 13:40:32   cjutzi
 * - fixed spox trace
 * 
 *    Rev 1.9   15 Mar 1996 16:07:44   DABROWN1
 * 
 * SYS_printf format changes
 * 
 *    Rev 1.8   13 Mar 1996 14:09:08   cjutzi
 * 
 * - added ASSERT Printout to the trace when it occurs.. 
 * 
 *    Rev 1.7   13 Mar 1996 09:46:00   dabrown1
 * 
 * modified Sys__printf to SYS_printf for Ring0
 * 
 *    Rev 1.6   11 Mar 1996 14:27:46   cjutzi
 * 
 * - addes sys_printf for SPOX 
 * - removed oildebug et.al..
 * 
 *    Rev 1.5   06 Mar 1996 12:10:40   cjutzi
 * - put ifndef SPOX around check_pdu, and dump_pdu..
 * 
 *    Rev 1.4   05 Mar 1996 16:49:46   cjutzi
 * - removed check_pdu from dump_pdu
 * 
 *    Rev 1.3   29 Feb 1996 08:22:04   cjutzi
 * - added pdu check constraints.. and (start but not complete.. )
 *   pdu tracing.. (tbd when Init includes print function )
 * 
 *    Rev 1.2   21 Feb 1996 12:14:20   EHOWARDX
 * 
 * Changed TraceLevel to DWORD.
 * 
 *    Rev 1.1   15 Feb 1996 14:42:20   cjutzi
 * - fixed the inst/Trace stuff.. 
 * 
 *    Rev 1.0   13 Feb 1996 15:00:42   DABROWN1
 * Initial revision.
 * 
 *    Rev 1.4   09 Feb 1996 15:45:08   cjutzi
 * - added h245trace
 * - added h245Assert
 *  $Ident$
 *
 *****************************************************************************/
#undef UNICODE
#ifndef STRICT 
#define STRICT 
#endif 

#include "precomp.h"

#include "h245asn1.h"
#include "isrg.h"
#include "h245com.h"

DWORD TraceLevel = 9;

#ifdef _DEBUG

/*****************************************************************************
 *									      
 * TYPE:	Global System
 *									      
 * PROCEDURE: 	H245TRACE 
 *
 * DESCRIPTION:	
 *
 *		Trace function for H245
 *		
 *		INPUT:
 *			inst   - dwInst
 *			level  - qualify trace level
 *			format - printf/sprintf string format 1-N parameters
 *
 * 			Trace Level Definitions:
 * 
 *			0 - no trace on at all
 *			1 - only errors
 *			2 - PDU tracking
 *			3 - PDU and SendReceive packet tracing
 *			4 - Main API Module level tracing
 *			5 - Inter Module level tracing #1
 *			6 - Inter Module level tracing #2
 *			7 - <Undefined>
 *			8 - <Undefined>
 *			9 - <Undefined>
 *			10- and above.. free for all, you call .. i'll haul
 *
 * RETURN:								      
 *		N/A
 *									      
 *****************************************************************************/

#if !defined(NDEBUG)
void H245TRACE (DWORD dwInst, DWORD dwLevel, LPSTR pszFormat, ...)
{
   char                 szBuffer[256];

#ifdef _IA_SPOX_
   /* Use SPOX printf */
   va_list              pParams;

  if (dwLevel <= TraceLevel)
    {
      va_start( pParams, pszFormat );
      SYS_vsprintf(szBuffer, pszFormat, pParams);

      switch (dwLevel)
      {
      case 0:
        SYS_printf("[ H245-%1d: MESSAGE ] %s\n",dwInst,szBuffer); 
        break;

      case 1:
        SYS_printf("[ H245-%1d: ERROR   ] %s\n",dwInst,szBuffer); 
        break;

      default:
        SYS_printf("[ H245-%1d: MSG-%02d  ] %s\n",dwInst,dwLevel,szBuffer); 
    }
#else
   va_list              pParams;
   BYTE                 byLevel;
   static WORD          wIsrInst = 0xFFFF;
   char                 szName[] = "H.245-1";

   /* Use ISRDBG32 output */

   if (dwLevel <= TraceLevel)
   {
      switch (dwLevel)
      {
      case 0:
         byLevel = kISRNotify;
         break;

      case 1:
         byLevel = kISRCritical;
         break;

      default:
         byLevel = kISRTrace;
      } // switch

      if (wIsrInst == 0xFFFF)
      {
	      UINT        hMod;
	      ptISRModule	pMod;

	      for (hMod = 0; hMod < kMaxModules; ++hMod)
	      {
		      pMod = ISR_GetModule(hMod);
		      if (pMod)
            {
		         if (memcmp(szName, pMod->zSName, sizeof(szName)) == 0)
		         {
                  szName[6] += 1;
               }
		      }
	      }
         ISR_RegisterModule(&wIsrInst, szName, szName);
      }
      wsprintf(szBuffer, "%9d:", GetTickCount());
      va_start( pParams, pszFormat );
      wvsprintf(&szBuffer[10], pszFormat, pParams);
      ISR_HookDbgStr((UINT)dwInst, wIsrInst, byLevel, szBuffer, 0);
   }
#endif
} // H245TRACE()

#endif //  && !defined(NDEBUG)
/*****************************************************************************
 *									      
 * TYPE:	Global System
 *									      
 * PROCEDURE: 	H245Assert
 *
 * DESCRIPTION:	
 *	
 *		H245Assert that will only pop up a dialog box, does not
 *		stop system with fault.
 *
 *		FOR WINDOWS ONLY (Ring3 development) at this point
 *
 *									      
 * RETURN:								      
 *									      
 *****************************************************************************/


void H245Panic (LPSTR file, int line)
{
#if !defined(SPOX) && defined(H324)
  int i;

  char Buffer[256];

  for (
       i=strlen(file);
       ((i) && (file[i] != '\\'));
       i--);
       wsprintf(Buffer,"file:%s line:%d",&file[i],line);
  MessageBox(GetTopWindow(NULL), Buffer, "H245 PANIC", MB_OK);
#endif
  H245TRACE(0,1,"<<< PANIC >>> file:%s line:%d",file,line);
}

/*****************************************************************************
 *									      
 * TYPE:	GLOBAL
 *									      
 * PROCEDURE: 	check_pdu
 *
 * DESCRIPTION:	
 *									      
 * RETURN:								      
 *									      
 *****************************************************************************/
int check_pdu (struct InstanceStruct *pInstance, MltmdSystmCntrlMssg *p_pdu)
{
  int error = H245_ERROR_OK;
#if 0 // legacy
#ifndef SPOX

  if (pInstance->pWorld) 
    {
      error = ossCheckConstraints(pInstance->pWorld, 1,(void *) p_pdu);

      switch (error)
	{
	case 0:
	  break;
	case  14: 
	  H245TRACE(0,1,"<<PDU ERROR>> - User constraint function returned error");
	  break;
	case  15: 
	  H245TRACE(0,1,"<<PDU ERROR>> - Single value constraint violated for a signed integer");
	  break;
	case  16: 
	  H245TRACE(0,1,"<<PDU ERROR>> - Single value constraint violated for an unsigned integer");         
	  break;
	case  17: 
	  H245TRACE(0,1,"<<PDU ERROR>> - Single value constraint violated for a floating point number");     
	  break;
	case  18: 
	  H245TRACE(0,1,"<<PDU ERROR>> - Single value constraint violated for a string");                    
	  break;
	case  19: 
	  H245TRACE(0,1,"<<PDU ERROR>> - Single value constraint violated for a complex type");              
	  break;
	case  20: 
	  H245TRACE(0,1,"<<PDU ERROR>> - Value range constraint violated  for a signed integer");            
	  break;
	case  21: 
	  H245TRACE(0,1,"<<PDU ERROR>> - Value range constraint violated  for an unsigned integer");         
	  break;
	case  22: 
	  H245TRACE(0,1,"<<PDU ERROR>> - Value range constraint violated  for a floating point number");     
	  break;
	case  23: 
	  H245TRACE(0,1,"<<PDU ERROR>> - Size constraint violated for a string");                    
	  break;
	case  24: 
	  H245TRACE(0,1,"<<PDU ERROR>> - Size constraint violated for a SET OF/SEQUENCE OF");        
	  break;
	case  25: 
	  H245TRACE(0,1,"<<PDU ERROR>> - Permitted alphabet constraint violated");                           
	  break;
	case  26: 
	  H245TRACE(0,1,"<<PDU ERROR>> - Absence constraint violated");                                      
	  break;
	case  27: 
	  H245TRACE(0,1,"<<PDU ERROR>> - Presence constraint violated");                                     
	  break;
	case  28: 
	  H245TRACE(0,1,"<<PDU ERROR>> - Error in encoding an open type");                                   
	  break;
	case  29: 
	  H245TRACE(0,1,"<<PDU ERROR>> - Table constraint violated");                                        
	  break;
	case  30: 
	  H245TRACE(0,1,"<<PDU ERROR>> - Component relation constraint violated");                           
	  break;
	case  31: 
	  H245TRACE(0,1,"<<PDU ERROR>> - Value not among the ENUMERATED");                                   
	  break;
	case  36: 
	  H245TRACE(0,1,"<<PDU ERROR>> - Type constraint violated");                                         
	  break;
	case  50: 
	  H245TRACE(0,1,"<<PDU ERROR>> - Unexpected NULL pointer in input");                                 
	  break;
	default:
	  H245TRACE(0,1,"<<PDU ERROR>> - ***UNKNOWN ***");
	  break;

	} /* switch */

    } /* if */
#endif
#endif // 0
  return error;
}

#if 0
/*****************************************************************************
 *									      
 * TYPE:	GLOBAL
 *									      
 * PROCEDURE: 	dump_pdu
 *
 * DESCRIPTION:	
 *									      
 * RETURN:								      
 *									      
 *****************************************************************************/
void dump_pdu (struct InstanceStruct *pInstance, MltmdSystmCntrlMssg 	*p_pdu)
{
#ifndef SPOX
  if (pInstance->pWorld)
    {
      ossPrintPDU (pInstance->pWorld, 1, p_pdu);
    }
#endif
}
#endif // NEVER

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\h245pdu.c ===
/******************************************************************************
 *
 *  File:  h245send.c
 *
 *   INTEL Corporation Proprietary Information
 *   Copyright (c) 1994, 1995, 1996 Intel Corporation.
 *
 *   This listing is supplied under the terms of a license agreement
 *   with INTEL Corporation and may not be used, copied, nor disclosed
 *   except in accordance with the terms of that agreement.
 *
 *****************************************************************************/

/******************************************************************************
 *
 *  $Workfile:   h245asn.c  $
 *  $Revision:   1.4  $
 *  $Modtime:   17 Jan 1997 14:31:20  $
 *  $Log:   S:\sturgeon\src\h245\src\vcs\h245asn.c_v  $
 *
 *    Rev 1.2   28 May 1996 14:25:22   EHOWARDX
 * Tel Aviv update.
 *
 *    Rev 1.1   21 May 1996 13:39:28   EHOWARDX
 * Added LOGGING switch to log PDUs to the file H245.OUT.
 * Add /D "LOGGING" to project options to enable this feature.
 *
 *    Rev 1.0   09 May 1996 21:06:20   EHOWARDX
 * Initial revision.
 *
 *    Rev 1.5.1.2   09 May 1996 19:34:44   EHOWARDX
 * Redesigned locking logic.
 * Simplified link API.
 *
 *    Rev 1.5.1.0   23 Apr 1996 14:42:44   EHOWARDX
 * Added check for ASN.1 initialized.
 *
 *    Rev 1.5   13 Mar 1996 11:33:06   DABROWN1
 * Enable logging for ring0
 *
 *    Rev 1.4   07 Mar 1996 23:20:14   dabrown1
 *
 * Modifications required for ring0/ring3 compatiblity
 *
 *    Rev 1.3   06 Mar 1996 13:13:52   DABROWN1
 *
 * added #define _DLL for SPOX build
 *
 *    Rev 1.2   23 Feb 1996 13:54:42   DABROWN1
 *
 * added tracing functions
 *
 *    Rev 1.1   21 Feb 1996 16:52:08   DABROWN1
 *
 * Removed call to h245_asn1free, now uses generic MemFree
 *
 *    Rev 1.0   09 Feb 1996 17:35:20   cjutzi
 * Initial revision.
 *
 *****************************************************************************/

#ifndef STRICT
#define STRICT
#endif

/***********************/
/*   SYSTEM INCLUDES   */
/***********************/
#include <stdlib.h>
#include <stddef.h>
#include <limits.h>

#include "precomp.h"

/***********************/
/*    H245 INCLUDES    */
/***********************/
#ifdef  _IA_SPOX_
# define _DLL
#endif //_IA_SPOX_

#include "h245asn1.h"
#include "h245sys.x"
#include "sendrcv.x"
#include "h245com.h"

/***********************/
/*    ASN1 INCLUDES    */
/***********************/

/***********************/
/*     S/R GLOBALS     */
/***********************/
#ifdef  _IA_SPOX_
# define MAKELONG(a, b)      ((LONG)(((WORD)(a)) | ((DWORD)((WORD)(b))) << 16))
# define HWND    void*
# undef _DLL
#endif //_IA_SPOX



#define ASN1_FLAGS   0

int initializeASN1(ASN1_CODER_INFO *pWorld)
{
    int         nResult;

    nResult = H245_InitWorld(pWorld);

    return (MAKELONG(nResult, 0));
}

int terminateASN1(ASN1_CODER_INFO *pWorld)
{
    H245_TermWorld(pWorld);

    H245TRACE(0, 10, "Unloading ASN.1 libraries", 0);

    return 0;
}


// THE FOLLOWING IS ADDED FOR TELES ASN.1 INTEGRATION

int H245_InitModule(void)
{
    H245ASN_Module_Startup();
    return (H245ASN_Module != NULL) ? ASN1_SUCCESS : ASN1_ERR_MEMORY;
}

int H245_TermModule(void)
{
    H245ASN_Module_Cleanup();
    return ASN1_SUCCESS;
}

int H245_InitWorld(ASN1_CODER_INFO *pWorld)
{
    int rc;

    ZeroMemory(pWorld, sizeof(*pWorld));

    if (H245ASN_Module == NULL)
    {
        return ASN1_ERR_BADARGS;
    }

    rc = ASN1_CreateEncoder(
                H245ASN_Module,         // ptr to mdule
                &(pWorld->pEncInfo),    // ptr to encoder info
                NULL,                   // buffer ptr
                0,                      // buffer size
                NULL);                  // parent ptr
    if (rc == ASN1_SUCCESS)
    {
        ASSERT(pWorld->pEncInfo != NULL);
        rc = ASN1_CreateDecoder(
                H245ASN_Module,         // ptr to mdule
                &(pWorld->pDecInfo),    // ptr to decoder info
                NULL,                   // buffer ptr
                0,                      // buffer size
                NULL);                  // parent ptr
        ASSERT(pWorld->pDecInfo != NULL);
    }

    if (rc != ASN1_SUCCESS)
    {
        H245_TermWorld(pWorld);
    }

    return rc;
}

int H245_TermWorld(ASN1_CODER_INFO *pWorld)
{
    if (H245ASN_Module == NULL)
    {
        return ASN1_ERR_BADARGS;
    }

    ASN1_CloseEncoder(pWorld->pEncInfo);
    ASN1_CloseDecoder(pWorld->pDecInfo);

    ZeroMemory(pWorld, sizeof(*pWorld));

    return ASN1_SUCCESS;
}

int H245_Encode(ASN1_CODER_INFO *pWorld, void *pStruct, int nPDU, ASN1_BUF *pBuf)
{
	int rc;
    ASN1encoding_t pEncInfo = pWorld->pEncInfo;
    BOOL fBufferSupplied = (pBuf->value != NULL) && (pBuf->length != 0);
    DWORD dwFlags = fBufferSupplied ? ASN1ENCODE_SETBUFFER : ASN1ENCODE_ALLOCATEBUFFER;

	// clean up out parameters
    if (! fBufferSupplied)
    {
        pBuf->length = 0;
        pBuf->value = NULL;
    }

    rc = ASN1_Encode(
                    pEncInfo,                   // ptr to encoder info
                    pStruct,                    // pdu data structure
                    nPDU,                       // pdu id
                    dwFlags,                    // flags
                    pBuf->value,                //  buffer
                    pBuf->length);              // buffer size if provided
    if (ASN1_SUCCEEDED(rc))
    {
        if (fBufferSupplied)
        {
            ASSERT(pBuf->value == pEncInfo->buf);
            ASSERT(pBuf->length >= pEncInfo->len);
        }
        else
        {
            pBuf->value = pEncInfo->buf;             // buffer to encode into
        }
        pBuf->length = pEncInfo->len;        // len of encoded data in buffer
    }
    else
    {
        ASSERT(FALSE);
    }
    return rc;
}

int H245_Decode(ASN1_CODER_INFO *pWorld, void **ppStruct, int nPDU, ASN1_BUF *pBuf)
{
    ASN1decoding_t pDecInfo = pWorld->pDecInfo;
    BYTE *pEncoded = pBuf->value;
    ULONG cbEncodedSize = pBuf->length;

    int rc = ASN1_Decode(
                    pDecInfo,                   // ptr to encoder info
                    ppStruct,                   // pdu data structure
                    nPDU,                       // pdu id
                    ASN1DECODE_SETBUFFER,       // flags
                    pEncoded,                   // do not provide buffer
                    cbEncodedSize);             // buffer size if provided
    if (ASN1_SUCCEEDED(rc))
    {
        ASSERT(pDecInfo->pos > pDecInfo->buf);
        pBuf->length -= (ULONG)(pDecInfo->pos - pDecInfo->buf);
        pBuf->value = pDecInfo->pos;
    }
    else
    {
        ASSERT(FALSE);
        *ppStruct = NULL;
    }
    return rc;
}




=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\h245plog.h ===
/***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************/

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
// AUTHOR       Stacy Bell
//
// DESCRIPTION
//              This file contains protocol logging definitions needed by H245 and
//              the H245 PDU logging class.
//
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

// This define identifies the H245 protocol as the one to be logged.  In the 
// H245 code, it is used only in the InteropLoad() call.  
// For example:  H245Logger = InteropLoad( H245LOG_PROTOCOL );
//
#define H245LOG_PROTOCOL "H245_PDU"

// PDU encoding type flags and PDU type flags.  These flags are passed from
// H245 to the logging via user data.  Bit 1 represents whether the PDU
// was sent or received.
//

#define H245LOG_SENT_PDU                1UL
#define H245LOG_RECEIVED_PDU            0UL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\h245man.c ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/CALLCONT/VCS/h245man.c_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1994 Intel Corporation.
 *
 *	$Revision:   1.225  $
 *	$Date:   03 Mar 1997 09:08:10  $
 *	$Author:   MANDREWS  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *		
 *
 *	Notes:
 *
 ***************************************************************************/

#include "precomp.h"

#include "apierror.h"
#include "incommon.h"
#include "callcont.h"
#include "q931.h"
#include "ccmain.h"
#include "listman.h"
#include "q931man.h"
#include "userman.h"
#include "callman.h"
#include "confman.h"
#include "h245man.h"
#include "chanman.h"
#include "hangman.h"
#include "ccutils.h"
#include "linkapi.h"
#include "h245com.h"

extern CALL_CONTROL_STATE	CallControlState;
extern THREADCOUNT			ThreadCount;

static BOOL		bH245ManagerInited = FALSE;

static struct {
	DWORD				dwPhysicalID;
	LOCK				Lock;
} PhysicalID;



HRESULT InitH245Manager()
{
	ASSERT(bH245ManagerInited == FALSE);

	// Note -- don't use a physical ID of 0; the physical ID gets mapped
	// to an H245 instance of the same value, and an H245 instance of
	// 0 is invalid
	PhysicalID.dwPhysicalID = 1;
	InitializeLock(&PhysicalID.Lock);
	bH245ManagerInited = H245SysInit();
	return CC_OK;
}



HRESULT DeInitH245Manager()
{
	if (bH245ManagerInited == FALSE)
		return CC_OK;

    H245SysDeInit();
    H245WSShutdown();
	DeleteLock(&PhysicalID.Lock);
	bH245ManagerInited = FALSE;
	return CC_OK;
}



HRESULT MakeH245PhysicalID(			DWORD					*pdwH245PhysicalID)
{
	AcquireLock(&PhysicalID.Lock);
	*pdwH245PhysicalID = PhysicalID.dwPhysicalID++;
	RelinquishLock(&PhysicalID.Lock);
	return CC_OK;
}



HRESULT _ConstructTermCapList(		PCC_TERMCAPLIST			*ppTermCapList,
									PCC_TERMCAP				*ppH2250MuxCap,
									PCC_TERMCAPDESCRIPTORS	*ppTermCapDescriptors,
									PCALL					pCall)
{
#define MAX_TERM_CAPS		257
#define MAX_TERM_CAP_DESC	255
H245_TOTCAP_T *				pTermCapArray[MAX_TERM_CAPS];
H245_TOTCAPDESC_T *			pTermCapDescriptorArray[MAX_TERM_CAP_DESC];
unsigned long				CapArrayLength;
unsigned long				CapDescriptorArrayLength;
unsigned long				i, j;
HRESULT						status;

	ASSERT(ppTermCapList != NULL);
	ASSERT(*ppTermCapList == NULL);
	ASSERT(ppH2250MuxCap != NULL);
	ASSERT(*ppH2250MuxCap == NULL);
	ASSERT(ppTermCapDescriptors != NULL);
	ASSERT(*ppTermCapDescriptors == NULL);
	ASSERT(pCall != NULL);

	CapArrayLength = MAX_TERM_CAPS;
	CapDescriptorArrayLength = MAX_TERM_CAP_DESC;

	status = H245GetCaps(pCall->H245Instance,
		                 H245_CAPDIR_RMTRXTX,
					     H245_DATA_DONTCARE,
					     H245_CLIENT_DONTCARE,
					     pTermCapArray,
					     &CapArrayLength,
					     pTermCapDescriptorArray,
					     &CapDescriptorArrayLength);
	if (status != H245_ERROR_OK) {
		*ppTermCapList = NULL;
		*ppH2250MuxCap = NULL;
		*ppTermCapDescriptors = NULL;
		return status;
	}

	// Check the term cap list to see if an H.225.0 mux capability is present;
	// this capability is treated as a special case
	*ppH2250MuxCap = NULL;
	for (i = 0; i < CapArrayLength; i++) {
		ASSERT(pTermCapArray[i] != NULL);
		if (pTermCapArray[i]->CapId == 0) {
			*ppH2250MuxCap = pTermCapArray[i];
			--CapArrayLength;
			for (j = i; j < CapArrayLength; j++)
				pTermCapArray[j] = pTermCapArray[j+1];
			break;
		}
	}

	if (CapArrayLength == 0)
		*ppTermCapList = NULL;
	else {
		*ppTermCapList = (PCC_TERMCAPLIST)MemAlloc(sizeof(CC_TERMCAPLIST));
		if (*ppTermCapList == NULL) {
			for (i = 0; i < CapArrayLength; i++)
				H245FreeCap(pTermCapArray[i]);
			if (*ppH2250MuxCap != NULL)
				H245FreeCap(*ppH2250MuxCap);
			for (i = 0; i < CapDescriptorArrayLength; i++)
				H245FreeCapDescriptor(pTermCapDescriptorArray[i]);
			return CC_NO_MEMORY;
		}

		(*ppTermCapList)->wLength = (WORD)CapArrayLength;
		(*ppTermCapList)->pTermCapArray =
			(H245_TOTCAP_T **)MemAlloc(sizeof(H245_TOTCAP_T *) * CapArrayLength);
		if ((*ppTermCapList)->pTermCapArray == NULL) {
			MemFree(*ppTermCapList);
			for (i = 0; i < CapArrayLength; i++)
				H245FreeCap(pTermCapArray[i]);
			if (*ppH2250MuxCap != NULL)
				H245FreeCap(*ppH2250MuxCap);
			for (i = 0; i < CapDescriptorArrayLength; i++)
				H245FreeCapDescriptor(pTermCapDescriptorArray[i]);
			*ppTermCapList = NULL;
			*ppH2250MuxCap = NULL;
			*ppTermCapDescriptors = NULL;
			return CC_NO_MEMORY;
		}

		for (i = 0; i < CapArrayLength; i++)
			(*ppTermCapList)->pTermCapArray[i] = pTermCapArray[i];
	}

	if (CapDescriptorArrayLength == 0)
		*ppTermCapDescriptors = NULL;
	else {
		*ppTermCapDescriptors = (PCC_TERMCAPDESCRIPTORS)MemAlloc(sizeof(CC_TERMCAPDESCRIPTORS));
		if (*ppTermCapDescriptors == NULL) {
			for (i = 0; i < CapArrayLength; i++)
				H245FreeCap(pTermCapArray[i]);
			if (*ppH2250MuxCap != NULL)
				H245FreeCap(*ppH2250MuxCap);
			for (i = 0; i < CapDescriptorArrayLength; i++)
				H245FreeCapDescriptor(pTermCapDescriptorArray[i]);
			if (*ppTermCapList != NULL) {
				MemFree((*ppTermCapList)->pTermCapArray);
				MemFree(*ppTermCapList);
			}
			*ppTermCapList = NULL;
			*ppH2250MuxCap = NULL;
			*ppTermCapDescriptors = NULL;
			return CC_NO_MEMORY;
		}

		(*ppTermCapDescriptors)->wLength = (WORD)CapDescriptorArrayLength;
		(*ppTermCapDescriptors)->pTermCapDescriptorArray =
			(H245_TOTCAPDESC_T **)MemAlloc(sizeof(H245_TOTCAPDESC_T *) * CapDescriptorArrayLength);
		if ((*ppTermCapDescriptors)->pTermCapDescriptorArray == NULL) {
			for (i = 0; i < CapArrayLength; i++)
				H245FreeCap(pTermCapArray[i]);
			if (*ppH2250MuxCap != NULL)
				H245FreeCap(*ppH2250MuxCap);
			for (i = 0; i < CapDescriptorArrayLength; i++)
				H245FreeCapDescriptor(pTermCapDescriptorArray[i]);
			if (*ppTermCapList != NULL) {
				MemFree((*ppTermCapList)->pTermCapArray);
				MemFree(*ppTermCapList);
			}
			MemFree(*ppTermCapDescriptors);
			*ppTermCapList = NULL;
			*ppH2250MuxCap = NULL;
			*ppTermCapDescriptors = NULL;
			return CC_NO_MEMORY;
		}

		for (i = 0; i < CapDescriptorArrayLength; i++)
			(*ppTermCapDescriptors)->pTermCapDescriptorArray[i] = pTermCapDescriptorArray[i];
	}
	return CC_OK;
}



HRESULT _ProcessConnectionComplete(	PCONFERENCE				pConference,
									PCALL					pCall)
{
CC_HCONFERENCE						hConference;
CC_HCALL							hCall;
HQ931CALL							hQ931Call;
HQ931CALL							hQ931CallInvitor;
HRESULT								status;
CC_CONNECT_CALLBACK_PARAMS			ConnectCallbackParams;
CC_MULTIPOINT_CALLBACK_PARAMS		MultipointCallbackParams;
CC_PEER_CHANGE_CAP_CALLBACK_PARAMS	PeerChangeCapCallbackParams;
CC_PEER_ADD_CALLBACK_PARAMS			PeerAddCallbackParams;
WORD								i;
BOOL								bMultipointConference;
H245_TRANSPORT_ADDRESS_T			Q931Address;
PDU_T								*pPdu = NULL;   // Too big to be local variable (70K)
CALLTYPE							CallType;
WORD								wNumCalls;
PCC_HCALL							CallList;
WORD								wNumChannels;
PCC_HCHANNEL						ChannelList;
PCHANNEL							pChannel;
PCALL								pOldCall;
CC_HCALL							hOldCall;
BYTE								bNewTerminalNumber;
BYTE								bNewMCUNumber;
CC_ENDPOINTTYPE						DestinationEndpointType;
H245_COMM_MODE_ENTRY_T				*pH245CommunicationTable;
BYTE								bCommunicationTableCount;
BOOL								bSessionTableChanged;
CONFMODE							PreviousConferenceMode;
CC_ADDR								MCAddress;
BOOL								bConferenceTermCapsChanged;
H245_INST_T							H245Instance;
PCC_TERMCAP							pTxTermCap;
PCC_TERMCAP							pRxTermCap;
H245_MUX_T							*pTxMuxTable;
H245_MUX_T							*pRxMuxTable;

    ASSERT(pConference != NULL);
	ASSERT(pCall != NULL);
	ASSERT(pCall->hConference == pConference->hConference);
	
	hConference = pConference->hConference;
	hCall = pCall->hCall;
	hQ931Call = pCall->hQ931Call;
	hQ931CallInvitor = pCall->hQ931CallInvitor;
	H245Instance = pCall->H245Instance;
	CallType = pCall->CallType;

	// Note that pConference->ConferenceMode refers to the conference mode BEFORE
	// this connection attempt completes.  If the current conference mode is
	// point-to-point, this connection (if successful) will result in a multipoint
	// conference.  We want to reflect in the CONNECT callback the connection mode
	// that would exist if the connect attempt is successful.
	if ((pConference->ConferenceMode == POINT_TO_POINT_MODE) ||
		(pConference->ConferenceMode == MULTIPOINT_MODE) ||
		(pCall->bCallerIsMC))
		bMultipointConference = TRUE;
	else
		bMultipointConference = FALSE;

	// Initialize all fields of ConnectCallbackParams now
	ConnectCallbackParams.pNonStandardData = pCall->pPeerNonStandardData;
	ConnectCallbackParams.pszPeerDisplay = pCall->pszPeerDisplay;
	ConnectCallbackParams.bRejectReason = CC_REJECT_UNDEFINED_REASON;
	ConnectCallbackParams.pTermCapList = pCall->pPeerH245TermCapList;
	ConnectCallbackParams.pH2250MuxCapability = pCall->pPeerH245H2250MuxCapability;
	ConnectCallbackParams.pTermCapDescriptors = pCall->pPeerH245TermCapDescriptors;
	ConnectCallbackParams.pLocalAddr = pCall->pQ931LocalConnectAddr;
	if (pCall->pQ931DestinationAddr == NULL)
		ConnectCallbackParams.pPeerAddr = pCall->pQ931PeerConnectAddr;
	else
		ConnectCallbackParams.pPeerAddr = pCall->pQ931DestinationAddr;
	ConnectCallbackParams.pVendorInfo = pCall->pPeerVendorInfo;
	ConnectCallbackParams.bMultipointConference = bMultipointConference;
	ConnectCallbackParams.pConferenceID = &pConference->ConferenceID;
	ConnectCallbackParams.pMCAddress = pConference->pMultipointControllerAddr;
	ConnectCallbackParams.pAlternateAddress = NULL;
	ConnectCallbackParams.dwUserToken = pCall->dwUserToken;

	status = AddEstablishedCallToConference(pCall, pConference);
	if (status != CC_OK) {
		MarkCallForDeletion(pCall);

		if (CallType == THIRD_PARTY_INTERMEDIARY)
			Q931RejectCall(hQ931CallInvitor,
						   CC_REJECT_UNDEFINED_REASON,
						   &pCall->ConferenceID,
						   NULL,	// alternate address
						   pCall->pPeerNonStandardData);

		if ((CallType == CALLER) || (CallType == THIRD_PARTY_INVITOR) ||
			((CallType == CALLEE) && (pConference->LocalEndpointAttached == NEVER_ATTACHED)))
			InvokeUserConferenceCallback(pConference,
										 CC_CONNECT_INDICATION,
										 status,
										 &ConnectCallbackParams);

		if (ValidateCallMarkedForDeletion(hCall) == CC_OK)
			FreeCall(pCall);
		H245ShutDown(H245Instance);
		Q931Hangup(hQ931Call, CC_REJECT_UNDEFINED_REASON);
		if (ValidateConference(hConference) == CC_OK)
			UnlockConference(pConference);

		return status;
	}

	if (((pConference->ConferenceMode == POINT_TO_POINT_MODE) ||
		 (pConference->ConferenceMode == MULTIPOINT_MODE)) &&
		(pConference->tsMultipointController == TS_TRUE))
		status = CreateConferenceTermCaps(pConference, &bConferenceTermCapsChanged);
	else {
		status = CC_OK;
		bConferenceTermCapsChanged = FALSE;
	}
	if (status != CC_OK) {
		MarkCallForDeletion(pCall);

		if (CallType == THIRD_PARTY_INTERMEDIARY)
			Q931RejectCall(pCall->hQ931CallInvitor,
						   CC_REJECT_UNDEFINED_REASON,
						   &pCall->ConferenceID,
						   NULL,	// alternate address
						   pCall->pPeerNonStandardData);

		if ((CallType == CALLER) || (CallType == THIRD_PARTY_INVITOR) ||
			((CallType == CALLEE) && (pConference->LocalEndpointAttached == NEVER_ATTACHED)))
			InvokeUserConferenceCallback(pConference,
										 CC_CONNECT_INDICATION,
										 status,
										 &ConnectCallbackParams);

		if (ValidateCallMarkedForDeletion(hCall) == CC_OK)
			FreeCall(pCall);
		H245ShutDown(H245Instance);
		Q931Hangup(hQ931Call, CC_REJECT_UNDEFINED_REASON);
		if (ValidateConference(hConference) == CC_OK)
			UnlockConference(pConference);

		return status;
	}

	if (pConference->tsMultipointController == TS_TRUE) {
		// Send MCLocationIndication
		status = GetLastListenAddress(&MCAddress);
		if (status == CC_OK) {
			ASSERT(MCAddress.nAddrType == CC_IP_BINARY);
			Q931Address.type = H245_IP_UNICAST;
			Q931Address.u.ip.tsapIdentifier =
				MCAddress.Addr.IP_Binary.wPort;
			HostToH245IPNetwork(Q931Address.u.ip.network,
							    MCAddress.Addr.IP_Binary.dwAddr);
			H245MCLocationIndication(pCall->H245Instance,
									 &Q931Address);
		}
	}

	EnumerateCallsInConference(&wNumCalls, &CallList, pConference, ESTABLISHED_CALL);

	if (pConference->ConferenceMode == UNCONNECTED_MODE) {
		ASSERT(pConference->pSessionTable == NULL);
		ASSERT(wNumCalls == 1);

		pConference->ConferenceMode = POINT_TO_POINT_MODE;
	} else { // we're currently in point-to-point mode or multipoint mode

		if (pConference->tsMultipointController == TS_TRUE) {
			PreviousConferenceMode = pConference->ConferenceMode;
			pConference->ConferenceMode = MULTIPOINT_MODE;

			// In the future, we may want to construct a new session table
			// each time a new peer is added to the conference
			if (PreviousConferenceMode == POINT_TO_POINT_MODE) {
				// Assign a terminal label to ourselves
				// Note that we reserve a terminal number of 0 for ourselves
				// if we're the MC
				ASSERT(pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bTerminalNumber == 255);
				pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bTerminalNumber = 0;

				// Create a new session table
				CreateConferenceSessionTable(
							pConference,
							&bSessionTableChanged);
			} else
				// For the current implementation, don't cause a new
				// CommunicationModeCommand to be issued when a new peer is added
				// unless we're switching from point-to-point to multipoint mode
				// (in which case bSessionTableChanged is ignored)
				bSessionTableChanged = FALSE;

			if (bSessionTableChanged)
				SessionTableToH245CommunicationTable(pConference->pSessionTable,
													 &pH245CommunicationTable,
													 &bCommunicationTableCount);
			else
				pH245CommunicationTable = NULL;

			// Send MultipointModeCommand to new call
			pPdu = (PDU_T *)MemAlloc(sizeof(PDU_T));
			if(NULL != pPdu)
			{
    			pPdu->choice = MSCMg_cmmnd_chosen;
    			pPdu->u.MSCMg_cmmnd.choice = miscellaneousCommand_chosen;
    			// logical channel number is irrelavent but needs to be filled in
    			pPdu->u.MSCMg_cmmnd.u.miscellaneousCommand.logicalChannelNumber = 1;
    			pPdu->u.MSCMg_cmmnd.u.miscellaneousCommand.type.choice = multipointModeCommand_chosen;
    			H245SendPDU(pCall->H245Instance, pPdu);
    			
    			MemFree(pPdu);
    			pPdu = NULL;
			}
			
			status = AllocatePeerParticipantInfo(pConference, &pCall->pPeerParticipantInfo);
			if (status == CC_OK) {
				bNewMCUNumber = pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel.bMCUNumber;
				bNewTerminalNumber = pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel.bTerminalNumber;
				// Send TerminalNumberAssign to new call
				H245ConferenceIndication(pCall->H245Instance,
										 H245_IND_TERMINAL_NUMBER_ASSIGN,// Indication Type
										 0,							// SBE number; ignored here
										 pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel.bMCUNumber,			// MCU number
										 pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel.bTerminalNumber);		// terminal number
				
				// Send EnterH243TerminalID to new call
				H245ConferenceRequest(pCall->H245Instance,
									  H245_REQ_ENTER_H243_TERMINAL_ID,
									  pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel.bMCUNumber,
									  pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel.bTerminalNumber);
				pCall->pPeerParticipantInfo->TerminalIDState = TERMINAL_ID_REQUESTED;
			} else {
				// Unable to assign a terminal number to the new call
				bNewMCUNumber = 0;
				bNewTerminalNumber = 0;
			}

			if (pH245CommunicationTable != NULL) {
				// Send CommunicationModeCommand to new call
				status = H245CommunicationModeCommand(pCall->H245Instance,
													  pH245CommunicationTable,
													  bCommunicationTableCount);
			}

			if (PreviousConferenceMode == POINT_TO_POINT_MODE) {
				// Generate MULTIPOINT callback
				MultipointCallbackParams.pTerminalInfo = &pConference->LocalParticipantInfo.ParticipantInfo;
				MultipointCallbackParams.pSessionTable = pConference->pSessionTable;
				InvokeUserConferenceCallback(pConference,
											 CC_MULTIPOINT_INDICATION,
											 CC_OK,
											 &MultipointCallbackParams);
				if (ValidateConference(hConference) != CC_OK) {
					if (ValidateCall(hCall) == CC_OK) {
						pCall->CallState = CALL_COMPLETE;
						UnlockCall(pCall);
					}
					MemFree(CallList);
					return CC_OK;
				}

				// Generate CC_PEER_CHANGE_CAP callback
				PeerChangeCapCallbackParams.pTermCapList =
					pConference->pConferenceTermCapList;
				PeerChangeCapCallbackParams.pH2250MuxCapability =
					pConference->pConferenceH245H2250MuxCapability;
				PeerChangeCapCallbackParams.pTermCapDescriptors =
					pConference->pConferenceTermCapDescriptors;
				InvokeUserConferenceCallback(pConference,
											 CC_PEER_CHANGE_CAP_INDICATION,
											 CC_OK,
											 &PeerChangeCapCallbackParams);
				if (ValidateConference(hConference) != CC_OK) {
					if (ValidateCall(hCall) == CC_OK) {
						pCall->CallState = CALL_COMPLETE;
						UnlockCall(pCall);
					}
					MemFree(CallList);
					return CC_OK;
				}

				ASSERT(wNumCalls == 2); // one existing call and new call
				if (CallList[0] == hCall)
					hOldCall = CallList[1];
				else
					hOldCall = CallList[0];

				if (LockCall(hOldCall, &pOldCall) == CC_OK) {
					// Send MultipointModeCommand to old call
        			pPdu = (PDU_T *)MemAlloc(sizeof(PDU_T));
        			if(NULL != pPdu)
        			{
    					pPdu->choice = MSCMg_cmmnd_chosen;
    					pPdu->u.MSCMg_cmmnd.choice = miscellaneousCommand_chosen;
    					// logical channel number is irrelavent but needs to be filled in
    					pPdu->u.MSCMg_cmmnd.u.miscellaneousCommand.logicalChannelNumber = 1;
    					pPdu->u.MSCMg_cmmnd.u.miscellaneousCommand.type.choice = multipointModeCommand_chosen;
    					H245SendPDU(pOldCall->H245Instance, pPdu);
    					
    					MemFree(pPdu);
    					pPdu = NULL;
        			}

					status = AllocatePeerParticipantInfo(pConference,
														 &pOldCall->pPeerParticipantInfo);
					if (status == CC_OK) {
						// Send TerminalNumberAssign to old call
						H245ConferenceIndication(pOldCall->H245Instance,
												 H245_IND_TERMINAL_NUMBER_ASSIGN,// Indication Type
												 0,							// SBE number; ignored here
												 pOldCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel.bMCUNumber,				// MCU number
												 pOldCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel.bTerminalNumber);	// terminal number
						
						// Send EnterH243TerminalID to old call
						H245ConferenceRequest(pOldCall->H245Instance,
											  H245_REQ_ENTER_H243_TERMINAL_ID,
											  pOldCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel.bMCUNumber,
											  pOldCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel.bTerminalNumber);
						pOldCall->pPeerParticipantInfo->TerminalIDState = TERMINAL_ID_REQUESTED;
					}

					if (pH245CommunicationTable != NULL) {
						// Send CommunicationModeCommand to old call
						status = H245CommunicationModeCommand(pOldCall->H245Instance,
															  pH245CommunicationTable,
															  bCommunicationTableCount);
	
						FreeH245CommunicationTable(pH245CommunicationTable,
												   bCommunicationTableCount);
					}

					// Send TerminalJoinedConference (this call) to old call
					H245ConferenceIndication(pOldCall->H245Instance,
											 H245_IND_TERMINAL_JOINED,	// Indication Type
											 0,							// SBE number; ignored here
											 pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bMCUNumber,			// MCU number
											 pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bTerminalNumber);	// terminal number					// terminal number of MC

					if (bNewTerminalNumber != 0) {
						// Send TerminalJoinedConference (new call) to old call
						H245ConferenceIndication(pOldCall->H245Instance,
												 H245_IND_TERMINAL_JOINED,	// Indication Type
												 0,							// SBE number; ignored here
												 bNewMCUNumber,				// MCU number
												 bNewTerminalNumber);		// terminal number

						// Generate PEER_ADD callback for old call
						PeerAddCallbackParams.hCall = pOldCall->hCall;
						PeerAddCallbackParams.TerminalLabel =
							pOldCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel;
						PeerAddCallbackParams.pPeerTerminalID = NULL;
						InvokeUserConferenceCallback(pConference,
											 CC_PEER_ADD_INDICATION,
											 CC_OK,
											 &PeerAddCallbackParams);
						if (ValidateConference(hConference) != CC_OK) {
							if (ValidateCall(hOldCall) == CC_OK)
								UnlockCall(pCall);
							if (ValidateCall(hCall) == CC_OK) {
								pCall->CallState = CALL_COMPLETE;
								UnlockCall(pCall);
							}
							MemFree(CallList);
							return CC_OK;
						}
					}

					// Send new term caps to old call
					SendTermCaps(pOldCall, pConference);

					UnlockCall(pOldCall);
				}
			} else { // we're currently in multipoint mode
				EnumerateChannelsInConference(&wNumChannels,
											  &ChannelList,
											  pConference,
											  TX_CHANNEL | PROXY_CHANNEL | TXRX_CHANNEL);
				for (i = 0; i < wNumChannels; i++) {
					if (LockChannel(ChannelList[i], &pChannel) == CC_OK) {
						if (pChannel->bMultipointChannel) {
							if ((pChannel->bChannelType == TX_CHANNEL) ||
								((pChannel->bChannelType == TXRX_CHANNEL) &&
								 (pChannel->bLocallyOpened == TRUE))) {
								pTxTermCap = pChannel->pTxH245TermCap;
								pTxMuxTable = pChannel->pTxMuxTable;
								pRxTermCap = pChannel->pRxH245TermCap;
								pRxMuxTable = pChannel->pRxMuxTable;
							} else {
								// Note: since this is a proxy or remotely-opened
								// bi-directional channel, RxTermCap and RxMuxTable
								// contain the channel's term cap and mux table,
								// and must be sent to other endpoints as the
								// Tx term cap and mux table;
								// TxTermCap and TxMuxTable should be NULL
								pTxTermCap = pChannel->pRxH245TermCap;
								pTxMuxTable = pChannel->pRxMuxTable;
								pRxTermCap = pChannel->pTxH245TermCap;
								pRxMuxTable = pChannel->pTxMuxTable;
							}
	
							status = H245OpenChannel(
										pCall->H245Instance,
										pChannel->hChannel,		// dwTransId
										pChannel->wLocalChannelNumber,
										pTxTermCap,				// TxMode
										pTxMuxTable,			// TxMux
										H245_INVALID_PORT_NUMBER,	// TxPort
										pRxTermCap,				// RxMode
										pRxMuxTable,			// RxMux
										pChannel->pSeparateStack);
							if ((status == CC_OK) && (pChannel->wNumOutstandingRequests != 0))
								(pChannel->wNumOutstandingRequests)++;
						}
						UnlockChannel(pChannel);
					}
				}
				MemFree(ChannelList);

				for (i = 0; i < wNumCalls; i++) {
					// Don't send a message to the endpoint that just joined the conference!
					if (CallList[i] != hCall) {
						if (LockCall(CallList[i], &pOldCall) == CC_OK) {
							if (bNewTerminalNumber != 0)
								// Send TerminalJoinedConference (new call) to old call
								H245ConferenceIndication(pOldCall->H245Instance,
														 H245_IND_TERMINAL_JOINED,	// Indication Type
														 0,							// SBE number; ignored here
														 bNewMCUNumber,				// MCU number
														 bNewTerminalNumber);		// terminal number
							// Send CommunicationModeCommand, if necessary
							if (pH245CommunicationTable != NULL)
								status = H245CommunicationModeCommand(pOldCall->H245Instance,
																	  pH245CommunicationTable,
																	  bCommunicationTableCount);
							if (bConferenceTermCapsChanged)
								// Send new term caps
								SendTermCaps(pOldCall, pConference);

							UnlockCall(pOldCall);
						}
					}
				}
				if (bConferenceTermCapsChanged) {
					// Generate CC_PEER_CHANGE_CAP callback
					PeerChangeCapCallbackParams.pTermCapList =
						pConference->pConferenceTermCapList;
					PeerChangeCapCallbackParams.pH2250MuxCapability =
						pConference->pConferenceH245H2250MuxCapability;
					PeerChangeCapCallbackParams.pTermCapDescriptors =
						pConference->pConferenceTermCapDescriptors;
					InvokeUserConferenceCallback(pConference,
												 CC_PEER_CHANGE_CAP_INDICATION,
												 CC_OK,
												 &PeerChangeCapCallbackParams);
					if (ValidateConference(hConference) != CC_OK) {
						if (ValidateCall(hCall) == CC_OK) {
							pCall->CallState = CALL_COMPLETE;
							UnlockCall(pCall);
						}
						MemFree(CallList);
						return CC_OK;
					}
				}
			}

			// Generate PEER_ADD callback
			PeerAddCallbackParams.hCall = pCall->hCall;
			PeerAddCallbackParams.TerminalLabel =
				pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel;
			PeerAddCallbackParams.pPeerTerminalID = NULL;
			InvokeUserConferenceCallback(pConference,
								 CC_PEER_ADD_INDICATION,
								 CC_OK,
								 &PeerAddCallbackParams);
			if (ValidateConference(hConference) != CC_OK) {
				if (ValidateCall(hCall) == CC_OK) {
					pCall->CallState = CALL_COMPLETE;
					UnlockCall(pCall);
					MemFree(CallList);
					return CC_OK;
				}
			}

			if (CallType == THIRD_PARTY_INTERMEDIARY) {
				DestinationEndpointType.pVendorInfo = pCall->pPeerVendorInfo;
				DestinationEndpointType.bIsTerminal = TRUE;
				DestinationEndpointType.bIsGateway = FALSE;

				status = Q931AcceptCall(pCall->hQ931CallInvitor,
										pCall->pszPeerDisplay,
										pCall->pPeerNonStandardData,
										&DestinationEndpointType,
										NULL,
										pCall->hCall);
				Q931Hangup(pCall->hQ931CallInvitor, CC_REJECT_NORMAL_CALL_CLEARING);
			}
		} // if (pConference->tsMultipointController == TS_TRUE)
	}

	MemFree(CallList);

	if (ValidateConference(hConference) == CC_OK)
		if ((CallType == CALLER) || (CallType == THIRD_PARTY_INVITOR) ||
			((CallType == CALLEE) && (pConference->LocalEndpointAttached == NEVER_ATTACHED))) {
			// This CONNECT must apply to the local endpoint
			pConference->LocalEndpointAttached = ATTACHED;
			InvokeUserConferenceCallback(pConference,
										 CC_CONNECT_INDICATION,
										 CC_OK,
										 &ConnectCallbackParams);
		}
	// Need to validate the conference and call handles; the associated
	// objects may have been deleted during user callback on this thread
	if (ValidateConference(hConference) == CC_OK)
		UnlockConference(pConference);

	if (ValidateCall(hCall) == CC_OK) {
		pCall->CallState = CALL_COMPLETE;
		UnlockCall(pCall);
	}
	return status;
}



HRESULT _IndUnimplemented(			H245_CONF_IND_T			*pH245ConfIndData)
{
	return H245_ERROR_NOSUP;
}



HRESULT _IndFlowControl(			H245_CONF_IND_T			*pH245ConfIndData)
{
HRESULT								status;
CC_HCALL							hCall;
PCALL								pCall;
PCONFERENCE							pConference;
CC_HCONFERENCE						hConference;
CC_HCHANNEL							hChannel;
PCHANNEL							pChannel;
CC_FLOW_CONTROL_CALLBACK_PARAMS		FlowControlCallbackParams;

	if (pH245ConfIndData->u.Indication.u.IndFlowControl.Scope != H245_SCOPE_CHANNEL_NUMBER)
		return H245_ERROR_NOSUP;

	hCall = pH245ConfIndData->u.Indication.dwPreserved;
	status = LockCallAndConference(hCall, &pCall, &pConference);
	if (status != CC_OK) {
		// This may be OK, if the call was cancelled while
		// call setup was in progress.
		return H245_ERROR_OK;
	}

	hConference = pCall->hConference;
	UnlockCall(pCall);

	if (FindChannelInConference(pH245ConfIndData->u.Indication.u.IndFlowControl.Channel,
								TRUE,	// local channel number
		                        TX_CHANNEL | PROXY_CHANNEL,
								CC_INVALID_HANDLE,
		                        &hChannel,
								pConference) != CC_OK) {
		UnlockConference(pConference);
		return H245_ERROR_OK;
	}

	if (LockChannel(hChannel, &pChannel) != CC_OK) {
		UnlockConference(pConference);
		return H245_ERROR_OK;
	}
	
	if (pChannel->bChannelType == TX_CHANNEL) {
		UnlockChannel(pChannel);
		FlowControlCallbackParams.hChannel = hChannel;
		FlowControlCallbackParams.dwRate =
			pH245ConfIndData->u.Indication.u.IndFlowControl.dwRestriction;
		InvokeUserConferenceCallback(pConference,
									 CC_FLOW_CONTROL_INDICATION,
									 CC_OK,
									 &FlowControlCallbackParams);
		if (ValidateConference(hConference) == CC_OK)
			UnlockConference(pConference);
	} else { // pChannel->bChannelType == PROXY_CHANNEL
		if (LockCall(pChannel->hCall, &pCall) == CC_OK) {
			H245FlowControl(pCall->H245Instance,
							pH245ConfIndData->u.Indication.u.IndFlowControl.Scope,
							pChannel->wRemoteChannelNumber,
							pH245ConfIndData->u.Indication.u.IndFlowControl.wResourceID,
							pH245ConfIndData->u.Indication.u.IndFlowControl.dwRestriction);
			UnlockCall(pCall);
		}
		UnlockChannel(pChannel);
		UnlockConference(pConference);
	}
	return H245_ERROR_OK;
}



HRESULT _IndEndSession(				H245_CONF_IND_T			*pH245ConfIndData)
{
CC_HCALL	hCall;

	hCall = pH245ConfIndData->u.Indication.dwPreserved;
	if (hCall != CC_INVALID_HANDLE)
		ProcessRemoteHangup(hCall, CC_INVALID_HANDLE, CC_REJECT_NORMAL_CALL_CLEARING);
	return H245_ERROR_OK;
}



HRESULT _IndCapability(				H245_CONF_IND_T			*pH245ConfIndData)
{
CC_HCALL							hCall;
PCALL								pCall;
HRESULT								status;
PCONFERENCE							pConference;
CC_HCONFERENCE						hConference;
CC_PEER_CHANGE_CAP_CALLBACK_PARAMS	PeerChangeCapCallbackParams;
BOOL								bConferenceTermCapsChanged;
WORD								wNumCalls;
PCC_HCALL							CallList;
PCALL								pOldCall;
WORD								i;

	// We received a TerminalCapabilitySet message from a peer

	hCall = pH245ConfIndData->u.Indication.dwPreserved;
	status = LockCallAndConference(hCall, &pCall, &pConference);
	if (status != CC_OK) {
		// This may be OK, if the call was cancelled while
		// call setup was in progress.
		return H245_ERROR_OK;
	}

	hConference = pCall->hConference;

	if ((pConference->ConferenceMode == MULTIPOINT_MODE) &&
		(pConference->tsMultipointController == TS_TRUE))
		CreateConferenceTermCaps(pConference, &bConferenceTermCapsChanged);
	else
		bConferenceTermCapsChanged = FALSE;

	pCall->bLinkEstablished = TRUE;

	pCall->IncomingTermCapState = TERMCAP_COMPLETE;

	if (pCall->CallState == TERMCAP) {
		ASSERT(pCall->pPeerH245TermCapList == NULL);
		ASSERT(pCall->pPeerH245H2250MuxCapability == NULL);
		ASSERT(pCall->pPeerH245TermCapDescriptors == NULL);
	} else {
		DestroyH245TermCapList(&pCall->pPeerH245TermCapList);
		DestroyH245TermCap(&pCall->pPeerH245H2250MuxCapability);
		DestroyH245TermCapDescriptors(&pCall->pPeerH245TermCapDescriptors);
	}

	_ConstructTermCapList(&(pCall->pPeerH245TermCapList),
			              &(pCall->pPeerH245H2250MuxCapability),
						  &(pCall->pPeerH245TermCapDescriptors),
			              pCall);

	if ((pCall->OutgoingTermCapState == TERMCAP_COMPLETE) &&
		(pCall->IncomingTermCapState == TERMCAP_COMPLETE) &&
	    (pCall->CallState == TERMCAP) &&
		(pCall->MasterSlaveState == MASTER_SLAVE_COMPLETE)) {
		// Note that _ProcessConnectionComplete() returns with pConference and pCall unlocked
		_ProcessConnectionComplete(pConference, pCall);
		return H245_ERROR_OK;
	}

	if (pCall->CallState == CALL_COMPLETE) {
		if ((pConference->ConferenceMode == MULTIPOINT_MODE) &&
			(pConference->tsMultipointController == TS_TRUE)) {
			CreateConferenceTermCaps(pConference, &bConferenceTermCapsChanged);
			if (bConferenceTermCapsChanged) {
				EnumerateCallsInConference(&wNumCalls, &CallList, pConference, ESTABLISHED_CALL);
				for (i = 0; i < wNumCalls; i++) {
					// Don't send a message to the endpoint that just joined the conference!
					if (CallList[i] != hCall) {
						if (LockCall(CallList[i], &pOldCall) == CC_OK) {
							// Send new term caps
							SendTermCaps(pOldCall, pConference);
							UnlockCall(pOldCall);
						}
					}
				}
				if (CallList != NULL)
					MemFree(CallList);

				// Generate CC_PEER_CHANGE_CAP callback
				PeerChangeCapCallbackParams.pTermCapList =
					pConference->pConferenceTermCapList;
				PeerChangeCapCallbackParams.pH2250MuxCapability =
					pConference->pConferenceH245H2250MuxCapability;
				PeerChangeCapCallbackParams.pTermCapDescriptors =
					pConference->pConferenceTermCapDescriptors;
				InvokeUserConferenceCallback(pConference,
											 CC_PEER_CHANGE_CAP_INDICATION,
											 CC_OK,
											 &PeerChangeCapCallbackParams);
			}
		} else {
			PeerChangeCapCallbackParams.pTermCapList = pCall->pPeerH245TermCapList;
			PeerChangeCapCallbackParams.pH2250MuxCapability = pCall->pPeerH245H2250MuxCapability;
			PeerChangeCapCallbackParams.pTermCapDescriptors = pCall->pPeerH245TermCapDescriptors;
			InvokeUserConferenceCallback(pConference,
										 CC_PEER_CHANGE_CAP_INDICATION,
										 CC_OK,
										 &PeerChangeCapCallbackParams);
		}
		if (ValidateConference(hConference) == CC_OK)
			UnlockConference(pConference);
		if (ValidateCall(hCall) == CC_OK)
			UnlockCall(pCall);
		return H245_ERROR_OK;
	}

	UnlockCall(pCall);
	UnlockConference(pConference);
	return H245_ERROR_OK;
}



HRESULT _IndOpenT120(				H245_CONF_IND_T			*pH245ConfIndData)
{
BOOL									bFailed;
CC_T120_CHANNEL_REQUEST_CALLBACK_PARAMS	T120ChannelRequestCallbackParams;
CC_HCALL								hCall;
PCALL									pCall;
CC_HCONFERENCE							hConference;
PCONFERENCE								pConference;
CC_HCHANNEL								hChannel;
PCHANNEL								pChannel;
CC_TERMCAP								*pRxTermCap = NULL;     // Too big to be local variable (9K)
CC_TERMCAP								*pTxTermCap = NULL;     // Too big to be local variable (9K)
H245_MUX_T								RxH245MuxTable;
H245_MUX_T								TxH245MuxTable;
CC_ADDR									T120Addr;
CC_OCTETSTRING							ExternalReference;

	hCall = pH245ConfIndData->u.Indication.dwPreserved;
	if (LockCallAndConference(hCall, &pCall, &pConference) != CC_OK) {
		// Can't cancel with H245, because we don't have the H245 instance
		return H245_ERROR_OK;
	}

	hConference = pCall->hConference;
	
	if (pH245ConfIndData->u.Indication.u.IndOpen.RxDataType != H245_DATA_DATA ||
	    pH245ConfIndData->u.Indication.u.IndOpen.RxClientType != H245_CLIENT_DAT_T120 ||
	    pH245ConfIndData->u.Indication.u.IndOpen.pRxCap == NULL ||
	    pH245ConfIndData->u.Indication.u.IndOpen.pRxCap->H245Dat_T120.application.choice != DACy_applctn_t120_chosen ||
	    pH245ConfIndData->u.Indication.u.IndOpen.pRxCap->H245Dat_T120.application.u.DACy_applctn_t120.choice != separateLANStack_chosen ||
 	    pH245ConfIndData->u.Indication.u.IndOpen.TxDataType != H245_DATA_DATA ||
	    pH245ConfIndData->u.Indication.u.IndOpen.TxClientType != H245_CLIENT_DAT_T120 ||
	    pH245ConfIndData->u.Indication.u.IndOpen.pTxCap == NULL ||
	    pH245ConfIndData->u.Indication.u.IndOpen.pTxCap->H245Dat_T120.application.choice != DACy_applctn_t120_chosen ||
	    pH245ConfIndData->u.Indication.u.IndOpen.pTxCap->H245Dat_T120.application.u.DACy_applctn_t120.choice != separateLANStack_chosen) {
		bFailed = TRUE;
    } else {
	    bFailed = FALSE;
    }

	if (pH245ConfIndData->u.Indication.u.IndOpen.pSeparateStack) {
		if ((pH245ConfIndData->u.Indication.u.IndOpen.pSeparateStack->networkAddress.choice == localAreaAddress_chosen) &&
			(pH245ConfIndData->u.Indication.u.IndOpen.pSeparateStack->networkAddress.u.localAreaAddress.choice == unicastAddress_chosen) &&
			(pH245ConfIndData->u.Indication.u.IndOpen.pSeparateStack->networkAddress.u.localAreaAddress.u.unicastAddress.choice == UnicastAddress_iPAddress_chosen)) {
			T120Addr.nAddrType = CC_IP_BINARY;
			T120Addr.bMulticast = FALSE;
			T120Addr.Addr.IP_Binary.wPort =
				pH245ConfIndData->u.Indication.u.IndOpen.pSeparateStack->networkAddress.u.localAreaAddress.u.unicastAddress.u.UnicastAddress_iPAddress.tsapIdentifier;
			H245IPNetworkToHost(&T120Addr.Addr.IP_Binary.dwAddr,
			                    pH245ConfIndData->u.Indication.u.IndOpen.pSeparateStack->networkAddress.u.localAreaAddress.u.unicastAddress.u.UnicastAddress_iPAddress.network.value);
		} else {
			bFailed = TRUE;
		}
	}

	if (bFailed) {
 		H245OpenChannelReject(pCall->H245Instance,	// H245 instance
							  pH245ConfIndData->u.Indication.u.IndOpen.RxChannel,
							  H245_REJ);			// rejection reason
		UnlockConference(pConference);
		UnlockCall(pCall);
		return H245_ERROR_OK;
	}

    // These will be freed immediatly after their use (AllocAndLockChannel)
    pRxTermCap = (CC_TERMCAP *)MemAlloc(sizeof(CC_TERMCAP));
    pTxTermCap = (CC_TERMCAP *)MemAlloc(sizeof(CC_TERMCAP));
    if((NULL == pRxTermCap) || (NULL == pTxTermCap))
    {
        MemFree(pRxTermCap);
        MemFree(pTxTermCap);

 		H245OpenChannelReject(pCall->H245Instance,	// H245 instance
							  pH245ConfIndData->u.Indication.u.IndOpen.RxChannel,
							  H245_REJ);			// rejection reason
		UnlockConference(pConference);
		UnlockCall(pCall);
		
		return H245_ERROR_NOMEM;
    }
    
	pRxTermCap->Dir = H245_CAPDIR_RMTTX;
	pRxTermCap->DataType = pH245ConfIndData->u.Indication.u.IndOpen.RxDataType;
	pRxTermCap->ClientType = pH245ConfIndData->u.Indication.u.IndOpen.RxClientType;
	pRxTermCap->CapId = 0;	// not used for channels
	pRxTermCap->Cap = *pH245ConfIndData->u.Indication.u.IndOpen.pRxCap;

	pTxTermCap->Dir = H245_CAPDIR_RMTTX;
	pTxTermCap->DataType = pH245ConfIndData->u.Indication.u.IndOpen.TxDataType;
	pTxTermCap->ClientType = pH245ConfIndData->u.Indication.u.IndOpen.TxClientType;
	pTxTermCap->CapId = 0;	// not used for channels
	pTxTermCap->Cap = *pH245ConfIndData->u.Indication.u.IndOpen.pTxCap;

	RxH245MuxTable = *pH245ConfIndData->u.Indication.u.IndOpen.pRxMux;
	if ((pCall->pPeerParticipantInfo != NULL) &&
		(pCall->pPeerParticipantInfo->TerminalIDState == TERMINAL_ID_VALID)) {
		RxH245MuxTable.u.H2250.destinationPresent = TRUE;
		RxH245MuxTable.u.H2250.destination.mcuNumber = pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel.bMCUNumber;
		RxH245MuxTable.u.H2250.destination.terminalNumber = pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel.bTerminalNumber;
	} else
		RxH245MuxTable.u.H2250.destinationPresent = FALSE;

    if(pH245ConfIndData->u.Indication.u.IndOpen.pTxMux)
    {
	    TxH245MuxTable = *pH245ConfIndData->u.Indication.u.IndOpen.pTxMux;
		TxH245MuxTable.u.H2250.destinationPresent = FALSE;
	}

    bFailed = (AllocAndLockChannel(&hChannel,
							pConference,
							hCall,
							pTxTermCap,			// Tx terminal capability
							pRxTermCap,			// Rx terminal capability
							(pH245ConfIndData->u.Indication.u.IndOpen.pTxMux)?
							    &TxH245MuxTable: NULL,	// Tx H245 mux table
							&RxH245MuxTable,	// Rx H245 mux table
							pH245ConfIndData->u.Indication.u.IndOpen.pSeparateStack, // separate stack
							0,					// user token
							TXRX_CHANNEL,		// channel type
							0,					// session ID
							0,					// associated session ID
							pH245ConfIndData->u.Indication.u.IndOpen.RxChannel,	// remote bi-dir channel number
							NULL,				// pLocalRTPAddr
							NULL,				// pLocalRTCPAddr
							NULL,				// pPeerRTPAddr
							NULL,				// pPeerRTCPAddr
							FALSE,				// locally opened
							&pChannel) != CC_OK);

    MemFree(pRxTermCap);
    pRxTermCap = NULL;
    
    MemFree(pTxTermCap);
    pTxTermCap = NULL;
    
	if(bFailed)
    {

		H245OpenChannelReject(pCall->H245Instance,	// H245 instance
							  pH245ConfIndData->u.Indication.u.IndOpen.RxChannel,
							  H245_REJ);			// rejection reason
		UnlockConference(pConference);
		UnlockCall(pCall);
		return H245_ERROR_OK;
	}

	if (AddChannelToConference(pChannel, pConference) != CC_OK) {
		H245OpenChannelReject(pCall->H245Instance,	// H245 instance
							  pH245ConfIndData->u.Indication.u.IndOpen.RxChannel,
							  H245_REJ);			// rejection reason
		UnlockConference(pConference);
		UnlockCall(pCall);
		FreeChannel(pChannel);
		return H245_ERROR_OK;
	}

	T120ChannelRequestCallbackParams.hChannel = hChannel;
	if (pH245ConfIndData->u.Indication.u.IndOpen.pSeparateStack == NULL) {
		T120ChannelRequestCallbackParams.bAssociateConference = FALSE;
		T120ChannelRequestCallbackParams.pExternalReference = NULL;
		T120ChannelRequestCallbackParams.pAddr = NULL;
	} else {
		T120ChannelRequestCallbackParams.bAssociateConference =
			pH245ConfIndData->u.Indication.u.IndOpen.pSeparateStack->associateConference;		
		if (pH245ConfIndData->u.Indication.u.IndOpen.pSeparateStack->bit_mask & externalReference_present) {
			ExternalReference.wOctetStringLength = (WORD)
				pH245ConfIndData->u.Indication.u.IndOpen.pSeparateStack->externalReference.length;
			ExternalReference.pOctetString =
				pH245ConfIndData->u.Indication.u.IndOpen.pSeparateStack->externalReference.value;
			T120ChannelRequestCallbackParams.pExternalReference = &ExternalReference;
		} else
			T120ChannelRequestCallbackParams.pExternalReference = NULL;
		T120ChannelRequestCallbackParams.pAddr = &T120Addr;
	}
	if ((pConference->ConferenceMode == MULTIPOINT_MODE) &&
		(pConference->tsMultipointController == TS_TRUE))
		T120ChannelRequestCallbackParams.bMultipointController = TRUE;
	else
		T120ChannelRequestCallbackParams.bMultipointController = FALSE;
	if (pH245ConfIndData->u.Indication.u.IndOpen.pRxMux->u.H2250.destinationPresent) {
		T120ChannelRequestCallbackParams.TerminalLabel.bMCUNumber =
			(BYTE)pH245ConfIndData->u.Indication.u.IndOpen.pRxMux->u.H2250.destination.mcuNumber;
		T120ChannelRequestCallbackParams.TerminalLabel.bTerminalNumber =
			(BYTE)pH245ConfIndData->u.Indication.u.IndOpen.pRxMux->u.H2250.destination.terminalNumber;
	} else {
		T120ChannelRequestCallbackParams.TerminalLabel.bMCUNumber = 255;
		T120ChannelRequestCallbackParams.TerminalLabel.bTerminalNumber = 255;
	}

	pChannel->wNumOutstandingRequests = 1;

	InvokeUserConferenceCallback(pConference,
		                         CC_T120_CHANNEL_REQUEST_INDICATION,
								 CC_OK,
								 &T120ChannelRequestCallbackParams);

	if (ValidateChannel(hChannel) == CC_OK)
		UnlockChannel(pChannel);
	if (ValidateCall(hCall) == CC_OK)
		UnlockCall(pCall);
	if (ValidateConference(hConference) == CC_OK)
		UnlockConference(pConference);

	return H245_ERROR_OK;
}



HRESULT _IndOpen(					H245_CONF_IND_T			*pH245ConfIndData)
{
CC_HCALL								hCall;
PCALL									pCall;
PCALL									pOldCall;
CC_HCONFERENCE							hConference;
PCONFERENCE								pConference;
WORD									wNumCalls;
PCC_HCALL								CallList;
CC_HCHANNEL								hChannel;
PCHANNEL								pChannel;
CC_TERMCAP								TermCap;
CC_ADDR									PeerRTPAddr;
CC_ADDR									PeerRTCPAddr;
CC_RX_CHANNEL_REQUEST_CALLBACK_PARAMS	RxChannelRequestCallbackParams;
BYTE									bChannelType;
WORD									i;
H245_MUX_T								H245MuxTable;
PCC_ADDR								pLocalRTPAddr;
PCC_ADDR								pLocalRTCPAddr;
PCC_ADDR								pPeerRTPAddr;
PCC_ADDR								pPeerRTCPAddr;
BOOL									bFoundSession;
HRESULT									status;

	// First check to see if this is a T.120 channel request,
	// as T.120 channels are handled differently then other channels
	if (pH245ConfIndData->u.Indication.u.IndOpen.RxClientType == H245_CLIENT_DAT_T120) {
		status = _IndOpenT120(pH245ConfIndData);
		return status;
	}

	hCall = pH245ConfIndData->u.Indication.dwPreserved;
	if (LockCallAndConference(hCall, &pCall, &pConference) != CC_OK) {
		// Can't cancel with H245, because we don't have the H245 instance
		return H245_ERROR_OK;
	}

	// Make sure that this is not a bi-directional channel
	if (pH245ConfIndData->u.Indication.u.IndOpen.pTxMux != NULL) {
		H245OpenChannelReject(pCall->H245Instance,	// H245 instance
							  pH245ConfIndData->u.Indication.u.IndOpen.RxChannel,
							  H245_REJ);			// rejection reason
		UnlockConference(pConference);
		UnlockCall(pCall);
		return H245_ERROR_OK;
	}

	hConference = pCall->hConference;
	
	TermCap.Dir = H245_CAPDIR_RMTTX;
	TermCap.DataType = pH245ConfIndData->u.Indication.u.IndOpen.RxDataType;
	TermCap.ClientType = pH245ConfIndData->u.Indication.u.IndOpen.RxClientType;
	TermCap.CapId = 0;	// not used for Rx channels
	TermCap.Cap = *pH245ConfIndData->u.Indication.u.IndOpen.pRxCap;
	
	RxChannelRequestCallbackParams.pChannelCapability = &TermCap;

	if ((pH245ConfIndData->u.Indication.u.IndOpen.pRxMux != NULL) &&
		(pH245ConfIndData->u.Indication.u.IndOpen.pRxMux->Kind == H245_H2250)) {
		RxChannelRequestCallbackParams.bSessionID =
			pH245ConfIndData->u.Indication.u.IndOpen.pRxMux->u.H2250.sessionID;
		if (pH245ConfIndData->u.Indication.u.IndOpen.pRxMux->u.H2250.associatedSessionIDPresent)
			RxChannelRequestCallbackParams.bAssociatedSessionID =
				pH245ConfIndData->u.Indication.u.IndOpen.pRxMux->u.H2250.associatedSessionID;
		else
			RxChannelRequestCallbackParams.bAssociatedSessionID = 0;
		if (pH245ConfIndData->u.Indication.u.IndOpen.pRxMux->u.H2250.silenceSuppressionPresent)
			RxChannelRequestCallbackParams.bSilenceSuppression =
				pH245ConfIndData->u.Indication.u.IndOpen.pRxMux->u.H2250.silenceSuppression;
		else
			RxChannelRequestCallbackParams.bSilenceSuppression = FALSE;
		if ((pH245ConfIndData->u.Indication.u.IndOpen.pRxMux->u.H2250.mediaChannelPresent) &&
			((pH245ConfIndData->u.Indication.u.IndOpen.pRxMux->u.H2250.mediaChannel.type == H245_IP_MULTICAST) ||
			(pH245ConfIndData->u.Indication.u.IndOpen.pRxMux->u.H2250.mediaChannel.type == H245_IP_UNICAST))) {
			RxChannelRequestCallbackParams.pPeerRTPAddr = &PeerRTPAddr;
			PeerRTPAddr.nAddrType = CC_IP_BINARY;
			if (pH245ConfIndData->u.Indication.u.IndOpen.pRxMux->u.H2250.mediaChannel.type == H245_IP_MULTICAST)
				PeerRTPAddr.bMulticast = TRUE;
			else
				PeerRTPAddr.bMulticast = FALSE;
			PeerRTPAddr.Addr.IP_Binary.wPort =
				pH245ConfIndData->u.Indication.u.IndOpen.pRxMux->u.H2250.mediaChannel.u.ip.tsapIdentifier;
			H245IPNetworkToHost(&PeerRTPAddr.Addr.IP_Binary.dwAddr,
			                    pH245ConfIndData->u.Indication.u.IndOpen.pRxMux->u.H2250.mediaChannel.u.ip.network);
		} else
			RxChannelRequestCallbackParams.pPeerRTPAddr = NULL;

		if ((pH245ConfIndData->u.Indication.u.IndOpen.pRxMux->u.H2250.mediaControlChannelPresent) &&
			((pH245ConfIndData->u.Indication.u.IndOpen.pRxMux->u.H2250.mediaControlChannel.type == H245_IP_MULTICAST) ||
			(pH245ConfIndData->u.Indication.u.IndOpen.pRxMux->u.H2250.mediaControlChannel.type == H245_IP_UNICAST))) {
			RxChannelRequestCallbackParams.pPeerRTCPAddr = &PeerRTCPAddr;
			PeerRTCPAddr.nAddrType = CC_IP_BINARY;
			if (pH245ConfIndData->u.Indication.u.IndOpen.pRxMux->u.H2250.mediaControlChannel.type == H245_IP_MULTICAST)
				PeerRTCPAddr.bMulticast = TRUE;
			else
				PeerRTCPAddr.bMulticast = FALSE;
			PeerRTCPAddr.Addr.IP_Binary.wPort =
				pH245ConfIndData->u.Indication.u.IndOpen.pRxMux->u.H2250.mediaControlChannel.u.ip.tsapIdentifier;
			H245IPNetworkToHost(&PeerRTCPAddr.Addr.IP_Binary.dwAddr,
			                    pH245ConfIndData->u.Indication.u.IndOpen.pRxMux->u.H2250.mediaControlChannel.u.ip.network);
		} else
			RxChannelRequestCallbackParams.pPeerRTCPAddr = NULL;

		if (pH245ConfIndData->u.Indication.u.IndOpen.pRxMux->u.H2250.destinationPresent) {
			RxChannelRequestCallbackParams.TerminalLabel.bMCUNumber =
				(BYTE)pH245ConfIndData->u.Indication.u.IndOpen.pRxMux->u.H2250.destination.mcuNumber;
			RxChannelRequestCallbackParams.TerminalLabel.bTerminalNumber =
				(BYTE)pH245ConfIndData->u.Indication.u.IndOpen.pRxMux->u.H2250.destination.terminalNumber;
		} else {
			RxChannelRequestCallbackParams.TerminalLabel.bMCUNumber = 255;
			RxChannelRequestCallbackParams.TerminalLabel.bTerminalNumber = 255;
		}

		if (pH245ConfIndData->u.Indication.u.IndOpen.pRxMux->u.H2250.dynamicRTPPayloadTypePresent)
			RxChannelRequestCallbackParams.bRTPPayloadType =
				pH245ConfIndData->u.Indication.u.IndOpen.pRxMux->u.H2250.dynamicRTPPayloadType;
		else
			RxChannelRequestCallbackParams.bRTPPayloadType = 0;
	} else {
		H245OpenChannelReject(pCall->H245Instance,	// H245 instance
							  pH245ConfIndData->u.Indication.u.IndOpen.RxChannel,
							  H245_REJ);			// rejection reason
		UnlockConference(pConference);
		UnlockCall(pCall);
		return H245_ERROR_OK;
	}

	// XXX -- someday we should allow dynamic sessions to be created on the MC
	if (pH245ConfIndData->u.Indication.u.IndOpen.pRxMux->u.H2250.sessionID == 0) {
		H245OpenChannelReject(pCall->H245Instance,	// H245 instance
							  pH245ConfIndData->u.Indication.u.IndOpen.RxChannel,
							  H245_REJ);			// rejection reason
		UnlockConference(pConference);
		UnlockCall(pCall);
		return H245_ERROR_OK;
	}

	if (pConference->ConferenceMode == MULTIPOINT_MODE) {
		if ((pConference->tsMultipointController == TS_TRUE) &&
			((RxChannelRequestCallbackParams.pPeerRTPAddr != NULL) ||
			 (RxChannelRequestCallbackParams.pPeerRTCPAddr != NULL)) ||
		    ((pConference->tsMultipointController == TS_FALSE) &&
			 ((RxChannelRequestCallbackParams.pPeerRTPAddr == NULL) ||
			  (RxChannelRequestCallbackParams.pPeerRTCPAddr == NULL) ||
			  (RxChannelRequestCallbackParams.bSessionID == 0)))) {
  			H245OpenChannelReject(pCall->H245Instance,	// H245 instance
								  pH245ConfIndData->u.Indication.u.IndOpen.RxChannel,
								  H245_REJ);			// rejection reason
			UnlockConference(pConference);
			UnlockCall(pCall);
			return H245_ERROR_OK;
		}

		// Validate session ID
		pLocalRTPAddr = NULL;
		pLocalRTCPAddr = NULL;
		bFoundSession = FALSE;
		if (pConference->pSessionTable != NULL) {
			for (i = 0; i < pConference->pSessionTable->wLength; i++) {
				if (pH245ConfIndData->u.Indication.u.IndOpen.pRxMux->u.H2250.sessionID ==
					pConference->pSessionTable->SessionInfoArray[i].bSessionID) {
					bFoundSession = TRUE;
					pLocalRTPAddr = pConference->pSessionTable->SessionInfoArray[i].pRTPAddr;
					pLocalRTCPAddr = pConference->pSessionTable->SessionInfoArray[i].pRTCPAddr;
					break;
				}
			}
		}
		if (bFoundSession == FALSE)	{
			H245OpenChannelReject(pCall->H245Instance,	// H245 instance
								  pH245ConfIndData->u.Indication.u.IndOpen.RxChannel,
								  H245_REJ);			// rejection reason
			UnlockConference(pConference);
			UnlockCall(pCall);
			return H245_ERROR_OK;
		}

		ASSERT(pLocalRTPAddr != NULL);
		ASSERT(pLocalRTCPAddr != NULL);

		if (pConference->tsMultipointController == TS_TRUE) {
			pPeerRTPAddr = pLocalRTPAddr;
			pPeerRTCPAddr = pLocalRTCPAddr;
			RxChannelRequestCallbackParams.pPeerRTPAddr = pLocalRTPAddr;
			RxChannelRequestCallbackParams.pPeerRTCPAddr = pLocalRTCPAddr;
			bChannelType = PROXY_CHANNEL;
		} else { // multipoint mode, not MC
			pLocalRTPAddr = RxChannelRequestCallbackParams.pPeerRTPAddr;
			pLocalRTCPAddr = RxChannelRequestCallbackParams.pPeerRTCPAddr;
			pPeerRTPAddr = RxChannelRequestCallbackParams.pPeerRTPAddr;
			pPeerRTCPAddr = RxChannelRequestCallbackParams.pPeerRTCPAddr;
			bChannelType = RX_CHANNEL;
		}
	} else { // not multipoint mode
		pLocalRTPAddr = NULL;
		pLocalRTCPAddr = NULL;
		pPeerRTPAddr = RxChannelRequestCallbackParams.pPeerRTPAddr;
		pPeerRTCPAddr = RxChannelRequestCallbackParams.pPeerRTCPAddr;
		bChannelType = RX_CHANNEL;
	}

	H245MuxTable = *pH245ConfIndData->u.Indication.u.IndOpen.pRxMux;
	if ((pCall->pPeerParticipantInfo != NULL) &&
		(pCall->pPeerParticipantInfo->TerminalIDState == TERMINAL_ID_VALID)) {
		H245MuxTable.u.H2250.destinationPresent = TRUE;
		H245MuxTable.u.H2250.destination.mcuNumber = pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel.bMCUNumber;
		H245MuxTable.u.H2250.destination.terminalNumber = pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel.bTerminalNumber;
	} else
		H245MuxTable.u.H2250.destinationPresent = FALSE;
	if (pLocalRTPAddr != NULL) {
		if (pLocalRTPAddr->bMulticast)
			H245MuxTable.u.H2250.mediaChannel.type = H245_IP_MULTICAST;
		else
			H245MuxTable.u.H2250.mediaChannel.type = H245_IP_UNICAST;
		H245MuxTable.u.H2250.mediaChannel.u.ip.tsapIdentifier =
			pLocalRTPAddr->Addr.IP_Binary.wPort;
		HostToH245IPNetwork(H245MuxTable.u.H2250.mediaChannel.u.ip.network,
							pLocalRTPAddr->Addr.IP_Binary.dwAddr);
		H245MuxTable.u.H2250.mediaChannelPresent = TRUE;
	} else
		H245MuxTable.u.H2250.mediaChannelPresent = FALSE;
	if (pLocalRTCPAddr != NULL) {
		if (pLocalRTCPAddr->bMulticast)
			H245MuxTable.u.H2250.mediaControlChannel.type = H245_IP_MULTICAST;
		else
			H245MuxTable.u.H2250.mediaControlChannel.type = H245_IP_UNICAST;
		H245MuxTable.u.H2250.mediaControlChannel.u.ip.tsapIdentifier =
			pLocalRTCPAddr->Addr.IP_Binary.wPort;
		HostToH245IPNetwork(H245MuxTable.u.H2250.mediaControlChannel.u.ip.network,
							pLocalRTCPAddr->Addr.IP_Binary.dwAddr);
		H245MuxTable.u.H2250.mediaControlChannelPresent = TRUE;
	} else
		H245MuxTable.u.H2250.mediaControlChannelPresent = FALSE;

	if (AllocAndLockChannel(&hChannel,
							pConference,
							hCall,
							NULL,				// Tx terminal capability
							&TermCap,			// Rx terminal capability
							NULL,				// Tx H245 mux table
							&H245MuxTable,		// Rx H245 mux table
							NULL,				// separate stack
							0,					// user token
							bChannelType,
							pH245ConfIndData->u.Indication.u.IndOpen.pRxMux->u.H2250.sessionID,
							RxChannelRequestCallbackParams.bAssociatedSessionID,
							pH245ConfIndData->u.Indication.u.IndOpen.RxChannel,
							pLocalRTPAddr,		// pLocalRTPAddr
							pLocalRTCPAddr,		// pLocalRTCPAddr
							pPeerRTPAddr,		// pPeerRTPAddr
							pPeerRTCPAddr,		// pPeerRTCPAddr
							FALSE,				// locally opened
							&pChannel) != CC_OK) {

		H245OpenChannelReject(pCall->H245Instance,	// H245 instance
							  pH245ConfIndData->u.Indication.u.IndOpen.RxChannel,
							  H245_REJ);			// rejection reason
		UnlockConference(pConference);
		UnlockCall(pCall);
		return H245_ERROR_OK;
	}

	if (AddChannelToConference(pChannel, pConference) != CC_OK) {
		H245OpenChannelReject(pCall->H245Instance,	// H245 instance
							  pH245ConfIndData->u.Indication.u.IndOpen.RxChannel,
							  H245_REJ);			// rejection reason
		UnlockConference(pConference);
		UnlockCall(pCall);
		FreeChannel(pChannel);
		return H245_ERROR_OK;
	}

	RxChannelRequestCallbackParams.hChannel = hChannel;
	
	if ((pConference->ConferenceMode == MULTIPOINT_MODE) &&
		(pConference->tsMultipointController == TS_TRUE)) {
		// Open this channel to each peer in the conference (except the peer
		// that requested this channel)
		EnumerateCallsInConference(&wNumCalls, &CallList, pConference, ESTABLISHED_CALL);
		for (i = 0; i < wNumCalls; i++) {
			if (CallList[i] != hCall) {
				if (LockCall(CallList[i], &pOldCall) == CC_OK) {
					ASSERT(pChannel->bChannelType == PROXY_CHANNEL);
					// Note: since this is a proxy channel, RxTermCap and RxMuxTable
					// contain the channel's term cap and mux table, and must be sent
					// to other endpoints as the Tx term cap and mux table;
					// TxTermCap and TxMuxTable should be NULL
					if (H245OpenChannel(pOldCall->H245Instance,
										pChannel->hChannel,		// dwTransId
										pChannel->wLocalChannelNumber,
										pChannel->pRxH245TermCap,	// TxMode
										pChannel->pRxMuxTable,		// TxMux
										H245_INVALID_PORT_NUMBER,	// TxPort
										pChannel->pTxH245TermCap,	// RxMode
										pChannel->pTxMuxTable,		// RxMux
										pChannel->pSeparateStack) == CC_OK)
						(pChannel->wNumOutstandingRequests)++;
					UnlockCall(pOldCall);
				}
			}
		}
		MemFree(CallList);
		if (pConference->LocalEndpointAttached == ATTACHED)
			(pChannel->wNumOutstandingRequests)++;
		if (pChannel->wNumOutstandingRequests == 0) {
			H245OpenChannelReject(pCall->H245Instance,	// H245 instance
								  pH245ConfIndData->u.Indication.u.IndOpen.RxChannel,
								  H245_REJ);			// rejection reason
			UnlockConference(pConference);
			UnlockCall(pCall);
			FreeChannel(pChannel);
			return H245_ERROR_OK;
		}
	} else
		pChannel->wNumOutstandingRequests = 1;
	
	InvokeUserConferenceCallback(pConference,
		                         CC_RX_CHANNEL_REQUEST_INDICATION,
								 CC_OK,
								 &RxChannelRequestCallbackParams);

	if (ValidateChannel(hChannel) == CC_OK)
		UnlockChannel(pChannel);
	if (ValidateCall(hCall) == CC_OK)
		UnlockCall(pCall);
	if (ValidateConference(hConference) == CC_OK)
		UnlockConference(pConference);

	return H245_ERROR_OK;
}



HRESULT _IndOpenConf(				H245_CONF_IND_T			*pH245ConfIndData)
{
CC_HCALL								hCall;
PCALL									pCall;
CC_HCONFERENCE							hConference;
PCONFERENCE								pConference;
CC_HCHANNEL								hChannel;
CC_ACCEPT_CHANNEL_CALLBACK_PARAMS	    AcceptChannelCallbackParams;

    // Bi-directional channel open initiated by remote peer is now complete.
    // Local peer may now send data over this channel.

	hCall = pH245ConfIndData->u.Indication.dwPreserved;
	if (LockCallAndConference(hCall, &pCall, &pConference) != CC_OK)
		return H245_ERROR_OK;

	hConference = pConference->hConference;
	UnlockCall(pCall);

	if (FindChannelInConference(pH245ConfIndData->u.Indication.u.IndOpenConf.TxChannel,
								FALSE,	// remote channel number
		                        TXRX_CHANNEL,
								hCall,
		                        &hChannel,
								pConference) != CC_OK) {
		UnlockConference(pConference);
		return H245_ERROR_OK;
	}

	AcceptChannelCallbackParams.hChannel = hChannel;
	
	InvokeUserConferenceCallback(pConference,
		                         CC_ACCEPT_CHANNEL_INDICATION,
								 CC_OK,
								 &AcceptChannelCallbackParams);

	if (ValidateConference(hConference) == CC_OK)
		UnlockConference(pConference);

	return H245_ERROR_OK;
}



HRESULT _IndMstslv(					H245_CONF_IND_T			*pH245ConfIndData)
{
CC_HCALL					hCall;
PCALL						pCall;
PCONFERENCE					pConference;
CC_CONNECT_CALLBACK_PARAMS	ConnectCallbackParams;
CC_HCALL					hEnqueuedCall;
PCALL						pEnqueuedCall;
CC_HCONFERENCE				hConference;
HRESULT						status;

	hCall = pH245ConfIndData->u.Indication.dwPreserved;
	if (LockCallAndConference(hCall, &pCall, &pConference) != CC_OK) {
		// Can't cancel with H245, because we don't have the H245 instance
		return H245_ERROR_OK;
	}

	ASSERT(pCall->MasterSlaveState != MASTER_SLAVE_COMPLETE);

	switch (pH245ConfIndData->u.Indication.u.IndMstSlv) {
	    case H245_MASTER:
		    pConference->tsMaster = TS_TRUE;
		    if (pConference->tsMultipointController == TS_UNKNOWN) {
			    ASSERT(pConference->bMultipointCapable == TRUE);
			    pConference->tsMultipointController = TS_TRUE;

			    // place all calls enqueued on this conference object
			    for ( ; ; ) {
				    // Start up all enqueued calls, if any exist
				    status = RemoveEnqueuedCallFromConference(pConference, &hEnqueuedCall);
				    if ((status != CC_OK) || (hEnqueuedCall == CC_INVALID_HANDLE))
					    break;

				    status = LockCall(hEnqueuedCall, &pEnqueuedCall);
				    if (status == CC_OK) {
					    pEnqueuedCall->CallState = PLACED;

					    status = PlaceCall(pEnqueuedCall, pConference);
					    UnlockCall(pEnqueuedCall);
				    }
			    }
		    }
	        break;

	    case H245_SLAVE:
		    ASSERT(pConference->tsMaster != TS_TRUE);
		    ASSERT(pConference->tsMultipointController != TS_TRUE);
		    pConference->tsMaster = TS_FALSE;
		    pConference->tsMultipointController = TS_FALSE;

		    // XXX -- we may eventually want to re-enqueue these requests
		    // and set an expiration timer
		    hConference = pConference->hConference;
				
		    for ( ; ; ) {
			    status = RemoveEnqueuedCallFromConference(pConference, &hEnqueuedCall);
			    if ((status != CC_OK) || (hEnqueuedCall == CC_INVALID_HANDLE))
				    break;

			    status = LockCall(hEnqueuedCall, &pEnqueuedCall);
			    if (status == CC_OK) {
				    MarkCallForDeletion(pEnqueuedCall);
				    ConnectCallbackParams.pNonStandardData = pEnqueuedCall->pPeerNonStandardData;
				    ConnectCallbackParams.pszPeerDisplay = pEnqueuedCall->pszPeerDisplay;
				    ConnectCallbackParams.bRejectReason = CC_REJECT_UNDEFINED_REASON;
				    ConnectCallbackParams.pTermCapList = pEnqueuedCall->pPeerH245TermCapList;
				    ConnectCallbackParams.pH2250MuxCapability = pEnqueuedCall->pPeerH245H2250MuxCapability;
				    ConnectCallbackParams.pTermCapDescriptors = pEnqueuedCall->pPeerH245TermCapDescriptors;
				    ConnectCallbackParams.pLocalAddr = pEnqueuedCall->pQ931LocalConnectAddr;
	                if (pEnqueuedCall->pQ931DestinationAddr == NULL)
		                ConnectCallbackParams.pPeerAddr = pEnqueuedCall->pQ931PeerConnectAddr;
	                else
		                ConnectCallbackParams.pPeerAddr = pEnqueuedCall->pQ931DestinationAddr;
				    ConnectCallbackParams.pVendorInfo = pEnqueuedCall->pPeerVendorInfo;
				    ConnectCallbackParams.bMultipointConference = TRUE;
				    ConnectCallbackParams.pConferenceID = &pConference->ConferenceID;
				    ConnectCallbackParams.pMCAddress = pConference->pMultipointControllerAddr;
					ConnectCallbackParams.pAlternateAddress = NULL;
				    ConnectCallbackParams.dwUserToken = pEnqueuedCall->dwUserToken;

				    InvokeUserConferenceCallback(pConference,
									    CC_CONNECT_INDICATION,
									    CC_NOT_MULTIPOINT_CAPABLE,
									    &ConnectCallbackParams);
				    if (ValidateCallMarkedForDeletion(hEnqueuedCall) == CC_OK)
					    FreeCall(pEnqueuedCall);
				    if (ValidateConference(hConference) != CC_OK) {
					    if (ValidateCall(hCall) == CC_OK)
						    UnlockCall(pCall);
					    return H245_ERROR_OK;
				    }
			    }
		    }
	        break;

	    default: // H245_INDETERMINATE
			UnlockConference(pConference);
			if (++pCall->wMasterSlaveRetry < MASTER_SLAVE_RETRY_MAX) {
				H245InitMasterSlave(pCall->H245Instance, pCall->H245Instance);
			    UnlockCall(pCall);
			} else {
			    UnlockCall(pCall);
				ProcessRemoteHangup(hCall, CC_INVALID_HANDLE, CC_REJECT_UNDEFINED_REASON);
			}
			return H245_ERROR_OK;
	} // switch

	pCall->MasterSlaveState = MASTER_SLAVE_COMPLETE;

	if ((pCall->OutgoingTermCapState == TERMCAP_COMPLETE) &&
		(pCall->IncomingTermCapState == TERMCAP_COMPLETE) &&
	    (pCall->CallState == TERMCAP) &&
		(pCall->MasterSlaveState == MASTER_SLAVE_COMPLETE)) {
		// Note that _ProcessConnectionComplete() returns with pConference and pCall unlocked
		_ProcessConnectionComplete(pConference, pCall);
		return H245_ERROR_OK;
	}
	UnlockCall(pCall);
	UnlockConference(pConference);
	return H245_ERROR_OK;
}



HRESULT _IndClose(					H245_CONF_IND_T			*pH245ConfIndData)
{
CC_HCALL							hCall;
PCALL								pCall;
CC_HCONFERENCE						hConference;
PCONFERENCE							pConference;
CC_HCHANNEL							hChannel;
PCHANNEL							pChannel;
WORD								i;
WORD								wNumCalls;
PCC_HCALL							CallList;
CC_RX_CHANNEL_CLOSE_CALLBACK_PARAMS	RxChannelCloseCallbackParams;
#ifdef    GATEKEEPER
unsigned                            uBandwidth;
#endif // GATEKEEPER

	hCall = pH245ConfIndData->u.Indication.dwPreserved;
	if (LockCallAndConference(hCall, &pCall, &pConference) != CC_OK)
		return H245_ERROR_OK;

	hConference = pCall->hConference;
	UnlockCall(pCall);

	if (FindChannelInConference(pH245ConfIndData->u.Indication.u.IndClose.Channel,
							    FALSE,	// remote channel number
		                        RX_CHANNEL | TXRX_CHANNEL | PROXY_CHANNEL,
								hCall,
		                        &hChannel,
								pConference) != CC_OK) {
		UnlockConference(pConference);
		return H245_ERROR_OK;
	}

	if (LockChannel(hChannel, &pChannel) != CC_OK)
		return H245_ERROR_OK;

	EnumerateCallsInConference(&wNumCalls, &CallList, pConference, ESTABLISHED_CALL);

#ifdef    GATEKEEPER
    if(GKIExists())
    {
    	if (pChannel->bChannelType != TXRX_CHANNEL)
    	{
    		uBandwidth = pChannel->dwChannelBitRate / 100;
    		for (i = 0; i < wNumCalls; i++)
    		{
    			if (LockCall(CallList[i], &pCall) == CC_OK)
    			{
    				if (uBandwidth && pCall->GkiCall.uBandwidthUsed >= uBandwidth)
    				{
    					if (GkiCloseChannel(&pCall->GkiCall, pChannel->dwChannelBitRate, hChannel) == CC_OK)
    					{
    						uBandwidth = 0;
    						UnlockCall(pCall);
    						break;
    					}
    				}
    				UnlockCall(pCall);
    			}
    		} // for
    	}
	}
#endif // GATEKEEPER

	if (pChannel->bChannelType == PROXY_CHANNEL) {
		ASSERT(pConference->ConferenceMode == MULTIPOINT_MODE);
		ASSERT(pConference->tsMultipointController == TS_TRUE);
		ASSERT(pChannel->bMultipointChannel == TRUE);

		for (i = 0; i < wNumCalls; i++) {
			if (CallList[i] != hCall) {
				if (LockCall(CallList[i], &pCall) == CC_OK) {
					H245CloseChannel(pCall->H245Instance,	// H245 instance
				                     0,						// dwTransId
							         pChannel->wLocalChannelNumber);
					UnlockCall(pCall);
				}
			}
		}
	}

	if (CallList != NULL)
	    MemFree(CallList);

	if (pChannel->tsAccepted == TS_TRUE) {
		RxChannelCloseCallbackParams.hChannel = hChannel;
		InvokeUserConferenceCallback(pConference,
									 CC_RX_CHANNEL_CLOSE_INDICATION,
									 CC_OK,
									 &RxChannelCloseCallbackParams);
	}

	if (ValidateChannel(hChannel) == CC_OK)
		FreeChannel(pChannel);
	if (ValidateConference(hConference) == CC_OK)
		UnlockConference(pConference);
	return H245_ERROR_OK;
}



HRESULT _IndRequestClose(			H245_CONF_IND_T			*pH245ConfIndData)
{
CC_HCALL							hCall;
PCALL								pCall;
CC_HCONFERENCE						hConference;
PCONFERENCE							pConference;
CC_HCHANNEL							hChannel;
PCHANNEL							pChannel;
CC_TX_CHANNEL_CLOSE_REQUEST_CALLBACK_PARAMS	TxChannelCloseRequestCallbackParams;

	hCall = pH245ConfIndData->u.Indication.dwPreserved;
	if (LockCallAndConference(hCall, &pCall, &pConference) != CC_OK)
		return H245_ERROR_OK;

	hConference = pCall->hConference;
	UnlockCall(pCall);

	if (FindChannelInConference(pH245ConfIndData->u.Indication.u.IndClose.Channel,
								TRUE,	// local channel number
		                        TX_CHANNEL | TXRX_CHANNEL | PROXY_CHANNEL,
								CC_INVALID_HANDLE,
		                        &hChannel,
								pConference) != CC_OK) {
		UnlockConference(pConference);
		return H245_ERROR_OK;
	}

	if (LockChannel(hChannel, &pChannel) != CC_OK) {
		UnlockConference(pConference);
		return H245_ERROR_OK;
	}
	
	if ((pChannel->bChannelType == TX_CHANNEL) ||
	    (pChannel->bChannelType == TXRX_CHANNEL)) {
		EnqueueRequest(&pChannel->pCloseRequests, hCall);
		UnlockChannel(pChannel);
		TxChannelCloseRequestCallbackParams.hChannel = hChannel;
		InvokeUserConferenceCallback(pConference,
							 CC_TX_CHANNEL_CLOSE_REQUEST_INDICATION,
							 CC_OK,
							 &TxChannelCloseRequestCallbackParams);
		if (ValidateConference(hConference) == CC_OK)
			UnlockConference(pConference);
	} else { // pChannel->bChannelType == PROXY_CHANNEL
		if (LockCall(pChannel->hCall, &pCall) == CC_OK) {
			// Note that dwTransID is set to the call handle of the peer who
			// initiated the close channel request. When the close channel response
			// is received, the dwTransID gives us back the call handle to which
			// the response must be forwarded
			H245CloseChannelReq(pCall->H245Instance,
								hCall,	// dwTransID
								pChannel->wRemoteChannelNumber);
			UnlockCall(pCall);
		}
		UnlockChannel(pChannel);
		UnlockConference(pConference);
	}
	return H245_ERROR_OK;
}


	
HRESULT _IndNonStandard(			H245_CONF_IND_T			*pH245ConfIndData)
{
CC_HCALL									hCall;
PCALL										pCall;
CC_HCONFERENCE								hConference;
PCONFERENCE									pConference;
CC_RX_NONSTANDARD_MESSAGE_CALLBACK_PARAMS	RxNonStandardMessageCallbackParams;

	// We only handle H221 non-standard messages; if pwObjectId is non-NULL,
	// ignore the message
	if (pH245ConfIndData->u.Indication.u.IndNonstandard.pwObjectId != NULL)
		return H245_ERROR_OK;

	hCall = pH245ConfIndData->u.Indication.dwPreserved;
	if (LockCallAndConference(hCall, &pCall, &pConference) != CC_OK)
		return H245_ERROR_OK;

	hConference = pCall->hConference;

	switch (pH245ConfIndData->u.Indication.Indicator) {
		case H245_IND_NONSTANDARD_REQUEST:
			RxNonStandardMessageCallbackParams.bH245MessageType = CC_H245_MESSAGE_REQUEST;
			break;
		case H245_IND_NONSTANDARD_RESPONSE:	
 			RxNonStandardMessageCallbackParams.bH245MessageType = CC_H245_MESSAGE_RESPONSE;
			break;
		case H245_IND_NONSTANDARD_COMMAND:	
 			RxNonStandardMessageCallbackParams.bH245MessageType = CC_H245_MESSAGE_COMMAND;
			break;
		case H245_IND_NONSTANDARD:	
 			RxNonStandardMessageCallbackParams.bH245MessageType = CC_H245_MESSAGE_INDICATION;
			break;
		default:
			UnlockConference(pConference);
			return H245_ERROR_NOSUP;
	}

	RxNonStandardMessageCallbackParams.NonStandardData.sData.pOctetString =
		pH245ConfIndData->u.Indication.u.IndNonstandard.pData;
	RxNonStandardMessageCallbackParams.NonStandardData.sData.wOctetStringLength =
		(WORD)pH245ConfIndData->u.Indication.u.IndNonstandard.dwDataLength;
	RxNonStandardMessageCallbackParams.NonStandardData.bCountryCode =
		pH245ConfIndData->u.Indication.u.IndNonstandard.byCountryCode;	
	RxNonStandardMessageCallbackParams.NonStandardData.bExtension =
		pH245ConfIndData->u.Indication.u.IndNonstandard.byExtension;
	RxNonStandardMessageCallbackParams.NonStandardData.wManufacturerCode =
		pH245ConfIndData->u.Indication.u.IndNonstandard.wManufacturerCode;
	RxNonStandardMessageCallbackParams.hCall = pCall->hCall;
	if (pCall->pPeerParticipantInfo != NULL)
		RxNonStandardMessageCallbackParams.InitiatorTerminalLabel =
			pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel;
	else {
		RxNonStandardMessageCallbackParams.InitiatorTerminalLabel.bMCUNumber = 255;
		RxNonStandardMessageCallbackParams.InitiatorTerminalLabel.bTerminalNumber = 255;
	}
				
	InvokeUserConferenceCallback(pConference,
		                         CC_RX_NONSTANDARD_MESSAGE_INDICATION,
								 CC_OK,
								 &RxNonStandardMessageCallbackParams);

	if (ValidateConference(hConference) == CC_OK)
		UnlockConference(pConference);
	if (ValidateCall(hCall) == CC_OK)
		UnlockCall(pCall);
	return H245_ERROR_OK;
}



HRESULT _IndMiscellaneous(			H245_CONF_IND_T			*pH245ConfIndData,
									MiscellaneousIndication	*pMiscellaneousIndication)
{
HRESULT						status = CC_OK;
CC_HCALL					hCall;
PCALL						pCall;
PCALL						pOldCall;
CC_HCONFERENCE				hConference;
PCONFERENCE					pConference;
CC_HCHANNEL					hChannel;
PCHANNEL					pChannel;
WORD						i;
WORD						wNumCalls;
PCC_HCALL					CallList;
PDU_T						*pPdu = NULL;
CC_MUTE_CALLBACK_PARAMS		MuteCallbackParams;
CC_UNMUTE_CALLBACK_PARAMS	UnMuteCallbackParams;
CC_H245_MISCELLANEOUS_INDICATION_CALLBACK_PARAMS	H245MiscellaneousIndicationCallbackParams;

	if (pMiscellaneousIndication == NULL)
		// Should never hit this case
		return H245_ERROR_NOSUP;

	hCall = pH245ConfIndData->u.Indication.dwPreserved;
	if (LockCallAndConference(hCall, &pCall, &pConference) != CC_OK)
		return H245_ERROR_OK;

	hConference = pCall->hConference;

	switch (pMiscellaneousIndication->type.choice) {
		case logicalChannelActive_chosen:
		case logicalChannelInactive_chosen:

			UnlockCall(pCall);

			if (FindChannelInConference(pMiscellaneousIndication->logicalChannelNumber,
										FALSE,	// remote channel number
										RX_CHANNEL | PROXY_CHANNEL,
										hCall,
										&hChannel,
										pConference) != CC_OK) {
				UnlockConference(pConference);
				return H245_ERROR_OK;
			}

			if (LockChannel(hChannel, &pChannel) != CC_OK) {
				UnlockConference(pConference);
				return H245_ERROR_OK;
			}

			if (pChannel->bChannelType == PROXY_CHANNEL) {
				ASSERT(pConference->ConferenceMode == MULTIPOINT_MODE);
				ASSERT(pConference->tsMultipointController == TS_TRUE);
				ASSERT(pChannel->bMultipointChannel == TRUE);

				// Construct an H.245 PDU to hold a miscellaneous indication
				// of "logical channel inactive" (mute) or "logical channel active" (unmute)
				pPdu = (PDU_T *)MemAlloc(sizeof(PDU_T));
				if(NULL != pPdu)
				{
    				pPdu->choice = indication_chosen;
    				pPdu->u.indication.choice = miscellaneousIndication_chosen;
    				pPdu->u.indication.u.miscellaneousIndication.logicalChannelNumber =
    					pChannel->wLocalChannelNumber;
    				pPdu->u.indication.u.miscellaneousIndication.type.choice =
    					pMiscellaneousIndication->type.choice;

    				EnumerateCallsInConference(&wNumCalls, &CallList, pConference, ESTABLISHED_CALL);
    				for (i = 0; i < wNumCalls; i++) {
    					if (CallList[i] != hCall) {
    						if (LockCall(CallList[i], &pCall) == CC_OK) {
    							H245SendPDU(pCall->H245Instance, pPdu);
    							UnlockCall(pCall);
    						}
    					}
    				}
    				MemFree(CallList);
    				
    				MemFree(pPdu);
    				pPdu = NULL;
				}
			}

			if (pMiscellaneousIndication->type.choice == logicalChannelActive_chosen) {
				if (pChannel->tsAccepted == TS_TRUE) {
					UnMuteCallbackParams.hChannel = hChannel;
					InvokeUserConferenceCallback(pConference,
												 CC_UNMUTE_INDICATION,
												 CC_OK,
												 &UnMuteCallbackParams);
				}
			} else {
				if (pChannel->tsAccepted == TS_TRUE) {
					MuteCallbackParams.hChannel = hChannel;
					InvokeUserConferenceCallback(pConference,
												 CC_MUTE_INDICATION,
												 CC_OK,
												 &MuteCallbackParams);
				}
			}

			if (ValidateChannel(hChannel) == CC_OK)
				UnlockChannel(pChannel);
			if (ValidateConference(hConference) == CC_OK)
				UnlockConference(pConference);
			status = H245_ERROR_OK;
			break;

		case multipointConference_chosen:
		case cnclMltpntCnfrnc_chosen:
			// We're required to support receipt of this indication, but I have no
			// idea what we're supposed to do with it
			UnlockCall(pCall);
			UnlockConference(pConference);
			status = H245_ERROR_OK;
			break;

		case vdIndctRdyTActvt_chosen:
		case MIn_tp_vdTmprlSptlTrdOff_chosen:
			if (FindChannelInConference(pMiscellaneousIndication->logicalChannelNumber,
										FALSE,	// remote channel number
										RX_CHANNEL | PROXY_CHANNEL,
										hCall,
										&hChannel,
										pConference) != CC_OK) {
				UnlockCall(pCall);
				UnlockConference(pConference);
				return H245_ERROR_OK;
			}

			if (LockChannel(hChannel, &pChannel) != CC_OK) {
				UnlockCall(pCall);
				UnlockConference(pConference);
				return H245_ERROR_OK;
			}

			if (pChannel->bChannelType == PROXY_CHANNEL) {
				ASSERT(pConference->ConferenceMode == MULTIPOINT_MODE);
				ASSERT(pConference->tsMultipointController == TS_TRUE);
				ASSERT(pChannel->bMultipointChannel == TRUE);

				// Construct an H.245 PDU to hold a miscellaneous indication
				// of "video indicate ready to activate" or
				// "video temporal spatial tradeoff"
				pPdu = (PDU_T *)MemAlloc(sizeof(PDU_T));
				if(NULL != pPdu)
				{
    				pPdu->choice = indication_chosen;
    				pPdu->u.indication.choice = miscellaneousIndication_chosen;
    				pPdu->u.indication.u.miscellaneousIndication.logicalChannelNumber =
    					pChannel->wLocalChannelNumber;
    				pPdu->u.indication.u.miscellaneousIndication.type.choice =
    					pMiscellaneousIndication->type.choice;

    				EnumerateCallsInConference(&wNumCalls, &CallList, pConference, ESTABLISHED_CALL);
    				for (i = 0; i < wNumCalls; i++) {
    					if (CallList[i] != hCall) {
    						if (LockCall(CallList[i], &pOldCall) == CC_OK) {
    							H245SendPDU(pOldCall->H245Instance, pPdu);
    							UnlockCall(pOldCall);
    						}
    					}
    				}
    				MemFree(CallList);
    				
    				MemFree(pPdu);
    				pPdu = NULL;
				}
			}

			if (pChannel->tsAccepted == TS_TRUE) {
				H245MiscellaneousIndicationCallbackParams.hCall = hCall;
				if (pCall->pPeerParticipantInfo == NULL) {
					H245MiscellaneousIndicationCallbackParams.InitiatorTerminalLabel.bMCUNumber = 255;
					H245MiscellaneousIndicationCallbackParams.InitiatorTerminalLabel.bTerminalNumber = 255;
				} else
					H245MiscellaneousIndicationCallbackParams.InitiatorTerminalLabel =
						pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel;
				H245MiscellaneousIndicationCallbackParams.hChannel = hChannel;
				H245MiscellaneousIndicationCallbackParams.pMiscellaneousIndication =
					pMiscellaneousIndication;

				status = InvokeUserConferenceCallback(pConference,
											 CC_H245_MISCELLANEOUS_INDICATION_INDICATION,
											 CC_OK,
											 &H245MiscellaneousIndicationCallbackParams);
				if (status != CC_OK)
					status = H245_ERROR_NOSUP;
			} else
				status = H245_ERROR_OK;

			if (ValidateChannel(hChannel) == CC_OK)
				UnlockChannel(pChannel);
			if (ValidateCall(hCall) == CC_OK)
				UnlockCall(pCall);
			if (ValidateConference(hConference) == CC_OK)
				UnlockConference(pConference);
			break;

		case videoNotDecodedMBs_chosen:
			if (FindChannelInConference(pMiscellaneousIndication->logicalChannelNumber,
										TRUE,	// local channel number
										TX_CHANNEL | PROXY_CHANNEL,
										CC_INVALID_HANDLE,
										&hChannel,
										pConference) != CC_OK) {
				UnlockCall(pCall);
				UnlockConference(pConference);
				return H245_ERROR_OK;
			}

			if (LockChannel(hChannel, &pChannel) != CC_OK) {
				UnlockCall(pCall);
				UnlockConference(pConference);
				return H245_ERROR_OK;
			}

			if (pChannel->bChannelType == TX_CHANNEL) {
				H245MiscellaneousIndicationCallbackParams.hCall = hCall;
				if (pCall->pPeerParticipantInfo == NULL) {
					H245MiscellaneousIndicationCallbackParams.InitiatorTerminalLabel.bMCUNumber = 255;
					H245MiscellaneousIndicationCallbackParams.InitiatorTerminalLabel.bTerminalNumber = 255;
				} else
					H245MiscellaneousIndicationCallbackParams.InitiatorTerminalLabel =
						pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel;
				H245MiscellaneousIndicationCallbackParams.hChannel = hChannel;
				H245MiscellaneousIndicationCallbackParams.pMiscellaneousIndication =
					pMiscellaneousIndication;

				status = InvokeUserConferenceCallback(pConference,
											 CC_H245_MISCELLANEOUS_INDICATION_INDICATION,
											 CC_OK,
											 &H245MiscellaneousIndicationCallbackParams);
				if (status != CC_OK)
					status = H245_ERROR_NOSUP;

				if (ValidateChannel(hChannel) == CC_OK)
					UnlockChannel(pChannel);
				if (ValidateCall(hCall) == CC_OK)
					UnlockCall(pCall);
				if (ValidateConference(hConference) == CC_OK)
					UnlockConference(pConference);
				return H245_ERROR_OK;
			} else {
				// Proxy channel; forward the request to the transmitter
  				ASSERT(pConference->ConferenceMode == MULTIPOINT_MODE);
				ASSERT(pConference->tsMultipointController == TS_TRUE);
				ASSERT(pChannel->bMultipointChannel == TRUE);

				// Construct an H.245 PDU to hold a miscellaneous indication
				// of "video not decoded MBs"
				pPdu = (PDU_T *)MemAlloc(sizeof(PDU_T));
				if(NULL != pPdu)
				{
    				pPdu->choice = indication_chosen;
    				pPdu->u.indication.choice = miscellaneousIndication_chosen;
    				pPdu->u.indication.u.miscellaneousIndication.logicalChannelNumber =
    					pChannel->wRemoteChannelNumber;
    				pPdu->u.indication.u.miscellaneousIndication.type.choice =
    					pMiscellaneousIndication->type.choice;

    				if (LockCall(pChannel->hCall, &pOldCall) == CC_OK) {
    					H245SendPDU(pOldCall->H245Instance, pPdu);
    					UnlockCall(pOldCall);
    				}

    				MemFree(pPdu);
    				pPdu = NULL;
				}
				
				UnlockChannel(pChannel);
				UnlockCall(pCall);
				UnlockConference(pConference);
				return H245_ERROR_OK;
			}
			// We should never reach here
			ASSERT(0);

		default:
			// Miscellaneous indication	not containing channel information
			// Pass it up to the client
			H245MiscellaneousIndicationCallbackParams.hCall = hCall;
			if (pCall->pPeerParticipantInfo == NULL) {
				H245MiscellaneousIndicationCallbackParams.InitiatorTerminalLabel.bMCUNumber = 255;
				H245MiscellaneousIndicationCallbackParams.InitiatorTerminalLabel.bTerminalNumber = 255;
			} else
				H245MiscellaneousIndicationCallbackParams.InitiatorTerminalLabel =
					pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel;
			H245MiscellaneousIndicationCallbackParams.hChannel = CC_INVALID_HANDLE;;
			H245MiscellaneousIndicationCallbackParams.pMiscellaneousIndication =
				pMiscellaneousIndication;

			status = InvokeUserConferenceCallback(pConference,
										 CC_H245_MISCELLANEOUS_INDICATION_INDICATION,
										 CC_OK,
										 &H245MiscellaneousIndicationCallbackParams);

			if (status != CC_OK)
				status = H245_ERROR_NOSUP;
			if (ValidateCall(hCall) == CC_OK)
				UnlockCall(pCall);
			if (ValidateConference(hConference) == CC_OK)
				UnlockConference(pConference);
			break;
	}

	return status;

	// We should never reach this point
	ASSERT(0);
}



HRESULT _IndMiscellaneousCommand(	H245_CONF_IND_T			*pH245ConfIndData,
									MiscellaneousCommand	*pMiscellaneousCommand)
{
CC_HCALL					hCall;
PCALL						pCall;
PCALL						pOldCall;
CC_HCONFERENCE				hConference;
PCONFERENCE					pConference;
HRESULT						status = CC_OK;
WORD						wChoice;
CC_HCHANNEL					hChannel;
PCHANNEL					pChannel;
CC_H245_MISCELLANEOUS_COMMAND_CALLBACK_PARAMS	H245MiscellaneousCommandCallbackParams;

	if (pMiscellaneousCommand == NULL)
		// Should never hit this case
		return H245_ERROR_NOSUP;

	hCall = pH245ConfIndData->u.Indication.dwPreserved;
	if (LockCallAndConference(hCall, &pCall, &pConference) != CC_OK)
		return H245_ERROR_OK;

	hConference = pConference->hConference;

	switch (pMiscellaneousCommand->type.choice) {
		case multipointModeCommand_chosen:
		//
		// from this point on, expect CommunicationModeCommand
		// also, theoretically, channels shouldn't be opened until at
		// least one CommunicationModeCommand is received.
		// It's only by examining CommunicationModeCommand contents
		// that we can determine if a conference has decentralized
		// media.

		// I'm commenting this out on 6/4/98 because it's bogus: all
		// endpoints have centralized media distribution.  Set
		// pConference->ConferenceMode = MULTIPOINT_MODE; only after
		// CommunicationModeCommand is received and the multiplex table has
		// been examined and decentralized media is found
#if(0)		
			if (pConference->bMultipointCapable == FALSE) {
				// We can't support multipoint operation, so treat this as if
				// we received a remote hangup indication
				UnlockConference(pConference);
				UnlockCall(pCall);
				ProcessRemoteHangup(hCall, CC_INVALID_HANDLE, CC_REJECT_NORMAL_CALL_CLEARING);
				return H245_ERROR_OK;
			} else {
				pConference->ConferenceMode = MULTIPOINT_MODE;

				// Send TerminalListRequest
				H245ConferenceRequest(pCall->H245Instance,
									  H245_REQ_TERMINAL_LIST,
									  pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bMCUNumber,
									  pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bTerminalNumber);
			}
#else
            // Send TerminalListRequest
			H245ConferenceRequest(pCall->H245Instance,
			    H245_REQ_TERMINAL_LIST,
				pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bMCUNumber,
				pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bTerminalNumber);
#endif
			status = H245_ERROR_OK;
			break;

		case cnclMltpntMdCmmnd_chosen:
			// We're required to support receipt of this command, but I have no
			// idea what we're supposed to do with it
			status = H245_ERROR_OK;
			break;

		case videoFreezePicture_chosen:
		case videoFastUpdatePicture_chosen:
		case videoFastUpdateGOB_chosen:
		case MCd_tp_vdTmprlSptlTrdOff_chosen:
		case videoSendSyncEveryGOB_chosen:
		case videoFastUpdateMB_chosen:
		case vdSndSyncEvryGOBCncl_chosen:
			if (FindChannelInConference(pMiscellaneousCommand->logicalChannelNumber,
										TRUE,	// local channel number
										TX_CHANNEL | PROXY_CHANNEL,
										CC_INVALID_HANDLE,
										&hChannel,
										pConference) != CC_OK) {
				UnlockCall(pCall);
				UnlockConference(pConference);
				return H245_ERROR_OK;
			}

			if (LockChannel(hChannel, &pChannel) != CC_OK) {
				UnlockCall(pCall);
				UnlockConference(pConference);
				return H245_ERROR_OK;
			}

			if (pChannel->bChannelType == TX_CHANNEL) {
				H245MiscellaneousCommandCallbackParams.hCall = hCall;
				if (pCall->pPeerParticipantInfo == NULL) {
					H245MiscellaneousCommandCallbackParams.InitiatorTerminalLabel.bMCUNumber = 255;
					H245MiscellaneousCommandCallbackParams.InitiatorTerminalLabel.bTerminalNumber = 255;
				} else
					H245MiscellaneousCommandCallbackParams.InitiatorTerminalLabel =
						pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel;
				H245MiscellaneousCommandCallbackParams.hChannel = hChannel;
				wChoice = pMiscellaneousCommand->type.choice;
				if ((wChoice == videoFreezePicture_chosen) ||
					(wChoice == videoFastUpdatePicture_chosen) ||
					(wChoice == videoFastUpdateGOB_chosen) ||
					(wChoice == videoFastUpdateMB_chosen))
					H245MiscellaneousCommandCallbackParams.bH323ActionRequired = TRUE;
				else
					H245MiscellaneousCommandCallbackParams.bH323ActionRequired = FALSE;
				H245MiscellaneousCommandCallbackParams.pMiscellaneousCommand =
					pMiscellaneousCommand;

				status = InvokeUserConferenceCallback(pConference,
											 CC_H245_MISCELLANEOUS_COMMAND_INDICATION,
											 CC_OK,
											 &H245MiscellaneousCommandCallbackParams);
				if (status != CC_OK)
					status = H245_ERROR_NOSUP;

				if (ValidateChannel(hChannel) == CC_OK)
					UnlockChannel(pChannel);
				if (ValidateCall(hCall) == CC_OK)
					UnlockCall(pCall);
				if (ValidateConference(hConference) == CC_OK)
					UnlockConference(pConference);
				return H245_ERROR_OK;
			} else {
				// Proxy channel; forward the request to the transmitter
  				ASSERT(pConference->ConferenceMode == MULTIPOINT_MODE);
				ASSERT(pConference->tsMultipointController == TS_TRUE);
				ASSERT(pChannel->bMultipointChannel == TRUE);

				if (LockCall(pChannel->hCall, &pOldCall) == CC_OK) {
				    
                    PDU_T	*pPdu = (PDU_T *) MemAlloc(sizeof(PDU_T));

                    if(NULL != pPdu)
                    {
        				pPdu->choice = MSCMg_cmmnd_chosen;
        				pPdu->u.MSCMg_cmmnd.choice = miscellaneousCommand_chosen;
        				pPdu->u.MSCMg_cmmnd.u.miscellaneousCommand.logicalChannelNumber =
        					pChannel->wRemoteChannelNumber;
        				pPdu->u.MSCMg_cmmnd.u.miscellaneousCommand = *pMiscellaneousCommand;
        				
    					H245SendPDU(pOldCall->H245Instance, pPdu);
    					
    					MemFree(pPdu);
    					pPdu = NULL;
                    }
                    
					UnlockCall(pOldCall);
				}
				
				UnlockChannel(pChannel);
				UnlockCall(pCall);
				UnlockConference(pConference);
				
				return H245_ERROR_OK;
			}
			// We should never reach here
			ASSERT(0);

		default:
			// Unrecognized miscellaneous command
			// Pass it up to the client
			H245MiscellaneousCommandCallbackParams.hCall = hCall;
			if (pCall->pPeerParticipantInfo == NULL) {
				H245MiscellaneousCommandCallbackParams.InitiatorTerminalLabel.bMCUNumber = 255;
				H245MiscellaneousCommandCallbackParams.InitiatorTerminalLabel.bTerminalNumber = 255;
			} else
				H245MiscellaneousCommandCallbackParams.InitiatorTerminalLabel =
					pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel;
			H245MiscellaneousCommandCallbackParams.hChannel = CC_INVALID_HANDLE;
			H245MiscellaneousCommandCallbackParams.bH323ActionRequired = FALSE;
			H245MiscellaneousCommandCallbackParams.pMiscellaneousCommand =
				pMiscellaneousCommand;
			status = InvokeUserConferenceCallback(pConference,
												  CC_H245_MISCELLANEOUS_COMMAND_INDICATION,
												  CC_OK,
												  &H245MiscellaneousCommandCallbackParams);
			if (status != CC_OK)
				status = H245_ERROR_NOSUP;
			if (ValidateCall(hCall) == CC_OK)
				UnlockCall(pCall);
			if (ValidateConference(hConference) == CC_OK)
				UnlockConference(pConference);
			return status;
	}

	if (ValidateCall(hCall) == CC_OK)
		UnlockCall(pCall);
	if (ValidateConference(hConference) == CC_OK)
		UnlockConference(pConference);

	return status;

	// We should never reach this point
	ASSERT(0);
}



HRESULT _IndMCLocation(				H245_CONF_IND_T			*pH245ConfIndData)
{
CC_HCALL					hCall;
PCALL						pCall;
PCONFERENCE					pConference;
CC_CONNECT_CALLBACK_PARAMS	ConnectCallbackParams;
PCALL						pEnqueuedCall;
CC_HCALL					hEnqueuedCall;
HRESULT						status;
CC_HCONFERENCE				hConference;

	if (pH245ConfIndData->u.Indication.u.IndMcLocation.type != H245_IP_UNICAST)
		return H245_ERROR_OK;

	hCall = pH245ConfIndData->u.Indication.dwPreserved;

	if (LockCallAndConference(hCall, &pCall, &pConference) != CC_OK)
		return H245_ERROR_OK;

	UnlockCall(pCall);

	hConference = pConference->hConference;

	if (pConference->tsMultipointController != TS_FALSE) {
		// We don't expect to receive an MCLocationIndication until master/slave
		// has completed, at which time tsMultipointController will change from
		// TS_UNKNOWN to either TS_TRUE or TS_FALSE.
		UnlockConference(pConference);
		return H245_ERROR_NOSUP;
	}

	if (pConference->pMultipointControllerAddr == NULL) {
		pConference->pMultipointControllerAddr = (PCC_ADDR)MemAlloc(sizeof(CC_ADDR));
		if (pConference->pMultipointControllerAddr == NULL) {
			UnlockConference(pConference);
			return H245_ERROR_OK;
		}
	}
	pConference->pMultipointControllerAddr->nAddrType = CC_IP_BINARY;
	pConference->pMultipointControllerAddr->bMulticast = FALSE;
	pConference->pMultipointControllerAddr->Addr.IP_Binary.wPort =
		pH245ConfIndData->u.Indication.u.IndMcLocation.u.ip.tsapIdentifier;
	H245IPNetworkToHost(&pConference->pMultipointControllerAddr->Addr.IP_Binary.dwAddr,
						pH245ConfIndData->u.Indication.u.IndMcLocation.u.ip.network);

	// place all calls enqueued on this conference object
	for ( ; ; ) {
		// Start up all enqueued calls, if any exist
		status = RemoveEnqueuedCallFromConference(pConference, &hEnqueuedCall);
		if ((status != CC_OK) || (hEnqueuedCall == CC_INVALID_HANDLE))
			break;

		status = LockCall(hEnqueuedCall, &pEnqueuedCall);
		if (status == CC_OK) {
			// Place Call to MC
			pEnqueuedCall->CallState = PLACED;
			pEnqueuedCall->CallType = THIRD_PARTY_INVITOR;
			if (pEnqueuedCall->pQ931DestinationAddr == NULL)
				pEnqueuedCall->pQ931DestinationAddr = pEnqueuedCall->pQ931PeerConnectAddr;
			if (pEnqueuedCall->pQ931PeerConnectAddr == NULL)
				pEnqueuedCall->pQ931PeerConnectAddr = (PCC_ADDR)MemAlloc(sizeof(CC_ADDR));
			if (pEnqueuedCall->pQ931PeerConnectAddr == NULL) {
				MarkCallForDeletion(pEnqueuedCall);
				ConnectCallbackParams.pNonStandardData = pEnqueuedCall->pPeerNonStandardData;
				ConnectCallbackParams.pszPeerDisplay = pEnqueuedCall->pszPeerDisplay;
				ConnectCallbackParams.bRejectReason = CC_REJECT_UNDEFINED_REASON;
				ConnectCallbackParams.pTermCapList = pEnqueuedCall->pPeerH245TermCapList;
				ConnectCallbackParams.pH2250MuxCapability = pEnqueuedCall->pPeerH245H2250MuxCapability;
				ConnectCallbackParams.pTermCapDescriptors = pEnqueuedCall->pPeerH245TermCapDescriptors;
				ConnectCallbackParams.pLocalAddr = pEnqueuedCall->pQ931LocalConnectAddr;
	            if (pEnqueuedCall->pQ931DestinationAddr == NULL)
		            ConnectCallbackParams.pPeerAddr = pEnqueuedCall->pQ931PeerConnectAddr;
	            else
		            ConnectCallbackParams.pPeerAddr = pEnqueuedCall->pQ931DestinationAddr;
				ConnectCallbackParams.pVendorInfo = pEnqueuedCall->pPeerVendorInfo;
				ConnectCallbackParams.bMultipointConference = TRUE;
				ConnectCallbackParams.pConferenceID = &pConference->ConferenceID;
				ConnectCallbackParams.pMCAddress = pConference->pMultipointControllerAddr;
				ConnectCallbackParams.pAlternateAddress = NULL;
				ConnectCallbackParams.dwUserToken = pEnqueuedCall->dwUserToken;

				InvokeUserConferenceCallback(pConference,
									 CC_CONNECT_INDICATION,
									 CC_NO_MEMORY,
									 &ConnectCallbackParams);

				if (ValidateCallMarkedForDeletion(hEnqueuedCall) == CC_OK)
					FreeCall(pEnqueuedCall);
				if (ValidateConference(hConference) != CC_OK)
					return H245_ERROR_OK;
			}
			pEnqueuedCall->pQ931PeerConnectAddr = pConference->pMultipointControllerAddr;

			status = PlaceCall(pEnqueuedCall, pConference);
			UnlockCall(pEnqueuedCall);
		}
	}

	UnlockConference(pConference);
	return H245_ERROR_OK;
}



HRESULT _IndConferenceRequest(		H245_CONF_IND_T			*pH245ConfIndData)
{
CC_HCALL					hCall;
PCALL						pCall;
PCALL						pPeerCall;
CC_HCONFERENCE				hConference;
PCONFERENCE					pConference;
HRESULT						status;
H245_TERMINAL_LABEL_T		*H245TerminalLabelList;
H245_TERMINAL_LABEL_T		H245TerminalLabel;
WORD						wNumTerminalLabels;
CC_H245_CONFERENCE_REQUEST_CALLBACK_PARAMS	H245ConferenceRequestCallbackParams;

	hCall = pH245ConfIndData->u.Indication.dwPreserved;
	if (LockCallAndConference(hCall, &pCall, &pConference) != CC_OK)
		return H245_ERROR_OK;

	hConference = pConference->hConference;

	switch (pH245ConfIndData->u.Indication.u.IndConferReq.RequestType) {
		case H245_REQ_ENTER_H243_TERMINAL_ID:
			switch (pConference->LocalParticipantInfo.TerminalIDState) {
				case TERMINAL_ID_INVALID:
					UnlockCall(pCall);
					EnqueueRequest(&pConference->LocalParticipantInfo.pEnqueuedRequestsForTerminalID,
								   hCall);
					pConference->LocalParticipantInfo.TerminalIDState = TERMINAL_ID_REQUESTED;
					InvokeUserConferenceCallback(pConference,
									 CC_TERMINAL_ID_REQUEST_INDICATION,
									 CC_OK,
									 NULL);
					if (ValidateConference(hConference) == CC_OK)
						UnlockConference(pConference);
					return H245_ERROR_OK;

				case TERMINAL_ID_REQUESTED:
					UnlockCall(pCall);
					EnqueueRequest(&pConference->LocalParticipantInfo.pEnqueuedRequestsForTerminalID,
								   hCall);
					UnlockConference(pConference);
					return H245_ERROR_OK;

				case TERMINAL_ID_VALID:
					H245ConferenceResponse(pCall->H245Instance,
										   H245_RSP_TERMINAL_ID,
										   pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bMCUNumber,
										   pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bTerminalNumber,
										   pConference->LocalParticipantInfo.ParticipantInfo.TerminalID.pOctetString,
										   (BYTE)pConference->LocalParticipantInfo.ParticipantInfo.TerminalID.wOctetStringLength,
										   NULL,					// terminal list
										   0);						// terminal list count
					UnlockCall(pCall);
					UnlockConference(pConference);
					return H245_ERROR_OK;

				default:
					ASSERT(0);
			}

		case H245_REQ_TERMINAL_LIST:
			if ((pConference->ConferenceMode == MULTIPOINT_MODE) &&
				(pConference->tsMultipointController == TS_TRUE)) {
				status = EnumerateTerminalLabelsInConference(&wNumTerminalLabels,
													      &H245TerminalLabelList,
														  pConference);
				if (status == CC_OK)
					H245ConferenceResponse(pCall->H245Instance,
										   H245_RSP_TERMINAL_LIST,
										   pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bMCUNumber,
										   pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bTerminalNumber,
										   pConference->LocalParticipantInfo.ParticipantInfo.TerminalID.pOctetString,
										   (BYTE)pConference->LocalParticipantInfo.ParticipantInfo.TerminalID.wOctetStringLength,
										   H245TerminalLabelList,		// terminal list
										   wNumTerminalLabels);			// terminal list count
				if (H245TerminalLabelList != NULL)
					MemFree(H245TerminalLabelList);
				status = H245_ERROR_OK;
			} else
				status = H245_ERROR_NOSUP;
			break;

		case H245_REQ_TERMINAL_ID:
			if (pConference->tsMultipointController != TS_TRUE) {
				status = H245_ERROR_NOSUP;
				break;
			}

			if (pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bMCUNumber !=
				pH245ConfIndData->u.Indication.u.IndConferReq.byMcuNumber) {
				// This terminal ID wasn't allocated by this MC, so return without a response
				status = H245_ERROR_OK;
				break;
			}

			// First check to see whether the requested terminal ID is ours
			if (pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bTerminalNumber ==
				 pH245ConfIndData->u.Indication.u.IndConferReq.byTerminalNumber) {
			    if (pConference->LocalEndpointAttached != ATTACHED) {
					status = H245_ERROR_OK;
					break;
				}

  				switch (pConference->LocalParticipantInfo.TerminalIDState) {
					case TERMINAL_ID_INVALID:
						UnlockCall(pCall);
						EnqueueRequest(&pConference->LocalParticipantInfo.pEnqueuedRequestsForTerminalID,
									   hCall);
						pConference->LocalParticipantInfo.TerminalIDState = TERMINAL_ID_REQUESTED;
						InvokeUserConferenceCallback(pConference,
										 CC_TERMINAL_ID_REQUEST_INDICATION,
										 CC_OK,
										 NULL);
						if (ValidateConference(hConference) == CC_OK)
							UnlockConference(pConference);
						return H245_ERROR_OK;

					case TERMINAL_ID_REQUESTED:
						UnlockCall(pCall);
						EnqueueRequest(&pConference->LocalParticipantInfo.pEnqueuedRequestsForTerminalID,
									   hCall);
						UnlockConference(pConference);
						return H245_ERROR_OK;

					case TERMINAL_ID_VALID:
						H245ConferenceResponse(pCall->H245Instance,
											   H245_RSP_MC_TERMINAL_ID,
											   pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bMCUNumber,
											   pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bTerminalNumber,
											   pConference->LocalParticipantInfo.ParticipantInfo.TerminalID.pOctetString,
											   (BYTE)pConference->LocalParticipantInfo.ParticipantInfo.TerminalID.wOctetStringLength,
											   NULL,					// terminal list
											   0);						// terminal list count
						UnlockCall(pCall);
						UnlockConference(pConference);
						return H245_ERROR_OK;

					default:
						ASSERT(0);
				}
			}

			H245TerminalLabel.mcuNumber = pH245ConfIndData->u.Indication.u.IndConferReq.byMcuNumber;
			H245TerminalLabel.terminalNumber = pH245ConfIndData->u.Indication.u.IndConferReq.byTerminalNumber;

			FindPeerParticipantInfo(H245TerminalLabel,
									pConference,
									ESTABLISHED_CALL,
									&pPeerCall);
			if (pPeerCall == NULL) {
				// We don't know about the existance of this terminal ID, so return without a response
				status = H245_ERROR_OK;
				break;
			}

			if (pPeerCall->pPeerParticipantInfo == NULL) {
				UnlockCall(pPeerCall);
				status = H245_ERROR_OK;
				break;
			}

			switch (pPeerCall->pPeerParticipantInfo->TerminalIDState) {
				case TERMINAL_ID_INVALID:
					EnqueueRequest(&pPeerCall->pPeerParticipantInfo->pEnqueuedRequestsForTerminalID,
								   hCall);
					pPeerCall->pPeerParticipantInfo->TerminalIDState = TERMINAL_ID_REQUESTED;
  					H245ConferenceRequest(pPeerCall->H245Instance,
										  H245_REQ_ENTER_H243_TERMINAL_ID,
										  pPeerCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel.bMCUNumber,
										  pPeerCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel.bTerminalNumber);
					break;

				case TERMINAL_ID_REQUESTED:
					EnqueueRequest(&pPeerCall->pPeerParticipantInfo->pEnqueuedRequestsForTerminalID,
								   hCall);
					break;

				case TERMINAL_ID_VALID:
					H245ConferenceResponse(pCall->H245Instance,
										   H245_RSP_MC_TERMINAL_ID,
										   pPeerCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel.bMCUNumber,
										   pPeerCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel.bTerminalNumber,
										   pPeerCall->pPeerParticipantInfo->ParticipantInfo.TerminalID.pOctetString,
										   (BYTE)pPeerCall->pPeerParticipantInfo->ParticipantInfo.TerminalID.wOctetStringLength,
										   NULL,			// terminal list
										   0);				// terminal list count
					break;

				default:
					ASSERT(0);
					break;
			}
			UnlockCall(pPeerCall);
			status = H245_ERROR_OK;
			break;

		default:
			H245ConferenceRequestCallbackParams.hCall = hCall;
			if (pCall->pPeerParticipantInfo == NULL) {
				H245ConferenceRequestCallbackParams.InitiatorTerminalLabel.bMCUNumber = 255;
				H245ConferenceRequestCallbackParams.InitiatorTerminalLabel.bTerminalNumber = 255;
			} else
				H245ConferenceRequestCallbackParams.InitiatorTerminalLabel =
					pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel;
			H245ConferenceRequestCallbackParams.RequestType =
				pH245ConfIndData->u.Indication.u.IndConferReq.RequestType;
			H245ConferenceRequestCallbackParams.TerminalLabel.bMCUNumber =
				pH245ConfIndData->u.Indication.u.IndConferReq.byMcuNumber;
			H245ConferenceRequestCallbackParams.TerminalLabel.bTerminalNumber =
				pH245ConfIndData->u.Indication.u.IndConferReq.byTerminalNumber;
			status = InvokeUserConferenceCallback(pConference,
												  CC_H245_CONFERENCE_REQUEST_INDICATION,
												  CC_OK,
												  &H245ConferenceRequestCallbackParams);
			if (status != CC_OK)
				status = H245_ERROR_NOSUP;
			break;
	}

	if (ValidateCall(hCall) == CC_OK)
		UnlockCall(pCall);
	if (ValidateConference(hConference) == CC_OK)
		UnlockConference(pConference);
	return status;
}



HRESULT _IndConferenceResponse(		H245_CONF_IND_T			*pH245ConfIndData)
{
CC_HCALL						hCall;
PCALL							pCall;
PCALL							pPeerCall;
CC_HCALL						hEnqueuedCall;
PCALL							pEnqueuedCall;
CC_HCALL						hVirtualCall;
CC_HCALL						hPeerCall;
PCALL							pVirtualCall;
PCONFERENCE						pConference;
CC_HCONFERENCE					hConference;
HRESULT							status;
WORD							i;
PPARTICIPANTINFO				pPeerParticipantInfo;
H245_TERMINAL_LABEL_T			TerminalLabel;
CC_PEER_ADD_CALLBACK_PARAMS		PeerAddCallbackParams;
CC_PEER_UPDATE_CALLBACK_PARAMS	PeerUpdateCallbackParams;
CC_H245_CONFERENCE_RESPONSE_CALLBACK_PARAMS	H245ConferenceResponseCallbackParams;
CC_OCTETSTRING					OctetString;

	hCall = pH245ConfIndData->u.Indication.dwPreserved;
	if (LockCallAndConference(hCall, &pCall, &pConference) != CC_OK)
		return H245_ERROR_OK;

	hConference = pConference->hConference;

	switch (pH245ConfIndData->u.Indication.u.IndConferRsp.ResponseType) {
		case H245_RSP_TERMINAL_LIST:
			if (pConference->tsMultipointController == TS_FALSE) {
				for (i = 0; i < pH245ConfIndData->u.Indication.u.IndConferRsp.wTerminalListCount; i++) {
					if ((pH245ConfIndData->u.Indication.u.IndConferRsp.pTerminalList[i].mcuNumber ==
						 pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bMCUNumber) &&
						(pH245ConfIndData->u.Indication.u.IndConferRsp.pTerminalList[i].terminalNumber ==
						 pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bTerminalNumber))
						// This terminal number refers to us
						continue;
					FindPeerParticipantInfo(pH245ConfIndData->u.Indication.u.IndConferRsp.pTerminalList[i],
											pConference,
											VIRTUAL_CALL,
											&pPeerCall);
					if (pPeerCall != NULL) {
						// We already know this peer's terminal label, and we
						// eithet know its terminal ID or we have a pending request
						// to obtain it
						UnlockCall(pPeerCall);
						continue;
					}

					// We don't know about this peer.
					// Create a virtual call object for it, and issue a request
					// for its terminal ID
					status = AllocAndLockCall(&hVirtualCall,
											  pConference->hConference,
											  CC_INVALID_HANDLE,	// hQ931Call
											  CC_INVALID_HANDLE,	// hQ931CallInvitor,
											  NULL,					// pLocalAliasNames,
											  NULL,					// pPeerAliasNames,
											  NULL,					// pPeerExtraAliasNames
											  NULL,					// pPeerExtension
											  NULL,					// pLocalNonStandardData,
											  NULL,					// pPeerNonStandardData,
											  NULL,					// pszLocalDisplay,
											  NULL,					// pszPeerDisplay,
											  NULL,					// pPeerVendorInfo,
											  NULL,					// pQ931LocalConnectAddr,
											  NULL,					// pQ931PeerConnectAddr,
											  NULL,					// pQ931DestinationAddr,
											  NULL,                 // pSourceCallSignalAddress
											  VIRTUAL,				// CallType,
											  FALSE,				// bCallerIsMC,
											  0,					// dwUserToken,
											  CALL_COMPLETE,		// InitialCallState,
											  NULL,                 // no CallIdentifier
											  &pConference->ConferenceID,
											  &pVirtualCall);
					if (status == CC_OK) {
						status = AllocatePeerParticipantInfo(NULL,
														     &pPeerParticipantInfo);
						if (status == CC_OK) {
							pVirtualCall->pPeerParticipantInfo =
								pPeerParticipantInfo;
							pPeerParticipantInfo->ParticipantInfo.TerminalLabel.bMCUNumber =
								(BYTE)pH245ConfIndData->u.Indication.u.IndConferRsp.pTerminalList[i].mcuNumber;
							pPeerParticipantInfo->ParticipantInfo.TerminalLabel.bTerminalNumber =
								(BYTE)pH245ConfIndData->u.Indication.u.IndConferRsp.pTerminalList[i].terminalNumber;
							AddVirtualCallToConference(pVirtualCall,
													   pConference);
							// Send RequestTerminalID
							H245ConferenceRequest(pCall->H245Instance,
										          H245_REQ_TERMINAL_ID,
										          (BYTE)pH245ConfIndData->u.Indication.u.IndConferRsp.pTerminalList[i].mcuNumber,
												  (BYTE)pH245ConfIndData->u.Indication.u.IndConferRsp.pTerminalList[i].terminalNumber);
							pPeerParticipantInfo->TerminalIDState = TERMINAL_ID_REQUESTED;

							// Generate PEER_ADD callback
							PeerAddCallbackParams.hCall = hVirtualCall;
							PeerAddCallbackParams.TerminalLabel =
								pVirtualCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel;
							PeerAddCallbackParams.pPeerTerminalID = NULL;
							InvokeUserConferenceCallback(pConference,
												 CC_PEER_ADD_INDICATION,
												 CC_OK,
												 &PeerAddCallbackParams);
							if (ValidateCall(hVirtualCall) == CC_OK)
								UnlockCall(pVirtualCall);
						} else
							FreeCall(pVirtualCall);
					}
				}
			}
			status = H245_ERROR_OK;
			break;

		case H245_RSP_MC_TERMINAL_ID:
			if (pConference->tsMultipointController == TS_FALSE) {
				TerminalLabel.mcuNumber = pH245ConfIndData->u.Indication.u.IndConferRsp.byMcuNumber;
				TerminalLabel.terminalNumber = pH245ConfIndData->u.Indication.u.IndConferRsp.byTerminalNumber;
				FindPeerParticipantInfo(TerminalLabel,
										pConference,
										VIRTUAL_CALL,
										&pPeerCall);
				if (pPeerCall != NULL) {
					hPeerCall = pPeerCall->hCall;
					if (pPeerCall->pPeerParticipantInfo->TerminalIDState != TERMINAL_ID_VALID) {
						pPeerCall->pPeerParticipantInfo->ParticipantInfo.TerminalID.pOctetString =
							(BYTE *)MemAlloc(pH245ConfIndData->u.Indication.u.IndConferRsp.byOctetStringLength);
						if (pPeerCall->pPeerParticipantInfo->ParticipantInfo.TerminalID.pOctetString == NULL) {
							UnlockCall(pPeerCall);
							status = H245_ERROR_OK;
							break;
						}
						memcpy(pPeerCall->pPeerParticipantInfo->ParticipantInfo.TerminalID.pOctetString,
							   pH245ConfIndData->u.Indication.u.IndConferRsp.pOctetString,
							   pH245ConfIndData->u.Indication.u.IndConferRsp.byOctetStringLength);
						pPeerCall->pPeerParticipantInfo->ParticipantInfo.TerminalID.wOctetStringLength =
							pH245ConfIndData->u.Indication.u.IndConferRsp.byOctetStringLength;
						pPeerCall->pPeerParticipantInfo->TerminalIDState = TERMINAL_ID_VALID;
						
						PeerUpdateCallbackParams.hCall = hPeerCall;
						PeerUpdateCallbackParams.TerminalLabel =
							pPeerCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel;
						PeerUpdateCallbackParams.pPeerTerminalID = &pPeerCall->pPeerParticipantInfo->ParticipantInfo.TerminalID;
						InvokeUserConferenceCallback(pConference,
													 CC_PEER_UPDATE_INDICATION,
													 CC_OK,
													 &PeerUpdateCallbackParams);
					}
					if (ValidateCall(hPeerCall) == CC_OK)
						UnlockCall(pPeerCall);
				}
			}
			status = H245_ERROR_OK;
			break;

		case H245_RSP_TERMINAL_ID:
			if ((pConference->ConferenceMode == MULTIPOINT_MODE) &&
				(pConference->tsMultipointController == TS_TRUE)) {
				TerminalLabel.mcuNumber = pH245ConfIndData->u.Indication.u.IndConferRsp.byMcuNumber;
				TerminalLabel.terminalNumber = pH245ConfIndData->u.Indication.u.IndConferRsp.byTerminalNumber;
				FindPeerParticipantInfo(TerminalLabel,
										pConference,
										ESTABLISHED_CALL,
										&pPeerCall);
				if (pPeerCall != NULL) {
					hPeerCall = pPeerCall->hCall;
					if (pPeerCall->pPeerParticipantInfo->TerminalIDState != TERMINAL_ID_VALID) {
						pPeerCall->pPeerParticipantInfo->ParticipantInfo.TerminalID.pOctetString =
							(BYTE *)MemAlloc(pH245ConfIndData->u.Indication.u.IndConferRsp.byOctetStringLength);
						if (pPeerCall->pPeerParticipantInfo->ParticipantInfo.TerminalID.pOctetString == NULL) {
							UnlockCall(pPeerCall);
							status = H245_ERROR_OK;
							break;
						}
						memcpy(pPeerCall->pPeerParticipantInfo->ParticipantInfo.TerminalID.pOctetString,
							   pH245ConfIndData->u.Indication.u.IndConferRsp.pOctetString,
							   pH245ConfIndData->u.Indication.u.IndConferRsp.byOctetStringLength);
						pPeerCall->pPeerParticipantInfo->ParticipantInfo.TerminalID.wOctetStringLength =
							pH245ConfIndData->u.Indication.u.IndConferRsp.byOctetStringLength;
						pPeerCall->pPeerParticipantInfo->TerminalIDState = TERMINAL_ID_VALID;
						
						// Dequeue and respond to each enqueued request for this terminal ID
						while (DequeueRequest(&pPeerCall->pPeerParticipantInfo->pEnqueuedRequestsForTerminalID,
											  &hEnqueuedCall) == CC_OK) {
							if (LockCall(hEnqueuedCall, &pEnqueuedCall) == CC_OK) {
								H245ConferenceResponse(pEnqueuedCall->H245Instance,
													   H245_RSP_MC_TERMINAL_ID,
													   pPeerCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel.bMCUNumber,
													   pPeerCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel.bTerminalNumber,
													   pPeerCall->pPeerParticipantInfo->ParticipantInfo.TerminalID.pOctetString,
													   (BYTE)pPeerCall->pPeerParticipantInfo->ParticipantInfo.TerminalID.wOctetStringLength,
													   NULL,			// terminal list
													   0);				// terminal list count

								UnlockCall(pEnqueuedCall);
							}
						}

						// Generate a CC_PEER_UPDATE_INDICATION callback
						PeerUpdateCallbackParams.hCall = hPeerCall;
						PeerUpdateCallbackParams.TerminalLabel =
							pPeerCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel;
						PeerUpdateCallbackParams.pPeerTerminalID = &pPeerCall->pPeerParticipantInfo->ParticipantInfo.TerminalID;
						InvokeUserConferenceCallback(pConference,
													 CC_PEER_UPDATE_INDICATION,
													 CC_OK,
													 &PeerUpdateCallbackParams);
					}
					if (ValidateCall(hPeerCall) == CC_OK)
						UnlockCall(pPeerCall);
				}
			}
			status = H245_ERROR_OK;
			break;

		default:
			H245ConferenceResponseCallbackParams.hCall = hCall;
			if (pCall->pPeerParticipantInfo == NULL) {
				H245ConferenceResponseCallbackParams.InitiatorTerminalLabel.bMCUNumber = 255;
				H245ConferenceResponseCallbackParams.InitiatorTerminalLabel.bTerminalNumber = 255;
			} else
				H245ConferenceResponseCallbackParams.InitiatorTerminalLabel =
					pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel;
			H245ConferenceResponseCallbackParams.ResponseType =
				pH245ConfIndData->u.Indication.u.IndConferRsp.ResponseType;
			H245ConferenceResponseCallbackParams.TerminalLabel.bMCUNumber =
				pH245ConfIndData->u.Indication.u.IndConferRsp.byMcuNumber;
			H245ConferenceResponseCallbackParams.TerminalLabel.bTerminalNumber =
				pH245ConfIndData->u.Indication.u.IndConferRsp.byTerminalNumber;
			if ((pH245ConfIndData->u.Indication.u.IndConferRsp.pOctetString == NULL) ||
				(pH245ConfIndData->u.Indication.u.IndConferRsp.byOctetStringLength == 0)) {
				H245ConferenceResponseCallbackParams.pOctetString = NULL;
			} else {
				OctetString.pOctetString =
					pH245ConfIndData->u.Indication.u.IndConferRsp.pOctetString;
				OctetString.wOctetStringLength =
					pH245ConfIndData->u.Indication.u.IndConferRsp.byOctetStringLength;
				H245ConferenceResponseCallbackParams.pOctetString = &OctetString;
			}
			if (pH245ConfIndData->u.Indication.u.IndConferRsp.wTerminalListCount == 0) {
				H245ConferenceResponseCallbackParams.pTerminalList = NULL;
				H245ConferenceResponseCallbackParams.wTerminalListCount = 0;
				status = CC_OK;
			} else {
				H245ConferenceResponseCallbackParams.pTerminalList =
					(CC_TERMINAL_LABEL *)MemAlloc(sizeof(CC_TERMINAL_LABEL) *
						pH245ConfIndData->u.Indication.u.IndConferRsp.wTerminalListCount);
				if (H245ConferenceResponseCallbackParams.pTerminalList == NULL) {
					H245ConferenceResponseCallbackParams.wTerminalListCount = 0;
					status = CC_NO_MEMORY;
				} else {
					for (i = 0; i < pH245ConfIndData->u.Indication.u.IndConferRsp.wTerminalListCount; i++) {
						H245ConferenceResponseCallbackParams.pTerminalList[i].bMCUNumber =
							(BYTE)pH245ConfIndData->u.Indication.u.IndConferRsp.pTerminalList[i].mcuNumber;
						H245ConferenceResponseCallbackParams.pTerminalList[i].bMCUNumber =
							(BYTE)pH245ConfIndData->u.Indication.u.IndConferRsp.pTerminalList[i].terminalNumber;
					}
					H245ConferenceResponseCallbackParams.wTerminalListCount =
						pH245ConfIndData->u.Indication.u.IndConferRsp.wTerminalListCount;
					status = CC_OK;
				}
			}
			status = InvokeUserConferenceCallback(pConference,
												  CC_H245_CONFERENCE_RESPONSE_INDICATION,
												  status,
												  &H245ConferenceResponseCallbackParams);
			if (status != CC_OK)
				status = H245_ERROR_NOSUP;
			if (H245ConferenceResponseCallbackParams.pTerminalList != NULL)
				MemFree(H245ConferenceResponseCallbackParams.pTerminalList);
			break;
	}

	if (ValidateCall(hCall) == CC_OK)
		UnlockCall(pCall);
	if (ValidateConference(hConference) == CC_OK)
		UnlockConference(pConference);
	return status;
}




HRESULT _IndConferenceCommand(		H245_CONF_IND_T			*pH245ConfIndData)
{
CC_HCALL						hCall;
PCALL							pCall;
PCALL							pOldCall;
PCONFERENCE						pConference;
CC_HCONFERENCE					hConference;
WORD							i;
WORD							wNumCalls;
PCC_HCALL						CallList;
WORD							wNumChannels;
PCC_HCHANNEL					ChannelList;
PCHANNEL						pChannel;
CC_HCHANNEL						hChannel;
CALLSTATE						CallState;
HQ931CALL						hQ931Call;
H245_INST_T						H245Instance;
HRESULT							status = CC_OK;
CC_H245_CONFERENCE_COMMAND_CALLBACK_PARAMS	H245ConferenceCommandCallbackParams;

	hCall = pH245ConfIndData->u.Indication.dwPreserved;
	if (LockCallAndConference(hCall, &pCall, &pConference) != CC_OK)
		return H245_ERROR_OK;

	hConference = pConference->hConference;

	switch (pH245ConfIndData->u.Indication.u.IndConferCmd.CommandType) {
		case H245_CMD_DROP_CONFERENCE:
			if ((pConference->ConferenceMode == MULTIPOINT_MODE) &&
				(pConference->tsMultipointController == TS_TRUE)) {
				UnlockCall(pCall);
				EnumerateCallsInConference(&wNumCalls, &CallList, pConference, ALL_CALLS);
				for (i = 0; i < wNumCalls; i++) {
					if (LockCall(CallList[i], &pCall) == CC_OK) {
						hQ931Call = pCall->hQ931Call;
						H245Instance = pCall->H245Instance;
						CallState = pCall->CallState;
						FreeCall(pCall);
						switch (CallState) {
							case ENQUEUED:
								break;

							case PLACED:
							case RINGING:
								Q931Hangup(hQ931Call, CC_REJECT_NORMAL_CALL_CLEARING);
								break;

							default:
								H245ShutDown(H245Instance);
								Q931Hangup(hQ931Call, CC_REJECT_NORMAL_CALL_CLEARING);
								break;
						}
					}
				}
				if (CallList != NULL)
					MemFree(CallList);

				EnumerateChannelsInConference(&wNumChannels,
											  &ChannelList,
											  pConference,
											  ALL_CHANNELS);
				for (i = 0; i < wNumChannels; i++) {
					if (LockChannel(ChannelList[i], &pChannel) == CC_OK)
						FreeChannel(pChannel);
				}
				if (ChannelList != NULL)
					MemFree(ChannelList);
						
				InvokeUserConferenceCallback(
									 pConference,
			                         CC_CONFERENCE_TERMINATION_INDICATION,
									 CC_OK,
									 NULL);
				if (ValidateConference(hConference) == CC_OK) {
					if (pConference->bDeferredDelete)
						FreeConference(pConference);
					else {
						ReInitializeConference(pConference);
						UnlockConference(pConference);
					}
				}
				return H245_ERROR_OK;
			}
			status = H245_ERROR_OK;
			break;

		case brdcstMyLgclChnnl_chosen:
		case cnclBrdcstMyLgclChnnl_chosen:
			if (FindChannelInConference(pH245ConfIndData->u.Indication.u.IndConferCmd.Channel,
										FALSE,	// remote channel number
										RX_CHANNEL | PROXY_CHANNEL,
										hCall,
										&hChannel,
										pConference) != CC_OK) {
				UnlockCall(pCall);
				UnlockConference(pConference);
				return H245_ERROR_OK;
			}

			if (LockChannel(hChannel, &pChannel) != CC_OK) {
				UnlockCall(pCall);
				UnlockConference(pConference);
				return H245_ERROR_OK;
			}
			
			if (pChannel->bChannelType == PROXY_CHANNEL) {
				ASSERT(pConference->ConferenceMode == MULTIPOINT_MODE);
				ASSERT(pConference->tsMultipointController == TS_TRUE);
				ASSERT(pChannel->bMultipointChannel == TRUE);

				EnumerateCallsInConference(&wNumCalls, &CallList, pConference, ESTABLISHED_CALL);
				for (i = 0; i < wNumCalls; i++) {
					if (CallList[i] != hCall) {
						if (LockCall(CallList[i], &pOldCall) == CC_OK) {
							H245ConferenceCommand(pOldCall->H245Instance,
												  pH245ConfIndData->u.Indication.u.IndConferCmd.CommandType,
												  pChannel->wLocalChannelNumber,
												  pH245ConfIndData->u.Indication.u.IndConferCmd.byMcuNumber,
												  pH245ConfIndData->u.Indication.u.IndConferCmd.byTerminalNumber);
							UnlockCall(pOldCall);
						}
					}
				}
				MemFree(CallList);
			}

			if (pChannel->tsAccepted == TS_TRUE) {
				H245ConferenceCommandCallbackParams.hCall = hCall;
				H245ConferenceCommandCallbackParams.hChannel = hChannel;
				if (pCall->pPeerParticipantInfo == NULL) {
					H245ConferenceCommandCallbackParams.InitiatorTerminalLabel.bMCUNumber = 255;
					H245ConferenceCommandCallbackParams.InitiatorTerminalLabel.bTerminalNumber = 255;
				} else
					H245ConferenceCommandCallbackParams.InitiatorTerminalLabel =
						pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel;
				H245ConferenceCommandCallbackParams.CommandType =
					pH245ConfIndData->u.Indication.u.IndConferCmd.CommandType;
				H245ConferenceCommandCallbackParams.TerminalLabel.bMCUNumber =
					pH245ConfIndData->u.Indication.u.IndConferCmd.byMcuNumber;
				H245ConferenceCommandCallbackParams.TerminalLabel.bTerminalNumber =
					pH245ConfIndData->u.Indication.u.IndConferCmd.byTerminalNumber;
				status = InvokeUserConferenceCallback(pConference,
													  CC_H245_CONFERENCE_COMMAND_INDICATION,
													  CC_OK,
													  &H245ConferenceCommandCallbackParams);
				if (status != CC_OK)
					status = H245_ERROR_NOSUP;
			} else
				status = H245_ERROR_OK;

			if (ValidateChannel(hChannel) == CC_OK)
				UnlockChannel(pChannel);
			if (ValidateCall(hCall) == CC_OK)
				UnlockCall(pCall);
			if (ValidateConference(hConference) == CC_OK)
				UnlockConference(pConference);
			return status;

		default:
			// Unrecognized conference command
			// Pass it up to the client
			H245ConferenceCommandCallbackParams.hCall = hCall;
			if (pCall->pPeerParticipantInfo == NULL) {
				H245ConferenceCommandCallbackParams.InitiatorTerminalLabel.bMCUNumber = 255;
				H245ConferenceCommandCallbackParams.InitiatorTerminalLabel.bTerminalNumber = 255;
			} else
				H245ConferenceCommandCallbackParams.InitiatorTerminalLabel =
					pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel;
			H245ConferenceCommandCallbackParams.CommandType =
				pH245ConfIndData->u.Indication.u.IndConferCmd.CommandType;
			H245ConferenceCommandCallbackParams.TerminalLabel.bMCUNumber =
				pH245ConfIndData->u.Indication.u.IndConferCmd.byMcuNumber;
			H245ConferenceCommandCallbackParams.TerminalLabel.bTerminalNumber =
				pH245ConfIndData->u.Indication.u.IndConferCmd.byTerminalNumber;
			H245ConferenceCommandCallbackParams.hChannel = CC_INVALID_HANDLE;
			
			status = InvokeUserConferenceCallback(pConference,
												  CC_H245_CONFERENCE_COMMAND_INDICATION,
												  CC_OK,
												  &H245ConferenceCommandCallbackParams);
			if (status != CC_OK)
				status = H245_ERROR_NOSUP;
			if (ValidateCall(hCall) == CC_OK)
				UnlockCall(pCall);
			if (ValidateConference(hConference) == CC_OK)
				UnlockConference(pConference);
			return status;
	}

	if (ValidateCall(hCall) == CC_OK)
		UnlockCall(pCall);
	if (ValidateConference(hConference) == CC_OK)
		UnlockConference(pConference);
	return status;
}



HRESULT _IndConference(				H245_CONF_IND_T			*pH245ConfIndData)
{
CC_HCALL						hCall;
PCALL							pCall;
PCALL							pPeerCall;
PCONFERENCE						pConference;
CC_HCONFERENCE					hConference;
H245_TERMINAL_LABEL_T			H245TerminalLabel;
PPARTICIPANTINFO				pPeerParticipantInfo;
HRESULT							status;
CC_HCALL						hVirtualCall;
PCALL							pVirtualCall;
CC_PEER_ADD_CALLBACK_PARAMS		PeerAddCallbackParams;
CC_PEER_DROP_CALLBACK_PARAMS	PeerDropCallbackParams;
CC_H245_CONFERENCE_INDICATION_CALLBACK_PARAMS	H245ConferenceIndicationCallbackParams;


	hCall = pH245ConfIndData->u.Indication.dwPreserved;
	if (LockCallAndConference(hCall, &pCall, &pConference) != CC_OK)
		return H245_ERROR_OK;

	hConference = pConference->hConference;

	switch (pH245ConfIndData->u.Indication.u.IndConfer.IndicationType) {
		case H245_IND_TERMINAL_NUMBER_ASSIGN:
			if (pConference->tsMultipointController == TS_FALSE) {
				pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bMCUNumber =
					pH245ConfIndData->u.Indication.u.IndConfer.byMcuNumber;
				pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bTerminalNumber =
					pH245ConfIndData->u.Indication.u.IndConfer.byTerminalNumber;

                hConference = pConference->hConference;
                // Generate a CC_TERMINAL_NUMBER_ASSIGN callback
				InvokeUserConferenceCallback(pConference,
											 CC_TERMINAL_NUMBER_INDICATION,
											 CC_OK,
											 &pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel);

				if (ValidateConference(hConference) == CC_OK)
					UnlockConference(pConference);
				UnlockCall(pCall);
				
				return H245_ERROR_OK;
			}
			status = H245_ERROR_OK;
			break;

		case H245_IND_TERMINAL_JOINED:
			if (pConference->tsMultipointController == TS_FALSE) {
				if ((pH245ConfIndData->u.Indication.u.IndConfer.byMcuNumber ==
					 pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bMCUNumber) &&
					(pH245ConfIndData->u.Indication.u.IndConfer.byTerminalNumber ==
					 pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bTerminalNumber)) {
					// This message refers to us
					status = H245_ERROR_OK;
					break;
				}

				H245TerminalLabel.mcuNumber = pH245ConfIndData->u.Indication.u.IndConfer.byMcuNumber;
				H245TerminalLabel.terminalNumber = pH245ConfIndData->u.Indication.u.IndConfer.byTerminalNumber;
				FindPeerParticipantInfo(H245TerminalLabel,
										pConference,
										VIRTUAL_CALL,
										&pPeerCall);
				if (pPeerCall != NULL) {
					// We already know this peer's terminal label, and we
					// eithet know its terminal ID or we have a pending request
					// to obtain it
					UnlockCall(pPeerCall);
					status = H245_ERROR_OK;
					break;
				}

				// We don't know about this peer.
				// Create a virtual call object for it, and issue a request
				// for its terminal ID
				status = AllocAndLockCall(&hVirtualCall,
										  pConference->hConference,
										  CC_INVALID_HANDLE,	// hQ931Call
										  CC_INVALID_HANDLE,	// hQ931CallInvitor,
										  NULL,					// pLocalAliasNames,
										  NULL,					// pPeerAliasNames,
										  NULL,					// pPeerExtraAliasNames
										  NULL,					// pPeerExtension
										  NULL,					// pLocalNonStandardData,
										  NULL,					// pPeerNonStandardData,
										  NULL,					// pszLocalDisplay,
										  NULL,					// pszPeerDisplay,
										  NULL,					// pPeerVendorInfo,
										  NULL,					// pQ931LocalConnectAddr,
										  NULL,					// pQ931PeerConnectAddr,
										  NULL,					// pQ931DestinationAddr,
										  NULL,                 // pSourceCallSignalAddress
										  VIRTUAL,				// CallType,
										  FALSE,				// bCallerIsMC,
										  0,					// dwUserToken,
										  CALL_COMPLETE,		// InitialCallState,
										  NULL,                 // no CallIdentifier
										  &pConference->ConferenceID,
										  &pVirtualCall);
				if (status == CC_OK) {
					status = AllocatePeerParticipantInfo(NULL,
														 &pPeerParticipantInfo);
					if (status == CC_OK) {
						pVirtualCall->pPeerParticipantInfo =
							pPeerParticipantInfo;
						pPeerParticipantInfo->ParticipantInfo.TerminalLabel.bMCUNumber =
							(BYTE)H245TerminalLabel.mcuNumber;
						pPeerParticipantInfo->ParticipantInfo.TerminalLabel.bTerminalNumber =
							(BYTE)H245TerminalLabel.terminalNumber;
						AddVirtualCallToConference(pVirtualCall,
												   pConference);
						// Send RequestTerminalID
						H245ConferenceRequest(pCall->H245Instance,
										      H245_REQ_TERMINAL_ID,
										      (BYTE)H245TerminalLabel.mcuNumber,
											  (BYTE)H245TerminalLabel.terminalNumber);
						pPeerParticipantInfo->TerminalIDState = TERMINAL_ID_REQUESTED;

						// Generate PEER_ADD callback
						PeerAddCallbackParams.hCall = hVirtualCall;
						PeerAddCallbackParams.TerminalLabel =
							pVirtualCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel;
						PeerAddCallbackParams.pPeerTerminalID = NULL;
						InvokeUserConferenceCallback(pConference,
											 CC_PEER_ADD_INDICATION,
											 CC_OK,
											 &PeerAddCallbackParams);
						if (ValidateCall(hVirtualCall) == CC_OK)
	 						UnlockCall(pVirtualCall);
						if (ValidateConference(hConference) == CC_OK)
							UnlockConference(pConference);
						UnlockCall(pCall);
						return H245_ERROR_OK;
					} else
						FreeCall(pVirtualCall);
				}
			}
			status = H245_ERROR_OK;
			break;

		case H245_IND_TERMINAL_LEFT:
			if (pConference->tsMultipointController == TS_FALSE) {
				H245TerminalLabel.mcuNumber = pH245ConfIndData->u.Indication.u.IndConfer.byMcuNumber;
				H245TerminalLabel.terminalNumber = pH245ConfIndData->u.Indication.u.IndConfer.byTerminalNumber;
				
				status = FindPeerParticipantInfo(H245TerminalLabel,
												 pConference,
												 VIRTUAL_CALL,
												 &pVirtualCall);
				if (status == CC_OK) {
					ASSERT(pVirtualCall != NULL);
					ASSERT(pVirtualCall->pPeerParticipantInfo != NULL);
					// Save the virtual call handle; we'll need to validate the virtual
					// call object after returning from the conference callback
					hVirtualCall = pVirtualCall->hCall;
					PeerDropCallbackParams.hCall = hVirtualCall;
					PeerDropCallbackParams.TerminalLabel = pVirtualCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel;
					if (pVirtualCall->pPeerParticipantInfo->TerminalIDState == TERMINAL_ID_VALID)
						PeerDropCallbackParams.pPeerTerminalID = &pVirtualCall->pPeerParticipantInfo->ParticipantInfo.TerminalID;
					else
						PeerDropCallbackParams.pPeerTerminalID = NULL;
				} else {
					// Set pVirtualCall to NULL to indicate that we don't have
					// a virtual call object that needs to be free'd up later
					pVirtualCall = NULL;
					PeerDropCallbackParams.hCall = CC_INVALID_HANDLE;
					PeerDropCallbackParams.TerminalLabel.bMCUNumber = pH245ConfIndData->u.Indication.u.IndConfer.byMcuNumber;
					PeerDropCallbackParams.TerminalLabel.bTerminalNumber = pH245ConfIndData->u.Indication.u.IndConfer.byTerminalNumber;
					PeerDropCallbackParams.pPeerTerminalID = NULL;
				}

				hConference = pConference->hConference;

				// Generate a CC_PEER_DROP_INDICATION callback
				InvokeUserConferenceCallback(pConference,
											 CC_PEER_DROP_INDICATION,
											 CC_OK,
											 &PeerDropCallbackParams);
				if (ValidateConference(hConference) == CC_OK)
					UnlockConference(pConference);
				// Check to see if we have a virtual call object that needs to be free'd up
				if (pVirtualCall != NULL)
					if (ValidateCall(hVirtualCall) == CC_OK)
						FreeCall(pVirtualCall);
				UnlockCall(pCall);
				return H245_ERROR_OK;
			}
			status = H245_ERROR_OK;
			break;

		default:
			H245ConferenceIndicationCallbackParams.hCall = hCall;
			if (pCall->pPeerParticipantInfo == NULL) {
				H245ConferenceIndicationCallbackParams.InitiatorTerminalLabel.bMCUNumber = 255;
				H245ConferenceIndicationCallbackParams.InitiatorTerminalLabel.bTerminalNumber = 255;
			} else
				H245ConferenceIndicationCallbackParams.InitiatorTerminalLabel =
					pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel;
			H245ConferenceIndicationCallbackParams.IndicationType =
				pH245ConfIndData->u.Indication.u.IndConfer.IndicationType;
			H245ConferenceIndicationCallbackParams.bSBENumber =
				pH245ConfIndData->u.Indication.u.IndConfer.bySbeNumber;
			H245ConferenceIndicationCallbackParams.TerminalLabel.bMCUNumber =
				pH245ConfIndData->u.Indication.u.IndConfer.byMcuNumber;
			H245ConferenceIndicationCallbackParams.TerminalLabel.bTerminalNumber =
				pH245ConfIndData->u.Indication.u.IndConfer.byTerminalNumber;
			status = InvokeUserConferenceCallback(pConference,
												  CC_H245_CONFERENCE_INDICATION_INDICATION,
												  CC_OK,
												  &H245ConferenceIndicationCallbackParams);
			if (status != CC_OK)
				status = H245_ERROR_NOSUP;
			break;
	}
	if (ValidateCall(hCall) == CC_OK)
		UnlockCall(pCall);
	if (ValidateConference(hConference) == CC_OK)
		UnlockConference(pConference);
	return status;
}



HRESULT _IndCommunicationModeCommand(
									H245_CONF_IND_T			*pH245ConfIndData)
{
CC_HCALL						hCall;
PCALL							pCall;
CC_HCONFERENCE					hConference;
PCONFERENCE						pConference;
CC_MULTIPOINT_CALLBACK_PARAMS	MultipointCallbackParams;

	hCall = pH245ConfIndData->u.Indication.dwPreserved;
	if (LockCallAndConference(hCall, &pCall, &pConference) != CC_OK)
		return H245_ERROR_OK;

	if (pConference->tsMultipointController == TS_TRUE) {
		UnlockCall(pCall);
		UnlockConference(pConference);
		return H245_ERROR_OK;
	}

	hConference = pConference->hConference;

	// Destroy the old session table
	FreeConferenceSessionTable(pConference);

	H245CommunicationTableToSessionTable(
									pH245ConfIndData->u.Indication.u.IndCommRsp.pTable,
									pH245ConfIndData->u.Indication.u.IndCommRsp.byTableCount,
									&pConference->pSessionTable);
	
	pConference->bSessionTableInternallyConstructed = TRUE;

	// Generate MULTIPOINT callback
	MultipointCallbackParams.pTerminalInfo = &pConference->LocalParticipantInfo.ParticipantInfo;
	MultipointCallbackParams.pSessionTable = pConference->pSessionTable;
	InvokeUserConferenceCallback(pConference,
								 CC_MULTIPOINT_INDICATION,
								 CC_OK,
								 &MultipointCallbackParams);

	if (ValidateCall(hCall) == CC_OK)
		UnlockCall(pCall);
	if (ValidateConference(hConference) == CC_OK)
		UnlockConference(pConference);
	return H245_ERROR_OK;
}



HRESULT _IndVendorIdentification(	H245_CONF_IND_T			*pH245ConfIndData,
									VendorIdentification	*pVendorIdentification)
{
CC_HCALL						hCall;
PCALL							pCall;
CC_HCONFERENCE					hConference;
PCONFERENCE						pConference;
CC_NONSTANDARDDATA				NonStandardData;
CC_OCTETSTRING					ProductNumber;
CC_OCTETSTRING					VersionNumber;
CC_VENDOR_ID_CALLBACK_PARAMS	VendorIDCallbackParams;

	hCall = pH245ConfIndData->u.Indication.dwPreserved;
	if (LockCallAndConference(hCall, &pCall, &pConference) != CC_OK)
		return H245_ERROR_OK;

	hConference = pConference->hConference;

	VendorIDCallbackParams.hCall = hCall;
	if (pCall->pPeerParticipantInfo == NULL) {
		VendorIDCallbackParams.InitiatorTerminalLabel.bMCUNumber = 255;
		VendorIDCallbackParams.InitiatorTerminalLabel.bTerminalNumber = 255;
	} else
		VendorIDCallbackParams.InitiatorTerminalLabel =
			pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel;

	if (pVendorIdentification->vendor.choice == h221NonStandard_chosen) {
		NonStandardData.sData.pOctetString = NULL;
		NonStandardData.sData.wOctetStringLength = 0;
		NonStandardData.bCountryCode = (BYTE)pVendorIdentification->vendor.u.h221NonStandard.t35CountryCode;
		NonStandardData.bExtension = (BYTE)pVendorIdentification->vendor.u.h221NonStandard.t35Extension;
		NonStandardData.wManufacturerCode = pVendorIdentification->vendor.u.h221NonStandard.manufacturerCode;
		VendorIDCallbackParams.pNonStandardData = &NonStandardData;
	} else
		VendorIDCallbackParams.pNonStandardData = NULL;

	if (pVendorIdentification->bit_mask & productNumber_present) {
		ProductNumber.pOctetString =
			pVendorIdentification->productNumber.value;
		ProductNumber.wOctetStringLength = (WORD)
			pVendorIdentification->productNumber.length;
		VendorIDCallbackParams.pProductNumber = &ProductNumber;
	} else
		VendorIDCallbackParams.pProductNumber = NULL;
	if (pVendorIdentification->bit_mask & versionNumber_present) {
		VersionNumber.pOctetString =
			pVendorIdentification->versionNumber.value;
		VersionNumber.wOctetStringLength = (WORD)
			pVendorIdentification->versionNumber.length;
		VendorIDCallbackParams.pVersionNumber = &VersionNumber;
	} else
		VendorIDCallbackParams.pVersionNumber = NULL;

	InvokeUserConferenceCallback(pConference,
								 CC_VENDOR_ID_INDICATION,
								 CC_OK,
								 &VendorIDCallbackParams);
	if (ValidateCall(hCall) == CC_OK)
		UnlockCall(pCall);
	if (ValidateConference(hConference) == CC_OK)
		UnlockConference(pConference);
	return H245_ERROR_OK;
}



HRESULT _IndH2250MaximumSkew(		H245_CONF_IND_T			*pH245ConfIndData)
{
HRESULT			status;
CC_HCONFERENCE	hConference;
PCONFERENCE		pConference;
CC_HCALL		hCall;
PCC_HCALL		CallList;
WORD			wNumCalls;
WORD			i;
PCALL			pCall;
PCALL			pOldCall;
CC_HCHANNEL		hChannel1;
PCHANNEL		pChannel1;
CC_HCHANNEL		hChannel2;
PCHANNEL		pChannel2;
CC_MAXIMUM_AUDIO_VIDEO_SKEW_CALLBACK_PARAMS	MaximumAudioVideoSkewCallbackParams;

	hCall = pH245ConfIndData->u.Indication.dwPreserved;
	status = LockCallAndConference(hCall, &pCall, &pConference);
	if (status != CC_OK) {
		// This may be OK, if the call was cancelled while
		// call setup was in progress.
		return H245_ERROR_OK;
	}

	hConference = pCall->hConference;
	UnlockCall(pCall);

	if (FindChannelInConference(pH245ConfIndData->u.Indication.u.IndH2250MaxSkew.LogicalChannelNumber1,
		                        FALSE,	// remote channel number
								RX_CHANNEL | PROXY_CHANNEL,
								hCall,
		                        &hChannel1,
								pConference) != CC_OK) {
		UnlockConference(pConference);
		return H245_ERROR_OK;
	}

	if (LockChannel(hChannel1, &pChannel1) != CC_OK) {
		UnlockConference(pConference);
		return H245_ERROR_OK;
	}
	
	if (pChannel1->bChannelType == RX_CHANNEL) {
		UnlockChannel(pChannel1);
		if (FindChannelInConference(pH245ConfIndData->u.Indication.u.IndH2250MaxSkew.LogicalChannelNumber2,
		                        FALSE,	// remote channel number
								RX_CHANNEL,
								hCall,
		                        &hChannel2,
								pConference) != CC_OK) {
			UnlockConference(pConference);
			return H245_ERROR_OK;
		}
		if (LockChannel(hChannel2, &pChannel2) != CC_OK) {
			UnlockConference(pConference);
			return H245_ERROR_OK;
		}
		if (pChannel2->bChannelType != RX_CHANNEL) {
			UnlockChannel(pChannel2);
			UnlockConference(pConference);
			return H245_ERROR_OK;
		}
		UnlockChannel(pChannel2);

		MaximumAudioVideoSkewCallbackParams.hChannel1 = hChannel1;
		MaximumAudioVideoSkewCallbackParams.hChannel2 = hChannel2;
		MaximumAudioVideoSkewCallbackParams.wMaximumSkew =
			pH245ConfIndData->u.Indication.u.IndH2250MaxSkew.wSkew;
		InvokeUserConferenceCallback(pConference,
									 CC_MAXIMUM_AUDIO_VIDEO_SKEW_INDICATION,
									 CC_OK,
									 &MaximumAudioVideoSkewCallbackParams);
		if (ValidateConference(hConference) == CC_OK)
			UnlockConference(pConference);
	} else { // pChannel1->bChannelType == PROXY_CHANNEL
		if (FindChannelInConference(pH245ConfIndData->u.Indication.u.IndH2250MaxSkew.LogicalChannelNumber2,
									FALSE,	// remote channel number
									PROXY_CHANNEL,
									hCall,
									&hChannel2,
									pConference) != CC_OK) {
			UnlockChannel(pChannel1);
			UnlockConference(pConference);
			return H245_ERROR_OK;
		}
		if (LockChannel(hChannel2, &pChannel2) != CC_OK) {
			UnlockChannel(pChannel1);
			UnlockConference(pConference);
			return H245_ERROR_OK;
		}
		if (pChannel1->hCall != pChannel2->hCall) {
			UnlockChannel(pChannel1);
			UnlockChannel(pChannel2);
			UnlockConference(pConference);
			return H245_ERROR_OK;
		}

		EnumerateCallsInConference(&wNumCalls, &CallList, pConference, ESTABLISHED_CALL);
		for (i = 0; i < wNumCalls; i++) {
			if (CallList[i] != hCall) {
				if (LockCall(CallList[i], &pOldCall) == CC_OK) {
 					H245H2250MaximumSkewIndication(pOldCall->H245Instance,
											pChannel1->wLocalChannelNumber,
											pChannel2->wLocalChannelNumber,
											pH245ConfIndData->u.Indication.u.IndH2250MaxSkew.wSkew);
					UnlockCall(pCall);
				}
			}
		}

		if (CallList != NULL)
			MemFree(CallList);

		if ((pChannel1->tsAccepted == TS_TRUE) && (pChannel2->tsAccepted == TS_TRUE)) {
 			MaximumAudioVideoSkewCallbackParams.hChannel1 = hChannel1;
			MaximumAudioVideoSkewCallbackParams.hChannel2 = hChannel2;
			MaximumAudioVideoSkewCallbackParams.wMaximumSkew =
				pH245ConfIndData->u.Indication.u.IndH2250MaxSkew.wSkew;
			InvokeUserConferenceCallback(pConference,
										 CC_MAXIMUM_AUDIO_VIDEO_SKEW_INDICATION,
										 CC_OK,
										 &MaximumAudioVideoSkewCallbackParams);
		}

		if (ValidateChannel(hChannel1) == CC_OK)
			UnlockChannel(pChannel1);
		if (ValidateChannel(hChannel2) == CC_OK)
			UnlockChannel(pChannel2);
		if (ValidateConference(hConference) == CC_OK)
			UnlockConference(pConference);
	}
	return H245_ERROR_OK;
}



HRESULT _IndUserInput(				H245_CONF_IND_T			*pH245ConfIndData)
{
	return H245_ERROR_OK;
}



HRESULT _IndSendTerminalCapabilitySet(
									H245_CONF_IND_T			*pH245ConfIndData)
{
HRESULT			status;
CC_HCALL		hCall;
PCALL			pCall;
PCONFERENCE		pConference;

	hCall = pH245ConfIndData->u.Indication.dwPreserved;
	status = LockCallAndConference(hCall, &pCall, &pConference);
	if (status != CC_OK) {
		// This may be OK, if the call was cancelled while
		// call setup was in progress.
		return H245_ERROR_OK;
	}

	SendTermCaps(pCall, pConference);
	UnlockCall(pCall);
	UnlockConference(pConference);
	return H245_ERROR_OK;
}



HRESULT _IndModeRequest(			H245_CONF_IND_T			*pH245ConfIndData)
{
HRESULT			status;
CC_HCALL		hCall;
PCALL			pCall;
CC_HCONFERENCE	hConference;
PCONFERENCE		pConference;
CC_REQUEST_MODE_CALLBACK_PARAMS	RequestModeCallbackParams;

	hCall = pH245ConfIndData->u.Indication.dwPreserved;
	status = LockCallAndConference(hCall, &pCall, &pConference);
	if (status != CC_OK) {
		// This may be OK, if the call was cancelled while
		// call setup was in progress.
		return H245_ERROR_OK;
	}

	hConference = pConference->hConference;

    EnqueueRequest(&pConference->pEnqueuedRequestModeCalls, hCall);

	RequestModeCallbackParams.hCall = hCall;
	if (pCall->pPeerParticipantInfo == NULL) {
		RequestModeCallbackParams.InitiatorTerminalLabel.bMCUNumber = 255;
		RequestModeCallbackParams.InitiatorTerminalLabel.bTerminalNumber = 255;
	} else
		RequestModeCallbackParams.InitiatorTerminalLabel =
			pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel;
	RequestModeCallbackParams.pRequestedModes =
		pH245ConfIndData->u.Indication.u.IndMrse.pRequestedModes;

	InvokeUserConferenceCallback(pConference,
								 CC_REQUEST_MODE_INDICATION,
								 CC_OK,
								 &RequestModeCallbackParams);
	if (ValidateCall(hCall) == CC_OK)
		UnlockCall(pCall);
	if (ValidateConference(hConference) == CC_OK)
		UnlockConference(pConference);
	return H245_ERROR_OK;
}



HRESULT _ConfUnimplemented(			H245_CONF_IND_T			*pH245ConfIndData)
{
	return H245_ERROR_NOSUP;
}



HRESULT _ConfBiDirectionalOpen(		H245_CONF_IND_T			*pH245ConfIndData)
{
CC_HCALL			hCall;
CC_HCHANNEL			hChannel;
CC_HCONFERENCE		hConference;
PCHANNEL			pChannel;
PCONFERENCE			pConference;
BOOL				bAccept;
HRESULT				status;
CC_ADDR				T120Addr;
CC_OCTETSTRING		ExternalReference;
CC_T120_CHANNEL_OPEN_CALLBACK_PARAMS	T120ChannelOpenCallbackParams;

	hCall = pH245ConfIndData->u.Confirm.dwPreserved;
	if (hCall == CC_INVALID_HANDLE)
		return H245_ERROR_OK;

	hChannel = pH245ConfIndData->u.Confirm.dwTransId;
	if (hChannel == CC_INVALID_HANDLE)
		return H245_ERROR_OK;

	if (LockChannelAndConference(hChannel, &pChannel, &pConference) != CC_OK)
		return H245_ERROR_OK;

	hConference = pConference->hConference;

	if (pChannel->bChannelType != TXRX_CHANNEL) {
		UnlockChannel(pChannel);
		UnlockConference(pConference);
		return H245_ERROR_OK;
	}

	if ((pH245ConfIndData->u.Confirm.u.ConfOpenNeedRsp.AccRej == H245_ACC) &&
	    (pH245ConfIndData->u.Confirm.Error == H245_ERROR_OK)) {
		pChannel->wNumOutstandingRequests = 0;
		bAccept = TRUE;
	} else {
		(pChannel->wNumOutstandingRequests)--;
		bAccept = FALSE;
	}

	T120ChannelOpenCallbackParams.hChannel = hChannel;
	T120ChannelOpenCallbackParams.hCall = hCall;
	T120ChannelOpenCallbackParams.dwUserToken = pChannel->dwUserToken;
	T120ChannelOpenCallbackParams.dwRejectReason = 0;

	if (bAccept) {
		status = CC_OK;
		if (pH245ConfIndData->u.Confirm.u.ConfOpenNeedRsp.pSeparateStack) {
			if ((pH245ConfIndData->u.Confirm.u.ConfOpenNeedRsp.pSeparateStack->networkAddress.choice == localAreaAddress_chosen) &&
				(pH245ConfIndData->u.Confirm.u.ConfOpenNeedRsp.pSeparateStack->networkAddress.u.localAreaAddress.choice == unicastAddress_chosen) &&
				(pH245ConfIndData->u.Confirm.u.ConfOpenNeedRsp.pSeparateStack->networkAddress.u.localAreaAddress.u.unicastAddress.choice == UnicastAddress_iPAddress_chosen)) {
				T120Addr.nAddrType = CC_IP_BINARY;
				T120Addr.bMulticast = FALSE;
				T120Addr.Addr.IP_Binary.wPort =
					pH245ConfIndData->u.Confirm.u.ConfOpenNeedRsp.pSeparateStack->networkAddress.u.localAreaAddress.u.unicastAddress.u.UnicastAddress_iPAddress.tsapIdentifier;
				H245IPNetworkToHost(&T120Addr.Addr.IP_Binary.dwAddr,
									pH245ConfIndData->u.Confirm.u.ConfOpenNeedRsp.pSeparateStack->networkAddress.u.localAreaAddress.u.unicastAddress.u.UnicastAddress_iPAddress.network.value);
				T120ChannelOpenCallbackParams.pAddr = &T120Addr;
			} else {
 				T120ChannelOpenCallbackParams.pAddr = NULL;
			}
			T120ChannelOpenCallbackParams.bAssociateConference =
				pH245ConfIndData->u.Confirm.u.ConfOpenNeedRsp.pSeparateStack->associateConference;		
			if (pH245ConfIndData->u.Confirm.u.ConfOpenNeedRsp.pSeparateStack->bit_mask & externalReference_present) {
				ExternalReference.wOctetStringLength = (WORD)
					pH245ConfIndData->u.Confirm.u.ConfOpenNeedRsp.pSeparateStack->externalReference.length;
				ExternalReference.pOctetString =
					pH245ConfIndData->u.Confirm.u.ConfOpenNeedRsp.pSeparateStack->externalReference.value;
				T120ChannelOpenCallbackParams.pExternalReference = &ExternalReference;
			} else
				T120ChannelOpenCallbackParams.pExternalReference = NULL;
		} else {
 			T120ChannelOpenCallbackParams.pAddr = NULL;
			T120ChannelOpenCallbackParams.bAssociateConference = FALSE;
			T120ChannelOpenCallbackParams.pExternalReference = NULL;
		}
	} else { // bAccept == FALSE
		if (pH245ConfIndData->u.Confirm.Error == H245_ERROR_OK)
			status = CC_PEER_REJECT;
		else
			status = pH245ConfIndData->u.Confirm.Error;
	 		
		T120ChannelOpenCallbackParams.pAddr = NULL;
		T120ChannelOpenCallbackParams.bAssociateConference = FALSE;
		T120ChannelOpenCallbackParams.pExternalReference = NULL;
		T120ChannelOpenCallbackParams.dwRejectReason =
			pH245ConfIndData->u.Confirm.u.ConfOpenNeedRsp.AccRej;
	}

	InvokeUserConferenceCallback(pConference,
								 CC_T120_CHANNEL_OPEN_INDICATION,
								 status,
								 &T120ChannelOpenCallbackParams);

	if (ValidateChannel(hChannel) == CC_OK)
		if (bAccept)
			UnlockChannel(pChannel);
		else
			FreeChannel(pChannel);
	if (ValidateConference(hConference) == CC_OK)
		UnlockConference(pConference);

	return H245_ERROR_OK;
}



HRESULT _ConfOpenT120(	H245_CONF_IND_T			*pH245ConfIndData)
{
CC_HCALL			hCall;
CC_HCHANNEL			hChannel;
CC_HCONFERENCE		hConference;
PCHANNEL			pChannel;
PCONFERENCE			pConference;
HRESULT				status;
CC_T120_CHANNEL_OPEN_CALLBACK_PARAMS	T120ChannelOpenCallbackParams;

	hCall = pH245ConfIndData->u.Confirm.dwPreserved;
	if (hCall == CC_INVALID_HANDLE)
		return H245_ERROR_OK;

	hChannel = pH245ConfIndData->u.Confirm.dwTransId;
	if (hChannel == CC_INVALID_HANDLE)
		return H245_ERROR_OK;

	if (LockChannelAndConference(hChannel, &pChannel, &pConference) != CC_OK)
		return H245_ERROR_OK;

	hConference = pConference->hConference;

	if (pChannel->bChannelType != TXRX_CHANNEL) {
		UnlockChannel(pChannel);
		UnlockConference(pConference);
		return H245_ERROR_OK;
	}

	if ((pH245ConfIndData->u.Confirm.u.ConfOpen.AccRej == H245_ACC) &&
	    (pH245ConfIndData->u.Confirm.Error == H245_ERROR_OK)) {
		// We expect to get a ConfOpenNeedRsp callback for this case;
		// Since we're not sure how we got here, just bail out
		UnlockChannel(pChannel);
		UnlockConference(pConference);
		return H245_ERROR_OK;
	}

	T120ChannelOpenCallbackParams.hChannel = hChannel;
	T120ChannelOpenCallbackParams.hCall = hCall;
	T120ChannelOpenCallbackParams.dwUserToken = pChannel->dwUserToken;

	if (pH245ConfIndData->u.Confirm.Error == H245_ERROR_OK)
		status = CC_PEER_REJECT;
	else
		status = pH245ConfIndData->u.Confirm.Error;
	 		
	T120ChannelOpenCallbackParams.pAddr = NULL;
	T120ChannelOpenCallbackParams.bAssociateConference = FALSE;
	T120ChannelOpenCallbackParams.pExternalReference = NULL;
	T120ChannelOpenCallbackParams.dwRejectReason =
		pH245ConfIndData->u.Confirm.u.ConfOpenNeedRsp.AccRej;

	InvokeUserConferenceCallback(pConference,
								 CC_T120_CHANNEL_OPEN_INDICATION,
								 status,
								 &T120ChannelOpenCallbackParams);

	if (ValidateChannel(hChannel) == CC_OK)
		FreeChannel(pChannel);
	if (ValidateConference(hConference) == CC_OK)
		UnlockConference(pConference);

	return H245_ERROR_OK;
}



HRESULT _ConfOpen(					H245_CONF_IND_T			*pH245ConfIndData)
{
HRESULT								status;
CC_ADDR								PeerRTPAddr;
PCC_ADDR							pPeerRTPAddr;
CC_ADDR								PeerRTCPAddr;
PCC_ADDR							pPeerRTCPAddr;
CC_HCHANNEL							hChannel;
PCHANNEL							pChannel;
CC_HCONFERENCE						hConference;
PCONFERENCE							pConference;
CC_TX_CHANNEL_OPEN_CALLBACK_PARAMS	TxChannelOpenCallbackParams;
PCALL								pCall;
BOOL								bAccept;
H245_MUX_T							H245MuxTable;
WORD								i;
#ifdef    GATEKEEPER
unsigned                            uBandwidth;
WORD								wNumCalls;
PCC_HCALL							CallList;
#endif // GATEKEEPER

	// a channel was opened

	hChannel = pH245ConfIndData->u.Confirm.dwTransId;
	if (hChannel == CC_INVALID_HANDLE)
		return H245_ERROR_OK;

	if (LockChannelAndConference(hChannel, &pChannel, &pConference) != CC_OK)
		return H245_ERROR_OK;

	if (pChannel->bChannelType == TXRX_CHANNEL) {
		UnlockChannel(pChannel);
		UnlockConference(pConference);
		return _ConfOpenT120(pH245ConfIndData);
	}

	hConference = pConference->hConference;

	if (pChannel->wNumOutstandingRequests == 0) {
		UnlockChannel(pChannel);
		UnlockConference(pConference);
		return H245_ERROR_OK;
	}

	if ((pH245ConfIndData->u.Confirm.u.ConfOpen.AccRej == H245_ACC) &&
	    (pH245ConfIndData->u.Confirm.Error == H245_ERROR_OK)) {
		pChannel->wNumOutstandingRequests = 0;
		bAccept = TRUE;
	} else {
		(pChannel->wNumOutstandingRequests)--;
		bAccept = FALSE;
#ifdef    GATEKEEPER
        if(GKIExists())
        {
    		uBandwidth = pChannel->dwChannelBitRate / 100;
    	    if (uBandwidth != 0 && pChannel->bChannelType != TXRX_CHANNEL)
    	    {
    	        EnumerateCallsInConference(&wNumCalls, &CallList, pConference, ESTABLISHED_CALL);
    		    for (i = 0; i < wNumCalls; ++i)
    		    {
    			    if (LockCall(CallList[i], &pCall) == CC_OK)
    			    {
    				    if (pCall->GkiCall.uBandwidthUsed >= uBandwidth)
    				    {
    					    if (GkiCloseChannel(&pCall->GkiCall, pChannel->dwChannelBitRate, hChannel) == CC_OK)
    					    {
    						    UnlockCall(pCall);
    						    break;
    					    }
    				    }
    				    UnlockCall(pCall);
    			    }
    		    } // for
    	        if (CallList != NULL)
    	            MemFree(CallList);
    	    }
	    }
#endif // GATEKEEPER

	}
	
	if (pChannel->wNumOutstandingRequests == 0) {

		if (pH245ConfIndData->u.Confirm.u.ConfOpen.pTxMux == NULL) {
			pPeerRTPAddr = NULL;
			pPeerRTCPAddr = NULL;
		} else {
			ASSERT(pH245ConfIndData->u.Confirm.u.ConfOpen.pTxMux->Kind == H245_H2250ACK);
			if ((pH245ConfIndData->u.Confirm.u.ConfOpen.pTxMux->u.H2250ACK.mediaChannelPresent) &&
				((pH245ConfIndData->u.Confirm.u.ConfOpen.pTxMux->u.H2250ACK.mediaChannel.type == H245_IP_MULTICAST) ||
				(pH245ConfIndData->u.Confirm.u.ConfOpen.pTxMux->u.H2250ACK.mediaChannel.type == H245_IP_UNICAST))) {
				
				pPeerRTPAddr = &PeerRTPAddr;
				PeerRTPAddr.nAddrType = CC_IP_BINARY;
				if (pH245ConfIndData->u.Confirm.u.ConfOpen.pTxMux->u.H2250ACK.mediaChannel.type == H245_IP_MULTICAST)
					PeerRTPAddr.bMulticast = TRUE;
				else
					PeerRTPAddr.bMulticast = FALSE;
				H245IPNetworkToHost(&PeerRTPAddr.Addr.IP_Binary.dwAddr,
									pH245ConfIndData->u.Confirm.u.ConfOpen.pTxMux->u.H2250ACK.mediaChannel.u.ip.network);
				PeerRTPAddr.Addr.IP_Binary.wPort =
					pH245ConfIndData->u.Confirm.u.ConfOpen.pTxMux->u.H2250ACK.mediaChannel.u.ip.tsapIdentifier;
			} else
				pPeerRTPAddr = NULL;

			if ((pH245ConfIndData->u.Confirm.u.ConfOpen.pTxMux->u.H2250ACK.mediaControlChannelPresent) &&
				((pH245ConfIndData->u.Confirm.u.ConfOpen.pTxMux->u.H2250ACK.mediaControlChannel.type == H245_IP_MULTICAST) ||
				(pH245ConfIndData->u.Confirm.u.ConfOpen.pTxMux->u.H2250ACK.mediaControlChannel.type == H245_IP_UNICAST))) {
				
				pPeerRTCPAddr = &PeerRTCPAddr;
				PeerRTCPAddr.nAddrType = CC_IP_BINARY;
				if (pH245ConfIndData->u.Confirm.u.ConfOpen.pTxMux->u.H2250ACK.mediaControlChannel.type == H245_IP_MULTICAST)
					PeerRTCPAddr.bMulticast = TRUE;
				else
					PeerRTCPAddr.bMulticast = FALSE;
				H245IPNetworkToHost(&PeerRTCPAddr.Addr.IP_Binary.dwAddr,
									pH245ConfIndData->u.Confirm.u.ConfOpen.pTxMux->u.H2250ACK.mediaControlChannel.u.ip.network);
				PeerRTCPAddr.Addr.IP_Binary.wPort =
					pH245ConfIndData->u.Confirm.u.ConfOpen.pTxMux->u.H2250ACK.mediaControlChannel.u.ip.tsapIdentifier;
			} else
				pPeerRTCPAddr = NULL;
		}

		if ((pPeerRTPAddr == NULL) || (pPeerRTCPAddr == NULL)) {
			if (pConference->pSessionTable != NULL) {
				for (i = 0; i < pConference->pSessionTable->wLength; i++) {
					if (pConference->pSessionTable->SessionInfoArray[i].bSessionID ==
						pChannel->bSessionID) {
						if (pPeerRTPAddr == NULL)
							pPeerRTPAddr = pConference->pSessionTable->SessionInfoArray[i].pRTPAddr;
						if (pPeerRTCPAddr == NULL)
							pPeerRTCPAddr = pConference->pSessionTable->SessionInfoArray[i].pRTCPAddr;
						break;
					}
				}
			}
		}

		if ((pChannel->pPeerRTPAddr == NULL) && (pPeerRTPAddr != NULL))
			CopyAddr(&pChannel->pPeerRTPAddr, pPeerRTPAddr);
		if ((pChannel->pPeerRTCPAddr == NULL) && (pPeerRTCPAddr != NULL))
			CopyAddr(&pChannel->pPeerRTCPAddr, pPeerRTCPAddr);

		if (pChannel->bChannelType == PROXY_CHANNEL) {
			if (LockCall(pChannel->hCall, &pCall) == CC_OK) {
	
				if (bAccept) {
					H245MuxTable.Kind = H245_H2250ACK;
					H245MuxTable.u.H2250ACK.nonStandardList = NULL;

					if (pPeerRTPAddr != NULL) {
						if (pPeerRTPAddr->bMulticast)
							H245MuxTable.u.H2250ACK.mediaChannel.type = H245_IP_MULTICAST;
						else
							H245MuxTable.u.H2250ACK.mediaChannel.type = H245_IP_UNICAST;
						H245MuxTable.u.H2250ACK.mediaChannel.u.ip.tsapIdentifier =
							pPeerRTPAddr->Addr.IP_Binary.wPort;
						HostToH245IPNetwork(H245MuxTable.u.H2250ACK.mediaChannel.u.ip.network,
											pPeerRTPAddr->Addr.IP_Binary.dwAddr);
						H245MuxTable.u.H2250ACK.mediaChannelPresent = TRUE;
					} else
						H245MuxTable.u.H2250ACK.mediaChannelPresent = FALSE;

					if (pPeerRTCPAddr != NULL) {
						if (pPeerRTCPAddr->bMulticast)
							H245MuxTable.u.H2250ACK.mediaControlChannel.type = H245_IP_MULTICAST;
						else
							H245MuxTable.u.H2250ACK.mediaControlChannel.type = H245_IP_UNICAST;
						H245MuxTable.u.H2250ACK.mediaControlChannel.u.ip.tsapIdentifier =
							pPeerRTCPAddr->Addr.IP_Binary.wPort;
						HostToH245IPNetwork(H245MuxTable.u.H2250ACK.mediaControlChannel.u.ip.network,
											pPeerRTCPAddr->Addr.IP_Binary.dwAddr);
						H245MuxTable.u.H2250ACK.mediaControlChannelPresent = TRUE;
					} else
						H245MuxTable.u.H2250ACK.mediaControlChannelPresent = FALSE;

					H245MuxTable.u.H2250ACK.dynamicRTPPayloadTypePresent = FALSE;
					H245MuxTable.u.H2250ACK.sessionIDPresent = TRUE;
					H245MuxTable.u.H2250ACK.sessionID = pChannel->bSessionID;
					
					status = H245OpenChannelAccept(pCall->H245Instance,
												   0,					// dwTransId
												   pChannel->wRemoteChannelNumber, // Rx channel
												   &H245MuxTable,
												   0,						// Tx channel
												   NULL,					// Tx mux
												   H245_INVALID_PORT_NUMBER,// Port
												   NULL);
				} else { // bAccept == FALSE
					status = H245OpenChannelReject(pCall->H245Instance,
												   pChannel->wRemoteChannelNumber,  // Rx channel
												   (unsigned short)pH245ConfIndData->u.Confirm.u.ConfOpen.AccRej);	// rejection reason
				}
				UnlockCall(pCall);
			}
		}

		TxChannelOpenCallbackParams.hChannel = hChannel;
		TxChannelOpenCallbackParams.pPeerRTPAddr = pPeerRTPAddr;
		TxChannelOpenCallbackParams.pPeerRTCPAddr = pPeerRTCPAddr;
		TxChannelOpenCallbackParams.dwUserToken = pChannel->dwUserToken;

		if (bAccept) {
			status = CC_OK;
			TxChannelOpenCallbackParams.dwRejectReason = H245_ACC;
		} else { // bAccept = FALSE
			if (pH245ConfIndData->u.Confirm.Error == H245_ERROR_OK)
				status = CC_PEER_REJECT;
			else
				status = pH245ConfIndData->u.Confirm.Error;
			TxChannelOpenCallbackParams.dwRejectReason =
				pH245ConfIndData->u.Confirm.u.ConfOpen.AccRej;
		}

		if ((pChannel->bCallbackInvoked == FALSE) &&
		    ((pChannel->bChannelType == TX_CHANNEL) ||
			 ((pChannel->bChannelType == TXRX_CHANNEL) &&
			  (pChannel->bLocallyOpened == TRUE)))) {
			pChannel->bCallbackInvoked = TRUE;

			InvokeUserConferenceCallback(pConference,
										 CC_TX_CHANNEL_OPEN_INDICATION,
										 status,
										 &TxChannelOpenCallbackParams);
		}

		if (ValidateChannel(hChannel) == CC_OK)
			if (bAccept)
				UnlockChannel(pChannel);
			else
				FreeChannel(pChannel);
	} else
		UnlockChannel(pChannel);

	if (ValidateConference(hConference) == CC_OK)
		UnlockConference(pConference);
	return H245_ERROR_OK;
}



HRESULT _ConfClose(					H245_CONF_IND_T			*pH245ConfIndData)
{

CC_HCALL							hCall;
CC_HCHANNEL							hChannel;
PCHANNEL							pChannel;
CC_HCONFERENCE						hConference;
PCONFERENCE							pConference;
PCALL								pCall;
H245_ACC_REJ_T						AccRej;

	hCall = pH245ConfIndData->u.Confirm.dwPreserved;
	if (LockCallAndConference(hCall, &pCall, &pConference) != CC_OK)
		return H245_ERROR_OK;

	hConference = pCall->hConference;
	UnlockCall(pCall);

    if (pH245ConfIndData->u.Confirm.Error != H245_ERROR_OK)
    {
        // TBD - Report error to Call Control client
        // but wait! CC_CloseChannel() is a synchronous API!  Until/unless that
        // changes, the buck stops here.

        if (FindChannelInConference(pH245ConfIndData->u.Confirm.u.ConfReqClose.Channel,
			TRUE,	// local channel number
			TX_CHANNEL | PROXY_CHANNEL,
			hCall,
			&hChannel,
			pConference) != CC_OK)
	    {
    		UnlockConference(pConference);
	        return H245_ERROR_OK;
    	}
   		if (LockChannel(hChannel, &pChannel) != CC_OK)
   		{
    		UnlockConference(pConference);
    		return H245_ERROR_OK;
        }
        // NOTE STOPGAP MEASURE : short term intentional "leak" of channel number.
        // The channel number is actually a bit in a per-conference bitmap, so there
        // is no real memory leak.

        // This case is rare. The most likely error that leads here is a timeout.

        // Calling FreeChannel() will normally recycle the logical channel
        // number, and a new channel could reuse this number very quickly. If the error
        // is a timeout, chances are that a late CloseLogicalChannelAck is on its
        // way up the wire. We don't want that late CloseLogicalChannelAck to be
        // associated with a completely new unrelated channel.

        // set channel number to zero so that FreeChannel() does not recycle the number
        pChannel->wLocalChannelNumber = 0;

        FreeChannel(pChannel);
        UnlockConference(pConference);

    }
    else
    {
        if(pH245ConfIndData->u.Confirm.u.ConfClose.AccRej == H245_ACC)
        {
            if (FindChannelInConference(pH245ConfIndData->u.Confirm.u.ConfReqClose.Channel,
				TRUE,	// local channel number
    			TX_CHANNEL | PROXY_CHANNEL,
				hCall,
				&hChannel,
				pConference) != CC_OK)
		    {
        		UnlockConference(pConference);
		        return H245_ERROR_OK;
        	}
       		if (LockChannel(hChannel, &pChannel) != CC_OK)
       		{
        		UnlockConference(pConference);
        		return H245_ERROR_OK;
	        }
            FreeChannel(pChannel);
            UnlockConference(pConference);
        }
        else
        {
            // At the time the ASSERT(0) was added here, the path that leads here
            // always set pH245ConfIndData->u.Confirm.u.ConfClose.AccRej = H245_ACC
            // at the same point it set ConfInd.u.Confirm.Error = H245_ERROR_OK;
            // if that is ever changed, this also needs to change.
            // see ..\h245\src\api_up.c, function H245FsmConfirm(), case  H245_CONF_CLOSE:
            ASSERT(0);
        }

    }
	return H245_ERROR_OK;
}



HRESULT _ConfRequestClose(			H245_CONF_IND_T			*pH245ConfIndData)
{
CC_HCALL							hCall;
CC_HCHANNEL							hChannel;
PCHANNEL							pChannel;
CC_HCONFERENCE						hConference;
PCONFERENCE							pConference;
PCALL								pCall;
H245_ACC_REJ_T						AccRej;

	hCall = pH245ConfIndData->u.Confirm.dwPreserved;
	if (LockCallAndConference(hCall, &pCall, &pConference) != CC_OK)
		return H245_ERROR_OK;

	hConference = pCall->hConference;
	UnlockCall(pCall);

    if (pH245ConfIndData->u.Confirm.Error == H245_ERROR_OK)
	    AccRej = pH245ConfIndData->u.Confirm.u.ConfReqClose.AccRej;
    else
        AccRej = H245_REJ;

	// Note: the only time we need to take any real action is when the channel
	// is a proxy channel, and the local endpoint is not the one which requested
	// the channel closure; in this case, we simply forward the closure response
	// on to the endpoint which initiated the request.
	// If the channel is an RX or TXRX channel, the channel object was deleted
	// when our client requested the channel closure, so there's no real work to
	// be done.
	// If the channel is a proxy channel which our client requested be closed,
	// the channel object will remain around until closed by the TX side, but we
	// don't need (nor do we have a mechanism) to inform our client of receipt
	// of this channel closure response.
	
	if (FindChannelInConference(pH245ConfIndData->u.Confirm.u.ConfReqClose.Channel,
								FALSE,	// remote channel number
								PROXY_CHANNEL,
								hCall,
								&hChannel,
								pConference) != CC_OK) {
		UnlockConference(pConference);
		return H245_ERROR_OK;
	}

	// Set hCall to the peer which initiated the close channel request
	hCall = pH245ConfIndData->u.Confirm.dwTransId;
	if (hCall == CC_INVALID_HANDLE) {
		// The local endpoint was the one who requested the channel closure,
		// so there's no one to forwards this response onto. We don't provide
		// a callback for informing our client of receipt of this response,
		// so we can simply clean up and return
		UnlockConference(pConference);
		return H245_ERROR_OK;
	}

	if (LockChannel(hChannel, &pChannel) != CC_OK) {
		UnlockConference(pConference);
		return H245_ERROR_OK;
	}

	// Forward this response onto the endpoint which requested the channel closure
	if (LockCall(hCall, &pCall) == CC_OK) {
		H245CloseChannelReqResp(pCall->H245Instance,
								AccRej,
								pChannel->wLocalChannelNumber);
		UnlockCall(pCall);
	}

	UnlockChannel(pChannel);
	UnlockConference(pConference);
	return H245_ERROR_OK;
}



#if 0

HRESULT _ConfShutdown(				H245_CONF_IND_T			*pH245ConfIndData)
{
CC_HCALL				hCall;
PCALL					pCall;
CC_HCONFERENCE			hConference;
PCONFERENCE				pConference;
HRESULT					status;
HQ931CALL				hQ931Call;
H245_INST_T				H245Instance;

#if 1
// Sync 2 - specific code

	hCall = pH245ConfIndData->u.Confirm.dwPreserved;
	if (LockCallAndConference(hCall, &pCall, &pConference) != CC_OK)
		return H245_ERROR_OK;

	hConference = pCall->hConference;

	if (pConference->tsMultipointController == TS_TRUE) {
		// XXX -- invoke user callback with "peer drop indication"
	} else {
		H245Instance = pCall->H245Instance;
		hQ931Call = pCall->hQ931Call;
		FreeCall(pCall);

		if (H245Instance != H245_INVALID_ID)
			status = H245ShutDown(H245Instance);
		else
			status = H245_ERROR_OK;

		if (status == H245_ERROR_OK) {
			status = Q931Hangup(hQ931Call, CC_REJECT_UNDEFINED_REASON);
			// Q931Hangup may legitimately return CS_BAD_PARAM, because the Q.931 call object
			// may have been deleted at this point
			if (status == CS_BAD_PARAM)
				status = CC_OK;
		} else
			Q931Hangup(hQ931Call, CC_REJECT_UNDEFINED_REASON);

		InvokeUserConferenceCallback(pConference,
			                         CC_CONFERENCE_TERMINATION_INDICATION,
									 status,
									 NULL);

		if (ValidateConference(hConference) == CC_OK)
			UnlockConference(pConference);

		return H245_ERROR_OK;
	}
#else
// Probably sync 3 code
HHANGUP						hHangup;
PHANGUP						pHangup;
CC_HANGUP_CALLBACK_PARAMS	HangupCallbackParams;

	hHangup = pH245ConfIndData->u.Confirm.dwTransId;
	if (hHangup == CC_INVALID_HANDLE)
		return H245_ERROR_OK;

	if (LockHangup(hHangup, &pHangup) != CC_OK)
		return H245_ERROR_OK;

	pHangup->wNumCalls--;
	if (pHangup->wNumCalls == 0) {
		hConference = pHangup->hConference;
		if (LockConference(hConference, &pConference) != CC_OK) {
			UnlockHangup(pHangup);
			return H245_ERROR_OK;
		}
		HangupCallbackParams.dwUserToken = pHangup->dwUserToken;
		InvokeUserConferenceCallback(pConference->ConferenceCallback,
			                         CC_HANGUP_INDICATION,
									 CC_OK,
									 hConference,
									 pConference->dwConferenceToken,
									 &HangupCallbackParams);
		if (ValidateConference(hConference) == CC_OK)
			UnlockConference(pConference);
		if (ValidateHangup(hHangup) == CC_OK)
			FreeHangup(pHangup);
		return H245_ERROR_OK;
	} else
		UnlockHangup(pHangup);
	return H245_ERROR_OK;
#endif // Sync 3 code
}

#endif



HRESULT _ConfInitMstslv(			H245_CONF_IND_T			*pH245ConfIndData)
{
CC_HCALL					hCall;
PCALL						pCall;
PCONFERENCE					pConference;
CC_CONNECT_CALLBACK_PARAMS	ConnectCallbackParams;
CC_HCALL					hEnqueuedCall;
PCALL						pEnqueuedCall;
CC_HCONFERENCE				hConference;
HRESULT						status;

	hCall = pH245ConfIndData->u.Confirm.dwPreserved;
	if (LockCallAndConference(hCall, &pCall, &pConference) != CC_OK)
		return H245_ERROR_OK;

	ASSERT(pCall->MasterSlaveState != MASTER_SLAVE_COMPLETE);

	switch (pH245ConfIndData->u.Confirm.u.ConfMstSlv) {
        case H245_MASTER:
		    pConference->tsMaster = TS_TRUE;
		    if (pConference->tsMultipointController == TS_UNKNOWN) {
			    ASSERT(pConference->bMultipointCapable == TRUE);
			    pConference->tsMultipointController = TS_TRUE;

			    // place all calls enqueued on this conference object
			    for ( ; ; ) {
				    // Start up all enqueued calls, if any exist
				    status = RemoveEnqueuedCallFromConference(pConference, &hEnqueuedCall);
				    if ((status != CC_OK) || (hEnqueuedCall == CC_INVALID_HANDLE))
					    break;

				    status = LockCall(hEnqueuedCall, &pEnqueuedCall);
				    if (status == CC_OK) {
					    pEnqueuedCall->CallState = PLACED;

					    status = PlaceCall(pEnqueuedCall, pConference);
					    UnlockCall(pEnqueuedCall);
				    }
			    }
		    }
            break;

        case H245_SLAVE:
		    ASSERT(pConference->tsMaster != TS_TRUE);
		    ASSERT(pConference->tsMultipointController != TS_TRUE);
		    pConference->tsMaster = TS_FALSE;
		    pConference->tsMultipointController = TS_FALSE;

		    // XXX -- we may eventually want to re-enqueue these requests
		    // and set an expiration timer
		    hConference = pConference->hConference;
				
		    for ( ; ; ) {
			    status = RemoveEnqueuedCallFromConference(pConference, &hEnqueuedCall);
			    if ((status != CC_OK) || (hEnqueuedCall == CC_INVALID_HANDLE))
				    break;

			    status = LockCall(hEnqueuedCall, &pEnqueuedCall);
			    if (status == CC_OK) {
				    MarkCallForDeletion(pEnqueuedCall);
				    ConnectCallbackParams.pNonStandardData = pEnqueuedCall->pPeerNonStandardData;
				    ConnectCallbackParams.pszPeerDisplay = pEnqueuedCall->pszPeerDisplay;
				    ConnectCallbackParams.bRejectReason = CC_REJECT_UNDEFINED_REASON;
				    ConnectCallbackParams.pTermCapList = pEnqueuedCall->pPeerH245TermCapList;
				    ConnectCallbackParams.pH2250MuxCapability = pEnqueuedCall->pPeerH245H2250MuxCapability;
				    ConnectCallbackParams.pTermCapDescriptors = pEnqueuedCall->pPeerH245TermCapDescriptors;
				    ConnectCallbackParams.pLocalAddr = pEnqueuedCall->pQ931LocalConnectAddr;
	                if (pEnqueuedCall->pQ931DestinationAddr == NULL)
		                ConnectCallbackParams.pPeerAddr = pEnqueuedCall->pQ931PeerConnectAddr;
	                else
		                ConnectCallbackParams.pPeerAddr = pEnqueuedCall->pQ931DestinationAddr;
				    ConnectCallbackParams.pVendorInfo = pEnqueuedCall->pPeerVendorInfo;
				    ConnectCallbackParams.bMultipointConference = TRUE;
				    ConnectCallbackParams.pConferenceID = &pConference->ConferenceID;
				    ConnectCallbackParams.pMCAddress = pConference->pMultipointControllerAddr;
					ConnectCallbackParams.pAlternateAddress = NULL;
				    ConnectCallbackParams.dwUserToken = pEnqueuedCall->dwUserToken;

				    InvokeUserConferenceCallback(pConference,
									    CC_CONNECT_INDICATION,
									    CC_NOT_MULTIPOINT_CAPABLE,
									    &ConnectCallbackParams);
				    if (ValidateCallMarkedForDeletion(hEnqueuedCall) == CC_OK)
					    FreeCall(pEnqueuedCall);
				    if (ValidateConference(hConference) != CC_OK) {
					    if (ValidateCall(hCall) == CC_OK)
						    UnlockCall(pCall);
					    return H245_ERROR_OK;
				    }
			    }
		    }
            break;

        default: // H245_INDETERMINATE
			UnlockConference(pConference);
			if (++pCall->wMasterSlaveRetry < MASTER_SLAVE_RETRY_MAX) {
				H245InitMasterSlave(pCall->H245Instance, pCall->H245Instance);
			    UnlockCall(pCall);
			} else {
			    UnlockCall(pCall);
				ProcessRemoteHangup(hCall, CC_INVALID_HANDLE, CC_REJECT_UNDEFINED_REASON);
			}
			return H245_ERROR_OK;
	} // switch

	pCall->MasterSlaveState = MASTER_SLAVE_COMPLETE;

	if ((pCall->OutgoingTermCapState == TERMCAP_COMPLETE) &&
		(pCall->IncomingTermCapState == TERMCAP_COMPLETE) &&
	    (pCall->CallState == TERMCAP) &&
		(pCall->MasterSlaveState == MASTER_SLAVE_COMPLETE)) {
		// Note that _ProcessConnectionComplete() returns with pConference and pCall unlocked
		_ProcessConnectionComplete(pConference, pCall);
		return H245_ERROR_OK;
	}

	UnlockCall(pCall);
	UnlockConference(pConference);
	return H245_ERROR_OK;
}



HRESULT _ConfSendTermCap(			H245_CONF_IND_T			*pH245ConfIndData)
{
CC_HCALL		hCall;
PCALL			pCall;
HRESULT			status;
PCONFERENCE		pConference;

	// A TerminalCapabilitySet message was successfully sent from this endpoint

	hCall = pH245ConfIndData->u.Confirm.dwPreserved;
	status = LockCallAndConference(hCall, &pCall, &pConference);
	if (status != CC_OK) {
		// This may be OK, if the call was cancelled while
		// call setup was in progress.
		return H245_ERROR_OK;
	}

    if (pH245ConfIndData->u.Confirm.Error == H245_ERROR_OK &&
        pH245ConfIndData->u.Confirm.u.ConfSndTcap.AccRej == H245_ACC) {
	    pCall->OutgoingTermCapState = TERMCAP_COMPLETE;
	    if ((pCall->IncomingTermCapState == TERMCAP_COMPLETE) &&
	        (pCall->CallState == TERMCAP) &&
		    (pCall->MasterSlaveState == MASTER_SLAVE_COMPLETE)) {
		    // Note that _ProcessConnectionComplete() returns with pConference and pCall unlocked
		    _ProcessConnectionComplete(pConference, pCall);
		    return H245_ERROR_OK;
	    }
    } else if (pCall->CallState == TERMCAP) {
        // Report error to Call Control client
		UnlockConference(pConference);
		UnlockCall(pCall);
		ProcessRemoteHangup(hCall, CC_INVALID_HANDLE, CC_REJECT_UNDEFINED_REASON);
	    return H245_ERROR_OK;
    }

	UnlockConference(pConference);
	UnlockCall(pCall);
	return H245_ERROR_OK;
}



HRESULT _ConfRequestMode(			H245_CONF_IND_T			*pH245ConfIndData)
{
HRESULT			status;
CC_HCALL		hCall;
PCALL			pCall;
CC_HCONFERENCE	hConference;
PCONFERENCE		pConference;
CC_REQUEST_MODE_RESPONSE_CALLBACK_PARAMS	RequestModeResponseCallbackParams;

	hCall = pH245ConfIndData->u.Confirm.dwPreserved;
	status = LockCallAndConference(hCall, &pCall, &pConference);
	if (status != CC_OK) {
		// This may be OK, if the call was cancelled while
		// call setup was in progress.
		return H245_ERROR_OK;
	}
	
	hConference = pConference->hConference;

	RequestModeResponseCallbackParams.hCall = hCall;
	if (pCall->pPeerParticipantInfo == NULL) {
		RequestModeResponseCallbackParams.TerminalLabel.bMCUNumber = 255;
		RequestModeResponseCallbackParams.TerminalLabel.bTerminalNumber = 255;
	} else
		RequestModeResponseCallbackParams.TerminalLabel =
			pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel;
	switch (pH245ConfIndData->u.Confirm.u.ConfMrse) {
		case wllTrnsmtMstPrfrrdMd_chosen:
			RequestModeResponseCallbackParams.RequestModeResponse = CC_WILL_TRANSMIT_PREFERRED_MODE;
			break;
		case wllTrnsmtLssPrfrrdMd_chosen:
			RequestModeResponseCallbackParams.RequestModeResponse = CC_WILL_TRANSMIT_LESS_PREFERRED_MODE;
			break;
		default:
			RequestModeResponseCallbackParams.RequestModeResponse = CC_REQUEST_DENIED;
			break;
	}
	InvokeUserConferenceCallback(pConference,
								 CC_REQUEST_MODE_RESPONSE_INDICATION,
								 pH245ConfIndData->u.Confirm.Error,
								 &RequestModeResponseCallbackParams);
	if (ValidateCall(hCall) == CC_OK)
		UnlockCall(pCall);
	if (ValidateConference(hConference) == CC_OK)
		UnlockConference(pConference);
	return H245_ERROR_OK;
}



HRESULT _ConfRequestModeReject(		H245_CONF_IND_T			*pH245ConfIndData)
{
HRESULT			status;
CC_HCALL		hCall;
PCALL			pCall;
CC_HCONFERENCE	hConference;
PCONFERENCE		pConference;
CC_REQUEST_MODE_RESPONSE_CALLBACK_PARAMS	RequestModeResponseCallbackParams;

	hCall = pH245ConfIndData->u.Confirm.dwPreserved;
	status = LockCallAndConference(hCall, &pCall, &pConference);
	if (status != CC_OK) {
		// This may be OK, if the call was cancelled while
		// call setup was in progress.
		return H245_ERROR_OK;
	}
	
	hConference = pConference->hConference;

	RequestModeResponseCallbackParams.hCall = hCall;
	if (pCall->pPeerParticipantInfo == NULL) {
		RequestModeResponseCallbackParams.TerminalLabel.bMCUNumber = 255;
		RequestModeResponseCallbackParams.TerminalLabel.bTerminalNumber = 255;
	} else
		RequestModeResponseCallbackParams.TerminalLabel =
			pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel;
	switch (pH245ConfIndData->u.Confirm.u.ConfMrseReject) {
		case H245_REJ_UNAVAILABLE:
			RequestModeResponseCallbackParams.RequestModeResponse = CC_MODE_UNAVAILABLE;
			break;
		case H245_REJ_MULTIPOINT:
			RequestModeResponseCallbackParams.RequestModeResponse = CC_MULTIPOINT_CONSTRAINT;
			break;
		case H245_REJ_DENIED:
			RequestModeResponseCallbackParams.RequestModeResponse = CC_REQUEST_DENIED;
			break;
		default:
			RequestModeResponseCallbackParams.RequestModeResponse = CC_REQUEST_DENIED;
			break;
	}
	InvokeUserConferenceCallback(pConference,
								 CC_REQUEST_MODE_RESPONSE_INDICATION,
								 pH245ConfIndData->u.Confirm.Error,
								 &RequestModeResponseCallbackParams);
	if (ValidateCall(hCall) == CC_OK)
		UnlockCall(pCall);
	if (ValidateConference(hConference) == CC_OK)
		UnlockConference(pConference);
	return H245_ERROR_OK;
}



HRESULT _ConfRequestModeExpired(		H245_CONF_IND_T			*pH245ConfIndData)
{
HRESULT			status;
CC_HCALL		hCall;
PCALL			pCall;
CC_HCONFERENCE	hConference;
PCONFERENCE		pConference;
CC_REQUEST_MODE_RESPONSE_CALLBACK_PARAMS	RequestModeResponseCallbackParams;

	hCall = pH245ConfIndData->u.Confirm.dwPreserved;
	status = LockCallAndConference(hCall, &pCall, &pConference);
	if (status != CC_OK) {
		// This may be OK, if the call was cancelled while
		// call setup was in progress.
		return H245_ERROR_OK;
	}
	
	hConference = pConference->hConference;

	RequestModeResponseCallbackParams.hCall = hCall;
	if (pCall->pPeerParticipantInfo == NULL) {
		RequestModeResponseCallbackParams.TerminalLabel.bMCUNumber = 255;
		RequestModeResponseCallbackParams.TerminalLabel.bTerminalNumber = 255;
	} else
		RequestModeResponseCallbackParams.TerminalLabel =
			pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel;
	RequestModeResponseCallbackParams.RequestModeResponse = CC_REQUEST_DENIED;
	InvokeUserConferenceCallback(pConference,
								 CC_REQUEST_MODE_RESPONSE_INDICATION,
								 pH245ConfIndData->u.Confirm.Error,
								 &RequestModeResponseCallbackParams);
	if (ValidateCall(hCall) == CC_OK)
		UnlockCall(pCall);
	if (ValidateConference(hConference) == CC_OK)
		UnlockConference(pConference);
	return H245_ERROR_OK;
}



HRESULT _ConfRoundTrip(				H245_CONF_IND_T			*pH245ConfIndData)
{
CC_HCALL							hCall;
PCALL								pCall;
CC_HCONFERENCE						hConference;
PCONFERENCE							pConference;
HRESULT								status;
CC_PING_RESPONSE_CALLBACK_PARAMS	PingCallbackParams;	

	hCall = pH245ConfIndData->u.Confirm.dwPreserved;
	status = LockCallAndConference(hCall, &pCall, &pConference);
	if (status != CC_OK) {
		// This may be OK, if the call was cancelled while
		// call setup was in progress.
		return H245_ERROR_OK;
	}
	
	hConference = pConference->hConference;

	PingCallbackParams.hCall = hCall;
	if (pCall->pPeerParticipantInfo == NULL) {
		PingCallbackParams.TerminalLabel.bMCUNumber = 255;
		PingCallbackParams.TerminalLabel.bTerminalNumber = 255;
	} else
		PingCallbackParams.TerminalLabel =
			pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel;
	PingCallbackParams.bResponse = TRUE;
	InvokeUserConferenceCallback(pConference,
								 CC_PING_RESPONSE_INDICATION,
								 pH245ConfIndData->u.Confirm.Error,
								 &PingCallbackParams);
	if (ValidateCall(hCall) == CC_OK)
		UnlockCall(pCall);
	if (ValidateConference(hConference) == CC_OK)
		UnlockConference(pConference);
	return H245_ERROR_OK;
}



HRESULT _ConfRoundTripExpired(		H245_CONF_IND_T			*pH245ConfIndData)
{
CC_HCALL		hCall;
PCALL			pCall;
CC_HCONFERENCE	hConference;
PCONFERENCE		pConference;
HRESULT								status;
CC_PING_RESPONSE_CALLBACK_PARAMS	PingCallbackParams;	

	hCall = pH245ConfIndData->u.Confirm.dwPreserved;
	status = LockCallAndConference(hCall, &pCall, &pConference);
	if (status != CC_OK) {
		// This may be OK, if the call was cancelled while
		// call setup was in progress.
		return H245_ERROR_OK;
	}
	
	hConference = pConference->hConference;

	PingCallbackParams.hCall = hCall;
	if (pCall->pPeerParticipantInfo == NULL) {
		PingCallbackParams.TerminalLabel.bMCUNumber = 255;
		PingCallbackParams.TerminalLabel.bTerminalNumber = 255;
	} else
		PingCallbackParams.TerminalLabel =
			pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel;
	PingCallbackParams.bResponse = FALSE;
	InvokeUserConferenceCallback(pConference,
								 CC_PING_RESPONSE_INDICATION,
								 pH245ConfIndData->u.Confirm.Error,
								 &PingCallbackParams);
	if (ValidateCall(hCall) == CC_OK)
		UnlockCall(pCall);
	if (ValidateConference(hConference) == CC_OK)
		UnlockConference(pConference);
	return H245_ERROR_OK;
}



HRESULT H245Callback(				H245_CONF_IND_T			*pH245ConfIndData,
									void					*pMisc)
{
HRESULT	status = H245_ERROR_OK;

	EnterCallControl();

	if (CallControlState != OPERATIONAL_STATE)
		HResultLeaveCallControl(H245_ERROR_OK);

	if (pH245ConfIndData == NULL)
		HResultLeaveCallControl(H245_ERROR_OK);

	if (pH245ConfIndData->Kind == H245_CONF) {
		switch (pH245ConfIndData->u.Confirm.Confirm) {
			
			case H245_CONF_INIT_MSTSLV:
				status = _ConfInitMstslv(pH245ConfIndData);
				break;

			case H245_CONF_SEND_TERMCAP:
				status = _ConfSendTermCap(pH245ConfIndData);
				break;

			case H245_CONF_OPEN:
				status = _ConfOpen(pH245ConfIndData);
				break;

			case H245_CONF_NEEDRSP_OPEN:
				status = _ConfBiDirectionalOpen(pH245ConfIndData);
				break;

			case H245_CONF_CLOSE:
				status = _ConfClose(pH245ConfIndData);
				break;

			case H245_CONF_REQ_CLOSE:
				status = _ConfRequestClose(pH245ConfIndData);
				break;

//			case H245_CONF_MUXTBL_SND:      not valid for H.323 MuliplexEntrySend
//			case H245_CONF_RMESE:           not valid for H.323 RequestMultiplexEntry
//			case H245_CONF_RMESE_REJECT:    not valid for H.323 RequestMultiplexEntryReject
//			case H245_CONF_RMESE_EXPIRED:   not valid for H.323

			case H245_CONF_MRSE:
				status = _ConfRequestMode(pH245ConfIndData);
				break;

			case H245_CONF_MRSE_REJECT:
				status = _ConfRequestModeReject(pH245ConfIndData);
				break;

			case H245_CONF_MRSE_EXPIRED:
				status = _ConfRequestModeExpired(pH245ConfIndData);
				break;

			case H245_CONF_RTDSE:
				status = _ConfRoundTrip(pH245ConfIndData);
				break;

			case H245_CONF_RTDSE_EXPIRED:
				status = _ConfRoundTripExpired(pH245ConfIndData);
				break;

			default:
				status = _ConfUnimplemented(pH245ConfIndData);
				break;
		}
	} else if (pH245ConfIndData->Kind == H245_IND) {
		switch (pH245ConfIndData->u.Indication.Indicator) {
			
 			case H245_IND_MSTSLV:
				status = _IndMstslv(pH245ConfIndData);
				break;

			case H245_IND_CAP:
				status = _IndCapability(pH245ConfIndData);
				break;

			case H245_IND_CESE_RELEASE:
                // Remote has abandoned TerminalCapabilitySet
                // No longer need to send TerminalCapabilitySetAck
                // We can probably get away with ignoring this,
                // but we should NOT return FunctionNotSupported!
				break;

			case H245_IND_OPEN:
				status = _IndOpen(pH245ConfIndData);
				break;

			case H245_IND_OPEN_CONF:
                // Bi-directionl channel open complete
				status = _IndOpenConf(pH245ConfIndData);
				break;

			case H245_IND_CLOSE:
				status = _IndClose(pH245ConfIndData);
				break;

			case H245_IND_REQ_CLOSE:
				status = _IndRequestClose(pH245ConfIndData);
				break;

			case H245_IND_CLCSE_RELEASE:
                // Remote has abandoned RequestChannelClose
                // No longer need to send RequestChannelCloseAck and CloseLogicalChannel
                // We can probably get away with ignoring this,
                // but we should NOT return FunctionNotSupported!
				break;

//			case H245_IND_MUX_TBL:          not valid in H.323 MuliplexEntrySend
//			case H245_IND_MTSE_RELEASE      not valid in H.323 MuliplexEntrySendRelease
//			case H245_IND_RMESE             not valid in H.323 RequestMuliplexEntry
//			case H245_IND_RMESE_RELEASE     not valid in H.323 RequestMuliplexEntryRelease

			case H245_IND_MRSE:
				status = _IndModeRequest(pH245ConfIndData);
				break;

			case H245_IND_MRSE_RELEASE:
                // Remote has abandoned RequestMode
                // No longer need to send RequestModeAck or RequestModeReject
                // We can probably get away with ignoring this,
                // but we should NOT return FunctionNotSupported!
				break;

//			case H245_IND_MLSE:             We don't support looping back data

			case H245_IND_MLSE_RELEASE:
                // Required to accept this message
                break;

			case H245_IND_NONSTANDARD_REQUEST:
			case H245_IND_NONSTANDARD_RESPONSE:
			case H245_IND_NONSTANDARD_COMMAND:
			case H245_IND_NONSTANDARD:
				 status = _IndNonStandard(pH245ConfIndData);
				break;

			case H245_IND_MISC_COMMAND:
				status = _IndMiscellaneousCommand(pH245ConfIndData, pMisc);
				break;

			case H245_IND_MISC:
				status = _IndMiscellaneous(pH245ConfIndData, pMisc);
				break;
				
			case H245_IND_COMM_MODE_REQUEST:
				status = _IndUnimplemented(pH245ConfIndData); // TBD
				break;

//			case H245_IND_COMM_MODE_RESPONSE:   We never send request!

			case H245_IND_COMM_MODE_COMMAND:
				status = _IndCommunicationModeCommand(pH245ConfIndData);
				break;

			case H245_IND_CONFERENCE_REQUEST:
				status = _IndConferenceRequest(pH245ConfIndData);
				break;

			case H245_IND_CONFERENCE_RESPONSE:
				status = _IndConferenceResponse(pH245ConfIndData);
				break;

			case H245_IND_CONFERENCE_COMMAND:
				status = _IndConferenceCommand(pH245ConfIndData);
				break;

			case H245_IND_CONFERENCE:
				status = _IndConference(pH245ConfIndData);
				break;
	
			case H245_IND_SEND_TERMCAP:
				status = _IndSendTerminalCapabilitySet(pH245ConfIndData);
				break;

//			case H245_IND_ENCRYPTION:       Not valid in H.323

			case H245_IND_FLOW_CONTROL:
				status = _IndFlowControl(pH245ConfIndData);
				break;

			case H245_IND_ENDSESSION:
				status = _IndEndSession(pH245ConfIndData);
				break;

			case H245_IND_FUNCTION_NOT_UNDERSTOOD:
				// We don't do anything with this but we still want to
                // return H245_ERROR_OK so H.245 does not sent
                // FunctionNotSupported back to remote peer!
				break;

			case H245_IND_JITTER:
                // It is ok to ignore this; no response is expected
                break;

//			case H245_IND_H223_SKEW:        Not valid in H.323
//			case H245_IND_NEW_ATM_VC:       Not valid in H.323

			case H245_IND_USERINPUT:
				status = _IndUserInput(pH245ConfIndData);
				break;

			case H245_IND_H2250_MAX_SKEW:
				status = _IndH2250MaximumSkew(pH245ConfIndData);
				break;

			case H245_IND_MC_LOCATION:
				status = _IndMCLocation(pH245ConfIndData);
				break;

			case H245_IND_VENDOR_ID:
				status = _IndVendorIdentification(pH245ConfIndData, pMisc);
				break;

			case H245_IND_FUNCTION_NOT_SUPPORTED:
				// We don't do anything with this but we still want to
                // return H245_ERROR_OK so H.245 does not sent
                // FunctionNotSupported back to remote peer!
				break;

//			case H245_IND_H223_RECONFIG:        Not valid in H.323
//			case H245_IND_H223_RECONFIG_ACK:    Not valid in H.323
//			case H245_IND_H223_RECONFIG_REJECT: Not valid in H.323
			default:
				status = _IndUnimplemented(pH245ConfIndData);
				break;
		}
	}
	HResultLeaveCallControl(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\h245init.c ===
/******************************************************************************
 *
 *   INTEL Corporation Proprietary Information				
 *   Copyright (c) 1994, 1995, 1996 Intel Corporation.				
 *									
 *   This listing is supplied under the terms of a license agreement	
 *   with INTEL Corporation and may not be used, copied, nor disclosed	
 *   except in accordance with the terms of that agreement.		
 *
 *****************************************************************************/

/******************************************************************************
 *									
 *  $Workfile:   h245init.c  $						
 *  $Revision:   1.2  $							
 *  $Modtime:   29 May 1996 13:12:46  $					
 *  $Log:   S:/STURGEON/SRC/H245/SRC/VCS/h245init.c_v  $	
 *
 *    Rev 1.2   29 May 1996 15:20:18   EHOWARDX
 * Change to use HRESULT.
 *
 *    Rev 1.1   28 May 1996 14:25:40   EHOWARDX
 * Tel Aviv update.
 *
 *    Rev 1.0   09 May 1996 21:06:22   EHOWARDX
 * Initial revision.
 *
 *    Rev 1.16   09 May 1996 19:35:34   EHOWARDX
 * Added new locking logic and changed timer.
 *
 *    Rev 1.15   09 Apr 1996 15:53:36   dabrown1
 *
 * Added srflush.x for queue flush bitmap
 *
 *    Rev 1.14   05 Apr 1996 10:56:58   dabrown1
 * Asynchronous/Synchronous shutdown support
 *
 *    Rev 1.13   04 Apr 1996 18:17:06   dabrown1
 *
 * - changed parameter for DeInitTimer..
 *
 *    Rev 1.12   02 Apr 1996 15:00:12   dabrown1
 *
 * SendRcv EndSession asynchronous support
 *
 *    Rev 1.11   18 Mar 1996 12:36:28   cjutzi
 * - added timer init and de-init
 *
 *    Rev 1.10   13 Mar 1996 15:08:26   helgebax
 * added Fsm_shutdown(Instance) to clear FSM context
 *
 *    Rev 1.9   06 Mar 1996 13:10:42   DABROWN1
 * Flush send receive transmit buffers at system shutdown
 *
 *    Rev 1.8   28 Feb 1996 17:23:38   EHOWARDX
 * Added #include "fsmexpor.h" for Fsm_init prototype.
 *
 *    Rev 1.7   27 Feb 1996 13:41:56   DABROWN1
 * removed mal/h223 initialization code
 *
 *    Rev 1.6   26 Feb 1996 11:17:36   cjutzi
 * - moved api_deinit.. to EndSystemClose
 *
 *    Rev 1.5   21 Feb 1996 13:23:12   DABROWN1
 *
 * check return codes for SR and FSM on initialization
 *
 *    Rev 1.4   13 Feb 1996 14:48:50   DABROWN1
 *
 * Removed SPOX only include files from mainline path
 *
 *    Rev 1.3   09 Feb 1996 16:00:22   cjutzi
 *
 * - cleaned up the startup...
 * - added the mal and h223 startup to the configuration as was
 *   determined to be correct.. (still some issues with handles)
 *  $Ident$
 *
 *****************************************************************************/

#ifndef STRICT
#define STRICT
#endif

#include "precomp.h"

/***********************/
/*    H245 INCLUDES    */
/***********************/
#include "h245api.h"
#include "h245com.h"
#include "sr_api.h"
//#include "h223api.h"
#include "fsmexpor.h"
#include "h245sys.x"

#if defined(H324)
/*****************************************************************************
 *									
 * Type:	LOCAL							
 *									
 * PROCEDURE: 	setup_from_H245_ini - setup using conmgr.ini file
 *									
 * DESCRIPTION:							      	
 *									
 *****************************************************************************/

static
void setup_from_H245_ini (int *p_dbg_lvl)
{
  char		*p_ini = "h245.ini";			
  char		*p_H245 ="H245";

  p_ini        	= "h245.ini";				
  p_H245       	= "H245";				

#ifdef OIL
  OIL_GetPrivateProfileInt(p_H245, "TraceLvl", 0, p_ini, p_dbg_lvl);
#else
  *p_dbg_lvl = GetPrivateProfileInt (p_H245, "TraceLvl", 0, p_ini);	
#endif
}
#endif  // (H324)

/*****************************************************************************
 *									
 * Type:	GLOBAL
 *									
 * PROCEDURE: 	StartSystemInitilize - Initialize Sub Systems
 *									
 * DESCRIPTION:							      	
 *
 *		This is called on entry to the H245_Init API Call
 *
 *
 *		This procedure initializes all the subsystems in H245. Errors
 *		must be mapped to an appropriate H245_ERROR_xxx allowing the
 *		initialization error to be propogated to through the API to the
 *		H245 Client.  As your subsystem initializes, if errors occur
 *		you are responsable for doing the mapping from your subsystem to
 *		the appropriate H245_ERROR_xxx.  If there is no appropriate error
 *		please contact the programmer in charge of the API indicating
 *		your new error return value so that h245api.h can be updated,
 *		as well as the new error documented in the API/EPS..
 *
 *
 *		returns - H245_ERROR_OK 	if no error has occured..
 *		returns - H245_ERROR_xxxx	indicating error
 *									
 *****************************************************************************/

DWORD StartSystemInit (struct InstanceStruct *pInstance)
{
  HRESULT lError;

  /* Timer Initialization */
//  H245InitTimer(pInstance);

  /* API Subsystem Initialization */
  lError = api_init(pInstance);
  if (lError != H245_ERROR_OK)
    return lError;

  /* Send Receive Subsystem Initialization */
  lError = sendRcvInit(pInstance);
  if (lError != H245_ERROR_OK)
    return lError;

  /* State Machine Subsystem Initialization */
  return Fsm_init(pInstance);
}

/*****************************************************************************
 *									
 * Type:	GLOBAL
 *									
 * PROCEDURE: 	EndSystemInitilize - Initialize Sub Systems
 *									
 * DESCRIPTION:							      	
 *
 *		This is called on exit from H245 System Initialization
 *
 *
 *		This procedure initializes all the subsystems in H245. Errors
 *		must be mapped to an appropriate H245_ERROR_xxx allowing the
 *		initialization error to be propogated to through the API to the
 *		H245 Client.  As your subsystem initializes, if errors occur
 *		you are responsable for doing the mapping from your subsystem to
 *		the appropriate H245_ERROR_xxx.  If there is no appropriate error
 *		please contact the programmer in charge of the API indicating
 *		your new error return value so that h245api.h can be updated,
 *		as well as the new error documented in the API/EPS..
 *
 *
 *		returns - H245_ERROR_OK 	if no error has occured..
 *		returns - H245_ERROR_xxxx	indicating error
 *									
 *****************************************************************************/

DWORD EndSystemInit (struct InstanceStruct *pInstance)
{
  /* API Subsystem Initialization */

  // -- TBD

  /* Send Receive Subsystem Initialization */

  // -- TBD

  /* State Machine Subsystem Initialization */

  // -- TBD

  return H245_ERROR_OK;
}


/*****************************************************************************
 *									
 * Type:	GLOBAL
 *									
 * PROCEDURE: 	StartSessionClose
 *									
 * DESCRIPTION:							      	
 *
 *		This procedure is called when H245_Shutdown occurs
 *
 *		Errors must be mapped to an appropriate H245_ERROR_xxx allowing the
 *		initialization error to be propogated to through the API to the
 *		H245 Client.  As your subsystem initializes, if errors occur
 *		you are responsable for doing the mapping from your subsystem to
 *		the appropriate H245_ERROR_xxx.  If there is no appropriate error
 *		please contact the programmer in charge of the API indicating
 *		your new error return value so that h245api.h can be updated,
 *		as well as the new error documented in the API/EPS..
 *
 *
 *		returns - H245_ERROR_OK 	if no error has occured..
 *		returns - H245_ERROR_xxxx	indicating error
 *									
 *****************************************************************************/

DWORD StartSystemClose (struct InstanceStruct *pInstance)
{
  /* API Subsystem Shutdown Initiation */

  // TBD

  /* Send Receive Shutdown Initiation */

  // TBD

  /* State Machine Shutdown Initiation */
  Fsm_shutdown(pInstance);

  return (H245_ERROR_OK);
}


/*****************************************************************************
 *									
 * Type:	GLOBAL
 *									
 * PROCEDURE: 	StartSessionClose
 *									
 * DESCRIPTION:							      	
 *
 *		This procedure is called when H245_Shutdown completes asynchroniously.
 *
 *		Errors must be mapped to an appropriate H245_ERROR_xxx allowing the
 *		initialization error to be propogated to through the API to the
 *		H245 Client.  As your subsystem initializes, if errors occur
 *		you are responsable for doing the mapping from your subsystem to
 *		the appropriate H245_ERROR_xxx.  If there is no appropriate error
 *		please contact the programmer in charge of the API indicating
 *		your new error return value so that h245api.h can be updated,
 *		as well as the new error documented in the API/EPS..
 *
 *
 *		returns - H245_ERROR_OK 	if no error has occured..
 *		returns - H245_ERROR_xxxx	indicating error
 *									
 *****************************************************************************/

DWORD EndSystemClose (struct InstanceStruct *pInstance)
{

  /* Send Receive Shutdown Completion */
  sendRcvShutdown(pInstance);

  /* API Subsystem Shutdown Completion */

  api_deinit(pInstance);

  /* State Machine Shutdown Completion */

  // -- TBD

  /* Timer Shutdown */
//  H245DeInitTimer(pInstance);

  return (H245_ERROR_OK);
}



/*****************************************************************************
 *									
 * Type:	GLOBAL
 *									
 * PROCEDURE: 	StartSessionInit
 *									
 * DESCRIPTION:							      	
 *
 *		This procedure is called when an H245_BeginConnection is called.
 *
 *		Errors must be mapped to an appropriate H245_ERROR_xxx allowing the
 *		initialization error to be propogated to through the API to the
 *		H245 Client.  As your subsystem initializes, if errors occur
 *		you are responsable for doing the mapping from your subsystem to
 *		the appropriate H245_ERROR_xxx.  If there is no appropriate error
 *		please contact the programmer in charge of the API indicating
 *		your new error return value so that h245api.h can be updated,
 *		as well as the new error documented in the API/EPS..
 *
 *
 *		returns - H245_ERROR_OK 	if no error has occured..
 *		returns - H245_ERROR_xxxx	indicating error
 *									
 *****************************************************************************/

DWORD StartSessionInit (struct InstanceStruct *pInstance)
{

  /* API Subsystem Initialization */


  /* Send Receive  Initialization */


  /* State Machine Initialization */


  return H245_ERROR_OK;
}

/*****************************************************************************
 *									
 * Type:	GLOBAL
 *									
 * PROCEDURE: 	EndSessionInit
 *									
 * DESCRIPTION:							      	
 *
 *		This procedure is called when an H245_BeginConnection call is
 *		completed.. Asynchroniously.
 *
 *		Errors must be mapped to an appropriate H245_ERROR_xxx allowing the
 *		initialization error to be propogated to through the API to the
 *		H245 Client.  As your subsystem initializes, if errors occur
 *		you are responsable for doing the mapping from your subsystem to
 *		the appropriate H245_ERROR_xxx.  If there is no appropriate error
 *		please contact the programmer in charge of the API indicating
 *		your new error return value so that h245api.h can be updated,
 *		as well as the new error documented in the API/EPS..
 *
 *
 *		returns - H245_ERROR_OK 	if no error has occured..
 *		returns - H245_ERROR_xxxx	indicating error
 *									
 *****************************************************************************/

DWORD EndSessionInit (struct InstanceStruct *pInstance)
{

  /* API Subsystem Initialization */


  /* Send Receive Initialization */


  /* Master Slave Initialization */


  return H245_ERROR_OK;
}

/*****************************************************************************
 *									
 * Type:	GLOBAL
 *									
 * PROCEDURE: 	StartSessionClose
 *									
 * DESCRIPTION:							      	
 *
 *		This procedure is called when H245_EndConnection occurs
 *
 *		Errors must be mapped to an appropriate H245_ERROR_xxx allowing the
 *		initialization error to be propogated to through the API to the
 *		H245 Client.  As your subsystem initializes, if errors occur
 *		you are responsable for doing the mapping from your subsystem to
 *		the appropriate H245_ERROR_xxx.  If there is no appropriate error
 *		please contact the programmer in charge of the API indicating
 *		your new error return value so that h245api.h can be updated,
 *		as well as the new error documented in the API/EPS..
 *
 *
 *		returns - H245_ERROR_OK 	if no error has occured..
 *		returns - H245_ERROR_xxxx	indicating error
 *									
 *****************************************************************************/

DWORD StartSessionClose (struct InstanceStruct *pInstance)
{
  /* API Subsystem Session Close */

  /* Send Receive Session Close */
  /* Dequeue any buffers posted in the data link transmit queue */
  if (H245_ERROR_OK != sendRcvFlushPDUs(
                            pInstance,
                            DATALINK_TRANSMIT,
                            TRUE))				
  {
    H245TRACE(pInstance->dwInst, 1, "Flush Buffer Failure");
  }

  /* State Machine Session Close */

  return H245_ERROR_OK;
}


/*****************************************************************************
 *									
 * Type:	GLOBAL
 *									
 * PROCEDURE: 	EndSessionClose
 *									
 * DESCRIPTION:							      	
 *
 *		This procedure is called when H245_EndConnection completes
 *		asynchroniously.
 *
 *		Errors must be mapped to an appropriate H245_ERROR_xxx allowing the
 *		initialization error to be propogated to through the API to the
 *		H245 Client.  As your subsystem initializes, if errors occur
 *		you are responsable for doing the mapping from your subsystem to
 *		the appropriate H245_ERROR_xxx.  If there is no appropriate error
 *		please contact the programmer in charge of the API indicating
 *		your new error return value so that h245api.h can be updated,
 *		as well as the new error documented in the API/EPS..
 *
 *
 *		returns - H245_ERROR_OK 	if no error has occured..
 *		returns - H245_ERROR_xxxx	indicating error
 *									
 *****************************************************************************/

DWORD EndSessionClose (struct InstanceStruct *pInstance)
{
  /* API Subsystem Session Close */


  /* Send Receive  Session Close */


  /* State Machine Session Close */

  return H245_ERROR_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\h245ws.h ===
/***************************************************************************
 *
 * File: h245ws.h
 *
 * INTEL Corporation Proprietary Information
 * Copyright (c) 1996 Intel Corporation.
 *
 * This listing is supplied under the terms of a license agreement
 * with INTEL Corporation and may not be used, copied, nor disclosed
 * except in accordance with the terms of that agreement.
 *
 ***************************************************************************
 *
 * $Workfile:   h245ws.h  $
 * $Revision:   1.19  $
 * $Modtime:   31 Jan 1997 15:56:32  $
 * $Log:   S:\sturgeon\src\h245ws\vcs\h245ws.h_v  $
 *
 *    Rev 1.19   31 Jan 1997 16:23:34   SBELL1
 * Got rid of unused next pointer and put in definition of SocketTOPhysicalID
 *
 *    Rev 1.18   13 Dec 1996 12:13:06   SBELL1
 * moved ifdef _cplusplus to after includes
 *
 *    Rev 1.17   11 Dec 1996 13:45:36   SBELL1
 * Changed table/locks to use tstable.h stuff.
 *
 *    Rev 1.16   21 Jun 1996 18:51:44   unknown
 * Fixed yet another shutdown bug - linkLayerShutdown re-entrancy check.
 *
 *    Rev 1.14   17 May 1996 16:49:36   EHOWARDX
 * Shutdown fix.
 *
 *    Rev 1.13   16 May 1996 13:09:50   EHOWARDX
 * Made reporting of IP Addres and port consistent between linkLayerListen
 * and LinkLayerConnect.
 *
 *    Rev 1.12   09 May 1996 18:33:06   EHOWARDX
 *
 * Changes to build with new LINKAPI.H.
 *
 *    Rev 1.11   Apr 29 1996 14:02:28   plantz
 * Delete unused or private functions.
 *
 *    Rev 1.10   Apr 29 1996 12:15:38   plantz
 * Remove unused members of HWSINST structure.
 *
 *    Rev 1.9   Apr 24 1996 20:46:58   plantz
 * Changed ListenCallback to ConnectCallback in HWSINST structure.
 *
 *    Rev 1.8   Apr 24 1996 16:24:14   plantz
 * Change to use winsock 1 and not use overlapped I/O.
 *
 *    Rev 1.7   01 Apr 1996 14:20:38   unknown
 * Shutdown redesign.
 *
 *    Rev 1.6   27 Mar 1996 13:01:28   EHOWARDX
 * Added dwThreadId to H245WS instance structure.
 *
 *    Rev 1.5   19 Mar 1996 20:21:46   EHOWARDX
 * Redesigned shutdown.
 *
 *    Rev 1.3   18 Mar 1996 19:07:10   EHOWARDX
 * Fixed shutdown; eliminated TPKT/WSCB dependencies.
 * Define TPKT to put TPKT/WSCB dependencies back in.
 *
 *    Rev 1.2   14 Mar 1996 17:01:50   EHOWARDX
 *
 * NT4.0 testing; got rid of HwsAssert(); got rid of TPKT/WSCB.
 *
 *    Rev 1.1   09 Mar 1996 21:12:58   EHOWARDX
 * Fixes as result of testing.
 *
 *    Rev 1.0   08 Mar 1996 20:17:56   unknown
 * Initial revision.
 *
 ***************************************************************************/

#ifndef H245WS_H
#define H245WS_H

#ifndef STRICT
#define STRICT
#endif



#ifdef __cplusplus
extern "C"
{
#endif  // __cplusplus

/*
 * Constants
 */

#define SUCCESS         0
#define TPKT_VERSION    3
#define TPKT_HEADER_SIZE 4

// Indexes of permanent events in Events[]
#define EVENT_SOCKET    0
#define EVENT_RECV      1
#define EVENT_SEND      2
#define EVENT_FIRST     3



// Values for byLevel
#define HWS_CRITICAL    0x01
#define HWS_ERROR       0x02
#define HWS_WARNING     0x04
#define HWS_NOTIFY      0x08
#define HWS_TRACE       0x10
#define HWS_TEMP        0x20

#if defined(_DEBUG)
 void HwsTrace (DWORD dwInst, BYTE byLevel, LPSTR pszFormat, ...);
 #define HWSASSERT ASSERT
 #define HWSTRACE0(dwH245Instance,byLevel,a) HwsTrace(dwH245Instance,byLevel,a)
 #define HWSTRACE1(dwH245Instance,byLevel,a,b) HwsTrace(dwH245Instance,byLevel,a,b)
 #define HWSTRACE2(dwH245Instance,byLevel,a,b,c) HwsTrace(dwH245Instance,byLevel,a,b,c)
 #define HWSTRACE3(dwH245Instance,byLevel,a,b,c,d) HwsTrace(dwH245Instance,byLevel,a,b,c,d)
 #define HWSTRACE4(dwH245Instance,byLevel,a,b,c,d,e) HwsTrace(dwH245Instance,byLevel,a,b,c,d,e)
 #define HWSTRACE5(dwH245Instance,byLevel,a,b,c,d,e,f) HwsTrace(dwH245Instance,byLevel,a,b,c,d,e,f)
#else   // (_DEBUG)
 #define HWSASSERT(exp)
 #define HWSTRACE0(dwH245Instance,byLevel,a)
 #define HWSTRACE1(dwH245Instance,byLevel,a,b)
 #define HWSTRACE2(dwH245Instance,byLevel,a,b,c)
 #define HWSTRACE3(dwH245Instance,byLevel,a,b,c,d)
 #define HWSTRACE4(dwH245Instance,byLevel,a,b,c,d,e)
 #define HWSTRACE5(dwH245Instance,byLevel,a,b,c,d,e,f)
#endif  // (_DEBUG)


// This structure is used for overlapped sends and receives
typedef struct _IO_REQUEST
{
   struct _HWSINST * req_pHws;         // Pointer back to socket data
   BYTE              req_TpktHeader[TPKT_HEADER_SIZE];
   int               req_header_bytes_done;
   BYTE            * req_client_data;
   int               req_client_length;
   int               req_client_bytes_done;
   DWORD             req_dwMagic;      // Request type (send or receive)
#define RECV_REQUEST_MAGIC 0x91827364
#define SEND_REQUEST_MAGIC 0x19283746
} REQUEST, *PREQUEST;



typedef struct _HWSINST
{
   UINT              hws_uState;
#define HWS_START          0
#define HWS_LISTENING      1  /* Waiting for FD_ACCEPT                     */
#define HWS_CONNECTING     2  /* Waiting for FD_CONNECT                    */
#define HWS_CONNECTED      3  /* Data transfer state                       */
#define HWS_CLOSING        4  /* Waiting for FD_CLOSE                      */
#define HWS_CLOSED         5  /* Waiting for linkLayerShutdown()           */
#define HWS_SHUTDOWN       6  /* linkLayerShutdown() called from callback  */

   DWORD             hws_dwPhysicalId;
   DWORD_PTR         hws_dwH245Instance;
   H245CONNECTCALLBACK hws_h245ConnectCallback;
   H245SRCALLBACK    hws_h245RecvCallback;
   H245SRCALLBACK    hws_h245SendCallback;
   SOCKET            hws_Socket;
   SOCKADDR_IN       hws_SockAddr;
   UINT              hws_uSockAddrLen;

   // points to a queue used to hold send buffers
   PQUEUE            hws_pSendQueue;

   // points to a queue used to hold receive buffers
   PQUEUE            hws_pRecvQueue;

   // The maximum message size we can send on this socket.
   // This value is either an integer or the manifest constant NO_MAX_MSG_SIZE.
   UINT              hws_uMaxMsgSize;
   BOOL              hws_bCloseFlag;

#if defined(_DEBUG)
   DWORD             hws_dwMagic;      // Request type (send or receive)
#define HWSINST_MAGIC   0x12345678
#endif  // (_DEBUG)

} HWSINST, *PHWSINST;


typedef struct _SOCKET_TO_INSTANCE
{
	SOCKET socket;
	DWORD dwPhysicalId;
	struct _SOCKET_TO_INSTANCE *next;
} SOCKET_TO_INSTANCE, *PSOCKET_TO_INSTANCE;

#define SOCK_TO_PHYSID_TABLE_SIZE		251

////////////////////////////////////////////////////////////////////////////
//
// Function Prototypes
//
////////////////////////////////////////////////////////////////////////////

#ifdef UNICODE_TRACE
LPCTSTR
#else
const char *
#endif
SocketErrorText(void);

//PHWSINST FindPhysicalId(DWORD dwPhysicalId);
void NotifyRead        (PHWSINST pHws);
void NotifyWrite       (PHWSINST pHws);
void ProcessQueuedRecvs(PHWSINST pHws);
void ProcessQueuedSends(PHWSINST pHws);
void SocketCloseEvent  (PHWSINST pHws);
DWORD SocketToPhysicalId (SOCKET socket);
BOOL CreateSocketToPhysicalIdMapping(SOCKET socket, DWORD dwPhysicalId);
BOOL RemoveSocketToPhysicalIdMapping(SOCKET socket);

#if defined(__cplusplus)
}
#endif  // (__cplusplus)


#endif  // H245WS_H

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\h245recv.c ===
/******************************************************************************
 *
 *  File:  h245recv.c
 *
 *   INTEL Corporation Proprietary Information
 *   Copyright (c) 1994, 1995, 1996 Intel Corporation.
 *
 *   This listing is supplied under the terms of a license agreement
 *   with INTEL Corporation and may not be used, copied, nor disclosed
 *   except in accordance with the terms of that agreement.
 *
 *****************************************************************************/

/******************************************************************************
 *
 *  $Workfile:   h245recv.c  $
 *  $Revision:   1.13  $
 *  $Modtime:   06 Feb 1997 18:17:22  $
 *  $Log:   S:\sturgeon\src\h245\src\vcs\h245recv.c_v  $
 *
 * Fixed warnings.
 *
 *    Rev 1.11   01 Nov 1996 15:24:56   EHOWARDX
 *
 * Added check for link not disconnected before re-posting receive buffer
 * to link layer to eliminate annoying error message from link layer.
 *
 *    Rev 1.10   22 Jul 1996 17:33:42   EHOWARDX
 * Updated to latest Interop API.
 *
 *    Rev 1.9   01 Jul 1996 16:14:32   EHOWARDX
 * locks
 * Added FunctionNotSupported if ossDecode fails.
 *
 *    Rev 1.8   10 Jun 1996 16:53:46   EHOWARDX
 * Removed special handling of EndSession since shutdown moved to InstanceUnlo
 *
 *    Rev 1.7   05 Jun 1996 17:14:28   EHOWARDX
 * Further work on converting to HRESULT; added PrintOssError to eliminate
 * pErrorString from instance structure.
 *
 *    Rev 1.6   04 Jun 1996 18:18:16   EHOWARDX
 * Interop Logging changes inside #if defined(PCS_COMPLIANCE) conditionals.
 *
 *    Rev 1.5   30 May 1996 23:39:10   EHOWARDX
 * Cleanup.
 *
 *    Rev 1.4   28 May 1996 14:25:08   EHOWARDX
 * Tel Aviv update.
 *
 *    Rev 1.3   21 May 1996 13:40:46   EHOWARDX
 * Added LOGGING switch to log PDUs to the file H245.OUT.
 * Add /D "LOGGING" to project options to enable this feature.
 *
 *    Rev 1.2   17 May 1996 16:44:22   EHOWARDX
 * Changed to use LINK_RECV_CLOSED to signal link layer close.
 *
 *    Rev 1.1   17 May 1996 16:20:32   EHOWARDX
 * Added code to change API state if zero-length buffer received
 * signalling link layer closed.
 *
 *    Rev 1.0   09 May 1996 21:06:24   EHOWARDX
 * Initial revision.
 *
 *    Rev 1.8.1.5   09 May 1996 19:33:58   EHOWARDX
 * Redesigned locking logic.
 * Simplified link API.
 *
 *    Rev 1.17   29 Apr 1996 16:05:12   EHOWARDX
 * Added special case handling of EndSessionCommand to ReceiveComplete().
 *
 *    Rev 1.16   27 Apr 1996 21:13:14   EHOWARDX
 * Hope we finally got ossDecode() failure handling right...
 *
 *    Rev 1.15   27 Apr 1996 13:08:54   EHOWARDX
 * Also need to terminate while loop if ossDecode fails!
 *
 *    Rev 1.8.1.4   27 Apr 1996 11:25:36   EHOWARDX
 * Changed to not call FsmIncoming if ossDecode fails...
 *
 *
 *    Rev 1.8.1.3   25 Apr 1996 21:26:46   EHOWARDX
 * Changed to use pInstance->p_ossWorld instead of bAsnInitialized.
 *
 *    Rev 1.8.1.2   23 Apr 1996 14:44:30   EHOWARDX
 * Updated.
 *
 *    Rev 1.8.1.1   15 Apr 1996 15:12:00   EHOWARDX
 * Updated.
 *
 *    Rev 1.8.1.0   26 Mar 1996 19:15:24   EHOWARDX
 *
 * Commented out hTraceFile for H.323
 *
 *    Rev 1.8   21 Mar 1996 17:21:36   dabrown1
 *
 * - put in test1/2 trace fdwrite
 *
 *    Rev 1.7   13 Mar 1996 11:31:56   DABROWN1
 *
 * Enable logging for ring0
 *
 *    Rev 1.6   06 Mar 1996 13:13:04   DABROWN1
 *
 * flush receive buffer functionality
 *
 *    Rev 1.5   01 Mar 1996 17:25:54   DABROWN1
 *
 * moved oss 'world' context to h245instance
 * changed oss delete from ossFreeBuf to ossFreePDU
 *
 *    Rev 1.4   23 Feb 1996 13:56:04   DABROWN1
 *
 * added H245TRACE / ASSERT calls
 *
 *    Rev 1.3   21 Feb 1996 12:09:56   EHOWARDX
 * Eliminated unused local variables.
 *
 *    Rev 1.2   21 Feb 1996 08:25:08   DABROWN1
 *
 * Provide multiple buffers receiving > 1 message (ie., link ACKs).
 *
 *    Rev 1.1   13 Feb 1996 14:46:06   DABROWN1
 *
 * changed asnexp.h (no longer there) to fsmexp.h
 *
 *    Rev 1.0   09 Feb 1996 17:36:20   cjutzi
 * Initial revision.
 *
 *****************************************************************************/
#ifndef STRICT
#define STRICT
#endif

/***********************/
/*   SYSTEM INCLUDES   */
/***********************/
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <limits.h>

#include "precomp.h"



/***********************/
/*    H245 INCLUDES    */
/***********************/
#ifdef  _IA_SPOX_
# define _DLL
#endif //_IA_SPOX_

#include "h245com.h"
#include "sr_api.h"

#if defined(_DEBUG) || defined(PCS_COMPLIANCE)
#include "interop.h"
#include "h245plog.h"
extern  LPInteropLogger H245Logger;
#endif  // (PCS_COMPLIANCE)

#ifdef  _IA_SPOX_
# undef _DLL
#endif //_IA_SPOX_



/**************************************************************************
** Function    : h245ReceiveComplete
** Description : Receive Completion Callback routine from link layer
***************************************************************************/

HRESULT
H245FunctionNotSupported(struct InstanceStruct *pInstance, unsigned short wChoice, unsigned char *pBuf, unsigned uLength)
{
    HRESULT             status  = H245_ERROR_OK;            
    MltmdSystmCntrlMssg *pPdu   = NULL;

    pPdu = (MltmdSystmCntrlMssg *) MemAlloc(sizeof(MltmdSystmCntrlMssg));
    if(NULL != pPdu)
    {
        memset(pPdu, 0, sizeof(MltmdSystmCntrlMssg));

        pPdu->choice = indication_chosen;
        pPdu->u.indication.choice = IndicationMessage_functionNotSupported_chosen;
        pPdu->u.indication.u.functionNotSupported.cause.choice = wChoice;
        if (pBuf != NULL && uLength != 0)
        {
            pPdu->u.indication.u.functionNotSupported.bit_mask = returnedFunction_present;
            pPdu->u.indication.u.functionNotSupported.returnedFunction.length = (WORD)uLength;
            pPdu->u.indication.u.functionNotSupported.returnedFunction.value  = pBuf;
        }
        else
        {
            pPdu->u.indication.u.functionNotSupported.bit_mask = 0;
        }

        status = sendPDU(pInstance, pPdu);
        
        MemFree(pPdu);
        pPdu = NULL;
    }
    else
    {
        status = H245_ERROR_NOMEM;
    }

    return status;
} // H245FunctionNotSupported()

void h245ReceiveComplete(DWORD_PTR h245Inst,
                         HRESULT dwMessage,
                         PBYTE   pbDataBuf,
                         DWORD   dwLength)
{
    struct InstanceStruct *pInstance;
    int                  pduNum = MltmdSystmCntrlMssg_PDU;
    ASN1_BUF             Asn1Buf;
    MltmdSystmCntrlMssg *pPdu;
    int                 nRet;

    // Validate the instance handle
    pInstance = InstanceLock(h245Inst);
    if (pInstance == NULL) {
        H245TRACE(h245Inst, 1, "h245ReceiveComplete: Instance not found");
        return;
    }

    // ONLY submit buffers to the decoder if it's for data received,
    // skip for flushes
    switch (dwMessage) {
    case LINK_RECV_CLOSED:
        H245TRACE(h245Inst, 3, "h245ReceiveComplete: Link Layer closed");
        pInstance->API.SystemState = APIST_Disconnected;
        InstanceUnlock(pInstance);
        return;

    case LINK_RECV_DATA:

        if (pInstance->pWorld == NULL) {
            H245TRACE(h245Inst, 1, "h245ReceiveComplete: ASN.1 Decoder not initialized");
            InstanceUnlock(pInstance);
            return;
        }


        switch (pInstance->Configuration) {
        case H245_CONF_H324:
            Asn1Buf.value  = &pbDataBuf[2];
            Asn1Buf.length = dwLength;
            break;

        default:
            Asn1Buf.value  = pbDataBuf;
            Asn1Buf.length = dwLength;
        } // switch

        // Loop around as long as the length field is positive.
        // ASN.1 decoder will update the length for each PDU it decodes until
        // a 0 length is achieved.
        while (Asn1Buf.length > 0)
        {
            int savePduLength = Asn1Buf.length;
            PBYTE savePdu = Asn1Buf.value;
            pPdu = NULL;

#if defined(_DEBUG) || defined(PCS_COMPLIANCE)
            if (H245Logger)
                InteropOutput(H245Logger,
                              (BYTE FAR *)Asn1Buf.value,
                              (int)Asn1Buf.length,
                              H245LOG_RECEIVED_PDU);
#endif  // (PCS_COMPLIANCE)

            nRet = H245_Decode(pInstance->pWorld,
                            (void **)&pPdu,
                            pduNum,
                            &Asn1Buf);

            if (ASN1_SUCCEEDED(nRet))
            {
                // Decode succeeded

                H245TRACE(h245Inst, 3, "H.245 Msg decode successful");

                // Pass on data to finite state machine
                FsmIncoming(pInstance, pPdu);
            }
            else
            {
                // Decode failed
                H245FunctionNotSupported(pInstance, syntaxError_chosen, savePdu, savePduLength);
                Asn1Buf.length = 0;          // Terminate loop!
            }

            if (pPdu != NULL)
            {
                // Free the memory used by the ASN.1 library
                if (freePDU(pInstance->pWorld, pduNum, pPdu, H245ASN_Module))
                {
                H245TRACE(h245Inst, 1, "SR: FREE FAILURE");
                }
            }
        } // while (Asn1Buf.length > 0)

        if (pInstance->API.SystemState != APIST_Disconnected)
        {
            // Repost the buffer to the data link layer
            pInstance->SendReceive.hLinkReceiveReq(pInstance->SendReceive.hLinkLayerInstance,
                                                   pbDataBuf,
                                                   pInstance->SendReceive.dwPDUSize);
        }
        break; // case LINK_RECV_DATA

    case LINK_RECV_ABORT:
        // Receive buffer flush in process
        ASSERT(pbDataBuf != NULL);
        H245TRACE(h245Inst, 3, "SR: RX Flush Buffer");
        break;

    case LINK_FLUSH_COMPLETE:
        // Receive buffer flush done
        ASSERT(pbDataBuf == NULL);
        H245TRACE(h245Inst, 3, "SR: RX Flush Complete");
        pInstance->SendReceive.dwFlushMap &= ~DATALINK_RECEIVE;
        break;

    default:
        H245TRACE(h245Inst, 1, "SR: RX COMPLETE Error %d", dwMessage);
        break;
    } // switch
    InstanceUnlock(pInstance);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\h245wsrx.cpp ===
/***************************************************************************
 *
 * File: h245wsrx.c
 *
 * INTEL Corporation Proprietary Information
 * Copyright (c) 1996 Intel Corporation.
 *
 * This listing is supplied under the terms of a license agreement
 * with INTEL Corporation and may not be used, copied, nor disclosed
 * except in accordance with the terms of that agreement.
 *
 ***************************************************************************
 *
 * $Workfile:   h245wsrx.cpp  $
 * $Revision:   2.4  $
 * $Modtime:   30 Jan 1997 17:15:58  $
 * $Log:   S:/STURGEON/SRC/H245WS/VCS/h245wsrx.cpv  $
 * 
 *    Rev 2.4   30 Jan 1997 17:17:16   EHOWARDX
 * Fixed bug in trace message - need to do trace before
 * calling shutdown() sent shutdown clears error retrieved
 * by WSAGetLastError().
 * 
 *    Rev 2.3   14 Jan 1997 15:48:04   EHOWARDX
 * Changed TryRecv() and TrySend() to check for WSAECONNRESET and
 * WSAECONNABORT return from recv() and send() and act accordingly.
 * 
 *    Rev 2.2   19 Dec 1996 18:54:54   SBELL1
 * took out tag comments
 * 
 *    Rev 2.1   Dec 13 1996 17:31:00   plantz
 * moved #ifdef _cplusplus to after include files
// 
//    Rev 1.1   13 Dec 1996 12:11:34   SBELL1
// moved #ifdef _cplusplus to after include files
// 
//    Rev 1.0   11 Dec 1996 13:41:52   SBELL1
// Initial revision.
 * 
 *    Rev 1.19   08 Jul 1996 19:27:44   unknown
 * Second experiment to try to fix Q.931 shutdown problem.
 * 
 *    Rev 1.18   01 Jul 1996 16:45:12   EHOWARDX
 * 
 * Moved Call to SocketCloseEvent from TryRecv() to ProcessQueuedRecvs().
 * TryRecv() now returns LINK_RECV_CLOSED to trigger ProcessQueuedRecvs()
 * to call SocketCloseEvent().
 * 
 *    Rev 1.17   May 28 1996 18:14:36   plantz
 * Change error codes to use HRESULT. Propogate Winsock errors where appropriate
 * 
 *    Rev 1.16   17 May 1996 16:49:32   EHOWARDX
 * Shutdown fix.
 * 
 *    Rev 1.15   09 May 1996 18:33:16   EHOWARDX
 * 
 * Changes to build with new LINKAPI.H.
 * 
 *    Rev 1.14   29 Apr 1996 16:53:16   EHOWARDX
 * 
 * Added trace statement.
 * 
 *    Rev 1.13   Apr 29 1996 14:04:20   plantz
 * Call NotifyRead instead of ProcessQueuedRecvs.
 * 
 *    Rev 1.12   Apr 29 1996 12:14:06   plantz
 * Change tpkt header to include header size in packet length.
 * Assert that message length does not exceed INT_MAX.
 * .
 * 
 *    Rev 1.11   27 Apr 1996 14:07:32   EHOWARDX
 * Parenthesized return from TryRecv().
 * 
 *    Rev 1.10   Apr 25 1996 21:15:12   plantz
 * Check state of connection before attemting to call recv.
 * 
 *    Rev 1.9   Apr 24 1996 16:39:34   plantz
 * Merge 1.5.1.0 with 1.8 (changes for winsock 1)
 * 
 *    Rev 1.5.1.0   Apr 24 1996 16:23:00   plantz
 * Change to not use overlapped I/O (for winsock 1).
 * 
 *    Rev 1.5   01 Apr 1996 14:20:12   unknown
 * Shutdown redesign.
 * 
 *    Rev 1.4   19 Mar 1996 20:18:16   EHOWARDX
 * 
 * Redesigned shutdown.
 * 
 *    Rev 1.3   18 Mar 1996 19:08:32   EHOWARDX
 * Fixed shutdown; eliminated TPKT/WSCB dependencies.
 * Define TPKT to put TPKT/WSCB dependencies back in.
 * 
 *    Rev 1.2   14 Mar 1996 17:01:58   EHOWARDX
 * 
 * NT4.0 testing; got rid of HwsAssert(); got rid of TPKT/WSCB.
 * 
 *    Rev 1.1   09 Mar 1996 21:12:02   EHOWARDX
 * Fixes as result of testing.
 * 
 *    Rev 1.0   08 Mar 1996 20:20:18   unknown
 * Initial revision.
 *
 ***************************************************************************/

#define LINKDLL_EXPORT

#pragma warning ( disable : 4115 4201 4214 4514 )
#undef _WIN32_WINNT	// override bogus platform definition in our common build environment


#include "precomp.h"

#include <limits.h>
//#include <winsock.h>
#include "queue.h"
#include "linkapi.h"
#include "h245ws.h"
#include "tstable.h"

#if defined(__cplusplus)
extern "C"
{
#endif  // (__cplusplus)


// If we are not using the Unicode version of the ISR display utility, then redefine
// the __TEXT macro to do nothing.

#ifndef UNICODE_TRACE
#undef  __TEXT
#define __TEXT(x) x
#endif

extern TSTable<HWSINST>* gpInstanceTable;	// global ptr to the instance table

#define GetTpktLength(pReq) (((pReq)->req_TpktHeader[2] << 8) + (pReq)->req_TpktHeader[3])


/*++

Description:
   Start a receive

Arguments:
   pHws              - Pointer to context for "connection"
   pReq              - Pointer to I/O request structure

Return Value:
   SUCCESS                       - Successfully started receive.
   LINK_RECV_ERROR_WOULD_BLOCK   - 
   Winsock error

--*/

static HRESULT
TryRecv(IN PHWSINST pHws, IN char *data, IN int length, IN OUT int *total_bytes_done)
{
   int requested_length = length - *total_bytes_done;
   int recv_result = recv(pHws->hws_Socket, data+*total_bytes_done, requested_length, 0);

   if (recv_result == SOCKET_ERROR)
   {
      int err = WSAGetLastError();
      switch (err)
      {
      case WSAEWOULDBLOCK:
         return LINK_RECV_WOULD_BLOCK;

      case WSAECONNABORTED:
      case WSAECONNRESET:
         HWSTRACE1(pHws->hws_dwPhysicalId, HWS_WARNING,
                   __TEXT("TryRecv: recv() returned %s"),
                   SocketErrorText());
         if (pHws->hws_uState == HWS_CONNECTED)
         {
            HWSTRACE0(pHws->hws_dwPhysicalId, HWS_TRACE,
                      __TEXT("TryRecv: calling shutdown"));
            if (shutdown(pHws->hws_Socket, 1) == SOCKET_ERROR)
            {
               HWSTRACE1(pHws->hws_dwPhysicalId, HWS_WARNING,
                        __TEXT("TryRecv: shutdown() returned %s"),
                        SocketErrorText());
            }
            pHws->hws_uState = HWS_CLOSING;
         }
         return MAKE_WINSOCK_ERROR(err);

      default:
         HWSTRACE1(pHws->hws_dwPhysicalId, HWS_WARNING,
                   __TEXT("TryRecv: recv() returned %s"),
                   SocketErrorText());
         return MAKE_WINSOCK_ERROR(err);
      } // switch
   }

   HWSTRACE1(pHws->hws_dwPhysicalId, HWS_TRACE, __TEXT("TryRecv: recv returned %d"), recv_result);
   if (recv_result == 0)
   {
      return LINK_RECV_CLOSED;
   }

   *total_bytes_done += recv_result;
   return (recv_result == requested_length) ? NOERROR : LINK_RECV_WOULD_BLOCK;
}


static HRESULT
RecvStart(IN PHWSINST pHws, IN PREQUEST pReq)
{
   HRESULT nResult = NOERROR;

   // Sanity checks
   HWSASSERT(pHws != NULL);
   HWSASSERT(pHws->hws_dwMagic == HWSINST_MAGIC);
   HWSASSERT(pReq != NULL);
   HWSASSERT(pReq->req_dwMagic == RECV_REQUEST_MAGIC);
   HWSASSERT(pReq->req_pHws == pHws);

   // Get the header first; if that succeeds get the client data
   if (pReq->req_header_bytes_done < TPKT_HEADER_SIZE)
   {
       nResult = TryRecv(pHws,
                         (char *)pReq->req_TpktHeader,
                         TPKT_HEADER_SIZE,
                         &pReq->req_header_bytes_done);
   }

   if (nResult == NOERROR)
   {
       long int tpkt_length = GetTpktLength(pReq) - TPKT_HEADER_SIZE;
       if (pReq->req_TpktHeader[0] != TPKT_VERSION || tpkt_length <= 0)
       {
          // Invalid header version
          HWSTRACE0(pHws->hws_dwPhysicalId, HWS_CRITICAL,
                    __TEXT("RecvComplete: bad header version; available data discarded"));
          // Should this be reported to the client??

          // Read and discard all available data
          // The client's buffer is used as a temporary buffer.
          while (recv(pHws->hws_Socket, (char *)pReq->req_client_data, pReq->req_client_length, 0) > 0)
              ;

          // Mark the header for this request as unread; it
          // will be read again when additional data is received.
          pReq->req_header_bytes_done = 0;
          nResult = LINK_RECV_ERROR;
       }
       else if (tpkt_length > pReq->req_client_length)
       {
          // Packet too large
          int request_length;
          int result;

          HWSTRACE0(pHws->hws_dwPhysicalId, HWS_CRITICAL,
                    __TEXT("RecvComplete: packet too large; packet discarded"));
          // Should this be reported to the client??

          // Read and discard the packet
          // The client's buffer is used as a temporary buffer.
          do {
              request_length = pReq->req_client_length;
              if (request_length > tpkt_length)
                  request_length = tpkt_length;
              result = recv(pHws->hws_Socket, (char *)pReq->req_client_data, request_length, 0);
          } while (result > 0 && (tpkt_length -= result) > 0);

          if (result == SOCKET_ERROR && WSAGetLastError() == WSAEWOULDBLOCK)
          {
              //TODO: packet too large handling
              // Adjust the header so that the rest of this packet will be read, but
              // flag it so that it is known to be an error and will not be returned
              // to the client.
          }
          else
          {
              // Mark the header for this request as unread; it
              // will be read again for the next packet received.
              pReq->req_header_bytes_done = 0;
          }

          nResult = LINK_RECV_ERROR;
       }
       else
       {
           // Normal case
           // The current implementation of TryRecv requires that the requested
           // size fit in a signed int (because that is what Winsock supports
           // in a single recv). This is guaranteed at this point regardless
           // of the originator of the packets, because we don't allow a buffer
           // to be posted that is larger than that (see ASSERT below). If the
           // packet were larger than the buffer, it would have been caught above.
           // If TryRecv is changed to remove the restriction on buffer size and
           // accept a parameter of type long int, this ASSERT may be removed.
           HWSASSERT(tpkt_length <= INT_MAX);
           nResult = TryRecv(pHws,
                             (char *)pReq->req_client_data,
                             (int)tpkt_length,
                             &pReq->req_client_bytes_done);
       }
   }

   return nResult;
} // RecvStart()


void
ProcessQueuedRecvs(IN PHWSINST pHws)
{
   register PREQUEST    pReq;
   register DWORD       dwPhysicalId = pHws->hws_dwPhysicalId;

   HWSASSERT(pHws != NULL);
   HWSASSERT(pHws->hws_dwMagic == HWSINST_MAGIC);
   HWSASSERT(pHws->hws_uState <= HWS_CLOSING);
   HWSTRACE0(pHws->hws_dwPhysicalId, HWS_TRACE, __TEXT("ProcessQueuedRecvs"));

   while ((pReq = (PREQUEST) QRemove(pHws->hws_pRecvQueue)) != NULL)
   {
      switch (RecvStart(pHws, pReq))
      {
      case NOERROR:
         // Call Recv callback
         pHws->hws_h245RecvCallback(pHws->hws_dwH245Instance,
                                    LINK_RECV_DATA,
                                    pReq->req_client_data,
                                    pReq->req_client_bytes_done);

         // Free the I/O request structure
         MemFree(pReq);

         // Check to see if callback deallocated our instance or state changed

         // Check to see if callback deallocated our instance - this can be done
  	      // by attempting a lock - which will now fail if the entry has been marked
	      // for deletion.  Thus, if the lock succeeds, then just unlock it (since we 
	      // already have a lock on it in a higher level function).

		   if(gpInstanceTable->Lock(dwPhysicalId) == NULL)
			   return;
		   gpInstanceTable->Unlock(dwPhysicalId);
		   if(pHws->hws_uState > HWS_CONNECTED)
		      return;

         break;

      default:
         HWSTRACE0(pHws->hws_dwPhysicalId, HWS_WARNING,
                   __TEXT("ProcessQueuedRecvs: RecvStart() failed"));

         // Fall-through to next case is intentional

      case LINK_RECV_WOULD_BLOCK:
         // The receive would have blocked; we need to requeue the I/O request
         // and wait for a FD_READ network event.
         // If any part of the data was received, the bytes_done field has been updated.
         if (QInsertAtHead(pHws->hws_pRecvQueue, pReq) == FALSE)
         {
            HWSTRACE0(pHws->hws_dwPhysicalId, HWS_CRITICAL,
                      __TEXT("ProcessQueuedRecvs: QInsertAtHead() failed"));
         }
         return;

      case LINK_RECV_CLOSED:
         if (QInsertAtHead(pHws->hws_pRecvQueue, pReq) == FALSE)
         {
            HWSTRACE0(pHws->hws_dwPhysicalId, HWS_CRITICAL,
                      __TEXT("ProcessQueuedRecvs: QInsertAtHead() failed"));
         }
         SocketCloseEvent(pHws);
         return;

      } // switch
   } // while
} // ProcessQueuedRecvs()






/**************************************************************************
** Function    : datalinkReceiveRequest
** Description : Fills header/tail of buffer and posts buffer to H.223
***************************************************************************/
LINKDLL HRESULT datalinkReceiveRequest( DWORD    dwPhysicalId,
                                        PBYTE    pbyDataBuf,
                                        DWORD    dwLength)
{
   register PHWSINST    pHws;
   register PREQUEST    pReq;

   HWSTRACE0(dwPhysicalId, HWS_TRACE, __TEXT("datalinkReceiveRequest"));

   pHws = gpInstanceTable->Lock(dwPhysicalId);

   if (pHws == NULL)
   {
      HWSTRACE0(dwPhysicalId, HWS_ERROR,
                __TEXT("datalinkReceiveRequest: dwPhysicalId not found"));
      return LINK_INVALID_INSTANCE;
   }

   if (pHws->hws_uState > HWS_CONNECTED)
   {
      HWSTRACE1(dwPhysicalId, HWS_ERROR,
                __TEXT("datalinkReceiveRequest: state = %d"), pHws->hws_uState);
	   gpInstanceTable->Unlock(dwPhysicalId);
      return LINK_INVALID_STATE;
   }

   // Allocate request structure
   pReq = (PREQUEST) MemAlloc(sizeof(*pReq));
   if (pReq == NULL)
   {
      HWSTRACE0(dwPhysicalId, HWS_WARNING,
                __TEXT("datalinkReceiveRequest: could not allocate request buffer"));
	   gpInstanceTable->Unlock(dwPhysicalId);
      return LINK_MEM_FAILURE;
   }

   // The current implementation requires that the size of each message
   // fit in a signed int (because that is what Winsock supports in a
   // single recv). If it is necessary to receive larger messages,
   // TryRecv and RecvStart must be changed to limit the size in each
   // recv call, and loop until all the data is received.
   // This ASSERT could then be removed.
   HWSASSERT(dwLength <= INT_MAX);

   pReq->req_pHws             = pHws;
   pReq->req_header_bytes_done= 0;
   pReq->req_client_data      = pbyDataBuf;
   pReq->req_client_length    = (int)dwLength;
   pReq->req_client_bytes_done= 0;
   pReq->req_dwMagic          = RECV_REQUEST_MAGIC;

   if (QInsert(pHws->hws_pRecvQueue, pReq) == FALSE)
   {
      HWSTRACE0(pHws->hws_dwPhysicalId, HWS_CRITICAL,
                __TEXT("datalinkReceiveRequest: QInsert() failed"));
	  gpInstanceTable->Unlock(dwPhysicalId);
      MemFree(pReq);
      return LINK_RECV_NOBUFF;
   }

   if (pHws->hws_uState == HWS_CONNECTED)
       NotifyRead(pHws);

   HWSTRACE0(dwPhysicalId, HWS_TRACE, __TEXT("datalinkReceiveRequest: succeeded"));
   gpInstanceTable->Unlock(dwPhysicalId);
   return NOERROR;
} // datalinkReceiveRequest()



#if defined(__cplusplus)
}
#endif  // (__cplusplus)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\h245sys.c ===
/******************************************************************************
 *
 *   INTEL Corporation Proprietary Information
 *   Copyright (c) 1994, 1995, 1996 Intel Corporation.
 *
 *   This listing is supplied under the terms of a license agreement
 *   with INTEL Corporation and may not be used, copied, nor disclosed
 *   except in accordance with the terms of that agreement.
 *
 *****************************************************************************/

/******************************************************************************
 *
 *  $Workfile:   h245sys.c  $
 *  $Revision:   1.8  $
 *  $Modtime:   Mar 04 1997 17:38:08  $
 *  $Log:   S:/STURGEON/SRC/H245/SRC/VCS/h245sys.c_v  $
 *
 *    Rev 1.8   Mar 04 1997 17:51:56   tomitowx
 * process detach fix
 *
 *    Rev 1.7   24 Jan 1997 19:40:48   SBELL1
 * upgraded to oss 4.2
 *
 *    Rev 1.6   21 Jun 1996 18:53:22   unknown
 * Changed InstUnlock() to fix shutdown re-entrancy bug.
 *
 *    Rev 1.5   10 Jun 1996 16:59:34   EHOWARDX
 * Moved init/shutdown of submodules to CreateInstance/InstanceUnlock.
 *
 *    Rev 1.3   04 Jun 1996 13:57:02   EHOWARDX
 * Fixed Release build warnings.
 *
 *    Rev 1.2   28 May 1996 14:25:38   EHOWARDX
 * Tel Aviv update.
 *
 *    Rev 1.1   16 May 1996 13:51:26   EHOWARDX
 * Fixed minor timer/lock count interaction bugs.
 *
 *    Rev 1.0   09 May 1996 21:06:28   EHOWARDX
 * Initial revision.
 *
 *    Rev 1.25   09 May 1996 19:39:04   EHOWARDX
 * Changed includes.
 *
 *    Rev 1.24   29 Apr 1996 12:56:58   EHOWARDX
 * Made timers more accurate & made them use fewer resources.
 * Note: This is windows-specific.
 *
 *    Rev 1.18.1.2   15 Apr 1996 15:12:34   EHOWARDX
 * Kludge to not call H245DeInitTimer() when last timer is stopped.
 * This will have to be revisited later.
 *
 *    Rev 1.18.1.1   02 Apr 1996 22:06:22   EHOWARDX
 * No change.
 *
 *    Rev 1.18.1.0   27 Mar 1996 16:44:18   EHOWARDX
 * Changed timer code; decided it would work better if H245InitTimer()
 * actually got called.
 *
 *    Rev 1.18   26 Mar 1996 09:46:08   cjutzi
 *
 * - ok.. Added Enter&Leave&Init&Delete Critical Sections for Ring 0
 *
 *    Rev 1.17   25 Mar 1996 18:30:14   helgebax
 * - removed H245ASSERT .
 * .
 *
 *
 *    Rev 1.16   25 Mar 1996 18:10:48   cjutzi
 *
 * - well .. I broke the build.. had to put back what I did..
 *
 *
 *    Rev 1.15   25 Mar 1996 17:50:02   cjutzi
 *
 * - removed critical section.. back step
 *
 *    Rev 1.14   25 Mar 1996 17:20:34   cjutzi
 *
 * - added Remesh's EnterCritical section definitions.. to use
 *   oil layer.
 *
 *    Rev 1.13   18 Mar 1996 12:44:40   cjutzi
 *
 * - put NULL as callback at shutdown
 *
 *    Rev 1.12   18 Mar 1996 12:41:32   cjutzi
 * - added timer code for multiple timers queue..
 *
 *    Rev 1.11   12 Mar 1996 15:48:46   cjutzi
 *
 * - added InstanceTbl Lock
 *
 *    Rev 1.10   07 Mar 1996 22:47:34   dabrown1
 *
 * Modifications required for ring0/ring3 compatibilty
 *
 *    Rev 1.9   02 Mar 1996 22:14:52   DABROWN1
 *
 * removed h245_bzero and h245_bcopy (use memset and memcpy instead)
 *
 *    Rev 1.8   26 Feb 1996 17:10:56   cjutzi
 *
 * - removed h245sys.h
 *
 *    Rev 1.7   26 Feb 1996 12:42:26   cjutzi
 *
 * - added bcopy
 *
 *    Rev 1.6   21 Feb 1996 16:23:38   DABROWN1
 *
 * removed h245_ASN1free
 * modified malloc and free to save buffer size internally
 *
 *    Rev 1.5   13 Feb 1996 14:54:12   DABROWN1
 *
 * removed trace/debug files to new debug directory
 *
 *    Rev 1.4   09 Feb 1996 15:45:08   cjutzi
 * - added h245trace
 * - added h245Assert
 *
 *****************************************************************************/
#ifndef STRICT
#define STRICT
#endif

#include "precomp.h"

#include "h245api.h"
#include "h245com.h"
#include "h245sys.x"

/**************************************************************************
 *
 * Instance Table/Instance Lock implementation
 *
 **************************************************************************/

CRITICAL_SECTION        InstanceCreateLock     = {0};
CRITICAL_SECTION        InstanceLocks[MAXINST] = {0};
struct InstanceStruct * InstanceTable[MAXINST] = {0};

struct InstanceStruct *InstanceCreate(DWORD dwPhysId, H245_CONFIG_T Configuration)
{
  register struct InstanceStruct *pInstance;
  register unsigned int           uIndex;
  unsigned int                    uFirst = (dwPhysId - 1) % MAXINST;
  HRESULT                         lError;

  // Allocate new instance
  pInstance = (struct InstanceStruct *)MemAlloc(sizeof(*pInstance));
  if (pInstance == NULL)
  {
    H245TRACE(dwPhysId,1,"InstanceCreate -> Instance malloc failed");
    return NULL;
  }

  // Make sure no one is trying to simultaneously add same physical Id
  // (I know this is a stretch...)
  EnterCriticalSection(&InstanceCreateLock);

  // Check if instance corresponding to dwPhysId already exists
  uIndex = uFirst;                      // Hash start index into table
  do
  {
    // Avoid entering critical section for unused instances
    if (InstanceTable[uIndex])
    {
      EnterCriticalSection(&InstanceLocks[uIndex]);
      if (InstanceTable[uIndex] && InstanceTable[uIndex]->dwPhysId == dwPhysId)
      {
        LeaveCriticalSection(&InstanceLocks[uIndex]);
        LeaveCriticalSection(&InstanceCreateLock);
        MemFree(pInstance);
        H245TRACE(dwPhysId,1,"InstanceCreate -> Physical Id already in use");
        return NULL;
      }
      LeaveCriticalSection(&InstanceLocks[uIndex]);
    }
    uIndex = (uIndex + 1) % MAXINST;
  } while (uIndex != uFirst);

  // Find empty slot for new instance
  uIndex = uFirst;                      // Hash start index into table
  do
  {
    // Avoid entering critical section for used instances
    if (InstanceTable[uIndex] == NULL)
    {
      EnterCriticalSection(&InstanceLocks[uIndex]);
      if (InstanceTable[uIndex] == NULL)
      {
        // Initialize new instance
        // Once the new instance is added to the instance table,
        // we can relinquish the CreateInstanceLock
        InstanceTable[uIndex] = pInstance;
        LeaveCriticalSection(&InstanceCreateLock);
        memset(pInstance, 0, sizeof(*pInstance));
        pInstance->dwPhysId  = dwPhysId;
        pInstance->dwInst    = uIndex + 1;
        pInstance->LockCount = 1;

        /* API Subsystem Initialization */
        pInstance->Configuration = Configuration;
        lError = api_init(pInstance);
        if (lError != H245_ERROR_OK)
        {
          InstanceTable[uIndex] = NULL;
          LeaveCriticalSection(&InstanceLocks[uIndex]);
          MemFree(pInstance);
          H245TRACE(dwPhysId,1,"InstanceCreate -> api_init failed");
          return NULL;
        }

        /* Send Receive Subsystem Initialization */
        lError = sendRcvInit(pInstance);
        if (lError != H245_ERROR_OK)
        {
          api_deinit(pInstance);
          InstanceTable[uIndex] = NULL;
          LeaveCriticalSection(&InstanceLocks[uIndex]);
          MemFree(pInstance);
          H245TRACE(dwPhysId,1,"InstanceCreate -> sendRcvInit failed");
          return NULL;
        }

        /* State Machine Subsystem Initialization */
        lError = Fsm_init(pInstance);
        if (lError != H245_ERROR_OK)
        {
          sendRcvShutdown(pInstance);
          api_deinit(pInstance);
          InstanceTable[uIndex] = NULL;
          LeaveCriticalSection(&InstanceLocks[uIndex]);
          MemFree(pInstance);
          H245TRACE(dwPhysId,1,"InstanceCreate -> Fsm_init failed");
          return NULL;
        }

        H245TRACE(pInstance->dwInst,9,"InstanceCreate: ++LockCount=%d", pInstance->LockCount);
        return pInstance;                 // Return locked instance
      }
      LeaveCriticalSection(&InstanceLocks[uIndex]);
    }
    uIndex = (uIndex + 1) % MAXINST;
  } while (uIndex != uFirst);

  LeaveCriticalSection(&InstanceCreateLock);
  MemFree(pInstance);
  H245TRACE(dwPhysId,1,"InstanceCreate -> Too many instances");
  return NULL;
} // InstanceCreate()

struct InstanceStruct *InstanceLock(register H245_INST_T dwInst)
{
  if (--dwInst >= MAXINST)
  {
    H245TRACE(dwInst+1,1,"InstanceLock -> Invalid instance");
    return NULL;
  }

  if (!InstanceTable[dwInst])
  {
      H245TRACE(dwInst+1,1,"InstanceLock -> Invalid instance");
      return NULL;
  }
  // Lock instance, then see if it still exists
  EnterCriticalSection(&InstanceLocks[dwInst]);
  if (InstanceTable[dwInst])
  {
    InstanceTable[dwInst]->LockCount++;
    H245TRACE(dwInst+1,9,"InstanceLock: ++LockCount=%d", InstanceTable[dwInst]->LockCount);
    return InstanceTable[dwInst];      // Return locked instance
  }
  LeaveCriticalSection(&InstanceLocks[dwInst]);
  H245TRACE(dwInst+1,1,"InstanceLock -> Invalid instance");
  return NULL;
} // InstanceLock()

int InstanceUnlock(struct InstanceStruct *pInstance)
{
  register H245_INST_T dwInst = pInstance->dwInst - 1;
  if (dwInst >= MAXINST || InstanceTable[dwInst] != pInstance)
  {
    H245TRACE(pInstance->dwInst,1,"InstanceUnlock -> Invalid instance");
    return -1;
  }
  if (pInstance->fDelete && pInstance->LockCount == 1)
  {
    H245TRACE(pInstance->dwInst,9,"InstanceUnlock: deleting instance");
    pInstance->fDelete = FALSE; // InstanceUnlock will be re-entered from H245WS callback!
    Fsm_shutdown(pInstance);
    sendRcvShutdown(pInstance);
    api_deinit(pInstance);
    InstanceTable[dwInst] = NULL;
    LeaveCriticalSection(&InstanceLocks[dwInst]);
    while (pInstance->pTimerList)
    {
      register TimerList_T *pTimer = pInstance->pTimerList;
      pInstance->pTimerList = pTimer->pNext;
      H245TRACE(pInstance->dwInst,1,"InstanceUnlock: deleting timer");
      MemFree(pTimer);
    }
    MemFree(pInstance);
  }
  else
  {
    pInstance->LockCount--;
    H245TRACE(pInstance->dwInst,9,"InstanceUnlock: --LockCount=%d", pInstance->LockCount);
    LeaveCriticalSection(&InstanceLocks[dwInst]);
  }
  return 0;
} // InstanceUnlock()

int InstanceDelete(struct InstanceStruct *pInstance)
{
  H245TRACE(pInstance->dwInst,9,"InstanceDelete");
  pInstance->fDelete = TRUE;
  return InstanceUnlock(pInstance);
} // InstanceDelete()



int InstanceUnlock_ProcessDetach(struct InstanceStruct *pInstance, BOOL fProcessDetach)
{
  register H245_INST_T dwInst = pInstance->dwInst - 1;
  if (dwInst >= MAXINST || InstanceTable[dwInst] != pInstance)
  {
    H245TRACE(pInstance->dwInst,1,"InstanceUnlock -> Invalid instance");
    return -1;
  }
  if (pInstance->fDelete && pInstance->LockCount == 1)
  {
    H245TRACE(pInstance->dwInst,9,"InstanceUnlock: deleting instance");
    pInstance->fDelete = FALSE; // InstanceUnlock will be re-entered from H245WS callback!

    Fsm_shutdown(pInstance);
    //sendRcvShutdown(pInstance);
    sendRcvShutdown_ProcessDetach(pInstance,fProcessDetach);

    api_deinit(pInstance);
    InstanceTable[dwInst] = NULL;
    LeaveCriticalSection(&InstanceLocks[dwInst]);
    while (pInstance->pTimerList)
    {
      register TimerList_T *pTimer = pInstance->pTimerList;
      pInstance->pTimerList = pTimer->pNext;
      H245TRACE(pInstance->dwInst,1,"InstanceUnlock: deleting timer");
      MemFree(pTimer);
    }
    MemFree(pInstance);
  }
  else
  {
    pInstance->LockCount--;
    H245TRACE(pInstance->dwInst,9,"InstanceUnlock: --LockCount=%d", pInstance->LockCount);
    LeaveCriticalSection(&InstanceLocks[dwInst]);
  }
  return 0;
} // InstanceUnlock_ProcessDetach()




/*****************************************************************************
 *
 * TYPE:  TIMER STUFF
 *
 *****************************************************************************/

CRITICAL_SECTION        TimerLock = {0};
static int              TimerInited = 0;
#ifndef _IA_SPOX_
static UINT_PTR         H245TimerId;
#endif

/*****************************************************************************
 *
 * TYPE:  Global System
 *
 * PROCEDURE:   H245TimerTick - ticks every 1000ms
 *
 * DESCRIPTION:
 *
 * RETURN:
 *
 *****************************************************************************/
void H245TimerTick (void)
{
  DWORD                           dwTickCount = GetTickCount();
  unsigned int                    uIndex;
  register struct InstanceStruct *pInstance;
  register TimerList_T           *pTimer;

  H245TRACE(0,9,"H245TimerTick <-");

  if (0 != TimerInited)
  {
    for (uIndex = 0; uIndex < MAXINST; ++uIndex)
    {
      // Avoid entering critical section for unused instances
      if (InstanceTable[uIndex])
      {
        pInstance = InstanceLock(uIndex + 1);
        if (pInstance)
        {
          while (pInstance->pTimerList && (pInstance->pTimerList->dwAlarm - dwTickCount) >= 0x80000000)
          {
            pTimer = pInstance->pTimerList;
            pInstance->pTimerList = pTimer->pNext;
            EnterCriticalSection(&TimerLock);
            if (--TimerInited == 0)
            {
#ifdef _IA_SPOX_
              H223_RegisterTimerCallBack((H223TIMERCB)NULL);
#else
              KillTimer (NULL, H245TimerId);
#endif
            }
            LeaveCriticalSection(&TimerLock);
            if (pTimer->pfnCallBack)
            {
              // TBD - what if pContext is no longer valid?
              (pTimer->pfnCallBack)(pInstance, (DWORD_PTR)pTimer, pTimer->pContext);
            }
            MemFree (pTimer);
          } // while
          InstanceUnlock(pInstance);
        } // if
      } // if
    } // for
  }
  H245TRACE(0,9,"H245TimerTick ->");
} // TimerTick()

/*****************************************************************************
 *
 * TYPE:  Global System
 *
 * PROCEDURE:   H245TimerProc - FOR WINDOWS Ring 3 only
 *
 * DESCRIPTION:
 *
 * RETURN:
 *
 *****************************************************************************/
#ifndef _IA_SPOX_
void CALLBACK  H245TimerProc(HWND  hwHwnd,
                             UINT  uiMessg,
                             UINT_PTR idTimer,
                             DWORD dwTime)
{
  if (idTimer == H245TimerId)
    H245TimerTick ();
}
#endif

/*****************************************************************************
 *
 * TYPE:        Global System
 *
 * PROCEDURE:   H245StartTimer
 *
 * DESCRIPTION:
 *
 * RETURN:
 *
 *****************************************************************************/
DWORD_PTR H245StartTimer (struct InstanceStruct *   pInstance,
                      void                  *   pContext,
                      H245TIMERCALLBACK         pfnCallBack,
                      DWORD                     dwTicks)
{
  TimerList_T   *pNew;
  TimerList_T   *pLook;
  TimerList_T   *pList;

  if (!pfnCallBack)
  {
    H245TRACE(pInstance->dwInst,1,"H245StartTimer: pfnCallBack == NULL");
    return 0;
  }

  pNew = (TimerList_T *)MemAlloc(sizeof(TimerList_T));
  if (pNew == NULL)
  {
    H245TRACE(pInstance->dwInst,1,"H245StartTimer: memory allocation failed");
    return 0;
  }

  pNew->pNext       = NULL;
  pNew->pContext    = pContext;
  pNew->pfnCallBack = pfnCallBack;
  pNew->dwAlarm     = GetTickCount() + dwTicks;

  EnterCriticalSection(&TimerLock);
  if (++TimerInited == 1)
  {
#ifdef _IA_SPOX_
    H223_RegisterTimerCallBack((H223TIMERCB)H245TimerTick);
#else
    H245TimerId = SetTimer ((HWND)NULL, (UINT)0, (UINT)1000, H245TimerProc);
#endif
  }
  LeaveCriticalSection(&TimerLock);

  /* as you traverse the list.. subtract the delta off the new one */
  /* and link it in.. this list is a list of delta's off the time  */
  /* out that is linked in front of it.. so subtract as you go     */
  for (pList = NULL, pLook = pInstance->pTimerList;
       pLook && (pLook->dwAlarm - pNew->dwAlarm) >= 0x80000000;
       pList = pLook, pLook = pLook->pNext);

  /* link it in the list */
  pNew->pNext = pLook;
  if (pList)
  {
    // Insert new timer after pList and before pLook
    pList->pNext = pNew;
  }
  else
  {
    // Insert new timer at front of list
    pInstance->pTimerList = pNew;
  }
  return (DWORD_PTR)pNew;
}


/*****************************************************************************
 *
 * TYPE:        Global System
 *
 * PROCEDURE:   H245StopTimer
 *
 * DESCRIPTION:
 *
 * RETURN:
 *
 *****************************************************************************/
DWORD H245StopTimer(struct InstanceStruct *pInstance, DWORD_PTR dwTimerId)
{
  TimerList_T   *pTimer = (TimerList_T *)dwTimerId;
  TimerList_T   *pLook;
  TimerList_T   *pList;

  ASSERT(TimerInited != 0);

  EnterCriticalSection(&TimerLock);
  if (--TimerInited == 0)
  {
#ifdef _IA_SPOX_
    H223_RegisterTimerCallBack((H223TIMERCB)NULL);
#else
    KillTimer (NULL, H245TimerId);
#endif
  }
  LeaveCriticalSection(&TimerLock);

  if (pInstance->pTimerList == NULL)
  {
    H245TRACE(pInstance->dwInst,1,"H245StopTimer: timer list NULL");
    return TRUE;
  }

  if (pTimer == pInstance->pTimerList)
  {
    pInstance->pTimerList = pTimer->pNext;
    MemFree (pTimer);
    return FALSE;
  }

  pList = pInstance->pTimerList;
  pLook = pList->pNext;
  while (pLook && pLook != pTimer)
  {
     pList = pLook;
     pLook = pLook->pNext;
  }

  /* if the timer exists.. */
  if (pLook == NULL)
  {
    H245TRACE(pInstance->dwInst,1,"H245StopTimer: pTimer not in timer list");
    return TRUE;
  }

  pList->pNext = pTimer->pNext;
  MemFree (pTimer);
  return FALSE;
}

#ifdef _IA_SPOX_
PUBLIC RESULT InitializeCriticalSection(CRITICAL_SECTION * phLock)

{
  return OIL_CreateLock(phLock);
}

PUBLIC RESULT EnterCriticalSection(CRITICAL_SECTION * phLock)
{
  return OIL_AcquireLock(*phLock);
}

PUBLIC RESULT LeaveCriticalSection(CRITICAL_SECTION * phLock)
{
  return OIL_ReleaseLock(*phLock);
}

PUBLIC RESULT DeleteCriticalSection(CRITICAL_SECTION * phLock)
{
  return OIL_DeleteLock(*phLock);
}
#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\h245send.c ===
/******************************************************************************
 *
 *  File:  h245send.c
 *
 *   INTEL Corporation Proprietary Information
 *   Copyright (c) 1994, 1995, 1996 Intel Corporation.
 *
 *   This listing is supplied under the terms of a license agreement
 *   with INTEL Corporation and may not be used, copied, nor disclosed
 *   except in accordance with the terms of that agreement.
 *
 *****************************************************************************/

/******************************************************************************
 *
 *  $Workfile:   h245send.c  $
 *  $Revision:   1.8  $
 *  $Modtime:   22 Jul 1996 17:24:18  $
 *  $Log:   S:/STURGEON/SRC/H245/SRC/VCS/h245send.c_v  $
 *
 *    Rev 1.8   22 Jul 1996 17:33:28   EHOWARDX
 * Updated to latest Interop API.
 *
 *    Rev 1.7   05 Jun 1996 17:14:30   EHOWARDX
 * Further work on converting to HRESULT; added PrintOssError to eliminate
 * pErrorString from instance structure.
 *
 *    Rev 1.6   04 Jun 1996 18:18:18   EHOWARDX
 * Interop Logging changes inside #if defined(PCS_COMPLIANCE) conditionals.
 *
 *    Rev 1.5   30 May 1996 23:39:12   EHOWARDX
 * Cleanup.
 *
 *    Rev 1.4   28 May 1996 14:25:18   EHOWARDX
 * Tel Aviv update.
 *
 *    Rev 1.3   21 May 1996 13:40:48   EHOWARDX
 * Added LOGGING switch to log PDUs to the file H245.OUT.
 * Add /D "LOGGING" to project options to enable this feature.
 *
 *    Rev 1.2   20 May 1996 14:35:14   EHOWARDX
 * Got rid of asynchronous H245EndConnection/H245ShutDown stuff...
 *
 *    Rev 1.1   17 May 1996 16:19:46   EHOWARDX
 * Changed sendPDU to return an error if link layer send fails.
 * (Probably should define a new error code for this...)
 *
 *    Rev 1.0   09 May 1996 21:06:26   EHOWARDX
 * Initial revision.
 *
 *    Rev 1.11.1.4   09 May 1996 19:34:46   EHOWARDX
 * Redesigned locking logic.
 * Simplified link API.
 *
 *    Rev 1.11.1.3   25 Apr 1996 21:27:14   EHOWARDX
 * Changed to use pInstance->p_ossWorld instead of bAsnInitialized.
 *
 *    Rev 1.11.1.2   23 Apr 1996 14:44:34   EHOWARDX
 * Updated.
 *
 *    Rev 1.11.1.1   15 Apr 1996 15:12:04   EHOWARDX
 * Updated.
 *
 *    Rev 1.11.1.0   26 Mar 1996 19:14:46   EHOWARDX
 *
 * Commented out hTraceFile for H.323
 *
 *    Rev 1.11   21 Mar 1996 17:20:40   dabrown1
 * - put in test1/2 trace fdwrite
 * .
 *
 * .
 *
 *
 *
 *
 *    Rev 1.10   13 Mar 1996 11:31:14   DABROWN1
 *
 * Enable logging for ring0
 *
 *    Rev 1.9   11 Mar 1996 15:32:06   DABROWN1
 *
 * Defined/Undefined _DLL for _IA_SPOX_ environment
 *
 *    Rev 1.8   06 Mar 1996 13:11:44   DABROWN1
 *
 * enable flush buffers
 *
 *    Rev 1.7   02 Mar 1996 22:10:26   DABROWN1
 * updated to new MemFree
 *
 *    Rev 1.6   01 Mar 1996 17:25:14   DABROWN1
 *
 * moved oss 'world' context to h245instance
 * delete buffer returned in sendcomplete instead of what was held in context
 *
 *    Rev 1.5   28 Feb 1996 14:52:18   DABROWN1
 * Put oss errors in range of SR (10000)
 *
 *    Rev 1.4   23 Feb 1996 13:56:30   DABROWN1
 *
 * added H245TRACE / ASSERT calls
 *
 *    Rev 1.3   21 Feb 1996 16:52:52   DABROWN1
 *
 * correct pointer passed to SRP for transmits
 *
 *    Rev 1.2   21 Feb 1996 10:50:42   EHOWARDX
 * Got rid of unreferenced local variable.
 *
 *    Rev 1.1   21 Feb 1996 08:24:20   DABROWN1
 * allocate/deallocate send buffers per message.  Enable sendComplete functiot
 *
 *    Rev 1.0   09 Feb 1996 17:37:42   cjutzi
 * Initial revision.
 *
 *****************************************************************************/
#ifndef STRICT
#define STRICT
#endif

/***********************/
/*   SYSTEM INCLUDES   */
/***********************/
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <limits.h>

#include "precomp.h"


/***********************/
/*    H245 INCLUDES    */
/***********************/
#ifdef   _IA_SPOX_
#define _DLL
#endif //_IA_SPOX_

#include "h245com.h"
#include "sr_api.h"

#if defined(_DEBUG) || defined(PCS_COMPLIANCE)
#include "interop.h"
#include "h245plog.h"
extern  LPInteropLogger H245Logger;
#endif  // (PCS_COMPLIANCE)

#ifdef   _IA_SPOX_
#undef  _DLL
#endif //_IA_SPOX_



/**************************************************************************
**  Function    : sendPDU
**  Description : Convert struct to ASN.1 PDU and forward to datalink layer
***************************************************************************/
HRESULT sendPDU(struct InstanceStruct  *pInstance,
                MltmdSystmCntrlMssg    *lp245MsgStruct)
{
    HRESULT         lError;
    ASN1_BUF        Asn1Buf;
    PBYTE           pEncoded_pdu;
    int             nRet;

    // Set up the oss struct for passing a pre-allocated buffer
    switch (pInstance->Configuration) {
    case H245_CONF_H324:
        // Allocate a buffer to transmit
        pEncoded_pdu = MemAlloc(pInstance->SendReceive.dwPDUSize);
        if (pEncoded_pdu == NULL) {
            H245TRACE(pInstance->dwInst, 1, "H245Send: No memory");
            return H245_ERROR_NOMEM;
        }
        Asn1Buf.value  = &pEncoded_pdu[2];
        Asn1Buf.length = pInstance->SendReceive.dwPDUSize - 4;
        break;

    case H245_CONF_H323:
        // Allocate a buffer to transmit
        pEncoded_pdu = MemAlloc(pInstance->SendReceive.dwPDUSize);
        if (pEncoded_pdu == NULL) {
            H245TRACE(pInstance->dwInst, 1, "H245Send: No memory");
            return H245_ERROR_NOMEM;
        }
        Asn1Buf.value  = pEncoded_pdu;
        Asn1Buf.length = pInstance->SendReceive.dwPDUSize;
        break;

    default:
        H245TRACE(pInstance->dwInst,
                  1,
                  "SR: Unknown Configuration %d",
                  pInstance->Configuration);
        return H245_ERROR_SUBSYS;
    }

    nRet = H245_Encode(pInstance->pWorld,
                       (void *)lp245MsgStruct,
                       MltmdSystmCntrlMssg_PDU,
                       &Asn1Buf);

    if (ASN1_SUCCEEDED(nRet))
    {
        H245TRACE(pInstance->dwInst, 3, "H245: Msg Encode Successful");

#if defined(_DEBUG) || defined(PCS_COMPLIANCE)
        if (H245Logger)
            InteropOutput(H245Logger,
                          (BYTE FAR*)(pEncoded_pdu),
                          (int)Asn1Buf.length,
                          H245LOG_SENT_PDU);
#endif  // (PCS_COMPLIANCE)

        lError = pInstance->SendReceive.hLinkSendReq(pInstance->SendReceive.hLinkLayerInstance,
                                                     pEncoded_pdu,
                                                     Asn1Buf.length);
    }
    else
    {
        MemFree(pEncoded_pdu);
        lError = H245_ERROR_ASN1;
    }

    return lError;
}


/**************************************************************************
**  Function    : h245SendComplete
**  Description : Send Completion Callback routine from link layer
***************************************************************************/

void h245SendComplete(   DWORD_PTR   h245Inst,
                         HRESULT dwMessage,
                         PBYTE   pbDataBuf,
                         DWORD   dwLength)
{
    struct InstanceStruct *pInstance;

    pInstance = InstanceLock(h245Inst);
    if (pInstance == NULL) {
        H245TRACE(h245Inst, 1, "SR: h245SendComplete - invalid instance");
        return;
    }

    // Return the buffer
    if (pbDataBuf) {
        MemFree(pbDataBuf);
    }

    switch (dwMessage) {
    case LINK_SEND_COMPLETE:
        if (pInstance->SendReceive.dwFlushMap & SHUTDOWN_PENDING) {
            H245TRACE(h245Inst, 10, "SR: Shutdown Complete");
        }
        break;
    case LINK_SEND_ABORT:
        H245TRACE(h245Inst, 10, "SR: TX Abort Buffer");
        break;
    case LINK_FLUSH_COMPLETE:
        // If we are in the process of abort, then the next and
        // last mesage out will be the endSession
        H245TRACE(h245Inst, 10, "SR: TX Flush Complete");

        // Indicate Transmit buffer flush is complete
        pInstance->SendReceive.dwFlushMap ^= DATALINK_TRANSMIT;

        // If all requested queues have been flushed, call the
        //  appropriate callback routing
        switch (pInstance->SendReceive.dwFlushMap & SHUTDOWN_MASK) {
        case 0:
            // TBD: Who is interested in callback if not in connection
            //  with shutdown?
            break;
        case SHUTDOWN_PENDING:
            // Flush buffers completed, and shutdown in progress
            //  notify the API
            H245TRACE(h245Inst, 20, "SR: SHUTDOWN CALLBACK");
            break;
        default:
            // Still waiting for buffers to be flushed. No action now
            break;
        }  // switch (pInstance->SendReceive.dwFlushMap & SHUTDOWN_MASK) {
        break;
    default:
        H245TRACE(h245Inst, 10, "SR: SendComplete");
        break;
    }
    InstanceUnlock(pInstance);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\h245ws.cpp ===
/***************************************************************************
 *
 * File: h245ws.c
 *
 * INTEL Corporation Proprietary Information
 * Copyright (c) 1996 Intel Corporation.
 *
 * This listing is supplied under the terms of a license agreement
 * with INTEL Corporation and may not be used, copied, nor disclosed
 * except in accordance with the terms of that agreement.
 *
 ***************************************************************************
 *
 *
 * $Workfile:   h245ws.cpp  $
 * $Revision:   2.11  $
 * $Modtime:   31 Jan 1997 19:22:28  $
 * $Log:   S:\sturgeon\src\h245ws\vcs\h245ws.cpv  $
 * 
 *    Rev 2.11   31 Jan 1997 20:24:34   SBELL1
 * Relinquished CallControl Stack lock before DefWindowProc
 * 
 *    Rev 2.10   31 Jan 1997 14:54:12   EHOWARDX
 * Added CCLOCK support.
 *
 *    Rev 2.9   20 Jan 1997 20:42:34   SBELL1
 * Fixed GPF when shutting down.
 * 
 *    Rev 2.8   07 Jan 1997 11:51:48   EHOWARDX
 * 
 * Fixed "assignment within conditional expression" warning
 * in GetLinkLayerInstance().
 * 
 *    Rev 2.7   03 Jan 1997 13:15:18   EHOWARDX
 * Attempt at workaround for #1718 linkLayerListen() returns WSAENOBUFS.
 * 
 *    Rev 2.6   23 Dec 1996 15:30:16   EHOWARDX
 * 
 * Set window to zero after call to destroy window -- Uninitialize seems
 * to be called more than once.
 * 
 *    Rev 2.5   20 Dec 1996 17:49:10   SBELL1
 * changed to blocking mode before closesocket in SocketClose. 
 * This makes the linger work.
 * 
 *    Rev 2.4   19 Dec 1996 19:03:18   SBELL1
 * Moved Initialize to linkLayerInit
 * Set linger option on accept socket
 * reversed "new" change 
 * 
 *    Rev 2.3   Dec 13 1996 17:12:36   plantz
 * fixed string for UNICODE.
// 
//    Rev 1.3   13 Dec 1996 14:32:10   SBELL1
// fixed string for UNICODE.
// 
//    Rev 1.1   12 Dec 1996 17:59:02   SBELL1
// Fixed bug in lingering on Q.931 Listen socket.
// 
//    Rev 1.0   11 Dec 1996 13:41:14   SBELL1
// Initial revision.
 * 
 *    Rev 1.46   18 Oct 1996 16:46:12   EHOWARDX
 * 
 * Changed GetIpAddress to take wide char cAddr field.
 * 
 *    Rev 1.45   Oct 01 1996 14:29:56   EHOWARDX
 * Moved Initialize() and Unitialize() calls to DllMain().
 * 
 *    Rev 1.44   26 Sep 1996 18:52:10   EHOWARDX
 * 
 * Moved some initialization around to prevent possible ASSERTion failure
 * in SocketClose().
 * 
 *    Rev 1.43   15 Aug 1996 13:59:00   rodellx
 * 
 * Added additional address validation for DOMAIN_NAME addresses
 * which cannot be resolved, but are used with SocketBind().
 * 
 *    Rev 1.42   Aug 07 1996 14:38:00   mandrews
 * Set bMulticast field of CC_ADDR structures correctly.
 * 
 *    Rev 1.41   24 Jul 1996 11:53:02   EHOWARDX
 * Changed ADDR to CC_ADDR, IP_XXX to CC_IP_XXX.
 * Fixed bug in SocketCloseEvent - needed to revalidate pHws after callback.
 * 
 *    Rev 1.40   08 Jul 1996 19:27:18   unknown
 * Second experiment to try to fix Q.931 shutdown problem.
 * 
 *    Rev 1.39   02 Jul 1996 16:23:02   EHOWARDX
 * Backed out experimental change.
 * 
 *    Rev 1.37   28 Jun 1996 18:06:50   unknown
 * Added breaks to GetPort.
 * 
 *    Rev 1.36   27 Jun 1996 14:06:06   EHOWARDX
 * Byte-swapped port number for debug trace in linkLayerListen & linkLayerConn
 * 
 *    Rev 1.35   21 Jun 1996 18:52:14   unknown
 * Fixed yet another shutdown bug - linkLayerShutdown re-entrancy check.
 * 
 *    Rev 1.34   18 Jun 1996 16:56:20   EHOWARDX
 * Added check to see if callback deallocated our instance to SocketConnect().
 * 
 *    Rev 1.33   17 Jun 1996 13:23:48   EHOWARDX
 * Workaround for PostQuitMessage() bug.
 * 
 *    Rev 1.32   12 Jun 1996 11:43:26   EHOWARDX
 * Changed linkLayerConnect errors from HWS_CRITICAL to HWS_WARNING.
 * 
 *    Rev 1.31   May 28 1996 18:14:00   plantz
 * Change error codes to use HRESULT. Propogate Winsock errors where appropriate
 * 
 *    Rev 1.30   May 28 1996 10:38:08   plantz
 * Change sprintf to wsprintf.
 * 
 *    Rev 1.29   17 May 1996 16:49:24   EHOWARDX
 * Shutdown fix.
 * 
 *    Rev 1.28   16 May 1996 13:09:18   EHOWARDX
 * Made reporting of IP Addres and port consistent between linkLayerListen
 * and LinkLayerConnect.
 * 
 *    Rev 1.27   14 May 1996 11:31:50   EHOWARDX
 * Fixed bug with doing another connect on instance that failed previous
 * connect. Instance now returns LINK_INVALID_STATE, and must be closed
 * and reopened.
 * 
 *    Rev 1.26   09 May 1996 18:33:22   EHOWARDX
 * 
 * Changes to build with new LINKAPI.H.
 * 
 *    Rev 1.25   Apr 29 1996 19:06:48   plantz
 * Reenable code to try to send all messages when shutting down.
 * 
 *    Rev 1.24   Apr 29 1996 14:02:58   plantz
 * Add NotifyRead and NotifyWrite functions.
 * Delete unused function FindH245Instance.
 * .
 * 
 *    Rev 1.23   Apr 25 1996 21:16:26   plantz
 * Add connect callback parameter to linkLayerAccept.
 * Pass message type to connect callback.
 * 
 *    Rev 1.22   Apr 24 1996 20:49:30   plantz
 * Listen on address passed to linkLayerListen; use INADDR_ANY if it is 0.
 * Return the result of getsockname after listening.
 * Add a callback parameter to linkLayerConnect. Call it when FD_CONNECT event
 * occurs and after calling accept, passing error code and local and peer
 * addresses.
 * 
 *    Rev 1.21   Apr 24 1996 16:55:20   plantz
 * Merge 1.15.1.0 with 1.20 (winsock 1 changes)
 * 
 *    Rev 1.20   19 Apr 1996 18:28:50   EHOWARDX
 * Changed Send and receive flush to call send and receive callback with
 * LINK_FLUSH_COMPLETE message to more accurately emulate behavior
 * of H245SRP.DLL.
 * 
 *    Rev 1.19   19 Apr 1996 10:34:26   EHOWARDX
 * Updated to latest LINKAPI.H - WINAPI keywork eliminated.
 * 
 *    Rev 1.18   12 Apr 1996 19:17:02   unknown
 * Removed annoying trace message.
 * 
 *    Rev 1.17   11 Apr 1996 14:53:22   EHOWARDX
 * Changed to include INCOMMON.H instead of CALLCONT.H.
 * 
 *    Rev 1.16   04 Apr 1996 12:35:04   EHOWARDX
 * Valiantly trying to track never-ending changes to Link Layer API
 * (Thanks Dan! Changing linkLayerGetInstId to linkLayerGetInstance() --
 * what a stroke of genius!)
 * 
 *    Rev 1.15.1.0   Apr 24 1996 16:23:02   plantz
 * Change to use winsock 1.
 * 
 *    Rev 1.15   03 Apr 1996 16:35:46   EHOWARDX
 * CLOSED state no longer implies that we have a thread;
 * replaced ASSERT with if statement.
 * 
 *    Rev 1.14   03 Apr 1996 14:52:24   EHOWARDX
 * Fixed yet another shutdown problem.
 * 
 *    Rev 1.13   02 Apr 1996 18:28:50   EHOWARDX
 * Added ProcessQueuedRecvs() to SocketAccept().
 * 
 *    Rev 1.12   01 Apr 1996 16:25:46   EHOWARDX
 * Experiment with calling ProcessRecvQueue on FD_WRITE event.
 * 
 *    Rev 1.11   01 Apr 1996 14:20:40   unknown
 * Shutdown redesign.
 * 
 *    Rev 1.10   29 Mar 1996 11:12:56   EHOWARDX
 * Added line to SocketClose to set state to HWS_CLOSED.
 * 
 *    Rev 1.9   27 Mar 1996 13:00:30   EHOWARDX
 * Added dwThreadId to H245WS instance structure.
 * Reversed shutdown loop to check state first BEFORE checking send queue.
 * 
 *    Rev 1.8   22 Mar 1996 10:54:20   unknown
 * 
 * Minor change in trace text.
 * 
 *    Rev 1.7   20 Mar 1996 14:11:20   unknown
 * Added Sleep(0) to bind retry loop.
 * 
 *    Rev 1.6   19 Mar 1996 20:21:56   EHOWARDX
 * Redesigned shutdown.
 * 
 *    Rev 1.4   18 Mar 1996 19:08:28   EHOWARDX
 * Fixed shutdown; eliminated TPKT/WSCB dependencies.
 * Define TPKT to put TPKT/WSCB dependencies back in.
 * 
 *    Rev 1.3   14 Mar 1996 17:01:46   EHOWARDX
 * 
 * NT4.0 testing; got rid of HwsAssert(); got rid of TPKT/WSCB.
 * 
 *    Rev 1.2   09 Mar 1996 21:12:26   EHOWARDX
 * Fixes as result of testing.
 * 
 *    Rev 1.1   08 Mar 1996 20:24:24   unknown
 * This is the real version of the main h245ws.dll code.
 * Version 1.0 was a stub version created by Mike Andrews.
 *
 ***************************************************************************/

#define LINKDLL_EXPORT
#undef _WIN32_WINNT	// override bogus platform definition in our common build environment
#pragma warning ( disable : 4115 4201 4214 4514 )

#include "precomp.h"

//#include <winsock.h>
#include "queue.h"
#include "linkapi.h"
#include "incommon.h"
#include "h245ws.h"
#include "tstable.h"
#ifdef FORCE_SERIALIZE_CALL_CONTROL
#include "cclock.h"
#endif

#include "q931.h"
#include "hcall.h"

#if defined(__cplusplus)
extern "C"
{
#endif  // (__cplusplus)

// REVIEW: Should we use the newer definition from winsock2.h ?
#undef FD_ALL_EVENTS
#define FD_ALL_EVENTS (FD_READ|FD_WRITE|FD_OOB|FD_ACCEPT|FD_CONNECT|FD_CLOSE)
#define WINSOCK_EVENT_MSG (WM_USER+1)

static HRESULT SocketOpen(PHWSINST pHws, BOOL bSetLinger = TRUE);
void Uninitialize();

/*
 * Static variables
 */
static BOOL bInitialized = FALSE;
static HWND        window   = 0;
TSTable<HWSINST>* gpInstanceTable;	// global ptr to the instance table
static CRITICAL_SECTION SocketToHWSInstanceMapLock;
static SOCKET_TO_INSTANCE *pSocketToHWSInstanceMap = NULL;

// If we are not using the Unicode enabled tracing, then undefine the __TEXT macro.
// Do not place anything that should be a Unicode constant string between this #undef
// and the corresponding redefinition of the macro

#if defined(_DEBUG)
#ifndef UNICODE_TRACE
#undef  __TEXT
#define __TEXT(x) x

static const char * StateMap[] =

#else

static const LPTSTR StateMap[] =

#endif
{
   __TEXT("HWS_START"),         // 0  Initial state
   __TEXT("HWS_LISTENING"),     // 1  Waiting for FD_ACCEPT
   __TEXT("HWS_CONNECTING"),    // 2  Waiting for FD_CONNECT
   __TEXT("HWS_CONNECTED"),     // 3  Data transfer state
   __TEXT("HWS_CLOSING"),       // 4  Waiting for FD_CLOSE
   __TEXT("HWS_CLOSED"),        // 5  Waiting for linkLayerShutdown()
   __TEXT("HWS_SHUTDOWN"),      // 6  linkLayerShutdown() called from callback
};


static const ERROR_MAP ErrorMap[] =
{
   0,                     __TEXT("OK"),
   WSAEINTR,              __TEXT("WSAEINTR - Interrupted function call"),
   WSAEBADF,              __TEXT("WSAEBADF"),
   WSAEACCES,             __TEXT("WSAEACCES - Permission denied"),
   WSAEFAULT,             __TEXT("WSAEFAULT - Bad address"),
   WSAEINVAL,             __TEXT("WSAEINVAL - Invalid argument"),
   WSAEMFILE,             __TEXT("WSAEMFILE - Too many open files"),
   WSAEWOULDBLOCK,        __TEXT("WSAEWOULDBLOCK - Resource temporarily unavailable"),
   WSAEINPROGRESS,        __TEXT("WSAEINPROGRESS - Operation now in progress"),
   WSAEALREADY,           __TEXT("WSAEALREADY - Operation already in progress"),
   WSAENOTSOCK,           __TEXT("WSAENOTSOCK - Socket operation on non-socket"),
   WSAEDESTADDRREQ,       __TEXT("WSAEDESTADDRREQ - Destination address required"),
   WSAEMSGSIZE,           __TEXT("WSAEMSGSIZE - Message too long"),
   WSAEPROTOTYPE,         __TEXT("WSAEPROTOTYPE - Protocol wrong type for socket"),
   WSAENOPROTOOPT,        __TEXT("WSAENOPROTOOPT - Bad protocol option"),
   WSAEPROTONOSUPPORT,    __TEXT("WSAEPROTONOSUPPORT - Protocol not supported"),
   WSAESOCKTNOSUPPORT,    __TEXT("WSAESOCKTNOSUPPORT - Socket type not supported"),
   WSAEOPNOTSUPP,         __TEXT("WSAEOPNOTSUPP - Operation not supported"),
   WSAEPFNOSUPPORT,       __TEXT("WSAEPFNOSUPPORT - Protocol family not supported"),
   WSAEAFNOSUPPORT,       __TEXT("WSAEAFNOSUPPORT - Address family not supported by protocol family"),
   WSAEADDRINUSE,         __TEXT("WSAEADDRINUSE - Address already in use"),
   WSAEADDRNOTAVAIL,      __TEXT("WSAEADDRNOTAVAIL - Cannot assign requested address"),
   WSAENETDOWN,           __TEXT("WSAENETDOWN - Network is down"),
   WSAENETUNREACH,        __TEXT("WSAENETUNREACH - Network is unreachable"),
   WSAENETRESET,          __TEXT("WSAENETRESET - Network dropped connection on reset"),
   WSAECONNABORTED,       __TEXT("WSAECONNABORTED - Software caused connection abort"),
   WSAECONNRESET,         __TEXT("WSAECONNRESET - Connection reset by peer"),
   WSAENOBUFS,            __TEXT("WSAENOBUFS - No buffer space available"),
   WSAEISCONN,            __TEXT("WSAEISCONN - Socket is already connected"),
   WSAENOTCONN,           __TEXT("WSAENOTCONN - Socket is not connected"),
   WSAESHUTDOWN,          __TEXT("WSAESHUTDOWN - Cannot send after socket shutdown"),
   WSAETOOMANYREFS,       __TEXT("WSAETOOMANYREFS"),
   WSAETIMEDOUT,          __TEXT("WSAETIMEDOUT - Connection timed out"),
   WSAECONNREFUSED,       __TEXT("WSAECONNREFUSED - Connection refused"),
   WSAELOOP,              __TEXT("WSAELOOP"),
   WSAENAMETOOLONG,       __TEXT("WSAENAMETOOLONG"),
   WSAEHOSTDOWN,          __TEXT("WSAEHOSTDOWN - Host is down"),
   WSAEHOSTUNREACH,       __TEXT("WSAEHOSTUNREACH - No route to host"),
   WSAENOTEMPTY,          __TEXT("WSAENOTEMPTY"),
   WSAEPROCLIM,           __TEXT("WSAEPROCLIM - Too many processes"),
   WSAEUSERS,             __TEXT("WSAEUSERS"),
   WSAEDQUOT,             __TEXT("WSAEDQUOT"),
   WSAESTALE,             __TEXT("WSAESTALE"),
   WSAEREMOTE,            __TEXT("WSAEREMOTE"),
   WSASYSNOTREADY,        __TEXT("WSASYSNOTREADY - Network subsystem is unavailable"),
   WSAVERNOTSUPPORTED,    __TEXT("WSAVERNOTSUPPORTED - WINSOCK.DLL version out of range"),
   WSANOTINITIALISED,     __TEXT("WSANOTINITIALISED - Successful WSAStartup() not yet performed"),
   WSAEDISCON,            __TEXT("WSAEDISCON - Graceful shutdown in progress"),
   WSAHOST_NOT_FOUND,     __TEXT("WSAHOST_NOT_FOUND - Host not found"),
   WSATRY_AGAIN,          __TEXT("WSATRY_AGAIN - Non-authoritative host not found"),
   WSANO_RECOVERY,        __TEXT("WSANO_RECOVERY - This is a non-recoverable error"),
   WSANO_DATA,            __TEXT("WSANO_DATA - Valid name, no data record of requested type"),
//   WSA_INVALID_HANDLE,    __TEXT("WSA_INVALID_HANDLE - Specified event object handle is invalid"),
//   WSA_INVALID_PARAMETER, __TEXT("WSA_INVALID_PARAMETER - One or more parameters are invalid"),
//   WSA_IO_PENDING,        __TEXT("WSA_IO_PENDING - Overlapped operations will complete later"),
//   WSA_IO_INCOMPLETE,     __TEXT("WSA_IO_INCOMPLETE - Overlapped I/O event object not in signaled state"),
//   WSA_NOT_ENOUGH_MEMORY, __TEXT("WSA_NOT_ENOUGH_MEMORY - Insufficient memory available"),
//   WSA_OPERATION_ABORTED, __TEXT("WSA_OPERATION_ABORTED - Overlapped operation aborted"),
};



//
// Function Definitions
//

#include <string.h>

#ifdef UNICODE_TRACE
static const LPTSTR
#else
static const char *
#endif
SocketStateText(UINT uState)
{
#ifdef UNICODE_TRACE
   static TCHAR      szSocketStateText[80];
#else
   static char       szSocketStateText[80];
#endif

   if (uState <= HWS_SHUTDOWN)
      return StateMap[uState];
   wsprintf(szSocketStateText, __TEXT("Unknown state %d"), uState);
   return szSocketStateText;
} // SocketStateText()



#ifdef UNICODE_TRACE
static LPCTSTR
#else
static const char *
#endif
SocketErrorText1(int nErrorCode)
{
   register int      nIndex = sizeof(ErrorMap) / sizeof(ErrorMap[0]);
#ifdef UNICODE_TRACE
   static TCHAR      szSocketErrorText[80];
#else
   static char       szSocketErrorText[80];
#endif


   while (nIndex > 0)
   {
      if (ErrorMap[--nIndex].nErrorCode == nErrorCode)
      {
         return ErrorMap[nIndex].pszErrorText;
      }
   }
   wsprintf(szSocketErrorText, __TEXT("Unknown error 0x%x"), nErrorCode);
   return szSocketErrorText;
} // SocketErrorText1()

#ifdef UNICODE_TRACE
LPCTSTR
#else
const char *
#endif
SocketErrorText(void)
{
   return SocketErrorText1(WSAGetLastError());
} // SocketErrorText()

#endif  // (_DEBUG)


/***************************************************************************
 *
 * Local routines
 *
 ***************************************************************************/

static DWORD
HashSocket(SOCKET socket)
{
	return(DWORD)((socket >> 2) % SOCK_TO_PHYSID_TABLE_SIZE);
}



DWORD
SocketToPhysicalId(SOCKET socket)
{
	// hash the socket to get an index into the SocketToHWSInstanceMap table
	DWORD idx = HashSocket(socket);
	if(pSocketToHWSInstanceMap == NULL)
		return(INVALID_PHYS_ID);

	EnterCriticalSection(&SocketToHWSInstanceMapLock);
	
	// idx indicates the entry point in the array, now traverse the linked list
	PSOCKET_TO_INSTANCE pEntry = &pSocketToHWSInstanceMap[idx]; 
	while(pEntry != NULL) 
	{
		if(pEntry->socket == socket)
		{
			LeaveCriticalSection(&SocketToHWSInstanceMapLock);
			return(pEntry->dwPhysicalId);
		} else
		{
			pEntry = pEntry->next;
		}
	}

	LeaveCriticalSection(&SocketToHWSInstanceMapLock);
	return(INVALID_PHYS_ID);

} // SocketToPhysicalId()

BOOL
CreateSocketToPhysicalIdMapping(SOCKET socket, DWORD dwPhysicalId)
{
	// hash the socket to get an index into the SocketToHWSInstanceMap table
	DWORD idx = HashSocket(socket);
	
	EnterCriticalSection(&SocketToHWSInstanceMapLock);
	
	// idx indicates the entry point in the array, now traverse the linked list
	PSOCKET_TO_INSTANCE pEntry = &pSocketToHWSInstanceMap[idx]; 
	PSOCKET_TO_INSTANCE pNewEntry;
	if (pEntry->socket == INVALID_SOCKET) 
	{
		pNewEntry = pEntry; 
	} else
	{
		pNewEntry = new SOCKET_TO_INSTANCE;
		if (pNewEntry == NULL) 
		{
			LeaveCriticalSection(&SocketToHWSInstanceMapLock);
			return(FALSE);
		}
		pNewEntry->next = pEntry->next;
		pEntry->next = pNewEntry;
	}

	pNewEntry->socket = socket;
	pNewEntry->dwPhysicalId = dwPhysicalId;

	LeaveCriticalSection(&SocketToHWSInstanceMapLock);
	return(TRUE);
}

BOOL
RemoveSocketToPhysicalIdMapping(SOCKET socket)
{

	if (socket == INVALID_SOCKET)
		return(FALSE);

	// hash the socket to get an index into the SocketToHWSInstanceMap table
	DWORD idx = HashSocket(socket);
	BOOL bFound = FALSE;

	EnterCriticalSection(&SocketToHWSInstanceMapLock);
	
	// idx indicates the entry point in the array, now traverse the linked list
	PSOCKET_TO_INSTANCE pEntry = &pSocketToHWSInstanceMap[idx]; 
	if (pEntry->socket == socket) 
	{
		pEntry->socket = INVALID_SOCKET;
		bFound = TRUE;
	} else
	{
		PSOCKET_TO_INSTANCE pNextEntry;
		pNextEntry = pEntry->next;
		while (bFound == FALSE && pNextEntry != NULL)
		{
			if(pNextEntry->socket == socket)
			{
				pEntry->next = pNextEntry->next;
				delete pNextEntry;
				bFound = TRUE;
			} else
			{
				pEntry     = pNextEntry;
				pNextEntry = pNextEntry->next;
			}
		}
	}

	LeaveCriticalSection(&SocketToHWSInstanceMapLock);
	return(bFound);
}

static unsigned short GetPort (CC_ADDR *pAddr)
{
   unsigned short int port = 0;
   switch (pAddr->nAddrType)
   {
   case CC_IP_DOMAIN_NAME:
      port = pAddr->Addr.IP_DomainName.wPort;
      break;

   case CC_IP_DOT:
      port = pAddr->Addr.IP_Dot.wPort;
      break;

   case CC_IP_BINARY:
      port = pAddr->Addr.IP_Binary.wPort;
      break;

   } // switch

   return htons(port);
} // GetPort()


static unsigned long GetIPAddress (CC_ADDR *pAddr)
{
   struct hostent *     pHostEnt;
   char                 szAddr[256];

   switch (pAddr->nAddrType)
   {
   case CC_IP_DOMAIN_NAME:
      WideCharToMultiByte(CP_ACP,           // code page
                          0,                // dwFlags
                          pAddr->Addr.IP_DomainName.cAddr,
                          -1,               // Unicode string length (bytes)
                          szAddr,           // ASCII string
                          sizeof(szAddr),   // max ASCII string length
                          NULL,             // default character
                          NULL);            // default character used
      pHostEnt = gethostbyname(szAddr);
      if (pHostEnt == NULL || pHostEnt->h_addr_list == NULL)
         return 0;
      return *((unsigned long *)pHostEnt->h_addr_list[0]);

   case CC_IP_DOT:
      WideCharToMultiByte(CP_ACP,           // code page
                          0,                // dwFlags
                          pAddr->Addr.IP_Dot.cAddr,
                          -1,               // Unicode string length (bytes)
                          szAddr,           // ASCII string
                          sizeof(szAddr),   // max ASCII string length
                          NULL,             // default character
                          NULL);            // default character used
      return inet_addr(szAddr);

   case CC_IP_BINARY:
       return pAddr->Addr.IP_Binary.dwAddr == 0 ? INADDR_ANY : htonl(pAddr->Addr.IP_Binary.dwAddr);
   } // switch
   return 0;
} // GetIPAddress()


static HRESULT GetLocalAddr(PHWSINST pHws, CC_ADDR *pAddr)
{
    SOCKADDR_IN sockaddr;
    int len = sizeof(sockaddr);

    if (getsockname(pHws->hws_Socket,
                    (struct sockaddr *)&sockaddr,
                    &len) == SOCKET_ERROR)
    {
        return MAKE_WINSOCK_ERROR(WSAGetLastError());
    }

    pAddr->nAddrType = CC_IP_BINARY;
	pAddr->bMulticast = FALSE;
    pAddr->Addr.IP_Binary.wPort = ntohs(sockaddr.sin_port);
    pAddr->Addr.IP_Binary.dwAddr = ntohl(sockaddr.sin_addr.S_un.S_addr);

    return NOERROR;
}

static HRESULT GetPeerAddr(PHWSINST pHws, CC_ADDR *pAddr)
{
    SOCKADDR_IN sockaddr;
    int len = sizeof(sockaddr);

    if (getpeername(pHws->hws_Socket,
                    (struct sockaddr *)&sockaddr,
                    &len) == SOCKET_ERROR)
    {
        return MAKE_WINSOCK_ERROR(WSAGetLastError());
    }

    pAddr->nAddrType = CC_IP_BINARY;
	pAddr->bMulticast = FALSE;
    pAddr->Addr.IP_Binary.wPort = ntohs(sockaddr.sin_port);
    pAddr->Addr.IP_Binary.dwAddr = ntohl(sockaddr.sin_addr.S_un.S_addr);

    return NOERROR;
}


static void
SocketFlushRecv(PHWSINST pHws)
{
   register PREQUEST    pReq;

   if (pHws->hws_pRecvQueue)
   {
      while ((pReq = (PREQUEST) QRemove(pHws->hws_pRecvQueue)) != NULL)
      {
         pHws->hws_h245RecvCallback(pHws->hws_dwH245Instance,
                                    LINK_RECV_ABORT,
                                    pReq->req_client_data,
                                    0);
         MemFree(pReq);
      }
   }
   pHws->hws_h245RecvCallback(pHws->hws_dwH245Instance,
                              LINK_FLUSH_COMPLETE,
                              NULL,
                              0);
} // SocketFlushRecv()



static void
SocketFlushSend(PHWSINST pHws)
{
   register PREQUEST    pReq;

   if (pHws->hws_pSendQueue)
   {
      while ((pReq = (PREQUEST)  QRemove(pHws->hws_pSendQueue)) != NULL)
      {
         pHws->hws_h245SendCallback(pHws->hws_dwH245Instance,
                                    LINK_SEND_ABORT,
                                    pReq->req_client_data,
                                    0);
         MemFree(pReq);
      }
   }
   pHws->hws_h245SendCallback(pHws->hws_dwH245Instance,
                              LINK_FLUSH_COMPLETE,
                              NULL,
                              0);
} // SocketFlushSend()



void
SocketCloseEvent(PHWSINST pHws)
{
   HWSTRACE0(pHws->hws_dwPhysicalId, HWS_TRACE, __TEXT("SocketCloseEvent"));
   if (pHws->hws_uState == HWS_CONNECTED)
   {
      register DWORD dwPhysicalId = pHws->hws_dwPhysicalId;
      pHws->hws_h245RecvCallback(pHws->hws_dwH245Instance,LINK_RECV_CLOSED,0,0);

      // Check to see if callback deallocated our instance or state changed

      if(gpInstanceTable->Validate(dwPhysicalId) == FALSE)
        return;

      HWSTRACE0(pHws->hws_dwPhysicalId, HWS_TRACE,
				__TEXT("SocketCloseEvent: calling shutdown"));
      if (shutdown(pHws->hws_Socket, 1) == SOCKET_ERROR)
      {
         HWSTRACE1(pHws->hws_dwPhysicalId, HWS_WARNING,
                  __TEXT("HandleNetworkEvent: shutdown() returned %s"),
                  SocketErrorText());
      }
   }
   pHws->hws_uState = HWS_CLOSED;
} // SocketCloseEvent()



/*
 * DESCRIPTION
 *    Deallocate all allocated objects except for task handle
 */

static void
SocketClose(PHWSINST pHws)
{
   HWSASSERT(pHws != NULL);
   HWSASSERT(pHws->hws_dwMagic == HWSINST_MAGIC);
   HWSTRACE0(pHws->hws_dwPhysicalId, HWS_TRACE, __TEXT("SocketClose"));

   pHws->hws_uState = HWS_CLOSED;

   RemoveSocketToPhysicalIdMapping(pHws->hws_Socket);

   // Close the socket
   if (pHws->hws_Socket != INVALID_SOCKET)
   {
      // To make the linger work, turn off WSAAsyncSelect to turn off 
      // non-blocking via ioctlsocket, to close the socket.
      unsigned long blocking = 0;
      HWSTRACE0(pHws->hws_dwPhysicalId, HWS_TRACE,
                __TEXT("SocketClose: calling closesocket"));
         
      WSAAsyncSelect(pHws->hws_Socket,
                     window, WINSOCK_EVENT_MSG,
                     0);
      ioctlsocket(pHws->hws_Socket, FIONBIO,&blocking);
      if (closesocket(pHws->hws_Socket) == SOCKET_ERROR)
      {
         HWSTRACE1(pHws->hws_dwPhysicalId, HWS_WARNING,
                   __TEXT("SocketClose: closesocket() returned %s"),
                   SocketErrorText());
      }
      pHws->hws_Socket = INVALID_SOCKET;
   }

} // SocketClose()



static HRESULT
SocketOpen(PHWSINST pHws, BOOL bSetLinger)
{
   HWSASSERT(pHws != NULL);
   HWSASSERT(pHws->hws_dwMagic == HWSINST_MAGIC);
   HWSTRACE0(pHws->hws_dwPhysicalId, HWS_TRACE, __TEXT("SocketOpen"));

   // Create a socket
   pHws->hws_Socket = socket(AF_INET, SOCK_STREAM, 0);
   if (pHws->hws_Socket == INVALID_SOCKET)
   {
      // WSASocket() failed
      int err = WSAGetLastError();
      HWSTRACE1(pHws->hws_dwPhysicalId, HWS_WARNING,
                __TEXT("SocketOpen: socket() returned %s"),
                SocketErrorText1(err));
      SocketClose(pHws);
      return MAKE_WINSOCK_ERROR(err);
   }

   /*
   ** Request notification messages for all events on this socket.
   ** Note that this call automatically puts the socket into non-blocking
   ** mode, as if we had called WSAIoctl with the FIONBIO flag.
   **/
   if (WSAAsyncSelect(pHws->hws_Socket,
                      window, WINSOCK_EVENT_MSG,
                      FD_ALL_EVENTS) == SOCKET_ERROR)
   {
      int err = WSAGetLastError();
      HWSTRACE1(pHws->hws_dwPhysicalId, HWS_WARNING,
                  __TEXT("SocketOpen: WSAASyncSelect() returned %s"),
                  SocketErrorText1(err));
      SocketClose(pHws);
      return MAKE_WINSOCK_ERROR(err);
   }

   if(bSetLinger == TRUE)
   {
		// Set a linger structure for the socket so that closesocket will block for a period of time (until all
		// data is sent or the timeout value) before actually killing the connection.
		// This change is being made in order to get rid of the PeekMessage() loops in linklayerShutdown().
		struct linger sockLinger;
		sockLinger.l_onoff = 1;				// yes we want to linger (wait for FIN ACK after sending data and FIN)
		sockLinger.l_linger = 1;			// linger for up to 1 second

	 
		if(setsockopt (pHws->hws_Socket,
								SOL_SOCKET,
								SO_LINGER,
								(const char*) &sockLinger,
								sizeof(sockLinger)) == SOCKET_ERROR)
		{
            int err = WSAGetLastError();
            HWSTRACE1(pHws->hws_dwPhysicalId, HWS_WARNING,
                  __TEXT("SocketOpen: setsockopt returned %s"),
                  SocketErrorText1(err));
            SocketClose(pHws);
            return MAKE_WINSOCK_ERROR(err);
		}

	 }

   // add an entry in the socket to instance map
	if(CreateSocketToPhysicalIdMapping(pHws->hws_Socket, pHws->hws_dwPhysicalId) != TRUE)
	{
		HWSTRACE0(pHws->hws_dwPhysicalId, HWS_WARNING,
			__TEXT("SocketOpen: CreateSocketToPhysicalIdMapping() failed"));
		SocketClose(pHws);
		return(LINK_MEM_FAILURE);
	}

   return NOERROR;
} // SocketOpen()



static HRESULT
SocketBind(PHWSINST pHws, CC_ADDR *pAddr)
{
   HWSASSERT(pHws != NULL);
   HWSASSERT(pHws->hws_dwMagic == HWSINST_MAGIC);
   HWSASSERT(pAddr != NULL);
   HWSTRACE0(pHws->hws_dwPhysicalId, HWS_TRACE, __TEXT("SocketBind"));

   // Get a local address to bind the socket to
   pHws->hws_SockAddr.sin_family           = AF_INET;
   pHws->hws_SockAddr.sin_port             = GetPort(pAddr);
   pHws->hws_SockAddr.sin_addr.S_un.S_addr = GetIPAddress(pAddr);
   if ((pAddr->nAddrType == CC_IP_DOMAIN_NAME) &&
           (pHws->hws_SockAddr.sin_addr.S_un.S_addr == 0))
   {
       return LINK_UNKNOWN_ADDR;
   }

   // Bind the socket
   while (bind(pHws->hws_Socket,                            // s
               (const struct sockaddr *)&pHws->hws_SockAddr, // name
               sizeof(pHws->hws_SockAddr)) == SOCKET_ERROR)      // namelen
   {
      // bind() failed
      int err = WSAGetLastError();
      HWSTRACE1(pHws->hws_dwPhysicalId, HWS_WARNING,
                __TEXT("SocketBind: bind() returned %s"),
                SocketErrorText1(err));
      if (err != WSAENOBUFS)
      {
         return MAKE_WINSOCK_ERROR(err);
      }
      Sleep(0);
   }

   return NOERROR;
} // SocketBind()

static void
SocketConnect(PHWSINST pHws, int error)
{
   HWSASSERT(pHws != NULL);
   HWSASSERT(pHws->hws_dwMagic == HWSINST_MAGIC);
   HWSTRACE0(pHws->hws_dwPhysicalId, HWS_TRACE, __TEXT("SocketConnect"));

   if (error == 0)
   {
       pHws->hws_uState = HWS_CONNECTED;

       if (pHws->hws_h245ConnectCallback)
       {
            CC_ADDR   LocalAddr;
            CC_ADDR   PeerAddr;
            PCC_ADDR  pLocalAddr = &LocalAddr;
            PCC_ADDR  pPeerAddr  = &PeerAddr;
            DWORD     dwPhysicalId = pHws->hws_dwPhysicalId;
            HRESULT     hr;

            hr = GetLocalAddr(pHws, pLocalAddr);
            if (FAILED(hr))
            {
                WARNING_OUT(("SocketConnect - failed to get local address w/ error 0x%08x", hr));
                pLocalAddr = NULL;
            }
            else
            {
                hr = GetPeerAddr(pHws, pPeerAddr);
                if (FAILED(hr))
                {
                    WARNING_OUT(("SocketConnect - failed to get remote address w/ error 0x%08x", hr));
                    pPeerAddr = NULL;
                }
                else
                {
                    // All is OK
                    hr = LINK_CONNECT_COMPLETE;
                }
            }

            pHws->hws_h245ConnectCallback(pHws->hws_dwH245Instance,
                hr, pLocalAddr, pPeerAddr);

            // Check to see if callback deallocated our instance - this can be done
		    // by attempting a lock - which will now fail if the entry has been marked
		    // for deletion.  Thus, if the lock succeeds, then just unlock it (since we 
		    // already have a lock on it).

		    if (gpInstanceTable->Validate(dwPhysicalId) == FALSE)
			    return;
       }

       NotifyWrite(pHws);
       NotifyRead(pHws);
   }
   else
   {
      if (pHws->hws_h245ConnectCallback)
      {
         pHws->hws_h245ConnectCallback(pHws->hws_dwH245Instance,
                                       MAKE_WINSOCK_ERROR(error), NULL, NULL);
      }
   }
} // SocketConnect()

static HRESULT
SocketAccept(PHWSINST pHwsListen, PHWSINST pHwsAccept)
{
   SOCKET listen_socket = pHwsListen->hws_Socket;
   struct linger sockLinger;
   sockLinger.l_onoff = 1;	// yes we want to linger (wait for FIN ACK after sending data and FIN)
   sockLinger.l_linger = 1;	// linger for up to 1 second

   // Accept the connection.
   pHwsAccept->hws_uSockAddrLen = sizeof(pHwsAccept->hws_SockAddr);
   pHwsAccept->hws_Socket = accept(pHwsListen->hws_Socket,
                       (struct sockaddr *)&pHwsAccept->hws_SockAddr,
                       (int *)&pHwsAccept->hws_uSockAddrLen);

   if (pHwsAccept->hws_Socket == INVALID_SOCKET)
   {
      int err = WSAGetLastError();
      HWSTRACE1(pHwsAccept->hws_dwPhysicalId, HWS_WARNING,
                __TEXT("linkLayerAccept: accept() returned %s"),
                SocketErrorText1(err));
      SocketConnect(pHwsAccept, err);
      return MAKE_WINSOCK_ERROR(err);
   }

   if (pHwsListen == pHwsAccept)
   {
      HWSTRACE0(pHwsListen->hws_dwPhysicalId, HWS_TRACE,
                __TEXT("SocketClose: calling closesocket"));
      closesocket(listen_socket);
      RemoveSocketToPhysicalIdMapping(listen_socket);
   }

   
   // Set a linger structure for the socket so that closesocket will block for a period of time (until all
   // data is sent or the timeout value) before actually killing the connection.
   // This change is being made in order to get rid of the PeekMessage() loops in linklayerShutdown().
   if(setsockopt (pHwsAccept->hws_Socket,
                  SOL_SOCKET,
	     		  SO_LINGER,
                  (const char*) &sockLinger,
                  sizeof(sockLinger)) == SOCKET_ERROR)
   {
      int err = WSAGetLastError();
      HWSTRACE1(pHwsAccept->hws_dwPhysicalId, HWS_WARNING,
                  __TEXT("SocketAccept: setsockopt returned %s"),
                  SocketErrorText1(err));
      SocketClose(pHwsAccept);
      return MAKE_WINSOCK_ERROR(err);
   }
   

   // add the new socket to the socket to phys id map
   CreateSocketToPhysicalIdMapping(pHwsAccept->hws_Socket, pHwsAccept->hws_dwPhysicalId);

   SocketConnect(pHwsAccept, 0);
   return NOERROR;
} // SocketAccept()



/*++

Description:

   Handles network events that may occur on a connected socket.
   The events handled by this function are FD_ACCEPT, FD_CLOSE, FD_READ, and
   FD_WRITE.

Arguments:

   pHws - pointer to data for the connection on which the event happened.
   event - event that occurred
   error - error code accompanying the event

Return Value:

   SUCCESS - The network event was successfully handled.

   LINK_FATAL_ERROR - Some kind of error occurred while handling the
   event, and the connection should be closed.

   LINK_RECV_CLOSED - The connection has been gracefully closed.

--*/

static void
HandleNetworkEvent(PHWSINST pHws, int event, int error)
{
   HWSASSERT(pHws != NULL);
   HWSASSERT(pHws->hws_dwMagic == HWSINST_MAGIC);
   HWSTRACE0(pHws->hws_dwPhysicalId, HWS_TRACE, __TEXT("HandleNetworkEvent"));

   if (error == WSAENETDOWN)
   {
       HWSTRACE0(pHws->hws_dwPhysicalId, HWS_NOTIFY,
                 __TEXT("HandleSocketEvent: Connection error"));
       pHws->hws_uState = HWS_CLOSED;
       return;
   }

   switch (event)
   {
   case FD_READ:
      HWSTRACE1(pHws->hws_dwPhysicalId, HWS_NOTIFY,
                __TEXT("HandleNetworkEvent: FD_READ %s"),
                SocketErrorText1(error));
      if (error == 0 && pHws->hws_uState <= HWS_CLOSING)
      {
         ProcessQueuedRecvs(pHws);
      }
      break;

   case FD_WRITE:
      HWSTRACE1(pHws->hws_dwPhysicalId, HWS_NOTIFY,
                __TEXT("HandleNetworkEvent: FD_WRITE %s"),
                SocketErrorText1(error));
      if (error == 0 && pHws->hws_uState <= HWS_CONNECTED)
      {
         ProcessQueuedSends(pHws);
      }
      break;

   case FD_OOB:
      HWSTRACE1(pHws->hws_dwPhysicalId, HWS_NOTIFY,
                __TEXT("HandleNetworkEvent: FD_OOB %s"),
                SocketErrorText1(error));
      break;


   case FD_ACCEPT:
      HWSTRACE1(pHws->hws_dwPhysicalId, HWS_NOTIFY,
                __TEXT("HandleNetworkEvent: FD_ACCEPT %s"),
                SocketErrorText1(error));
      if (pHws->hws_h245ConnectCallback != NULL)
      {
         if (error == 0)
         {
             pHws->hws_h245ConnectCallback(pHws->hws_dwH245Instance,
                                           LINK_CONNECT_REQUEST, NULL, NULL);
         }
         else
         {
             pHws->hws_h245ConnectCallback(pHws->hws_dwH245Instance,
                                           MAKE_WINSOCK_ERROR(error), NULL, NULL);
         }
      }
      else if (error == 0)
      {
         // If the client did not specify a callback, accept the call using the same physical
         // Id as the listen. This will result in the listen socket being closed.
         SocketAccept(pHws, pHws);
      }
      break;

   case FD_CONNECT:
      HWSTRACE1(pHws->hws_dwPhysicalId, HWS_NOTIFY,
                __TEXT("HandleNetworkEvent: FD_CONNECT %s"),
                SocketErrorText1(error));
      SocketConnect(pHws, error);
      break;

   case FD_CLOSE:
      HWSTRACE1(pHws->hws_dwPhysicalId, HWS_NOTIFY,
                __TEXT("HandleNetworkEvent: FD_CLOSE %s"),
                SocketErrorText1(error));
      SocketCloseEvent(pHws);
      break;
   }
} // HandleNetworkEvent()


LRESULT APIENTRY WndProc(
        HWND hWnd,                /* window handle                   */
        UINT message,             /* type of message                 */
        WPARAM wParam,              /* additional information          */
        LPARAM lParam)              /* additional information          */
{
   PHWSINST pHws;
   DWORD dwPhysicalId;

#ifdef FORCE_SERIALIZE_CALL_CONTROL
	 CCLOCK_AcquireLock();
#endif 

   switch (message)
   {
   case WINSOCK_EVENT_MSG:
		if (((dwPhysicalId=SocketToPhysicalId((SOCKET)wParam)) == INVALID_PHYS_ID) ||
				((pHws=gpInstanceTable->Lock(dwPhysicalId)) == NULL))

      {
         HWSTRACE1(0, HWS_WARNING,
                   __TEXT("WndProc: Winsock event on unknown socket 0x%x"),
                   wParam);
         break;
      }

      HandleNetworkEvent(pHws, WSAGETSELECTEVENT(lParam), WSAGETSELECTERROR(lParam));
	  gpInstanceTable->Unlock(dwPhysicalId);

      break;

   default:
   		{
   		#ifdef FORCE_SERIALIZE_CALL_CONTROL
	        CCLOCK_RelinquishLock();
		#endif 
			return DefWindowProc(hWnd, message, wParam, lParam);
		}
   }
   
   #ifdef FORCE_SERIALIZE_CALL_CONTROL
           CCLOCK_RelinquishLock();
   #endif 
   
   return (0);
}

void NotifyRead(PHWSINST pHws)
{
   PostMessage(window, WINSOCK_EVENT_MSG, (WPARAM)pHws->hws_Socket, (LPARAM)MAKELONG(FD_READ, 0));
}

void NotifyWrite(PHWSINST pHws)
{
   PostMessage(window, WINSOCK_EVENT_MSG, (WPARAM)pHws->hws_Socket, (LPARAM)MAKELONG(FD_WRITE, 0));
}

/*++

Description:

   Calls WSAStartup, makes sure we have a good version of WinSock

Arguments:

   None.

Return Value:
   0                 WinSock DLL successfully started up.
   LINK_FATAL_ERROR  Error starting up WinSock DLL.

--*/


static const TCHAR CLASS_NAME[] = __TEXT("H245WSWndClass");

int     WinsockInitError = -1;
HRESULT InitializeStatus = LINK_INVALID_STATE;

LINKDLL VOID H245WSShutdown()
{
	Uninitialize();
}

void Initialize()
{
   WORD wVersion = MAKEWORD(1, 1);
   WSADATA  WsaData;      // receives data from WSAStartup
   WNDCLASS wndclass = { 0, WndProc, 0, 0, 0, 0, 0, 0, NULL, CLASS_NAME };
   DWORD    dwIndex;

   // Caveat: We can't use WSAGetLastError() for WSAStartup failure!
   if ((WinsockInitError = WSAStartup(wVersion, &WsaData)) != 0)
   {
      HWSTRACE0(0, HWS_WARNING, __TEXT("linkLayerInit: WSAStartup() failed"));
      InitializeStatus = MAKE_WINSOCK_ERROR(WinsockInitError);
      return;
   }

   if (LOBYTE(WsaData.wVersion) != 1 ||
       HIBYTE(WsaData.wVersion) != 1)
   {
      HWSTRACE0(0, HWS_WARNING, __TEXT("linkLayerInit: Winsock version mismatch"));
      InitializeStatus = MAKE_WINSOCK_ERROR(WSAVERNOTSUPPORTED);
      return;
   }

   // Create window to receive Winsock messages
   if (RegisterClass(&wndclass) == 0
       || (window = CreateWindow(CLASS_NAME, __TEXT(""), WS_OVERLAPPED, 0, 0, 0, 0, 0, 0, 0, NULL)) == 0)
   {
      HWSTRACE0(0, HWS_WARNING, __TEXT("linkLayerInit: error creating window"));
      InitializeStatus = HRESULT_FROM_WIN32(GetLastError());
      return;
   }

    //
    // LAURABU
    // BOGUS BUGBUG
    // 
    // This table code was never stressed by the people who wrote it.  It
    // totally falls apart when it completely fills up
    //      * Allocating the last item doesn't work
    //      * Freeing the last item doesn't work
    //      * Resizing larger doesn't work
    //
    // Since it doesn't take a lot of memory, a decent solution is to just
    // allocate it maximum+1 sized, and leave the last item free.
    //
   gpInstanceTable = new TSTable <HWSINST> (257);

   if(gpInstanceTable == NULL || gpInstanceTable->IsInitialized() == FALSE)
   {
	  InitializeStatus = LINK_MEM_FAILURE;
      return;
   }
      
   pSocketToHWSInstanceMap = new SOCKET_TO_INSTANCE[SOCK_TO_PHYSID_TABLE_SIZE];
   if(pSocketToHWSInstanceMap == NULL)
   {
	  InitializeStatus = LINK_MEM_FAILURE;
      return;
   }
   InitializeCriticalSection(&SocketToHWSInstanceMapLock);

   memset(pSocketToHWSInstanceMap, 0, sizeof(SOCKET_TO_INSTANCE) * SOCK_TO_PHYSID_TABLE_SIZE);
	
   // Init the sockets to a bad value

   for (dwIndex = 0; dwIndex < SOCK_TO_PHYSID_TABLE_SIZE; dwIndex++)
   {
      pSocketToHWSInstanceMap[dwIndex].socket = INVALID_SOCKET;
   }

   InitializeStatus = NOERROR;
   bInitialized = TRUE;
}

void Uninitialize()
{
   if(bInitialized)
   {
	   if (WinsockInitError == 0)
	   {
	      if (window)
	      {
	         DestroyWindow(window);
	         window = 0;
	         UnregisterClass(CLASS_NAME, 0);

	         if (gpInstanceTable)
	         {
	            delete gpInstanceTable;

	            if (InitializeStatus == NOERROR)
	            {
	               EnterCriticalSection(&SocketToHWSInstanceMapLock);
	               delete pSocketToHWSInstanceMap;
	               LeaveCriticalSection(&SocketToHWSInstanceMapLock);
	               DeleteCriticalSection(&SocketToHWSInstanceMapLock);
	            }
	         }
	      }
	      WSACleanup();
	   }
	   bInitialized = FALSE;
   }
 }


/***************************************************************************
 *
 * External entry points
 *
 ***************************************************************************/
//MULTITHREAD => dwH245Instance is now an OUTPUT param not an INPUT param.
LINKDLL HRESULT linkLayerInit (DWORD          *dwPhysicalId,
                              DWORD_PTR          dwH245Instance,
                              H245SRCALLBACK cbReceiveComplete,
                              H245SRCALLBACK cbTransmitComplete)
{
   register PHWSINST    pHws;
   *dwPhysicalId = INVALID_PHYS_ID; // Just in case...

   // Put Initialize back in here so we know everything we need is up and
   // running.
   if (InitializeStatus == LINK_INVALID_STATE)
      Initialize();
  
   if (InitializeStatus != NOERROR)
      return InitializeStatus;

   pHws = (PHWSINST)MemAlloc(sizeof(*pHws));
   if (pHws == NULL)
   {
      // couldn't allocate our context. Return
      HWSTRACE0(INVALID_PHYS_ID, HWS_WARNING, __TEXT("linkLayerInit: could not allocate context"));
      return LINK_MEM_FAILURE;
   }
   memset(pHws, 0, sizeof(*pHws));
   pHws->hws_Socket           = INVALID_SOCKET;
#if defined(_DEBUG)
   pHws->hws_dwMagic = HWSINST_MAGIC;
#endif  // (_DEBUG)

   // Create and initialize the Receive queue
   pHws->hws_pRecvQueue = QCreate();
   if (pHws->hws_pRecvQueue == NULL)
   {
      HWSTRACE0(INVALID_PHYS_ID, HWS_WARNING, __TEXT("linkLayerInit: could not allocate Receive queue"));
      MemFree(pHws);
      return LINK_MEM_FAILURE;
   }

   // Create and initialize the Send queue
   pHws->hws_pSendQueue = QCreate();
   if (pHws->hws_pSendQueue == NULL)
   {
      HWSTRACE0(INVALID_PHYS_ID, HWS_WARNING, __TEXT("linkLayerInit: could not allocate Send queue"));
      QFree(pHws->hws_pRecvQueue);
      MemFree(pHws);
      return LINK_MEM_FAILURE;
   }

   // Save intance identifiers and callback pointers
   pHws->hws_uState           = HWS_START;
   pHws->hws_dwH245Instance   = dwH245Instance;
   pHws->hws_h245RecvCallback = cbReceiveComplete;
   pHws->hws_h245SendCallback = cbTransmitComplete;

   // Open Channel 0 for the Forward and Reverse Directions
   // TBD

   // Add instance to instance list

   if(!gpInstanceTable->CreateAndLock(pHws, &pHws->hws_dwPhysicalId))
   {
      Q931HangupPendingCalls(NULL);

      if(!gpInstanceTable->CreateAndLock(pHws, &pHws->hws_dwPhysicalId))
      {
         HWSTRACE0(INVALID_PHYS_ID, HWS_WARNING, __TEXT("linkLayerInit: could not add to instance table"));
         QFree(pHws->hws_pSendQueue);
         QFree(pHws->hws_pRecvQueue);
         MemFree(pHws);
         return LINK_INSTANCE_TABLE_FULL;
      }
   }
   
   *dwPhysicalId = pHws->hws_dwPhysicalId;

   gpInstanceTable->Unlock(pHws->hws_dwPhysicalId);

   HWSTRACE2(*dwPhysicalId, HWS_TRACE,
             __TEXT("linkLayerInit(%d, %d) succeeded"), dwPhysicalId, dwH245Instance);

   return NOERROR;
} // linkLayerInit()



LINKDLL HRESULT linkLayerShutdown(DWORD dwPhysicalId)
{
   register PHWSINST    pHws;
   UINT                 uRetryCount;
   register PREQUEST    pReq;

   if (InitializeStatus != NOERROR)
      return InitializeStatus;
	
   if ((dwPhysicalId == INVALID_PHYS_ID) ||
      (!(pHws = gpInstanceTable->Lock(dwPhysicalId))))
   {
      HWSTRACE0(dwPhysicalId, HWS_ERROR,
                __TEXT("linkLayerShutdown: dwPhysicalId not found"));
      return LINK_INVALID_INSTANCE;
   }

   // mark this instance as deleted so we don't process anymore messages for it - 
   // note: the FALSE indicates to the TSTable class to NOT do the deletion of memory
   // once the last unlock has completed (which is at the end of this function)
   gpInstanceTable->Delete(dwPhysicalId, FALSE);

   RemoveSocketToPhysicalIdMapping(pHws->hws_Socket);

   switch (pHws->hws_uState)
   {
   case HWS_START:
   case HWS_LISTENING:
   case HWS_CONNECTING:
      break;

   case HWS_CONNECTED:
      // Try to send all messages waiting on send queue
      HWSASSERT(pHws->hws_pSendQueue != NULL);
      ProcessQueuedSends(pHws);
      uRetryCount = 0;
      while (  pHws->hws_uState == HWS_CONNECTED &&
               IsQEmpty(pHws->hws_pSendQueue) == FALSE &&
               ++uRetryCount <= 5)
      {
         HWSTRACE1(pHws->hws_dwPhysicalId, HWS_NOTIFY,
                   __TEXT("linkLayerShutdown: Waiting for send %d"), uRetryCount);
         ProcessQueuedSends(pHws);
         Sleep(100);
      }

      if (pHws->hws_uState == HWS_CONNECTED)
      {
         HWSTRACE0(pHws->hws_dwPhysicalId, HWS_TRACE,
                   __TEXT("linkLayerShutdown: calling shutdown"));
         if (shutdown(pHws->hws_Socket, 1) == SOCKET_ERROR)
         {
            HWSTRACE1(pHws->hws_dwPhysicalId, HWS_WARNING,
                     __TEXT("linkLayerShutdown: shutdown() returned %s"),
                     SocketErrorText());
         }
         pHws->hws_uState = HWS_CLOSING;
      }

   case HWS_CLOSING:
      break;

   case HWS_CLOSED:
      break;

   default:
      HWSASSERT(FALSE);
   } // switch

   // Deallocate instance objects

   SocketClose(pHws);


   // Deallocate Receive queue
   if (pHws->hws_pRecvQueue)
   {
      while ((pReq = (PREQUEST) QRemove(pHws->hws_pRecvQueue)) != NULL)
      {
         pHws->hws_h245RecvCallback(pHws->hws_dwH245Instance,
                                    LINK_RECV_ABORT,
                                    pReq->req_client_data,
                                    0);
         MemFree(pReq);
      }
      QFree(pHws->hws_pRecvQueue);
      pHws->hws_pRecvQueue = NULL;
   }

   // Deallocate Send queue
   if (pHws->hws_pSendQueue)
   {
      while ((pReq = (PREQUEST) QRemove(pHws->hws_pSendQueue)) != NULL)
      {
         pHws->hws_h245SendCallback(pHws->hws_dwH245Instance,
                                    LINK_SEND_ABORT,
                                    pReq->req_client_data,
                                    0);
         MemFree(pReq);
      }
      QFree(pHws->hws_pSendQueue);
      pHws->hws_pSendQueue = NULL;
   }

   gpInstanceTable->Unlock(dwPhysicalId);

   MemFree(pHws);

   HWSTRACE0(dwPhysicalId, HWS_TRACE, __TEXT("linkLayerShutdown: succeeded"));
   return NOERROR;
} // linkLayerShutdown



/***************************************************************************
 *
 *  NAME
 *      linkLayerGetInstance - return instance id corresponding to physical id
 *
 *  SYNOPSIS
 *      LINKDLL DWORD linkLayerGetInstance(DWORD dwPhysicalId);
 *
 * DESCRIPTION
 *      Returns the Instance identifier corresponding to dwPhysId.
 *
 *  PARAMETERS
 *      dwPhysicalId    Physical identifier to search for
 *
 *  RETURN VALUE
 //MULTITHREAD
 *      INVALID_PHYS_ID    (-1)No instance corresponding to dwPhysicalId found
 *      n>0             Instance Id corresponding to dwPhysicalId
 *
 ***************************************************************************/

LINKDLL DWORD linkLayerGetInstance(DWORD dwPhysicalId)
{
   if (InitializeStatus == NOERROR &&
       dwPhysicalId != INVALID_PHYS_ID &&
       gpInstanceTable->Lock(dwPhysicalId) != NULL)
   {
      HWSTRACE0(dwPhysicalId, HWS_TRACE, __TEXT("linkLayerGetInstance: succeeded"));
      gpInstanceTable->Unlock(dwPhysicalId); 
      return dwPhysicalId;
   }

   HWSTRACE0(dwPhysicalId, HWS_ERROR, __TEXT("linkLayerGetInstance: failed"));
   return INVALID_PHYS_ID;                           // return failure
} // linkLayerGetInstance()



/***************************************************************************
 *
 * NAME
 *    linkLayerFlushChannel - flush transmit and/or receive channels
 *
 * DESCRIPTION
 *    This is a dummy function required only for compatibility with the SRP API.
 *
 * RETURN VALUE
 *    0           Function succeeded.
 *    n!=0        Link error code (see LINKAPI.H for definitions.)
 *
 ***************************************************************************/

LINKDLL HRESULT linkLayerFlushChannel(DWORD dwPhysicalId, DWORD dwDirectionMask)
{
   if (InitializeStatus != NOERROR)
      return InitializeStatus;

   PHWSINST pHws;
   if ((dwPhysicalId == INVALID_PHYS_ID) ||
      (!(pHws = gpInstanceTable->Lock(dwPhysicalId))))
   {
      HWSTRACE0(dwPhysicalId, HWS_ERROR,
                __TEXT("linkLayerFlushChannel: dwPhysicalId not found"));
      return LINK_INVALID_INSTANCE;
   }

   switch (dwDirectionMask & (DATALINK_RECEIVE | DATALINK_TRANSMIT))
   {
   case DATALINK_TRANSMIT | DATALINK_RECEIVE:
      // Flush both receive and transmit
      // Caveat: H.245 expects us to flush receive first!
      SocketFlushRecv(pHws);

      // Fall through to next case

   case DATALINK_TRANSMIT:
      // Flush transmit
      // SockFlushSend() just removes the entries from the queue - it doesn't send them.
      // So instead, call ProcessQueuedSends() to actually empty the send queue.
      //      SocketFlushSend(pHws);	
			ProcessQueuedSends(pHws);
      break;

   case DATALINK_RECEIVE:
      // Flush receive
      SocketFlushRecv(pHws);
      break;

   } // switch

 	gpInstanceTable->Unlock(dwPhysicalId);

   HWSTRACE2(dwPhysicalId, HWS_TRACE,
             __TEXT("linkLayerFlushChannel(%d, 0x%X) succeeded"),
             dwPhysicalId, dwDirectionMask);
   return NOERROR;
} // linkLayerFlushChannel()



/***************************************************************************
 *
 * NAME
 *    linkLayerFlushAll - flush transmit and receive channels
 *
 * DESCRIPTION
 *    This is a dummy function required only for compatibility with the SRP API.
 *
 * RETURN VALUE
 *    0           Function succeeded.
 *    n!=0        Link error code (see LINKAPI.H for definitions.)
 *
 ***************************************************************************/

LINKDLL HRESULT linkLayerFlushAll(DWORD dwPhysicalId)
{

   if (InitializeStatus != NOERROR)
      return InitializeStatus;

   PHWSINST pHws;
   if ((dwPhysicalId == INVALID_PHYS_ID) ||
      (!(pHws = gpInstanceTable->Lock(dwPhysicalId))))
   {
      HWSTRACE0(dwPhysicalId, HWS_ERROR,
                __TEXT("linkLayerFlushAll: dwPhysicalId not found"));
      return LINK_INVALID_INSTANCE;
   }

   // Flush both receive and transmit
   // Caveat: H.245 expects us to flush receive first!
   SocketFlushRecv(pHws);
   SocketFlushSend(pHws);

   gpInstanceTable->Unlock(dwPhysicalId);

   HWSTRACE0(dwPhysicalId, HWS_TRACE, __TEXT("linkLayerFlushAll succeeded"));
   return NOERROR;
} // linkLayerFlushAll()



/*++

Description:

   Initiates a call to a remote node.
   1) Create a socket.
   2) Set the socket up for windows message notification of FD_CONNECT events.
   3) Attempt a connection

Arguments:
   pHws  - Pointer to context data from connection.

Return Value:
   SUCCESS  - A connection attempt was successfully initiated.
   LINK_FATAL_ERROR  - Error occurred while attempting to initiate a connection.

--*/

LINKDLL HRESULT linkLayerConnect(DWORD dwPhysicalId, CC_ADDR *pAddr, H245CONNECTCALLBACK callback)
{
   register PHWSINST    pHws;
   CC_ADDR              Addr;
   HRESULT              hr;

   if (InitializeStatus != NOERROR)
      return InitializeStatus;

   HWSTRACE5(dwPhysicalId, HWS_TRACE, __TEXT("linkLayerConnect: connecting to %d.%d.%d.%d/%d"),
             GetIPAddress(pAddr) & 0xFF,
             (GetIPAddress(pAddr) >>  8) & 0xFF,
             (GetIPAddress(pAddr) >> 16) & 0xFF,
             GetIPAddress(pAddr) >> 24,
             ntohs(GetPort(pAddr)));

   if ((dwPhysicalId == INVALID_PHYS_ID) ||
      (!(pHws = gpInstanceTable->Lock(dwPhysicalId))))
   {
      HWSTRACE0(dwPhysicalId, HWS_ERROR, __TEXT("linkLayerConnect: dwPhysicalId not found"));
      return LINK_INVALID_INSTANCE;
   }

   if (pHws->hws_uState != HWS_START)
   {
      HWSTRACE1(dwPhysicalId, HWS_ERROR, __TEXT("linkLayerConnect: State = %s"),
                SocketStateText(pHws->hws_uState));
   	  gpInstanceTable->Unlock(dwPhysicalId);
      return LINK_INVALID_STATE;
   }

   pHws->hws_h245ConnectCallback = callback;

   // Create a socket, bind to a local address and initiate a connection.
   if ((hr = SocketOpen(pHws)) != NOERROR)
   {
      HWSTRACE0(dwPhysicalId, HWS_WARNING,
                __TEXT("linkLayerConnect: SocketOpen() failed"));
      pHws->hws_uState = HWS_START;
      gpInstanceTable->Unlock(dwPhysicalId);
      return hr;
   }

   Addr.nAddrType = CC_IP_BINARY;
   Addr.bMulticast = FALSE;
   Addr.Addr.IP_Binary.wPort = 0;
   Addr.Addr.IP_Binary.dwAddr = 0;
   if ((hr = SocketBind(pHws, &Addr)) != NOERROR)
   {
      HWSTRACE0(dwPhysicalId, HWS_WARNING,
	      __TEXT("linkLayerConnect: SocketBind() failed"));
      pHws->hws_uState = HWS_START;
      gpInstanceTable->Unlock(dwPhysicalId);
      return hr;
   }

   // Reminder: WinSock requires that we pass a struct sockaddr *
   // to connect; however, the service provider is free to
   // interpret the pointer as an arbitrary chunk of data of size
   // uSockAddrLen.
   pHws->hws_SockAddr.sin_port             = GetPort(pAddr);
   pHws->hws_SockAddr.sin_addr.S_un.S_addr = GetIPAddress(pAddr);
   if (connect(pHws->hws_Socket,                                   // s
            (const struct sockaddr *)&pHws->hws_SockAddr,   // name
            sizeof(pHws->hws_SockAddr)) == SOCKET_ERROR)   // namelen
   {
      int err = WSAGetLastError();
      switch (err)
      {
      case WSAEWOULDBLOCK:
         break;

      default:
         HWSTRACE1(dwPhysicalId, HWS_WARNING,
                   __TEXT("linkLayerConnect: WSAConnect() returned %s"),
                   SocketErrorText1(err));
         SocketClose(pHws);
         pHws->hws_uState = HWS_START;
         gpInstanceTable->Unlock(dwPhysicalId);
         return MAKE_WINSOCK_ERROR(err);
      } // switch
   } // if
   else
   {
      HWSTRACE0(dwPhysicalId, HWS_TRACE, __TEXT("connect() succeeded"));
      SocketConnect(pHws, 0);
      gpInstanceTable->Unlock(dwPhysicalId);
      return NOERROR;
   } // else

   pHws->hws_uState = HWS_CONNECTING;
   HWSTRACE0(dwPhysicalId, HWS_TRACE, __TEXT("linkLayerConnect: succeeded"));
   gpInstanceTable->Unlock(dwPhysicalId);
   return NOERROR;
} // linkLayerConnect()



/***************************************************************************
 *
 * NAME
 *    linkLayerListen - start listen on connection
 *
 * DESCRIPTION
 *    This function creates a socket,
 *    binds to a local address, and listens on the created socket.
 *    The address being listened to is returned in the structure
 *    pointed to by pAddr.
 *
 * PARAMETERS
 *    dwPhysicalId      Link layer identifier returned by linkLayerGetInstance().
 *    pAddr             Pointer to address structure (defined in CALLCONT.H.)
 *
 * RETURN VALUE
 *    0                 Function succeeded.
 *    n!=0              Error code (see LINKAPI.H for definitions.)
 *
 ***************************************************************************/
//MULTITHREAD => dwPhysicalID was INPUT now it's OUTPUT
LINKDLL HRESULT linkLayerListen (DWORD *dwPhysicalId, DWORD_PTR dwH245Instance, CC_ADDR *pAddr, H245CONNECTCALLBACK callback)
{
   HRESULT hr;
   register PHWSINST    pHws;

   if (InitializeStatus == LINK_INVALID_STATE)
      Initialize();
   if (InitializeStatus != NOERROR)
      return InitializeStatus;

   if ((*dwPhysicalId == INVALID_PHYS_ID) ||
      (!(pHws = gpInstanceTable->Lock(*dwPhysicalId))))
   {
      if ((hr = linkLayerInit(dwPhysicalId, dwH245Instance, NULL, NULL)) != NOERROR)
         return hr;

      pHws = gpInstanceTable->Lock(*dwPhysicalId);
      HWSASSERT(pHws != NULL);
   }
   else
   {
      HWSASSERT(pHws->hws_dwH245Instance == dwH245Instance);
   }

   if (pHws->hws_uState != HWS_START)
   {
      HWSTRACE1(*dwPhysicalId, HWS_ERROR, __TEXT("linkLayerListen: State = %s"),
                SocketStateText(pHws->hws_uState));
      gpInstanceTable->Unlock(*dwPhysicalId);
      return LINK_INVALID_STATE;
   }

   pHws->hws_h245ConnectCallback = callback;

   if ((hr = SocketOpen(pHws, FALSE)) != NOERROR)
   {
      HWSTRACE0(*dwPhysicalId, HWS_WARNING, __TEXT("linkLayerListen: SocketBind() failed"));
      pHws->hws_uState = HWS_START;
      gpInstanceTable->Unlock(*dwPhysicalId);
      return hr;
   }

   if ((hr = SocketBind(pHws, pAddr)) != NOERROR)
   {
      HWSTRACE0(*dwPhysicalId, HWS_WARNING, __TEXT("linkLayerListen: SocketBind() failed"));
      pHws->hws_uState = HWS_START;
      gpInstanceTable->Unlock(*dwPhysicalId);
      return hr;
   }

   // Listen for incoming connection requests on the socket.
   int nBacklog = SOMAXCONN;
   while (listen(pHws->hws_Socket, nBacklog) == SOCKET_ERROR)
   {
      int err = WSAGetLastError();
      HWSTRACE1(*dwPhysicalId,
                HWS_WARNING,
                __TEXT("linkLayerListen: listen() returned %s"),
                SocketErrorText1(err));
      if (nBacklog == SOMAXCONN)
         nBacklog = 10;
      if (err != WSAENOBUFS || --nBacklog == 0)
      {
         SocketClose(pHws);
         pHws->hws_uState = HWS_START;
         gpInstanceTable->Unlock(*dwPhysicalId);
         return MAKE_WINSOCK_ERROR(err);
      }     
      Sleep(0);
   }

   if ((hr = GetLocalAddr(pHws, pAddr)) != NOERROR)
   {
      // getsockname() failed
      HWSTRACE1(pHws->hws_dwPhysicalId, HWS_WARNING,
                __TEXT("linkLayerListen: getsockname() returned %s"),
                SocketErrorText());
      SocketClose(pHws);
      pHws->hws_uState = HWS_START;
      gpInstanceTable->Unlock(*dwPhysicalId);
      return hr;
   }

   HWSTRACE5(*dwPhysicalId, HWS_TRACE, __TEXT("linkLayerListen: listening on %d.%d.%d.%d/%d"),
             GetIPAddress(pAddr) & 0xFF,
             (GetIPAddress(pAddr) >>  8) & 0xFF,
             (GetIPAddress(pAddr) >> 16) & 0xFF,
             GetIPAddress(pAddr) >> 24,
             ntohs(GetPort(pAddr)));

   pHws->hws_uState = HWS_LISTENING;
   HWSTRACE0(*dwPhysicalId, HWS_TRACE, __TEXT("linkLayerListen: succeeded"));
   gpInstanceTable->Unlock(*dwPhysicalId);
   return NOERROR;
} // linkLayerListen()


LINKDLL HRESULT
linkLayerAccept(DWORD dwPhysicalIdListen, DWORD dwPhysicalIdAccept, H245CONNECTCALLBACK callback)
{
    PHWSINST pHwsListen;
    PHWSINST pHwsAccept;

    HRESULT rc;
    if (InitializeStatus != NOERROR)
       return InitializeStatus;

	HWSTRACE0(dwPhysicalIdAccept, HWS_TRACE, __TEXT("linkLayerAccept"));
    if ((dwPhysicalIdListen == INVALID_PHYS_ID) ||
       (!(pHwsListen = gpInstanceTable->Lock(dwPhysicalIdListen))))
    {
       HWSTRACE0(dwPhysicalIdListen, HWS_ERROR, __TEXT("linkLayerAccept: dwPhysicalIdListen not found"));
       return LINK_INVALID_INSTANCE;
    }

    pHwsAccept = gpInstanceTable->Lock(dwPhysicalIdAccept);
    if (pHwsAccept == NULL)
    {
       HWSTRACE0(dwPhysicalIdAccept, HWS_ERROR, __TEXT("linkLayerAccept: dwPhysicalIdAccept not found"));
		 gpInstanceTable->Unlock(dwPhysicalIdListen);
       return LINK_INVALID_INSTANCE;
    }

    HWSASSERT(pHwsListen->hws_uState == HWS_LISTENING);
    HWSASSERT(pHwsAccept == pHwsListen || pHwsAccept->hws_uState == HWS_START);

    pHwsAccept->hws_h245ConnectCallback = callback;

    rc = SocketAccept(pHwsListen, pHwsAccept);
	gpInstanceTable->Unlock(dwPhysicalIdListen);
    gpInstanceTable->Unlock(dwPhysicalIdAccept);
    return rc;
}

/***************************************************************************
 *
 * NAME
 *    linkLayerReject   - reject an incomming connection request
 *
 * DESCRIPTION
 *    This function accepts an incomming connection
 *    request then immediatly closes the new socket. 
 *
 * PARAMETERS
 *    dwPhysicalId      Link layer identifier of the listening socket
 *
 * RETURN VALUE
 *    0                 Function succeeded.
 *    n!=0              Error code (see LINKAPI.H for definitions.)
 *
 ***************************************************************************/
LINKDLL HRESULT
linkLayerReject(DWORD dwPhysicalIdListen)
{
    HRESULT     hr          = NOERROR;
    PHWSINST    pHwsListen  = NULL;
    SOCKET      sockReject  = INVALID_SOCKET;
    SOCKADDR_IN sockAddr;
    INT         sockAddrLen = sizeof(sockAddr);

    // Lock the table to get the socket handle
    pHwsListen = gpInstanceTable->Lock(dwPhysicalIdListen);
    if(NULL != pHwsListen)
    {
        // Accept incoming conenction then immediately close it
        sockReject = accept(pHwsListen->hws_Socket, (SOCKADDR *)&sockAddr, &sockAddrLen);
        if(INVALID_SOCKET != sockReject)
        {
            closesocket(sockReject);
        }
        else
        {
            hr = MAKE_WINSOCK_ERROR(WSAGetLastError());
        }
    }
    else
    {
        hr =  LINK_INVALID_INSTANCE;
    }

    // Unlock the instance table
    gpInstanceTable->Unlock(dwPhysicalIdListen);

    return hr;       
}



// Here is the corresponding redefinition of the __TEXT macro

#ifndef UNICODE_TRACE
#undef  __TEXT
#define __TEXT(x) L##x
#endif


#if defined(__cplusplus)
}
#endif  // (__cplusplus)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\h245wstx.cpp ===
/***************************************************************************
 *
 * File: h245wstx.c
 *
 * INTEL Corporation Proprietary Information
 * Copyright (c) 1996 Intel Corporation.
 *
 * This listing is supplied under the terms of a license agreement
 * with INTEL Corporation and may not be used, copied, nor disclosed
 * except in accordance with the terms of that agreement.
 *
 ***************************************************************************
 *
 * $Workfile:   h245wstx.cpp  $
 * $Revision:   2.4  $
 * $Modtime:   30 Jan 1997 17:15:58  $
 * $Log:   S:/STURGEON/SRC/H245WS/VCS/h245wstx.cpv  $
 * 
 *    Rev 2.4   30 Jan 1997 17:18:02   EHOWARDX
 * Fixed bug in trace message - need to do trace before
 * calling shutdown() sent shutdown clears error retrieved
 * by WSAGetLastError().
 * 
 *    Rev 2.3   14 Jan 1997 15:49:00   EHOWARDX
 * Changed TryRecv() and TrySend() to check for WSAECONNRESET and
 * WSAECONNABORT return from recv() and send() and act accordingly.
 * 
 *    Rev 2.2   19 Dec 1996 18:55:12   SBELL1
 * took out tag comments
 * 
 *    Rev 2.1   Dec 13 1996 17:33:24   plantz
 * moved #ifdef _cplusplus to after include files
// 
//    Rev 1.1   13 Dec 1996 12:12:02   SBELL1
// moved #ifdef _cplusplus to after include files
// 
//    Rev 1.0   11 Dec 1996 13:41:54   SBELL1
// Initial revision.
 * 
 *    Rev 1.16   May 28 1996 18:14:40   plantz
 * Change error codes to use HRESULT. Propogate Winsock errors where appropriate
 * 
 *    Rev 1.15   17 May 1996 16:49:34   EHOWARDX
 * Shutdown fix.
 * 
 *    Rev 1.14   09 May 1996 18:33:20   EHOWARDX
 * 
 * Changes to build with new LINKAPI.H.
 * 
 *    Rev 1.13   29 Apr 1996 16:53:28   EHOWARDX
 * 
 * Added trace statement.
 * 
 *    Rev 1.12   Apr 29 1996 14:04:38   plantz
 * Call NotifyWrite instead of ProcessQueuedSends.
 * 
 *    Rev 1.11   Apr 29 1996 12:15:04   plantz
 * Change tpkt header to include header size in packet length.
 * Assert that message length does not exceed INT_MAX.
 * .
 * 
 *    Rev 1.10   27 Apr 1996 14:46:24   EHOWARDX
 * Parenthesized TrySend() return.
 * 
 *    Rev 1.9   Apr 24 1996 16:41:30   plantz
 * Merge 1.5.1.0 with 1.8 (changes for winsock 1).
 * 
 *    Rev 1.5.1.0   Apr 24 1996 16:22:22   plantz
 * Change to not use overlapped I/O (for winsock 1).
 * 
 *    Rev 1.5   01 Apr 1996 14:20:44   unknown
 * Shutdown redesign.
 * 
 *    Rev 1.4   19 Mar 1996 20:18:20   EHOWARDX
 * 
 * Redesigned shutdown.
 * 
 *    Rev 1.3   18 Mar 1996 19:08:32   EHOWARDX
 * Fixed shutdown; eliminated TPKT/WSCB dependencies.
 * Define TPKT to put TPKT/WSCB dependencies back in.
 * 
 *    Rev 1.2   14 Mar 1996 17:02:02   EHOWARDX
 * 
 * NT4.0 testing; got rid of HwsAssert(); got rid of TPKT/WSCB.
 * 
 *    Rev 1.1   09 Mar 1996 21:12:30   EHOWARDX
 * Fixes as result of testing.
 * 
 *    Rev 1.0   08 Mar 1996 20:20:06   unknown
 * Initial revision.
 *
 ***************************************************************************/

#define LINKDLL_EXPORT

#pragma warning ( disable : 4115 4201 4214 4514 )
#undef _WIN32_WINNT	// override bogus platform definition in our common build environment

#include "precomp.h"

#include <limits.h>
//#include <winsock.h>
#include "queue.h"
#include "linkapi.h"
#include "h245ws.h"
#include "tstable.h"

#if defined(__cplusplus)
extern "C"
{
#endif  // (__cplusplus)


// If we are using not using the Unicode version of the IRS display utility, then
// redefine the __TEXT macro to do nothing.

#ifndef UNICODE_TRACE
#undef  __TEXT
#define __TEXT(x) x
#endif

extern TSTable<HWSINST>* gpInstanceTable;	// global ptr to the instance table

static void SetupTPKTHeader(BYTE *tpkt_header, DWORD length);

/*++

Description:
   Attempt to send

Arguments:
   pHws              - Pointer to context for "connection"
   pReq              - Pointer to I/O request structure

Return Value:
   SUCCESS                       - Successfully started send.
   LINK_SEND_ERROR_WOULD_BLOCK   - 
   LINK_SEND_ERROR_CLOSED        - The socket was gracefully closed.
   LINK_SEND_ERROR_ERROR         - Error receiving data.

--*/

static HRESULT
TrySend(IN PHWSINST pHws, IN const char *data, IN int length, IN OUT int *total_bytes_sent)
{
   int requested_length = length - *total_bytes_sent;
   int send_result = send(pHws->hws_Socket, data+*total_bytes_sent, requested_length, 0);

   if (send_result == SOCKET_ERROR)
   {
      int err = WSAGetLastError();
      switch (err)
      {
      case WSAEWOULDBLOCK:
         return LINK_SEND_WOULD_BLOCK;

      case WSAECONNABORTED:
      case WSAECONNRESET:
         HWSTRACE1(pHws->hws_dwPhysicalId, HWS_WARNING,
                   __TEXT("TrySend: send() returned %s"),
                   SocketErrorText());
         if (pHws->hws_uState == HWS_CONNECTED)
         {
            HWSTRACE0(pHws->hws_dwPhysicalId, HWS_TRACE,
                      __TEXT("TrySend: calling shutdown"));
            if (shutdown(pHws->hws_Socket, 1) == SOCKET_ERROR)
            {
               HWSTRACE1(pHws->hws_dwPhysicalId, HWS_WARNING,
                        __TEXT("TrySend: shutdown() returned %s"),
                        SocketErrorText());
            }
            pHws->hws_uState = HWS_CLOSING;
         }
         return MAKE_WINSOCK_ERROR(err);

      default:
         HWSTRACE1(pHws->hws_dwPhysicalId, HWS_WARNING,
                   __TEXT("TrySend: send() returned %s"),
                   SocketErrorText());
         return MAKE_WINSOCK_ERROR(err);
      } // switch
   }

   HWSTRACE1(pHws->hws_dwPhysicalId, HWS_TRACE, __TEXT("TrySend: send returned %d"), send_result);
   *total_bytes_sent += send_result;
   return (send_result == requested_length) ? NOERROR : LINK_SEND_WOULD_BLOCK;
}


static HRESULT
SendStart(IN PHWSINST pHws, IN PREQUEST pReq)
{
   HRESULT nResult = NOERROR;

   // Sanity checks
   HWSASSERT(pHws != NULL);
   HWSASSERT(pHws->hws_dwMagic == HWSINST_MAGIC);
   HWSASSERT(pReq != NULL);
   HWSASSERT(pReq->req_dwMagic == SEND_REQUEST_MAGIC);
   HWSASSERT(pReq->req_pHws == pHws);

   // Send the header first; if that succeeds send the client data
   if (pReq->req_header_bytes_done < TPKT_HEADER_SIZE)
   {
       nResult = TrySend(pHws,
                         (const char *)pReq->req_TpktHeader,
                         TPKT_HEADER_SIZE,
                         &pReq->req_header_bytes_done);
   }

   if (nResult == NOERROR)
   {
       nResult = TrySend(pHws,
                         (const char *)pReq->req_client_data,
                         pReq->req_client_length,
                         &pReq->req_client_bytes_done);
   }

   return nResult;
} // SendStart()


void
ProcessQueuedSends(IN PHWSINST pHws)
{
   register PREQUEST    pReq;
   register DWORD       dwPhysicalId = pHws->hws_dwPhysicalId;

   HWSASSERT(pHws != NULL);
   HWSASSERT(pHws->hws_dwMagic == HWSINST_MAGIC);
   HWSASSERT(pHws->hws_uState <= HWS_CONNECTED);
   HWSTRACE0(pHws->hws_dwPhysicalId, HWS_TRACE, __TEXT("ProcessQueuedSends"));

   while ((pReq = (PREQUEST)QRemove(pHws->hws_pSendQueue)) != NULL)
   {
      switch (SendStart(pHws, pReq))
      {
      case NOERROR:
         // Call Send callback
         pHws->hws_h245SendCallback(pHws->hws_dwH245Instance,
                                    LINK_SEND_COMPLETE,
                                    pReq->req_client_data,
                                    pReq->req_client_bytes_done);

         // Free the I/O request structure
         MemFree(pReq);

         // Check to see if callback deallocated our instance or state changed
		   if(gpInstanceTable->Lock(dwPhysicalId) == NULL)
			   return;
		   gpInstanceTable->Unlock(dwPhysicalId);
		   if(pHws->hws_uState > HWS_CONNECTED)
		      return;

         break;

      default:
         HWSTRACE0(pHws->hws_dwPhysicalId, HWS_WARNING,
                   __TEXT("ProcessQueuedSends: SendStart() failed"));

         // Fall-through to next case is intentional

      case LINK_SEND_WOULD_BLOCK:
         // The send would have blocked; we need to requeue the I/O request
         // and wait for a FD_WRITE network event.
         // If any part of the data was sent, the bytes_done field has been updated.
         if (QInsertAtHead(pHws->hws_pSendQueue, pReq) == FALSE)
         {
            HWSTRACE0(pHws->hws_dwPhysicalId, HWS_CRITICAL,
                      __TEXT("ProcessQueuedSends: QInsertAtHead() failed"));
         }
         return;

      } // switch
   } // while
} // ProcessQueuedSends()



/**************************************************************************
** Function    : datalinkSendRequest
** Description : Fills header/tail of buffer and posts buffer to H.223
***************************************************************************/
LINKDLL HRESULT datalinkSendRequest( DWORD    dwPhysicalId,
                                   PBYTE    pbyDataBuf,
                                   DWORD    dwLength)
{
   register PHWSINST    pHws;
   register PREQUEST    pReq;

   HWSTRACE0(dwPhysicalId, HWS_TRACE, __TEXT("datalinkSendRequest"));

   pHws = gpInstanceTable->Lock(dwPhysicalId);
   if (pHws == NULL)
   {
      HWSTRACE0(dwPhysicalId, HWS_ERROR,
                __TEXT("datalinkSendRequest: dwPhysicalId not found"));
      return LINK_INVALID_INSTANCE;
   }

   if (pHws->hws_uState > HWS_CONNECTED)
   {
      HWSTRACE1(dwPhysicalId, HWS_ERROR,
                __TEXT("datalinkSendRequest: state = %d"), pHws->hws_uState);
	  gpInstanceTable->Unlock(dwPhysicalId);
      return LINK_INVALID_STATE;
   }

   // Allocate request structure
   pReq = (PREQUEST) MemAlloc(sizeof(*pReq));
   if (pReq == NULL)
   {
      HWSTRACE0(dwPhysicalId, HWS_WARNING,
                __TEXT("datalinkSendRequest: could not allocate request buffer"));
	   gpInstanceTable->Unlock(dwPhysicalId);
      return LINK_MEM_FAILURE;
   }

   // The current implementation requires that the size of each message
   // fit in a signed int (because that is what Winsock supports in a
   // single send). If it is necessary to send larger messages,
   // TrySend must be changed to limit the size in each send call, and
   // loop until all the data is sent. This ASSERT could then be removed.
   HWSASSERT(dwLength <= INT_MAX);

   pReq->req_pHws             = pHws;
   pReq->req_client_data      = pbyDataBuf;
   pReq->req_client_length    = (int)dwLength;
   pReq->req_client_bytes_done= 0;
   pReq->req_dwMagic          = SEND_REQUEST_MAGIC;

   // Format TPKT header
   SetupTPKTHeader(pReq->req_TpktHeader, dwLength);
   pReq->req_header_bytes_done = 0;

   if (QInsert(pHws->hws_pSendQueue, pReq) == FALSE)
   {
      HWSTRACE0(pHws->hws_dwPhysicalId, HWS_CRITICAL,
                __TEXT("datalinkSendRequest: QInsert() failed"));
	  gpInstanceTable->Unlock(dwPhysicalId);
      MemFree(pReq);
      return LINK_SEND_NOBUFF;
   }

   if (pHws->hws_uState == HWS_CONNECTED)
       NotifyWrite(pHws);

   HWSTRACE0(dwPhysicalId, HWS_TRACE, __TEXT("datalinkSendRequest: succeeded"));
   gpInstanceTable->Unlock(dwPhysicalId);
   return NOERROR;
} // datalinkSendRequest

static void SetupTPKTHeader(BYTE *tpkt_header, DWORD length)
{
    length += TPKT_HEADER_SIZE;

    // TPKT requires that the packet size fit in two bytes.
    HWSASSERT(length < (1L << 16));

    tpkt_header[0] = TPKT_VERSION;
    tpkt_header[1] = 0;
    tpkt_header[2] = (BYTE)(length >> 8);
    tpkt_header[3] = (BYTE)length;
}


#if defined(__cplusplus)
}
#endif  // (__cplusplus)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\h245_sr.c ===
/******************************************************************************
 *
 *  File:  h245_sr.c
 *
 *   INTEL Corporation Proprietary Information
 *   Copyright (c) 1994, 1995, 1996 Intel Corporation.
 *
 *   This listing is supplied under the terms of a license agreement
 *   with INTEL Corporation and may not be used, copied, nor disclosed
 *   except in accordance with the terms of that agreement.
 *
 *****************************************************************************/

/******************************************************************************
 *
 *  $Workfile:   h245_sr.c  $
 *  $Revision:   1.10  $
 *  $Modtime:   Mar 04 1997 17:30:56  $
 *  $Log:   S:/STURGEON/SRC/H245/SRC/VCS/h245_sr.c_v  $
 *
 *    Rev 1.11   Jun 25 1998 00:00:00 mikev@microsoft.com
 * STRIPPED PLUGIN LINK LAYER AND COMBINED THE SEPARATE DLLs
 * 
 *    Rev 1.10   Mar 04 1997 17:51:22   tomitowx
 * process detach fix
 * 
 *    Rev 1.9   11 Dec 1996 13:55:20   SBELL1
 * Changed linkLayerInit parameters
 * 
 *    Rev 1.8   14 Oct 1996 14:05:52   EHOWARDX
 * 
 * Used cast to get rid of warning.
 * 
 *    Rev 1.7   14 Oct 1996 14:01:30   EHOWARDX
 * Unicode changes.
 * 
 *    Rev 1.6   23 Jul 1996 08:57:08   EHOWARDX
 * 
 * Moved H245 interop logger init/deinit from H245_SR.C (per-instance)
 * to H245MAIN.C (per-DLL). With multiple instances and a global variable,
 * per-instance init/deinit is fundamentally brain-dead.
 * 
 *    Rev 1.5   22 Jul 1996 17:33:44   EHOWARDX
 * Updated to latest Interop API.
 * 
 *    Rev 1.4   05 Jun 1996 17:13:50   EHOWARDX
 * Further work on converting to HRESULT; added PrintOssError to eliminate
 * pErrorString from instance structure.
 * 
 *    Rev 1.3   04 Jun 1996 18:17:32   EHOWARDX
 * Interop Logging changes inside #if defined(PCS_COMPLIANCE) conditionals.
 * 
 *    Rev 1.2   29 May 1996 15:20:20   EHOWARDX
 * Change to use HRESULT.
 * 
 *    Rev 1.1   28 May 1996 14:25:32   EHOWARDX
 * Tel Aviv update.
 * 
 *    Rev 1.0   09 May 1996 21:06:28   EHOWARDX
 * Initial revision.
 * 
 *    Rev 1.17.1.6   09 May 1996 19:34:40   EHOWARDX
 * Redesigned locking logic.
 * Simplified link API.
 * 
 *    Rev 1.17.1.5   29 Apr 1996 19:42:42   EHOWARDX
 * Commented out linkLayerFlushAll() call and synchronized with Rev 1.30.
 * 
 *    Rev 1.26   29 Apr 1996 12:53:16   EHOWARDX
 * Commented out receive thread/receive queue code.
 * 
 *    Rev 1.17.1.4   25 Apr 1996 21:27:04   EHOWARDX
 * Changed to use h245Instance->p_ossWorld instead of bAsnInitialized.
 * 
 *    Rev 1.17.1.3   23 Apr 1996 14:44:22   EHOWARDX
 * Updated.
 *
 *    Rev 1.17.1.2   15 Apr 1996 15:11:54   EHOWARDX
 * Updated.
 *
 *    Rev 1.17.1.1   26 Mar 1996 19:13:50   EHOWARDX
 *
 * Commented out hTraceFile.
 *
 *    Rev 1.17.1.0   26 Mar 1996 13:11:22   EHOWARDX
 * Branced and added H245_CONF_H323 to sendRecvInit
 *
 *    Rev 1.17   19 Mar 1996 18:09:04   helgebax
 * removed old timer code
 *
 *    Rev 1.16   13 Mar 1996 11:30:44   DABROWN1
 *
 * Enable logging for ring 0
 *
 *    Rev 1.15   11 Mar 1996 15:39:18   DABROWN1
 *
 * modifications required for ring0/ring3 compatiblity
 *
 *    Rev 1.13   06 Mar 1996 13:12:24   DABROWN1
 *
 * flush link layer buffers at shutdown
 *
 *    Rev 1.12   02 Mar 1996 22:11:10   DABROWN1
 *
 * changed h245_bzero to memset
 *
 *    Rev 1.11   01 Mar 1996 17:24:46   DABROWN1
 *
 * moved oss 'world' context to h245instance
 *
 *    Rev 1.10   28 Feb 1996 18:45:00   EHOWARDX
 *
 * Added H245TimerStart and H245TimerStop to linkLayerInit call.
 *
 *    Rev 1.9   28 Feb 1996 15:43:52   EHOWARDX
 *
 * Removed sample code.
 * Added code to free up all events on timer queue before deallocating.
 *
 *    Rev 1.8   27 Feb 1996 13:35:10   DABROWN1
 *
 * added h245instance in datalink initialization routine
 *
 *    Rev 1.7   26 Feb 1996 18:59:34   EHOWARDX
 *
 * Added H245TimerStart and H245TimerStop functions.
 * Also added sample timer function, which should be removed later.
 *
 *    Rev 1.6   23 Feb 1996 22:17:26   EHOWARDX
 *
 * Fixed check at start of sendRecvShutdown.
 * It's an error if dwInst is greater than or equal to MAXINST, not less than!
 *
 *    Rev 1.5   23 Feb 1996 21:59:28   EHOWARDX
 *
 * winspox changes.
 *
 *    Rev 1.4   23 Feb 1996 13:55:30   DABROWN1
 *
 * added h245TRACE ASSERT calls
 *
 *    Rev 1.3   21 Feb 1996 15:12:36   EHOWARDX
 *
 * Forgot to replace H245ReceiveComplete with H245ReceivePost.
 *
 *    Rev 1.2   20 Feb 1996 19:14:20   EHOWARDX
 * Added in mailbox changes.
 *
 *    Rev 1.1   21 Feb 1996 08:26:28   DABROWN1
 *
 * create and free multiple receive buffers.
 * Make size of buffer dependent on protocol in use
 *
 *    Rev 1.0   09 Feb 1996 17:34:24   cjutzi
 * Initial revision.
 *
 *****************************************************************************/

#ifndef STRICT 
#define STRICT 
#endif

/***********************/
/*   SYSTEM INCLUDES   */
/***********************/
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <limits.h>

#include "precomp.h"


/***********************/
/*    H245 INCLUDES    */
/***********************/
#include "h245com.h"
#include "sr_api.h"
#include "linkapi.h"


#if defined(USE_RECEIVE_QUEUE)
DWORD
ReceiveThread(VOID *lpThreadParameter)
{
    struct InstanceStruct *pInstance = (struct InstanceStruct *)lpThreadParameter;
	RXMSG				RxMsg;
    Uns                 uTimeout;

    Bool                bPendResult;


	SETTASK("H245RCVTASK0");

	if (pInstance == NULL) {
		H245PANIC();
		return SR_INVALID_CONTEXT;
	}

	// Loop until thread is ready to terminate
    pInstance->SendReceive.bReceiveThread = TRUE;
	for ( ; ; )
	{
        uTimeout = SYS_FOREVER;
		// Wait for an event (or a queued callback function) to wake us up.
		// This is an alertable wait state (fAlertable == TRUE)
        pInstance->SendReceive.bReceiveThread = FALSE;
        H245TRACE(pInstance->dwInst, 2, "ReceiveThread, uTimeout = %d", uTimeout);
		RESETTASK();

		bPendResult = MBX_pend(pInstance->SendReceive.pMailbox, &RxMsg, uTimeout);

		SETTASK("H245RCVTASK");
        H245TRACE(pInstance->pInstance->dwInst, 2, "ReceiveThread, bPendResult = %d", bPendResult);
        pInstance->SendReceive.bReceiveThread = TRUE;

		switch (RxMsg.dwMessage) {
		case EXIT_RECEIVE_THREAD:
			// Thread exiting....signal app

			TRACE("H245: Receive Thread Exiting");
			SEM_post(pInstance->SendReceive.hReceiveSemphore);
			RESETTASK();
			return 0;
			break;

		default:
			// Ignore timer message, which should have dwLength == 0
			if (RxMsg.dwLength)
			{
				h245ReceiveComplete(RxMsg.h245Inst,
									RxMsg.dwMessage,
									RxMsg.pbDataBuf,
									RxMsg.dwLength);
			}
			else 
			{

TRACE1("H245SEND: SendTask %d", RxMsg.dwMessage);

				h245SendComplete(RxMsg.h245Inst,
									RxMsg.dwMessage,
									RxMsg.pbDataBuf,
									RxMsg.dwLength);
			}
			break;
		} // switch

	} // for
	return 0;
} // ReceiveThread()


static void
h245ReceivePost(DWORD	h245Inst,
				DWORD	dwMessage,
				PBYTE	pbDataBuf,
				DWORD	dwLength)
{
    register struct InstanceStruct *pInstance;
	RXMSG					        RxMsg;

	// Validate the instance handle
    pInstance = InstanceLock(h245Inst);
    if (pInstance == NULL) {
		H245TRACE(h245Inst, 1, "h245ReceivePost h245Inst Invalid");
		H245PANIC();
		return;
	}

	RxMsg.h245Inst    = h245Inst;
	RxMsg.dwMessage   = dwMessage;
	RxMsg.pbDataBuf   = pbDataBuf;
	RxMsg.dwLength    = dwLength;

	if (MBX_post(pInstance->SendReceive.pMailbox, &RxMsg, 0) == FALSE) {
		H245TRACE(h245Inst, 1, "SR: MBX POST FAIL");
		H245PANIC();
	}
    InstanceUnlock(pInstance);
} // h245ReceivePost()
#endif  // (USE_RECEIVE_QUEUE)

HRESULT
initializeLinkDllEntry
(
	struct InstanceStruct * pInstance,
	LPCTSTR		            szDLLFile
)
{


#if(0)
	if (!(pInstance->SendReceive.hLinkModule = LoadLibrary(szDLLFile))) {
		return H245_ERROR_FATAL;
	}

	if (!(pInstance->SendReceive.hLinkLayerInit = (PFxnlinkLayerInit)
			GetProcAddress(pInstance->SendReceive.hLinkModule,
						   LINKINITIALIZE)))		{
		return H245_ERROR_FATAL;
	}

	if (!(pInstance->SendReceive.hLinkShutdown = (PFxnlinkLayerShutdown)
			GetProcAddress(pInstance->SendReceive.hLinkModule,
						   LINKSHUTDOWN)))		{
		return H245_ERROR_FATAL;
	}

	if (!(pInstance->SendReceive.hLinkGetInstance = (PFxnlinkLayerGetInstance)
			GetProcAddress(pInstance->SendReceive.hLinkModule,
						   LINKGETINSTANCE)))		{
		return H245_ERROR_FATAL;
	}

	if (!(pInstance->SendReceive.hLinkReceiveReq = (PFxndatalinkReceiveRequest)
			GetProcAddress(pInstance->SendReceive.hLinkModule,
						   LINKRECEIVEREQUEST)))		{
		return H245_ERROR_FATAL;
	}

	if (!(pInstance->SendReceive.hLinkSendReq = (PFxndatalinkSendRequest)
			GetProcAddress(pInstance->SendReceive.hLinkModule,
						   LINKSENDREQUEST)))		{
		return H245_ERROR_FATAL;
	}

	if (!(pInstance->SendReceive.hLinkLayerFlushChannel = (PFxnlinkLayerFlushChannel)
			GetProcAddress(pInstance->SendReceive.hLinkModule,
						   LINKFLUSHCHANNEL)))		{
		return H245_ERROR_FATAL;
	}

	if (!(pInstance->SendReceive.hLinkLayerFlushAll = (PFxnlinkLayerFlushAll)
			GetProcAddress(pInstance->SendReceive.hLinkModule,
						   LINKFLUSHALL)))		{
		return H245_ERROR_FATAL;
	}
#else
    pInstance->SendReceive.hLinkLayerInit = linkLayerInit;
    pInstance->SendReceive.hLinkShutdown = linkLayerShutdown;
    pInstance->SendReceive.hLinkGetInstance = linkLayerGetInstance;
    pInstance->SendReceive.hLinkReceiveReq = datalinkReceiveRequest;
    pInstance->SendReceive.hLinkSendReq = datalinkSendRequest;
    pInstance->SendReceive.hLinkLayerFlushChannel = linkLayerFlushChannel;
    pInstance->SendReceive.hLinkLayerFlushAll = linkLayerFlushAll;
#endif //if(0)
	H245TRACE(pInstance->dwInst,
			  3,
			  "SR: %s Loaded", szDLLFile);

	return (0);
}


#if defined(_DEBUG) && defined(H324)
void
srInitializeLogging
(
	struct InstanceStruct *pInstance,
	BOOL	bTracingEnabled
)
{
	FILE				*hTraceFile;
	char				initTraceFile[20] = "c:\\tmp\\h2450.000";
	BOOL				bSearch = TRUE;		// search for filename

	if (pInstance == NULL) {
		H245TRACE(h245Inst, 1, "SR:Enable Log Instance Error");
		H245PANIC();
		return;
	}

	// eventually will be from registry
	pInstance->SendReceive.bLoggingEnabled = bTracingEnabled;
	
	if (pInstance->SendReceive.bLoggingEnabled) {
		// Init the logger file for Ring0/SPOX implementations.  Loop until
		//	we get the next available revision
		memcpy(pInstance->SendReceive.fTraceFile,
			   initTraceFile,
			   20);
		pInstance->SendReceive.fTraceFile[11] = ((unsigned char)pInstance->dwInst & 0xF) + 0x30;

		do {
			hTraceFile = fopen(pInstance->SendReceive.fTraceFile, "r");
			if ((hTraceFile == NULL) || ((int)hTraceFile == -1)) {
				bSearch = FALSE;
			}
			else {
				// able to open the file. close it and try the next one
				fclose(hTraceFile);

				// get the next revision number
				if (pInstance->SendReceive.fTraceFile[15] == '9') {
					pInstance->SendReceive.fTraceFile[15] = '0';
					if (pInstance->SendReceive.fTraceFile[14] == '9') {
						pInstance->SendReceive.fTraceFile[14] = '0';
						pInstance->SendReceive.fTraceFile[13]++;
					}
					else {
						pInstance->SendReceive.fTraceFile[14]++;
					}
				}
				else {
					pInstance->SendReceive.fTraceFile[15]++;
				}
			}
		}while (bSearch);

		hTraceFile = fopen(pInstance->SendReceive.fTraceFile, "wb");
		if ((hTraceFile == NULL) || ((int)hTraceFile == -1)) {
			pInstance->SendReceive.bLoggingEnabled = FALSE;
			H245TRACE(h245Inst,
					  1,
					  "SR: Trace File CREATE ERROR");
		}
		else {
		// Close the file.  Will be opened immediately before writing
		//	and closed immediately thereafter
			pInstance->SendReceive.bLoggingEnabled = TRUE;
			fclose(hTraceFile);
		}
		
	}
}
#endif  // (_DEBUG)

HRESULT
sendRcvShutdown
(
	struct InstanceStruct *pInstance
)
{
#if defined(USE_RECEIVE_QUEUE)
	RXMSG			RxMsg;
#endif  // (USE_RECEIVE_QUEUE)
	int				i;

	if (pInstance == NULL) {
		H245TRACE(pInstance->dwInst, 1, "SR: Shutdown Instance Error");
		return H245_ERROR_INVALID_INST;
	}

	if (pInstance->pWorld) {

		// Shutdown the ASN.1 libraries
		terminateASN1(pInstance->pWorld);

		// Free the ASN.1 global structure
		MemFree(        pInstance->pWorld);
        pInstance->pWorld = NULL;
	}



	// Shutdown link layer
#if(0)	
	if (pInstance->SendReceive.hLinkModule) {
		// First get all buffers back that may still be lurking
//		if (pInstance->SendReceive.hLinkLayerFlushAll) {
//			pInstance->SendReceive.hLinkLayerFlushAll(pInstance->SendReceive.hLinkLayerInstance);
//		}
		if (pInstance->SendReceive.hLinkShutdown) {
			pInstance->SendReceive.hLinkShutdown(pInstance->SendReceive.hLinkLayerInstance);
		}

        FreeLibrary(pInstance->SendReceive.hLinkModule);

		pInstance->SendReceive.hLinkModule = NULL;
	}
#else
	pInstance->SendReceive.hLinkShutdown(pInstance->SendReceive.hLinkLayerInstance);
#endif // if(0)
	// return buffers from data link layer
	for (i = 0; i < pInstance->SendReceive.dwNumRXBuffers; ++i) {
		if (pInstance->SendReceive.lpRxBuffer[i]) {
			MemFree(        pInstance->SendReceive.lpRxBuffer[i]);
			pInstance->SendReceive.lpRxBuffer[i] = NULL;
		}
	}
#if defined(USE_RECEIVE_QUEUE)
	// Terminate receive thread
	if (pInstance->SendReceive.pTaskReceive && pInstance->SendReceive.pMailbox) {

TRACE("H245: Task/Mbox Present");
		// First post a message to have it exit
		RxMsg.h245Inst    = (DWORD)pInstance;
		RxMsg.dwMessage   = EXIT_RECEIVE_THREAD;
		RxMsg.pbDataBuf   = NULL;
		RxMsg.dwLength    = 0;
#ifdef   _IA_SPOX_
		if (RIL_WriteMailbox(pInstance->SendReceive.pMailbox, (PMBoxMessage)&RxMsg, 0) == OIL_TIMEOUT) {
#else
		if (MBX_post(pInstance->SendReceive.pMailbox, &RxMsg, 0) == FALSE) {
#endif //_IA_SPOX_
			H245TRACE(h245Inst, 1, "SR: Shutdown MBX POST FAIL");
			H245PANIC();
		}

		// Wait on semaphore for receive task to exit
#ifdef _IA_SPOX_
		RIL_WaitForSemaphore(pInstance->SendReceive.hReceiveSemphore, OIL_WAITFOREVER);
#else
		SEM_pend(pInstance->SendReceive.hReceiveSemphore, SYS_FOREVER);
#endif //_IA_SPOX_
		TRACE("H245: ReceiveTask Semaphore");
		
#ifdef _IA_SPOX_
		RIL_DeleteTask(pInstance->SendReceive.pTaskReceive);
#else
		TSK_delete(pInstance->SendReceive.pTaskReceive);
#endif //_IA_SPOX_
		pInstance->SendReceive.pTaskReceive = NULL;

#ifdef   _IA_SPOX_
		RIL_DeleteSemaphore(pInstance->SendReceive.hReceiveSemphore);
#else
		SEM_delete(pInstance->SendReceive.hReceiveSemphore);
#endif //_IA_SPOX_
		pInstance->SendReceive.hReceiveSemphore = NULL;

TRACE("H245: Semaphore Delete");
    }

    // Deallocate mailbox
    if (pInstance->SendReceive.pMailbox) {
#ifdef   _IA_SPOX_
	RIL_DeleteMailbox(pInstance->SendReceive.pMailbox);
#else
	MBX_delete(pInstance->SendReceive.pMailbox);
#endif //_IA_SPOX_
        pInstance->SendReceive.pMailbox = NULL;
    }
#endif  // (USE_RECEIVE_QUEUE)

    H245TRACE(pInstance->dwInst, 3, "SR: Shutdown Complete");
    return H245_ERROR_OK;
} // sendRcvShutdown()


HRESULT
sendRcvShutdown_ProcessDetach(	struct InstanceStruct *pInstance, BOOL fProcessDetach)
{
#if defined(USE_RECEIVE_QUEUE)
	RXMSG			RxMsg;
#endif  // (USE_RECEIVE_QUEUE)
	int				i;

	if (pInstance == NULL) {
		H245TRACE(pInstance->dwInst, 1, "SR: Shutdown Instance Error");
		return H245_ERROR_INVALID_INST;
	}

	if (pInstance->pWorld) {

		// Shutdown the ASN.1 libraries
		terminateASN1(pInstance->pWorld);

		// Free the ASN.1 global structure
		MemFree(        pInstance->pWorld);
        pInstance->pWorld = NULL;
	}



	// Shutdown link layer
	if (pInstance->SendReceive.hLinkModule) {
		// First get all buffers back that may still be lurking
//		if (pInstance->SendReceive.hLinkLayerFlushAll) {
//			pInstance->SendReceive.hLinkLayerFlushAll(pInstance->SendReceive.hLinkLayerInstance);
//		}
		//tomitowoju@intel.com
		if(!fProcessDetach)
		{
            H245TRACE(0, 0, "***** fProcessDetach = FALSE");

			if (pInstance->SendReceive.hLinkShutdown) {
				pInstance->SendReceive.hLinkShutdown(pInstance->SendReceive.hLinkLayerInstance);
			}
		}
		//tomitowoju@intel.com

        FreeLibrary(pInstance->SendReceive.hLinkModule);

		pInstance->SendReceive.hLinkModule = NULL;
	}

	// return buffers from data link layer
	for (i = 0; i < pInstance->SendReceive.dwNumRXBuffers; ++i) {
		if (pInstance->SendReceive.lpRxBuffer[i]) {
			MemFree(        pInstance->SendReceive.lpRxBuffer[i]);
			pInstance->SendReceive.lpRxBuffer[i] = NULL;
		}
	}
#if defined(USE_RECEIVE_QUEUE)
	// Terminate receive thread
	if (pInstance->SendReceive.pTaskReceive && pInstance->SendReceive.pMailbox) {

TRACE("H245: Task/Mbox Present");
		// First post a message to have it exit
		RxMsg.h245Inst    = (DWORD)pInstance;
		RxMsg.dwMessage   = EXIT_RECEIVE_THREAD;
		RxMsg.pbDataBuf   = NULL;
		RxMsg.dwLength    = 0;
#ifdef   _IA_SPOX_
		if (RIL_WriteMailbox(pInstance->SendReceive.pMailbox, (PMBoxMessage)&RxMsg, 0) == OIL_TIMEOUT) {
#else
		if (MBX_post(pInstance->SendReceive.pMailbox, &RxMsg, 0) == FALSE) {
#endif //_IA_SPOX_
			H245TRACE(h245Inst, 1, "SR: Shutdown MBX POST FAIL");
			H245PANIC();
		}

		// Wait on semaphore for receive task to exit
#ifdef _IA_SPOX_
		RIL_WaitForSemaphore(pInstance->SendReceive.hReceiveSemphore, OIL_WAITFOREVER);
#else
		SEM_pend(pInstance->SendReceive.hReceiveSemphore, SYS_FOREVER);
#endif //_IA_SPOX_
		TRACE("H245: ReceiveTask Semaphore");
		
#ifdef _IA_SPOX_
		RIL_DeleteTask(pInstance->SendReceive.pTaskReceive);
#else
		TSK_delete(pInstance->SendReceive.pTaskReceive);
#endif //_IA_SPOX_
		pInstance->SendReceive.pTaskReceive = NULL;

#ifdef   _IA_SPOX_
		RIL_DeleteSemaphore(pInstance->SendReceive.hReceiveSemphore);
#else
		SEM_delete(pInstance->SendReceive.hReceiveSemphore);
#endif //_IA_SPOX_
		pInstance->SendReceive.hReceiveSemphore = NULL;

TRACE("H245: Semaphore Delete");
    }

    // Deallocate mailbox
    if (pInstance->SendReceive.pMailbox) {
#ifdef   _IA_SPOX_
	RIL_DeleteMailbox(pInstance->SendReceive.pMailbox);
#else
	MBX_delete(pInstance->SendReceive.pMailbox);
#endif //_IA_SPOX_
        pInstance->SendReceive.pMailbox = NULL;
    }
#endif  // (USE_RECEIVE_QUEUE)

    H245TRACE(pInstance->dwInst, 3, "SR: Shutdown Complete");
    return H245_ERROR_OK;
} // sendRcvShutdown_ProcessDetach()




HRESULT
sendRcvInit
(
	struct InstanceStruct *pInstance
)
{

	int 				rc;
	LPTSTR				szDLLFile;
	int					i;
   
    //MULTITHREAD
    DWORD dwTmpPhysID = INVALID_PHYS_ID; 

	// Overall oss ASN.1 initialization routine.  First allocate
	//	resources for its global structure, then initialize the
	//	subsystem.
	pInstance->pWorld = (ASN1_CODER_INFO *)MemAlloc(sizeof(ASN1_CODER_INFO));
	if (pInstance->pWorld == NULL) {
		H245TRACE(pInstance->dwInst, 1, "SR: SndRecvInit - No Memory");
		return H245_ERROR_NOMEM;
	}

	if (initializeASN1(pInstance->pWorld) != 0) {
		H245TRACE(pInstance->dwInst, 1, "SR: SndRecvInit - ASN.1 Encoder/Decoder initialization failed");

		// Free the ASN.1 global structure
		MemFree(pInstance->pWorld);
        pInstance->pWorld = NULL;
		return H245_ERROR_ASN1;
	}


	// Initialization proceeding well.  Wake up the
	//	data link layers, if necessary, based on the
	//	underlying protocol.
	switch (pInstance->Configuration) {
#if(0)	
	case H245_CONF_H324:
		// Get the DLL
		szDLLFile = (LPTSTR)SRPDLLFILE;

		// Initialize default size of PDU for SRP
		pInstance->SendReceive.dwPDUSize = LL_PDU_SIZE + 4;
		pInstance->SendReceive.dwNumRXBuffers = NUM_SRP_LL_RCV_BUFFERS;
		break;
#endif
	case H245_CONF_H323:
		// Get the DLL
		szDLLFile = (LPTSTR)H245WSDLLFILE;

		// Initialize default size of PDU
		pInstance->SendReceive.dwPDUSize = LL_PDU_SIZE;
		pInstance->SendReceive.dwNumRXBuffers = MAX_LL_BUFFERS;
		break;

	default:
		H245TRACE(pInstance->dwInst, 1, "SR: SndRecvInit - Invalid configuration %d", pInstance->Configuration);
		return H245_ERROR_SUBSYS;
	}


	//	Load and Initialize Datalink layer
	if ((rc = initializeLinkDllEntry(pInstance, szDLLFile)) != 0) {
		H245TRACE(pInstance->dwInst, 1, "SR: Link Open Lib Fail %d", rc);
		return rc;
	}

        //MULTITHREAD
        //use dwTmpPhysID so PhysID doesn't change.
        //PhysID is different var for H245 than H245ws.
        //Use hLinkLayerInstance for H245ws PhysID.
	rc = pInstance->SendReceive.hLinkLayerInit(&dwTmpPhysID,
					   pInstance->dwInst,
#if defined(USE_RECEIVE_QUEUE)
					   h245ReceivePost,
					   h245SendPost);
#else   // (USE_RECEIVE_QUEUE)
					   h245ReceiveComplete,
					   h245SendComplete);
#endif  // (USE_RECEIVE_QUEUE)

	if (FAILED(rc)) {
		H245TRACE(pInstance->dwInst, 1, "SR: Link Init Fail");
		return rc;
	}
	// Get the Link layer's instance handle
	pInstance->SendReceive.hLinkLayerInstance = pInstance->SendReceive.hLinkGetInstance(dwTmpPhysID);

#if defined(USE_RECEIVE_QUEUE)
	// Allocate semaphore for task deletion procedures
#ifdef  _IA_SPOX_
    RIL_CreateSemaphore(0, &(pInstance->SendReceive.hReceiveSemphore));
#else
	pInstance->SendReceive.hReceiveSemphore = SEM_create(0, NULL);
#endif //_IA_SPOX_
	if (pInstance->SendReceive.hReceiveSemphore == NULL) {
		H245TRACE(pInstance->dwInst, 1, "SR: Semaphore creation failed");
		return SR_CREATE_SEM_FAIL;
	}

	// Allocate mailbox
#ifdef   _IA_SPOX_
	RIL_CreateMailbox(pInstance->dwInst,
					  ID_H245,
					  16,
					  OIL_LOCAL,
					  &(pInstance->SendReceive.pMailbox));
#else 
	pInstance->SendReceive.pMailbox = MBX_create(sizeof(RXMSG), 16, NULL);
#endif   _IA_SPOX_
	if (pInstance->SendReceive.pMailbox == NULL) {
		H245TRACE(pInstance->dwInst, 1, "SR: Mailbox creation failed");
		return SR_CREATE_MBX_FAIL;
	}

#if defined(_DEBUG) && defined(H324)
	// Turn logging on/off
	srInitializeLogging(pInstance, H245_TRACE_ENABLED);
#endif  // (_DEBUG)

#ifdef _IA_SPOX_
	// Initialize the task and
	// Start the receive thread
    srTaskAttr.idwPriority = OIL_MINPRI;
    srTaskAttr.pStack    = NULL;
    srTaskAttr.dwStackSize = 8192;
	srTaskAttr.pEnviron = NULL;
    srTaskAttr.szName = "H245ReceiveThread";
    srTaskAttr.bExitFlag = TRUE;

	RIL_CreateTask((PFxn)ReceiveThread,
				   &srTaskAttr,
				   srContext,
				   &pInstance->SendReceive.pTaskReceive);
#else
	// Initialize the task and
	// Start the receive thread
    srTaskAttr.priority = TSK_MINPRI;
    srTaskAttr.stack    = NULL;
    srTaskAttr.stacksize = 8192;
    srTaskAttr.stackseg = 0;
//	srTaskAttr.environ = NULL;
    srTaskAttr.name = " ";
    srTaskAttr.exitflag = FALSE;
//    srTaskAttr.debug = TSK_DBG_NO;

	pInstance->SendReceive.pTaskReceive = TSK_create((Fxn)ReceiveThread,
                                          &srTaskAttr,
                                          srContext);
#endif //_IA_SPOX_
	if (pInstance->SendReceive.pTaskReceive == NULL)
	{
		H245TRACE(pInstance->dwInst, 1, "SR: Thread Create FAIL");		H245PANIC();
		return SR_THREAD_CREATE_ERROR;
	}





#endif  // (USE_RECEIVE_QUEUE)

	// post buffers to link layer for receive
	for (i = 0; i < pInstance->SendReceive.dwNumRXBuffers; ++i) {
		pInstance->SendReceive.lpRxBuffer[i] = MemAlloc(pInstance->SendReceive.dwPDUSize);
		if (pInstance->SendReceive.lpRxBuffer[i] == NULL) {
		    H245TRACE(pInstance->dwInst, 1, "SR: SndRecvInit - No Memory");
			return H245_ERROR_NOMEM;
		}
		rc = pInstance->SendReceive.hLinkReceiveReq(pInstance->SendReceive.hLinkLayerInstance,
									   (PBYTE)pInstance->SendReceive.lpRxBuffer[i],
									   pInstance->SendReceive.dwPDUSize);
        if (rc != 0) {
		    H245TRACE(pInstance->dwInst, 1, "SR: SndRecvInit - Receive Buffer Post returned %d", rc);
		    return rc;
        }
	}

	H245TRACE(pInstance->dwInst,  3, "SR: INIT Complete");

	return H245_ERROR_OK;
} // sendRcvInit()


HRESULT
sendRcvFlushPDUs
(
	struct InstanceStruct *pInstance,
	DWORD	 dwDirection,
	BOOL	 bShutdown
)
{
    pInstance->SendReceive.dwFlushMap = dwDirection;
    if (bShutdown) {
     	pInstance->SendReceive.dwFlushMap |= SHUTDOWN_PENDING;
    }

    // Flush the requested queue(s)
    return(pInstance->SendReceive.hLinkLayerFlushChannel(pInstance->SendReceive.hLinkLayerInstance,
                                                         dwDirection));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\hangman.c ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/CALLCONT/VCS/Hangman.c_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1994 Intel Corporation.
 *
 *	$Revision:   1.16  $
 *	$Date:   22 Jan 1997 14:55:52  $
 *	$Author:   MANDREWS  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *		
 *
 *	Notes:
 *
 ***************************************************************************/

#include "precomp.h"

#include "apierror.h"
#include "incommon.h"
#include "callcont.h"
#include "q931.h"
#include "ccmain.h"
#include "ccutils.h"
#include "hangman.h"


static BOOL		bHangupInited = FALSE;

static struct {
	PHANGUP				pHead;
	LOCK				Lock;
} HangupTable;

static struct {
	HHANGUP				hHangup;
	LOCK				Lock;
} HangupHandle;


HRESULT InitHangupManager()
{
	ASSERT(bHangupInited == FALSE);

	HangupTable.pHead = NULL;
	InitializeLock(&HangupTable.Lock);

	HangupHandle.hHangup = CC_INVALID_HANDLE + 1;
	InitializeLock(&HangupHandle.Lock);

	bHangupInited = TRUE;
	return CC_OK;
}



HRESULT DeInitHangupManager()
{
PHANGUP		pHangup;
PHANGUP		pNextHangup;

	if (bHangupInited == FALSE)
		return CC_OK;

	pHangup = HangupTable.pHead;
	while (pHangup != NULL) {
		AcquireLock(&pHangup->Lock);
		pNextHangup = pHangup->pNextInTable;
		FreeHangup(pHangup);
		pHangup = pNextHangup;
	}

	DeleteLock(&HangupHandle.Lock);
	DeleteLock(&HangupTable.Lock);
	bHangupInited = FALSE;
	return CC_OK;
}



HRESULT _AddHangupToTable(			PHANGUP					pHangup)
{
	ASSERT(pHangup != NULL);
	ASSERT(pHangup->hHangup != CC_INVALID_HANDLE);
	ASSERT(pHangup->bInTable == FALSE);

	AcquireLock(&HangupTable.Lock);

	pHangup->pNextInTable = HangupTable.pHead;
	pHangup->pPrevInTable = NULL;
	if (HangupTable.pHead != NULL)
		HangupTable.pHead->pPrevInTable = pHangup;
	HangupTable.pHead = pHangup;

	pHangup->bInTable = TRUE;

	RelinquishLock(&HangupTable.Lock);
	return CC_OK;
}



HRESULT _RemoveHangupFromTable(		PHANGUP					pHangup)
{
HHANGUP		hHangup;
BOOL		bTimedOut;

	ASSERT(pHangup != NULL);
	ASSERT(pHangup->bInTable == TRUE);

	// Caller must have a lock on the hangup object;
	// in order to avoid deadlock, we must:
	//   1. unlock the hangup object,
	//   2. lock the HangupTable,
	//   3. locate the hangup object in the HangupTable (note that
	//      after step 2, the hangup object may be deleted from the
	//      HangupTable by another thread),
	//   4. lock the hangup object (someone else may have the lock)
	//   5. remove the hangup object from the HangupTable,
	//   6. unlock the HangupTable
	//
	// The caller can now safely unlock and destroy the hangup object,
	// since no other thread will be able to find the object (its been
	// removed from the HangupTable), and therefore no other thread will
	// be able to lock it.

	// Save the hangup handle; its the only way to look up
	// the hangup object in the HangupTable. Note that we
	// can't use pHangup to find the hangup object, since
	// pHangup may be free'd up, and another hangup object
	// allocated at the same address
	hHangup = pHangup->hHangup;

	// step 1
	RelinquishLock(&pHangup->Lock);

step2:
	// step 2
	AcquireLock(&HangupTable.Lock);

	// step 3
	pHangup = HangupTable.pHead;
	while ((pHangup != NULL) && (pHangup->hHangup != hHangup))
		pHangup = pHangup->pNextInTable;

	if (pHangup != NULL) {
		// step 4
		AcquireTimedLock(&pHangup->Lock,10,&bTimedOut);
		if (bTimedOut) {
			RelinquishLock(&HangupTable.Lock);
			Sleep(0);
			goto step2;
		}
		// step 5
		if (pHangup->pPrevInTable == NULL)
			HangupTable.pHead = pHangup->pNextInTable;
		else
			pHangup->pPrevInTable->pNextInTable = pHangup->pNextInTable;

		if (pHangup->pNextInTable != NULL)
			pHangup->pNextInTable->pPrevInTable = pHangup->pPrevInTable;

		pHangup->pNextInTable = NULL;
		pHangup->pPrevInTable = NULL;
		pHangup->bInTable = FALSE;
	}

	// step 6
	RelinquishLock(&HangupTable.Lock);

	if (pHangup == NULL)
		return CC_BAD_PARAM;
	else
		return CC_OK;
}



HRESULT _MakeHangupHandle(			PHHANGUP				phHangup)
{
	AcquireLock(&HangupHandle.Lock);
	*phHangup = HangupHandle.hHangup++;
	RelinquishLock(&HangupHandle.Lock);
	return CC_OK;
}



HRESULT AllocAndLockHangup(			PHHANGUP				phHangup,
									CC_HCONFERENCE			hConference,
									DWORD_PTR				dwUserToken,
									PPHANGUP				ppHangup)
{
HRESULT		status;
	
	ASSERT(bHangupInited == TRUE);

	// all parameters should have been validated by the caller
	ASSERT(phHangup != NULL);
	ASSERT(hConference != CC_INVALID_HANDLE);
	ASSERT(ppHangup != NULL);

	// set phHangup now, in case we encounter an error
	*phHangup = CC_INVALID_HANDLE;

	*ppHangup = (PHANGUP)MemAlloc(sizeof(HANGUP));
	if (*ppHangup == NULL)
		return CC_NO_MEMORY;

	(*ppHangup)->bInTable = FALSE;
	status = _MakeHangupHandle(&(*ppHangup)->hHangup);
	if (status != CC_OK) {
		MemFree(*ppHangup);
		return status;
	}
	
	(*ppHangup)->hConference = hConference;
	(*ppHangup)->wNumCalls = 0;
	(*ppHangup)->dwUserToken = dwUserToken;
	(*ppHangup)->pNextInTable = NULL;
	(*ppHangup)->pPrevInTable = NULL;

	InitializeLock(&(*ppHangup)->Lock);
	AcquireLock(&(*ppHangup)->Lock);

	*phHangup = (*ppHangup)->hHangup;

	// add the Hangup to the Hangup table
	status = _AddHangupToTable(*ppHangup);
	if (status != CC_OK)
		FreeHangup(*ppHangup);
	
	return status;
}



// Caller must have a lock on the Hangup object
HRESULT FreeHangup(					PHANGUP				pHangup)
{
HHANGUP		hHangup;

	ASSERT(pHangup != NULL);

	// caller must have a lock on the Hangup object,
	// so there's no need to re-lock it
	
	hHangup = pHangup->hHangup;

	if (pHangup->bInTable == TRUE)
		if (_RemoveHangupFromTable(pHangup) == CC_BAD_PARAM)
			// the Hangup object was deleted by another thread,
			// so just return CC_OK
			return CC_OK;

	// Since the hangup object has been removed from the HangupTable,
	// no other thread will be able to find the hangup object and obtain
	// a lock, so its safe to unlock the hangup object and delete it here
	RelinquishLock(&pHangup->Lock);
	DeleteLock(&pHangup->Lock);
	MemFree(pHangup);
	return CC_OK;
}



HRESULT LockHangup(					HHANGUP					hHangup,
									PPHANGUP				ppHangup)
{
BOOL	bTimedOut;

	ASSERT(hHangup != CC_INVALID_HANDLE);
	ASSERT(ppHangup != NULL);

step1:
	AcquireLock(&HangupTable.Lock);

	*ppHangup = HangupTable.pHead;
	while ((*ppHangup != NULL) && ((*ppHangup)->hHangup != hHangup))
		*ppHangup = (*ppHangup)->pNextInTable;

	if (*ppHangup != NULL) {
		AcquireTimedLock(&(*ppHangup)->Lock,10,&bTimedOut);
		if (bTimedOut) {
			RelinquishLock(&HangupTable.Lock);
			Sleep(0);
			goto step1;
		}
	}

	RelinquishLock(&HangupTable.Lock);

	if (*ppHangup == NULL)
		return CC_BAD_PARAM;
	else
		return CC_OK;
}



HRESULT ValidateHangup(				HHANGUP					hHangup)
{
PHANGUP	pHangup;

	ASSERT(hHangup != CC_INVALID_HANDLE);

	AcquireLock(&HangupTable.Lock);

	pHangup = HangupTable.pHead;
	while ((pHangup != NULL) && (pHangup->hHangup != hHangup))
		pHangup = pHangup->pNextInTable;

	RelinquishLock(&HangupTable.Lock);

	if (pHangup == NULL)
		return CC_BAD_PARAM;
	else
		return CC_OK;
}



HRESULT UnlockHangup(				PHANGUP					pHangup)
{
	ASSERT(pHangup != NULL);

	RelinquishLock(&pHangup->Lock);
	return CC_OK;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\hcall.cpp ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/Q931/VCS/hcall.cpv  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1996 Intel Corporation.
 *
 *	$Revision:   2.7  $
 *	$Date:   28 Jan 1997 11:17:52  $
 *	$Author:   jdashevx  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *		
 *
 *	Notes:
 *
 ***************************************************************************/

#pragma warning ( disable : 4100 4115 4201 4214 4514 4702 4710 )

#include "precomp.h"

#include <string.h>
#include <time.h>

#include "h225asn.h"

#include "isrg.h"

#include "common.h"
#include "q931.h"

#include "hcall.h"
#include "utils.h"

#include "tstable.h"

#ifdef UNICODE_TRACE
// We include this header to fix problems with macro expansion when Unicode is turned on.
#include "unifix.h"
#endif

// variable needed to support ISR debug facility.
#if defined(_DEBUG)
extern WORD ghISRInst;
#endif

static BOOL bCallListCreated = FALSE;

// Pointer to our global table.  Note that this table replaces the previous
// linked-list implementation.

TSTable<CALL_OBJECT>* gpCallObjectTable = NULL;

// Our call back function for enumerating the table when we want to tear down
// all existing calls

DWORD Q931HangUpAllCalls(P_CALL_OBJECT pCallObject, LPVOID context);

// Our call back function for determining if a timer has expired

DWORD Q931CheckForTimeout(P_CALL_OBJECT pCallObject, LPVOID context);

// Our call back function for determining if a timer has expired

DWORD Q931CallObjectFind(P_CALL_OBJECT pCallObject, LPVOID context);


static struct
{
    WORD                wCRV;              // Call Reference Value (0..7FFF).
    CRITICAL_SECTION    Lock;
} CRVSource;

static struct
{
    BOOL bBusy;
    DWORD dwTimerCount;
    DWORD dwTicks301;
    DWORD dwTicks303;
    UINT_PTR uTimerId;
    CRITICAL_SECTION Lock;
} Q931GlobalTimer = {0};



typedef struct
{
		BOOL bFound;
		WORD wCRV;
		PCC_ADDR pPeerAddr;
		HQ931CALL hQ931Call;
} Q931CALLOBJKEY, *PQ931CALLOBJKEY;


//====================================================================================
//
// PRIVATE FUNCTIONS
//
//====================================================================================

//====================================================================================
//====================================================================================
CS_STATUS
Q931CRVNew(
    WORD *pwCRV)
{
    EnterCriticalSection(&(CRVSource.Lock));
    CRVSource.wCRV = (WORD)((CRVSource.wCRV + 1) & 0x7fff);
    if (CRVSource.wCRV == 0)
    {
        CRVSource.wCRV = 1;
    }
    *pwCRV = CRVSource.wCRV;
    LeaveCriticalSection(&(CRVSource.Lock));
    return CS_OK;
}

//====================================================================================
//
// PUBLIC FUNCTIONS
//
//====================================================================================

//====================================================================================
//====================================================================================
CS_STATUS
CallListCreate()
{
    if (bCallListCreated == TRUE)
    {
        ASSERT(FALSE);
        return CS_DUPLICATE_INITIALIZE;
    }

    // list creation is not protected against multiple threads because it is only
    // called when a process is started, not when a thread is started.

    //
    // LAURABU
    // BOGUS BUGBUG
    // 
    // This table code was never stressed by the people who wrote it.  It
    // totally falls apart when it completely fills up
    //      * Allocating the last item doesn't work
    //      * Freeing the last item doesn't work
    //      * Resizing larger doesn't work
    //
    // Since it doesn't take a lot of memory, a decent solution is to just
    // allocate it maximum+1 sized, and leave the last item free.
    //
		gpCallObjectTable = new TSTable <CALL_OBJECT> (258);

		if (gpCallObjectTable == NULL || gpCallObjectTable->IsInitialized() == FALSE)
		{
			return CS_NO_MEMORY;
		}

    CRVSource.wCRV = (WORD) (time(NULL) & 0x7fff);
    InitializeCriticalSection(&(CRVSource.Lock));

    Q931GlobalTimer.dwTicks301 = Q931_TICKS_301;
    Q931GlobalTimer.dwTicks303 = Q931_TICKS_303;
    InitializeCriticalSection(&(Q931GlobalTimer.Lock));

    bCallListCreated = TRUE;

    return CS_OK;
}


//====================================================================================
// this routine assumes all of the events and sockets belonging to each object
// are already destroyed.  It just makes sure memory is cleaned up.
//====================================================================================
CS_STATUS
CallListDestroy()
{
    if (bCallListCreated == FALSE)
    {
        ASSERT(FALSE);
        return CS_INTERNAL_ERROR;
    }

		// For all entries, hang up the calls

		gpCallObjectTable->EnumerateEntries(Q931HangUpAllCalls,
																				NULL);

		// Get rid of the call object table

		delete gpCallObjectTable;
		gpCallObjectTable = NULL;

    DeleteCriticalSection(&(Q931GlobalTimer.Lock));
    DeleteCriticalSection(&(CRVSource.Lock));

    bCallListCreated = FALSE;

    return CS_OK;
}

//====================================================================================
//====================================================================================
void
CallObjectFree(P_CALL_OBJECT pCallObject)
{
    if (pCallObject->NonStandardData.sData.pOctetString != NULL)
    {
        MemFree(pCallObject->NonStandardData.sData.pOctetString);
        pCallObject->NonStandardData.sData.pOctetString = NULL;
    }
    if (pCallObject->VendorInfoPresent)
    {
        if (pCallObject->VendorInfo.pProductNumber != NULL)
        {
            MemFree(pCallObject->VendorInfo.pProductNumber);
        }
        if (pCallObject->VendorInfo.pVersionNumber != NULL)
        {
            MemFree(pCallObject->VendorInfo.pVersionNumber);
        }
    }

    Q931FreeAliasNames(pCallObject->pCallerAliasList);
    pCallObject->pCallerAliasList = NULL;
    Q931FreeAliasNames(pCallObject->pCalleeAliasList);
    pCallObject->pCalleeAliasList = NULL;
    Q931FreeAliasNames(pCallObject->pExtraAliasList);
    pCallObject->pExtraAliasList = NULL;
    Q931FreeAliasItem(pCallObject->pExtensionAliasItem);
    pCallObject->pExtensionAliasItem = NULL;
    MemFree(pCallObject);
}

//====================================================================================
//====================================================================================
CS_STATUS
CallObjectCreate(
    PHQ931CALL          phQ931Call,
    DWORD_PTR           dwListenToken,
    DWORD_PTR           dwUserToken,
    Q931_CALLBACK       ConnectCallback,
    BOOL                fIsCaller,
    CC_ADDR             *pLocalAddr,         // Local address on which channel is connected
    CC_ADDR             *pPeerConnectAddr,   // Address to which channel is connected
    CC_ADDR             *pPeerCallAddr,      // Address of opposite call end-point.
    CC_ADDR             *pSourceAddr,        // Address of this call end-point.
    CC_CONFERENCEID     *pConferenceID,
    WORD                wGoal,
    WORD                wCallType,
    BOOL                bCallerIsMC,
    char                *pszDisplay,
    char                *pszCalledPartyNumber,
    PCC_ALIASNAMES      pCallerAliasList,
    PCC_ALIASNAMES      pCalleeAliasList,
    PCC_ALIASNAMES      pExtraAliasList,
    PCC_ALIASITEM       pExtensionAliasItem,
    PCC_ENDPOINTTYPE    pEndpointType,
    PCC_NONSTANDARDDATA pNonStandardData,    // questionable!
    WORD                wCRV,
    LPGUID				pCallIdentifier)
{
    P_CALL_OBJECT pCallObject = NULL;
    CS_STATUS status = CS_OK;
    CS_STATUS CopyStatus = CS_OK;
    DWORD dwIndex = 0;
    int rc = 0;

    // make sure the call list has been created.
    if (bCallListCreated == FALSE)
    {
        ASSERT(FALSE);
        return CS_INTERNAL_ERROR;
    }

    // validate all parameters for bogus values.
    if ((phQ931Call == NULL) || (ConnectCallback == NULL))
    {
        ASSERT(FALSE);
        return CS_BAD_PARAM;
    }

    // set phQ931Call now, in case we encounter an error later.
    *phQ931Call = 0;

    pCallObject = (P_CALL_OBJECT)MemAlloc(sizeof(CALL_OBJECT));
    if (pCallObject == NULL)
    {
        return CS_NO_MEMORY;
    }
    memset(pCallObject, 0, sizeof(CALL_OBJECT));


    // create and init an oss world struct for each call object.  This is
		// necessary to work in MT environments.
    rc = Q931_InitWorld(&pCallObject->World);
    if (rc != ASN1_SUCCESS)
    {
#if defined(_DEBUG)
        ISRERROR(ghISRInst, "Q931_InitCoder() returned: %d ", rc);
#endif
        return CS_SUBSYSTEM_FAILURE;
    }

    pCallObject->LocalAddr.bMulticast = FALSE;
    pCallObject->PeerConnectAddr.bMulticast = FALSE;
    pCallObject->PeerCallAddr.bMulticast = FALSE;
    pCallObject->SourceAddr.bMulticast = FALSE;

	if(pCallIdentifier)
	{
		memcpy(&pCallObject->CallIdentifier, pCallIdentifier, sizeof(GUID));
	}
    if (wCRV == 0)
    {
        if (Q931CRVNew(&pCallObject->wCRV) != CS_OK)
        {
            CallObjectFree(pCallObject);
            return CS_INTERNAL_ERROR;
        }
    }
    else
    {
        pCallObject->wCRV = wCRV;
    }

    pCallObject->szDisplay[0] = '\0';
    if (pszDisplay)
    {
        strcpy(pCallObject->szDisplay, pszDisplay);
    }

    pCallObject->szCalledPartyNumber[0] = '\0';
    if (pszCalledPartyNumber)
    {
        strcpy(pCallObject->szCalledPartyNumber, pszCalledPartyNumber);
    }

    pCallObject->dwListenToken = dwListenToken;
    pCallObject->dwUserToken = dwUserToken;
    pCallObject->Callback = ConnectCallback;
    pCallObject->bCallState = CALLSTATE_NULL;
    pCallObject->fIsCaller = fIsCaller;

    if (pLocalAddr)
    {
        pCallObject->LocalAddr = *pLocalAddr;
    }
    if (pPeerConnectAddr)
    {
        pCallObject->PeerConnectAddr = *pPeerConnectAddr;
    }
    if (pPeerCallAddr)
    {
        pCallObject->PeerCallAddr = *pPeerCallAddr;
        pCallObject->PeerCallAddrPresent = TRUE;
    }
    else
    {
        pCallObject->PeerCallAddrPresent = FALSE;
    }

    if (pSourceAddr)
    {
        pCallObject->SourceAddr = *pSourceAddr;
        pCallObject->SourceAddrPresent = TRUE;
    }
    else
    {
        pCallObject->SourceAddrPresent = FALSE;
    }

    if (pConferenceID == NULL)
    {
        memset(&(pCallObject->ConferenceID), 0, sizeof(CC_CONFERENCEID));
    }
    else
    {
        int length = min(sizeof(pConferenceID->buffer),
            sizeof(pCallObject->ConferenceID.buffer));
        memcpy(pCallObject->ConferenceID.buffer,
            pConferenceID->buffer, length);
    }

    pCallObject->wGoal = wGoal;
    pCallObject->bCallerIsMC = bCallerIsMC;
    pCallObject->wCallType = wCallType;

    if (pNonStandardData != NULL)
    {
        pCallObject->NonStandardData = *pNonStandardData;
        if (pNonStandardData->sData.wOctetStringLength > 0)
        {
            pCallObject->NonStandardData.sData.pOctetString =
                (BYTE *) MemAlloc(pNonStandardData->sData.wOctetStringLength);
            if (pCallObject->NonStandardData.sData.pOctetString == NULL)
            {
                CallObjectFree(pCallObject);
                return CS_NO_MEMORY;
            }
            memcpy(pCallObject->NonStandardData.sData.pOctetString,
                pNonStandardData->sData.pOctetString,
                pNonStandardData->sData.wOctetStringLength);
        }
        pCallObject->NonStandardDataPresent = TRUE;
    }
    else
    {
        pCallObject->NonStandardDataPresent = FALSE;
    }

    CopyStatus = Q931CopyAliasNames(&(pCallObject->pCallerAliasList),
        pCallerAliasList);
    if (CopyStatus != CS_OK)
    {
        CallObjectFree(pCallObject);
        return CopyStatus;
    }
    CopyStatus = Q931CopyAliasNames(&(pCallObject->pCalleeAliasList),
        pCalleeAliasList);
    if (CopyStatus != CS_OK)
    {
        CallObjectFree(pCallObject);
        return CopyStatus;
    }
    CopyStatus = Q931CopyAliasNames(&(pCallObject->pExtraAliasList),
        pExtraAliasList);
    if (CopyStatus != CS_OK)
    {
        CallObjectFree(pCallObject);
        return CopyStatus;
    }
    CopyStatus = Q931CopyAliasItem(&(pCallObject->pExtensionAliasItem),
        pExtensionAliasItem);
    if (CopyStatus != CS_OK)
    {
        CallObjectFree(pCallObject);
        return CopyStatus;
    }

    pCallObject->bResolved = FALSE;
    pCallObject->VendorInfoPresent = FALSE;
    pCallObject->bIsTerminal = TRUE;
    pCallObject->bIsGateway = FALSE;
    if (pEndpointType != NULL)
    {
        PCC_VENDORINFO pVendorInfo = pEndpointType->pVendorInfo;
        if (pVendorInfo != NULL)
        {
            pCallObject->VendorInfoPresent = TRUE;
            pCallObject->VendorInfo = *(pVendorInfo);

            if (pVendorInfo->pProductNumber && pVendorInfo->pProductNumber->pOctetString &&
                    pVendorInfo->pProductNumber->wOctetStringLength)
            {
                memcpy(pCallObject->bufVendorProduct,
                    pVendorInfo->pProductNumber->pOctetString,
                    pVendorInfo->pProductNumber->wOctetStringLength);
                pCallObject->VendorInfo.pProductNumber = (CC_OCTETSTRING*) MemAlloc(sizeof(CC_OCTETSTRING));
                if (pCallObject->VendorInfo.pProductNumber == NULL)
                {
                    CallObjectFree(pCallObject);
                    return CS_NO_MEMORY;
                }
                pCallObject->VendorInfo.pProductNumber->pOctetString =
                    pCallObject->bufVendorProduct;
                pCallObject->VendorInfo.pProductNumber->wOctetStringLength =
                    pVendorInfo->pProductNumber->wOctetStringLength;
            }
            else
            {
                pCallObject->VendorInfo.pProductNumber = NULL;
            }

            if (pVendorInfo->pVersionNumber && pVendorInfo->pVersionNumber->pOctetString &&
                    pVendorInfo->pVersionNumber->wOctetStringLength)
            {
                memcpy(pCallObject->bufVendorVersion,
                    pVendorInfo->pVersionNumber->pOctetString,
                    pVendorInfo->pVersionNumber->wOctetStringLength);
                pCallObject->VendorInfo.pVersionNumber = (CC_OCTETSTRING*) MemAlloc(sizeof(CC_OCTETSTRING));
                if (pCallObject->VendorInfo.pVersionNumber == NULL)
                {
                    CallObjectFree(pCallObject);
                    return CS_NO_MEMORY;
                }
                pCallObject->VendorInfo.pVersionNumber->pOctetString =
                    pCallObject->bufVendorVersion;
                pCallObject->VendorInfo.pVersionNumber->wOctetStringLength =
                    pVendorInfo->pVersionNumber->wOctetStringLength;
            }
            else
            {
                pCallObject->VendorInfo.pVersionNumber = NULL;
            }

        }
        pCallObject->bIsTerminal = pEndpointType->bIsTerminal;
        pCallObject->bIsGateway = pEndpointType->bIsGateway;
    }

	Q931MakePhysicalID(&pCallObject->dwPhysicalId);
				
		// Insert the object into the table...if that doesn't work, blow away the object.

		if (gpCallObjectTable->CreateAndLock(pCallObject,
																				 &dwIndex) == FALSE)
		{
			CallObjectFree(pCallObject);
			return CS_INTERNAL_ERROR;
		}

		// Save the index as the handle (this makes it easier to find the object later).

    *phQ931Call = pCallObject->hQ931Call = (HQ931CALL) dwIndex;
             #if defined(_DEBUG)
		ISRTRACE(ghISRInst, "CallObjectCreate() -returned-> 0x%.8x", dwIndex);
             #endif
		// Unlock the entry

		gpCallObjectTable->Unlock(dwIndex);

    return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
CallObjectDestroy(
    P_CALL_OBJECT  pCallObject)
{
    if (pCallObject == NULL)
    {
        ASSERT(FALSE);
        return CS_BAD_PARAM;
    }

             #if defined (_DEBUG)
		ISRTRACE(ghISRInst, "CallObjectDestroy(0x%.8x)", (DWORD)pCallObject->hQ931Call);
             #endif

		
		Q931_TermWorld(&pCallObject->World);

		// Since the caller must already have a lock on the object, remove the entry from
		// the table.  We won't let the table delete the object as we want to clean up.

		if (gpCallObjectTable->Delete((DWORD) pCallObject->hQ931Call) == FALSE)
		{
			return CS_OK;
		}

    Q931StopTimer(pCallObject, Q931_TIMER_301);
    Q931StopTimer(pCallObject, Q931_TIMER_303);

		// Unlock the object

		gpCallObjectTable->Unlock((DWORD) pCallObject->hQ931Call);

		// Free up the call object

    CallObjectFree(pCallObject);

    return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
CallObjectLock(
    HQ931CALL         hQ931Call,
    PP_CALL_OBJECT    ppCallObject)
{
    if (ppCallObject == NULL)
    {
        ASSERT(FALSE);
        return CS_BAD_PARAM;
    }

	// Attempt to lock the entry.  If that fails, we'll return CS_BAD_PARAM under
	// the assumption that the entry is invalid.

	*ppCallObject = gpCallObjectTable->Lock((DWORD) hQ931Call);

	return (*ppCallObject == NULL ? CS_BAD_PARAM : CS_OK);
}

//====================================================================================
//====================================================================================
CS_STATUS
CallObjectUnlock(
    P_CALL_OBJECT  pCallObject)
{
    if (pCallObject == NULL)
    {
        ASSERT(FALSE);
        return CS_BAD_PARAM;
    }
    return CallEntryUnlock(pCallObject->hQ931Call);
}

//====================================================================================
//====================================================================================
CS_STATUS
CallEntryUnlock(
    HQ931CALL     	  hQ931Call)
{

		// Unlock the entry

		if (gpCallObjectTable->Unlock(hQ931Call) == FALSE)
		{
                   #if defined(_DEBUG)
			ISRERROR(ghISRInst, "gpCallObjectTable->Unlock(0x%.8x) FAILED!!!!", (DWORD)hQ931Call);
                   #endif
			return CS_BAD_PARAM;
		}

    return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
CallObjectValidate(
    HQ931CALL hQ931Call)
{
	if (gpCallObjectTable->Validate((DWORD) hQ931Call) == TRUE)
	{
		return CS_OK;
	}

	return CS_BAD_PARAM;
}

//====================================================================================
//====================================================================================
BOOL
CallObjectFind(
    HQ931CALL *phQ931Call,
    WORD wCRV,
    PCC_ADDR pPeerAddr)
{
		Q931CALLOBJKEY Q931CallObjKey;
		Q931CallObjKey.wCRV = wCRV;
		Q931CallObjKey.pPeerAddr = pPeerAddr;
		Q931CallObjKey.bFound = FALSE;
		
		gpCallObjectTable->EnumerateEntries(Q931CallObjectFind,
																				(LPVOID) &Q931CallObjKey);
	
		if(Q931CallObjKey.bFound == TRUE)
		{
        *phQ931Call = Q931CallObjKey.hQ931Call;
        return TRUE;
    }
    return FALSE;
}

//====================================================================================
//====================================================================================
CS_STATUS CallObjectMarkForDelete(HQ931CALL hQ931Call)
{
	// User must have the object already locked to call this.

	// Mark the object as deleted but don't let the table delete the object's
	// memory.

	return (gpCallObjectTable->Delete((DWORD) hQ931Call) == FALSE ? CS_BAD_PARAM : CS_OK);
}


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// Timer Routines...
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

//====================================================================================
// This routine will be called every 1000 ms if any call object
// has caused the Q931GlobalTimer to be created.
//====================================================================================
VOID CALLBACK
Q931TimerProc(HWND hwnd, UINT uMsg, UINT idEvent, DWORD dwTime)
{
    DWORD dwTickCount = GetTickCount();

    EnterCriticalSection(&(Q931GlobalTimer.Lock));
    if (Q931GlobalTimer.bBusy)
    {
        LeaveCriticalSection(&(Q931GlobalTimer.Lock));
        return;
    }
    Q931GlobalTimer.bBusy = TRUE;

		// Check all of the entries for timeout

		gpCallObjectTable->EnumerateEntries(Q931CheckForTimeout,
																				(LPVOID) &dwTickCount);

    Q931GlobalTimer.bBusy = FALSE;
    LeaveCriticalSection(&(Q931GlobalTimer.Lock));
}

//====================================================================================
//====================================================================================
HRESULT
Q931StartTimer(P_CALL_OBJECT pCallObject, DWORD wTimerId)
{
    if (pCallObject == NULL)
    {
        return CS_BAD_PARAM;
    }

    switch (wTimerId)
    {
        case Q931_TIMER_301:
            if (pCallObject->dwTimerAlarm301)
            {
                // timer is already set for this call object...
                return CS_INTERNAL_ERROR;
            }
            EnterCriticalSection(&(Q931GlobalTimer.Lock));
            pCallObject->dwTimerAlarm301 = GetTickCount() + Q931GlobalTimer.dwTicks301;
            LeaveCriticalSection(&(Q931GlobalTimer.Lock));
            break;
        case Q931_TIMER_303:
            if (pCallObject->dwTimerAlarm303)
            {
                // timer is already set for this call object...
                return CS_INTERNAL_ERROR;
            }
            EnterCriticalSection(&(Q931GlobalTimer.Lock));
            pCallObject->dwTimerAlarm303 = GetTickCount() + Q931GlobalTimer.dwTicks303;
            LeaveCriticalSection(&(Q931GlobalTimer.Lock));
            break;
        default:
            return CS_BAD_PARAM;
            break;
    }

    EnterCriticalSection(&(Q931GlobalTimer.Lock));
    if (!Q931GlobalTimer.dwTimerCount)
    {
        Q931GlobalTimer.uTimerId = SetTimer(NULL, 0, 1000, (TIMERPROC)Q931TimerProc);
    }
    Q931GlobalTimer.dwTimerCount++;
    LeaveCriticalSection(&(Q931GlobalTimer.Lock));

    return CS_OK;
}

//====================================================================================
//====================================================================================
HRESULT
Q931StopTimer(P_CALL_OBJECT pCallObject, DWORD wTimerId)
{
    if (pCallObject == NULL)
    {
        return CS_BAD_PARAM;
    }
    switch (wTimerId)
    {
        case Q931_TIMER_301:
            if (!pCallObject->dwTimerAlarm301)
            {
                return CS_OK;
            }
            pCallObject->dwTimerAlarm301 = 0;
            break;
        case Q931_TIMER_303:
            if (!pCallObject->dwTimerAlarm303)
            {
                return CS_OK;
            }
            pCallObject->dwTimerAlarm303 = 0;
            break;
        default:
            return CS_BAD_PARAM;
            break;
    }

    EnterCriticalSection(&(Q931GlobalTimer.Lock));
    if (Q931GlobalTimer.dwTimerCount > 0)
    {
        Q931GlobalTimer.dwTimerCount--;
        if (!Q931GlobalTimer.dwTimerCount)
        {
            KillTimer(NULL, Q931GlobalTimer.uTimerId);
            Q931GlobalTimer.uTimerId = 0;
        }
    }
    LeaveCriticalSection(&(Q931GlobalTimer.Lock));

    return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931SetAlertingTimeout(DWORD dwDuration)
{
    EnterCriticalSection(&(Q931GlobalTimer.Lock));
    if (dwDuration)
    {
        Q931GlobalTimer.dwTicks303 = dwDuration;
    }
    else
    {
        Q931GlobalTimer.dwTicks303 = Q931_TICKS_303;
    }
    LeaveCriticalSection(&(Q931GlobalTimer.Lock));
    return CS_OK;
}

//====================================================================================
//====================================================================================
DWORD Q931HangUpAllCalls(P_CALL_OBJECT pCallObject, LPVOID context)
{
	HQ931CALL hQ931Call = pCallObject->hQ931Call;

	// Try to hangup the call object.

	Q931Hangup(hQ931Call, CC_REJECT_NORMAL_CALL_CLEARING);

	// Try to lock the object.  If that succeeds, then we want to force the object to
	// be deleted.  We should never have to do this as the hang up is supposed to
	// take care of that for us.

	if (gpCallObjectTable->Lock(hQ931Call) != NULL)
	{
		CallObjectDestroy(pCallObject);
	}

	return CALLBACK_DELETE_ENTRY;
}

//====================================================================================
//====================================================================================
DWORD
Q931CallObjectFind(P_CALL_OBJECT pCallObject, LPVOID context)
{
	PQ931CALLOBJKEY pQ931CallObjKey = (PQ931CALLOBJKEY) context;
	PCC_ADDR pPeerAddr = pQ931CallObjKey->pPeerAddr;
	WORD wCRV = pQ931CallObjKey->wCRV;

	if (!pCallObject->bResolved)
	{
		return(CALLBACK_CONTINUE);
	}
	
	if ((pCallObject->wCRV & (~0x8000)) == (wCRV & (~0x8000)))
	{
		if (!pPeerAddr)
		{
			pQ931CallObjKey->bFound = TRUE;
			pQ931CallObjKey->hQ931Call = pCallObject->hQ931Call;
			return(CALLBACK_ABORT);
		}
		else if ((pCallObject->PeerConnectAddr.nAddrType == CC_IP_BINARY) &&
				(pPeerAddr->nAddrType == CC_IP_BINARY) &&
				(pCallObject->PeerConnectAddr.Addr.IP_Binary.dwAddr == pPeerAddr->Addr.IP_Binary.dwAddr))
		{
			pQ931CallObjKey->bFound = TRUE;
			pQ931CallObjKey->hQ931Call = pCallObject->hQ931Call;
			return(CALLBACK_ABORT);
		}
	}
	return(CALLBACK_CONTINUE);
}


//====================================================================================
//====================================================================================

DWORD Q931CheckForTimeout(P_CALL_OBJECT pCallObject, LPVOID context)
{
	DWORD dwTickCount = *((LPDWORD) context);

	// Determine if a timer has expired for the entry

	if (pCallObject->dwTimerAlarm301 &&
			(pCallObject->dwTimerAlarm301 <= dwTickCount))
	{
		Q931StopTimer(pCallObject, Q931_TIMER_301);
		Q931StopTimer(pCallObject, Q931_TIMER_303);

		if (pCallObject->dwTimerAlarm303 &&
				(pCallObject->dwTimerAlarm303 < pCallObject->dwTimerAlarm301) &&
				(pCallObject->dwTimerAlarm303 <= dwTickCount))
		{
			CallBackT303(pCallObject);
		}
		else
		{
			CallBackT301(pCallObject);
		}
	}
	else if (pCallObject->dwTimerAlarm303 &&
					 (pCallObject->dwTimerAlarm303 <= dwTickCount))
	{
		Q931StopTimer(pCallObject, Q931_TIMER_301);
		Q931StopTimer(pCallObject, Q931_TIMER_303);
		CallBackT303(pCallObject);
	}

	return CALLBACK_CONTINUE;
}


/***************************************************************************
 *
 * NAME
 *    HangupPendingCalls - Hangs up incoming calls from specified destination
 *                        
 * DESCRIPTION
 *    This function will hang up all calls in waiting 
 *    from the specified destination to prevent DOS attacks
 *    that would fill up the call object table.
 *
 * PARAMETERS
 *    pCallObject       Current enumerated call object
 *    context           Callback parameter representing source IP address
 *
 * RETURN VALUE
 *    CALLBACK_ABORT    Stop enumerating calls
 *    CALLBACK_CONTINUE Continue enumerating calls
 *
 ***************************************************************************/
DWORD Q931HangupPendingCallsCallback(P_CALL_OBJECT pCallObject, LPVOID context)
{
    ASSERT(NULL != pCallObject);

    // Only hang up incoming calls
    if(FALSE == pCallObject->fIsCaller)
    {
        if(CALLSTATE_INITIATED == pCallObject->bCallState)
        {
            Q931Hangup(pCallObject->hQ931Call, CC_REJECT_SECURITY_DENIED);
        }
    }

    return CALLBACK_CONTINUE;
}

HRESULT Q931HangupPendingCalls(LPVOID context)
{
    gpCallObjectTable->EnumerateEntries(Q931HangupPendingCallsCallback, context);
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\hlisten.h ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/Q931/VCS/hlisten.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1996 Intel Corporation.
 *
 *	$Revision:   1.8  $
 *	$Date:   22 Jul 1996 19:00:20  $
 *	$Author:   rodellx  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *		
 *      Listen Object Methods
 *
 *	Notes:
 *
 ***************************************************************************/


#ifndef HLISTEN_H
#define HLISTEN_H

#ifdef __cplusplus
extern "C" {
#endif

#define LISTEN_SHUTDOWN_EVENT 0
#define LISTEN_ACCEPT_EVENT 1

typedef struct LISTEN_OBJECT_tag
{
    HQ931LISTEN         hQ931Listen;
    DWORD_PTR           dwUserToken;
    Q931_CALLBACK       ListenCallback;
    DWORD               dwPhysicalId;

    BOOL                bInList;
    struct LISTEN_OBJECT_tag *pNextInList;
    struct LISTEN_OBJECT_tag *pPrevInList;
    CRITICAL_SECTION    Lock;
} LISTEN_OBJECT, *P_LISTEN_OBJECT, **PP_LISTEN_OBJECT;

BOOL ListenListAddrSearch(
    WORD             wListenPort);

CS_STATUS ListenListCreate();

CS_STATUS ListenListDestroy();

CS_STATUS ListenObjectCreate(
    PHQ931LISTEN        phQ931Listen,
    DWORD_PTR           dwUserToken,
    Q931_CALLBACK       ListenCallback);

CS_STATUS ListenObjectDestroy(
    P_LISTEN_OBJECT     pListenObject);

CS_STATUS ListenObjectLock(
    HQ931LISTEN         hQ931Listen,
    PP_LISTEN_OBJECT    ppListenObject);

CS_STATUS ListenObjectUnlock(
    P_LISTEN_OBJECT     pListenObject);

#ifdef __cplusplus
}
#endif

#endif HLISTEN_H

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\hcall.h ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/Q931/VCS/hcall.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1996 Intel Corporation.
 *
 *	$Revision:   1.27  $
 *	$Date:   08 Jan 1997 18:04:32  $
 *	$Author:   EHOWARDX  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *		
 *      Call Object Methods
 *
 *	Notes:
 *
 ***************************************************************************/


#ifndef HCALL_H
#define HCALL_H

#include "av_asn1.h"

#ifdef __cplusplus
extern "C" {
#endif

// Call Object states                     // OUT          // IN
#define CALLSTATE_NULL              0x00  // relcomp*     // relcomp*
#define CALLSTATE_INITIATED         0x01  // setup*       //
#define CALLSTATE_OUTGOING          0x03  //              // proceeding*
#define CALLSTATE_DELIVERED         0x04  //              // alerting*
#define CALLSTATE_PRESENT           0x06  //              // setup*
#define CALLSTATE_RECEIVED          0x07  // alerting*    //
#define CALLSTATE_CONNECT_REQUEST   0x08  //              //
#define CALLSTATE_INCOMING          0x09  // proceeding-  //
#define CALLSTATE_ACTIVE            0x0A  // connect*     // connect*

// Call Timer limits
#define Q931_TIMER_301             301
#define Q931_TICKS_301             180000L        // 3 minutes
#define Q931_TIMER_303             303
#define Q931_TICKS_303             4000L          // 4 seconds

typedef struct CALL_OBJECT_tag
{
    HQ931CALL           hQ931Call;
    WORD                wCRV;              // Call Reference Value (0..7FFF).
    DWORD_PTR           dwListenToken;
    DWORD_PTR           dwUserToken;
    Q931_CALLBACK       Callback;
    BYTE                bCallState;
    BOOL                fIsCaller;
    DWORD               dwPhysicalId;
    BOOL                bResolved;         // re-connect phase is over.
    BOOL                bConnected;        // has a live channel.

    CC_ADDR             LocalAddr;         // Local address on which channel is connected
    CC_ADDR             PeerConnectAddr;   // Address to which channel is connected

    CC_ADDR             PeerCallAddr;      // Address of opposite call end-point.
    BOOL                PeerCallAddrPresent;  // Address is present.

    CC_ADDR             SourceAddr;        // Address of this end-point.
    BOOL                SourceAddrPresent; // Address is present.

    CC_CONFERENCEID     ConferenceID;
    WORD                wGoal;
    BOOL                bCallerIsMC;
    WORD                wCallType;

    BOOL                NonStandardDataPresent;
    CC_NONSTANDARDDATA  NonStandardData;

    char                szDisplay[CC_MAX_DISPLAY_LENGTH];
                                           // length = 0 means not present.
    char                szCalledPartyNumber[CC_MAX_PARTY_NUMBER_LEN];
                                           // length = 0 means not present.

    PCC_ALIASNAMES      pCallerAliasList;
    PCC_ALIASNAMES      pCalleeAliasList;
    PCC_ALIASNAMES      pExtraAliasList;

    PCC_ALIASITEM       pExtensionAliasItem;

    // these are part of EndpointType...
    BOOL                VendorInfoPresent;
    CC_VENDORINFO       VendorInfo;
    BYTE                bufVendorProduct[CC_MAX_PRODUCT_LENGTH];
    BYTE                bufVendorVersion[CC_MAX_VERSION_LENGTH];
    BOOL                bIsTerminal;
    BOOL                bIsGateway;

    ASN1_CODER_INFO     World;

    DWORD               dwTimerAlarm301;
    DWORD               dwTimerAlarm303;
    GUID                CallIdentifier;
} CALL_OBJECT, *P_CALL_OBJECT, **PP_CALL_OBJECT;

CS_STATUS CallListCreate();

CS_STATUS CallListDestroy();

CS_STATUS CallObjectCreate(
    PHQ931CALL          phQ931Call,
    DWORD_PTR           dwListenToken,
    DWORD_PTR           dwUserToken,
    Q931_CALLBACK       ConnectCallback,
    BOOL                fIsCaller,
    CC_ADDR             *pLocalAddr,         // Local address on which channel is connected
    CC_ADDR             *pPeerConnectAddr,   // Address to which channel is connected
    CC_ADDR             *pPeerCallAddr,      // Address of opposite call end-point.
    CC_ADDR             *pSourceAddr,        // Address of this call end-point.
    CC_CONFERENCEID     *pConferenceID,
    WORD                wGoal,
    WORD                wCallType,
    BOOL                bCallerIsMC,
    char *              pszDisplay,
    char *              pszCalledPartyNumber,
    PCC_ALIASNAMES      pCallerAliasList,
    PCC_ALIASNAMES      pCalleeAliasList,
    PCC_ALIASNAMES      pExtraAliasList,
    PCC_ALIASITEM       pExtensionAliasItem,
    PCC_ENDPOINTTYPE    pEndpointType,
    PCC_NONSTANDARDDATA pNonStandardData,
    WORD                wCRV,
    LPGUID              pCallIdentifier);

CS_STATUS CallObjectDestroy(
    P_CALL_OBJECT  pCallObject);

CS_STATUS CallObjectLock(
    HQ931CALL         hQ931Call,
    PP_CALL_OBJECT    ppCallObject);

CS_STATUS CallObjectUnlock(
    P_CALL_OBJECT     pCallObject);

CS_STATUS CallEntryUnlock(
    HQ931CALL     	  hQ931Call);

CS_STATUS CallObjectValidate(
    HQ931CALL hQ931Call);

BOOL CallObjectFind(
    HQ931CALL *phQ931Call,
    WORD wCRV,
    PCC_ADDR pPeerAddr);

CS_STATUS CallObjectMarkForDelete(
    HQ931CALL hQ931Call);

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// Timer Routines...
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void CallBackT301(P_CALL_OBJECT pCallObject);
void CallBackT303(P_CALL_OBJECT pCallObject);
void CALLBACK Q931TimerProc(HWND hwnd, UINT uMsg, UINT idEvent, DWORD dwTime);
HRESULT Q931StartTimer(P_CALL_OBJECT pCallObject, DWORD wTimerId);
HRESULT Q931StopTimer(P_CALL_OBJECT pCallObject, DWORD wTimerId);
HRESULT Q931HangupPendingCalls(LPVOID context);

#ifdef __cplusplus
}
#endif

#endif HCALL_H

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\hangman.h ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/CALLCONT/VCS/hangman.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1994 Intel Corporation.
 *
 *	$Revision:   1.4  $
 *	$Date:   Aug 12 1996 09:40:22  $
 *	$Author:   mandrews  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *		
 *
 *	Notes:
 *
 ***************************************************************************/


HRESULT InitHangupManager();

HRESULT DeInitHangupManager();

HRESULT AllocAndLockHangup(			PHHANGUP				phHangup,
									CC_HCONFERENCE			hConference,
									DWORD_PTR				dwUserToken,
									PPHANGUP				ppHangup);

HRESULT FreeHangup(					PHANGUP					pHangup);

HRESULT LockHangup(					HHANGUP					hHangup,
									PPHANGUP				ppHangup);

HRESULT ValidateHangup(				HHANGUP					hHangup);

HRESULT UnlockHangup(				PHANGUP					pHangup);

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\hlisten.c ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/Q931/VCS/HLISTEN.C_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1996 Intel Corporation.
 *
 *	$Revision:   1.15  $
 *	$Date:   08 Jan 1997 14:10:34  $
 *	$Author:   EHOWARDX  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *		
 *
 *	Notes:
 *
 ***************************************************************************/

#pragma warning ( disable : 4115 4201 4214 4514 )

#include "precomp.h"

#ifdef __cplusplus
extern "C" {
#endif

#include <string.h>
#include "q931.h"
#include "hlisten.h"
#include "utils.h"

static BOOL bListenListCreated = FALSE;

static struct
{
    P_LISTEN_OBJECT     pHead;
	CRITICAL_SECTION	Lock;
} ListenList;

static struct
{
    HQ931LISTEN           hQ931Listen;
	CRITICAL_SECTION	Lock;
} ListenHandleSource;


//====================================================================================
//
// PRIVATE FUNCTIONS
//
//====================================================================================

//====================================================================================
//====================================================================================
CS_STATUS
_ListenObjectListAdd(
    P_LISTEN_OBJECT  pListenObject)
{
    if ((pListenObject == NULL) || (pListenObject->bInList == TRUE))
    {
        ASSERT(FALSE);
        return CS_BAD_PARAM;
    }
	
	EnterCriticalSection(&ListenList.Lock);

	pListenObject->pNextInList = ListenList.pHead;
	pListenObject->pPrevInList = NULL;
	if (ListenList.pHead != NULL)
    {
		ListenList.pHead->pPrevInList = pListenObject;
    }
	ListenList.pHead = pListenObject;

	pListenObject->bInList = TRUE;
	LeaveCriticalSection(&ListenList.Lock);

	return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
_ListenObjectListRemove(
    P_LISTEN_OBJECT  pListenObject)
{
    HQ931LISTEN hQ931Listen;

    if ((pListenObject == NULL) || (pListenObject->bInList == FALSE))
    {
        ASSERT(FALSE);
        return CS_BAD_PARAM;
    }
	
    // caller must have a lock on the listen object;
    // in order to avoid deadlock, we must:
    //   1. unlock the listen object,
    //   2. lock the ListenList,
    //   3. locate the listen object in the ListenList (note that
    //      after step 2, the listen object may be deleted from the
    //      ListenList by another thread),
    //   4. lock the listen object (someone else may have the lock)
    //   5. remove the listen object from the ListenList,
    //   6. unlock the ListenList
    //
    // the caller can now safely unlock and destroy the listen object,
    // since no other thread will be able to find the object (its been
    // removed from the ListenList), and therefore no other thread will
    // be able to lock it.

    // Save the listen handle; its the only way to look up
    // the listen object in the ListenList. Note that we
    // can't use pListenObject to find the listen object, because
    // the pointer will no longer be usable after step 1.
    hQ931Listen = pListenObject->hQ931Listen;

    // step 1
    LeaveCriticalSection(&pListenObject->Lock);

    // step 2
    EnterCriticalSection(&ListenList.Lock);

    // step 3
    pListenObject = ListenList.pHead;
    while ((pListenObject != NULL) && (pListenObject->hQ931Listen != hQ931Listen))
    {
        pListenObject = pListenObject->pNextInList;
    }

    if (pListenObject != NULL)
    {
        // step 4
        EnterCriticalSection(&pListenObject->Lock);

        // step 5
        if (pListenObject->pPrevInList == NULL)
        {
            ListenList.pHead = pListenObject->pNextInList;
        }
        else
        {
            pListenObject->pPrevInList->pNextInList = pListenObject->pNextInList;
        }

        if (pListenObject->pNextInList != NULL)
        {
            pListenObject->pNextInList->pPrevInList = pListenObject->pPrevInList;
        }

        pListenObject->bInList = FALSE;
    }

    // step 6
    LeaveCriticalSection(&ListenList.Lock);

    if (pListenObject == NULL)
    {
        return CS_BAD_PARAM;
    }
    return CS_OK;
}


//====================================================================================
//====================================================================================
CS_STATUS
_ListenHandleNew(
    PHQ931LISTEN phQ931Listen)
{
	EnterCriticalSection(&(ListenHandleSource.Lock));
	*phQ931Listen = ListenHandleSource.hQ931Listen++;
	LeaveCriticalSection(&(ListenHandleSource.Lock));
	return CS_OK;
}



//====================================================================================
//
// PUBLIC FUNCTIONS
//
//====================================================================================

//====================================================================================
//====================================================================================
#if 0

BOOL
ListenListAddrSearch(
	WORD wListenPort)          // UDP or TCP port (host byte order)
{
    P_LISTEN_OBJECT pListenObject = NULL;
    BOOL found = FALSE;

    EnterCriticalSection(&ListenList.Lock);

    pListenObject = ListenList.pHead;

    while ((pListenObject != NULL) && (pListenObject->ListenSocketAddr.sin_port != wListenPort))
    {
        pListenObject = pListenObject->pNextInList;
    }
    if (pListenObject != NULL)
    {
        found = TRUE;
    }

    LeaveCriticalSection(&ListenList.Lock);

    return found;
}
#endif

//====================================================================================
//====================================================================================
CS_STATUS
ListenListCreate()
{
    if (bListenListCreated == TRUE)
    {
    	ASSERT(FALSE);
        return CS_DUPLICATE_INITIALIZE;
    }

    // list creation is not protected against multiple threads because it is only
    // called when a process is started, not when a thread is started.
	ListenList.pHead = NULL;
	InitializeCriticalSection(&(ListenList.Lock));

	ListenHandleSource.hQ931Listen = 1;
	InitializeCriticalSection(&(ListenHandleSource.Lock));

	bListenListCreated = TRUE;

    return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
ListenListDestroy()
{
    P_LISTEN_OBJECT  pListenObject;
    HQ931LISTEN hCurrent;

	if (bListenListCreated == FALSE)
    {
    	ASSERT(FALSE);
        return CS_INTERNAL_ERROR;
    }

    for ( ; ; )
    {
        // first, get the top-most listen handle in the list (safely)
        EnterCriticalSection(&(ListenList.Lock));
        pListenObject = ListenList.pHead;
        if (pListenObject == NULL)
        {
            LeaveCriticalSection(&(ListenList.Lock));
            break;
        }
        EnterCriticalSection(&pListenObject->Lock);
        hCurrent = pListenObject->hQ931Listen;
        LeaveCriticalSection(&(pListenObject->Lock));
        LeaveCriticalSection(&(ListenList.Lock));

        // try to cancel the listen object.
        Q931CancelListen(hCurrent);

        // destroy the listen object. (if the object is still around for some reason)
        if (ListenObjectLock(hCurrent, &pListenObject) == CS_OK)
        {
            ListenObjectDestroy(pListenObject);
        }
    }

	DeleteCriticalSection(&(ListenList.Lock));
	DeleteCriticalSection(&(ListenHandleSource.Lock));

	bListenListCreated = FALSE;

    return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
ListenObjectCreate(
    PHQ931LISTEN        phQ931Listen,
    DWORD_PTR           dwUserToken,
    Q931_CALLBACK       ListenCallback)
{
    P_LISTEN_OBJECT pListenObject = NULL;
    CS_STATUS status = CS_OK;

    // make sure the listen list has been created.	
    if (bListenListCreated == FALSE)
    {
        ASSERT(FALSE);
        return CS_INTERNAL_ERROR;
    }

	// validate all parameters for bogus values.
    if ((phQ931Listen == NULL) || (ListenCallback == NULL))
    {
        ASSERT(FALSE);
        return CS_BAD_PARAM;
    }

    // set phQ931Listen now, in case we encounter an error later.
    *phQ931Listen = 0;

    pListenObject = (P_LISTEN_OBJECT)MemAlloc(sizeof(LISTEN_OBJECT));
    if (pListenObject == NULL)
    {
        return CS_NO_MEMORY;
    }

    pListenObject->bInList = FALSE;

    if (_ListenHandleNew(&(pListenObject->hQ931Listen)) != CS_OK)
    {
        MemFree(pListenObject);
        return CS_INTERNAL_ERROR;
    }

    pListenObject->dwUserToken = dwUserToken;
    pListenObject->ListenCallback = ListenCallback;

	Q931MakePhysicalID(&pListenObject->dwPhysicalId);
    InitializeCriticalSection(&pListenObject->Lock);
    *phQ931Listen = pListenObject->hQ931Listen;

    // add the listen object to the listen list.
    status = _ListenObjectListAdd(pListenObject);
    if (status != CS_OK)
    {
        ListenObjectDestroy(pListenObject);
    }
    return status;
}

//====================================================================================
//====================================================================================
CS_STATUS
ListenObjectDestroy(
    P_LISTEN_OBJECT  pListenObject)
{
    if (pListenObject == NULL)
    {
        ASSERT(FALSE);
        return CS_BAD_PARAM;
    }
	
	// caller must have a lock on the listen object,
	// so there's no need to re-lock it
	
	if (pListenObject->bInList == TRUE)
    {
		if (_ListenObjectListRemove(pListenObject) == CS_BAD_PARAM)
        {
			// the listen object was deleted by another thread,
			// so just return CS_OK
			return CS_OK;
        }
    }

	// since the listen object has been removed from the ListenList,
	// no other thread will be able to find the listen object and obtain
	// a lock, so its safe to unlock the listen object and delete it here.
	LeaveCriticalSection(&(pListenObject->Lock));
	DeleteCriticalSection(&(pListenObject->Lock));
	MemFree(pListenObject);
    return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
ListenObjectLock(
    HQ931LISTEN         hQ931Listen,
    PP_LISTEN_OBJECT    ppListenObject)
{
	if ((hQ931Listen == 0) || (ppListenObject == NULL))
    {
    	ASSERT(FALSE);
		return CS_BAD_PARAM;
    }

	EnterCriticalSection(&(ListenList.Lock));

	*ppListenObject = ListenList.pHead;
	while ((*ppListenObject != NULL) && ((*ppListenObject)->hQ931Listen != hQ931Listen))
    {
		*ppListenObject = (*ppListenObject)->pNextInList;
    }

	if (*ppListenObject != NULL)
    {
		EnterCriticalSection(&((*ppListenObject)->Lock));
    }

	LeaveCriticalSection(&(ListenList.Lock));

    if (*ppListenObject == NULL)
    {
        // the handle was not found in the list, so this is treated as a bad parm.
        return CS_BAD_PARAM;
    }
    return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
ListenObjectUnlock(
    P_LISTEN_OBJECT  pListenObject)
{
    if (pListenObject == NULL)
    {
        ASSERT(FALSE);
        return CS_BAD_PARAM;
    }
    LeaveCriticalSection(&pListenObject->Lock);
    return CS_OK;
}

#ifdef __cplusplus
}
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\interop.cpp ===
#include "precomp.h"


#if (defined(_DEBUG) || defined(PCS_COMPLIANCE))

#include "interop.h"
#include <stdio.h>
#include "cpls.h"

static int g_nRefCount = 0;

LPInteropLogger INTEROP_EXPORT InteropLoad(CPLProtocol Protocol)
{

	LPInteropLogger Logger = (LPInteropLogger) GlobalAlloc (GMEM_FIXED | GMEM_ZEROINIT, sizeof(InteropLogger));
	if (!(Logger))
		return NULL;
    UINT oldMode = SetErrorMode(SEM_NOOPENFILEERRORBOX);

	(Logger)->hInst = LoadLibrary(DLLName);

    SetErrorMode(oldMode);

    if ((INT_PTR)(Logger)->hInst > HINSTANCE_ERROR)
    {
	  g_nRefCount++;

      (Logger)->CPLInitialize = (CPLInitialize_t)GetProcAddress((Logger)->hInst, "CPLInitialize");
      (Logger)->CPLUninitialize = (CPLUninitialize_t)GetProcAddress((Logger)->hInst, "CPLUninitialize");
      (Logger)->CPLOpen = (CPLOpen_t)GetProcAddress((Logger)->hInst, "CPLOpen");
      (Logger)->CPLClose = (CPLClose_t)GetProcAddress((Logger)->hInst, "CPLClose");
      (Logger)->CPLOutput = (CPLOutput_t)GetProcAddress((Logger)->hInst, "CPLOutput");
	  Logger->g_ProtocolLogID = Logger->CPLInitialize(Protocol);
	  Logger->g_ComplianceProtocolLogger = Logger->CPLOpen(Logger->g_ProtocolLogID,
													NULL,
													CPLS_CREATE | CPLS_APPEND);
	}
    else
    {
		GlobalFree((Logger));
		(Logger) = NULL;
    }

    return Logger;
}

void INTEROP_EXPORT InteropUnload(LPInteropLogger Logger)
{
	if ((Logger))
	{
		if ((INT_PTR)(Logger)->hInst > HINSTANCE_ERROR)
		{
			Logger->CPLClose(Logger->g_ComplianceProtocolLogger);
			Logger->CPLUninitialize(Logger->g_ProtocolLogID);
			if (--g_nRefCount <= 0)
				FreeLibrary((Logger)->hInst);
		}
		GlobalFree((Logger));
		(Logger) = NULL;
	}
}

void INTEROP_EXPORT InteropOutput(LPInteropLogger Logger, BYTE* buf,
							int length, unsigned long userData)
{
	if (!Logger)
		return;
	Logger->CPLOutput(Logger->g_ComplianceProtocolLogger, buf, length,userData);

}

#endif // #if (defined(_DEBUG) || defined(PCS_COMPLIANCE))

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\interop.h ===
/***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************/

#ifndef __INTEROP_H
#define __INTEROP_H

#if (defined(_DEBUG) || defined(PCS_COMPLIANCE))

#define INTEROP_EXPORT  __declspec(dllexport)

#define DLLName "CPLS.DLL"


typedef int    (WINAPI *CPLInitialize_t)(const char*);
typedef int    (WINAPI *CPLUninitialize_t)(int) ;
typedef int    (WINAPI *CPLOpen_t)(int, 
							const char*, 
							int);
typedef int    (WINAPI *CPLClose_t)( int );
typedef int    (WINAPI *CPLOutput_t)(int, 
							BYTE*, 
							int,
							unsigned long);



typedef struct {
    CPLInitialize_t       CPLInitialize;
	CPLUninitialize_t     CPLUninitialize;
    CPLOpen_t			  CPLOpen;
    CPLClose_t			  CPLClose;
    CPLOutput_t			  CPLOutput;
	int					  g_ComplianceProtocolLogger;
	int					  g_ProtocolLogID;
	HINSTANCE hInst;
} *LPInteropLogger, InteropLogger;

#ifdef __cplusplus
extern "C" {
#endif

LPInteropLogger INTEROP_EXPORT InteropLoad(const char*  Protocol);
void INTEROP_EXPORT InteropUnload(LPInteropLogger Logger);
void INTEROP_EXPORT InteropOutput(LPInteropLogger Logger, BYTE* buf, int length, unsigned long userData);

#ifdef __cplusplus
}
#endif

#else   // ! (defined(_DEBUG) || defined(PCS_COMPLIANCE))
#define InteropLoad()
#define InteropUnload()
#define InteropOutput()

#endif  // (defined(_DEBUG) || defined(PCS_COMPLIANCE))

#endif  // __CPLS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\hwsdebug.c ===
/***************************************************************************
 *
 * File: hwsdebug.c
 *
 * INTEL Corporation Proprietary Information
 * Copyright (c) 1996 Intel Corporation.
 *
 * This listing is supplied under the terms of a license agreement
 * with INTEL Corporation and may not be used, copied, nor disclosed
 * except in accordance with the terms of that agreement.
 *
 ***************************************************************************
 *
 * $Workfile:   hwsdebug.c  $
 * $Revision:   1.13  $
 * $Modtime:   13 Dec 1996 11:44:24  $
 * $Log:   S:\sturgeon\src\h245ws\vcs\hwsdebug.c_v  $
 * 
 *    Rev 1.13   13 Dec 1996 12:12:50   SBELL1
 * moved ifdef _cplusplus to after includes
 * 
 *    Rev 1.12   11 Dec 1996 13:41:56   SBELL1
 * Put in UNICODE tracing stuff.
 * 
 *    Rev 1.11   01 Oct 1996 14:49:22   EHOWARDX
 * Revision 1.9 copied to tip.
 * 
 *    Rev 1.9   May 28 1996 10:40:14   plantz
 * Change vsprintf to wvsprintf.
 * 
 *    Rev 1.8   29 Apr 1996 17:13:16   unknown
 * Fine-tuning instance-specific name.
 * 
 *    Rev 1.7   29 Apr 1996 13:04:56   EHOWARDX
 * 
 * Added timestamp and instance-specific short name.
 * 
 *    Rev 1.6   Apr 24 1996 16:20:56   plantz
 * Removed include winsock2.h and incommon.h
 * 
 *    Rev 1.4.1.0   Apr 24 1996 16:19:54   plantz
 * Removed include winsock2.h and callcont.h
 * 
 *    Rev 1.4   01 Apr 1996 14:20:34   unknown
 * Shutdown redesign.
 * 
 *    Rev 1.3   22 Mar 1996 16:04:18   EHOWARDX
 * Added #if defined(_DEBUG) around whole file.
 * 
 *    Rev 1.2   22 Mar 1996 15:25:28   EHOWARDX
 * Changed to use ISR_HookDbgStr instead of OutputDebugString.
 * 
 *    Rev 1.1   14 Mar 1996 17:01:00   EHOWARDX
 * 
 * NT4.0 testing; got rid of HwsAssert(); got rid of TPKT/WSCB.
 * 
 *    Rev 1.0   08 Mar 1996 20:22:14   unknown
 * Initial revision.
 *
 ***************************************************************************/

#if defined(_DEBUG)

#ifndef STRICT
#define STRICT
#endif	// not defined STRICT
#undef _WIN32_WINNT	// override bogus platform definition in our common build environment

#pragma warning ( disable : 4115 4201 4214 4514 )
#include "precomp.h"

#include "queue.h"
#include "linkapi.h"
#include "h245ws.h"
#include "isrg.h"

#if defined(__cplusplus)
extern "C"
{
#endif  // (__cplusplus)


/*****************************************************************************
 *
 * TYPE:       Global System
 *
 * PROCEDURE:  HwsTrace
 *
 * DESCRIPTION:
 *    Trace function for HWS
 *
 * INPUT:
 *    dwInst         Instance identifier for trace message
 *    dwLevel        Trace level as defined below
 *    pszFormat      sprintf string format with 1-N parameters
 *
 * Trace Level (byLevel) Definitions:
 *    HWS_CRITICAL   Progammer errors that should never happen
 *    HWS_ERROR	   Errors that need to be fixed
 *    HWS_WARNING	   The user could have problems if not corrected
 *    HWS_NOTIFY	   Status, events, settings...
 *    HWS_TRACE	   Trace info that will not overrun the system
 *    HWS_TEMP		   Trace info that may be reproduced in heavy loops
 *
 * RETURN VALUE:
 *    None
 *
 *****************************************************************************/

void HwsTrace (DWORD dwInst, 
               BYTE byLevel, 
#ifdef UNICODE_TRACE
				LPTSTR pszFormat,
#else
				LPSTR pszFormat,
#endif               
                ...)
{
#ifdef UNICODE_TRACE
   TCHAR                szBuffer[128];
   static TCHAR         szName[] = __TEXT("H245WS-1");
#else
   char                 szBuffer[128];
   static char          szName[] = "H245WS-1";
#endif
   va_list              pParams;
   static WORD          wIsrInst = 0xFFFF;

   ASSERT(pszFormat != NULL);

   switch (byLevel)
   {
   case HWS_CRITICAL:
   case HWS_ERROR:
   case HWS_WARNING:
   case HWS_NOTIFY:
   case HWS_TRACE:
   case HWS_TEMP:
      break;

   default:
      byLevel = HWS_CRITICAL;
   } // switch

   if (wIsrInst == 0xFFFF)
   {
	   UINT        hMod;
	   ptISRModule	pMod;

	   for (hMod = 0; hMod < kMaxModules; ++hMod)
	   {
		   pMod = ISR_GetModule(hMod);
		   if (pMod)
         {
		      if (memcmp(szName, pMod->zSName, sizeof(szName)) == 0)
		      {
               szName[7] += 1;
            }
		   }
      }
      ISR_RegisterModule(&wIsrInst, szName, szName);
   }

#ifdef UNICODE_TRACE
   wsprintf(szBuffer, __TEXT("%9d:"), GetTickCount());
#else
   wsprintf(szBuffer, "%9d:", GetTickCount());
#endif
   va_start(pParams, pszFormat);
   wvsprintf(&szBuffer[10], pszFormat, pParams);
   ISR_HookDbgStr((UINT)dwInst, wIsrInst, byLevel, szBuffer, 0);
} // HwsTrace()



#if defined(__cplusplus)
}
#endif  // (__cplusplus)

#endif  // (_DEBUG)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\listman.h ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/CALLCONT/VCS/listman.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1994 Intel Corporation.
 *
 *	$Revision:   1.10  $
 *	$Date:   10 Dec 1996 11:26:46  $
 *	$Author:   MANDREWS  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *		
 *
 *	Notes:
 *
 ***************************************************************************/


HRESULT InitListenManager();

HRESULT DeInitListenManager();

HRESULT AllocAndLockListen(			PCC_HLISTEN				phListen,
									PCC_ADDR				pListenAddr,
									HQ931LISTEN				hQ931Listen,
									PCC_ALIASNAMES			pLocalAliasNames,
									DWORD_PTR				dwListenToken,
									CC_LISTEN_CALLBACK		ListenCallback,
									PPLISTEN				ppListen);

HRESULT FreeListen(					PLISTEN					pListen);

HRESULT LockListen(					CC_HLISTEN				hListen,
									PPLISTEN				ppListen);

HRESULT ValidateListen(				CC_HLISTEN				hListen);

HRESULT UnlockListen(				PLISTEN					pListen);

HRESULT GetLastListenAddress(		PCC_ADDR				pListenAddr);

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\mlse.c ===
/***********************************************************************
 *                                                                     *
 * Filename: mlse.c                                                    *
 * Module:   H245 Finite State Machine Subsystem                       *
 *                                                                     *
 ***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *                                                                     *
 * $Workfile:   MLSE.C  $
 * $Revision:   1.4  $
 * $Modtime:   09 Dec 1996 13:34:24  $
 * $Log:   S:/STURGEON/SRC/H245/SRC/VCS/MLSE.C_v  $
 *
 *    Rev 1.4   09 Dec 1996 13:34:46   EHOWARDX
 * Updated copyright notice.
 *
 *    Rev 1.3   04 Jun 1996 13:57:24   EHOWARDX
 * Fixed Release build warnings.
 *
 *    Rev 1.2   30 May 1996 23:39:14   EHOWARDX
 * Cleanup.
 *
 *    Rev 1.1   28 May 1996 14:25:42   EHOWARDX
 * Tel Aviv update.
 *
 *    Rev 1.0   09 May 1996 21:06:30   EHOWARDX
 * Initial revision.
 *
 *    Rev 1.1   09 May 1996 19:48:26   EHOWARDX
 * Change TimerExpiryF function arguements.
 *
 *    Rev 1.0   15 Apr 1996 10:46:58   EHOWARDX
 * Initial revision.
 *                                                                     *
 ***********************************************************************/
#include "precomp.h"

#include "h245api.h"
#include "h245com.h"
#include "h245fsm.h"
#include "mlse.h"



// Out-going/In-coming MLSE states
#define MLSE_NOT_LOOPED             0   // NOT LOOPED
#define MLSE_WAIT                   1   // AWAITING RESPONSE
#define MLSE_LOOPED                 1   // LOOPED


extern unsigned int uT102;

/***********************************************************************
 *
 * LOCAL FUNCTIONS
 *
 ***********************************************************************/

/*
 *  NAME
 *      T102ExpiryF - Callback function called by the timer
 *
 *
 *  PARAMETERS
 *   INPUT   dwInst     current instance of H245
 *   INPUT   id         timer id
 *   INPUT   pObject    pointer to a State Entity
 *
 *
 *  RETURN VALUE
 *       OK
 */

int T102ExpiryF(struct InstanceStruct *pInstance, DWORD_PTR dwTimerId, void *pObject)
{
    return FsmTimerEvent(pInstance, dwTimerId, pObject, T102Expiry);
} // T102ExpiryF()



static void BuildMaintenanceLoopOffCommand(PDU_t *pPdu)
{
    pPdu->choice = MSCMg_cmmnd_chosen;
    pPdu->u.MSCMg_cmmnd.choice = mntnncLpOffCmmnd_chosen;
} // BuildMaintenanceLoopOffCommand()



/***********************************************************************
 *
 * OUT-GOING FINITE STATE MACHINE FUNCTIONS
 *
 ***********************************************************************/

/*
 *  NAME
 *      MLSE0_LOOP_requestF - LOOP.request from API in NOT LOOPED state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MLSE0_LOOP_requestF             (Object_t *pObject, PDU_t *pPdu)
{
    HRESULT             lError;

    ASSERT(pObject->Entity == MLSE_OUT);
    ASSERT(pObject->State  == MLSE_NOT_LOOPED);
    H245TRACE(pObject->dwInst, 2, "MLSE0_LOOP_request:%d", pObject->Key);

    // Save type from PDU
    pObject->u.mlse.wLoopType =
       pPdu->u.MltmdSystmCntrlMssg_rqst.u.maintenanceLoopRequest.type.choice;

    // Send Maintenance Loop Request PDU to remote peer
    lError = sendPDU(pObject->pInstance, pPdu);

    // Set timer T102
    pObject->State = MLSE_WAIT;
    FsmStartTimer(pObject, T102ExpiryF, uT102);

    return lError;
} // MLSE0_LOOP_request



/*
 *  NAME
 *      MLSE1_MaintenanceLoopAckF - MaintenanceLoopAck in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MLSE1_MaintenanceLoopAckF       (Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == MLSE_OUT);
    ASSERT(pObject->State  == MLSE_WAIT);
    H245TRACE(pObject->dwInst, 2, "MLSE1_MaintenanceLoopAck:%d", pObject->Key);

    // Reset timer T102
    FsmStopTimer(pObject);

    // Send LOOP.confirm to client
    pObject->State = MLSE_LOOPED;
    H245FsmConfirm(pPdu, H245_CONF_MLSE, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return 0;
} // MLSE1_MaintenanceLoopAck



/*
 *  NAME
 *      MLSE1_MaintenanceLoopRejF - MaintenanceLoopReject in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MLSE1_MaintenanceLoopRejF       (Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == MLSE_OUT);
    ASSERT(pObject->State  == MLSE_WAIT);
    H245TRACE(pObject->dwInst, 2, "MLSE1_MaintenanceLoopRej:%d", pObject->Key);

    // Reset timer T102
    FsmStopTimer(pObject);

    // Send RELEASE.indication to client
    pObject->State = MLSE_NOT_LOOPED;
    H245FsmConfirm(pPdu, H245_CONF_MLSE_REJECT, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return 0;
} // MLSE1_MaintenanceLoopRej



/*
 *  NAME
 *      MLSE1_OUT_RELEASE_requestF - RELEASE.request from API in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MLSE1_OUT_RELEASE_requestF      (Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == MLSE_OUT);
    ASSERT(pObject->State  == MLSE_WAIT);
    H245TRACE(pObject->dwInst, 2, "MLSE1_OUT_RELEASE_request:%d", pObject->Key);

    // Send MaintenanceLoopOffCommand PDU to remote peer
    pObject->State = MLSE_NOT_LOOPED;
    BuildMaintenanceLoopOffCommand(pPdu);
    return sendPDU(pObject->pInstance, pPdu);
} // MLSE1_OUT_RELEASE_request



/*
 *  NAME
 *      MLSE1_T102ExpiryF - timer T102 Expiry in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MLSE1_T102ExpiryF               (Object_t *pObject, PDU_t *pPdu)
{
    PDU_t *             pOut;
    HRESULT             lError;

    ASSERT(pObject->Entity == MLSE_OUT);
    ASSERT(pObject->State  == MLSE_WAIT);
    ASSERT(pPdu == NULL);
    H245TRACE(pObject->dwInst, 2, "MLSE1_T102Expiry:%d", pObject->Key);

    // Send MaintenanceLoopOffCommand PDU to remote peer
    pOut = MemAlloc(sizeof(*pOut));
    if (pOut == NULL)
    {
        H245TRACE(pObject->dwInst, 2,
                  "MLSE1_T102ExpiryF: memory allocation failed");
        return H245_ERROR_NOMEM;
    }
    BuildMaintenanceLoopOffCommand(pOut);
    lError = sendPDU(pObject->pInstance, pOut);
    MemFree(pOut);

    // Send RELEASE.indication to client
    //   SOURCE := MLSE
    pObject->State = MLSE_NOT_LOOPED;
    H245FsmConfirm(NULL, H245_CONF_MLSE_EXPIRED, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return lError;
} // MLSE1_T102Expiry

/*
 *  NAME
 *      MLSE2_MaintenanceLoopRejF - MaintenanceLoopReject in LOOPED state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MLSE2_MaintenanceLoopRejF       (Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == MLSE_OUT);
    ASSERT(pObject->State  == MLSE_WAIT);
    H245TRACE(pObject->dwInst, 2, "MLSE2_MaintenanceLoopRej:%d", pObject->Key);

    pObject->State = MLSE_NOT_LOOPED;

#if defined(SDL_COMPLIANT)
    // Send ERROR.indication(B) to client
    // TBD
#endif

    // Send RELEASE.indication to client
    //   SOURCE := MLSE
    H245FsmConfirm(pPdu, H245_CONF_MLSE_REJECT, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return 0;
} // MLSE2_MaintenanceLoopRej



/*
 *  NAME
 *      MLSE2_OUT_RELEASE_requestF - RELEASE.request from API in LOOPED state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MLSE2_OUT_RELEASE_requestF      (Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == MLSE_OUT);
    ASSERT(pObject->State  == MLSE_WAIT);
    H245TRACE(pObject->dwInst, 2, "MLSE2_OUT_RELEASE_request:%d", pObject->Key);

    // Send MaintenanceLoopOffCommand PDU to remote peer
    pObject->State = MLSE_NOT_LOOPED;
    BuildMaintenanceLoopOffCommand(pPdu);
    return sendPDU(pObject->pInstance, pPdu);
} // MLSE2_OUT_RELEASE_request



/***********************************************************************
 *
 * IN-COMING FINITE STATE MACHINE FUNCTIONS
 *
 ***********************************************************************/

/*
 *  NAME
 *      MLSE0_MaintenanceLoopRequestF - MaintenanceLoopRequest received in NOT LOOPED state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MLSE0_MaintenanceLoopRequestF   (Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == MLSE_IN);
    ASSERT(pObject->State  == MLSE_NOT_LOOPED);
    H245TRACE(pObject->dwInst, 2, "MLSE0_MaintenanceLoopRequest:%d", pObject->Key);

    // Save type from PDU
    pObject->u.mlse.wLoopType =
       pPdu->u.MltmdSystmCntrlMssg_rqst.u.maintenanceLoopRequest.type.choice;

    // Send LOOP.indication to client
    pObject->State = MLSE_WAIT;
    H245FsmIndication(pPdu, H245_IND_MLSE, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return 0;
} // MLSE0_MaintenanceLoopRequest



/*
 *  NAME
 *      MLSE1_MaintenanceLoopRequestF - MaintenanceLoopRequest received in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MLSE1_MaintenanceLoopRequestF   (Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == MLSE_IN);
    ASSERT(pObject->State  == MLSE_WAIT);
    H245TRACE(pObject->dwInst, 2, "MLSE1_MaintenanceLoopRequest:%d", pObject->Key);

    // Save type from PDU
    pObject->u.mlse.wLoopType =
       pPdu->u.MltmdSystmCntrlMssg_rqst.u.maintenanceLoopRequest.type.choice;

#if defined(SDL_COMPLIANT)
    // Send RELEASE.indication to client
    H245FsmIndication(pPdu, H245_IND_MLSE_RELEASE, pObject->pInstance, pObject->dwTransId, FSM_OK);
#endif

    // Send LOOP.indication to client
    H245FsmIndication(pPdu, H245_IND_MLSE, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return 0;
} // MLSE1_MaintenanceLoopRequest



/*
 *  NAME
 *      MLSE1_MaintenanceLoopReleaseF - MaintenanceLoopOffCommand received in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MLSE1_MaintenanceLoopOffCommandF(Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == MLSE_IN);
    ASSERT(pObject->State  == MLSE_WAIT);
    H245TRACE(pObject->dwInst, 2, "MLSE1_MaintenanceLoopOffCommand:%d", pObject->Key);

    // Send RELEASE.indication to client
    pObject->State = MLSE_NOT_LOOPED;
    H245FsmIndication(pPdu, H245_IND_MLSE_RELEASE, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return 0;
} // MLSE1_MaintenanceLoopOffCommand



/*
 *  NAME
 *      MLSE1_LOOP_responseF - LOOP.response from API in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MLSE1_LOOP_responseF         (Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == MLSE_IN);
    ASSERT(pObject->State  == MLSE_WAIT);
    H245TRACE(pObject->dwInst, 2, "MLSE1_LOOP_response:%d", pObject->Key);

    // Send MaintenanceLoopAck PDU to remote peer
    pPdu->u.MSCMg_rspns.u.maintenanceLoopAck.type.choice = pObject->u.mlse.wLoopType;
    switch (pObject->u.mlse.wLoopType)
    {
    case systemLoop_chosen:
        break;
    case mediaLoop_chosen:
        pPdu->u.MSCMg_rspns.u.maintenanceLoopAck.type.u.mediaLoop          = (WORD)pObject->Key;
        break;
    case logicalChannelLoop_chosen:
        pPdu->u.MSCMg_rspns.u.maintenanceLoopAck.type.u.logicalChannelLoop = (WORD)pObject->Key;
        break;
    default:
        H245TRACE(pObject->dwInst, 1, "Invalid loop type %d", pObject->u.mlse.wLoopType);
    } // switch
    pObject->State = MLSE_LOOPED;
    return sendPDU(pObject->pInstance, pPdu);
} // MLSE1_LOOP_response



/*
 *  NAME
 *      MLSE1_IN_RELEASE_requestF - RELEASE.request from API in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MLSE1_IN_RELEASE_requestF       (Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == MLSE_IN);
    ASSERT(pObject->State  == MLSE_WAIT);
    H245TRACE(pObject->dwInst, 2, "MLSE1_IN_RELEASE_request:%d", pObject->Key);

    // Send MaintenanceLoopReject PDU to remote peer
    pPdu->u.MSCMg_rspns.u.maintenanceLoopReject.type.choice = pObject->u.mlse.wLoopType;
    switch (pObject->u.mlse.wLoopType)
    {
    case systemLoop_chosen:
        break;
    case mediaLoop_chosen:
        pPdu->u.MSCMg_rspns.u.maintenanceLoopReject.type.u.mediaLoop          = (WORD)pObject->Key;
        break;
    case logicalChannelLoop_chosen:
        pPdu->u.MSCMg_rspns.u.maintenanceLoopReject.type.u.logicalChannelLoop = (WORD)pObject->Key;
        break;
    default:
        H245TRACE(pObject->dwInst, 1, "Invalid loop type %d", pObject->u.mlse.wLoopType);
    } // switch
    pObject->State = MLSE_NOT_LOOPED;
    return sendPDU(pObject->pInstance, pPdu);
} // MLSE1_IN_RELEASE_request



/*
 *  NAME
 *      MLSE2_MaintenanceLoopRequestF - MaintenanceLoopRequest received in LOOPED state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MLSE2_MaintenanceLoopRequestF   (Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == MLSE_IN);
    ASSERT(pObject->State  == MLSE_LOOPED);
    H245TRACE(pObject->dwInst, 2, "MLSE2_MaintenanceLoopRequest:%d", pObject->Key);

    // Save type from PDU
    pObject->u.mlse.wLoopType =
       pPdu->u.MltmdSystmCntrlMssg_rqst.u.maintenanceLoopRequest.type.choice;

    pObject->State = MLSE_WAIT;

#if defined(SDL_COMPLIANT)
    // Send RELEASE.indication to client
    H245FsmIndication(pPdu, H245_IND_MLSE_RELEASE, pObject->pInstance, pObject->dwTransId, FSM_OK);
#endif

    // Send LOOP.indication to client
    H245FsmIndication(pPdu, H245_IND_MLSE, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return 0;
} // MLSE2_MaintenanceLoopRequest



/*
 *  NAME
 *      MLSE2_MaintenanceLoopReleaseF - MaintenanceLoopOffCommand received in LOOPED state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MLSE2_MaintenanceLoopOffCommandF(Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == MLSE_IN);
    ASSERT(pObject->State  == MLSE_LOOPED);
    H245TRACE(pObject->dwInst, 2, "MLSE2_MaintenanceLoopOffCommand:%d", pObject->Key);

    // Send RELEASE.indication to client
    pObject->State = MLSE_NOT_LOOPED;
    H245FsmIndication(pPdu, H245_IND_MLSE_RELEASE, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return 0;
} // MLSE2_MaintenanceLoopOffCommand

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\listman.c ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/CALLCONT/VCS/Listman.c_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1994 Intel Corporation.
 *
 *	$Revision:   1.22  $
 *	$Date:   22 Jan 1997 14:55:52  $
 *	$Author:   MANDREWS  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *		
 *
 *	Notes:
 *
 ***************************************************************************/

#include "precomp.h"

#include "apierror.h"
#include "incommon.h"
#include "callcont.h"
#include "q931.h"
#include "ccmain.h"
#include "ccutils.h"
#include "listman.h"


static BOOL		bListenInited = FALSE;

static struct {
	PLISTEN				pHead;
	LOCK				Lock;
} ListenTable;

static struct {
	CC_HLISTEN			hListen;
	LOCK				Lock;
} ListenHandle;


HRESULT InitListenManager()
{
	ASSERT(bListenInited == FALSE);

	ListenTable.pHead = NULL;
	InitializeLock(&ListenTable.Lock);

	ListenHandle.hListen = CC_INVALID_HANDLE + 1;
	InitializeLock(&ListenHandle.Lock);

	bListenInited = TRUE;
	return CC_OK;
}



HRESULT DeInitListenManager()
{
PLISTEN		pListen;
PLISTEN		pNextListen;

	if (bListenInited == FALSE)
		return CC_OK;

	pListen = ListenTable.pHead;
	while (pListen != NULL) {
		AcquireLock(&pListen->Lock);
		pNextListen = pListen->pNextInTable;
		FreeListen(pListen);
		pListen = pNextListen;
	}

	DeleteLock(&ListenHandle.Lock);
	DeleteLock(&ListenTable.Lock);
	bListenInited = FALSE;
	return CC_OK;
}



HRESULT _AddListenToTable(			PLISTEN					pListen)
{
	ASSERT(pListen != NULL);
	ASSERT(pListen->hListen != CC_INVALID_HANDLE);
	ASSERT(pListen->bInTable == FALSE);

	AcquireLock(&ListenTable.Lock);

	pListen->pNextInTable = ListenTable.pHead;
	pListen->pPrevInTable = NULL;
	if (ListenTable.pHead != NULL)
		ListenTable.pHead->pPrevInTable = pListen;
	ListenTable.pHead = pListen;

	pListen->bInTable = TRUE;

	RelinquishLock(&ListenTable.Lock);
	return CC_OK;
}



HRESULT _RemoveListenFromTable(		PLISTEN					pListen)
{
CC_HLISTEN		hListen;
BOOL			bTimedOut;

	ASSERT(pListen != NULL);
	ASSERT(pListen->bInTable == TRUE);

	// Caller must have a lock on the listen object;
	// in order to avoid deadlock, we must:
	//   1. unlock the listen object,
	//   2. lock the ListenTable,
	//   3. locate the listen object in the ListenTable (note that
	//      after step 2, the listen object may be deleted from the
	//      ListenTable by another thread),
	//   4. lock the listen object (someone else may have the lock)
	//   5. remove the listen object from the ListenTable,
	//   6. unlock the ListenTable
	//
	// The caller can now safely unlock and destroy the listen object,
	// since no other thread will be able to find the object (its been
	// removed from the ListenTable), and therefore no other thread will
	// be able to lock it.

	// Save the listen handle; its the only way to look up
	// the listen object in the ListenTable. Note that we
	// can't use pListen to find the listen object, since
	// pListen may be free'd up, and another listen object
	// allocated at the same address
	hListen = pListen->hListen;

	// step 1
	RelinquishLock(&pListen->Lock);

step2:
	// step 2
	AcquireLock(&ListenTable.Lock);

	// step 3
	pListen = ListenTable.pHead;
	while ((pListen != NULL) && (pListen->hListen != hListen))
		pListen = pListen->pNextInTable;

	if (pListen != NULL) {
		// step 4
		AcquireTimedLock(&pListen->Lock,10,&bTimedOut);
		if (bTimedOut) {
			RelinquishLock(&ListenTable.Lock);
			Sleep(0);
			goto step2;
		}
		// step 5
		if (pListen->pPrevInTable == NULL)
			ListenTable.pHead = pListen->pNextInTable;
		else
			pListen->pPrevInTable->pNextInTable = pListen->pNextInTable;

		if (pListen->pNextInTable != NULL)
			pListen->pNextInTable->pPrevInTable = pListen->pPrevInTable;

		pListen->pNextInTable = NULL;
		pListen->pPrevInTable = NULL;
		pListen->bInTable = FALSE;
	}

	// step 6
	RelinquishLock(&ListenTable.Lock);

	if (pListen == NULL)
		return CC_BAD_PARAM;
	else
		return CC_OK;
}



HRESULT _MakeListenHandle(			PCC_HLISTEN				phListen)
{
	AcquireLock(&ListenHandle.Lock);
	*phListen = ListenHandle.hListen++;
	RelinquishLock(&ListenHandle.Lock);
	return CC_OK;
}



HRESULT AllocAndLockListen(			PCC_HLISTEN				phListen,
									PCC_ADDR				pListenAddr,
									HQ931LISTEN				hQ931Listen,
									PCC_ALIASNAMES			pLocalAliasNames,
									DWORD_PTR				dwListenToken,
									CC_LISTEN_CALLBACK		ListenCallback,
									PPLISTEN				ppListen)
{
HRESULT		status;
	
	ASSERT(bListenInited == TRUE);

	// all parameters should have been validated by the caller
	ASSERT(phListen != NULL);
	ASSERT(pListenAddr != NULL);
	ASSERT(ListenCallback != NULL);
	ASSERT(ppListen != NULL);

	// set phListen now, in case we encounter an error
	*phListen = CC_INVALID_HANDLE;

	*ppListen = (PLISTEN)MemAlloc(sizeof(LISTEN));
	if (*ppListen == NULL)
		return CC_NO_MEMORY;

	(*ppListen)->bInTable = FALSE;
	status = _MakeListenHandle(&(*ppListen)->hListen);
	if (status != CC_OK) {
		MemFree(*ppListen);
		return status;
	}
	
	// make a local copy of the ListenAddr
	(*ppListen)->ListenAddr = *pListenAddr;
	(*ppListen)->hQ931Listen = hQ931Listen;
	(*ppListen)->dwListenToken = dwListenToken;
	(*ppListen)->pLocalAliasNames = NULL;
	(*ppListen)->ListenCallback = ListenCallback;
	(*ppListen)->pNextInTable = NULL;
	(*ppListen)->pPrevInTable = NULL;
	(*ppListen)->pLocalAliasNames = NULL;

	InitializeLock(&(*ppListen)->Lock);
	AcquireLock(&(*ppListen)->Lock);

	*phListen = (*ppListen)->hListen;

	// make a local copy of the local alias names
	status = Q931CopyAliasNames(&(*ppListen)->pLocalAliasNames, pLocalAliasNames);
	if (status != CS_OK) {
		FreeListen(*ppListen);
		*phListen = CC_INVALID_HANDLE;
		return status;
	}

	// add the Listen to the Listen table
	status = _AddListenToTable(*ppListen);
	if (status != CC_OK)
		FreeListen(*ppListen);
	
	return status;
}



// Caller must have a lock on the Listen object
HRESULT FreeListen(					PLISTEN				pListen)
{
CC_HLISTEN		hListen;

	ASSERT(pListen != NULL);

	// caller must have a lock on the Listen object,
	// so there's no need to re-lock it

	hListen = pListen->hListen;

	if (pListen->bInTable == TRUE)
		if (_RemoveListenFromTable(pListen) == CC_BAD_PARAM)
			// the Listen object was deleted by another thread,
			// so just return CC_OK
			return CC_OK;

	if (pListen->pLocalAliasNames != NULL)
		Q931FreeAliasNames(pListen->pLocalAliasNames);
	
	// Since the listen object has been removed from the ListenTable,
	// no other thread will be able to find the listen object and obtain
	// a lock, so its safe to unlock the listen object and delete it here
	RelinquishLock(&pListen->Lock);
	DeleteLock(&pListen->Lock);
	MemFree(pListen);
	return CC_OK;
}



HRESULT LockListen(					CC_HLISTEN				hListen,
									PPLISTEN				ppListen)
{
BOOL	bTimedOut;

	ASSERT(hListen != CC_INVALID_HANDLE);
	ASSERT(ppListen != NULL);

step1:
	AcquireLock(&ListenTable.Lock);

	*ppListen = ListenTable.pHead;
	while ((*ppListen != NULL) && ((*ppListen)->hListen != hListen))
		*ppListen = (*ppListen)->pNextInTable;

	if (*ppListen != NULL) {
		AcquireTimedLock(&(*ppListen)->Lock,10,&bTimedOut);
		if (bTimedOut) {
			RelinquishLock(&ListenTable.Lock);
			Sleep(0);
			goto step1;
		}
	}

	RelinquishLock(&ListenTable.Lock);

	if (*ppListen == NULL)
		return CC_BAD_PARAM;
	else
		return CC_OK;
}



HRESULT ValidateListen(				CC_HLISTEN				hListen)
{
PLISTEN	pListen;

	ASSERT(hListen != CC_INVALID_HANDLE);

	AcquireLock(&ListenTable.Lock);

	pListen = ListenTable.pHead;
	while ((pListen != NULL) && (pListen->hListen != hListen))
		pListen = pListen->pNextInTable;

	RelinquishLock(&ListenTable.Lock);

	if (pListen == NULL)
		return CC_BAD_PARAM;
	else
		return CC_OK;
}



HRESULT UnlockListen(				PLISTEN					pListen)
{
	ASSERT(pListen != NULL);

	RelinquishLock(&pListen->Lock);
	return CC_OK;
}



HRESULT GetLastListenAddress(		PCC_ADDR				pListenAddr)
{
HRESULT	status;
PLISTEN	pListen;
PLISTEN	pLastListen;

	ASSERT(pListenAddr != NULL);

	AcquireLock(&ListenTable.Lock);

	pListen = ListenTable.pHead;
	pLastListen = pListen;
	while (pListen != NULL) {
		if (pLastListen->hListen < pListen->hListen)
			pLastListen = pListen;
		pListen = pListen->pNextInTable;
	}

	if (pLastListen == NULL)
		status = CC_BAD_PARAM;
	else {
		status = CC_OK;
		*pListenAddr = pLastListen->ListenAddr;
	}	

	RelinquishLock(&ListenTable.Lock);
	return status;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\mlse.h ===
/***********************************************************************
 *                                                                     *
 * Filename: mlse.h                                                    *
 * Module:   H245 Finite State Machine Subsystem                       *
 *                                                                     *
 ***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *                                                                     *
 * $Workfile:   MLSE.H  $
 * $Revision:   1.2  $
 * $Modtime:   09 Dec 1996 13:40:40  $
 * $Log:   S:/STURGEON/SRC/H245/INCLUDE/VCS/MLSE.H_v  $
 * 
 *    Rev 1.2   09 Dec 1996 13:40:58   EHOWARDX
 * Updated copyright notice.
 * 
 *    Rev 1.1   30 May 1996 23:38:22   EHOWARDX
 * Cleanup.
 * 
 *    Rev 1.0   09 May 1996 21:04:52   EHOWARDX
 * Initial revision.
 * 
 *    Rev 1.2   15 Apr 1996 10:43:08   EHOWARDX
 * Update.
 * 
 *    Rev 1.1   11 Apr 1996 13:21:10   EHOWARDX
 * Deleted unused function.
 * 
 *    Rev 1.0   10 Apr 1996 21:08:30   EHOWARDX
 * Initial revision.
 *                                                                     *
 ***********************************************************************/

// Out-going Request Mode (MLSE_OUT) state functions
HRESULT MLSE0_LOOP_requestF             (Object_t *pObject, PDU_t *pPdu);
HRESULT MLSE1_MaintenanceLoopAckF       (Object_t *pObject, PDU_t *pPdu);
HRESULT MLSE1_MaintenanceLoopRejF       (Object_t *pObject, PDU_t *pPdu);
HRESULT MLSE1_OUT_RELEASE_requestF      (Object_t *pObject, PDU_t *pPdu);
HRESULT MLSE1_T102ExpiryF               (Object_t *pObject, PDU_t *pPdu);
HRESULT MLSE2_MaintenanceLoopRejF       (Object_t *pObject, PDU_t *pPdu);
HRESULT MLSE2_OUT_RELEASE_requestF      (Object_t *pObject, PDU_t *pPdu);

// In-coming Request Mode (MLSE_IN) state functions
HRESULT MLSE0_MaintenanceLoopRequestF   (Object_t *pObject, PDU_t *pPdu);
HRESULT MLSE1_MaintenanceLoopRequestF   (Object_t *pObject, PDU_t *pPdu);
HRESULT MLSE1_MaintenanceLoopOffCommandF(Object_t *pObject, PDU_t *pPdu);
HRESULT MLSE1_LOOP_responseF            (Object_t *pObject, PDU_t *pPdu);
HRESULT MLSE1_IN_RELEASE_requestF       (Object_t *pObject, PDU_t *pPdu);
HRESULT MLSE2_MaintenanceLoopRequestF   (Object_t *pObject, PDU_t *pPdu);
HRESULT MLSE2_MaintenanceLoopOffCommandF(Object_t *pObject, PDU_t *pPdu);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\linkapi.h ===
/***************************************************************************
 *
 * File: linkapi.h
 *
 * INTEL Corporation Proprietary Information
 * Copyright (c) 1996 Intel Corporation.
 *
 * This listing is supplied under the terms of a license agreement
 * with INTEL Corporation and may not be used, copied, nor disclosed
 * except in accordance with the terms of that agreement.
 *
 ***************************************************************************
 *
 * $Workfile:   linkapi.h  $
 * $Revision:   1.17  $
 * $Modtime:   11 Dec 1996 13:57:14  $
 * $Log:   S:\sturgeon\src\include\vcs\linkapi.h_v  $
 *
 *    Rev 1.17   11 Dec 1996 14:10:48   SBELL1
 * changed parameters to linkLayerInit/Listen
 *
 *    Rev 1.16.1.0   11 Dec 1996 13:57:14   SBELL1
 * CHanged parameters to linkLayerInit and Listen.
 *
 *    Rev 1.16   14 Oct 1996 14:00:20   EHOWARDX
 *
 * Unicode changes.
 *
 *    Rev 1.15   15 Aug 1996 14:00:08   rodellx
 *
 * Added additional address validation error case for DOMAIN_NAME addresses
 * which cannot be resolved, but are used with SocketBind().
 *
 *    Rev 1.14   11 Jul 1996 18:42:10   rodellx
 *
 * Fixed bug where HRESULT ids were in violation of Facility and/or Code
 * value rules.
 *
 *    Rev 1.13   10 Jul 1996 21:36:26   rodellx
 *
 * Changed error code base to required value defined by apierror.h.
 *
 *    Rev 1.12   May 28 1996 18:09:08   plantz
 * Change all error and message codes to use HRESULT. Deleted unused codes.
 *
 *    Rev 1.11   09 May 1996 18:28:36   EHOWARDX
 * Eliminated unnessary formal parameters.
 *
 *    Rev 1.4   25 Apr 1996 21:43:50   helgebax
 * Copied Philip's changes from sturgeon\src\include.
 *
 *    Rev 1.10   Apr 25 1996 21:07:16   plantz
 * Add messages for connect callback.
 * Add connect callback parameter to link layer accept.
 *
 *    Rev 1.9   Apr 25 1996 15:36:50   plantz
 * Remove #include incommon.h and dependencies on types defined in incommon
 * (use pointers to incomplete structure types instead).
 *
 *    Rev 1.8   Apr 24 1996 20:54:08   plantz
 * Change name of H245LISTENCALLBACK to H245CONNECTCALLBACK and add additional
 * parameters. Add it as an parameter to linkLayerConnect as well as
 * linkLayerListen.
 *
 *    Rev 1.7   Apr 24 1996 17:00:04   plantz
 * Merge 1.3.1.0 with 1.6 (changes to support Q931).
 *
 *    Rev 1.6   19 Apr 1996 10:35:36   EHOWARDX
 * Encorporate Dan's latest SRPAPI.H changes.
 *
 *    Rev 1.3.1.0   Apr 23 1996 13:45:26   plantz
 * Changes to support Q.931.
 *
 *****************************************************************************/

#ifndef LINKAPI_H
#define LINKAPI_H

#include "apierror.h"

#if defined(__cplusplus)
extern "C"
{
#endif  // (__cplusplus)

// declare exported functions
#if(0)  // it's all in one DLL
#if defined(LINKDLL_EXPORT)
#define LINKDLL __declspec (dllexport)
#else   // (LINKDLL_EXPORT)
#define LINKDLL __declspec (dllimport)
#endif  // (LINKDLL_EXPORT)
#define SRPDLL LINKDLL
#else
#define LINKDLL cdecl
#endif

////////////////////////////////////////////////////////////////////////////
//
// Link Layer defaults
//
////////////////////////////////////////////////////////////////////////////

#define INVALID_PHYS_ID			(DWORD) 0xffffffff


////////////////////////////////////////////////////////////////////////////
//
// Link Layer Error defines
//
////////////////////////////////////////////////////////////////////////////

#define LINK_ERROR_BASE        ERROR_LOCAL_BASE_ID
#define LINK_SEND_ERROR_BASE   LINK_ERROR_BASE + 0x100
#define LINK_SEND_COMP_BASE    LINK_ERROR_BASE + 0x200
#define LINK_RCV_ERROR_BASE    LINK_ERROR_BASE + 0x300
#define LINK_RCV_COMP_BASE     LINK_ERROR_BASE + 0x400
#define LINK_UTIL_ERROR_BASE   LINK_ERROR_BASE + 0x500
#define LINK_UTIL_COMP_BASE    LINK_ERROR_BASE + 0x600
#define LINK_FATAL_ERROR       LINK_ERROR_BASE + 0x700
#define LINK_CONN_ERROR_BASE   LINK_ERROR_BASE + 0x800
#define LINK_CONN_COMP_BASE    LINK_ERROR_BASE + 0x900

////////////////////////////////////////////////////////////////////////////
//
// CallBack Prototype for Channel CallBack
//
////////////////////////////////////////////////////////////////////////////

typedef void (*H245SRCALLBACK)
(
    DWORD_PTR   dwH245Instance,
    HRESULT     dwMessage,
    PBYTE       pbyDataBuf,
    DWORD       dwLength
);

// Link Send Callback error codes
#define LINK_SEND_COMPLETE     MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_H245WS, LINK_SEND_COMP_BASE+ 0)
#define LINK_SEND_ABORT        MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_H245WS, LINK_SEND_COMP_BASE+ 5) // Tx aborted the SDU (not implemented)
#define LINK_SEND_WOULD_BLOCK  MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_H245WS, LINK_SEND_COMP_BASE+20)
#define LINK_SEND_CLOSED       MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_H245WS, LINK_SEND_COMP_BASE+22)
#define LINK_SEND_ERROR        MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,   TRUE, FACILITY_H245WS, LINK_SEND_COMP_BASE+23)

// Link Receive Callback error codes
#define LINK_RECV_DATA         MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_H245WS, LINK_RCV_COMP_BASE+ 6) // DATA.INDICATION from H.223 (Should not be zero)
#define LINK_RECV_ABORT        MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_H245WS, LINK_RCV_COMP_BASE+ 7) // Tx aborted the SDU (not implemented)
#define LINK_RECV_ERROR        MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,   TRUE, FACILITY_H245WS, LINK_RCV_COMP_BASE+10) // from AL2 - _CRC error
#define LINK_RECV_WOULD_BLOCK  MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_H245WS, LINK_RCV_COMP_BASE+20)
#define LINK_RECV_CLOSED       MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_H245WS, LINK_RCV_COMP_BASE+22)

typedef void (*H245CONNECTCALLBACK)
(
   DWORD_PTR   dwH245Instance,
   HRESULT     dwMessage,
   struct _ADDR *LocalAddr,
   struct _ADDR *PeerAddr
);

#define LINK_CONNECT_REQUEST   MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_H245WS, LINK_CONN_COMP_BASE+1)
#define LINK_CONNECT_COMPLETE  MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_H245WS, LINK_CONN_COMP_BASE+2)

////////////////////////////////////////////////////////////////////////////
//
// Link Layer Function Prototypes
//
////////////////////////////////////////////////////////////////////////////
LINKDLL VOID H245WSShutdown();

/**************************************************************************
**	Function 	: linkLayerInit
**	Description : This function will initialize the datalink subsystem.
**				  This in turn will make appropriate calls to initialize
**				  the software and hardware subsystems below this layer.
**				  linkLayernit() has to be called before any other service or
**				  System control functions are used.
****************************************************************************/
LINKDLL HRESULT
linkLayerInit
(
    DWORD*           pdwPhysicalId,
    DWORD_PTR       dwH245Instance,
    H245SRCALLBACK  cbReceiveComplete,
    H245SRCALLBACK  cbTransmitComplete
);

typedef
HRESULT
(*PFxnlinkLayerInit)
(
    DWORD*           pdwPhysicalId,
    DWORD_PTR       dwH245Instance,
    H245SRCALLBACK  cbReceiveComplete,
    H245SRCALLBACK  cbTransmitComplete
);

///////////////////////////////////////////////////////////////
///
///	SRP Initialization defines
///
///////////////////////////////////////////////////////////////

#define LINK_INVALID_INSTANCE    MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,   TRUE, FACILITY_H245WS, LINK_ERROR_BASE+1)
#define LINK_DUPLICATE_INSTANCE  MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,   TRUE, FACILITY_H245WS, LINK_ERROR_BASE+2)
#define LINK_MEM_FAILURE         MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,   TRUE, FACILITY_H245WS, ERROR_OUTOFMEMORY)
#define LINK_INVALID_STATE       MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,   TRUE, FACILITY_H245WS, LINK_ERROR_BASE+6)
#define LINK_INSTANCE_TABLE_FULL MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,   TRUE, FACILITY_H245WS, LINK_ERROR_BASE+7)



/**************************************************************************
**	Function 	: linkLayerShutdown
**	Description : This releases all the memory the link layer used for a particular
**				  instance. For using any of the linklayer services in that
**				  instance again, a linkLayerInit has to be called.
**				  This function will shutdown the linklayer session pointed
**				  by the dwPhysicalID.
***************************************************************************/
LINKDLL HRESULT
linkLayerShutdown
(DWORD dwPhysicalId);



typedef
 HRESULT
(*PFxnlinkLayerShutdown)
(DWORD dwPhysicalId);



///////////////////////////////////////////////////////////////
///
///	SRP Termination defines
///
///////////////////////////////////////////////////////////////

/**************************************************************************
**	Function 	: linkLayerGetInstance
**	Description : Returns the link layer instance corresponding to a physical ID
***************************************************************************/
LINKDLL DWORD
linkLayerGetInstance
(DWORD dwPhysicalId);



typedef
DWORD
(*PFxnlinkLayerGetInstance)
(DWORD dwPhysicalId);



/**************************************************************************
**	Function 	: datalinkReceiveRequest
**	Description : Posts one receive message buffer to the link layer subsystem.
**				  This buffer will be filled in by the incoming message for
** 				  the specified channel. H223_DATA_INDICATION will be sendto
**				  the client on receiving a complete PDU. Error messages may also be
**				  reported.
***************************************************************************/
LINKDLL HRESULT
datalinkReceiveRequest
(
    DWORD   dwPhysicalId,
    PBYTE   pbyDataBuf,
    DWORD   dwLength
);

typedef
HRESULT
(*PFxndatalinkReceiveRequest)
(
    DWORD   dwPhysicalId,
    PBYTE   pbyDataBuf,
    DWORD   dwLength
);

// Link Receive Request return codes

#define LINK_RECV_NOBUFF       MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,   TRUE, FACILITY_H245WS, LINK_RCV_ERROR_BASE+ 2) // No room for buffering


/**************************************************************************
**	Function 	: datalinkSendRequest
**	Description : Hands over the message to be sent to the link layer subsystem.
***************************************************************************/
LINKDLL HRESULT
datalinkSendRequest
(
    DWORD   dwPhysicalId,
    PBYTE   pbyDataBuf,
    DWORD   dwLength
);

typedef
HRESULT
(*PFxndatalinkSendRequest)
(
    DWORD   dwPhysicalId,
    PBYTE   pbyDataBuf,
    DWORD   dwLength
);

// Link Send Request return codes

#define LINK_SEND_NOBUFF       MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,   TRUE, FACILITY_H245WS, LINK_SEND_ERROR_BASE+2)


/**************************************************************************
**	Function 	: linkLayerFlushChannel
**	Description : All the posted transmit and/or receive buffers are released.
**					The bitmasks DATALINK_RECEIVE and DATALINK_RECEIVE can
**					be OR'd together to perform both functions in the same call
**************************************************************************/
LINKDLL HRESULT
linkLayerFlushChannel
(DWORD dwPhysicalId, DWORD dwDirectionMask);




typedef
HRESULT
(*PFxnlinkLayerFlushChannel)
(DWORD dwPhysicalId, DWORD dwDirectionMask);




// Bits for dwDirectionMask
#define DATALINK_RECEIVE      0x01  // Flush buffer in receive direction
#define DATALINK_TRANSMIT     0x02  // Flush buffer in Transmit direction
#define DATALINK_TX_ACTIVES   0x04  // Flush buffers actively being transmitted
#define SHUTDOWN_PENDING      0x08  // Shutdown is in progress
#define FLUSH_SYNCH           0x10  // 0: Asynch call, 1: Synchronous call
#define DATALINK_TRANSMIT_ALL (DATALINK_TRANSMIT | DATALINK_TX_ACTIVES)
#define SHUTDOWN_MASK         (DATALINK_RECEIVE | DATALINK_TRANSMIT | SHUTDOWN_PENDING)


// linkLayerFlushChannel Callback

#define LINK_FLUSH_COMPLETE   MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_H245WS, LINK_UTIL_COMP_BASE+1)


/**************************************************************************
**	Function 	: linkLayerFlushAll
**	Description : All the posted transmit and/or receive buffers are released.
**					Same as LinkLayerFlushChannel except:
**					1) Synchronous Call
**					2) Transmit Buffers in progress are flushed
**************************************************************************/
LINKDLL HRESULT
linkLayerFlushAll
(DWORD	dwPhysicalId);



typedef
HRESULT
(*PFxnlinkLayerFlushAll)
(DWORD	dwPhysicalId);



// linkLayerFlushChannel RETURN CODES same as for linkLayerFlushChannel

#define LINK_UNKNOWN_ADDR      MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_H245WS, LINK_UTIL_ERROR_BASE + 1)

LINKDLL HRESULT
linkLayerConnect(DWORD dwPhysicalId, struct _ADDR *pAddr, H245CONNECTCALLBACK callback);

LINKDLL HRESULT
linkLayerListen(DWORD* dwPhysicalId, DWORD_PTR dwH245Instance, struct _ADDR *pAddr, H245CONNECTCALLBACK callback);

LINKDLL HRESULT
linkLayerAccept(DWORD dwPhysicalIdListen, DWORD dwPhysicalIdAccept, H245CONNECTCALLBACK callback);

LINKDLL HRESULT
linkLayerReject(DWORD dwPhysicalIdListen);


#define LL_PDU_SIZE             2048



/**************************************************************************
**
**  Dynamic DLL Function Calls
**
**************************************************************************/
#ifdef UNICODE
#define SRPDLLFILE          L"h245srp.dll"
#define H245WSDLLFILE       L"h245ws.dll"
#else
#define SRPDLLFILE          "h245srp.dll"
#define H245WSDLLFILE       "h245ws.dll"
#endif

#define LINKINITIALIZE      __TEXT("linkLayerInit")
#define LINKSHUTDOWN        __TEXT("linkLayerShutdown")
#define LINKGETINSTANCE     __TEXT("linkLayerGetInstance")
#define LINKRECEIVEREQUEST  __TEXT("datalinkReceiveRequest")
#define LINKSENDREQUEST     __TEXT("datalinkSendRequest")
#define LINKFLUSHCHANNEL    __TEXT("linkLayerFlushChannel")
#define LINKFLUSHALL        __TEXT("linkLayerFlushAll")

#if defined(__cplusplus)
}
#endif  // (__cplusplus)

#endif  // LINKAPI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\mrse.c ===
/***********************************************************************
 *                                                                     *
 * Filename: mrse.c                                                    *
 * Module:   H245 Finite State Machine Subsystem                       *
 *                                                                     *
 ***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *                                                                     *
 * $Workfile:   mrse.c  $
 * $Revision:   1.5  $
 * $Modtime:   13 Feb 1997 19:25:48  $
 * $Log:   S:/STURGEON/SRC/H245/SRC/VCS/mrse.c_v  $
 *
 *    Rev 1.5   13 Feb 1997 19:31:20   MANDREWS
 * Fixed bug in generation of request mode ack and request mode reject;
 * the sequence number was not being copied into the pdu.
 *
 *    Rev 1.4   09 Dec 1996 13:34:46   EHOWARDX
 * Updated copyright notice.
 *
 *    Rev 1.3   04 Jun 1996 14:01:06   EHOWARDX
 * Fixed Release build warnings.
 *
 *    Rev 1.2   30 May 1996 23:39:16   EHOWARDX
 * Cleanup.
 *
 *    Rev 1.1   28 May 1996 14:25:44   EHOWARDX
 * Tel Aviv update.
 *
 *    Rev 1.0   09 May 1996 21:06:32   EHOWARDX
 * Initial revision.
 *
 *    Rev 1.1   09 May 1996 19:48:08   EHOWARDX
 * Change TimerExpiryF function arguements.
 *
 *    Rev 1.0   15 Apr 1996 10:44:52   EHOWARDX
 * Initial revision.
 *                                                                     *
 ***********************************************************************/

#include "precomp.h"

#include "h245api.h"
#include "h245com.h"
#include "h245fsm.h"
#include "mrse.h"



// Out-going/In-coming MRSE states
#define MRSE_IDLE                   0   // IDLE
#define MRSE_WAIT                   1   // AWAITING_RESPONSE



extern unsigned int uT109;

/***********************************************************************
 *
 * LOCAL FUNCTIONS
 *
 ***********************************************************************/

/*
 *  NAME
 *      T109ExpiryF - Callback function called by the timer
 *
 *
 *  PARAMETERS
 *   INPUT   dwInst     current instance of H245
 *   INPUT   id         timer id
 *   INPUT   pObject    pointer to a State Entity
 *
 *
 *  RETURN VALUE
 *       OK
 */

int T109ExpiryF(struct InstanceStruct *pInstance, DWORD_PTR dwTimerId, void *pObject)
{
    return FsmTimerEvent(pInstance, dwTimerId, pObject, T109Expiry);
} // T109ExpiryF()



/***********************************************************************
 *
 * OUT-GOING FINITE STATE MACHINE FUNCTIONS
 *
 ***********************************************************************/

/*
 *  NAME
 *      MRSE0_TRANSFER_requestF - TRANSFER.request from API in IDLE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MRSE0_TRANSFER_requestF          (Object_t *pObject, PDU_t *pPdu)
{
    HRESULT             lError;

    ASSERT(pObject->Entity == MRSE_OUT);
    ASSERT(pObject->State  == MRSE_IDLE);
    H245TRACE(pObject->dwInst, 2, "MRSE0_TRANSFER_request:%d", pObject->Key);

    pObject->pInstance->StateMachine.byMrseOutSequence++;
    pPdu->u.MltmdSystmCntrlMssg_rqst.u.requestMode.sequenceNumber =
        pObject->pInstance->StateMachine.byMrseOutSequence;

    // Send Request Mode PDU to remote
    lError = sendPDU(pObject->pInstance, pPdu);

    // Set timer T109
    pObject->State = MRSE_WAIT;
    FsmStartTimer(pObject, T109ExpiryF, uT109);

    return lError;
} // MRSE0_TRANSFER_request



/*
 *  NAME
 *      MRSE1_TRANSFER_requestF - TRANSFER.request from API in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MRSE1_TRANSFER_requestF          (Object_t *pObject, PDU_t *pPdu)
{
    HRESULT             lError;

    ASSERT(pObject->Entity == MRSE_OUT);
    ASSERT(pObject->State  == MRSE_WAIT);
    H245TRACE(pObject->dwInst, 2, "MRSE1_TRANSFER_request:%d", pObject->Key);

    // Reset timer T109
    FsmStopTimer(pObject);

    pObject->pInstance->StateMachine.byMrseOutSequence++;
    pPdu->u.MltmdSystmCntrlMssg_rqst.u.requestMode.sequenceNumber =
        pObject->pInstance->StateMachine.byMrseOutSequence;

    // Send Request Mode PDU to remote
    lError = sendPDU(pObject->pInstance, pPdu);

    // Set timer T109
    FsmStartTimer(pObject, T109ExpiryF, uT109);

    return lError;
} // MRSE1_TRANSFER_request



/*
 *  NAME
 *      MRSE1_RequestModeAckF - RequestModeAck in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MRSE1_RequestModeAckF     (Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == MRSE_OUT);
    ASSERT(pObject->State  == MRSE_WAIT);
    H245TRACE(pObject->dwInst, 2, "MRSE1_RequestModeAck:%d", pObject->Key);

    if (pPdu->u.MSCMg_rspns.u.requestModeAck.sequenceNumber ==
        pObject->pInstance->StateMachine.byMrseOutSequence)
    {
        // Reset timer T109
        FsmStopTimer(pObject);

        // Send TRANSFER.confirm to H.245 user
        pObject->State = MRSE_IDLE;
        H245FsmConfirm(pPdu, H245_CONF_MRSE, pObject->pInstance, pObject->dwTransId, FSM_OK);
    }

    return 0;
} // MRSE1_RequestModeAck



/*
 *  NAME
 *      MRSE1_RequestModeRejF - RequestModeReject in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MRSE1_RequestModeRejF  (Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == MRSE_OUT);
    ASSERT(pObject->State  == MRSE_WAIT);
    H245TRACE(pObject->dwInst, 2, "MRSE0_RequestModeRej:%d", pObject->Key);

    if (pPdu->u.MSCMg_rspns.u.requestModeReject.sequenceNumber ==
        pObject->pInstance->StateMachine.byMrseOutSequence)
    {
        // Reset timer T109
        FsmStopTimer(pObject);

        // Send REJECT.indication to H.245 user
        // CAUSE = RequestModeReject.cause
        pObject->State = MRSE_IDLE;
        H245FsmConfirm(pPdu, H245_CONF_MRSE_REJECT, pObject->pInstance, pObject->dwTransId, FSM_OK);
    }

    return 0;
} // MRSE1_RequestModeRej



/*
 *  NAME
 *      MRSE1_T109ExpiryF - timer T109 Expiry
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MRSE1_T109ExpiryF                (Object_t *pObject, PDU_t *pPdu)
{
    HRESULT             lError;
    PDU_t *             pOut;
    unsigned short      wNumber = (unsigned short) pObject->Key;

    ASSERT(pObject->Entity == MRSE_OUT);
    ASSERT(pObject->State  == MRSE_WAIT);
    ASSERT(pPdu == NULL);
    H245TRACE(pObject->dwInst, 2, "MRSE1_T109Expiry:%d", pObject->Key);

    // Send RequestModeRelease PDU to remote peer
    pOut = MemAlloc(sizeof(*pOut));
    if (pOut == NULL)
    {
        H245TRACE(pObject->dwInst, 2,
                  "MRSE1_T109ExpiryF: memory allocation failed");
        return H245_ERROR_NOMEM;
    }
    pOut->choice = indication_chosen;
    pOut->u.indication.choice = requestModeRelease_chosen;
    lError = sendPDU(pObject->pInstance, pOut);
    MemFree(pOut);

    // Send REJECT.indication to H.245 user
    //   SOURCE := PROTOCOL
    pObject->State = MRSE_IDLE;
    H245FsmConfirm(NULL, H245_CONF_MRSE_EXPIRED, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return lError;
} // MRSE1_T109Expiry

/***********************************************************************
 *
 * IN-COMING FINITE STATE MACHINE FUNCTIONS
 *
 ***********************************************************************/

/*
 *  NAME
 *      MRSE0_RequestModeF - RequestMode received in IDLE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MRSE0_RequestModeF        (Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == MRSE_IN);
    ASSERT(pObject->State  == MRSE_IDLE);
    H245TRACE(pObject->dwInst, 2, "MRSE0_RequestMode:%d", pObject->Key);

    pObject->byInSequence = (unsigned char)
        pPdu->u.MltmdSystmCntrlMssg_rqst.u.requestMode.sequenceNumber;

    // Send TRANSFER.indication to H.245 user
    pObject->State = MRSE_WAIT;
    H245FsmIndication(pPdu, H245_IND_MRSE, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return 0;
} // MRSE0_RequestMode



/*
 *  NAME
 *      MRSE1_RequestModeF - RequestMode received in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MRSE1_RequestModeF        (Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == MRSE_IN);
    ASSERT(pObject->State  == MRSE_WAIT);
    H245TRACE(pObject->dwInst, 2, "MRSE1_RequestMode:%d", pObject->Key);

    pObject->byInSequence = (unsigned char)
        pPdu->u.MltmdSystmCntrlMssg_rqst.u.requestMode.sequenceNumber;

#if defined(SDL_COMPLIANT)
    // Send REJECT.indication to H.245 user
    H245FsmIndication(pPdu, H245_IND_MRSE_RELEASE, pObject->pInstance, pObject->dwTransId, FSM_OK);
#endif

    // Send TRANSFER.indication to H.245 user
    H245FsmIndication(pPdu, H245_IND_MRSE, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return 0;
} // MRSE1_RequestMode



/*
 *  NAME
 *      MRSE1_RequestModeReleaseF - RequestModeRelease received in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MRSE1_RequestModeReleaseF (Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == MRSE_IN);
    ASSERT(pObject->State  == MRSE_WAIT);
    H245TRACE(pObject->dwInst, 2, "MRSE1_RequestModeRelease:%d", pObject->Key);

    // Send REJECT.indication to H.245 user
    // SOURCE:=PROTOCOL
    pObject->State = MRSE_IDLE;
    H245FsmIndication(pPdu, H245_IND_MRSE_RELEASE, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return 0;
} // MRSE1_RequestModeRelease



/*
 *  NAME
 *      MRSE1_TRANSFER_responseF - TRANSFER.response from API in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MRSE1_TRANSFER_responseF         (Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == MRSE_IN);
    ASSERT(pObject->State  == MRSE_WAIT);
    H245TRACE(pObject->dwInst, 2, "MRSE1_TRANSFER_response:%d", pObject->Key);

    // Send RequestModeAck PDU to remote peer
    pObject->State = MRSE_IDLE;
	pPdu->u.MSCMg_rspns.u.requestModeAck.sequenceNumber = pObject->byInSequence;
    return sendPDU(pObject->pInstance, pPdu);
} // MRSE1_TRANSFER_response



/*
 *  NAME
 *      MRSE1_REJECT_requestF - REJECT.request from API in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MRSE1_REJECT_requestF            (Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == MRSE_IN);
    ASSERT(pObject->State  == MRSE_WAIT);
    H245TRACE(pObject->dwInst, 2, "MRSE1_REJECT_request:%d", pObject->Key);

    // Send RequestModeReject PDU to remote
    pObject->State = MRSE_IDLE;
	pPdu->u.MSCMg_rspns.u.requestModeReject.sequenceNumber = pObject->byInSequence;
    return sendPDU(pObject->pInstance, pPdu);
} // MRSE1_REJECT_request

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\mstrslv.c ===
/***********************************************************************
 *                                                                     *
 * Filename: mstrslv.c                                                 *
 * Module:   H245 Finite State Machine Subsystem                       *
 *                                                                     *
 ***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *                                                                     *
 * $Workfile:   mstrslv.c  $
 * $Revision:   1.12  $
 * $Modtime:   12 Dec 1996 14:37:12  $
 * $Log:   S:/STURGEON/SRC/H245/SRC/VCS/mstrslv.c_v  $
 *
 *    Rev 1.12   12 Dec 1996 15:52:50   EHOWARDX
 * Master Slave Determination kludge.
 *
 *    Rev 1.11   11 Dec 1996 16:50:50   EHOWARDX
 * Went back to original Master/Slave determination algorithm.
 *
 *    Rev 1.10   09 Dec 1996 13:34:48   EHOWARDX
 * Updated copyright notice.
 *
 *    Rev 1.9   26 Nov 1996 17:06:02   EHOWARDX
 * Reversed order of subtraction for DetermineMasterSlave.
 *
 *    Rev 1.8   08 Aug 1996 16:03:40   EHOWARDX
 *
 * Fixed master slave determinate bug (hopefully the last one!)
 *
 *    Rev 1.7   19 Jul 1996 12:12:44   EHOWARDX
 *
 * Changed to use API events defined in H245API.H instead of FSM events
 * which are no longer defined in FSMEXPOR.H.
 *
 *    Rev 1.6   01 Jul 1996 23:35:48   EHOWARDX
 * MSDetAckIncoming bug - was sending indication instead of confirm.
 *
 *    Rev 1.5   01 Jul 1996 23:14:20   EHOWARDX
 * Fixed bug in MSDetOutgoing -- state change was ifdefed out.
 *
 *    Rev 1.4   07 Jun 1996 16:00:26   EHOWARDX
 * Fixed bug with pOut not getting freed in msDetOutgoing.
 *
 *    Rev 1.3   07 Jun 1996 15:40:20   EHOWARDX
 * Fixed bug in msDetRejOutgoing; pOut was not freed if N100 count exceeded.
 *
 *    Rev 1.2   04 Jun 1996 13:57:54   EHOWARDX
 * Fixed Release build warnings.
 *
 *    Rev 1.1   30 May 1996 23:39:16   EHOWARDX
 * Cleanup.
 *
 *    Rev 1.0   09 May 1996 21:06:32   EHOWARDX
 * Initial revision.
 *
 *    Rev 1.11.1.4   09 May 1996 19:48:48   EHOWARDX
 * Change TimerExpiryF function arguements.
 *
 *    Rev 1.11.1.3   25 Apr 1996 17:00:22   EHOWARDX
 * Minor fixes.
 *
 *    Rev 1.11.1.2   15 Apr 1996 10:45:46   EHOWARDX
 * Update.
 *
 *    Rev 1.11.1.1   10 Apr 1996 21:15:46   EHOWARDX
 * Check-in for safety in middle of re-design.
 *                                                                     *
 ***********************************************************************/

#include "precomp.h"

#include "h245api.h"
#include "h245com.h"
#include "h245fsm.h"
#include "mstrslv.h"
#include "pdu.x"



// Master Slave Determination states

#define MSIDLE                      0
#define MSOutgoingAwaiting          1
#define MSIncomingAwaiting          2

#define MAX_RAND                  0x00FFFFFF


extern unsigned int uN100;
extern unsigned int uT106;



/***********************************************************************
 *
 * LOCAL FUNCTIONS
 *
 ***********************************************************************/

/*
 *  NAME
 *      T106ExpiryF - Callback function called by the timer.
 *
 *
 *  PARAMETERS
 *   INPUT   dwInst     current instance of H245
 *   INPUT   id         timer id
 *   INPUT   pObject    pointer to a State Entity
 *
 *
 *  RETURN VALUE
 *       OK
 */

int T106ExpiryF(struct InstanceStruct *pInstance, DWORD_PTR dwTimerId, void *pObject)
{
    return FsmTimerEvent(pInstance, dwTimerId, pObject, T106Expiry);
} // T106ExpiryF()



#define GetTerminal(pObject)  (pObject)->pInstance->StateMachine.sv_TT
#define GetStatus(pObject)    (pObject)->pInstance->StateMachine.sv_STATUS
#define SetStatus(pObject, Status) (pObject)->pInstance->StateMachine.sv_STATUS = (Status)
#define GetRandomNumber(pObject) (pObject)->u.msdse.sv_SDNUM
#define SetRandomNumber(pObject, uRandom) (pObject)->u.msdse.sv_SDNUM = (uRandom)
#define GetCount(pObject) (pObject)->u.msdse.sv_NCOUNT
#define SetCount(pObject, uCount) (pObject)->u.msdse.sv_NCOUNT = (uCount)



/*
 *  NAME
 *      DetermineStatus - determines whether the terminal is a master or a slave or neither
 *
 *
 *  PARAMETERS
 *   INPUT   pdu        pointer to a PDU structure
 *
 *  RETURN VALUE
 *   terminal status
 */

static MS_Status_t DetermineStatus(Object_t *pObject, PDU_t *pPdu)
{
    unsigned int uTemp;
    unsigned char sv_TT = GetTerminal(pObject);

    if (pPdu->u.MltmdSystmCntrlMssg_rqst.u.masterSlaveDetermination.terminalType < sv_TT)
        return pObject->pInstance->StateMachine.sv_STATUS = MASTER;
    if (pPdu->u.MltmdSystmCntrlMssg_rqst.u.masterSlaveDetermination.terminalType > sv_TT)
        return pObject->pInstance->StateMachine.sv_STATUS = SLAVE;
    uTemp = (pPdu->u.MltmdSystmCntrlMssg_rqst.u.masterSlaveDetermination.statusDeterminationNumber - GetRandomNumber(pObject)) & 0xFFFFFF;
    if (uTemp > 0x800000)
        return pObject->pInstance->StateMachine.sv_STATUS = SLAVE;
    if (uTemp < 0x800000 && uTemp != 0)
        return pObject->pInstance->StateMachine.sv_STATUS = MASTER;
    return pObject->pInstance->StateMachine.sv_STATUS = INDETERMINATE;
}



/***********************************************************************
 *
 * FINITE STATE MACHINE FUNCTIONS
 *
 ***********************************************************************/

/*
 *  NAME
 *      detRequestIdle - request Master/Slave Determination from API in idle state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT detRequestIdle(Object_t *pObject, PDU_t *pPdu)
{
    HRESULT             lError;

    ASSERT(pObject->Entity == MSDSE);
    ASSERT(pObject->State  == MSIDLE);

    SetRandomNumber(pObject, GetTickCount() & MAX_RAND);
    SetCount(pObject, 1);               // Initialize retry counter
    SetStatus(pObject, INDETERMINATE);
    H245TRACE(  pObject->dwInst, 2,
                "detRequestIdle: TerminalType=%d StatusDeterminationNumber=%d",
                GetTerminal(pObject), GetRandomNumber(pObject));

    /* Send a Master/Slave determination PDU */
    H245TRACE(pObject->dwInst, 2, "Master/Slave Determination to Send/Rec module");
    pdu_req_mstslv (pPdu, GetTerminal(pObject), GetRandomNumber(pObject));
    lError = sendPDU(pObject->pInstance, pPdu);

    /* set timer T106 */
    pObject->State = MSOutgoingAwaiting;
    FsmStartTimer(pObject, T106ExpiryF, uT106);

    return lError;
} // detRequestIdle()

/*
 *  NAME
 *      msDetIdle - received Master/Slave Determination PDU in idle state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT msDetIdle(Object_t *pObject, PDU_t *pPdu)
{
    PDU_t *             pOut;
    HRESULT             lError;

    ASSERT(pObject->Entity == MSDSE);
    ASSERT(pObject->State  == MSIDLE);

    pOut = (PDU_t *) MemAlloc(sizeof(PDU_t));
    if (pOut == NULL)
    {
        DetermineStatus(pObject, pPdu);
        return H245_ERROR_NOMEM;
    }

    SetRandomNumber(pObject, GetTickCount() & MAX_RAND);
    switch (DetermineStatus(pObject, pPdu))
    {
    case MASTER:
        /* Build MasterSlave Determination Ack */
        H245TRACE(pObject->dwInst, 2, "msDetIdle: sending Ack: SLAVE");
        pdu_rsp_mstslv_ack(pOut, slave_chosen);
        break;

    case SLAVE:
        /* Build MasterSlave Determination Ack */
        H245TRACE(pObject->dwInst, 2, "msDetIdle: sending Ack: MASTER");
        pdu_rsp_mstslv_ack(pOut, master_chosen);
        break;

    default:
        /* Send a masterSlaveDet Reject */
        pdu_rsp_mstslv_rej(pOut);
        lError = sendPDU(pObject->pInstance, pOut);
        MemFree(pOut);
        return lError;
    } // switch

    /* Send MasterSlave Determination Ack to remote */
    lError = sendPDU(pObject->pInstance, pOut);
    MemFree(pOut);

    pObject->State = MSIncomingAwaiting;

#if defined(SDL_COMPLIANT)
    /* Send DETERMINE indication to client - unnecessary */
    H245FsmIndication(pPdu, H245_IND_MSTSLV, pObject->pInstance, pObject->dwTransId, FSM_OK);
#endif

    /* set timer T106 */
    FsmStartTimer(pObject, T106ExpiryF, uT106);
    return lError;
}



/*
 *  NAME
 *      msDetAckOutgoing - received Master/Slave Determination Ack pdu in outgoing state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */
HRESULT msDetAckOutgoing(Object_t *pObject, PDU_t *pPdu)
{
    PDU_t *             pOut;
    HRESULT             lError;

    ASSERT(pObject->Entity == MSDSE);
    ASSERT(pObject->State  == MSOutgoingAwaiting);

    pOut = (PDU_t *) MemAlloc(sizeof(PDU_t));
    if (pOut == NULL)
    {
        return H245_ERROR_NOMEM;
    }

    /* reset timer */
    FsmStopTimer(pObject);

    /* Decision is opposite of MasterSlaveDeterminationAck.decision */
    switch(pPdu->u.MSCMg_rspns.u.mstrSlvDtrmntnAck.decision.choice)
    {
    case master_chosen:
        pObject->pInstance->StateMachine.sv_STATUS = MASTER;
        H245TRACE(pObject->dwInst, 2, "msDetAckOutgoing: sending Ack: SLAVE");
        pdu_rsp_mstslv_ack(pOut, slave_chosen);
        break;

    case slave_chosen:
        pObject->pInstance->StateMachine.sv_STATUS = SLAVE;
        H245TRACE(pObject->dwInst, 2, "msDetAckOutgoing: sending Ack: MASTER");
        pdu_rsp_mstslv_ack(pOut, master_chosen);
        break;

    default:
        H245TRACE(pObject->dwInst, 1, "msDetAckOutgoing: Invalid Master Slave Determination Ack received");
        return H245_ERROR_PARAM;
    }

    /* Send MasterSlave Determination Ack to remote */
    lError = sendPDU(pObject->pInstance, pOut);
    MemFree(pOut);

    /* Send DETERMINE confirm to client */
    pObject->State = MSIDLE;
    H245FsmConfirm(pPdu, H245_CONF_INIT_MSTSLV, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return lError;
}



/*
 *  NAME
 *      msDetOutgoing- received Master/Slave Determination pdu in outgoing state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT msDetOutgoing(Object_t *pObject, PDU_t *pPdu)
{
    PDU_t *             pOut;
    HRESULT             lError;

    ASSERT(pObject->Entity == MSDSE);
    ASSERT(pObject->State  == MSOutgoingAwaiting);

	if (pObject->pInstance->bMasterSlaveKludge == 0)
	{
		// Ignore this message
		return NOERROR;
	}

    pOut = (PDU_t *) MemAlloc(sizeof(PDU_t));
    if (pOut == NULL)
    {
        return H245_ERROR_NOMEM;
    }

    /* reset timer T106 */
    FsmStopTimer(pObject);

    switch (DetermineStatus(pObject, pPdu))
    {
    case MASTER:
        H245TRACE(pObject->dwInst, 2, "msDetOutgoing: sending Ack: SLAVE");
        pdu_rsp_mstslv_ack(pOut, slave_chosen);
        break;

    case SLAVE:
        H245TRACE(pObject->dwInst, 2, "msDetOutgoing: sending Ack: MASTER");
        pdu_rsp_mstslv_ack(pOut, master_chosen);
        break;

    default:
        if (GetCount(pObject) >= uN100)
        {
            MemFree(pOut);

            /* Send ERROR.indication(F) to client */
            H245TRACE(pObject->dwInst, 2, "msDetOutgoing: Counter expired; Session Failed");
            H245FsmConfirm(NULL,H245_CONF_INIT_MSTSLV, pObject->pInstance, pObject->dwTransId, MS_FAILED);

            /* Send REJECT.indication to client - unnecessary */

            pObject->State = MSIDLE;
            lError = 0;
        }
        else
        {
            /* generate a new random number */
            H245TRACE(pObject->dwInst, 2, "Resending MasterSlaveDetermination");
            SetRandomNumber(pObject, GetTickCount() & MAX_RAND);
            SetCount(pObject, GetCount(pObject) + 1);

            /* Send MasterSlave Determination PDU to remote */
            pdu_req_mstslv (pOut, GetTerminal(pObject), GetRandomNumber(pObject));
            lError = sendPDU(pObject->pInstance, pOut);
            MemFree(pOut);

            /* set timer T106 */
            pObject->State = MSOutgoingAwaiting;
            FsmStartTimer(pObject, T106ExpiryF, uT106);
        }
        return lError;
    } // switch

    /* Send MasterSlave Determination Ack to remote */
    lError = sendPDU(pObject->pInstance, pOut);
    MemFree(pOut);

    pObject->State = MSIncomingAwaiting;

#if defined(SDL_COMPLIANT)
    /* Send DETERMINE indication to client */
    H245FsmIndication(pPdu, H245_IND_MSTSLV, pObject->pInstance, pObject->dwTransId, FSM_OK);
#endif

    /* set timer T106 */
    FsmStartTimer(pObject, T106ExpiryF, uT106);

    return lError;
}



/*
 *  NAME
 *      msDetRejOutgoing- received Master/Slave Determination Reject pdu in outgoing state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */


HRESULT msDetRejOutgoing(Object_t *pObject, PDU_t *pPdu)
{
    PDU_t *             pOut;
    HRESULT             lError;

    ASSERT(pObject->Entity == MSDSE);
    ASSERT(pObject->State  == MSOutgoingAwaiting);

    pOut = (PDU_t *) MemAlloc(sizeof(PDU_t));
    if (pOut == NULL)
    {
        return H245_ERROR_NOMEM;
    }

    /* reset timer T106 */
    FsmStopTimer(pObject);

    if (GetCount(pObject) >= uN100)
    {
        MemFree(pOut);

        H245TRACE(pObject->dwInst, 2, "msDetRejOutgoing: Counter expired; Session Failed");
        pObject->State = MSIDLE;

        /* Send ERROR.indication(f) to client */
        H245FsmConfirm(pPdu,H245_CONF_INIT_MSTSLV, pObject->pInstance, pObject->dwTransId, MS_FAILED);

#if defined(SDL_COMPLIANT)
        /* Send REJECT.indication to client - not necessary */
        H245FsmIndication(NULL, H245_IND_MSTSLV, pObject->pInstance, pObject->dwTransId, REJECT);
#endif

        lError = 0;
    }
    else
    {
        H245TRACE(pObject->dwInst, 2, "msDetRejOutgoint: Re-sending a MasterSlaveDetermination");

        /* generate a new random number */
        SetRandomNumber(pObject, GetTickCount() & MAX_RAND);
        SetCount(pObject, GetCount(pObject) + 1);

        /* Send MasterSlave Determination PDU to remote */
        pdu_req_mstslv (pOut, GetTerminal(pObject), GetRandomNumber(pObject));
        lError = sendPDU(pObject->pInstance,pOut);
        MemFree(pOut);

        /* set timer T106 */
        FsmStartTimer(pObject, T106ExpiryF, uT106);
    }

    return lError;
}



/*
 *  NAME
 *      msDetReleaseOutgoing- received Master/Slave Determination release pdu in outgoing state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT msDetReleaseOutgoing(Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == MSDSE);
    ASSERT(pObject->State  == MSOutgoingAwaiting);
    H245TRACE(pObject->dwInst, 2, "msDetReleaseOutgoing: Master/Slave Determination Release received; session failed");

    /* reset timer T106 */
    FsmStopTimer(pObject);

    /* Send ERROR.indication(B) to client */
    pObject->State = MSIDLE;
    H245FsmConfirm(pPdu, H245_CONF_INIT_MSTSLV, pObject->pInstance, pObject->dwTransId, MS_FAILED);

#if defined(SDL_COMPLIANT)
    /* Send REJECT.indication to client - not necessary */
    H245FsmIndication(NULL, H245_IND_MSTSLV, pObject->pInstance, pObject->dwTransId, REJECT);
#endif

    return 0;
}



/*
 *  NAME
 *      t106ExpiryOutgoing- timer expired for an outgoing M/S determination pdu
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT t106ExpiryOutgoing(Object_t *pObject, PDU_t *pPdu)
{
    PDU_t *             pOut;
    HRESULT             lError;

    ASSERT(pObject->Entity == MSDSE);
    ASSERT(pObject->State  == MSOutgoingAwaiting);
    ASSERT(pPdu            == NULL);
    H245TRACE(pObject->dwInst, 2, "t106ExpiryOutgoing: Timer expired before receiving Ack; session failed");

    pOut = (PDU_t *) MemAlloc(sizeof(PDU_t));
    if (pOut == NULL)
    {
        return H245_ERROR_NOMEM;
    }

    /* Send MasterSlave Determination Release to remote */
    pOut->choice = indication_chosen;
    pOut->u.indication.choice = mstrSlvDtrmntnRls_chosen;
    lError = sendPDU(pObject->pInstance, pOut);
    MemFree(pOut);

    /* Send ERROR.indication(A) to client */
    pObject->State = MSIDLE;
    H245FsmConfirm(NULL,H245_CONF_INIT_MSTSLV, pObject->pInstance, pObject->dwTransId, TIMER_EXPIRY);

#if defined(SDL_COMPLIANT)
    /* Send REJECT.indication to client - not necessary */
    H245FsmIndication(NULL, H245_IND_MSTSLV, pObject->pInstance, pObject->dwTransId, REJECT);
#endif

    return lError;
}

/*
*  NAME
*      msDetAckIncoming- received Master/Slave Determination Ack pdu in incoming state
*
*
*  PARAMETERS
*   INPUT   pObject        pointer to a State Entity
*
*  RETURN VALUE
*       error return codes defined in h245com.h
*/

HRESULT msDetAckIncoming(Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == MSDSE);
    ASSERT(pObject->State  == MSIncomingAwaiting);

    /* reset timer T106 */
    FsmStopTimer(pObject);

    switch (GetStatus(pObject))
    {
    case  master_chosen:
        if (pPdu->u.MSCMg_rspns.u.mstrSlvDtrmntnAck.decision.choice == master_chosen)
        {
            H245TRACE(pObject->dwInst, 2, "msDetAckIncoming: Terminal is a MASTER");

            /* Send DETERMINE.confirm to client */
            pObject->State = MSIDLE;
            H245FsmConfirm(pPdu, H245_CONF_INIT_MSTSLV, pObject->pInstance, pObject->dwTransId, FSM_OK);
            return 0;
        }
        break;

    case slave_chosen:
        if (pPdu->u.MSCMg_rspns.u.mstrSlvDtrmntnAck.decision.choice == slave_chosen)
        {
            H245TRACE(pObject->dwInst, 2, "msDetAckIncoming: Terminal is a SLAVE");

            /* Send DETERMINE.confirm to client */
            pObject->State = MSIDLE;
            H245FsmConfirm(pPdu, H245_CONF_INIT_MSTSLV, pObject->pInstance, pObject->dwTransId, FSM_OK);
            return 0;
        }
        break;

    default:
        H245TRACE(pObject->dwInst, 2, "msDetAckIncoming: Invalid MasterSlave Determination Ack received");
        return H245_ERROR_PARAM;
    } // switch

    H245TRACE(pObject->dwInst, 2, "msDetAckIncoming: bad decision in MasterSlave Determination Ack; Session failed");

    /* Send ERROR.indication(E) to client */
    pObject->State = MSIDLE;
    H245FsmConfirm(pPdu, H245_CONF_INIT_MSTSLV, pObject->pInstance, pObject->dwTransId, SESSION_FAILED);

#if defined(SDL_COMPLIANT)
    /* Send REJECT.indication to client - not necessary */
    H245FsmIndication(NULL, H245_IND_MSTSLV, pObject->pInstance, pObject->dwTransId, REJECT);
#endif

return 0;
}



/*
 *  NAME
 *      msDetIncoming- received Master/Slave Determination pdu in incoming state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT msDetIncoming(Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == MSDSE);
    ASSERT(pObject->State  == MSIncomingAwaiting);
    H245TRACE(pObject->dwInst, 2, "msDetIncoming: received MasterSlave Determination in INCOMING state; Session failed");

    /* reset timer T106 */
    FsmStopTimer(pObject);

    /* Send ERROR.indication(C) to client */
    pObject->State = MSIDLE;
    H245FsmIndication(pPdu,H245_IND_MSTSLV, pObject->pInstance, pObject->dwTransId, MS_FAILED);

#if defined(SDL_COMPLIANT)
    /* Send REJECT.indication to client - not necessary */
    H245FsmIndication(NULL, H245_IND_MSTSLV, pObject->pInstance, pObject->dwTransId, REJECT);
#endif

    return 0;
}



/*
 *  NAME
 *      msDetRejIncoming- received Master/Slave Determination Reject pdu in incoming state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT msDetRejIncoming(Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == MSDSE);
    ASSERT(pObject->State  == MSIncomingAwaiting);
    H245TRACE(pObject->dwInst, 2, "msDetRejIncoming: received MasterSlave Reject: Session Failed");

    /* reset timer T106 */
    FsmStopTimer(pObject);

    /* Send ERROR.indication(D) to client */
    pObject->State = MSIDLE;
    H245FsmIndication(pPdu,H245_IND_MSTSLV, pObject->pInstance, pObject->dwTransId, MS_FAILED);

#if defined(SDL_COMPLIANT)
    /* Send REJECT.indication to client - not necessary */
    H245FsmIndication(NULL, H245_IND_MSTSLV, pObject->pInstance, pObject->dwTransId, REJECT);
#endif

    return 0;
}



/*
 *  NAME
 *      msDetReleaseIncoming- received Master/Slave Determination Release pdu in incoming state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT msDetReleaseIncoming(Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == MSDSE);
    ASSERT(pObject->State  == MSIncomingAwaiting);
    H245TRACE(pObject->dwInst, 2, "msDetReleaseIncoming: received MasterSlave Release; Session Failed");

    /* reset timer T106 */
    FsmStopTimer(pObject);

    /* Send ERROR.indication(B) to client */
    pObject->State = MSIDLE;
    H245FsmIndication(pPdu,H245_IND_MSTSLV, pObject->pInstance, pObject->dwTransId, MS_FAILED);

#if defined(SDL_COMPLIANT)
    /* Send REJECT.indication to client - not necessary */
    H245FsmIndication(NULL, H245_IND_MSTSLV, pObject->pInstance, pObject->dwTransId, REJECT);
#endif

    return 0;
}



/*
 *  NAME
 *      t106ExpiryIncoming - timer expired while waiting for second Ack
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT t106ExpiryIncoming(Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == MSDSE);
    ASSERT(pObject->State  == MSIncomingAwaiting);
    ASSERT(pPdu            == NULL);
    H245TRACE(pObject->dwInst, 2, "t106ExpiryIncoming: timer expired waiting for Ack; Session failed");

    /* Send ERROR.indication(A) to client */
    pObject->State = MSIDLE;
    H245FsmIndication(NULL, H245_IND_MSTSLV, pObject->pInstance, pObject->dwTransId, TIMER_EXPIRY);

#if defined(SDL_COMPLIANT)
    /* Send REJECT.indication to client - not necessary */
    H245FsmIndication(NULL, H245_IND_MSTSLV, pObject->pInstance, pObject->dwTransId, REJECT);
#endif

    return 0;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\mrse.h ===
/***********************************************************************
 *                                                                     *
 * Filename: mrse.h                                                    *
 * Module:   H245 Finite State Machine Subsystem                       *
 *                                                                     *
 ***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *                                                                     *
 * $Workfile:   MRSE.H  $
 * $Revision:   1.2  $
 * $Modtime:   09 Dec 1996 13:40:40  $
 * $Log:   S:/STURGEON/SRC/H245/INCLUDE/VCS/MRSE.H_v  $
 * 
 *    Rev 1.2   09 Dec 1996 13:41:00   EHOWARDX
 * Updated copyright notice.
 * 
 *    Rev 1.1   30 May 1996 23:38:24   EHOWARDX
 * Cleanup.
 * 
 *    Rev 1.0   09 May 1996 21:04:52   EHOWARDX
 * Initial revision.
 * 
 *    Rev 1.1   15 Apr 1996 10:44:02   EHOWARDX
 * Update.
 * 
 *    Rev 1.0   10 Apr 1996 21:11:14   EHOWARDX
 * Initial revision.
 *                                                                     *
 ***********************************************************************/

// Out-going Request Mode (MRSE_OUT) state functions
HRESULT MRSE0_TRANSFER_requestF         (Object_t *pObject, PDU_t *pPdu);
HRESULT MRSE1_TRANSFER_requestF         (Object_t *pObject, PDU_t *pPdu);
HRESULT MRSE1_RequestModeAckF           (Object_t *pObject, PDU_t *pPdu);
HRESULT MRSE1_RequestModeRejF           (Object_t *pObject, PDU_t *pPdu);
HRESULT MRSE1_T109ExpiryF               (Object_t *pObject, PDU_t *pPdu);

// In-coming Request Mode (MRSE_OUT) state functions
HRESULT MRSE0_RequestModeF              (Object_t *pObject, PDU_t *pPdu);
HRESULT MRSE1_RequestModeF              (Object_t *pObject, PDU_t *pPdu);
HRESULT MRSE1_RequestModeReleaseF       (Object_t *pObject, PDU_t *pPdu);
HRESULT MRSE1_TRANSFER_responseF        (Object_t *pObject, PDU_t *pPdu);
HRESULT MRSE1_REJECT_requestF           (Object_t *pObject, PDU_t *pPdu);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\mstrslv.h ===
/***********************************************************************
 *                                                                     *
 * Filename: mstrslv.h                                                 *
 * Module:   H245 Finite State Machine Subsystem                       *
 *                                                                     *
 ***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *                                                                     *
 * $Workfile:   MSTRSLV.H  $
 * $Revision:   1.2  $
 * $Modtime:   09 Dec 1996 13:40:40  $
 * $Log:   S:/STURGEON/SRC/H245/INCLUDE/VCS/MSTRSLV.H_v  $
 * 
 *    Rev 1.2   09 Dec 1996 13:41:00   EHOWARDX
 * Updated copyright notice.
 * 
 *    Rev 1.1   30 May 1996 23:38:24   EHOWARDX
 * Cleanup.
 * 
 *    Rev 1.0   09 May 1996 21:04:54   EHOWARDX
 * Initial revision.
 * 
 *    Rev 1.4.1.2   15 Apr 1996 10:43:40   EHOWARDX
 * Update.
 * 
 *    Rev 1.4.1.1   10 Apr 1996 21:08:34   EHOWARDX
 * Deleted No-op functions and moved state definitions to .C file.
 * 
 *    Rev 1.4.1.0   05 Apr 1996 12:14:32   helgebax
 * Branched.
 *                                                                     *
 ***********************************************************************/

// Master Slave Determination state functions
HRESULT detRequestIdle                  (Object_t *pObject, PDU_t *pPdu);
HRESULT msDetIdle                       (Object_t *pObject, PDU_t *pPdu);
HRESULT msDetAckOutgoing                (Object_t *pObject, PDU_t *pPdu);
HRESULT msDetOutgoing                   (Object_t *pObject, PDU_t *pPdu);
HRESULT msDetRejOutgoing                (Object_t *pObject, PDU_t *pPdu);
HRESULT msDetReleaseOutgoing            (Object_t *pObject, PDU_t *pPdu);
HRESULT t106ExpiryOutgoing              (Object_t *pObject, PDU_t *pPdu);
HRESULT msDetAckIncoming                (Object_t *pObject, PDU_t *pPdu);
HRESULT msDetIncoming                   (Object_t *pObject, PDU_t *pPdu);
HRESULT msDetRejIncoming                (Object_t *pObject, PDU_t *pPdu);
HRESULT msDetReleaseIncoming            (Object_t *pObject, PDU_t *pPdu);
HRESULT t106ExpiryIncoming              (Object_t *pObject, PDU_t *pPdu);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\muxentry.c ===
/***********************************************************************
 *                                                                     *
 * Filename: muxentry.c                                                *
 * Module:   H245 Finite State Machine Subsystem                       *
 *                                                                     *
 ***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *                                                                     *
 * $Workfile:   MUXENTRY.C  $
 * $Revision:   1.5  $
 * $Modtime:   09 Dec 1996 13:34:24  $
 * $Log:   S:/STURGEON/SRC/H245/SRC/VCS/MUXENTRY.C_v  $
 *
 *    Rev 1.5   09 Dec 1996 13:34:50   EHOWARDX
 * Updated copyright notice.
 *
 *    Rev 1.4   19 Jul 1996 12:12:46   EHOWARDX
 *
 * Changed to use API events defined in H245API.H instead of FSM events
 * which are no longer defined in FSMEXPOR.H.
 *
 *    Rev 1.3   14 Jun 1996 18:58:30   EHOWARDX
 * Geneva Update.
 *
 *    Rev 1.2   04 Jun 1996 13:57:06   EHOWARDX
 * Fixed Release build warnings.
 *
 *    Rev 1.1   30 May 1996 23:39:18   EHOWARDX
 * Cleanup.
 *
 *    Rev 1.0   09 May 1996 21:06:34   EHOWARDX
 * Initial revision.
 *
 *    Rev 1.14.1.3   09 May 1996 19:48:36   EHOWARDX
 * Change TimerExpiryF function arguements.
 *
 *    Rev 1.14.1.2   15 Apr 1996 10:46:00   EHOWARDX
 * Update.
 *
 *    Rev 1.14.1.1   10 Apr 1996 21:15:00   EHOWARDX
 * Check-in for safety in middle of re-design.
 *
 *    Rev 1.14.1.0   05 Apr 1996 20:52:56   EHOWARDX
 * Branched.
 *
 *    Rev 1.14   02 Apr 1996 12:01:58   helgebax
 * documented code
 *
 *    Rev 1.13   28 Mar 1996 11:20:52   helgebax
 * removed mux release, fixed return values
 *
 *    Rev 1.12   19 Mar 1996 18:09:46   helgebax
 *
 * removed include file: h245time.h
 *
 *    Rev 1.11   19 Mar 1996 17:31:36   helgebax
 *
 * added new timers
 *
 *    Rev 1.10   13 Mar 1996 11:49:14   helgebax
 * s can also access already deleted objects
 *
 *    Rev 1.9   13 Mar 1996 08:58:46   helgebax
 * No change.
 *
 *    Rev 1.8   11 Mar 1996 14:31:32   helgebax
 * removed prototype def for release function (moved to pdu.x)
 *
 *    Rev 1.7   07 Mar 1996 13:23:12   helgebax
 * changed pObject->pdu_struct to NULL in timerExpiry function because the
 * pdu pointer has been deleted
 *
 *    Rev 1.6   01 Mar 1996 13:22:46   unknown
 *
 * Changed to used pdu_id to save muxentry number so when timeout occurs
 * we can send the correct muxentry number in the MultiplexEntrySendRelease.
 *
 *    Rev 1.5   01 Mar 1996 11:47:56   unknown
 * Since nSequence was removed from header, I have commented out
 * all references to it in the code. Also, state ASSERTs have been
 * changed to reflect the fact that state changes occur BEFORE
 * calling the state function, rather than AFTER.
 *
 *    Rev 1.4   29 Feb 1996 20:57:20   helgebax
 * No change.
 *
 *    Rev 1.3   29 Feb 1996 18:19:46   EHOWARDX
 * Made changes requested by Hani.
 *
 *    Rev 1.2   28 Feb 1996 15:47:04   EHOWARDX
 *
 * First pass MTSE implementation complete.
 *                                                                     *
 ***********************************************************************/

#include "precomp.h"

#include "h245api.h"
#include "h245com.h"
#include "h245fsm.h"
#include "muxentry.h"



// Out-going/In-coming MTSE states
#define MTSE_IDLE                   0   // IDLE
#define MTSE_WAIT                   1   // AWAITING_RESPONSE



extern unsigned int uT104;

/***********************************************************************
 *
 * LOCAL FUNCTIONS
 *
 ***********************************************************************/

/*
 *  NAME
 *      T103ExpiryF - Callback function called by the timer
 *
 *
 *  PARAMETERS
 *   INPUT   dwInst     current instance of H245
 *   INPUT   id         timer id
 *   INPUT   pObject    pointer to a State Entity
 *
 *
 *  RETURN VALUE
 *       OK
 */

int T104ExpiryF(struct InstanceStruct *pInstance, DWORD_PTR dwTimerId, void *pObject)
{
    return FsmTimerEvent(pInstance, dwTimerId, pObject, T104Expiry);
} // T104ExpiryF()



/***********************************************************************
 *
 * OUT-GOING FINITE STATE MACHINE FUNCTIONS
 *
 ***********************************************************************/

/*
 *  NAME
 *      MTSE0_TRANSFER_requestF - TRANSFER.request from API in IDLE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MTSE0_TRANSFER_requestF          (Object_t *pObject, PDU_t *pPdu)
{
    HRESULT                       lError;
    unsigned int                  uIndex;
    MultiplexEntryDescriptorLink  pLink;

    ASSERT(pObject->Entity  == MTSE_OUT);
    ASSERT(pObject->State == MTSE_IDLE);
    H245TRACE(pObject->dwInst, 2, "MTSE0_TRANSFER_request:%d", pObject->Key);

    pObject->pInstance->StateMachine.byMtseOutSequence++;
    pPdu->u.MltmdSystmCntrlMssg_rqst.u.multiplexEntrySend.sequenceNumber =
        pObject->pInstance->StateMachine.byMtseOutSequence;

    // Save information for release
    uIndex = 0;
    pLink = pPdu->u.MltmdSystmCntrlMssg_rqst.u.multiplexEntrySend.multiplexEntryDescriptors;
    while (pLink)
    {
      pObject->u.mtse.multiplexTableEntryNumber.value[uIndex++] =
        pLink->value.multiplexTableEntryNumber;
      pLink = pLink->next;
    }
    pObject->u.mtse.multiplexTableEntryNumber.count = (unsigned short)uIndex;

    // Send MultiplexEntrySend PDU to remote
    lError = sendPDU(pObject->pInstance, pPdu);

    // Set timer T104
    pObject->State = MTSE_WAIT;
    FsmStartTimer(pObject, T104ExpiryF, uT104);

    return lError;
} // MTSE0_TRANSFER_request



/*
 *  NAME
 *      MTSE1_TRANSFER_requestF - TRANSFER.request from API in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MTSE1_TRANSFER_requestF          (Object_t *pObject, PDU_t *pPdu)
{
    HRESULT                       lError;
    unsigned int                  uIndex;
    MultiplexEntryDescriptorLink  pLink;

    ASSERT(pObject->Entity  == MTSE_OUT);
    ASSERT(pObject->State == MTSE_WAIT);
    H245TRACE(pObject->dwInst, 2, "MTSE1_TRANSFER_request:%d", pObject->Key);

    // Reset timer T104
    FsmStopTimer(pObject);

    pObject->pInstance->StateMachine.byMtseOutSequence++;
    pPdu->u.MltmdSystmCntrlMssg_rqst.u.multiplexEntrySend.sequenceNumber =
        pObject->pInstance->StateMachine.byMtseOutSequence;

    // Save information for release
    uIndex = 0;
    pLink = pPdu->u.MltmdSystmCntrlMssg_rqst.u.multiplexEntrySend.multiplexEntryDescriptors;
    while (pLink)
    {
      pObject->u.mtse.multiplexTableEntryNumber.value[uIndex++] =
        pLink->value.multiplexTableEntryNumber;
      pLink = pLink->next;
    }
    pObject->u.mtse.multiplexTableEntryNumber.count = (unsigned short)uIndex;

    // Send MultiplexEntrySend PDU to remote
    lError = sendPDU(pObject->pInstance, pPdu);

    // Set timer T104
    FsmStartTimer(pObject, T104ExpiryF, uT104);

    return lError;
} // MTSE1_TRANSFER_request



/*
 *  NAME
 *      MTSE1_MultiplexEntrySendAckF - MultiplexEntrySendAck in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MTSE1_MultiplexEntrySendAckF     (Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity  == MTSE_OUT);
    ASSERT(pObject->State == MTSE_WAIT);
    H245TRACE(pObject->dwInst, 2, "MTSE1_MultiplexEntrySendAck:%d", pObject->Key);

    if (pPdu->u.MltmdSystmCntrlMssg_rqst.u.multiplexEntrySend.sequenceNumber ==
        pObject->pInstance->StateMachine.byMtseOutSequence)
    {
        // Reset timer T104
        FsmStopTimer(pObject);

        // Send TRANSFER.confirm to H.245 user
        pObject->State = MTSE_IDLE;
        H245FsmConfirm(pPdu, H245_CONF_MUXTBL_SND, pObject->pInstance, pObject->dwTransId, FSM_OK);
    }

    return 0;
} // MTSE1_MultiplexEntrySendAck



/*
 *  NAME
 *      MTSE1_MultiplexEntrySendRejF - MultiplexEntrySendReject in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MTSE1_MultiplexEntrySendRejF  (Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity  == MTSE_OUT);
    ASSERT(pObject->State == MTSE_WAIT);
    H245TRACE(pObject->dwInst, 2, "MTSE0_MultiplexEntrySendRej:%d", pObject->Key);

    if (pPdu->u.MltmdSystmCntrlMssg_rqst.u.multiplexEntrySend.sequenceNumber ==
        pObject->pInstance->StateMachine.byMtseOutSequence)
    {
        // Reset timer T104
        FsmStopTimer(pObject);

        // Send REJECT.indication to H.245 user
        // CAUSE = MultiplexEntrySendReject.cause
        pObject->State = MTSE_IDLE;
        H245FsmConfirm(pPdu, H245_CONF_MUXTBL_SND, pObject->pInstance, pObject->dwTransId, REJECT);
    }

    return 0;
} // MTSE1_MultiplexEntrySendRej



/*
 *  NAME
 *      MTSE1_T104ExpiryF - timer T104 Expiry
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MTSE1_T104ExpiryF                (Object_t *pObject, PDU_t *pPdu)
{
    HRESULT             lError;
    PDU_t *             pOut;
    unsigned short      wNumber = (unsigned short) pObject->Key;

    ASSERT(pObject->Entity  == MTSE_OUT);
    ASSERT(pObject->State == MTSE_WAIT);
    ASSERT(pPdu == NULL);
    H245TRACE(pObject->dwInst, 2, "MTSE1_T104Expiry:%d", pObject->Key);

    // Send MultiplexEntrySendRelease PDU to remote peer
    pOut = MemAlloc(sizeof(*pOut));
    if (pOut == NULL)
    {
        H245TRACE(pObject->dwInst, 2,
                  "MTSE1_T104ExpiryF: memory allocation failed");
        return H245_ERROR_NOMEM;
    }
    pOut->choice = indication_chosen;
    pOut->u.indication.choice = mltplxEntrySndRls_chosen;
    pOut->u.indication.u.mltplxEntrySndRls = pObject->u.mtse;
    lError = sendPDU(pObject->pInstance, pOut);
    MemFree(pOut);

    // Send REJECT.indication to H.245 user
    // SOURCE = PROTOCOL
    pObject->State = MTSE_IDLE;
    H245FsmConfirm(NULL, H245_CONF_MUXTBL_SND, pObject->pInstance, pObject->dwTransId, TIMER_EXPIRY);

    return lError;
} // MTSE1_T104Expiry

/***********************************************************************
 *
 * IN-COMING FINITE STATE MACHINE FUNCTIONS
 *
 ***********************************************************************/

/*
 *  NAME
 *      MTSE0_MultiplexEntrySendF - MultiplexEntrySend received in IDLE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MTSE0_MultiplexEntrySendF        (Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity  == MTSE_IN);
    ASSERT(pObject->State == MTSE_IDLE);
    H245TRACE(pObject->dwInst, 2, "MTSE0_MultiplexEntrySend:%d", pObject->Key);

    pObject->byInSequence = (unsigned char)
        pPdu->u.MltmdSystmCntrlMssg_rqst.u.multiplexEntrySend.sequenceNumber;

    // Send TRANSFER.indication to H.245 user
    pObject->State = MTSE_WAIT;
    H245FsmIndication(pPdu, H245_IND_MUX_TBL, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return 0;
} // MTSE0_MultiplexEntrySend



/*
 *  NAME
 *      MTSE1_MultiplexEntrySendF - MultiplexEntrySend received in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MTSE1_MultiplexEntrySendF        (Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity  == MTSE_IN);
    ASSERT(pObject->State == MTSE_WAIT);
    H245TRACE(pObject->dwInst, 2, "MTSE1_MultiplexEntrySend:%d", pObject->Key);

    pObject->byInSequence = (unsigned char)
        pPdu->u.MltmdSystmCntrlMssg_rqst.u.multiplexEntrySend.sequenceNumber;

#if defined(SDL_COMPLIANT)
    // Send REJECT.indication to H.245 user
    H245FsmIndication(pPdu, H245_IND_MTSE_RELEASE, pObject->pInstance, pObject->dwTransId, FSM_OK);
#endif

    // Send TRANSFER.indication to H.245 user
    H245FsmIndication(pPdu, H245_IND_MUX_TBL, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return 0;
} // MTSE1_MultiplexEntrySend



/*
 *  NAME
 *      MTSE1_MultiplexEntrySendReleaseF - MultiplexEntrySendRelease received in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MTSE1_MultiplexEntrySendReleaseF (Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity  == MTSE_IN);
    ASSERT(pObject->State == MTSE_WAIT);
    H245TRACE(pObject->dwInst, 2, "MTSE1_MultiplexEntrySendRelease:%d", pObject->Key);

    // Send REJECT.indication to H.245 user
    // SOURCE:=PROTOCOL
    pObject->State = MTSE_IDLE;
    H245FsmIndication(pPdu, H245_IND_MTSE_RELEASE, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return 0;
} // MTSE1_MultiplexEntrySendRelease



/*
 *  NAME
 *      MTSE1_TRANSFER_responseF - TRANSFER.response from API in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MTSE1_TRANSFER_responseF         (Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity  == MTSE_IN);
    ASSERT(pObject->State == MTSE_WAIT);
    H245TRACE(pObject->dwInst, 2, "MTSE1_TRANSFER_response:%d", pObject->Key);

    // Send MultiplexEntrySendAck PDU to remote peer
    pObject->State = MTSE_IDLE;
    return sendPDU(pObject->pInstance, pPdu);
} // MTSE1_TRANSFER_response



/*
 *  NAME
 *      MTSE1_REJECT_requestF - REJECT.request from API in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MTSE1_REJECT_requestF            (Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity  == MTSE_IN);
    ASSERT(pObject->State == MTSE_WAIT);
    H245TRACE(pObject->dwInst, 2, "MTSE1_REJECT_request:%d", pObject->Key);

    // Send MultiplexEntrySendReject PDU to remote
    pObject->State = MTSE_IDLE;
    return sendPDU(pObject->pInstance, pPdu);
} // MTSE1_REJECT_request

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\openu.c ===
/***********************************************************************
 *                                                                     *
 * Filename: openu.c                                                   *
 * Module:   H245 Finite State Machine Subsystem                       *
 *                                                                     *
 ***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *                                                                     *
 * $Workfile:   OPENU.C  $
 * $Revision:   1.5  $
 * $Modtime:   09 Dec 1996 13:36:34  $
 * $Log:   S:/STURGEON/SRC/H245/SRC/VCS/OPENU.C_v  $
 *
 *    Rev 1.5   09 Dec 1996 13:36:50   EHOWARDX
 * Updated copyright notice.
 *
 *    Rev 1.4   19 Jul 1996 12:12:02   EHOWARDX
 *
 * Changed to use API events defined in H245API.H instead of FSM events
 * which are no longer defined in FSMEXPOR.H.
 *
 *    Rev 1.3   04 Jun 1996 13:56:52   EHOWARDX
 * Fixed Release build warnings.
 *
 *    Rev 1.2   30 May 1996 23:39:20   EHOWARDX
 * Cleanup.
 *
 *    Rev 1.1   28 May 1996 14:25:24   EHOWARDX
 * Tel Aviv update.
 *
 *    Rev 1.0   09 May 1996 21:06:36   EHOWARDX
 * Initial revision.
 *
 *    Rev 1.13.1.2   09 May 1996 19:48:32   EHOWARDX
 * Change TimerExpiryF function arguements.
 *
 *    Rev 1.13.1.1   15 Apr 1996 10:45:26   EHOWARDX
 * Update.
 *
 *    Rev 1.13.1.0   10 Apr 1996 21:14:06   EHOWARDX
 * Branched.
 *                                                                     *
 ***********************************************************************/

#include "precomp.h"

#include "h245api.h"
#include "h245com.h"
#include "h245fsm.h"
#include "openu.h"
#include "pdu.x"



// Open Uni-directional Logical Channel Out-going states
#define OpenOutUReleased                 0
#define OpenOutUAwaitingEstablishment    1
#define OpenOutUEstablished              2
#define OpenOutUAwaitingRelease          3



// Open Uni-directional Logical Channel In-coming states
#define OpenInUReleased                  0
#define OpenInUAwaitingEstablishment     1
#define OpenInUEstablished               2



extern unsigned int uT103;

/***********************************************************************
 *
 * LOCAL FUNCTIONS
 *
 ***********************************************************************/

/*
 *  NAME
 *      T103ExpiryF - Callback function called by the timer
 *
 *
 *  PARAMETERS
 *   INPUT   dwInst     current instance of H245
 *   INPUT   id         timer id
 *   INPUT   pObject    pointer to a State Entity
 *
 *
 *  RETURN VALUE
 *       OK
 */

int T103ExpiryF(struct InstanceStruct *pInstance, DWORD_PTR dwTimerId, void *pObject)
{
    return FsmTimerEvent(pInstance, dwTimerId, pObject, T103Expiry);
} // T103ExpiryF()



/***********************************************************************
 *
 * OUT-GOING FINITE STATE MACHINE FUNCTIONS
 *
 ***********************************************************************/

/*
 *  NAME
 *      establishReleased - request for open unidirectional channel from API in idle state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject    pointer to a State Entity
 *
 *  RETURN VALUE
 *      error return codes defined in h245com.h
 */

HRESULT establishReleased(Object_t *pObject, PDU_t *pPdu)
{
    HRESULT             lError;

    ASSERT(pObject->Entity == LCSE_OUT);
    ASSERT(pObject->State == OpenOutUReleased);
    H245TRACE(pObject->dwInst, 2, "Sending open logical channel to ASN; Channel=%d",
              pObject->Key);

    /* Send Open Logical Channel to remote peer */
    lError = sendPDU(pObject->pInstance, pPdu);

    /* set timer T103 */
    pObject->State = OpenOutUAwaitingEstablishment;
    FsmStartTimer(pObject, T103ExpiryF, uT103);

    return lError;
}



/*
 *  NAME
 *      openAckAwaitingE - received open unidirectional channel Ack in Awaiting Establishment state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject    pointer to a State Entity
 *
 *  RETURN VALUE
 *      error return codes defined in h245com.h
 */

HRESULT openAckAwaitingE(Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == LCSE_OUT);
    ASSERT(pObject->State == OpenOutUAwaitingEstablishment);

    /* reset timer T103 */
    FsmStopTimer(pObject);

    /* Send ESTABLISH.confirm (SOURCE:=USER) to client */
    pObject->State = OpenOutUEstablished;
    H245FsmConfirm(pPdu, H245_CONF_OPEN, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return 0;
}



/*
 *  NAME
 *      openRejAwaitingE - received open unidirectional channel reject in Awaiting Establishment state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject    pointer to a State Entity
 *
 *  RETURN VALUE
 *      error return codes defined in h245com.h
 */

HRESULT openRejAwaitingE(Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == LCSE_OUT);
    ASSERT(pObject->State == OpenOutUAwaitingEstablishment);
    H245TRACE(pObject->dwInst, 2, "H245_CONF_OPEN with REJECT to API; Channel=%d",
              pObject->Key);

    /* reset timer T103 */
    FsmStopTimer(pObject);

    pObject->State = OpenOutUReleased;
    H245FsmConfirm(pPdu, H245_CONF_OPEN, pObject->pInstance, pObject->dwTransId, REJECT);

    return 0;
}



/*
 *  NAME
 *      releaseAwaitingE - close unidirectional channel in Awaiting Establishment state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject    pointer to a State Entity
 *
 *  RETURN VALUE
 *      error return codes defined in h245com.h
 */

HRESULT releaseAwaitingE(Object_t *pObject, PDU_t *pPdu)
{
    HRESULT             lError;

    ASSERT(pObject->Entity == LCSE_OUT);
    ASSERT(pObject->State == OpenOutUAwaitingEstablishment);
    H245TRACE(pObject->dwInst, 2, "Close message to ASN; Channel=%d",
              pObject->Key);

    /* reset timer T103 */
    FsmStopTimer(pObject);

    /* Send Close Logical Channel to remote peer */
    lError = sendPDU(pObject->pInstance, pPdu);

    /* set timer T103 */
    pObject->State = OpenOutUAwaitingRelease;
    FsmStartTimer(pObject, T103ExpiryF, uT103);

    return lError;
}



/*
 *  NAME
 *      t103AwaitingE - handle timer T103 expiry
 *
 *
 *  PARAMETERS
 *   INPUT   pObject    pointer to a State Entity
 *
 *  RETURN VALUE
 *      error return codes defined in h245com.h
 */

HRESULT t103AwaitingE(Object_t *pObject, PDU_t *pPdu)
{
    PDU_t *             pOut;
    HRESULT             lError;

    ASSERT(pObject->Entity == LCSE_OUT);
    ASSERT(pObject->State == OpenOutUAwaitingEstablishment);
    H245TRACE(pObject->dwInst, 2,
              "H245_CONF_OPEN with a timer expiry to API; Channel=%d",
              pObject->Key);

    pOut =  MemAlloc(sizeof(PDU_t ));
    if (pOut == NULL)
    {
        H245TRACE(pObject->dwInst, 2,
                  "t103AwaitingE: memory allocation failed");
        return H245_ERROR_NOMEM;
    }

    /* Send Close Logical Channel (source:=lcse) to remote peer */
    pdu_req_close_logical_channel(pOut, (WORD)pObject->Key, 1);
    lError = sendPDU(pObject->pInstance,pOut);
    MemFree(pOut);

    /* Send RELEASE.indication (SOURCE:=LCSE) to client */
    pObject->State = OpenOutUReleased;
    H245FsmConfirm(pPdu, H245_CONF_OPEN, pObject->pInstance, pObject->dwTransId, ERROR_D_TIMEOUT);

    return lError;
}



/*
 *  NAME
 *      releaseEstablished - send close channel while in the Established state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject    pointer to a State Entity
 *
 *  RETURN VALUE
 *      error return codes defined in h245com.h
 */

HRESULT releaseEstablished(Object_t *pObject, PDU_t *pPdu)
{
    HRESULT             lError;

    ASSERT(pObject->Entity == LCSE_OUT);
    ASSERT(pObject->State == OpenOutUEstablished);
    H245TRACE(pObject->dwInst, 2, "Send a Close Logical Channel to ASN; Channel=%d",
              pObject->Key);

    /* Send Close Logical Channel to remote peer */
    lError = sendPDU(pObject->pInstance, pPdu);

    /* set timer T103 */
    pObject->State = OpenOutUAwaitingRelease;
    FsmStartTimer(pObject, T103ExpiryF, uT103);

    return lError;
}



/*
 *  NAME
 *      openRejEstablished - received open unidirectional channel reject in Establish state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject    pointer to a State Entity
 *
 *  RETURN VALUE
 *      error return codes defined in h245com.h
 */

HRESULT openRejEstablished(Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == LCSE_OUT);
    ASSERT(pObject->State == OpenOutUEstablished);
    H245TRACE(pObject->dwInst, 2,
              "H245_CONF_OPEN with error B then with REJECT to API; Channel=%d",
              pObject->Key);

    pObject->State = OpenOutUReleased;

#if defined(SDL_COMPLIANT)
    /* Send ERROR.indication(B) to client - not necessary */
    H245FsmConfirm(pPdu, H245_CONF_OPEN, pObject->pInstance, pObject->dwTransId, ERROR_B_INAPPROPRIATE);
#endif

    /* Send RELEASE.indication (SOURCE:=LCSE) to client */
    H245FsmConfirm(pPdu, H245_CONF_OPEN, pObject->pInstance, pObject->dwTransId, REJECT);

    return 0;
}



/*
 *  NAME
 *      closeAckEstablished - received close unidirectional channel Ack in Established state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject    pointer to a State Entity
 *
 *  RETURN VALUE
 *      error return codes defined in h245com.h
 */

HRESULT closeAckEstablished(Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == LCSE_OUT);
    ASSERT(pObject->State == OpenOutUEstablished);
    H245TRACE(pObject->dwInst, 2, "H245_CONF_OPEN with error C then with REJECT to API->channel:%d", pObject->Key);

    pObject->State = OpenOutUReleased;

#if defined(SDL_COMPLIANT)
    /* Send ERROR.indication(C) to client - not necessary */
    H245FsmConfirm(pPdu, H245_CONF_OPEN, pObject->pInstance, pObject->dwTransId, ERROR_C_INAPPROPRIATE);
#endif

    /* Send RELEASE.indication (SOURCE:=LCSE) to client */
    H245FsmConfirm(pPdu, H245_CONF_OPEN, pObject->pInstance, pObject->dwTransId, REJECT);

    return 0;
}



/*
 *  NAME
 *      closeAckAwaitingR - received CloseAck/OpenReject in Awaiting Release state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject    pointer to a State Entity
 *
 *  RETURN VALUE
 *      error return codes defined in h245com.h
 */

HRESULT closeAckAwaitingR(Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == LCSE_OUT);
    ASSERT(pObject->State == OpenOutUAwaitingRelease);
    H245TRACE(pObject->dwInst, 2,
              "H245_CONF_CLOSE with no error to API; Channel=%d",
              pObject->Key);

    /* reset timer T103 */
    FsmStopTimer(pObject);

    /* Send RELEASE.confirm to client */
    pObject->State = OpenOutUReleased;
    H245FsmConfirm(pPdu, H245_CONF_CLOSE, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return 0;
}



/*
 *  NAME
 *      openRejAwaitingR - received open unidirectional channel Reject in Awaiting Release state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject    pointer to a State Entity
 *
 *  RETURN VALUE
 *      error return codes defined in h245com.h
 */

HRESULT openRejAwaitingR(Object_t *pObject, PDU_t *pPdu)
{
    return closeAckAwaitingR(pObject, pPdu);
}



/*
 *  NAME
 *      t103AwaitingR - handle timer expiry for close channel
 *
 *  PARAMETERS
 *   INPUT   pObject    pointer to a State Entity
 *
 *  RETURN VALUE
 *      error return codes defined in h245com.h
 */

HRESULT t103AwaitingR(Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == LCSE_OUT);
    ASSERT(pObject->State  == OpenOutUAwaitingRelease);
    ASSERT(pPdu            == NULL);
    H245TRACE(pObject->dwInst, 2,
              "H245_CONF_CLOSE with timer expiry to API; Channel=%d",
              pObject->Key);

    /* Send ERROR.indication(D) to client */
    pObject->State = OpenOutUReleased;
    H245FsmConfirm(NULL, H245_CONF_CLOSE, pObject->pInstance, pObject->dwTransId, ERROR_D_TIMEOUT);

#if defined(SDL_COMPLIANT)
    /* Send RELEASE.confirm to client - not necessary */
    H245FsmConfirm(NULL, H245_CONF_OPEN, pObject->pInstance, pObject->dwTransId, REJECT);
#endif

    return 0;
}

/*
 *  NAME
 *      establishAwaitingR - open unidirectional channel request from API in Awaiting Release state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject    pointer to a State Entity
 *
 *  RETURN VALUE
 *      error return codes defined in h245com.h
 */

HRESULT establishAwaitingR(Object_t *pObject, PDU_t *pPdu)
{
    HRESULT             lError;

    ASSERT(pObject->Entity == LCSE_OUT);
    ASSERT(pObject->State == OpenOutUAwaitingRelease);
    H245TRACE(pObject->dwInst, 2, "send a (re) Open Channel to ASN; Channel=%d",
              pObject->Key);

    /* reset timer T103 */
    FsmStopTimer(pObject);

    /* Send Open Logical Channel to remote peer */
    lError = sendPDU(pObject->pInstance,pPdu);

    /* set timer T103 */
    pObject->State = OpenOutUAwaitingEstablishment;
    FsmStartTimer(pObject, T103ExpiryF, uT103);

    return lError;
}



/***********************************************************************
 *
 * IN-COMING FINITE STATE MACHINE FUNCTIONS
 *
 ***********************************************************************/

HRESULT openReleased(Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == LCSE_IN);
    ASSERT(pObject->State == OpenInUReleased);
    H245TRACE(pObject->dwInst, 2,
              "H245_IND_OPEN with no error to API; Channel=%d",
              pObject->Key);

    /* Send ESTABLISH.indication to client */
    pObject->State = OpenInUAwaitingEstablishment;
    H245FsmIndication(pPdu, H245_IND_OPEN, pObject->pInstance, 0, FSM_OK);

    return 0;
}



/*
 *  NAME
 *      closeReleased - received close unidirectional channel in Idle state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject    pointer to a State Entity
 *
 *  RETURN VALUE
 *      error return codes defined in h245com.h
 */

HRESULT closeReleased(Object_t *pObject, PDU_t *pPdu)
{
    PDU_t *             pOut;
    HRESULT             lError;

    ASSERT(pObject->Entity == LCSE_IN);
    ASSERT(pObject->State == OpenInUReleased);
    ASSERT(pObject->Key == pPdu->u.MltmdSystmCntrlMssg_rqst.u.closeLogicalChannel.forwardLogicalChannelNumber);
    H245TRACE(pObject->dwInst, 2, "Close Channel received while in Released state; Channel=%d",
              pObject->Key);
    H245TRACE(pObject->dwInst, 2, "Send Close Ack; Channel=%d",
              pObject->Key);

    pOut =  MemAlloc(sizeof(PDU_t));
    if (pOut == NULL)
    {
        H245TRACE(pObject->dwInst, 2,
                  "closeReleased: memory allocation failed");
        return H245_ERROR_NOMEM;
    }

    /* Send Close Logical Channel Ack to remote peer */
    pdu_rsp_close_logical_channel_ack(pOut,(WORD)pObject->Key);
    lError = sendPDU(pObject->pInstance, pOut);
    MemFree(pOut);

    return lError;
}

/*
 *  NAME
 *      responseAwaiting - response to an open in Awaiting Establishment state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject    pointer to a State Entity
 *
 *  RETURN VALUE
 *      error return codes defined in h245com.h
 */

HRESULT responseAwaiting(Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == LCSE_IN);
    ASSERT(pObject->State == OpenInUAwaitingEstablishment);
    H245TRACE(pObject->dwInst, 2,
              "Send OpenAck to ASN; Channel=%d",
              pObject->Key);

    /* Send Open Logical Channel Ack to remote peer */
    pObject->State = OpenInUEstablished;
    return sendPDU(pObject->pInstance, pPdu);
}



/*
 *  NAME
 *      releaseAwaiting - response to open with open reject
 *
 *
 *  PARAMETERS
 *   INPUT   pObject    pointer to a State Entity
 *
 *  RETURN VALUE
 *      error return codes defined in h245com.h
 */

HRESULT releaseAwaiting(Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == LCSE_IN);
    ASSERT(pObject->State == OpenInUAwaitingEstablishment);
    H245TRACE(pObject->dwInst, 2,
              "Send OpenReject to ASN; Channel=%d",
              pObject->Key);

    /* Send Open Logical Channel Reject to remote peer */
    pObject->State = OpenInUReleased;
    return sendPDU(pObject->pInstance, pPdu);
}



/*
 *  NAME
 *      closeAwaiting - received close unidirectional channel in Awaiting  state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject    pointer to a State Entity
 *
 *  RETURN VALUE
 *      error return codes defined in h245com.h
 */

HRESULT closeAwaiting(Object_t *pObject, PDU_t *pPdu)
{
    PDU_t *             pOut;
    HRESULT             lError;

    ASSERT(pObject->Entity == LCSE_IN);
    ASSERT(pObject->State == OpenInUAwaitingEstablishment);
    H245TRACE(pObject->dwInst, 2,
              "H245_IND_CLOSE with no error to API; Channel=%d",
              pObject->Key);

    pOut = (PDU_t *) MemAlloc(sizeof(PDU_t));
    if (pOut == NULL)
    {
        H245TRACE(pObject->dwInst, 2,
                  "closeAwaiting: memory allocation failed");
        return H245_ERROR_NOMEM;
    }

    /* Send Close Logical Channel Ack to remote peer */
    pdu_rsp_close_logical_channel_ack(pOut,(WORD)pObject->Key);
    lError = sendPDU(pObject->pInstance, pOut);
    MemFree(pOut);

    /* Send RELEASE.indication to client */
    pObject->State = OpenInUReleased;
    H245FsmIndication(pPdu, H245_IND_CLOSE, pObject->pInstance, 0, FSM_OK);

    return lError;
}



/*
 *  NAME
 *      openAwaiting - received an overriding open unidirectional channel while Awaiting establishment
 *
 *
 *  PARAMETERS
 *   INPUT   pObject    pointer to a State Entity
 *
 *  RETURN VALUE
 *      error return codes defined in h245com.h
 */

HRESULT openAwaiting(Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == LCSE_IN);
    ASSERT(pObject->State == OpenInUAwaitingEstablishment);
    H245TRACE(pObject->dwInst, 2,
              "H245_IND_CLOSE, then H245_IND_OPEN to API; Channel=%d",
              pObject->Key);

    pObject->State = OpenInUReleased;

#if defined(SDL_COMPLIANT)
    /* Send RELEASE.indication (SOURCE:=USER) to client */
    H245FsmIndication( NULL, H245_IND_CLOSE, pObject->pInstance, 0, FSM_OK);
#endif

    /* Send ESTABLISH.indication to client */
    H245FsmIndication(pPdu, H245_IND_OPEN, pObject->pInstance, 0, FSM_OK);

    return 0;
}



/*
 *  NAME
 *      closeEstablished - received close unidirectional channel in Established state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject    pointer to a State Entity
 *
 *  RETURN VALUE
 *      error return codes defined in h245com.h
 */

HRESULT closeEstablished(Object_t *pObject, PDU_t *pPdu)
{
    PDU_t *             pOut;
    HRESULT             lError;

    ASSERT(pObject->Entity == LCSE_IN);
    ASSERT(pObject->State == OpenInUEstablished);
    H245TRACE(pObject->dwInst, 2,
              "H245_IND_CLOSE with no error to API; Channel=%d",
              pObject->Key);

    pOut = (PDU_t *) MemAlloc(sizeof(PDU_t ));
    if (pOut == NULL)
    {
        H245TRACE(pObject->dwInst, 2,
                  "closeEstablished: memory allocation failed");
        return H245_ERROR_NOMEM;
    }

    /* Send Close Logical Channel Ack to remote peer */
    pdu_rsp_close_logical_channel_ack(pOut,(WORD)pObject->Key);
    lError = sendPDU(pObject->pInstance, pOut);
    MemFree(pOut);

    /* Send RELEASE.indication to clietn */
    pObject->State = OpenInUReleased;
    H245FsmIndication(pPdu, H245_IND_CLOSE, pObject->pInstance, 0, FSM_OK);

    return lError;
}



/*
 *  NAME
 *      openEstablished - received overriding open unidirectional channel in Established state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject    pointer to a State Entity
 *
 *  RETURN VALUE
 *      error return codes defined in h245com.h
 */

HRESULT openEstablished(Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == LCSE_IN);
    ASSERT(pObject->State == OpenInUEstablished);
    H245TRACE(pObject->dwInst, 2,
              "H245_IND_CLOSE followed by H245_IND_OPEN to API; Channel=%d",
              pObject->Key);

#if defined(SDL_COMPLIANT)
    /* Send RELEASE.indication (SOURCE:=USER) to client - not necessary */
    H245FsmIndication( NULL, H245_IND_CLOSE, pObject->pInstance, 0, FSM_OK);
#endif

    /* Send ESTABLISH.indication to client */
    H245FsmIndication( pPdu, H245_IND_OPEN, pObject->pInstance, 0, FSM_OK);

    return 0;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\openb.c ===
/***********************************************************************
 *                                                                     *
 * Filename: openb.c                                                   *
 * Module:   H245 Finite State Machine Subsystem                       *
 *                                                                     *
 ***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *                                                                     *
 * $Workfile:   openb.c  $
 * $Revision:   1.5  $
 * $Modtime:   09 Dec 1996 18:05:30  $
 * $Log L:\mphone\h245\h245env\comm\h245_3\h245_fsm\vcs\src\openb.c_v $
 *                                                                     *
 ***********************************************************************/

#include "precomp.h"

#include "h245api.h"
#include "h245com.h"
#include "h245fsm.h"
#include "openb.h"
#include "pdu.x"



// Open Bi-directional Logical Channel Out-going states
#define OpenOutBReleased                 0
#define OpenOutBAwaitingEstablishment    1
#define OpenOutBEstablished              2
#define OpenOutBAwaitingRelease          3

// Open Bi-directional Logical Channel In-coming states
#define OpenInBReleased                  0
#define OpenInBAwaitingEstablishment     1
#define OpenInBAwaitingConfirmation      2
#define OpenInBEstablished               3



extern unsigned int uT103;

/***********************************************************************
 *
 * LOCAL FUNCTIONS
 *
 ***********************************************************************/

/*
 *  NAME
 *      T103OutExpiryF - Callback function called by the timer.
 *      T103InExpiryF  - Callback function called by the timer.
 *
 *
 *  PARAMETERS
 *   INPUT   dwInst     current instance of H245
 *   INPUT   id         timer id
 *   INPUT   obj        pointer to a FSM object
 *
 *
 *  RETURN VALUE
 *       OK
 */

int T103OutExpiryF(struct InstanceStruct *pInstance, DWORD_PTR dwTimerId, void *pObject)
{
    return FsmTimerEvent(pInstance, dwTimerId, pObject, T103OutExpiry);
} // T103OutExpiryF()

int T103InExpiryF(struct InstanceStruct *pInstance, DWORD_PTR dwTimerId, void *pObject)
{
    return FsmTimerEvent(pInstance, dwTimerId, pObject, T103InExpiry);
} // T103InExpiryF()



/***********************************************************************
 *
 * OUT-GOING FINITE STATE MACHINE FUNCTIONS
 *
 ***********************************************************************/

/*
 *  NAME
 *      establishReqBReleased - API request to open bidirectional channel in idle state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT establishReqBReleased(Object_t *pObject, PDU_t *pPdu)
{
    HRESULT             lError;

    ASSERT(pObject->Entity == BLCSE_OUT);
    ASSERT(pObject->State == OpenOutBReleased);
    H245TRACE(pObject->dwInst, 2,
              "Sending open Bidirectional channel to ASN; Channel=%d",
              pObject->Key);

    /* Send Open Logical Channel to remote peer */
    lError = sendPDU(pObject->pInstance, pPdu);

    /* set timer T103 */
    pObject->State = OpenOutBAwaitingEstablishment;
    FsmStartTimer(pObject, T103OutExpiryF, uT103);

    return lError;
}



/*
 *  NAME
 *      openChannelAckBAwaitingE - received open bidirectional channel Ack in Awaiting Establishment state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT openChannelAckBAwaitingE(Object_t *pObject, PDU_t *pPdu)
{
    PDU_t *             pOut;
    HRESULT             lError;

    ASSERT(pObject->Entity == BLCSE_OUT);
    ASSERT(pObject->State == OpenOutBAwaitingEstablishment);
    H245TRACE(pObject->dwInst, 2,
              "H245_CONF_NEEDRSP_OPEN with no error to API; Channel=%d",
              pObject->Key);

    /* reset timer T103 */
    FsmStopTimer(pObject);

    /* Send ESTABLISH.confirm to client */
    pObject->State = OpenOutBEstablished;
    H245FsmConfirm(pPdu,H245_CONF_NEEDRSP_OPEN, pObject->pInstance, pObject->dwTransId, FSM_OK);

    /* Send Open Logical Channel Confirm to remote peer */
    pOut = (PDU_t *) MemAlloc(sizeof(PDU_t ));
    if (pOut == NULL)
    {
        H245TRACE(pObject->dwInst, 1,
                  "openChannelAckBAwaitingE: memory allocation failed");
        return H245_ERROR_NOMEM;
    }
    pdu_ind_open_logical_channel_conf(pOut, (WORD)pObject->Key);
    lError = sendPDU(pObject->pInstance, pOut);
    MemFree(pOut);
    return lError;
}



/*
 *  NAME
 *      openChannelRejBAwaitingE - received open bidirectional channel reject in Awaiting Establishment state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT openChannelRejBAwaitingE(Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == BLCSE_OUT);
    ASSERT(pObject->State == OpenOutBAwaitingEstablishment);
    H245TRACE(pObject->dwInst, 2,
              "H245_CONF_NEEDRSP_OPEN with REJECT to API; Channel=%d",
              pObject->Key);

    /* reset  timer T103 */
    FsmStopTimer(pObject);

    /* Send RELEASE.indication to client */
    pObject->State = OpenOutBReleased;
    H245FsmConfirm(pPdu, H245_CONF_NEEDRSP_OPEN, pObject->pInstance, pObject->dwTransId, REJECT);

    return 0;
}



/*
 *  NAME
 *      releaseReqBOutAwaitingE - API request to close bidirectional channel in Awaiting Establishment state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT releaseReqBOutAwaitingE(Object_t *pObject, PDU_t *pPdu)
{
    HRESULT             lError;

    ASSERT(pObject->Entity == BLCSE_OUT);
    ASSERT(pObject->State == OpenOutBAwaitingEstablishment);
    H245TRACE(pObject->dwInst, 2,
              "Close (Bidirectional) to ASN; Channel=%d",
              pObject->Key);

    /* reset timer T103 */
    FsmStopTimer(pObject);

    /* Send Close Logical Channel to remote peer */
    lError = sendPDU(pObject->pInstance,pPdu);

    /* set timer T103 */
    pObject->State = OpenOutBAwaitingRelease;
    FsmStartTimer(pObject, T103OutExpiryF, uT103);

    return lError;
}



/*
 *  NAME
 *      t103ExpiryBAwaitingE - handle timeout for  outstanding  open bidirectional pdu
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT t103ExpiryBAwaitingE(Object_t *pObject, PDU_t *pPdu)
{
    PDU_t *             pOut;
    HRESULT             lError;

    ASSERT(pObject->Entity == BLCSE_OUT);
    ASSERT(pObject->State == OpenOutBAwaitingEstablishment);
    ASSERT(pPdu == NULL);
    H245TRACE(pObject->dwInst, 2, "H245_CONF_NEEDRSP_OPEN  with a timer expiry to API->Channel=%d", pObject->Key);

    /* Send ERROR.indication(D) to client */
    pObject->State = OpenOutBReleased;
    H245FsmConfirm(NULL, H245_CONF_NEEDRSP_OPEN, pObject->pInstance, pObject->dwTransId, ERROR_D_TIMEOUT);

    /* Send Close Logical Channel (source:=lcse) to remote peer */
    pOut = (PDU_t *) MemAlloc(sizeof(PDU_t ));
    if (pOut == NULL)
    {
        H245TRACE(pObject->dwInst, 1,
                  "t103ExpiryBAwaitingE: memory allocation failed");
        return H245_ERROR_NOMEM;
    }
    pdu_req_close_logical_channel(pOut, (WORD)pObject->Key, 1);
    lError = sendPDU(pObject->pInstance, pOut);
    MemFree(pOut);

#if defined(SDL_COMPLIANT)
    /* Send RELEASE.indication to client */
    H245FsmIndication(pPdu, H245_IND_CLOSE, pObject->pInstance, 0, FSM_OK);
#endif

    return lError;
}

/*
 *  NAME
 *      releaseReqBEstablished - API request to close channel in established state
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT releaseReqBEstablished(Object_t *pObject, PDU_t *pPdu)
{
    HRESULT             lError;

    ASSERT(pObject->Entity == BLCSE_OUT);
    ASSERT(pObject->State == OpenOutBEstablished);
    H245TRACE(pObject->dwInst, 2,
              "Send Close Bidirectional Channel to ASN; Channel=%d",
              pObject->Key);

    /* Send Close Logical Channel to remote peer */
    lError = sendPDU(pObject->pInstance,pPdu);

    /* set timer T103 */
    pObject->State = OpenOutBAwaitingRelease;
    FsmStartTimer(pObject, T103OutExpiryF, uT103);

    return lError;
}



/*
 *  NAME
 *      openChannelRejBEstablished - received open reject in established state
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT openChannelRejBEstablished(Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == BLCSE_OUT);
    ASSERT(pObject->State == OpenOutBEstablished);
    H245TRACE(pObject->dwInst, 2, "H245_CONF_NEEDRSP_OPEN with error B then with REJECT to API->Channel=%d", pObject->Key);

    pObject->State = OpenOutBReleased;

#if defined(SDL_COMPLIANT)
    /* Send ERROR.indication(B) to client */
    H245FsmConfirm(pPdu, H245_CONF_NEEDRSP_OPEN, pObject->pInstance, pObject->dwTransId, ERROR_B_INAPPROPRIATE);
#endif

    /* Send RELEASE.indication (SOURCE:=B-LCSE) to client */
    H245FsmConfirm(pPdu, H245_CONF_NEEDRSP_OPEN, pObject->pInstance, pObject->dwTransId, REJECT);

    return 0;
}



/*
 *  NAME
 *      closeChannelAckBEstablished - received close ack in established state
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT closeChannelAckBEstablished(Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == BLCSE_OUT);
    ASSERT(pObject->State == OpenOutBEstablished);
    H245TRACE(pObject->dwInst, 2,
              "H245_CONF_NEEDRSP_OPEN with error C then with REJECT to API; Channel=%d",
              pObject->Key);

    pObject->State = OpenOutBReleased;

#if defined(SDL_COMPLIANT)
    /* Send ERROR.indication(C) to client */
    H245FsmConfirm(pPdu, H245_CONF_NEEDRSP_OPEN, pObject->pInstance, pObject->dwTransId, ERROR_C_INAPPROPRIATE);
#endif

    /* Send RELEASE.indication to client */
    H245FsmConfirm(pPdu, H245_CONF_NEEDRSP_OPEN, pObject->pInstance, pObject->dwTransId, REJECT);

    return 0;
}



/*
 *  NAME
 *      closeChannelAckAwaitingR - received close ack in Awaiting Release state
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT closeChannelAckAwaitingR(Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == BLCSE_OUT);
    ASSERT(pObject->State == OpenOutBAwaitingRelease);
    H245TRACE(pObject->dwInst, 2,
              "H245_CONF_CLOSE with no error to API; Channel=%d",
              pObject->Key);

    /* reset timer T103 */
    FsmStopTimer(pObject);

    /* Send RELEASE.confirm to client */
    pObject->State = OpenOutBReleased;
    H245FsmConfirm(pPdu, H245_CONF_CLOSE, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return 0;
}



/*
 *  NAME
 *      openChannelRejBAwaitingR - received open reject in awaiting release state
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT openChannelRejBAwaitingR(Object_t *pObject, PDU_t *pPdu)
{
    return closeChannelAckAwaitingR(pObject, pPdu);
}



/*
 *  NAME
 *      t103ExpiryBAwaitingR - handle timer expiry in awaiting release
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT t103ExpiryBAwaitingR(Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == BLCSE_OUT);
    ASSERT(pObject->State == OpenOutBAwaitingRelease);
    ASSERT(pPdu == NULL);
    H245TRACE(pObject->dwInst, 2,
              "H245_CONF_CLOSE with timer expiry to API; Channel=%d",
              pObject->Key);

    /* Send ERROR.indication(D) to client */
    pObject->State = OpenOutBReleased;
    H245FsmConfirm(NULL, H245_CONF_CLOSE, pObject->pInstance, pObject->dwTransId, ERROR_D_TIMEOUT);

#if defined(SDL_COMPLIANT)
    /* Send RELEASE.confirm to client */
#endif

    return 0;
}

/*
 *  NAME
 *      establishReqAwaitingR - API open request in awaiting release state
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT establishReqAwaitingR(Object_t *pObject, PDU_t *pPdu)
{
    HRESULT             lError;

    ASSERT(pObject->Entity == BLCSE_OUT);
    ASSERT(pObject->State == OpenOutBAwaitingRelease);
    H245TRACE(pObject->dwInst, 2,
              "Send a (re) Open Bidirectional Channel to ASN; Channel=%d",
              pObject->Key);

    /* reset timer T103 */
    FsmStopTimer(pObject);

    /* Send Open Logical Channel to remote peer */
    lError = sendPDU(pObject->pInstance, pPdu);

    /* set timer T103 */
    pObject->State = OpenOutBAwaitingEstablishment;
    FsmStartTimer(pObject, T103OutExpiryF, uT103);

    return lError;
}



/***********************************************************************
 *
 * IN-COMING FINITE STATE MACHINE FUNCTIONS
 *
 ***********************************************************************/

/*
 *  NAME
 *      openChannelBReleased - open channel received in idle state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT openChannelBReleased(Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == BLCSE_IN);
    ASSERT(pObject->State == OpenInBReleased);
    H245TRACE(pObject->dwInst, 2,
              "H245_IND_OPEN with no error to API; Channel=%d",
              pObject->Key);

    /* Send ESTABLISH.indication to client */
    pObject->State = OpenInBAwaitingEstablishment;
    H245FsmIndication(pPdu, H245_IND_OPEN, pObject->pInstance, 0, FSM_OK);
    return 0;
}



/*
 *  NAME
 *      closeChannelBReleased - close channel received in idle state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT closeChannelBReleased (Object_t *pObject, PDU_t *pPdu)
{
    PDU_t *             pOut;
    HRESULT             lError;

    ASSERT(pObject->Entity == BLCSE_IN);
    ASSERT(pObject->State == OpenInBReleased);
    ASSERT(pObject->Key == pPdu->u.MltmdSystmCntrlMssg_rqst.u.closeLogicalChannel.forwardLogicalChannelNumber);
    H245TRACE(pObject->dwInst, 2,
              "Close Channel (Bidirectional) received while in Released state; Channel=%d",
              pObject->Key);
    H245TRACE(pObject->dwInst, 2,
              "Send Close Ack (Bidirectional) to ASN; Channel=%d",
              pObject->Key);

    /* Send Close Logical Channel Ack to remote peer */
    pOut = (PDU_t *) MemAlloc(sizeof(PDU_t));
    if (pOut == NULL)
    {
        H245TRACE(pObject->dwInst, 2,
                  "closeChannelBReleased: memory allocation failed");
        return H245_ERROR_NOMEM;
    }
    pdu_rsp_close_logical_channel_ack(pOut, (WORD)pObject->Key);
    lError = sendPDU(pObject->pInstance, pOut);
    MemFree(pOut);

    return lError;
}

/*
 *  NAME
 *      establishResBAwaitingE - response to an open request    with an ack
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT establishResBAwaitingE (Object_t *pObject, PDU_t *pPdu)
{
    HRESULT             lError;

    ASSERT(pObject->Entity == BLCSE_IN);
    ASSERT(pObject->State == OpenInBAwaitingEstablishment);
    H245TRACE(pObject->dwInst, 2,
              "Send OpenAck (Bidirectional) to ASN module; Channel=%d",
              pObject->Key);

    /* Send Open Logical Channel Ack to remote peer */
    lError = sendPDU(pObject->pInstance, pPdu);

    /* set timer T103 */
    pObject->State = OpenInBAwaitingConfirmation;
    FsmStartTimer(pObject, T103InExpiryF, uT103);

    return lError;
}



/*
 *  NAME
 *      releaseReqBInAwaitingE - response to an open request with a reject
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT releaseReqBInAwaitingE (Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == BLCSE_IN);
    ASSERT(pObject->State == OpenInBAwaitingEstablishment);
    H245TRACE(pObject->dwInst, 2, "Send OpenReject (Bidirectional) to SR module; Channel=%d", pObject->Key);

    /* Send Open Logical Channel Reject to remote peer */
    pObject->State = OpenInBReleased;
    return sendPDU(pObject->pInstance, pPdu);
}



/*
 *  NAME
 *      closeChannelBAwaitingE - received close channel in Awaiting establishment state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT closeChannelBAwaitingE(Object_t *pObject, PDU_t *pPdu)
{
    PDU_t *             pOut;
    HRESULT             lError;

    ASSERT(pObject->Entity == BLCSE_IN);
    ASSERT(pObject->State == OpenInBAwaitingEstablishment);
    H245TRACE(pObject->dwInst, 2,
              "H245_IND_CLOSE with no error to API; Channel=%d",
              pObject->Key);

    /* Send Close Logical Channel Ack to remote peer */
    pOut = (PDU_t *) MemAlloc(sizeof(PDU_t ));
    if (pOut == NULL)
    {
        H245TRACE(pObject->dwInst, 2,
                  "closeChannelBAwaitingE: memory allocation failed");
        return H245_ERROR_NOMEM;
    }
    pdu_rsp_close_logical_channel_ack(pOut, (WORD)pObject->Key);
    lError = sendPDU(pObject->pInstance, pOut);
    MemFree(pOut);

    /* Send RELEASE.indication to client */
    pObject->State = OpenInBReleased;
    H245FsmIndication(pPdu, H245_IND_CLOSE, pObject->pInstance, 0, FSM_OK);

    return lError;
}



/*
 *  NAME
 *      openChannelBAwaitingE - overriding open request
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT openChannelBAwaitingE(Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == BLCSE_IN);
    ASSERT(pObject->State == OpenInBAwaitingEstablishment);
    H245TRACE(pObject->dwInst, 2, "Overriding H245_IND_OPEN to API; Channel=%d", pObject->Key);

#if defined(SDL_COMPLIANT)
    /* Send RELEASE.indication (SOURCE:=USER) to client */
    H245FsmIndication(pPdu, H245_IND_CLOSE, pObject->pInstance, 0, FSM_OK);
#endif

    /* Send ESTABLISH.indication to client */
    H245FsmIndication(pPdu, H245_IND_OPEN, pObject->pInstance, 0, FSM_OK);

    return 0;
}



/*
 *  NAME
 *      openChannelConfirmBAwaitingE - received open confirm while awaiting establishment
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT openChannelConfirmBAwaitingE (Object_t *pObject, PDU_t *pPdu)
{
    PDU_t *             pOut;
    HRESULT             lError;

    ASSERT(pObject->Entity == BLCSE_IN);
    ASSERT(pObject->State == OpenInBAwaitingEstablishment);
    H245TRACE(pObject->dwInst, 2,
              "H245_IND_OPEN_CONF with error F to API; Channel=%d",
              pObject->Key);

    /* Send ERROR.indication(F) to client */
    pObject->State = OpenInBReleased;
    H245FsmIndication(pPdu, H245_IND_OPEN_CONF, pObject->pInstance, 0, ERROR_E_INAPPROPRIATE);

    /* Send Close Logical Channel Ack to remote peer */
    pOut = (PDU_t *) MemAlloc(sizeof(PDU_t ));
    if (pOut == NULL)
    {
        H245TRACE(pObject->dwInst, 2,
                  "openChannelConfirmBAwaitingE: memory allocation failed");
        return H245_ERROR_NOMEM;
    }
    pdu_rsp_close_logical_channel_ack(pOut, (WORD)pObject->Key);
    lError = sendPDU(pObject->pInstance, pOut);
    MemFree(pOut);

#if defined(SDL_COMPLIANT)
    /* Send RELEASE.indication (SOURCE:=B-LCSE) to client */
    H245FsmIndication(pPdu, H245_IND_CLOSE, pObject->pInstance, 0, FSM_OK);
#endif

    return lError;
}



/*
 *  NAME
 *      t103ExpiryBAwaitingC - timer expired waiting for open confirm
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT t103ExpiryBAwaitingC(Object_t *pObject, PDU_t *pPdu)
{
    PDU_t *             pOut;
    HRESULT             lError;

    ASSERT(pObject->Entity == BLCSE_IN);
    ASSERT(pObject->State == OpenInBAwaitingConfirmation);
    ASSERT(pPdu == NULL);
    H245TRACE(pObject->dwInst, 2,
              "Timer T103 expired while waiting for OpenConfirm for OpenAck");

    /* Send ERROR.indication(G) to client */
    pObject->State = OpenInBReleased;
    H245FsmIndication(NULL, H245_IND_OPEN_CONF, pObject->pInstance, pObject->dwTransId, ERROR_F_TIMEOUT);

    /* Send Close Logical Channel Ack to remote peer */
    pOut = (PDU_t *) MemAlloc(sizeof(PDU_t ));
    if (pOut == NULL)
    {
        H245TRACE(pObject->dwInst, 2,
                  "t103ExpiryBAwaitingC: memory allocation failed");
        return H245_ERROR_NOMEM;
    }
    pdu_rsp_close_logical_channel_ack(pOut, (WORD)pObject->Key);
    lError = sendPDU(pObject->pInstance, pOut);
    MemFree(pOut);

#if defined(SDL_COMPLIANT)
    /* Send RELEASE.indication to client */
    H245FsmIndication(pPdu, H245_IND_CLOSE, pObject->pInstance, 0, FSM_OK);
#endif

    return lError;
}

/*
 *  NAME
 *      openChannelConfirmBAwaitingC - received open confirm while awaiting confirmation
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT openChannelConfirmBAwaitingC (Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == BLCSE_IN);
    ASSERT(pObject->State == OpenInBAwaitingConfirmation);
    H245TRACE(pObject->dwInst, 2,
              "H245_IND_OPEN_CONF with no errors; Channel=%d",
              pObject->Key);

    /* reset timer T103 */
    FsmStopTimer(pObject);

    /* Send ESTABLISH.confirm to client */
    pObject->State = OpenInBEstablished;
    H245FsmIndication(pPdu, H245_IND_OPEN_CONF, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return 0;
}



/*
 *  NAME
 *      closeChannelBAwaitingC - received close channel while awaiting confirmation
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT closeChannelBAwaitingC (Object_t *pObject, PDU_t *pPdu)
{
    PDU_t *             pOut;
    HRESULT             lError;

    ASSERT(pObject->Entity == BLCSE_IN);
    ASSERT(pObject->State == OpenInBAwaitingConfirmation);
    H245TRACE(pObject->dwInst, 2,
              "H245_IND_CLOSE with no error; Channel=%d",
              pObject->Key);
    H245TRACE(pObject->dwInst, 2,
              "Send Close Ack (Bidirectional) to ASN; Channel=%d",
              pObject->Key);

    /* reset timer T103 */
    FsmStopTimer(pObject);

    /* Send Close Logical Channel Ack to remote peer */
    pOut = (PDU_t *) MemAlloc(sizeof(PDU_t));
    if (pOut == NULL)
    {
        H245TRACE(pObject->dwInst, 2,
                  "closeChannelBAwaitingC: memory allocation failed");
        return H245_ERROR_NOMEM;
    }
    pdu_rsp_close_logical_channel_ack(pOut, (WORD)pObject->Key);
    lError = sendPDU(pObject->pInstance, pOut);
    MemFree(pOut);

    /* Send RELEASE.indication to client */
    pObject->State = OpenInBReleased;
    H245FsmIndication(pPdu, H245_IND_CLOSE, pObject->pInstance, 0, FSM_OK);

    return lError;
}



/*
 *  NAME
 *      openChannelBAwaitingC - received open channel while awaiting confirmation
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT openChannelBAwaitingC (Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == BLCSE_IN);
    ASSERT(pObject->State == OpenInBAwaitingConfirmation);
    H245TRACE(pObject->dwInst, 2, "Overriding H245_IND_OPEN to API; Channel=%d", pObject->Key);

    /* reset timer T103 */
    FsmStopTimer(pObject);

    pObject->State = OpenInBAwaitingEstablishment;

#if defined(SDL_COMPLIANT)
    /* Send RELEASE.indication (SOURCE:=USER) to client */
    H245FsmIndication(pPdu, H245_IND_CLOSE, pObject->pInstance, 0, FSM_OK);
#endif

    /* Send ESTABLISH.indication to client */
    H245FsmIndication(pPdu, H245_IND_OPEN, pObject->pInstance, 0, FSM_OK);

    return 0;
}



/*
 *  NAME
 *      closeChannelBEstablished - received close channel while in established state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT closeChannelBEstablished(Object_t *pObject, PDU_t *pPdu)
{
    PDU_t *             pOut;
    HRESULT             lError;

    ASSERT(pObject->Entity == BLCSE_IN);
    ASSERT(pObject->State == OpenInBEstablished);
    H245TRACE(pObject->dwInst, 2,
              "H245_IND_CLOSE with no error up to API; Channel=%d",
              pObject->Key);

    /* Send Close Logical Channel Ack to remote peer */
    pOut = (PDU_t *) MemAlloc(sizeof(PDU_t ));
    if (pOut == NULL)
    {
        H245TRACE(pObject->dwInst, 2,
                  "closeChannelBEstablished: memory allocation failed");
        return H245_ERROR_NOMEM;
    }
    pdu_rsp_close_logical_channel_ack(pOut, (WORD)pObject->Key);
    lError = sendPDU(pObject->pInstance, pOut);
    MemFree(pOut);

    /* Send RELEASE.indication to client */
    pObject->State = OpenInBReleased;
    H245FsmIndication(pPdu, H245_IND_CLOSE, pObject->pInstance, 0, FSM_OK);

    return lError;
}



/*
 *  NAME
 *      openChannelBEstablished - received open channel while in established state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT openChannelBEstablished(Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == BLCSE_IN);
    ASSERT(pObject->State == OpenInBEstablished);
    H245TRACE(pObject->dwInst, 2, "Overriding H245_IND_OPEN to API; Channel=%d", pObject->Key);

    pObject->State = OpenInBAwaitingEstablishment;

#if defined(SDL_COMPLIANT)
    /* Send RELEASE.indication to client */
    H245FsmIndication(pPdu, H245_IND_CLOSE, pObject->pInstance, 0, FSM_OK);
#endif

    /* Send ESTABLISH.indication to client*/
    H245FsmIndication(pPdu, H245_IND_OPEN, pObject->pInstance, 0, FSM_OK);

    return 0;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\openu.h ===
/***********************************************************************
 *                                                                     *
 * Filename: openu.h                                                   *
 * Module:   H245 Finite State Machine Subsystem                       *
 *                                                                     *
 ***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *                                                                     *
 * $Workfile:   OPENU.H  $
 * $Revision:   1.2  $
 * $Modtime:   09 Dec 1996 13:42:50  $
 * $Log:   S:/STURGEON/SRC/H245/INCLUDE/VCS/OPENU.H_v  $
 * 
 *    Rev 1.2   09 Dec 1996 13:43:00   EHOWARDX
 * Updated copyright notice.
 * 
 *    Rev 1.1   30 May 1996 23:38:28   EHOWARDX
 * Cleanup.
 * 
 *    Rev 1.0   09 May 1996 21:04:56   EHOWARDX
 * Initial revision.
 * 
 *    Rev 1.6.1.2   15 Apr 1996 10:43:56   EHOWARDX
 * Update.
 * 
 *    Rev 1.6.1.1   10 Apr 1996 21:06:40   EHOWARDX
 * Deleted No-op functions; moved state defines to .C file.
 * 
 *    Rev 1.6.1.0   05 Apr 1996 12:14:26   helgebax
 * Branched.
 *                                                                     *
 ***********************************************************************/

// Open Uni-directional Logical Channel Out-going state functions
HRESULT establishReleased               (Object_t *pObject, PDU_t *pPdu);
HRESULT openAckAwaitingE                (Object_t *pObject, PDU_t *pPdu);
HRESULT openRejAwaitingE                (Object_t *pObject, PDU_t *pPdu);
HRESULT releaseAwaitingE                (Object_t *pObject, PDU_t *pPdu);
HRESULT t103AwaitingE                   (Object_t *pObject, PDU_t *pPdu);
HRESULT releaseEstablished              (Object_t *pObject, PDU_t *pPdu);
HRESULT openRejEstablished              (Object_t *pObject, PDU_t *pPdu);
HRESULT closeAckEstablished             (Object_t *pObject, PDU_t *pPdu);
HRESULT closeAckAwaitingR               (Object_t *pObject, PDU_t *pPdu);
HRESULT openRejAwaitingR                (Object_t *pObject, PDU_t *pPdu);
HRESULT t103AwaitingR                   (Object_t *pObject, PDU_t *pPdu);
HRESULT establishAwaitingR              (Object_t *pObject, PDU_t *pPdu);

// Open Uni-directional Logical Channel In-coming state functions
HRESULT openReleased                    (Object_t *pObject, PDU_t *pPdu);
HRESULT closeReleased                   (Object_t *pObject, PDU_t *pPdu);
HRESULT responseAwaiting                (Object_t *pObject, PDU_t *pPdu);
HRESULT releaseAwaiting                 (Object_t *pObject, PDU_t *pPdu);
HRESULT closeAwaiting                   (Object_t *pObject, PDU_t *pPdu);
HRESULT openAwaiting                    (Object_t *pObject, PDU_t *pPdu);
HRESULT closeEstablished                (Object_t *pObject, PDU_t *pPdu);
HRESULT openEstablished                 (Object_t *pObject, PDU_t *pPdu);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\pdu.c ===
/***************************************************************************
 *
 *   INTEL Corporation Proprietary Information
 *   Copyright (c) 1994, 1995, 1996 Intel Corporation.
 *
 *   This listing is supplied under the terms of a license agreement
 *   with INTEL Corporation and may not be used, copied, nor disclosed
 *   except in accordance with the terms of that agreement.
 *
 ***************************************************************************
 *
 *  $Workfile:   pdu.c  $
 *  $Revision:   1.13  $
 *  $Modtime:   27 Jan 1997 12:33:26  $
 *  $Log:   S:/STURGEON/SRC/H245/SRC/VCS/pdu.c_v  $
 *
 *    Rev 1.13   27 Jan 1997 12:40:28   MANDREWS
 *
 * Fixed warnings.
 *
 *    Rev 1.12   28 Aug 1996 11:37:26   EHOWARDX
 * const changes.
 *
 *    Rev 1.11   19 Aug 1996 15:38:36   EHOWARDX
 * Initialized lResult to H245_ERROR_OK in SetupCommModeEntry().
 *
 *    Rev 1.10   15 Aug 1996 15:20:34   EHOWARDX
 * First pass at new H245_COMM_MODE_ENTRY_T requested by Mike Andrews.
 * Use at your own risk!
 *
 *    Rev 1.9   08 Aug 1996 16:01:56   EHOWARDX
 *
 * Change pdu_rsp_mstslv_ack to take either master_chosen or slave_chosen
 * as second parameter.
 *
 *    Rev 1.8   19 Jul 1996 12:14:30   EHOWARDX
 * Eliminated pdu_cmd_misc.
 *
 *    Rev 1.7   09 Jul 1996 17:10:26   EHOWARDX
 * Fixed pointer offset bug in processing DataType from received
 * OpenLogicalChannel.
 *
 *    Rev 1.6   14 Jun 1996 18:58:32   EHOWARDX
 * Geneva Update.
 *
 *    Rev 1.5   10 Jun 1996 16:52:24   EHOWARDX
 * Eliminated #include "h245init.x"
 *
 *    Rev 1.4   30 May 1996 23:39:22   EHOWARDX
 * Cleanup.
 *
 *    Rev 1.3   29 May 1996 15:20:22   EHOWARDX
 * Change to use HRESULT.
 *
 *    Rev 1.2   28 May 1996 14:25:20   EHOWARDX
 * Tel Aviv update.
 *
 *    Rev 1.1   13 May 1996 23:16:40   EHOWARDX
 * Fixed remote terminal capability handling.
 *
 *    Rev 1.0   09 May 1996 21:06:38   EHOWARDX
 * Initial revision.
 *
 *    Rev 1.27   09 May 1996 19:32:46   EHOWARDX
 * Added support for new H.245 fields (e.g. SeparateStack).
 *
 *    Rev 1.26   01 May 1996 19:28:24   EHOWARDX
 * Changed H2250_xxx defines from H2250 address type to H245_xxx defines.
 *
 *    Rev 1.25   27 Apr 1996 21:10:42   EHOWARDX
 * Cleaned up multiplex ack parameter handling.
 *
 *    Rev 1.23.1.5   25 Apr 1996 17:54:34   EHOWARDX
 * Changed wTxPort to dwTxPort in pdu_req_open_logical_channel().
 *
 *    Rev 1.23.1.4   24 Apr 1996 20:51:24   EHOWARDX
 * Added new OpenLogicalChannelAck support.
 *
 *    Rev 1.23.1.3   16 Apr 1996 20:10:58   EHOWARDX
 * Added support for H2250LogicalParameters to OpenLogicalChannel.
 *
 *    Rev 1.23.1.2   15 Apr 1996 15:14:20   EHOWARDX
 * Updated Open Logical Channel to match current ASN.1 syntax structure.
 *
 *    Rev 1.23.1.1   02 Apr 1996 22:35:04   EHOWARDX
 * Needed to initialize setupType.choice in H245OpenChannel.
 * (This field is probably soon to be obsolete, but right now
 * the PDU encode rejects it if it is not initialized.
 *
 *    Rev 1.23.1.0   28 Mar 1996 20:17:18   EHOWARDX
 *
 * Changes for new ASN syntax additions.
 *
 *    Rev 1.22   13 Mar 1996 10:12:00   cjutzi
 *
 * - was not puting sequence number in mux_acc or mux_rej
 *
 *    Rev 1.21   12 Mar 1996 15:50:22   cjutzi
 *
 * added EndSession
 *
 *    Rev 1.20   11 Mar 1996 14:04:32   cjutzi
 * - added ind_multiplex_entry_send_release.. back in.. and to the header..
 *
 *    Rev 1.19   08 Mar 1996 14:01:04   cjutzi
 *
 * - added Multiplex Entry stuff
 *
 *    Rev 1.18   06 Mar 1996 08:43:32   cjutzi
 * - fixed constraints on sub element lists, and nesting depth for
 *   mux table pdu build..
 *
 *    Rev 1.17   05 Mar 1996 19:40:04   EHOWARDX
 * Put pdu_ind_multiplex_entry_send_release() and
 * pdu_ind_request_multiplex_entry_release() functions back in after
 * Curt was so kind as to delete them for us.
 *
 *    Rev 1.16   05 Mar 1996 17:33:12   cjutzi
 *
 * - fixed, and imlemented down muxt table entries,
 * - removed bzero/bcopy and fixed free api call
 *
 *    Rev 1.15   02 Mar 1996 22:14:18   DABROWN1
 *
 *    Rev 1.14   28 Feb 1996 19:06:34   unknown
 * Oops! Gotta watch those global replaces... (Changed H245ASSERT
 * back to ASSERT)
 *
 *    Rev 1.13   28 Feb 1996 18:29:34   EHOWARDX
 * Changed ASSERT() to ASSERT().
 *
 *    Rev 1.12   28 Feb 1996 16:08:36   EHOWARDX
 *
 * Changed pTable to WORD pointer.
 *
 *    Rev 1.11   28 Feb 1996 14:01:42   EHOWARDX
 *
 * Added MultiplexEntry functions:
 *   pdu_req_multiplex_entry_send
 *   pdu_rsp_multiplex_entry_send_ack
 *   pdu_rsp_multiplex_entry_send_reject
 *   pdu_ind_multiplex_entry_send_release
 *   pdu_ind_request_multiplex_entry_release
 *
 *    Rev 1.10   26 Feb 1996 17:25:14   cjutzi
 *
 * - implemented MISCCMD command for PDU's
 *
 *    Rev 1.9   26 Feb 1996 09:24:30   cjutzi
 * - removed req_termcqap_set (bit_mask) setup.. moved to main line
 *   code.. rather than the pdu build..
 *
 *    Rev 1.8   22 Feb 1996 12:43:16   unknown
 * Fixed bitmask Open Ack problem
 *
 *    Rev 1.7   21 Feb 1996 14:17:36   unknown
 * No change.
 *
 *    Rev 1.6   15 Feb 1996 10:55:16   cjutzi
 *
 * - fixed open pdu problem bit-mask
 * - changed interface for MUX_T
 *
 *    Rev 1.5   13 Feb 1996 14:39:48   DABROWN1
 * Removed SPOX dependent include files from mainline
 *
 *    Rev 1.4   13 Feb 1996 13:27:04   cjutzi
 * - fixed a problem w/ open channel
 *
 *    Rev 1.3   09 Feb 1996 15:49:48   cjutzi
 *
 * - added dollar log to header.
 * - changed bitmask on open.. hadn't set forward open parameters to present..
 *
 ***************************************************************************/
#ifndef STRICT
#define STRICT
#endif

#include "precomp.h"

/***********************/
/*    H245 INCLUDES    */
/***********************/
#include "h245asn1.h"                   /* must be included before H245api.h */
#include "h245api.h"
#include "h245com.h"
#include "h245sys.x"
#include "api_util.x"	                /* for free_mux_desc_list */
#include "pdu.x"



HRESULT
SetupUnicastAddress (UnicastAddress                  *pOut,
                     const H245_TRANSPORT_ADDRESS_T  *pIn)
{
  switch (pIn->type)
  {
  case H245_IP_UNICAST:
    pOut->choice = UnicastAddress_iPAddress_chosen;
    pOut->u.UnicastAddress_iPAddress.network.length = 4;
    memcpy(pOut->u.UnicastAddress_iPAddress.network.value, pIn->u.ip.network, 4);
    pOut->u.UnicastAddress_iPAddress.tsapIdentifier = pIn->u.ip.tsapIdentifier;
    break;

  case H245_IP6_UNICAST:
    pOut->choice = UncstAddrss_iP6Address_chosen;
    pOut->u.UncstAddrss_iP6Address.network.length = 16;
    memcpy(pOut->u.UncstAddrss_iP6Address.network.value, pIn->u.ip6.network, 16);
    pOut->u.UncstAddrss_iP6Address.tsapIdentifier = pIn->u.ip6.tsapIdentifier;
    break;

  case H245_IPSSR_UNICAST:
    pOut->choice = iPSourceRouteAddress_chosen;
    pOut->u.iPSourceRouteAddress.routing.choice = strict_chosen;
    pOut->u.iPSourceRouteAddress.network.length = 4;
    memcpy(pOut->u.iPSourceRouteAddress.network.value, pIn->u.ipSourceRoute.network, 4);
    pOut->u.iPSourceRouteAddress.tsapIdentifier = pIn->u.ipSourceRoute.tsapIdentifier;
    // TBD - handle route
    return H245_ERROR_NOTIMP;
    break;

  case H245_IPLSR_UNICAST:
    pOut->choice = iPSourceRouteAddress_chosen;
    pOut->u.iPSourceRouteAddress.routing.choice = loose_chosen;
    pOut->u.iPSourceRouteAddress.network.length = 4;
    memcpy(pOut->u.iPSourceRouteAddress.network.value, pIn->u.ipSourceRoute.network, 4);
    pOut->u.iPSourceRouteAddress.tsapIdentifier = pIn->u.ipSourceRoute.tsapIdentifier;
    // TBD - handle route
    return H245_ERROR_NOTIMP;
    break;

  case H245_IPX_UNICAST:
    pOut->choice = iPXAddress_chosen;
    pOut->u.iPXAddress.node.length = 6;
    memcpy(pOut->u.iPXAddress.node.value, pIn->u.ipx.node, 6);
    pOut->u.iPXAddress.netnum.length = 4;
    memcpy(pOut->u.iPXAddress.netnum.value, pIn->u.ipx.netnum, 4);
    pOut->u.iPXAddress.tsapIdentifier.length = 2;
    memcpy(pOut->u.iPXAddress.tsapIdentifier.value, pIn->u.ipx.tsapIdentifier, 2);
    break;

  case H245_NETBIOS_UNICAST:
    pOut->choice = netBios_chosen;
    pOut->u.netBios.length = 16;
    memcpy(pOut->u.netBios.value, pIn->u.netBios, 16);
    break;

  default:
	  H245TRACE(0,1,"API:SetupUnicastAddress: invalid address type %d", pIn->type);
    return H245_ERROR_PARAM;
  } // switch

  return H245_ERROR_OK;
} // SetupUnicastAddress()



HRESULT
SetupMulticastAddress (MulticastAddress                *pOut,
                       const H245_TRANSPORT_ADDRESS_T  *pIn)
{
  switch (pIn->type)
  {
  case H245_IP_MULTICAST:
    pOut->choice = MltcstAddrss_iPAddress_chosen;
    pOut->u.MltcstAddrss_iPAddress.network.length = 4;
    memcpy(pOut->u.MltcstAddrss_iPAddress.network.value, pIn->u.ip.network, 4);
    pOut->u.MltcstAddrss_iPAddress.tsapIdentifier = pIn->u.ip.tsapIdentifier;
    break;

  case H245_IP6_MULTICAST:
    pOut->choice = MltcstAddrss_iP6Address_chosen;
    pOut->u.MltcstAddrss_iP6Address.network.length = 16;
    memcpy(pOut->u.MltcstAddrss_iP6Address.network.value, pIn->u.ip6.network, 16);
    pOut->u.MltcstAddrss_iP6Address.tsapIdentifier = pIn->u.ip6.tsapIdentifier;
    break;

  default:
    H245TRACE(0,1,"API:SetupMulticastAddress: invalid address type %d", pIn->type);
    return H245_ERROR_PARAM;
  } // switch

  return H245_ERROR_OK;
} // SetupMulticastAddress()



HRESULT
SetupTransportAddress ( H245TransportAddress               *pOut,
                        const H245_TRANSPORT_ADDRESS_T *pIn)
{
  if (pIn->type & 1)
  {
    pOut->choice = unicastAddress_chosen;
    return SetupUnicastAddress(&pOut->u.unicastAddress, pIn);
  }
  else
  {
    pOut->choice = multicastAddress_chosen;
    return SetupMulticastAddress(&pOut->u.multicastAddress, pIn);
  }
} // SetupTransportAddress()



HRESULT
SetupCommModeEntry    ( CommunicationModeTableEntry        *pOut,
                        const H245_COMM_MODE_ENTRY_T       *pIn)
{
  HRESULT   lResult = H245_ERROR_OK;

  memset(pOut, 0, sizeof(*pOut));
  if (pIn->pNonStandard != NULL)
  {
    pOut->CMTEy_nnStndrd = pIn->pNonStandard;
    pOut->bit_mask |= CMTEy_nnStndrd_present;
  }

  pOut->sessionID = pIn->sessionID;

  if (pIn->associatedSessionIDPresent)
  {
    pOut->CMTEy_assctdSssnID = pIn->associatedSessionID;
    pOut->bit_mask |= CMTEy_assctdSssnID_present;
  }

  if (pIn->terminalLabelPresent)
  {
    pOut->terminalLabel = pIn->terminalLabel;
    pOut->bit_mask |= CommunicationModeTableEntry_terminalLabel_present;
  }

  pOut->sessionDescription.value  = pIn->pSessionDescription;
  pOut->sessionDescription.length = pIn->wSessionDescriptionLength;

  switch (pIn->dataType.ClientType)
  {
  case H245_CLIENT_VID_NONSTD:
    H245TRACE(0,20,"SetupCommModeEntry: H245_CLIENT_VID_NONSTD");
    lResult = CopyNonStandardParameter(&pOut->dataType.u.dataType_videoData.u.VdCpblty_nonStandard,
                                       &pIn->dataType.Cap.H245Vid_NONSTD);
    pOut->dataType.u.dataType_videoData.choice = VdCpblty_nonStandard_chosen;
    pOut->dataType.choice = dataType_videoData_chosen;
    break;
  case H245_CLIENT_VID_H261:
    H245TRACE(0,20,"SetupCommModeEntry: H245_CLIENT_VID_H261");
    pOut->dataType.u.dataType_videoData.u.h261VideoCapability = pIn->dataType.Cap.H245Vid_H261;
    pOut->dataType.u.dataType_videoData.choice = h261VideoCapability_chosen;
    pOut->dataType.choice = dataType_videoData_chosen;
    break;
  case H245_CLIENT_VID_H262:
    H245TRACE(0,20,"SetupCommModeEntry: H245_CLIENT_VID_H262");
    pOut->dataType.u.dataType_videoData.u.h262VideoCapability = pIn->dataType.Cap.H245Vid_H262;
    pOut->dataType.u.dataType_videoData.choice = h262VideoCapability_chosen;
    pOut->dataType.choice = dataType_videoData_chosen;
    break;
  case H245_CLIENT_VID_H263:
    H245TRACE(0,20,"SetupCommModeEntry: H245_CLIENT_VID_H263");
    pOut->dataType.u.dataType_videoData.u.h263VideoCapability = pIn->dataType.Cap.H245Vid_H263;
    pOut->dataType.u.dataType_videoData.choice = h263VideoCapability_chosen;
    pOut->dataType.choice = dataType_videoData_chosen;
    break;
  case H245_CLIENT_VID_IS11172:
    H245TRACE(0,20,"SetupCommModeEntry: H245_CLIENT_VID_IS11172");
    pOut->dataType.u.dataType_videoData.u.is11172VideoCapability = pIn->dataType.Cap.H245Vid_IS11172;
    pOut->dataType.u.dataType_videoData.choice = is11172VideoCapability_chosen;
    pOut->dataType.choice = dataType_videoData_chosen;
    break;

  case H245_CLIENT_AUD_NONSTD:
    H245TRACE(0,20,"SetupCommModeEntry: H245_CLIENT_AUD_NONSTD");
    lResult = CopyNonStandardParameter(&pOut->dataType.u.dataType_audioData.u.AdCpblty_nonStandard,
                                      &pIn->dataType.Cap.H245Aud_NONSTD);
    pOut->dataType.u.dataType_audioData.choice = AdCpblty_nonStandard_chosen;
    pOut->dataType.choice = dataType_audioData_chosen;



    break;
  case H245_CLIENT_AUD_G711_ALAW64:
    H245TRACE(0,20,"SetupCommModeEntry: H245_CLIENT_AUD_G711_ALAW64");
    pOut->dataType.u.dataType_audioData.u.AdCpblty_g711Alaw64k = pIn->dataType.Cap.H245Aud_G711_ALAW64;
    pOut->dataType.u.dataType_audioData.choice = AdCpblty_g711Alaw64k_chosen;
    pOut->dataType.choice = dataType_audioData_chosen;
    break;
  case H245_CLIENT_AUD_G711_ALAW56:
    H245TRACE(0,20,"SetupCommModeEntry: H245_CLIENT_AUD_G711_ALAW56");
    pOut->dataType.u.dataType_audioData.u.AdCpblty_g711Alaw56k = pIn->dataType.Cap.H245Aud_G711_ALAW56;
    pOut->dataType.u.dataType_audioData.choice = AdCpblty_g711Alaw56k_chosen;
    pOut->dataType.choice = dataType_audioData_chosen;
    break;
  case H245_CLIENT_AUD_G711_ULAW64:
    H245TRACE(0,20,"SetupCommModeEntry: H245_CLIENT_AUD_G711_ULAW64");
    pOut->dataType.u.dataType_audioData.u.AdCpblty_g711Ulaw64k = pIn->dataType.Cap.H245Aud_G711_ULAW64;
    pOut->dataType.u.dataType_audioData.choice = AdCpblty_g711Ulaw64k_chosen;
    pOut->dataType.choice = dataType_audioData_chosen;
    break;
  case H245_CLIENT_AUD_G711_ULAW56:
    H245TRACE(0,20,"SetupCommModeEntry: H245_CLIENT_AUD_G711_ULAW56");
    pOut->dataType.u.dataType_audioData.u.AdCpblty_g711Ulaw56k = pIn->dataType.Cap.H245Aud_G711_ULAW56;
    pOut->dataType.u.dataType_audioData.choice = AdCpblty_g711Ulaw56k_chosen;
    pOut->dataType.choice = dataType_audioData_chosen;
    break;
  case H245_CLIENT_AUD_G722_64:
    H245TRACE(0,20,"SetupCommModeEntry: H245_CLIENT_AUD_G722_64");
    pOut->dataType.u.dataType_audioData.u.AudioCapability_g722_64k = pIn->dataType.Cap.H245Aud_G722_64;
    pOut->dataType.u.dataType_audioData.choice = AudioCapability_g722_64k_chosen;
    pOut->dataType.choice = dataType_audioData_chosen;
    break;
  case H245_CLIENT_AUD_G722_56:
    H245TRACE(0,20,"SetupCommModeEntry: H245_CLIENT_AUD_G722_56");
    pOut->dataType.u.dataType_audioData.u.AudioCapability_g722_56k = pIn->dataType.Cap.H245Aud_G722_56;
    pOut->dataType.u.dataType_audioData.choice = AudioCapability_g722_56k_chosen;
    pOut->dataType.choice = dataType_audioData_chosen;
    break;
  case H245_CLIENT_AUD_G722_48:
    H245TRACE(0,20,"SetupCommModeEntry: H245_CLIENT_AUD_G722_48");
    pOut->dataType.u.dataType_audioData.u.AudioCapability_g722_48k = pIn->dataType.Cap.H245Aud_G722_48;
    pOut->dataType.u.dataType_audioData.choice = AudioCapability_g722_48k_chosen;
    pOut->dataType.choice = dataType_audioData_chosen;
    break;
  case H245_CLIENT_AUD_G723:
    H245TRACE(0,20,"SetupCommModeEntry: H245_CLIENT_AUD_G723");
    pOut->dataType.u.dataType_audioData.u.AudioCapability_g7231 = pIn->dataType.Cap.H245Aud_G723;
    pOut->dataType.u.dataType_audioData.choice = AudioCapability_g7231_chosen;
    pOut->dataType.choice = dataType_audioData_chosen;
    break;
  case H245_CLIENT_AUD_G728:
    H245TRACE(0,20,"SetupCommModeEntry: H245_CLIENT_AUD_G728");
    pOut->dataType.u.dataType_audioData.u.AudioCapability_g728 = pIn->dataType.Cap.H245Aud_G728;
    pOut->dataType.u.dataType_audioData.choice = AudioCapability_g728_chosen;
    pOut->dataType.choice = dataType_audioData_chosen;
    break;
  case H245_CLIENT_AUD_G729:
    H245TRACE(0,20,"SetupCommModeEntry: H245_CLIENT_AUD_G729");
    pOut->dataType.u.dataType_audioData.u.AudioCapability_g729 = pIn->dataType.Cap.H245Aud_G729;
    pOut->dataType.u.dataType_audioData.choice = AudioCapability_g729_chosen;
    pOut->dataType.choice = dataType_audioData_chosen;
    break;
  case H245_CLIENT_AUD_GDSVD:
    H245TRACE(0,20,"SetupCommModeEntry: H245_CLIENT_AUD_GDSVD");
    pOut->dataType.u.dataType_audioData.u.AdCpblty_g729AnnexA = pIn->dataType.Cap.H245Aud_GDSVD;
    pOut->dataType.u.dataType_audioData.choice = AdCpblty_g729AnnexA_chosen;
    pOut->dataType.choice = dataType_audioData_chosen;
    break;
  case H245_CLIENT_AUD_IS11172:
    H245TRACE(0,20,"SetupCommModeEntry: H245_CLIENT_AUD_IS11172");
    pOut->dataType.u.dataType_audioData.u.is11172AudioCapability = pIn->dataType.Cap.H245Aud_IS11172;
    pOut->dataType.u.dataType_audioData.choice = is11172AudioCapability_chosen;
    pOut->dataType.choice = dataType_audioData_chosen;
    break;
  case H245_CLIENT_AUD_IS13818:
    H245TRACE(0,20,"SetupCommModeEntry: H245_CLIENT_AUD_IS13818");
    pOut->dataType.u.dataType_audioData.u.is13818AudioCapability = pIn->dataType.Cap.H245Aud_IS13818;
    pOut->dataType.u.dataType_audioData.choice = is13818AudioCapability_chosen;
    pOut->dataType.choice = dataType_audioData_chosen;
    break;

  case H245_CLIENT_DAT_NONSTD:
    H245TRACE(0,20,"SetupCommModeEntry: H245_CLIENT_DAT_NONSTD");
    pOut->dataType.u.dataType_data = pIn->dataType.Cap.H245Dat_NONSTD;
    lResult = CopyNonStandardParameter(&pOut->dataType.u.dataType_data.application.u.DACy_applctn_nnStndrd,
                                            &pIn->dataType.Cap.H245Dat_NONSTD.application.u.DACy_applctn_nnStndrd);
    pOut->dataType.u.dataType_data.application.choice = DACy_applctn_nnStndrd_chosen;
    pOut->dataType.choice = dataType_data_chosen;
    break;
  case H245_CLIENT_DAT_T120:
    H245TRACE(0,20,"SetupCommModeEntry: H245_CLIENT_DAT_T120");
    pOut->dataType.u.dataType_data = pIn->dataType.Cap.H245Dat_T120;
    if (pIn->dataType.Cap.H245Dat_T120.application.u.DACy_applctn_t120.choice == DtPrtclCpblty_nnStndrd_chosen)
    {
      lResult = CopyNonStandardParameter(&pOut->dataType.u.dataType_data.application.u.DACy_applctn_t120.u.DtPrtclCpblty_nnStndrd,
                                                &pIn->dataType.Cap.H245Dat_T120.application.u.DACy_applctn_t120.u.DtPrtclCpblty_nnStndrd);
    }
    pOut->dataType.u.dataType_data.application.choice = DACy_applctn_t120_chosen;
    pOut->dataType.choice = dataType_data_chosen;
    break;
  case H245_CLIENT_DAT_DSMCC:
    H245TRACE(0,20,"SetupCommModeEntry: H245_CLIENT_DAT_DSMCC");
    pOut->dataType.u.dataType_data = pIn->dataType.Cap.H245Dat_DSMCC;
    if (pIn->dataType.Cap.H245Dat_DSMCC.application.u.DACy_applctn_dsm_cc.choice == DtPrtclCpblty_nnStndrd_chosen)
    {
      lResult = CopyNonStandardParameter(&pOut->dataType.u.dataType_data.application.u.DACy_applctn_dsm_cc.u.DtPrtclCpblty_nnStndrd,
                                                &pIn->dataType.Cap.H245Dat_DSMCC.application.u.DACy_applctn_dsm_cc.u.DtPrtclCpblty_nnStndrd);
    }
    pOut->dataType.u.dataType_data.application.choice = DACy_applctn_dsm_cc_chosen;
    pOut->dataType.choice = dataType_data_chosen;
    break;
  case H245_CLIENT_DAT_USERDATA:
    H245TRACE(0,20,"SetupCommModeEntry: H245_CLIENT_DAT_USERDATA");
    pOut->dataType.u.dataType_data = pIn->dataType.Cap.H245Dat_USERDATA;
    if (pIn->dataType.Cap.H245Dat_USERDATA.application.u.DACy_applctn_usrDt.choice == DtPrtclCpblty_nnStndrd_chosen)
    {
      lResult = CopyNonStandardParameter(&pOut->dataType.u.dataType_data.application.u.DACy_applctn_usrDt.u.DtPrtclCpblty_nnStndrd,
                                            &pIn->dataType.Cap.H245Dat_USERDATA.application.u.DACy_applctn_usrDt.u.DtPrtclCpblty_nnStndrd);
    }
    pOut->dataType.u.dataType_data.application.choice = DACy_applctn_usrDt_chosen;
    pOut->dataType.choice = dataType_data_chosen;
    break;
  case H245_CLIENT_DAT_T84:
    H245TRACE(0,20,"SetupCommModeEntry: H245_CLIENT_DAT_T84");
    pOut->dataType.u.dataType_data = pIn->dataType.Cap.H245Dat_T84;
    if (pIn->dataType.Cap.H245Dat_T84.application.u.DACy_applctn_t84.t84Protocol.choice == DtPrtclCpblty_nnStndrd_chosen)
    {
      lResult = CopyNonStandardParameter(&pOut->dataType.u.dataType_data.application.u.DACy_applctn_t84.t84Protocol.u.DtPrtclCpblty_nnStndrd,
                                                  &pIn->dataType.Cap.H245Dat_T84.application.u.DACy_applctn_t84.t84Protocol.u.DtPrtclCpblty_nnStndrd);
    }
    pOut->dataType.u.dataType_data.application.choice = DACy_applctn_t84_chosen;
    pOut->dataType.choice = dataType_data_chosen;
    break;
  case H245_CLIENT_DAT_T434:
    H245TRACE(0,20,"SetupCommModeEntry: H245_CLIENT_DAT_T434");
    pOut->dataType.u.dataType_data = pIn->dataType.Cap.H245Dat_T434;
    if (pIn->dataType.Cap.H245Dat_T434.application.u.DACy_applctn_t434.choice == DtPrtclCpblty_nnStndrd_chosen)
    {
      lResult = CopyNonStandardParameter(&pOut->dataType.u.dataType_data.application.u.DACy_applctn_t434.u.DtPrtclCpblty_nnStndrd,
                                                &pIn->dataType.Cap.H245Dat_T434.application.u.DACy_applctn_t434.u.DtPrtclCpblty_nnStndrd);
    }
    pOut->dataType.u.dataType_data.application.choice = DACy_applctn_t434_chosen;
    pOut->dataType.choice = dataType_data_chosen;
    break;
  case H245_CLIENT_DAT_H224:
    H245TRACE(0,20,"SetupCommModeEntry: H245_CLIENT_DAT_H224");
    pOut->dataType.u.dataType_data = pIn->dataType.Cap.H245Dat_H224;
    if (pIn->dataType.Cap.H245Dat_H224.application.u.DACy_applctn_h224.choice == DtPrtclCpblty_nnStndrd_chosen)
    {
      lResult = CopyNonStandardParameter(&pOut->dataType.u.dataType_data.application.u.DACy_applctn_h224.u.DtPrtclCpblty_nnStndrd,
                                                &pIn->dataType.Cap.H245Dat_H224.application.u.DACy_applctn_h224.u.DtPrtclCpblty_nnStndrd);
    }
    pOut->dataType.u.dataType_data.application.choice = DACy_applctn_h224_chosen;
    pOut->dataType.choice = dataType_data_chosen;
    break;
  case H245_CLIENT_DAT_NLPID:
    H245TRACE(0,20,"SetupCommModeEntry: H245_CLIENT_DAT_NLPID");
    pOut->dataType.u.dataType_data = pIn->dataType.Cap.H245Dat_NLPID;
    if (pIn->dataType.Cap.H245Dat_NLPID.application.u.DACy_applctn_nlpd.nlpidProtocol.choice == DtPrtclCpblty_nnStndrd_chosen)
    {
      lResult = CopyNonStandardParameter(&pOut->dataType.u.dataType_data.application.u.DACy_applctn_nlpd.nlpidProtocol.u.DtPrtclCpblty_nnStndrd,
                                                &pIn->dataType.Cap.H245Dat_NLPID.application.u.DACy_applctn_nlpd.nlpidProtocol.u.DtPrtclCpblty_nnStndrd);
    }
    if (lResult == H245_ERROR_OK && pIn->dataType.Cap.H245Dat_NLPID.application.u.DACy_applctn_nlpd.nlpidData.length != 0)
    {
      pOut->dataType.u.dataType_data.application.u.DACy_applctn_nlpd.nlpidData.value =
        MemAlloc(pIn->dataType.Cap.H245Dat_NLPID.application.u.DACy_applctn_nlpd.nlpidData.length);
      if (pOut->dataType.u.dataType_data.application.u.DACy_applctn_nlpd.nlpidData.value)
      {
        memcpy(pOut->dataType.u.dataType_data.application.u.DACy_applctn_nlpd.nlpidData.value,
                pIn->dataType.Cap.H245Dat_NLPID.application.u.DACy_applctn_nlpd.nlpidData.value,
                pIn->dataType.Cap.H245Dat_NLPID.application.u.DACy_applctn_nlpd.nlpidData.length);
      }
      else
        lResult = H245_ERROR_NOMEM;
    }
    else
      pOut->dataType.u.dataType_data.application.u.DACy_applctn_nlpd.nlpidData.value = NULL;

    pOut->dataType.u.dataType_data.application.choice = DACy_applctn_nlpd_chosen;
    pOut->dataType.choice = dataType_data_chosen;
    break;
  case H245_CLIENT_DAT_DSVD:
    H245TRACE(0,20,"SetupCommModeEntry: H245_CLIENT_DAT_DSVD");
    pOut->dataType.u.dataType_data = pIn->dataType.Cap.H245Dat_DSMCC;
    pOut->dataType.u.dataType_data.application.choice = DACy_applctn_dsvdCntrl_chosen;
    pOut->dataType.choice = dataType_data_chosen;
    break;
  case H245_CLIENT_DAT_H222:
    H245TRACE(0,20,"SetupCommModeEntry: H245_CLIENT_DAT_H222");
    pOut->dataType.u.dataType_data = pIn->dataType.Cap.H245Dat_H222;
    if (pIn->dataType.Cap.H245Dat_H222.application.u.DACy_an_h222DtPrttnng.choice == DtPrtclCpblty_nnStndrd_chosen)
    {
      lResult = CopyNonStandardParameter(&pOut->dataType.u.dataType_data.application.u.DACy_an_h222DtPrttnng.u.DtPrtclCpblty_nnStndrd,
                                         &pIn->dataType.Cap.H245Dat_H222.application.u.DACy_an_h222DtPrttnng.u.DtPrtclCpblty_nnStndrd);
    }
    pOut->dataType.u.dataType_data.application.choice = DACy_an_h222DtPrttnng_chosen ;
    pOut->dataType.choice = dataType_data_chosen;
    break;
  default:
    H245TRACE(0,20,"SetupCommModeEntry: default");
    lResult = H245_ERROR_NOSUP;
  } /* switch */
  
  if (H245_ERROR_OK != lResult)
    return lResult;

  if (pIn->mediaChannelPresent)
  {
    lResult = SetupTransportAddress(&pOut->CMTEy_mdChnnl, &pIn->mediaChannel);
    
    if (H245_ERROR_OK != lResult)
      return lResult;
    
    pOut->bit_mask |= CMTEy_mdChnnl_present;
  }

  if (pIn->mediaGuaranteedPresent)
  {
    pOut->CMTEy_mdGrntdDlvry = pIn->mediaGuaranteed;
    pOut->bit_mask |= CMTEy_mdGrntdDlvry_present;
  }

  if (pIn->mediaControlChannelPresent)
  {
    lResult = SetupTransportAddress(&pOut->CMTEy_mdCntrlChnnl, &pIn->mediaControlChannel);
    
    if (H245_ERROR_OK != lResult)
      return lResult;
    
    pOut->bit_mask |= CMTEy_mdCntrlChnnl_present;
  }

  if (pIn->mediaControlGuaranteedPresent)
  {
    pOut->CMTEy_mdCntrlGrntdDlvry = pIn->mediaControlGuaranteed;
    pOut->bit_mask |= CMTEy_mdCntrlGrntdDlvry_present;
  }

  return H245_ERROR_OK;
} // SetupCommModeEntry()



/*****************************************************************************
 *
 * TYPE:        Local
 *
 * PROCEDURE:   setup_H223_mux
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/
static HRESULT
setup_H222_mux (H222LogicalChannelParameters         *pOut,
                const H245_H222_LOGICAL_PARAM_T      *pIn)
{
  /* See load_H222_param() for inverse function */
  pOut->bit_mask     = 0;
  pOut->resourceID   = pIn->resourceID;
  pOut->subChannelID = pIn->subChannelID;
  if (pIn->pcr_pidPresent)
  {
    pOut->bit_mask |= pcr_pid_present;
    pOut->pcr_pid = pIn->pcr_pid;
  }
  if (pIn->programDescriptors.length && pIn->programDescriptors.value)
  {
    pOut->bit_mask |= programDescriptors_present;
    pOut->programDescriptors.length = (WORD)pIn->programDescriptors.length;
    pOut->programDescriptors.value  = pIn->programDescriptors.value;
  }
  if (pIn->streamDescriptors.length && pIn->streamDescriptors.value)
  {
    pOut->bit_mask |= streamDescriptors_present;
    pOut->streamDescriptors.length = (WORD)pIn->streamDescriptors.length;
    pOut->streamDescriptors.value  = pIn->streamDescriptors.value;
  }
  return H245_ERROR_OK;
} // setup_H222_mux

static HRESULT
setup_H223_mux (H223LogicalChannelParameters         *pOut,
		            const H245_H223_LOGICAL_PARAM_T      *pIn)
{
  /* See load_H223_param() for inverse function */
  switch (pIn->AlType)
  {
  case H245_H223_AL_NONSTD:
    pOut->adaptationLayerType.u.H223LCPs_aLTp_nnStndrd = pIn->H223_NONSTD;
    pOut->adaptationLayerType.choice = H223LCPs_aLTp_nnStndrd_chosen;
    break;

  case H245_H223_AL_AL1FRAMED:
    pOut->adaptationLayerType.choice = H223LCPs_aLTp_al1Frmd_chosen;
    break;

  case H245_H223_AL_AL1NOTFRAMED:
    pOut->adaptationLayerType.choice = H223LCPs_aLTp_al1NtFrmd_chosen;
    break;

  case H245_H223_AL_AL2NOSEQ:
    pOut->adaptationLayerType.choice = H223LCPs_aLTp_a2WSNs_1_chosen;
    break;

  case H245_H223_AL_AL2SEQ:
    pOut->adaptationLayerType.choice = H223LCPs_aLTp_a2WSNs_2_chosen;
    break;

  case H245_H223_AL_AL3:
    pOut->adaptationLayerType.choice = H223LCPs_aLTp_al3_chosen;
    pOut->adaptationLayerType.u.H223LCPs_aLTp_al3.controlFieldOctets = pIn->CtlFldOctet;
    pOut->adaptationLayerType.u.H223LCPs_aLTp_al3.sendBufferSize = pIn->SndBufSize;
    break;

  default:
	 H245TRACE(0,1,"API:setup_H223_mux: invalid AlType %d", pIn->AlType);
    return H245_ERROR_PARAM;
  } /* switch */

  /* segmentation flag */
  pOut->segmentableFlag = pIn->SegmentFlag;

  return H245_ERROR_OK;
} // setup_H223_mux

static HRESULT
setup_VGMUX_mux(V76LogicalChannelParameters        *pOut,
                const H245_VGMUX_LOGICAL_PARAM_T   *pIn)
{
  /* See load_VGMUX_param() for inverse function */
  pOut->hdlcParameters.crcLength.choice       = (unsigned short)pIn->crcLength;
  pOut->hdlcParameters.n401                   = pIn->n401;
  pOut->hdlcParameters.loopbackTestProcedure  = pIn->loopbackTestProcedure;
  pOut->suspendResume.choice                  = (unsigned short)pIn->suspendResume;
  pOut->uIH                                   = pIn->uIH;
  pOut->mode.choice                           = (unsigned short)pIn->mode;
  switch (pIn->mode)
  {
  case H245_V76_ERM:
    pOut->mode.u.eRM.windowSize               = pIn->windowSize;
    pOut->mode.u.eRM.recovery.choice          = (unsigned short)pIn->recovery;
    break;

  } // switch
  pOut->v75Parameters.audioHeaderPresent = pIn->audioHeaderPresent;
  return H245_ERROR_OK;
} // setup_VGMUX_mux

static HRESULT
setup_H2250_mux(H2250LogicalChannelParameters  *pOut,
                const H245_H2250_LOGICAL_PARAM_T     *pIn)
{
  /* See load_H2250_param() for inverse function */
  HRESULT                lError = H245_ERROR_OK;

  pOut->bit_mask = 0;

  if (pIn->nonStandardList)
  {
    pOut->H2250LCPs_nnStndrd = pIn->nonStandardList;
    pOut->bit_mask |= H2250LCPs_nnStndrd_present;
  }

  pOut->sessionID = pIn->sessionID;

  if (pIn->associatedSessionIDPresent)
  {
    pOut->H2250LCPs_assctdSssnID = pIn->associatedSessionID;
    pOut->bit_mask |= H2250LCPs_assctdSssnID_present;
  }

  if (pIn->mediaChannelPresent)
  {
    if (lError == H245_ERROR_OK)
    {
      lError = SetupTransportAddress(&pOut->H2250LCPs_mdChnnl,
                                     &pIn->mediaChannel);
      if (lError == H245_ERROR_OK)
      {
        pOut->bit_mask |= H2250LCPs_mdChnnl_present;
      }
    }
  }

  if (pIn->mediaGuaranteedPresent)
  {
    pOut->H2250LCPs_mdGrntdDlvry = pIn->mediaGuaranteed;
    pOut->bit_mask |= H2250LCPs_mdGrntdDlvry_present;
  }

  if (pIn->mediaControlChannelPresent)
  {
    if (lError == H245_ERROR_OK)
    {
      lError = SetupTransportAddress(&pOut->H2250LCPs_mdCntrlChnnl,
                                     &pIn->mediaControlChannel);
      if (lError == H245_ERROR_OK)
      {
        pOut->bit_mask |= H2250LCPs_mdCntrlChnnl_present;
      }
    }
  }

  if (pIn->mediaControlGuaranteedPresent)
  {
    pOut->H2250LCPs_mCGDy = pIn->mediaControlGuaranteed;
    pOut->bit_mask |= H2250LCPs_mCGDy_present;
  }

  if (pIn->silenceSuppressionPresent)
  {
    pOut->silenceSuppression = pIn->silenceSuppression;
    pOut->bit_mask |= silenceSuppression_present;
  }

  if (pIn->destinationPresent)
  {
    pOut->destination = pIn->destination;
    pOut->bit_mask |= H2250LogicalChannelParameters_destination_present;
  }

  if (pIn->mediaControlChannelPresent)
  {
    pOut->bit_mask |= H2250LCPs_mdCntrlChnnl_present;
    lError = SetupTransportAddress(&pOut->H2250LCPs_mdCntrlChnnl,
                                     &pIn->mediaControlChannel);
  }

  if (pIn->dynamicRTPPayloadTypePresent)
  {
    pOut->H2250LCPs_dRTPPTp = pIn->dynamicRTPPayloadType;
    pOut->bit_mask |= H2250LCPs_dRTPPTp_present;
  }

  if (pIn->h261aVideoPacketization)
  {
    pOut->mediaPacketization.choice = h261aVideoPacketization_chosen;
    pOut->bit_mask |= mediaPacketization_present;
  }

  return lError;
} // setup_H2250_mux

static HRESULT
setup_H2250ACK_mux(H2250LgclChnnlAckPrmtrs             *pOut,
                   const H245_H2250ACK_LOGICAL_PARAM_T *pIn)
{
  /* See load_H2250ACK_param() for inverse function */
  HRESULT                lError = H245_ERROR_OK;

  pOut->bit_mask = 0;

  if (pIn->nonStandardList)
  {
    pOut->H2250LCAPs_nnStndrd = pIn->nonStandardList;
    pOut->bit_mask |= H2250LCAPs_nnStndrd_present;
  }

  if (pIn->sessionIDPresent)
  {
    pOut->sessionID = pIn->sessionID;
    pOut->bit_mask |= sessionID_present;
  }

  if (pIn->mediaChannelPresent)
  {
    if (lError == H245_ERROR_OK)
    {
      lError = SetupTransportAddress(&pOut->H2250LCAPs_mdChnnl,
                                     &pIn->mediaChannel);
      if (lError == H245_ERROR_OK)
      {
        pOut->bit_mask |= H2250LCAPs_mdChnnl_present;
      }
    }
  }

  if (pIn->mediaControlChannelPresent)
  {
    if (lError == H245_ERROR_OK)
    {
      lError = SetupTransportAddress(&pOut->H2250LCAPs_mdCntrlChnnl,
                                       &pIn->mediaControlChannel);
      if (lError == H245_ERROR_OK)
      {
        pOut->bit_mask |= H2250LCAPs_mdCntrlChnnl_present;
      }
    }
  }

  if (pIn->dynamicRTPPayloadTypePresent)
  {
    pOut->H2250LCAPs_dRTPPTp = pIn->dynamicRTPPayloadType;
    pOut->bit_mask |= H2250LCAPs_dRTPPTp_present;
  }

  return lError;
} // setup_H2250ACK_mux



/*****************************************************************************
 *
 * TYPE:
 *
 * PROCEDURE:
 *
 * DESCRIPTION:
 *
 * RETURN:
 *
 *****************************************************************************/
HRESULT
pdu_req_open_channel (  PDU_T *         pPdu,
                        WORD            wTxChannel,
                        DWORD           dwTxPort,
                        const H245_TOTCAP_T * pTxMode,
                        const H245_MUX_T    * pTxMux,
                        const H245_TOTCAP_T * pRxMode,
                        const H245_MUX_T    * pRxMux,
                        const H245_ACCESS_T * pSeparateStack)
{
  RequestMessage               *p_req = &pPdu->u.MltmdSystmCntrlMssg_rqst;
  struct OpenLogicalChannel    *pPdu_olc = &p_req->u.openLogicalChannel;
  HRESULT                       lError;

  pPdu->choice = MltmdSystmCntrlMssg_rqst_chosen;
  p_req->choice = openLogicalChannel_chosen;

  ASSERT(pTxMode);
  ASSERT(pTxMux);

  /* Initialize bit masks to 0 */
  /* --> bit_mask no reverse parameters, no reverse mux table parameters */
  pPdu_olc->bit_mask = 0;
  /* no port number present */
  pPdu_olc->forwardLogicalChannelParameters.bit_mask = 0;
  /* no reverse mulitiplex parameters present    */
  pPdu_olc->OLCl_rLCPs.bit_mask = 0;

  /************************************************************/
  /* SETUP THE CHANNEL INFORMATION (NOT MUX STUFF : SEE BELOW */
  /************************************************************/

  /*************************/
  /* FORWARD CHANNEL STUFF */
  /*************************/

  /* --> forwardLogicalChannelNumber */
  pPdu_olc->forwardLogicalChannelNumber = wTxChannel;

  /* --> forwardLogicalChannelParameters                */
  /*    -->forwardLogicalChannelParameters.bit_mask     */
  /*    -->forwardLogicalChannelParameters.fLCPs_prtNmbr*/

  /*    -->forwardLogicalChannelParameters.dataType     */


  /* if port present .. make it so.. (beam me up scotty) */
  if (dwTxPort != H245_INVALID_PORT_NUMBER)
  {
    pPdu_olc->forwardLogicalChannelParameters.bit_mask |= fLCPs_prtNmbr_present;
    pPdu_olc->forwardLogicalChannelParameters.fLCPs_prtNmbr = (WORD)dwTxPort;
  }

  /* select the data type */
  switch (pTxMode->DataType)
    {
    case H245_DATA_NONSTD:
      pPdu_olc->forwardLogicalChannelParameters.dataType.choice = DataType_nonStandard_chosen;
      break;
    case H245_DATA_NULL:
      pPdu_olc->forwardLogicalChannelParameters.dataType.choice = nullData_chosen;
      break;
    case H245_DATA_VIDEO:
      pPdu_olc->forwardLogicalChannelParameters.dataType.choice = DataType_videoData_chosen;
      break;
    case H245_DATA_AUDIO:
      pPdu_olc->forwardLogicalChannelParameters.dataType.choice = DataType_audioData_chosen;
      break;
    case H245_DATA_DATA:
      pPdu_olc->forwardLogicalChannelParameters.dataType.choice = DataType_data_chosen;
      break;
    case H245_DATA_ENCRYPT_D:
      pPdu_olc->forwardLogicalChannelParameters.dataType.choice = encryptionData_chosen;
      return H245_ERROR_NOTIMP;     // TBD
      break;
    default:
	   H245TRACE(0,1,"API:pdu_req_open_channel: invalid TX DataType %d", pTxMode->DataType);
      return H245_ERROR_PARAM;
    } /* switch */

  /* in the DataType.. load the capability */
  lError = load_cap((struct Capability *)&pPdu_olc->forwardLogicalChannelParameters.dataType, pTxMode);
  if (lError != H245_ERROR_OK)
    {
      return lError;
    }

  /********************************/
  /* FORWARD MUX H223 PARAM STUFF */
  /********************************/

  /* set forward parameters choices */
  /*    -->forwardLogicalChannelParameters.multiplexParameters.choice                   */
  /*    -->forwardLogicalChannelParameters.multiplexParameters.u.fLCPs_mPs_h222LCPs     */
  switch (pTxMux->Kind)
  {
  case H245_H222:
    pPdu_olc->forwardLogicalChannelParameters.multiplexParameters.choice =
      fLCPs_mPs_h222LCPs_chosen;
    lError = setup_H222_mux(&pPdu_olc->forwardLogicalChannelParameters.multiplexParameters.u.fLCPs_mPs_h222LCPs,
                             &pTxMux->u.H222);
    break;

  case H245_H223:
    pPdu_olc->forwardLogicalChannelParameters.multiplexParameters.choice =
      fLCPs_mPs_h223LCPs_chosen;
    lError = setup_H223_mux(&pPdu_olc->forwardLogicalChannelParameters.multiplexParameters.u.fLCPs_mPs_h223LCPs,
                             &pTxMux->u.H223);
    break;

  case H245_VGMUX:
    pPdu_olc->forwardLogicalChannelParameters.multiplexParameters.choice =
      fLCPs_mPs_v76LCPs_chosen;
    lError = setup_VGMUX_mux(&pPdu_olc->forwardLogicalChannelParameters.multiplexParameters.u.fLCPs_mPs_v76LCPs,
                              &pTxMux->u.VGMUX);
    break;

  case H245_H2250:
    pPdu_olc->forwardLogicalChannelParameters.multiplexParameters.choice =
      fLCPs_mPs_h2250LCPs_chosen;
    lError = setup_H2250_mux(&pPdu_olc->forwardLogicalChannelParameters.multiplexParameters.u.fLCPs_mPs_h2250LCPs,
                              &pTxMux->u.H2250);
    // TBD - Add Network Access Parameters support
    break;

  default:
    H245TRACE(0,1,"API:pdu_req_open_channel: invalid TX Mux Kind %d", pTxMux->Kind);
    lError = H245_ERROR_PARAM;
  } /* switch */
  if (lError != H245_ERROR_OK)
    return lError;

  /*************************/
  /* REVERSE CHANNEL STUFF */
  /*************************/

  if (pRxMode)
    {
      /* --> bit_mask reverse parameters exist !!!! party..down garth..  */
      pPdu_olc->bit_mask |= OLCl_rLCPs_present;
      /*        -->OLCl_rLCPs.dataType  */

      /* select the data type */
      switch (pRxMode->DataType)
        {
        case H245_DATA_NONSTD:
          pPdu_olc->OLCl_rLCPs.dataType.choice = DataType_nonStandard_chosen;
          break;
        case H245_DATA_NULL:
          pPdu_olc->OLCl_rLCPs.dataType.choice = nullData_chosen;
          break;
        case H245_DATA_VIDEO:
          pPdu_olc->OLCl_rLCPs.dataType.choice = DataType_videoData_chosen;
          break;
        case H245_DATA_AUDIO:
          pPdu_olc->OLCl_rLCPs.dataType.choice = DataType_audioData_chosen;
          break;
        case H245_DATA_DATA:
          pPdu_olc->OLCl_rLCPs.dataType.choice = DataType_data_chosen;
          break;
        case H245_DATA_ENCRYPT_D:
          pPdu_olc->OLCl_rLCPs.dataType.choice = encryptionData_chosen;
          return H245_ERROR_NOTIMP;     // TBD
          break;
        default:
	       H245TRACE(0,1,"API:pdu_req_open_channel: invalid RX DataType %d", pRxMode->DataType);
          return H245_ERROR_PARAM;
        } /* switch */

      /* in the DataType.. load the capability */
      lError = load_cap((struct Capability *)&pPdu_olc->OLCl_rLCPs.dataType, pRxMode);
      if (lError != H245_ERROR_OK)
        {
          return lError;
        }

      /********************************/
      /* REVERSE MUX H223 PARAM STUFF */
      /********************************/

      if (pRxMux)
        {
              /* set reverse parameters choices         */
              /*        -->OLCl_rLCPs.dataType          */
              /*        -->OLCl_rLCPs.bit_mask  */
              /* set them to be present.. and it was so */

          switch (pRxMux->Kind)
            {
            case H245_H223:
              pPdu_olc->OLCl_rLCPs.OLCl_rLCPs_mltplxPrmtrs.choice = rLCPs_mPs_h223LCPs_chosen;
              lError = setup_H223_mux (&pPdu_olc->OLCl_rLCPs.OLCl_rLCPs_mltplxPrmtrs.u.rLCPs_mPs_h223LCPs,
                                        &pRxMux->u.H223);
              break;

            case H245_VGMUX:
              pPdu_olc->OLCl_rLCPs.OLCl_rLCPs_mltplxPrmtrs.choice = rLCPs_mPs_v76LCPs_chosen;
              lError = setup_VGMUX_mux (&pPdu_olc->OLCl_rLCPs.OLCl_rLCPs_mltplxPrmtrs.u.rLCPs_mPs_v76LCPs,
                                         &pRxMux->u.VGMUX);
              break;

            case H245_H2250:
              pPdu_olc->OLCl_rLCPs.OLCl_rLCPs_mltplxPrmtrs.choice = rLCPs_mPs_h2250LCPs_chosen;
              lError = setup_H2250_mux (&pPdu_olc->OLCl_rLCPs.OLCl_rLCPs_mltplxPrmtrs.u.rLCPs_mPs_h2250LCPs,
                                         &pRxMux->u.H2250);
              break;

            default:
              H245TRACE(0,1,"API:pdu_req_open_channel: invalid RX Mux Kind %d", pRxMux->Kind);
              lError = H245_ERROR_PARAM;
            } /* switch */
            if (lError != H245_ERROR_OK)
              return lError;

            pPdu_olc->OLCl_rLCPs.bit_mask |= OLCl_rLCPs_mltplxPrmtrs_present; /* reverse multiplex parameters present */

        } /* if pRxMux */
    } /* if pRxMode */

  if (pSeparateStack)
  {
    pPdu_olc->bit_mask |= OpnLgclChnnl_sprtStck_present;
    pPdu_olc->OpnLgclChnnl_sprtStck = *pSeparateStack;
  }

  return H245_ERROR_OK;
}


//
// Frees PDU and contents used for pdu_req_open_channel()
//
void free_pdu_req_open_channel
(
    PDU_T * pPdu,
    const H245_TOTCAP_T * pTxMode,
    const H245_TOTCAP_T * pRxMode
)
{
    RequestMessage *            p_req = &pPdu->u.MltmdSystmCntrlMssg_rqst;
    struct OpenLogicalChannel * pPdu_olc = &p_req->u.openLogicalChannel;

    if (pRxMode)
    {
        free_cap((struct Capability *)&pPdu_olc->OLCl_rLCPs.dataType, pRxMode);
    }

    free_cap((struct Capability *)&pPdu_olc->forwardLogicalChannelParameters.dataType, pTxMode);

    // Free PDU pointer
    MemFree(pPdu);
}

/*****************************************************************************
 *
 * TYPE:
 *
 * PROCEDURE:
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/
HRESULT
pdu_rsp_open_logical_channel_ack (  PDU_T *               pPdu,
				                            WORD                  wRxChannel,
                                    const H245_MUX_T *    pRxMux,
				                            WORD                  wTxChannel,
				                            const H245_MUX_T *    pTxMux, // for H.222/H.225.0 only
                                    DWORD                 dwTxPort,
                                    const H245_ACCESS_T * pSeparateStack)
{
  OpenLogicalChannelAck  *pAck = &pPdu->u.MSCMg_rspns.u.openLogicalChannelAck;
  HRESULT                 lError;

  pPdu->choice = MSCMg_rspns_chosen;
  pPdu->u.MSCMg_rspns.choice = openLogicalChannelAck_chosen;

  pAck->bit_mask = 0;                   // Initialize bit mask

  pAck->forwardLogicalChannelNumber = wRxChannel;

  if (wTxChannel != 0)
  {
    pAck->bit_mask |= OLCAk_rLCPs_present;

    pAck->OLCAk_rLCPs.bit_mask = 0;     // Initialize bit mask
    pAck->OLCAk_rLCPs.reverseLogicalChannelNumber = wTxChannel;
    if (dwTxPort != H245_INVALID_PORT_NUMBER)
    {
      pAck->OLCAk_rLCPs.bit_mask |= rLCPs_prtNmbr_present;
      pAck->OLCAk_rLCPs.rLCPs_prtNmbr = (WORD)dwTxPort;
    }

    if (pTxMux)
    {
      pAck->OLCAk_rLCPs.bit_mask |= OLCAk_rLCPs_mPs_present;
      lError = H245_ERROR_PARAM;
      switch (pTxMux->Kind)
      {
      case H245_H222:
        pAck->OLCAk_rLCPs.OLCAk_rLCPs_mPs.choice = rLCPs_mPs_h222LCPs_chosen;
        lError = setup_H222_mux(&pAck->OLCAk_rLCPs.OLCAk_rLCPs_mPs.u.rLCPs_mPs_h222LCPs,
                                  &pTxMux->u.H222);
        break;

      case H245_H2250:
        pAck->OLCAk_rLCPs.OLCAk_rLCPs_mPs.choice = mPs_h2250LgclChnnlPrmtrs_chosen;
        lError = setup_H2250_mux(&pAck->OLCAk_rLCPs.OLCAk_rLCPs_mPs.u.mPs_h2250LgclChnnlPrmtrs,
                                      &pTxMux->u.H2250);
        break;

      } // switch
      if (lError != H245_ERROR_OK)
        return lError;
    } // if
  } // if

  if (pSeparateStack)
  {
    pAck->bit_mask |= OLCAk_sprtStck_present;
    pAck->OLCAk_sprtStck = *pSeparateStack;
  }

  if (pRxMux)
  {
    pAck->bit_mask |= frwrdMltplxAckPrmtrs_present;
    lError = H245_ERROR_PARAM;
    switch (pRxMux->Kind)
    {
    case H245_H2250ACK:
      pAck->frwrdMltplxAckPrmtrs.choice = h2250LgclChnnlAckPrmtrs_chosen;
      lError = setup_H2250ACK_mux(&pAck->frwrdMltplxAckPrmtrs.u.h2250LgclChnnlAckPrmtrs,
                                    &pRxMux->u.H2250ACK);
      break;

    } // switch
    if (lError != H245_ERROR_PARAM)
      return lError;
  }

  return H245_ERROR_OK;
}

/*****************************************************************************
 *
 * TYPE:
 *
 * PROCEDURE:
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/
HRESULT
pdu_rsp_open_logical_channel_rej (  PDU_T *         pPdu,
				                            WORD            wRxChannel,
				                            WORD            wCause)
{
  pPdu->choice = MSCMg_rspns_chosen;
  pPdu->u.MSCMg_rspns.choice = openLogicalChannelReject_chosen;
  pPdu->u.MSCMg_rspns.u.openLogicalChannelReject.forwardLogicalChannelNumber = wRxChannel;
  pPdu->u.MSCMg_rspns.u.openLogicalChannelReject.cause.choice = wCause;
  return H245_ERROR_OK;
}

/*****************************************************************************
 *
 * TYPE:
 *
 * PROCEDURE:
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/
HRESULT
pdu_ind_open_logical_channel_conf ( PDU_T *pPdu,
				                            WORD                 wChannel)
{
  IndicationMessage     *p_ind = &pPdu->u.indication;
  OpenLogicalChannelConfirm *pPdu_olcc = &(p_ind->u.opnLgclChnnlCnfrm);
  p_ind->choice = opnLgclChnnlCnfrm_chosen;

  pPdu->choice = indication_chosen;
  pPdu_olcc->forwardLogicalChannelNumber = wChannel;
  return H245_ERROR_OK;
}

/*****************************************************************************
 *
 * TYPE:
 *
 * PROCEDURE:
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/
HRESULT
pdu_req_request_close_channel(PDU_T *pPdu,
			                        WORD                 wChannel)
{
  RequestMessage        *p_req = &pPdu->u.MltmdSystmCntrlMssg_rqst;
  RequestChannelClose   *pPdu_rcc = &(p_req->u.requestChannelClose);

  pPdu->choice = MltmdSystmCntrlMssg_rqst_chosen;
  p_req->choice = requestChannelClose_chosen;
  pPdu_rcc->forwardLogicalChannelNumber = wChannel;
  return H245_ERROR_OK;
}

/*****************************************************************************
 *
 * TYPE:
 *
 * PROCEDURE:
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/
HRESULT
pdu_req_close_logical_channel (PDU_T *pPdu,
			                         WORD                wChannel,
			                         DWORD               user_lcse) /* 0=user */
							                                                /* 1=lcse */

{
  RequestMessage        *p_req = &pPdu->u.MltmdSystmCntrlMssg_rqst;
  CloseLogicalChannel   *pPdu_cc = &(p_req->u.closeLogicalChannel);
  p_req->choice = closeLogicalChannel_chosen;

  pPdu_cc->bit_mask = CloseLogicalChannel_reason_present;
  pPdu_cc->reason.choice = CloseLogicalChannel_reason_reopen_chosen;

  pPdu->choice = MltmdSystmCntrlMssg_rqst_chosen;
  pPdu_cc->forwardLogicalChannelNumber = wChannel;
  if (user_lcse)
    pPdu_cc->source.choice = lcse_chosen;
  else
    pPdu_cc->source.choice = user_chosen;
  return H245_ERROR_OK;
}

/*****************************************************************************
 *
 * TYPE:
 *
 * PROCEDURE:
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/
HRESULT
pdu_rsp_close_logical_channel_ack ( PDU_T *pPdu,
				                            WORD                 wChannel)
{
  ResponseMessage       *p_rsp = &pPdu->u.MSCMg_rspns;
  CloseLogicalChannelAck        *pPdu_clca = &(p_rsp->u.closeLogicalChannelAck);

  p_rsp->choice = closeLogicalChannelAck_chosen;
  pPdu->choice = MSCMg_rspns_chosen;
  pPdu_clca->forwardLogicalChannelNumber = wChannel;
  return H245_ERROR_OK;
}

/*****************************************************************************
 *
 * TYPE:
 *
 * PROCEDURE:
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/
HRESULT
pdu_rsp_request_channel_close_ack ( PDU_T *pPdu,
				                            WORD                 wChannel)
{
  ResponseMessage       *p_rsp = &pPdu->u.MSCMg_rspns;
  RequestChannelCloseAck *pPdu_rcca = &(p_rsp->u.requestChannelCloseAck);
  p_rsp->choice = requestChannelCloseAck_chosen;
  pPdu->choice = MSCMg_rspns_chosen;
  pPdu_rcca->forwardLogicalChannelNumber = wChannel;
  return H245_ERROR_OK;
}

/*****************************************************************************
 *
 * TYPE:
 *
 * PROCEDURE:
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/
HRESULT
pdu_rsp_request_channel_close_rej ( PDU_T *pPdu,
				                            WORD                 wChannel,
				                            H245_ACC_REJ_T       acc_rej)
{
  ResponseMessage               *p_rsp = &pPdu->u.MSCMg_rspns;
  RequestChannelCloseReject     *pPdu_rccr = &(p_rsp->u.rqstChnnlClsRjct);

  p_rsp->choice = rqstChnnlClsRjct_chosen;
  pPdu->choice = MSCMg_rspns_chosen;
  pPdu_rccr->forwardLogicalChannelNumber = wChannel;
  pPdu_rccr->cause.choice = (WORD)acc_rej;
  return H245_ERROR_OK;
}

/*****************************************************************************
 *
 * TYPE:
 *
 * PROCEDURE:
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/
HRESULT
pdu_req_mstslv (        PDU_T *                 pPdu,
		                    BYTE                    byTerminalType,
		                    unsigned int            number)
{
  RequestMessage        *p_req = &pPdu->u.MltmdSystmCntrlMssg_rqst;
  MasterSlaveDetermination      *pPdu_msd = &(p_req->u.masterSlaveDetermination);
  p_req->choice = masterSlaveDetermination_chosen;

  pPdu->choice = MltmdSystmCntrlMssg_rqst_chosen;
  pPdu_msd->terminalType = byTerminalType;
  pPdu_msd->statusDeterminationNumber = number;
  return H245_ERROR_OK;
}

/*****************************************************************************
 *
 * TYPE:
 *
 * PROCEDURE:
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/
HRESULT
pdu_rsp_mstslv_rej (PDU_T *pPdu)
{
  ResponseMessage                       *p_rsp = &pPdu->u.MSCMg_rspns;
  MasterSlaveDeterminationReject        *pPdu_msdr = &(p_rsp->u.mstrSlvDtrmntnRjct);

  p_rsp->choice = mstrSlvDtrmntnRjct_chosen;
  pPdu->choice = MSCMg_rspns_chosen;
  pPdu_msdr->cause.choice = identicalNumbers_chosen;
  return H245_ERROR_OK;
}

/*****************************************************************************
 *
 * TYPE:
 *
 * PROCEDURE:
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/
HRESULT
pdu_rsp_mstslv_ack (    PDU_T *                 pPdu,
                        unsigned short          mst_slv)
{
  pPdu->choice = MSCMg_rspns_chosen;
  pPdu->u.MSCMg_rspns.choice = mstrSlvDtrmntnAck_chosen;
  pPdu->u.MSCMg_rspns.u.mstrSlvDtrmntnAck.decision.choice = mst_slv;
  return H245_ERROR_OK;
}

/*****************************************************************************
 *
 * TYPE:
 *
 * PROCEDURE:
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/
HRESULT
pdu_req_termcap_set (PDU_T *pPdu,
		               WORD                 wSequenceNumber)
{
  RequestMessage *p_req = &pPdu->u.MltmdSystmCntrlMssg_rqst;
  TerminalCapabilitySet *pPdu_tcs = &(p_req->u.terminalCapabilitySet);
  p_req->choice = terminalCapabilitySet_chosen;
				
  pPdu->choice = MltmdSystmCntrlMssg_rqst_chosen;
  pPdu_tcs->sequenceNumber = (SequenceNumber)wSequenceNumber;

  return H245_ERROR_OK;
}

/*****************************************************************************
 *
 * TYPE:
 *
 * PROCEDURE:
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/
HRESULT
pdu_rsp_termcap_set_ack(PDU_T *pPdu,
			                  WORD                 wSequenceNumber)
{
  ResponseMessage               *p_rsp = &pPdu->u.MSCMg_rspns;
  TerminalCapabilitySetAck      *pPdu_tcsa = &(p_rsp->u.terminalCapabilitySetAck);

  p_rsp->choice = terminalCapabilitySetAck_chosen;
  pPdu->choice = MSCMg_rspns_chosen;
  pPdu_tcsa->sequenceNumber = (SequenceNumber)wSequenceNumber;
  return H245_ERROR_OK;
}

/*****************************************************************************
 *
 * TYPE:
 *
 * PROCEDURE:
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/
HRESULT
pdu_rsp_termcap_set_rej(PDU_T *pPdu,
			               WORD                 wSequenceNumber,
			               H245_ACC_REJ_T       reason,
			               WORD                 highest_processed)
{
  ResponseMessage               *p_rsp = &pPdu->u.MSCMg_rspns;
  TerminalCapabilitySetReject   *pPdu_tcsr = &(p_rsp->u.trmnlCpbltyStRjct);

  p_rsp->choice = trmnlCpbltyStRjct_chosen;
  pPdu->choice = MSCMg_rspns_chosen;
  pPdu_tcsr->sequenceNumber = (SequenceNumber)wSequenceNumber;

  switch (reason)
    {
    case H245_REJ_UNDEF_TBL_ENTRY:
      pPdu_tcsr->cause.choice =  undefinedTableEntryUsed_chosen;
      break;
    case H245_REJ_DIS_CAP_EXCEED:
      pPdu_tcsr->cause.choice = dscrptrCpctyExcdd_chosen;
      break;
    case H245_REJ_TBLENTRY_CAP_EXCEED:
      pPdu_tcsr->cause.choice = tblEntryCpctyExcdd_chosen;

      if (!highest_processed)
	pPdu_tcsr->cause.u.tblEntryCpctyExcdd.choice = noneProcessed_chosen;
      else
	{
	  pPdu_tcsr->cause.u.tblEntryCpctyExcdd.choice = hghstEntryNmbrPrcssd_chosen;
	  pPdu_tcsr->cause.u.tblEntryCpctyExcdd.u.hghstEntryNmbrPrcssd = highest_processed;
	}
      break;
    case H245_REJ:
    default:
      pPdu_tcsr->cause.choice = TCSRt_cs_unspcfd_chosen;
      break;
    }
  return H245_ERROR_OK;
}



/*****************************************************************************
 *
 * TYPE:
 *
 * PROCEDURE:
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/
HRESULT
pdu_ind_misc (PDU_T       *pPdu)
{
  IndicationMessage     *p_ind = &pPdu->u.indication;
  MiscellaneousIndication       *p_pdu_misc = &(p_ind->u.miscellaneousIndication);
  p_ind->choice = miscellaneousIndication_chosen;

  pPdu->choice = indication_chosen;
  /* (TBC) */
  return H245_ERROR_NOTIMP;
}




/*****************************************************************************
 *
 * TYPE:        LOCAL
 *
 * PROCEDURE:   build_mux_entry_element - recursivly build mux element list
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/
HRESULT
build_mux_entry_element(struct InstanceStruct    *pInstance,
       			         H245_MUX_ENTRY_ELEMENT_T *p_mux_el,
			               MultiplexElement         *p_ASN_mux_el,
			               DWORD			              element_depth)
{
  HRESULT       lError;
  DWORD		max_element_depth = 0;
  DWORD		max_element_width = 0;

  /* check for h223 MAX depth of recursion */
  if (pInstance->Configuration == H245_CONF_H324)
    {
      /* if h223 in basic mode */
      if (pInstance->API.PDU_LocalTermCap.
	    u.MltmdSystmCntrlMssg_rqst.
	      u.terminalCapabilitySet.multiplexCapability.
	        u.h223Capability.
		  h223MultiplexTableCapability.choice == h223MltplxTblCpblty_bsc_chosen)
	{
	  max_element_depth = 1;
	  max_element_width = 2;
	}
      else
      if (pInstance->API.PDU_LocalTermCap.
	    u.MltmdSystmCntrlMssg_rqst.
	      u.terminalCapabilitySet.multiplexCapability.
	        u.h223Capability.
		  h223MultiplexTableCapability.choice == h223MTCy_enhncd_chosen)
	{
	  max_element_depth =
	    pInstance->API.PDU_LocalTermCap.
	      u.MltmdSystmCntrlMssg_rqst.
		u.terminalCapabilitySet.multiplexCapability.
		  u.h223Capability.
		    h223MultiplexTableCapability.u.h223MTCy_enhncd.maximumNestingDepth;
	  max_element_width =
	    pInstance->API.PDU_LocalTermCap.
	      u.MltmdSystmCntrlMssg_rqst.
		u.terminalCapabilitySet.multiplexCapability.
		  u.h223Capability.
		    h223MultiplexTableCapability.u.h223MTCy_enhncd.maximumElementListSize;
	}
    }
  /* nested too deap */
  if (max_element_depth)
    if (element_depth > max_element_depth)
      {
	H245TRACE(pInstance->dwInst,1,"API:build_mux_entry_element: << ERROR >> Maximum Depth %d",element_depth );
	return (H245_ERROR_MUXELEMENT_DEPTH);
      }

  ASSERT (p_mux_el);

  /* if logical channel number (termination of tree branch) */
  if (p_mux_el->Kind == H245_MUX_LOGICAL_CHANNEL)
    {
      p_ASN_mux_el->type.choice = typ_logicalChannelNumber_chosen;

      /* invalid channel number .. 0 is command channel */
      // 3/7/96 - cjutzi removed.. looks like they use it in the examples
      //
      //if (p_mux_el->u.wChannel == 0)
      //	{
      //	  H245TRACE(Inst,1,"API:build_mux_entry_element: << ERROR >> Channel 0 not allowed if format");
      //	  return H245_ERROR_INVALID_DATA_FORMAT;
      //	}

      p_ASN_mux_el->type.u.typ_logicalChannelNumber = (WORD)p_mux_el->u.Channel;
    }
  /* else it is a sub element list again.. */
  else
    {
      MultiplexElementLink 	        p_ASN_mux_link;
      H245_MUX_ENTRY_ELEMENT_T 	       *p_mux_el_look;

      /* allocate a new sub element list structure */

      p_ASN_mux_link = (MultiplexElementLink)MemAlloc(sizeof(*p_ASN_mux_link));
      if (p_ASN_mux_link == NULL)
	{
	  return H245_ERROR_NOMEM;
	}

      /* zero memory out */
      memset (p_ASN_mux_link, 0, sizeof (*p_ASN_mux_link));

      /* for every entry  entry present.. */
      for (p_ASN_mux_link->count = 0, p_mux_el_look = p_mux_el->u.pMuxTblEntryElem;
	   p_mux_el_look;
	   p_mux_el_look = p_mux_el_look->pNext, p_ASN_mux_link->count++)
	{
	  /* check.. for api mistakes.. ie.. pointer is really a channel # */
	
	  if ((DWORD_PTR)p_mux_el_look < (DWORD)128)
	    {
	      H245TRACE(pInstance->dwInst,1,"API:build_mux_entry_element: << WARNING >> Possible H245_MUX_LOGICAL_CHANNEL labeled as pointer.. <<CRASH>>");
	    }

	  if ((lError = build_mux_entry_element (pInstance,
						p_mux_el_look,
						&(p_ASN_mux_link->value[p_ASN_mux_link->count]),
						element_depth+1)) != H245_ERROR_OK)
	    {
	      MemFree (p_ASN_mux_link);
	      return lError;
	    }

	} /* for */

      /* must have at least 2 subelements in the list.. if not */
      /* there is an error in the construct.  */
      if (p_ASN_mux_link->count < 2)
	{
	  H245TRACE(pInstance->dwInst,1,"API:build_mux_entry_element: << ERROR >> Element List < 2");
	  MemFree (p_ASN_mux_link);
	  return H245_ERROR_INVALID_DATA_FORMAT;
	}

      /* width too wide for MuxLayer*/
      if (max_element_width)
	if (p_ASN_mux_link->count > max_element_width)
	  {
	    H245TRACE(pInstance->dwInst,1,"API:build_mux_entry_element: << ERROR >> Maximum Width %d",(p_ASN_mux_link->count));
	    MemFree (p_ASN_mux_link);
	    return H245_ERROR_MUXELEMENT_WIDTH;
	  }

      /* assign to the ASN1 struct for this element */
      p_ASN_mux_el->type.u.subElementList = p_ASN_mux_link;
      p_ASN_mux_el->type.choice = subElementList_chosen;
    }

  /* ok.. deal w/ ASN1 repeat count */
  if (!p_mux_el->RepeatCount)
    p_ASN_mux_el->repeatCount.choice = untilClosingFlag_chosen;
  else
    {
      p_ASN_mux_el->repeatCount.choice = repeatCount_finite_chosen;
      p_ASN_mux_el->repeatCount.u.repeatCount_finite = (WORD)p_mux_el->RepeatCount;
    }

  return H245_ERROR_OK;
}



/*****************************************************************************
 *
 * TYPE:
 *
 * PROCEDURE:
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/
HRESULT
pdu_req_send_mux_table (  struct InstanceStruct * pInstance,
			  PDU_T                 * pPdu,
			  H245_MUX_TABLE_T      * p_mux_table,
			  WORD                    wSequenceNumber,
			  DWORD	                * p_mux_count)
{
  RequestMessage         	       *p_req = &pPdu->u.MltmdSystmCntrlMssg_rqst;
  MultiplexEntrySend     	       *pPdu_mes = &(p_req->u.multiplexEntrySend);
  MultiplexEntryDescriptorLink	        p_ASN_med_link = NULL;
  MultiplexEntryDescriptorLink	        p_ASN_med_link_lst = NULL;
  //H245_MUX_ENTRY_DESC_T		*p_mux_desc;

  /* setup pdu choices */
  pPdu->choice = MltmdSystmCntrlMssg_rqst_chosen;
  p_req->choice = multiplexEntrySend_chosen;

  pPdu_mes->sequenceNumber = (SequenceNumber)wSequenceNumber;
  pPdu_mes->multiplexEntryDescriptors = NULL;

  /* must have mux table structure */
  if (!p_mux_table)
    return H245_ERROR_PARAM;

  /* for each descriptor in the table.. */
  /* make sure there are only max of 15 */
  /* and that the numbers range 1-15	*/

  for (*p_mux_count = 0;
       p_mux_table && (*p_mux_count < 16);
       p_mux_table = p_mux_table->pNext,*p_mux_count = (*p_mux_count)+1)
    {
      /* allocate a new multiplex Entry Descriptor */
      p_ASN_med_link = (MultiplexEntryDescriptorLink)MemAlloc(sizeof(*p_ASN_med_link));
      if (p_ASN_med_link == NULL)
	{
	  free_mux_desc_list(pPdu_mes->multiplexEntryDescriptors);
	  return H245_ERROR_NOMEM;
	}

      /* zero out the structure */
      memset (p_ASN_med_link, 0, sizeof(*p_ASN_med_link));

      /* first multiplex entry descriptor ie. time through */
      /* assign to "->multiplexEntryDescriptors" 	   */
      if (!pPdu_mes->multiplexEntryDescriptors)
	pPdu_mes->multiplexEntryDescriptors = p_ASN_med_link;

      /* every other time.. link it in.. */
      else
	{
	  ASSERT (p_ASN_med_link_lst);
	  p_ASN_med_link_lst->next = p_ASN_med_link;
	}
      /* setup for next time thorugh */
      p_ASN_med_link_lst = p_ASN_med_link;

      /* set the entry number */
      if ((p_mux_table->MuxEntryId > 15) ||
	  (p_mux_table->MuxEntryId < 1))
	{
	  free_mux_desc_list(pPdu_mes->multiplexEntryDescriptors);
	  /* MemFree (p_ASN_med_link); -- will be freed in call abouve since it is already linked in */
	  return H245_ERROR_PARAM;
	}
      p_ASN_med_link->value.multiplexTableEntryNumber = (MultiplexTableEntryNumber)p_mux_table->MuxEntryId;

      /* if entry is present */
      if (p_mux_table->pMuxTblEntryElem)
	{
	  H245_MUX_ENTRY_ELEMENT_T *p_mux_el;
	  DWORD			    error;

	  /* setup so ASN knows entry is present */
	  p_ASN_med_link->value.bit_mask = elementList_present;

	  /* for every entry  entry present.. */
	  for (p_ASN_med_link->value.elementList.count = 0, p_mux_el = p_mux_table->pMuxTblEntryElem;
	       p_mux_el;
	       p_mux_el = p_mux_el->pNext, p_ASN_med_link->value.elementList.count++)
	    {
	      if ((error =
		   build_mux_entry_element (pInstance, p_mux_el,
		    &(p_ASN_med_link->value.elementList.value[p_ASN_med_link->value.elementList.count]),0)) != H245_ERROR_OK)
		{
		  free_mux_desc_list(pPdu_mes->multiplexEntryDescriptors);
		  return error;
		}
	    } /* for */

	} /* if */
      /* else.. not present */
      else
	p_ASN_med_link->value.bit_mask = 0;

    } /* for */

  /* you've got too many mux entries.. no more than 16 .. remember.. */
  if (*p_mux_count >= 16)
    {
      free_mux_desc_list(pPdu_mes->multiplexEntryDescriptors);
      return H245_ERROR_INVALID_MUXTBLENTRY;
    }
  return H245_ERROR_OK;
}

/*****************************************************************************
 *
 * TYPE:
 *
 * PROCEDURE:   pdu_rsp_mux_table_ack -
 *
 * DESCRIPTION
 *
 * ASSUMES:
 *
 *		- Assume all mux id's are valid.
 *
 * RETURN:
 *		- H245_ERROR_OK if there are acks to send
 *		- H245_CANCELED if you shouldn't send the pdu.. (nothing to do)
 *
 *****************************************************************************/
HRESULT
pdu_rsp_mux_table_ack ( PDU_T *pPdu,
		                  WORD		            wSequenceNumber,
		                  H245_ACC_REJ_MUX_T   acc_rej_mux,
		                  DWORD		            count)
{
  DWORD			 ii;
  WORD	 num_ack = 0;
  ResponseMessage	*p_rsp 	  = &(pPdu->u.MSCMg_rspns);
  MultiplexEntrySendAck *p_mux_ack = &(p_rsp->u.multiplexEntrySendAck);

  pPdu->choice = MSCMg_rspns_chosen;
  p_rsp->choice = multiplexEntrySendAck_chosen;
  p_mux_ack->sequenceNumber = (SequenceNumber)wSequenceNumber;

  for (ii = 0; ii < count; ii++)
    {
      if (acc_rej_mux[ii].AccRej == H245_ACC)
	{
	  p_mux_ack->multiplexTableEntryNumber.value[num_ack] =
	     (MultiplexTableEntryNumber)acc_rej_mux[ii].MuxEntryId;
	  num_ack++;
	}
    }

  p_mux_ack->multiplexTableEntryNumber.count = num_ack;

  if (num_ack)
    return H245_ERROR_OK;
  else
    return H245_ERROR_CANCELED;
}

/*****************************************************************************
 *
 * TYPE:
 *
 * PROCEDURE:   pdu_rsp_mux_table_rej -
 *
 * DESCRIPTION
 *
 * ASSUMES:
 *
 *		- Assume all mux id's are valid.
 *
 * RETURN:
 *		- H245_ERROR_OK if there are rej to send
 *		- H245_CANCELED if you shouldn't send the pdu.. (nothing to do)
 *
 *****************************************************************************/
HRESULT
pdu_rsp_mux_table_rej ( PDU_T *pPdu,
		                  WORD		            wSequenceNumber,
		                  H245_ACC_REJ_MUX_T   acc_rej_mux,
		                  DWORD		            count)
{
  DWORD			    ii;
  WORD	    num_rej = 0;
  ResponseMessage	   *p_rsp 	  = &(pPdu->u.MSCMg_rspns);
  MultiplexEntrySendReject *p_mux_rej = &(p_rsp->u.multiplexEntrySendReject);

  pPdu->choice = MSCMg_rspns_chosen;
  p_rsp->choice = multiplexEntrySendReject_chosen;

  p_mux_rej->sequenceNumber = (SequenceNumber)wSequenceNumber;

  for (ii = 0; ii < count; ii++)
    {
      if (acc_rej_mux[ii].AccRej != H245_ACC)
	{
	  p_mux_rej->rejectionDescriptions.value[num_rej].multiplexTableEntryNumber =
	    (MultiplexTableEntryNumber)acc_rej_mux[ii].MuxEntryId;

	  switch (acc_rej_mux[ii].AccRej)
	    {
	    case H245_REJ_MUX_COMPLICATED:
	      p_mux_rej->rejectionDescriptions.value[num_rej].cause.choice =
		descriptorTooComplex_chosen;
	      break;

	    case H245_REJ:
	    default:
	      p_mux_rej->rejectionDescriptions.value[num_rej].cause.choice =
		MERDs_cs_unspcfdCs_chosen;
	      break;
	    }
	
	  num_rej++;
	}
    }

  p_mux_rej->rejectionDescriptions.count = num_rej;

  if (num_rej)
    return H245_ERROR_OK;
  else
    return H245_ERROR_CANCELED;
}



/*****************************************************************************
 *
 * TYPE:
 *
 * PROCEDURE:   pdu_cmd_end_session
 *
 * DESCRIPTION
 *
 * ASSUMES:
 *
 * RETURN:
 *
 *****************************************************************************/
HRESULT
pdu_cmd_end_session(PDU_T *         pPdu,
		                H245_ENDSESSION_T       		mode,
		                const H245_NONSTANDARD_PARAMETER_T *p_nonstd)
{
  CommandMessage     *p_cmd = &pPdu->u.MSCMg_cmmnd;
  EndSessionCommand  *p_pdu_endsess = &(p_cmd->u.endSessionCommand);
  p_cmd->choice = endSessionCommand_chosen;
  pPdu->choice = MSCMg_cmmnd_chosen;

  switch (mode)
    {
    case H245_ENDSESSION_DISCONNECT:
      p_pdu_endsess->choice = disconnect_chosen;
      break;
    case H245_ENDSESSION_NONSTD:
      p_pdu_endsess->choice = EndSssnCmmnd_nonStandard_chosen;
      ASSERT(p_nonstd);
      p_pdu_endsess->u.EndSssnCmmnd_nonStandard = *p_nonstd;
      break;
    case H245_ENDSESSION_TELEPHONY:
      p_pdu_endsess->choice = gstnOptions_chosen;
      p_pdu_endsess->u.gstnOptions.choice =
        EndSessionCommand_gstnOptions_telephonyMode_chosen;
      break;
    case H245_ENDSESSION_V8BIS:
      p_pdu_endsess->choice = gstnOptions_chosen;
      p_pdu_endsess->u.gstnOptions.choice = v8bis_chosen;
      break;
    case H245_ENDSESSION_V34DSVD:
      p_pdu_endsess->choice = gstnOptions_chosen;
      p_pdu_endsess->u.gstnOptions.choice =  v34DSVD_chosen;
      break;
    case H245_ENDSESSION_V34DUPFAX:
      p_pdu_endsess->choice = gstnOptions_chosen;
      p_pdu_endsess->u.gstnOptions.choice = v34DuplexFAX_chosen;
      break;
    case H245_ENDSESSION_V34H324:
      p_pdu_endsess->choice = gstnOptions_chosen;
      p_pdu_endsess->u.gstnOptions.choice = v34H324_chosen;
      break;
    default:
      return H245_ERROR_NOSUP;
    }
  return H245_ERROR_OK;
}

/*****************************************************************************
 *
 * TYPE:
 *
 * PROCEDURE:
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/
HRESULT
pdu_ind_usrinpt ( PDU_T *pPdu,
                  const H245_NONSTANDARD_PARAMETER_T *pNonStd,
                  const char *string)
{
  IndicationMessage    *p_ind     = &pPdu->u.indication;
  UserInputIndication  *p_pdu_usr = &p_ind->u.userInput;
  pPdu->choice = indication_chosen;
  p_ind->choice = userInput_chosen;

  /* Must be either one or the other */
  if (pNonStd && string)
    return H245_ERROR_PARAM;

  if (pNonStd)
  {
    p_pdu_usr->choice = UsrInptIndctn_nnStndrd_chosen;
    p_pdu_usr->u.UsrInptIndctn_nnStndrd = *pNonStd;
  }
  else if (string)
  {
    p_pdu_usr->choice = alphanumeric_chosen;
    p_pdu_usr->u.alphanumeric = (char *)string;
  }
  else
    return H245_ERROR_PARAM;

  return H245_ERROR_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\muxentry.h ===
/***********************************************************************
 *                                                                     *
 * Filename: muxentry.h                                                *
 * Module:   H245 Finite State Machine Subsystem                       *
 *                                                                     *
 ***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *                                                                     *
 * $Workfile:   MUXENTRY.H  $
 * $Revision:   1.2  $
 * $Modtime:   09 Dec 1996 13:40:40  $
 * $Log:   S:/STURGEON/SRC/H245/INCLUDE/VCS/MUXENTRY.H_v  $
 * 
 *    Rev 1.2   09 Dec 1996 13:41:02   EHOWARDX
 * Updated copyright notice.
 * 
 *    Rev 1.1   30 May 1996 23:38:26   EHOWARDX
 * Cleanup.
 * 
 *    Rev 1.0   09 May 1996 21:04:54   EHOWARDX
 * Initial revision.
 * 
 *    Rev 1.3.1.2   15 Apr 1996 10:44:00   EHOWARDX
 * Update.
 * 
 *    Rev 1.3.1.1   10 Apr 1996 21:07:32   EHOWARDX
 * Deleted No-op functions; moved state defines to .C file.
 * 
 *    Rev 1.3.1.0   05 Apr 1996 11:48:12   EHOWARDX
 * Branched.
 *
 *    Rev 1.3   29 Feb 1996 20:42:40   helgebax
 * No change.
 *
 *    Rev 1.2   28 Feb 1996 15:54:28   EHOWARDX
 * Completed first pass MTSE implementation.
 *                                                                     *
 ***********************************************************************/

// Out-going Multiplex Table (MTSE_OUT) state functions
HRESULT MTSE0_TRANSFER_requestF         (Object_t *pObject, PDU_t *pPdu);
HRESULT MTSE1_TRANSFER_requestF         (Object_t *pObject, PDU_t *pPdu);
HRESULT MTSE1_MultiplexEntrySendAckF    (Object_t *pObject, PDU_t *pPdu);
HRESULT MTSE1_MultiplexEntrySendRejF    (Object_t *pObject, PDU_t *pPdu);
HRESULT MTSE1_T104ExpiryF               (Object_t *pObject, PDU_t *pPdu);

// In-coming Multiplex Table (MTSE_OUT) state functions
HRESULT MTSE0_MultiplexEntrySendF       (Object_t *pObject, PDU_t *pPdu);
HRESULT MTSE1_MultiplexEntrySendF       (Object_t *pObject, PDU_t *pPdu);
HRESULT MTSE1_MultiplexEntrySendReleaseF(Object_t *pObject, PDU_t *pPdu);
HRESULT MTSE1_TRANSFER_responseF        (Object_t *pObject, PDU_t *pPdu);
HRESULT MTSE1_REJECT_requestF           (Object_t *pObject, PDU_t *pPdu);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\pduparse.c ===
/***********************************************************************
 *                                                                     *
 * Filename: pduparse.c                                                *
 * Module:   H245 Finite State Machine Subsystem                       *
 *                                                                     *
 ***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *                                                                     *
 * $Workfile:   PDUPARSE.C  $
 * $Revision:   1.6  $
 * $Modtime:   09 Dec 1996 13:36:34  $
 * $Log:   S:/STURGEON/SRC/H245/SRC/VCS/PDUPARSE.C_v  $
 * 
 *    Rev 1.6   09 Dec 1996 13:36:56   EHOWARDX
 * Updated copyright notice.
 * 
 *    Rev 1.5   29 Jul 1996 16:58:08   EHOWARDX
 * 
 * Missed some Geneva update PDU types.
 * 
 *    Rev 1.4   05 Jun 1996 17:15:02   EHOWARDX
 * MaintenanceLoop fix.
 * 
 *    Rev 1.3   04 Jun 1996 13:58:06   EHOWARDX
 * Fixed Release build warnings.
 * 
 *    Rev 1.2   29 May 1996 15:20:24   EHOWARDX
 * Change to use HRESULT.
 * 
 *    Rev 1.1   28 May 1996 14:25:26   EHOWARDX
 * Tel Aviv update.
 * 
 *    Rev 1.0   09 May 1996 21:06:40   EHOWARDX
 * Initial revision.
 * 
 *    Rev 1.8.1.4   09 May 1996 19:48:40   EHOWARDX
 * Change TimerExpiryF function arguements.
 * 
 *    Rev 1.8.1.3   25 Apr 1996 17:00:16   EHOWARDX
 * Minor fixes.
 * 
 *    Rev 1.8.1.2   15 Apr 1996 10:48:00   EHOWARDX
 * Update.
 *
 *    Rev 1.8.1.1   10 Apr 1996 21:15:54   EHOWARDX
 * Check-in for safety in middle of re-design.
 *
 *    Rev 1.8.1.0   05 Apr 1996 20:53:06   EHOWARDX
 * Branched.
 *                                                                     *
 ***********************************************************************/

#include "precomp.h"

#include "h245api.h"
#include "h245com.h"
#include "h245fsm.h"

/*
 *  NAME
 *      PduParseIncoming - parse an inbound PDU and determine Entity, Event, etc.
 *
 *
 *  PARAMETERS
 *      INPUT   pInst       Pointer to FSM Instance structure
 *      INPUT   pPdu        Pointer to an incoming PDU structure
 *      OUTPUT  pEntity     Pointer to variable to return PDU state entity in
 *      OUTPUT  pEvent      Pointer to variable to return PDU event in
 *      OUTPUT  pKey        Pointer to variable to return lookup key in
 *      OUTPUT  pbCreate    Pointer to variable to return create flag in
 *
 *  RETURN VALUE
 *      SUCCESS or FAIL
 */


HRESULT
PduParseIncoming(struct InstanceStruct *pInstance, PDU_t *pPdu,
                 Entity_t *pEntity, Event_t *pEvent, Key_t *pKey, int *pbCreate)
{
    ASSERT(pInstance != NULL);
    ASSERT(pPdu      != NULL);
    ASSERT(pEntity   != NULL);
    ASSERT(pEvent    != NULL);
    ASSERT(pKey      != NULL);
    ASSERT(pbCreate  != NULL);

    // Set default value for key
    *pKey = 0;

    switch (pPdu->choice)
    {

    ////////////////////////////////////////////////////////////////////
    //
    // REQUEST
    //
    ////////////////////////////////////////////////////////////////////
    case MltmdSystmCntrlMssg_rqst_chosen:
        *pbCreate = TRUE;
        switch (pPdu->u.MltmdSystmCntrlMssg_rqst.choice)
        {
        case RqstMssg_nonStandard_chosen:
            *pEntity    = STATELESS;
            *pEvent     = NonStandardRequestPDU;
            break;

        case masterSlaveDetermination_chosen:
            *pEntity    = MSDSE;
            *pEvent     = MSDetPDU;
            break;

        case terminalCapabilitySet_chosen:
            *pEntity    = CESE_IN;
            *pEvent     = TermCapSetPDU;
            break;

        case openLogicalChannel_chosen:
            if (pPdu->u.MltmdSystmCntrlMssg_rqst.u.openLogicalChannel.bit_mask & OLCl_rLCPs_present)
            {
                *pEntity    = BLCSE_IN;
                *pEvent     = OpenBChPDU;
            }
            else
            {
                *pEntity    = LCSE_IN;
                *pEvent     = OpenUChPDU;
            }
            *pKey = pPdu->u.MltmdSystmCntrlMssg_rqst.u.openLogicalChannel.forwardLogicalChannelNumber;
            break;

        case closeLogicalChannel_chosen:
            *pKey = pPdu->u.MltmdSystmCntrlMssg_rqst.u.closeLogicalChannel.forwardLogicalChannelNumber;
            if (ObjectFind(pInstance, BLCSE_IN, *pKey) != NULL)
            {
                *pEntity    = BLCSE_IN;
                *pEvent     = CloseBChPDU;
            }
            else
            {
               *pEntity     = LCSE_IN;
               *pEvent      = CloseUChPDU;
            }
            break;

        case requestChannelClose_chosen:
            *pEntity    = CLCSE_IN;
            *pEvent     = ReqChClosePDU;
            *pKey = pPdu->u.MltmdSystmCntrlMssg_rqst.u.requestChannelClose.forwardLogicalChannelNumber;
            break;

        case multiplexEntrySend_chosen:
            *pEntity    = MTSE_IN;
            *pEvent     = MultiplexEntrySendPDU;
            break;

        case requestMultiplexEntry_chosen:
            *pEntity    = RMESE_IN;
            *pEvent     = RequestMultiplexEntryPDU;
            break;

        case requestMode_chosen:
            *pEntity    = MRSE_IN;
            *pEvent     = RequestModePDU;
            break;

        case roundTripDelayRequest_chosen:
            *pEntity    = RTDSE;
            *pEvent     = RoundTripDelayRequestPDU;
            break;

        case maintenanceLoopRequest_chosen:
            *pEntity    = MLSE_IN;
            *pEvent     = MaintenanceLoopRequestPDU;
            switch (pPdu->u.MltmdSystmCntrlMssg_rqst.u.maintenanceLoopRequest.type.choice)
            {
            case systemLoop_chosen:
                break;
            case mediaLoop_chosen:
                *pKey = pPdu->u.MltmdSystmCntrlMssg_rqst.u.maintenanceLoopRequest.type.u.mediaLoop;
                break;
            case logicalChannelLoop_chosen:
                *pKey = pPdu->u.MltmdSystmCntrlMssg_rqst.u.maintenanceLoopRequest.type.u.logicalChannelLoop;
                break;
            default:
                return H245_ERROR_PARAM;
            } // switch
            break;

        case communicationModeRequest_chosen:
            *pEntity    = STATELESS;
            *pEvent     = CommunicationModeRequestPDU;
            break;

        case conferenceRequest_chosen:
            *pEntity    = STATELESS;
            *pEvent     = ConferenceRequestPDU;
            break;
#if(0) // this is not part of H.245 version 3
        case h223AnnxARcnfgrtn_chosen:
            *pEntity    = STATELESS;
            *pEvent     = H223ReconfigPDU;
            break;
#endif // if (0)
        default:
            H245TRACE(pInstance->dwInst, 1, "PduParseIncoming: Invalid Request %d",
                      pPdu->u.MltmdSystmCntrlMssg_rqst.choice);
            return H245_ERROR_PARAM;
        }
        break;

    ////////////////////////////////////////////////////////////////////
    //
    // RESPONSE
    //
    ////////////////////////////////////////////////////////////////////
    case MSCMg_rspns_chosen:
        *pbCreate = FALSE;
        switch (pPdu->u.MSCMg_rspns.choice)
        {
        case RspnsMssg_nonStandard_chosen:
            *pEntity    = STATELESS;
            *pEvent     = NonStandardResponsePDU;
            break;

        case mstrSlvDtrmntnAck_chosen:
            *pEntity    = MSDSE;
            *pEvent     = MSDetAckPDU;
            break;

        case mstrSlvDtrmntnRjct_chosen:
            *pEntity    = MSDSE;
            *pEvent     = MSDetRejectPDU;
            break;

        case terminalCapabilitySetAck_chosen:
            *pEntity    = CESE_OUT;
            *pEvent     = TermCapSetAckPDU;
            break;

        case trmnlCpbltyStRjct_chosen:
            *pEntity    = CESE_OUT;
            *pEvent     = TermCapSetRejectPDU;
            break;

        case openLogicalChannelAck_chosen:
            if (pPdu->u.MSCMg_rspns.u.openLogicalChannelAck.bit_mask & OLCAk_rLCPs_present)
            {
                *pEntity    = BLCSE_OUT;
                *pEvent     = OpenBChAckPDU;
            }
            else
            {
                *pEntity    = LCSE_OUT;
                *pEvent     = OpenUChAckPDU;
            }
            *pKey = pPdu->u.MSCMg_rspns.u.openLogicalChannelAck.forwardLogicalChannelNumber;
            break;

        case openLogicalChannelReject_chosen:
            *pKey = pPdu->u.MSCMg_rspns.u.openLogicalChannelReject.forwardLogicalChannelNumber;
            if (ObjectFind(pInstance, BLCSE_OUT, *pKey) != NULL)
            {
                *pEntity    = BLCSE_OUT;
                *pEvent     = OpenBChRejectPDU;
            }
            else
            {
               *pEntity     = LCSE_OUT;
               *pEvent      = OpenUChRejectPDU;
            }
            break;

        case closeLogicalChannelAck_chosen:
            *pKey = pPdu->u.MSCMg_rspns.u.closeLogicalChannelAck.forwardLogicalChannelNumber;
            if (ObjectFind(pInstance, BLCSE_OUT, *pKey) != NULL)
            {
                *pEntity    = BLCSE_OUT;
                *pEvent     = CloseBChAckPDU;
            }
            else
            {
               *pEntity     = LCSE_OUT;
               *pEvent      = CloseUChAckPDU;
            }
            break;

        case requestChannelCloseAck_chosen:
            *pEntity    = CLCSE_OUT;
            *pEvent     = ReqChCloseAckPDU;
            *pKey = pPdu->u.MSCMg_rspns.u.requestChannelCloseAck.forwardLogicalChannelNumber;
            break;

        case rqstChnnlClsRjct_chosen:
            *pEntity    = CLCSE_OUT;
            *pEvent     = ReqChCloseRejectPDU;
            *pKey = pPdu->u.MSCMg_rspns.u.rqstChnnlClsRjct.forwardLogicalChannelNumber;
            break;

        case multiplexEntrySendAck_chosen:
            *pEntity    = MTSE_OUT;
            *pEvent     = MultiplexEntrySendAckPDU;
            break;

        case multiplexEntrySendReject_chosen:
            *pEntity    = MTSE_OUT;
            *pEvent     = MultiplexEntrySendRejectPDU;
            break;

        case requestMultiplexEntryAck_chosen:
            *pEntity    = RMESE_OUT;
            *pEvent     = RequestMultiplexEntryAckPDU;
            break;

        case rqstMltplxEntryRjct_chosen:
            *pEntity    = RMESE_OUT;
            *pEvent     = RequestMultiplexEntryRejectPDU;
            break;

        case requestModeAck_chosen:
            *pEntity    = MRSE_OUT;
            *pEvent     = RequestModeAckPDU;
            break;

        case requestModeReject_chosen:
            *pEntity    = MRSE_OUT;
            *pEvent     = RequestModeRejectPDU;
            break;

        case roundTripDelayResponse_chosen:
            *pEntity    = RTDSE;
            *pEvent     = RoundTripDelayResponsePDU;
            break;

        case maintenanceLoopAck_chosen:
            *pEntity    = MLSE_OUT;
            *pEvent     = MaintenanceLoopAckPDU;
            switch (pPdu->u.MSCMg_rspns.u.maintenanceLoopAck.type.choice)
            {
            case systemLoop_chosen:
                break;
            case mediaLoop_chosen:
                *pKey = pPdu->u.MSCMg_rspns.u.maintenanceLoopAck.type.u.mediaLoop;
                break;
            case logicalChannelLoop_chosen:
                *pKey = pPdu->u.MSCMg_rspns.u.maintenanceLoopAck.type.u.logicalChannelLoop;
                break;
            default:
                return H245_ERROR_PARAM;
            } // switch
            break;

        case maintenanceLoopReject_chosen:
            *pEntity    = MLSE_OUT;
            *pEvent     = MaintenanceLoopRejectPDU;
            switch (pPdu->u.MSCMg_rspns.u.maintenanceLoopReject.type.choice)
            {
            case systemLoop_chosen:
                break;
            case mediaLoop_chosen:
                *pKey = pPdu->u.MSCMg_rspns.u.maintenanceLoopReject.type.u.mediaLoop;
                break;
            case logicalChannelLoop_chosen:
                *pKey = pPdu->u.MSCMg_rspns.u.maintenanceLoopReject.type.u.logicalChannelLoop;
                break;
            default:
                return H245_ERROR_PARAM;
            } // switch
            break;

        case cmmnctnMdRspns_chosen:
            *pEntity    = STATELESS;
            *pEvent     = CommunicationModeResponsePDU;
            break;

        case conferenceResponse_chosen:
            *pEntity    = STATELESS;
            *pEvent     = ConferenceResponsePDU;
            break;
#if(0) // this is not part of H.245 version 3
        case h223AnnxARcnfgrtnAck_chosen:
            *pEntity    = STATELESS;
            *pEvent     = H223ReconfigAckPDU;
            break;

        case h223AnnxARcnfgrtnRjct_chosen:
            *pEntity    = STATELESS;
            *pEvent     = H223ReconfigRejectPDU;
            break;
#endif // if(0)
        default:
            H245TRACE(pInstance->dwInst, 1, "PduParseIncoming: Invalid Response %d",
                      pPdu->u.MSCMg_rspns.choice);
            return H245_ERROR_PARAM;
        }
        break;

    ////////////////////////////////////////////////////////////////////
    //
    // COMMAND
    //
    ////////////////////////////////////////////////////////////////////
    case MSCMg_cmmnd_chosen:
        *pbCreate = FALSE;
        switch (pPdu->u.MSCMg_cmmnd.choice)
        {
        case CmmndMssg_nonStandard_chosen:
            *pEntity    = STATELESS;
            *pEvent     = NonStandardCommandPDU;
            break;

        case mntnncLpOffCmmnd_chosen:
            *pEntity    = MLSE_IN;
            *pEvent     = MaintenanceLoopOffCommandPDU;
            break;

        case sndTrmnlCpbltySt_chosen:
            *pEntity    = STATELESS;
            *pEvent     = SendTerminalCapabilitySetPDU;
            *pbCreate   = TRUE;
            break;

        case encryptionCommand_chosen:
            *pEntity    = STATELESS;
            *pEvent     = EncryptionCommandPDU;
            break;

        case flowControlCommand_chosen:
            *pEntity    = STATELESS;
            *pEvent     = FlowControlCommandPDU;
            break;

        case endSessionCommand_chosen:
            *pEntity    = STATELESS;
            *pEvent     = EndSessionCommandPDU;
            break;

        case miscellaneousCommand_chosen:
            *pEntity    = STATELESS;
            *pEvent     = MiscellaneousCommandPDU;
            break;

        case communicationModeCommand_chosen:
            *pEntity    = STATELESS;
            *pEvent     = CommunicationModeCommandPDU;
            break;

        case conferenceCommand_chosen:
            *pEntity    = STATELESS;
            *pEvent     = ConferenceCommandPDU;
            break;

        default:
            H245TRACE(pInstance->dwInst, 1, "PduParseIncoming: Invalid Command %d",
                      pPdu->u.MSCMg_cmmnd.choice);
            return H245_ERROR_PARAM;
        } // switch
        break;

    ////////////////////////////////////////////////////////////////////
    //
    // INDICATION
    //
    ////////////////////////////////////////////////////////////////////
    case indication_chosen:
        *pbCreate = FALSE;
        switch (pPdu->u.indication.choice)
        {
        case IndctnMssg_nonStandard_chosen:
            *pEntity    = STATELESS;
            *pEvent     = NonStandardIndicationPDU;
            break;

        case functionNotUnderstood_chosen:
            *pEntity    = STATELESS;
            *pEvent     = FunctionNotUnderstoodPDU;
            break;

        case mstrSlvDtrmntnRls_chosen:
            *pEntity    = MSDSE;
            *pEvent     = MSDetReleasePDU;
            break;

        case trmnlCpbltyStRls_chosen:
            *pEntity    = CESE_IN;
            *pEvent     = TermCapSetReleasePDU;
            break;

        case opnLgclChnnlCnfrm_chosen:
            *pEntity    = BLCSE_IN;
            *pEvent     = OpenBChConfirmPDU;
            *pKey = pPdu->u.indication.u.opnLgclChnnlCnfrm.forwardLogicalChannelNumber;
            break;

        case rqstChnnlClsRls_chosen:
            *pEntity    = CLCSE_IN;
            *pEvent     = ReqChCloseReleasePDU;
            *pKey = pPdu->u.indication.u.rqstChnnlClsRls.forwardLogicalChannelNumber;
            break;

        case mltplxEntrySndRls_chosen:
            *pEntity    = MTSE_IN;
            *pEvent     = MultiplexEntrySendReleasePDU;
            break;

        case rqstMltplxEntryRls_chosen:
            *pEntity    = RMESE_IN;
            *pEvent     = RequestMultiplexEntryReleasePDU;
            break;

        case requestModeRelease_chosen:
            *pEntity    = MRSE_IN;
            *pEvent     = RequestModeReleasePDU;
            break;

        case miscellaneousIndication_chosen:
            *pEntity    = STATELESS;
            *pEvent     = MiscellaneousIndicationPDU;
            break;

        case jitterIndication_chosen:
            *pEntity    = STATELESS;
            *pEvent     = JitterIndicationPDU;
            break;

        case h223SkewIndication_chosen:
            *pEntity    = STATELESS;
            *pEvent     = H223SkewIndicationPDU;
            break;

        case newATMVCIndication_chosen:
            *pEntity    = STATELESS;
            *pEvent     = NewATMVCIndicationPDU;
            break;

        case userInput_chosen:
            *pEntity    = STATELESS;
            *pEvent     = UserInputIndicationPDU;
            break;

        case h2250MxmmSkwIndctn_chosen:
            *pEntity    = STATELESS;
            *pEvent     = H2250MaximumSkewIndicationPDU;
            break;

        case mcLocationIndication_chosen:
            *pEntity    = STATELESS;
            *pEvent     = MCLocationIndicationPDU;
            break;

        case conferenceIndication_chosen:
            *pEntity    = STATELESS;
            *pEvent     = ConferenceIndicationPDU;
            break;

        case vendorIdentification_chosen:
            *pEntity    = STATELESS;
            *pEvent     = VendorIdentificationPDU;
            break;

        case IndicationMessage_functionNotSupported_chosen:
            *pEntity    = STATELESS;
            *pEvent     = FunctionNotSupportedPDU;
            break;

        default:
            H245TRACE(pInstance->dwInst, 1, "PduParseIncoming: Invalid Indication %d",
                      pPdu->u.indication.choice);
            return H245_ERROR_PARAM;
        } // switch
        break;

    default:
        H245TRACE(pInstance->dwInst, 1, "PduParseIncoming: Invalid Message Type %d",
                  pPdu->choice);
        return H245_ERROR_PARAM;
    } // switch

    return H245_ERROR_OK;
} // PduParseIncoming()



/*
 *  NAME
 *      PduParseOutgoing - parse an outbound PDU and determine Entity, Event, etc.
 *
 *  PARAMETERS
 *      INPUT   pInst       Pointer to FSM Instance structure
 *      INPUT   pPdu        Pointer to an incoming PDU structure
 *      OUTPUT  pEntity     Pointer to variable to return PDU state entity in
 *      OUTPUT  pEvent      Pointer to variable to return PDU event in
 *      OUTPUT  pKey        Pointer to variable to return lookup key in
 *      OUTPUT  pbCreate    Pointer to variable to return create flag in
 *
 *  RETURN VALUE
 *      SUCCESS or FAIL
 */

HRESULT
PduParseOutgoing(struct InstanceStruct *pInstance, PDU_t *pPdu,
                 Entity_t *pEntity, Event_t *pEvent, Key_t *pKey, int *pbCreate)
{
    ASSERT(pInstance != NULL);
    ASSERT(pPdu      != NULL);
    ASSERT(pEntity   != NULL);
    ASSERT(pEvent    != NULL);
    ASSERT(pKey      != NULL);
    ASSERT(pbCreate  != NULL);

    // Set default value for key
    *pKey = 0;

    switch (pPdu->choice)
    {

    ////////////////////////////////////////////////////////////////////
    //
    // REQUEST
    //
    ////////////////////////////////////////////////////////////////////
    case MltmdSystmCntrlMssg_rqst_chosen:
        *pbCreate = TRUE;
        switch (pPdu->u.MltmdSystmCntrlMssg_rqst.choice)
        {
        case RqstMssg_nonStandard_chosen:
            *pEntity    = STATELESS;
            break;

        case masterSlaveDetermination_chosen:
            *pEntity    = MSDSE;
            *pEvent     = MSDetReq;
            break;

        case terminalCapabilitySet_chosen:
            *pEntity    = CESE_OUT;
            *pEvent     = TransferCapRequest;
            break;

        case openLogicalChannel_chosen:
            if (pPdu->u.MltmdSystmCntrlMssg_rqst.u.openLogicalChannel.bit_mask & OLCl_rLCPs_present)
            {
                *pEntity    = BLCSE_OUT;
                *pEvent     = ReqBEstablish;
            }
            else
            {
                *pEntity    = LCSE_OUT;
                *pEvent     = ReqUEstablish;
            }
            *pKey = pPdu->u.MltmdSystmCntrlMssg_rqst.u.openLogicalChannel.forwardLogicalChannelNumber;
            break;

        case closeLogicalChannel_chosen:
            *pKey = pPdu->u.MltmdSystmCntrlMssg_rqst.u.closeLogicalChannel.forwardLogicalChannelNumber;
            if (ObjectFind(pInstance, BLCSE_OUT, *pKey) != NULL)
            {
                *pEntity    = BLCSE_OUT;
                *pEvent     = ReqClsBLCSE;
            }
            else
            {
               *pEntity     = LCSE_OUT;
               *pEvent      = ReqURelease;
            }
            break;

        case requestChannelClose_chosen:
            *pEntity    = CLCSE_OUT;
            *pEvent     = ReqClose;
            *pKey = pPdu->u.MltmdSystmCntrlMssg_rqst.u.requestChannelClose.forwardLogicalChannelNumber;
            break;

        case multiplexEntrySend_chosen:
            *pEntity    = MTSE_OUT;
            *pEvent     = MTSE_TRANSFER_request;
            break;

        case requestMultiplexEntry_chosen:
            *pEntity    = RMESE_OUT;
            *pEvent     = RMESE_SEND_request;
            break;

        case requestMode_chosen:
            *pEntity    = MRSE_OUT;
            *pEvent     = MRSE_TRANSFER_request;
            break;

        case roundTripDelayRequest_chosen:
            *pEntity    = RTDSE;
            *pEvent     = RTDSE_TRANSFER_request;
            break;

        case maintenanceLoopRequest_chosen:
            *pEntity    = MLSE_OUT;
            *pEvent     = MLSE_LOOP_request;
            switch (pPdu->u.MltmdSystmCntrlMssg_rqst.u.maintenanceLoopRequest.type.choice)
            {
            case systemLoop_chosen:
                break;
            case mediaLoop_chosen:
                *pKey = pPdu->u.MltmdSystmCntrlMssg_rqst.u.maintenanceLoopRequest.type.u.mediaLoop;
                break;
            case logicalChannelLoop_chosen:
                *pKey = pPdu->u.MltmdSystmCntrlMssg_rqst.u.maintenanceLoopRequest.type.u.logicalChannelLoop;
                break;
            default:
                return H245_ERROR_PARAM;
            } // switch
            break;

        case communicationModeRequest_chosen:
        case conferenceRequest_chosen:
        // case h223AnnxARcnfgrtn_chosen:
            *pEntity    = STATELESS;
            break;

        default:
            H245TRACE(pInstance->dwInst, 1, "PduParseOutgoing: Invalid Request %d",
                      pPdu->u.MltmdSystmCntrlMssg_rqst.choice);
            return H245_ERROR_PARAM;
        }
        break;

    ////////////////////////////////////////////////////////////////////
    //
    // RESPONSE
    //
    ////////////////////////////////////////////////////////////////////
    case MSCMg_rspns_chosen:
        *pbCreate = FALSE;
        switch (pPdu->u.MSCMg_rspns.choice)
        {
        case RspnsMssg_nonStandard_chosen:
            *pEntity    = STATELESS;
            break;

#if 0
        // Master Slave Determination Ack is generated by State Machine only
        case mstrSlvDtrmntnAck_chosen:
            *pEntity    = MSDSE;
            break;

        // Master Slave Determination Reject is generated by State Machine only
        case mstrSlvDtrmntnRjct_chosen:
            *pEntity    = MSDSE;
            break;
#endif

        case terminalCapabilitySetAck_chosen:
            *pEntity    = CESE_IN;
            *pEvent     = CESE_TRANSFER_response;
            break;

        case trmnlCpbltyStRjct_chosen:
            *pEntity    = CESE_IN;
            *pEvent     = CESE_REJECT_request;
            break;

        case openLogicalChannelAck_chosen:
            if (pPdu->u.MSCMg_rspns.u.openLogicalChannelAck.bit_mask & OLCAk_rLCPs_present)
            {
                *pEntity    = BLCSE_IN;
                *pEvent     = ResponseBEstablish;
            }
            else
            {
                *pEntity    = LCSE_IN;
                *pEvent     = ResponseUEstablish;
            }
            *pKey = pPdu->u.MSCMg_rspns.u.openLogicalChannelAck.forwardLogicalChannelNumber;
            break;

        case openLogicalChannelReject_chosen:
            *pKey = pPdu->u.MSCMg_rspns.u.openLogicalChannelReject.forwardLogicalChannelNumber;
            if (ObjectFind(pInstance, BLCSE_IN, *pKey) != NULL)
            {
                *pEntity    = BLCSE_IN;
                *pEvent     = OpenRejectBLCSE;
            }
            else
            {
               *pEntity     = LCSE_IN;
               *pEvent      = EstablishUReject;
            }
            break;

#if 0
        // Close Logical Channel Ack is generated by State Machine only
        case closeLogicalChannelAck_chosen:
            *pKey = pPdu->u.MSCMg_rspns.u.closeLogicalChannelAck.forwardLogicalChannelNumber;
            if (ObjectFind(pInstance, BLCSE_IN, *pKey) != NULL)
            {
                *pEntity    = BLCSE_IN;
            }
            else
            {
               *pEntity     = LCSE_IN;
            }
            break;
#endif

        case requestChannelCloseAck_chosen:
            *pEntity    = CLCSE_IN;
            *pEvent     = CLCSE_CLOSE_response;
            *pKey = pPdu->u.MSCMg_rspns.u.requestChannelCloseAck.forwardLogicalChannelNumber;
            break;

        case rqstChnnlClsRjct_chosen:
            *pEntity    = CLCSE_IN;
            *pEvent     = CLCSE_REJECT_request;
            *pKey = pPdu->u.MSCMg_rspns.u.rqstChnnlClsRjct.forwardLogicalChannelNumber;
            break;

        case multiplexEntrySendAck_chosen:
            *pEntity    = MTSE_IN;
            *pEvent     = MTSE_TRANSFER_response;
            break;

        case multiplexEntrySendReject_chosen:
            *pEntity    = MTSE_IN;
            *pEvent     = MTSE_REJECT_request;
            break;

        case requestMultiplexEntryAck_chosen:
            *pEntity    = RMESE_IN;
            *pEvent     = RMESE_SEND_response;
            break;

        case rqstMltplxEntryRjct_chosen:
            *pEntity    = RMESE_IN;
            *pEvent     = RMESE_REJECT_request;
            break;

        case requestModeAck_chosen:
            *pEntity    = MRSE_IN;
            *pEvent     = MRSE_TRANSFER_response;
            break;

        case requestModeReject_chosen:
            *pEntity    = MRSE_IN;
            *pEvent     = MRSE_REJECT_request;
            break;

#if 0
        // Round Trip Delay Response sent by State Machine only
        case roundTripDelayResponse_chosen:
            *pEntity    = RTDSE;
            *pEvent     = RoundTripDelayResponse;
            break;
#endif

        case maintenanceLoopAck_chosen:
            *pEntity    = MLSE_IN;
            *pEvent     = MLSE_LOOP_response;
            // Caveat: Channel number must be zero if system loop!
            *pKey = pPdu->u.MSCMg_rspns.u.maintenanceLoopAck.type.u.mediaLoop;
            break;

        case maintenanceLoopReject_chosen:
            *pEntity    = MLSE_IN;
            *pEvent     = MLSE_IN_RELEASE_request;
            // Caveat: Channel number must be zero if system loop!
            *pKey = pPdu->u.MSCMg_rspns.u.maintenanceLoopReject.type.u.mediaLoop;
            break;

        case cmmnctnMdRspns_chosen:
        case conferenceResponse_chosen:
//        case h223AnnxARcnfgrtnAck_chosen:
//        case h223AnnxARcnfgrtnRjct_chosen:
            *pEntity    = STATELESS;
            break;

        default:
            H245TRACE(pInstance->dwInst, 1, "PduParseOutgoing: Invalid Response %d",
                      pPdu->u.MSCMg_rspns.choice);
            return H245_ERROR_PARAM;
        }
        break;

    ////////////////////////////////////////////////////////////////////
    //
    // COMMAND
    //
    ////////////////////////////////////////////////////////////////////
    case MSCMg_cmmnd_chosen:
        *pbCreate = FALSE;
        switch (pPdu->u.MSCMg_cmmnd.choice)
        {
        case CmmndMssg_nonStandard_chosen:
            *pEntity    = STATELESS;
            break;

        case mntnncLpOffCmmnd_chosen:
            *pEntity    = MLSE_OUT;
            *pEvent     = MLSE_OUT_RELEASE_request;
            break;

        case sndTrmnlCpbltySt_chosen:
        case encryptionCommand_chosen:
        case flowControlCommand_chosen:
        case endSessionCommand_chosen:
        case miscellaneousCommand_chosen:
        case communicationModeCommand_chosen:
        case conferenceCommand_chosen:
            *pEntity    = STATELESS;
            break;

        default:
            H245TRACE(pInstance->dwInst, 1, "PduParseOutgoing: Invalid Command %d",
                      pPdu->u.MSCMg_cmmnd.choice);
            return H245_ERROR_PARAM;
        } // switch
        break;

    ////////////////////////////////////////////////////////////////////
    //
    // INDICATION
    //
    ////////////////////////////////////////////////////////////////////
    case indication_chosen:
        *pbCreate = FALSE;
        switch (pPdu->u.indication.choice)
        {
        case IndctnMssg_nonStandard_chosen:
            *pEntity    = STATELESS;
            break;

        case functionNotUnderstood_chosen:
            *pEntity    = STATELESS;
            break;

#if 0
        // Master Slave Determination Release is sent by State Machine Only
        case mstrSlvDtrmntnRls_chosen:
            *pEntity    = MSDSE;
            break;

       // Terminal Capability Set Release is sent by State Machine Only
        case trmnlCpbltyStRls_chosen:
            *pEntity    = CESE_OUT
            break;
#endif

        case opnLgclChnnlCnfrm_chosen:
            *pEntity    = BLCSE_OUT;
            *pEvent     = RspConfirmBLCSE;
            *pKey = pPdu->u.indication.u.opnLgclChnnlCnfrm.forwardLogicalChannelNumber;
            break;

#if 0
        // Request Channel Close Release is sent by State Machine Only
        case rqstChnnlClsRls_chosen:
            *pEntity    = CLCSE_OUT;
            *pKey = pPdu->u.indication.u.rqstChnnlClsRls.forwardLogicalChannelNumber;
            break;

        // Multiplex Entry Send Release is sent by State Machine Only
        case mltplxEntrySndRls_chosen:
            *pEntity    = MTSE_OUT;
            break;

        // Request Multiplex Entry Release is sent by State Machine Only
        case rqstMltplxEntryRls_chosen:
            *pEntity    = RMESE_OUT;
            break;

        // Request Mode Release is sent by State Machine Only
        case requestModeRelease_chosen:
            *pEntity    = MRSE_OUT;
            break;
#endif

        case miscellaneousIndication_chosen:
        case jitterIndication_chosen:
        case h223SkewIndication_chosen:
        case newATMVCIndication_chosen:
        case userInput_chosen:
        case h2250MxmmSkwIndctn_chosen:
        case mcLocationIndication_chosen:
        case conferenceIndication_chosen:
        case vendorIdentification_chosen:
        case IndicationMessage_functionNotSupported_chosen:
            *pEntity    = STATELESS;
            break;

        default:
            H245TRACE(pInstance->dwInst, 1, "PduParseOutgoing: Invalid Indication %d",
                      pPdu->u.indication.choice);
            return H245_ERROR_PARAM;
        } // switch
        break;

    default:
        H245TRACE(pInstance->dwInst, 1, "PduParseOutgoing: Invalid Message Type %d",
                  pPdu->choice);
        return H245_ERROR_PARAM;
    } // switch

    return H245_ERROR_OK;
} // PduParseOutgoing()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\openb.h ===
/***********************************************************************
 *                                                                     *
 * Filename: openb.h                                                   *
 * Module:   H245 Finite State Machine Subsystem                       *
 *                                                                     *
 ***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *                                                                     *
 * $Workfile:   OPENB.H  $
 * $Revision:   1.2  $
 * $Modtime:   09 Dec 1996 13:42:50  $
 * $Log:   S:/STURGEON/SRC/H245/INCLUDE/VCS/OPENB.H_v  $
 * 
 *    Rev 1.2   09 Dec 1996 13:42:52   EHOWARDX
 * Updated copyright notice.
 * 
 *    Rev 1.1   30 May 1996 23:38:26   EHOWARDX
 * Cleanup.
 * 
 *    Rev 1.0   09 May 1996 21:04:56   EHOWARDX
 * Initial revision.
 * 
 *    Rev 1.4.1.3   09 May 1996 19:42:38   EHOWARDX
 * 
 * Removed gratuitious outgoing waiting for confirm state that was
 * not in the ITI SDLs.
 * 
 *    Rev 1.4.1.2   15 Apr 1996 10:44:10   EHOWARDX
 * Update.
 * 
 *    Rev 1.4.1.1   10 Apr 1996 21:07:14   EHOWARDX
 * Deleted No-op functions; moved state defines to .C file.
 * 
 *    Rev 1.4.1.0   05 Apr 1996 12:14:20   helgebax
 * Branched.
 *                                                                     *
 ***********************************************************************/

// Open Bi-directional Logical Channel Out-going state functions
HRESULT establishReqBReleased           (Object_t *pObject, PDU_t *pPdu);
HRESULT openChannelAckBAwaitingE        (Object_t *pObject, PDU_t *pPdu);
HRESULT openChannelRejBAwaitingE        (Object_t *pObject, PDU_t *pPdu);
HRESULT releaseReqBOutAwaitingE         (Object_t *pObject, PDU_t *pPdu);
HRESULT t103ExpiryBAwaitingE            (Object_t *pObject, PDU_t *pPdu);
HRESULT releaseReqBEstablished          (Object_t *pObject, PDU_t *pPdu);
HRESULT openChannelRejBEstablished      (Object_t *pObject, PDU_t *pPdu);
HRESULT closeChannelAckBEstablished     (Object_t *pObject, PDU_t *pPdu);
HRESULT closeChannelAckAwaitingR        (Object_t *pObject, PDU_t *pPdu);
HRESULT openChannelRejBAwaitingR        (Object_t *pObject, PDU_t *pPdu);
HRESULT t103ExpiryBAwaitingR            (Object_t *pObject, PDU_t *pPdu);
HRESULT establishReqAwaitingR           (Object_t *pObject, PDU_t *pPdu);

// Open Bi-directional Logical Channel In-coming state functions
HRESULT openChannelBReleased            (Object_t *pObject, PDU_t *pPdu);
HRESULT closeChannelBReleased           (Object_t *pObject, PDU_t *pPdu);
HRESULT establishResBAwaitingE          (Object_t *pObject, PDU_t *pPdu);
HRESULT releaseReqBInAwaitingE          (Object_t *pObject, PDU_t *pPdu);
HRESULT closeChannelBAwaitingE          (Object_t *pObject, PDU_t *pPdu);
HRESULT openChannelBAwaitingE           (Object_t *pObject, PDU_t *pPdu);
HRESULT openChannelConfirmBAwaitingE    (Object_t *pObject, PDU_t *pPdu);
HRESULT t103ExpiryBAwaitingC            (Object_t *pObject, PDU_t *pPdu);
HRESULT openChannelConfirmBAwaitingC    (Object_t *pObject, PDU_t *pPdu);
HRESULT closeChannelBAwaitingC          (Object_t *pObject, PDU_t *pPdu);
HRESULT openChannelBAwaitingC           (Object_t *pObject, PDU_t *pPdu);
HRESULT closeChannelBEstablished        (Object_t *pObject, PDU_t *pPdu);
HRESULT openChannelBEstablished         (Object_t *pObject, PDU_t *pPdu);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\precomp.h ===
#include <windows.h>
#include <windowsx.h>
#include <winsock2.h>
#include <winreg.h>
#include <oprahcom.h>

#define MULTI_LEVEL_ZONES
#include <mlzdbg.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\port32.h ===
//////////////////////////////////////////////////////////////////////////////
//
//              INTEL CORPORATION PROPRIETARY INFORMATION
//  
//   This source is supplied under the terms of a licence agreement or
//   non-disclosure statement with Intel Corporation and may not be copied
//   nor disclosed except in accordance with the terms of that agreement.
//
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// PORT32.H
// Stuff to make porting from Win3.1 to Win32 a little less hellish.
//////////////////////////////////////////////////////////////////////////////
#ifndef PORT32_H
#define PORT32_H


//////////////////////////////////////////////////////////////////////////////
// some convenient, explicit types
//////////////////////////////////////////////////////////////////////////////
typedef short INTEGER_16;
typedef int INTEGER_32;
typedef unsigned short UINTEGER_16;
typedef unsigned int UINTEGER_32;
typedef short BOOLEAN_16;

#ifndef _BASETSD_H_
typedef short INT16;
typedef int INT32;
typedef unsigned short UINT16;
typedef unsigned int UINT32;
#endif

typedef short BOOL16;
	
//////////////////////////////////////////////////////////////////////////////
// macros to make old keywords go away
//////////////////////////////////////////////////////////////////////////////
#define __pascal
#define _pascal
#define _far
#define __far
#define _export
#define __export
#define _huge
#define huge
#define __huge
#define  __segment
#define _HFAR_
#define _loadds
#define __loadds

//////////////////////////////////////////////////////////////////////////////
// other macros that may or may not be handy
//////////////////////////////////////////////////////////////////////////////
#define WRITE OF_WRITE

#define OFFSETOF(lp)        (int) (lp)
#define SELECTOROF

#define GLOBALHANDLE(lp)      GlobalHandle(lp)
#define GLOBALHANDLEFUNC(lp)  GlobalHandle(lp)
#define LOCALHANDLE(lp)       LocalHandle(lp)
#define LOCALHANDLEFUNC(lp)   LocalHandle(lp)


#define _AfxGetPtrFromFarPtr(p)   ((void*)(p))
#define GETWINDOWHINSTANCE(hWnd)  GetWindowLong(hWnd ,GWL_HINSTANCE)
#define GETWINDOWHPARENT(hWnd)    GetWindowLong(hWnd, GWL_HWNDPARENT)
#define GETWINDOWID(hWnd)         GetWindowLong(hWnd, GWL_ID)

#define SETCLASSCURSOR(hWnd,NewVal)  SetClassLong(hWnd ,GCL_HCURSOR,NewVal)

//////////////////////////////////////////////////////////////////////////////
// Name of shared mutex for serializing access to 16-bit data stack
//////////////////////////////////////////////////////////////////////////////
#define STR_DATASTACKMUX "_mux_DataStack"

#endif // PORT32_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\protocol.h ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/Q931/VCS/protocol.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1996 Intel Corporation.
 *
 *	$Revision:   1.3  $
 *	$Date:   Apr 25 1996 21:21:48  $
 *	$Author:   plantz  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *		
 *      Line Protocol Definitions.
 *
 *	Notes:
 *
 ***************************************************************************/


#ifndef PROTOCOL_H
#define PROTOCOL_H

#ifdef __cplusplus
extern "C" {
#endif


#define TYPE_Q931_SETUP                 1
#define TYPE_Q931_CONNECT               2
#define TYPE_Q931_RELEASE_COMPLETE      3
#define TYPE_Q931_ALERTING              4
// and more later....


#define Q931_PROTOCOL ((WORD)0x1)

typedef struct 
{
	WORD            wProtocol;      // identifies Q931 protocol.
	WORD            wType;          // defined above.
} MSG_Q931, *PMSG_Q931;

typedef struct 
{
	WORD            wProtocol;      // identifies Q931 protocol.
	WORD            wType;          // defined above.
    HQ931CALL       hCallID;
    ADDR            CallerAddr;     // needed because call may be made from gatekeeper.
    ADDR            CalleeAddr;     // needed because call may be made to gatekeeper.
    WORD            wConferenceID;
    WORD            wGoal;
	H323USERINFO    H323UserInfo;
    char            H323UserData[0];
} MSG_Q931_SETUP, *PMSG_Q931_SETUP;

typedef struct 
{
	WORD            wProtocol;      // identifies Q931 protocol.
	WORD            wType;          // defined above.
    HQ931CALL       hCallID;
    WORD            wConferenceID;
    ADDR            H245Addr;       // address returned by callee.
	H323USERINFO    H323UserInfo;
    char            H323UserData[0];
} MSG_Q931_CONNECT, *PMSG_Q931_CONNECT;


typedef struct 
{
	WORD            wProtocol;      // identifies Q931 protocol.
	WORD            wType;          // defined above.
    HQ931CALL       hCallID;
    WORD            wConferenceID;  //   I think this should be passed from the user...
	BYTE            bReason;        // defined above.
    ADDR            AlternateAddr;  // alternative address to use.
	H323USERINFO    H323UserInfo;
    char            H323UserData[0];
} MSG_Q931_RELEASE_COMPLETE, *PMSG_Q931_RELEASE_COMPLETE;


typedef struct 
{
	WORD            wProtocol;      // identifies Q931 protocol.
	WORD            wType;          // defined above.
    HQ931CALL       hCallID;
} MSG_Q931_ALERTING, *PMSG_Q931_ALERTING;


#ifdef __cplusplus
}
#endif

#endif PROTOCOL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\q931asn1.h ===
#ifndef _Q931_ASN1_H_
#define _Q931_ASN1_H_

#include "av_asn1.h"

#ifdef __cplusplus
extern "C" {
#endif


// H310Caps, H320Caps, H321Caps, H322Caps, H323Caps, H324Caps, VoiceCaps, T120OnlyCaps, McuInfo, TerminalInfo, GatekeeperInfo
#define GtkprInf_nnStndrdDt_present     H310Caps_nonStandardData_present
#define GtkprInf_nnStndrdDt             nonStandardData

// GatewayInfo
#define GtwyInf_nonStandardData_present GatewayInfo_nonStandardData_present
#define GtwyInf_nonStandardData         nonStandardData

// EndpointType
#define EndpntTyp_nnStndrdDt_present    EndpointType_nonStandardData_present
#define EndpntTyp_nnStndrdDt            nonStandardData


// CallProceeding_UUIE, Alerting_UUIE
#define CPg_UUIE_h245Addrss_present     CallProceeding_UUIE_h245Address_present
#define CPg_UUIE_h245Addrss             h245Address

// Connect_UUIE
#define Cnnct_UUIE_h245Address_present  Connect_UUIE_h245Address_present
#define Cnnct_UUIE_h245Address          h245Address

// ReleaseCompleteReason
#define RlsCmpltRsn_undfndRsn_chosen    ReleaseCompleteReason_undefinedReason_chosen

// FacilityReason
#define FcltyRsn_undefinedReason_chosen FacilityReason_undefinedReason_chosen

// H323_UU_PDU
#define H323_UU_PDU_nnStndrdDt_present  H323_UU_PDU_nonStandardData_present
#define H323_UU_PDU_nnStndrdDt          nonStandardData


#ifdef __cplusplus
} // extern "C"
#endif

#endif // _Q931_ASN1_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\postrecv.cpp ===
/************************************************************************
*																		*
*	INTEL CORPORATION PROPRIETARY INFORMATION							*
*																		*
*	This software is supplied under the terms of a license			   	*
*	agreement or non-disclosure agreement with Intel Corporation		*
*	and may not be copied or disclosed except in accordance	   			*
*	with the terms of that agreement.									*
*																		*
*	Copyright (C) 1997 Intel Corp.	All Rights Reserved					*
*																		*
*	$Archive:   S:/STURGEON/SRC/GKI/VCS/postrecv.cpv  $
*																		*
*	$Revision:   1.8  $
*	$Date:   13 Feb 1997 15:05:20  $
*																		*
*	$Author:   unknown  $
*																		*
*   $Log:   S:/STURGEON/SRC/GKI/VCS/postrecv.cpv  $
// 
//    Rev 1.8   13 Feb 1997 15:05:20   unknown
// Moved CGatekeeper::Unlock to end of PostRecv thread to avoid shutdown err
// 
//    Rev 1.7   12 Feb 1997 01:12:08   CHULME
// Redid thread synchronization to use Gatekeeper.Lock
// 
//    Rev 1.6   24 Jan 1997 18:36:24   CHULME
// Reverted to rev 1.4
// 
//    Rev 1.4   17 Jan 1997 09:02:32   CHULME
// Changed reg.h to gkreg.h to avoid name conflict with inc directory
// 
//    Rev 1.3   10 Jan 1997 16:15:54   CHULME
// Removed MFC dependency
// 
//    Rev 1.2   22 Nov 1996 15:21:24   CHULME
// Added VCS log to the header
*************************************************************************/

// postrecv.cpp : Provides the secondary thread implementation
//
#include "precomp.h"

#include "gkicom.h"
#include "dspider.h"
#include "dgkilit.h"
#include "DGKIPROT.H"
#include "gksocket.h"
#include "GKREG.H"
#include "GATEKPR.H"
#include "h225asn.h"
#include "coder.hpp"
#include "dgkiext.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

void 
PostReceive(void *pv)
{
	// ABSTRACT:  This function is invoked in a separate thread to
	//            post a receive on the associated socket.  When a datagram
	//            arrives, this function will decode it and send it
	//            to the PDUHandler.  If the PDUHandler doesn't instruct
	//            this thread to exit (with a non-zero return code), this
	//            function will post another receive.
	// AUTHOR:    Colin Hulme

	char			szBuffer[512];
	int				nRet;
	ASN1_BUF		Asn1Buf;
	DWORD			dwErrorCode;
	RasMessage		*pRasMessage;
#ifdef _DEBUG
	char			szGKDebug[80];
#endif
	HRESULT			hResult = GKI_OK;

	SPIDER_TRACE(SP_FUNC, "PostReceive(pv)\n", 0);
	ASSERT(g_pCoder);
	if ((g_pCoder == NULL) && (g_pGatekeeper == NULL))
		return;	
		
	while ((hResult == GKI_OK) && g_pReg && H225ASN_Module)
	{
		g_pReg->LockSocket();			
		nRet = g_pReg->m_pSocket->Receive(szBuffer, 512);
		g_pReg->UnlockSocket();

		g_pGatekeeper->Lock();
		if ((g_pReg == 0) || (H225ASN_Module == NULL))
		{
			SPIDER_TRACE(SP_THREAD, "PostReceive thread exiting\n", 0);
			g_pGatekeeper->Unlock();
			return;
		}		

		if (nRet != SOCKET_ERROR)
		{
			if (fGKIEcho && (pEchoBuff != 0))
			{
				if (nEchoLen != nRet)
				{
					SPIDER_TRACE(SP_DEBUG, "*** Received buffer len != Sent buffer len ***\n", 0);
				}
				if (memcmp(szBuffer, pEchoBuff, nEchoLen) == 0)
				{
					SPIDER_TRACE(SP_DEBUG, "Received buffer = Sent buffer\n", 0);
				}
				else
				{
					SPIDER_TRACE(SP_DEBUG, "*** Received buffer != Sent buffer ***\n", 0);
				}
				SPIDER_TRACE(SP_NEWDEL, "del pEchoBuff = %X\n", pEchoBuff);
				delete pEchoBuff;
				pEchoBuff = 0;
			}
			else	// Process incoming PDU
			{
				// Setup Asn1Buf for decoder and decode PDU
				Asn1Buf.length = nRet;	// number of bytes received
				Asn1Buf.value = (unsigned char *)szBuffer;
				dwErrorCode = g_pCoder->Decode(&Asn1Buf, &pRasMessage);

				if (dwErrorCode)
				{
					SPIDER_TRACE(SP_GKI, "PostMessage(m_hWnd, m_wBaseMessage + GKI_ERROR, 0, GKI_DECODER_ERROR)\n", 0);
					PostMessage(g_pReg->GetHWnd(), g_pReg->GetBaseMessage() + GKI_ERROR, 0, GKI_DECODER_ERROR);
				}

				else
				{
#ifdef _DEBUG
					if (dwGKIDLLFlags & SP_DUMPMEM)
						DumpMem(pRasMessage, sizeof(RasMessage));
#endif
					hResult = g_pReg->PDUHandler(pRasMessage);

					// Notify client app if an error code was received
					if (hResult & HR_SEVERITY_MASK)
					{
						SPIDER_TRACE(SP_GKI, "PostMessage(m_hWnd, m_wBaseMessage + GKI_ERROR, 0, %X)\n", hResult);
						PostMessage(g_pReg->GetHWnd(), g_pReg->GetBaseMessage() + GKI_ERROR, 0, 
																hResult);
					}
				}

				// Free the encoder memory
				g_pCoder->Free(pRasMessage);
			}
		}
		//======================================================================================
		else
		{
			// WSAEINTR - returned when socket closed
			//            get out cleanly
			if (g_pReg->m_pSocket->GetLastError() == WSAEINTR)
				hResult = GKI_REDISCOVER;

			else
			{
				hResult = GKI_WINSOCK2_ERROR(g_pReg->m_pSocket->GetLastError());
				SPIDER_TRACE(SP_GKI, "PostMessage(m_hWnd, m_wBaseMessage + GKI_ERROR, 0, %X)\n", hResult);
				PostMessage(g_pReg->GetHWnd(), g_pReg->GetBaseMessage() + GKI_ERROR, 0, hResult);
				hResult = GKI_EXIT_THREAD;
			}
		}

		// Release access to the registration object
		g_pGatekeeper->Unlock();
	}

	// Lock access to the registration object
	g_pGatekeeper->Lock();
	if (g_pReg == 0)
	{
		SPIDER_TRACE(SP_THREAD, "PostReceive thread exiting\n", 0);
		g_pGatekeeper->Unlock();
		return;
	}
	if (hResult != GKI_REDISCOVER)
	{
		SPIDER_TRACE(SP_NEWDEL, "del g_pReg = %X\n", g_pReg);
		delete g_pReg;
		g_pReg = 0;
	}
	else
		g_pReg->SetRcvThread(0);

	SPIDER_TRACE(SP_THREAD, "PostReceive thread exiting\n", 0);
	g_pGatekeeper->Unlock();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\q931man.h ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/CALLCONT/VCS/q931man.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1994 Intel Corporation.
 *
 *	$Revision:   1.14  $
 *	$Date:   Aug 12 1996 09:40:40  $
 *	$Author:   mandrews  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *		
 *
 *	Notes:
 *
 ***************************************************************************/

HRESULT InitQ931Manager();

HRESULT DeInitQ931Manager();

DWORD Q931Callback(					BYTE					bEvent,
									HQ931CALL				hQ931Call,
									DWORD_PTR				dwListenToken,
									DWORD_PTR				dwUserToken,
									void *					pEventData);



								


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\q931.c ===
/****************************************************************************
 *
 *	$Archive:	S:/STURGEON/SRC/Q931/VCS/q931.c_v  $
 *
 *	INTEL Corporation Prorietary Information
 *
 *	This listing is	supplied under the terms of	a license agreement
 *	with INTEL Corporation and may not be copied nor disclosed except
 *	in accordance with the terms of	that agreement.
 *
 *	Copyright (c) 1993-1996	Intel Corporation.
 *
 *	$Revision:	 1.122	$
 *	$Date:	 04	Mar	1997 20:59:26  $
 *	$Author:   MANDREWS	 $
 *
 *	BCL's revision info:
 *	Revision:	1.99
 *	Date:	19 Nov 1996	14:54:02
 *	Author:	  rodellx
 *
 *	Deliverable:
 *
 *	Abstract:
 *		
 *
 *	Notes:
 *
 ***************************************************************************/
// [ ] Add facility	ie to FACILITY MSG.
// [ ] Read	Q931 Appendix D.

#pragma	warning	( disable :	4057 4100 4115 4201	4214 4514 )

#include "precomp.h"

#ifdef __cplusplus
extern "C" {
#endif

#include <string.h>
#include <stdio.h>

#include <rpc.h>

#include "apierror.h"
#include "isrg.h"
#include "incommon.h"
#include "linkapi.h"

#include "common.h"
#include "q931.h"
#include "utils.h"
#include "hlisten.h"
#include "hcall.h"
#include "q931pdu.h"

#if	(defined(_DEBUG) ||	defined(PCS_COMPLIANCE))
#include "interop.h"
#include "q931plog.h"
LPInteropLogger	Q931Logger;
#endif

#define	RECEIVE_BUFFER_SIZE	0x2000
#define	HANGUP_TIMEOUT				1000		// 1 second
#define	CANCEL_LISTEN_TIMEOUT		5000		// 5 seconds

// variable	needed to support ISR debug	facility.
#if	(ISRDEBUGINFO >= 1)
WORD ghISRInst = 0;
#endif

#ifdef UNICODE_TRACE
// We include this header to fix problems with macro expansion when	Unicode	is turned on.
#include "unifix.h"
#endif

#define	_Unicode(x)	L ## x
#define	Unicode(x) _Unicode(x)

// global data used	by WinSock.
static BOOL	bQ931Initialized = FALSE;

static Q931_RECEIVE_PDU_CALLBACK gReceivePDUHookProc = NULL;

static struct
{
	DWORD TempID;
	CC_CONFERENCEID	ConferenceID;
	CRITICAL_SECTION Lock;
} ConferenceIDSource;


extern VOID	Q931PduInit();

//====================================================================================
//
// PRIVATE FUNCTIONS
//
//====================================================================================

//====================================================================================
//====================================================================================
void _FreeSetupASN(Q931_SETUP_ASN *pSetupASN)
{
	ASSERT(pSetupASN !=	NULL);

	// Cleanup any dynamically allocated fields	within SetupASN
	if (pSetupASN->NonStandardData.sData.pOctetString)
	{
		MemFree(pSetupASN->NonStandardData.sData.pOctetString);
		pSetupASN->NonStandardData.sData.pOctetString =	NULL;
	}
	if (pSetupASN->VendorInfo.pProductNumber)
	{
		MemFree(pSetupASN->VendorInfo.pProductNumber);
		pSetupASN->VendorInfo.pProductNumber = NULL;
	}
	if (pSetupASN->VendorInfo.pVersionNumber)
	{
		MemFree(pSetupASN->VendorInfo.pVersionNumber);
		pSetupASN->VendorInfo.pVersionNumber = NULL;
	}
	Q931FreeAliasNames(pSetupASN->pCallerAliasList);
	pSetupASN->pCallerAliasList	= NULL;
	Q931FreeAliasNames(pSetupASN->pCalleeAliasList);
	pSetupASN->pCalleeAliasList	= NULL;
	Q931FreeAliasNames(pSetupASN->pExtraAliasList);
	pSetupASN->pExtraAliasList = NULL;
	Q931FreeAliasItem(pSetupASN->pExtensionAliasItem);
	pSetupASN->pExtensionAliasItem = NULL;
}


void _FreeReleaseCompleteASN(Q931_RELEASE_COMPLETE_ASN *pReleaseCompleteASN)
{
	ASSERT(pReleaseCompleteASN != NULL);

	// Cleanup any dynamically allocated fields	within SetupASN
	if (pReleaseCompleteASN->NonStandardData.sData.pOctetString)
	{
		MemFree(pReleaseCompleteASN->NonStandardData.sData.pOctetString);
		pReleaseCompleteASN->NonStandardData.sData.pOctetString	= NULL;
	}
}


void _FreeFacilityASN(Q931_FACILITY_ASN	*pFacilityASN)
{
	ASSERT(pFacilityASN	!= NULL);

	// Cleanup any dynamically allocated fields	within SetupASN
	if (pFacilityASN->NonStandardData.sData.pOctetString)
	{
		MemFree(pFacilityASN->NonStandardData.sData.pOctetString);
		pFacilityASN->NonStandardData.sData.pOctetString = NULL;
	}
}


void _FreeProceedingASN(Q931_CALL_PROCEEDING_ASN *pProceedingASN)
{
	ASSERT(pProceedingASN != NULL);

	// Cleanup any dynamically allocated fields	within SetupASN
	if (pProceedingASN->NonStandardData.sData.pOctetString)
	{
		MemFree(pProceedingASN->NonStandardData.sData.pOctetString);
		pProceedingASN->NonStandardData.sData.pOctetString = NULL;
	}
}


void _FreeAlertingASN(Q931_ALERTING_ASN	*pAlertingASN)
{
	ASSERT(pAlertingASN	!= NULL);

	// Cleanup any dynamically allocated fields	within SetupASN
	if (pAlertingASN->NonStandardData.sData.pOctetString)
	{
		MemFree(pAlertingASN->NonStandardData.sData.pOctetString);
		pAlertingASN->NonStandardData.sData.pOctetString = NULL;
	}
}


void _FreeConnectASN(Q931_CONNECT_ASN *pConnectASN)
{
	ASSERT(pConnectASN != NULL);

	// Cleanup any dynamically allocated fields	within SetupASN
	if (pConnectASN->NonStandardData.sData.pOctetString)
	{
		MemFree(pConnectASN->NonStandardData.sData.pOctetString);
		pConnectASN->NonStandardData.sData.pOctetString	= NULL;
	}
	if (pConnectASN->VendorInfo.pProductNumber)
	{
		MemFree(pConnectASN->VendorInfo.pProductNumber);
		pConnectASN->VendorInfo.pProductNumber = NULL;
	}
	if (pConnectASN->VendorInfo.pVersionNumber)
	{
		MemFree(pConnectASN->VendorInfo.pVersionNumber);
		pConnectASN->VendorInfo.pVersionNumber = NULL;
	}
}


void
_ConferenceIDNew(
	CC_CONFERENCEID	*pConferenceID)
{
	UUID id;
	int	iresult;

	EnterCriticalSection(&(ConferenceIDSource.Lock));

	memset(ConferenceIDSource.ConferenceID.buffer, 0,
		sizeof(ConferenceIDSource.ConferenceID.buffer));
	iresult	= UuidCreate(&id);

	if ((iresult ==	RPC_S_OK) || (iresult ==RPC_S_UUID_LOCAL_ONLY))
	{
		memcpy(ConferenceIDSource.ConferenceID.buffer, &id,
			min(sizeof(ConferenceIDSource.ConferenceID.buffer),	sizeof(UUID)));
	}
	else
		ASSERT(0);

	memcpy(pConferenceID->buffer, ConferenceIDSource.ConferenceID.buffer,
		sizeof(pConferenceID->buffer));

	LeaveCriticalSection(&(ConferenceIDSource.Lock));
	return;
}

//====================================================================================
// This	function is	used internally	whenever a function	needs to send a	PDU.
// Note	that before	a datalinkSendRequest()	is done, the call object is	unlocked
// and then	subsequently locked	after returning.  This is necessary	to prevent deadlock
// in MT apps.	Further, it	is the responsibility of calling functions to revalidate
// the call	object before using	it.
//====================================================================================
CS_STATUS
Q931SendMessage(
	P_CALL_OBJECT		pCallObject,
	BYTE*				CodedPtrPDU,
	DWORD				CodedLengthPDU,
	BOOL				bOkToUnlock)
{
	HQ931CALL			hQ931Call;
	DWORD				dwPhysicalId;
	HRESULT				result;

	ASSERT(pCallObject != NULL);
	ASSERT(CodedPtrPDU != NULL);
	ASSERT(CodedLengthPDU != 0);

	hQ931Call	 = pCallObject->hQ931Call;
	dwPhysicalId = pCallObject->dwPhysicalId;

	// send	the	message.
	if (pCallObject->bConnected)
	{
		// Unlock the call object before we	call down to Link Layer	(if	caller said	it was ok)
		if(bOkToUnlock)
			CallObjectUnlock(pCallObject);

#if	(defined(_DEBUG) ||	defined(PCS_COMPLIANCE))
		InteropOutput(Q931Logger, (BYTE	FAR*)CodedPtrPDU, CodedLengthPDU, Q931LOG_SENT_PDU);
#endif

		result = datalinkSendRequest(dwPhysicalId, CodedPtrPDU,	CodedLengthPDU);

		// Now attempt to lock the object again.  Note:	higher level funcs must
		// be sure to call CallObjectValidate before assuming they have	a valid	lock
		if (bOkToUnlock	&& ((CallObjectLock(hQ931Call, &pCallObject) !=	CS_OK) || (pCallObject == NULL)))
		{
			ISRERROR(ghISRInst,	"CallObjectLock() returned error (object not found).", 0L);
		}

		// Note: if	we can't get the lock, perhaps we should pass back a specific return code
		// that	higher layers can check	for??? For now,	they should	call CallObjectValidate()
		// before assuming the call	object is still	good.
		if (FAILED(result))
		{
			ISRERROR(ghISRInst,	"datalinkSendRequest() failed",	0L);
			MemFree(CodedPtrPDU);
		}
		return result;
	}

	ISRWARNING(ghISRInst, "Q931SendMessage:	message	not	sent because bConnected	is FALSE", 0L);
	MemFree(CodedPtrPDU);
	return CS_OK;
}


//====================================================================================
//====================================================================================
CS_STATUS
Q931RingingInternal(P_CALL_OBJECT pCallObject, WORD	wCRV)
{
	CC_ENDPOINTTYPE	EndpointType;
	DWORD CodedLengthASN;
	BYTE *CodedPtrASN;
	BINARY_STRING UserUserData;
	DWORD CodedLengthPDU;
	BYTE *CodedPtrPDU;
	HRESULT	result = CS_OK;
	int	nError = 0;
	HQ931CALL hQ931Call	= pCallObject->hQ931Call;

	if (pCallObject->VendorInfoPresent)
		EndpointType.pVendorInfo = &pCallObject->VendorInfo;
	else
		EndpointType.pVendorInfo = NULL;
	EndpointType.bIsTerminal = pCallObject->bIsTerminal;
	EndpointType.bIsGateway	= pCallObject->bIsGateway;

	result = Q931AlertingEncodeASN(
		NULL, /* pNonStandardData */
		NULL, /* h245Addr */
		&EndpointType,
		&pCallObject->World,
		&CodedPtrASN,
		&CodedLengthASN,
		&pCallObject->CallIdentifier);

	if (result != CS_OK	|| CodedLengthASN == 0 || CodedPtrASN == NULL)
	{
		ISRERROR(ghISRInst,	"Q931AlertingEncodeASN() failed, nothing to	send.",	0L);
		if (CodedPtrASN	!= NULL)
		{
			Q931FreeEncodedBuffer(&pCallObject->World, CodedPtrASN);
		}
		return (result != CS_OK) ? result :	CS_INTERNAL_ERROR;
	}

	UserUserData.length	= (WORD)CodedLengthASN;
	UserUserData.ptr = CodedPtrASN;

	result = Q931AlertingEncodePDU(wCRV, &UserUserData,	&CodedPtrPDU,
		&CodedLengthPDU);

	if (CodedPtrASN	!= NULL)
	{
		Q931FreeEncodedBuffer(&pCallObject->World, CodedPtrASN);
	}

	if ((result	!= CS_OK) || (CodedLengthPDU ==	0) ||
			(CodedPtrPDU ==	NULL))
	{
		ISRERROR(ghISRInst,	"Q931AlertingEncodePDU() failed, nothing to	send.",	0L);
		if (CodedPtrPDU	!= NULL)
		{
			MemFree(CodedPtrPDU);
		}
		if (result != CS_OK)
		{
			return result;
		}
		return CS_INTERNAL_ERROR;
	}
	else
	{
		result = Q931SendMessage(pCallObject, CodedPtrPDU, CodedLengthPDU, TRUE);
		if(CallObjectValidate(hQ931Call) !=	CS_OK)
			return(CS_INTERNAL_ERROR);

	}
	return result;
}


//====================================================================================
//====================================================================================
CS_STATUS
Q931OnCallSetup(
	P_CALL_OBJECT pCallObject,
	Q931MESSAGE	*pMessage,
	Q931_SETUP_ASN *pSetupASN)
{
	DWORD		result;
	HQ931CALL	hQ931Call;
	HRESULT		Status;

	// if the callstate	is anything	other than null, ignore...
//	  if (pCallObject->bCallState != CALLSTATE_NULL)
//	  {
//		  return CS_OK;
//	  }

	hQ931Call =	pCallObject->hQ931Call;

	if (pMessage->CallReference	& 0x8000)
	{
		// the message came	from the callee, so	this should	be ignored???
	}
	pMessage->CallReference	&= ~(0x8000);	 //	strip off the high bit.
	pCallObject->wCRV =	pMessage->CallReference;

	pCallObject->wGoal = pSetupASN->wGoal;
	pCallObject->bCallerIsMC = pSetupASN->bCallerIsMC;
	pCallObject->wCallType = pSetupASN->wCallType;
	pCallObject->ConferenceID =	pSetupASN->ConferenceID;
	pCallObject->CallIdentifier	= pSetupASN->CallIdentifier;

	pCallObject->bCallState	= CALLSTATE_PRESENT;

	{
		CSS_CALL_INCOMING EventData;
		WCHAR szUnicodeDisplay[CC_MAX_DISPLAY_LENGTH + 1];
		WCHAR szUnicodeCalledPartyNumber[CC_MAX_PARTY_NUMBER_LEN + 1];

		EventData.wGoal	= pCallObject->wGoal;
		EventData.wCallType	= pCallObject->wCallType;
		EventData.bCallerIsMC =	pCallObject->bCallerIsMC;
		EventData.ConferenceID = pCallObject->ConferenceID;

		EventData.pSourceAddr =	NULL;
		if (pSetupASN->SourceAddrPresent)
		{
			EventData.pSourceAddr =	&(pSetupASN->SourceAddr);
		}

		EventData.pCallerAddr =	NULL;
		if (pSetupASN->CallerAddrPresent)
		{
			EventData.pCallerAddr =	&(pSetupASN->CallerAddr);
		}

		EventData.pCalleeDestAddr =	NULL;
		if (pSetupASN->CalleeDestAddrPresent)
		{
			EventData.pCalleeDestAddr =	&(pSetupASN->CalleeDestAddr);
		}

		EventData.pLocalAddr = NULL;
		if (pSetupASN->CalleeAddrPresent)
		{
			EventData.pLocalAddr = &(pSetupASN->CalleeAddr);
		}

		if (!(pSetupASN->NonStandardDataPresent) ||
				(pSetupASN->NonStandardData.sData.wOctetStringLength ==	0) ||
				(pSetupASN->NonStandardData.sData.pOctetString == NULL))
		{
			EventData.pNonStandardData = NULL;
		}
		else
		{
			EventData.pNonStandardData = &(pSetupASN->NonStandardData);
		}

		EventData.pCallerAliasList = pSetupASN->pCallerAliasList;
		EventData.pCalleeAliasList = pSetupASN->pCalleeAliasList;
		EventData.pExtraAliasList =	pSetupASN->pExtraAliasList;
		EventData.pExtensionAliasItem =	pSetupASN->pExtensionAliasItem;
		EventData.CallIdentifier = pSetupASN->CallIdentifier;

		EventData.pszDisplay = NULL;
		if (pMessage->Display.Present && pMessage->Display.Contents)
		{
			MultiByteToWideChar(CP_ACP,	0, (const char *)pMessage->Display.Contents, -1,
				szUnicodeDisplay, sizeof(szUnicodeDisplay) / sizeof(szUnicodeDisplay[0]));
			EventData.pszDisplay = szUnicodeDisplay;
		}

		EventData.pszCalledPartyNumber = NULL;
		if (pMessage->CalledPartyNumber.Present	&& pMessage->CalledPartyNumber.PartyNumberLength)
		{
			MultiByteToWideChar(CP_ACP,	0, (const char *)pMessage->CalledPartyNumber.PartyNumbers, -1,
				szUnicodeCalledPartyNumber,	sizeof(szUnicodeCalledPartyNumber) / sizeof(szUnicodeCalledPartyNumber[0]));
			EventData.pszCalledPartyNumber = szUnicodeCalledPartyNumber;
		}

		EventData.pSourceEndpointType =	&(pSetupASN->EndpointType);

		EventData.wCallReference = pMessage->CallReference;

		result = pCallObject->Callback((BYTE)Q931_CALL_INCOMING,
			pCallObject->hQ931Call,	pCallObject->dwListenToken,
			pCallObject->dwUserToken, &EventData);
	}

	Status = CallObjectValidate(hQ931Call);
	if (Status != CS_OK)
		return Status;

	if (result == 0)
	{
		WORD wCRV =	(WORD)(pMessage->CallReference | 0x8000);

		Status = Q931RingingInternal(pCallObject, wCRV);
		if (Status != CS_OK)
		{
			return Status;
		}
		pCallObject->bCallState	= CALLSTATE_RECEIVED;
	}
	return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931Ringing(
	HQ931CALL hQ931Call,
	WORD *pwCRV)
{
	P_CALL_OBJECT pCallObject =	NULL;
	CS_STATUS Status;
	WORD wCRV;

	if (bQ931Initialized ==	FALSE)
	{
		ASSERT(FALSE);
		return CS_NOT_INITIALIZED;
	}

	ISRTRACE(ghISRInst,	"Entering Q931Ringing()...", 0L);

	// need	parameter checking...
	if ((CallObjectLock(hQ931Call, &pCallObject) !=	CS_OK) || (pCallObject == NULL))
	{
		ISRERROR(ghISRInst,	"CallObjectLock() returned error (object not found).", 0L);
		return CS_BAD_PARAM;
	}

	if (pwCRV != NULL)
	{
		wCRV = *pwCRV;
	}
	else
	{
		wCRV = pCallObject->wCRV;
	}

	Status = Q931RingingInternal(pCallObject, wCRV);
	if (Status != CS_OK)
	{
		return Status;
	}

	pCallObject->bCallState	= CALLSTATE_RECEIVED;
	Status = CallObjectUnlock(pCallObject);

	return Status;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931OnCallProceeding(
	P_CALL_OBJECT pCallObject,
	Q931MESSAGE	*pMessage,
	Q931_CALL_PROCEEDING_ASN *pProceedingASN)
{
	pCallObject->bCallState	= CALLSTATE_OUTGOING;

	Q931StopTimer(pCallObject, Q931_TIMER_303);

	return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931OnCallAlerting(
	P_CALL_OBJECT pCallObject,
	Q931MESSAGE	*pMessage,
	Q931_ALERTING_ASN *pAlertingASN)
{
	DWORD result;

	pCallObject->bCallState	= CALLSTATE_DELIVERED;

	if (pAlertingASN !=	NULL)
	{
		// we could	pass h245addr, userinfo, and conferenceid
		// if desired later...
		// (this would be passed in	the	pAlertingASN field)
	}

	Q931StopTimer(pCallObject, Q931_TIMER_303);
	Q931StartTimer(pCallObject,	Q931_TIMER_301);

	result = pCallObject->Callback((BYTE)Q931_CALL_RINGING,
		pCallObject->hQ931Call,	pCallObject->dwListenToken,
		pCallObject->dwUserToken, NULL);

	return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931OnCallConnect(
	P_CALL_OBJECT pCallObject,
	Q931MESSAGE	*pMessage,
	Q931_CONNECT_ASN *pConnectASN)
{
	DWORD result;

	if ((pMessage->CallReference & 0x8000) == 0)
	{
		// the message came	from the caller, so	this should	be ignored???
	}
	pMessage->CallReference	&= ~(0x8000);	 //	strip off the high bit.

	pCallObject->ConferenceID =	pConnectASN->ConferenceID;

	pCallObject->bCallState	= CALLSTATE_ACTIVE;

	{
		CSS_CALL_ACCEPTED EventData;
		WCHAR szUnicodeDisplay[CC_MAX_DISPLAY_LENGTH + 1];

		// populate	the	event data struct.

		EventData.ConferenceID = pCallObject->ConferenceID;

		if (pCallObject->PeerCallAddrPresent)
		{
			EventData.pCalleeAddr =	&(pCallObject->PeerCallAddr);
		}
		else
		{
			EventData.pCalleeAddr =	NULL;
		}
		EventData.pLocalAddr = &(pCallObject->LocalAddr);

		EventData.pH245Addr	= NULL;
		if (pConnectASN->h245AddrPresent)
		{
			EventData.pH245Addr	= &(pConnectASN->h245Addr);
		}

		if (!(pConnectASN->NonStandardDataPresent) ||
				(pConnectASN->NonStandardData.sData.wOctetStringLength == 0) ||
				(pConnectASN->NonStandardData.sData.pOctetString ==	NULL))
		{
			EventData.pNonStandardData = NULL;
		}
		else
		{
			EventData.pNonStandardData = &(pConnectASN->NonStandardData);
		}

		EventData.pszDisplay = NULL;
		if (pMessage->Display.Present && pMessage->Display.Contents)
		{
			MultiByteToWideChar(CP_ACP,	0, (const char *)pMessage->Display.Contents, -1,
				szUnicodeDisplay, sizeof(szUnicodeDisplay) / sizeof(szUnicodeDisplay[0]));
			EventData.pszDisplay = szUnicodeDisplay;
		}

		EventData.pDestinationEndpointType = &(pConnectASN->EndpointType);

		EventData.wCallReference = pMessage->CallReference;

		Q931StopTimer(pCallObject, Q931_TIMER_303);
		Q931StopTimer(pCallObject, Q931_TIMER_301);

		result = pCallObject->Callback((BYTE)Q931_CALL_ACCEPTED,
			pCallObject->hQ931Call,	pCallObject->dwListenToken,
			pCallObject->dwUserToken, &EventData);
	}

	return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931OnCallReleaseComplete(
	P_CALL_OBJECT pCallObject,
	Q931MESSAGE	*pMessage,
	Q931_RELEASE_COMPLETE_ASN *pReleaseCompleteASN)
{
	DWORD result;
	BYTE bCause	= 0;

	if (pMessage &&	pMessage->Cause.Present	&&
			(pMessage->Cause.Length	>= 3))
	{
		bCause = (BYTE)(pMessage->Cause.Contents[2]	& (~CAUSE_EXT_BIT));
	}

	Q931StopTimer(pCallObject, Q931_TIMER_303);
	Q931StopTimer(pCallObject, Q931_TIMER_301);

	// if this is the callee, or the call has been connected already,
	// then	this message should	be treated as hangup (not reject).
	if (!(pCallObject->fIsCaller) ||
			(pCallObject->bCallState ==	CALLSTATE_ACTIVE) ||
			(bCause	== CAUSE_VALUE_NORMAL_CLEAR))
	{
		CSS_CALL_REMOTE_HANGUP EventData;

		EventData.bReason =	CC_REJECT_NORMAL_CALL_CLEARING;
		pCallObject->bCallState	= CALLSTATE_NULL;

		result = pCallObject->Callback((BYTE)Q931_CALL_REMOTE_HANGUP,
			pCallObject->hQ931Call,	pCallObject->dwListenToken,
			pCallObject->dwUserToken, &EventData);
	}
	else
	{
		CSS_CALL_REJECTED EventData;

		pCallObject->bCallState	= CALLSTATE_NULL;

		// populate	the	event data struct.
		switch (bCause)
		{
			case CAUSE_VALUE_NORMAL_CLEAR:
				EventData.bRejectReason	= CC_REJECT_NORMAL_CALL_CLEARING;
				break;
			case CAUSE_VALUE_USER_BUSY:
				EventData.bRejectReason	= CC_REJECT_USER_BUSY;
				break;
			case CAUSE_VALUE_SECURITY_DENIED:
				EventData.bRejectReason	= CC_REJECT_SECURITY_DENIED;
				break;
			case CAUSE_VALUE_NO_ANSWER:
				EventData.bRejectReason	= CC_REJECT_NO_ANSWER;
				break;
			case CAUSE_VALUE_NOT_IMPLEMENTED:
				EventData.bRejectReason	= CC_REJECT_NOT_IMPLEMENTED;
				break;
			case CAUSE_VALUE_INVALID_CRV:
				EventData.bRejectReason	= CC_REJECT_INVALID_IE_CONTENTS;
				break;
			case CAUSE_VALUE_IE_MISSING:
				EventData.bRejectReason	= CC_REJECT_MANDATORY_IE_MISSING;
				break;
			case CAUSE_VALUE_IE_CONTENTS:
				EventData.bRejectReason	= CC_REJECT_INVALID_IE_CONTENTS;
				break;
			case CAUSE_VALUE_TIMER_EXPIRED:
				EventData.bRejectReason	= CC_REJECT_TIMER_EXPIRED;
				break;
			default:
				EventData.bRejectReason	= pReleaseCompleteASN->bReason;
				break;
		}

		EventData.ConferenceID = pCallObject->ConferenceID;

		EventData.pAlternateAddr = NULL;

		if (!(pReleaseCompleteASN->NonStandardDataPresent) ||
				(pReleaseCompleteASN->NonStandardData.sData.wOctetStringLength == 0) ||
				(pReleaseCompleteASN->NonStandardData.sData.pOctetString ==	NULL))
		{
			EventData.pNonStandardData = NULL;
		}
		else
		{
			EventData.pNonStandardData = &(pReleaseCompleteASN->NonStandardData);
		}

		result = pCallObject->Callback((BYTE)Q931_CALL_REJECTED,
			pCallObject->hQ931Call,	pCallObject->dwListenToken,
			pCallObject->dwUserToken, &EventData);
	}

	return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931OnCallFacility(
	P_CALL_OBJECT pCallObject,
	Q931MESSAGE	*pMessage,
	Q931_FACILITY_ASN *pFacilityASN)
{
	DWORD result;

	// if this is the callee, or the call has been connected already,
	// then	this message should	be treated as hangup (not reject).
	if (!(pCallObject->fIsCaller) ||
			(pCallObject->bCallState ==	CALLSTATE_ACTIVE))
	{
		CSS_CALL_REMOTE_HANGUP EventData;

		EventData.bReason =	pFacilityASN->bReason;
		pCallObject->bCallState	= CALLSTATE_NULL;

		result = pCallObject->Callback((BYTE)Q931_CALL_REMOTE_HANGUP,
			pCallObject->hQ931Call,	pCallObject->dwListenToken,
			pCallObject->dwUserToken, &EventData);
	}
	else
	{
		CSS_CALL_REJECTED EventData;

		pCallObject->bCallState	= CALLSTATE_NULL;

		// populate	the	event data struct.
		EventData.bRejectReason	= pFacilityASN->bReason;

		EventData.ConferenceID = pFacilityASN->ConferenceIDPresent ?
			pFacilityASN->ConferenceID : pCallObject->ConferenceID;

		EventData.pAlternateAddr = &(pFacilityASN->AlternativeAddr);

		if (!(pFacilityASN->NonStandardDataPresent)	||
				(pFacilityASN->NonStandardData.sData.wOctetStringLength	== 0) ||
				(pFacilityASN->NonStandardData.sData.pOctetString == NULL))
		{
			EventData.pNonStandardData = NULL;
		}
		else
		{
			EventData.pNonStandardData = &(pFacilityASN->NonStandardData);
		}

		result = pCallObject->Callback((BYTE)Q931_CALL_REJECTED,
			pCallObject->hQ931Call,	pCallObject->dwListenToken,
			pCallObject->dwUserToken, &EventData);
	}

	return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931SendReleaseCompleteMessage(
	P_CALL_OBJECT pCallObject,
	BYTE bRejectReason,
	PCC_CONFERENCEID pConferenceID,
	PCC_ADDR pAlternateAddr,
	PCC_NONSTANDARDDATA	pNonStandardData)
{
	CS_STATUS result = CS_OK;
	HQ931CALL hQ931Call	= pCallObject->hQ931Call;

	// since this call is going	away, mark the call	object for deletion	so any other
	// threads attempting to use this object will fail to get a	lock on	it.
	CallObjectMarkForDelete(hQ931Call);

	if((bRejectReason == CC_REJECT_ROUTE_TO_GATEKEEPER)	||
			(bRejectReason == CC_REJECT_CALL_FORWARDED)	||
			(bRejectReason == CC_REJECT_ROUTE_TO_MC))
	{
		// send	the	FACILITY message to	the	peer to	reject the call.
		DWORD CodedLengthASN;
		BYTE *CodedPtrASN;
		HRESULT	ResultASN =	CS_OK;
		CC_ADDR	AltAddr;

		MakeBinaryADDR(pAlternateAddr, &AltAddr);

		ResultASN =	Q931FacilityEncodeASN(pNonStandardData,
			(pAlternateAddr	? &AltAddr : NULL),
			bRejectReason, pConferenceID, NULL,	&pCallObject->World,
			&CodedPtrASN, &CodedLengthASN, &pCallObject->CallIdentifier);
		if ((ResultASN != CS_OK) ||	(CodedLengthASN	== 0) ||
				(CodedPtrASN ==	NULL))
		{
			ISRERROR(ghISRInst,	"Q931FacilityEncodeASN() failed, nothing to	send.",	0L);
			if (CodedPtrASN	!= NULL)
			{
				Q931FreeEncodedBuffer(&pCallObject->World, CodedPtrASN);
			}
			result = CS_INTERNAL_ERROR;
		}
		else
		{
			DWORD CodedLengthPDU;
			BYTE *CodedPtrPDU;
			BINARY_STRING UserUserData;
			HRESULT	ResultEncode = CS_OK;
			WORD wCRV;
			if (pCallObject->fIsCaller)
			{
				wCRV = (WORD)(pCallObject->wCRV	& 0x7FFF);
			}
			else
			{
				wCRV = (WORD)(pCallObject->wCRV	| 0x8000);
			}

			UserUserData.length	= (WORD)CodedLengthASN;
			UserUserData.ptr = CodedPtrASN;

			ResultEncode = Q931FacilityEncodePDU(wCRV,
				&UserUserData, &CodedPtrPDU, &CodedLengthPDU);
			if (CodedPtrASN	!= NULL)
			{
				Q931FreeEncodedBuffer(&pCallObject->World, CodedPtrASN);
			}
			if ((ResultEncode != CS_OK)	|| (CodedLengthPDU == 0) ||
					(CodedPtrPDU ==	NULL))
			{
				ISRERROR(ghISRInst,	"Q931FacilityEncodePDU() failed, nothing to	send.",	0L);
				if (CodedPtrPDU	!= NULL)
				{
					MemFree(CodedPtrPDU);
				}
				result = CS_INTERNAL_ERROR;
			}
			else
			{
				result = Q931SendMessage(pCallObject, CodedPtrPDU, CodedLengthPDU, FALSE);
			}
		}
	}
	else
	{
		// send	the	RELEASE	COMPLETE message to	the	peer to	reject call.
		DWORD CodedLengthASN;
		BYTE *CodedPtrASN;
		HRESULT	ResultASN =	CS_OK;
		BYTE bReasonUU = bRejectReason;
		BYTE *pbReasonUU = &bReasonUU;

		switch (bReasonUU)
		{
			case CC_REJECT_NO_BANDWIDTH:			//noBandwidth_chosen
			case CC_REJECT_GATEKEEPER_RESOURCES:	// gatekeeperResources_chosen
			case CC_REJECT_UNREACHABLE_DESTINATION:	// unreachableDestination_chosen
			case CC_REJECT_DESTINATION_REJECTION:	// destinationRejection_chosen
			case CC_REJECT_INVALID_REVISION:		// ReleaseCompleteReason_invalidRevision_chosen
			case CC_REJECT_NO_PERMISSION:			// noPermission_chosen
			case CC_REJECT_UNREACHABLE_GATEKEEPER:	// unreachableGatekeeper_chosen
			case CC_REJECT_GATEWAY_RESOURCES:		// gatewayResources_chosen
			case CC_REJECT_BAD_FORMAT_ADDRESS:		// badFormatAddress_chosen
			case CC_REJECT_ADAPTIVE_BUSY:			// adaptiveBusy_chosen
			case CC_REJECT_IN_CONF:					// inConf_chosen
			case CC_REJECT_UNDEFINED_REASON:		// ReleaseCompleteReason_undefinedReason_chosen
			case CC_REJECT_INTERNAL_ERROR:			// will	be mapped to ReleaseCompleteReason_undefinedReason_chosen
			case CC_REJECT_NORMAL_CALL_CLEARING:	// will	be mapped to ReleaseCompleteReason_undefinedReason_chosen
			case CC_REJECT_USER_BUSY:				// will	be mapped to inConf_chosen
			case CC_REJECT_CALL_DEFLECTION:			// facilityCallDeflection_chosen
			case CC_REJECT_SECURITY_DENIED:			// securityDenied_chosen

			   break;
			default:
				pbReasonUU = NULL;
				break;
		}

		ResultASN =	Q931ReleaseCompleteEncodeASN(pNonStandardData,
			pConferenceID, pbReasonUU, &pCallObject->World,
			&CodedPtrASN, &CodedLengthASN, &pCallObject->CallIdentifier);
		if ((ResultASN != CS_OK) ||	(CodedLengthASN	== 0) ||
				(CodedPtrASN ==	NULL))
		{
			ISRERROR(ghISRInst,	"Q931ReleaseCompleteEncodeASN()	failed,	nothing	to send.", 0L);
			if (CodedPtrASN	!= NULL)
			{
				Q931FreeEncodedBuffer(&pCallObject->World, CodedPtrASN);
			}
			result = CS_INTERNAL_ERROR;
		}
		else
		{
			DWORD CodedLengthPDU;
			BYTE *CodedPtrPDU;
			BINARY_STRING UserUserData;
			HRESULT	ResultEncode = CS_OK;
			BYTE bCause	= 0;
			BYTE *pbCause =	&bCause;
			WORD wCRV;

			if (pCallObject->fIsCaller)
			{
				wCRV = (WORD)(pCallObject->wCRV	& 0x7FFF);
			}
			else
			{
				wCRV = (WORD)(pCallObject->wCRV	| 0x8000);
			}

			UserUserData.length	= (WORD)CodedLengthASN;
			UserUserData.ptr = CodedPtrASN;

			switch (bRejectReason)
			{
				case CC_REJECT_NORMAL_CALL_CLEARING:
					bCause = CAUSE_VALUE_NORMAL_CLEAR;
					break;
				case CC_REJECT_USER_BUSY:
					bCause = CAUSE_VALUE_USER_BUSY;
					break;
				case CC_REJECT_SECURITY_DENIED:
					bCause = CAUSE_VALUE_SECURITY_DENIED;
					break;
				case CC_REJECT_NO_ANSWER:
					bCause = CAUSE_VALUE_NO_ANSWER;
					break;
				case CC_REJECT_NOT_IMPLEMENTED:
					bCause = CAUSE_VALUE_NOT_IMPLEMENTED;
					break;
				case CC_REJECT_MANDATORY_IE_MISSING:
					bCause = CAUSE_VALUE_IE_MISSING;
					break;
				case CC_REJECT_INVALID_IE_CONTENTS:
					bCause = CAUSE_VALUE_IE_CONTENTS;
					break;
				case CC_REJECT_TIMER_EXPIRED:
					bCause = CAUSE_VALUE_TIMER_EXPIRED;
					break;
				default:
					pbCause	= NULL;
					break;
			}

			ResultEncode = Q931ReleaseCompleteEncodePDU(wCRV,
				pbCause, &UserUserData,
				&CodedPtrPDU, &CodedLengthPDU);
			if (CodedPtrASN	!= NULL)
			{
				Q931FreeEncodedBuffer(&pCallObject->World, CodedPtrASN);
			}
			if ((ResultEncode != CS_OK)	|| (CodedLengthPDU == 0) ||
					(CodedPtrPDU ==	NULL))
			{
				ISRERROR(ghISRInst,	"Q931ReleaseCompleteEncodePDU()	failed,	nothing	to send.", 0L);
				if (CodedPtrPDU	!= NULL)
				{
					MemFree(CodedPtrPDU);
				}
				result = CS_INTERNAL_ERROR;
			}
			else
			{
				result = Q931SendMessage(pCallObject, CodedPtrPDU, CodedLengthPDU, FALSE);
			}
		}
	}

	pCallObject->bCallState	= CALLSTATE_NULL;

	if (result != CS_OK)
	{
		return result;
	}
	return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931SendStatusMessage(
	P_CALL_OBJECT pCallObject,
	Q931MESSAGE	*pMessage,
	BYTE bCause)
{
	CS_STATUS result = CS_OK;

	DWORD CodedLengthPDU;
	BYTE *CodedPtrPDU;
	HRESULT	EncodePDU =	CS_OK;
	int	nError = 0;
	HQ931CALL hQ931Call	= pCallObject->hQ931Call;
	WORD wCRV;
	if (pCallObject->fIsCaller)
	{
		wCRV = (WORD)(pCallObject->wCRV	& 0x7FFF);
	}
	else
	{
		wCRV = (WORD)(pCallObject->wCRV	| 0x8000);
	}

	EncodePDU =	Q931StatusEncodePDU(wCRV, NULL,	bCause,
		pCallObject->bCallState, &CodedPtrPDU, &CodedLengthPDU);
	if ((EncodePDU != CS_OK) ||	(CodedLengthPDU	== 0) ||
			(CodedPtrPDU ==	NULL))
	{
		ISRERROR(ghISRInst,	"Q931StatusEncodePDU() failed, nothing to send.", 0L);
		if (CodedPtrPDU	!= NULL)
		{
			MemFree(CodedPtrPDU);
		}
		result = CS_INTERNAL_ERROR;
	}
	else
	{
		result = Q931SendMessage(pCallObject, CodedPtrPDU, CodedLengthPDU, TRUE);
		if(CallObjectValidate(hQ931Call) !=	CS_OK)
			return(CS_INTERNAL_ERROR);
	}
	return(result);
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931SendProceedingMessage(
	HQ931CALL hQ931Call,
	WORD wCallReference,
	PCC_ENDPOINTTYPE pDestinationEndpointType,
	PCC_NONSTANDARDDATA	pNonStandardData)
{
	CS_STATUS result = CS_OK;

	DWORD CodedLengthASN;
	BYTE *CodedPtrASN;
	HRESULT	ResultASN =	CS_OK;
	DWORD dwPhysicalId = INVALID_PHYS_ID;
	P_CALL_OBJECT pCallObject =	NULL;


	if ((CallObjectLock(hQ931Call, &pCallObject) !=	CS_OK) || (pCallObject == NULL))
	{
		ISRERROR(ghISRInst,	"CallObjectLock() returned error", 0L);
		return CS_SUBSYSTEM_FAILURE;
	}
	dwPhysicalId = pCallObject->dwPhysicalId;

	// first build the ASN portion of the message (user	to user	part)
	ResultASN =	Q931ProceedingEncodeASN(
		pNonStandardData,
		NULL,						   // No H245 address.
		pDestinationEndpointType,	   // EndpointType information.
		&pCallObject->World,
		&CodedPtrASN,
		&CodedLengthASN,
		&pCallObject->CallIdentifier);

	if ((ResultASN != CS_OK) ||	(CodedLengthASN	== 0) ||
			(CodedPtrASN ==	NULL))
	{
		ISRERROR(ghISRInst,	"Q931ProceedingEncodeASN() failed, nothing to send.", 0L);

		if (CodedPtrASN	!= NULL)
		{
			Q931FreeEncodedBuffer(&pCallObject->World, CodedPtrASN);
		}
		result = CS_INTERNAL_ERROR;
	}
	else
	{
		// now build the rest of the message
		DWORD CodedLengthPDU;
		BYTE *CodedPtrPDU;
		BINARY_STRING UserUserData;
		HRESULT	ResultEncode = CS_OK;
		WORD wCRV =	(WORD)(wCallReference |	0x8000);

		UserUserData.length	= (WORD)CodedLengthASN;
		UserUserData.ptr = CodedPtrASN;

		ResultEncode = Q931ProceedingEncodePDU(wCRV,
			&UserUserData, &CodedPtrPDU, &CodedLengthPDU);
		if (CodedPtrASN	!= NULL)
		{
			Q931FreeEncodedBuffer(&pCallObject->World, CodedPtrASN);
		}
		if ((ResultEncode != CS_OK)	|| (CodedLengthPDU == 0) ||
				(CodedPtrPDU ==	NULL))
		{
			ISRERROR(ghISRInst,	"Q931ProceedingEncodePDU() failed, nothing to send.", 0L);
			if (CodedPtrPDU	!= NULL)
			{
				MemFree(CodedPtrPDU);
			}
			result = CS_INTERNAL_ERROR;
		}
		else
		{
			result = Q931SendMessage(pCallObject, CodedPtrPDU, CodedLengthPDU, TRUE);

			if (CallObjectValidate(hQ931Call) != CS_OK)
			{
				CallEntryUnlock(hQ931Call);
				return(CS_INTERNAL_ERROR);
			}
		}
	}
	CallObjectUnlock(pCallObject);
	return(result);
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931SendPDU(HQ931CALL hQ931Call, BYTE* CodedPtrPDU,	DWORD CodedLengthPDU)
{
	CS_STATUS result = CS_OK;
	HRESULT	TempResult;
	P_CALL_OBJECT pCallObject =	NULL;

	if ((CallObjectLock(hQ931Call, &pCallObject) !=	CS_OK) ||
			(pCallObject ==	NULL))
	{
		ISRERROR(ghISRInst,	"CallObjectLock() returned error", 0L);
		return CS_SUBSYSTEM_FAILURE;
	}


	TempResult = Q931SendMessage(pCallObject, CodedPtrPDU, CodedLengthPDU, TRUE);

	if (CallObjectValidate(hQ931Call) != CS_OK)
	{
		CallEntryUnlock(hQ931Call);
		return(CS_INTERNAL_ERROR);
	}

	if(FAILED(TempResult))
	{
		CSS_CALL_FAILED	EventData;
		EventData.error	= TempResult;
		if ((pCallObject->bCallState ==	CALLSTATE_ACTIVE) &&
				(pCallObject->bResolved))
		{
			pCallObject->Callback(Q931_CALL_CONNECTION_CLOSED,
				pCallObject->hQ931Call,	pCallObject->dwListenToken,
				pCallObject->dwUserToken, NULL);
		}
		else
		{
			pCallObject->Callback(Q931_CALL_FAILED,
				pCallObject->hQ931Call,	pCallObject->dwListenToken,
				pCallObject->dwUserToken, &EventData);
		}

		if (CallObjectValidate(hQ931Call) == CS_OK)
		{
		   DWORD dwId =	pCallObject->dwPhysicalId;
		   if ((pCallObject->bCallState	!= CALLSTATE_ACTIVE) ||
				   (!pCallObject->bResolved))
		   {
			   CallObjectDestroy(pCallObject);
			   pCallObject = NULL;
		   }
		   linkLayerShutdown(dwId);
		   if (pCallObject)
		   {
			   pCallObject->bConnected = FALSE;
		   }
		}
		else
		{
			CallEntryUnlock(hQ931Call);
		}
		return TempResult;
	}
	CallObjectUnlock(pCallObject);
	return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931OnCallStatusEnquiry(
	P_CALL_OBJECT pCallObject,
	Q931MESSAGE	*pMessage)
{
	CS_STATUS SendStatus;

	SendStatus = Q931SendStatusMessage(pCallObject,	pMessage,
		CAUSE_VALUE_ENQUIRY_RESPONSE);

	return SendStatus;
}

//====================================================================================
//====================================================================================
void
Q931SendComplete(DWORD_PTR instance, HRESULT msg, PBYTE	buf, DWORD length)
{
	HQ931CALL hQ931Call	= (HQ931CALL)instance;
	P_CALL_OBJECT pCallObject =	NULL;

	ISRTRACE(ghISRInst,	"Entering Q931SendComplete()...", 0L);

	if (buf	!= NULL)
	{
		MemFree(buf);
	}

	if (FAILED(msg))
	{
		// shut	down link layer; report	failure	to client
		CSS_CALL_FAILED	EventData;

		ISRERROR(ghISRInst,	"error in datalinkSendRequest()", 0L);

		if ((CallObjectLock(hQ931Call, &pCallObject) !=	CS_OK) || (pCallObject == NULL))
		{
			ISRERROR(ghISRInst,	"CallObjectLock() returned error", 0L);
			return;
		}

		EventData.error	= msg;
		if ((pCallObject->bCallState ==	CALLSTATE_ACTIVE) &&
				(pCallObject->bResolved))
		{
			pCallObject->Callback(Q931_CALL_CONNECTION_CLOSED,
				pCallObject->hQ931Call,	pCallObject->dwListenToken,
				pCallObject->dwUserToken, NULL);
		}
		else
		{
			pCallObject->Callback(Q931_CALL_FAILED,
				pCallObject->hQ931Call,	pCallObject->dwListenToken,
				pCallObject->dwUserToken, &EventData);
		}

		if (CallObjectValidate(hQ931Call) == CS_OK)
		{
			 DWORD dwId	= pCallObject->dwPhysicalId;
			 if	((pCallObject->bCallState != CALLSTATE_ACTIVE) ||
					 (!pCallObject->bResolved))
			 {
				 CallObjectDestroy(pCallObject);
				 pCallObject = NULL;
			 }
			 linkLayerShutdown(dwId);
			 if	(pCallObject)
			 {
				 pCallObject->bConnected = FALSE;
			 }
		}
		else
		{
			CallEntryUnlock(hQ931Call);
		}
		return;
	}
	return;
}

//====================================================================================
//====================================================================================
static DWORD
PostReceiveBuffer(DWORD	dwPhysicalId, BYTE *buf)
{
	HRESULT		hr			= S_OK;
	BOOL		bAllocated	= FALSE;
	
	if (buf	== NULL)
	{
		buf	= MemAlloc(RECEIVE_BUFFER_SIZE);
		bAllocated = TRUE;
	}
	
	hr = datalinkReceiveRequest(dwPhysicalId, buf, RECEIVE_BUFFER_SIZE);
	if (FAILED(hr) && bAllocated)
	{
		MemFree(buf);
	}

	return hr;
}

//====================================================================================
//====================================================================================
void
OnReceiveCallback(DWORD_PTR	instance, HRESULT message, Q931MESSAGE *pMessage, BYTE *buf, DWORD nbytes)
{
	HQ931CALL hQ931Call	= (HQ931CALL)instance;
	P_CALL_OBJECT pCallObject =	NULL;
	DWORD dwPhysicalId;

	ISRTRACE(ghISRInst,	"Entering ReceiveCallback()...", 0L);

	if ((CallObjectLock(hQ931Call, &pCallObject) !=	CS_OK) || (pCallObject == NULL))
	{
		if (buf)
		{
			MemFree(buf);
		}
		ISRTRACE(ghISRInst,	"Call Object no	longer available:",	(DWORD)hQ931Call);
		return;
	}

	if (message	== LINK_RECV_DATA)
	{
		HRESULT	Result = CS_OK;

		if ((buf ==	NULL) || (nbytes ==	0))
		{
			ISRERROR(ghISRInst,	"Empty buffer received as data.", 0L);
			CallObjectUnlock(pCallObject);
			return;
		}

		// This	block is the Q931 call re-connect implementation:
		// if the object related to	the	incoming message is	not	yet	resolved...
		if (pCallObject->bResolved == FALSE)
		{
			// try to resolve the object.
			HQ931CALL hFoundCallObject;
			P_CALL_OBJECT pFoundCallObject = NULL;

			// If found	another	object with	matching CRV/Addr...
			if (CallObjectFind(&hFoundCallObject, pCallObject->wCRV,
					&(pCallObject->PeerConnectAddr)) &&
					((CallObjectLock(hFoundCallObject, &pFoundCallObject) == CS_OK)	&&
					(pFoundCallObject != NULL)))
			{
				// friendly	channel	close of the pFoundCallObject.
				Q931SendReleaseCompleteMessage(pFoundCallObject,
					CC_REJECT_UNDEFINED_REASON,	&(pFoundCallObject->ConferenceID), NULL, NULL);

				// unlock the call object before calling shutdown
				CallObjectUnlock(pFoundCallObject);

				linkLayerShutdown(pFoundCallObject->dwPhysicalId);

				if((CallObjectLock(hFoundCallObject, &pFoundCallObject)	!= CS_OK) ||
				  (pFoundCallObject	== NULL))
				  return;

				// assign the new dwPhysicalId to found	object.
				pFoundCallObject->dwPhysicalId = pCallObject->dwPhysicalId;

				// new object should be	destroyed.
				CallObjectDestroy(pCallObject);
				pCallObject	= pFoundCallObject;
			}
			else
			{
				// The call	is a newly established call, so	resolve	it now.
				pCallObject->bResolved = TRUE;
			}
		}

		Result = Q931ParseMessage((BYTE	*)buf, nbytes, pMessage);

#if	(defined(_DEBUG) ||	defined(PCS_COMPLIANCE))
		InteropOutput(Q931Logger, buf, nbytes, Q931LOG_RECEIVED_PDU);
#endif

		if (Result != CS_OK)
		{
			Result = Q931SendStatusMessage(pCallObject,	pMessage,
				CAUSE_VALUE_INVALID_MSG);

			ISRERROR(ghISRInst,	"Q931ParseMessage(): failed.", 0L);

			if(CallObjectValidate(hQ931Call) !=	CS_OK)
			{
				if (buf)
				{
					MemFree(buf);
				}
				
				CallEntryUnlock(hQ931Call);
				return;
			}

			dwPhysicalId = pCallObject->dwPhysicalId;
			CallObjectUnlock(pCallObject);
			PostReceiveBuffer(dwPhysicalId,	buf);
			return;
		}

		if (pMessage->Shift.Present)
		{
			ISRERROR(ghISRInst,	"Shift present in message:	dropped.", 0L);
			dwPhysicalId = pCallObject->dwPhysicalId;
			CallObjectUnlock(pCallObject);
			PostReceiveBuffer(dwPhysicalId,	buf);
			return;
		}

		// If a	hooking	procedure has been installed,
		// give	it first shot at acting	on the received	PDU.
		// If it returns TRUE, then	processing is finished.
		if (gReceivePDUHookProc)
		{
			BOOL bHookProcessedMessage;

			bHookProcessedMessage =	gReceivePDUHookProc(pMessage,
				pCallObject->hQ931Call,	pCallObject->dwListenToken,
				pCallObject->dwUserToken);

			if (bHookProcessedMessage)
			{
				if (CallObjectValidate(hQ931Call) == CS_OK)
				{
					dwPhysicalId = pCallObject->dwPhysicalId;
					CallObjectUnlock(pCallObject);
					PostReceiveBuffer(dwPhysicalId,	buf);
				}
				else
				{
					CallEntryUnlock(hQ931Call);
				}
				return;
			}
		}

		// Message now contains	the	values of the Q931 PDU elements...
		switch (pMessage->MessageType)
		{
		case SETUPMESSAGETYPE:
			{
				Q931_SETUP_ASN SetupASN;

				if (!pMessage->UserToUser.Present || (pMessage->UserToUser.UserInformationLength ==	0))
				{
					ISRERROR(ghISRInst,	"ReceiveCallback():	Message	is missing ASN.1 UserUser data...",	0L);
					dwPhysicalId = pCallObject->dwPhysicalId;
					CallObjectUnlock(pCallObject);
					PostReceiveBuffer(dwPhysicalId,	buf);
					return;
				}

				ISRTRACE(ghISRInst,	"ReceiveCallback():	received Setup message...",	0L);
				Result = Q931SetupParseASN(&pCallObject->World,	pMessage->UserToUser.UserInformation,
					pMessage->UserToUser.UserInformationLength,	&SetupASN);
				if (Result == CS_OPTION_NOT_IMPLEMENTED)
				{
					//... maybe	callback callcont in later drop.

					// initiate	a disconnect sequence from the caller side.
					if (Q931SendReleaseCompleteMessage(pCallObject,
							CC_REJECT_TIMER_EXPIRED, NULL, NULL, NULL) != CS_OK)
					{
						// nothing to do if	this fails.
					}

					dwPhysicalId = pCallObject->dwPhysicalId;
					CallObjectDestroy(pCallObject);
					linkLayerShutdown(dwPhysicalId);
					if (buf)
					{
						MemFree(buf);
						buf	= NULL;
					}
					return;
				}
				if (Result != CS_OK)
				{
					ISRERROR(ghISRInst,	"ReceiveCallback():	Unable to parse	ASN.1 data.", 0L);
					break;
				}

				// The "CallerAddr is not passed in	the	PDU, so	the
				// only	valuable addr to use is	the	connection addr
				// passed from the link	layer and saved	into the call
				// object at connect-time.
				SetupASN.CallerAddrPresent = TRUE;
				SetupASN.CallerAddr	= pCallObject->PeerConnectAddr;

				// The "CalleeAddr"	which is passed	in the PDU is ignored
				// by the ASN parser, and supplied by the link layer
				// instead and saved into the call object at connect-time.
				// here, this address is used as the callee	addr.
				SetupASN.CalleeAddrPresent = TRUE;
				SetupASN.CalleeAddr	= pCallObject->LocalAddr;

				Result = Q931OnCallSetup(pCallObject, pMessage,	&SetupASN);

				_FreeSetupASN(&SetupASN);
			}
			break;
		case RELEASECOMPLMESSAGETYPE:
			{
				Q931_RELEASE_COMPLETE_ASN ReleaseCompleteASN;

				if (!pMessage->UserToUser.Present || (pMessage->UserToUser.UserInformationLength ==	0))
				{
					ISRERROR(ghISRInst,	"ReceiveCallback():	Message	is missing ASN.1 UserUser data...",	0L);
					dwPhysicalId = pCallObject->dwPhysicalId;
					CallObjectUnlock(pCallObject);
					PostReceiveBuffer(dwPhysicalId,	buf);
					return;
				}

				ISRTRACE(ghISRInst,	"ReceiveCallback():	received ReleaseComplete message...", 0L);
				Result = Q931ReleaseCompleteParseASN(&pCallObject->World,
										pMessage->UserToUser.UserInformation,
					pMessage->UserToUser.UserInformationLength,	&ReleaseCompleteASN);
				if (Result != CS_OK)
				{
					ISRERROR(ghISRInst,	"ReceiveCallback():	Unable to parse	ASN.1 data.", 0L);
					break;
				}
				Result = Q931OnCallReleaseComplete(pCallObject,	pMessage, &ReleaseCompleteASN);
				if (CallObjectValidate(hQ931Call) == CS_OK)
				{
					 dwPhysicalId =	pCallObject->dwPhysicalId;
					 CallObjectDestroy(pCallObject);
					 linkLayerShutdown(dwPhysicalId);
				}
				else
				{
					CallEntryUnlock(hQ931Call);
				}
				MemFree(buf);
				_FreeReleaseCompleteASN(&ReleaseCompleteASN);
				return;
			}
			break;
		case FACILITYMESSAGETYPE:
			{
				Q931_FACILITY_ASN FacilityASN;

				if (!pMessage->UserToUser.Present || (pMessage->UserToUser.UserInformationLength ==	0))
				{
					ISRERROR(ghISRInst,	"ReceiveCallback():	Message	is missing ASN.1 UserUser data...",	0L);
					dwPhysicalId = pCallObject->dwPhysicalId;
					CallObjectUnlock(pCallObject);
					PostReceiveBuffer(dwPhysicalId,	buf);
					return;
				}

				ISRTRACE(ghISRInst,	"ReceiveCallback():	received Facility message...", 0L);
				Result = Q931FacilityParseASN(&pCallObject->World, pMessage->UserToUser.UserInformation,
					pMessage->UserToUser.UserInformationLength,	&FacilityASN);
				if (Result != CS_OK)
				{
					ISRERROR(ghISRInst,	"ReceiveCallback():	Unable to parse	ASN.1 data.", 0L);
					break;
				}

				// initiate	a disconnect sequence from the caller side.
				Q931SendReleaseCompleteMessage(pCallObject,
						CC_REJECT_CALL_DEFLECTION, NULL, NULL, NULL);

				Result = Q931OnCallFacility(pCallObject, pMessage, &FacilityASN);
				_FreeFacilityASN(&FacilityASN);
				dwPhysicalId = pCallObject->dwPhysicalId;
				CallObjectDestroy(pCallObject);
				linkLayerShutdown(dwPhysicalId);
				MemFree(buf);
				return;
			}
			break;
		case CONNECTMESSAGETYPE:
			{
				Q931_CONNECT_ASN ConnectASN;

				if (!pMessage->UserToUser.Present || (pMessage->UserToUser.UserInformationLength ==	0))
				{
					ISRERROR(ghISRInst,	"ReceiveCallback():	Message	is missing ASN.1 UserUser data...",	0L);
					dwPhysicalId = pCallObject->dwPhysicalId;
					CallObjectUnlock(pCallObject);
					PostReceiveBuffer(dwPhysicalId,	buf);
					return;
				}

				ISRTRACE(ghISRInst,	"ReceiveCallback():	received Connect message...", 0L);
				Result = Q931ConnectParseASN(&pCallObject->World, pMessage->UserToUser.UserInformation,
					pMessage->UserToUser.UserInformationLength,	&ConnectASN);
				if (Result != CS_OK)
				{
					ISRERROR(ghISRInst,	"ReceiveCallback():	Unable to parse	ASN.1 data.", 0L);
					break;
				}
				Result = Q931OnCallConnect(pCallObject,	pMessage, &ConnectASN);
				_FreeConnectASN(&ConnectASN);
			}
			break;
		case PROCEEDINGMESSAGETYPE:
			{
				Q931_CALL_PROCEEDING_ASN ProceedingASN;

				ISRTRACE(ghISRInst,	"ReceiveCallback():	received Proceeding	message...", 0L);
				if (!pMessage->UserToUser.Present || (pMessage->UserToUser.UserInformationLength ==	0))
				{
					Result = Q931OnCallProceeding(pCallObject, pMessage, NULL);
				}
				else
				{
					Result = Q931ProceedingParseASN(&pCallObject->World, pMessage->UserToUser.UserInformation,
						pMessage->UserToUser.UserInformationLength,	&ProceedingASN);
					if (Result != CS_OK)
					{
						ISRERROR(ghISRInst,	"ReceiveCallback():	Unable to parse	ASN.1 data.", 0L);
						break;
					}
					Result = Q931OnCallProceeding(pCallObject, pMessage, &ProceedingASN);
					_FreeProceedingASN(&ProceedingASN);
				}
			}
			break;
		case ALERTINGMESSAGETYPE:
			{
				Q931_ALERTING_ASN AlertingASN;

				ISRTRACE(ghISRInst,	"ReceiveCallback():	received Alerting message...", 0L);
				if (!pMessage->UserToUser.Present || (pMessage->UserToUser.UserInformationLength ==	0))
				{
					Result = Q931OnCallAlerting(pCallObject, pMessage, NULL);
				}
				else
				{
					Result = Q931AlertingParseASN(&pCallObject->World, pMessage->UserToUser.UserInformation,
						pMessage->UserToUser.UserInformationLength,	&AlertingASN);
					if (Result != CS_OK)
					{
						ISRERROR(ghISRInst,	"ReceiveCallback():	Unable to parse	ASN.1 data.", 0L);
						break;
					}
					Result = Q931OnCallAlerting(pCallObject, pMessage, &AlertingASN);
					_FreeAlertingASN(&AlertingASN);
				}
			}
			break;
		case RELEASEMESSAGETYPE:
		case STATUSMESSAGETYPE:
			ISRWARNING(ghISRInst, "ReceiveCallback(): message not yet supported.", 0L);
			break;
		case STATUSENQUIRYMESSAGETYPE:
			ISRWARNING(ghISRInst, "ReceiveCallback(): message not yet supported.", 0L);
			Result = Q931OnCallStatusEnquiry(pCallObject, pMessage);
			break;
		default:
			ISRERROR(ghISRInst,	"ReceiveCallback():	unknown	message	received.",	0L);
			break;
		}

		// re-validate the call	object:
		if (CallObjectValidate(hQ931Call) == CS_OK)
		{
			dwPhysicalId = pCallObject->dwPhysicalId;
			CallObjectUnlock(pCallObject);
			PostReceiveBuffer(dwPhysicalId,	buf);
			if ((CallObjectLock(hQ931Call, &pCallObject) !=	CS_OK) || (pCallObject == NULL))
			  return;
		}
		else
		{
			if (buf)
			{
				MemFree(buf);
			}
			CallEntryUnlock(hQ931Call);
			return;
		}

		if (Result == CS_INCOMPATIBLE_VERSION)
		{
			// initiate	a disconnect sequence from the caller side.
			Q931SendReleaseCompleteMessage(pCallObject,
					CC_REJECT_INVALID_REVISION,	NULL, NULL,	NULL);

			dwPhysicalId = pCallObject->dwPhysicalId;
			CallObjectDestroy(pCallObject);
			linkLayerShutdown(dwPhysicalId);
			return;
		}

		if (Result == CS_MANDATORY_IE_MISSING)
		{
			Q931SendStatusMessage(pCallObject, pMessage,
				CAUSE_VALUE_IE_MISSING);
		}
		else if	(Result	== CS_BAD_IE_CONTENT)
		{
			Q931SendStatusMessage(pCallObject, pMessage,
				CAUSE_VALUE_IE_CONTENTS);
		}

	}
	else if	(message ==	LINK_RECV_CLOSED)
	{
		// Socket closed
		if (buf)
		{
			MemFree(buf);
		}
		pCallObject->Callback(Q931_CALL_CONNECTION_CLOSED, pCallObject->hQ931Call,
			pCallObject->dwListenToken,
			pCallObject->dwUserToken, NULL);

		if (CallObjectValidate(hQ931Call) == CS_OK)
		{
			 dwPhysicalId =	pCallObject->dwPhysicalId;
			 pCallObject->bConnected = FALSE;
			 CallObjectDestroy(pCallObject);
			 linkLayerShutdown(dwPhysicalId);
		}
		else
		{
			CallEntryUnlock(hQ931Call);
		}
		return;
	}
	else if	(buf)
	{
		// unknown condition?
		MemFree(buf);
	}

	if (CallObjectValidate(hQ931Call) == CS_OK)
	{
		CallObjectUnlock(pCallObject);
	}
	else
	{
		CallEntryUnlock(hQ931Call);
	}

	return;
}

//====================================================================================
//====================================================================================
void
Q931ReceiveCallback(DWORD_PTR instance,	HRESULT	message, BYTE *buf,	DWORD nbytes)
{
	Q931MESSAGE	*pMessage =	NULL;
	if (message	== LINK_RECV_DATA)
	{
		pMessage = (Q931MESSAGE	*)MemAlloc(sizeof(Q931MESSAGE));
		if (pMessage ==	NULL)
		{
			ISRERROR(ghISRInst,	"Not enough	memory to process Q931 message.", 0L);
			// something more should be	done here to indicate SERIOUS error...
			return;
		}
	}
	OnReceiveCallback(instance,	message, pMessage, buf,	nbytes);
	if (pMessage)
	{
		MemFree(pMessage);
	}
	return;
}

//====================================================================================
//====================================================================================
void
Q931ConnectCallback(DWORD_PTR dwInstance, HRESULT dwMessage,
		CC_ADDR	*pLocalAddr, CC_ADDR *pPeerAddr)
{
	HQ931CALL hQ931Call	= (HQ931CALL)dwInstance;
	P_CALL_OBJECT pCallObject =	NULL;
	HRESULT	TempResult;
	DWORD dwPhysicalId;

	ISRTRACE(ghISRInst,	"Entering Q931ConnectCallback()...", 0L);

	if ((CallObjectLock(hQ931Call, &pCallObject) !=	CS_OK) || (pCallObject == NULL))
	{
		ISRERROR(ghISRInst,	"CallObjectLock() returned error", 0L);
		return;
	}

	pCallObject->bConnected	= TRUE;

	if (FAILED(dwMessage))
	{
		// shut	down link layer; report	failure	to client
		CSS_CALL_FAILED	EventData;

		ISRERROR(ghISRInst,	"error in connect",	0L);

		EventData.error	= dwMessage;
		pCallObject->Callback(Q931_CALL_FAILED,	pCallObject->hQ931Call,
			pCallObject->dwListenToken,
			pCallObject->dwUserToken, &EventData);

		if (CallObjectValidate(hQ931Call) == CS_OK)
		{
			 DWORD dwId	= pCallObject->dwPhysicalId;
			 CallObjectDestroy(pCallObject);
			 linkLayerShutdown(dwId);
		}
		else
		{
			CallEntryUnlock(hQ931Call);
		}
		return;
	}

	if (dwMessage != LINK_CONNECT_COMPLETE)
	{
		ISRERROR(ghISRInst,	"unexpected	connect	callback", 0L);
		CallObjectUnlock(pCallObject);
		return;
	}

	if (pCallObject->bCallState	== CALLSTATE_NULL)
	{
		pCallObject->bCallState	= CALLSTATE_INITIATED;
	}

	ASSERT(pLocalAddr);
	pCallObject->LocalAddr = *pLocalAddr;

	ASSERT(pPeerAddr);
	pCallObject->PeerConnectAddr = *pPeerAddr;

	// if the user specified a binary source address with address =	0,
	// fill	in the address with	the	local address and send.
	if ((pCallObject->SourceAddrPresent) &&
			(pCallObject->SourceAddr.nAddrType == CC_IP_BINARY)	&&
			(!pCallObject->SourceAddr.Addr.IP_Binary.dwAddr))
	{
		pCallObject->SourceAddr	= *pLocalAddr;
	}

	if ((pCallObject->fIsCaller) &&
			(pCallObject->bCallState ==	CALLSTATE_INITIATED))
	{
		// send	the	SETUP message to the peer.
		DWORD CodedLengthASN;
		BYTE *CodedPtrASN;
		HRESULT	ResultASN =	CS_OK;

		DWORD CodedLengthPDU;
		BYTE *CodedPtrPDU;
		HRESULT	ResultPDU =	CS_OK;

		int	nError = 0;
		BOOL ResultSend	= FALSE;
		BINARY_STRING UserUserData;
		PCC_VENDORINFO pVendorInfo = NULL;
		CC_NONSTANDARDDATA *pNonStandardData = NULL;
		DWORD dwId;

		if (pCallObject->VendorInfoPresent)
		{
			pVendorInfo	= &(pCallObject->VendorInfo);
		}

		if (pCallObject->NonStandardDataPresent)
		{
			pNonStandardData = &(pCallObject->NonStandardData);
		}

		// if there	is a special callee	alias list,	load the calledparty#.
		if (pCallObject->szCalledPartyNumber[0]	== 0 &&
			pCallObject->pCalleeAliasList != NULL &&
			pCallObject->pCalleeAliasList->wCount == 1 &&
			pCallObject->pCalleeAliasList->pItems[0].wType == CC_ALIAS_H323_PHONE &&
			pCallObject->pCalleeAliasList->pItems[0].wDataLength > 0 &&
			pCallObject->pCalleeAliasList->pItems[0].pData != NULL)
		{
			PCC_ALIASITEM pItem	= &pCallObject->pCalleeAliasList->pItems[0];
			WCHAR szWidePartyNumber[CC_MAX_PARTY_NUMBER_LEN	+ 1];

			memset(szWidePartyNumber, 0	, CC_MAX_PARTY_NUMBER_LEN +	1);

			if (pItem->wPrefixLength > 0 &&	pItem->pPrefix != NULL)
			{
				ASSERT((pItem->wPrefixLength + pItem->wDataLength +1) <= (sizeof(szWidePartyNumber)/sizeof(szWidePartyNumber[0])));
				memcpy(&szWidePartyNumber[0],
					   pItem->pPrefix,
					   (pItem->wPrefixLength) *	sizeof(WCHAR));
				memcpy(&szWidePartyNumber[pItem->wPrefixLength],
					   pItem->pData,
					   pItem->wDataLength *	sizeof(WCHAR));
			}
			else
			{
				ASSERT((pItem->wDataLength +1) <= (sizeof(szWidePartyNumber)/sizeof(szWidePartyNumber[0])));
				memcpy(szWidePartyNumber,
					   pCallObject->pCalleeAliasList->pItems[0].pData,
					   pItem->wDataLength *	sizeof(WCHAR));
			}
			WideCharToMultiByte(CP_ACP,	0, szWidePartyNumber,
				pItem->wPrefixLength + pItem->wDataLength *	sizeof(WCHAR),
				pCallObject->szCalledPartyNumber,
				sizeof(pCallObject->szCalledPartyNumber), NULL,	NULL);
		}

		// may wish	to pass	alias parms	later instead of NULL, NULL.
		ResultASN =	Q931SetupEncodeASN(pNonStandardData,
			pCallObject->SourceAddrPresent ? &(pCallObject->SourceAddr)	: NULL,
			pCallObject->PeerCallAddrPresent ? &(pCallObject->PeerCallAddr)	: NULL,	 //	callee
			pCallObject->wGoal,
			pCallObject->wCallType,
			pCallObject->bCallerIsMC,
			&(pCallObject->ConferenceID),
			pCallObject->pCallerAliasList,
			pCallObject->pCalleeAliasList,
			pCallObject->pExtraAliasList,
			pCallObject->pExtensionAliasItem,
			pVendorInfo,
			pCallObject->bIsTerminal,
			pCallObject->bIsGateway,
						&pCallObject->World,
			&CodedPtrASN,
			&CodedLengthASN,
			&pCallObject->CallIdentifier);

		if ((ResultASN != CS_OK) ||	(CodedLengthASN	== 0) ||
				(CodedPtrASN ==	NULL))
		{
			CSS_CALL_FAILED	EventData;
			ISRERROR(ghISRInst,	"Q931SetupEncodeASN() failed, nothing to send.", 0L);
			if (CodedPtrASN	!= NULL)
			{
				Q931FreeEncodedBuffer(&pCallObject->World, CodedPtrASN);
			}
			EventData.error	= CS_INTERNAL_ERROR;
			dwId = pCallObject->dwPhysicalId;
			pCallObject->Callback(Q931_CALL_FAILED,	pCallObject->hQ931Call,
				pCallObject->dwListenToken,
				pCallObject->dwUserToken, &EventData);
			linkLayerShutdown(dwId);
			if (CallObjectValidate(hQ931Call) == CS_OK)
			{
				 CallObjectDestroy(pCallObject);
			}
			else
			{
				CallEntryUnlock(hQ931Call);
			}
			return;
		}

		UserUserData.length	= (WORD)CodedLengthASN;
		UserUserData.ptr = CodedPtrASN;

		ResultPDU =	Q931SetupEncodePDU(pCallObject->wCRV,
			pCallObject->szDisplay,	pCallObject->szCalledPartyNumber,
			&UserUserData, &CodedPtrPDU, &CodedLengthPDU);

		if (CodedPtrASN	!= NULL)
		{
			Q931FreeEncodedBuffer(&pCallObject->World, CodedPtrASN);
		}

		if ((ResultPDU != CS_OK) ||	(CodedLengthPDU	== 0) ||
				(CodedPtrPDU ==	NULL))
		{
			CSS_CALL_FAILED	EventData;
			ISRERROR(ghISRInst,	"Q931SetupEncodePDU() failed, nothing to send.", 0L);
			if (CodedPtrPDU	!= NULL)
			{
				MemFree(CodedPtrPDU);
			}
			EventData.error	= CS_INTERNAL_ERROR;
			dwId = pCallObject->dwPhysicalId;
			pCallObject->Callback(Q931_CALL_FAILED,	pCallObject->hQ931Call,
				pCallObject->dwListenToken,
				pCallObject->dwUserToken, &EventData);
			linkLayerShutdown(dwId);
			if (CallObjectValidate(hQ931Call) == CS_OK)
			{
				 CallObjectDestroy(pCallObject);
			}
			else
			{
				CallEntryUnlock(hQ931Call);
			}
			return;
		}

		if (pCallObject->NonStandardDataPresent)
		{
			if (pCallObject->NonStandardData.sData.pOctetString	!= NULL)
			{
				MemFree(pCallObject->NonStandardData.sData.pOctetString);
				pCallObject->NonStandardData.sData.pOctetString	= NULL;
			}
			pCallObject->NonStandardDataPresent	= FALSE;
		}
		Q931FreeAliasNames(pCallObject->pCallerAliasList);
		pCallObject->pCallerAliasList =	NULL;
		Q931FreeAliasNames(pCallObject->pCalleeAliasList);
		pCallObject->pCalleeAliasList =	NULL;
		Q931FreeAliasNames(pCallObject->pExtraAliasList);
		pCallObject->pExtraAliasList = NULL;
		Q931FreeAliasItem(pCallObject->pExtensionAliasItem);
		pCallObject->pExtensionAliasItem = NULL;

		TempResult=Q931SendMessage(pCallObject,	CodedPtrPDU, CodedLengthPDU, TRUE);
		if (CallObjectValidate(hQ931Call) != CS_OK)
		{
			CallEntryUnlock(hQ931Call);
			return;
		}

		if(FAILED(TempResult))
		{
			CSS_CALL_FAILED	EventData;

			EventData.error	= TempResult;
			dwId = pCallObject->dwPhysicalId;
			pCallObject->Callback(Q931_CALL_FAILED,	pCallObject->hQ931Call,
				pCallObject->dwListenToken,
				pCallObject->dwUserToken, &EventData);
			linkLayerShutdown(dwId);
			if (CallObjectValidate(hQ931Call) == CS_OK)
			{
				 CallObjectDestroy(pCallObject);
			}
			else
			{
				CallEntryUnlock(hQ931Call);
			}
			return;
		}

		Q931StartTimer(pCallObject,	Q931_TIMER_303);
	}
	dwPhysicalId = pCallObject->dwPhysicalId;
	CallObjectUnlock(pCallObject);
	PostReceiveBuffer(dwPhysicalId,	NULL);
}

//====================================================================================
//====================================================================================
void
Q931ListenCallback(DWORD_PTR dwInstance, HRESULT dwMessage,
		CC_ADDR	*LocalAddr,	CC_ADDR	*PeerAddr)
{
	HQ931LISTEN	hListenObject =	(HQ931LISTEN)dwInstance;
	P_LISTEN_OBJECT	pListenObject =	NULL;
	CS_STATUS CreateObjectResult;
	HQ931CALL hQ931Call;
	P_CALL_OBJECT pCallObject =	NULL;
	HRESULT	TempResult;
	DWORD dwPhysicalId;

	ISRTRACE(ghISRInst,	"Q931ListenCallback.", 0L);

	if (dwMessage != LINK_CONNECT_REQUEST)
	{
		ISRERROR(ghISRInst,	"unexpected	callback received on listen	socket", 0L);
		return;
	}

	if (FAILED(dwMessage))
	{
		ISRERROR(ghISRInst,	"error on listen socket", 0L);
		return;
	}

	if ((ListenObjectLock(hListenObject, &pListenObject) !=	CS_OK) || (pListenObject ==	NULL))
	{
		ISRERROR(ghISRInst,	"ListenObjectLock()	returned error", 0L);
		return;
	}

	// create call object with all known attributes	of this	call.
	// a handle	of the call	object is returned in phQ931Call.
	CreateObjectResult = CallObjectCreate(&hQ931Call,
		pListenObject->dwUserToken,
		CC_INVALID_HANDLE,
		pListenObject->ListenCallback,
		FALSE,					// I am	NOT	the	caller.
		LocalAddr,				// Local address on	which channel is connected
		PeerAddr,				// Address to which	channel	is connected
		NULL,					// Address of opposite call	end-point.
		NULL,					// no source addr
		NULL,					// no conference id	yet.
		CSG_NONE,				// no goal yet.
		CC_CALLTYPE_UNKNOWN,	// no call type	yet.
		FALSE,					// caller is assumed to	not	be the MC.
		NULL,					// no display yet.
		NULL,					// no called party number yet.
		NULL,					// no caller aliases yet.
		NULL,					// no callee aliases yet.
		NULL,					// no extra	aliases	yet.
		NULL,					// no extension	aliases.
		NULL,					// no EndpointType info	yet.
		NULL,
		0,						// no CRV yet.
		NULL);					// no h225 CallIdentifier yet.
	if (CreateObjectResult != CS_OK)
	{
		ISRERROR(ghISRInst,	"CallObjectCreate()	failed.", 0L);
		ListenObjectUnlock(pListenObject);
		return;
	}

	if ((CallObjectLock(hQ931Call, &pCallObject) !=	CS_OK) || (pCallObject == NULL))
	{
		ISRERROR(ghISRInst,	"CallObjectLock() returned error", 0L);
		ListenObjectUnlock(pListenObject);
		return;
	}

	TempResult = linkLayerInit(&pCallObject->dwPhysicalId, hQ931Call,
		Q931ReceiveCallback, Q931SendComplete);
	if (FAILED(TempResult))
	{
		ISRERROR(ghISRInst,	"linkLayerInit() failed", 0);
		linkLayerReject(pListenObject->dwPhysicalId);
		CallObjectDestroy(pCallObject);
		ListenObjectUnlock(pListenObject);
		return;
	}

//	  pCallObject->bCallState =	CALLSTATE_NULL;

	// unlock CallObject before	calling	down into h245ws in	order to prevent deadlock -	which
	// is probably unlikely	with linkLayerAccept(),	but	just to	be safe	and	consistent...
	// not sure	if we need to worry	about unlocking	the	listen object???

	dwPhysicalId = pCallObject->dwPhysicalId;
	CallObjectUnlock(pCallObject);

	TempResult = linkLayerAccept(pListenObject->dwPhysicalId,
		dwPhysicalId, Q931ConnectCallback);

	if (FAILED(TempResult))
	{
		  if((CallObjectLock(hQ931Call,	&pCallObject) != CS_OK)	|| (pCallObject	== NULL))
		{
			   ListenObjectUnlock(pListenObject);
			   return;
		}
		ISRERROR(ghISRInst,	"linkLayerAccept() failed",	0);
		{
			 DWORD dwId	= pCallObject->dwPhysicalId;
			 CallObjectDestroy(pCallObject);
			 linkLayerShutdown(dwId);
		}
		ListenObjectUnlock(pListenObject);
		return;
	}

	ListenObjectUnlock(pListenObject);
}

//====================================================================================
//
// PUBLIC FUNCTIONS
//
//====================================================================================

//====================================================================================
//====================================================================================

CS_STATUS
H225Init()
{
	 CS_STATUS result;

	if (H225_InitModule() != ASN1_SUCCESS)
	{
		ASSERT(FALSE);
		return CS_SUBSYSTEM_FAILURE;
	}



	 return	CS_OK;
}


CS_STATUS
H225DeInit()
{
	CS_STATUS result;
	result = H225_TermModule();
	if (result != CS_OK)
	{
		return CS_SUBSYSTEM_FAILURE;
	}
	return CS_OK;
}

CS_STATUS
Q931Init()
{
	CS_STATUS result;

	if (bQ931Initialized ==	TRUE)
	{
		ASSERT(FALSE);
		return CS_DUPLICATE_INITIALIZE;
	}

	bQ931Initialized = TRUE;

	// Register	Call Setup for debug output
	ISRREGISTERMODULE(&ghISRInst, "Q931", "Q931	Call Setup");

	// Initialize the current conference ID	to 0's,	which is intentionally
	// assigned	to an invalid conference ID.  Must create one for it
	// to be valid.
	memset(&(ConferenceIDSource), 0, sizeof(ConferenceIDSource));
	InitializeCriticalSection(&(ConferenceIDSource.Lock));

	if ((result	= ListenListCreate()) != CS_OK)
	{
		return result;
	}
	if ((result	= CallListCreate())	!= CS_OK)
	{
		ListenListDestroy();
		return result;
	}

	// init	protocol ID	structures
	Q931PduInit();

#if	(defined(_DEBUG) ||	defined(PCS_COMPLIANCE))
	Q931Logger = InteropLoad(Q931LOG_PROTOCOL);
#endif

	return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931DeInit()
{
	CS_STATUS result1;
	CS_STATUS result2;

	if (bQ931Initialized ==	FALSE)
	{
		return CS_NOT_INITIALIZED;
	}

#if	(defined(_DEBUG) ||	defined(PCS_COMPLIANCE))
// This	causes a protection	exception, so don't	do it for now.	DAC	12/9/96
//	  InteropUnload(Q931Logger);
#endif

	result1	= ListenListDestroy();

	result2	= CallListDestroy();

	DeleteCriticalSection(&(ConferenceIDSource.Lock));

	bQ931Initialized = FALSE;

	if (result1	!= CS_OK)
	{
		return result1;
	}
	return result2;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931Listen(
	PHQ931LISTEN		phQ931Listen,
	PCC_ADDR			pListenAddr,
	DWORD_PTR			dwListenToken,
	Q931_CALLBACK		ListenCallback)
{
	CS_STATUS CreateObjectResult;
	P_LISTEN_OBJECT	pListenObject =	NULL;
	HRESULT	TempResult;

	// make	sure q931 is initialized with an initialize	flag.
	if (bQ931Initialized ==	FALSE)
	{
		return CS_NOT_INITIALIZED;
	}

	// make	sure parms are validated.
	if ((phQ931Listen == NULL) || (ListenCallback == NULL) || (pListenAddr == NULL))
	{
		ASSERT(FALSE);
		return CS_BAD_PARAM;
	}

	SetDefaultPort(pListenAddr);

	// create listen object	with all known attributes of this listen session.
	// a handle	of the listen object is	returned in	phQ931Listen.

	CreateObjectResult = ListenObjectCreate(phQ931Listen, dwListenToken, ListenCallback);
	if (CreateObjectResult != CS_OK)
	{
		return CS_SUBSYSTEM_FAILURE;
	}

	if (ListenObjectLock(*phQ931Listen,	&pListenObject)	!= CS_OK)
	{
		return CS_BAD_PARAM;
	}

	TempResult = linkLayerListen(&pListenObject->dwPhysicalId, *phQ931Listen,
		pListenAddr, Q931ListenCallback);
	ListenObjectUnlock(pListenObject);
	if (FAILED(TempResult))
	{
		ISRTRACE(ghISRInst,	"Q931Listen() linkLayerListen failed.",	0L);
		return TempResult;
	}

	ISRTRACE(ghISRInst,	"Q931Listen() completed	successfully.",	0L);
	return CS_OK;
}

//====================================================================================
// In the old code,	this blocked until thread and socket were finished
// closing...
//====================================================================================
CS_STATUS
Q931CancelListen(
	HQ931LISTEN			hQ931Listen)
{
	P_LISTEN_OBJECT	pListenObject =	NULL;
	CS_STATUS Status;

	// make	sure q931 is initialized with an initialize	flag.
	if (bQ931Initialized ==	FALSE)
	{
		return CS_NOT_INITIALIZED;
	}

	ISRTRACE(ghISRInst,	"Q931CancelListen()	finding	listen object...", 0L);

	// lock	the	listen object, get the event to	wait for, and unlock the listen	object.
	if (ListenObjectLock(hQ931Listen, &pListenObject) != CS_OK)
	{
		return CS_BAD_PARAM;
	}

	{
		DWORD dwId = pListenObject->dwPhysicalId;
		linkLayerShutdown(dwId);
		// destroy the object.	dont need to unlock	it since entire	object will	be destroyed.
		ISRTRACE(ghISRInst,	"Q931CancelListen(): destroying	listen object...", 0L);
		Status = ListenObjectDestroy(pListenObject);
	}

	return Status;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931PlaceCall(
	PHQ931CALL phQ931Call,
	LPWSTR pszDisplay,
	PCC_ALIASNAMES pCallerAliasList,
	PCC_ALIASNAMES pCalleeAliasList,
	PCC_ALIASNAMES pExtraAliasList,
	PCC_ALIASITEM pExtensionAliasItem,
	PCC_NONSTANDARDDATA	pNonStandardData,
	PCC_ENDPOINTTYPE pSourceEndpointType,
	LPWSTR pszCalledPartyNumber,
	PCC_ADDR pControlAddr,
	PCC_ADDR pDestinationAddr,
	PCC_ADDR pSourceAddr,
	BOOL bCallerIsMC,
	CC_CONFERENCEID	*pConferenceID,
	WORD wGoal,
	WORD wCallType,
	DWORD_PTR dwUserToken,
	Q931_CALLBACK ConnectCallback,
	WORD wCRV,
	LPGUID pCallIdentifier)
{
	CS_STATUS CreateObjectResult;
	P_CALL_OBJECT pCallObject =	NULL;
	CC_ADDR	PeerCallAddr;
	CC_ADDR	PeerConnectAddr;
	CC_ADDR	SourceAddr;
	HRESULT	TempResult;
	char szAsciiDisplay[CC_MAX_DISPLAY_LENGTH +	1];
	char szAsciiPartyNumber[CC_MAX_PARTY_NUMBER_LEN	+ 1];
	DWORD dwPhysicalId;

	// make	sure q931 is initialized with an initialize	flag.
	if (bQ931Initialized ==	FALSE)
	{
		return CS_NOT_INITIALIZED;
	}

	// make	sure parms are validated.
	if ((phQ931Call	== NULL) ||	(ConnectCallback ==	NULL) ||
			((pControlAddr == NULL)	&& (pDestinationAddr ==	NULL)) ||
			(pSourceEndpointType ==	NULL))
	{
		return CS_BAD_PARAM;
	}

	{
		CS_STATUS TempStatus;

		TempStatus = Q931ValidateAddr(pControlAddr);
		if (TempStatus != CS_OK)
		{
			return TempStatus;
		}
		TempStatus = Q931ValidateAddr(pDestinationAddr);
		if (TempStatus != CS_OK)
		{
			return TempStatus;
		}
		TempStatus = Q931ValidateAddr(pSourceAddr);
		if (TempStatus != CS_OK)
		{
			return TempStatus;
		}

		TempStatus = Q931ValidateVendorInfo(pSourceEndpointType->pVendorInfo);
		if (TempStatus != CS_OK)
		{
			return TempStatus;
		}
		TempStatus = Q931ValidateDisplay(pszDisplay);
		if (TempStatus != CS_OK)
		{
			return TempStatus;
		}
		TempStatus = Q931ValidatePartyNumber(pszCalledPartyNumber);
		if (TempStatus != CS_OK)
		{
			return TempStatus;
		}

		szAsciiDisplay[0] =	'\0';
		if (pszDisplay && WideCharToMultiByte(CP_ACP, 0, pszDisplay, -1, szAsciiDisplay,
				sizeof(szAsciiDisplay),	NULL, NULL)	== 0)
		{
			return CS_BAD_PARAM;
		}
		szAsciiPartyNumber[0] =	'\0';
		if (pszCalledPartyNumber &&	WideCharToMultiByte(CP_ACP,	0, pszCalledPartyNumber, -1, szAsciiPartyNumber,
				sizeof(szAsciiPartyNumber),	NULL, NULL)	== 0)
		{
			return CS_BAD_PARAM;
		}
		TempStatus = Q931ValidateNonStandardData(pNonStandardData);
		if (TempStatus != CS_OK)
		{
			return TempStatus;
		}
		TempStatus = Q931ValidateAliasNames(pCallerAliasList);
		if (TempStatus != CS_OK)
		{
			return TempStatus;
		}
		TempStatus = Q931ValidateAliasNames(pCalleeAliasList);
		if (TempStatus != CS_OK)
		{
			return TempStatus;
		}
		TempStatus = Q931ValidateAliasNames(pExtraAliasList);
		if (TempStatus != CS_OK)
		{
			return TempStatus;
		}
		TempStatus = Q931ValidateAliasItem(pExtensionAliasItem);
		if (TempStatus != CS_OK)
		{
			return TempStatus;
		}
	}

	// get the correct callee and control address to use for the call.
	if (pDestinationAddr)
	{
		if (!MakeBinaryADDR(pDestinationAddr, &PeerCallAddr))
		{
			return CS_BAD_PARAM;
		}
		SetDefaultPort(&PeerCallAddr);
	}

	if (pControlAddr)
	{
		if (!MakeBinaryADDR(pControlAddr, &PeerConnectAddr))
		{
			return CS_BAD_PARAM;
		}
		SetDefaultPort(&PeerConnectAddr);
	}
	else
	{
		PeerConnectAddr	= PeerCallAddr;
	}

	// get the correct callee and control address to use for the call.
	if (pSourceAddr)
	{
		if (!MakeBinaryADDR(pSourceAddr, &SourceAddr))
		{
			return CS_BAD_PARAM;
		}
		SetDefaultPort(&SourceAddr);
	}

	if (wGoal == CSG_CREATE)
		{
			// caller is asking	to start a new conference.
			if (((DWORD	*)pConferenceID->buffer)[0]	== 0 &&
				((DWORD	*)pConferenceID->buffer)[1]	== 0 &&
				((DWORD	*)pConferenceID->buffer)[2]	== 0 &&
				((DWORD	*)pConferenceID->buffer)[3]	== 0)
			{
				_ConferenceIDNew(pConferenceID);
			}
		}

	// create call object with all known attributes	of this	call.
	// a handle	of the call	object is returned in phQ931Call.
	CreateObjectResult = CallObjectCreate(phQ931Call,
		CC_INVALID_HANDLE,
		dwUserToken,
		ConnectCallback,
		TRUE,				   // I	am the caller.
		NULL,				   // no local address yet.
		&PeerConnectAddr,
		pDestinationAddr ? &PeerCallAddr : NULL,
		pSourceAddr	? &SourceAddr :	NULL,
		pConferenceID,
		wGoal,
		wCallType,
		bCallerIsMC,
		pszDisplay ? szAsciiDisplay	: NULL,
		pszCalledPartyNumber ? szAsciiPartyNumber :	NULL,
		pCallerAliasList,
		pCalleeAliasList,
		pExtraAliasList,
		pExtensionAliasItem,
		pSourceEndpointType,
		pNonStandardData,
		wCRV,
		pCallIdentifier);

	if (CreateObjectResult != CS_OK)
	{
		return CS_SUBSYSTEM_FAILURE;
	}

	if ((CallObjectLock(*phQ931Call, &pCallObject) != CS_OK) ||	(pCallObject ==	NULL))
	{
		ISRERROR(ghISRInst,	"CallObjectLock() returned error", 0L);
		return CS_SUBSYSTEM_FAILURE;
	}

	TempResult = linkLayerInit(&pCallObject->dwPhysicalId, *phQ931Call,
		Q931ReceiveCallback, Q931SendComplete);
	if (FAILED(TempResult))
	{
		ISRERROR(ghISRInst,	"linkLayerInit() failed", 0);
		CallObjectDestroy(pCallObject);
		*phQ931Call	= 0;
		return TempResult;
	}

	// unlock CallObject before	calling	down into h245ws in	order to prevent deadlock -	which
	// is probably unlikely	with linkLayerConnect(), but just to be	safe and consistent...
	dwPhysicalId = pCallObject->dwPhysicalId;
	CallObjectUnlock(pCallObject);
	TempResult = linkLayerConnect(dwPhysicalId,	&PeerConnectAddr,
			Q931ConnectCallback);
	if((CallObjectLock(*phQ931Call,	&pCallObject) != CS_OK)	|| (pCallObject	== NULL))
	{
		*phQ931Call	= 0;
		return(CS_INTERNAL_ERROR);
	}

	if (FAILED(TempResult))
	{
		ISRERROR(ghISRInst,	"linkLayerConnect()	failed", 0);
		{
			 DWORD dwId	= pCallObject->dwPhysicalId;
			 CallObjectDestroy(pCallObject);
			 linkLayerShutdown(dwId);
		}
		*phQ931Call	= 0;
		return TempResult;
	}

//	  pCallObject->bCallState =	CALLSTATE_NULL;

	CallObjectUnlock(pCallObject);

	ISRTRACE(ghISRInst,	"Q931PlaceCall() completed successfully.", 0L);
	return CS_OK;
}

//====================================================================================
// In the old code,	this blocked until thread and socket were finished
// closing...
//====================================================================================
CS_STATUS
Q931Hangup(
	HQ931CALL hQ931Call,
	BYTE bReason)
{
	P_CALL_OBJECT pCallObject =	NULL;
	CS_STATUS Status;

	if (bQ931Initialized ==	FALSE)
	{
		return CS_NOT_INITIALIZED;
	}

	ISRTRACE(ghISRInst,	"Entering Q931Hangup()...",	0L);

	// need	parameter checking...
	if ((CallObjectLock(hQ931Call, &pCallObject) !=	CS_OK) || (pCallObject == NULL))
	{
		ISRTRACE(ghISRInst,	"Call Object no	longer available:",	(DWORD)hQ931Call);
		return CS_BAD_PARAM;
	}

	{

		CS_STATUS SendStatus = CS_OK;
		if (pCallObject->bCallState	!= CALLSTATE_NULL)
		{
			// send	the	RELEASE	COMPLETE message to	the	peer to	hang-up.
			SendStatus = Q931SendReleaseCompleteMessage(pCallObject,
				bReason, &(pCallObject->ConferenceID), NULL, NULL);
		}

		{
			 DWORD dwId	= pCallObject->dwPhysicalId;
			 Status	= CallObjectDestroy(pCallObject);
			 linkLayerShutdown(dwId);
		}

		if (FAILED(SendStatus))
		{
			return SendStatus;
		}
	}

	return Status;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931AcceptCall(
	HQ931CALL			hQ931Call,
	LPWSTR				pszDisplay,
	PCC_NONSTANDARDDATA	pNonStandardData,
	PCC_ENDPOINTTYPE	pDestinationEndpointType,
	PCC_ADDR			pH245Addr,
	DWORD_PTR			dwUserToken)
{
	P_CALL_OBJECT pCallObject =	NULL;
	CS_STATUS result = CS_OK;
	char szAsciiDisplay[CC_MAX_DISPLAY_LENGTH +	1];

	if (bQ931Initialized ==	FALSE)
	{
		return CS_NOT_INITIALIZED;
	}

	ISRTRACE(ghISRInst,	"Entering Q931AcceptCall()...",	0L);

	if ((pDestinationEndpointType == NULL) ||
			(pDestinationEndpointType->pVendorInfo == NULL))
	{
		return CS_BAD_PARAM;
	}

	{
		CS_STATUS TempStatus;

		TempStatus = Q931ValidateVendorInfo(pDestinationEndpointType->pVendorInfo);
		if (TempStatus != CS_OK)
		{
			return TempStatus;
		}
		TempStatus = Q931ValidateDisplay(pszDisplay);
		if (TempStatus != CS_OK)
		{
			return TempStatus;
		}
		szAsciiDisplay[0] =	'\0';
		if (pszDisplay && WideCharToMultiByte(CP_ACP, 0, pszDisplay, -1, szAsciiDisplay,
				sizeof(szAsciiDisplay),	NULL, NULL)	== 0)
		{
			return CS_BAD_PARAM;
		}
		TempStatus = Q931ValidateNonStandardData(pNonStandardData);
		if (TempStatus != CS_OK)
		{
			return TempStatus;
		}
	}

	if ((CallObjectLock(hQ931Call, &pCallObject) !=	CS_OK) || (pCallObject == NULL))
	{
		ISRERROR(ghISRInst,	"CallObjectLock() returned error (Socket not found).", 0L);
		return CS_INTERNAL_ERROR;
	}

	if (pCallObject->fIsCaller)
	{
		ISRERROR(ghISRInst,	"Caller	attempted to accept	call.",	0L);

		CallObjectUnlock(pCallObject);
		return CS_OUT_OF_SEQUENCE;
	}

	// label with the user supplied	UserToken for this call	object.
	pCallObject->dwUserToken = dwUserToken;

	// send	the	CONNECT	message	to peer	to accept call.
	{
		DWORD CodedLengthASN;
		BYTE *CodedPtrASN;
		HRESULT	ResultASN =	CS_OK;
		CC_ADDR	h245Addr;

		if (pH245Addr != NULL)
		{
			MakeBinaryADDR(pH245Addr, &h245Addr);
		}

		ResultASN =	Q931ConnectEncodeASN(pNonStandardData,
			&(pCallObject->ConferenceID),
			(pH245Addr ? &h245Addr : NULL),
			pDestinationEndpointType,
						&pCallObject->World,
			&CodedPtrASN,
			&CodedLengthASN,
			&pCallObject->CallIdentifier);
		if ((ResultASN != CS_OK) ||	(CodedLengthASN	== 0) ||
				(CodedPtrASN ==	NULL))
		{
			ISRERROR(ghISRInst,	"Q931ConnectEncodeASN()	failed,	nothing	to send.", 0L);
			if (CodedPtrASN	!= NULL)
			{
				Q931FreeEncodedBuffer(&pCallObject->World, CodedPtrASN);
			}
			CallObjectUnlock(pCallObject);
			return CS_SUBSYSTEM_FAILURE;
		}
		else
		{
			DWORD CodedLengthPDU;
			BYTE *CodedPtrPDU;
			BINARY_STRING UserUserData;
			HRESULT	ResultEncode = CS_OK;
			HRESULT	TempResult;
			WORD wCRV =	(WORD)(pCallObject->wCRV | 0x8000);

			UserUserData.length	= (WORD)CodedLengthASN;
			UserUserData.ptr = CodedPtrASN;

			ResultEncode = Q931ConnectEncodePDU(wCRV,
				szAsciiDisplay,	&UserUserData, &CodedPtrPDU, &CodedLengthPDU);
			if (CodedPtrASN	!= NULL)
			{
				Q931FreeEncodedBuffer(&pCallObject->World, CodedPtrASN);
			}
			if ((ResultEncode != CS_OK)	|| (CodedLengthPDU == 0) ||
					(CodedPtrPDU ==	NULL))
			{
				ISRERROR(ghISRInst,	"Q931ConnectEncodePDU()	failed,	nothing	to send.", 0L);
				if (CodedPtrPDU	!= NULL)
				{
					MemFree(CodedPtrPDU);
				}
				CallObjectUnlock(pCallObject);
				return CS_SUBSYSTEM_FAILURE;
			}

			TempResult = Q931SendMessage(pCallObject, CodedPtrPDU, CodedLengthPDU, TRUE);
			if (CallObjectValidate(hQ931Call) != CS_OK)
			{
				CallEntryUnlock(hQ931Call);
				return CS_INTERNAL_ERROR;
			}


			if (FAILED(TempResult))
			{
				ISRERROR(ghISRInst,	"datalinkSendRequest() failed",	0);
				if (CodedPtrPDU	!= NULL)
				{
					MemFree(CodedPtrPDU);
				}
				// when	the	connect	notification fails...what should we	do anyway????
				CallObjectUnlock(pCallObject);
				return TempResult;
			}
		}
	}

	pCallObject->bCallState	= CALLSTATE_ACTIVE;

	CallObjectUnlock(pCallObject);
	return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931RejectCall(
	HQ931CALL hQ931Call,
	BYTE bRejectReason,
	PCC_CONFERENCEID pConferenceID,
	PCC_ADDR pAlternateAddr,
	PCC_NONSTANDARDDATA	pNonStandardData)
{
	P_CALL_OBJECT pCallObject =	NULL;
	CS_STATUS result = CS_OK;
	CS_STATUS Status = CS_OK;

	if (bQ931Initialized ==	FALSE)
	{
		return CS_NOT_INITIALIZED;
	}

	ISRTRACE(ghISRInst,	"Entering Q931RejectCall()...",	0L);

	{
		CS_STATUS TempStatus;

		TempStatus = Q931ValidateNonStandardData(pNonStandardData);
		if (TempStatus != CS_OK)
		{
			return TempStatus;
		}
	}

	// if reason is	alternate addr,	but	there is no	alternate addr -->err
	if (((bRejectReason	== CC_REJECT_ROUTE_TO_GATEKEEPER) ||
			(bRejectReason == CC_REJECT_CALL_FORWARDED)	||
			(bRejectReason == CC_REJECT_ROUTE_TO_MC)) &&
			(pAlternateAddr	== NULL))
	{
		return CS_BAD_PARAM;
	}

	if ((CallObjectLock(hQ931Call, &pCallObject) !=	CS_OK) || (pCallObject == NULL))
	{
		ISRERROR(ghISRInst,	"CallObjectLock() returned error (Socket not found).", 0L);
		return CS_INTERNAL_ERROR;
	}

	if (pCallObject->fIsCaller)
	{
		ISRERROR(ghISRInst,	"Caller	attempted to reject	call.",	0L);

		CallObjectUnlock(pCallObject);
		return CS_OUT_OF_SEQUENCE;
	}

	result = Q931SendReleaseCompleteMessage(pCallObject,
		bRejectReason, pConferenceID, pAlternateAddr, pNonStandardData);

	{
		DWORD dwId = pCallObject->dwPhysicalId;
		Status = CallObjectDestroy(pCallObject);
		linkLayerShutdown(dwId);
	}

	if (result != CS_OK)
	{
		return result;
	}


	return Status;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931ReOpenConnection(
	HQ931CALL hQ931Call)
{
	P_CALL_OBJECT pCallObject =	NULL;
	HRESULT	TempResult = CS_OK;
	CC_ADDR	PeerConnectAddr;
	DWORD dwPhysicalId;

	if (bQ931Initialized ==	FALSE)
	{
		return CS_NOT_INITIALIZED;
	}

	ISRTRACE(ghISRInst,	"Entering Q931ReOpenConnection()...", 0L);

	if ((CallObjectLock(hQ931Call, &pCallObject) !=	CS_OK) || (pCallObject == NULL))
	{
		ISRERROR(ghISRInst,	"CallObjectLock() returned error.",	0L);
		return CS_INTERNAL_ERROR;
	}

	if (pCallObject->bConnected)
	{
		return CS_OUT_OF_SEQUENCE;
	}

	Q931MakePhysicalID(&pCallObject->dwPhysicalId);
	TempResult = linkLayerInit(&pCallObject->dwPhysicalId, hQ931Call,
		Q931ReceiveCallback, Q931SendComplete);
	if (FAILED(TempResult))
	{
		ISRERROR(ghISRInst,	"linkLayerInit() failed	on re-connect.", 0);
		CallObjectUnlock(pCallObject);
		return TempResult;
	}

	// unlock CallObject before	calling	down into h245ws in	order to prevent deadlock -	which
	// is probably unlikely	with linkLayerConnect, but just	to be safe and consistent...

	// copy	stuff we need out of call object before	we unlock it
	dwPhysicalId = pCallObject->dwPhysicalId;
	PeerConnectAddr	= pCallObject->PeerConnectAddr;

	CallObjectUnlock(pCallObject);

	TempResult = linkLayerConnect(dwPhysicalId,
			&PeerConnectAddr, Q931ConnectCallback);

	if((CallObjectLock(hQ931Call, &pCallObject)	!= CS_OK) || (pCallObject == NULL))
	{
		return(CS_INTERNAL_ERROR);
	}

	if (FAILED(TempResult))
	{
		ISRERROR(ghISRInst,	"linkLayerConnect()	failed on re-connect.",	0);
		linkLayerShutdown(pCallObject->dwPhysicalId);
		CallObjectUnlock(pCallObject);
		return TempResult;
	}

	CallObjectUnlock(pCallObject);

	ISRTRACE(ghISRInst,	"Q931ReOpenConnection()	completed successfully.", 0L);
	return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931GetVersion(
	WORD wLength,
	LPWSTR pszVersion)
{
WCHAR	pszQ931Version[255];

	// parameter validation.
	if ((wLength ==	0) || (pszVersion == NULL))
	{
		return CS_BAD_PARAM;
	}

	wcscpy(pszQ931Version, L"Call Setup	");
	wcscat(pszQ931Version, Unicode(__DATE__));
	wcscat(pszQ931Version, L" ");
	wcscat(pszQ931Version, Unicode(__TIME__));

	if (wcslen(pszQ931Version) >= wLength)
	{
		memcpy(pszVersion, pszQ931Version, (wLength-1)*sizeof(WCHAR));
		pszQ931Version[wLength-1] =	L'\0';
		return CS_BAD_SIZE;
	}

	wcscpy(pszVersion, pszQ931Version);
	return CS_OK;
}

//-	- -	- -	- -	- -	- -	- -	- -	- -	- -	- -	- -	- -	- -	- -	- -	- -	- -	- -	- -	- -	-
// Timer Routines...
//-	- -	- -	- -	- -	- -	- -	- -	- -	- -	- -	- -	- -	- -	- -	- -	- -	- -	- -	- -	- -	-

//====================================================================================
// Timer 301 has expired for this object...
//====================================================================================
void
CallBackT301(P_CALL_OBJECT pCallObject)
{
	CSS_CALL_FAILED	EventData;
	HQ931CALL hQ931Call	= pCallObject->hQ931Call;

	EventData.error	= CS_RINGING_TIMER_EXPIRED;
	pCallObject->Callback(Q931_CALL_FAILED,	pCallObject->hQ931Call,
		pCallObject->dwListenToken,
		pCallObject->dwUserToken, &EventData);

	if (CallObjectValidate(hQ931Call) == CS_OK)
	{
		if (Q931SendReleaseCompleteMessage(pCallObject,
			CC_REJECT_TIMER_EXPIRED, NULL, NULL, NULL) == CS_OK)
		{
			// nothing to do...
		}

		{
			 DWORD dwId	= pCallObject->dwPhysicalId;
			 CallObjectDestroy(pCallObject);
			 linkLayerShutdown(dwId);
		}
	}
	else
	{
		CallEntryUnlock(hQ931Call);
	}
	return;
}

//====================================================================================
// Timer 303 has expired for this object...
//====================================================================================
void
CallBackT303(P_CALL_OBJECT pCallObject)
{
	CSS_CALL_FAILED	EventData;
	HQ931CALL hQ931Call	= pCallObject->hQ931Call;

	EventData.error	= CS_SETUP_TIMER_EXPIRED;
	pCallObject->Callback(Q931_CALL_FAILED,	pCallObject->hQ931Call,
		pCallObject->dwListenToken,
		pCallObject->dwUserToken, &EventData);

	if (CallObjectValidate(hQ931Call) == CS_OK)
	{
		if (Q931SendReleaseCompleteMessage(pCallObject,
			CC_REJECT_TIMER_EXPIRED, NULL, NULL, NULL) == CS_OK)
		{
			// nothing to do...
		}

		{
			 DWORD dwId	= pCallObject->dwPhysicalId;
			 CallObjectDestroy(pCallObject);
			 linkLayerShutdown(dwId);
		}
	}
	else
	{
		CallEntryUnlock(hQ931Call);
	}
	return;
}

//====================================================================================
//====================================================================================
void
Q931SetReceivePDUHook(Q931_RECEIVE_PDU_CALLBACK	Q931ReceivePDUCallback)
{
	gReceivePDUHookProc	= Q931ReceivePDUCallback;
	return;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931FlushSendQueue(
	HQ931CALL hQ931Call)
{
	P_CALL_OBJECT pCallObject =	NULL;
	HRESULT	TempResult = CS_OK;
	DWORD dwPhysicalId;

	if (bQ931Initialized ==	FALSE)
	{
		return CS_NOT_INITIALIZED;
	}

	ISRTRACE(ghISRInst,	"Entering Q931FlushSendQueue()...",	0L);

	// need	parameter checking...
	if ((CallObjectLock(hQ931Call, &pCallObject) !=	CS_OK) || (pCallObject == NULL))
	{
		ISRTRACE(ghISRInst,	"Call Object no	longer available:",	(DWORD)hQ931Call);
		return CS_INTERNAL_ERROR;
	}

	dwPhysicalId = pCallObject->dwPhysicalId;

	CallObjectUnlock(pCallObject);

	TempResult = linkLayerFlushChannel(dwPhysicalId, DATALINK_TRANSMIT);
	if (FAILED(TempResult))
	{
		ISRERROR(ghISRInst,	"datalinkSendRequest() failed",	0L);
	}

	return(TempResult);
}

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\q931.h ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/INCLUDE/VCS/q931.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1996 Intel Corporation.
 *
 *	$Revision:   1.49  $
 *	$Date:   08 Jan 1997 18:02:54  $
 *	$Author:   EHOWARDX  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *		
 *
 *	Notes:
 *
 ***************************************************************************/


#ifndef Q931_H
#define Q931_H


#include "incommon.h"
#include "q931pdu.h"
#include "apierror.h"

#ifdef __cplusplus
extern "C" {
#endif

//====================================================================================
// Q931-specific codes
//====================================================================================

// Status codes
#define CS_OK                               NOERROR
#define CS_BAD_PARAM                        MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0x1)
#define CS_DUPLICATE_LISTEN                 MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0x2)
#define CS_INTERNAL_ERROR                   MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0x3)
#define CS_BAD_SIZE                         MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0x4)
#define CS_NO_MEMORY                        MAKE_Q931_ERROR(ERROR_OUTOFMEMORY)
#define CS_NOT_IMPLEMENTED                  MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0x6)
#define CS_NOT_INITIALIZED                  MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0x7)
#define CS_DUPLICATE_INITIALIZE             MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0x8)
#define CS_SUBSYSTEM_FAILURE                MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0x9)
#define CS_OUT_OF_SEQUENCE                  MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0xA)
#define CS_PEER_UNREACHABLE                 MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0xB)
#define CS_SETUP_TIMER_EXPIRED              MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0xC)
#define CS_RINGING_TIMER_EXPIRED            MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0xD)
#define CS_INCOMPATIBLE_VERSION             MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0xE)

// parsing error cases
#define CS_OPTION_NOT_IMPLEMENTED           MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0xF)
#define CS_ENDOFINPUT                       MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0x10)
#define CS_INVALID_FIELD                    MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0x11)
#define CS_NO_FIELD_DATA                    MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0x12)
#define CS_INVALID_PROTOCOL                 MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0x13)
#define CS_INVALID_MESSAGE_TYPE             MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0x14)
#define CS_MANDATORY_IE_MISSING             MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0x15)
#define CS_BAD_IE_CONTENT                   MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0x16)

// Event codes
#define Q931_CALL_INCOMING                  1
#define Q931_CALL_REMOTE_HANGUP             2
#define Q931_CALL_REJECTED                  3
#define Q931_CALL_ACCEPTED                  4
#define Q931_CALL_RINGING                   5
#define Q931_CALL_FAILED                    6
#define Q931_CALL_CONNECTION_CLOSED         7

// Goal codes
#define CSG_NONE                            0
#define CSG_JOIN                            1
#define CSG_CREATE                          2
#define CSG_INVITE                          3

#define CC_MAX_PARTY_NUMBER_LEN             254

//====================================================================================
// Q931-specific types
//====================================================================================

typedef HRESULT CS_STATUS;
typedef DWORD_PTR HQ931LISTEN, *PHQ931LISTEN;
typedef DWORD_PTR HQ931CALL, *PHQ931CALL;


//====================================================================================
// Callback definitions.
//====================================================================================

typedef DWORD (*Q931_CALLBACK) (BYTE bEvent, HQ931CALL hQ931Call,
    HQ931LISTEN hListenToken, DWORD_PTR dwUserToken, void *pEventData);

typedef BOOL (*Q931_RECEIVE_PDU_CALLBACK) (Q931MESSAGE *pMessage,
    HQ931CALL hQ931Call, DWORD_PTR dwListenToken, DWORD_PTR dwUserToken);

//====================================================================================
// definitions of structures passed to callbacks as parameters.
//====================================================================================

// CSS_CALL_INCOMING callback parameter type
typedef struct
{
    WORD wCallReference;
    WORD wGoal;
    WORD wCallType;
    BOOL bCallerIsMC;
    CC_CONFERENCEID ConferenceID;
    LPWSTR pszCalledPartyNumber;
    PCC_ADDR pSourceAddr;
    PCC_ADDR pCallerAddr;
    PCC_ADDR pCalleeDestAddr;
    PCC_ADDR pLocalAddr;
    PCC_ALIASNAMES pCallerAliasList;
    PCC_ALIASNAMES pCalleeAliasList;
    PCC_ALIASNAMES pExtraAliasList;
    PCC_ALIASITEM pExtensionAliasItem;
    LPWSTR pszDisplay;
    PCC_ENDPOINTTYPE pSourceEndpointType;
    PCC_NONSTANDARDDATA pNonStandardData;
    GUID CallIdentifier;
} CSS_CALL_INCOMING, *PCSS_CALL_INCOMING;

// CSS_CALL_REMOTE_HANGUP callback parameter type
typedef struct
{
    BYTE bReason;
} CSS_CALL_REMOTE_HANGUP, *PCSS_CALL_REMOTE_HANGUP;


// CSS_CALL_REJECTED callback parameter type
typedef struct
{
    BYTE bRejectReason;
    CC_CONFERENCEID ConferenceID;
    PCC_ADDR pAlternateAddr;
    PCC_NONSTANDARDDATA pNonStandardData;
} CSS_CALL_REJECTED, *PCSS_CALL_REJECTED;

// CSS_CALL_ACCEPTED callback parameter type
typedef struct
{
    WORD wCallReference;
    CC_CONFERENCEID ConferenceID;
    PCC_ADDR pCalleeAddr;
    PCC_ADDR pLocalAddr;
    PCC_ADDR pH245Addr;
    LPWSTR pszDisplay;
    PCC_ENDPOINTTYPE pDestinationEndpointType;
    PCC_NONSTANDARDDATA pNonStandardData;
} CSS_CALL_ACCEPTED, *PCSS_CALL_ACCEPTED;

// Q931_CALL_RINGING callback event will have pEventData set to NULL

// CSS_CALL_FAILED callback paremeter type
typedef struct
{
    HRESULT error;
} CSS_CALL_FAILED, *PCSS_CALL_FAILED;

//====================================================================================
// function declarations.
//====================================================================================

CS_STATUS H225Init();
CS_STATUS H225DeInit();

CS_STATUS Q931Init();
CS_STATUS Q931DeInit();

CS_STATUS Q931Listen(
    PHQ931LISTEN phQ931Listen,
    PCC_ADDR pListenAddr,
    DWORD_PTR dwListenToken,
    Q931_CALLBACK ListenCallback);

CS_STATUS Q931CancelListen(
    HQ931LISTEN hQ931Listen);

CS_STATUS Q931PlaceCall(
    PHQ931CALL phQ931Call,
    LPWSTR pszDisplay,
    PCC_ALIASNAMES pCallerAliasList,
    PCC_ALIASNAMES pCalleeAliasList,
    PCC_ALIASNAMES pExtraAliasList,
    PCC_ALIASITEM pExtensionAliasItem,
    PCC_NONSTANDARDDATA pNonStandardData,
    PCC_ENDPOINTTYPE pSourceEndpointType,
    LPWSTR pszCalledPartyNumber,
    PCC_ADDR pControlAddr,
    PCC_ADDR pDestinationAddr,
    PCC_ADDR pSourceAddr,
    BOOL bCallerIsMC,
    CC_CONFERENCEID *pConferenceID,
    WORD wGoal,
    WORD wCallType,
    DWORD_PTR dwUserToken,
    Q931_CALLBACK ConnectCallback,
    WORD wCRV,
    LPGUID pCallIdentifier);

CS_STATUS Q931Hangup(
    HQ931CALL hQ931Call,
    BYTE bReason);

CS_STATUS Q931Ringing(
    HQ931CALL hQ931Call,
    WORD *pwCRV);

CS_STATUS Q931AcceptCall(
    HQ931CALL hQ931Call,
    LPWSTR pszDisplay,
    PCC_NONSTANDARDDATA pNonStandardData,
    PCC_ENDPOINTTYPE pDestinationEndpointType,
    PCC_ADDR pH245Addr,
    DWORD_PTR dwUserToken);

CS_STATUS Q931RejectCall(
    HQ931CALL hQ931Call,
    BYTE bRejectReason,
    PCC_CONFERENCEID pConferenceID,
    PCC_ADDR pAlternateAddr,
    PCC_NONSTANDARDDATA pNonStandardData);

CS_STATUS Q931ReOpenConnection(
    HQ931CALL hQ931Call);

CS_STATUS Q931GetVersion(
    WORD wLength,          // character count, not byte count.
    LPWSTR pszVersion);

CS_STATUS Q931SetAlertingTimeout(
    DWORD dwDuration);

void Q931SetReceivePDUHook(
    Q931_RECEIVE_PDU_CALLBACK Q931ReceivePDUCallback);

CS_STATUS Q931SendProceedingMessage(
    HQ931CALL hQ931Call,
    WORD wCallReference,
    PCC_ENDPOINTTYPE pDestinationEndpointType,
    PCC_NONSTANDARDDATA pNonStandardData);

CS_STATUS Q931SendPDU(
    HQ931CALL hQ931Call,
    BYTE* CodedPtrPDU,
    DWORD CodedLengthPDU);

CS_STATUS Q931FlushSendQueue(
    HQ931CALL hQ931Call);

// utility routines
CS_STATUS Q931ValidateAddr(PCC_ADDR pAddr);
CS_STATUS Q931ValidatePartyNumber(LPWSTR pszPartyNumber);

CS_STATUS Q931ValidateAliasItem(PCC_ALIASITEM pSource);
CS_STATUS Q931CopyAliasItem(PCC_ALIASITEM *ppTarget, PCC_ALIASITEM pSource);
CS_STATUS Q931FreeAliasItem(PCC_ALIASITEM pSource);

CS_STATUS Q931ValidateAliasNames(PCC_ALIASNAMES pSource);
CS_STATUS Q931CopyAliasNames(PCC_ALIASNAMES *ppTarget, PCC_ALIASNAMES pSource);
CS_STATUS Q931FreeAliasNames(PCC_ALIASNAMES pSource);

CS_STATUS Q931ValidateDisplay(LPWSTR pszDisplay);
CS_STATUS Q931CopyDisplay(LPWSTR *ppDest, LPWSTR pSource);
CS_STATUS Q931FreeDisplay(LPWSTR pszDisplay);

CS_STATUS Q931ValidateVendorInfo(PCC_VENDORINFO pVendorInfo);
CS_STATUS Q931CopyVendorInfo(PCC_VENDORINFO *ppDest, PCC_VENDORINFO pSource);
CS_STATUS Q931FreeVendorInfo(PCC_VENDORINFO pVendorInfo);

CS_STATUS Q931ValidateNonStandardData(PCC_NONSTANDARDDATA pNonStandardData);
CS_STATUS Q931CopyNonStandardData(PCC_NONSTANDARDDATA *ppDest, PCC_NONSTANDARDDATA pSource);
CS_STATUS Q931FreeNonStandardData(PCC_NONSTANDARDDATA pNonStandardData);

#ifdef __cplusplus
}
#endif

#endif Q931_H

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\q931pdu.h ===
/****************************************************************************
 *
 *  $Archive:   S:/STURGEON/SRC/INCLUDE/VCS/q931pdu.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *  Copyright (c) 1996 Intel Corporation.
 *
 *  $Revision:   1.11  $
 *  $Date:   22 Jan 1997 17:21:04  $
 *  $Author:   MANDREWS  $
 *
 *  Abstract: Parser routines for Q931 PDUs
 *
 ***************************************************************************/
#ifndef Q931PAR_H
#define Q931PAR_H

#include <winerror.h>
#include "av_asn1.h"

#ifdef __cplusplus
extern "C" {
#endif

struct S_BUFFERDESCR
{
    DWORD Length;
    BYTE *BufferPtr;
};

typedef struct S_BUFFERDESCR BUFFERDESCR;
typedef struct S_BUFFERDESCR *PBUFFERDESCR;

// Mask to extract a message type from a byte
#define MESSAGETYPEMASK 0x7f

typedef BYTE MESSAGEIDTYPE;

// Q931 defined message types
#define ALERTINGMESSAGETYPE      0x01
#define PROCEEDINGMESSAGETYPE    0x02
#define CONNECTMESSAGETYPE       0x07
#define CONNECTACKMESSAGETYPE    0x0F
#define PROGRESSMESSAGETYPE      0x03
#define SETUPMESSAGETYPE         0x05
#define SETUPACKMESSAGETYPE      0x0D

#define RESUMEMESSAGETYPE        0x26
#define RESUMEACKMESSAGETYPE     0x2E
#define RESUMEREJMESSAGETYPE     0x22
#define SUSPENDMESSAGETYPE       0x25
#define SUSPENDACKMESSAGETYPE    0x2D
#define SUSPENDREJMESSAGETYPE    0x21
#define USERINFOMESSAGETYPE      0x20

#define DISCONNECTMESSAGETYPE    0x45
#define RELEASEMESSAGETYPE       0x4D
#define RELEASECOMPLMESSAGETYPE  0x5A
#define RESTARTMESSAGETYPE       0x46
#define RESTARTACKMESSAGETYPE    0x4E

#define SEGMENTMESSAGETYPE       0x60
#define CONGCTRLMESSAGETYPE      0x79
#define INFORMATIONMESSAGETYPE   0x7B
#define NOTIFYMESSAGETYPE        0x6E
#define STATUSMESSAGETYPE        0x7D
#define STATUSENQUIRYMESSAGETYPE 0x75


// Mask to remove only the field identifier from a type 1 single octet field
#define TYPE1IDENTMASK 0xf0

// Mask to remove only the value from a type 1 single octet field
#define TYPE1VALUEMASK 0x0f

// Type of the field identitifiers
typedef BYTE FIELDIDENTTYPE;

// Field identifiers
// Single octet values
#define IDENT_RESERVED        0x80
#define IDENT_SHIFT           0x90
#define IDENT_MORE            0xA0
#define IDENT_SENDINGCOMPLETE 0xA1
#define IDENT_CONGESTION      0xB0
#define IDENT_REPEAT          0xD0

// Variable length octet values
#define IDENT_SEGMENTED       0x00
#define IDENT_BEARERCAP       0x04
#define IDENT_CAUSE           0x08
#define IDENT_CALLIDENT       0x10
#define IDENT_CALLSTATE       0x14
#define IDENT_CHANNELIDENT    0x18
#define IDENT_PROGRESS        0x1E
#define IDENT_PROGRESS2       0x1F
#define IDENT_NETWORKSPEC     0x20
#define IDENT_NOTIFICATION    0x27
#define IDENT_DISPLAY         0x28
#define IDENT_DATE            0x29
#define IDENT_KEYPAD          0x2C
#define IDENT_SIGNAL          0x34
#define IDENT_INFORMATIONRATE 0x40
#define IDENT_ENDTOENDDELAY   0x42
#define IDENT_TRANSITDELAY    0x43
#define IDENT_PLBINARYPARAMS  0x44
#define IDENT_PLWINDOWSIZE    0x45
#define IDENT_PACKETSIZE      0x46
#define IDENT_CLOSEDUG        0x47
#define IDENT_REVCHARGE       0x4A
#define IDENT_CALLINGNUMBER   0x6C
#define IDENT_CALLINGSUBADDR  0x6D
#define IDENT_CALLEDNUMBER    0x70
#define IDENT_CALLEDSUBADDR   0x71
#define IDENT_REDIRECTING     0x74
#define IDENT_TRANSITNET      0x78
#define IDENT_RESTART         0x79
#define IDENT_LLCOMPATIBILITY 0x7C
#define IDENT_HLCOMPATIBILITY 0x7D
#define IDENT_USERUSER        0x7E
   
//-------------------------------------------------------------------
// Structures for messages and information elements
//-------------------------------------------------------------------

typedef BYTE PDTYPE;
#define Q931PDVALUE ((PDTYPE)0x08)

typedef WORD CRTYPE;

// Since right now we don't need to separate out the individual
// parts of the fields of the structures these are the base 
// types from which the fields are made.
// Single octet element type 1 (contains a value)
struct S_SINGLESTRUCT1
{
    BOOLEAN Present;
    BYTE Value;
};

// Single octet element type 2 (does not contain a value)
struct S_SINGLESTRUCT2
{
    BOOLEAN Present;
};

// Variable length element
// Maximum element size
#define MAXVARFIELDLEN 131

struct S_VARSTRUCT
{
    BOOLEAN Present;
    BYTE Length;
    BYTE Contents[MAXVARFIELDLEN];
};

// Right now all of the fields are bound to the simplest
// structures above.  No parsing other than just 
// single octet/variable octet is done.  When the values
// in some of the subfields are important, change the 
// structures here and change the appropriate parsing
// routine to generate the right structure

// The shift element is a single type 1
typedef struct S_SINGLESTRUCT1 SHIFTIE;
typedef struct S_SINGLESTRUCT1 *PSHIFTIE;

// The more data element is a single type 2
typedef struct S_SINGLESTRUCT2 MOREDATAIE;
typedef struct S_SINGLESTRUCT2 *PMOREDATAIE;

// The sending complete element is a single type 2
typedef struct S_SINGLESTRUCT2 SENDCOMPLIE;
typedef struct S_SINGLESTRUCT2 *PSENDCOMPLIE;

// The congestion level element is a single type 1
typedef struct S_SINGLESTRUCT1 CONGESTIONIE;
typedef struct S_SINGLESTRUCT1 *PCONGESTIONIE;

// The repeat indicator element is a single type 1
typedef struct S_SINGLESTRUCT1 REPEATIE;
typedef struct S_SINGLESTRUCT1 *PREPEATIE;

// The segmented element is a variable 
typedef struct S_VARSTRUCT SEGMENTEDIE;
typedef struct S_VARSTRUCT *PSEGMENTEDIE;

// The bearer capability element is a variable 
typedef struct S_VARSTRUCT BEARERCAPIE;
typedef struct S_VARSTRUCT *PBEARERCAPIE;

// The cause element is a variable 
typedef struct S_VARSTRUCT CAUSEIE;
typedef struct S_VARSTRUCT *PCAUSEIE;

// The call identity element is a variable 
typedef struct S_VARSTRUCT CALLIDENTIE;
typedef struct S_VARSTRUCT *PCALLIDENTIE;

// The call state element is a variable 
typedef struct S_VARSTRUCT CALLSTATEIE;
typedef struct S_VARSTRUCT *PCALLSTATEIE;

// The channel identifier element is a variable 
typedef struct S_VARSTRUCT CHANIDENTIE;
typedef struct S_VARSTRUCT *PCHANIDENTIE;

// The progress indicator element is a variable 
typedef struct S_VARSTRUCT PROGRESSIE;
typedef struct S_VARSTRUCT *PPROGRESSIE;

// The network specific element is a variable 
typedef struct S_VARSTRUCT NETWORKIE;
typedef struct S_VARSTRUCT *PNETWORKIE;

// The notification indicator element is a variable 
typedef struct S_VARSTRUCT NOTIFICATIONINDIE;
typedef struct S_VARSTRUCT *PNOTIFICATIONINDIE;

// The display element is a variable 
typedef struct S_VARSTRUCT DISPLAYIE;
typedef struct S_VARSTRUCT *PDISPLAYIE;

// The date element is a variable 
typedef struct S_VARSTRUCT DATEIE;
typedef struct S_VARSTRUCT *PDATEIE;

// The keypad element is a variable 
typedef struct S_VARSTRUCT KEYPADIE;
typedef struct S_VARSTRUCT *PKEYPADIE;

// The signal element is a variable 
typedef struct S_VARSTRUCT SIGNALIE;
typedef struct S_VARSTRUCT *PSIGNALIE;

// The information rate element is a variable 
typedef struct S_VARSTRUCT INFORATEIE;
typedef struct S_VARSTRUCT *PINFORATEIE;

// The end to end transit delay element is a variable 
typedef struct S_VARSTRUCT ENDTOENDDELAYIE;
typedef struct S_VARSTRUCT *PENDTOENDDELAYIE;

// The transit delay element is a variable 
typedef struct S_VARSTRUCT TRANSITDELAYIE;
typedef struct S_VARSTRUCT *PTRANSITDELAYIE;

// The packet layer binary parameters element is a variable 
typedef struct S_VARSTRUCT PLBINARYPARAMSIE;
typedef struct S_VARSTRUCT *PPLBINARYPARAMSIE;

// The packet layer window size element is a variable 
typedef struct S_VARSTRUCT PLWINDOWSIZEIE;
typedef struct S_VARSTRUCT *PPLWINDOWSIZEIE;

// The packet size element is a variable 
typedef struct S_VARSTRUCT PACKETSIZEIE;
typedef struct S_VARSTRUCT *PPACKETSIZEIE;

// The closed user group element is a variable 
typedef struct S_VARSTRUCT CLOSEDUGIE;
typedef struct S_VARSTRUCT *PCLOSEDUGIE;

// The reverse charge indication element is a variable 
typedef struct S_VARSTRUCT REVERSECHARGEIE;
typedef struct S_VARSTRUCT *PREVERSECHARGEIE;

// The calling party number element is a variable 
typedef struct S_VARSTRUCT CALLINGNUMBERIE;
typedef struct S_VARSTRUCT *PCALLINGNUMBERIE;

// The calling party subaddress element is a variable 
typedef struct S_VARSTRUCT CALLINGSUBADDRIE;
typedef struct S_VARSTRUCT *PCALLINGSUBADDRIE;

// The called party subaddress element is a variable 
typedef struct S_VARSTRUCT CALLEDSUBADDRIE;
typedef struct S_VARSTRUCT *PCALLEDSUBADDRIE;

// The redirecting number element is a variable 
typedef struct S_VARSTRUCT REDIRECTINGIE;
typedef struct S_VARSTRUCT *PREDIRECTINGIE;

// The transit network selection element is a variable 
typedef struct S_VARSTRUCT TRANSITNETIE;
typedef struct S_VARSTRUCT *PTRANSITNETIE;

// The restart indicator element is a variable 
typedef struct S_VARSTRUCT RESTARTIE;
typedef struct S_VARSTRUCT *PRESTARTIE;

// The low layer compatibility element is a variable 
typedef struct S_VARSTRUCT LLCOMPATIBILITYIE;
typedef struct S_VARSTRUCT *PLLCOMPATIBILITYIE;

// The higher layer compatibility element is a variable 
typedef struct S_VARSTRUCT HLCOMPATIBILITYIE;
typedef struct S_VARSTRUCT *PHLCOMPATIBILITYIE;

#define Q931_PROTOCOL_X209 ((PDTYPE)0x05)

struct S_VARSTRUCT_UU
{
    BOOLEAN Present;
    BYTE ProtocolDiscriminator;
    WORD UserInformationLength;
    BYTE UserInformation[0x1000];   // 4k bytes should be good for now...
};

// The user to user element is a variable 
typedef struct S_VARSTRUCT_UU USERUSERIE;
typedef struct S_VARSTRUCT_UU *PUSERUSERIE;

struct S_PARTY_NUMBER
{
    BOOLEAN Present;
    BYTE NumberType;
    BYTE NumberingPlan;
    BYTE PartyNumberLength;
    BYTE PartyNumbers[MAXVARFIELDLEN];
};

// The called party number element is a variable 
typedef struct S_PARTY_NUMBER CALLEDNUMBERIE;
typedef struct S_PARTY_NUMBER *PCALLEDNUMBERIE;

// Q932 defined message types
#define FACILITYMESSAGETYPE   0x62
#define IDENT_FACILITY        0x1C
typedef struct S_VARSTRUCT FACILITYIE;
typedef struct S_VARSTRUCT *PFACILITYIE;


// Generic structure for a Q.931 message
struct S_MESSAGE
{
    PDTYPE ProtocolDiscriminator;
    CRTYPE CallReference;
    MESSAGEIDTYPE MessageType;
    SHIFTIE Shift;
    MOREDATAIE MoreData;
    SENDCOMPLIE SendingComplete;
    CONGESTIONIE CongestionLevel;
    REPEATIE RepeatIndicator;
    SEGMENTEDIE SegmentedMessage;
    BEARERCAPIE BearerCapability;
    CAUSEIE Cause;
    CALLIDENTIE CallIdentity;
    CALLSTATEIE CallState;
    CHANIDENTIE ChannelIdentification;
    PROGRESSIE ProgressIndicator;
    NETWORKIE NetworkFacilities;
    NOTIFICATIONINDIE NotificationIndicator;
    DISPLAYIE Display;
    DATEIE Date;
    KEYPADIE Keypad;
    SIGNALIE Signal;
    INFORATEIE InformationRate;
    ENDTOENDDELAYIE EndToEndTransitDelay;
    TRANSITDELAYIE TransitDelay;
    PLBINARYPARAMSIE PacketLayerBinaryParams;
    PLWINDOWSIZEIE PacketLayerWindowSize;
    PACKETSIZEIE PacketSize;
    CLOSEDUGIE ClosedUserGroup;
    REVERSECHARGEIE ReverseChargeIndication;
    CALLINGNUMBERIE CallingPartyNumber;
    CALLINGSUBADDRIE CallingPartySubaddress;
    CALLEDNUMBERIE CalledPartyNumber;
    CALLEDSUBADDRIE CalledPartySubaddress;
    REDIRECTINGIE RedirectingNumber;
    TRANSITNETIE TransitNetworkSelection;
    RESTARTIE RestartIndicator;
    LLCOMPATIBILITYIE LowLayerCompatibility;
    HLCOMPATIBILITYIE HighLayerCompatibility;
    FACILITYIE Facility;
    USERUSERIE UserToUser;
};

typedef struct S_MESSAGE Q931MESSAGE;
typedef struct S_MESSAGE *PQ931MESSAGE;

//-------------------------------------------------------------------
// Single routine for parsing Q931 messages
//-------------------------------------------------------------------
HRESULT
Q931ParseMessage(
    BYTE *CodedBufferPtr,
    DWORD CodedBufferLength,
    PQ931MESSAGE Message);

//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////

//==========================================================
// CAUSE FIELD DEFINITIONS
//==========================================================
#define CAUSE_EXT_BIT                0x80
#define CAUSE_CODING_CCITT           0x00
#define CAUSE_LOCATION_USER          0x00
#define CAUSE_RECOMMENDATION_Q931    0x00

#define CAUSE_VALUE_NORMAL_CLEAR     0x10
#define CAUSE_VALUE_USER_BUSY        0x11
#define CAUSE_VALUE_SECURITY_DENIED  0x12
#define CAUSE_VALUE_NO_ANSWER        0x13   // Callee does not answer
#define CAUSE_VALUE_REJECTED         0x15
#define CAUSE_VALUE_ENQUIRY_RESPONSE 0x1E
#define CAUSE_VALUE_NOT_IMPLEMENTED  0x4F
#define CAUSE_VALUE_INVALID_CRV      0x51
#define CAUSE_VALUE_INVALID_MSG      0x5F
#define CAUSE_VALUE_IE_MISSING       0x60
#define CAUSE_VALUE_IE_CONTENTS      0x64
#define CAUSE_VALUE_TIMER_EXPIRED    0x66

typedef struct _ERROR_MAP
{
    int nErrorCode;
#ifdef UNICODE_TRACE
    LPWSTR pszErrorText;
#else
    LPSTR pszErrorText;
#endif
} ERROR_MAP;

typedef struct _BINARY_STRING
{
    WORD length;
    BYTE *ptr;
} BINARY_STRING;

typedef struct _Q931_SETUP_ASN
{
    BOOL NonStandardDataPresent;
    CC_NONSTANDARDDATA NonStandardData;
    PCC_ALIASNAMES pCallerAliasList;
    PCC_ALIASNAMES pCalleeAliasList;
    PCC_ALIASNAMES pExtraAliasList;
    PCC_ALIASITEM pExtensionAliasItem;
    BOOL SourceAddrPresent;
    BOOL CallerAddrPresent;
    BOOL CalleeAddrPresent;
    BOOL CalleeDestAddrPresent;
    CC_ADDR SourceAddr;                // originating addr
    CC_ADDR CallerAddr;                // gk addr
    CC_ADDR CalleeAddr;                // local addr
    CC_ADDR CalleeDestAddr;            // target destination addr
    WORD wGoal;
    WORD wCallType;
    BOOL bCallerIsMC;
    CC_CONFERENCEID ConferenceID;

    CC_ENDPOINTTYPE EndpointType;
    CC_VENDORINFO VendorInfo;
    GUID CallIdentifier;    // H.225 CallIdentifier
    BYTE bufProductValue[CC_MAX_PRODUCT_LENGTH];
    BYTE bufVersionValue[CC_MAX_VERSION_LENGTH];

} Q931_SETUP_ASN;

typedef struct _Q931_RELEASE_COMPLETE_ASN
{
    BOOL NonStandardDataPresent;
    CC_NONSTANDARDDATA NonStandardData;
    BYTE bReason;
    GUID CallIdentifier;    // H.225 CallIdentifier

} Q931_RELEASE_COMPLETE_ASN;

typedef struct _Q931_CONNECT_ASN
{
    BOOL NonStandardDataPresent;
    CC_NONSTANDARDDATA NonStandardData;
    BOOL h245AddrPresent;
    CC_ADDR h245Addr;
    CC_CONFERENCEID ConferenceID;

    CC_ENDPOINTTYPE EndpointType;
    CC_VENDORINFO VendorInfo;
    GUID CallIdentifier;    // H.225 CallIdentifier

    BYTE bufProductValue[CC_MAX_PRODUCT_LENGTH];
    BYTE bufVersionValue[CC_MAX_VERSION_LENGTH];

} Q931_CONNECT_ASN;

typedef struct _Q931_ALERTING_ASN
{
    BOOL NonStandardDataPresent;
    CC_NONSTANDARDDATA NonStandardData;
    CC_ADDR h245Addr;
    GUID CallIdentifier;    // H.225 CallIdentifier

} Q931_ALERTING_ASN;

typedef struct _Q931_CALL_PROCEEDING_ASN
{
    BOOL NonStandardDataPresent;
    CC_NONSTANDARDDATA NonStandardData;
    CC_ADDR h245Addr;
    GUID CallIdentifier;    // H.225 CallIdentifier

} Q931_CALL_PROCEEDING_ASN;

typedef struct _Q931_FACILITY_ASN
{
    BOOL NonStandardDataPresent;
    CC_NONSTANDARDDATA NonStandardData;
    CC_ADDR AlternativeAddr;
    PCC_ALIASNAMES pAlternativeAliasList;
    CC_CONFERENCEID ConferenceID;
    BOOL ConferenceIDPresent;
    BYTE bReason;
    GUID CallIdentifier;    // H.225 CallIdentifier

} Q931_FACILITY_ASN;


//-------------------------------------------------------------------
// Parsing Routines
//-------------------------------------------------------------------

HRESULT
Q931MakeEncodedMessage(
    PQ931MESSAGE Message,
    BYTE **CodedBufferPtr,
    DWORD *CodedBufferLength);

HRESULT
Q931SetupParseASN(
    ASN1_CODER_INFO *pWorld,
    BYTE *pEncodedBuf,
    DWORD dwEncodedLength,
    Q931_SETUP_ASN *pParsedData);

HRESULT
Q931ReleaseCompleteParseASN(
    ASN1_CODER_INFO *pWorld,
    BYTE *pEncodedBuf,
    DWORD dwEncodedLength,
    Q931_RELEASE_COMPLETE_ASN *pParsedData);

HRESULT
Q931ConnectParseASN(
    ASN1_CODER_INFO *pWorld,
    BYTE *pEncodedBuf,
    DWORD dwEncodedLength,
    Q931_CONNECT_ASN *pParsedData);

HRESULT
Q931AlertingParseASN(
    ASN1_CODER_INFO *pWorld,
    BYTE *pEncodedBuf,
    DWORD dwEncodedLength,
    Q931_ALERTING_ASN *pParsedData);

HRESULT
Q931ProceedingParseASN(
    ASN1_CODER_INFO *pWorld,
    BYTE *pEncodedBuf,
    DWORD dwEncodedLength,
    Q931_CALL_PROCEEDING_ASN *pParsedData);

HRESULT
Q931FacilityParseASN(
    ASN1_CODER_INFO *pWorld,
    BYTE *pEncodedBuf,
    DWORD dwEncodedLength,
    Q931_FACILITY_ASN *pParsedData);

//-------------------------------------------------------------------
// Encoding Routines
//-------------------------------------------------------------------

// routines for the Setup Message:
HRESULT
Q931SetupEncodePDU(
    WORD wCallReference,
    char *pszDisplay,
    char *pszCalledPartyNumber,
    BINARY_STRING *pUserUserData,
    BYTE **CodedBufferPtr,
    DWORD *CodedBufferLength);

HRESULT
Q931SetupEncodeASN(
    PCC_NONSTANDARDDATA pNonStandardData,
    CC_ADDR *pCallerAddr,
    CC_ADDR *pCalleeAddr,
    WORD wGoal,
    WORD wCallType,
    BOOL bCallerIsMC,
    CC_CONFERENCEID *pConferenceID,
    PCC_ALIASNAMES pCallerAliasList,
    PCC_ALIASNAMES pCalleeAliasList,
    PCC_ALIASNAMES pExtraAliasList,
    PCC_ALIASITEM pExtensionAliasItem,
    PCC_VENDORINFO pVendorInfo,
    BOOL bIsTerminal,
    BOOL bIsGateway,
    ASN1_CODER_INFO *pWorld,
    BYTE **ppEncodedBuf,
    DWORD *pdwEncodedLength,
    LPGUID pCallIdentifier);

// routines for the Release Complete Message:
HRESULT
Q931ReleaseCompleteEncodePDU(
    WORD wCallReference,
    BYTE *pbCause,
    BINARY_STRING *pUserUserData,
    BYTE **CodedBufferPtr,
    DWORD *CodedBufferLength);

HRESULT
Q931ReleaseCompleteEncodeASN(
    PCC_NONSTANDARDDATA pNonStandardData,
    CC_CONFERENCEID *pConferenceID, // must be able to support 16 byte conf id's!
    BYTE *pbReason,
    ASN1_CODER_INFO *pWorld,
    BYTE **ppEncodedBuf,
    DWORD *pdwEncodedLength,
    LPGUID pCallIdentifier);

// routines for the Connect Message:
HRESULT
Q931ConnectEncodePDU(
    WORD wCallReference,
    char *pszDisplay,
    BINARY_STRING *pUserUserData,
    BYTE **CodedBufferPtr,
    DWORD *CodedBufferLength);

HRESULT
Q931ConnectEncodeASN(
    PCC_NONSTANDARDDATA pNonStandardData,
    CC_CONFERENCEID *pConferenceID, // must be able to support 16 byte conf id's!
    CC_ADDR *h245Addr,
    PCC_ENDPOINTTYPE pEndpointType,
    ASN1_CODER_INFO *pWorld,
    BYTE **ppEncodedBuf,
    DWORD *pdwEncodedLength,
    LPGUID pCallIdentifier);

// routines for the Alerting Message:
HRESULT
Q931AlertingEncodePDU(
    WORD wCallReference,
    BINARY_STRING *pUserUserData,
    BYTE **CodedBufferPtr,
    DWORD *CodedBufferLength);

HRESULT
Q931AlertingEncodeASN(
    PCC_NONSTANDARDDATA pNonStandardData,
    CC_ADDR *h245Addr,
    PCC_ENDPOINTTYPE pEndpointType,
    ASN1_CODER_INFO *pWorld,
    BYTE **ppEncodedBuf,
    DWORD *pdwEncodedLength,
    LPGUID pCallIdentifier);

// routines for the Proceeding Message:
HRESULT
Q931ProceedingEncodePDU(
    WORD wCallReference,
    BINARY_STRING *pUserUserData,
    BYTE **CodedBufferPtr,
    DWORD *CodedBufferLength);

HRESULT
Q931ProceedingEncodeASN(
    PCC_NONSTANDARDDATA pNonStandardData,
    CC_ADDR *h245Addr,
    PCC_ENDPOINTTYPE pEndpointType,
    ASN1_CODER_INFO *pWorld,
    BYTE **ppEncodedBuf,
    DWORD *pdwEncodedLength,
    LPGUID pCallIdentifier);

HRESULT
Q931FacilityEncodePDU(
    WORD wCallReference,
    BINARY_STRING *pUserUserData,
    BYTE **CodedBufferPtr,
    DWORD *CodedBufferLength);

HRESULT
Q931FacilityEncodeASN(
    PCC_NONSTANDARDDATA pNonStandardData,
    CC_ADDR *AlternativeAddr,
    BYTE bReason,
    CC_CONFERENCEID *pConferenceID,
    PCC_ALIASNAMES pAlternativeAliasList,
    ASN1_CODER_INFO *pWorld,
    BYTE **ppEncodedBuf,
    DWORD *pdwEncodedLength,
    LPGUID pCallIdentifier);

HRESULT
Q931StatusEncodePDU(
    WORD wCallReference,
    char *pszDisplay,
    BYTE bCause,
    BYTE bCallState,
    BYTE **CodedBufferPtr,
    DWORD *CodedBufferLength);

void
Q931FreeEncodedBuffer(ASN1_CODER_INFO *pWorld, BYTE *pEncodedBuf);

#ifdef __cplusplus
}
#endif

#endif Q931PAR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\q931man.c ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/CALLCONT/VCS/q931man.c_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1994 Intel Corporation.
 *
 *	$Revision:   1.138  $
 *	$Date:   04 Mar 1997 09:43:22  $
 *	$Author:   MANDREWS  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *		
 *
 *	Notes:
 *
 ***************************************************************************/

#include "precomp.h"

#include "apierror.h"
#include "incommon.h"
#include "callcont.h"
#include "q931.h"
#include "ccmain.h"
#include "listman.h"
#include "q931man.h"
#include "userman.h"
#include "callman.h"
#include "confman.h"
#include "h245man.h"
#include "linkapi.h"
#include "ccutils.h"


extern CALL_CONTROL_STATE	CallControlState;
extern THREADCOUNT			ThreadCount;
extern CC_CONFERENCEID		InvalidConferenceID;


HRESULT InitQ931Manager()
{
	return CC_OK;
}



HRESULT DeInitQ931Manager()
{
	return CC_OK;
}



DWORD _GenerateListenCallback(		PLISTEN					pListen,
									HQ931CALL				hQ931Call,
									PCSS_CALL_INCOMING		pCallIncomingData)
{
HRESULT						status;
CC_HLISTEN					hListen;
CC_LISTEN_CALLBACK_PARAMS	ListenCallbackParams;
PCALL						pCall;
CC_HCALL					hCall;

	ASSERT(pListen != NULL);
	ASSERT(pCallIncomingData != NULL);

	hListen = pListen->hListen;

	status = AllocAndLockCall(
		&hCall,							// pointer to call handle
		CC_INVALID_HANDLE,				// conference handle
		hQ931Call,						// Q931 call handle
		CC_INVALID_HANDLE,				// Q931 call handle for third party invitor
		pCallIncomingData->pCalleeAliasList,
		pCallIncomingData->pCallerAliasList,
		NULL,							// pPeerExtraAliasNames
		NULL,							// pPeerExtension
		NULL,							// local non-standard data
		pCallIncomingData->pNonStandardData,	// remote non-standard data
		NULL,							// local display value
		pCallIncomingData->pszDisplay,	// remote display value
		pCallIncomingData->pSourceEndpointType->pVendorInfo,// remote vendor info
		pCallIncomingData->pLocalAddr,	// local address
		pCallIncomingData->pCallerAddr,	// connect address
		NULL,							// destination address
		pCallIncomingData->pSourceAddr, // source call signal address
		CALLEE,							// call direction
		pCallIncomingData->bCallerIsMC,
		0,								// user token; user will specify in AcceptRejectCall
		INCOMING,						// initial call state
		&pCallIncomingData->CallIdentifier, // H225 CallIdentifier
		&pCallIncomingData->ConferenceID,	// conference ID
		&pCall);						// pointer to call object

	if (status != CC_OK) {
		UnlockListen(pListen);
		Q931RejectCall(hQ931Call,				// Q931 call handle
					   CC_REJECT_UNDEFINED_REASON,	// reject reason
					   &pCallIncomingData->ConferenceID,
					   NULL,					// alternate address
					   NULL);					// non-standard data
		return 1;
	}	

	// Map from Q.931 goals to Call Control goals
	switch (pCallIncomingData->wGoal) {
		case CSG_JOIN:
			ListenCallbackParams.wGoal = CC_GOAL_JOIN;
			break;
		case CSG_CREATE:
			ListenCallbackParams.wGoal = CC_GOAL_CREATE;
			break;
		case CSG_INVITE:
			ListenCallbackParams.wGoal = CC_GOAL_INVITE;
			break;
	}

	ListenCallbackParams.hCall = hCall;
	ListenCallbackParams.pCallerAliasNames = pCallIncomingData->pCallerAliasList;
	ListenCallbackParams.pCalleeAliasNames = pCallIncomingData->pCalleeAliasList;
	ListenCallbackParams.pNonStandardData = pCallIncomingData->pNonStandardData;
	ListenCallbackParams.pszDisplay = pCallIncomingData->pszDisplay;
	ListenCallbackParams.pVendorInfo = pCallIncomingData->pSourceEndpointType->pVendorInfo;
	ListenCallbackParams.ConferenceID = pCallIncomingData->ConferenceID;
	ListenCallbackParams.pCallerAddr = pCallIncomingData->pCallerAddr;
	ListenCallbackParams.pCalleeAddr = pCallIncomingData->pLocalAddr;
	ListenCallbackParams.dwListenToken = pListen->dwListenToken;

	UnlockCall(pCall);

	// Invoke the user callback -- the listen object is locked during the callback,
	// but the associated call object is unlocked (to prevent deadlock if
	// CC_AcceptCall() or CC_RejectCall() is called during the callback from a
	// different thread, and the callback thread blocks pending completion of
	// CC_AcceptCall() or CC_RejectCall())
	InvokeUserListenCallback(pListen,
							 CC_OK,
							 &ListenCallbackParams);

	// Need to validate the listen handle; the associated object may have been
	// deleted during the user callback by this thread
	if (ValidateListen(hListen) == CC_OK)
		UnlockListen(pListen);

	status = LockCall(hCall, &pCall);
	if ((status == CC_OK) && (pCall->CallState == INCOMING)) {
		UnlockCall(pCall);
		return 0;	// cause a ringing condition to occur
	} else {
		// call object has been deleted, or exists in a non-incoming state
		if (status == CC_OK)
			// call object exists in a non-incoming state; AcceptRejectCall
			// may have been invoked from the user callback
			UnlockCall(pCall);
//                return 1;       // don't cause a ringing condition to occur
	}
			
//        // We should never reach this point
//        ASSERT(0);
	return 1;
}



DWORD _Q931CallIncoming(			HQ931CALL				hQ931Call,
									CC_HLISTEN				hListen,
									PCSS_CALL_INCOMING		pCallIncomingData)
{
HRESULT						status;
PLISTEN						pListen;
PCONFERENCE					pConference;
PCALL						pCall;
CC_HCALL					hCall;

	ASSERT(hListen != CC_INVALID_HANDLE);
	ASSERT(pCallIncomingData != NULL);
	ASSERT(!EqualConferenceIDs(&pCallIncomingData->ConferenceID, &InvalidConferenceID));

	if ((pCallIncomingData->wGoal != CSG_CREATE) &&
		(pCallIncomingData->wGoal != CSG_JOIN) &&
		(pCallIncomingData->wGoal != CSG_INVITE)) {
		Q931RejectCall(hQ931Call,				// Q931 call handle
					   CC_REJECT_UNDEFINED_REASON,	// reject reason
					   &pCallIncomingData->ConferenceID,
					   NULL,					// alternate address
					   NULL);					// non-standard data
		return 1;
	}

	status = LockListen(hListen, &pListen);
	if (status != CC_OK) {
		// the listen was presumably cancelled by the user,
		// but we haven't informed Call Setup yet
		Q931RejectCall(hQ931Call,				// Q931 call handle
			           CC_REJECT_UNDEFINED_REASON,	// reject reason
					   &pCallIncomingData->ConferenceID,
					   NULL,					// alternate address
					   NULL);					// non-standard data
		return 1;
	}

	// Look for wConferenceID in conference list
	status = LockConferenceID(&pCallIncomingData->ConferenceID, &pConference);
	if (status == CC_OK) {
		// We found a matching conference ID
		if ((pConference->bDeferredDelete) &&
			((pConference->bAutoAccept == FALSE) ||
			 ((pConference->tsMultipointController == TS_TRUE) &&
			 (pCallIncomingData->bCallerIsMC == TRUE)))) {
			UnlockListen(pListen);
			UnlockConference(pConference);
			Q931RejectCall(hQ931Call,				// Q931 call handle
						   CC_REJECT_UNDEFINED_REASON,	// reject reason
						   &pCallIncomingData->ConferenceID,
						   NULL,					// alternate address
						   NULL);					// non-standard data
			return 1;
		} else {
			if (pConference->tsMultipointController == TS_TRUE) {
				if ((pCallIncomingData->pCalleeDestAddr == NULL) ||
					((pCallIncomingData->pCalleeDestAddr != NULL) &&
					 (EqualAddrs(pCallIncomingData->pLocalAddr,
					             pCallIncomingData->pCalleeDestAddr)))) {
					switch (pCallIncomingData->wGoal) {
						case CSG_CREATE:
							UnlockListen(pListen);
							UnlockConference(pConference);
							Q931RejectCall(hQ931Call,				// Q931 call handle
										   CC_REJECT_UNDEFINED_REASON,	// reject reason
										   &pCallIncomingData->ConferenceID,
										   NULL,					// alternate address
										   NULL);					// non-standard data
							return 1;
						case CSG_JOIN:
							if ((pConference->bDeferredDelete) &&
								(pConference->bAutoAccept == TRUE)) {
								// Auto accept
								status = AllocAndLockCall(
									&hCall,							// pointer to call handle
									pConference->hConference,		// conference handle
									hQ931Call,						// Q931 call handle
									CC_INVALID_HANDLE,				// Q931 call handle for third party invitor
									pCallIncomingData->pCalleeAliasList,
									pCallIncomingData->pCallerAliasList,
									NULL,							// pPeerExtraAliasNames
									NULL,							// pPeerExtension
									NULL,							// local non-standard data
									pCallIncomingData->pNonStandardData,	// remote non-standard data
									NULL,							// local display value
									pCallIncomingData->pszDisplay,	// remote display value
									pCallIncomingData->pSourceEndpointType->pVendorInfo,// remote vendor info
									pCallIncomingData->pLocalAddr,	// local address
									pCallIncomingData->pCallerAddr,	// connect address
									NULL,							// destination address
									pCallIncomingData->pSourceAddr, // source call signal address
									CALLEE,							// call type
									pCallIncomingData->bCallerIsMC,
									0,								// user token; user will specify in AcceptRejectCall
									INCOMING,						// initial call state
									&pCallIncomingData->CallIdentifier,  // h225 CallIdentifier
									&pCallIncomingData->ConferenceID,	// conference ID
									&pCall);						// pointer to call object

								if (status != CC_OK) {
									UnlockListen(pListen);
									UnlockConference(pConference);
									Q931RejectCall(hQ931Call,				// Q931 call handle
												   CC_REJECT_UNDEFINED_REASON,	// reject reason
												   &pCallIncomingData->ConferenceID,
												   NULL,					// alternate address
												   NULL);					// non-standard data
									return 1;
								}
								
								AcceptCall(pCall, pConference);
								return 1;	// Don't send back a RINGING indication
							} else {
								UnlockConference(pConference);
								return _GenerateListenCallback(pListen,
															   hQ931Call,
															   pCallIncomingData);
							}
						case CSG_INVITE:
							UnlockListen(pListen);
							UnlockConference(pConference);
							Q931RejectCall(hQ931Call,				// Q931 call handle
										   CC_REJECT_IN_CONF,		// reject reason
										   &pCallIncomingData->ConferenceID,
										   NULL,					// alternate address
										   NULL);					// non-standard data
							return 1;
					} // switch (wGoal)
				} else { // connect addr != destination addr
					switch (pCallIncomingData->wGoal) {
						case CSG_CREATE:
						case CSG_JOIN:
							UnlockListen(pListen);
							UnlockConference(pConference);
							Q931RejectCall(hQ931Call,				// Q931 call handle
										   CC_REJECT_UNDEFINED_REASON,	// reject reason
										   &pCallIncomingData->ConferenceID,
										   NULL,					// alternate address
										   NULL);					// non-standard data
							return 1;
						case CSG_INVITE:
							// 3rd party invite
							if (pCallIncomingData->bCallerIsMC == TRUE) {
								UnlockListen(pListen);
								UnlockConference(pConference);
								Q931RejectCall(hQ931Call,				// Q931 call handle
											   CC_REJECT_UNDEFINED_REASON,	// reject reason
											   &pCallIncomingData->ConferenceID,
											   NULL,					// alternate address
											   NULL);					// non-standard data
								return 1;
							}
							status = AllocAndLockCall(
								&hCall,							// pointer to call handle
								pConference->hConference,		// conference handle
								CC_INVALID_HANDLE,				// Q931 call handle
								hQ931Call,						// Q931 call handle for third party invitor
								pCallIncomingData->pCallerAliasList, // local alias names
								pCallIncomingData->pCalleeAliasList, // remote alias names
								NULL,							// pPeerExtraAliasNames
								NULL,							// pPeerExtension
								pCallIncomingData->pNonStandardData, // local non-standard data
								NULL,							// remote non-standard data
								pCallIncomingData->pszDisplay,	// local display value
								NULL,							// remote display value
								NULL,							// remote vendor info
								NULL,							// local address
								pCallIncomingData->pCalleeDestAddr,	// connect address
								pCallIncomingData->pCalleeDestAddr,	// destination address
								pCallIncomingData->pSourceAddr, // source call signal address
								THIRD_PARTY_INTERMEDIARY,			// call type
								TRUE,							// caller (this endpoint) is MC
								0,								// user token; user will specify in AcceptRejectCall
								PLACED,							// initial call state
								&pCallIncomingData->CallIdentifier,  // h225 CallIdentifier
								&pCallIncomingData->ConferenceID,	// conference ID
								&pCall);						// pointer to call object

							if (status != CC_OK) {
								UnlockListen(pListen);
								UnlockConference(pConference);
								Q931RejectCall(hQ931Call,				// Q931 call handle
											   CC_REJECT_UNDEFINED_REASON,	// reject reason
											   &pCallIncomingData->ConferenceID,
											   NULL,					// alternate address
											   NULL);					// non-standard data
								return 1;
							}
							PlaceCall(pCall, pConference);
							UnlockCall(pCall);
							UnlockConference(pConference);
							return 1;	// Don't send back a RINGING indication
					} // switch (wGoal)
				}
			} else { // pConference->tsMultipointController != TS_TRUE
				if ((pCallIncomingData->pCalleeDestAddr == NULL) ||
					((pCallIncomingData->pCalleeDestAddr != NULL) &&
					 (EqualAddrs(pCallIncomingData->pLocalAddr,
					             pCallIncomingData->pCalleeDestAddr)))) {
					switch (pCallIncomingData->wGoal) {
						case CSG_CREATE:
							UnlockListen(pListen);
							UnlockConference(pConference);
							Q931RejectCall(hQ931Call,				// Q931 call handle
										   CC_REJECT_UNDEFINED_REASON,	// reject reason
										   &pCallIncomingData->ConferenceID,
										   NULL,					// alternate address
										   NULL);					// non-standard data
							return 1;
						case CSG_JOIN:
						case CSG_INVITE:
							UnlockConference(pConference);
							return _GenerateListenCallback(pListen,
														   hQ931Call,
														   pCallIncomingData);
					} // switch (wGoal)
				} else { // connect addr != destination addr
					UnlockListen(pListen);
					UnlockConference(pConference);
					Q931RejectCall(hQ931Call,				// Q931 call handle
								   CC_REJECT_UNDEFINED_REASON,	// reject reason
								   &pCallIncomingData->ConferenceID,
								   NULL,					// alternate address
								   NULL);					// non-standard data
					return 1;
				} // connect addr != destination addr
			} // pConference->tsMultipointController != TS_TRUE
		} // Matching conference ID
	} else if (status == CC_BAD_PARAM) {
		// This is OK; it simply means that we did not find a matching conference ID
		if (((pCallIncomingData->pCalleeDestAddr != NULL) &&
			(EqualAddrs(pCallIncomingData->pLocalAddr,
					    pCallIncomingData->pCalleeDestAddr))) ||
		    (pCallIncomingData->pCalleeDestAddr == NULL)) {
				return _GenerateListenCallback(pListen,
											   hQ931Call,
											   pCallIncomingData);
		} else { // connect addr != destination addr
			UnlockListen(pListen);
			Q931RejectCall(hQ931Call,				// Q931 call handle
						   CC_REJECT_UNDEFINED_REASON,	// reject reason
						   &pCallIncomingData->ConferenceID,
						   NULL,					// alternate address
						   NULL);					// non-standard data
			return 1;
		}
	} else { // fatal error in LockConference
		UnlockListen(pListen);
		Q931RejectCall(hQ931Call,				// Q931 call handle
					   CC_REJECT_UNDEFINED_REASON,	// reject reason
					   &pCallIncomingData->ConferenceID,
					   NULL,					// alternate address
					   NULL);					// non-standard data
		return 1;	
	}
	
	// We should never reach this point
	ASSERT(0);
	return 1;
}



DWORD _Q931CallRemoteHangup(		HQ931CALL				hQ931Call,
									CC_HLISTEN				hListen,
									CC_HCALL				hCall)
{
CC_LISTEN_CALLBACK_PARAMS	ListenCallbackParams;
PCALL						pCall;
PLISTEN						pListen;

	if (hCall == CC_INVALID_HANDLE) {
		// Either we've already informed the user of the hangup,
		// or the user has not yet accepted or rejected the incoming
		// call request
		ASSERT(hListen != CC_INVALID_HANDLE);

		if (LockQ931Call(hCall, hQ931Call, &pCall) != CC_OK)
			return 0;

		hCall = pCall->hCall;

		if (pCall->hConference != CC_INVALID_HANDLE) {
			UnlockCall(pCall);
			// XXX -- need bHangupReason
			ProcessRemoteHangup(hCall, hQ931Call, CC_REJECT_NORMAL_CALL_CLEARING);
			return 0;
		}

		if (LockListen(hListen, &pListen) != CC_OK) {
			FreeCall(pCall);
			return 0;
		}

		MarkCallForDeletion(pCall);

		ListenCallbackParams.hCall = pCall->hCall;
		ListenCallbackParams.pCallerAliasNames = pCall->pPeerAliasNames;
		ListenCallbackParams.pCalleeAliasNames = pCall->pLocalAliasNames;
		ListenCallbackParams.pNonStandardData = pCall->pPeerNonStandardData;
		ListenCallbackParams.pszDisplay = pCall->pszPeerDisplay;
		ListenCallbackParams.pVendorInfo = pCall->pPeerVendorInfo;
		ListenCallbackParams.wGoal = CC_GOAL_CREATE;	// igonred in this callback
		ListenCallbackParams.ConferenceID = pCall->ConferenceID;
		ListenCallbackParams.pCallerAddr = pCall->pQ931PeerConnectAddr;
		ListenCallbackParams.pCalleeAddr = pCall->pQ931LocalConnectAddr;
		ListenCallbackParams.dwListenToken = pListen->dwListenToken;

		InvokeUserListenCallback(pListen,
		                         CC_PEER_CANCEL,
								 &ListenCallbackParams);

		// Need to validate the listen and call handles; the associated objects may
		// have been deleted during the user callback by this thread
		if (ValidateListen(hListen) == CC_OK)
			UnlockListen(pListen);
		if (ValidateCallMarkedForDeletion(hCall) == CC_OK)
			FreeCall(pCall);
	} else
		// XXX -- need bHangupReason
		ProcessRemoteHangup(hCall, hQ931Call, CC_REJECT_NORMAL_CALL_CLEARING);

	return 0;
}



DWORD _Q931CallRejected(			HQ931CALL				hQ931Call,
									CC_HCALL				hCall,
									PCSS_CALL_REJECTED		pCallRejectedData)
{
PCALL						pCall;
CC_HCONFERENCE				hConference;
PCONFERENCE					pConference;
HRESULT						status;
CC_CONNECT_CALLBACK_PARAMS	ConnectCallbackParams;
HQ931CALL					hQ931CallInvitor;
CC_ENDPOINTTYPE				SourceEndpointType;
CALLTYPE					CallType;
CC_CONFERENCEID				ConferenceID;
CC_ADDR						SourceAddr;
WORD						wNumCalls;
WORD                        wQ931Goal;
WORD                        wQ931CallType;

	status = LockCall(hCall, &pCall);
	if (status != CC_OK)
		return 0;

	CallType = pCall->CallType;
	ConferenceID = pCall->ConferenceID;

	if ((pCall->hQ931Call != hQ931Call) ||
		((pCall->CallState != PLACED) && (pCall->CallState != RINGING))) {
		// The peer must be in a bad state; we don't expect to receive this message now
		UnlockCall(pCall);
		return 0;
	}

	if (CallType == THIRD_PARTY_INTERMEDIARY) {
		hQ931CallInvitor = pCall->hQ931CallInvitor;
		FreeCall(pCall);
		if (hQ931CallInvitor != CC_INVALID_HANDLE)
			Q931RejectCall(hQ931CallInvitor,
						   pCallRejectedData->bRejectReason,
						   &ConferenceID,
						   NULL,	// alternate address
						   NULL);	// non-standard data
		return 0;
	}

	if (pCall->hConference == CC_INVALID_HANDLE) {
		// Call is not attached to a conference
		FreeCall(pCall);
		return 0;
	}

	UnlockCall(pCall);

	status = LockCallAndConference(hCall, &pCall, &pConference);
	if (status != CC_OK)
		return 0;

	ConnectCallbackParams.pNonStandardData = pCallRejectedData->pNonStandardData;
	ConnectCallbackParams.pszPeerDisplay = NULL;
	ConnectCallbackParams.bRejectReason = pCallRejectedData->bRejectReason;
	ConnectCallbackParams.pTermCapList = NULL;
	ConnectCallbackParams.pH2250MuxCapability = NULL;
	ConnectCallbackParams.pTermCapDescriptors = NULL;	
	ConnectCallbackParams.pLocalAddr = pCall->pQ931LocalConnectAddr;
	if (pCall->pQ931DestinationAddr == NULL)
		ConnectCallbackParams.pPeerAddr = pCall->pQ931PeerConnectAddr;
	else
		ConnectCallbackParams.pPeerAddr = pCall->pQ931DestinationAddr;
	ConnectCallbackParams.pVendorInfo = pCall->pPeerVendorInfo;

	if (pCallRejectedData->bRejectReason == CC_REJECT_ROUTE_TO_MC)
    {
		ConnectCallbackParams.bMultipointConference = TRUE;
        wQ931Goal = CSG_JOIN;
        wQ931CallType = CC_CALLTYPE_N_N;
    }
	else
    {
        // Goal and CallType need to be changed for multipoint support.
		ConnectCallbackParams.bMultipointConference = FALSE;
        wQ931Goal = CSG_CREATE;
        wQ931CallType = CC_CALLTYPE_PT_PT;
    }
	ConnectCallbackParams.pConferenceID = &pCallRejectedData->ConferenceID;
	if (pCallRejectedData->bRejectReason == CC_REJECT_ROUTE_TO_MC)
		ConnectCallbackParams.pMCAddress = pCallRejectedData->pAlternateAddr;
	else
		ConnectCallbackParams.pMCAddress = NULL;
	ConnectCallbackParams.pAlternateAddress = pCallRejectedData->pAlternateAddr;
	ConnectCallbackParams.dwUserToken = pCall->dwUserToken;

	// save a copy of the conference handle; we'll need it to validate
	// the conference object after returning from the user callback
	hConference = pConference->hConference;

	if (((pCallRejectedData->bRejectReason == CC_REJECT_ROUTE_TO_MC) ||
		 (pCallRejectedData->bRejectReason == CC_REJECT_CALL_FORWARDED) ||
		 (pCallRejectedData->bRejectReason == CC_REJECT_ROUTE_TO_GATEKEEPER)) &&
		(EqualConferenceIDs(&pCallRejectedData->ConferenceID, &pCall->ConferenceID)) &&
		(pCallRejectedData->pAlternateAddr != NULL)) {
		// XXX - In order to be H.323 compliant here, we need to re-permission this call
		// through the gatekeeper because:
		// 1. The rerouted call may be going to another gatekeeper zone.
		// 2. The alternate address may be NULL, and we may have to resolve the
		//    alternate alias name list through the gatekeeper
		SourceEndpointType.pVendorInfo = pConference->pVendorInfo;
		SourceEndpointType.bIsTerminal = TRUE;
		SourceEndpointType.bIsGateway = FALSE;

		// Cause our local Q.931 connect address to be placed in the
		// Q.931 setup-UUIE sourceAddress field
		SourceAddr.nAddrType = CC_IP_BINARY;
		SourceAddr.bMulticast = FALSE;
		SourceAddr.Addr.IP_Binary.dwAddr = 0;
		SourceAddr.Addr.IP_Binary.wPort = 0;

		status = Q931PlaceCall(&pCall->hQ931Call,			// Q931 call handle
			                   pCall->pszLocalDisplay,
			                   pCall->pLocalAliasNames,
							   pCall->pPeerAliasNames,
                               pCall->pPeerExtraAliasNames,	// pExtraAliasList
                               pCall->pPeerExtension,		// pExtensionAliasItem
			                   pCall->pLocalNonStandardData,// non-standard data
							   &SourceEndpointType,
                               NULL,						// pszCalledPartyNumber
							   pCallRejectedData->pAlternateAddr, // connect address
							   pCall->pQ931DestinationAddr,	// destination address
							   NULL,						// source address
							   FALSE,						// bIsMC
							   &pCall->ConferenceID,		// conference ID
							   wQ931Goal,					// goal
							   wQ931CallType,				// call type
							   hCall,						// user token
							   (Q931_CALLBACK)Q931Callback,	// callback
#ifdef GATEKEEPER
                               pCall->GkiCall.usCRV,        // CRV
                               &pCall->CallIdentifier);     // H.225 CallIdentifier
#else
                               0,                           // CRV
                               &pCall->CallIdentifier);     // H.225 CallIdentifier
#endif GATEKEEPER
		if (status != CS_OK) {
			MarkCallForDeletion(pCall);
			InvokeUserConferenceCallback(pConference,
										 CC_CONNECT_INDICATION,
										 status,
										 &ConnectCallbackParams);

			if (ValidateCallMarkedForDeletion(hCall) == CC_OK)
				FreeCall(pCall);

			if (ValidateConference(hConference) != CC_OK)
				return 0;

			for ( ; ; ) {
				// Start up an enqueued call, if one exists
				status = RemoveEnqueuedCallFromConference(pConference, &hCall);
				if ((status != CC_OK) || (hCall == CC_INVALID_HANDLE))
					break;

				status = LockCall(hCall, &pCall);
				if (status == CC_OK) {
					pCall->CallState = PLACED;

					status = PlaceCall(pCall, pConference);
					UnlockCall(pCall);
					if (status == CC_OK)
						break;
				}
			}
			return 0;
		}
		UnlockCall(pCall);
		UnlockConference(pConference);
		return 0;
	}

	MarkCallForDeletion(pCall);

	if ((CallType == CALLER) || (CallType == THIRD_PARTY_INVITOR) ||
		((CallType == CALLEE) && (pConference->LocalEndpointAttached == NEVER_ATTACHED))) {
		InvokeUserConferenceCallback(pConference,
									 CC_CONNECT_INDICATION,
									 CC_PEER_REJECT,
									 &ConnectCallbackParams);
	}
	
	if (ValidateCallMarkedForDeletion(hCall) == CC_OK)
		FreeCall(pCall);

	// Need to validate conference handle; the associated object may
	// have been deleted during the user callback in this thread
	if (ValidateConference(hConference) != CC_OK)
		return 0;

	for ( ; ; ) {
		// Start up an enqueued call, if one exists
		status = RemoveEnqueuedCallFromConference(pConference, &hCall);
		if ((status != CC_OK) || (hCall == CC_INVALID_HANDLE))
			break;

		status = LockCall(hCall, &pCall);
		if (status == CC_OK) {
			pCall->CallState = PLACED;

			status = PlaceCall(pCall, pConference);
			UnlockCall(pCall);
			if (status == CC_OK)
				break;
		}
	}
	
	EnumerateCallsInConference(&wNumCalls, NULL, pConference, REAL_CALLS);

	if (wNumCalls == 0) {
		if (pConference->bDeferredDelete) {
			ASSERT(pConference->LocalEndpointAttached == DETACHED);
			FreeConference(pConference);
		} else {
			if ((pConference->ConferenceMode != MULTIPOINT_MODE) ||
				(pConference->tsMultipointController != TS_TRUE))
				ReInitializeConference(pConference);
			UnlockConference(pConference);
		}
	} else {
		UnlockConference(pConference);
	}
	return 0;
}



DWORD _Q931CallAccepted(			HQ931CALL				hQ931Call,
									CC_HCALL				hCall,
									PCSS_CALL_ACCEPTED		pCallAcceptedData)
{
HRESULT						status;
PCALL						pCall;
CC_HCONFERENCE				hConference;
PCONFERENCE					pConference;
CC_CONNECT_CALLBACK_PARAMS	ConnectCallbackParams;
BYTE						bTerminalType;
BOOL						bMultipointConference;
CALLTYPE					CallType;
HQ931CALL					hQ931CallInvitor;
H245_INST_T					H245Instance;
DWORD                       dwLinkLayerPhysicalId;

	status = LockCallAndConference(hCall, &pCall, &pConference);
	if (status != CC_OK)
		return 0;

	CallType = pCall->CallType;
	hConference = pConference->hConference;
	hQ931Call = pCall->hQ931Call;
	hQ931CallInvitor = pCall->hQ931CallInvitor;

	ASSERT((pCall->hQ931Call == hQ931Call) || (pCall->hQ931CallInvitor == hQ931Call));

	if ((pConference->ConferenceMode == POINT_TO_POINT_MODE) ||
		(pConference->ConferenceMode == MULTIPOINT_MODE))
		bMultipointConference = TRUE;
	else
		bMultipointConference = FALSE;

	// Initialize ConnectCallbackParams
	ConnectCallbackParams.pNonStandardData = pCallAcceptedData->pNonStandardData;
	ConnectCallbackParams.pszPeerDisplay = pCallAcceptedData->pszDisplay;
	ConnectCallbackParams.bRejectReason = CC_REJECT_UNDEFINED_REASON;	// field ignored
	ConnectCallbackParams.pTermCapList = NULL;
	ConnectCallbackParams.pH2250MuxCapability = NULL;
	ConnectCallbackParams.pTermCapDescriptors = NULL;
	ConnectCallbackParams.pLocalAddr = pCall->pQ931LocalConnectAddr;
	ConnectCallbackParams.pPeerAddr = pCallAcceptedData->pCalleeAddr;
	ConnectCallbackParams.pVendorInfo = pCall->pPeerVendorInfo;
	ConnectCallbackParams.bMultipointConference = bMultipointConference;
	ConnectCallbackParams.pConferenceID = &pConference->ConferenceID;
	ConnectCallbackParams.pMCAddress = pConference->pMultipointControllerAddr;
	ConnectCallbackParams.pAlternateAddress = NULL;
	ConnectCallbackParams.dwUserToken = pCall->dwUserToken;

	if (pCallAcceptedData->pCalleeAddr) {
		// Set pCall->pQ931DestinationAddr to the destination address that we got from Q931.
		// Note that we may not current have a destination address (if the client didn't
		// specify one), or we may currently have a destination address	in domain name format
		// which we need to change to binary format
		if (pCall->pQ931DestinationAddr == NULL)
			pCall->pQ931DestinationAddr = (PCC_ADDR)MemAlloc(sizeof(CC_ADDR));
		if (pCall->pQ931DestinationAddr != NULL)
			*pCall->pQ931DestinationAddr = *pCallAcceptedData->pCalleeAddr;
	}

	if ((!EqualConferenceIDs(&pConference->ConferenceID, &InvalidConferenceID)) &&
		(!EqualConferenceIDs(&pConference->ConferenceID, &pCallAcceptedData->ConferenceID))) {

		MarkCallForDeletion(pCall);

		if (CallType == THIRD_PARTY_INTERMEDIARY) {
			if (hQ931CallInvitor != CC_INVALID_HANDLE)
				Q931RejectCall(hQ931CallInvitor,
							   CC_REJECT_UNDEFINED_REASON,
							   &pCallAcceptedData->ConferenceID,
							   NULL,	// alternate address
							   pCallAcceptedData->pNonStandardData);
		} else {
			if ((CallType == CALLER) || (CallType == THIRD_PARTY_INVITOR) ||
			    ((CallType == CALLEE) && (pConference->LocalEndpointAttached == NEVER_ATTACHED)))
				InvokeUserConferenceCallback(pConference,
											 CC_CONNECT_INDICATION,
											 CC_INTERNAL_ERROR,
											 &ConnectCallbackParams);
		}
		if (ValidateCallMarkedForDeletion(hCall) == CC_OK)
			FreeCall(pCall);
		if (ValidateConference(hConference) == CC_OK)
			UnlockConference(pConference);
		Q931Hangup(hQ931Call, CC_REJECT_UNDEFINED_REASON);
		return 0;
	}

	pConference->ConferenceID = pCallAcceptedData->ConferenceID;
	pCall->ConferenceID = pCallAcceptedData->ConferenceID;
	// Copy the newly-supplied peer address into the call object.
	// This is preferable if the original peer address was in IP dot
	// or domain name format
	if (CallType != THIRD_PARTY_INVITOR) {
		if (pCallAcceptedData->pCalleeAddr != NULL) {
			if (pCall->pQ931DestinationAddr == NULL)
				pCall->pQ931DestinationAddr = (PCC_ADDR)MemAlloc(sizeof(CC_ADDR));
			if (pCall->pQ931DestinationAddr != NULL)
				*pCall->pQ931DestinationAddr = *pCallAcceptedData->pCalleeAddr;
		}
		
		if (pCallAcceptedData->pLocalAddr != NULL) {
			if (pCall->pQ931LocalConnectAddr == NULL)
				pCall->pQ931LocalConnectAddr = (PCC_ADDR)MemAlloc(sizeof(CC_ADDR));
			if (pCall->pQ931LocalConnectAddr != NULL)
				*pCall->pQ931LocalConnectAddr = *pCallAcceptedData->pLocalAddr;
		}
	}

	ASSERT(pCall->pPeerNonStandardData == NULL);
	CopyNonStandardData(&pCall->pPeerNonStandardData,
		                pCallAcceptedData->pNonStandardData);

	ASSERT(pCall->pszPeerDisplay == NULL);
	CopyDisplay(&pCall->pszPeerDisplay,
		        pCallAcceptedData->pszDisplay);

	ASSERT(pCall->pPeerVendorInfo == NULL);
	CopyVendorInfo(&pCall->pPeerVendorInfo,
	               pCallAcceptedData->pDestinationEndpointType->pVendorInfo);

	if (CallType == THIRD_PARTY_INVITOR) {
		pCall->CallState = CALL_COMPLETE;
		ConnectCallbackParams.pPeerAddr = pCall->pQ931DestinationAddr;
		MarkCallForDeletion(pCall);
		InvokeUserConferenceCallback(pConference,
									 CC_CONNECT_INDICATION,
									 CC_OK,
									 &ConnectCallbackParams);
		if (ValidateCallMarkedForDeletion(hCall) == CC_OK)
			FreeCall(pCall);
		if (ValidateConference(hConference) == CC_OK)
			UnlockConference(pConference);
		return 0;
	}

	pCall->CallState = TERMCAP;

	status = MakeH245PhysicalID(&pCall->dwH245PhysicalID);
	if (status != CC_OK) {
		
		MarkCallForDeletion(pCall);

		if (CallType == THIRD_PARTY_INTERMEDIARY) {
			if (hQ931CallInvitor != CC_INVALID_HANDLE)
				Q931RejectCall(hQ931CallInvitor,
							   CC_REJECT_UNDEFINED_REASON,
							   &pCallAcceptedData->ConferenceID,
							   NULL,	// alternate address
							   pCallAcceptedData->pNonStandardData);
		} else {
			if ((CallType == CALLER) || (CallType == THIRD_PARTY_INVITOR) ||
			    ((CallType == CALLEE) && (pConference->LocalEndpointAttached == NEVER_ATTACHED)))
				InvokeUserConferenceCallback(pConference,
											 CC_CONNECT_INDICATION,
											 status,
											 &ConnectCallbackParams);
		}
		Q931Hangup(hQ931Call, CC_REJECT_UNDEFINED_REASON);
		if (ValidateCallMarkedForDeletion(hCall) == CC_OK)
			FreeCall(pCall);
		if (ValidateConference(hConference) == CC_OK)
			UnlockConference(pConference);
		return 0;
	}

    //MULTITHREAD
    //Use a tmp ID so we don't clobber the chosen H245Id.
    //   H245Id=>
    //   <= linkLayerId
    dwLinkLayerPhysicalId = INVALID_PHYS_ID;

	SetTerminalType(pConference->tsMultipointController, &bTerminalType);
	pCall->H245Instance = H245Init(H245_CONF_H323,
                                   pCall->dwH245PhysicalID,
                                   &dwLinkLayerPhysicalId,
								   hCall,
								   (H245_CONF_IND_CALLBACK_T)H245Callback,
								   bTerminalType);
	if (pCall->H245Instance == H245_INVALID_ID) {
		MarkCallForDeletion(pCall);
		if (CallType == THIRD_PARTY_INTERMEDIARY) {
			if (hQ931CallInvitor != CC_INVALID_HANDLE)
				Q931RejectCall(hQ931CallInvitor,
							   CC_REJECT_UNDEFINED_REASON,
							   &pCallAcceptedData->ConferenceID,
							   NULL,	// alternate address
							   pCallAcceptedData->pNonStandardData);
		} else {
			if ((CallType == CALLER) || (CallType == THIRD_PARTY_INVITOR) ||
			    ((CallType == CALLEE) && (pConference->LocalEndpointAttached == NEVER_ATTACHED)))
				InvokeUserConferenceCallback(pConference,
											 CC_CONNECT_INDICATION,
											 CC_INTERNAL_ERROR,
											 &ConnectCallbackParams);
		}
		Q931Hangup(hQ931Call, CC_REJECT_UNDEFINED_REASON);
		if (ValidateCallMarkedForDeletion(hCall) == CC_OK)
			FreeCall(pCall);
		if (ValidateConference(hConference) == CC_OK)
			UnlockConference(pConference);
		return 0;
	}

	H245Instance = pCall->H245Instance;

	// XXX -- need to define connect callback routine
    // Send in the Id we got back from H245Init.
    status = linkLayerConnect(dwLinkLayerPhysicalId,
		                      pCallAcceptedData->pH245Addr,
							  NULL);
	if (status != NOERROR) {

		MarkCallForDeletion(pCall);

		if (CallType == THIRD_PARTY_INTERMEDIARY) {
			if (hQ931CallInvitor != CC_INVALID_HANDLE)
				Q931RejectCall(hQ931CallInvitor,
							   CC_REJECT_UNDEFINED_REASON,
							   &pCallAcceptedData->ConferenceID,
							   NULL,	// alternate address
							   pCallAcceptedData->pNonStandardData);
		} else {
			if ((CallType == CALLER) || (CallType == THIRD_PARTY_INVITOR) ||
			    ((CallType == CALLEE) && (pConference->LocalEndpointAttached == NEVER_ATTACHED)))
				InvokeUserConferenceCallback(pConference,
											 CC_CONNECT_INDICATION,
											 status,
											 &ConnectCallbackParams);
		}
		H245ShutDown(H245Instance);
		Q931Hangup(hQ931Call, CC_REJECT_UNDEFINED_REASON);
		if (ValidateCallMarkedForDeletion(hCall) == CC_OK)
			FreeCall(pCall);
		if (ValidateConference(hConference) == CC_OK)
			UnlockConference(pConference);
		return 0;
	}

	pCall->bLinkEstablished = TRUE;

	status = SendTermCaps(pCall, pConference);
	if (status != CC_OK) {

		MarkCallForDeletion(pCall);

		if (CallType == THIRD_PARTY_INTERMEDIARY) {
			if (hQ931CallInvitor != CC_INVALID_HANDLE)
				Q931RejectCall(hQ931CallInvitor,
							   CC_REJECT_UNDEFINED_REASON,
							   &pCallAcceptedData->ConferenceID,
							   NULL,	// alternate address
							   pCallAcceptedData->pNonStandardData);
		} else {
			if ((CallType == CALLER) || (CallType == THIRD_PARTY_INVITOR) ||
			    ((CallType == CALLEE) && (pConference->LocalEndpointAttached == NEVER_ATTACHED)))
				InvokeUserConferenceCallback(pConference,
											 CC_CONNECT_INDICATION,
											 CC_NO_MEMORY,
											 &ConnectCallbackParams);
		}
		H245ShutDown(H245Instance);
		Q931Hangup(hQ931Call, CC_REJECT_UNDEFINED_REASON);
		if (ValidateCallMarkedForDeletion(hCall) == CC_OK)
			FreeCall(pCall);
		if (ValidateConference(hConference) == CC_OK)
			UnlockConference(pConference);
		return 0;
	}
	
	pCall->OutgoingTermCapState = AWAITING_ACK;

	if (pCall->MasterSlaveState == MASTER_SLAVE_NOT_STARTED) {
		status = H245InitMasterSlave(pCall->H245Instance,
			                         pCall->H245Instance);	// returned as dwTransId in the callback
		if (status != H245_ERROR_OK) {

			MarkCallForDeletion(pCall);

			if (CallType == THIRD_PARTY_INTERMEDIARY) {
				if (hQ931CallInvitor != CC_INVALID_HANDLE)
					Q931RejectCall(hQ931CallInvitor,
								   CC_REJECT_UNDEFINED_REASON,
								   &pCallAcceptedData->ConferenceID,
								   NULL,	// alternate address
								   pCallAcceptedData->pNonStandardData);
			} else {
				if ((CallType == CALLER) || (CallType == THIRD_PARTY_INVITOR) ||
			        ((CallType == CALLEE) && (pConference->LocalEndpointAttached == NEVER_ATTACHED)))
					InvokeUserConferenceCallback(pConference,
												 CC_CONNECT_INDICATION,
												 status,
												 &ConnectCallbackParams);
			}
			H245ShutDown(H245Instance);
			Q931Hangup(hQ931Call, CC_REJECT_UNDEFINED_REASON);
			if (ValidateCallMarkedForDeletion(hCall) == CC_OK)
				FreeCall(pCall);
			if (ValidateConference(hConference) == CC_OK)
				UnlockConference(pConference);
			return 0;
		}
		pCall->MasterSlaveState = MASTER_SLAVE_IN_PROGRESS;
	}

	UnlockConference(pConference);
	UnlockCall(pCall);
	return 0;
}



DWORD _Q931CallRinging(				HQ931CALL				hQ931Call,
									CC_HCALL				hCall)
{
PCALL						pCall;
CC_HCONFERENCE				hConference;
PCONFERENCE					pConference;
HRESULT						status;
CC_RINGING_CALLBACK_PARAMS	RingingCallbackParams;
CC_CONFERENCEID				ConferenceID;

	status = LockCallAndConference(hCall, &pCall, &pConference);
	if (status != CC_OK) {
		Q931RejectCall(hQ931Call,				// Q931 call handle
		               CC_REJECT_UNDEFINED_REASON,	// reject reason
					   NULL,					// conference ID
					   NULL,					// alternate address
					   NULL);					// non-standard data
		return 0;
	}

	ConferenceID = pCall->ConferenceID;

	if ((pCall->hQ931Call != hQ931Call) || (pCall->CallState != PLACED)) {
		// The peer must be in a bad state; we don't expect to receive this message now
		UnlockCall(pCall);
		return 0;
	}

	pCall->CallState = RINGING;

	if (pCall->CallType == THIRD_PARTY_INTERMEDIARY) {
		// Send "ringing" indication to pCall->hQ931CallInvitor
		Q931Ringing(pCall->hQ931CallInvitor,
			        NULL);	// pCRV
		UnlockConference(pConference);
		UnlockCall(pCall);
		return 0;
	}

	RingingCallbackParams.pNonStandardData = NULL;
	RingingCallbackParams.dwUserToken = pCall->dwUserToken;

	// save a copy of the conference handle; we'll need it to validate
	// the conference object after returning from the user callback
	hConference = pConference->hConference;

	InvokeUserConferenceCallback(pConference,
		                         CC_RINGING_INDICATION,
								 CC_OK,
								 &RingingCallbackParams);
	
	// Need to validate conference and call handles; the associated objects may
	// have been deleted during the user callback in this thread
	if (ValidateConference(hConference) == CC_OK)
		UnlockConference(pConference);
	if (ValidateCall(hCall) == CC_OK)
		UnlockCall(pCall);
	return 0;
}



DWORD _Q931CallFailed(				HQ931CALL				hQ931Call,
									CC_HCALL				hCall,
									PCSS_CALL_FAILED		pCallFailedData)
{
PCALL						pCall;
CC_HCONFERENCE				hConference;
PCONFERENCE					pConference;
HQ931CALL					hQ931CallInvitor;
HRESULT						status;
CC_CONNECT_CALLBACK_PARAMS	ConnectCallbackParams;
CALLTYPE					CallType;
CC_CONFERENCEID				ConferenceID;
WORD						wNumCalls;

	status = LockCallAndConference(hCall, &pCall, &pConference);
	if (status != CC_OK)
		return 0;

	CallType = pCall->CallType;
	ConferenceID = pCall->ConferenceID;

	if (pCall->hQ931Call != hQ931Call) {
		UnlockConference(pConference);
		UnlockCall(pCall);
		return 0;
	}

	if (CallType == THIRD_PARTY_INTERMEDIARY) {
		hQ931CallInvitor = pCall->hQ931CallInvitor;
		FreeCall(pCall);
		UnlockConference(pConference);
		if (hQ931CallInvitor != CC_INVALID_HANDLE)
			Q931RejectCall(hQ931CallInvitor,
						   CC_REJECT_UNREACHABLE_DESTINATION,
						   &ConferenceID,
						   NULL,	// alternate address
						   NULL);	// non-standard data
		return 0;
	}

	ConnectCallbackParams.pNonStandardData = NULL;
	ConnectCallbackParams.pszPeerDisplay = NULL;
	ConnectCallbackParams.bRejectReason = CC_REJECT_UNREACHABLE_DESTINATION;
	ConnectCallbackParams.pTermCapList = NULL;
	ConnectCallbackParams.pH2250MuxCapability = NULL;
	ConnectCallbackParams.pTermCapDescriptors = NULL;	
	ConnectCallbackParams.pLocalAddr = pCall->pQ931LocalConnectAddr;
 	if (pCall->pQ931DestinationAddr == NULL)
		ConnectCallbackParams.pPeerAddr = pCall->pQ931PeerConnectAddr;
	else
		ConnectCallbackParams.pPeerAddr = pCall->pQ931DestinationAddr;
	ConnectCallbackParams.pVendorInfo = pCall->pPeerVendorInfo;
	ConnectCallbackParams.bMultipointConference = FALSE;
	ConnectCallbackParams.pConferenceID = &pConference->ConferenceID;
	ConnectCallbackParams.pMCAddress = NULL;
	ConnectCallbackParams.pAlternateAddress = NULL;
	ConnectCallbackParams.dwUserToken = pCall->dwUserToken;

	// save a copy of the conference handle; we'll need it to validate
	// the conference object after returning from the user callback
	hConference = pConference->hConference;

	MarkCallForDeletion(pCall);

	if ((CallType == CALLER) || (CallType == THIRD_PARTY_INVITOR) ||
	    ((CallType == CALLEE) && (pConference->LocalEndpointAttached == NEVER_ATTACHED))) {
		InvokeUserConferenceCallback(pConference,
									 CC_CONNECT_INDICATION,
									 pCallFailedData->error,
									 &ConnectCallbackParams);
	}
	if (ValidateCallMarkedForDeletion(hCall) == CC_OK)
		FreeCall(pCall);
	// Need to validate conference handle; the associated object may
	// have been deleted during the user callback in this thread
	if (ValidateConference(hConference) != CC_OK)
		return 0;

	for ( ; ; ) {
		// Start up an enqueued call, if one exists
		status = RemoveEnqueuedCallFromConference(pConference, &hCall);
		if ((status != CC_OK) || (hCall == CC_INVALID_HANDLE))
			break;

		status = LockCall(hCall, &pCall);
		if (status == CC_OK) {
			pCall->CallState = PLACED;

			status = PlaceCall(pCall, pConference);
			UnlockCall(pCall);
			if (status == CC_OK)
				break;
		}
	}

	EnumerateCallsInConference(&wNumCalls, NULL, pConference, REAL_CALLS);

	if (wNumCalls == 0) {
		if (pConference->bDeferredDelete) {
			ASSERT(pConference->LocalEndpointAttached == DETACHED);
			FreeConference(pConference);
		} else {
			if ((pConference->ConferenceMode != MULTIPOINT_MODE) ||
				(pConference->tsMultipointController != TS_TRUE))
				ReInitializeConference(pConference);
			UnlockConference(pConference);
		}
	} else {
		UnlockConference(pConference);
	}
	return 0;
}



DWORD _Q931CallConnectionClosed(	HQ931CALL				hQ931Call,
									CC_HCALL				hCall)
{
	return 0;
}



DWORD Q931Callback(					BYTE					bEvent,
									HQ931CALL				hQ931Call,
									DWORD_PTR				dwListenToken,
									DWORD_PTR				dwUserToken,
									void *					pEventData)
{
DWORD	dwStatus;

	EnterCallControl();

	if (CallControlState != OPERATIONAL_STATE)
		DWLeaveCallControl(0);

	switch (bEvent) {
		case Q931_CALL_INCOMING:
			dwStatus = _Q931CallIncoming(hQ931Call, (CC_HLISTEN)dwListenToken,
				                         (PCSS_CALL_INCOMING)pEventData);
			break;

		case Q931_CALL_REMOTE_HANGUP:
			dwStatus = _Q931CallRemoteHangup(hQ931Call, (CC_HLISTEN)dwListenToken,
				                             (CC_HCALL)dwUserToken);
			break;

		case Q931_CALL_REJECTED:
			dwStatus =  _Q931CallRejected(hQ931Call, (CC_HCALL)dwUserToken,
				                          (PCSS_CALL_REJECTED)pEventData);
			break;

		case Q931_CALL_ACCEPTED:
			dwStatus =  _Q931CallAccepted(hQ931Call, (CC_HCALL)dwUserToken,
				                          (PCSS_CALL_ACCEPTED)pEventData);
			break;

		case Q931_CALL_RINGING:
			dwStatus =  _Q931CallRinging(hQ931Call, (CC_HCALL)dwUserToken);
			break;

		case Q931_CALL_FAILED:
			dwStatus = _Q931CallFailed(hQ931Call, (CC_HCALL)dwUserToken,
				                       (PCSS_CALL_FAILED)pEventData);
			break;

		case Q931_CALL_CONNECTION_CLOSED:
			dwStatus = _Q931CallConnectionClosed(hQ931Call, (CC_HCALL)dwUserToken);
			break;

		default:
			ASSERT(0);
			dwStatus = 0;
			break;
	}
	DWLeaveCallControl(dwStatus);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\q931plog.h ===
/***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************/

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
// AUTHOR    Tony Moy, Stacy Bell
//
// DESCRIPTION
//		This file contains protocol logging definitions needed by Q931 and
//		the Q931 PDU logging class.
//
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

// This define identifies the Q931 protocol as the one to be logged.  In the 
// Q931 code, it is used only in the InteorpLoad() call.  
// For example:  Q931Logger = InteropLoad( Q931LOG_PROTOCOL );
//

#define Q931LOG_PROTOCOL "Q931_PDU"

// PDU encoding type flags and PDU type flags.  These flags are passed from
// Q931 to the logging via user data.  Bit zero of the user data represents
// whether the PDU was sent or received.
//

#define Q931LOG_SENT_PDU        1UL
#define Q931LOG_RECEIVED_PDU    0UL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\q931pdu.c ===
/****************************************************************************
 *
 *    $Archive:   S:/STURGEON/SRC/Q931/VCS/q931pdu.c_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *    Copyright (c) 1996 Intel Corporation.
 *
 *    $Revision:   1.67.1.0  $
 *    $Date:   17 Mar 1997 19:44:52  $
 *    $Author:   MANDREWS  $
 *
 *    Deliverable:
 *
 *    Abstract: Parser routines for Q931 PDUs
 *
 *    Notes:
 *
 ***************************************************************************/
#pragma comment (exestr, "$Workfile:   q931pdu.c  $ $Revision:   1.67.1.0  $")

// [ ]  Do another integration of own q931test area.
// [ ]  Alias values displayed in tracing routines.
// - - - -  -  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
// STANDARDS ISSUES
// - - - -  -  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
// [ ]  !!! EndpointType contains MC info, so Setup_UUIE doesnt need MC field !!!
// [ ]  !!! Need to decide how CallType is to be used !!!
// [ ]  !!! ALERTING message is missing the ConferenceID field !!!
// [ ]  !!! Place needed for Caller and Callee transport addr, or else explanation of how this information is available round-trip !!!
// [ ]  !!! FACILITY message is missing the protocolIdentifier field !!!

//------------------------------------------------------------------------------
// Note:  These parsing details have not yet been supported:
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// 1) variable octet fields having extending groups,
//    extending indications, or escape for extensions. (See 4.5.1)
// 2) codeset recognition and exclusion based on SHIFT (See 4.5.2)
// 3) correct ignoring of escapes for nationally specific message types.
// 4) The call reference value is 2 bytes long sizeof(WORD).
//    A call reference of 0 means, the message pertains to all
//    calls on the same data link.
//------------------------------------------------------------------------------

#pragma warning ( disable : 4100 4115 4201 4214 4514 )

#include "precomp.h"
#include <string.h>

#include "h225asn.h"
#include "q931asn1.h"

#include "common.h"
#include "q931.h"
#include "isrg.h"

#include "utils.h"
#include "q931pdu.h"

#ifdef UNICODE_TRACE
// We include this header to fix problems with macro expansion when Unicode is turned on.
#include "unifix.h"
#endif


//==========================================================
// CALLED PARTY FIELD DEFINITIONS
//==========================================================
// called party encoding bits...
#define CALLED_PARTY_EXT_BIT        0x80

// called party number type
#define CALLED_PARTY_TYPE_UNKNOWN   0x00
        // ...other types are not defined because they are not used...

// called party numbering plan
#define CALLED_PARTY_PLAN_E164      0x01
        // ...other plans are not defined because they are not used...
 


//==========================================================
// BEARER FIELD DEFINITIONS
//==========================================================
// bearer encoding bits...
#define BEAR_EXT_BIT                0x80

// bearer coding standards...
#define BEAR_CCITT                  0x00
        // ...others not needed...

// bearer information transfer capability...
#define BEAR_UNRESTRICTED_DIGITAL   0x08
        // ...others not needed...

// bearer transfer mode...
#define BEAR_PACKET_MODE            0x40
        // ...others not needed...

// bearer information transfer rate...
#define BEAR_NO_CIRCUIT_RATE        0x00
        // ...others not needed...

// bearer layer1 protocol...
#define BEAR_LAYER1_INDICATOR       0x20
#define BEAR_LAYER1_H221_H242       0x05
        // ...others not needed...

static struct ObjectID_ ProtocolId1;
static struct ObjectID_ ProtocolId2;
static struct ObjectID_ ProtocolId3;
static struct ObjectID_ ProtocolId4;
static struct ObjectID_ ProtocolId5;
static struct ObjectID_ ProtocolId6;

static struct GatewayInfo_protocol TempProtocol;

MESSAGEIDTYPE MessageSet[] =
{
    ALERTINGMESSAGETYPE,
    PROCEEDINGMESSAGETYPE,
    CONNECTMESSAGETYPE,
    CONNECTACKMESSAGETYPE,
    PROGRESSMESSAGETYPE,
    SETUPMESSAGETYPE,
    SETUPACKMESSAGETYPE,

    RESUMEMESSAGETYPE,
    RESUMEACKMESSAGETYPE,
    RESUMEREJMESSAGETYPE,
    SUSPENDMESSAGETYPE,
    SUSPENDACKMESSAGETYPE,
    SUSPENDREJMESSAGETYPE,
    USERINFOMESSAGETYPE,

    DISCONNECTMESSAGETYPE,
    RELEASEMESSAGETYPE,
    RELEASECOMPLMESSAGETYPE,
    RESTARTMESSAGETYPE,
    RESTARTACKMESSAGETYPE,

    SEGMENTMESSAGETYPE,
    CONGCTRLMESSAGETYPE,
    INFORMATIONMESSAGETYPE,
    NOTIFYMESSAGETYPE,
    STATUSMESSAGETYPE,
    STATUSENQUIRYMESSAGETYPE,

    FACILITYMESSAGETYPE
};


#define Q931_PROTOCOL_ID1           0
#define Q931_PROTOCOL_ID2           0
#define Q931_PROTOCOL_ID3           8
#define Q931_PROTOCOL_ID4           2250
#define Q931_PROTOCOL_ID5           0
//#define Q931_PROTOCOL_ID6           1
#define Q931_PROTOCOL_ID6           2       // H.225 version 2!

VOID Q931PduInit()
{
    ProtocolId1.value = Q931_PROTOCOL_ID1;
    ProtocolId1.next = &ProtocolId2;
    ProtocolId2.value = Q931_PROTOCOL_ID2;
    ProtocolId2.next = &ProtocolId3;
    ProtocolId3.value = Q931_PROTOCOL_ID3;
    ProtocolId3.next = &ProtocolId4;
    ProtocolId4.value = Q931_PROTOCOL_ID4;
    ProtocolId4.next = &ProtocolId5;
    ProtocolId5.value = Q931_PROTOCOL_ID5;
    ProtocolId5.next = &ProtocolId6;
    ProtocolId6.value = Q931_PROTOCOL_ID6;
    ProtocolId6.next = NULL;

    // gateway protocol supported.  For now, hard-coded to only 1:  H323.
    TempProtocol.next = NULL;
    TempProtocol.value.choice = h323_chosen;
}

//====================================================================================
//====================================================================================
static CS_STATUS
AliasToSeqof(struct Setup_UUIE_sourceAddress **ppTarget, PCC_ALIASNAMES pSource)
{
    if (ppTarget == NULL)
    {
        return CS_BAD_PARAM;
    }
    *ppTarget = NULL;
    if (pSource == NULL)
    {
        return CS_OK;
    }
    if (pSource && (pSource->wCount))
    {
        struct Setup_UUIE_sourceAddress *ListHead = NULL;
        struct Setup_UUIE_sourceAddress *CurrentNode = NULL;
        LPWSTR pData = NULL;         // UNICODE STRING
        int SourceItem;
        WORD x;

        for (SourceItem = pSource->wCount - 1; SourceItem >= 0; SourceItem--)
        {
            BOOL Cleanup = FALSE;

            // first do the required memory allocations...
            CurrentNode = (struct Setup_UUIE_sourceAddress *)MemAlloc(sizeof(struct Setup_UUIE_sourceAddress));
            if (CurrentNode == NULL)
            {
                Cleanup = TRUE;
            }
            else
            {
                if (pSource->pItems[SourceItem].wType == CC_ALIAS_H323_ID)
                {
                    if ((pSource->pItems[SourceItem].wDataLength != 0) &&
                        (pSource->pItems[SourceItem].pData != NULL))
                    {
                        pData = (LPWSTR)MemAlloc(pSource->pItems[SourceItem].wDataLength *
                            sizeof(WCHAR));
                        if (pData == NULL)
                        {
                            MemFree(CurrentNode);
                            Cleanup = TRUE;
                        }
                    }
                }
            }
            if (Cleanup)
            {
                for (CurrentNode = ListHead; CurrentNode; CurrentNode = ListHead)
                {
                    ListHead = CurrentNode->next;
                    if (CurrentNode->value.choice == h323_ID_chosen)
                    {
                        if (CurrentNode->value.u.h323_ID.value)
                        {
                            MemFree(CurrentNode->value.u.h323_ID.value);
                        }
                    }
                    MemFree(CurrentNode);
                }
                return CS_NO_MEMORY;
            }

            // then do the required memory copying.
            if (pSource->pItems[SourceItem].wType == CC_ALIAS_H323_ID)
            {
                CurrentNode->value.choice = h323_ID_chosen;
                if ((pSource->pItems[SourceItem].wDataLength != 0) &&
                    (pSource->pItems[SourceItem].pData != NULL))
                {
                    CurrentNode->value.u.h323_ID.length =
                        pSource->pItems[SourceItem].wDataLength;
                    for (x = 0; x < pSource->pItems[SourceItem].wDataLength; x++)
                    {
                        pData[x] = pSource->pItems[SourceItem].pData[x];
                    }
                    CurrentNode->value.u.h323_ID.value = pData;
                }
                else
                {
                    CurrentNode->value.u.h323_ID.length = 0;
                    CurrentNode->value.u.h323_ID.value = NULL;
                }
            }
            else if (pSource->pItems[SourceItem].wType == CC_ALIAS_H323_PHONE)
            {
                CurrentNode->value.choice = e164_chosen;
                if ((pSource->pItems[SourceItem].wDataLength != 0) &&
                    (pSource->pItems[SourceItem].pData != NULL))
                {
                    for (x = 0; x < pSource->pItems[SourceItem].wDataLength; x++)
                    {
                        CurrentNode->value.u.e164[x] = (BYTE)(pSource->pItems[SourceItem].pData[x]);
                    }
                    CurrentNode->value.u.e164[pSource->pItems[SourceItem].wDataLength] = '\0';
                }
                else
                {
                    CurrentNode->value.u.e164[0] = '\0';
                }
            }
            CurrentNode->next = ListHead;
            ListHead = CurrentNode;
        }
        *ppTarget = ListHead;
    }
    return CS_OK;
}

//====================================================================================
//====================================================================================
static CS_STATUS
AliasWithPrefixToSeqof(struct Setup_UUIE_sourceAddress **ppTarget, PCC_ALIASNAMES pSource)
{
    if (ppTarget == NULL)
    {
        return CS_BAD_PARAM;
    }
    *ppTarget = NULL;
    if (pSource == NULL)
    {
        return CS_OK;
    }
    if (pSource && (pSource->wCount))
    {
        struct Setup_UUIE_sourceAddress *ListHead = NULL;
        struct Setup_UUIE_sourceAddress *CurrentNode = NULL;
        int SourceItem;

        for (SourceItem = pSource->wCount - 1; SourceItem >= 0; SourceItem--)
        {
			PCC_ALIASITEM pItem = &pSource->pItems[SourceItem];
			LPWSTR pData = NULL;        // UNICODE STRING
            BOOL Cleanup = FALSE;
            unsigned uPrefixLength;
            unsigned uDataLength;
            unsigned x;
            
            if (pItem->pPrefix != NULL &&
                pItem->wPrefixLength > 0)
            {
                uPrefixLength = (unsigned) pItem->wPrefixLength;
            }
            else
            {
                uPrefixLength = 0;
            }

            if (pItem->pData != NULL &&
                pItem->wDataLength > 0)
            {
                uDataLength = (unsigned) pItem->wDataLength;
            }
            else
            {
                uDataLength = 0;
            }

            // first do the required memory allocations...
            CurrentNode = (struct Setup_UUIE_sourceAddress *)MemAlloc(sizeof(struct Setup_UUIE_sourceAddress));
            if (CurrentNode == NULL)
            {
                Cleanup = TRUE;
            }
            else
            {
                if (pItem->wType == CC_ALIAS_H323_ID)
                {
#ifdef USE_PREFIX_FOR_H323_ID
                    if (uPrefixLength != 0 || uDataLength != 0)
                    {
                        pData = (LPWSTR)MemAlloc((uPrefixLength + uDataLength) * sizeof(WCHAR));
#else
                    if (uDataLength != 0)
                    {
                        pData = (LPWSTR)MemAlloc((uDataLength) * sizeof(WCHAR));
#endif
                        if (pData == NULL)
                        {
                            MemFree(CurrentNode);
                            Cleanup = TRUE;
                        }
                    }
                }
            }
            if (Cleanup)
            {
                for (CurrentNode = ListHead; CurrentNode; CurrentNode = ListHead)
                {
                    ListHead = CurrentNode->next;
                    if (CurrentNode->value.choice == h323_ID_chosen)
                    {
                        if (CurrentNode->value.u.h323_ID.value)
                        {
                            MemFree(CurrentNode->value.u.h323_ID.value);
                        }
                    }
                    MemFree(CurrentNode);
                }
                return CS_NO_MEMORY;
            }

            // then do the required memory copying.
            switch (pItem->wType)
            {
            case CC_ALIAS_H323_ID:
                CurrentNode->value.choice = h323_ID_chosen;
#ifdef USE_PREFIX_FOR_H323_ID
                if (uPrefixLength != 0 || uDataLength != 0)
                {
                    CurrentNode->value.u.h323_ID.length = (WORD)(uPrefixLength + uDataLength);
                    for (x = 0; x < uPrefixLength; ++x)
                    {
                        pData[x] = pItem->pPrefix[x];
                    }
                    for (x = 0; x < uDataLength; ++x)
                    {
                        pData[uPrefixLength + x] = pItem->pData[x];
                    }
#else
                if (uDataLength != 0)
                {
                    CurrentNode->value.u.h323_ID.length = (WORD)(uDataLength);
                    for (x = 0; x < uDataLength; ++x)
                    {
                        pData[x] = pItem->pData[x];
                    }
#endif
                    CurrentNode->value.u.h323_ID.value = pData;
                }
                else
                {
                    CurrentNode->value.u.h323_ID.length = 0;
                    CurrentNode->value.u.h323_ID.value  = NULL;
                }
                break;

            case CC_ALIAS_H323_PHONE:
                CurrentNode->value.choice = e164_chosen;
                for (x = 0; x < uPrefixLength; ++x)
                {
                    CurrentNode->value.u.e164[x] = (BYTE)(pItem->pPrefix[x]);
                }
                for (x = 0; x < uDataLength; ++x)
                {
                    CurrentNode->value.u.e164[uPrefixLength + x] = (BYTE)(pItem->pData[x]);
                }
                for (x = uDataLength + uPrefixLength; x < sizeof(CurrentNode->value.u.e164); ++x)
                {
                    CurrentNode->value.u.e164[x] = 0;
                }
                break;

            default:
                MemFree(CurrentNode);
                for (CurrentNode = ListHead; CurrentNode; CurrentNode = ListHead)
                {
                    ListHead = CurrentNode->next;
                    if (CurrentNode->value.choice == h323_ID_chosen)
                    {
                        if (CurrentNode->value.u.h323_ID.value)
                        {
                            MemFree(CurrentNode->value.u.h323_ID.value);
                        }
                    }
                    MemFree(CurrentNode);
                }
                return CS_BAD_PARAM;
            } // switch
            CurrentNode->next = ListHead;
            ListHead = CurrentNode;
        }
        *ppTarget = ListHead;
    }
    return CS_OK;
}

//====================================================================================
//====================================================================================
static CS_STATUS
SeqofToAlias(PCC_ALIASNAMES *ppTarget, struct Setup_UUIE_sourceAddress *pSource)
{
    struct Setup_UUIE_sourceAddress *ListHead = NULL;
    struct Setup_UUIE_sourceAddress *CurrentNode = NULL;
    WORD wCount;
    WORD x = 0;
    PCC_ALIASITEM p = NULL;
    CS_STATUS status = CS_OK;

    if (ppTarget == NULL)
    {
        return CS_BAD_PARAM;
    }
    *ppTarget = NULL;
    if (pSource == NULL)
    {
        return CS_OK;
    }

    wCount = 0;
    for (CurrentNode = pSource; CurrentNode; CurrentNode = CurrentNode->next)
    {
        wCount++;
    }

    *ppTarget = (PCC_ALIASNAMES)MemAlloc(sizeof(CC_ALIASNAMES));
    if (*ppTarget == NULL)
    {
        return CS_NO_MEMORY;
    }

    (*ppTarget)->pItems = (PCC_ALIASITEM)MemAlloc(wCount * sizeof(CC_ALIASITEM));
    if ((*ppTarget)->pItems == NULL)
    {
        MemFree(*ppTarget);
        *ppTarget = NULL;
        return CS_NO_MEMORY;
    }

    p = (*ppTarget)->pItems;

    for (CurrentNode = pSource; CurrentNode; CurrentNode = CurrentNode->next)
    {
        WORD y;

	    p[x].wPrefixLength = 0;
        p[x].pPrefix = NULL;

        switch (CurrentNode->value.choice)
        {
        case h323_ID_chosen:
            p[x].wType = CC_ALIAS_H323_ID;
            if ((CurrentNode->value.u.h323_ID.length != 0) &&
                    (CurrentNode->value.u.h323_ID.value != NULL))
            {
                p[x].wDataLength = (WORD) CurrentNode->value.u.h323_ID.length;
                p[x].pData = (LPWSTR)MemAlloc(CurrentNode->value.u.h323_ID.length * sizeof(p[x].pData[0]));
                if (p[x].pData != NULL)
                {
                    for (y = 0; y < CurrentNode->value.u.h323_ID.length; y++)
                    {
                        p[x].pData[y] = (WCHAR)((CurrentNode->value.u.h323_ID.value)[y]);
                    }
					x++;
                }
                else
                {
                    status = CS_NO_MEMORY;
                }
            }
            break;


        case e164_chosen:
            p[x].wType = CC_ALIAS_H323_PHONE;
            p[x].wDataLength = (WORD)strlen(CurrentNode->value.u.e164);
            p[x].pData = (LPWSTR)MemAlloc((p[x].wDataLength+1) * sizeof(p[x].pData[0]));
            if (p[x].pData != NULL)
            {
                for (y = 0; y < p[x].wDataLength; y++)
                {
                    p[x].pData[y] = CurrentNode->value.u.e164[y];
                }
                p[x].pData[p[x].wDataLength] = 0;
				x++;
            }
            else
            {
                status = CS_NO_MEMORY;
            }
            break;

        default:
			// we don't currently handle other alias types
			break;
        } // switch

        if (status != CS_OK)
        {
            // Free everything that has been allocated so far...
            for (y = 0; y < x; y++)
            {
                MemFree(p[y].pData);
            }
            MemFree(p);
            MemFree(*ppTarget);
            *ppTarget = NULL;
            return status;
        }
    }
    (*ppTarget)->wCount = x;

    return CS_OK;
}

//====================================================================================
//====================================================================================
static CS_STATUS
FreeSeqof(struct Setup_UUIE_sourceAddress *pSource)
{
    struct Setup_UUIE_sourceAddress *CurrentNode = NULL;

    for (CurrentNode = pSource; CurrentNode; CurrentNode = pSource)
    {
        pSource = CurrentNode->next;
        if (CurrentNode->value.choice == h323_ID_chosen)
        {
            if (CurrentNode->value.u.h323_ID.value)
            {
                MemFree(CurrentNode->value.u.h323_ID.value);
            }
        }
        MemFree(CurrentNode);
    }
    return CS_OK;
}

//====================================================================================
//====================================================================================
static CS_STATUS
Q931CopyAliasItemToAliasAddr(AliasAddress *pTarget, PCC_ALIASITEM pSource)
{
    AliasAddress *pNewAddress = NULL;
    WORD x;

    if (pTarget == NULL)
    {
        return CS_BAD_PARAM;
    }
    if (pSource == NULL)
    {
        return CS_BAD_PARAM;
    }

    pNewAddress = pTarget;

    if (pSource->wType == CC_ALIAS_H323_ID)
    {
        pNewAddress->choice = h323_ID_chosen;
        if ((pSource->wDataLength != 0) && (pSource->pData != NULL))
        {
            LPWSTR pData = NULL;         // UNICODE STRING
            pData = (LPWSTR)MemAlloc(pSource->wDataLength * sizeof(WCHAR));
            if (pData == NULL)
            {
                return CS_NO_MEMORY;
            }
            pNewAddress->u.h323_ID.length = pSource->wDataLength;
            for (x = 0; x < pSource->wDataLength; x++)
            {
                pData[x] = pSource->pData[x];
            }
            pNewAddress->u.h323_ID.value = pData;
        }
        else
        {
            pNewAddress->u.h323_ID.length = 0;
            pNewAddress->u.h323_ID.value = NULL;
        }
    }
    else if (pSource->wType == CC_ALIAS_H323_PHONE)
    {
        pNewAddress->choice = e164_chosen;
        if ((pSource->wDataLength != 0) && (pSource->pData != NULL))
        {
            for (x = 0; x < pSource->wDataLength; x++)
            {
                pNewAddress->u.e164[x] = (BYTE)(pSource->pData[x]);
            }
            pNewAddress->u.e164[pSource->wDataLength] = '\0';
        }
        else
        {
            pNewAddress->u.e164[0] = '\0';
        }
    }

    return CS_OK;
}

//====================================================================================
//====================================================================================
static CS_STATUS
Q931AliasAddrToAliasItem(PCC_ALIASITEM *ppTarget, AliasAddress *pSource)
{
    PCC_ALIASITEM pNewItem = NULL;
    WORD y;

    if (ppTarget == NULL)
    {
        return CS_BAD_PARAM;
    }
    if (pSource == NULL)
    {
        *ppTarget = NULL;
        return CS_OK;
    }

    pNewItem = (PCC_ALIASITEM)MemAlloc(sizeof(CC_ALIASITEM));
    if (pNewItem == NULL)
    {
        *ppTarget = NULL;
        return CS_NO_MEMORY;
    }
    memset(pNewItem, 0, sizeof(*pNewItem));

    switch (pSource->choice)
    {
    case h323_ID_chosen:
        pNewItem->wType = CC_ALIAS_H323_ID;
        if ((pSource->u.h323_ID.length != 0) &&
            (pSource->u.h323_ID.value  != NULL))
        {
            // convert the text from UNICODE to ascii.
            pNewItem->wDataLength = (WORD) pSource->u.h323_ID.length;
            pNewItem->pData = (LPWSTR)MemAlloc(pSource->u.h323_ID.length * sizeof(pNewItem->pData[0]));
            if (pNewItem->pData == NULL)
            {
                MemFree(pNewItem);
                return CS_NO_MEMORY;
            }
            for (y = 0; y < pSource->u.h323_ID.length; y++)
            {
                pNewItem->pData[y] = (WCHAR)((pSource->u.h323_ID.value)[y]);
            }
        }
        break;

    case e164_chosen:
        pNewItem->wType = CC_ALIAS_H323_PHONE;
        pNewItem->wDataLength = (WORD)strlen(pSource->u.e164);
        pNewItem->pData = (LPWSTR)MemAlloc((pNewItem->wDataLength + 1) * sizeof(pNewItem->pData[0]));
        if (pNewItem->pData == NULL)
        {
            MemFree(pNewItem);
            return CS_NO_MEMORY;
        }
        for (y = 0; y < pNewItem->wDataLength; y++)
        {
            pNewItem->pData[y] = pSource->u.e164[y];
        }
        pNewItem->pData[pNewItem->wDataLength] = 0;
        break;

    default:
        MemFree(pNewItem);
        *ppTarget = NULL;
        return CS_BAD_PARAM;
    } // switch

    *ppTarget = pNewItem;
    return CS_OK;
}

//====================================================================================
//====================================================================================
static CS_STATUS
Q931ClearAliasAddr(AliasAddress *pSource)
{
    if (pSource)
    {
        if (pSource->choice == h323_ID_chosen)
        {
            if (pSource->u.h323_ID.value)
            {
                MemFree(pSource->u.h323_ID.value);
            }
        }
    }
    return CS_OK;
}





//------------------------------------------------------------------------------
// Parse and return a single octet encoded value, See Q931 section 4.5.1.
//
// Parameters:
//     BufferPtr  Pointer to a descriptor of the buffer
//                containing the length and a pointer
//                to the raw bytes of the input stream.
//     Ident      Pointer to space for field identifier
//     Value      Pointer to space for field value
//------------------------------------------------------------------------------
static HRESULT 
ParseSingleOctetType1(
    PBUFFERDESCR BufferDescriptor,
    BYTE *Ident,
    BYTE *Value)
{
    // There has to be at least 1 byte in the stream to be
    // able to parse the single octet value
    if (BufferDescriptor->Length < 1)
    {
        return CS_ENDOFINPUT;
    }

    // low bits (0, 1, 2, 3) of the byte are the value
    *Value = (BYTE)(*BufferDescriptor->BufferPtr & TYPE1VALUEMASK);

    // higher bits (4, 5, 6) are the identifier.  bit 7 is always 1,
    // and is not returned as part of the id.
    *Ident = (BYTE)((*BufferDescriptor->BufferPtr & 0x70) >> 4);

    BufferDescriptor->BufferPtr++;
    BufferDescriptor->Length--;

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse and return a single octet encoded value, See Q931 section 4.5.1.
// This octet has no value, only an identifier.
//
// Parameters:
//     BufferPtr  Pointer to a descriptor of the buffer containing the
//                length and a pointer to the raw bytes of the input stream.
//     Ident      Pointer to space for field identifier
//------------------------------------------------------------------------------
static HRESULT
ParseSingleOctetType2(
    PBUFFERDESCR BufferDescriptor,
    BYTE *Ident)
{
    // There has to be at least 1 byte in the stream to be
    // able to parse the single octet value
    if (BufferDescriptor->Length < 1)
    {
        return CS_ENDOFINPUT;
    }

    // low 7 bits of the byte are the identifier
    *Ident = (BYTE)(*BufferDescriptor->BufferPtr & 0x7f);

    BufferDescriptor->BufferPtr++;
    BufferDescriptor->Length--;

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse and return a variable length Q931 field see Q931 section 4.5.1.
//
// Parameters :
//     BufferPtr  Pointer to a descriptor of the buffer
//                containing the length and a pointer
//                to the raw bytes of the input stream.
//     Ident      Pointer to space for field identifier
//     Length     Pointer to space for the length
//     Contents   Pointer to space for the bytes of the field
//------------------------------------------------------------------------------
static HRESULT 
ParseVariableOctet(
    PBUFFERDESCR BufferDescriptor,
    BYTE *Ident,
    BYTE *Length,
    BYTE *Contents)
{
    register int i;
    BYTE *Tempptr;

    // There has to be at least 2 bytes in order just to get 
    // the length and the identifier
    // able to parse the single octet value
    if (BufferDescriptor->Length < 2)
    {
        return CS_ENDOFINPUT;
    }

    // low 7 bits of the first byte are the identifier
    *Ident= (BYTE)(*BufferDescriptor->BufferPtr & 0x7f);

    BufferDescriptor->BufferPtr++;
    BufferDescriptor->Length--;

    // The next byte is the length
    *Length = *BufferDescriptor->BufferPtr;
    BufferDescriptor->BufferPtr++;
    BufferDescriptor->Length--;

    ASSERT(*Length <= MAXVARFIELDLEN);
    if (MAXVARFIELDLEN < *Length)
    {
        return CS_INVALID_FIELD;
    }
    
    if (BufferDescriptor->Length < *Length)
    {
        return CS_ENDOFINPUT;
    }

    Tempptr = Contents;
    for (i = 0; i < *Length; i++)
    {
        // Copy the bytes out of the rest of the buffer
        *Tempptr = *BufferDescriptor->BufferPtr;
        BufferDescriptor->BufferPtr++;
        BufferDescriptor->Length--;
        Tempptr++;
    }
    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse and return a variable length Q931 field see Q931 section 4.5.1.
//------------------------------------------------------------------------------
static HRESULT 
ParseVariableASN(
    PBUFFERDESCR BufferDescriptor,
    BYTE *Ident,
    BYTE *ProtocolDiscriminator,
    WORD *UserInformationLength,     // Length of the User Information.
    BYTE *UserInformation,           // Bytes of the User Information.
    WORD cbMaxUserInformation)
{
    register int i;
    BYTE *Tempptr;
    WORD ContentsLength;     // Length of the full UserUser contents.

    *UserInformationLength = 0;

    // There has to be at least 4 bytes for the IE identifier,
    // the contents length, and the protocol discriminator (1 + 2 + 1).
    if (BufferDescriptor->Length < 4)
    {
        return CS_ENDOFINPUT;
    }

    // low 7 bits of the first byte are the identifier
    *Ident= (BYTE)(*BufferDescriptor->BufferPtr & 0x7f);
    BufferDescriptor->BufferPtr++;
    BufferDescriptor->Length--;

    // The next 2 bytes are the length
    ContentsLength = *(BufferDescriptor->BufferPtr);
    BufferDescriptor->BufferPtr++;
    BufferDescriptor->Length--;
    ContentsLength = (WORD)((ContentsLength << 8) + *BufferDescriptor->BufferPtr);
    BufferDescriptor->BufferPtr++;
    BufferDescriptor->Length--;

    if (BufferDescriptor->Length < ContentsLength)
    {
        return CS_ENDOFINPUT;
    }

    // The next byte is the protocol discriminator.
    *ProtocolDiscriminator = *BufferDescriptor->BufferPtr;
    BufferDescriptor->BufferPtr++;
    BufferDescriptor->Length--;

    if (ContentsLength > 0)
    {
        *UserInformationLength = (WORD)(ContentsLength - 1);
    }

    ASSERT(*UserInformationLength <= cbMaxUserInformation);
    if(cbMaxUserInformation < *UserInformationLength)
    {
        return CS_INVALID_FIELD;
    }

    Tempptr = UserInformation;
    for (i = 0; i < *UserInformationLength; i++)
    {
        // Copy the bytes out of the rest of the buffer
        *Tempptr = *BufferDescriptor->BufferPtr;
        BufferDescriptor->BufferPtr++;
        BufferDescriptor->Length--;
        Tempptr++;
    }
    return CS_OK;
}

//------------------------------------------------------------------------------
// Get the identifier of the next field from the buffer and
// return it.  The buffer pointer is not incremented, To
// parse the field and extract its values, the above functions
// should be used.  See Q931 table 4-3 for the encodings of the 
// identifiers.
//
// Parameters:
//      BufferPtr        Pointer to the buffer space
//------------------------------------------------------------------------------
static BYTE
GetNextIdent(
    void *BufferPtr)
{
    FIELDIDENTTYPE Ident;

    // Extract the first byte from the buffer
    Ident= (*(FIELDIDENTTYPE *)BufferPtr);

    // This value can be returned as the identifier as long
    // as it is not a single Octet - Type 1 element.
    // Those items must have the value removed from them
    // before they can be returned.
    if ((Ident & 0x80) && ((Ident & TYPE1IDENTMASK) != 0xA0))
    {
        return (BYTE)(Ident & TYPE1IDENTMASK);
    }

    return Ident;
}

//------------------------------------------------------------------------------
// Parse and return a protocol discriminator. See Q931 section 4.2.
// The octet pointed to by **BufferPtr is the protocol Discriminator.
//
// Parameters:
//     BufferPtr  Pointer to a descriptor of the buffer
//                containing the length and a pointer
//                to the raw bytes of the input stream.
//     Discrim    Pointer to space for discriminator
//------------------------------------------------------------------------------
static HRESULT
ParseProtocolDiscriminator(
    PBUFFERDESCR BufferDescriptor,
    PDTYPE *Discrim)
{
    // There has to be at least enough bytes left in the 
    // string for the operation
    if (BufferDescriptor->Length < sizeof(PDTYPE))
    {
        return CS_ENDOFINPUT;
    }

    *Discrim = *(PDTYPE *)BufferDescriptor->BufferPtr;
    if (*Discrim != Q931PDVALUE)
    {
        return CS_INVALID_PROTOCOL;
    }

    BufferDescriptor->BufferPtr += sizeof(PDTYPE);
    BufferDescriptor->Length -= sizeof(PDTYPE);
    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse and return a variable length Q931 call reference see 
// Q931 section 4.3.
//
// Parameters:
//     BufferPtr  Pointer to a descriptor of the buffer
//                containing the length and a pointer
//                to the raw bytes of the input stream.
//     Length     Pointer to space for the length
//     Contents   Pointer to space for the bytes of the field
//------------------------------------------------------------------------------
static HRESULT
ParseCallReference(
    PBUFFERDESCR BufferDescriptor,
    CRTYPE *CallReference)
{
    register int i;
    BYTE Length;

    // There has to be at least enough bytes left in the 
    // string for the length byte
    if (BufferDescriptor->Length < 1)
    {
        return CS_ENDOFINPUT;
    }

    // low 4 bits of the first byte are the length.
    // the rest of the bits are zeroes.
    Length = (BYTE)(*BufferDescriptor->BufferPtr & 0x0f);

    BufferDescriptor->BufferPtr++;
    BufferDescriptor->Length--;

    // There has to be at least enough bytes left in the 
    // string for the operation
    if (BufferDescriptor->Length < Length)
    {
        return CS_ENDOFINPUT;
    }

    *CallReference = 0;     // length can be 0, so initialize here first...
    for (i = 0; i < Length; i++)
    {
        if (i < sizeof(CRTYPE))
        {
            // Copy the bytes out of the rest of the buffer
            *CallReference = (WORD)((*CallReference << 8) +
                *BufferDescriptor->BufferPtr);
        }
        BufferDescriptor->BufferPtr++;
        BufferDescriptor->Length--;
    }

    // note:  the high order bit of the value represents callee relationship.

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse and return a message type.  See Q931 section 4.4.
// The octet pointed to by **BufferPtr is the message type.
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     MessageType  Pointer to space for message type
//------------------------------------------------------------------------------
static HRESULT
ParseMessageType(
    PBUFFERDESCR BufferDescriptor,
    MESSAGEIDTYPE *MessageType)
{
    register int i;

    // There has to be at least enough bytes left in the 
    // string for the operation
    if (BufferDescriptor->Length < sizeof(MESSAGEIDTYPE))
    {
        return CS_ENDOFINPUT;
    }

    *MessageType = (BYTE)(*((MESSAGEIDTYPE *)BufferDescriptor->BufferPtr) & MESSAGETYPEMASK);
    for (i = 0; i < sizeof(MessageSet) / sizeof(MESSAGEIDTYPE); i++)
    {
        if (MessageSet[i] == *MessageType)
        {
            break;
        }
    }
    if (i >= sizeof(MessageSet) / sizeof(MESSAGEIDTYPE))
    {
        return CS_INVALID_MESSAGE_TYPE;
    }

    BufferDescriptor->BufferPtr += sizeof(MESSAGEIDTYPE);
    BufferDescriptor->Length -= sizeof(MESSAGEIDTYPE);
    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional shift field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer containing the
//                  length and a pointer to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed shift message information.
//------------------------------------------------------------------------------
static HRESULT
ParseShift(
    PBUFFERDESCR BufferDescriptor,
    PSHIFTIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(SHIFTIE));
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_SHIFT)
    {
        FieldStruct->Present = TRUE;
        return ParseSingleOctetType1(BufferDescriptor,
            &Ident, &FieldStruct->Value);
    }
    else
    {
        FieldStruct->Present = FALSE;
    }
    return CS_OK;
}


//------------------------------------------------------------------------------
// Parse an optional facility ie field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed facility
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParseFacility(
    PBUFFERDESCR BufferDescriptor,
    PFACILITYIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(FACILITYIE));
    FieldStruct->Present = FALSE;
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_FACILITY)
    {
        HRESULT ParseResult;
        ParseResult = ParseVariableOctet(BufferDescriptor,
            &Ident, &FieldStruct->Length, &FieldStruct->Contents[0]);
        if (ParseResult != CS_OK)
        {
            return ParseResult;
        }
        if (FieldStruct->Length > 0)
        {
            FieldStruct->Present = TRUE;
        }
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional more data field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed field information
//------------------------------------------------------------------------------
static HRESULT 
ParseMoreData(
    PBUFFERDESCR BufferDescriptor,
    PMOREDATAIE FieldStruct)
{
    BYTE Ident;

    memset(FieldStruct, 0, sizeof(MOREDATAIE));
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_MORE)
    {
        FieldStruct->Present = TRUE;
        return ParseSingleOctetType2(BufferDescriptor, &Ident);
    }
    else
    {
        FieldStruct->Present = FALSE;
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional sending clomplete field.  Q931 section 4.4.
// The octet pointed to by **BufferPtr is the message type.
//
// Parameters:
//      BufferPtr    Pointer to a descriptor of the buffer
//                   containing the length and a pointer
//                   to the raw bytes of the input stream.
//      MessageType  Pointer to space for message type
//------------------------------------------------------------------------------
static HRESULT
ParseSendingComplete(
    PBUFFERDESCR BufferDescriptor,
    PSENDCOMPLIE FieldStruct)
{
    BYTE Ident;

    memset(FieldStruct, 0, sizeof(SENDCOMPLIE));
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_SENDINGCOMPLETE)
    {
        FieldStruct->Present = TRUE;
        return ParseSingleOctetType2(BufferDescriptor, &Ident);
    }
    else
    {
        FieldStruct->Present = FALSE;
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional congestion level field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed congestion 
//                  level information.
//------------------------------------------------------------------------------
static HRESULT 
ParseCongestionLevel(
    PBUFFERDESCR BufferDescriptor,
    PCONGESTIONIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(CONGESTIONIE));
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_CONGESTION)
    {
        FieldStruct->Present = TRUE;
        return ParseSingleOctetType1(BufferDescriptor,
            &Ident, &FieldStruct->Value);
    }
    else
    {
        FieldStruct->Present = FALSE;
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional repeat indicator field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed repeat
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParseRepeatIndicator(
    PBUFFERDESCR BufferDescriptor,
    PREPEATIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(REPEATIE));
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_REPEAT)
    {
        FieldStruct->Present = TRUE;
        return ParseSingleOctetType1(BufferDescriptor,
            &Ident, &FieldStruct->Value);
    }
    else
    {
        FieldStruct->Present = FALSE;
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional segmented message field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed segmented message
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParseSegmented(
    PBUFFERDESCR BufferDescriptor,
    PSEGMENTEDIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(SEGMENTEDIE));
    FieldStruct->Present = FALSE;
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_SEGMENTED)
    {
        HRESULT ParseResult;
        ParseResult = ParseVariableOctet(BufferDescriptor,
            &Ident, &FieldStruct->Length, &FieldStruct->Contents[0]);
        if (ParseResult != CS_OK)
        {
            return ParseResult;
        }
        if (FieldStruct->Length > 0)
        {
            FieldStruct->Present = TRUE;
        }
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional bearer capability field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed bearer capability
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParseBearerCapability(
    PBUFFERDESCR BufferDescriptor,
    PBEARERCAPIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(BEARERCAPIE));
    FieldStruct->Present = FALSE;
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_BEARERCAP)
    {
        HRESULT ParseResult;
        ParseResult = ParseVariableOctet(BufferDescriptor,
            &Ident, &FieldStruct->Length, &FieldStruct->Contents[0]);
        if (ParseResult != CS_OK)
        {
            return ParseResult;
        }
        if (FieldStruct->Length > 0)
        {
            FieldStruct->Present = TRUE;
        }
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional cause field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed cause
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParseCause(
    PBUFFERDESCR BufferDescriptor,
    PCAUSEIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(CAUSEIE));
    FieldStruct->Present = FALSE;
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_CAUSE)
    {
        HRESULT ParseResult;
        ParseResult = ParseVariableOctet(BufferDescriptor,
            &Ident, &FieldStruct->Length, &FieldStruct->Contents[0]);
        if (ParseResult != CS_OK)
        {
            return ParseResult;
        }
        if (FieldStruct->Length > 0)
        {
            FieldStruct->Present = TRUE;
        }
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional call identity field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed call identity
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParseCallIdentity(
    PBUFFERDESCR BufferDescriptor,
    PCALLIDENTIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(CALLIDENTIE));
    FieldStruct->Present = FALSE;
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_CALLIDENT)
    {
        HRESULT ParseResult;
        ParseResult = ParseVariableOctet(BufferDescriptor,
            &Ident, &FieldStruct->Length, &FieldStruct->Contents[0]);
        if (ParseResult != CS_OK)
        {
            return ParseResult;
        }
        if (FieldStruct->Length > 0)
        {
            FieldStruct->Present = TRUE;
        }
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional call state field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed call state
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParseCallState(
    PBUFFERDESCR BufferDescriptor,
    PCALLSTATEIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(CALLSTATEIE));
    FieldStruct->Present = FALSE;
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_CALLSTATE)
    {
        HRESULT ParseResult;
        ParseResult = ParseVariableOctet(BufferDescriptor,
            &Ident, &FieldStruct->Length, &FieldStruct->Contents[0]);
        if (ParseResult != CS_OK)
        {
            return ParseResult;
        }
        if (FieldStruct->Length > 0)
        {
            FieldStruct->Present = TRUE;
        }
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional channel identification field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed channel identity
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParseChannelIdentification(
    PBUFFERDESCR BufferDescriptor,
    PCHANIDENTIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(CHANIDENTIE));
    FieldStruct->Present = FALSE;
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_CHANNELIDENT)
    {
        HRESULT ParseResult;
        ParseResult = ParseVariableOctet(BufferDescriptor, 
            &Ident, &FieldStruct->Length, &FieldStruct->Contents[0]);
        if (ParseResult != CS_OK)
        {
            return ParseResult;
        }
        if (FieldStruct->Length > 0)
        {
            FieldStruct->Present = TRUE;
        }
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional progress indication field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed progress
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParseProgress(
    PBUFFERDESCR BufferDescriptor,
    PPROGRESSIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(PROGRESSIE));
    FieldStruct->Present = FALSE;
    if ((GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_PROGRESS) ||
	(GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_PROGRESS2))
    {
        HRESULT ParseResult;
        ParseResult = ParseVariableOctet(BufferDescriptor, 
            &Ident, &FieldStruct->Length, &FieldStruct->Contents[0]);
        if (ParseResult != CS_OK)
        {
            return ParseResult;
        }
        if (FieldStruct->Length > 0)
        {
            FieldStruct->Present = TRUE;
        }
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional network specific facilities field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed network facitlities
//                  information.
//------------------------------------------------------------------------------
static HRESULT 
ParseNetworkSpec(
    PBUFFERDESCR BufferDescriptor,
    PNETWORKIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(NETWORKIE));
    FieldStruct->Present = FALSE;
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_NETWORKSPEC)
    {
        HRESULT ParseResult;
        ParseResult = ParseVariableOctet(BufferDescriptor, 
            &Ident, &FieldStruct->Length, &FieldStruct->Contents[0]);
        if (ParseResult != CS_OK)
        {
            return ParseResult;
        }
        if (FieldStruct->Length > 0)
        {
            FieldStruct->Present = TRUE;
        }
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional notification indicator field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parse notification indicator
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParseNotificationIndicator(
    PBUFFERDESCR BufferDescriptor,
    PNOTIFICATIONINDIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(NOTIFICATIONINDIE));
    FieldStruct->Present = FALSE;
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_NOTIFICATION)
    {
        HRESULT ParseResult;
        ParseResult = ParseVariableOctet(BufferDescriptor, 
            &Ident, &FieldStruct->Length, &FieldStruct->Contents[0]);
        if (ParseResult != CS_OK)
        {
            return ParseResult;
        }
        if (FieldStruct->Length > 0)
        {
            FieldStruct->Present = TRUE;
        }
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional display field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed display
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParseDisplay(
    PBUFFERDESCR BufferDescriptor,
    PDISPLAYIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(DISPLAYIE));
    FieldStruct->Present = FALSE;
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_DISPLAY)
    {
        HRESULT ParseResult;
        ParseResult = ParseVariableOctet(BufferDescriptor, 
            &Ident, &FieldStruct->Length, &FieldStruct->Contents[0]);
        if (ParseResult != CS_OK)
        {
            return ParseResult;
        }
        if (FieldStruct->Length > 0)
        {
            FieldStruct->Present = TRUE;
        }
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional date/time field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed date/time
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParseDate(
    PBUFFERDESCR BufferDescriptor,
    PDATEIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(DATEIE));
    FieldStruct->Present = FALSE;
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_DATE)
    {
        HRESULT ParseResult;
        ParseResult = ParseVariableOctet(BufferDescriptor, 
            &Ident, &FieldStruct->Length, &FieldStruct->Contents[0]);
        if (ParseResult != CS_OK)
        {
            return ParseResult;
        }
        if (FieldStruct->Length > 0)
        {
            FieldStruct->Present = TRUE;
        }
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional keypad field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed keypad
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParseKeypad(
    PBUFFERDESCR BufferDescriptor,
    PKEYPADIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(KEYPADIE));
    FieldStruct->Present = FALSE;
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_KEYPAD)
    {
        HRESULT ParseResult;
        ParseResult = ParseVariableOctet(BufferDescriptor, 
            &Ident, &FieldStruct->Length, &FieldStruct->Contents[0]);
        if (ParseResult != CS_OK)
        {
            return ParseResult;
        }
        if (FieldStruct->Length > 0)
        {
            FieldStruct->Present = TRUE;
        }
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional signal field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed signal
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParseSignal(
    PBUFFERDESCR BufferDescriptor,
    PSIGNALIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(SIGNALIE));
    FieldStruct->Present = FALSE;
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_SIGNAL)
    {
        HRESULT ParseResult;
        ParseResult = ParseVariableOctet(BufferDescriptor, 
            &Ident, &FieldStruct->Length, &FieldStruct->Contents[0]);
        if (ParseResult != CS_OK)
        {
            return ParseResult;
        }
        if (FieldStruct->Length > 0)
        {
            FieldStruct->Present = TRUE;
        }
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional information rate field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed information rate
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParseInformationRate(
    PBUFFERDESCR BufferDescriptor,
    PINFORATEIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(INFORATEIE));
    FieldStruct->Present = FALSE;
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_INFORMATIONRATE)
    {
        HRESULT ParseResult;
        ParseResult = ParseVariableOctet(BufferDescriptor, 
            &Ident, &FieldStruct->Length, &FieldStruct->Contents[0]);
        if (ParseResult != CS_OK)
        {
            return ParseResult;
        }
        if (FieldStruct->Length > 0)
        {
            FieldStruct->Present = TRUE;
        }
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional end to end transit delay field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed end to end
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParseEndToEndDelay(
    PBUFFERDESCR BufferDescriptor,
    PENDTOENDDELAYIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(ENDTOENDDELAYIE));
    FieldStruct->Present = FALSE;
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_ENDTOENDDELAY)
    {
        HRESULT ParseResult;
        ParseResult = ParseVariableOctet(BufferDescriptor, 
            &Ident, &FieldStruct->Length, &FieldStruct->Contents[0]);
        if (ParseResult != CS_OK)
        {
            return ParseResult;
        }
        if (FieldStruct->Length > 0)
        {
            FieldStruct->Present = TRUE;
        }
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional transit delay field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed transit delay
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParseTransitDelay(
    PBUFFERDESCR BufferDescriptor,
    PTRANSITDELAYIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(TRANSITDELAYIE));
    FieldStruct->Present = FALSE;
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_TRANSITDELAY)
    {
        HRESULT ParseResult;
        ParseResult = ParseVariableOctet(BufferDescriptor, 
            &Ident, &FieldStruct->Length, &FieldStruct->Contents[0]);
        if (ParseResult != CS_OK)
        {
            return ParseResult;
        }
        if (FieldStruct->Length > 0)
        {
            FieldStruct->Present = TRUE;
        }
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional packet layer binary params field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed 
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParsePacketLayerParams(
    PBUFFERDESCR BufferDescriptor,
    PPLBINARYPARAMSIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(PLBINARYPARAMSIE));
    FieldStruct->Present = FALSE;
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_PLBINARYPARAMS)
    {
        HRESULT ParseResult;
        ParseResult = ParseVariableOctet(BufferDescriptor, 
            &Ident, &FieldStruct->Length, &FieldStruct->Contents[0]);
        if (ParseResult != CS_OK)
        {
            return ParseResult;
        }
        if (FieldStruct->Length > 0)
        {
            FieldStruct->Present = TRUE;
        }
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional packet layer window size field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed 
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParsePacketLayerWindowSize(
    PBUFFERDESCR BufferDescriptor,
    PPLWINDOWSIZEIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(PLWINDOWSIZEIE));
    FieldStruct->Present = FALSE;
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_PLWINDOWSIZE)
    {
        HRESULT ParseResult;
        ParseResult = ParseVariableOctet(BufferDescriptor, 
            &Ident, &FieldStruct->Length, &FieldStruct->Contents[0]);
        if (ParseResult != CS_OK)
        {
            return ParseResult;
        }
        if (FieldStruct->Length > 0)
        {
            FieldStruct->Present = TRUE;
        }
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional packet size field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parse packet size
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParsePacketSize(
    PBUFFERDESCR BufferDescriptor,
    PPACKETSIZEIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(PACKETSIZEIE));
    FieldStruct->Present = FALSE;
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_PACKETSIZE)
    {
        HRESULT ParseResult;
        ParseResult = ParseVariableOctet(BufferDescriptor, 
            &Ident, &FieldStruct->Length, &FieldStruct->Contents[0]);
        if (ParseResult != CS_OK)
        {
            return ParseResult;
        }
        if (FieldStruct->Length > 0)
        {
            FieldStruct->Present = TRUE;
        }
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional closed user group field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed 
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParseClosedUserGroup(
    PBUFFERDESCR BufferDescriptor,
    PCLOSEDUGIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(CLOSEDUGIE));
    FieldStruct->Present = FALSE;
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_CLOSEDUG)
    {
        HRESULT ParseResult;
        ParseResult = ParseVariableOctet(BufferDescriptor, 
            &Ident, &FieldStruct->Length, &FieldStruct->Contents[0]);
        if (ParseResult != CS_OK)
        {
            return ParseResult;
        }
        if (FieldStruct->Length > 0)
        {
            FieldStruct->Present = TRUE;
        }
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional reverse charge field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed 
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParseReverseCharge(
    PBUFFERDESCR BufferDescriptor,
    PREVERSECHARGEIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(REVERSECHARGEIE));
    FieldStruct->Present = FALSE;
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_REVCHARGE)
    {
        HRESULT ParseResult;
        ParseResult = ParseVariableOctet(BufferDescriptor, 
            &Ident, &FieldStruct->Length, &FieldStruct->Contents[0]);
        if (ParseResult != CS_OK)
        {
            return ParseResult;
        }
        if (FieldStruct->Length > 0)
        {
            FieldStruct->Present = TRUE;
        }
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional calling party number field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed 
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParseCallingPartyNumber(
    PBUFFERDESCR BufferDescriptor,
    PCALLINGNUMBERIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(CALLINGNUMBERIE));
    FieldStruct->Present = FALSE;
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_CALLINGNUMBER)
    {
        HRESULT ParseResult;
        ParseResult = ParseVariableOctet(BufferDescriptor, 
            &Ident, &FieldStruct->Length, &FieldStruct->Contents[0]);
        if (ParseResult != CS_OK)
        {
            return ParseResult;
        }
        if (FieldStruct->Length > 0)
        {
            FieldStruct->Present = TRUE;
        }
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional calling party subaddress field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed 
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParseCallingPartySubaddress(
    PBUFFERDESCR BufferDescriptor,
    PCALLINGSUBADDRIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(CALLINGSUBADDRIE));
    FieldStruct->Present = FALSE;
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_CALLINGSUBADDR)
    {
        HRESULT ParseResult;
        ParseResult = ParseVariableOctet(BufferDescriptor, 
            &Ident, &FieldStruct->Length, &FieldStruct->Contents[0]);
        if (ParseResult != CS_OK)
        {
            return ParseResult;
        }
        if (FieldStruct->Length > 0)
        {
            FieldStruct->Present = TRUE;
        }
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional called party number field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed 
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParseCalledPartyNumber(
    PBUFFERDESCR BufferDescriptor, 
    PCALLEDNUMBERIE FieldStruct)
{
    memset(FieldStruct, 0, sizeof(PCALLEDNUMBERIE));
    FieldStruct->Present = FALSE;
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_CALLEDNUMBER)
    {
        register int i;
        BYTE RemainingLength = 0;
        BYTE *Tempptr;
    
        // Need 3 bytes for the ident (1), length (1),
        // and type + plan (1) fields.
        if (BufferDescriptor->Length < 3)
        {
            return CS_ENDOFINPUT;
        }

        // skip the ie identifier...    
        BufferDescriptor->BufferPtr++;
        BufferDescriptor->Length--;

        // Get the length of the contents following the length field.
        RemainingLength = *BufferDescriptor->BufferPtr;
        BufferDescriptor->BufferPtr++;
        BufferDescriptor->Length--;

        // make sure we have at least that much length left...    
        if (BufferDescriptor->Length < RemainingLength)
        {
            return CS_ENDOFINPUT;
        }

        // Get the type + plan fields.
        if (*(BufferDescriptor->BufferPtr) & 0x80)
        {
            FieldStruct->NumberType =
                (BYTE)(*BufferDescriptor->BufferPtr & 0xf0);
            FieldStruct->NumberingPlan =
                (BYTE)(*BufferDescriptor->BufferPtr & 0x0f);
            BufferDescriptor->BufferPtr++;
            BufferDescriptor->Length--;
            RemainingLength--;
        }

        FieldStruct->PartyNumberLength = RemainingLength;
        FieldStruct->Present = TRUE;

        Tempptr = FieldStruct->PartyNumbers;
        for (i = 0; i < RemainingLength; i++)
        {
            // Copy the bytes out of the rest of the buffer
            *Tempptr = *(BufferDescriptor->BufferPtr);
            BufferDescriptor->BufferPtr++;
            BufferDescriptor->Length--;
            Tempptr++;
        }
        *Tempptr = (BYTE)0;
    }
    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional called party subaddress field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed 
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParseCalledPartySubaddress(
    PBUFFERDESCR BufferDescriptor,
    PCALLEDSUBADDRIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(CALLEDSUBADDRIE));
    FieldStruct->Present = FALSE;
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_CALLEDSUBADDR)
    {
        HRESULT ParseResult;
        ParseResult = ParseVariableOctet(BufferDescriptor, 
            &Ident, &FieldStruct->Length, &FieldStruct->Contents[0]);
        if (ParseResult != CS_OK)
        {
            return ParseResult;
        }
        if (FieldStruct->Length > 0)
        {
            FieldStruct->Present = TRUE;
        }
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional redirecting number field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed 
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParseRedirectingNumber(
    PBUFFERDESCR BufferDescriptor, 
    PREDIRECTINGIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(REDIRECTINGIE));
    FieldStruct->Present = FALSE;
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_REDIRECTING)
    {
        HRESULT ParseResult;
        ParseResult = ParseVariableOctet(BufferDescriptor, 
            &Ident, &FieldStruct->Length, &FieldStruct->Contents[0]);
        if (ParseResult != CS_OK)
        {
            return ParseResult;
        }
        if (FieldStruct->Length > 0)
        {
            FieldStruct->Present = TRUE;
        }
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional transit network selection field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed 
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParseTransitNetwork(
    PBUFFERDESCR BufferDescriptor, 
    PTRANSITNETIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(TRANSITNETIE));
    FieldStruct->Present = FALSE;
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_TRANSITNET)
    {
        HRESULT ParseResult;
        ParseResult = ParseVariableOctet(BufferDescriptor, 
            &Ident, &FieldStruct->Length, &FieldStruct->Contents[0]);
        if (ParseResult != CS_OK)
        {
            return ParseResult;
        }
        if (FieldStruct->Length > 0)
        {
            FieldStruct->Present = TRUE;
        }
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional restart indicator field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed 
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParseRestart(
    PBUFFERDESCR BufferDescriptor,
    PRESTARTIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(PRESTARTIE));
    FieldStruct->Present = FALSE;
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_RESTART)
    {
        HRESULT ParseResult;
        ParseResult = ParseVariableOctet(BufferDescriptor, 
            &Ident, &FieldStruct->Length, &FieldStruct->Contents[0]);
        if (ParseResult != CS_OK)
        {
            return ParseResult;
        }
        if (FieldStruct->Length > 0)
        {
            FieldStruct->Present = TRUE;
        }
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional lower layer compatibility field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed 
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParseLowLayerCompatibility(
    PBUFFERDESCR BufferDescriptor,
    PLLCOMPATIBILITYIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(LLCOMPATIBILITYIE));
    FieldStruct->Present = FALSE;
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_LLCOMPATIBILITY)
    {
        HRESULT ParseResult;
        ParseResult = ParseVariableOctet(BufferDescriptor, 
            &Ident, &FieldStruct->Length, &FieldStruct->Contents[0]);
        if (ParseResult != CS_OK)
        {
            return ParseResult;
        }
        if (FieldStruct->Length > 0)
        {
            FieldStruct->Present = TRUE;
        }
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional higher layer compatibility field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed 
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParseHighLayerCompatibility(
    PBUFFERDESCR BufferDescriptor,
    PHLCOMPATIBILITYIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(HLCOMPATIBILITYIE));
    FieldStruct->Present = FALSE;
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_HLCOMPATIBILITY)
    {
        HRESULT ParseResult;
        ParseResult = ParseVariableOctet(BufferDescriptor, 
            &Ident, &FieldStruct->Length, &FieldStruct->Contents[0]);
        if (ParseResult != CS_OK)
        {
            return ParseResult;
        }
        if (FieldStruct->Length > 0)
        {
            FieldStruct->Present = TRUE;
        }
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional user to user field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed 
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParseUserToUser(
    PBUFFERDESCR BufferDescriptor,
    PUSERUSERIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(USERUSERIE));
    FieldStruct->Present = FALSE;
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_USERUSER)
    {
        HRESULT ParseResult;

        ParseResult = ParseVariableASN(BufferDescriptor, 
            &Ident, &(FieldStruct->ProtocolDiscriminator),
            &(FieldStruct->UserInformationLength),
            &(FieldStruct->UserInformation[0]),
            sizeof(FieldStruct->UserInformation));

        if (ParseResult != CS_OK)
        {
            return ParseResult;
        }
        if (FieldStruct->UserInformationLength > 0)
        {
            FieldStruct->Present = TRUE;
        }
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse the next Q931 field in the given message
//
// Parameters:
//      BufferDescriptor  Pointer to buffer descriptor of a 
//                        the network packet of the 931 message
//      Message           Pointer to space for parsed information.
//------------------------------------------------------------------------------
static HRESULT
ParseQ931Field(
    PBUFFERDESCR BufferDescriptor,
    PQ931MESSAGE Message)
{
    FIELDIDENTTYPE Ident;

    Ident = GetNextIdent(BufferDescriptor->BufferPtr);
    switch (Ident)
    {
    case IDENT_SHIFT:
        return ParseShift(BufferDescriptor,
            &Message->Shift);
    case IDENT_FACILITY:
        return ParseFacility(BufferDescriptor,
            &Message->Facility);
    case IDENT_MORE:
        return ParseMoreData(BufferDescriptor,
            &Message->MoreData);
    case IDENT_SENDINGCOMPLETE:
        return ParseSendingComplete(BufferDescriptor,
            &Message->SendingComplete);
    case IDENT_CONGESTION:
        return ParseCongestionLevel(BufferDescriptor,
            &Message->CongestionLevel);
    case IDENT_REPEAT:
        return ParseRepeatIndicator(BufferDescriptor,
            &Message->RepeatIndicator);
    case IDENT_SEGMENTED:
        return ParseSegmented(BufferDescriptor,
            &Message->SegmentedMessage);
    case IDENT_BEARERCAP:
        return ParseBearerCapability(BufferDescriptor,
            &Message->BearerCapability);
    case IDENT_CAUSE:
        return ParseCause(BufferDescriptor,
            &Message->Cause);
    case IDENT_CALLIDENT:
        return ParseCallIdentity(BufferDescriptor,
            &Message->CallIdentity);
    case IDENT_CALLSTATE:
        return ParseCallState(BufferDescriptor,
            &Message->CallState);
    case IDENT_CHANNELIDENT:
        return ParseChannelIdentification(BufferDescriptor,
            &Message->ChannelIdentification);
    case IDENT_PROGRESS:
    case IDENT_PROGRESS2:
        return ParseProgress(BufferDescriptor,
            &Message->ProgressIndicator);
    case IDENT_NETWORKSPEC:
        return ParseNetworkSpec(BufferDescriptor,
            &Message->NetworkFacilities);
    case IDENT_NOTIFICATION:
        return ParseNotificationIndicator(BufferDescriptor,
            &Message->NotificationIndicator);
    case IDENT_DISPLAY:
        return ParseDisplay(BufferDescriptor,
            &Message->Display);
    case IDENT_DATE:
        return ParseDate(BufferDescriptor,
            &Message->Date);
    case IDENT_KEYPAD:
        return ParseKeypad(BufferDescriptor,
            &Message->Keypad);
    case IDENT_SIGNAL:
        return ParseSignal(BufferDescriptor,
            &Message->Signal);
    case IDENT_INFORMATIONRATE:
        return ParseInformationRate(BufferDescriptor,
            &Message->InformationRate);
    case IDENT_ENDTOENDDELAY:
        return ParseEndToEndDelay(BufferDescriptor,
            &Message->EndToEndTransitDelay);
    case IDENT_TRANSITDELAY:
        return ParseTransitDelay(BufferDescriptor,
            &Message->TransitDelay);
    case IDENT_PLBINARYPARAMS:
        return ParsePacketLayerParams(BufferDescriptor,
            &Message->PacketLayerBinaryParams);
    case IDENT_PLWINDOWSIZE:
        return ParsePacketLayerWindowSize(BufferDescriptor,
            &Message->PacketLayerWindowSize);
    case IDENT_PACKETSIZE:
        return ParsePacketSize(BufferDescriptor,
            &Message->PacketSize);
    case IDENT_CLOSEDUG:
        return ParseClosedUserGroup(BufferDescriptor,
            &Message->ClosedUserGroup);
    case IDENT_REVCHARGE:
        return ParseReverseCharge(BufferDescriptor,
            &Message->ReverseChargeIndication);
    case IDENT_CALLINGNUMBER:
        return ParseCallingPartyNumber(BufferDescriptor,
            &Message->CallingPartyNumber);
    case IDENT_CALLINGSUBADDR:
        return ParseCallingPartySubaddress(BufferDescriptor,
            &Message->CallingPartySubaddress);
    case IDENT_CALLEDNUMBER:
        return ParseCalledPartyNumber(BufferDescriptor,
            &Message->CalledPartyNumber);
    case IDENT_CALLEDSUBADDR:
        return ParseCalledPartySubaddress(BufferDescriptor,
            &Message->CalledPartySubaddress);
    case IDENT_REDIRECTING:
        return ParseRedirectingNumber(BufferDescriptor,
            &Message->RedirectingNumber);
    case IDENT_TRANSITNET:
        return ParseTransitNetwork(BufferDescriptor,
            &Message->TransitNetworkSelection);
    case IDENT_RESTART:
        return ParseRestart(BufferDescriptor,
            &Message->RestartIndicator);
    case IDENT_LLCOMPATIBILITY:
        return ParseLowLayerCompatibility(BufferDescriptor,
            &Message->LowLayerCompatibility);
    case IDENT_HLCOMPATIBILITY:
        return ParseHighLayerCompatibility(BufferDescriptor,
            &Message->HighLayerCompatibility);
    case IDENT_USERUSER:
        return ParseUserToUser(BufferDescriptor,
            &Message->UserToUser);
    default:
        return CS_INVALID_FIELD;
    }
}

//------------------------------------------------------------------------------
// Parse a generic Q931 message and place the fields of the buffer
// into the appropriate structure fields.
//
// Parameters:
//     BufferDescriptor  Pointer to buffer descriptor of an
//                       input packet containing the 931 message.
//     Message           Pointer to space for parsed output information.
//------------------------------------------------------------------------------
HRESULT
Q931ParseMessage(
    BYTE *CodedBufferPtr,
    DWORD CodedBufferLength,
    PQ931MESSAGE Message)
{
    HRESULT Result;
    BUFFERDESCR BufferDescriptor;

    BufferDescriptor.Length = CodedBufferLength;
    BufferDescriptor.BufferPtr = CodedBufferPtr;

    memset(Message, 0, sizeof(Q931MESSAGE));

    if ((Result = ParseProtocolDiscriminator(&BufferDescriptor,
        &Message->ProtocolDiscriminator)) != CS_OK)
    {
        return Result;
    }

    if ((Result = ParseCallReference(&BufferDescriptor,
        &Message->CallReference)) != CS_OK)
    {
        return Result;
    }

    if ((Result = ParseMessageType(&BufferDescriptor,
        &Message->MessageType)) != CS_OK)
    {
        return Result;
    }

    while (BufferDescriptor.Length)
    {
        Result = ParseQ931Field(&BufferDescriptor, Message);
        if (Result != CS_OK)
        {
            return Result;
        }
    }
    return CS_OK;
}


//==============================================================================
//==============================================================================
//==============================================================================
// BELOW HERE ARE THE OUTPUT ROUTINES...
//==============================================================================
//==============================================================================
//==============================================================================


//------------------------------------------------------------------------------
// Write the protocol discriminator. See Q931 section 4.2.
//------------------------------------------------------------------------------
static HRESULT
WriteProtocolDiscriminator(
    PBUFFERDESCR BufferDescriptor)
{
    BufferDescriptor->Length += sizeof(PDTYPE);
    if (BufferDescriptor->BufferPtr)
    {
        *(PDTYPE *)BufferDescriptor->BufferPtr = Q931PDVALUE;
        BufferDescriptor->BufferPtr += sizeof(PDTYPE);
    }
    return CS_OK;
}

//------------------------------------------------------------------------------
// Write a variable length Q931 call reference.  See Q931 section 4.3.
//------------------------------------------------------------------------------
static HRESULT
WriteCallReference(
    PBUFFERDESCR BufferDescriptor,
    CRTYPE *CallReference)
{
    register int i;

    // space for the length byte
    BufferDescriptor->Length++;

    // the length byte
    if (BufferDescriptor->BufferPtr != NULL)
    {
        *BufferDescriptor->BufferPtr = (BYTE)sizeof(CRTYPE);
        BufferDescriptor->BufferPtr++;
    }

    for (i = 0; i < sizeof(CRTYPE); i++)
    {
        // Copy the value bytes to the buffer
        BufferDescriptor->Length++;
        if (BufferDescriptor->BufferPtr != NULL)
        {
            *BufferDescriptor->BufferPtr =
                (BYTE)(((*CallReference) >> ((sizeof(CRTYPE) - 1 -i) * 8)) & 0xff);
            BufferDescriptor->BufferPtr++;
        }
    }
    return CS_OK;
}

//------------------------------------------------------------------------------
// Write a Q931 message type.  See Q931 section 4.4.
//------------------------------------------------------------------------------
static HRESULT
WriteMessageType(
    PBUFFERDESCR BufferDescriptor,
    MESSAGEIDTYPE *MessageType)
{
    register int i;

    for (i = 0; i < sizeof(MessageSet) / sizeof(MESSAGEIDTYPE); i++)
    {
        if (MessageSet[i] == *MessageType)
        {
            break;
        }
    }
    if (i >= sizeof(MessageSet) / sizeof(MESSAGEIDTYPE))
    {
        return CS_INVALID_MESSAGE_TYPE;
    }

    BufferDescriptor->Length += sizeof(MESSAGEIDTYPE);
    if (BufferDescriptor->BufferPtr != NULL)
    {
        *(MESSAGEIDTYPE *)(BufferDescriptor->BufferPtr) =
            (BYTE)(*MessageType & MESSAGETYPEMASK);
        BufferDescriptor->BufferPtr += sizeof(MESSAGEIDTYPE);
    }
    return CS_OK;
}

//------------------------------------------------------------------------------
// Write a single octet encoded value, See Q931 section 4.5.1.
//------------------------------------------------------------------------------
static HRESULT 
WriteSingleOctetType1(
    PBUFFERDESCR BufferDescriptor,
    BYTE Ident,
    BYTE Value)
{
    BufferDescriptor->Length++;
    if (BufferDescriptor->BufferPtr)
    {
        *BufferDescriptor->BufferPtr =
            (BYTE)(0x80 | Ident | (Value & TYPE1VALUEMASK));
        BufferDescriptor->BufferPtr++;
    }
    return CS_OK;
}

//------------------------------------------------------------------------------
// Write a single octet encoded value, See Q931 section 4.5.1.
//------------------------------------------------------------------------------
static HRESULT 
WriteSingleOctetType2(
    PBUFFERDESCR BufferDescriptor,
    BYTE Ident)
{
    BufferDescriptor->Length++;
    if (BufferDescriptor->BufferPtr)
    {
        *BufferDescriptor->BufferPtr = (BYTE)(0x80 | Ident);
        BufferDescriptor->BufferPtr++;
    }
    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse and return a variable length Q931 field see Q931 section 4.5.1.
//------------------------------------------------------------------------------
static HRESULT 
WriteVariableOctet(
    PBUFFERDESCR BufferDescriptor,
    BYTE Ident,
    BYTE Length,
    BYTE *Contents)
{
    register int i;
    BYTE *Tempptr;

    if (Contents == NULL)
    {
        Length = 0;
    }

    // space for the length and the identifier bytes
    BufferDescriptor->Length += 2;

    // the id byte, then the length byte
    if (BufferDescriptor->BufferPtr != NULL)
    {
        // low 7 bits of the first byte are the identifier
        *BufferDescriptor->BufferPtr = (BYTE)(Ident & 0x7f);
        BufferDescriptor->BufferPtr++;
        *BufferDescriptor->BufferPtr = Length;
        BufferDescriptor->BufferPtr++;
    }

    Tempptr = Contents;
    for (i = 0; i < Length; i++)
    {
        // Copy the value bytes to the buffer
        BufferDescriptor->Length++;
        if (BufferDescriptor->BufferPtr != NULL)
        {
            *BufferDescriptor->BufferPtr = *Tempptr;
            BufferDescriptor->BufferPtr++;
            Tempptr++;
        }
    }
    return CS_OK;
}

//------------------------------------------------------------------------------
//Write out the Party number.
//------------------------------------------------------------------------------
static HRESULT 
WritePartyNumber(
    PBUFFERDESCR BufferDescriptor,
    BYTE Ident,
    BYTE NumberType,
    BYTE NumberingPlan,
    BYTE PartyNumberLength,
    BYTE *PartyNumbers)
{
    register int i;
    BYTE *Tempptr;

    if (PartyNumbers == NULL)
    {
        PartyNumberLength = 0;
    }

    // space for the ident (1), length (1), and type + plan (1) fields.
    BufferDescriptor->Length += 3;

    // write the fields out.
    if (BufferDescriptor->BufferPtr != NULL)
    {
        // low 7 bits of byte 1 are the ie identifier
        *BufferDescriptor->BufferPtr = (BYTE)(Ident & 0x7f);
        BufferDescriptor->BufferPtr++;

        // byte 2 is the ie contents length following the length field.
        *BufferDescriptor->BufferPtr = (BYTE)(PartyNumberLength + 1);
        BufferDescriptor->BufferPtr++;

        // byte 3 is the type and plan field.
        *BufferDescriptor->BufferPtr = (BYTE)(NumberType | NumberingPlan);
        BufferDescriptor->BufferPtr++;
    }

    Tempptr = PartyNumbers;
    for (i = 0; i < PartyNumberLength; i++)
    {
        // Copy the value bytes to the buffer
        BufferDescriptor->Length++;
        if (BufferDescriptor->BufferPtr != NULL)
        {
            *BufferDescriptor->BufferPtr = *Tempptr;
            BufferDescriptor->BufferPtr++;
            Tempptr++;
        }
    }
    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse and return a variable length Q931 field see Q931 section 4.5.1.
//------------------------------------------------------------------------------
static HRESULT 
WriteVariableASN(
    PBUFFERDESCR BufferDescriptor,
    BYTE Ident,
    WORD UserInformationLength,
    BYTE *UserInformation)
{
    register int i;
    BYTE *Tempptr;
    WORD ContentsLength = (WORD)(UserInformationLength + 1);

    // There has to be at least 4 bytes for the IE identifier,
    // the contents length, and the protocol discriminator (1 + 2 + 1).
    BufferDescriptor->Length += 4;

    if (BufferDescriptor->BufferPtr != NULL)
    {
        // low 7 bits of the first byte are the identifier
        *BufferDescriptor->BufferPtr = (BYTE)(Ident & 0x7f);
        BufferDescriptor->BufferPtr++;

        // write the contents length bytes.
        *BufferDescriptor->BufferPtr = (BYTE)(ContentsLength >> 8);
        BufferDescriptor->BufferPtr++;
        *BufferDescriptor->BufferPtr = (BYTE)ContentsLength;
        BufferDescriptor->BufferPtr++;

        // write the protocol discriminator byte.
        *(BufferDescriptor->BufferPtr) = Q931_PROTOCOL_X209;
        BufferDescriptor->BufferPtr++;
    }

    Tempptr = UserInformation;
    for (i = 0; i < UserInformationLength; i++)
    {
        // Copy the value bytes to the buffer
        BufferDescriptor->Length++;
        if (BufferDescriptor->BufferPtr != NULL)
        {
            *BufferDescriptor->BufferPtr = *Tempptr;
            BufferDescriptor->BufferPtr++;
            Tempptr++;
        }
    }
    return CS_OK;
}

//------------------------------------------------------------------------------
// Write the Q931 fields to the encoding buffer.
//
// Parameters:
//      BufferDescriptor  Pointer to buffer descriptor for
//                        the encoded output buffer.
//      Message           Pointer to space for parsed input information.
//------------------------------------------------------------------------------
static HRESULT
WriteQ931Fields(
    PBUFFERDESCR BufferDescriptor,
    PQ931MESSAGE Message)
{
    // write the required information elements...
    WriteProtocolDiscriminator(BufferDescriptor);
    WriteCallReference(BufferDescriptor,
        &Message->CallReference);
    WriteMessageType(BufferDescriptor,
        &Message->MessageType);

    // try to write all other information elements...
// don't write this message.
#if 0
    if (Message->Shift.Present)
    {
        WriteSingleOctetType1(BufferDescriptor, IDENT_SHIFT,
            Message->Shift.Value);
    }
#endif

    if (Message->Facility.Present)
    {
        WriteVariableOctet(BufferDescriptor, IDENT_FACILITY,
            Message->Facility.Length,
            Message->Facility.Contents);
    }

    if (Message->MoreData.Present)
    {
        WriteSingleOctetType2(BufferDescriptor, IDENT_MORE);
    }
    if (Message->SendingComplete.Present)
    {
        WriteSingleOctetType2(BufferDescriptor, IDENT_SENDINGCOMPLETE);
    }
    if (Message->CongestionLevel.Present)
    {
        WriteSingleOctetType1(BufferDescriptor, IDENT_CONGESTION,
            Message->CongestionLevel.Value);
    }
    if (Message->RepeatIndicator.Present)
    {
        WriteSingleOctetType1(BufferDescriptor, IDENT_REPEAT,
            Message->RepeatIndicator.Value);
    }

    if (Message->SegmentedMessage.Present &&
            Message->SegmentedMessage.Length)
    {
        WriteVariableOctet(BufferDescriptor, IDENT_SEGMENTED,
            Message->SegmentedMessage.Length,
            Message->SegmentedMessage.Contents);
    }
    if (Message->BearerCapability.Present &&
            Message->BearerCapability.Length)
    {
        WriteVariableOctet(BufferDescriptor, IDENT_BEARERCAP,
            Message->BearerCapability.Length,
            Message->BearerCapability.Contents);
    }
    if (Message->Cause.Present &&
            Message->Cause.Length)
    {
        WriteVariableOctet(BufferDescriptor, IDENT_CAUSE,
            Message->Cause.Length,
            Message->Cause.Contents);
    }
    if (Message->CallIdentity.Present &&
            Message->CallIdentity.Length)
    {
        WriteVariableOctet(BufferDescriptor, IDENT_CALLIDENT,
            Message->CallIdentity.Length,
            Message->CallIdentity.Contents);
    }
    if (Message->CallState.Present &&
            Message->CallState.Length)
    {
        WriteVariableOctet(BufferDescriptor, IDENT_CALLSTATE,
            Message->CallState.Length,
            Message->CallState.Contents);
    }
    if (Message->ChannelIdentification.Present &&
            Message->ChannelIdentification.Length)
    {
        WriteVariableOctet(BufferDescriptor, IDENT_CHANNELIDENT,
            Message->ChannelIdentification.Length,
            Message->ChannelIdentification.Contents);
    }
    if (Message->ProgressIndicator.Present &&
            Message->ProgressIndicator.Length)
    {
        WriteVariableOctet(BufferDescriptor, IDENT_PROGRESS,
            Message->ProgressIndicator.Length,
            Message->ProgressIndicator.Contents);
    }
    if (Message->NetworkFacilities.Present &&
            Message->NetworkFacilities.Length)
    {
        WriteVariableOctet(BufferDescriptor, IDENT_NETWORKSPEC,
            Message->NetworkFacilities.Length,
            Message->NetworkFacilities.Contents);
    }
    if (Message->NotificationIndicator.Present &&
            Message->NotificationIndicator.Length)
    {
        WriteVariableOctet(BufferDescriptor, IDENT_NOTIFICATION,
            Message->NotificationIndicator.Length,
            Message->NotificationIndicator.Contents);
    }
    if (Message->Display.Present &&
            Message->Display.Length)
    {
        WriteVariableOctet(BufferDescriptor, IDENT_DISPLAY,
            Message->Display.Length,
            Message->Display.Contents);
    }
    if (Message->Date.Present &&
            Message->Date.Length)
    {
        WriteVariableOctet(BufferDescriptor, IDENT_DATE,
            Message->Date.Length,
            Message->Date.Contents);
    }
    if (Message->Keypad.Present &&
            Message->Keypad.Length)
    {
        WriteVariableOctet(BufferDescriptor, IDENT_KEYPAD,
            Message->Keypad.Length,
            Message->Keypad.Contents);
    }
    if (Message->Signal.Present &&
            Message->Signal.Length)
    {
        WriteVariableOctet(BufferDescriptor, IDENT_SIGNAL,
            Message->Signal.Length,
            Message->Signal.Contents);
    }
    if (Message->InformationRate.Present &&
            Message->InformationRate.Length)
    {
        WriteVariableOctet(BufferDescriptor, IDENT_INFORMATIONRATE,
            Message->InformationRate.Length,
            Message->InformationRate.Contents);
    }
    if (Message->EndToEndTransitDelay.Present &&
            Message->EndToEndTransitDelay.Length)
    {
        WriteVariableOctet(BufferDescriptor, IDENT_ENDTOENDDELAY,
            Message->EndToEndTransitDelay.Length,
            Message->EndToEndTransitDelay.Contents);
    }
    if (Message->TransitDelay.Present &&
            Message->TransitDelay.Length)
    {
        WriteVariableOctet(BufferDescriptor, IDENT_TRANSITDELAY,
            Message->TransitDelay.Length,
            Message->TransitDelay.Contents);
    }
    if (Message->PacketLayerBinaryParams.Present &&
            Message->PacketLayerBinaryParams.Length)
    {
        WriteVariableOctet(BufferDescriptor, IDENT_PLBINARYPARAMS,
            Message->PacketLayerBinaryParams.Length,
            Message->PacketLayerBinaryParams.Contents);
    }
    if (Message->PacketLayerWindowSize.Present &&
            Message->PacketLayerWindowSize.Length)
    {
        WriteVariableOctet(BufferDescriptor, IDENT_PLWINDOWSIZE,
            Message->PacketLayerWindowSize.Length,
            Message->PacketLayerWindowSize.Contents);
    }
    if (Message->PacketSize.Present &&
            Message->PacketSize.Length)
    {
        WriteVariableOctet(BufferDescriptor, IDENT_PACKETSIZE,
            Message->PacketSize.Length,
            Message->PacketSize.Contents);
    }
    if (Message->ClosedUserGroup.Present &&
            Message->ClosedUserGroup.Length)
    {
        WriteVariableOctet(BufferDescriptor, IDENT_CLOSEDUG,
            Message->ClosedUserGroup.Length,
            Message->ClosedUserGroup.Contents);
    }
    if (Message->ReverseChargeIndication.Present &&
            Message->ReverseChargeIndication.Length)
    {
        WriteVariableOctet(BufferDescriptor, IDENT_REVCHARGE,
            Message->ReverseChargeIndication.Length,
            Message->ReverseChargeIndication.Contents);
    }
    if (Message->CallingPartyNumber.Present &&
            Message->CallingPartyNumber.Length)
    {
        WriteVariableOctet(BufferDescriptor, IDENT_CALLINGNUMBER,
            Message->CallingPartyNumber.Length,
            Message->CallingPartyNumber.Contents);
    }
    if (Message->CallingPartySubaddress.Present &&
            Message->CallingPartySubaddress.Length)
    {
        WriteVariableOctet(BufferDescriptor, IDENT_CALLINGSUBADDR,
            Message->CallingPartySubaddress.Length,
            Message->CallingPartySubaddress.Contents);
    }
    if (Message->CalledPartyNumber.Present)
    {
        WritePartyNumber(BufferDescriptor, IDENT_CALLEDNUMBER,
            Message->CalledPartyNumber.NumberType,
            Message->CalledPartyNumber.NumberingPlan,
            Message->CalledPartyNumber.PartyNumberLength,
            Message->CalledPartyNumber.PartyNumbers);
     }
    if (Message->CalledPartySubaddress.Present &&
            Message->CalledPartySubaddress.Length)
    {
        WriteVariableOctet(BufferDescriptor, IDENT_CALLEDSUBADDR,
            Message->CalledPartySubaddress.Length,
            Message->CalledPartySubaddress.Contents);
    }
    if (Message->RedirectingNumber.Present &&
            Message->RedirectingNumber.Length)
    {
        WriteVariableOctet(BufferDescriptor, IDENT_REDIRECTING,
            Message->RedirectingNumber.Length,
            Message->RedirectingNumber.Contents);
    }
    if (Message->TransitNetworkSelection.Present &&
            Message->TransitNetworkSelection.Length)
    {
        WriteVariableOctet(BufferDescriptor, IDENT_TRANSITNET,
            Message->TransitNetworkSelection.Length,
            Message->TransitNetworkSelection.Contents);
    }
    if (Message->RestartIndicator.Present &&
            Message->RestartIndicator.Length)
    {
        WriteVariableOctet(BufferDescriptor, IDENT_RESTART,
            Message->RestartIndicator.Length,
            Message->RestartIndicator.Contents);
    }
    if (Message->LowLayerCompatibility.Present &&
            Message->LowLayerCompatibility.Length)
    {
        WriteVariableOctet(BufferDescriptor, IDENT_LLCOMPATIBILITY,
            Message->LowLayerCompatibility.Length,
            Message->LowLayerCompatibility.Contents);
    }
    if (Message->HighLayerCompatibility.Present &&
            Message->HighLayerCompatibility.Length)
    {
        WriteVariableOctet(BufferDescriptor, IDENT_HLCOMPATIBILITY,
            Message->HighLayerCompatibility.Length,
            Message->HighLayerCompatibility.Contents);
    }
    if (Message->UserToUser.Present &&
            Message->UserToUser.UserInformationLength)
    {
        WriteVariableASN(BufferDescriptor,
            IDENT_USERUSER,
            Message->UserToUser.UserInformationLength,
            Message->UserToUser.UserInformation);
    }
    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse a generic Q931 message and place the fields of the 
// of the buffer into the appropriate field structure.
//
// Parameters:
//     BufferDescriptor  Pointer to buffer descriptor of a 
//                       the network packet of the 931 message
//     Message           Pointer to space for parsed information.
//------------------------------------------------------------------------------
HRESULT
Q931MakeEncodedMessage(
    PQ931MESSAGE Message,
    BYTE **CodedBufferPtr,
    DWORD *CodedBufferLength)
{
    BUFFERDESCR BufferDescriptor;
    BYTE *OutBuffer = NULL;
    DWORD Pass1Length = 0;

    if ((CodedBufferPtr == NULL) || (CodedBufferLength == NULL))
    {
        return CS_BAD_PARAM;
    }

    BufferDescriptor.Length = 0;
    BufferDescriptor.BufferPtr = NULL;

    WriteQ931Fields(&BufferDescriptor, Message);
    if (BufferDescriptor.Length == 0)
    {
        return CS_NO_FIELD_DATA;
    }

    Pass1Length = BufferDescriptor.Length;

    OutBuffer = (BYTE *)MemAlloc(BufferDescriptor.Length + 1000);
    if (OutBuffer == NULL)
    {
        return CS_NO_MEMORY;
    }

    BufferDescriptor.Length = 0;
    BufferDescriptor.BufferPtr = OutBuffer;

    WriteQ931Fields(&BufferDescriptor, Message);

    if (Pass1Length != BufferDescriptor.Length)
    {
        // this is a serious error, since memory may have been overrun.
        return CS_BAD_PARAM;
    }

    *CodedBufferPtr = OutBuffer;
    *CodedBufferLength = BufferDescriptor.Length;

    return CS_OK;
}


//-------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------
HRESULT
Q931SetupEncodePDU(
    WORD wCallReference,
    char *pszDisplay,
    char *pszCalledPartyNumber,
    BINARY_STRING *pUserUserData,
    BYTE **CodedBufferPtr,
    DWORD *CodedBufferLength)
{
    Q931MESSAGE *pMessage;
    HRESULT Result = CS_OK;

    pMessage = (Q931MESSAGE *)MemAlloc(sizeof(Q931MESSAGE));
    if (pMessage == NULL)
    {
        return CS_NO_MEMORY;
    }

    // fill in the required fields for the setup message.
    memset(pMessage, 0, sizeof(Q931MESSAGE));
    pMessage->ProtocolDiscriminator = Q931PDVALUE;
    pMessage->CallReference = wCallReference;
    pMessage->MessageType = SETUPMESSAGETYPE;

    pMessage->BearerCapability.Present = TRUE;
    pMessage->BearerCapability.Length = 3;
    pMessage->BearerCapability.Contents[0] =
        (BYTE)(BEAR_EXT_BIT | BEAR_CCITT | BEAR_UNRESTRICTED_DIGITAL);
    pMessage->BearerCapability.Contents[1] = 
        (BYTE)(BEAR_EXT_BIT | BEAR_PACKET_MODE | BEAR_NO_CIRCUIT_RATE);
    pMessage->BearerCapability.Contents[2] = 
        (BYTE)(BEAR_EXT_BIT | BEAR_LAYER1_INDICATOR | BEAR_LAYER1_H221_H242);

    if (pszDisplay && *pszDisplay)
    {
        pMessage->Display.Present = TRUE;
        pMessage->Display.Length = (BYTE)(strlen(pszDisplay) + 1);
        strcpy((char *)pMessage->Display.Contents, pszDisplay);
    }

    if (pszCalledPartyNumber && *pszCalledPartyNumber)
    {
        WORD wLen = (WORD)strlen(pszCalledPartyNumber);
        pMessage->CalledPartyNumber.Present = TRUE;

        pMessage->CalledPartyNumber.NumberType =
            (BYTE)(CALLED_PARTY_EXT_BIT | CALLED_PARTY_TYPE_UNKNOWN);
        pMessage->CalledPartyNumber.NumberingPlan =
            (BYTE)(CALLED_PARTY_PLAN_E164);
        pMessage->CalledPartyNumber.PartyNumberLength = (BYTE)wLen;
        memcpy(pMessage->CalledPartyNumber.PartyNumbers,
            pszCalledPartyNumber, wLen);
    }

    if (pUserUserData && pUserUserData->ptr)
    {
        if (pUserUserData->length > sizeof(pMessage->UserToUser.UserInformation))
        {
            MemFree(pMessage);
            return CS_BAD_PARAM;
        }
        pMessage->UserToUser.Present = TRUE;
        pMessage->UserToUser.UserInformationLength = (pUserUserData->length);
        memcpy(pMessage->UserToUser.UserInformation,
            pUserUserData->ptr, pUserUserData->length);
    }
    Result = Q931MakeEncodedMessage(pMessage, CodedBufferPtr,
        CodedBufferLength);

    MemFree(pMessage);
    return Result;
}

//-------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------
HRESULT
Q931ReleaseCompleteEncodePDU(
    WORD wCallReference,
    BYTE *pbCause,
    BINARY_STRING *pUserUserData,
    BYTE **CodedBufferPtr,
    DWORD *CodedBufferLength)
{
    Q931MESSAGE *pMessage;
    HRESULT Result = CS_OK;

    if (pbCause)
    {
        switch (*pbCause)
        {
            case CAUSE_VALUE_NORMAL_CLEAR:
            case CAUSE_VALUE_USER_BUSY:
            case CAUSE_VALUE_SECURITY_DENIED:
            case CAUSE_VALUE_NO_ANSWER:
            case CAUSE_VALUE_REJECTED:
            case CAUSE_VALUE_NOT_IMPLEMENTED:
            case CAUSE_VALUE_INVALID_CRV:
            case CAUSE_VALUE_IE_MISSING:
            case CAUSE_VALUE_IE_CONTENTS:
            case CAUSE_VALUE_TIMER_EXPIRED:
                break;
            default:
                return CS_BAD_PARAM;
                break;
        }
    }

    pMessage = (Q931MESSAGE *)MemAlloc(sizeof(Q931MESSAGE));
    if (pMessage == NULL)
    {
        return CS_NO_MEMORY;
    }

    // fill in the required fields for the setup message.
    memset(pMessage, 0, sizeof(Q931MESSAGE));
    pMessage->ProtocolDiscriminator = Q931PDVALUE;
    pMessage->CallReference = wCallReference;
    pMessage->MessageType = RELEASECOMPLMESSAGETYPE;

    if (pbCause)
    {
        pMessage->Cause.Present = TRUE;
        pMessage->Cause.Length = 3;
        pMessage->Cause.Contents[0] = (BYTE)(CAUSE_CODING_CCITT | CAUSE_LOCATION_USER);
        pMessage->Cause.Contents[1] = (BYTE)(CAUSE_RECOMMENDATION_Q931);
        pMessage->Cause.Contents[2] = (BYTE)(CAUSE_EXT_BIT | *pbCause);
    }
    else
    {
        pMessage->Cause.Present = FALSE;
    }

    if (pUserUserData && pUserUserData->ptr)
    {
        if (pUserUserData->length > sizeof(pMessage->UserToUser.UserInformation))
        {
            MemFree(pMessage);
            return CS_BAD_PARAM;
        }
        pMessage->UserToUser.Present = TRUE;
        pMessage->UserToUser.UserInformationLength = (pUserUserData->length);
        memcpy(pMessage->UserToUser.UserInformation,
            pUserUserData->ptr, pUserUserData->length);
    }
    Result = Q931MakeEncodedMessage(pMessage, CodedBufferPtr,
        CodedBufferLength);

    MemFree(pMessage);
    return Result;
}

//-------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------
HRESULT
Q931ConnectEncodePDU(
    WORD wCallReference,
    char *pszDisplay,
    BINARY_STRING *pUserUserData,
    BYTE **CodedBufferPtr,
    DWORD *CodedBufferLength)
{
    Q931MESSAGE *pMessage;
    HRESULT Result = CS_OK;

    pMessage = (Q931MESSAGE *)MemAlloc(sizeof(Q931MESSAGE));
    if (pMessage == NULL)
    {
        return CS_NO_MEMORY;
    }

    // fill in the required fields for the setup message.
    memset(pMessage, 0, sizeof(Q931MESSAGE));
    pMessage->ProtocolDiscriminator = Q931PDVALUE;
    pMessage->CallReference = wCallReference;
    pMessage->MessageType = CONNECTMESSAGETYPE;

    pMessage->BearerCapability.Present = TRUE;
    pMessage->BearerCapability.Length = 3;
    pMessage->BearerCapability.Contents[0] =
        (BYTE)(BEAR_EXT_BIT | BEAR_CCITT | BEAR_UNRESTRICTED_DIGITAL);
    pMessage->BearerCapability.Contents[1] = 
        (BYTE)(BEAR_EXT_BIT | BEAR_PACKET_MODE | BEAR_NO_CIRCUIT_RATE);
    pMessage->BearerCapability.Contents[2] = 
        (BYTE)(BEAR_EXT_BIT | BEAR_LAYER1_INDICATOR | BEAR_LAYER1_H221_H242);

    if (pszDisplay && *pszDisplay)
    {
        pMessage->Display.Present = TRUE;
        pMessage->Display.Length = (BYTE)strlen(pszDisplay);
        strcpy((char *)pMessage->Display.Contents, pszDisplay);
    }

    if (pUserUserData && pUserUserData->ptr)
    {
        if (pUserUserData->length > sizeof(pMessage->UserToUser.UserInformation))
        {
            MemFree(pMessage);
            return CS_BAD_PARAM;
        }
        pMessage->UserToUser.Present = TRUE;
        pMessage->UserToUser.UserInformationLength = (pUserUserData->length);
        memcpy(pMessage->UserToUser.UserInformation,
            pUserUserData->ptr, pUserUserData->length);
    }
    Result = Q931MakeEncodedMessage(pMessage, CodedBufferPtr,
        CodedBufferLength);

    MemFree(pMessage);
    return Result;
}

//-------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------
HRESULT
Q931ProceedingEncodePDU(
    WORD wCallReference,
    BINARY_STRING *pUserUserData,
    BYTE **CodedBufferPtr,
    DWORD *CodedBufferLength)
{
    Q931MESSAGE *pMessage;
    HRESULT Result = CS_OK;

    pMessage = (Q931MESSAGE *)MemAlloc(sizeof(Q931MESSAGE));
    if (pMessage == NULL)
    {
        return CS_NO_MEMORY;
    }

    // fill in the required fields for the setup message.
    memset(pMessage, 0, sizeof(Q931MESSAGE));
    pMessage->ProtocolDiscriminator = Q931PDVALUE;
    pMessage->CallReference = wCallReference;
    pMessage->MessageType = PROCEEDINGMESSAGETYPE;

    if (pUserUserData && pUserUserData->ptr)
    {
        if (pUserUserData->length > sizeof(pMessage->UserToUser.UserInformation))
        {
            MemFree(pMessage);
            return CS_BAD_PARAM;
        }
        pMessage->UserToUser.Present = TRUE;
        pMessage->UserToUser.UserInformationLength = (pUserUserData->length);
        memcpy(pMessage->UserToUser.UserInformation,
            pUserUserData->ptr, pUserUserData->length);
    }
    Result = Q931MakeEncodedMessage(pMessage, CodedBufferPtr,
        CodedBufferLength);

    MemFree(pMessage);
    return Result;
}

//-------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------
HRESULT
Q931AlertingEncodePDU(
    WORD wCallReference,
    BINARY_STRING *pUserUserData,
    BYTE **CodedBufferPtr,
    DWORD *CodedBufferLength)
{
    Q931MESSAGE *pMessage;
    HRESULT Result = CS_OK;

    pMessage = (Q931MESSAGE *)MemAlloc(sizeof(Q931MESSAGE));
    if (pMessage == NULL)
    {
        return CS_NO_MEMORY;
    }

    // fill in the required fields for the setup message.
    memset(pMessage, 0, sizeof(Q931MESSAGE));
    pMessage->ProtocolDiscriminator = Q931PDVALUE;
    pMessage->CallReference = wCallReference;
    pMessage->MessageType = ALERTINGMESSAGETYPE;

    if (pUserUserData && pUserUserData->ptr)
    {
        if (pUserUserData->length > sizeof(pMessage->UserToUser.UserInformation))
        {
            MemFree(pMessage);
            return CS_BAD_PARAM;
        }
        pMessage->UserToUser.Present = TRUE;
        pMessage->UserToUser.UserInformationLength = (pUserUserData->length);
        memcpy(pMessage->UserToUser.UserInformation,
            pUserUserData->ptr, pUserUserData->length);
    }
    Result = Q931MakeEncodedMessage(pMessage, CodedBufferPtr,
        CodedBufferLength);

    MemFree(pMessage);
    return Result;
}

//-------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------
HRESULT
Q931FacilityEncodePDU(
    WORD wCallReference,
    BINARY_STRING *pUserUserData,
    BYTE **CodedBufferPtr,
    DWORD *CodedBufferLength)
{
    Q931MESSAGE *pMessage;
    HRESULT Result = CS_OK;

    pMessage = (Q931MESSAGE *)MemAlloc(sizeof(Q931MESSAGE));
    if (pMessage == NULL)
    {
        return CS_NO_MEMORY;
    }

    // fill in the required fields for the setup message.
    memset(pMessage, 0, sizeof(Q931MESSAGE));
    pMessage->ProtocolDiscriminator = Q931PDVALUE;
    pMessage->CallReference = wCallReference;
    pMessage->MessageType = FACILITYMESSAGETYPE;

    // The facility ie is encoded as present, but empty...
    pMessage->Facility.Present = TRUE;
    pMessage->Facility.Length = 0;
    pMessage->Facility.Contents[0] = 0;

    if (pUserUserData && pUserUserData->ptr)
    {
        if (pUserUserData->length > sizeof(pMessage->UserToUser.UserInformation))
        {
            MemFree(pMessage);
            return CS_BAD_PARAM;
        }
        pMessage->UserToUser.Present = TRUE;
        pMessage->UserToUser.UserInformationLength = (pUserUserData->length);
        memcpy(pMessage->UserToUser.UserInformation,
            pUserUserData->ptr, pUserUserData->length);
    }
    Result = Q931MakeEncodedMessage(pMessage, CodedBufferPtr,
        CodedBufferLength);

    MemFree(pMessage);
    return Result;
}

//-------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------
HRESULT
Q931StatusEncodePDU(
    WORD wCallReference,
    char *pszDisplay,
    BYTE bCause,
    BYTE bCallState,
    BYTE **CodedBufferPtr,
    DWORD *CodedBufferLength)
{
    Q931MESSAGE *pMessage;
    HRESULT Result = CS_OK;

    pMessage = (Q931MESSAGE *)MemAlloc(sizeof(Q931MESSAGE));
    if (pMessage == NULL)
    {
        return CS_NO_MEMORY;
    }

    // fill in the required fields for the setup message.
    memset(pMessage, 0, sizeof(Q931MESSAGE));
    pMessage->ProtocolDiscriminator = Q931PDVALUE;
    pMessage->CallReference = wCallReference;
    pMessage->MessageType = STATUSMESSAGETYPE;

    if (pszDisplay && *pszDisplay)
    {
        pMessage->Display.Present = TRUE;
        pMessage->Display.Length = (BYTE)(strlen(pszDisplay) + 1);
        strcpy((char *)pMessage->Display.Contents, pszDisplay);
    }

    pMessage->Cause.Present = TRUE;
    pMessage->Cause.Length = 3;
    pMessage->Cause.Contents[0] = (BYTE)(CAUSE_CODING_CCITT | CAUSE_LOCATION_USER);
    pMessage->Cause.Contents[1] = (BYTE)(CAUSE_RECOMMENDATION_Q931);
    pMessage->Cause.Contents[2] = (BYTE)(CAUSE_EXT_BIT | bCause);

    pMessage->CallState.Present = TRUE;
    pMessage->CallState.Length = 1;
    pMessage->CallState.Contents[0] = (BYTE)(bCallState);

    Result = Q931MakeEncodedMessage(pMessage, CodedBufferPtr,
        CodedBufferLength);

    MemFree(pMessage);
    return Result;
}
#if(0)
//========================================================================
//========================================================================
//========================================================================
// THIS IS THE ASN PART...
//========================================================================
//========================================================================
//========================================================================

static ERROR_MAP EncodeErrorMap[] =
{
    PDU_ENCODED, __TEXT("PDU successfully encoded"),
    MORE_BUF, __TEXT("User-provided output buffer too small"),
    PDU_RANGE, __TEXT("PDU specified out of range"),
    BAD_ARG, __TEXT("Bad pointer was passed"),
    BAD_VERSION, __TEXT("Versions of encoder and table do not match"),
    OUT_MEMORY, __TEXT("Memory-allocation error"),
    BAD_CHOICE, __TEXT("Unknown selector for a choice"),
    BAD_OBJID, __TEXT("Object identifier conflicts with x.208"),
    BAD_PTR, __TEXT("Unexpected NULL pointer in input buffer"),
    BAD_TIME, __TEXT("Bad value in time type"),
    MEM_ERROR, __TEXT("Memory violation signal trapped"),
    BAD_TABLE, __TEXT("Table was bad, but not NULL"),
    TOO_LONG, __TEXT("Type was longer than constraint"),
    CONSTRAINT_VIOLATED, __TEXT("Constraint violation error occured"),
    FATAL_ERROR, __TEXT("Serious internal error"),
    ACCESS_SERIALIZATION_ERROR, __TEXT("Thread access to global data failed"),
    NULL_TBL, __TEXT("NULL control table pointer"),
    NULL_FCN, __TEXT("Encoder called via a NULL pointer"),
    BAD_ENCRULES, __TEXT("Unknown encoding rules"),
    UNAVAIL_ENCRULES, __TEXT("Encoding rules requested are not implemented"),
    UNIMPLEMENTED, __TEXT("Type was not implemented yet"),
//    LOAD_ERR, __TEXT("Unable to load DLL"),
    CANT_OPEN_TRACE_FILE, __TEXT("Error when opening a trace file"),
    TRACE_FILE_ALREADY_OPEN, __TEXT("Trace file has been opened"),
    TABLE_MISMATCH, __TEXT("Control table mismatch"),
    0, NULL
};

static ERROR_MAP DecodeErrorMap[] =
{
    PDU_DECODED, __TEXT("PDU successfully decoded"),
    MORE_BUF, __TEXT("User-provided output buffer too small"),
    NEGATIVE_UINTEGER, __TEXT("The first unsigned bit of the encoding is 1"),
    PDU_RANGE, __TEXT("Pdu specified out of range"),
    MORE_INPUT, __TEXT("Unexpected end of input buffer"),
    DATA_ERROR, __TEXT("An error exists in the encoded data"),
    BAD_VERSION, __TEXT("Versions of encoder and table do not match"),
    OUT_MEMORY, __TEXT("Memory-allocation error"),
    PDU_MISMATCH, __TEXT("The PDU tag does not match data"),
    LIMITED, __TEXT("Size implementation limit exceeded"),
    CONSTRAINT_VIOLATED, __TEXT("Constraint violation error occured"),
    ACCESS_SERIALIZATION_ERROR, __TEXT("Thread access to global data failed"),
    NULL_TBL, __TEXT("NULL control table pointer"),
    NULL_FCN, __TEXT("Encoder called via a NULL pointer"),
    BAD_ENCRULES, __TEXT("Unknown encoding rules"),
    UNAVAIL_ENCRULES, __TEXT("Encoding rules requested are not implemented"),
    UNIMPLEMENTED, __TEXT("The type was not implemented yet"),
//    LOAD_ERR, __TEXT("Unable to load DLL"),
    CANT_OPEN_TRACE_FILE, __TEXT("Error when opening a trace file"),
    TRACE_FILE_ALREADY_OPEN, __TEXT("The trace file has been opened"),
    TABLE_MISMATCH, __TEXT("Control table mismatch"),
    0, NULL
};

#endif // if(0)

//====================================================================================
//====================================================================================
#ifdef UNICODE_TRACE
LPWSTR
#else
LPSTR
#endif
ErrorToTextASN(ERROR_MAP *Map, int nErrorCode)
{
    register int nIndex = 0;

    if (Map != NULL)
    {
        for (nIndex = 0; Map[nIndex].pszErrorText; nIndex++)
        {
            if (Map[nIndex].nErrorCode == nErrorCode)
            {
                return Map[nIndex].pszErrorText;
            }
        }
    }
    return __TEXT("Unknown ASN.1 Error");
}

#if 0
//------------------------------------------------------------------------
//------------------------------------------------------------------------
int
ASN1LinePrint(FILE *stream, const char *format, ...)
{
    va_list marker;
    char buf[300];
    int i;

    va_start(marker, format);
    i = wsprintf(buf, format, marker);
    va_end(marker);

    // TRACE the buf...
    ISRTRACE(ghISRInst, buf, 0L);

    return i;
}
#endif



#define USE_ASN1_ENCODING 5

//-------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------
HRESULT
Q931SetupEncodeASN(
    PCC_NONSTANDARDDATA pNonStandardData,
    CC_ADDR *pCallerAddr,                     // this data is not yet passed in the PDU...
    CC_ADDR *pCalleeAddr,
    WORD wGoal,
    WORD wCallType,
    BOOL bCallerIsMC,
    CC_CONFERENCEID *pConferenceID,
    PCC_ALIASNAMES pCallerAliasList,
    PCC_ALIASNAMES pCalleeAliasList,
    PCC_ALIASNAMES pExtraAliasList,
    PCC_ALIASITEM pExtensionAliasItem,
    PCC_VENDORINFO pVendorInfo,
    BOOL bIsTerminal,
    BOOL bIsGateway,
    ASN1_CODER_INFO *pWorld,
    BYTE **ppEncodedBuf,
    DWORD *pdwEncodedLength,
    LPGUID pCallIdentifier)
{
    int rc;
    H323_UserInformation UserInfo;

    *ppEncodedBuf = NULL;
    *pdwEncodedLength = 0;

    memset(&UserInfo, 0, sizeof(H323_UserInformation));

    // redundant! memset to zero ---> UserInfo.bit_mask = 0;

    // make sure the user_data_present flag is turned off.
    // redundant ---> UserInfo.bit_mask &= (~user_data_present);

    if (pNonStandardData)
    {
        UserInfo.h323_uu_pdu.bit_mask |= H323_UU_PDU_nnStndrdDt_present;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.choice = 
            H225NonStandardIdentifier_h221NonStandard_chosen;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.t35CountryCode =
            pNonStandardData->bCountryCode;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.t35Extension =
            pNonStandardData->bExtension;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.manufacturerCode =
            pNonStandardData->wManufacturerCode;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.data.length =
            pNonStandardData->sData.wOctetStringLength;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.data.value =
            pNonStandardData->sData.pOctetString;
    }
    else
    {
        UserInfo.h323_uu_pdu.bit_mask &= (~H323_UU_PDU_nnStndrdDt_present);
    }

    UserInfo.h323_uu_pdu.h323_message_body.choice = setup_chosen;
    UserInfo.h323_uu_pdu.h323_message_body.u.setup.bit_mask = 0;

    UserInfo.h323_uu_pdu.h323_message_body.u.setup.protocolIdentifier = &ProtocolId1;

    if (pCallerAliasList)
    {
        CS_STATUS AliasResult = CS_OK;
        AliasResult = AliasToSeqof((struct Setup_UUIE_sourceAddress **)&(UserInfo.h323_uu_pdu.
            h323_message_body.u.setup.sourceAddress), pCallerAliasList);
        if (AliasResult != CS_OK)
        {
            return CS_NO_MEMORY;
        }
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.bit_mask |=
            (sourceAddress_present);
    }
    else
    {
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.bit_mask &=
            (~sourceAddress_present);
    }

    UserInfo.h323_uu_pdu.h323_message_body.u.setup.sourceInfo.bit_mask = 0;

    if (pVendorInfo)
    {
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.sourceInfo.bit_mask |= vendor_present;
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.sourceInfo.vendor.bit_mask = 0;
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.sourceInfo.vendor.vendor.t35CountryCode = pVendorInfo->bCountryCode;
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.sourceInfo.vendor.vendor.t35Extension = pVendorInfo->bExtension;
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.sourceInfo.vendor.vendor.manufacturerCode = pVendorInfo->wManufacturerCode;
        if (pVendorInfo->pProductNumber && pVendorInfo->pProductNumber->pOctetString &&
                pVendorInfo->pProductNumber->wOctetStringLength)
        {
            UserInfo.h323_uu_pdu.h323_message_body.u.setup.sourceInfo.vendor.bit_mask |= productId_present;
            UserInfo.h323_uu_pdu.h323_message_body.u.setup.sourceInfo.vendor.productId.length =
                pVendorInfo->pProductNumber->wOctetStringLength;
            memcpy(UserInfo.h323_uu_pdu.h323_message_body.u.setup.sourceInfo.vendor.productId.value,
                pVendorInfo->pProductNumber->pOctetString,
                pVendorInfo->pProductNumber->wOctetStringLength);
        }
        if (pVendorInfo->pVersionNumber && pVendorInfo->pVersionNumber->pOctetString &&
                pVendorInfo->pVersionNumber->wOctetStringLength)
        {
            UserInfo.h323_uu_pdu.h323_message_body.u.setup.sourceInfo.vendor.bit_mask |= versionId_present;
            UserInfo.h323_uu_pdu.h323_message_body.u.setup.sourceInfo.vendor.versionId.length =
                pVendorInfo->pVersionNumber->wOctetStringLength;
            memcpy(UserInfo.h323_uu_pdu.h323_message_body.u.setup.sourceInfo.vendor.versionId.value,
                pVendorInfo->pVersionNumber->pOctetString,
                pVendorInfo->pVersionNumber->wOctetStringLength);
        }
    }

    if (bIsTerminal)
    {
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.sourceInfo.bit_mask |=
            terminal_present;
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.sourceInfo.terminal.bit_mask = 0;
    }

    if (bIsGateway)
    {
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.sourceInfo.bit_mask |=
            gateway_present;
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.sourceInfo.gateway.bit_mask = protocol_present;
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.sourceInfo.gateway.protocol = &TempProtocol;
    }

    UserInfo.h323_uu_pdu.h323_message_body.u.setup.sourceInfo.mc = (ASN1_BOOL)bCallerIsMC;
    UserInfo.h323_uu_pdu.h323_message_body.u.setup.sourceInfo.undefinedNode = 0;

    if (pCalleeAliasList)
    {
        CS_STATUS AliasResult = CS_OK;
        AliasResult = AliasWithPrefixToSeqof((struct Setup_UUIE_sourceAddress **)&(UserInfo.h323_uu_pdu.
            h323_message_body.u.setup.destinationAddress), pCalleeAliasList);
        if (AliasResult != CS_OK)
        {
            FreeSeqof((struct Setup_UUIE_sourceAddress *)UserInfo.h323_uu_pdu.
                h323_message_body.u.setup.sourceAddress);
            UserInfo.h323_uu_pdu.h323_message_body.u.setup.sourceAddress = NULL;
            return CS_NO_MEMORY;
        }
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.bit_mask |=
            (destinationAddress_present);
    }
    else
    {
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.bit_mask &=
            (~destinationAddress_present);
    }

    if (pExtraAliasList)
    {
        CS_STATUS AliasResult = CS_OK;
        AliasResult = AliasWithPrefixToSeqof((struct Setup_UUIE_sourceAddress **)&(UserInfo.h323_uu_pdu.
            h323_message_body.u.setup.destExtraCallInfo), pExtraAliasList);
        if (AliasResult != CS_OK)
        {
            FreeSeqof((struct Setup_UUIE_sourceAddress *)UserInfo.h323_uu_pdu.h323_message_body.u.setup.destinationAddress);
            UserInfo.h323_uu_pdu.h323_message_body.u.setup.destinationAddress = NULL;
            FreeSeqof((struct Setup_UUIE_sourceAddress *)UserInfo.h323_uu_pdu.h323_message_body.u.setup.sourceAddress);
            UserInfo.h323_uu_pdu.h323_message_body.u.setup.sourceAddress = NULL;
            return CS_NO_MEMORY;
        }
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.bit_mask |=
            (Setup_UUIE_destExtraCallInfo_present);
    }
    else
    {
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.bit_mask &=
            (~Setup_UUIE_destExtraCallInfo_present);
    }

    if (pCalleeAddr)
    {
        DWORD a = pCalleeAddr->Addr.IP_Binary.dwAddr;
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.destCallSignalAddress.choice = ipAddress_chosen;
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.destCallSignalAddress.u.ipAddress.ip.length = 4;
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.destCallSignalAddress.u.ipAddress.port =
            pCalleeAddr->Addr.IP_Binary.wPort;
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.destCallSignalAddress.u.ipAddress.ip.value[0] =
            ((BYTE *)&a)[3];
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.destCallSignalAddress.u.ipAddress.ip.value[1] =
            ((BYTE *)&a)[2];
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.destCallSignalAddress.u.ipAddress.ip.value[2] =
            ((BYTE *)&a)[1];
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.destCallSignalAddress.u.ipAddress.ip.value[3] =
            ((BYTE *)&a)[0];
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.bit_mask |=
            (Setup_UUIE_destCallSignalAddress_present);
    }
    else
    {
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.bit_mask &=
            (~Setup_UUIE_destCallSignalAddress_present);
    }

    UserInfo.h323_uu_pdu.h323_message_body.u.setup.activeMC = (ASN1_BOOL)bCallerIsMC;

    if (pConferenceID != NULL)
    {
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.conferenceID.length =
            sizeof(UserInfo.h323_uu_pdu.h323_message_body.u.setup.conferenceID.value);
        memcpy(UserInfo.h323_uu_pdu.h323_message_body.u.setup.conferenceID.value,
            pConferenceID->buffer,
            UserInfo.h323_uu_pdu.h323_message_body.u.setup.conferenceID.length);
    }

    switch (wGoal)
	{
	case CSG_INVITE:
		UserInfo.h323_uu_pdu.h323_message_body.u.setup.conferenceGoal.choice = invite_chosen;
		break;
    case CSG_JOIN:
		UserInfo.h323_uu_pdu.h323_message_body.u.setup.conferenceGoal.choice = join_chosen;
		break;
	default:
		UserInfo.h323_uu_pdu.h323_message_body.u.setup.conferenceGoal.choice = create_chosen;
	} // switch

	switch (wCallType)
	{
	case CC_CALLTYPE_1_N:
		UserInfo.h323_uu_pdu.h323_message_body.u.setup.callType.choice = oneToN_chosen;
		break;
	case CC_CALLTYPE_N_1:
		UserInfo.h323_uu_pdu.h323_message_body.u.setup.callType.choice = nToOne_chosen;
		break;
	case CC_CALLTYPE_N_N:
		UserInfo.h323_uu_pdu.h323_message_body.u.setup.callType.choice = nToN_chosen;
		break;
	default:
		UserInfo.h323_uu_pdu.h323_message_body.u.setup.callType.choice = pointToPoint_chosen;
	} // switch

    if (pCallerAddr)
    {
        DWORD a = pCallerAddr->Addr.IP_Binary.dwAddr;
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.sourceCallSignalAddress.choice = ipAddress_chosen;
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.sourceCallSignalAddress.u.ipAddress.ip.length = 4;
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.sourceCallSignalAddress.u.ipAddress.port =
            pCallerAddr->Addr.IP_Binary.wPort;
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.sourceCallSignalAddress.u.ipAddress.ip.value[0] =
            ((BYTE *)&a)[3];
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.sourceCallSignalAddress.u.ipAddress.ip.value[1] =
            ((BYTE *)&a)[2];
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.sourceCallSignalAddress.u.ipAddress.ip.value[2] =
            ((BYTE *)&a)[1];
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.sourceCallSignalAddress.u.ipAddress.ip.value[3] =
            ((BYTE *)&a)[0];
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.bit_mask |=
            (sourceCallSignalAddress_present);
    }
    else
    {
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.bit_mask &=
            (~sourceCallSignalAddress_present);
    }

    if (pExtensionAliasItem)
    {
        CS_STATUS AliasResult = CS_OK;
        AliasResult = Q931CopyAliasItemToAliasAddr(&(UserInfo.h323_uu_pdu.
            h323_message_body.u.setup.remoteExtensionAddress), pExtensionAliasItem);
        if (AliasResult != CS_OK)
        {
            FreeSeqof((struct Setup_UUIE_sourceAddress *)UserInfo.h323_uu_pdu.h323_message_body.u.setup.destExtraCallInfo);
            UserInfo.h323_uu_pdu.h323_message_body.u.setup.destExtraCallInfo = NULL;
            FreeSeqof((struct Setup_UUIE_sourceAddress *)UserInfo.h323_uu_pdu.h323_message_body.u.setup.destinationAddress);
            UserInfo.h323_uu_pdu.h323_message_body.u.setup.destinationAddress = NULL;
            FreeSeqof((struct Setup_UUIE_sourceAddress *)UserInfo.h323_uu_pdu.h323_message_body.u.setup.sourceAddress);
            UserInfo.h323_uu_pdu.h323_message_body.u.setup.sourceAddress = NULL;
            return CS_NO_MEMORY;
        }
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.bit_mask |=
            (Setup_UUIE_remoteExtensionAddress_present);
    }
    else
    {
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.bit_mask &=
            (~Setup_UUIE_remoteExtensionAddress_present);
    }

    ASSERT(pCallIdentifier);
    if(pCallIdentifier)
    {
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.bit_mask |=
            (Setup_UUIE_callIdentifier_present);
        ASSERT(sizeof(GUID) 
            == sizeof(UserInfo.h323_uu_pdu.h323_message_body.u.setup.
                callIdentifier.guid.value));
        memcpy(&UserInfo.h323_uu_pdu.h323_message_body.u.setup.
            callIdentifier.guid.value, pCallIdentifier, 
            sizeof(GUID));
            
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.
            callIdentifier.guid.length = sizeof(GUID);
    }

    rc = Q931_Encode(pWorld,
                     (void *) &UserInfo,
                     H323_UserInformation_PDU,
                     ppEncodedBuf,
                     pdwEncodedLength);

    // Free the alias name structures from the UserInfo area.
    FreeSeqof((struct Setup_UUIE_sourceAddress *)UserInfo.h323_uu_pdu.h323_message_body.u.
        setup.sourceAddress);
    FreeSeqof((struct Setup_UUIE_sourceAddress *)UserInfo.h323_uu_pdu.h323_message_body.u.
        setup.destinationAddress);
    FreeSeqof((struct Setup_UUIE_sourceAddress *)UserInfo.h323_uu_pdu.h323_message_body.u.
        setup.destExtraCallInfo);
    Q931ClearAliasAddr(&(UserInfo.h323_uu_pdu.h323_message_body.u.setup.remoteExtensionAddress));

    if (ASN1_FAILED(rc))
    {
        ASSERT(FALSE);
        return CS_SUBSYSTEM_FAILURE;
    }
    
    return CS_OK;
}

//-------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------
void
Q931FreeEncodedBuffer(ASN1_CODER_INFO *pWorld, BYTE *pEncodedBuf)
{
    ASN1_FreeEncoded(pWorld->pEncInfo, pEncodedBuf);
}

//-------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------
HRESULT
Q931ReleaseCompleteEncodeASN(
    PCC_NONSTANDARDDATA pNonStandardData,
    CC_CONFERENCEID *pConferenceID,          // not passed in PDU!
    BYTE *pbReason,
    ASN1_CODER_INFO *pWorld,
    BYTE **ppEncodedBuf,
    DWORD *pdwEncodedLength,
    LPGUID pCallIdentifier)
{
    int rc;
    H323_UserInformation UserInfo;

    *ppEncodedBuf = NULL;
    *pdwEncodedLength = 0;

    memset(&UserInfo, 0, sizeof(H323_UserInformation));

    UserInfo.bit_mask = 0;

    // make sure the user_data_present flag is turned off.
    UserInfo.bit_mask &= (~user_data_present);

    UserInfo.h323_uu_pdu.bit_mask = 0;

    if (pNonStandardData)
    {
        UserInfo.h323_uu_pdu.bit_mask |= H323_UU_PDU_nnStndrdDt_present;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.choice 
            = H225NonStandardIdentifier_h221NonStandard_chosen;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.t35CountryCode =
            pNonStandardData->bCountryCode;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.t35Extension =
            pNonStandardData->bExtension;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.manufacturerCode =
            pNonStandardData->wManufacturerCode;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.data.length =
            pNonStandardData->sData.wOctetStringLength;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.data.value =
            pNonStandardData->sData.pOctetString;
    }
    else
    {
        UserInfo.h323_uu_pdu.bit_mask &= (~H323_UU_PDU_nnStndrdDt_present);
    }

    UserInfo.h323_uu_pdu.h323_message_body.choice = releaseComplete_chosen;

    UserInfo.h323_uu_pdu.h323_message_body.u.releaseComplete.protocolIdentifier = &ProtocolId1;

    if (pbReason)
    {
        unsigned short choice = 0;

        UserInfo.h323_uu_pdu.h323_message_body.u.releaseComplete.bit_mask |=
            (ReleaseComplete_UUIE_reason_present);
        switch (*pbReason)
        {
        case CC_REJECT_NO_BANDWIDTH:
            choice = noBandwidth_chosen;
            break;
        case CC_REJECT_GATEKEEPER_RESOURCES:
            choice = gatekeeperResources_chosen;
            break;
        case CC_REJECT_UNREACHABLE_DESTINATION:
            choice = unreachableDestination_chosen;
            break;
        case CC_REJECT_DESTINATION_REJECTION:
            choice = destinationRejection_chosen;
            break;
        case CC_REJECT_INVALID_REVISION:
            choice = ReleaseCompleteReason_invalidRevision_chosen;
            break;
        case CC_REJECT_NO_PERMISSION:
            choice = noPermission_chosen;
            break;
        case CC_REJECT_UNREACHABLE_GATEKEEPER:
            choice = unreachableGatekeeper_chosen;
            break;
        case CC_REJECT_GATEWAY_RESOURCES:
            choice = gatewayResources_chosen;
            break;
        case CC_REJECT_BAD_FORMAT_ADDRESS:
            choice = badFormatAddress_chosen;
            break;
        case CC_REJECT_ADAPTIVE_BUSY:
            choice = adaptiveBusy_chosen;
            break;
            
        case CC_REJECT_USER_BUSY:
        case CC_REJECT_IN_CONF:
            choice = inConf_chosen;
            break;
            
        case CC_REJECT_SECURITY_DENIED:
            choice = securityDenied_chosen;
            break;
            
        case CC_REJECT_CALL_DEFLECTION:
            choice = facilityCallDeflection_chosen;
            break;
        
        case CC_REJECT_NORMAL_CALL_CLEARING:// normal  = undefined reason
        case CC_REJECT_UNDEFINED_REASON:    // internal error = undefined reason
        case CC_REJECT_INTERNAL_ERROR:
            choice = RlsCmpltRsn_undfndRsn_chosen;
            break;
            
        default:
            return CS_BAD_PARAM;
            break;
        }
        UserInfo.h323_uu_pdu.h323_message_body.u.releaseComplete.reason.choice = choice;
    }

    ASSERT(pCallIdentifier);
    if(pCallIdentifier)
    {
        UserInfo.h323_uu_pdu.h323_message_body.u.releaseComplete.bit_mask |=
            (ReleaseComplete_UUIE_callIdentifier_present);
            
        memcpy(&UserInfo.h323_uu_pdu.h323_message_body.u.releaseComplete.
            callIdentifier.guid.value, pCallIdentifier, 
            sizeof(GUID));
        UserInfo.h323_uu_pdu.h323_message_body.u.releaseComplete.
            callIdentifier.guid.length = sizeof(GUID);
    }
    rc = Q931_Encode(pWorld,
                     (void *) &UserInfo,
                     H323_UserInformation_PDU,
                     ppEncodedBuf,
                     pdwEncodedLength);

    if (ASN1_FAILED(rc))
    {
        ASSERT(FALSE);
        return CS_SUBSYSTEM_FAILURE;
    }

    return CS_OK;
}

//-------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------
HRESULT
Q931ConnectEncodeASN(
    PCC_NONSTANDARDDATA pNonStandardData,
    CC_CONFERENCEID *pConferenceID, // must be able to support 16 byte conf id's!
    CC_ADDR *h245Addr,
    PCC_ENDPOINTTYPE pEndpointType,
    ASN1_CODER_INFO *pWorld,
    BYTE **ppEncodedBuf,
    DWORD *pdwEncodedLength,
    LPGUID pCallIdentifier
    )
{
    int rc;
    H323_UserInformation UserInfo;

    *ppEncodedBuf = NULL;
    *pdwEncodedLength = 0;

    memset(&UserInfo, 0, sizeof(H323_UserInformation));
    UserInfo.bit_mask = 0;

    // make sure the user_data_present flag is turned off.
    UserInfo.bit_mask &= (~user_data_present);

    UserInfo.h323_uu_pdu.bit_mask = 0;

    if (pNonStandardData)
    {
        UserInfo.h323_uu_pdu.bit_mask |= H323_UU_PDU_nnStndrdDt_present;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.choice 
            = H225NonStandardIdentifier_h221NonStandard_chosen;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.t35CountryCode =
            pNonStandardData->bCountryCode;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.t35Extension =
            pNonStandardData->bExtension;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.manufacturerCode =
            pNonStandardData->wManufacturerCode;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.data.length =
            pNonStandardData->sData.wOctetStringLength;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.data.value =
            pNonStandardData->sData.pOctetString;
    }
    else
    {
        UserInfo.h323_uu_pdu.bit_mask &= (~H323_UU_PDU_nnStndrdDt_present);
    }

    UserInfo.h323_uu_pdu.h323_message_body.choice = connect_chosen;

    UserInfo.h323_uu_pdu.h323_message_body.u.connect.protocolIdentifier = &ProtocolId1;

    if (h245Addr != NULL)
    {
        DWORD a = h245Addr->Addr.IP_Binary.dwAddr;
        UserInfo.h323_uu_pdu.h323_message_body.u.connect.Cnnct_UUIE_h245Address.choice = ipAddress_chosen;
        UserInfo.h323_uu_pdu.h323_message_body.u.connect.Cnnct_UUIE_h245Address.u.ipAddress.ip.length = 4;
        UserInfo.h323_uu_pdu.h323_message_body.u.connect.Cnnct_UUIE_h245Address.u.ipAddress.port =
            h245Addr->Addr.IP_Binary.wPort;
        UserInfo.h323_uu_pdu.h323_message_body.u.connect.Cnnct_UUIE_h245Address.u.ipAddress.ip.value[0] =
            ((BYTE *)&a)[3];
        UserInfo.h323_uu_pdu.h323_message_body.u.connect.Cnnct_UUIE_h245Address.u.ipAddress.ip.value[1] =
            ((BYTE *)&a)[2];
        UserInfo.h323_uu_pdu.h323_message_body.u.connect.Cnnct_UUIE_h245Address.u.ipAddress.ip.value[2] =
            ((BYTE *)&a)[1];
        UserInfo.h323_uu_pdu.h323_message_body.u.connect.Cnnct_UUIE_h245Address.u.ipAddress.ip.value[3] =
            ((BYTE *)&a)[0];
        UserInfo.h323_uu_pdu.h323_message_body.u.connect.bit_mask |=
            (Cnnct_UUIE_h245Address_present);
    }
    else
    {
        UserInfo.h323_uu_pdu.h323_message_body.u.connect.bit_mask &=
            (~Cnnct_UUIE_h245Address_present);
    }

    UserInfo.h323_uu_pdu.h323_message_body.u.connect.destinationInfo.bit_mask = 0;

    if (pEndpointType)
    {
        PCC_VENDORINFO pVendorInfo = pEndpointType->pVendorInfo;
        if (pVendorInfo)
        {
            UserInfo.h323_uu_pdu.h323_message_body.u.connect.destinationInfo.bit_mask |= vendor_present;
            UserInfo.h323_uu_pdu.h323_message_body.u.connect.destinationInfo.vendor.bit_mask = 0;
            UserInfo.h323_uu_pdu.h323_message_body.u.connect.destinationInfo.vendor.vendor.t35CountryCode = pVendorInfo->bCountryCode;
            UserInfo.h323_uu_pdu.h323_message_body.u.connect.destinationInfo.vendor.vendor.t35Extension = pVendorInfo->bExtension;
            UserInfo.h323_uu_pdu.h323_message_body.u.connect.destinationInfo.vendor.vendor.manufacturerCode = pVendorInfo->wManufacturerCode;

            if (pVendorInfo->pProductNumber && pVendorInfo->pProductNumber->pOctetString &&
                    pVendorInfo->pProductNumber->wOctetStringLength)
            {
                UserInfo.h323_uu_pdu.h323_message_body.u.connect.destinationInfo.vendor.bit_mask |= productId_present;
                UserInfo.h323_uu_pdu.h323_message_body.u.connect.destinationInfo.vendor.productId.length =
                    pVendorInfo->pProductNumber->wOctetStringLength;
                memcpy(UserInfo.h323_uu_pdu.h323_message_body.u.connect.destinationInfo.vendor.productId.value,
                    pVendorInfo->pProductNumber->pOctetString,
                    pVendorInfo->pProductNumber->wOctetStringLength);
            }
            if (pVendorInfo->pVersionNumber && pVendorInfo->pVersionNumber->pOctetString &&
                    pVendorInfo->pVersionNumber->wOctetStringLength)
            {
                UserInfo.h323_uu_pdu.h323_message_body.u.connect.destinationInfo.vendor.bit_mask |= versionId_present;
                UserInfo.h323_uu_pdu.h323_message_body.u.connect.destinationInfo.vendor.versionId.length =
                    pVendorInfo->pVersionNumber->wOctetStringLength;
                memcpy(UserInfo.h323_uu_pdu.h323_message_body.u.connect.destinationInfo.vendor.versionId.value,
                    pVendorInfo->pVersionNumber->pOctetString,
                    pVendorInfo->pVersionNumber->wOctetStringLength);
            }
        }
        if (pEndpointType->bIsTerminal)
        {
            UserInfo.h323_uu_pdu.h323_message_body.u.connect.destinationInfo.bit_mask |=
                terminal_present;
            UserInfo.h323_uu_pdu.h323_message_body.u.connect.destinationInfo.terminal.bit_mask = 0;
        }
        if (pEndpointType->bIsGateway)
        {
            UserInfo.h323_uu_pdu.h323_message_body.u.connect.destinationInfo.bit_mask |=
                gateway_present;
            UserInfo.h323_uu_pdu.h323_message_body.u.connect.destinationInfo.gateway.bit_mask = protocol_present;
            UserInfo.h323_uu_pdu.h323_message_body.u.connect.destinationInfo.gateway.protocol = &TempProtocol;
        }
    }

    UserInfo.h323_uu_pdu.h323_message_body.u.connect.destinationInfo.mc = 0;
    UserInfo.h323_uu_pdu.h323_message_body.u.connect.destinationInfo.undefinedNode = 0;

    if (pConferenceID != NULL)
    {
        UserInfo.h323_uu_pdu.h323_message_body.u.connect.conferenceID.length =
            sizeof(UserInfo.h323_uu_pdu.h323_message_body.u.connect.conferenceID.value);
        memcpy(UserInfo.h323_uu_pdu.h323_message_body.u.connect.conferenceID.value,
            pConferenceID->buffer,
            UserInfo.h323_uu_pdu.h323_message_body.u.connect.conferenceID.length);
    }

    ASSERT(pCallIdentifier);
    if(pCallIdentifier)
    {
        UserInfo.h323_uu_pdu.h323_message_body.u.connect.bit_mask |=
            (Connect_UUIE_callIdentifier_present);
            
        memcpy(&UserInfo.h323_uu_pdu.h323_message_body.u.connect.
            callIdentifier.guid.value, pCallIdentifier, 
            sizeof(GUID));
        UserInfo.h323_uu_pdu.h323_message_body.u.connect.
            callIdentifier.guid.length = sizeof(GUID);
    }
    rc = Q931_Encode(pWorld,
                     (void *) &UserInfo,
                     H323_UserInformation_PDU,
                     ppEncodedBuf,
                     pdwEncodedLength);

    if (ASN1_FAILED(rc))
    {
        ASSERT(FALSE);
        return CS_SUBSYSTEM_FAILURE;
    }

    return CS_OK;
}

//-------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------
HRESULT
Q931AlertingEncodeASN(
    PCC_NONSTANDARDDATA pNonStandardData,
    CC_ADDR *h245Addr,
    PCC_ENDPOINTTYPE pEndpointType,
    ASN1_CODER_INFO *pWorld,
    BYTE **ppEncodedBuf,
    DWORD *pdwEncodedLength,
    LPGUID pCallIdentifier)
{
    int rc;
    H323_UserInformation UserInfo;

    *ppEncodedBuf = NULL;
    *pdwEncodedLength = 0;

    memset(&UserInfo, 0, sizeof(H323_UserInformation));
    UserInfo.bit_mask = 0;

    // make sure the user_data_present flag is turned off.
    UserInfo.bit_mask &= (~user_data_present);

    UserInfo.h323_uu_pdu.bit_mask = 0;

    if (pNonStandardData)
    {
        UserInfo.h323_uu_pdu.bit_mask |= H323_UU_PDU_nnStndrdDt_present;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.choice 
            = H225NonStandardIdentifier_h221NonStandard_chosen;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.t35CountryCode =
            pNonStandardData->bCountryCode;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.t35Extension =
            pNonStandardData->bExtension;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.manufacturerCode =
            pNonStandardData->wManufacturerCode;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.data.length =
            pNonStandardData->sData.wOctetStringLength;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.data.value =
            pNonStandardData->sData.pOctetString;
    }
    else
    {
        UserInfo.h323_uu_pdu.bit_mask &= (~H323_UU_PDU_nnStndrdDt_present);
    }

    UserInfo.h323_uu_pdu.h323_message_body.choice = alerting_chosen;

    UserInfo.h323_uu_pdu.h323_message_body.u.alerting.protocolIdentifier = &ProtocolId1;

    UserInfo.h323_uu_pdu.h323_message_body.u.alerting.destinationInfo.bit_mask = 0;
    if (pEndpointType)
    {
        PCC_VENDORINFO pVendorInfo = pEndpointType->pVendorInfo;
        if (pVendorInfo)
        {
            UserInfo.h323_uu_pdu.h323_message_body.u.alerting.destinationInfo.bit_mask |= vendor_present;
            UserInfo.h323_uu_pdu.h323_message_body.u.alerting.destinationInfo.vendor.bit_mask = 0;
            UserInfo.h323_uu_pdu.h323_message_body.u.alerting.destinationInfo.vendor.vendor.t35CountryCode = pVendorInfo->bCountryCode;
            UserInfo.h323_uu_pdu.h323_message_body.u.alerting.destinationInfo.vendor.vendor.t35Extension = pVendorInfo->bExtension;
            UserInfo.h323_uu_pdu.h323_message_body.u.alerting.destinationInfo.vendor.vendor.manufacturerCode = pVendorInfo->wManufacturerCode;

            if (pVendorInfo->pProductNumber && pVendorInfo->pProductNumber->pOctetString &&
                    pVendorInfo->pProductNumber->wOctetStringLength)
            {
                UserInfo.h323_uu_pdu.h323_message_body.u.alerting.destinationInfo.vendor.bit_mask |= productId_present;
                UserInfo.h323_uu_pdu.h323_message_body.u.alerting.destinationInfo.vendor.productId.length =
                    pVendorInfo->pProductNumber->wOctetStringLength;
                memcpy(UserInfo.h323_uu_pdu.h323_message_body.u.alerting.destinationInfo.vendor.productId.value,
                    pVendorInfo->pProductNumber->pOctetString,
                    pVendorInfo->pProductNumber->wOctetStringLength);
            }
            if (pVendorInfo->pVersionNumber && pVendorInfo->pVersionNumber->pOctetString &&
                    pVendorInfo->pVersionNumber->wOctetStringLength)
            {
                UserInfo.h323_uu_pdu.h323_message_body.u.alerting.destinationInfo.vendor.bit_mask |= versionId_present;
                UserInfo.h323_uu_pdu.h323_message_body.u.alerting.destinationInfo.vendor.versionId.length =
                    pVendorInfo->pVersionNumber->wOctetStringLength;
                memcpy(UserInfo.h323_uu_pdu.h323_message_body.u.alerting.destinationInfo.vendor.versionId.value,
                    pVendorInfo->pVersionNumber->pOctetString,
                    pVendorInfo->pVersionNumber->wOctetStringLength);
            }
        }
        if (pEndpointType->bIsTerminal)
        {
            UserInfo.h323_uu_pdu.h323_message_body.u.alerting.destinationInfo.bit_mask =
                terminal_present;
            UserInfo.h323_uu_pdu.h323_message_body.u.alerting.destinationInfo.terminal.bit_mask = 0;
        }
        if (pEndpointType->bIsGateway)
        {
            UserInfo.h323_uu_pdu.h323_message_body.u.alerting.destinationInfo.bit_mask =
                gateway_present;
            UserInfo.h323_uu_pdu.h323_message_body.u.alerting.destinationInfo.gateway.bit_mask = protocol_present;
            UserInfo.h323_uu_pdu.h323_message_body.u.alerting.destinationInfo.gateway.protocol = &TempProtocol;
        }
    }

    UserInfo.h323_uu_pdu.h323_message_body.u.alerting.destinationInfo.mc = 0;
    UserInfo.h323_uu_pdu.h323_message_body.u.alerting.destinationInfo.undefinedNode = 0;

    if (h245Addr != NULL)
    {
        DWORD a = h245Addr->Addr.IP_Binary.dwAddr;
        UserInfo.h323_uu_pdu.h323_message_body.u.alerting.CPg_UUIE_h245Addrss.choice = ipAddress_chosen;
        UserInfo.h323_uu_pdu.h323_message_body.u.alerting.CPg_UUIE_h245Addrss.u.ipAddress.ip.length = 4;
        UserInfo.h323_uu_pdu.h323_message_body.u.alerting.CPg_UUIE_h245Addrss.u.ipAddress.port =
            h245Addr->Addr.IP_Binary.wPort;
        UserInfo.h323_uu_pdu.h323_message_body.u.alerting.CPg_UUIE_h245Addrss.u.ipAddress.ip.value[0] =
            ((BYTE *)&a)[3];
        UserInfo.h323_uu_pdu.h323_message_body.u.alerting.CPg_UUIE_h245Addrss.u.ipAddress.ip.value[1] =
            ((BYTE *)&a)[2];
        UserInfo.h323_uu_pdu.h323_message_body.u.alerting.CPg_UUIE_h245Addrss.u.ipAddress.ip.value[2] =
            ((BYTE *)&a)[1];
        UserInfo.h323_uu_pdu.h323_message_body.u.alerting.CPg_UUIE_h245Addrss.u.ipAddress.ip.value[3] =
            ((BYTE *)&a)[0];
        UserInfo.h323_uu_pdu.h323_message_body.u.alerting.bit_mask |=
            (CPg_UUIE_h245Addrss_present);
    }
    else
    {
        UserInfo.h323_uu_pdu.h323_message_body.u.alerting.bit_mask &=
            (~CPg_UUIE_h245Addrss_present);
    }

    ASSERT(pCallIdentifier);
    if(pCallIdentifier)
    {
        UserInfo.h323_uu_pdu.h323_message_body.u.alerting.bit_mask |=
            (Alerting_UUIE_callIdentifier_present);
            
        memcpy(&UserInfo.h323_uu_pdu.h323_message_body.u.alerting.
            callIdentifier.guid.value, pCallIdentifier, 
            sizeof(GUID));
        UserInfo.h323_uu_pdu.h323_message_body.u.alerting.
            callIdentifier.guid.length = sizeof(GUID);
    }

    rc = Q931_Encode(pWorld,
                     (void *) &UserInfo,
                     H323_UserInformation_PDU,
                     ppEncodedBuf,
                     pdwEncodedLength);

    if (ASN1_FAILED(rc))
    {
        ASSERT(FALSE);
        return CS_SUBSYSTEM_FAILURE;
    }

    return CS_OK;
}

//-------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------
HRESULT
Q931ProceedingEncodeASN(
    PCC_NONSTANDARDDATA pNonStandardData,
    CC_ADDR *h245Addr,
    PCC_ENDPOINTTYPE pEndpointType,
    ASN1_CODER_INFO *pWorld,
    BYTE **ppEncodedBuf,
    DWORD *pdwEncodedLength,
    LPGUID pCallIdentifier)
{
    int rc;
    H323_UserInformation UserInfo;

    *ppEncodedBuf = NULL;
    *pdwEncodedLength = 0;

    memset(&UserInfo, 0, sizeof(H323_UserInformation));
    UserInfo.bit_mask = 0;

    // make sure the user_data_present flag is turned off.
    UserInfo.bit_mask &= (~user_data_present);

    UserInfo.h323_uu_pdu.bit_mask = 0;

    if (pNonStandardData)
    {
        UserInfo.h323_uu_pdu.bit_mask |= H323_UU_PDU_nnStndrdDt_present;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.choice 
            = H225NonStandardIdentifier_h221NonStandard_chosen;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.t35CountryCode =
            pNonStandardData->bCountryCode;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.t35Extension =
            pNonStandardData->bExtension;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.manufacturerCode =
            pNonStandardData->wManufacturerCode;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.data.length =
            pNonStandardData->sData.wOctetStringLength;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.data.value =
            pNonStandardData->sData.pOctetString;
    }
    else
    {
        UserInfo.h323_uu_pdu.bit_mask &= (~H323_UU_PDU_nnStndrdDt_present);
    }

    UserInfo.h323_uu_pdu.h323_message_body.choice = callProceeding_chosen;

    UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding.protocolIdentifier = &ProtocolId1;

    if (h245Addr != NULL)
    {
        DWORD a = h245Addr->Addr.IP_Binary.dwAddr;
        UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding.CPg_UUIE_h245Addrss.choice = ipAddress_chosen;
        UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding.CPg_UUIE_h245Addrss.u.ipAddress.ip.length = 4;
        UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding.CPg_UUIE_h245Addrss.u.ipAddress.port =
            h245Addr->Addr.IP_Binary.wPort;
        UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding.CPg_UUIE_h245Addrss.u.ipAddress.ip.value[0] =
            ((BYTE *)&a)[3];
        UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding.CPg_UUIE_h245Addrss.u.ipAddress.ip.value[1] =
            ((BYTE *)&a)[2];
        UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding.CPg_UUIE_h245Addrss.u.ipAddress.ip.value[2] =
            ((BYTE *)&a)[1];
        UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding.CPg_UUIE_h245Addrss.u.ipAddress.ip.value[3] =
            ((BYTE *)&a)[0];
        UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding.bit_mask |=
            (CPg_UUIE_h245Addrss_present);
    }
    else
    {
        UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding.bit_mask &=
            (~CPg_UUIE_h245Addrss_present);
    }

    UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding.destinationInfo.bit_mask = 0;
    if (pEndpointType)
    {
        PCC_VENDORINFO pVendorInfo = pEndpointType->pVendorInfo;
        if (pVendorInfo)
        {
            UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding.destinationInfo.bit_mask |= vendor_present;
            UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding.destinationInfo.vendor.bit_mask = 0;
            UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding.destinationInfo.vendor.vendor.t35CountryCode = pVendorInfo->bCountryCode;
            UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding.destinationInfo.vendor.vendor.t35Extension = pVendorInfo->bExtension;
            UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding.destinationInfo.vendor.vendor.manufacturerCode = pVendorInfo->wManufacturerCode;

            if (pVendorInfo->pProductNumber && pVendorInfo->pProductNumber->pOctetString &&
                pVendorInfo->pProductNumber->wOctetStringLength)
            {
                UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding.destinationInfo.vendor.bit_mask |= productId_present;
                UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding.destinationInfo.vendor.productId.length =
                    pVendorInfo->pProductNumber->wOctetStringLength;
                memcpy(UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding.destinationInfo.vendor.productId.value,
                    pVendorInfo->pProductNumber->pOctetString,
                    pVendorInfo->pProductNumber->wOctetStringLength);
            }
            if (pVendorInfo->pVersionNumber && pVendorInfo->pVersionNumber->pOctetString &&
                    pVendorInfo->pVersionNumber->wOctetStringLength)
            {
                UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding.destinationInfo.vendor.bit_mask |= versionId_present;
                UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding.destinationInfo.vendor.versionId.length =
                    pVendorInfo->pVersionNumber->wOctetStringLength;
                memcpy(UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding.destinationInfo.vendor.versionId.value,
                    pVendorInfo->pVersionNumber->pOctetString,
                    pVendorInfo->pVersionNumber->wOctetStringLength);
            }
        }
        if (pEndpointType->bIsTerminal)
        {
            UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding.destinationInfo.bit_mask =
                terminal_present;
            UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding.destinationInfo.terminal.bit_mask = 0;
        }
        if (pEndpointType->bIsGateway)
        {
            UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding.destinationInfo.bit_mask =
                gateway_present;
            UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding.destinationInfo.gateway.bit_mask = protocol_present;
            UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding.destinationInfo.gateway.protocol = &TempProtocol;
        }
    }

    UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding.destinationInfo.mc = 0;
    UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding.destinationInfo.undefinedNode = 0;

    ASSERT(pCallIdentifier);
    if(pCallIdentifier)
    {
        UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding.bit_mask |=
            (CallProceeding_UUIE_callIdentifier_present);
            
        memcpy(&UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding.
            callIdentifier.guid.value, pCallIdentifier, 
            sizeof(GUID));
        UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding.
            callIdentifier.guid.length = sizeof(GUID);
    }
    rc = Q931_Encode(pWorld,
                     (void *) &UserInfo,
                     H323_UserInformation_PDU,
                     ppEncodedBuf,
                     pdwEncodedLength);

    if (ASN1_FAILED(rc))
    {
        ASSERT(FALSE);
        return CS_SUBSYSTEM_FAILURE;
    }

    return CS_OK;
}

//-------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------
HRESULT
Q931FacilityEncodeASN(
    PCC_NONSTANDARDDATA pNonStandardData,
    CC_ADDR *AlternativeAddr,
    BYTE bReason,
    CC_CONFERENCEID *pConferenceID,
    PCC_ALIASNAMES pAlternativeAliasList,
    ASN1_CODER_INFO *pWorld,
    BYTE **ppEncodedBuf,
    DWORD *pdwEncodedLength,
    LPGUID pCallIdentifier)
{
    int rc;
    H323_UserInformation UserInfo;

    *ppEncodedBuf = NULL;
    *pdwEncodedLength = 0;

    memset(&UserInfo, 0, sizeof(H323_UserInformation));

    UserInfo.bit_mask = 0;

    // make sure the user_data_present flag is turned off.
    UserInfo.bit_mask &= (~user_data_present);

    if (pNonStandardData)
    {
        UserInfo.h323_uu_pdu.bit_mask |= H323_UU_PDU_nnStndrdDt_present;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.choice 
            = H225NonStandardIdentifier_h221NonStandard_chosen;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.t35CountryCode =
            pNonStandardData->bCountryCode;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.t35Extension =
            pNonStandardData->bExtension;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.manufacturerCode =
            pNonStandardData->wManufacturerCode;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.data.length =
            pNonStandardData->sData.wOctetStringLength;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.data.value =
            pNonStandardData->sData.pOctetString;
    }
    else
    {
        UserInfo.h323_uu_pdu.bit_mask &= (~H323_UU_PDU_nnStndrdDt_present);
    }

    UserInfo.h323_uu_pdu.h323_message_body.choice = facility_chosen;

    UserInfo.h323_uu_pdu.h323_message_body.u.facility.protocolIdentifier = &ProtocolId1;

    if (AlternativeAddr != NULL)
    {
        DWORD a = AlternativeAddr->Addr.IP_Binary.dwAddr;
        UserInfo.h323_uu_pdu.h323_message_body.u.facility.alternativeAddress.choice = ipAddress_chosen;
        UserInfo.h323_uu_pdu.h323_message_body.u.facility.alternativeAddress.u.ipAddress.ip.length = 4;
        UserInfo.h323_uu_pdu.h323_message_body.u.facility.alternativeAddress.u.ipAddress.port =
            AlternativeAddr->Addr.IP_Binary.wPort;
        UserInfo.h323_uu_pdu.h323_message_body.u.facility.alternativeAddress.u.ipAddress.ip.value[0] =
            ((BYTE *)&a)[3];
        UserInfo.h323_uu_pdu.h323_message_body.u.facility.alternativeAddress.u.ipAddress.ip.value[1] =
            ((BYTE *)&a)[2];
        UserInfo.h323_uu_pdu.h323_message_body.u.facility.alternativeAddress.u.ipAddress.ip.value[2] =
            ((BYTE *)&a)[1];
        UserInfo.h323_uu_pdu.h323_message_body.u.facility.alternativeAddress.u.ipAddress.ip.value[3] =
            ((BYTE *)&a)[0];
        UserInfo.h323_uu_pdu.h323_message_body.u.facility.bit_mask |=
            (alternativeAddress_present);
    }
    else
    {
        UserInfo.h323_uu_pdu.h323_message_body.u.facility.bit_mask &=
            (~alternativeAddress_present);
    }

    if (pAlternativeAliasList)
    {
        CS_STATUS AliasResult = CS_OK;
        AliasResult = AliasToSeqof((struct Setup_UUIE_sourceAddress **)&(UserInfo.h323_uu_pdu.
            h323_message_body.u.facility.alternativeAliasAddress), pAlternativeAliasList);
        if (AliasResult != CS_OK)
        {
            return CS_NO_MEMORY;
        }
        UserInfo.h323_uu_pdu.h323_message_body.u.facility.bit_mask |=
            (alternativeAliasAddress_present);
    }
    else
    {
        UserInfo.h323_uu_pdu.h323_message_body.u.facility.bit_mask &=
            (~alternativeAliasAddress_present);
    }

    if (pConferenceID != NULL)
    {
        UserInfo.h323_uu_pdu.h323_message_body.u.facility.conferenceID.length =
            sizeof(UserInfo.h323_uu_pdu.h323_message_body.u.facility.conferenceID.value);
        memcpy(UserInfo.h323_uu_pdu.h323_message_body.u.facility.conferenceID.value,
            pConferenceID->buffer,
            UserInfo.h323_uu_pdu.h323_message_body.u.facility.conferenceID.length);
        UserInfo.h323_uu_pdu.h323_message_body.u.facility.bit_mask |=
            (Facility_UUIE_conferenceID_present);
    }
    else
    {
        UserInfo.h323_uu_pdu.h323_message_body.u.facility.bit_mask &=
            (~Facility_UUIE_conferenceID_present);
    }

    switch (bReason)
	{
	case CC_REJECT_ROUTE_TO_GATEKEEPER:
		UserInfo.h323_uu_pdu.h323_message_body.u.facility.reason.choice 
		    = FacilityReason_routeCallToGatekeeper_chosen;
		break;
	case CC_REJECT_CALL_FORWARDED:
		UserInfo.h323_uu_pdu.h323_message_body.u.facility.reason.choice 
		    = callForwarded_chosen;
		break;
	case CC_REJECT_ROUTE_TO_MC:
		UserInfo.h323_uu_pdu.h323_message_body.u.facility.reason.choice 
		    = routeCallToMC_chosen;
		break;
	default:
        UserInfo.h323_uu_pdu.h323_message_body.u.facility.reason.choice 
            = RlsCmpltRsn_undfndRsn_chosen;
	} // switch

    ASSERT(pCallIdentifier);
    if(pCallIdentifier)
    {
        UserInfo.h323_uu_pdu.h323_message_body.u.facility.bit_mask |=
            (Facility_UUIE_callIdentifier_present);
            
        memcpy(&UserInfo.h323_uu_pdu.h323_message_body.u.facility.
            callIdentifier.guid.value, pCallIdentifier, 
            sizeof(GUID));
        UserInfo.h323_uu_pdu.h323_message_body.u.facility.
            callIdentifier.guid.length = sizeof(GUID);
    }
    
    rc = Q931_Encode(pWorld,
                     (void *) &UserInfo,
                     H323_UserInformation_PDU,
                     ppEncodedBuf,
                     pdwEncodedLength);

    // Free the alias name structures from the UserInfo area.
    FreeSeqof((struct Setup_UUIE_sourceAddress *)UserInfo.h323_uu_pdu.h323_message_body.u.
        facility.alternativeAliasAddress);

    if (ASN1_FAILED(rc))
    {
        ASSERT(FALSE);
        return CS_SUBSYSTEM_FAILURE;
    }
    
    return CS_OK;
}

//------------------------------------------------------------------------
//------------------------------------------------------------------------
BOOL
Q931ValidPduVersion(struct ObjectID_ *id)
{
// not sure what version checking to put here
#if 0
    if ((id != NULL) && (id->value == 0) && (id->next != NULL) && (id->next->value <= 1))
    {
        return TRUE;
    }
    return FALSE;
#else
    return TRUE;
#endif
}

//------------------------------------------------------------------------
//------------------------------------------------------------------------
HRESULT
Q931SetupParseASN(
    ASN1_CODER_INFO *pWorld,
    BYTE *pEncodedBuf,
    DWORD dwEncodedLength,
    Q931_SETUP_ASN *pParsedData)
{
    int PDU = H323_UserInformation_PDU;
    char *pDecodedBuf = NULL;
    H323_UserInformation *pUserInfo;
    struct ObjectID_ *id;
    int Result;

    if (pParsedData == NULL)
    {
        return CS_BAD_PARAM;
    }

    Result = Q931_Decode(pWorld,
                         (void **) &pDecodedBuf,
                         PDU,
                         pEncodedBuf,
                         dwEncodedLength);

    if (ASN1_FAILED(Result) || (pDecodedBuf == NULL))
    {
        ASSERT(FALSE);
        // trace and return an decoding error of some sort.
        // Note: some values of Result should cause CS_SUBSYSTEM_FAILURE return.
        return CS_BAD_PARAM;
    }

    // validate some basic things about the PDU...
    pUserInfo = (H323_UserInformation *)pDecodedBuf;

    // validate that this is a H323 PDU.
    if (PDU != H323_UserInformation_PDU)
    {
        freePDU(pWorld, PDU, pDecodedBuf, q931asn);
        return CS_BAD_PARAM;
    }

    // validate that the PDU user-data uses ASN encoding.
    if (((pUserInfo->bit_mask & user_data_present) != 0) &&
            (pUserInfo->user_data.protocol_discriminator != USE_ASN1_ENCODING))
    {
        freePDU(pWorld, PDU, pDecodedBuf, q931asn);
        return CS_BAD_PARAM;
    }

    // validate that the PDU is H323 Setup information.
    if (pUserInfo->h323_uu_pdu.h323_message_body.choice != setup_chosen)
    {
        freePDU(pWorld, PDU, pDecodedBuf, q931asn);
        return CS_BAD_PARAM;
    }

    id = pUserInfo->h323_uu_pdu.h323_message_body.u.setup.protocolIdentifier;
    if (!Q931ValidPduVersion(id))
    {
        freePDU(pWorld, PDU, pDecodedBuf, q931asn);
        return CS_INCOMPATIBLE_VERSION;
    }

    // make sure that the conference id is formed correctly.
    if (pUserInfo->h323_uu_pdu.h323_message_body.u.setup.conferenceID.length >
            sizeof(pUserInfo->h323_uu_pdu.h323_message_body.u.setup.conferenceID.value))
    {
        freePDU(pWorld, PDU, pDecodedBuf, q931asn);
        return CS_BAD_PARAM;
    }

#if 0
    if (pUserInfo->h323_uu_pdu.h323_message_body.u.setup.conferenceGoal.choice != create_chosen)
    {
        freePDU(pWorld, PDU, pDecodedBuf, q931asn);
        return CS_OPTION_NOT_IMPLEMENTED;
    }
    if (pUserInfo->h323_uu_pdu.h323_message_body.u.setup.callType.choice != pointToPoint_chosen)
    {
        freePDU(pWorld, PDU, pDecodedBuf, q931asn);
        return CS_OPTION_NOT_IMPLEMENTED;
    }
#endif

    // parse the message contained in pUserInfo.
    memset(pParsedData, 0, sizeof(Q931_SETUP_ASN));
    pParsedData->SourceAddr.bMulticast = FALSE;
    pParsedData->CallerAddr.bMulticast = FALSE;
    pParsedData->CalleeDestAddr.bMulticast = FALSE;
    pParsedData->CalleeAddr.bMulticast = FALSE;

    // no validation of sourceInfo needed.

    pParsedData->EndpointType.pVendorInfo = NULL;
    if (pUserInfo->h323_uu_pdu.h323_message_body.u.setup.sourceInfo.bit_mask & (vendor_present))
    {
        pParsedData->EndpointType.pVendorInfo = &(pParsedData->VendorInfo);
        pParsedData->VendorInfo.bCountryCode =
            (BYTE)pUserInfo->h323_uu_pdu.h323_message_body.u.setup.sourceInfo.vendor.vendor.t35CountryCode;
        pParsedData->VendorInfo.bExtension =
            (BYTE)pUserInfo->h323_uu_pdu.h323_message_body.u.setup.sourceInfo.vendor.vendor.t35Extension;
        pParsedData->VendorInfo.wManufacturerCode =
            pUserInfo->h323_uu_pdu.h323_message_body.u.setup.sourceInfo.vendor.vendor.manufacturerCode;
        if (pUserInfo->h323_uu_pdu.h323_message_body.u.setup.sourceInfo.vendor.bit_mask & (productId_present))
        {
            pParsedData->VendorInfo.pProductNumber = MemAlloc(sizeof(CC_OCTETSTRING));
            if (pParsedData->VendorInfo.pProductNumber == NULL)
            {
                freePDU(pWorld, PDU, pDecodedBuf, q931asn);
                return CS_NO_MEMORY;
            }
            pParsedData->VendorInfo.pProductNumber->wOctetStringLength = (WORD)
                min(pUserInfo->h323_uu_pdu.h323_message_body.u.setup.sourceInfo.vendor.productId.length,
                CC_MAX_PRODUCT_LENGTH - 1);
            memcpy(pParsedData->bufProductValue,
                pUserInfo->h323_uu_pdu.h323_message_body.u.setup.sourceInfo.vendor.productId.value,
                pParsedData->VendorInfo.pProductNumber->wOctetStringLength);
            pParsedData->bufProductValue[pParsedData->VendorInfo.pProductNumber->wOctetStringLength] = '\0';
            pParsedData->VendorInfo.pProductNumber->pOctetString = pParsedData->bufProductValue;
        }
        if (pUserInfo->h323_uu_pdu.h323_message_body.u.setup.sourceInfo.vendor.bit_mask & (versionId_present))
        {
            pParsedData->VendorInfo.pVersionNumber = MemAlloc(sizeof(CC_OCTETSTRING));
            if (pParsedData->VendorInfo.pVersionNumber == NULL)
            {
                MemFree(pParsedData->VendorInfo.pProductNumber);
                freePDU(pWorld, PDU, pDecodedBuf, q931asn);
                return CS_NO_MEMORY;
            }
            pParsedData->VendorInfo.pVersionNumber->wOctetStringLength = (WORD)
                min(pUserInfo->h323_uu_pdu.h323_message_body.u.setup.sourceInfo.vendor.versionId.length,
                CC_MAX_VERSION_LENGTH - 1);
            memcpy(pParsedData->bufVersionValue,
                pUserInfo->h323_uu_pdu.h323_message_body.u.setup.sourceInfo.vendor.versionId.value,
                pParsedData->VendorInfo.pVersionNumber->wOctetStringLength);
            pParsedData->bufVersionValue[pParsedData->VendorInfo.pVersionNumber->wOctetStringLength] = '\0';
            pParsedData->VendorInfo.pVersionNumber->pOctetString = pParsedData->bufVersionValue;
        }
    }

    pParsedData->EndpointType.bIsTerminal = FALSE;
    if (pUserInfo->h323_uu_pdu.h323_message_body.u.setup.sourceInfo.bit_mask & (terminal_present))
    {
        pParsedData->EndpointType.bIsTerminal = TRUE;
    }
    pParsedData->EndpointType.bIsGateway = FALSE;
    if (pUserInfo->h323_uu_pdu.h323_message_body.u.setup.sourceInfo.bit_mask & (gateway_present))
    {
        pParsedData->EndpointType.bIsGateway = TRUE;
    }

    if ((pUserInfo->h323_uu_pdu.bit_mask & H323_UU_PDU_nnStndrdDt_present) != 0)
    {
        pParsedData->NonStandardDataPresent = TRUE;
        if (pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.choice 
            == H225NonStandardIdentifier_h221NonStandard_chosen)
        {
            pParsedData->NonStandardData.bCountryCode =
                (BYTE)(pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.t35CountryCode);
            pParsedData->NonStandardData.bExtension =
                (BYTE)(pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.t35Extension);
            pParsedData->NonStandardData.wManufacturerCode =
                pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.manufacturerCode;
        }
        pParsedData->NonStandardData.sData.wOctetStringLength =	(WORD)
            pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.data.length;
		pParsedData->NonStandardData.sData.pOctetString =
			(BYTE *)MemAlloc(pParsedData->NonStandardData.sData.wOctetStringLength);
		if (pParsedData->NonStandardData.sData.pOctetString == NULL)
		{
            MemFree(pParsedData->VendorInfo.pProductNumber);
            MemFree(pParsedData->VendorInfo.pVersionNumber);
            freePDU(pWorld, PDU, pDecodedBuf, q931asn);
            return CS_NO_MEMORY;
		}
		memcpy(pParsedData->NonStandardData.sData.pOctetString,
			   pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.data.value,
			   pParsedData->NonStandardData.sData.wOctetStringLength);
    }
    else
    {
        pParsedData->NonStandardDataPresent = FALSE;
    }

//RMO. ignore the h245 address.

    {
        CS_STATUS AliasResult = CS_OK;

        // parse the sourceAddress aliases here...
        AliasResult = SeqofToAlias(&(pParsedData->pCallerAliasList),
            (struct Setup_UUIE_sourceAddress *)pUserInfo->h323_uu_pdu.h323_message_body.u.setup.sourceAddress);
        if (AliasResult != CS_OK)
        {
  			if (pParsedData->NonStandardData.sData.pOctetString != NULL)
				MemFree(pParsedData->NonStandardData.sData.pOctetString);
			MemFree(pParsedData->VendorInfo.pProductNumber);
            MemFree(pParsedData->VendorInfo.pVersionNumber);
            freePDU(pWorld, PDU, pDecodedBuf, q931asn);
            return CS_NO_MEMORY;
        }

        // parse the destinationAddress aliases here...
        AliasResult = SeqofToAlias(&(pParsedData->pCalleeAliasList),
            (struct Setup_UUIE_sourceAddress *)pUserInfo->h323_uu_pdu.h323_message_body.u.setup.destinationAddress);
        if (AliasResult != CS_OK)
        {
            Q931FreeAliasNames(pParsedData->pCallerAliasList);
   			if (pParsedData->NonStandardData.sData.pOctetString != NULL)
				MemFree(pParsedData->NonStandardData.sData.pOctetString);
            pParsedData->pCallerAliasList = NULL;
            MemFree(pParsedData->VendorInfo.pProductNumber);
            MemFree(pParsedData->VendorInfo.pVersionNumber);
            freePDU(pWorld, PDU, pDecodedBuf, q931asn);
            return CS_NO_MEMORY;
        }

        // parse the destExtraCallInfo aliases here...
        AliasResult = SeqofToAlias(&(pParsedData->pExtraAliasList),
            (struct Setup_UUIE_sourceAddress *)pUserInfo->h323_uu_pdu.h323_message_body.u.setup.destExtraCallInfo);
        if (AliasResult != CS_OK)
        {
            Q931FreeAliasNames(pParsedData->pCalleeAliasList);
            Q931FreeAliasNames(pParsedData->pCallerAliasList);
  			if (pParsedData->NonStandardData.sData.pOctetString != NULL)
				MemFree(pParsedData->NonStandardData.sData.pOctetString);
            pParsedData->pCallerAliasList = NULL;
            MemFree(pParsedData->VendorInfo.pProductNumber);
            MemFree(pParsedData->VendorInfo.pVersionNumber);
            freePDU(pWorld, PDU, pDecodedBuf, q931asn);
            return CS_NO_MEMORY;
        }

        // parse the remoteExtensionAddress aliases here...
        if ((pUserInfo->h323_uu_pdu.h323_message_body.u.setup.bit_mask &
                Setup_UUIE_remoteExtensionAddress_present) != 0)
        {
            AliasResult = Q931AliasAddrToAliasItem(&(pParsedData->pExtensionAliasItem),
                &(pUserInfo->h323_uu_pdu.h323_message_body.u.setup.remoteExtensionAddress));
            if (AliasResult != CS_OK)
            {
                Q931FreeAliasNames(pParsedData->pExtraAliasList);
                Q931FreeAliasNames(pParsedData->pCalleeAliasList);
                Q931FreeAliasNames(pParsedData->pCallerAliasList);
                pParsedData->pCallerAliasList = NULL;
  				if (pParsedData->NonStandardData.sData.pOctetString != NULL)
					MemFree(pParsedData->NonStandardData.sData.pOctetString);
                MemFree(pParsedData->VendorInfo.pProductNumber);
                MemFree(pParsedData->VendorInfo.pVersionNumber);
                freePDU(pWorld, PDU, pDecodedBuf, q931asn);
                return CS_NO_MEMORY;
            }
        }
    }

    if ((pUserInfo->h323_uu_pdu.h323_message_body.u.setup.bit_mask &
            Setup_UUIE_destCallSignalAddress_present) != 0)
    {
        BYTE *a = (BYTE *)(&(pParsedData->CalleeDestAddr.Addr.IP_Binary.dwAddr));
        pParsedData->CalleeDestAddr.nAddrType = CC_IP_BINARY;
        pParsedData->CalleeDestAddr.Addr.IP_Binary.wPort = 
            pUserInfo->h323_uu_pdu.h323_message_body.u.setup.destCallSignalAddress.u.ipAddress.port;
        a[3] = pUserInfo->h323_uu_pdu.h323_message_body.u.setup.destCallSignalAddress.u.ipAddress.ip.value[0];
        a[2] = pUserInfo->h323_uu_pdu.h323_message_body.u.setup.destCallSignalAddress.u.ipAddress.ip.value[1];
        a[1] = pUserInfo->h323_uu_pdu.h323_message_body.u.setup.destCallSignalAddress.u.ipAddress.ip.value[2];
        a[0] = pUserInfo->h323_uu_pdu.h323_message_body.u.setup.destCallSignalAddress.u.ipAddress.ip.value[3];
        pParsedData->CalleeDestAddrPresent = TRUE;
    }

    if ((pUserInfo->h323_uu_pdu.h323_message_body.u.setup.bit_mask &
            sourceCallSignalAddress_present) != 0)
    {
        BYTE *a = (BYTE *)(&(pParsedData->SourceAddr.Addr.IP_Binary.dwAddr));
        pParsedData->SourceAddr.nAddrType = CC_IP_BINARY;
        pParsedData->SourceAddr.Addr.IP_Binary.wPort = 
            pUserInfo->h323_uu_pdu.h323_message_body.u.setup.sourceCallSignalAddress.u.ipAddress.port;
        a[3] = pUserInfo->h323_uu_pdu.h323_message_body.u.setup.sourceCallSignalAddress.u.ipAddress.ip.value[0];
        a[2] = pUserInfo->h323_uu_pdu.h323_message_body.u.setup.sourceCallSignalAddress.u.ipAddress.ip.value[1];
        a[1] = pUserInfo->h323_uu_pdu.h323_message_body.u.setup.sourceCallSignalAddress.u.ipAddress.ip.value[2];
        a[0] = pUserInfo->h323_uu_pdu.h323_message_body.u.setup.sourceCallSignalAddress.u.ipAddress.ip.value[3];
        pParsedData->SourceAddrPresent = TRUE;
    }

    pParsedData->bCallerIsMC = pUserInfo->h323_uu_pdu.h323_message_body.u.setup.activeMC;

    memcpy(pParsedData->ConferenceID.buffer,
        pUserInfo->h323_uu_pdu.h323_message_body.u.setup.conferenceID.value,
        pUserInfo->h323_uu_pdu.h323_message_body.u.setup.conferenceID.length);

    if ((pUserInfo->h323_uu_pdu.h323_message_body.u.setup.bit_mask &
            Setup_UUIE_callIdentifier_present) != 0)
    {
        ASSERT(pUserInfo->h323_uu_pdu.h323_message_body.u.setup.callIdentifier.guid.length 
            <= sizeof(GUID));
        memcpy(&pParsedData->CallIdentifier,
            pUserInfo->h323_uu_pdu.h323_message_body.u.setup.callIdentifier.guid.value,
            pUserInfo->h323_uu_pdu.h323_message_body.u.setup.callIdentifier.guid.length);
    }
    
#if(0)  // not yet implemented
    if ((pUserInfo->h323_uu_pdu.h323_message_body.u.setup.bit_mask &
            Setup_UUIE_fastStart_present) != 0)
    {

    }

    if ((pUserInfo->h323_uu_pdu.h323_message_body.u.setup.bit_mask &
            Setup_UUIE_fastCap_present) != 0)
    {

    }
#endif

    switch (pUserInfo->h323_uu_pdu.h323_message_body.u.setup.conferenceGoal.choice)
	{
	case invite_chosen:
		pParsedData->wGoal = CSG_INVITE;
		break;
	case join_chosen:
		pParsedData->wGoal = CSG_JOIN;
		break;
	default:
		pParsedData->wGoal = CSG_CREATE;
	} // switch

	switch (pUserInfo->h323_uu_pdu.h323_message_body.u.setup.callType.choice)
    {
	case oneToN_chosen:
        pParsedData->wCallType = CC_CALLTYPE_1_N;
		break;
	case nToOne_chosen:
        pParsedData->wCallType = CC_CALLTYPE_N_1;
		break;
	case nToN_chosen:
        pParsedData->wCallType = CC_CALLTYPE_N_N;
		break;
	default:
        pParsedData->wCallType = CC_CALLTYPE_PT_PT;
    } // switch

    // Free the PDU data.
    Result = freePDU(pWorld, PDU, pDecodedBuf, q931asn);
    ASSERT(ASN1_SUCCEEDED(Result));
    return CS_OK;
}

//------------------------------------------------------------------------
//------------------------------------------------------------------------
HRESULT
Q931ReleaseCompleteParseASN(
    ASN1_CODER_INFO *pWorld,
    BYTE *pEncodedBuf,
    DWORD dwEncodedLength,
    Q931_RELEASE_COMPLETE_ASN *pParsedData)
{
    int PDU = H323_UserInformation_PDU;
    char *pDecodedBuf = NULL;
    H323_UserInformation *pUserInfo;
    struct ObjectID_ *id;
    int Result;

    if (pParsedData == NULL)
    {
        return CS_BAD_PARAM;
    }

    Result = Q931_Decode(pWorld,
                         (void **) &pDecodedBuf,
                         PDU,
                         pEncodedBuf,
                         dwEncodedLength);

    if (ASN1_FAILED(Result) || (pDecodedBuf == NULL))
    {
        ASSERT(FALSE);
        // trace and return an decoding error of some sort.
        // Note: some values of Result should cause CS_SUBSYSTEM_FAILURE return.
        return CS_BAD_PARAM;
    }

    // validate some basic things about the PDU...
    pUserInfo = (H323_UserInformation *)pDecodedBuf;

    // validate that this is a H323 PDU.
    if (PDU != H323_UserInformation_PDU)
    {
        freePDU(pWorld, PDU, pDecodedBuf, q931asn);
        return CS_BAD_PARAM;
    }

    // validate that the PDU user-data uses ASN encoding.
    if (((pUserInfo->bit_mask & user_data_present) != 0) &&
            (pUserInfo->user_data.protocol_discriminator != USE_ASN1_ENCODING))
    {
        freePDU(pWorld, PDU, pDecodedBuf, q931asn);
        return CS_BAD_PARAM;
    }

    // validate that the PDU is H323 Release Complete information.
    if (pUserInfo->h323_uu_pdu.h323_message_body.choice != releaseComplete_chosen)
    {
        freePDU(pWorld, PDU, pDecodedBuf, q931asn);
        return CS_BAD_PARAM;
    }

    id = pUserInfo->h323_uu_pdu.h323_message_body.u.releaseComplete.protocolIdentifier;
    if (!Q931ValidPduVersion(id))
    {
        freePDU(pWorld, PDU, pDecodedBuf, q931asn);
        return CS_INCOMPATIBLE_VERSION;
    }

    // parse the message contained in pUserInfo.
    memset(pParsedData, 0, sizeof(Q931_RELEASE_COMPLETE_ASN));

    if ((pUserInfo->h323_uu_pdu.bit_mask & H323_UU_PDU_nnStndrdDt_present) != 0)
    {
        pParsedData->NonStandardDataPresent = TRUE;
        if (pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.choice 
            == H225NonStandardIdentifier_h221NonStandard_chosen)
        {
            pParsedData->NonStandardData.bCountryCode =
                (BYTE)(pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.t35CountryCode);
            pParsedData->NonStandardData.bExtension =
                (BYTE)(pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.t35Extension);
            pParsedData->NonStandardData.wManufacturerCode =
                pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.manufacturerCode;
        }
        pParsedData->NonStandardData.sData.wOctetStringLength =	(WORD)
            pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.data.length;
		pParsedData->NonStandardData.sData.pOctetString =
			(BYTE *)MemAlloc(pParsedData->NonStandardData.sData.wOctetStringLength);
		if (pParsedData->NonStandardData.sData.pOctetString == NULL)
		{
            freePDU(pWorld, PDU, pDecodedBuf, q931asn);
            return CS_NO_MEMORY;
		}
		memcpy(pParsedData->NonStandardData.sData.pOctetString,
			   pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.data.value,
			   pParsedData->NonStandardData.sData.wOctetStringLength);    }
    else
    {
        pParsedData->NonStandardDataPresent = FALSE;
    }

    if ((pUserInfo->h323_uu_pdu.h323_message_body.u.releaseComplete.bit_mask &
            ReleaseComplete_UUIE_callIdentifier_present) != 0)
    {
        ASSERT(pUserInfo->h323_uu_pdu.h323_message_body.u.releaseComplete.callIdentifier.guid.length 
            <= sizeof(GUID));
        memcpy(&pParsedData->CallIdentifier,
            pUserInfo->h323_uu_pdu.h323_message_body.u.releaseComplete.callIdentifier.guid.value,
            pUserInfo->h323_uu_pdu.h323_message_body.u.releaseComplete.callIdentifier.guid.length);
    }
    
    if (pUserInfo->h323_uu_pdu.h323_message_body.u.releaseComplete.bit_mask 
        & ReleaseComplete_UUIE_reason_present)
    {
        switch (pUserInfo->h323_uu_pdu.h323_message_body.u.releaseComplete.reason.choice)
		{
        case noBandwidth_chosen:
			pParsedData->bReason = CC_REJECT_NO_BANDWIDTH;
			break;
        case gatekeeperResources_chosen:
			pParsedData->bReason = CC_REJECT_GATEKEEPER_RESOURCES;
			break;
        case unreachableDestination_chosen:
			pParsedData->bReason = CC_REJECT_UNREACHABLE_DESTINATION;
			break;
        case destinationRejection_chosen:
			pParsedData->bReason = CC_REJECT_DESTINATION_REJECTION;
			break;
        case ReleaseCompleteReason_invalidRevision_chosen:
			pParsedData->bReason = CC_REJECT_INVALID_REVISION;
			break;
        case noPermission_chosen:
			pParsedData->bReason = CC_REJECT_NO_PERMISSION;
			break;
        case unreachableGatekeeper_chosen:
			pParsedData->bReason = CC_REJECT_UNREACHABLE_GATEKEEPER;
			break;
        case gatewayResources_chosen:
			pParsedData->bReason = CC_REJECT_GATEWAY_RESOURCES;
			break;
        case badFormatAddress_chosen:
			pParsedData->bReason = CC_REJECT_BAD_FORMAT_ADDRESS;
			break;
        case adaptiveBusy_chosen:
			pParsedData->bReason = CC_REJECT_ADAPTIVE_BUSY;
			break;
        case inConf_chosen:
			pParsedData->bReason = CC_REJECT_IN_CONF;
			break;
        case securityDenied_chosen:
			pParsedData->bReason = CC_REJECT_SECURITY_DENIED;
			break;
        case facilityCallDeflection_chosen:
			pParsedData->bReason = CC_REJECT_CALL_DEFLECTION;
			break;
		default:
            pParsedData->bReason = CC_REJECT_UNDEFINED_REASON;
		} // switch
    }
	else
	{
		pParsedData->bReason = CC_REJECT_UNDEFINED_REASON;
	}

    // Free the PDU data.
    Result = freePDU(pWorld, PDU, pDecodedBuf, q931asn);
    ASSERT(ASN1_SUCCEEDED(Result));
    return CS_OK;
}

//------------------------------------------------------------------------
//------------------------------------------------------------------------
HRESULT
Q931ConnectParseASN(
    ASN1_CODER_INFO *pWorld,
    BYTE *pEncodedBuf,
    DWORD dwEncodedLength,
    Q931_CONNECT_ASN *pParsedData)
{
    int PDU = H323_UserInformation_PDU;
    char *pDecodedBuf = NULL;
    H323_UserInformation *pUserInfo;
    struct ObjectID_ *id;
    int Result;

    if (pParsedData == NULL)
    {
        return CS_BAD_PARAM;
    }

    Result = Q931_Decode(pWorld,
                         (void **) &pDecodedBuf,
                         PDU,
                         pEncodedBuf,
                         dwEncodedLength);

    if (ASN1_FAILED(Result) || (pDecodedBuf == NULL))
    {
        ASSERT(FALSE);
        // trace and return an decoding error of some sort.
        // Note: some values of Result should cause CS_SUBSYSTEM_FAILURE return.
        return CS_BAD_PARAM;
    }

    // validate some basic things about the PDU...
    pUserInfo = (H323_UserInformation *)pDecodedBuf;

    // validate that this is a H323 PDU.
    if (PDU != H323_UserInformation_PDU)
    {
        freePDU(pWorld, PDU, pDecodedBuf, q931asn);
        return CS_BAD_PARAM;
    }

    // validate that the PDU user-data uses ASN encoding.
    if (((pUserInfo->bit_mask & user_data_present) != 0) &&
            (pUserInfo->user_data.protocol_discriminator != USE_ASN1_ENCODING))
    {
        freePDU(pWorld, PDU, pDecodedBuf, q931asn);
        return CS_BAD_PARAM;
    }

    // validate that the PDU is H323 Connect information.
    if (pUserInfo->h323_uu_pdu.h323_message_body.choice != connect_chosen)
    {
        freePDU(pWorld, PDU, pDecodedBuf, q931asn);
        return CS_BAD_PARAM;
    }

    id = pUserInfo->h323_uu_pdu.h323_message_body.u.connect.protocolIdentifier;
    if (!Q931ValidPduVersion(id))
    {
        freePDU(pWorld, PDU, pDecodedBuf, q931asn);
        return CS_INCOMPATIBLE_VERSION;
    }

    // make sure that the conference id is formed correctly.
    if (pUserInfo->h323_uu_pdu.h323_message_body.u.connect.conferenceID.length >
            sizeof(pUserInfo->h323_uu_pdu.h323_message_body.u.connect.conferenceID.value))
    {
        freePDU(pWorld, PDU, pDecodedBuf, q931asn);
        return CS_BAD_PARAM;
    }

    // parse the message contained in pUserInfo.
    memset(pParsedData, 0, sizeof(Q931_CONNECT_ASN));
    pParsedData->h245Addr.bMulticast = FALSE;

    if ((pUserInfo->h323_uu_pdu.bit_mask & H323_UU_PDU_nnStndrdDt_present) != 0)
    {
        pParsedData->NonStandardDataPresent = TRUE;
        if (pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.choice ==
                H225NonStandardIdentifier_h221NonStandard_chosen)
        {
            pParsedData->NonStandardData.bCountryCode =
                (BYTE)(pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.t35CountryCode);
            pParsedData->NonStandardData.bExtension =
                (BYTE)(pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.t35Extension);
            pParsedData->NonStandardData.wManufacturerCode =
                pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.manufacturerCode;
        }
        pParsedData->NonStandardData.sData.wOctetStringLength = (WORD)
            pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.data.length;
		pParsedData->NonStandardData.sData.pOctetString =
			(BYTE *)MemAlloc(pParsedData->NonStandardData.sData.wOctetStringLength);
		if (pParsedData->NonStandardData.sData.pOctetString == NULL)
		{
            freePDU(pWorld, PDU, pDecodedBuf, q931asn);
            return CS_NO_MEMORY;
		}
		memcpy(pParsedData->NonStandardData.sData.pOctetString,
			   pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.data.value,
			   pParsedData->NonStandardData.sData.wOctetStringLength);
    }
    else
    {
        pParsedData->NonStandardDataPresent = FALSE;
    }

    if ((pUserInfo->h323_uu_pdu.h323_message_body.u.connect.bit_mask &
            Cnnct_UUIE_h245Address_present) != 0)
    {
        BYTE *a = (BYTE *)(&(pParsedData->h245Addr.Addr.IP_Binary.dwAddr));
        pParsedData->h245Addr.nAddrType = CC_IP_BINARY;
        pParsedData->h245Addr.Addr.IP_Binary.wPort = 
            pUserInfo->h323_uu_pdu.h323_message_body.u.connect.Cnnct_UUIE_h245Address.u.ipAddress.port;
        a[3] = pUserInfo->h323_uu_pdu.h323_message_body.u.connect.Cnnct_UUIE_h245Address.u.ipAddress.ip.value[0];
        a[2] = pUserInfo->h323_uu_pdu.h323_message_body.u.connect.Cnnct_UUIE_h245Address.u.ipAddress.ip.value[1];
        a[1] = pUserInfo->h323_uu_pdu.h323_message_body.u.connect.Cnnct_UUIE_h245Address.u.ipAddress.ip.value[2];
        a[0] = pUserInfo->h323_uu_pdu.h323_message_body.u.connect.Cnnct_UUIE_h245Address.u.ipAddress.ip.value[3];
        pParsedData->h245AddrPresent = TRUE;
    }
    else
    {
        pParsedData->h245AddrPresent = FALSE;
    }

    // no validation of destinationInfo needed.

    pParsedData->EndpointType.pVendorInfo = NULL;
    if (pUserInfo->h323_uu_pdu.h323_message_body.u.connect.destinationInfo.bit_mask & (vendor_present))
    {
        pParsedData->EndpointType.pVendorInfo = &(pParsedData->VendorInfo);
        pParsedData->VendorInfo.bCountryCode =
            (BYTE)pUserInfo->h323_uu_pdu.h323_message_body.u.connect.destinationInfo.vendor.vendor.t35CountryCode;
        pParsedData->VendorInfo.bExtension =
            (BYTE)pUserInfo->h323_uu_pdu.h323_message_body.u.connect.destinationInfo.vendor.vendor.t35Extension;
        pParsedData->VendorInfo.wManufacturerCode =
            pUserInfo->h323_uu_pdu.h323_message_body.u.connect.destinationInfo.vendor.vendor.manufacturerCode;

        if (pUserInfo->h323_uu_pdu.h323_message_body.u.connect.destinationInfo.vendor.bit_mask & (productId_present))
        {
            pParsedData->VendorInfo.pProductNumber = MemAlloc(sizeof(CC_OCTETSTRING));
            if (pParsedData->VendorInfo.pProductNumber == NULL)
            {
				if (pParsedData->NonStandardData.sData.pOctetString != NULL)
					MemFree(pParsedData->NonStandardData.sData.pOctetString);
                freePDU(pWorld, PDU, pDecodedBuf, q931asn);
                return CS_NO_MEMORY;
            }
            pParsedData->VendorInfo.pProductNumber->wOctetStringLength = (WORD)
                min(pUserInfo->h323_uu_pdu.h323_message_body.u.connect.destinationInfo.vendor.productId.length,
                CC_MAX_PRODUCT_LENGTH - 1);
            memcpy(pParsedData->bufProductValue,
                pUserInfo->h323_uu_pdu.h323_message_body.u.connect.destinationInfo.vendor.productId.value,
                pParsedData->VendorInfo.pProductNumber->wOctetStringLength);
            pParsedData->bufProductValue[pParsedData->VendorInfo.pProductNumber->wOctetStringLength] = '\0';
            pParsedData->VendorInfo.pProductNumber->pOctetString = pParsedData->bufProductValue;
        }
        if (pUserInfo->h323_uu_pdu.h323_message_body.u.connect.destinationInfo.vendor.bit_mask & (versionId_present))
        {
            pParsedData->VendorInfo.pVersionNumber = MemAlloc(sizeof(CC_OCTETSTRING));
            if (pParsedData->VendorInfo.pVersionNumber == NULL)
            {
				if (pParsedData->NonStandardData.sData.pOctetString != NULL)
					MemFree(pParsedData->NonStandardData.sData.pOctetString);
                MemFree(pParsedData->VendorInfo.pProductNumber);
                freePDU(pWorld, PDU, pDecodedBuf, q931asn);
                return CS_NO_MEMORY;
            }
            pParsedData->VendorInfo.pVersionNumber->wOctetStringLength = (WORD)
                min(pUserInfo->h323_uu_pdu.h323_message_body.u.connect.destinationInfo.vendor.versionId.length,
                CC_MAX_VERSION_LENGTH - 1);
            memcpy(pParsedData->bufVersionValue,
                pUserInfo->h323_uu_pdu.h323_message_body.u.connect.destinationInfo.vendor.versionId.value,
                pParsedData->VendorInfo.pVersionNumber->wOctetStringLength);
            pParsedData->bufVersionValue[pParsedData->VendorInfo.pVersionNumber->wOctetStringLength] = '\0';
            pParsedData->VendorInfo.pVersionNumber->pOctetString = pParsedData->bufVersionValue;
        }

    }

    pParsedData->EndpointType.bIsTerminal = FALSE;
    if (pUserInfo->h323_uu_pdu.h323_message_body.u.connect.destinationInfo.bit_mask & (terminal_present))
    {
        pParsedData->EndpointType.bIsTerminal = TRUE;
    }
    pParsedData->EndpointType.bIsGateway = FALSE;
    if (pUserInfo->h323_uu_pdu.h323_message_body.u.connect.destinationInfo.bit_mask & (gateway_present))
    {
        pParsedData->EndpointType.bIsGateway = TRUE;
    }


    memcpy(pParsedData->ConferenceID.buffer,
        pUserInfo->h323_uu_pdu.h323_message_body.u.connect.conferenceID.value,
        pUserInfo->h323_uu_pdu.h323_message_body.u.connect.conferenceID.length);

     if ((pUserInfo->h323_uu_pdu.h323_message_body.u.connect.bit_mask &
            Connect_UUIE_callIdentifier_present) != 0)
    {
        ASSERT(pUserInfo->h323_uu_pdu.h323_message_body.u.connect.callIdentifier.guid.length 
            <= sizeof(GUID));
        memcpy(&pParsedData->CallIdentifier,
            pUserInfo->h323_uu_pdu.h323_message_body.u.connect.callIdentifier.guid.value,
            pUserInfo->h323_uu_pdu.h323_message_body.u.connect.callIdentifier.guid.length);
    }

    // Free the PDU data.
    Result = freePDU(pWorld, PDU, pDecodedBuf, q931asn);
    ASSERT(ASN1_SUCCEEDED(Result));
    return CS_OK;
}

//------------------------------------------------------------------------
//------------------------------------------------------------------------
HRESULT
Q931AlertingParseASN(
    ASN1_CODER_INFO *pWorld,
    BYTE *pEncodedBuf,
    DWORD dwEncodedLength,
    Q931_ALERTING_ASN *pParsedData)
{
    int PDU = H323_UserInformation_PDU;
    char *pDecodedBuf = NULL;
    H323_UserInformation *pUserInfo;
    struct ObjectID_ *id;
    int Result;

    if (pParsedData == NULL)
    {
        return CS_BAD_PARAM;
    }

    Result = Q931_Decode(pWorld,
                         (void **) &pDecodedBuf,
                         PDU,
                         pEncodedBuf,
                         dwEncodedLength);

    if (ASN1_FAILED(Result) || (pDecodedBuf == NULL))
    {
        ASSERT(FALSE);
        // trace and return an decoding error of some sort.
        // Note: some values of Result should cause CS_SUBSYSTEM_FAILURE return.
        return CS_BAD_PARAM;
    }

    // validate some basic things about the PDU...
    pUserInfo = (H323_UserInformation *)pDecodedBuf;

    // validate that this is a H323 PDU.
    if (PDU != H323_UserInformation_PDU)
    {
        freePDU(pWorld, PDU, pDecodedBuf, q931asn);
        return CS_BAD_PARAM;
    }

    // validate that the PDU user-data uses ASN encoding.
    if (((pUserInfo->bit_mask & user_data_present) != 0) &&
            (pUserInfo->user_data.protocol_discriminator != USE_ASN1_ENCODING))
    {
        freePDU(pWorld, PDU, pDecodedBuf, q931asn);
        return CS_BAD_PARAM;
    }

    // validate that the PDU is H323 Alerting information.
    if (pUserInfo->h323_uu_pdu.h323_message_body.choice != alerting_chosen)
    {
        freePDU(pWorld, PDU, pDecodedBuf, q931asn);
        return CS_BAD_PARAM;
    }

    id = pUserInfo->h323_uu_pdu.h323_message_body.u.alerting.protocolIdentifier;
    if (!Q931ValidPduVersion(id))
    {
        freePDU(pWorld, PDU, pDecodedBuf, q931asn);
        return CS_INCOMPATIBLE_VERSION;
    }

    // parse the message contained in pUserInfo.
    memset(pParsedData, 0, sizeof(Q931_ALERTING_ASN));
    pParsedData->h245Addr.bMulticast = FALSE;

    if ((pUserInfo->h323_uu_pdu.bit_mask & H323_UU_PDU_nnStndrdDt_present) != 0)
    {
        pParsedData->NonStandardDataPresent = TRUE;
        if (pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.choice ==
                H225NonStandardIdentifier_h221NonStandard_chosen)
        {
            pParsedData->NonStandardData.bCountryCode =
                (BYTE)(pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.t35CountryCode);
            pParsedData->NonStandardData.bExtension =
                (BYTE)(pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.t35Extension);
            pParsedData->NonStandardData.wManufacturerCode =
                pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.manufacturerCode;
        }
        pParsedData->NonStandardData.sData.wOctetStringLength =	(WORD)
            pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.data.length;
		pParsedData->NonStandardData.sData.pOctetString =
			(BYTE *)MemAlloc(pParsedData->NonStandardData.sData.wOctetStringLength);
		if (pParsedData->NonStandardData.sData.pOctetString == NULL)
		{
            freePDU(pWorld, PDU, pDecodedBuf, q931asn);
            return CS_NO_MEMORY;
		}
		memcpy(pParsedData->NonStandardData.sData.pOctetString,
			   pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.data.value,
			   pParsedData->NonStandardData.sData.wOctetStringLength);
    }
    else
    {
        pParsedData->NonStandardDataPresent = FALSE;
    }

    if ((pUserInfo->h323_uu_pdu.h323_message_body.u.alerting.bit_mask &
            CPg_UUIE_h245Addrss_present) != 0)
    {
        BYTE *a = (BYTE *)(&(pParsedData->h245Addr.Addr.IP_Binary.dwAddr));
        pParsedData->h245Addr.nAddrType = CC_IP_BINARY;
        pParsedData->h245Addr.Addr.IP_Binary.wPort = 
            pUserInfo->h323_uu_pdu.h323_message_body.u.alerting.CPg_UUIE_h245Addrss.u.ipAddress.port;
        a[3] = pUserInfo->h323_uu_pdu.h323_message_body.u.alerting.CPg_UUIE_h245Addrss.u.ipAddress.ip.value[0];
        a[2] = pUserInfo->h323_uu_pdu.h323_message_body.u.alerting.CPg_UUIE_h245Addrss.u.ipAddress.ip.value[1];
        a[1] = pUserInfo->h323_uu_pdu.h323_message_body.u.alerting.CPg_UUIE_h245Addrss.u.ipAddress.ip.value[2];
        a[0] = pUserInfo->h323_uu_pdu.h323_message_body.u.alerting.CPg_UUIE_h245Addrss.u.ipAddress.ip.value[3];
    }

    if ((pUserInfo->h323_uu_pdu.h323_message_body.u.alerting.bit_mask &
            Alerting_UUIE_callIdentifier_present) != 0)
    {
        ASSERT(pUserInfo->h323_uu_pdu.h323_message_body.u.alerting.callIdentifier.guid.length 
            <= sizeof(GUID));
        memcpy(&pParsedData->CallIdentifier,
            pUserInfo->h323_uu_pdu.h323_message_body.u.alerting.callIdentifier.guid.value,
            pUserInfo->h323_uu_pdu.h323_message_body.u.alerting.callIdentifier.guid.length);
    }

//RMO. ignore the destinationInfo field.

    // Free the PDU data.
    Result = freePDU(pWorld, PDU, pDecodedBuf, q931asn);
    ASSERT(ASN1_SUCCEEDED(Result));
    return CS_OK;
}

//------------------------------------------------------------------------
//------------------------------------------------------------------------
HRESULT
Q931ProceedingParseASN(
    ASN1_CODER_INFO *pWorld,
    BYTE *pEncodedBuf,
    DWORD dwEncodedLength,
    Q931_CALL_PROCEEDING_ASN *pParsedData)
{
    int PDU = H323_UserInformation_PDU;
    char *pDecodedBuf = NULL;
    H323_UserInformation *pUserInfo;
    struct ObjectID_ *id;
    int Result;

    if (pParsedData == NULL)
    {
        return CS_BAD_PARAM;
    }

    Result = Q931_Decode(pWorld,
                         (void **) &pDecodedBuf,
                         PDU,
                         pEncodedBuf,
                         dwEncodedLength);

    if (ASN1_FAILED(Result) || (pDecodedBuf == NULL))
    {
        ASSERT(FALSE);
        // trace and return an decoding error of some sort.
        // Note: some values of Result should cause CS_SUBSYSTEM_FAILURE return.
        return CS_BAD_PARAM;
    }

    // validate some basic things about the PDU...
    pUserInfo = (H323_UserInformation *)pDecodedBuf;

    // validate that this is a H323 PDU.
    if (PDU != H323_UserInformation_PDU)
    {
        freePDU(pWorld, PDU, pDecodedBuf, q931asn);
        return CS_BAD_PARAM;
    }

    // validate that the PDU user-data uses ASN encoding.
    if (((pUserInfo->bit_mask & user_data_present) != 0) &&
            (pUserInfo->user_data.protocol_discriminator != USE_ASN1_ENCODING))
    {
        freePDU(pWorld, PDU, pDecodedBuf, q931asn);
        return CS_BAD_PARAM;
    }

    // validate that the PDU is H323 Call Proceeding information.
    if (pUserInfo->h323_uu_pdu.h323_message_body.choice != callProceeding_chosen)
    {
        freePDU(pWorld, PDU, pDecodedBuf, q931asn);
        return CS_BAD_PARAM;
    }

    id = pUserInfo->h323_uu_pdu.h323_message_body.u.callProceeding.protocolIdentifier;
    if (!Q931ValidPduVersion(id))
    {
        freePDU(pWorld, PDU, pDecodedBuf, q931asn);
        return CS_INCOMPATIBLE_VERSION;
    }

    // parse the message contained in pUserInfo.
    memset(pParsedData, 0, sizeof(Q931_CALL_PROCEEDING_ASN));
    pParsedData->h245Addr.bMulticast = FALSE;

    if ((pUserInfo->h323_uu_pdu.bit_mask & H323_UU_PDU_nnStndrdDt_present) != 0)
    {
        pParsedData->NonStandardDataPresent = TRUE;
        if (pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.choice ==
                H225NonStandardIdentifier_h221NonStandard_chosen)
        {
            pParsedData->NonStandardData.bCountryCode =
                (BYTE)(pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.t35CountryCode);
            pParsedData->NonStandardData.bExtension =
                (BYTE)(pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.t35Extension);
            pParsedData->NonStandardData.wManufacturerCode =
                pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.manufacturerCode;
        }
        pParsedData->NonStandardData.sData.wOctetStringLength =	(WORD)
        pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.data.length;
				pParsedData->NonStandardData.sData.pOctetString =
			(BYTE *)MemAlloc(pParsedData->NonStandardData.sData.wOctetStringLength);
		if (pParsedData->NonStandardData.sData.pOctetString == NULL)
		{
            freePDU(pWorld, PDU, pDecodedBuf, q931asn);
            return CS_NO_MEMORY;
		}
		memcpy(pParsedData->NonStandardData.sData.pOctetString,
			   pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.data.value,
			   pParsedData->NonStandardData.sData.wOctetStringLength);
    }
    else
    {
        pParsedData->NonStandardDataPresent = FALSE;
    }

    if ((pUserInfo->h323_uu_pdu.h323_message_body.u.callProceeding.bit_mask &
            CPg_UUIE_h245Addrss_present) != 0)
    {
        BYTE *a = (BYTE *)(&(pParsedData->h245Addr.Addr.IP_Binary.dwAddr));
        pParsedData->h245Addr.nAddrType = CC_IP_BINARY;
        pParsedData->h245Addr.Addr.IP_Binary.wPort = 
            pUserInfo->h323_uu_pdu.h323_message_body.u.callProceeding.CPg_UUIE_h245Addrss.u.ipAddress.port;
        a[3] = pUserInfo->h323_uu_pdu.h323_message_body.u.callProceeding.CPg_UUIE_h245Addrss.u.ipAddress.ip.value[0];
        a[2] = pUserInfo->h323_uu_pdu.h323_message_body.u.callProceeding.CPg_UUIE_h245Addrss.u.ipAddress.ip.value[1];
        a[1] = pUserInfo->h323_uu_pdu.h323_message_body.u.callProceeding.CPg_UUIE_h245Addrss.u.ipAddress.ip.value[2];
        a[0] = pUserInfo->h323_uu_pdu.h323_message_body.u.callProceeding.CPg_UUIE_h245Addrss.u.ipAddress.ip.value[3];
    }

    if ((pUserInfo->h323_uu_pdu.h323_message_body.u.callProceeding.bit_mask &
            CallProceeding_UUIE_callIdentifier_present) != 0)
    {
        ASSERT(pUserInfo->h323_uu_pdu.h323_message_body.u.callProceeding.callIdentifier.guid.length 
            <= sizeof(GUID));
        memcpy(&pParsedData->CallIdentifier,
            pUserInfo->h323_uu_pdu.h323_message_body.u.callProceeding.callIdentifier.guid.value,
            pUserInfo->h323_uu_pdu.h323_message_body.u.callProceeding.callIdentifier.guid.length);
    }
//RMO. ignore the destinationInfo field.

    // Free the PDU data.
    Result = freePDU(pWorld, PDU, pDecodedBuf, q931asn);
    ASSERT(ASN1_SUCCEEDED(Result));
    return CS_OK;
}

//------------------------------------------------------------------------
//------------------------------------------------------------------------
HRESULT
Q931FacilityParseASN(
    ASN1_CODER_INFO *pWorld,
    BYTE *pEncodedBuf,
    DWORD dwEncodedLength,
    Q931_FACILITY_ASN *pParsedData)
{
    int PDU = H323_UserInformation_PDU;
    char *pDecodedBuf = NULL;
    H323_UserInformation *pUserInfo;
    int Result;

    if (pParsedData == NULL)
    {
        return CS_BAD_PARAM;
    }

    Result = Q931_Decode(pWorld,
                         (void **) &pDecodedBuf,
                         PDU,
                         pEncodedBuf,
                         dwEncodedLength);

    if (ASN1_FAILED(Result) || (pDecodedBuf == NULL))
    {
        ASSERT(FALSE);
        // trace and return an decoding error of some sort.
        // Note: some values of Result should cause CS_SUBSYSTEM_FAILURE return.
        return CS_BAD_PARAM;
    }

    // validate some basic things about the PDU...
    pUserInfo = (H323_UserInformation *)pDecodedBuf;

    // validate that this is a H323 PDU.
    if (PDU != H323_UserInformation_PDU)
    {
        freePDU(pWorld, PDU, pDecodedBuf, q931asn);
        return CS_BAD_PARAM;
    }

    // validate that the PDU user-data uses ASN encoding.
    if (((pUserInfo->bit_mask & user_data_present) != 0) &&
            (pUserInfo->user_data.protocol_discriminator != USE_ASN1_ENCODING))
    {
        freePDU(pWorld, PDU, pDecodedBuf, q931asn);
        return CS_BAD_PARAM;
    }

    // validate that the PDU is H323 Facility information.
    if (pUserInfo->h323_uu_pdu.h323_message_body.choice != facility_chosen)
    {
        freePDU(pWorld, PDU, pDecodedBuf, q931asn);
        return CS_BAD_PARAM;
    }

    {
        struct ObjectID_ *id;

        id = pUserInfo->h323_uu_pdu.h323_message_body.u.facility.protocolIdentifier;
        if (!Q931ValidPduVersion(id))
        {
            freePDU(pWorld, PDU, pDecodedBuf, q931asn);
            return CS_INCOMPATIBLE_VERSION;
        }
    }

    // if there is a conference id, make sure that it is formed correctly.
    if ((pUserInfo->h323_uu_pdu.h323_message_body.u.facility.bit_mask &
            Facility_UUIE_conferenceID_present) != 0)
    {
        if (pUserInfo->h323_uu_pdu.h323_message_body.u.facility.conferenceID.length >
                sizeof(pUserInfo->h323_uu_pdu.h323_message_body.u.facility.conferenceID.value))
        {
            freePDU(pWorld, PDU, pDecodedBuf, q931asn);
            return CS_BAD_PARAM;
        }
    }

    // parse the message contained in pUserInfo.
    memset(pParsedData, 0, sizeof(Q931_FACILITY_ASN));
    pParsedData->AlternativeAddr.bMulticast = FALSE;

    if ((pUserInfo->h323_uu_pdu.bit_mask & H323_UU_PDU_nnStndrdDt_present) != 0)
    {
        pParsedData->NonStandardDataPresent = TRUE;
        if (pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.choice ==
                H225NonStandardIdentifier_h221NonStandard_chosen)
        {
            pParsedData->NonStandardData.bCountryCode =
                (BYTE)(pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.t35CountryCode);
            pParsedData->NonStandardData.bExtension =
                (BYTE)(pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.t35Extension);
            pParsedData->NonStandardData.wManufacturerCode =
                pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.manufacturerCode;
        }
        pParsedData->NonStandardData.sData.wOctetStringLength =	(WORD)
            pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.data.length;
		pParsedData->NonStandardData.sData.pOctetString =
			(BYTE *)MemAlloc(pParsedData->NonStandardData.sData.wOctetStringLength);
		if (pParsedData->NonStandardData.sData.pOctetString == NULL)
		{
            freePDU(pWorld, PDU, pDecodedBuf, q931asn);
            return CS_NO_MEMORY;
		}
		memcpy(pParsedData->NonStandardData.sData.pOctetString,
			   pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.data.value,
			   pParsedData->NonStandardData.sData.wOctetStringLength);
    }
    else
    {
        pParsedData->NonStandardDataPresent = FALSE;
    }

    if ((pUserInfo->h323_uu_pdu.h323_message_body.u.facility.bit_mask &
            alternativeAddress_present) != 0)
    {
        BYTE *a = (BYTE *)(&(pParsedData->AlternativeAddr.Addr.IP_Binary.dwAddr));
        pParsedData->AlternativeAddr.nAddrType = CC_IP_BINARY;
        pParsedData->AlternativeAddr.Addr.IP_Binary.wPort = 
            pUserInfo->h323_uu_pdu.h323_message_body.u.facility.alternativeAddress.u.ipAddress.port;
        a[3] = pUserInfo->h323_uu_pdu.h323_message_body.u.facility.alternativeAddress.u.ipAddress.ip.value[0];
        a[2] = pUserInfo->h323_uu_pdu.h323_message_body.u.facility.alternativeAddress.u.ipAddress.ip.value[1];
        a[1] = pUserInfo->h323_uu_pdu.h323_message_body.u.facility.alternativeAddress.u.ipAddress.ip.value[2];
        a[0] = pUserInfo->h323_uu_pdu.h323_message_body.u.facility.alternativeAddress.u.ipAddress.ip.value[3];
    }

    if ((pUserInfo->h323_uu_pdu.h323_message_body.u.facility.bit_mask &
            alternativeAliasAddress_present) != 0)
    {
        CS_STATUS AliasResult = CS_OK;

        // parse the sourceAddress aliases here...
        AliasResult = SeqofToAlias(&(pParsedData->pAlternativeAliasList),
            (struct Setup_UUIE_sourceAddress *)pUserInfo->h323_uu_pdu.h323_message_body.u.facility.alternativeAliasAddress);
        if (AliasResult != CS_OK)
        {
            freePDU(pWorld, PDU, pDecodedBuf, q931asn);
            return CS_NO_MEMORY;
        }
    }

    if ((pUserInfo->h323_uu_pdu.h323_message_body.u.facility.bit_mask &
            Facility_UUIE_conferenceID_present) != 0)
    {
        memcpy(pParsedData->ConferenceID.buffer,
            pUserInfo->h323_uu_pdu.h323_message_body.u.facility.conferenceID.value,
            pUserInfo->h323_uu_pdu.h323_message_body.u.facility.conferenceID.length);
        pParsedData->ConferenceIDPresent = TRUE;
    }

	switch (pUserInfo->h323_uu_pdu.h323_message_body.u.facility.reason.choice)
    {
	case FacilityReason_routeCallToGatekeeper_chosen:
        pParsedData->bReason = CC_REJECT_ROUTE_TO_GATEKEEPER;
		break;
	case callForwarded_chosen:
        pParsedData->bReason = CC_REJECT_CALL_FORWARDED;
		break;
	case routeCallToMC_chosen:
        pParsedData->bReason = CC_REJECT_ROUTE_TO_MC;
		break;
	default:
        pParsedData->bReason = CC_REJECT_UNDEFINED_REASON;
	} // switch


    if ((pUserInfo->h323_uu_pdu.h323_message_body.u.facility.bit_mask &
            Facility_UUIE_callIdentifier_present) != 0)
    {
        ASSERT(pUserInfo->h323_uu_pdu.h323_message_body.u.facility.callIdentifier.guid.length 
            <= sizeof(GUID));
        memcpy(&pParsedData->CallIdentifier,
            pUserInfo->h323_uu_pdu.h323_message_body.u.facility.callIdentifier.guid.value,
            pUserInfo->h323_uu_pdu.h323_message_body.u.facility.callIdentifier.guid.length);
    }
    
    // Free the PDU data.
    Result = freePDU(pWorld, PDU, pDecodedBuf, q931asn);
    ASSERT(ASN1_SUCCEEDED(Result));
    return CS_OK;
}

// THE FOLLOWING IS ADDED FOR TELES ASN.1 INTEGRATION

int H225_InitModule(void)
{
    H225ASN_Module_Startup();
    return (H225ASN_Module != NULL) ? ASN1_SUCCESS : ASN1_ERR_MEMORY;
}

int H225_TermModule(void)
{
    H225ASN_Module_Cleanup();
    return ASN1_SUCCESS;
}

int Q931_InitWorld(ASN1_CODER_INFO *pWorld)
{
    int rc;

    ZeroMemory(pWorld, sizeof(*pWorld));

    if (H225ASN_Module == NULL)
    {
        return ASN1_ERR_BADARGS;
    }

    rc = ASN1_CreateEncoder(
                H225ASN_Module,         // ptr to mdule
                &(pWorld->pEncInfo),    // ptr to encoder info
                NULL,                   // buffer ptr
                0,                      // buffer size
                NULL);                  // parent ptr
    if (rc == ASN1_SUCCESS)
    {
        ASSERT(pWorld->pEncInfo != NULL);
        rc = ASN1_CreateDecoder(
                H225ASN_Module,         // ptr to mdule
                &(pWorld->pDecInfo),    // ptr to decoder info
                NULL,                   // buffer ptr
                0,                      // buffer size
                NULL);                  // parent ptr
        ASSERT(pWorld->pDecInfo != NULL);
    }

    if (rc != ASN1_SUCCESS)
    {
        Q931_TermWorld(pWorld);
    }

    return rc;
}

int Q931_TermWorld(ASN1_CODER_INFO *pWorld)
{
    if (H225ASN_Module == NULL)
    {
        return ASN1_ERR_BADARGS;
    }

    ASN1_CloseEncoder(pWorld->pEncInfo);
    ASN1_CloseDecoder(pWorld->pDecInfo);

    ZeroMemory(pWorld, sizeof(*pWorld));

    return ASN1_SUCCESS;
}

int Q931_Encode(ASN1_CODER_INFO *pWorld, void *pStruct, int nPDU, BYTE **ppEncoded, DWORD *pcbEncodedSize)
{
    ASN1encoding_t pEncInfo = pWorld->pEncInfo;
    int rc = ASN1_Encode(
                    pEncInfo,                   // ptr to encoder info
                    pStruct,                    // pdu data structure
                    nPDU,                       // pdu id
                    ASN1ENCODE_ALLOCATEBUFFER,  // flags
                    NULL,                       // do not provide buffer
                    0);                         // buffer size if provided
    if (ASN1_SUCCEEDED(rc))
    {
        *pcbEncodedSize = pEncInfo->len;        // len of encoded data in buffer
        *ppEncoded = pEncInfo->buf;             // buffer to encode into
    }
    else
    {
        ASSERT(FALSE);
        *pcbEncodedSize = 0;
        *ppEncoded = NULL;
    }
    return rc;
}

int Q931_Decode(ASN1_CODER_INFO *pWorld, void **ppStruct, int nPDU, BYTE *pEncoded, DWORD cbEncodedSize)
{
    ASN1decoding_t pDecInfo = pWorld->pDecInfo;
    int rc = ASN1_Decode(
                    pDecInfo,                   // ptr to encoder info
                    ppStruct,                   // pdu data structure
                    nPDU,                       // pdu id
                    ASN1DECODE_SETBUFFER,       // flags
                    pEncoded,                   // do not provide buffer
                    cbEncodedSize);             // buffer size if provided
    if (ASN1_FAILED(rc))
    {
        ASSERT(FALSE);
        *ppStruct = NULL;
    }
    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\queue.c ===
/***************************************************************************
 *
 * File: queue.c
 *
 * INTEL Corporation Proprietary Information
 * Copyright (c) 1996 Intel Corporation.
 *
 * This listing is supplied under the terms of a license agreement
 * with INTEL Corporation and may not be used, copied, nor disclosed
 * except in accordance with the terms of that agreement.
 *
 ***************************************************************************
 *
 * $Workfile:   queue.c  $
 * $Revision:   1.8  $
 * $Modtime:   13 Dec 1996 11:48:16  $
 * $Log:   S:\sturgeon\src\h245ws\vcs\queue.c_v  $
 * 
 *    Rev 1.8   13 Dec 1996 12:13:12   SBELL1
 * moved ifdef _cplusplus to after includes
 * 
 *    Rev 1.7   May 28 1996 10:39:00   plantz
 * Change QFree to not free objects on the queue; instead it insists that
 * the queue be empty.
 * 
 *    Rev 1.6   21 May 1996 16:21:36   EHOWARDX
 * Added DeleteCriticalSection to QFree().
 * 
 *    Rev 1.5   Apr 24 1996 16:18:58   plantz
 * Removed include winsock2.h and incommon.h
 * 
 *    Rev 1.3.1.0   Apr 24 1996 16:16:42   plantz
 * Removed include winsock2.h and callcont.h
 * 
 *    Rev 1.3   01 Apr 1996 14:53:28   EHOWARDX
 * Changed pQUEUE to PQUEUE.
 * 
 *    Rev 1.1   09 Mar 1996 21:12:34   EHOWARDX
 * Fixes as result of testing.
 * 
 *    Rev 1.0   08 Mar 1996 20:22:38   unknown
 * Initial revision.
 *
 ***************************************************************************/

#ifndef STRICT
#define STRICT
#endif	// not defined STRICT

#pragma warning ( disable : 4115 4201 4214 4514 )
#undef _WIN32_WINNT	// override bogus platform definition in our common build environment

#include "precomp.h"

#include "queue.h"
#include "linkapi.h"
#include "h245ws.h"

#if defined(__cplusplus)
extern "C"
{
#endif  // (__cplusplus)



/*-*-------------------------------------------------------------------------

   Function Name:
      QCreate

   Syntax:
      PQUEUE QCreate(void);

   Parameters:
      None.

   Summary:
      Allocates and initializes a new queue.

   Returns:
      NULL        - Allocation of memory for new queue failed.
      Otherwise   - Address of new queue created.

-------------------------------------------------------------------------*-*/

PQUEUE QCreate(void)
{
   register PQUEUE     pQueue;         /* pointer to the new queue         */

   /* Allocate a new queue */
   pQueue = (PQUEUE)MemAlloc(sizeof(QUEUE));
   if (pQueue != NULL)
   {
      /* Initialize the new queue */
      pQueue->nHead = pQueue->nTail = Q_NULL;
      InitializeCriticalSection(&pQueue->CriticalSection);
   }

   return pQueue;
} /* QCreate */



/*-*-------------------------------------------------------------------------

   Function Name:
      QFree

   Syntax:
      void QFree(PQUEUE pQueue);

   Parameters:
      pQueue      -pointer to the queue to free

   Summary:
      Deallocates a queue that was allocated by QCreate.

-------------------------------------------------------------------------*-*/

void QFree(PQUEUE pQueue)
{
   /* The queue must be empty before it is freed. */
   HWSASSERT(pQueue->nHead == Q_NULL);

   /* Free the queue. */
   DeleteCriticalSection(&pQueue->CriticalSection);
   MemFree(pQueue);
} /* QFree */



/*
 *  NAME
 *      QRemove - remove object from head of queue
 *
 *  ARGUMENTS
 *      pQueue      Pointer to queue
 *
 *  RETURN VALUE
 *      Pointer to object dequeued or NULL of queue empty
 */

/*-*-------------------------------------------------------------------------

   Function Name:
      QRemove

   Syntax:
      LPVOID QRemove(PQUEUE pQueue);

   Parameters:
      pQueue      - Pointer to queue.

   Summary:
      Removes and returns object from head of queue.

   Returns:
      NULL        - Queue was empty.
      Otherwise   - Address of object dequeued.

-------------------------------------------------------------------------*-*/

LPVOID QRemove(PQUEUE pQueue)
{
   register LPVOID     pObject;           /* pointer to the object to remove  */

   EnterCriticalSection(&pQueue->CriticalSection);

   if (pQueue->nHead == Q_NULL)
   {
      /* If the queue is empty, we will return NULL */
      pObject = NULL;
   }
   else
   {
      /* Get the pointer, NULL it in the apObjects array. */
      pObject = pQueue->apObjects[pQueue->nHead];
      pQueue->apObjects[pQueue->nHead] = NULL;

      /* Check to see if we've just emptied the queue; if so, set */
      /* the nHead and nTail indices to Q_NULL.  If not, set the nHead */
      /* index to the right value. */
      if (pQueue->nHead == pQueue->nTail)
      {
         pQueue->nHead = pQueue->nTail = Q_NULL;
      }
      else
      {
         pQueue->nHead = (pQueue->nHead + 1) % MAX_QUEUE_SIZE;
      }
   }

   LeaveCriticalSection(&pQueue->CriticalSection);
   return pObject;
} /* QRemove */



/*-*-------------------------------------------------------------------------

   Function Name:
      QInsert

   Syntax:
      BOOL QInsert(PQUEUE pQueue, LPVOID pObject);

   Parameters:
      pQueue      - Pointer to queue to insert object into.
      pObject     - Pointer to object to insert into queue.

   Summary:
      Inserts an object at tail of queue.

   Returns:
      TRUE        - Object successfully added to queue.
      FALSE       - Queue full; object could not be added.

-------------------------------------------------------------------------*-*/

BOOL QInsert(PQUEUE pQueue, LPVOID pObject)
{
   register int        iTemp;

   EnterCriticalSection(&pQueue->CriticalSection);

   /* If the queue is full, set the return value to FALSE and do */
   /* nothing; if not, update the indices appropriately and set the */
   /* return value to TRUE.  */
   if (pQueue->nHead == Q_NULL)
   {
      /* Queue is empty */
      pQueue->apObjects[0] = pObject;
      pQueue->nHead = pQueue->nTail = 0;
      iTemp = TRUE;
   }
   else
   {
      iTemp = (pQueue->nTail + 1) % MAX_QUEUE_SIZE;
      if (iTemp == pQueue->nHead)
      {
         /* Queue is full */
         iTemp = FALSE;
      }
      else
      {
         pQueue->apObjects[iTemp] = pObject;
         pQueue->nTail = iTemp;
         iTemp = TRUE;
      }
   }

   LeaveCriticalSection(&pQueue->CriticalSection);
   return (BOOL) iTemp;
}



/*-*-------------------------------------------------------------------------

   Function Name:
      QInsertAtHead

   Syntax:
      BOOL QInsertAtHead(PQUEUE pQueue, LPVOID pObject);

   Parameters:
      pQueue      - Pointer to queue to insert object into.
      pObject     - Pointer to object to insert into queue.

   Summary:
      Inserts an object at head of queue.

   Returns:
      TRUE        - Object successfully added to queue.
      FALSE       - Queue full; object could not be added.

-------------------------------------------------------------------------*-*/

BOOL QInsertAtHead(PQUEUE pQueue, LPVOID pObject)
{
   register int        iTemp;

   EnterCriticalSection(&pQueue->CriticalSection);

   if (pQueue->nHead == Q_NULL)
   {
      /* Queue is empty */
      pQueue->apObjects[0] = pObject;
      pQueue->nHead = pQueue->nTail = 0;
      iTemp = TRUE;
   }
   else
   {
      iTemp = (pQueue->nHead + (MAX_QUEUE_SIZE - 1)) % MAX_QUEUE_SIZE;
      if (iTemp == pQueue->nTail)
      {
         /* Queue is full */
         iTemp = FALSE;
      }
      else
      {
         pQueue->apObjects[iTemp] = pObject;
         pQueue->nHead = iTemp;
         iTemp = TRUE;
      }
   }

   LeaveCriticalSection(&pQueue->CriticalSection);
   return (BOOL) iTemp;
} /* QInsertAtHead */



/*-*-------------------------------------------------------------------------

   Function Name:
      IsQEmpty

   Syntax:
      BOOL IsQEmpty(PQUEUE pQueue);

   Parameters:
      pQueue      - Pointer to queue to check.

   Summary:
      Checks if a queue is empty.

   Returns:
      TRUE        - Queue is empty.
      FALSE       - Queue contains at least one object.

-------------------------------------------------------------------------*-*/

BOOL IsQEmpty(PQUEUE pQueue)
{
   return (pQueue->nHead == Q_NULL ? TRUE : FALSE);
} /* IsQEmpty */



#if defined(__cplusplus)
}
#endif  // (__cplusplus)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\queue.h ===
/***********************************************************************
 *  INTEL Corporation Prorietary Information                           *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation.                          *
 ***********************************************************************/
/*-*-------------------------------------------------------------------------

   File Name:
      queue.h

   Summary:
      Queue management header file.

   Prerequisites:
      windows.h

   Hide:
   $Header:   S:\sturgeon\src\h245ws\vcs\queue.h_v   1.5   13 Dec 1996 12:13:58   SBELL1  $

-------------------------------------------------------------------------*-*/

#ifndef QUEUE_H
#define QUEUE_H

#if defined(__cplusplus)
extern "C"
{
#endif  // (__cplusplus)

#define NORMAL          0
#define ABNORMAL        1

#define MAX_QUEUE_SIZE  10
#define Q_NULL          -1

typedef struct _QUEUE
{

    LPVOID              apObjects[MAX_QUEUE_SIZE];
    int                 nHead;
    int                 nTail;
    CRITICAL_SECTION    CriticalSection;

} QUEUE, *PQUEUE;


PQUEUE  QCreate         (void);
void    QFree           (PQUEUE pQueue);
BOOL    QInsert         (PQUEUE pQueue, LPVOID pObject);
BOOL    QInsertAtHead   (PQUEUE pQueue, LPVOID pObject);
LPVOID  QRemove         (PQUEUE pQueue);
BOOL    IsQEmpty        (PQUEUE pQueue);

#if defined(__cplusplus)
}
#endif  // (__cplusplus)

#endif  /* QUEUE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\rasplog.h ===
/***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************/

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1994:  Intel Corporation
// Confidential -- All proprietary rights reserved.
//
// AUTHOR	Steve Nesland, Sam Sakthivel
//
// DESCRIPTION
//		This file contains protocol logging definitions needed by MBFT and
//		the MBFT PDU logging class.
//
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

// This define identifies the MBFT protocol as the one to be logged.  In the 
// MBFT code, it is used only in the CPLInitialize() call.  
// For example:  MBFTProtocolLogger = CPLInitialize( MBFT_PROTOCOL );
//
#define RASLOG_PROTOCOL "RAS_PDU"

// PDU encoding type flags and PDU type flags.  These flags are passed from
// MBFT to the logging via user data.  Bit zero of the user data represents
// the ASN encoding type.  Bit 1 represents pdu type (Connect or Domain).
// Bit 2 represents whether the PDU was sent or received.
//

#define RASLOG_SENT_PDU                1UL
#define RASLOG_RECEIVED_PDU            0UL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\retry.cpp ===
/************************************************************************
*																		*
*	INTEL CORPORATION PROPRIETARY INFORMATION							*
*																		*
*	This software is supplied under the terms of a license			   	*
*	agreement or non-disclosure agreement with Intel Corporation		*
*	and may not be copied or disclosed except in accordance	   			*
*	with the terms of that agreement.									*
*																		*
*	Copyright (C) 1997 Intel Corp.	All Rights Reserved					*
*																		*
*	$Archive:   S:\sturgeon\src\gki\vcs\retry.cpv  $
*																		*
*	$Revision:   1.11  $
*	$Date:   12 Feb 1997 01:10:26  $
*																		*
*	$Author:   CHULME  $
*																		*
*   $Log:   S:\sturgeon\src\gki\vcs\retry.cpv  $
// 
//    Rev 1.11   12 Feb 1997 01:10:26   CHULME
// Redid thread synchronization to use Gatekeeper.Lock
// 
//    Rev 1.10   08 Feb 1997 13:05:10   CHULME
// Added debug message for thread termination
// 
//    Rev 1.9   08 Feb 1997 12:18:08   CHULME
// Added Check for semaphore signalling to exit the retry thread
// 
//    Rev 1.8   24 Jan 1997 18:29:44   CHULME
// Reverted to rev 1.6
// 
//    Rev 1.6   22 Jan 1997 20:45:38   EHOWARDX
// Work-around for race condition that may result in
// GKI_RegistrationRequest returning GKI_ALREADY_REG.
// 
//    Rev 1.5   17 Jan 1997 09:02:34   CHULME
// Changed reg.h to gkreg.h to avoid name conflict with inc directory
// 
//    Rev 1.4   10 Jan 1997 16:16:04   CHULME
// Removed MFC dependency
// 
//    Rev 1.3   20 Dec 1996 01:28:00   CHULME
// Fixed memory leak on GK_REG_BYPASS
// 
//    Rev 1.2   22 Nov 1996 15:21:12   CHULME
// Added VCS log to the header
*************************************************************************/

// retry.cpp : Provides a background retry thread
//
#include "precomp.h"

#include "gkicom.h"
#include "dspider.h"
#include "dgkilit.h"
#include "DGKIPROT.H"
#include "gksocket.h"
#include "GKREG.H"
#include "GATEKPR.H"
#include "h225asn.h"
#include "coder.hpp"
#include "dgkiext.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#if (0)
void 
Retry(void *pv)
{
	// ABSTRACT:  This function is invoked in a separate thread to
	//            periodically check for outstanding PDUs.  If a configurable 
	//            timeout period has expired, the PDU will be reissued.  If
	//            the maximum number of retries has been exhausted, this thread
	//            will clean-up the appropriate memory.
	// AUTHOR:    Colin Hulme

	DWORD			dwTime, dwErrorCode;
#ifdef _DEBUG
	char			szGKDebug[80];
#endif
	HRESULT			hResult = GKI_OK;
	HANDLE			hRetrySemaphore;
	
	SPIDER_TRACE(SP_FUNC, "Retry(pv)\n", 0);
	ASSERT(g_pGatekeeper);
	if(g_pGatekeeper == NULL)
		return; 
		
	dwTime = g_pGatekeeper->GetRetryMS();

	g_pGatekeeper->Lock();
	while (hResult == GKI_OK)
	{
		hRetrySemaphore = g_pReg->m_hRetrySemaphore;
		g_pGatekeeper->Unlock();
		dwErrorCode = WaitForSingleObject(hRetrySemaphore, dwTime);
		if(dwErrorCode != WAIT_TIMEOUT)
		{
			SPIDER_TRACE(SP_THREAD, "Retry thread exiting\n", 0);
			return;		// Exit thread
		}

		g_pGatekeeper->Lock();
		if (g_pReg == 0)
		{
			SPIDER_TRACE(SP_THREAD, "Retry thread exiting\n", 0);
			g_pGatekeeper->Unlock();
			return;		// Exit thread
		}

		hResult = g_pReg->Retry();
	}

	SPIDER_TRACE(SP_NEWDEL, "del g_pReg = %X\n", g_pReg);
	delete g_pReg;
	g_pReg = 0;

	SPIDER_TRACE(SP_THREAD, "Retry thread exiting\n", 0);
	g_pGatekeeper->Unlock();
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\rtdse.c ===
/***********************************************************************
 *                                                                     *
 * Filename: rtdse.c                                                   *
 * Module:   H245 Finite State Machine Subsystem                       *
 *                                                                     *
 ***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *                                                                     *
 * $Workfile:   rtdse.c  $
 * $Revision:   1.4  $
 * $Modtime:   Feb 28 1997 13:13:32  $
 * $Log:   S:/STURGEON/SRC/H245/SRC/VCS/rtdse.c_v  $
 *
 *    Rev 1.4   Feb 28 1997 13:14:24   tomitowx
 * fixed Roundtripdelay timer problem.
 * that occurs when ping peer link is invalid/unvailable
 * due to an abnormal application/machine shutdown.
 *
 *    Rev 1.3   09 Dec 1996 13:37:04   EHOWARDX
 * Updated copyright notice.
 *
 *    Rev 1.2   04 Jun 1996 13:57:26   EHOWARDX
 * Fixed Release build warnings.
 *
 *    Rev 1.1   30 May 1996 23:39:28   EHOWARDX
 * Cleanup.
 *
 *    Rev 1.0   09 May 1996 21:06:42   EHOWARDX
 * Initial revision.
 *
 *    Rev 1.1   09 May 1996 19:48:24   EHOWARDX
 * Change TimerExpiryF function arguements.
 *
 *    Rev 1.0   15 Apr 1996 10:46:40   EHOWARDX
 * Initial revision.
 *                                                                     *
 ***********************************************************************/

#include "precomp.h"

#include "h245api.h"
#include "h245com.h"
#include "h245fsm.h"
#include "rtdse.h"



// Out-going/In-coming RTDSE states
#define RTDSE_IDLE                  0   // IDLE
#define RTDSE_WAIT                  1   // AWAITING_RESPONSE



extern unsigned int uT105;

/***********************************************************************
 *
 * LOCAL FUNCTIONS
 *
 ***********************************************************************/

/*
 *  NAME
 *      T105ExpiryF - Callback function called by the timer
 *
 *
 *  PARAMETERS
 *   INPUT   dwInst     current instance of H.245
 *   INPUT   id         timer id
 *   INPUT   pObject    pointer to a State Entity
 *
 *
 *  RETURN VALUE
 *       OK
 */

int T105ExpiryF(struct InstanceStruct *pInstance, DWORD_PTR dwTimerId, void *pObject)
{
    return FsmTimerEvent(pInstance, dwTimerId, pObject, T105Expiry);
} // T105ExpiryF()



static void BuildRoundTripDelayResponse(PDU_t *pOut, BYTE bySequenceNumber)
{
    pOut->choice = MSCMg_rspns_chosen;
    pOut->u.MSCMg_rspns.choice = roundTripDelayResponse_chosen;
    pOut->u.MSCMg_rspns.u.roundTripDelayResponse.sequenceNumber = bySequenceNumber;
} // BuildRoundTripDelayResponse()



/***********************************************************************
 *
 * FINITE STATE MACHINE FUNCTIONS
 *
 ***********************************************************************/

/*
 *  NAME
 *      RTDSE0_TRANSFER_requestF - TRANSFER.request from API in IDLE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT RTDSE0_TRANSFER_requestF        (Object_t *pObject, PDU_t *pPdu)
{
    HRESULT             lError;

    ASSERT(pObject->Entity == RTDSE);
    ASSERT(pObject->State  == RTDSE_IDLE);
    H245TRACE(pObject->dwInst, 2, "RTDSE0_TRANSFER_request:%d", pObject->Key);

    pObject->pInstance->StateMachine.byRtdseSequence++;
    pPdu->u.MltmdSystmCntrlMssg_rqst.u.roundTripDelayRequest.sequenceNumber =
        pObject->pInstance->StateMachine.byRtdseSequence;

    // Send RoundTripDelayRequest PDU to remote peer
    lError = sendPDU(pObject->pInstance, pPdu);

	
//tomitowoju@intel.com
	if(lError == H245_ERROR_OK)
	{
		// Set timer T105
		pObject->State = RTDSE_WAIT;
		FsmStartTimer(pObject, T105ExpiryF, uT105);

	}
//tomitowoju@intel.com
		// Set timer T105
//		pObject->State = RTDSE_WAIT;
//		FsmStartTimer(pObject, T105ExpiryF, uT105);
//tomitowoju@intel.com

    return lError;
} // RTDSE0_TRANSFER_request



/*
 *  NAME
 *      RTDSE0_RoundTripDelayRequestF - RoundTripDelayRequest received in IDLE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT RTDSE0_RoundTripDelayRequestF   (Object_t *pObject, PDU_t *pPdu)
{
    PDU_t *             pOut;
    HRESULT             lError;

    ASSERT(pObject->Entity == RTDSE);
    ASSERT(pObject->State  == RTDSE_IDLE);
    H245TRACE(pObject->dwInst, 2, "RTDSE0_RoundTripDelayRequest:%d", pObject->Key);

    // Send RoundTripDelayResponse to remote peer
    pOut = MemAlloc(sizeof(*pOut));
    if (pOut == NULL)
    {
        H245TRACE(pObject->dwInst, 2,
                  "RTDSE0_RoundTripDelayRequestF: memory allocation failed");
        return H245_ERROR_NOMEM;
    }
    BuildRoundTripDelayResponse(pOut, (BYTE)pPdu->u.MltmdSystmCntrlMssg_rqst.u.roundTripDelayRequest.sequenceNumber);
    lError = sendPDU(pObject->pInstance, pOut);
    MemFree(pOut);

    return lError;
} // RTDSE0_RoundTripDelayRequest



/*
 *  NAME
 *      RTDSE1_TRANSFER_requestF - TRANSFER.request from API in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT RTDSE1_TRANSFER_requestF        (Object_t *pObject, PDU_t *pPdu)
{
    HRESULT             lError;

    ASSERT(pObject->Entity == RTDSE);
    ASSERT(pObject->State  == RTDSE_WAIT);
    H245TRACE(pObject->dwInst, 2, "RTDSE1_TRANSFER_request:%d", pObject->Key);

    // Reset timer T105
    FsmStopTimer(pObject);

    pObject->pInstance->StateMachine.byRtdseSequence++;
    pPdu->u.MltmdSystmCntrlMssg_rqst.u.roundTripDelayRequest.sequenceNumber =
        pObject->pInstance->StateMachine.byRtdseSequence;

    // Send RoundTripDelayRequest PDU to remote
    lError = sendPDU(pObject->pInstance, pPdu);

    // Set timer T105
    FsmStartTimer(pObject, T105ExpiryF, uT105);

    return lError;
} // RTDSE1_TRANSFER_request



/*
 *  NAME
 *      RTDSE1_RoundTripDelayRequestF - RoundTripDelayRequest received in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT RTDSE1_RoundTripDelayRequestF   (Object_t *pObject, PDU_t *pPdu)
{
    PDU_t *             pOut;
    HRESULT             lError;

    ASSERT(pObject->Entity == RTDSE);
    ASSERT(pObject->State  == RTDSE_WAIT);
    H245TRACE(pObject->dwInst, 2, "RTDSE1_RoundTripDelayRequest:%d", pObject->Key);

    // Send RoundTripDelayResponse to remote peer
    pOut = MemAlloc(sizeof(*pOut));
    if (pOut == NULL)
    {
        H245TRACE(pObject->dwInst, 2,
                  "RTDSE1_RoundTripDelayRequestF: memory allocation failed");
        return H245_ERROR_NOMEM;
    }
    BuildRoundTripDelayResponse(pOut, (BYTE)pPdu->u.MltmdSystmCntrlMssg_rqst.u.roundTripDelayRequest.sequenceNumber);
    lError = sendPDU(pObject->pInstance, pOut);
    MemFree(pOut);

    return lError;
} // RTDSE1_RoundTripDelayRequest



/*
 *  NAME
 *      RTDSE1_RoundTripDelayResponseF - RoundTripDelayResponse in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT RTDSE1_RoundTripDelayResponseF  (Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == RTDSE);
    ASSERT(pObject->State  == RTDSE_WAIT);
    H245TRACE(pObject->dwInst, 2, "RTDSE1_RoundTripDelayResponse:%d", pObject->Key);

    if (pPdu->u.MSCMg_rspns.u.roundTripDelayResponse.sequenceNumber ==
        pObject->pInstance->StateMachine.byRtdseSequence)
    {
        // Reset timer T105
        FsmStopTimer(pObject);

        // Send TRANSFER.confirm to H.245 user
        pObject->State = RTDSE_IDLE;
        H245FsmConfirm(pPdu, H245_CONF_RTDSE, pObject->pInstance, pObject->dwTransId, FSM_OK);
    }

    return 0;
} // RTDSE1_RoundTripDelayResponse



/*
 *  NAME
 *      RTDSE1_T105ExpiryF - timer T105 Expiry in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT RTDSE1_T105ExpiryF              (Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == RTDSE);
    ASSERT(pObject->State  == RTDSE_WAIT);
    ASSERT(pPdu == NULL);
    H245TRACE(pObject->dwInst, 2, "RTDSE1_T105Expiry:%d", pObject->Key);

    // Send EXPIRY.notification to client
    pObject->State = RTDSE_IDLE;
    H245FsmConfirm(NULL, H245_CONF_RTDSE_EXPIRED, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return 0;
} // RTDSE1_T105Expiry

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\rmese.c ===
/***********************************************************************
 *                                                                     *
 * Filename: rmese.c                                                   *
 * Module:   H245 Finite State Machine Subsystem                       *
 *                                                                     *
 ***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *                                                                     *
 * $Workfile:   RMESE.C  $
 * $Revision:   1.3  $
 * $Modtime:   09 Dec 1996 13:36:34  $
 * $Log:   S:/STURGEON/SRC/H245/SRC/VCS/RMESE.C_v  $
 *
 *    Rev 1.3   09 Dec 1996 13:37:00   EHOWARDX
 * Updated copyright notice.
 *
 *    Rev 1.2   04 Jun 1996 13:57:38   EHOWARDX
 * Fixed Release build warnings.
 *
 *    Rev 1.1   30 May 1996 23:39:26   EHOWARDX
 * Cleanup.
 *
 *    Rev 1.0   09 May 1996 21:06:40   EHOWARDX
 * Initial revision.
 *
 *    Rev 1.1   09 May 1996 19:48:50   EHOWARDX
 * Change TimerExpiryF function arguements.
 *
 *    Rev 1.0   15 Apr 1996 10:45:20   EHOWARDX
 * Initial revision.
 *                                                                     *
 ***********************************************************************/

#include "precomp.h"

#include "h245api.h"
#include "h245com.h"
#include "h245fsm.h"
#include "rmese.h"



// Out-going/In-coming RMESE states
#define RMESE_IDLE                  0   // IDLE
#define RMESE_WAIT                  1   // AWAITING_RESPONSE



extern unsigned int uT107;

/***********************************************************************
 *
 * LOCAL FUNCTIONS
 *
 ***********************************************************************/

/*
 *  NAME
 *      T107ExpiryF - Callback function called by the timer
 *
 *
 *  PARAMETERS
 *   INPUT   dwInst     current instance of H245
 *   INPUT   id         timer id
 *   INPUT   pObject    pointer to a State Entity
 *
 *
 *  RETURN VALUE
 *       OK
 */

int T107ExpiryF(struct InstanceStruct *pInstance, DWORD_PTR dwTimerId, void *pObject)
{
    return FsmTimerEvent(pInstance, dwTimerId, pObject, T107Expiry);
} // T107ExpiryF()



/***********************************************************************
 *
 * OUT-GOING FINITE STATE MACHINE FUNCTIONS
 *
 ***********************************************************************/

/*
 *  NAME
 *      RMESE0_SEND_requestF - SEND.request from API in IDLE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT RMESE0_SEND_requestF            (Object_t *pObject, PDU_t *pPdu)
{
    HRESULT             lError;

    ASSERT(pObject->Entity == RMESE_OUT);
    ASSERT(pObject->State  == RMESE_IDLE);
    H245TRACE(pObject->dwInst, 2, "RMESE0_SEND_request:%d", pObject->Key);

    // Save information for release
    pObject->u.rmese = pPdu->u.indication.u.rqstMltplxEntryRls;

    // Send RequestMultiplexEntry PDU to remote peer
    lError = sendPDU(pObject->pInstance, pPdu);

    // Set timer T107
    pObject->State = RMESE_WAIT;
    FsmStartTimer(pObject, T107ExpiryF, uT107);

    return lError;
} // RMESE0_SEND_request



/*
 *  NAME
 *      RMESE1_SEND_requestF - SEND.request from API in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT RMESE1_SEND_requestF            (Object_t *pObject, PDU_t *pPdu)
{
    HRESULT             lError;

    ASSERT(pObject->Entity == RMESE_OUT);
    ASSERT(pObject->State  == RMESE_WAIT);
    H245TRACE(pObject->dwInst, 2, "RMESE1_SEND_request:%d", pObject->Key);

    // Reset timer T107
    FsmStopTimer(pObject);

    // Save information for release
    pObject->u.rmese = pPdu->u.indication.u.rqstMltplxEntryRls;

    // Send RequestMultiplexEntry PDU to remote peer
    lError = sendPDU(pObject->pInstance, pPdu);

    // Set timer T107
    FsmStartTimer(pObject, T107ExpiryF, uT107);

    return lError;
} // RMESE1_SEND_request



/*
 *  NAME
 *      RMESE1_RequestMuxEntryAckF - RequestMultiplexEntryAck in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT RMESE1_RequestMuxEntryAckF      (Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == RMESE_OUT);
    ASSERT(pObject->State  == RMESE_WAIT);
    H245TRACE(pObject->dwInst, 2, "RMESE1_RequestMuxEntryAck:%d", pObject->Key);

    // Reset timer T107
    FsmStopTimer(pObject);

    // Send SEND.confirm to H.245 user
    pObject->State = RMESE_IDLE;
    H245FsmConfirm(pPdu, H245_CONF_RMESE, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return 0;
} // RMESE1_RequestMuxEntryAck



/*
 *  NAME
 *      RMESE1_RequestMuxEntryRejF - RequestMultiplexEntryReject in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT RMESE1_RequestMuxEntryRejF      (Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == RMESE_OUT);
    ASSERT(pObject->State  == RMESE_WAIT);
    H245TRACE(pObject->dwInst, 2, "RMESE0_RequestMuxEntryRej:%d", pObject->Key);

    // Reset timer T107
    FsmStopTimer(pObject);

    // Send REJECT.indication to H.245 user
    pObject->State = RMESE_IDLE;
    H245FsmConfirm(pPdu, H245_CONF_RMESE_REJECT, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return 0;
} // RMESE1_RequestMuxEntryRej



/*
 *  NAME
 *      RMESE1_T107ExpiryF - timer T107 Expiry
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT RMESE1_T107ExpiryF              (Object_t *pObject, PDU_t *pPdu)
{
    HRESULT             lError;
    PDU_t *             pOut;
    unsigned short      wNumber = (unsigned short) pObject->Key;

    ASSERT(pObject->Entity == RMESE_OUT);
    ASSERT(pObject->State  == RMESE_WAIT);
    ASSERT(pPdu == NULL);
    H245TRACE(pObject->dwInst, 2, "RMESE1_T107Expiry:%d", pObject->Key);

    // Send RequestMultiplexEntryRelease PDU to remote peer
    pOut = MemAlloc(sizeof(*pOut));
    if (pOut == NULL)
    {
        H245TRACE(pObject->dwInst, 2,
                  "RMESE1_T107ExpiryF: memory allocation failed");
        return H245_ERROR_NOMEM;
    }
    pOut->choice = indication_chosen;
    pOut->u.indication.choice = rqstMltplxEntryRls_chosen;
    pOut->u.indication.u.rqstMltplxEntryRls = pObject->u.rmese;
    lError = sendPDU(pObject->pInstance, pOut);
    MemFree(pOut);

    // Send REJECT.indication to H.245 user
    //   SOURCE := PROTOCOL
    pObject->State = RMESE_IDLE;
    H245FsmConfirm(NULL, H245_CONF_RMESE_EXPIRED, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return lError;
} // RMESE1_T107Expiry

/***********************************************************************
 *
 * IN-COMING FINITE STATE MACHINE FUNCTIONS
 *
 ***********************************************************************/

/*
 *  NAME
 *      RMESE0_RequestMuxEntryF - RequestMultiplexEntry received in IDLE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT RMESE0_RequestMuxEntryF         (Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == RMESE_IN);
    ASSERT(pObject->State  == RMESE_IDLE);
    H245TRACE(pObject->dwInst, 2, "RMESE0_RequestMuxEntry:%d", pObject->Key);

    // Send SEND.indication to H.245 user
    pObject->State = RMESE_WAIT;
    H245FsmIndication(pPdu, H245_IND_RMESE, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return 0;
} // RMESE0_RequestMuxEntry



/*
 *  NAME
 *      RMESE1_RequestMuxEntryF - RequestMultiplexEntry received in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT RMESE1_RequestMuxEntryF         (Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == RMESE_IN);
    ASSERT(pObject->State  == RMESE_WAIT);
    H245TRACE(pObject->dwInst, 2, "RMESE1_RequestMuxEntry:%d", pObject->Key);

#if defined(SDL_COMPLIANT)
    // Send REJECT.indication to H.245 user
    H245FsmIndication(pPdu, H245_IND_RMESE_RELEASE, pObject->pInstance, pObject->dwTransId, FSM_OK);
#endif

    // Send SEND.indication to H.245 user
    H245FsmIndication(pPdu, H245_IND_RMESE, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return 0;
} // RMESE1_RequestMuxEntry



/*
 *  NAME
 *      RMESE1_RequestMuxEntryReleaseF - RequestMultiplexEntryRelease received in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT RMESE1_RequestMuxEntryReleaseF  (Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == RMESE_IN);
    ASSERT(pObject->State  == RMESE_WAIT);
    H245TRACE(pObject->dwInst, 2, "RMESE1_RequestMuxEntryRelease:%d", pObject->Key);

    // Send REJECT.indication to H.245 user
    //   SOURCE := PROTOCOL
    pObject->State = RMESE_IDLE;
    H245FsmIndication(pPdu, H245_IND_RMESE_RELEASE, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return 0;
} // RMESE1_RequestMuxEntryRelease



/*
 *  NAME
 *      RMESE1_SEND_responseF - SEND.response from API in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT RMESE1_SEND_responseF           (Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == RMESE_IN);
    ASSERT(pObject->State  == RMESE_WAIT);
    H245TRACE(pObject->dwInst, 2, "RMESE1_SEND_response:%d", pObject->Key);

    // Send RequestMultiplexEntryAck PDU to remote peer
    pObject->State = RMESE_IDLE;
    return sendPDU(pObject->pInstance, pPdu);
} // RMESE1_SEND_response



/*
 *  NAME
 *      RMESE1_REJECT_requestF - REJECT.request from API in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT RMESE1_REJECT_requestF          (Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == RMESE_IN);
    ASSERT(pObject->State  == RMESE_WAIT);
    H245TRACE(pObject->dwInst, 2, "RMESE1_REJECT_request:%d", pObject->Key);

    // Send RequestMultiplexEntryReject PDU to remote
    pObject->State = RMESE_IDLE;
    return sendPDU(pObject->pInstance, pPdu);
} // RMESE1_REJECT_request

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\rtdse.h ===
/***********************************************************************
 *                                                                     *
 * Filename: rtdse.h                                                   *
 * Module:   H245 Finite State Machine Subsystem                       *
 *                                                                     *
 ***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *                                                                     *
 * $Workfile:   RTDSE.H  $
 * $Revision:   1.2  $
 * $Modtime:   09 Dec 1996 13:42:50  $
 * $Log:   S:/STURGEON/SRC/H245/INCLUDE/VCS/RTDSE.H_v  $
 * 
 *    Rev 1.2   09 Dec 1996 13:43:06   EHOWARDX
 * Updated copyright notice.
 * 
 *    Rev 1.1   30 May 1996 23:38:32   EHOWARDX
 * Cleanup.
 * 
 *    Rev 1.0   09 May 1996 21:04:58   EHOWARDX
 * Initial revision.
 * 
 *    Rev 1.1   15 Apr 1996 10:43:46   EHOWARDX
 * Update.
 * 
 *    Rev 1.0   10 Apr 1996 21:09:14   EHOWARDX
 * Initial revision.
 *                                                                     *
 ***********************************************************************/

// Round Trip Delay (RTDSE) state functions
HRESULT RTDSE0_TRANSFER_requestF        (Object_t *pObject, PDU_t *pPdu);
HRESULT RTDSE0_RoundTripDelayRequestF   (Object_t *pObject, PDU_t *pPdu);
HRESULT RTDSE1_TRANSFER_requestF        (Object_t *pObject, PDU_t *pPdu);
HRESULT RTDSE1_RoundTripDelayRequestF   (Object_t *pObject, PDU_t *pPdu);
HRESULT RTDSE1_RoundTripDelayResponseF  (Object_t *pObject, PDU_t *pPdu);
HRESULT RTDSE1_T105ExpiryF              (Object_t *pObject, PDU_t *pPdu);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\rqstcls.h ===
/***********************************************************************
 *                                                                     *
 * Filename: rqstcls.h                                                 *
 * Module:   H245 Finite State Machine Subsystem                       *
 *                                                                     *
 ***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *                                                                     *
 * $Workfile:   RQSTCLS.H  $
 * $Revision:   1.2  $
 * $Modtime:   09 Dec 1996 13:42:50  $
 * $Log:   S:/STURGEON/SRC/H245/INCLUDE/VCS/RQSTCLS.H_v  $
 * 
 *    Rev 1.2   09 Dec 1996 13:43:06   EHOWARDX
 * Updated copyright notice.
 * 
 *    Rev 1.1   30 May 1996 23:38:32   EHOWARDX
 * Cleanup.
 * 
 *    Rev 1.0   09 May 1996 21:04:58   EHOWARDX
 * Initial revision.
 * 
 *    Rev 1.3.1.2   15 Apr 1996 10:43:52   EHOWARDX
 * Update.
 * 
 *    Rev 1.3.1.1   10 Apr 1996 21:07:22   EHOWARDX
 * Deleted No-op functions; moved state defines to .C file.
 * 
 *    Rev 1.3.1.0   05 Apr 1996 11:48:24   EHOWARDX
 * Branched.
 *                                                                     *
 ***********************************************************************/

// Out-going Request Close Logical Channel state functions
HRESULT closeRequestIdle                (Object_t *pObject, PDU_t *pPdu);
HRESULT requestCloseAckAwaitingR        (Object_t *pObject, PDU_t *pPdu);
HRESULT requestCloseRejAwaitingR        (Object_t *pObject, PDU_t *pPdu);
HRESULT t108ExpiryAwaitingR             (Object_t *pObject, PDU_t *pPdu);

// In-coming Request Close Logical Channel state functions
HRESULT requestCloseIdle                (Object_t *pObject, PDU_t *pPdu);
HRESULT closeResponseAwaitingR          (Object_t *pObject, PDU_t *pPdu);
HRESULT rejectRequestAwaitingR          (Object_t *pObject, PDU_t *pPdu);
HRESULT requestCloseReleaseAwaitingR    (Object_t *pObject, PDU_t *pPdu);
HRESULT requestCloseAwaitingR           (Object_t *pObject, PDU_t *pPdu);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\rqstcls.c ===
/***********************************************************************
 *                                                                     *
 * Filename: rqstcls.c                                                 *
 * Module:   H245 Finite State Machine Subsystem                       *
 *                                                                     *
 ***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *                                                                     *
 * $Workfile:   RQSTCLS.C  $
 * $Revision:   1.5  $
 * $Modtime:   09 Dec 1996 13:36:34  $
 * $Log:   S:/STURGEON/SRC/H245/SRC/VCS/RQSTCLS.C_v  $
 *
 *    Rev 1.5   09 Dec 1996 13:37:02   EHOWARDX
 * Updated copyright notice.
 *
 *    Rev 1.4   19 Jul 1996 12:15:40   EHOWARDX
 *
 * Changed to use event definitions from H245API.H.
 *
 *    Rev 1.3   04 Jun 1996 13:57:30   EHOWARDX
 * Fixed Release build warnings.
 *
 *    Rev 1.2   30 May 1996 23:39:26   EHOWARDX
 * Cleanup.
 *
 *    Rev 1.1   29 May 1996 15:20:26   EHOWARDX
 * Change to use HRESULT.
 *
 *    Rev 1.0   09 May 1996 21:06:42   EHOWARDX
 * Initial revision.
 *
 *    Rev 1.6.1.2   09 May 1996 19:48:46   EHOWARDX
 * Change TimerExpiryF function arguements.
 *
 *    Rev 1.6.1.1   15 Apr 1996 10:46:22   EHOWARDX
 * Update.
 *
 *    Rev 1.6.1.0   10 Apr 1996 21:12:42   EHOWARDX
 * Branched.
 *                                                                     *
 ***********************************************************************/

#include "precomp.h"

#include "h245api.h"
#include "h245com.h"
#include "h245fsm.h"
#include "rqstcls.h"



// request close channels from receive side outgoing states
#define ReqCloseOutIDLE             0
#define ReqCloseOutAwaitingResponse 1

// request close channels on open side incoming states
#define ReqCloseInIDLE              0
#define ReqCloseInAwaitingResponse  1



extern unsigned int uT108;

/***********************************************************************
 *
 * LOCAL FUNCTIONS
 *
 ***********************************************************************/

/*
 *  NAME
 *      T108ExpiryF - Callback function called by the timer
 *
 *
 *  PARAMETERS
 *   INPUT   dwInst     current instance of H245
 *   INPUT   id         timer id
 *   INPUT   pObject    pointer to a State Entity
 *
 *
 *  RETURN VALUE
 *       OK
 */

int T108ExpiryF(struct InstanceStruct *pInstance, DWORD_PTR dwTimerId, void *pObject)
{
    return FsmTimerEvent(pInstance, dwTimerId, pObject, T108Expiry);
} // T108ExpiryF()



/***********************************************************************
 *
 * OUT-GOING FINITE STATE MACHINE FUNCTIONS
 *
 ***********************************************************************/

/*
 *  NAME
 *      closeRequestIdle - request to close a remote channel by API in idle state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject    pointer to a State Entity
 *
 *  RETURN VALUE
 *      error return codes defined in h245com.h
 */

HRESULT closeRequestIdle (Object_t *pObject, PDU_t *pPdu)
{
    HRESULT             lError;

    ASSERT(pObject->Entity == CLCSE_OUT);
    ASSERT(pObject->State == ReqCloseOutIDLE);
    H245TRACE(pObject->dwInst, 2,
              "Send RequestChannelClose to ASN; Channel=%d",
              pObject->Key);

    /* Send Request Channel Close to remote peer */
    lError = sendPDU(pObject->pInstance, pPdu);

    /* set timer T108 */
    pObject->State = ReqCloseOutAwaitingResponse;
    FsmStartTimer(pObject, T108ExpiryF, uT108);

    return lError;
}



/*
 *  NAME
 *      requestCloseAckAwaitingR - received request close Ack in awaiting release state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject    pointer to a State Entity
 *
 *  RETURN VALUE
 *      error return codes defined in h245com.h
 */

HRESULT requestCloseAckAwaitingR(Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == CLCSE_OUT);
    ASSERT(pObject->State == ReqCloseOutAwaitingResponse);
    H245TRACE(pObject->dwInst, 2,
              "H245_CONF_REQ_CLOSE to API; Channel=%d",
              pObject->Key);

    /* reset timer T108 */
    FsmStopTimer(pObject);

    /* Send CLOSE.confirm to client */
    pObject->State = ReqCloseOutIDLE;
    H245FsmConfirm(pPdu, H245_CONF_REQ_CLOSE, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return 0;
}



/*
 *  NAME
 *      requestCloseRejAwaitingR - received request close reject in Awaiting Release state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject    pointer to a State Entity
 *
 *  RETURN VALUE
 *      error return codes defined in h245com.h
 */

HRESULT requestCloseRejAwaitingR(Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == CLCSE_OUT);
    ASSERT(pObject->State == ReqCloseOutAwaitingResponse);
    H245TRACE(pObject->dwInst, 2,
              "H245_CONF_REQ_CLOSE to API with REJECT; Channel=%d",
              pObject->Key);

    /* reset timer T108 */
    FsmStopTimer(pObject);

    /* Send REJECT.indication to client */
    pObject->State = ReqCloseOutIDLE;
    H245FsmConfirm(pPdu,H245_CONF_REQ_CLOSE, pObject->pInstance, pObject->dwTransId,REJECT);

    return 0;
}



/*
 *  NAME
 *      t108ExpiryAwaitingR - handle timer expiry of an outstanding request close
 *
 *
 *  PARAMETERS
 *   INPUT   pObject    pointer to a State Entity
 *
 *  RETURN VALUE
 *      error return codes defined in h245com.h
 */

HRESULT t108ExpiryAwaitingR (Object_t *pObject, PDU_t *pPdu)
{
    PDU_t *             pOut;
    HRESULT             lError;

    ASSERT(pObject->Entity == CLCSE_OUT);
    ASSERT(pObject->State == ReqCloseOutAwaitingResponse);
    ASSERT(pPdu == NULL);
    H245TRACE(pObject->dwInst, 2,
              "H245_CONF_REQ_CLOSE with Timer T108 Expiry to API; Channel=%d",
              pObject->Key);

    /* Send Request Channel Close Release to remote peer */
    pOut = (PDU_t *) MemAlloc(sizeof(*pOut));
    if (pOut == NULL)
    {
        H245TRACE(pObject->dwInst, 2,
                  "t108ExpiryAwaitingR: memory allocation failed");
        return H245_ERROR_NOMEM;
    }
    pOut->choice = indication_chosen;
    pOut->u.indication.choice = rqstChnnlClsRls_chosen;
    pOut->u.indication.u.rqstChnnlClsRls.forwardLogicalChannelNumber = (WORD)pObject->Key;
    lError = sendPDU(pObject->pInstance, pOut);
    MemFree(pOut);

    /* Send REJECT.indication (SOURCE:=PROTOCOL to client */
    pObject->State = ReqCloseOutIDLE;
    H245FsmConfirm(NULL, H245_CONF_REQ_CLOSE, pObject->pInstance, pObject->dwTransId, TIMER_EXPIRY);

    return lError;
}

/***********************************************************************
 *
 * IN-COMING FINITE STATE MACHINE FUNCTIONS
 *
 ***********************************************************************/

/*
 *  NAME
 *      requestCloseIdle - received requestClose in idle state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject    pointer to a State Entity
 *
 *  RETURN VALUE
 *      error return codes defined in h245com.h
 */

HRESULT requestCloseIdle (Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == CLCSE_IN);
    ASSERT(pObject->State == ReqCloseInIDLE);
    H245TRACE(pObject->dwInst, 2,
              "H245_IND_REQ_CLOSE with no error to API; Channel=%d",
              pObject->Key);

    /* Send CLOSE.indication to client */
    pObject->State = ReqCloseInAwaitingResponse;
    H245FsmIndication(pPdu, H245_IND_REQ_CLOSE, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return 0;
}



/*
 *  NAME
 *      closeResponseAwaitingR - respond to a requestclose with an Ack (or Reject)
 *
 *
 *  PARAMETERS
 *   INPUT   pObject    pointer to a State Entity
 *
 *  RETURN VALUE
 *      error return codes defined in h245com.h
 */

HRESULT closeResponseAwaitingR(Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == CLCSE_IN);
    ASSERT(pObject->State == ReqCloseInAwaitingResponse);
    H245TRACE(pObject->dwInst, 2,
              "Request Close Response Ack to ASN; Channel=%d",
              pObject->Key);

    /* Send Request Channel Close Ack to remote peer */
    pObject->State = ReqCloseInIDLE;
    return sendPDU(pObject->pInstance, pPdu);
}



HRESULT rejectRequestAwaitingR(Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == CLCSE_IN);
    ASSERT(pObject->State == ReqCloseInAwaitingResponse);
    H245TRACE(pObject->dwInst, 2, "Request Close Response Reject to ASN; Channel=%d",
              pObject->Key);

    /* Send Request Channel Close Reject to remote peer */
    pObject->State = ReqCloseInIDLE;
    return sendPDU(pObject->pInstance, pPdu);
}



/*
 *  NAME
 *      requestCloseReleaseAwaitingR - received a release while awaiting the api to respond
 *
 *
 *  PARAMETERS
 *   INPUT   pObject    pointer to a State Entity
 *
 *  RETURN VALUE
 *      error return codes defined in h245com.h
 */

HRESULT requestCloseReleaseAwaitingR(Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == CLCSE_IN);
    ASSERT(pObject->State == ReqCloseInAwaitingResponse);
    H245TRACE(pObject->dwInst, 2,
              "H245_IND_REQ_CLOSE with Reject to API; Channel=%d",
              pObject->Key);

    /* Send REJECT.indication to client */
    pObject->State = ReqCloseInIDLE;
    H245FsmIndication(pPdu, H245_IND_CLCSE_RELEASE, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return 0;
}



/*
 *  NAME
 *      requestCloseAwaitingR - overriding requestClose pdu in Awaiting Release state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject    pointer to a State Entity
 *
 *  RETURN VALUE
 *      error return codes defined in h245com.h
 */

HRESULT requestCloseAwaitingR (Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == CLCSE_IN);
    ASSERT(pObject->State == ReqCloseInAwaitingResponse);
    H245TRACE(pObject->dwInst, 2,
              "Overriding H245_IND_REQ_CLOSE with OK to API; Channel=%d",
              pObject->Key);

#if defined(SDL_COMPLIANT)
    /* Send REJECT.indication to client - not necessary */
    H245FsmIndication(pPdu, H245_IND_REQ_CLOSE, pObject->pInstance, pObject->dwTransId, REJECT);
#endif

    /* Send CLOSE.indication to client */
    H245FsmIndication(pPdu, H245_IND_REQ_CLOSE, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return 0;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\rmese.h ===
/***********************************************************************
 *                                                                     *
 * Filename: rmese.h                                                   *
 * Module:   H245 Finite State Machine Subsystem                       *
 *                                                                     *
 ***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *                                                                     *
 * $Workfile:   RMESE.H  $
 * $Revision:   1.2  $
 * $Modtime:   09 Dec 1996 13:42:50  $
 * $Log:   S:/STURGEON/SRC/H245/INCLUDE/VCS/RMESE.H_v  $
 * 
 *    Rev 1.2   09 Dec 1996 13:43:02   EHOWARDX
 * Updated copyright notice.
 * 
 *    Rev 1.1   30 May 1996 23:38:30   EHOWARDX
 * Cleanup.
 * 
 *    Rev 1.0   09 May 1996 21:04:56   EHOWARDX
 * Initial revision.
 * 
 *    Rev 1.1   15 Apr 1996 10:43:28   EHOWARDX
 * Update.
 * 
 *    Rev 1.0   10 Apr 1996 21:07:58   EHOWARDX
 * Initial revision.
 *                                                                     *
 ***********************************************************************/

// Out-going Request Mux Entry (RMESE_OUT) state functions
HRESULT RMESE0_SEND_requestF            (Object_t *pObject, PDU_t *pPdu);
HRESULT RMESE1_SEND_requestF            (Object_t *pObject, PDU_t *pPdu);
HRESULT RMESE1_RequestMuxEntryAckF      (Object_t *pObject, PDU_t *pPdu);
HRESULT RMESE1_RequestMuxEntryRejF      (Object_t *pObject, PDU_t *pPdu);
HRESULT RMESE1_T107ExpiryF              (Object_t *pObject, PDU_t *pPdu);

// In-coming Request Mux Entry (RMESE_OUT) state functions
HRESULT RMESE0_RequestMuxEntryF         (Object_t *pObject, PDU_t *pPdu);
HRESULT RMESE1_RequestMuxEntryF         (Object_t *pObject, PDU_t *pPdu);
HRESULT RMESE1_RequestMuxEntryReleaseF  (Object_t *pObject, PDU_t *pPdu);
HRESULT RMESE1_SEND_responseF           (Object_t *pObject, PDU_t *pPdu);
HRESULT RMESE1_REJECT_requestF          (Object_t *pObject, PDU_t *pPdu);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\userman.h ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/CALLCONT/VCS/userman.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1994 Intel Corporation.
 *
 *	$Revision:   1.10  $
 *	$Date:   Aug 12 1996 09:40:44  $
 *	$Author:   mandrews  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *		
 *
 *	Notes:
 *
 ***************************************************************************/

HRESULT InitUserManager();

HRESULT DeInitUserManager();

HRESULT InvokeUserListenCallback(	PLISTEN						pListen,
									HRESULT						status,
									PCC_LISTEN_CALLBACK_PARAMS	pListenCallbackParams);

HRESULT InvokeUserConferenceCallback(
									PCONFERENCE				pConference,
									BYTE					bIndication,
									HRESULT					status,
									void *					pConferenceCallbackParams);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\userman.c ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/CALLCONT/VCS/Userman.c_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1994 Intel Corporation.
 *
 *	$Revision:   1.22  $
 *	$Date:   22 Jan 1997 14:55:54  $
 *	$Author:   MANDREWS  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *		
 *
 *	Notes:
 *
 ***************************************************************************/

#include "precomp.h"

#include "apierror.h"
#include "incommon.h"
#include "callcont.h"
#include "q931.h"
#include "ccmain.h"



HRESULT InitUserManager()
{
	return CC_OK;
}



HRESULT DeInitUserManager()
{
	return CC_OK;
}



HRESULT InvokeUserListenCallback(	PLISTEN						pListen,
									HRESULT						status,
									PCC_LISTEN_CALLBACK_PARAMS	pListenCallbackParams)
{
	ASSERT(pListen != NULL);
	ASSERT(pListenCallbackParams != NULL);

	pListen->ListenCallback(status, pListenCallbackParams);

	return CC_OK;
}



HRESULT InvokeUserConferenceCallback(
									PCONFERENCE				pConference,
									BYTE					bIndication,
									HRESULT					status,
									void *					pConferenceCallbackParams)
{
HRESULT		ReturnStatus;

	ASSERT(pConference != NULL);
	// Note that ConferenceCallback and/or pConferenceCallbackParams may legitimately be NULL

	if ((pConference->ConferenceCallback != NULL) &&
		(pConference->LocalEndpointAttached != DETACHED)) {
		ReturnStatus = pConference->ConferenceCallback(bIndication,
													   status,
													   pConference->hConference,
													   pConference->dwConferenceToken,
													   pConferenceCallbackParams);
	} else {
		ReturnStatus = CC_OK;
	}
	return ReturnStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\sr_api.h ===
/******************************************************************************
 *
 *  File:  sr_api.h
 *
 *   INTEL Corporation Proprietary Information
 *   Copyright (c) 1994, 1995, 1996 Intel Corporation.
 *
 *   This listing is supplied under the terms of a license agreement
 *   with INTEL Corporation and may not be used, copied, nor disclosed
 *   except in accordance with the terms of that agreement.
 *
 *****************************************************************************/

/******************************************************************************
 *
 *  $Workfile:   sr_api.h  $
 *  $Revision:   1.5  $
 *  $Modtime:   Mar 04 1997 17:32:54  $
 *  $History$
 *  $Log:   S:/STURGEON/SRC/H245/INCLUDE/VCS/sr_api.h_v  $
 *
 *    Rev 1.5   Mar 04 1997 17:52:48   tomitowx
 * process detach fix
 *
 *    Rev 1.4   19 Jul 1996 12:04:34   EHOWARDX
 *
 * Eliminated H245DLL #define (God only knows why Dan put it in this
 * file in the first place!)
 *
 *    Rev 1.3   05 Jun 1996 17:20:20   EHOWARDX
 * Changed initializeASN1 and terminateASN1 prototypes back to int.
 *
 *    Rev 1.2   05 Jun 1996 16:37:18   EHOWARDX
 * Further work in converting to HRESULT.
 *
 *    Rev 1.1   30 May 1996 23:38:34   EHOWARDX
 * Cleanup.
 *
 *    Rev 1.0   09 May 1996 21:05:00   EHOWARDX
 * Initial revision.
 *
 *    Rev 1.8   09 May 1996 19:38:18   EHOWARDX
 * Redesigned locking logic and added new functionality.
 *
 *    Rev 1.7   15 Apr 1996 13:00:14   DABROWN1
 *
 * Added SR initialize trace logging call
 *
 *    Rev 1.6   12 Apr 1996 10:27:40   dabrown1
 *
 * removed WINAPI/windows references
 *  $Ident$
 *
 *****************************************************************************/
#ifndef STRICT
#define STRICT
#endif

#ifndef _SR_API_H
#define _SR_API_H

#include "h245com.h"
#include "h245asn1.h"

#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus

///////////////////////////////////////////////////////////////
///
/// TRACE Logging Defines
///
///////////////////////////////////////////////////////////////
#define H245_TRACE_ENABLED  TRUE


////////////////////////////////////////////////////////////////////
//
// Callback routines for Link Layer
//
////////////////////////////////////////////////////////////////////
void h245ReceiveComplete(DWORD_PTR h245Instance,
                         HRESULT  dwMessage,
                         PBYTE    pbDataBuf,
                         DWORD    dwLength);

void h245SendComplete   (DWORD_PTR h245Instance,
                         HRESULT  dwMessage,
                         PBYTE    pbDataBuf,
                         DWORD    dwLength);
HRESULT
sendRcvFlushPDUs
(
    struct InstanceStruct * pInstance,
    DWORD                   dwDirection,
    BOOL                    bShutdown
);

void
srInitializeLogging
(
    struct InstanceStruct * pInstance,
    BOOL                    bTracingEnabled
);

int     initializeASN1 (ASN1_CODER_INFO *);
int     terminateASN1  (ASN1_CODER_INFO *);
HRESULT sendRcvInit    (struct InstanceStruct * pInstance);
HRESULT sendRcvShutdown(struct InstanceStruct * pInstance);
HRESULT sendPDU        (struct InstanceStruct * pInstance, MltmdSystmCntrlMssg *pPdu);
HRESULT sendRcvShutdown_ProcessDetach(	struct InstanceStruct *pInstance, BOOL fProcessDetach);


#ifdef __cplusplus
}
#endif // __cplusplus

#endif // _SRP_API_H

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\tstable.h ===
/****************************************************************************
 *
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1996 Intel Corporation.
 *
 *
 *	Abstract:
 *
 *	Notes:
 *
 ***************************************************************************/

#ifndef __TSTABLE_H
#define __TSTABLE_H

typedef struct _LOCK_ENTRY
{
	HANDLE        hLock;
	int           iLockCount;
	BOOL          bCleanup,
								bDeleted;
	WORD          wNextFree,
								wUniqueID;

} LOCK_ENTRY, *PLOCK_ENTRY;


// definition of an invalid ID
#define TSTABLE_INVALID_ID				(DWORD) 0xFFFFFFFF

// return codes that the callback function used in conjunction with EnumerateEntries can return
const DWORD CALLBACK_CONTINUE                = 1;
const DWORD CALLBACK_ABORT                   = 2;
const DWORD CALLBACK_DELETE_ENTRY            = 3;
const DWORD CALLBACK_DELETE_ENTRY_AND_OBJECT = 4;



// used in call to Lock
#define TSTABLE_INVALID_UNIQUE_ID            (WORD) 0xFFFF
#define TSTABLE_INVALID_INDEX                (WORD) 0xFFFF

// This is a compare function that we aren't using right now.  It
// will be useful in the future if there is a reason to search
// the table

typedef INT (*ENTRY_COMPARE) (LPVOID ptr1, LPVOID ptr2);


template <class EntryData> class TSTable
{
typedef DWORD (*TABLE_CALLBACK) (EntryData* ptr, LPVOID context);

public:
	           TSTable         (WORD            _size);
	          ~TSTable         ();
	BOOL       Resize          (WORD            wNewSize);
	BOOL       CreateAndLock   (EntryData*      pEntryData,
															LPDWORD         lpdwID);
	BOOL       Validate        (DWORD_PTR       dwID);
	EntryData *Lock            (DWORD_PTR       dwID,
															DWORD           timeout = INFINITE);
	BOOL       Unlock          (DWORD_PTR       dwID);
	BOOL       Delete          (DWORD_PTR       dwID,
															BOOL            bCleanup = FALSE);
	EntryData *EnumerateEntries(TABLE_CALLBACK  callBackFunc,
															void*           context,
															BOOL            bUnlockTable = FALSE);
	
	BOOL       IsInitialized   () {return bInitialized;}
	WORD       GetSize         () {return wNumUsed;}

private:
	// data

	EntryData**       pDataTable;
	PLOCK_ENTRY       pLockTable;
	CRITICAL_SECTION  csTableLock;
	WORD              wSize,
					  wNumUsed,
					  wFirstFree,
				      wLastFree,
					  wUniqueID;
	BOOL              bInitialized;

	// private methods

	BOOL LockEntry   (WORD wIndex,
									 DWORD timeout = INFINITE);
	BOOL UnLockEntry(WORD wIndex);
	void LockTable  () { EnterCriticalSection(&csTableLock); };
	void UnLockTable() { LeaveCriticalSection(&csTableLock); };
	WORD GenerateUniqueID();
	DWORD MakeID(WORD wIndex, WORD wUniqueID)
		{
			DWORD theID = wUniqueID;
			theID = (theID << 16) & 0xFFFF0000;
			theID |= wIndex;
			return(theID);
		};
	void BreakID(DWORD_PTR theID, WORD* pwIndex, WORD* pwUID)
		{
			*pwIndex = (WORD) (theID & 0x0000FFFF);
			*pwUID   = (WORD) ((theID >> 16) & 0x0000FFFF);
		};

};

/*
 ** TSTable::TSTable
 *
 *  FILENAME: c:\msdev\projects\firewalls\inc\tstable.h
 *
 *  PARAMETERS:
 *
 *  DESCRIPTION:
 *
 *  RETURNS:
 *
 */

template <class EntryData>
TSTable<EntryData>::TSTable(WORD _size) :
														wSize(_size),
														wNumUsed((WORD) 0),
														wFirstFree((WORD) 0),
														wLastFree((WORD) (_size - 1)),
														wUniqueID((WORD) 0),
														bInitialized(TRUE),
														pDataTable(NULL),
														pLockTable(NULL)
{
	WORD wIndex;

	// Create the table lock

	InitializeCriticalSection(&csTableLock);

	// Lock the table

	LockTable();

	// Create the data table

	pDataTable = new EntryData*[wSize];
	
	if(pDataTable == NULL)
	{
		bInitialized = FALSE;
		return;
	}

	// Init the pointers

	for (wIndex = 0; wIndex < wSize; wIndex++)
	{
		pDataTable[wIndex] = NULL;
	}

	// Create the lock table

	pLockTable = new LOCK_ENTRY[wSize];

	if (pLockTable == NULL)
	{
		bInitialized = FALSE;
		return;
	}

	// Initialize the lock table entries...each entry begins with
	// a NULL mutex handle, a zero lock count and it's next free is
	// the next successive entry.

	for (wIndex = 0; wIndex < wSize; wIndex++ )
	{
		pLockTable[wIndex].hLock      = NULL;
		pLockTable[wIndex].iLockCount = 0;
		pLockTable[wIndex].wNextFree = (WORD) (wIndex + 1);
	}

	// note: the wNextFree in the last table entry points to an invalid index, however,
	// this is OK since if the table ever fills, it is automatically resized making what
	// was an invalid index, the index into the first entry of newly added part of the
	// enlargened table.  Trust me...

	// Unlock the table

	UnLockTable();
}

/*
 ** TSTable::~TSTable
 *
 *  FILENAME: c:\msdev\projects\firewalls\inc\table.h
 *
 *  PARAMETERS:
 *
 *  DESCRIPTION:
 *
 *  RETURNS:
 *
 */

template <class EntryData>
TSTable<EntryData>::~TSTable()
{
	DWORD wIndex;

	// Lock the table

	LockTable();

	// Delete the data table

	if (pDataTable != NULL)
	{
		delete pDataTable;
	}

	// Delete the lock table

	if (pLockTable != NULL)
	{
		// Destroy the mutexes

		for (wIndex = 0; wIndex < wSize; wIndex++)
		{
			if (pLockTable[wIndex].hLock != NULL)
			{
				CloseHandle(pLockTable[wIndex].hLock);
			}
		}

		delete pLockTable;
	}

	// Unlock the table

	UnLockTable();

	// Destroy the table lock

	DeleteCriticalSection(&csTableLock);

	bInitialized = FALSE;
}

/*
 ** TSTable::CreateAndLock
 *
 *  FILENAME: c:\msdev\projects\firewalls\inc\table.h
 *
 *  PARAMETERS:
 *
 *  DESCRIPTION:
 *
 *  RETURNS:
 *
 */

template <class EntryData>
BOOL TSTable<EntryData>::CreateAndLock(EntryData* pEntryData,
																			 LPDWORD    lpdwID)
{
	BOOL  bRetCode = FALSE;
	WORD wIndex;

	// If the pointer passed in is bad, then don't even try to do anything for them

	if (pEntryData == NULL || lpdwID == NULL)
	{
		goto EXIT;
	}

	// Lock the table

	LockTable();

	// If the table is full, then resize it.

	if (wNumUsed >= wSize - 1)
	{
		goto EXIT;
	}

	// Get the first free entry

	wIndex = wFirstFree;

	// Create the mutex for the object

	if ((pLockTable[wIndex].hLock = CreateMutexA(NULL, FALSE, NULL)) == NULL)
	{
		goto EXIT;
	}

	// Lock the entry (no need checking the return code as the entire
	// table is locked) - since this is a new entry, that means that nobody
	// could have locked the entry already.

	LockEntry(wIndex, 0);

	// Copy pointer to the data table

	pDataTable[wIndex] = pEntryData;

	// Init the corresponding lock table entry

	pLockTable[wIndex].bDeleted   = FALSE;
	pLockTable[wIndex].iLockCount = 1;
	pLockTable[wIndex].wUniqueID = GenerateUniqueID();

	// Set the id for the caller

	*lpdwID = MakeID(wIndex, pLockTable[wIndex].wUniqueID);

	// Bump up the count of number used

	wNumUsed++;

	// Fix the next free index

	wFirstFree = pLockTable[wIndex].wNextFree;

	// Signal success

	bRetCode = TRUE;

EXIT:

	// Unlock the table

	UnLockTable();
	return bRetCode;
}

/*
 ** TSTable::Lock
 *
 *  FILENAME: c:\msdev\projects\firewalls\inc\table.h
 *
 *  PARAMETERS:
 *
 *  DESCRIPTION:
 *
 *  RETURNS:
 *
 */

template <class EntryData>
EntryData* TSTable<EntryData>::Lock(DWORD_PTR dwID,
																		DWORD timeout)
{
	EntryData* pEntryData = NULL;

	WORD wIndex,
       wUID;

	BreakID(dwID, &wIndex, &wUID);

	// Lock the table

	LockTable();

	// Verify the index is within bounds

	if (wIndex >= wSize)
	{
		goto EXIT;
	}

	// Verify that the entry is actually valid (ie the lock in non-NULL,
	// the object status is valid, and the unique ID matches).

	if (pLockTable[wIndex].hLock    == NULL ||
			pLockTable[wIndex].bDeleted == TRUE ||
			pLockTable[wIndex].wUniqueID != wUID)
	{
		goto EXIT;
	}

	// If the timeout is INFINITE, then try to lock the entry using a more
	// "thread friendly" method.	 If a timeout is specified, then don't do
	// the spin lock since it could be implemented at a higher level.

	if(timeout == INFINITE)
	{
		// simulate infinity with a pseudo "spin lock"
		// This is more "thread friendly" in that it unlocks the table allowing some
		// other thread that is trying to unlock the same entry to be able to lock the
		// table.

		while(LockEntry(wIndex, 0) == FALSE)
		{
			UnLockTable();

			// give up the rest of this thread quantum, allowing others to run and potentially
			// unlock the entry

			Sleep(0);
			LockTable();

			// If the entry has been replaced, deleted or marked for deletion then
			// bag it (give up)

			if((pLockTable[wIndex].wUniqueID != wUID)  ||
				 (pLockTable[wIndex].hLock      == NULL)  ||
				 (pLockTable[wIndex].bDeleted   == TRUE))
			{
				goto EXIT;
			}
		}

		// we got the lock

		pEntryData = pDataTable[wIndex];
	}
	
	// Otherwise, do a normal lock

	else
	{	
		if (LockEntry(wIndex, timeout) == TRUE)
		{
			pEntryData = pDataTable[wIndex];
		}
	}

EXIT:

	// Unlock the table

	UnLockTable();

	return pEntryData;
}

/*
 ** TSTable::Unlock
 *
 *  FILENAME: c:\msdev\projects\firewalls\inc\table.h
 *
 *  PARAMETERS:
 *
 *  DESCRIPTION:
 *
 *  RETURNS:
 *
 */

template <class EntryData>
BOOL TSTable<EntryData>::Unlock(DWORD_PTR dwID)
{
	BOOL bRetCode = TRUE;

	WORD wIndex,
       wUID;

	BreakID(dwID, &wIndex, &wUID);
	
	// Lock the table

	LockTable();

	// Verify the id is within bounds

	if (wIndex >= wSize)
	{
		bRetCode = FALSE;
		goto EXIT;
	}

	// verify that the UID matches
	if (pLockTable[wIndex].wUniqueID != wUID)
	{
		bRetCode = FALSE;
		goto EXIT;
	}

	// Verify that the lock is actually valid and that the entry has not been
	// deleted

	if (pLockTable[wIndex].hLock == NULL)
	{
		goto EXIT;
	}

	// Make sure that that thread has the lock on the entry

	if ((bRetCode = LockEntry(wIndex, 0)) == TRUE)
	{
		// if this table entry is marked for delete and the lock count is less than 2
		// (since the thread could have called delete after unlocking the entry...although
		// this is a no-no) then clean up the table entry

		if (pLockTable[wIndex].bDeleted   == TRUE &&
				pLockTable[wIndex].iLockCount <= 2)
		{
			// If the caller specifed cleanup on delete, then get rid of memory

			if (pLockTable[wIndex].bCleanup == TRUE)
			{
				delete pDataTable[wIndex];
			}

			// Set the pointer to NULL

			pDataTable[wIndex] = NULL;

			// Decrement the count of used entries

			wNumUsed--;

			// Fix the entry so that it's next free index is what is currently
			// the next free pointed to by the current last free entry.
			// Then update the last free entry's next pointer, and finally,
			// update the last free index to this entry
			pLockTable[wIndex].wNextFree    = pLockTable[wLastFree].wNextFree;
			pLockTable[wLastFree].wNextFree = wIndex;
			wLastFree                       = wIndex;
		}

		// Do two unlocks on the entry ... one for the original lock and another for
		// the lock we obtained during the test

		UnLockEntry(wIndex);
		UnLockEntry(wIndex);

		// Since the entire table is locked, then we can get away with this.  If
		// the code is ever changed so that the entire table is not locked during
		// these operations, then this will cause a race condition.

		// If we got rid of the data, then close the handle to the mutex and
		// set the handle to NULL

		if (pDataTable[wIndex] == NULL)
		{
			CloseHandle(pLockTable[wIndex].hLock);
			pLockTable[wIndex].hLock = NULL;
		}
	}

EXIT:

	// Unlock the table

	UnLockTable();

	return bRetCode;
}

/*
 ** TSTable::Delete
 *
 *  FILENAME: c:\msdev\projects\firewalls\inc\table.h
 *
 *  PARAMETERS:
 *
 *  DESCRIPTION:
 *
 *  RETURNS:
 *
 */

template <class EntryData>
BOOL TSTable<EntryData>::Delete(DWORD_PTR dwID,
																BOOL  bCleanup)
{
	BOOL bRetCode = TRUE;

	WORD wIndex,
       wUID;

	BreakID(dwID, &wIndex, &wUID);

	// Lock the table

	LockTable();

	// Verify that the ID is within bounds

	if (wIndex >= wSize)
	{
		bRetCode = FALSE;
		goto EXIT;
	}

	// verify that the UID matches
	if (pLockTable[wIndex].wUniqueID != wUID)
	{
		bRetCode = FALSE;
		goto EXIT;
	}

	// Verify that the entry is valid

	if (pDataTable[wIndex] == NULL)
	{
		bRetCode = FALSE;
		goto EXIT;
	}

	// Try to lock the entry (ie check to see if we had the entry locked)

	if (LockEntry(wIndex, 0) == TRUE)
	{
		// mark it for deletion, set the cleanp flag and then unlock it

		pLockTable[wIndex].bDeleted = TRUE;
		pLockTable[wIndex].bCleanup = bCleanup;

		UnLockEntry(wIndex);

		// Note: this function does not call ::Unlock() on behalf of the user.
		// Thus, the entry is only marked as deleted at this point and can no
		// longer be locked by any threads (including the one that marked it for delete).
		// The thread that marked the entry as deleted must call ::Unlock() to actually
		// free up the entry.
	}

EXIT:

	// Unlock the table

	UnLockTable();

	return bRetCode;
}

/*
 ** TSTable::Lock
 *
 *  FILENAME: c:\msdev\projects\firewalls\inc\table.h
 *
 *  PARAMETERS:
 *
 *  DESCRIPTION:  Validates that an object still exists.  Can be called
 *								regardless if caller has entry locked or not.
 *
 *  RETURNS:
 *
 */

template <class EntryData>
BOOL TSTable<EntryData>::Validate(DWORD_PTR dwID)
{
	BOOL bRetCode = TRUE;
	WORD wIndex,
       wUID;

	BreakID(dwID, &wIndex, &wUID);

	// Lock the table

	LockTable();

	// Verify the index is within bounds

	if (wIndex >= wSize)
	{
		bRetCode = FALSE;
		goto EXIT;
	}

	// Verify that the entry is actually valid (ie the lock in non-NULL,
	// the object status is valid, the unique ID matches, and the data ptr is not null).

	if (pLockTable[wIndex].hLock    == NULL  ||
			pLockTable[wIndex].bDeleted == TRUE  ||
			pLockTable[wIndex].wUniqueID != wUID ||
			pDataTable[wIndex] == NULL)
	{
		bRetCode = FALSE;
		goto EXIT;
	}

EXIT:

	// Unlock the table

	UnLockTable();

	return bRetCode;
}

/*
 ** TSTable::EnumerateEntries
 *
 *  FILENAME: c:\msdev\projects\firewalls\inc\table.h
 *
 *  PARAMETERS:
 *
 *  DESCRIPTION:
 *
 *  RETURNS:
 *
 */

template <class EntryData>
EntryData* TSTable<EntryData>::EnumerateEntries(TABLE_CALLBACK callbackFunc,
																								LPVOID         context,
																								BOOL           bUnlockTable)
{
	DWORD      dwAction;
	WORD       wIndex = wSize;
	EntryData* pEntryData = NULL;
	DWORD      dwEntryID;

	// Make sure they passed a good function

	if (callbackFunc == NULL)
	{
		goto EXIT;
	}

	// Lock the table

	LockTable();

	// Run through the data table and pass the data to the callback function

	for (wIndex = 0; wIndex < wSize; wIndex++)
	{
		// Verify that there is actually data in the entry and that the entry has not
		// been marked for deletion.

		if (pDataTable[wIndex]          == NULL ||
				pLockTable[wIndex].bDeleted == TRUE)
		{
			continue;
		}


		// Try to lock the entry...if we cannot, then we don't have the lock and
		// we will only report entries that we have locked (or are unlocked)

		if (LockEntry(wIndex, 0) == FALSE)
		{
			continue;
		}
		
		// build and remember the "full" entry ID so we can use it to unlock the entry
		dwEntryID = MakeID(wIndex, pLockTable[wIndex].wUniqueID);

		// Save the pointer to the object.

		pEntryData = pDataTable[wIndex];

		// note: only unlock the table during the callback if we are explicitly asked to (the
		// default is not to unlock the table).
		if(bUnlockTable == TRUE)
			UnLockTable();

		// Call their function
		dwAction = callbackFunc(pDataTable[wIndex], context);

		if(bUnlockTable == TRUE)
			LockTable();

		// If the action says to delete the entry, then do so...if we are also to delete
		// the object, pass in a TRUE.

		if (dwAction == CALLBACK_DELETE_ENTRY ||
				dwAction == CALLBACK_DELETE_ENTRY_AND_OBJECT)
		{
			Delete(dwEntryID, (dwAction == CALLBACK_DELETE_ENTRY ? FALSE : TRUE));
		}

		// If the action says abort, then break the loop...notice that means that
		// the entry is still locked

		else if (dwAction == CALLBACK_ABORT)
		{
			goto EXIT;
		}

		// Unlock the entry...notice we don't use UnLockEntry.  The reason is that
		// if the entry has been marked as deleted, then we need to have
		// it destroyed and UnLockEntry doesn't do that.

		Unlock(dwEntryID);
	}

EXIT:

	// Unlock the table

	UnLockTable();

	// Return NULL if we processed the entire table...if we were told to abort,
	// return a pointer to the entry we stopped on.

	return (wIndex == wSize ? NULL : pEntryData);
}

// helper functions - these assume table is locked and index is good

/*
 ** TSTable::LockEntry
 *
 *  FILENAME: c:\msdev\projects\firewalls\inc\table.h
 *
 *  PARAMETERS:
 *
 *  DESCRIPTION:
 *
 *  RETURNS:
 *
 */

template <class EntryData>
BOOL TSTable<EntryData>::LockEntry(WORD wIndex,
																	 DWORD timeout)
{
	BOOL  bRetCode = TRUE;
	DWORD dwRetCode;


	// Try to lock the entry.  If it succeeds, we'll bump up the lock count.  If
	// the wait ended because another thread abandoned the mutex, then set the count
	// to one.

	dwRetCode = WaitForSingleObject(pLockTable[wIndex].hLock, timeout);
	
	if (dwRetCode == WAIT_OBJECT_0)
	{
		pLockTable[wIndex].iLockCount++;
	}
	else if (dwRetCode == WAIT_ABANDONED)
	{
		pLockTable[wIndex].iLockCount = 1;
	}
	else
	{
		bRetCode = FALSE;
	}

	return bRetCode;
}

/*
 ** TSTable::UnLockEntry
 *
 *  FILENAME: c:\msdev\projects\firewalls\inc\table.h
 *
 *  PARAMETERS:
 *
 *  DESCRIPTION:
 *
 *  RETURNS:
 *
 */

template <class EntryData>
BOOL TSTable<EntryData>::UnLockEntry(WORD wIndex)
{
	BOOL bRetCode;

	// Release the mutex...if that succeeds, reduce the count

	if((bRetCode = ReleaseMutex(pLockTable[wIndex].hLock)) == TRUE)
	{
		pLockTable[wIndex].iLockCount--;
	}

	return bRetCode;
}


/*
 ** TSTable::GenerateUniqueID
 *
 *  FILENAME: c:\msdev\projects\firewalls\inc\table.h
 *
 *  PARAMETERS:
 *
 *  DESCRIPTION: table should be locked before calling this function.
 *
 *  RETURNS:
 *
 */

template <class EntryData>
WORD TSTable<EntryData>::GenerateUniqueID()
{
	// table must be locked
	if(++wUniqueID == TSTABLE_INVALID_UNIQUE_ID)
		wUniqueID++;
	return(wUniqueID);
}






#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\utils.c ===
/****************************************************************************
 *
 *	$Archive:   S:\sturgeon\src\q931\vcs\utils.c_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1996 Intel Corporation.
 *
 *	$Revision:   1.33  $
 *	$Date:   23 Jan 1997 20:42:54  $
 *	$Author:   SBELL1  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *		
 *
 *	Notes:
 *
 ***************************************************************************/

#pragma warning ( disable : 4115 4201 4214 4514 )

#include "precomp.h"

#ifdef __cplusplus
extern "C" {
#endif

#include <string.h>
#include "q931.h"
#include "isrg.h"
#include "utils.h"
#include "linkapi.h"

//====================================================================================
//===============/=====================================================================
void
Q931MakePhysicalID(DWORD *pdwPhysicalID)
{
   *pdwPhysicalID = INVALID_PHYS_ID;
}

//====================================================================================
//====================================================================================
WORD
ADDRToInetPort(CC_ADDR *pAddr)
{
    WORD HostPort = 0;
    switch (pAddr->nAddrType)
    {
    case CC_IP_DOMAIN_NAME:
        HostPort = pAddr->Addr.IP_DomainName.wPort;
        break;
    case CC_IP_DOT:
        HostPort = pAddr->Addr.IP_Dot.wPort;
        break;
    case CC_IP_BINARY:
        HostPort = pAddr->Addr.IP_Binary.wPort;
        break;
    }
    return htons(HostPort);
}

//====================================================================================
//====================================================================================
DWORD
ADDRToInetAddr(CC_ADDR *pAddr)
{
    struct hostent *pHostEnt;

    switch (pAddr->nAddrType)
    {
    case CC_IP_DOMAIN_NAME:
        {
            char buf[sizeof(pAddr->Addr.IP_DomainName.cAddr) / sizeof(WCHAR)];

            WideCharToMultiByte(CP_ACP, 0, pAddr->Addr.IP_DomainName.cAddr, -1, buf, sizeof(buf), NULL, NULL);

            pHostEnt = gethostbyname(buf);
        }
        if (pHostEnt == NULL || pHostEnt->h_addr_list == NULL)
        {
            return htonl(0L);
        }
        return *((DWORD *)pHostEnt->h_addr_list[0]);
    
    case CC_IP_DOT:
        {
            char buf[sizeof(pAddr->Addr.IP_Dot.cAddr) / sizeof(WCHAR)];

            WideCharToMultiByte(CP_ACP, 0, pAddr->Addr.IP_Dot.cAddr, -1, buf, sizeof(buf), NULL, NULL);

            return inet_addr(buf);
        }
    case CC_IP_BINARY:
        return htonl(pAddr->Addr.IP_Binary.dwAddr);
    }
    return 0L;
}

//====================================================================================
// If Port 0 is passed in, use default listen port.
//====================================================================================
void
SetDefaultPort(CC_ADDR *pAddr)
{
    switch (pAddr->nAddrType)
    {
    case CC_IP_DOMAIN_NAME:
        if (pAddr->Addr.IP_DomainName.wPort == 0)
        {
            pAddr->Addr.IP_DomainName.wPort = CC_H323_HOST_CALL;
        }
        return;
    case CC_IP_DOT:
        if (pAddr->Addr.IP_Dot.wPort == 0)
        {
            pAddr->Addr.IP_Dot.wPort = CC_H323_HOST_CALL;
        }
        return;
    case CC_IP_BINARY:
        if (pAddr->Addr.IP_Binary.wPort == 0)
        {
            pAddr->Addr.IP_Binary.wPort = CC_H323_HOST_CALL;
        }
        return;
    }
    return;
}

//====================================================================================
//====================================================================================
BOOL
MakeBinaryADDR(CC_ADDR *pInAddr, CC_ADDR *pOutAddr)
{
    if (pOutAddr == NULL)
    {
        return FALSE;
    }

    memset(pOutAddr, 0, sizeof(CC_ADDR));

    if (pInAddr == NULL)
    {
        return FALSE;
    }

    pOutAddr->nAddrType = CC_IP_BINARY;
    pOutAddr->bMulticast = pInAddr->bMulticast;

    switch (pInAddr->nAddrType)
    {
    case CC_IP_DOMAIN_NAME:
    {
        struct hostent *pHostEnt;
        DWORD net_addr;
        {
            char buf[sizeof(pInAddr->Addr.IP_DomainName.cAddr) / sizeof(WCHAR)];

            WideCharToMultiByte(CP_ACP, 0, pInAddr->Addr.IP_DomainName.cAddr, -1, buf, sizeof(buf), NULL, NULL);

            if (buf[0] == '\0')
            {
                return FALSE;
            }
            pHostEnt = gethostbyname(buf);
        }
        if (pHostEnt == NULL || pHostEnt->h_addr_list == NULL)
        {
            return FALSE;
        }
        net_addr = *((DWORD *)pHostEnt->h_addr_list[0]);
        pOutAddr->Addr.IP_Binary.wPort = pInAddr->Addr.IP_DomainName.wPort;
        pOutAddr->Addr.IP_Binary.dwAddr = ntohl(net_addr);
    }
        break;
    case CC_IP_DOT:
        {
            char buf[sizeof(pInAddr->Addr.IP_Dot.cAddr) / sizeof(WCHAR)];

            WideCharToMultiByte(CP_ACP, 0, pInAddr->Addr.IP_Dot.cAddr, -1, buf, sizeof(buf), NULL, NULL);

            if (buf[0] == '\0')
            {
                return FALSE;
            }
            pOutAddr->Addr.IP_Binary.dwAddr = ntohl(inet_addr(buf));
        }
        pOutAddr->Addr.IP_Binary.wPort = pInAddr->Addr.IP_Dot.wPort;
        break;
    default:
        pOutAddr->Addr.IP_Binary.wPort = pInAddr->Addr.IP_Binary.wPort;
        pOutAddr->Addr.IP_Binary.dwAddr = pInAddr->Addr.IP_Binary.dwAddr;
        break;
    }
    return TRUE;
}

//====================================================================================
//====================================================================================
void
GetDomainAddr(CC_ADDR *pAddr)
{
    WORD wTemp;
    char szHostName[80];

    if (gethostname(szHostName, sizeof(szHostName)) != SOCKET_ERROR)
    {
        wTemp = pAddr->Addr.IP_Binary.wPort;
        pAddr->nAddrType = CC_IP_DOMAIN_NAME;

        MultiByteToWideChar(CP_ACP, 0, szHostName, -1,
            pAddr->Addr.IP_DomainName.cAddr,
            sizeof(pAddr->Addr.IP_DomainName.cAddr) /
            sizeof(pAddr->Addr.IP_DomainName.cAddr[0]));

        pAddr->Addr.IP_DomainName.wPort = wTemp;
    }
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931ValidateAddr(PCC_ADDR pAddr)
{
    if (pAddr == NULL)
    {
        return CS_OK;
    }
    if ((pAddr->nAddrType != CC_IP_DOMAIN_NAME) &&
            (pAddr->nAddrType != CC_IP_DOT) &&
            (pAddr->nAddrType != CC_IP_BINARY))
    {
        return CS_BAD_PARAM;
    }

    if (pAddr->nAddrType == CC_IP_DOT)
    {
        WCHAR *p = pAddr->Addr.IP_Dot.cAddr;

        while (*p)
        {
            if (wcschr((const WCHAR *)CC_ODOTTO_CHARS, *p) == NULL)
            {
                return CS_BAD_PARAM;
            }
            p++;
        }
    }

    if (pAddr->bMulticast == TRUE)
    {
        return CS_BAD_PARAM;
    }

    return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931ValidateAliasItem(PCC_ALIASITEM pSource)
{
    register unsigned int y;

    if (pSource)
    {
        if ((pSource->pData == NULL) || (pSource->wDataLength == 0))
        {
            return CS_BAD_PARAM;
        }
        if (pSource->pPrefix != NULL)
        {
            if (pSource->wPrefixLength == 0)
            {
                return CS_BAD_PARAM;
            }
        }
        else if (pSource->wPrefixLength != 0)
        {
            return CS_BAD_PARAM;
        }
        switch (pSource->wType)
        {
        case CC_ALIAS_H323_ID:
            if ((pSource->wDataLength + pSource->wPrefixLength) > CC_ALIAS_MAX_H323_ID)
            {
                return CS_BAD_PARAM;
            }
            break;

        case CC_ALIAS_H323_PHONE:
            if ((pSource->wDataLength + pSource->wPrefixLength +1) > CC_ALIAS_MAX_H323_PHONE)
            {
                return CS_BAD_PARAM;
            }
            for (y = 0; y < pSource->wDataLength; ++y)
            {
                if (wcschr((const WCHAR *)CC_ALIAS_H323_PHONE_CHARS, pSource->pData[y]) == NULL)
                {
                    return CS_BAD_PARAM;
                }
            }
            if (pSource->pPrefix != NULL)
            {
                for (y = 0; y < pSource->wPrefixLength; ++y)
                {
                    if (wcschr((const WCHAR *)CC_ALIAS_H323_PHONE_CHARS, pSource->pPrefix[y]) == NULL)
                    {
                        return CS_BAD_PARAM;
                    }
                }
            }
        }
    }
    return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931CopyAliasItem(PCC_ALIASITEM *ppTarget, PCC_ALIASITEM pSource)
{
    PCC_ALIASITEM pNewItem = NULL;

    if (ppTarget == NULL)
    {
        return CS_BAD_PARAM;
    }
    *ppTarget = NULL;
    if (pSource == NULL)
    {
        return CS_OK;
    }

    pNewItem = (PCC_ALIASITEM)MemAlloc(sizeof(CC_ALIASITEM));
    if (pNewItem == NULL)
    {
        return CS_NO_MEMORY;
    }
    pNewItem->wType = pSource->wType;

  	if ((pSource->wPrefixLength != 0) && (pSource->pPrefix != NULL))
	{
        pNewItem->wPrefixLength = pSource->wPrefixLength;
        pNewItem->pPrefix = (LPWSTR)MemAlloc(pSource->wPrefixLength * sizeof(pNewItem->pPrefix[0]));
        if (pNewItem->pPrefix == NULL)
        {
            MemFree(pNewItem);
            return CS_NO_MEMORY;
        }
        memcpy(pNewItem->pPrefix, pSource->pPrefix, pSource->wPrefixLength * sizeof(WCHAR));
    }
    else
    {
        pNewItem->wPrefixLength = 0;
        pNewItem->pPrefix = NULL;
    }


    if ((pSource->wDataLength != 0) && (pSource->pData != NULL))
    {
        pNewItem->wDataLength = pSource->wDataLength;
        pNewItem->pData = (LPWSTR)MemAlloc(pSource->wDataLength * sizeof(pNewItem->pData[0]));
        if (pNewItem->pData == NULL)
        {
            if (pNewItem->pPrefix)
            {
               MemFree(pNewItem->pPrefix);
            }
            MemFree(pNewItem);
            return CS_NO_MEMORY;
        }
        memcpy(pNewItem->pData, pSource->pData, pSource->wDataLength * sizeof(WCHAR));
    }
    else
    {
        pNewItem->wDataLength = 0;
        pNewItem->pData = NULL;
    }
    *ppTarget = pNewItem;

    return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931FreeAliasItem(PCC_ALIASITEM pSource)
{
    if (pSource)
    {
        if ((pSource->pPrefix) != NULL)
        {
            MemFree(pSource->pPrefix);
        }
        if ((pSource->pData) != NULL)
        {
            MemFree(pSource->pData);
        }
        MemFree(pSource);
    }
    return CS_OK;
}












//====================================================================================
//====================================================================================
CS_STATUS
Q931ValidateAliasNames(PCC_ALIASNAMES pSource)
{
    CS_STATUS TempResult = CS_OK;
    WORD x;

    if (pSource)
    {
        for (x = 0; x < pSource->wCount; x++)
        {
            TempResult = Q931ValidateAliasItem(&(pSource->pItems[x]));
            if (TempResult != CS_OK)
            {
                return TempResult;
            }
        }
    }
    return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931CopyAliasNames(PCC_ALIASNAMES *ppTarget, PCC_ALIASNAMES pSource)
{
    if (ppTarget == NULL)
    {
        return CS_BAD_PARAM;
    }
    *ppTarget = NULL;
    if (pSource == NULL)
    {
        return CS_OK;
    }
    if (pSource->wCount)
    {
        WORD x;
        *ppTarget = (PCC_ALIASNAMES)MemAlloc(sizeof(CC_ALIASNAMES));
        if (*ppTarget == NULL)
        {
            return CS_NO_MEMORY;
        }
        (*ppTarget)->pItems = (PCC_ALIASITEM)MemAlloc(pSource->wCount *
            sizeof(CC_ALIASITEM));
        if ((*ppTarget)->pItems == NULL)
        {
            MemFree(*ppTarget);
            *ppTarget = NULL;
            return CS_NO_MEMORY;
        }
        (*ppTarget)->wCount = pSource->wCount;
        {
            PCC_ALIASITEM p = (*ppTarget)->pItems;

            for (x = 0; x < pSource->wCount; x++)
            {
                p[x].wType = pSource->pItems[x].wType;

                if ((pSource->pItems[x].wPrefixLength != 0) &&
                        (pSource->pItems[x].pPrefix != NULL))
                {
                    p[x].wPrefixLength = pSource->pItems[x].wPrefixLength;
                    p[x].pPrefix = (LPWSTR)MemAlloc(pSource->pItems[x].wPrefixLength * sizeof(p[x].pPrefix[0]));
                    if (p[x].pPrefix == NULL)
                    {
                        // Free everything that has been allocated so far...
                        int y;
                        for (y = 0; y < x; y++)
                        {
                            if (p[y].pPrefix)
                            {
                                MemFree(p[y].pPrefix);
                            }
                            if (p[y].pData)
                            {
                                MemFree(p[y].pData);
                            }
                        }
                        MemFree(p);
                        MemFree(*ppTarget);
                        *ppTarget = NULL;
                        return CS_NO_MEMORY;
                    }
                    memcpy(p[x].pPrefix, pSource->pItems[x].pPrefix,
                        pSource->pItems[x].wPrefixLength * sizeof(WCHAR));
                }
                else
                {
                    p[x].wPrefixLength = 0;
                    p[x].pPrefix = NULL;
                }


                if ((pSource->pItems[x].wDataLength != 0) &&
                        (pSource->pItems[x].pData != NULL))
                {
                    p[x].wDataLength = pSource->pItems[x].wDataLength;
                    p[x].pData = (LPWSTR)MemAlloc(pSource->pItems[x].wDataLength * sizeof(p[x].pData[0]));
                    if (p[x].pData == NULL)
                    {
                        // Free everything that has been allocated so far...
                        int y;
                        if (p[x].pPrefix)
                        {
                            MemFree(p[x].pPrefix);
                        }
                        for (y = 0; y < x; y++)
                        {
                            if (p[y].pPrefix)
                            {
                                MemFree(p[y].pPrefix);
                            }
                            if (p[y].pData)
                            {
                                MemFree(p[y].pData);
                            }
                         }
                        MemFree(p);
                        MemFree(*ppTarget);
                        *ppTarget = NULL;
                        return CS_NO_MEMORY;
                    }
                    memcpy(p[x].pData, pSource->pItems[x].pData,
                        pSource->pItems[x].wDataLength * sizeof(WCHAR));
                }
                else
                {
                    p[x].wDataLength = 0;
                    p[x].pData = NULL;
                }
            }
        }
    }
    return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931FreeAliasNames(PCC_ALIASNAMES pSource)
{
    if (pSource && (pSource->wCount))
    {
        // Free everything that has been allocated so far...
        int x;
        for (x = 0; x < pSource->wCount; x++)
        {
            if ((pSource->pItems[x].pPrefix) != NULL)
            {
                MemFree(pSource->pItems[x].pPrefix);
            }
            if ((pSource->pItems[x].pData) != NULL)
            {
                MemFree(pSource->pItems[x].pData);
            }
        }
        if (pSource->pItems != NULL)
        {
            MemFree(pSource->pItems);
        }
        if (pSource != NULL)
        {
            MemFree(pSource);
        }
    }
    return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931ValidateDisplay(LPWSTR pszDisplay)
{
    if (pszDisplay == NULL)
    {
        return CS_OK;
    }
    if (wcslen(pszDisplay) > CC_MAX_DISPLAY_LENGTH)
    {
        return CS_BAD_PARAM;
    }
#if 0 // turn this on to validate display field against IA5 characters...
    while (*pszDisplay)
    {
        if (wcschr(CC_UNICODE_IA5_CHARS, *pszDisplay) == NULL)
        {
            return CS_BAD_PARAM;
        }
        pszDisplay++;
    }
#endif
    return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931ValidatePartyNumber(LPWSTR pszPartyNumber)
{
    if (pszPartyNumber == NULL)
    {
        return CS_OK;
    }
    if (wcslen(pszPartyNumber) > CC_MAX_PARTY_NUMBER_LEN)
    {
        return CS_BAD_PARAM;
    }
#if 0 // turn this on to validate party number field against IA5 characters...
    while (*pszPartyNumber)
    {
        if (wcschr(CC_UNICODE_IA5_CHARS, *pszPartyNumber) == NULL)
        {
            return CS_BAD_PARAM;
        }
        pszPartyNumber++;
    }
#endif
    return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931CopyDisplay(LPWSTR *ppDest, LPWSTR pSource)
{
    if (ppDest == NULL)
    {
        ASSERT(FALSE);
        return CS_BAD_PARAM;
    }
    if (pSource == NULL)
    {
        *ppDest = NULL;
        return CS_OK;
    }
    *ppDest = (LPWSTR)MemAlloc((wcslen(pSource) + 1) * sizeof(WCHAR));
    if (*ppDest == NULL)
    {
        return CS_NO_MEMORY;
    }
    wcscpy(*ppDest, pSource);
    return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931FreeDisplay(LPWSTR pszDisplay)
{
    if (pszDisplay == NULL)
    {
        return CS_OK;
    }
    MemFree(pszDisplay);
    return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931ValidateVendorInfo(PCC_VENDORINFO pVendorInfo)
{
    if (pVendorInfo == NULL)
    {
        return CS_OK;
    }

    if (pVendorInfo->pProductNumber)
    {
        if (pVendorInfo->pProductNumber->wOctetStringLength)
        {
            if (pVendorInfo->pProductNumber->wOctetStringLength > CC_MAX_PRODUCT_LENGTH)
            {
                return CS_BAD_PARAM;
            }
            if (pVendorInfo->pProductNumber->pOctetString == NULL)
            {
                return CS_BAD_PARAM;
            }
        }
        else if (pVendorInfo->pProductNumber->pOctetString)
        {
            return CS_BAD_PARAM;
        }
    }

    if (pVendorInfo->pVersionNumber)
    {
        if (pVendorInfo->pVersionNumber->wOctetStringLength)
        {
            if (pVendorInfo->pVersionNumber->wOctetStringLength > CC_MAX_VERSION_LENGTH)
            {
                return CS_BAD_PARAM;
            }
            if (pVendorInfo->pVersionNumber->pOctetString == NULL)
            {
                return CS_BAD_PARAM;
            }
        }
        else if (pVendorInfo->pVersionNumber->pOctetString)
        {
            return CS_BAD_PARAM;
        }
    }

    return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931CopyVendorInfo(PCC_VENDORINFO *ppDest, PCC_VENDORINFO pSource)
{
    if (ppDest == NULL)
    {
        ASSERT(FALSE);
        return CS_BAD_PARAM;
    }
    if (pSource == NULL)
    {
        *ppDest = NULL;
        return CS_OK;
    }
    *ppDest = (PCC_VENDORINFO)MemAlloc(sizeof(CC_VENDORINFO));
    if (*ppDest == NULL)
    {
        return CS_NO_MEMORY;
    }
    memset(*ppDest, 0, sizeof(CC_VENDORINFO));
    (*ppDest)->bCountryCode = pSource->bCountryCode;
    (*ppDest)->bExtension = pSource->bExtension;
    (*ppDest)->wManufacturerCode = pSource->wManufacturerCode;

    if ((pSource->pProductNumber == NULL) ||
            (pSource->pProductNumber->pOctetString == NULL) ||
            (pSource->pProductNumber->wOctetStringLength == 0))
    {
        (*ppDest)->pProductNumber = NULL;
    }
    else
    {
        (*ppDest)->pProductNumber = (PCC_OCTETSTRING)MemAlloc(sizeof(CC_OCTETSTRING));
        if ((*ppDest)->pProductNumber == NULL)
        {
            Q931FreeVendorInfo(*ppDest);
            *ppDest = NULL;
            return CS_NO_MEMORY;
        }
        memset((*ppDest)->pProductNumber, 0, sizeof(CC_OCTETSTRING));
        (*ppDest)->pProductNumber->pOctetString =
            (BYTE *)MemAlloc(pSource->pProductNumber->wOctetStringLength);
        if ((*ppDest)->pProductNumber->pOctetString == NULL)
        {
            Q931FreeVendorInfo(*ppDest);
            *ppDest = NULL;
            return CS_NO_MEMORY;
        }
        (*ppDest)->pProductNumber->wOctetStringLength =
            pSource->pProductNumber->wOctetStringLength;
        memcpy((*ppDest)->pProductNumber->pOctetString,
            pSource->pProductNumber->pOctetString,
            pSource->pProductNumber->wOctetStringLength);
    }

    if ((pSource->pVersionNumber == NULL) ||
            (pSource->pVersionNumber->pOctetString == NULL) ||
            (pSource->pVersionNumber->wOctetStringLength == 0))
    {
        (*ppDest)->pVersionNumber = NULL;
    }
    else
    {
        (*ppDest)->pVersionNumber = (PCC_OCTETSTRING)MemAlloc(sizeof(CC_OCTETSTRING));
        if ((*ppDest)->pVersionNumber == NULL)
        {
            Q931FreeVendorInfo(*ppDest);
            *ppDest = NULL;
            return CS_NO_MEMORY;
        }
        memset((*ppDest)->pVersionNumber, 0, sizeof(CC_OCTETSTRING));
        (*ppDest)->pVersionNumber->pOctetString =
            (BYTE *)MemAlloc(pSource->pVersionNumber->wOctetStringLength);
        if ((*ppDest)->pVersionNumber->pOctetString == NULL)
        {
            Q931FreeVendorInfo(*ppDest);
            *ppDest = NULL;
            return CS_NO_MEMORY;
        }
        (*ppDest)->pVersionNumber->wOctetStringLength =
            pSource->pVersionNumber->wOctetStringLength;
        memcpy((*ppDest)->pVersionNumber->pOctetString,
            pSource->pVersionNumber->pOctetString,
            pSource->pVersionNumber->wOctetStringLength);
    }

    return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931FreeVendorInfo(PCC_VENDORINFO pVendorInfo)
{
    if (pVendorInfo == NULL)
    {
        return CS_OK;
    }
    if (pVendorInfo->pProductNumber != NULL)
    {
        if (pVendorInfo->pProductNumber->pOctetString != NULL)
        {
            MemFree(pVendorInfo->pProductNumber->pOctetString);
        }
        MemFree(pVendorInfo->pProductNumber);
    }
    if (pVendorInfo->pVersionNumber != NULL)
    {
        if (pVendorInfo->pVersionNumber->pOctetString != NULL)
        {
            MemFree(pVendorInfo->pVersionNumber->pOctetString);
        }
        MemFree(pVendorInfo->pVersionNumber);
    }
    MemFree(pVendorInfo);
    return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931ValidateNonStandardData(PCC_NONSTANDARDDATA pNonStandardData)
{
    if (pNonStandardData)
    {
        if ((pNonStandardData->sData.pOctetString == NULL) ||
                (pNonStandardData->sData.wOctetStringLength == 0))
        {
            return CS_BAD_PARAM;
        }
    }
    return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931CopyNonStandardData(PCC_NONSTANDARDDATA *ppDest, PCC_NONSTANDARDDATA pSource)
{
    if (ppDest == NULL)
    {
        ASSERT(FALSE);
        return CS_BAD_PARAM;
    }
    if (pSource == NULL)
    {
        *ppDest = NULL;
        return CS_OK;
    }
    *ppDest = (PCC_NONSTANDARDDATA)MemAlloc(sizeof(CC_NONSTANDARDDATA));
    if (*ppDest == NULL)
    {
        return CS_NO_MEMORY;
    }
    (*ppDest)->bCountryCode = pSource->bCountryCode;
    (*ppDest)->bExtension = pSource->bExtension;
    (*ppDest)->wManufacturerCode = pSource->wManufacturerCode;
    (*ppDest)->sData.wOctetStringLength = pSource->sData.wOctetStringLength;
    if (pSource->sData.pOctetString == NULL)
    {
        (*ppDest)->sData.pOctetString = NULL;
    }
    else
    {
        (*ppDest)->sData.pOctetString = (void *)MemAlloc(pSource->sData.wOctetStringLength);
        if ((*ppDest)->sData.pOctetString == NULL)
        {
            MemFree(*ppDest);
            *ppDest = NULL;
            return CS_NO_MEMORY;
        }
        memcpy((*ppDest)->sData.pOctetString, pSource->sData.pOctetString,
            pSource->sData.wOctetStringLength);
    }
    return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931FreeNonStandardData(PCC_NONSTANDARDDATA pNonStandardData)
{
    if (pNonStandardData == NULL)
    {
        return CS_OK;
    }
    if (pNonStandardData->sData.pOctetString != NULL)
    {
        MemFree(pNonStandardData->sData.pOctetString);
    }
    MemFree(pNonStandardData);
    return CS_OK;
}

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\termcap.c ===
/***********************************************************************
 *                                                                     *
 * Filename: termcap.c                                                 *
 * Module:   H245 Finite State Machine Subsystem                       *
 *                                                                     *
 ***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *                                                                     *
 * $Workfile:   TERMCAP.C  $
 * $Revision:   1.6  $
 * $Modtime:   09 Dec 1996 13:36:34  $
 * $Log L:\mphone\h245\h245env\comm\h245_3\h245_fsm\vcs\src\termcap.c_v $
 *                                                                     *
 ***********************************************************************/

#include "precomp.h"

#include "h245api.h"
#include "h245com.h"
#include "h245fsm.h"
#include "termcap.h"
#include "pdu.x"



// Terminal Capability Exchange Out-going/In-coming states
#define CapIDLE                         0
#define CapAwaitingResponse             1



extern unsigned int uT101;

/***********************************************************************
 *
 * LOCAL FUNCTIONS
 *
 ***********************************************************************/

/*
 *  NAME
 *      T101ExpiryF - Callback function called by the timer.
 *
 *
 *  PARAMETERS
 *   INPUT   dwInst     current instance of H245
 *   INPUT   id         timer id
 *   INPUT   pObject    pointer to a State Entity
 *
 *
 *  RETURN VALUE
 *       OK
 */

int T101ExpiryF(struct InstanceStruct *pInstance, DWORD_PTR dwTimerId, void *pObject)
{
    return FsmTimerEvent(pInstance, dwTimerId, pObject, T101Expiry);
} // T101ExpiryF()



/***********************************************************************
 *
 * OUT-GOING FINITE STATE MACHINE FUNCTIONS
 *
 ***********************************************************************/

/*
 *  NAME
 *      requestCapIdle - received TRANSFER.request in idle state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a FSM object
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT requestCapIdle(Object_t *pObject, PDU_t *pPdu)
{
    HRESULT             lError;

    ASSERT(pObject->Entity == CESE_OUT);
    ASSERT(pObject->State == CapIDLE);

    /* Increment sequence number */
    pObject->pInstance->StateMachine.byCeseOutSequence++;
    pPdu->u.MltmdSystmCntrlMssg_rqst.u.terminalCapabilitySet.sequenceNumber =
        pObject->pInstance->StateMachine.byCeseOutSequence;
    H245TRACE(  pObject->dwInst, 2, "TerminalCapabilitySet to ASN; Sequence=%d",
                pObject->pInstance->StateMachine.byCeseOutSequence);

    /* Send Terminal Capability Set to remote */
    lError = sendPDU(pObject->pInstance, pPdu);

    /* set timer T101 */
    pObject->State = CapAwaitingResponse;
    FsmStartTimer(pObject, T101ExpiryF, uT101);

    return lError;
}



/*
 *  NAME
 *      termCapAckAwaiting - received termCap Ack in Awaiting state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a FSM object
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT termCapAckAwaiting(Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == CESE_OUT);
    ASSERT(pObject->State == CapAwaitingResponse);

    /* reset timer T101 */
    FsmStopTimer(pObject);

    if (pPdu->u.MSCMg_rspns.u.terminalCapabilitySetAck.sequenceNumber ==
        pObject->pInstance->StateMachine.byCeseOutSequence)
    {
        H245TRACE(pObject->dwInst, 2, "H245_CONF_SEND_TERMCAP with no error to API; Sequence=%d",
                  pObject->pInstance->StateMachine.byCeseOutSequence);
        pObject->State = CapIDLE;
        H245FsmConfirm(pPdu, H245_CONF_SEND_TERMCAP, pObject->pInstance, pObject->dwTransId, FSM_OK);
    }
    else
    {
        H245TRACE(pObject->dwInst, 2, "termCapAckAwaiting: Sequence %d != %d",
                  pPdu->u.MSCMg_rspns.u.terminalCapabilitySetAck.sequenceNumber,
                  pObject->pInstance->StateMachine.byCeseOutSequence);
    }

    return 0;
}



/*
 *  NAME
 *      termCapRejAwaiting - received termCap Ack  in Awaiting state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a FSM object
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT termCapRejAwaiting(Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == CESE_OUT);
    ASSERT(pObject->State == CapAwaitingResponse);

    /* reset timer T101 */
    FsmStopTimer(pObject);

    if (pPdu->u.MSCMg_rspns.u.trmnlCpbltyStRjct.sequenceNumber ==
        pObject->pInstance->StateMachine.byCeseOutSequence)
    {
        H245TRACE(pObject->dwInst, 2, "H245_CONF_SEND_TERMCAP with Reject to API; Sequence=%d",
                  pObject->pInstance->StateMachine.byCeseOutSequence);
        pObject->State = CapIDLE;
        H245FsmConfirm(pPdu, H245_CONF_SEND_TERMCAP, pObject->pInstance, pObject->dwTransId, REJECT);
    }
    else
    {
        H245TRACE(pObject->dwInst, 2, "termCapRejAwaiting: Sequence %d != %d",
                  pPdu->u.MSCMg_rspns.u.trmnlCpbltyStRjct.sequenceNumber,
                  pObject->pInstance->StateMachine.byCeseOutSequence);
    }

    return 0;
}



/*
 *  NAME
 *      t101ExpiryAwaiting - handle timer expiry for an outstanding termcap
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a FSM object
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT t101ExpiryAwaiting(Object_t *pObject, PDU_t *pPdu)
{
    PDU_t *             pOut;
    HRESULT             lError;

    ASSERT(pObject->Entity == CESE_OUT);
    ASSERT(pObject->State == CapAwaitingResponse);
    ASSERT(pPdu           == NULL);

    pOut = (PDU_t *) MemAlloc(sizeof(*pOut));
    if (pOut == NULL)
    {
        return H245_ERROR_NOMEM;
    }

    /* Send Terminal Capability Set Release to remote */
    pOut->choice = indication_chosen;
    pOut->u.indication.choice = trmnlCpbltyStRls_chosen;
    lError = sendPDU(pObject->pInstance, pOut);
    MemFree(pOut);

    /* Send REJECT.indication (SOURCE=PROTOCOL) to client */
    H245TRACE(pObject->dwInst, 2, "H245_CONF_SEND_TERMCAP with Timer Expiry to API; Sequence=%d",
              pObject->pInstance->StateMachine.byCeseOutSequence);
    pObject->State = CapIDLE;
    H245FsmConfirm(NULL, H245_CONF_SEND_TERMCAP, pObject->pInstance, pObject->dwTransId, TIMER_EXPIRY);

    return lError;
}

/***********************************************************************
 *
 * IN-COMING FINITE STATE MACHINE FUNCTIONS
 *
 ***********************************************************************/

/*
 *  NAME
 *      termCapSetIdle - received termcap set in idle state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a FSM object
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT termCapSetIdle(Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == CESE_IN);
    ASSERT(pObject->State == CapIDLE);

    /* Save sequence number from PDU */
    pObject->byInSequence = (unsigned char)
        pPdu->u.MltmdSystmCntrlMssg_rqst.u.terminalCapabilitySet.sequenceNumber;
    H245TRACE(pObject->dwInst, 2, "H245_IND_CAP with no error to API; Sequence=%d",
              pObject->byInSequence);

    /* Send TRANSFER.indication to client */
    pObject->State = CapAwaitingResponse;
    H245FsmIndication(pPdu, H245_IND_CAP, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return 0;
}



/*
 *  NAME
 *      responseCapAwaiting - respond to a termcap with ack
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a FSM object
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT responseCapAwaiting(Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == CESE_IN);
    ASSERT(pObject->State == CapAwaitingResponse);
    H245TRACE(pObject->dwInst, 2, "Send Term Cap Ack to ASN; Sequence=%d",
              pObject->byInSequence);

    pPdu->u.MSCMg_rspns.u.terminalCapabilitySetAck.sequenceNumber =
        pObject->byInSequence;

    /* Send Terminal Capability Set Ack to remote */
    pObject->State = CapIDLE;
    return sendPDU(pObject->pInstance, pPdu);
}



/*
 *  NAME
 *      rejectCapAwaiting - respond to a termcap with reject
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a FSM object
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT rejectCapAwaiting(Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == CESE_IN);
    ASSERT(pObject->State == CapAwaitingResponse);
    H245TRACE(pObject->dwInst, 2, "Send Term Cap Reject to ASN; Sequence=%d",
              pObject->byInSequence);

    pPdu->u.MSCMg_rspns.u.trmnlCpbltyStRjct.sequenceNumber =
        pObject->byInSequence;

    /* Send Terminal Capability Set Reject to remote */
    pObject->State = CapIDLE;
    return sendPDU(pObject->pInstance, pPdu);
}



/*
 *  NAME
 *      termCapReleaseAwaiting - received termcap release in Awaiting state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a FSM object
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT termCapReleaseAwaiting(Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == CESE_IN);
    ASSERT(pObject->State == CapAwaitingResponse);
    H245TRACE(pObject->dwInst, 2, "H245_IND_CAP with Reject to API; Sequence=%d",
              pObject->byInSequence);

    /* Send REJECT.indication (SOURCE = PROTOCOL) to client */
    pObject->State = CapIDLE;
    H245FsmIndication(pPdu, H245_IND_CESE_RELEASE, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return 0;
}



/*
 *  NAME
 *      termCapSetAwaiting - received overriding termcap set in Awaiting state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a FSM object
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT termCapSetAwaiting(Object_t *pObject, PDU_t *pPdu)
{
    ASSERT(pObject->Entity == CESE_IN);
    ASSERT(pObject->State == CapAwaitingResponse);

    /* Save sequence number from PDU */
    pObject->byInSequence = (unsigned char)
        pPdu->u.MltmdSystmCntrlMssg_rqst.u.terminalCapabilitySet.sequenceNumber;
    H245TRACE(  pObject->dwInst, 2, "termCapSetAwaiting: Sequence=%d",
                pObject->byInSequence);

#if defined(SDL_COMPLIANT)
    /* Send REJECT.indication to client - not necessary */
    H245FsmIndication(NULL, H245_IND_CAP, pObject->pInstance, pObject->dwTransId, REJECT);
#endif

    /* Send TRANSFER.indication to client */
    H245FsmIndication(pPdu, H245_IND_CAP, pObject->pInstance, 0, FSM_OK);

    return 0;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\utils.h ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/Q931/VCS/utils.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1996 Intel Corporation.
 *
 *	$Revision:   1.16  $
 *	$Date:   21 Jan 1997 16:09:10  $
 *	$Author:   MANDREWS  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *		
 *      Call Setup Utilities
 *
 *	Notes:
 *
 ***************************************************************************/


#ifndef UTILS_H
#define UTILS_H

#ifdef __cplusplus
extern "C" {
#endif

void Q931MakePhysicalID(DWORD *);

#define UnicodeToAscii(src, dest, max)    WideCharToMultiByte(CP_ACP, 0, src, -1, dest, max, NULL, NULL)
#define AsciiToUnicode(src, dest, max)    MultiByteToWideChar(CP_ACP, 0, src, -1, dest, max)

WORD ADDRToInetPort(CC_ADDR *pAddr);
DWORD ADDRToInetAddr(CC_ADDR *pAddr);
void SetDefaultPort(CC_ADDR *pAddr);
BOOL MakeBinaryADDR(CC_ADDR *pInAddr, CC_ADDR *pOutAddr);
void GetDomainAddr(CC_ADDR *pAddr);

#ifdef __cplusplus
}
#endif

#endif UTILS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\termcap.h ===
/***********************************************************************
 *                                                                     *
 * Filename: termcap.h                                                 *
 * Module:   H245 Finite State Machine Subsystem                       *
 *                                                                     *
 ***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *                                                                     *
 * $Workfile:   TERMCAP.H  $
 * $Revision:   1.2  $
 * $Modtime:   09 Dec 1996 13:42:50  $
 * $Log:   S:/STURGEON/SRC/H245/INCLUDE/VCS/TERMCAP.H_v  $
 * 
 *    Rev 1.2   09 Dec 1996 13:43:08   EHOWARDX
 * Updated copyright notice.
 * 
 *    Rev 1.1   30 May 1996 23:38:34   EHOWARDX
 * Cleanup.
 * 
 *    Rev 1.0   09 May 1996 21:05:00   EHOWARDX
 * Initial revision.
 * 
 *    Rev 1.6.1.2   15 Apr 1996 10:43:50   EHOWARDX
 * Update.
 * 
 *    Rev 1.6.1.1   10 Apr 1996 21:07:26   EHOWARDX
 * Deleted No-op functions; moved state defines to .C file.
 * 
 *    Rev 1.6.1.0   05 Apr 1996 11:47:56   EHOWARDX
 * Branched.
 *                                                                     *
 ***********************************************************************/

// Terminal Capability Exchange (CESE) Out-going state functions
HRESULT requestCapIdle                  (Object_t *pObject, PDU_t *pPdu);
HRESULT termCapAckAwaiting              (Object_t *pObject, PDU_t *pPdu);
HRESULT termCapRejAwaiting              (Object_t *pObject, PDU_t *pPdu);
HRESULT t101ExpiryAwaiting              (Object_t *pObject, PDU_t *pPdu);

// Terminal Capability Exchange (CESE) Out-going state functions
HRESULT termCapSetIdle                  (Object_t *pObject, PDU_t *pPdu);
HRESULT responseCapAwaiting             (Object_t *pObject, PDU_t *pPdu);
HRESULT rejectCapAwaiting               (Object_t *pObject, PDU_t *pPdu);
HRESULT termCapReleaseAwaiting          (Object_t *pObject, PDU_t *pPdu);
HRESULT termCapSetAwaiting              (Object_t *pObject, PDU_t *pPdu);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech261\ac3.h ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: ac3.h,v $
 * Revision 1.1.2.3  1996/11/11  18:21:00  Hans_Graves
 * 	Added AC3_SYNC_WORD_REV define.
 * 	[1996/11/11  17:56:01  Hans_Graves]
 *
 * Revision 1.1.2.2  1996/11/08  21:50:39  Hans_Graves
 * 	Swapped bytes in SYNC_WORD
 * 	[1996/11/08  21:16:07  Hans_Graves]
 * 
 * 	First time under SLIB.
 * 	[1996/11/08  16:23:53  Hans_Graves]
 * 
 * $EndLog$
 */
/*	File: usr_equ.h		$Revision: 1.1.2.3 $	*/

/****************************************************************************
;	Unpublished work.  Copyright 1993-1996 Dolby Laboratories, Inc.
;	All Rights Reserved.
;
;	File:	usr_equ.h
;		Common equates for AC-3 system
;
;	History:
;		8/2/93		Created
;***************************************************************************/

#ifndef _AC3_H_
#define _AC3_H_

/**** General system equates ****/

#define NBLOCKS      6   /* # of time blocks per frame */
#define NCHANS       6   /* max # of discrete channels */
#define N            256 /* # of samples per time block */
#define AC3_FRAME_SIZE (NBLOCKS*N) /* 6 * 256 = 1536 */

/**** Miscellaneous equates ****/

#define NOUTWORDS         (3840 / 2)  /* max # words per frame */
#define NINFOWDS          10          /* # words needed by frame info */

/* Note:  Because of mismatches between the way AC-3 word stream parsing works
**		and the way that it's done for MPEG, you need to be careful using these
**		definitions
*/

#define AC3_SYNC_WORD     0x0B77      /* Byte reversed AC-3 sync word */
#define AC3_SYNC_WORD_REV 0x770B      /* packed data stream sync word */
#define AC3_SYNC_WORD_LEN 16          /* sync word length */
#define PCMCHANSZ         256         /* decoder overlap-add channel size */
#define PCM16BIT          1           /* 16-bit PCM code for Dolby SIP */

#ifdef KCAPABLE
#define NKCAPABLEMODES  4 /* # defined karaoke capable modes */
#define NKCAPABLEVARS   6 /* # karaoke pan/mix parameters */
#endif

#endif /* _AC3_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech261\avi.h ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: avi.h,v $
 * Revision 1.1.2.4  1996/01/15  16:26:22  Hans_Graves
 * 	Added Wave stuff
 * 	[1996/01/15  15:43:39  Hans_Graves]
 *
 * Revision 1.1.2.3  1996/01/08  16:41:23  Hans_Graves
 * 	Renamed AVI header structures.
 * 	[1996/01/08  15:45:16  Hans_Graves]
 * 
 * Revision 1.1.2.2  1995/12/07  19:31:26  Hans_Graves
 * 	Creation under SLIB
 * 	[1995/12/07  18:29:05  Hans_Graves]
 * 
 * $EndLog$
 */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

#ifndef _AVI_H_
#define _AVI_H_

/************** AVI parsing definitions **************/
typedef unsigned short twocc_t;
typedef unsigned int fourcc_t;

#ifndef FOURCC
#define FOURCC( ch0, ch1, ch2, ch3 ) \
          ( (fourcc_t)(char)(ch3) | ( (fourcc_t)(char)(ch2) << 8 ) | \
          ( (fourcc_t)(char)(ch1) << 16 ) | ( (fourcc_t)(char)(ch0) << 24 ) )
#endif

/* Macro to make a TWOCC out of two characters */

#ifndef TWOCC
#define TWOCC(ch0, ch1) ((twocc_t)(char)(ch1)|((twocc_t)(char)(ch0)<<8))
#endif

/* form types, list types, and chunk types */
#define AVI_AVI                 FOURCC('A', 'V', 'I', ' ')
#define AVI_AVIHEADERTYPE       FOURCC('h', 'd', 'r', 'l')
#define AVI_MAINHDR             FOURCC('a', 'v', 'i', 'h')
#define AVI_STREAMHEADERTYPE    FOURCC('s', 't', 'r', 'l')
#define AVI_STREAMHEADER        FOURCC('s', 't', 'r', 'h')
#define AVI_STREAMFORMAT        FOURCC('s', 't', 'r', 'f')
#define AVI_STREAMHANDLERDATA   FOURCC('s', 't', 'r', 'd')

#define AVI_MOVIETYPE           FOURCC('m', 'o', 'v', 'i')
#define AVI_RECORDTYPE          FOURCC('r', 'e', 'c', ' ')

#define AVI_NEWINDEX            FOURCC('i', 'd', 'x', '1')

/*
** Stream types for the <fccType> field of the stream header.
*/
#define AVI_VIDEOSTREAM         FOURCC('v', 'i', 'd', 's')
#define AVI_AUDIOSTREAM         FOURCC('a', 'u', 'd', 's')

/* Basic chunk types */
#define AVI_DIBbits           TWOCC('d', 'b')
#define AVI_DIBcompressed     TWOCC('d', 'c')
#define AVI_PALchange         TWOCC('p', 'c')
#define AVI_WAVEbytes         TWOCC('w', 'b')
#define AVI_Indeo             TWOCC('i', 'v')

/* Chunk id to use for extra chunks for padding. */
#define AVI_PADDING             FOURCC('J', 'U', 'N', 'K')

typedef struct
{
  dword dwMicroSecPerFrame;     /* frame display rate */
  dword dwMaxBytesPerSec;       /* max. transfer rate */
  dword dwPaddingGranularity;   /* pad to multiples of this */
                                /* size; normally 2K. */
  dword dwFlags;                /* the ever-present flags */
  dword dwTotalFrames;          /* # frames in file */
  dword dwInitialFrames;
  dword dwStreams;
  dword dwSuggestedBufferSize;

  dword dwWidth;
  dword dwHeight;

  dword dwReserved[4];
} AVI_MainHeader;

typedef struct {
    short left,top,right,bottom;
} DUMMYRECT;

typedef struct {
  fourcc_t  fccType;
  fourcc_t  fccHandler;
  dword     dwFlags;        /* Contains AVITF_* flags */
  dword     dwPriority;
  dword     dwInitialFrames;
  dword     dwScale;
  dword     dwRate; /* dwRate / dwScale == samples/second */
  dword     dwStart;
  dword     dwLength; /* In units above... */
  dword     dwSuggestedBufferSize;
  dword     dwQuality;
  dword     dwSampleSize;
  DUMMYRECT rcFrame;
} AVI_StreamHeader;

typedef struct
{
  dword ckid;
  dword dwFlags;
  dword dwChunkOffset;          /* Position of chunk */
  dword dwChunkLength;          /* Length of chunk */
} AVI_INDEXENTRY;

#define RIFF_WAVE               FOURCC('W', 'A', 'V', 'E')
#define RIFF_FORMAT             FOURCC('f', 'm', 't', ' ')
#define RIFF_DATA               FOURCC('d', 'a', 't', 'a')

typedef struct
{
  word  wFormatTag;
  word  nChannels;
  dword nSamplesPerSec;
  dword nAvgBytesPerSec;
  word  nBlockAlign;
  word  wBitsPerSample;
} WAVE_format;

#endif _AVI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech261\audio.c ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: slib_audio.c,v $
 * Revision 1.1.6.14  1996/12/13  18:19:06  Hans_Graves
 * 	Added initialization of AudioPTimeBase.
 * 	[1996/12/13  18:07:26  Hans_Graves]
 *
 * Revision 1.1.6.13  1996/12/04  22:34:30  Hans_Graves
 * 	Make AC3 detection in audio streams more accurate.
 * 	[1996/12/04  22:19:21  Hans_Graves]
 *
 * Revision 1.1.6.12  1996/11/18  23:07:34  Hans_Graves
 * 	Make use of presentation timestamps. Make seeking time-based.
 * 	[1996/11/18  22:47:36  Hans_Graves]
 *
 * Revision 1.1.6.11  1996/11/11  18:21:06  Hans_Graves
 * 	Added AC3 support for multiplexed streams.
 * 	[1996/11/11  18:00:25  Hans_Graves]
 *
 * Revision 1.1.6.10  1996/11/08  21:51:04  Hans_Graves
 * 	Added AC3 support. Better seperation of stream types.
 * 	[1996/11/08  21:28:01  Hans_Graves]
 *
 * Revision 1.1.6.9  1996/10/28  17:32:30  Hans_Graves
 * 	MME-1402, 1431, 1435: Timestamp related changes.
 * 	[1996/10/28  17:23:01  Hans_Graves]
 *
 * Revision 1.1.6.8  1996/10/15  17:34:11  Hans_Graves
 * 	Added MPEG-2 Program Stream support. Fix MPEG-2 not skipping audio.
 * 	[1996/10/15  17:31:11  Hans_Graves]
 *
 * Revision 1.1.6.7  1996/09/29  22:19:39  Hans_Graves
 * 	Removed SLIB_MODE_DECOMPRESS_QUERY.
 * 	[1996/09/29  21:33:10  Hans_Graves]
 *
 * Revision 1.1.6.6  1996/09/25  19:16:46  Hans_Graves
 * 	Added SLIB_INTERNAL define.
 * 	[1996/09/25  19:01:51  Hans_Graves]
 *
 * Revision 1.1.6.5  1996/09/18  23:46:37  Hans_Graves
 * 	Use slibSetMaxInput under MPEG
 * 	[1996/09/18  22:03:03  Hans_Graves]
 *
 * Revision 1.1.6.4  1996/05/24  12:39:52  Hans_Graves
 * 	Disable debugging printfs
 * 	[1996/05/24  12:39:37  Hans_Graves]
 *
 * Revision 1.1.6.3  1996/05/23  18:46:37  Hans_Graves
 * 	Merge fixes MME-1292, MME-1293, and MME-1304.
 * 	[1996/05/23  18:45:22  Hans_Graves]
 *
 * Revision 1.1.6.2  1996/05/10  21:17:20  Hans_Graves
 * 	Fix calculation of audio lengths (NT)
 * 	[1996/05/10  20:44:27  Hans_Graves]
 *
 * Revision 1.1.4.4  1996/04/22  15:04:53  Hans_Graves
 * 	Added slibValidateAudioParams()
 * 	[1996/04/22  14:43:35  Hans_Graves]
 *
 * Revision 1.1.4.3  1996/04/01  16:23:14  Hans_Graves
 * 	NT porting
 * 	[1996/04/01  16:15:58  Hans_Graves]
 *
 * Revision 1.1.4.2  1996/03/29  22:21:33  Hans_Graves
 * 	Added MPEG/JPEG/H261_SUPPORT ifdefs
 * 	[1996/03/29  21:56:58  Hans_Graves]
 *
 * Revision 1.1.2.12  1996/02/21  22:52:45  Hans_Graves
 * 	Fixed MPEG 2 systems stuff
 * 	[1996/02/21  22:51:03  Hans_Graves]
 *
 * Revision 1.1.2.11  1996/02/19  18:03:56  Hans_Graves
 * 	Fixed a number of MPEG related bugs
 * 	[1996/02/19  17:57:40  Hans_Graves]
 *
 * Revision 1.1.2.10  1996/02/13  18:47:48  Hans_Graves
 * 	Added slibSkipAudio()
 * 	[1996/02/13  18:41:27  Hans_Graves]
 *
 * Revision 1.1.2.9  1996/02/07  23:23:56  Hans_Graves
 * 	Added SEEK_EXACT. Fixed most frame counting problems.
 * 	[1996/02/07  23:20:31  Hans_Graves]
 *
 * Revision 1.1.2.8  1996/02/02  17:36:03  Hans_Graves
 * 	Enhanced audio info. Cleaned up API
 * 	[1996/02/02  17:29:46  Hans_Graves]
 *
 * Revision 1.1.2.7  1996/01/31  14:50:39  Hans_Graves
 * 	Renamed SLIB_TYPE_WAVE to SLIB_TYPE_PCM_WAVE
 * 	[1996/01/31  14:50:27  Hans_Graves]
 *
 * Revision 1.1.2.6  1996/01/15  16:26:29  Hans_Graves
 * 	Added MPEG 1 Audio compression support
 * 	[1996/01/15  15:46:07  Hans_Graves]
 *
 * Revision 1.1.2.5  1996/01/11  16:17:31  Hans_Graves
 * 	Added MPEG II Systems decode support
 * 	[1996/01/11  16:12:35  Hans_Graves]
 *
 * Revision 1.1.2.4  1996/01/08  16:41:32  Hans_Graves
 * 	Added MPEG II decoding support
 * 	[1996/01/08  15:53:05  Hans_Graves]
 *
 * Revision 1.1.2.3  1995/11/09  23:14:06  Hans_Graves
 * 	Added MPEG audio decompression
 * 	[1995/11/09  23:08:41  Hans_Graves]
 *
 * Revision 1.1.2.2  1995/11/06  18:47:55  Hans_Graves
 * 	First time under SLIB
 * 	[1995/11/06  18:36:03  Hans_Graves]
 *
 * $EndLog$
 */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/
/*
#define _SLIBDEBUG_
*/

#define SLIB_INTERNAL
#include "slib.h"
#include "mpeg.h"
#include "avi.h"
#ifdef AC3_SUPPORT
#include "ac3.h"
#endif /* AC3_SUPPORT */

#ifdef _SLIBDEBUG_
#define _DEBUG_   1  /* detailed debuging statements */
#define _VERBOSE_ 1  /* show progress */
#define _VERIFY_  1  /* verify correct operation */
#define _WARN_    1  /* warnings about strange behavior */
#endif

#ifdef AC3_SUPPORT
SlibBoolean_t slibParseAC3Header(SlibInfo_t *Info, SlibPin_t *srcpin,
                                 unsigned char *buf, unsigned dword size,
                                 int *channels, int *sps, int *bps)
{
  /*
   * Initial cut at parameters -
   * Update later using header parsing - ***tfm***
   */
  Info->AudioBitRate = 256000;
  *channels = 2;
  *sps = 48000;
  *bps = 16;
  _SlibDebug(_VERBOSE_,
     printf("AC3: bitrate=%d channels=%d sps=%d bps=%s\n",
                   Info->AudioBitRate, channels, sps, bps) );
  return(TRUE);
}
#endif /* AC3_SUPPORT */

void SlibUpdateAudioInfo(SlibInfo_t *Info)
{
  int channels=2, sps=44100, bps=16;
  SlibTime_t ptime=SLIB_TIME_NONE;
  _SlibDebug(_DEBUG_, printf("SlibUpdateAudioInfo()\n") );

  if (SlibTypeIsVideoOnly(Info->Type)) /* no audio? */
    return;
  if (Info->Mode == SLIB_MODE_COMPRESS)
  {
    switch (Info->Type)
    {
      case SLIB_TYPE_G723:
            //Initialize some info
            sps = 8000;
            bps = 16;
            channels =1;
            break;
      default:
            break;
    }
  }
  else if (Info->Mode == SLIB_MODE_DECOMPRESS)
  {
    SlibPin_t *srcpin;
    unsigned char *buf;
    unsigned dword size;

    switch (Info->Type)
    {
      case SLIB_TYPE_RIFF: /* might be WAVE format */
      case SLIB_TYPE_PCM_WAVE: /* might be WAVE format */
            srcpin=slibGetPin(Info, SLIB_DATA_COMPRESSED);
            buf = slibSearchBuffersOnPin(Info, srcpin,
                                         NULL, &size, RIFF_WAVE, 4, FALSE);
            if (buf)
            {
              Info->Type = SLIB_TYPE_PCM_WAVE;
              buf = slibSearchBuffersOnPin(Info, srcpin,
                                           NULL, &size, RIFF_FORMAT, 4, FALSE);
              if (buf)
              {
                dword datasize=((int)buf[3]<<24) | (int)buf[2]<<16 |
                               (int)buf[1]<<8 | (int)buf[0];
                WAVE_format fmt;

                _SlibDebug(_DEBUG_,
                printf("datasize=%d\n", datasize);
                printf("%02X %02X %02X %02X\n", buf[0], buf[1], buf[2], buf[3]);
                printf("WAVE: SamplesPerSec=%d BitsPerSample=%d Channels=%d\n",
                     sps, bps, channels) );
                buf+=4; /* skip size */
                memcpy(&fmt, buf, sizeof(fmt));
                channels = fmt.nChannels;
                sps = fmt.nSamplesPerSec;
                if (datasize<sizeof(WAVE_format)) /* not PCM */
                  bps = 8;
                else
                  bps = fmt.wBitsPerSample;
                if ((sps*channels*bps)>800)
                  Info->AudioLength = (qword)(Info->FileSize*10L)/
                                      (qword)((sps*channels*bps)/800);
                if ((srcpin=slibLoadPin(Info, SLIB_DATA_AUDIO))==NULL)
                  return;
                Info->AudioType=SLIB_TYPE_PCM;
              }
              else
                return; /* couldn't find format */
            }
            break;

#ifdef MPEG_SUPPORT
      case SLIB_TYPE_MPEG1_AUDIO:
      case SLIB_TYPE_MPEG_SYSTEMS:
      case SLIB_TYPE_MPEG_SYSTEMS_MPEG2:
      case SLIB_TYPE_MPEG_TRANSPORT:
      case SLIB_TYPE_MPEG_PROGRAM:
            slibSetMaxInput(Info, 1000*1024);
            if ((srcpin=slibLoadPin(Info, SLIB_DATA_AUDIO))==NULL)
            {
              _SlibDebug(_DEBUG_ || _WARN_,
                 printf("SlibUpdateAudioInfo() no audio data found\n") );
              if ((srcpin=slibLoadPin(Info, SLIB_DATA_PRIVATE))==NULL)
              {
                Info->AudioStreams = 0;
                _SlibDebug(_DEBUG_ || _WARN_,
                   printf("SlibUpdateAudioInfo() no private data found\n") );
                slibSetMaxInput(Info, 0); /* no limit to input data */
                return;
              }
              buf=slibGetBufferFromPin(Info, srcpin, &size, NULL);
              if (buf && size>=4)
              {
                _SlibDebug(_DEBUG_,
                  printf("AC3 Audio Head: %02X %02X %02X %02X\n",
                     buf[0], buf[1], buf[2], buf[3]));
                /* check for AC3 sync code, may be reverse ordered */
                if ((buf[0]==0x0B && buf[1]==0x77) ||
                    (buf[2]==0x0B && buf[3]==0x77) ||
                    (buf[0]==0x77 && buf[1]==0x0B) ||
                    (buf[2]==0x77 && buf[3]==0x0B))
                {
                  Info->AudioType=SLIB_TYPE_AC3_AUDIO;
                  _SlibDebug(_DEBUG_, printf("AC3 Audio Sync Word found\n") );
                }
              }
            }

            if (Info->AudioType==SLIB_TYPE_UNKNOWN ||
                Info->AudioType==SLIB_TYPE_MPEG1_AUDIO)
            {
              /* search for MPEG audio sync word */
              buf = NULL;
              slibSetMaxInput(Info, 10*1024); /* don't search too much */
              do {
                buf = slibSearchBuffersOnPin(Info, srcpin, buf, &size,
                                           0xFF, 1, FALSE);
              } while (buf && (*buf&0xF0) != 0xF0);
              slibSetMaxInput(Info, 0); /* no limit to input data */
              if (buf)
              {
                const char *mode_names[4] =
                { "stereo", "j-stereo", "dual-ch", "single-ch" };
                const char *layer_names[4] = { "?", "I", "II", "III" };
                const int mpeg_freq[4] = {44100, 48000, 32000, 0};
                const int bitrate[4][15] = {
                  {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
                  {0,32,64,96,128,160,192,224,256,288,320,352,384,416,448},
                  {0,32,48,56,64,80,96,112,128,160,192,224,256,320,384},
                  {0,32,40,48,56,64,80,96,112,128,160,192,224,256,320}
                };
                int bitrate_index, layer, mode, freq_index;
                _SlibDebug(_DEBUG_,
                  printf("MPEG Audio Head: %02X %02X %02X %02X\n",
                     buf[0], buf[1], buf[2], buf[3]));
                if ((*buf & 0xF0)==0xF0)
                {
                  layer = 4-((*buf>>1) & 0x03);
                  buf++; size--;
                  bitrate_index = *buf >> 4;
                  freq_index = (*buf>>2) & 0x03;
                  buf++; size--;
                  mode = *buf >> 6;

                  Info->AudioBitRate = bitrate[layer][bitrate_index]*1000;
                  channels = mode==3 ? 1 : 2;
                  sps = mpeg_freq[freq_index];
                  bps = 16;
                  if (Info->AudioBitRate>100)
                    Info->AudioLength = (qword)(Info->FileSize*80L)/
                                        (qword)(Info->AudioBitRate/100);
                  _SlibDebug(_VERBOSE_,
                   printf("layer=%d bitrate=%d(%d) mode=%s freq(%d)=%d\n",
                     layer, bitrate[layer][bitrate_index], bitrate_index,
                     mode_names[mode], freq_index, mpeg_freq[freq_index]) );
                  if (layer<=2 && Info->AudioBitRate>0 &&
                                 Info->AudioBitRate<10000000) /* valid header */
                    Info->AudioType=SLIB_TYPE_MPEG1_AUDIO;
                  else
                    Info->AudioBitRate=0;
                }
              }
            }
            if (Info->AudioType==SLIB_TYPE_UNKNOWN ||
                Info->AudioType==SLIB_TYPE_AC3_AUDIO)
            {
#ifdef AC3_SUPPORT
              _SlibDebug(_VERBOSE_,
                 printf("Searching for AC-3 on %s\n", srcpin->name) );
              /* Search for AC-3 sync word */
              slibSetMaxInput(Info, 1000*1024);
              buf = slibSearchBuffersOnPin(Info, srcpin, NULL, &size,
                               AC3_SYNC_WORD_REV, AC3_SYNC_WORD_LEN/8, FALSE);
              slibSetMaxInput(Info, 0); /* no limit to input data */
              if (buf) /* found sync word */
              {
                Info->AudioType=SLIB_TYPE_AC3_AUDIO;
                _SlibDebug(_VERBOSE_, printf("AC3\n"));
                slibParseAC3Header(Info, srcpin, buf, size,
                                         &channels, &sps, &bps);
                if (srcpin->ID==SLIB_DATA_PRIVATE)
                {
                  /* the private data pin now become the audio pin */
                  slibRenamePin(Info, SLIB_DATA_PRIVATE, SLIB_DATA_AUDIO,
                                        "Audio");
                  /* audio will be pulled from PRIVATE packets */
                  Info->AudioMainStream=MPEG_PRIVATE_STREAM1_BASE;
                }
              }
              else
              {
                slibRemovePin(Info, SLIB_DATA_AUDIO);
                return;
              }
#else /* !AC3_SUPPORT */
              slibRemovePin(Info, SLIB_DATA_AUDIO);
              return;
#endif /* !AC3_SUPPORT */
            }
            break;
#endif /* MPEG_SUPPORT */
#ifdef AC3_SUPPORT
      case SLIB_TYPE_AC3_AUDIO:
            slibSetMaxInput(Info, 1000*1024);
            if ((srcpin=slibLoadPin(Info, SLIB_DATA_AUDIO))==NULL)
            {
              Info->AudioStreams = 0;
              _SlibDebug(_DEBUG_ || _WARN_,
                 printf("SlibUpdateAudioInfo() no audio data found\n") );
              slibSetMaxInput(Info, 0);
              return;
            }

            /* buf = slibGetBufferFromPin(Info, srcpin, &size, NULL); */
		
            /* Search for AC-3 sync word */
            buf = slibSearchBuffersOnPin(Info, srcpin, NULL, &size,
                               AC3_SYNC_WORD_REV, AC3_SYNC_WORD_LEN/8, FALSE);
            slibSetMaxInput(Info, 0);
            if (buf)
            {
              slibParseAC3Header(Info, srcpin, buf, size,
                                         &channels, &sps, &bps);
              if (Info->AudioBitRate>100)
                Info->AudioLength = (qword)(Info->FileSize*80L)/
                                    (qword)(Info->AudioBitRate/100);
            }
            else
            {
              slibRemovePin(Info, SLIB_DATA_AUDIO);
              return;
            }
            Info->AudioType=SLIB_TYPE_AC3_AUDIO;
            break;
#endif /* AC3_SUPPORT */
#ifdef G723_SUPPORT
      case SLIB_TYPE_G723:
            slibSetMaxInput(Info, 1000*1024);
            if ((srcpin=slibLoadPin(Info, SLIB_DATA_AUDIO))==NULL)
            {
              Info->AudioStreams = 0;
              _SlibDebug(_DEBUG_ || _WARN_,
                 printf("SlibUpdateAudioInfo() no audio data found\n") );
              slibSetMaxInput(Info, 0);
              return;
            }
            slibSetMaxInput(Info, 0);
            buf = slibPeekBufferOnPin(Info, srcpin, &size, NULL);
            if (buf)
            {
              /* we need to parse the G.723 frame header to
               * get the actual bitrate
               */
              if(buf[0] & 0x1) /* read the rate bit in the G.723 frame header */
                Info->AudioBitRate=5333;
              else
                Info->AudioBitRate=6400;
              if (Info->AudioBitRate>0)
                Info->AudioLength = (qword)(Info->FileSize*80L)/
                                    (qword)(Info->AudioBitRate/100);
            }
            else
            {
              slibRemovePin(Info, SLIB_DATA_AUDIO);
              return;
            }
            //Initialize some info
            sps = 8000;
            bps = 16;
            channels =1;
            Info->AudioType=SLIB_TYPE_G723;
            break;
#endif /*G723_SUPPORT*/
      default:
            return;
    }
  }
  Info->AudioStreams = 1;
  if (SlibTypeHasTimeStamps(Info->Type))
  {
    ptime=slibGetNextTimeOnPin(Info, slibGetPin(Info, SLIB_DATA_AUDIO), 100*1024);
    if (SlibTimeIsValid(ptime))
      Info->AudioPTimeBase=ptime;
  }
  /* round sample rate to nearest valid rate */
  if (sps<=8000)
    sps=8000;
  else if (sps<=11025)
    sps=11025;
  else if (sps<=22050)
    sps=22050;
  else if (sps<=32000)
    sps=32000;
  else if (sps<=44100)
    sps=44100;
  Info->SamplesPerSec = sps;
  Info->BitsPerSample = bps;
  Info->Channels = channels;
  if (Info->CompAudioFormat==NULL)
    Info->CompAudioFormat=(WAVEFORMATEX *)ScAlloc(sizeof(WAVEFORMATEX));
  if (Info->CompAudioFormat!=NULL)
  {
    Info->CompAudioFormat->wFormatTag = WAVE_FORMAT_PCM;
    Info->CompAudioFormat->nChannels = (WORD)channels;
    Info->CompAudioFormat->wBitsPerSample = (WORD)bps;
    Info->CompAudioFormat->nSamplesPerSec = sps;
    Info->CompAudioFormat->nBlockAlign = bps>>3 * channels;
    Info->CompAudioFormat->nAvgBytesPerSec =
                      Info->CompAudioFormat->nBlockAlign * sps;
  }
  if (Info->AudioFormat==NULL)
    Info->AudioFormat=(WAVEFORMATEX *)ScAlloc(sizeof(WAVEFORMATEX));
  if (Info->AudioFormat!=NULL)
  {
    Info->AudioFormat->wFormatTag = WAVE_FORMAT_PCM;
    Info->AudioFormat->nChannels = (WORD)channels;
    Info->AudioFormat->wBitsPerSample = (WORD)bps;
    Info->AudioFormat->nSamplesPerSec = sps;
    Info->AudioFormat->nBlockAlign = (bps>>3) * channels;
    Info->AudioFormat->nAvgBytesPerSec =
                      Info->AudioFormat->nBlockAlign * sps;
  }
}

SlibTime_t slibSkipAudio(SlibInfo_t *Info, SlibStream_t stream,
                                           SlibTime_t timems)
{
  dword timeskipped=0, samples=0, frames=0;
  SlibPin_t *srcpin;
  if (Info->AudioStreams<=0)
    return(0);
  srcpin=slibLoadPin(Info, SLIB_DATA_AUDIO);
  if (!srcpin)
    return(0);
  _SlibDebug(_VERBOSE_, printf("slibSkipAudio(stream=%d, %d ms)\n",
                                      stream,timems) );
  switch (Info->AudioType)
  {
#ifdef MPEG_SUPPORT
    case SLIB_TYPE_MPEG1_AUDIO:
            {
              unsigned char *buf, *bufstart;
              unsigned dword size, sps, channels, layer;
              static const int layer_samples[4] = {384, 384, 1152, 1152};
              static const int mpeg_freq[4] = {44100, 48000, 32000, 0};
              while (timeskipped<timems)
              {
                do {
                  bufstart=buf=slibSearchBuffersOnPin(Info, srcpin, NULL, &size,
                                               0xFF, 1, TRUE);
                  _SlibDebug(_WARN_ && size==0, printf("SkipAudio() size=0\n"));
                  if (!bufstart)
                    return(timeskipped);
                  if ((buf[0]&0xF0)==0xF0 && buf[0]!=0xFF)
                    break;
                  else
                    slibInsertBufferOnPin(srcpin, buf, size, SLIB_TIME_NONE);
                } while (1);
                frames++;
                layer = 4-((*buf>>1) & 0x03);
                buf++; size--;
                if (!size)
                {
                  SlibFreeBuffer(bufstart);
                  bufstart=buf=slibGetBufferFromPin(Info, srcpin, &size, NULL);
                  if (!bufstart)
                    return(timeskipped);
                }
                sps = mpeg_freq[(*buf>>2) & 0x03];
                buf++; size--;
                if (!size)
                {
                  SlibFreeBuffer(bufstart);
                  bufstart=buf=slibGetBufferFromPin(Info, srcpin, &size, NULL);
                  if (!bufstart)
                    return(timeskipped);
                }
                channels = (*buf >> 6)==3 ? 1 : 2;
                buf++; size--;
                samples+=layer_samples[layer];
                if (sps)
                  timeskipped=(1000*samples)/sps;
                _SlibDebug(_DEBUG_,
                  printf("samples=%d timeskipped=%d\n", samples, timeskipped));
                if (size)
                {
                  SlibAllocSubBuffer(buf, size);
                  slibInsertBufferOnPin(srcpin, buf, size, SLIB_TIME_NONE);
                }
                SlibFreeBuffer(bufstart);
              }
            }
            break;
#endif /* MPEG_SUPPORT */
#ifdef AC3_SUPPORT
    case SLIB_TYPE_AC3_AUDIO:
      /* For better audio/video synchronization - add Dolby AC-3 support here */
            break;
#endif /* AC3_SUPPORT */
    default:
            break;
  }
  _SlibDebug(_VERBOSE_,
        printf("slibSkipAudio() frames=%d samples=%d timeskipped=%d ms\n",
                                     frames, samples, timeskipped));
  return(timeskipped);
}


SlibStatus_t slibValidateAudioParams(SlibInfo_t *Info)
{
  return(SlibErrorNone);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech261\cdd6.c ===
/* File: sv_h261_cdd6.c */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995, 1997                 **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/
/*   Some Modifications were done to incorporate a scaled IDCT scheme
     on the DecodeXXX routines.  These modifications are to
     improve the performance  -S.I.S. September 29, 1993.
*/
/*************************************************************
This file contains the routines to run-length encode the ac and dc
coefficients.
*************************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include "sv_intrn.h"
#include "SC_err.h"
#include "sv_h261.h"
#include "proto.h"

#ifndef WIN32
long __CVTTQ(double);
#endif /* !WIN32 */


/* Scaled stuff  - S.I.S. */
extern const unsigned int tdzz[];
extern const unsigned int tzz[];
float static  quantiscale[32][64];
float static qs[64];
float DCIscale;

/*PRIVATE*/
extern int bit_set_mask[];
extern int extend_mask[];


#define MYPI 3.1415926535897931

void DGenScaleMat()
{
    double dbli, dblj;
    float  dij;
    int i, j, k, quantindex;

    for(k=0;k<64;k++)
	quantiscale[0][k] = (float)1.0;
    for(quantindex=1;quantindex<2;quantindex++)  {
	k=0;
 	for(i=0;i<8;i++)  {
	    for(j=0;j<8;j++)  {
		dbli = MYPI*i/16.0;
		dblj = MYPI*j/16.0;
		dij  =  (float)(16.0*(float)cos(dbli)*cos(dblj));
		if(i==0) dij = (float)(dij/sqrt(2.0));
		if(j==0) dij = (float)(dij/sqrt(2.0));
	        qs[tdzz[k]] = (float)(1.0/dij);
		k++;
	    }
	}
    }
    DCIscale = (float)(4.0*quantiscale[1][0]);
}

SvStatus_t DecodeAC_Scale(SvH261Info_t *H261, ScBitstream_t *bs, int index,
                    int QuantUse, float *fmatrix)
{
  float *mptr;
  register int k, r, l, temp;
  register unsigned short cb;
  DHUFF *huff = H261->T1DHuff;

  for(mptr=fmatrix+index; mptr<fmatrix+H261_BLOCKSIZE; mptr++)
    *mptr = (float)0.0;
  for(k=index; k<H261_BLOCKSIZE; k++)  /* JPEG Mistake */
  {
    DecodeHuffB(bs, huff, r, l, cb, temp);
    if (l & bit_set_mask[7])
      l |= extend_mask[7];
    k += r;
	if (k < H261_BLOCKSIZE)
	   {
       if (QuantUse&1)
          temp = (l>0) ? ( ((l<<1)+1)*QuantUse ) : (  ((l<<1)-1)*QuantUse );
       else
          temp = (l>0) ? ( ((l<<1)+1)*QuantUse -1 ) : (  ((l<<1)-1)*QuantUse +1 );
       fmatrix[tzz[k]] = temp*qs[k];
       H261->NumberNZ++;
	   }
  }
  DecodeHuffA(bs, huff, r, cb, temp);
  return(SvErrorVideoInput);
}

SvStatus_t CBPDecodeAC_Scale(SvH261Info_t *H261, ScBitstream_t *bs,
                             int index, int QuantUse, int BlockType,
                             float *fmatrix)
{
  int k,r,l, temp;
  float  *mptr, *local_qptr;
  register unsigned short cb;
  DHUFF *huff = H261->T2DHuff;

  local_qptr = &quantiscale[QuantUse][0];
  for(mptr=fmatrix+index;mptr<fmatrix+H261_BLOCKSIZE;mptr++) {*mptr = (float)0.0;}
  k = index;
  DecodeHuffB(bs, huff, r, l, cb, temp);
  if (l & bit_set_mask[7])
      l |= extend_mask[7];
  k += r;
  if(((k==0) & (BlockType==1)))
      fmatrix[0] = (float) l;
  else  {
      if(QuantUse&1)  {
          temp = (l>0) ? ( ((l<<1)+1)*QuantUse ) : (  ((l<<1)-1)*QuantUse );
      }
      else   {
          temp = (l>0) ? ( ((l<<1)+1)*QuantUse-1) : (  ((l<<1)-1)*QuantUse+1);
      }
      fmatrix[tzz[k]] = temp*qs[k];
  }
  k++;
  H261->NumberNZ++;
  huff=H261->T1DHuff;
  while(k<H261_BLOCKSIZE)
    {
    DecodeHuffB(bs, huff, r, l, cb, temp);
      if (l & bit_set_mask[7]) {l |= extend_mask[7];}
      k += r;
	  if (k < H261_BLOCKSIZE)
	      {	
          if(QuantUse&1)
		      {
              temp = (l>0) ? ( ((l<<1)+1)*QuantUse ) : (  ((l<<1)-1)*QuantUse );
              }
          else
		      {
              temp = (l>0) ? ( ((l<<1)+1)*QuantUse -1 ) : (  ((l<<1)-1)*QuantUse +1 );
              }
          fmatrix[tzz[k]] = temp*qs[k];
          k++;
          H261->NumberNZ++;
	      }
       }
    DecodeHuffA(bs, huff, r, cb, temp);
      return (SvErrorVideoInput);
}


/*
** Function: DecodeDC_Scale()
** Purpose:  Decodes a dc element from the stream.
*/
float DecodeDC_Scale(SvH261Info_t *H261, ScBitstream_t *bs,
                      int BlockType, int QuantUse)
{
  int l, temp;

  l = (int)ScBSGetBits(bs,8);
  if (bs->EOI) return ((float)l);

  if (l==255) {l=128;}
  if (l!=1){H261->NumberNZ++;}
  if(BlockType) {
       return ((float) l);
  }
  else {
      if(QuantUse&1)  {
	  if(l>0)  {
	       temp = ((l<<1)+1)*QuantUse;
	       return((float)temp*qs[0]);
          }
	  else if(l<0)  {
	       temp = ((l<<1)-1)*QuantUse;
	       return((float)temp*qs[0]);
          }
      }
      else   {
	  if(l>0)  {
	       temp = ((l<<1)+1)*QuantUse -1;
	       return((float)temp*qs[0]);
          }
	  else  if(l<0) {
	       temp = ((l<<1)-1)*QuantUse +1;
	       return((float)temp*qs[0]);
          }
      }
  }
  return((float)0);
}

int DecodeDC(SvH261Info_t *H261, ScBitstream_t *bs)
{
  int l;

  l = (int)ScBSGetBits(bs,8);
  if (l==255) {l=128;}
  if (l!=1){H261->NumberNZ++;}
  return(l);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech261\cdenc.c ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: sv_h261_cdenc.c,v $
 * Revision 1.1.4.3  1995/12/18  21:39:02  Karen_Dintino
 * 	Porting to NT - added casting, removed unused vars, fixed includes
 * 	[1995/12/18  21:36:50  Karen_Dintino]
 *
 * Revision 1.1.4.2  1995/09/13  14:52:04  Hans_Graves
 * 	Some code optimizations.
 * 	[1995/09/13  14:33:22  Hans_Graves]
 * 
 * Revision 1.1.2.7  1995/08/15  19:14:01  Karen_Dintino
 * 	fix reentrant problem
 * 	[1995/08/15  18:35:32  Karen_Dintino]
 * 
 * Revision 1.1.2.6  1995/08/04  16:32:32  Karen_Dintino
 * 	Return approp errors on end of stream
 * 	[1995/08/04  16:27:06  Karen_Dintino]
 * 
 * Revision 1.1.2.5  1995/08/03  18:02:13  Karen_Dintino
 * 	Fix error handling
 * 	[1995/08/03  17:58:43  Karen_Dintino]
 * 
 * Revision 1.1.2.4  1995/07/17  16:12:25  Hans_Graves
 * 	Switched compression to ScBS* bitstreaming routines.
 * 	[1995/07/17  15:45:50  Hans_Graves]
 * 
 * Revision 1.1.2.3  1995/07/11  22:11:41  Karen_Dintino
 * 	Start to clean up prototypes
 * 	[1995/07/11  22:01:21  Karen_Dintino]
 * 
 * Revision 1.1.2.2  1995/06/19  20:31:26  Karen_Dintino
 * 	H.261 slib codec
 * 	[1995/06/19  19:49:18  Karen_Dintino]
 * 
 * $EndLog$
 */
/*
**++
** FACILITY:  Workstation Multimedia  (WMM)  v1.0
**
** FILE NAME: sv_h261_cdenc.c
** MODULE NAME:
**
** MODULE DESCRIPTION:
**
** DESIGN OVERVIEW:
**
**--
*/
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1994, 1997                 **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/
/*   Some Modifications were done to incorporate a scaled IDCT scheme 
     on the DecodeXXX routines.  These modifications are to 
     improve the performance  -S.I.S. September 29, 1993.   
*/   
/*************************************************************
This file contains the routines to run-length encode the ac and dc
coefficients.
*************************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <math.h>  

#include "sv_intrn.h"
#include "SC_err.h"
#include "sv_h261.h"
#include "proto.h"

#define fgetv mgetv
#define fgetb mgetb
#define fputvb mputvb
#define fputbb mputbb

#define MYPI 3.1415926535897931
#define RSQ2 0.7071067811865
#define COSM1P3 1.3065629648764
#define COS1M3  0.5411961001462
#define COS3 0.3826834323651
#define sround(x) ( (x >= 0) ? (int) (x+0.5) : (int) (x-0.5) )    
#define SCLAMP(x) ( (x>127) ? 127 : ((x<-128) ? -128 : x) )  
#define Abs(value) ( (value < 0) ? (-value) : value)
/*PUBLIC*/


const unsigned int tdzz[64] = {
    0, 1, 5, 6, 14, 15, 27, 28,
    2, 4, 7, 13, 16, 26, 29, 42,
    3, 8, 12, 17, 25, 30, 41, 43,
    9, 11, 18, 24, 31, 40, 44, 53,
    10, 19, 23, 32, 39, 45, 52, 54,
    20, 22, 33, 38, 46, 51, 55, 60,
    21, 34, 37, 47, 50, 56, 59, 61,
    35, 36, 48, 49, 57, 58, 62, 63};

const unsigned int tzz[64] = {
    0, 1, 8, 16, 9, 2, 3, 10,
    17, 24, 32, 25, 18, 11, 4, 5,
    12, 19, 26, 33, 40, 48, 41, 34,
    27, 20, 13, 6, 7, 14, 21, 28,
    35, 42, 49, 56, 57, 50, 43, 36,
    29, 22, 15, 23, 30, 37, 44, 51,
    58, 59, 52, 45, 38, 31, 39, 46,
    53, 60, 61, 54, 47, 55, 62, 63};
float static  qscale[32][64];
float static qs[64], invq[32]; 
float DCIscale;
  
/*PRIVATE*/

extern int bit_set_mask[];
/*
extern DHUFF *T1DHuff;
extern DHUFF *T2DHuff;

extern EHUFF *T1EHuff;
extern EHUFF *T2EHuff;
*/
int extend_mask[] = {
0xFFFFFFFE,
0xFFFFFFFC,
0xFFFFFFF8,
0xFFFFFFF0,
0xFFFFFFE0,
0xFFFFFFC0,
0xFFFFFF80,
0xFFFFFF00,
0xFFFFFE00,
0xFFFFFC00,
0xFFFFF800,
0xFFFFF000,
0xFFFFE000,
0xFFFFC000,
0xFFFF8000,
0xFFFF0000,
0xFFFE0000,
0xFFFC0000,
0xFFF80000,
0xFFF00000
};


/*START*/

void GenScaleMat() 
{
    BEGIN("GenScaleMat"); 
    double dbli, dblj;
    float  dij;
    int i, j, k, quantindex;

    for(quantindex=1;quantindex<32;quantindex++)  {
	k=0; 
        invq[quantindex] = (float) 1.0/(float)(2.0*quantindex);  
 	for(i=0;i<8;i++)  {
	    for(j=0;j<8;j++)  { 
		dbli = MYPI*i/16.0; 
		dblj = MYPI*j/16.0; 
		dij  =  (float)(16.0*(float)(cos(dbli)*cos(dblj))); 
		if(i==0) dij = (float)(dij/sqrt(2.0));  
		if(j==0) dij = (float)(dij/sqrt(2.0));  
	        qs[k]  = (float)(1.0/dij);  
                qscale[quantindex][k]  = (float)(1.0/(2.0*quantindex*dij));   
		k++; 
	    }
	}  
    } 
}  


/*
** Function: EncodeAC()
** Purpose:  Encodes the quantized coefficient matrix input by the first
**           Huffman table.  The index is an offset into the matrix.
*/
SvStatus_t EncodeAC(SvH261Info_t *H261, ScBitstream_t *bs, int index, 
                                          int *matrix)
{
  BEGIN("EncodeAC");
  int k,r,l,code,retval;
  ScBSPosition_t Start;
  int tempbits;  

  Start=ScBSBitPosition(bs);  /* swtellb(H261); */
  for(r=0,k=index-1;++k<H261_BLOCKSIZE;)
    {
      l = matrix[k];
      if (!l) {r++;}
      else
        {
          code = Abs(l) | (r << 8);
          if (code != HUFFMAN_ESCAPE) {retval=sv_H261HuffEncode(H261,bs,code,H261->T1EHuff);}
          else {retval=0;}
          if (!retval)
            {
              sv_H261HuffEncode(H261,bs,HUFFMAN_ESCAPE,H261->T1EHuff);
              ScBSPutBits(bs,r,6);  /* fputvb(H261,6,r); */
              ScBSPutBits(bs,l,8);  /* fputvb(H261,8,l); */
            }
          else
            {
              if (l < 0)
                ScBSPutBit(bs,1); /*  fputbb(H261,1); */
              else
                ScBSPutBit(bs,0); /* fputbb(H261,0); */
            }
          r=0;
          H261->NumberNZ++;
        }
    }
  H261->CurrentBlockBits = ScBSBitPosition(bs)-Start; /* swtellb(H261)-Start */ 
  H261->CodedBlockBits+=H261->CurrentBlockBits;
  tempbits = sv_H261HuffEncode(H261,bs,0,H261->T1EHuff);
  H261->EOBBits += tempbits;  
  H261->CurrentBlockBits += tempbits;  
  return (NoErrors);
}


/*
** Function: CBPEncodeAC()
** Purpose:  Encodes the AC block matrix when we know there exists a
**           non-zero coefficient in the matrix. Thus the EOB cannot 
**           occur as the first element and we save countless bits...
*/
SvStatus_t CBPEncodeAC(SvH261Info_t *H261, ScBitstream_t *bs, 
                 int index, int *matrix)
{
  int k,r,l,code,ovfl;
  ScBSPosition_t Start;
  int tempbits;  
  _SlibDebug(_DEBUG_, printf("CBPEncodeAC()") );

  Start=ScBSBitPosition(bs);  /* Start=swtellb(H261); */
  for (ovfl=1, r=0, k=index-1; ++k<H261_BLOCKSIZE; )
  {
    l = matrix[k];
    if (!l)
      r++;
    else
    {
      code = Abs(l) | (r << 8);
      if (code == HUFFMAN_ESCAPE || !sv_H261HuffEncode(H261,bs,code,H261->T2EHuff)) 
      {
        sv_H261HuffEncode(H261,bs,HUFFMAN_ESCAPE,H261->T2EHuff);
        ScBSPutBits(bs,r,6);  /* fputvb(H261,6,r); */
        ScBSPutBits(bs,l,8);  /* fputvb(H261,8,l); */
      }
      else if (l < 0)
        ScBSPutBit(bs,1); /*  fputbb(H261,1); */
      else
        ScBSPutBit(bs,0); /* fputbb(H261,0); */
      ovfl=0;
      H261->NumberNZ++;
      break;
    }
  }
  if (ovfl)
  {
    _SlibDebug(_VERIFY_, printf("CBP block without any coefficients.\n") );
    return(SvErrorVideoInput);
  }
  for(r=0; ++k<H261_BLOCKSIZE; )
  {
    l = matrix[k];
    if (!l)
      r++;
    else
    {
      code = Abs(l) | (r << 8);
      if (code == HUFFMAN_ESCAPE || !sv_H261HuffEncode(H261,bs,code,H261->T1EHuff)) 
      {
        sv_H261HuffEncode(H261,bs,HUFFMAN_ESCAPE,H261->T1EHuff);
        ScBSPutBits(bs, r, 6);  /* fputvb(H261,6,r); */
        ScBSPutBits(bs, l, 8);  /* fputvb(H261,8,l); */
      }
      else if (l < 0)
        ScBSPutBit(bs,1); /*  fputbb(H261,1); */
      else
        ScBSPutBit(bs,0); /* fputbb(H261,0); */
      r=0;
      H261->NumberNZ++;
    }
  }
  H261->CurrentBlockBits = ScBSBitPosition(bs)-Start; /* swtellb(H261)-Start;*/ 
  H261->CodedBlockBits+=H261->CurrentBlockBits;
  tempbits = sv_H261HuffEncode(H261,bs,0,H261->T1EHuff);
  H261->EOBBits += tempbits;  
  H261->CurrentBlockBits += tempbits;  
  return (NoErrors);
}


/*
** Function: EncodeDC()
** Purpose:  Encodes the coefficient input into the output stream.
*/
void EncodeDC(SvH261Info_t *H261, ScBitstream_t *bs, int coef)
{
  _SlibDebug(_DEBUG_, printf("EncodeDC()") );
  if (coef > 254)
  {
    ScBSPutBits(bs, 254, 8);
    H261->NumberNZ++;
  }
  else if (coef <= 1)
    ScBSPutBits(bs, 1, 8);
  else if (coef==128)
  {
    ScBSPutBits(bs, 255, 8);
    H261->NumberNZ++;
  }
  else
  {
    ScBSPutBits(bs, coef, 8);
    H261->NumberNZ++;
  }
  H261->CodedBlockBits+=8;
}


void InterQuant(float *tdct, int *dct, int mq)  
{
  int i;
  float *pqs=qscale[mq];
  _SlibDebug(_DEBUG_, printf("InterQuant()") );

  for(i=H261_BLOCKSIZE; i; i--)
    *dct++ = (int)((*tdct++)*(*pqs++)); 
}   

void IntraQuant(float *tdct, int *dct, int mq)  
{
  int i,temp; 
  float *pqs=&qscale[mq][1];
  _SlibDebug(_DEBUG_, printf("IntraQuant()") );
   
  if (tdct[0] > 0)     
    i = (int) (tdct[0] * qscale[4][0] + 0.5);  
  else  
    i = (int) (tdct[0] * qscale[4][0] - 0.5);  
  if (i>254)
    *dct = 254;
  else if (i<1)
    *dct = 1;
  else
    *dct = i;

  for(i=1, dct++, tdct++; i<H261_BLOCKSIZE; i++){
    if(mq < 3){
      temp  = (int)((*tdct++)*(*pqs++)); 
  	  if(temp > 127) *dct++ = 127;
	  else if (temp < -127) *dct++ = -127;
      else *dct++ = temp;
     }
     else *dct++ = (int)((*tdct++)*(*pqs++)); 
  }
}  


/*
** Function: ZigzagMatrix()
** Purpose:  Performs a zig-zag translation on the input imatrix
**           and puts the output in omatrix.
*/
void ZigzagMatrix(int *imatrix, int *omatrix)
{
  const unsigned int *ptdzz=tdzz;
  int k;
  _SlibDebug(_DEBUG_, printf("ZigzagMatrix") );

  for(k=H261_BLOCKSIZE; k; k--)
    omatrix[*ptdzz++] = *imatrix++;
}


void Inv_Quant(int *matrix, int QuantUse, int BlockType, float *fmatrix)
{
  int k, l, temp;
  float *pqs=qs+1;
  _SlibDebug(_DEBUG_, printf("Inv_Quant()") );

 /* for(mptr=fmatrix;mptr<fmatrix+H261_BLOCKSIZE;mptr++) {*mptr = 0.0;}*/

  if (matrix[0])
  {
    if (BlockType==1)
      fmatrix[0] = (float)matrix[0];
    else
    {
      l = matrix[0];
      if (QuantUse&1)
        temp = (l>0) ? (((l*2)+1)*QuantUse):(((l*2)-1)*QuantUse);
      else
        temp = (l>0) ? (((l*2)+1)*QuantUse-1):(((l*2)-1)*QuantUse+1);
      fmatrix[0] = temp*qs[0];
    }
  }
  else
    fmatrix[0] = (float)0.0;
      
  matrix++;
  fmatrix++;
  if (QuantUse&1)
  {
    for (k=1; k<64; k++)
    {
      if ((l=*matrix++)>0)
        *fmatrix++ = (((l<<1)+1)*QuantUse) * (*pqs++);
      else if (l)
        *fmatrix++ = (((l<<1)-1)*QuantUse) * (*pqs++);
      else
      {
        *fmatrix++ = (float)0.0;
        pqs++;
      }
    }
  }
  else
  {
    for (k=1; k<64; k++)  
    {
      if ((l=*matrix++)>0)
        *fmatrix++ = (((l<<1)+1)*QuantUse-1) * (*pqs++);
      else if (l)
        *fmatrix++ = (((l<<1)-1)*QuantUse+1) * (*pqs++);
      else
      {
        *fmatrix++ = (float)0.0;
        pqs++;
      }
    }
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech261\compress.c ===
/* File: sv_h261_compress.c */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995, 1997                 **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/
/*
#define VIC 1
#define USE_C
#define _SLIBDEBUG_
*/

#include <math.h>

#include "sv_intrn.h"
#include "SC.h"
#include "SC_conv.h"
#include "SC_err.h"
#include "sv_h261.h"
#include "proto.h"
#include "sv_proto.h"

#ifdef WIN32
#include <mmsystem.h>
#endif

#ifdef _SLIBDEBUG_
#include <stdio.h>
#include <stdlib.h>

#define _DEBUG_   0  /* detailed debuging statements */
#define _VERBOSE_ 0  /* show progress */
#define _VERIFY_  1  /* verify correct operation */
#define _WARN_    0  /* warnings about strange behavior */
#endif

#define Limit_Alpha(x) ( (x>20.0) ? 20.0 : ((x<0.5) ? 0.5 : x) )
#define Limit_Bits(x) ( (x>250.0) ? 250.0 : ((x<5.0) ? 5.0 : x) )
#define Bpos_Y(h261, g, m) (h261->ImageType==IT_QCIF ? (g * 33) + (m % 33) \
                            : (g/2)*66 + (m % 11) + (g&1)*11 + (m/11) * 22)
static void ExecuteQuantization_GOB();
void CopySubClip_C();
void CopyRev_C();
#define SKIP_THRESH 0.51
#define SKIP_THRESH_INT 2
#define QUANT_CHANGE_THRESH 100.0
#define Intra_Start 1

#define FC 6.6e-9
#define TotalCodedMB_Threshold 2
/* MC Threshold for coding blocks through filter*/

#define D_FILTERTHRESHOLD 1
/* Intra forced every so many blocks */

#define SEQUENCE_INTRA_THRESHOLD 131

extern int bit_set_mask[];
int QuantMType[] =    {0,1,0,1,0,0,1,0,0,1}; /* Quantization used */
int CBPMType[] =      {0,0,1,1,0,1,1,0,1,1}; /* CBP used in coding */
int IntraMType[] =    {1,1,0,0,0,0,0,0,0,0}; /* Intra coded macroblock */
int MFMType[] =       {0,0,0,0,1,1,1,1,1,1}; /* Motion forward vector used */
int FilterMType[] =   {0,0,0,0,0,0,0,1,1,1}; /* Filter flags */
int TCoeffMType[] =   {1,1,1,1,0,1,1,0,1,1}; /* Transform coeff. coded */

struct CodeBook  {
	float AcEnergy;
	float BitsMB;
	float QuantClass;
} CBook[100] = {
(float)3.057549,  (float)13.650990,  (float)16.000000,
(float)2.736564,  (float)15.620879,  (float)10.000000,
(float)3.032565,  (float)13.728155,  (float)14.000000,
(float)2.945122,  (float)14.390745,  (float)17.000000,
(float)4.236328,  (float)25.890757,  (float)17.000000,
(float)2.935733,  (float)14.596116,  (float)18.000000,
(float)2.994938,  (float)14.515091,  (float)19.000000,
(float)3.440835,  (float)15.698944,  (float)21.000000,
(float)3.235103,  (float)13.875000,  (float)22.000000,
(float)3.362380,  (float)11.448718, (float)23.000000,
(float)4.262544,  (float)17.246819,  (float)23.000000,
(float)3.933512,  (float)15.207619,  (float)25.000000,
(float)3.825050,  (float)14.351406,  (float)26.000000,
(float)3.840182,  (float)14.048289,  (float)27.000000,
(float)3.717020,  (float)14.076046,  (float)28.000000,
(float)3.942766,  (float)14.216071,  (float)29.000000,
(float)3.934838,  (float)13.509554,  (float)30.000000,
(float)3.899720,  (float)14.233502,  (float)31.000000,
(float)2.737911,  (float)16.522635,  (float)5.000000,
(float)2.607979,  (float)15.374468,  (float)6.000000,
(float)2.864391,  (float)15.432000,  (float)7.000000,
(float)2.752342,  (float)15.809941,  (float)8.000000,
(float)2.682438,  (float)16.186302,  (float)9.000000,
(float)3.581855,  (float)34.849625,  (float)10.000000,
(float)2.853593,  (float)14.700565,  (float)11.000000,
(float)2.908124,  (float)14.091216,  (float)12.000000,
(float)3.099578,  (float)15.157043,  (float)15.000000,
(float)3.916690,  (float)23.636772,  (float)16.000000,
(float)5.574149,  (float)251.866074, (float) 5.000000,
(float)3.964282,  (float)25.137724,  (float)18.000000,
(float)4.080521,  (float)24.059999,  (float)19.000000,
(float)5.759516,  (float)37.446808,  (float)19.000000,
(float)7.210877,  (float)58.061539,  (float)19.000000,
(float)2.878292,  (float)13.737089,  (float)20.000000,
(float)4.076149,  (float)22.525490,  (float)20.000000,
(float)5.269855,  (float)24.170732,  (float)22.000000,
(float)7.206488,  (float)30.965218,  (float)23.000000,
(float)8.118586,  (float)40.752293,  (float)22.000000,
(float)3.133760,  (float)12.679641,  (float)24.000000,
(float)4.624318,  (float)18.820961,  (float)24.000000,
(float)7.050338,  (float)30.319149,  (float)24.000000,
(float)6.955218,  (float)28.934525,  (float)25.000000,
(float)6.830490,  (float)24.564627,  (float)26.000000,
(float)6.244225,  (float)22.895706,  (float)27.000000,
(float)8.060182,  (float)32.934959,  (float)26.000000,
(float)6.349021,  (float)23.500000,  (float)28.000000,
(float)6.514215,  (float)23.680555,  (float)29.000000,
(float)8.116955,  (float)36.047619,  (float)28.000000,
(float)6.143418,  (float)19.691589,  (float)30.000000,
(float)6.238575,  (float)20.666666,  (float)31.000000,
(float)8.063477,  (float)28.651785,  (float)31.000000,
(float)10.753970,  (float)45.786884,  (float)30.000000,
(float)2.728013,  (float)14.628572,  (float)3.000000,
(float)2.851330,  (float)14.559524,  (float)4.000000,
(float)2.524028,  (float)28.197674,  (float)3.000000,
(float)2.218242,  (float)38.810001,  (float)5.000000,
(float)2.457342,  (float)53.670456,  (float)5.000000,
(float)2.437406,  (float)33.156628,  (float)6.000000,
(float)2.861240,  (float)33.810810,  (float)7.000000,
(float)2.996593,  (float)46.674419,  (float)7.000000,
(float)3.321854,  (float)60.000000,  (float)6.000000,
(float)3.035449,  (float)35.875000,  (float)8.000000,
(float)3.199618 , (float)33.715328,  (float)9.000000,
(float)3.625941,  (float)50.168674, (float)9.000000,
(float)3.577415,  (float)60.454544,  (float)8.000000,
(float)4.022958,  (float)50.719299,  (float)10.000000,
(float)4.749763,  (float)69.863640,  (float)10.000000,
(float)3.209624,  (float)24.840708,  (float)11.000000,
(float)3.293082,  (float)22.490385,  (float)12.000000,
(float)3.845358, (float)34.169117,  (float)12.000000,
(float)4.811161,  (float)38.609524,  (float)13.000000,
(float)4.716694,  (float)49.273685,  (float)11.000000,
(float)5.540541,  (float)68.905403,  (float)11.000000,
(float)2.989831,  (float)13.654839,  (float)13.000000,
(float)3.670721,  (float)23.812500,  (float)13.000000,
(float)3.589297,  (float)21.033333,  (float)14.000000,
(float)4.645432,  (float)30.153847,  (float)14.000000,
(float)4.498426,  (float)30.930555,  (float)15.000000,
(float)4.926270,  (float)35.812500,  (float)16.000000,
(float)5.255817,  (float)43.228260,  (float)14.000000,
(float)6.547225,  (float)57.948719,  (float)14.000000,
(float)6.379679,  (float)71.934067, (float) 12.000000,
(float)7.022222,  (float)76.955559,  (float)14.000000,
(float)6.077474,  (float)46.511112,  (float)16.000000,
(float)7.406376,  (float)79.258064,  (float)16.000000,
(float)2.280469,  (float)64.266670,  (float)3.000000,
(float)2.396216,  (float)75.647057,  (float)4.000000,
(float)3.033032,  (float)74.105263,  (float)6.000000,
(float)3.093046,  (float)90.606560,  (float)5.000000,
(float)3.843145,  (float)79.211266,  (float)7.000000,
(float)4.781610,  (float)87.513161,  (float)9.000000,
(float)3.846819,  (float)101.846939,  (float)7.000000,
(float)4.856852,  (float)114.625000,  (float)8.000000,
(float)5.609015,  (float)90.250000, (float)10.000000,
(float)7.049340,  (float)97.333336,  (float)12.000000,
(float)6.508484,  (float)113.569893, (float) 10.000000,
(float)7.099700,  (float)136.116272,  (float)10.000000,
(float)8.087169,  (float)100.054344,  (float)13.000000,
(float)9.193896,  (float)135.032974,  (float)12.000000,
(float)11.427065,  (float)162.600006,  (float)14.000000
};

#define Abs(value) ( (value < 0) ? (-value) : value)

#define BufferContents() (ScBSBitPosition(bs) + H261->BufferOffset -\
(((H261->CurrentGOB*H261->NumberMDU)+H261->CurrentMDU) \
                           *H261->bit_rate*H261->FrameSkip\
	/(H261->NumberGOB*H261->NumberMDU*H261->FrameRate_Fix)))

#define BufferSize() (H261->bit_rate/1) /*In bits */

/******** For sending RTP info. ************/

static SvStatus_t sv_H261WriteExtBitstream(SvH261Info_t *H261, ScBitstream_t *bs);


extern ScStatus_t ScConvert422ToYUV_char (u_char *RawImage,
                         u_char *Y, u_char *U, u_char *V,
                         int Width, int Height);

/***** forward declarations ******/
static SvStatus_t p64EncodeFrame(SvCodecInfo_t *Info, u_char *InputImage,
                            u_char *CompData);
static SvStatus_t p64EncodeGOB(SvH261Info_t *H261, ScBitstream_t *bs);
static SvStatus_t p64EncodeMDU (SvH261Info_t *H261, ScBitstream_t *bs);
static SvStatus_t p64CompressMDU(SvH261Info_t *H261, ScBitstream_t *bs);
static void ExecuteQuantization_GOB(SvH261Info_t *H261);
static int findcode(SvH261Info_t *H261, struct CodeBook *lcb);
static SvStatus_t ntsc_grab (u_char *RawImage,
                         u_char *Comp1, u_char *Comp2, u_char *Comp3,
                         int Width, int Height);
static void VertSubSampleK (unsigned char *Incomp, unsigned char *workloc,
                           int Width, int Height);

#if 0
SvStatus_t SvSetFrameSkip (SvHandle_t Svh, int FrameSkip)
    {
    SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;
    SvH261Info_t *H261 = (SvH261Info_t *) Info->h261;

    H261->FrameSkip = FrameSkip;

    return (NoErrors);
    }

SvStatus_t SvSetFrameCount (SvHandle_t Svh, int FrameCount)
    {
    SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;
    SvH261Info_t *H261 = (SvH261Info_t *) Info->h261;

    H261->LastFrame = FrameCount;
    return (NoErrors);
    }

SvStatus_t SvSetSearchLimit (SvHandle_t Svh, int SearchLimit)
    {
    SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;
    SvH261Info_t *H261 = (SvH261Info_t *) Info->h261;

    if ((SearchLimit <= 0) || (SearchLimit > 20))
	return (SvErrorBadArgument);
    H261->search_limit = SearchLimit;
    return (NoErrors);
    }

SvStatus_t SvSetMotionEstimationType (SvHandle_t Svh, int MotionEstType)
{
    SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;
    SvH261Info_t *H261 = (SvH261Info_t *) Info->h261;

    if (MotionEstType < 0)
	return (SvErrorBadArgument);
    H261->ME_method = MotionEstType;
    return (NoErrors);
}

SvStatus_t SvSetMotionThreshold (SvHandle_t Svh, int Threshold)
{
    SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;
    SvH261Info_t *H261 = (SvH261Info_t *) Info->h261;

    if (Threshold < 0)
	return (SvErrorBadArgument);
    H261->ME_threshold = Threshold;
    return (NoErrors);
}


SvStatus_t SvSetImageType (SvHandle_t Svh, int ImageType)
{
    SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;
    SvH261Info_t *H261 = (SvH261Info_t *) Info->h261;
    int i;

    if (!Info)
	return (SvErrorCodecHandle);

    H261->ImageType = ImageType;

   switch(H261->ImageType)
        {
        case IT_NTSC:
            H261->NumberGOB = 10;  /* Parameters for NTSC design */
            H261->NumberMDU = 33;
            H261->YWidth = 352;
            H261->YHeight = 240;
            H261->CWidth = H261->YWidth/2;
            H261->CHeight = H261->YHeight/2;
            break;
        case IT_CIF:
            H261->NumberGOB = 12;  /* Parameters for CIF design */
            H261->NumberMDU = 33;
            H261->YWidth = 352;
            H261->YHeight = 288;
            H261->CWidth = H261->YWidth/2;
            H261->CHeight = H261->YHeight/2;
            break;
         case IT_QCIF:
            H261->NumberGOB = 3;  /* Parameters for QCIF design */
            H261->NumberMDU = 33;
            H261->YWidth = 176;
            H261->YHeight = 144;
            H261->CWidth = H261->YWidth/2;
            H261->CHeight = H261->YHeight/2;
            break;
        default:
           /*WHEREAMI();*/
	   _SlibDebug(_VERIFY_,
                  printf("Unknown ImageType: %d\n",H261->ImageType) );
           return (SvErrorUnrecognizedFormat);
        }
    H261->YW4  = H261->YWidth/4;
    H261->CW4  = H261->CWidth/4;
    H261->LastIntra = (unsigned char **)
        ScCalloc(H261->NumberGOB*sizeof(unsigned char *));

    for(i=0;i<H261->NumberGOB;i++)
        {
        H261->LastIntra[i] = (unsigned char *)
            ScCalloc(H261->NumberMDU*sizeof(unsigned char));
        memset(H261->LastIntra[i],0,H261->NumberMDU);
        }
    _SlibDebug(_VERBOSE_, printf("H261->NumberGOB=%d\n",H261->NumberGOB) );

    switch(H261->ImageType)
        {
        case IT_NTSC:
            H261->PType=0x04;
            H261->PSpareEnable=1;
            H261->PSpare=0x8c;
            break;
        case IT_CIF:
            H261->PType=0x04;
            break;
         case IT_QCIF:
            H261->PType=0x00;
            break;
        default:
            /*WHEREAMI();*/
	    _SlibDebug(_VERIFY_,
               printf("Image Type not supported: %d\n", H261->ImageType) );
	    return (SvErrorUnrecognizedFormat);
        }
    return (NoErrors);
}
#endif

SvStatus_t svH261CompressFree(SvHandle_t Svh)
{
  SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;
  SvH261Info_t *H261 = (SvH261Info_t *) Info->h261;
  if (!H261->inited)
    return(NoErrors);

  if (H261->CurrentFrame > H261->LastFrame+1)
    H261->CurrentFrame = H261->LastFrame+1;
  H261->TemporalReference = H261->CurrentFrame % 32;
  H261->ByteOffset = 0;
  WritePictureHeader(H261, Info->BSOut);

  sv_H261HuffFree(Info->h261);
  if (Info->h261->LastIntra)
  {
    int i;
    for(i=0; i<Info->h261->NumberGOB; i++)
      ScFree(Info->h261->LastIntra[i]);
    ScFree(Info->h261->LastIntra);
  }
  if (Info->h261->Y)
    ScFree(Info->h261->Y);
  if (Info->h261->U)
    ScFree(Info->h261->U);
  if (Info->h261->V)
    ScFree(Info->h261->V);
  if (Info->h261->YREF)
    ScFree(Info->h261->YREF);
  if (Info->h261->UREF)
    ScFree(Info->h261->UREF);
  if (Info->h261->VREF)
    ScFree(Info->h261->VREF);
  if (Info->h261->YRECON)
    ScFree(Info->h261->YRECON);
  if (Info->h261->URECON)
    ScFree(Info->h261->URECON);
  if (Info->h261->VRECON)
    ScFree(Info->h261->VRECON);
  if (Info->h261->YDEC)
    ScFree(Info->h261->YDEC);
  if (Info->h261->UDEC)
    ScFree(Info->h261->UDEC);
  if (Info->h261->VDEC)
    ScFree(Info->h261->VDEC);
  if (Info->h261->workloc)
    ScFree(Info->h261->workloc);
  if (Info->h261->RTPInfo)
    ScFree(Info->h261->RTPInfo);

  H261->inited=FALSE;
  return (NoErrors);
}

SvStatus_t SvGetFrameNumber (SvHandle_t Svh, u_int *FrameNumber)
{
  SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;
	
  *FrameNumber = Info->h261->CurrentFrame;
  return (NoErrors);
}

/*
** Purpose:  Writes the RTP payload info out to the stream.
*/
static SvStatus_t sv_H261WriteExtBitstream(SvH261Info_t *H261, ScBitstream_t *bs)
{
  ScBSPosition_t NumberBits, i;

  /* use this macro to byte reverse words */
#define PutBits32(BS, a)  ScBSPutBits(BS, (a) & 0xff, 8);  \
                          ScBSPutBits(BS, (a>>8)&0xff, 8); \
                          ScBSPutBits(BS, (a>>16)&0xff, 8); \
                          ScBSPutBits(BS, (a>>24)&0xff, 8);

  /* Need to bitstuff here to make sure that these structures are
  DWORD aligned */
  NumberBits=ScBSBitPosition(bs);
  if ((NumberBits%32)!=0)
    ScBSPutBits(bs, 0, 32-((unsigned int)NumberBits % 32));  /* align on a DWORD boundary */

  for (i = 0; i < (int)H261->RTPInfo->trailer.dwNumberOfPackets; i++)
  {
	ScBSPutBits(bs,0,32) ;                            /* dwFlags */
    PutBits32(bs,H261->RTPInfo->bsinfo[i].dwBitOffset);
    ScBSPutBits(bs,H261->RTPInfo->bsinfo[i].MBAP,8);
    ScBSPutBits(bs,H261->RTPInfo->bsinfo[i].Quant,8);
    ScBSPutBits(bs,H261->RTPInfo->bsinfo[i].GOBN,8);
    ScBSPutBits(bs,H261->RTPInfo->bsinfo[i].HMV,8);
    ScBSPutBits(bs,H261->RTPInfo->bsinfo[i].VMV,8);
    ScBSPutBits(bs,0,8);                              /* padding0 */
    ScBSPutBits(bs,0,16);                             /* padding1 */
  }
  /* write RTP extension trailer */
  PutBits32(bs, H261->RTPInfo->trailer.dwVersion);
  PutBits32(bs, H261->RTPInfo->trailer.dwFlags);
  PutBits32(bs, H261->RTPInfo->trailer.dwUniqueCode);
  PutBits32(bs, (H261->RTPInfo->trailer.dwCompressedSize+7)/8); 	/*tfm - padded up to whole byte */
  PutBits32(bs, H261->RTPInfo->trailer.dwNumberOfPackets);

  ScBSPutBits(bs, H261->RTPInfo->trailer.SourceFormat, 8);
  ScBSPutBits(bs, H261->RTPInfo->trailer.TR, 8);
  ScBSPutBits(bs, H261->RTPInfo->trailer.TRB, 8);
  ScBSPutBits(bs, H261->RTPInfo->trailer.DBQ, 8);

  return (NoErrors);
}


/*
** Function: svH261Compress()
** Purpose:  Encodes a single H261 image frame.
*/
SvStatus_t svH261Compress(SvCodecInfo_t *Info, u_char *InputImage)
{
  SvH261Info_t *H261=Info->h261;
  ScBitstream_t *bs=Info->BSOut;
  SvStatus_t status;
  int i1, i2, tBuff;
  int iGOB, iMDU, iMBpos, MiniFlag;
  unsigned char *dummy_y, *dummy_u, *dummy_v;
  double xValue,yValue;


  _SlibDebug(_DEBUG_,
              printf("p64EncodeFrame(Info=%p, H261=%p)\n",Info, H261) );
  if (H261->CurrentFrame == 0)
    H261->GQuant=H261->MQuant=H261->InitialQuant;
	
  H261->ByteOffset = 0;

  if((H261->CurrentFrame != H261->StartFrame) && H261->NoSkippedFrame)
  {
    dummy_y = H261->YRECON;
    dummy_u = H261->URECON;
    dummy_v = H261->VRECON;
    H261->YRECON = H261->YDEC;
    H261->URECON = H261->UDEC;
    H261->VRECON = H261->VDEC;
    H261->YDEC = dummy_y;
    H261->UDEC = dummy_u;
    H261->VDEC = dummy_v;
    /* memset(H261->YDEC, 0,( H261->PICSIZE ) );
    memset(H261->UDEC, 0,( H261->PICSIZEBY4) );
    memset(H261->VDEC, 0,( H261->PICSIZEBY4 ) );
    */
/*
    dummy_y = H261->YREF;
    dummy_u = H261->UREF;
    dummy_v = H261->VREF;

    H261->YREF = H261->Y;
    H261->UREF = H261->U;
    H261->VREF = H261->V;

    H261->Y    = dummy_y;
    H261->U    = dummy_u;
    H261->V    = dummy_v;
*/
    _SlibDebug(_DEBUG_, printf("LastBits=%d NBitsPerFrame=%d\n",
                             H261->LastBits, H261->NBitsPerFrame) );
    if (H261->NBitsPerFrame)
    {
      H261->OverFlow  = (int)((double) H261->LastBits/
				(double) H261->NBitsPerFrame + 0.5);
      H261->OverFlow -= 1;
      if(H261->OverFlow >0)
      {
        H261->alpha1 += 2.2* H261->OverFlow;
        H261->alpha2 -= 3.2* H261->OverFlow;
        H261->MIN_MQUANT += 1;
        H261->alpha1 = Limit_Alpha(H261->alpha1);
        H261->alpha2 = Limit_Alpha(H261->alpha2);
      }

      if(H261->OverFlow<0) H261->OverFlow=0;
      if(H261->OverFlow>2) H261->OverFlow=2;
    }
    else
      H261->OverFlow=0;
    H261->C_U_Frames += H261->OverFlow;
    H261->CurrentFrame += H261->OverFlow*H261->FrameSkip;
  }
  _SlibDebug(_VERBOSE_,
      printf("Currently Encoding Frame No. %d\n", H261->CurrentFrame) );

  if (IsYUV422Packed(Info->InputFormat.biCompression))
  {
	/* Input is in NTSC format, convert */
	if ((Info->InputFormat.biWidth == NTSC_WIDTH) &&
		(Info->InputFormat.biHeight == NTSC_HEIGHT))
	    status = ntsc_grab ((unsigned char *)InputImage,
                        (unsigned char *)(H261->Y),
                        (unsigned char *)(H261->U),
                        (unsigned char *)(H261->V),
                        (int) Info->Width,(int )Info->Height);
	
    else if (((Info->InputFormat.biWidth == CIF_WIDTH) &&
              (Info->InputFormat.biHeight == CIF_HEIGHT)) ||
		((Info->InputFormat.biWidth == QCIF_WIDTH) &&
                (Info->InputFormat.biHeight == QCIF_HEIGHT)))
            status = ScConvert422ToYUV_char(InputImage,
                        (unsigned char *)(H261->Y),
                        (unsigned char *)(H261->U),
                        (unsigned char *)(H261->V),
                        Info->Width,Info->Height);
    if (status != NoErrors)
      return (status);
  }
  else if (IsYUV411Sep(Info->InputFormat.biCompression))
  {
    /*
     *  If YUV 12 SEP, Not converting, so just copy data to the luminance
     * and chrominance appropriatelyi
     */
    memcpy (H261->Y, InputImage, H261->PICSIZE );
    memcpy (H261->U, InputImage+( H261->PICSIZE),
                           H261->PICSIZE/4 );
    memcpy (H261->V, InputImage+(H261->PICSIZE + (H261->PICSIZEBY4)),
                           H261->PICSIZE/4);
  }
  else if (IsYUV422Sep(Info->InputFormat.biCompression))
  {
    _SlibDebug(_DEBUG_, printf("ScConvert422PlanarTo411()\n") );
    ScConvert422PlanarTo411(InputImage,
                         H261->Y, H261->U, H261->V,
                         Info->Width,Info->Height);
  }
  else
  {
    _SlibDebug(_WARN_, printf("Unsupported Video format\n") );
    return(SvErrorUnrecognizedFormat);
  }

  H261->Global_Avg = 0.0;
  if ((H261->CodedFrames >= Intra_Start) && !H261->makekey )
  {
    if (H261->ME_method==ME_BRUTE)
      BruteMotionEstimation(H261, H261->YREF, H261->YRECON, H261->Y);
    else
      Logsearch(H261, H261->YREF, H261->YRECON, H261->Y);
/*
      CrawlMotionEstimation(H261, H261->YREF, H261->YRECON, H261->Y);
*/
    memset(H261->CodedMB, 1, 512);
    H261->TotalCodedMB_Intra = 0;
    H261->TotalCodedMB_Inter = 0;
    H261->ChChange = 0;
    for(iGOB=0; iGOB < H261->NumberGOB; iGOB++)
    {
      _SlibDebug(_DEBUG_, printf("ByteOffset = %d\n",H261->ByteOffset) );
      for (iMDU=0; iMDU<H261->NumberMDU; iMDU++)
      {
        iMBpos  = Bpos_Y(H261, iGOB, iMDU);
        if(H261->MeOVal[iMBpos] < SKIP_THRESH_INT)
        {
          H261->CodedMB[iMBpos] = 0;
          MiniFlag = 0;
        }
        else if (H261->MeOVal[iMBpos] <= H261->MeVal[iMBpos])
        {
          if ((H261->PreviousMeOVal[iMBpos]-H261->ActThr2<H261->MeOVal[iMBpos])
               && (H261->MeOVal[iMBpos] < (H261->PreviousMeOVal[iMBpos]+
					                   H261->ActThr2)))
          {
            if (((H261->PreviousMeOVal[iMBpos]-H261->ActThr) <
					H261->MeOVal[iMBpos])
                 && (H261->MeOVal[iMBpos] < (H261->PreviousMeOVal[iMBpos] +
					H261->ActThr)))
            {
              MiniFlag = 0;
              H261->CodedMB[iMBpos] = 0;
            }
            else
            {
              H261->ChChange++;
              MiniFlag = 1;
            }
          }
          else
            MiniFlag = 1;
        }
        else
          MiniFlag = 1;

        if (MiniFlag)
        {
          xValue = (double) H261->MeOVal[iMBpos];
          yValue = (double) H261->MeVal[iMBpos];
          xValue = xValue/256;
          yValue = yValue/256;
          H261->VARF  = 3*H261->MeVAR[iMBpos]/(512.);
          H261->VARORF = 3*H261->MeVAROR[iMBpos]/(512.);
          H261->VARSQ = H261->VARF*H261->VARF;
          H261->VARORSQ = H261->VARORF*H261->VARORF;
          H261->MWOR = H261->MeMWOR[iMBpos];
          if ((H261->VARSQ < H261->ZBDecide) || (H261->VARORSQ > H261->VARSQ))
          {
            /* (MC+Inter)mode */
            if ( !H261->MeX[iMBpos] && !H261->MeY[iMBpos] &&
				 (xValue < 0.75 || (xValue < 2.8 && yValue > (xValue*0.5)) ||
                      yValue > (xValue/1.1)) )
            {
              H261->All_MType[iMBpos] = 2;  /* Inter mode */
              H261->TotalCodedMB_Inter++;
              H261->Global_Avg += H261->VARF;
            }
            else if (H261->VARF < (double) D_FILTERTHRESHOLD)  /* MC mode */
            {
              H261->All_MType[iMBpos] = 5; /* No Filter MC */
              H261->TotalCodedMB_Inter++;
              H261->Global_Avg += H261->VARF;
            }
            else
            {
              H261->All_MType[iMBpos] = 8;  /* Filter MC */
              H261->TotalCodedMB_Inter++;
              H261->Global_Avg += H261->VARF;
            }
          }
          else
	      {
            H261->All_MType[iMBpos] = 0; /*Intramode */
            H261->TotalCodedMB_Intra++;
            H261->Global_Avg += H261->VARORF;
          }
        }
        if (H261->LastIntra[iGOB][iMDU]>SEQUENCE_INTRA_THRESHOLD)
        {
          H261->All_MType[iMBpos]=0; /* Code intra every 132 blocks */
          H261->TotalCodedMB_Intra++;
          H261->Global_Avg += H261->VARF;
        }
      }
    }
  }
  else
  {
    memset(H261->CodedMB, 0, 512);
    H261->TotalCodedMB_Intra = 0;
    H261->TotalCodedMB_Inter = 0;
    if(H261->CodedFrames==0)
      i1 = 0;
    else
      i1 = (H261->NumberGOB/Intra_Start)*H261->CodedFrames;
    i2 = (H261->NumberGOB/Intra_Start)*(H261->CodedFrames+1);

	if(H261->makekey){
  	  i1 = 0;
      i2 = H261->NumberGOB;
	}

    for(iGOB=i1; iGOB<i2; iGOB++)
    {
      _SlibDebug(_DEBUG_, printf("ByteOffset = %d\n", H261->ByteOffset) );
      for(iMDU=0; iMDU<H261->NumberMDU; iMDU++)
      {
        iMBpos  = Bpos_Y(H261, iGOB, iMDU);
        H261->All_MType[iMBpos] = 0;
        H261->CodedMB[iMBpos] = 1;
        H261->TotalCodedMB_Intra++;
        H261->Global_Avg += H261->VARF;
      }
    }
  }
  H261->TotalCodedMB = H261->TotalCodedMB_Intra + H261->TotalCodedMB_Inter/2;
  H261->TT_MB = H261->TotalCodedMB_Intra +
		H261->TotalCodedMB_Inter - H261->ChChange;
  if (H261->TT_MB) /* watch out for divide by 0 */
    H261->Global_Avg = H261->Global_Avg/H261->TT_MB;
  _SlibDebug(_DEBUG_,
          printf("TT_MB = %d Global_Avg=%d\n", H261->TT_MB, H261->Global_Avg) );
  H261->Current_CodedMB[0] = 0;
  H261->Current_CodedMB[1] = 0;
  if(H261->C_U_Frames==0) H261->BitsLeft = 0;
  H261->BitsLeft = H261->BitsLeft - H261->Buffer_NowPic;
  tBuff = H261->PBUFF - (H261->C_U_Frames%H261->PBUFF);
  if(tBuff >= H261->Pictures_in_Buff)
  {
    H261->Pictures_in_Buff = tBuff;
    if (H261->BitsLeft < - H261->Buffer_All/3)
      H261->BitsLeft = H261->Buffer_All;
    else if (H261->BitsLeft > 2*H261->Buffer_All)
      H261->BitsLeft = H261->Buffer_All;
    else
      H261->BitsLeft = H261->BitsLeft + H261->Buffer_All;
    H261->NBitsCurrentFrame = H261->BitsLeft/H261->Pictures_in_Buff;
  }
  H261->Pictures_in_Buff = tBuff;
  if(H261->BitsLeft > 2*H261->Buffer_All)
  {
    _SlibDebug(_DEBUG_, printf("\n Bits Left is %f times more than Buffer_All",
                     (float)H261->BitsLeft/(float) H261->Buffer_All) );
    H261->BitsLeft = H261->Buffer_All;
    if(H261->MIN_MQUANT > 2)
      H261->MIN_MQUANT -=  1;
  }
  H261->NBitsCurrentFrame = H261->BitsLeft/H261->Pictures_in_Buff;
  H261->LowerQuant = 0;
  H261->FineQuant = 0;
  H261->ActThr = H261->ActThr5; H261->ActThr2 = H261->ActThr6;

  if (H261->bit_rate < 128001)
    if (H261->NBitsCurrentFrame > (5*H261->NBitsPerFrame/3))
      H261->NBitsCurrentFrame = 5*H261->NBitsPerFrame/4;
    else if (H261->NBitsCurrentFrame > 5*H261->NBitsPerFrame/4)
    {
      if((H261->frame_rate<=15) && (H261->bit_rate > 255000))
      {
        H261->NBitsCurrentFrame = 5*H261->NBitsPerFrame/4;
        H261->FineQuant = 3;
        H261->ActThr = H261->ActThr3;
        H261->ActThr2 = H261->ActThr4;
      }
      else if (H261->frame_rate==30)
      {
        H261->FineQuant = 0;
        H261->ActThr = H261->ActThr4;
        H261->ActThr2 = H261->ActThr4;
        H261->NBitsCurrentFrame = 5*H261->NBitsPerFrame/4;
      }
    }

  H261->Buffer_NowPic = 0;
  H261->MQuant = H261->GQuant;

  _SlibDebug(_DEBUG_, printf("GQuant for this picture is %d\n", H261->GQuant) );
  H261->TemporalReference = H261->CurrentFrame % 32;
  if(H261->TotalCodedMB > TotalCodedMB_Threshold)
  {
    /* TRAILER information */
    if (H261->extbitstream)
    {
      /* H261->RTPInfo->trailer.dwSrcVersion = 0; */
      H261->RTPInfo->trailer.dwVersion = 0;
      if(H261->CurrentFrame == H261->StartFrame)
         H261->RTPInfo->trailer.dwFlags = RTP_H261_INTRA_CODED;
	  else
         H261->RTPInfo->trailer.dwFlags = 0;
      H261->RTPInfo->trailer.dwUniqueCode = BI_DECH261DIB;
      H261->RTPInfo->trailer.dwNumberOfPackets = 0;

      if(H261->ImageType == IT_QCIF)
         H261->RTPInfo->trailer.SourceFormat = 2;
      else
         H261->RTPInfo->trailer.SourceFormat = 3;
      H261->RTPInfo->trailer.TR = (unsigned char)H261->TemporalReference;
      H261->RTPInfo->trailer.TRB = 0;
      H261->RTPInfo->trailer.DBQ = 0;
      H261->RTPInfo->pre_MB_position=H261->RTPInfo->last_packet_position=ScBSBitPosition(bs);
      H261->RTPInfo->pre_MB_GOB = 0;
      H261->RTPInfo->pre_MBAP = 0;
      /* store the picture start pos in dwCompressSize,
         we'll subtract from this later */
      H261->RTPInfo->trailer.dwCompressedSize = (unsigned dword)ScBSBitPosition(bs);
    }

    H261->CodedFrames++;
    H261->C_U_Frames++;
    WritePictureHeader(H261, bs);
    H261->Buffer_NowPic += 32;
    for (H261->CurrentGOB=0; H261->CurrentGOB<H261->NumberGOB; H261->CurrentGOB++)
	{
      H261->CurrentMDU=0;
      _SlibDebug(_DEBUG_,
             printf("p64EncodeGOB() ByteOffset = %d\n", H261->ByteOffset) );
      status = p64EncodeGOB(H261, bs);
      if (status != NoErrors)
        return (status);
    }
    {
      ScBSPosition_t x = ScBSBitPosition(bs);  /* mwtellb(H261); */
      H261->LastBits = x - H261->TotalBits;
      H261->TotalBits = x;

      if (H261->extbitstream)
        H261->RTPInfo->trailer.dwCompressedSize
           = (unsigned dword)(x-H261->RTPInfo->trailer.dwCompressedSize);
    }

    _SlibDebug(_DEBUG_, printf("after mwtellb() LastBits=%d TotalBits=%d\n",
                 H261->LastBits, H261->TotalBits) );
    if (H261->bit_rate)
    {
      if (H261->CurrentFrame==H261->StartFrame)
      {
        /* Begin Buffer at 0.5 size */
        H261->FirstFrameBits = H261->TotalBits;
        H261->BufferOffset = (BufferSize()/2) - BufferContents();
        _SlibDebug(_DEBUG_,
              printf("First Frame Reset Buffer by delta bits: %d\n",
                                       H261->BufferOffset) );
      }
      /* Take off standard deduction afterwards. */
      H261->BufferOffset -= (H261->bit_rate*H261->FrameSkip/H261->FrameRate_Fix);
    }
    else if (H261->CurrentFrame==H261->StartFrame)
      H261->FirstFrameBits = H261->TotalBits;
    H261->CurrentGOB=0;H261->TransmittedFrames++;
    H261->NoSkippedFrame = 1;
    H261->CurrentFrame+=H261->FrameSkip;/* Change GOB & Frame at same time */

	/* write RTP info. */
    if (H261->extbitstream)
    {
      SvStatus_t status;
	  status = sv_H261WriteExtBitstream(H261, bs);
      if (status!=SvErrorNone) return(status);
    }
  }
  else
  {
    H261->NoSkippedFrame = 0;
    H261->CurrentFrame+=H261->FrameSkip;
    H261->C_U_Frames++;
    H261->alpha1 -= 1.50;
    H261->alpha2 += 1.50;
    H261->MIN_MQUANT -= 1;
    H261->alpha1 = Limit_Alpha(H261->alpha1);
    H261->alpha2 = Limit_Alpha(H261->alpha2);
  }

  if(H261->makekey) H261->makekey = 0; /* disable key-frame trigger */

  return (NoErrors);
} /**** End of Encode Frame ****/

/*
** Function: p64EncodeGOB()
** Pupose:   Encodes a group of blocks within a frame.
*/
static SvStatus_t p64EncodeGOB(SvH261Info_t *H261, ScBitstream_t *bs)
{
  const int CurrentGOB=H261->CurrentGOB;
  const int YWidth=H261->YWidth, CWidth=H261->CWidth;
  int CurrentMDU, h, VIndex, HIndex;
  double error, stepsize;
  SvStatus_t status;

  if (H261->extbitstream)
  {
    ScBSPosition_t cur_position;

    cur_position = ScBSBitPosition(bs);

    /* start a new packet */
    if (H261->RTPInfo->trailer.dwNumberOfPackets==0 ||
        (cur_position-H261->RTPInfo->last_packet_position)
                   >= (unsigned)H261->packetsize-128)
    {
      SvH261BSInfo_t *bsinfo=&H261->RTPInfo->bsinfo[H261->RTPInfo->trailer.dwNumberOfPackets];
      /* breaking packet before GOB boundaries */
      H261->RTPInfo->last_packet_position = H261->RTPInfo->pre_MB_position;

      H261->RTPInfo->trailer.dwNumberOfPackets++;
      bsinfo->dwBitOffset = (unsigned dword)H261->RTPInfo->pre_MB_position;

      bsinfo->MBAP  = (unsigned char)H261->RTPInfo->pre_MBAP;
      bsinfo->Quant = (unsigned char)H261->UseQuant;
      bsinfo->GOBN  = (unsigned char)H261->RTPInfo->pre_MB_GOB;
      bsinfo->HMV   = 0;
      bsinfo->VMV   = 0;
      bsinfo->padding0 = 0;
      bsinfo->padding1 = 0;
    }
    H261->RTPInfo->pre_MB_position = cur_position;
    H261->RTPInfo->pre_MB_GOB = CurrentGOB;
    H261->RTPInfo->pre_MBAP=0;
  }

  if(H261->bit_rate) {
    if(CurrentGOB==0){
	  H261->GQuant =8;
      H261->MQuant = 8;
    }
    else
      ExecuteQuantization_GOB(H261);
  }
  else{											 /* for VBR */
      if (H261->CurrentFrame==H261->StartFrame)
  	    H261->GQuant = H261->MQuant = H261->QPI;
	  else
  	    H261->GQuant = H261->MQuant = H261->QP;
  }

  switch (H261->ImageType)
  {
    case IT_NTSC:
    case IT_CIF:
           H261->GRead=CurrentGOB;
           break;
    case IT_QCIF:
	       H261->GRead=CurrentGOB<<1;
           break;
    default:
           _SlibDebug(_VERIFY_,
               printf("Unknown Image Type: %d\n", H261->ImageType) );
           return (SvErrorUnrecognizedFormat);
  }
  WriteGOBHeader(H261, bs);

  H261->Buffer_NowPic += 26;
  H261->LastMBA = -1; H261->MType=0;
  /*
   * MAIN LOOP
   */
  for (CurrentMDU=0; CurrentMDU<H261->NumberMDU; CurrentMDU++)
  {
      H261->CurrentMDU=CurrentMDU;
      H261->MBpos  = Bpos_Y(H261, CurrentGOB, CurrentMDU);
      H261->LastMType=H261->MType;
      H261->MType = H261->All_MType[H261->MBpos];
      if((H261->MType>1) && !H261->CodedMB[H261->MBpos])
      {
        H261->SkipMB++;
        if (H261->ImageType==IT_QCIF)
        {
          HIndex = (CurrentMDU % 11) * 16;
          VIndex = (CurrentGOB*48) + ((CurrentMDU/11) * 16);
        }
        else /* IT_CIF or NTSC */
        {
          HIndex = ((((CurrentGOB & 1)*11)+(CurrentMDU%11))*16);
          VIndex = ((CurrentGOB/2)*48) + ((CurrentMDU/11) * 16);
        }
	_SlibDebug(_DEBUG_,
                   printf ("Skipping MB...  MType=%d\n", H261->MType) );
        h = VIndex*YWidth;
        H261->VYWH = h + HIndex;
        H261->VYWH2 = (((h/2) + HIndex) /2);
        ScCopyMB16(&H261->YRECON[H261->VYWH], &H261->YDEC[H261->VYWH],
                    YWidth, YWidth);

        ScCopyMB8 (&H261->URECON[H261->VYWH2], &H261->UDEC[H261->VYWH2],
	            CWidth, CWidth);
        ScCopyMB8 (&H261->VRECON[H261->VYWH2], &H261->VDEC[H261->VYWH2],
                    CWidth, CWidth);
	
      }
      else
      {
        /*
         * Encode a MDU - was a call to p64EncodeMDU()
         */
        H261->Current_MBBits=0;
		status = p64CompressMDU(H261, bs);
        if (status != NoErrors)
          return (status);

        if (H261->extbitstream)
        {
          ScBSPosition_t cur_position;

          cur_position = ScBSBitPosition(bs);

		  /* start a new packet */
          if ((cur_position-H261->RTPInfo->last_packet_position) >= (unsigned)H261->packetsize-128)
	      {
            SvH261BSInfo_t *bsinfo=&H261->RTPInfo->bsinfo[H261->RTPInfo->trailer.dwNumberOfPackets];
            H261->RTPInfo->last_packet_position = H261->RTPInfo->pre_MB_position;

            H261->RTPInfo->trailer.dwNumberOfPackets++;
            bsinfo->dwBitOffset = (unsigned dword)H261->RTPInfo->pre_MB_position;

            bsinfo->MBAP  = (unsigned char)H261->RTPInfo->pre_MBAP;
            bsinfo->Quant = (unsigned char)H261->UseQuant;
            bsinfo->GOBN  = (unsigned char)H261->RTPInfo->pre_MB_GOB;
            bsinfo->HMV   = 0;
            bsinfo->VMV   = 0;
            bsinfo->padding0 = 0;
            bsinfo->padding1 = 0;
	      }
	      H261->RTPInfo->pre_MB_position = cur_position;
	      H261->RTPInfo->pre_MB_GOB = H261->CurrentGOB;
	      H261->RTPInfo->pre_MBAP = H261->LastMBA;
        }

        H261->QUse++;                  /* Accumulate statistics */
        H261->QSum+=H261->UseQuant;
        if (H261->MType < 10)
          H261->MacroTypeFrequency[H261->MType]++;
        else
        {
          _SlibDebug(_VERIFY_, printf("Illegal MType: %d\n",H261->MType) );
	  return (SvErrorIllegalMType);
        }
        H261->Buffer_NowPic += H261->Current_MBBits;
/*
        H261->MyCB[H261->CurrentCBNo].BitsMB += 0.02*(H261->Current_MBBits -
                                  H261->MyCB[H261->CurrentCBNo].BitsMB);
*/
        if (H261->MType > 1 && H261->bit_rate > 0)
        {
          error = (H261->Current_MBBits - CBook[H261->CurrentCBNo].BitsMB);
	      if (fabs(error) > (0.2*H261->Current_MBBits))
	         error = CBook[H261->CurrentCBNo].BitsMB * 0.2*error/fabs(error);

	      if (error > 0)
	         stepsize = 0.005/(H261->Current_MBBits*H261->bit_rate/112000.0);
	      if (error <= 0)
	         stepsize = 0.07/(H261->Current_MBBits*H261->bit_rate/112000.0);

	      CBook[H261->CurrentCBNo].BitsMB += (float)(stepsize*error);
        }
      }
  }
  return (NoErrors);
} /**** End of p64EncodeGOB ****/


#if 0
/* Now done inline */
/*
** Function: p64EncodeMDU()
** Purpose:  Encodes the MDU by read/compressing the MDU, then
**           writing it, then decoding it and accumulating statistics.
*/
static SvStatus_t p64EncodeMDU (SvH261Info_t *H261, ScBitstream_t *bs)
{
    SvStatus_t status;

    H261->Current_MBBits=0;
    status = p64CompressMDU(H261, bs);
    if (status != NoErrors)
      return (status);
    H261->QUse++;                  /* Accumulate statistics */
    H261->QSum+=H261->UseQuant;
    if (H261->MType < 10)
      H261->MacroTypeFrequency[H261->MType]++;
    else
    {
      _SlibDebug(_VERIFY_, printf("Illegal MType: %d\n",H261->MType) );
      return (SvErrorIllegalMType);
    }
    return (NoErrors);
}
#endif

/* these temporary buffers are used by p64CompressMDU and
   should be allocated elsewhere */
static float Idct[6][64];
static int Odct[6][64];
static float TempDct[64];
static int Dct[64];

/*
** Function: p64CompressMDU()
** Pupose:   Reads in the MDU, and attempts to compress it.
**           If the chosen MType is invalid, it finds the closest match.
*/
static SvStatus_t p64CompressMDU(SvH261Info_t *H261, ScBitstream_t *bs)
{
    const int CurrentGOB=H261->CurrentGOB, CurrentMDU=H261->CurrentMDU;
    const int YWidth=H261->YWidth, CWidth=H261->CWidth;
    const int YW4=H261->YW4, CW4 = H261->CW4;
    int j, x, tQuant, indQ, VIndex, HIndex, MType;
    int accum, pmask, CBPFlag, *input;
    SvStatus_t status;
    int inputbuf[10][64];
    unsigned int *y0ptr, *y1ptr, *y2ptr, *y3ptr;
    unsigned int *uptr, *vptr;
    unsigned int *y0ptr_dec, *y1ptr_dec, *y2ptr_dec,*y3ptr_dec;
    unsigned int *uptr_dec, *vptr_dec;

    if (H261->ImageType==IT_QCIF)
    {
      HIndex = (CurrentMDU % 11) * 16;
      VIndex = (CurrentGOB*48) + ((CurrentMDU/11) * 16);
    }
    else /* IT_CIF or NTSC */
    {
      HIndex = ((((CurrentGOB & 1)*11)+(CurrentMDU%11))*16);
      VIndex = ((CurrentGOB/2)*48) + ((CurrentMDU/11) * 16);
    }
    H261->MQFlag = 0;
    if(H261->MType < 2)
	H261->Avg_AC = H261->MeVAROR[H261->MBpos]/256.0;
    else
	H261->Avg_AC = H261->MeVAR[H261->MBpos]/256.0;

    H261->MVDH = H261->MeX[H261->MBpos];
    H261->MVDV = H261->MeY[H261->MBpos];

    H261->VYWH = (VIndex*YWidth) + HIndex;
    H261->VYWH2 = ((((VIndex*YWidth)/2) + HIndex) /2);

    H261->VYWHMV = H261->VYWH + H261->MVDH + (H261->MVDV*YWidth);
    H261->VYWHMV2 = H261->VYWH2 +
		((H261->MVDV/2)*CWidth) + (H261->MVDH/2);

    y0ptr = (unsigned int *) (H261->Y + H261->VYWH);
    y1ptr = y0ptr + 2;
    y2ptr = y0ptr + (YWidth<<1);
    y3ptr = y2ptr + 2;

    uptr  = (unsigned int *) (H261->U + H261->VYWH2);
    vptr  = (unsigned int *) (H261->V + H261->VYWH2);

    y0ptr_dec = (unsigned int *) (H261->YDEC + H261->VYWH);
    y1ptr_dec = y0ptr_dec + 2;
    y2ptr_dec = y0ptr_dec + (YWidth<<1);
    y3ptr_dec = y2ptr_dec + 2;

    uptr_dec  = (unsigned int *) (H261->UDEC + H261->VYWH2);
    vptr_dec  = (unsigned int *) (H261->VDEC + H261->VYWH2);
    tQuant = H261->MQuant;

    if (CurrentMDU==0 || H261->LastMBA==-1)
      H261->MQuant = H261->GQuant;
    else
    {
	  if(H261->bit_rate)	
        ExecuteQuantization_GOB(H261);

      indQ = H261->GQuant-tQuant;
      if (indQ < 0)
        indQ = indQ*2;
      if (Abs(indQ) < H261->MSmooth)
        H261->MQuant =  tQuant;
      else
      {
        H261->MQuant = H261->GQuant;
        H261->MQFlag = 1;
      }
    }

    if (H261->MQFlag && H261->MType!=4 && H261->MType!=7)
    {
      H261->MType++;
      _SlibDebug(_DEBUG_, printf("H261->MType++ == %d\n", H261->MType) );
    }
    else
      _SlibDebug(_DEBUG_, printf("H261->MType == %d\n", H261->MType) );
    MType=H261->MType;

    H261->Current_MBBits = 0;

    if (QuantMType[MType])
    {
      if(H261->bit_rate){ /* CBR */
        H261->UseQuant = H261->MQuant;
        H261->GQuant = H261->MQuant; /* Future MB Quant is now MQuant */
	  }
	  else {              /* VBR */
        if (H261->CurrentFrame==H261->StartFrame || IntraMType[MType])
   	      H261->UseQuant = H261->GQuant = H261->MQuant = H261->QPI;
	    else
  	      H261->UseQuant = H261->GQuant = H261->MQuant = H261->QP;
	  }
    }
    else
        H261->UseQuant = H261->GQuant;

    /*
     * WRITE
     */
    H261->MBA = CurrentMDU - H261->LastMBA;
    if (TCoeffMType[MType])
    {
      if (!IntraMType[MType])
      {
        if (FilterMType[MType])
        {
          ScCopyMB16(&H261->YRECON[H261->VYWHMV], &H261->mbRecY[0], YWidth, 16);
	  ScCopyMB8 (&H261->URECON[H261->VYWHMV2],&H261->mbRecU[0], CWidth, 8);
          ScCopyMB8 (&H261->VRECON[H261->VYWHMV2],&H261->mbRecV[0], CWidth, 8);

          ScLoopFilter(&H261->mbRecY[0],   H261->workloc, 16);
          ScLoopFilter(&H261->mbRecY[8],   H261->workloc, 16);
          ScLoopFilter(&H261->mbRecY[128], H261->workloc, 16);
          ScLoopFilter(&H261->mbRecY[136], H261->workloc, 16);
          ScLoopFilter(&H261->mbRecU[0],   H261->workloc, 8);
          ScLoopFilter(&H261->mbRecV[0],   H261->workloc, 8);
        }
        else if (MFMType[MType])
        {
          ScCopyMB16(&H261->YRECON[H261->VYWHMV], &H261->mbRecY[0], YWidth, 16);
	  ScCopyMB8 (&H261->URECON[H261->VYWHMV2],&H261->mbRecU[0], CWidth, 8);
          ScCopyMB8 (&H261->VRECON[H261->VYWHMV2],&H261->mbRecV[0], CWidth, 8);
		}
        else
	    {
          ScCopyMB16(&H261->YRECON[H261->VYWH], &H261->mbRecY[0], YWidth, 16);
	  ScCopyMB8 (&H261->URECON[H261->VYWH2],&H261->mbRecU[0], CWidth, 8);
          ScCopyMB8 (&H261->VRECON[H261->VYWH2],&H261->mbRecV[0], CWidth, 8);
        }
        _SlibDebug(_DEBUG_, printf("Doing CopySub \n") );
        ScCopySubClip(&H261->mbRecY[0],   &Idct[0][0], y0ptr, 4, YW4);
        ScCopySubClip(&H261->mbRecY[8],   &Idct[1][0], y1ptr, 4, YW4);
        ScCopySubClip(&H261->mbRecY[128], &Idct[2][0], y2ptr, 4, YW4);
        ScCopySubClip(&H261->mbRecY[136], &Idct[3][0], y3ptr, 4, YW4);
        ScCopySubClip(&H261->mbRecU[0],   &Idct[4][0], uptr,  2, CW4);
        ScCopySubClip(&H261->mbRecV[0],   &Idct[5][0], vptr,  2, CW4);
      }
      else
      {
        _SlibDebug(_DEBUG_, printf("Doing CopyRev \n") );
        ScCopyRev(y0ptr, &Idct[0][0], YW4 );
        ScCopyRev(y1ptr, &Idct[1][0], YW4);
        ScCopyRev(y2ptr, &Idct[2][0], YW4);
        ScCopyRev(y3ptr, &Idct[3][0], YW4);
        ScCopyRev(uptr,  &Idct[4][0], CW4);
        ScCopyRev(vptr,  &Idct[5][0], CW4);
      }
    }

    /*
     *  DCT, Quantize, and Zigzag.
     *   Dequantize and IDCT
     */
    if (IntraMType[MType])
    {
      _SlibDebug(_DEBUG_, printf("Doing IntraQuant\n") );
      for(j=0; j<6; j++)
      {
        /* ScaleDct(&Idct[j][0],TempDct);*/
        ScFDCT8x8(&Idct[j][0],TempDct);
        IntraQuant(TempDct, Dct, H261->UseQuant);
        ZigzagMatrix(Dct, &inputbuf[j][0]);
        Inv_Quant(Dct, H261->UseQuant, IntraMType[MType], TempDct);
        ScScaleIDCT8x8(TempDct, &Odct[j][0]);
      }
    }
    else
    {
      _SlibDebug(_DEBUG_, printf("Doing InterQuant\n") );
      for(j=0; j<6; j++)
      {
        /* ScaleDct(&Idct[j][0],TempDct);*/
		ScFDCT8x8(&Idct[j][0],TempDct);
        InterQuant(TempDct, Dct, H261->UseQuant);
        ZigzagMatrix(Dct, &inputbuf[j][0]);
        Inv_Quant(Dct, H261->UseQuant, IntraMType[MType], TempDct);
        ScScaleIDCT8x8(TempDct, &Odct[j][0]);
      }
    }

    if (!CBPMType[MType])
    {
      CBPFlag=0;
      H261->CBP = 0x3f;
    }
    else
    {
      for(pmask=0, H261->CBP=0, j=0; j<6; j++)
      {
        input = &inputbuf[j][0];
        for(accum=0, x=0; x<64; x++)
          accum += (int)Abs(input[x]);
        if (accum && (pmask==0))
          pmask|=bit_set_mask[5-j];
        if (accum>H261->CBPThreshold)
          H261->CBP |= bit_set_mask[5-j];
      }
      if (!H261->CBP)
      {
        if (pmask)
          H261->CBP=pmask;
        else if (!FilterMType[MType])
        {
          H261->MType=4;
          MType=4;
        }
        else
        {
          H261->MType=7;
          MType=7;
        }
      }
    }
    _SlibDebug(_DEBUG_,printf("CurrentGOB=%d CurrentMDU=%d LastIntra[%d]=%p\n",
                      CurrentGOB, CurrentMDU,CurrentGOB,
                      H261->LastIntra[CurrentGOB]) );
    if (IntraMType[MType])
	H261->LastIntra[CurrentGOB][CurrentMDU]=0;
    else
        H261->LastIntra[CurrentGOB][CurrentMDU]++;

    /*
     * Write out the MB
     */
    status = WriteMBHeader(H261, bs);
    if (status != NoErrors)
      return (status);
    H261->LastMBA = CurrentMDU;
    H261->TotalMB[IntraMType[MType]]++;
    H261->Current_CodedMB[IntraMType[MType]]++;
    if (TCoeffMType[MType])
      for(j=0; j<6; j++)
      {
        if (H261->CBP & bit_set_mask[5-j])
        {
          input = &inputbuf[j][0];
          if (j>3)
            H261->UVTypeFrequency[MType]++;
          else
            H261->YTypeFrequency[MType]++;
          H261->CodedBlockBits=0;
          if (CBPMType[MType])
            status = CBPEncodeAC(H261, bs, 0, input);
          else
          {
            EncodeDC(H261, bs, *input);
            H261->Current_MBBits += 8;
            status = EncodeAC(H261, bs, 1, input);
          }
          if (status != NoErrors)
            return (status);
          H261->Current_MBBits += H261->CurrentBlockBits;
          H261->MBBits[IntraMType[MType]] += H261->CodedBlockBits;
          if (j<4)
            H261->YCoefBits+=H261->CodedBlockBits;
          else if (j==5)
            H261->UCoefBits+=H261->CodedBlockBits;
          else
            H261->VCoefBits+=H261->CodedBlockBits;
        }
      }
    /*
     *  Now write it to Frame _dec !!
     */
    if(!IntraMType[MType])
    {
      const unsigned char CBP = (unsigned char)H261->CBP;
      if (CBP & 0x20)
      {
        ScCopyAddClip(&H261->mbRecY[0], &Odct[0][0], y0ptr_dec, 16, YW4);
        H261->CBPFreq[0]++;
      }
      else
        ScCopyMV8(&H261->mbRecY[0], y0ptr_dec, 16, YW4);
      if (CBP & 0x10)
      {
        ScCopyAddClip(&H261->mbRecY[8], &Odct[1][0],y1ptr_dec, 16, YW4);
        H261->CBPFreq[1]++;
      }
      else
        ScCopyMV8(&H261->mbRecY[8], y1ptr_dec, 16, YW4);
      if (CBP & 0x08)
      {
        ScCopyAddClip(&H261->mbRecY[128], &Odct[2][0], y2ptr_dec, 16, YW4);
        H261->CBPFreq[2]++;
      }
      else
        ScCopyMV8(&H261->mbRecY[128], y2ptr_dec, 16, YW4);
      if (CBP & 0x04)
      {
        ScCopyAddClip(&H261->mbRecY[136], &Odct[3][0], y3ptr_dec, 16, YW4);
        H261->CBPFreq[3]++;
      }
      else
        ScCopyMV8(&H261->mbRecY[136], y3ptr_dec, 16, YW4);
      if (CBP & 0x02)
      {
        ScCopyAddClip(&H261->mbRecU[0], &Odct[4][0], uptr_dec, 8, CW4);
        H261->CBPFreq[4]++;
      }
      else
        ScCopyMV8(&H261->mbRecU[0], uptr_dec, 8, CW4);
      if (CBP & 0x01)
      {
        ScCopyAddClip(&H261->mbRecV[0], &Odct[5][0], vptr_dec, 8, CW4);
        H261->CBPFreq[5]++;
      }
      else
        ScCopyMV8(&H261->mbRecV[0], vptr_dec, 8, CW4);
    }
    else
    {
      ScCopyClip(&Odct[0][0], y0ptr_dec, YW4);
      ScCopyClip(&Odct[1][0], y1ptr_dec, YW4);
      ScCopyClip(&Odct[2][0], y2ptr_dec, YW4);
      ScCopyClip(&Odct[3][0], y3ptr_dec, YW4);
      ScCopyClip(&Odct[4][0], uptr_dec, CW4);
      ScCopyClip(&Odct[5][0], vptr_dec, CW4);
    }
    return (NoErrors);
}



#ifndef Bpos_Y
/* Now a macro */
/*
** Function: Bpos_Y()
** Purpose:  Returns the designated MDU number inside of the frame of the
**           installed Iob given by the input gob, mdu, horizontal and
**           vertical offset. It returns 0 on error.
*/
static int Bpos_Y(SvH261Info_t *H261, int g, int m)
{
    int tg;
    BEGIN("Bpos");

    switch (H261->ImageType)
        {
        case IT_QCIF:
            tg = (g * 33) + (m % 33);
/*
            tg = (g/2) * 33 + (m%11) + (m/11)*11;
*/
            return(tg);
            break;
        case IT_CIF:
        case IT_NTSC:
            tg = (g/2)*66 + (m % 11) + (g&1)*11 + (m/11) * 22;
            return(tg);
            break;
        default:
            /* WHEREAMI();*/
	    _SlibDebug(_VERIFY_,
               printf("Unknown image type: %d.\n",H261->ImageType) );
            /* return (SvErrorUnrecognizedFormat);*/
            break;
        }
    return(0);
}
#endif


static void ExecuteQuantization_GOB(SvH261Info_t *H261)
{
  double si1, si2;

  if(H261->TotalCodedMB)
  {
    if(H261->bit_rate) { /* CBR */
      si1  =  (double) H261->CurrentGOB / (double) H261->NumberGOB;
      si2  =(double) exp(-4.0*(si1-0.5)*(si1-0.5)) + 0.45;

      if (H261->Avg_AC >= H261->Global_Avg)
        H261->BitsAvailableMB =(float)(si2 *
		  H261->NBitsCurrentFrame/(1.0 *(float) H261->TT_MB) -
 		  (H261->Global_Avg - H261->Avg_AC)*2.5)  ;
      else if (H261->Avg_AC < H261->Global_Avg)
        H261->BitsAvailableMB = (float)( si2* H261->NBitsCurrentFrame/
			(1.0*(float) H261->TT_MB) -
                     (H261->Global_Avg - H261->Avg_AC)*2.5 ) ;

      if(H261->MType > 0)
        H261->LowerQuant = H261->LowerQuant_FIX;
      else
        H261->LowerQuant = 0;
      H261->BitsAvailableMB += H261->LowerQuant;
      H261->BitsAvailableMB =(float)Limit_Bits(H261->BitsAvailableMB);
      H261->ACE = (float) H261->Avg_AC;
      H261->GQuant = findcode(H261, CBook);

      if(H261->FineQuant) H261->GQuant -= H261->FineQuant;
      if(H261->CurrentFrame == H261->StartFrame) H261->GQuant = 8;
      if (H261->GQuant < 1) H261->GQuant = 1;
      if(H261->GQuant > 28) H261->GQuant = 28;
	}
	else                 /* VBR */
        H261->GQuant = H261->QP;
  }
}


static int findcode(SvH261Info_t *H261, struct CodeBook *cb)
{
  const codelength=H261->CodeLength;
  const float ace=H261->ACE, bmb=H261->BitsAvailableMB;
  int i, mincb=-1;
  float distance, mindist, val1, val2;
  struct CodeBook *lcb=cb;

  H261->CurrentCBNo = 15;
  if((ace <=0.0) || (bmb <=0.0))
    return(25);
  mindist = (float)1000000.0;
  for(i=0; i<codelength; i++)
  {
    val1=lcb->AcEnergy - ace;
    val2=lcb->BitsMB - bmb;
    distance = (val1*val1) + (val2*val2);
    if (distance < mindist)
    {
      mindist = distance;
      mincb = i;
    }
    lcb++;
 }

 if (mincb>=0)
 {
   H261->CurrentCBNo = mincb;
   return((int)cb[mincb].QuantClass);
 }
 else
   return(25);
}

/*
** Function: ntsc_grab()
** Purpose:  Grab a Q/CIF frame from a 4:2:2 NTSC input.  We dup every 10th
**           pixel horizontally and every 4th line vertically.  We also
**           discard the chroma on every other line, since CIF wants 4:1:1.
*/
static SvStatus_t ntsc_grab (u_char *RawImage,
                         u_char *Comp1, u_char *Comp2, u_char *Comp3,
                         int Width, int Height)
{
    int h, w;
    u_char *yp = Comp1, *up = Comp2, *vp = Comp3;
    int NTSC_Height = 240;
    int NTSC_Width = 320;

    int stride = Width;
    int vdup = 5;
    for (h = 0; h < NTSC_Height; ++h)
        {
        int hdup = 10/2;
        for (w = NTSC_Width; w > 0; w -= 2)
	    {
            yp[0] = RawImage[0];
            yp[1] = RawImage[2];
            yp += 2;
            if ((h & 1) == 0)
		{
                *up++ = RawImage[1];
                *vp++ = RawImage[3];
                }
            RawImage += 4;
            if (--hdup <= 0)
		{
                hdup = 10/2;
                yp[0] = yp[-1];
                yp += 1;
                if ((h & 1) == 0)
		    {
                    if ((w & 2) == 0)
			{
                        up[0] = up[-1];
                        ++up;
                        vp[0] = vp[-1];
                        ++vp;
                        }
                    }
                }
            }
        if (--vdup <= 0)
	    {
            vdup = 5;
            /* copy previous line */
            memcpy((char*)yp, (char*)yp - stride, stride);
            yp += stride;
            if ((h & 1) == 0)
		{
                int s = stride >> 1;
                memcpy((char*)up, (char*)up - s, s);
                memcpy((char*)vp, (char*)vp - s, s);
                up += s;
                vp += s;
                }
            }
        }
    return (NoErrors);
}
#ifdef USE_C
static void VertSubSampleK (unsigned char *Incomp, unsigned char *workloc,
                           int Width, int Height)
{
  int j, i, temp;

  int ByteWidth = Width * 4;
  for(j=0; j<(Width ); j++)  {
        temp  = Incomp[(j * 4)]*3;
        temp += Incomp[(j * 4)+ByteWidth]*3;
        temp += Incomp[(j * 4)+ByteWidth*2];
        temp = temp/7;
        workloc[j] = (unsigned char) temp;
    }

    for(i=2; i<(Height-2); i += 2)  {
        for(j=0; j<(Width ); j++)  {
            temp  = Incomp[(i-1)*ByteWidth + (j * 4)];
            temp += Incomp[i*ByteWidth + (j * 4)]*3;
            temp += Incomp[(i+1)*ByteWidth + (j * 4)]*3;
            temp += Incomp[(i+2)*ByteWidth + (j * 4)];
            workloc[(i/2)*Width + j]  = (unsigned char) (temp >> 3);
	}
    }
    i = Width*(Height/2-1);
    for(j=0; j<Width; j++)  {
        temp =  Incomp[(j * 4) + (Height-3)*ByteWidth];
        temp += Incomp[j + (Height-2)*ByteWidth]*3;
        temp += Incomp[j + (Height-1)*ByteWidth]*3;
        temp = temp/7;
        workloc[i+j] = (unsigned char) temp;
    }
}
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech261\buffer.c ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: slib_buffer.c,v $
 * Revision 1.1.6.26  1996/12/13  18:19:07  Hans_Graves
 * 	Check for valid pin pointer in slibGetNextTimeOnPin().
 * 	[1996/12/13  18:08:27  Hans_Graves]
 *
 * Revision 1.1.6.25  1996/12/10  19:21:58  Hans_Graves
 * 	Fix MPEG Systems encoding bug.
 * 	[1996/12/10  19:15:33  Hans_Graves]
 * 
 * Revision 1.1.6.24  1996/12/04  22:34:32  Hans_Graves
 * 	Enable AC3 detection in PRIVATE packets.
 * 	[1996/12/04  22:18:48  Hans_Graves]
 * 
 * Revision 1.1.6.23  1996/12/03  23:15:16  Hans_Graves
 * 	Fixed updating of offset value for buffers on pins.
 * 	[1996/12/03  23:09:51  Hans_Graves]
 * 
 * Revision 1.1.6.22  1996/12/03  00:08:33  Hans_Graves
 * 	Handling of End Of Sequence points. Added PERCENT100 support.
 * 	[1996/12/03  00:06:03  Hans_Graves]
 * 
 * Revision 1.1.6.21  1996/11/18  23:07:36  Hans_Graves
 * 	Make use of presentation timestamps. Make seeking time-based.
 * 	[1996/11/18  22:47:40  Hans_Graves]
 * 
 * Revision 1.1.6.20  1996/11/13  16:10:56  Hans_Graves
 * 	Skip AC3 header in private packets.
 * 	[1996/11/13  16:03:50  Hans_Graves]
 * 
 * Revision 1.1.6.19  1996/11/11  18:21:07  Hans_Graves
 * 	Added AC3 support for multiplexed streams.
 * 	[1996/11/11  18:00:27  Hans_Graves]
 * 
 * Revision 1.1.6.18  1996/11/08  21:51:06  Hans_Graves
 * 	Added AC3 support. Fixed Program Stream demultiplexing.
 * 	[1996/11/08  21:31:43  Hans_Graves]
 * 
 * Revision 1.1.6.17  1996/10/31  21:58:09  Hans_Graves
 * 	Turned of debugging code.
 * 	[1996/10/31  21:57:56  Hans_Graves]
 * 
 * Revision 1.1.6.16  1996/10/31  21:55:47  Hans_Graves
 * 	Fix bad multiplexing when encoding to MPEG Systems.
 * 	[1996/10/31  21:15:01  Hans_Graves]
 * 
 * Revision 1.1.6.15  1996/10/29  17:04:59  Hans_Graves
 * 	Add padding packets support for MPEG Systems Encoding.
 * 	[1996/10/29  17:04:45  Hans_Graves]
 * 
 * Revision 1.1.6.14  1996/10/28  17:32:32  Hans_Graves
 * 	MME-1402, 1431, 1435: Timestamp related changes.
 * 	[1996/10/28  17:23:03  Hans_Graves]
 * 
 * Revision 1.1.6.13  1996/10/17  00:23:34  Hans_Graves
 * 	Fix buffer problems after SlibQueryData() calls.
 * 	[1996/10/17  00:19:14  Hans_Graves]
 * 
 * Revision 1.1.6.12  1996/10/15  17:34:13  Hans_Graves
 * 	Added MPEG-2 Program Stream support.
 * 	[1996/10/15  17:30:30  Hans_Graves]
 * 
 * Revision 1.1.6.11  1996/10/12  17:18:54  Hans_Graves
 * 	Added parsing of Decode and Presentation timestamps with MPEG Transport.
 * 	[1996/10/12  17:01:55  Hans_Graves]
 * 
 * Revision 1.1.6.10  1996/10/03  19:14:24  Hans_Graves
 * 	Added Presentation and Decoding timestamp support.
 * 	[1996/10/03  19:10:38  Hans_Graves]
 * 
 * Revision 1.1.6.9  1996/09/29  22:19:41  Hans_Graves
 * 	Added debugging printf's
 * 	[1996/09/29  21:30:27  Hans_Graves]
 * 
 * Revision 1.1.6.8  1996/09/25  19:16:48  Hans_Graves
 * 	Added SLIB_INTERNAL define.
 * 	[1996/09/25  19:01:53  Hans_Graves]
 * 
 * Revision 1.1.6.7  1996/09/18  23:46:48  Hans_Graves
 * 	MPEG2 Systems parsing fixes. Added Audio presentation timestamps to MPEG1 Systems writing
 * 	[1996/09/18  22:06:07  Hans_Graves]
 * 
 * Revision 1.1.6.6  1996/08/09  20:51:48  Hans_Graves
 * 	Fix callbacks with user buffers
 * 	[1996/08/09  20:11:06  Hans_Graves]
 * 
 * Revision 1.1.6.5  1996/07/19  02:11:13  Hans_Graves
 * 	Added support for SLIB_MSG_BUFDONE with user buffers.
 * 	[1996/07/19  02:02:53  Hans_Graves]
 * 
 * Revision 1.1.6.4  1996/06/07  18:26:12  Hans_Graves
 * 	Merge MME-01326. Encoded MPEG-1 Systems files now include Presentation timestamps
 * 	[1996/06/07  17:54:11  Hans_Graves]
 * 
 * Revision 1.1.6.3  1996/05/10  21:17:27  Hans_Graves
 * 	Add Callback support.
 * 	[1996/05/10  20:58:39  Hans_Graves]
 * 
 * Revision 1.1.6.2  1996/05/07  19:56:22  Hans_Graves
 * 	Added HUFF_SUPPORT.
 * 	[1996/05/07  17:20:50  Hans_Graves]
 * 
 * Revision 1.1.4.10  1996/05/02  17:10:35  Hans_Graves
 * 	Better checking for NULL pointers in ParseMpeg2Systems(). Fixes MME-01234
 * 	[1996/05/02  17:05:46  Hans_Graves]
 * 
 * Revision 1.1.4.9  1996/04/24  22:33:46  Hans_Graves
 * 	MPEG encoding bitrate fixups.
 * 	[1996/04/24  22:27:13  Hans_Graves]
 * 
 * Revision 1.1.4.8  1996/04/23  15:36:42  Hans_Graves
 * 	Added MPEG 1 Systems packet recovery
 * 	[1996/04/23  15:35:23  Hans_Graves]
 * 
 * Revision 1.1.4.7  1996/04/19  21:52:24  Hans_Graves
 * 	MPEG 1 Systems writing enhancements
 * 	[1996/04/19  21:47:53  Hans_Graves]
 * 
 * Revision 1.1.4.6  1996/04/01  19:07:54  Hans_Graves
 * 	And some error checking
 * 	[1996/04/01  19:04:37  Hans_Graves]
 * 
 * Revision 1.1.4.5  1996/04/01  16:23:16  Hans_Graves
 * 	NT porting
 * 	[1996/04/01  16:16:00  Hans_Graves]
 * 
 * Revision 1.1.4.4  1996/03/29  22:21:35  Hans_Graves
 * 	Added MPEG/JPEG/H261_SUPPORT ifdefs
 * 	[1996/03/29  21:57:01  Hans_Graves]
 * 
 * 	Added MPEG-I Systems encoding support
 * 	[1996/03/27  21:55:57  Hans_Graves]
 * 
 * Revision 1.1.4.3  1996/03/12  16:15:52  Hans_Graves
 * 	Changed hard coded File buffer size to param
 * 	[1996/03/12  15:57:23  Hans_Graves]
 * 
 * Revision 1.1.4.2  1996/03/08  18:46:46  Hans_Graves
 * 	Increased Buffer size
 * 	[1996/03/08  18:40:59  Hans_Graves]
 * 
 * Revision 1.1.2.13  1996/02/23  22:17:09  Hans_Graves
 * 	Fixed bad handling of large packets in ParseMpeg1()
 * 	[1996/02/23  21:56:15  Hans_Graves]
 * 
 * Revision 1.1.2.12  1996/02/21  22:52:46  Hans_Graves
 * 	Fixed MPEG 2 systems stuff
 * 	[1996/02/21  22:51:11  Hans_Graves]
 * 
 * Revision 1.1.2.11  1996/02/19  20:09:29  Hans_Graves
 * 	Debugging message clean-up
 * 	[1996/02/19  20:08:34  Hans_Graves]
 * 
 * Revision 1.1.2.10  1996/02/19  18:03:58  Hans_Graves
 * 	Fixed a number of MPEG related bugs
 * 	[1996/02/19  17:57:43  Hans_Graves]
 * 
 * Revision 1.1.2.9  1996/02/13  18:47:50  Hans_Graves
 * 	Fix some Seek related bugs
 * 	[1996/02/13  18:40:40  Hans_Graves]
 * 
 * Revision 1.1.2.8  1996/02/07  23:23:57  Hans_Graves
 * 	Added SEEK_EXACT. Fixed most frame counting problems.
 * 	[1996/02/07  23:20:34  Hans_Graves]
 * 
 * Revision 1.1.2.7  1996/02/06  22:54:07  Hans_Graves
 * 	Seek fix-ups. More accurate MPEG frame counts.
 * 	[1996/02/06  22:45:02  Hans_Graves]
 * 
 * Revision 1.1.2.6  1996/01/30  22:23:09  Hans_Graves
 * 	Added AVI YUV support
 * 	[1996/01/30  22:21:41  Hans_Graves]
 * 
 * Revision 1.1.2.5  1996/01/15  16:26:31  Hans_Graves
 * 	Reorganized Parsing, Added Wave file support
 * 	[1996/01/15  15:46:56  Hans_Graves]
 * 
 * Revision 1.1.2.4  1996/01/11  16:17:32  Hans_Graves
 * 	Added MPEG II Systems decode support
 * 	[1996/01/11  16:12:38  Hans_Graves]
 * 
 * Revision 1.1.2.3  1996/01/08  16:41:34  Hans_Graves
 * 	Added MPEG II decoding support
 * 	[1996/01/08  15:53:07  Hans_Graves]
 * 
 * Revision 1.1.2.2  1995/12/08  20:01:23  Hans_Graves
 * 	Creation. Split off from slib_api.c
 * 	[1995/12/08  19:57:18  Hans_Graves]
 * 
 * $EndLog$
 */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

/*
#define _SLIBDEBUG_
*/

#ifdef WIN32
#include <io.h>
#endif
#include <stdio.h>
#ifdef _SHM_
#include  <sys/ipc.h>  /* shared memory */
#endif
#define SLIB_INTERNAL
#include "slib.h"
#include "SC_err.h"
#include "mpeg.h"
#include "avi.h"

#ifdef _SLIBDEBUG_
#include "sc_debug.h"
#define _DEBUG_     0  /* detailed debuging statements: if >1 more detail */
#define _VERBOSE_   0  /* show progress */
#define _VERIFY_    1  /* verify correct operation */
#define _WARN_      1  /* warnings about strange behavior: 2=lower warnings */
#define _MEMORY_    0  /* memory debugging: if >1 more detail */
#define _WRITE_     0  /* data writing debugging */
#define _TIMECODE_  0  /* timecode/timestamp debugging */
#define _PARSE_     0  /* parsing debugging */

#endif

/************************** Memory Allocation ***********************/
typedef struct slibMemory_s {
    unsigned char *address;
    long           shmid;
    unsigned dword   size;
    int            count;
    ScBoolean_t    user;
    SlibInfo_t    *sinfo;
    void          *uinfo; /* userdata */
    struct slibMemory_s *next;
} slibMemory_t;

static slibMemory_t *_slibMemoryList = NULL;
static slibMemory_t *_slibMemoryListTail = NULL;
static dword _slibMemoryCount = 0;
static unsigned qword _slibMemoryUsed = 0L;
#ifdef WIN32
static HANDLE _slibMemoryMutex = NULL;
#define slibInitMemoryMutex()  if (_slibMemoryMutex==NULL) \
                                 _slibMemoryMutex=CreateMutex(NULL, FALSE, NULL)
#define slibFreeMemoryMutex()  if (_slibMemoryMutex!=NULL) \
                               CloseHandle(_slibMemoryMutex); _slibMemoryMutex=NULL
#define slibEnterMemorySection()  WaitForSingleObject(_slibMemoryMutex, 5000);
#define slibExitMemorySection()   ReleaseMutex(_slibMemoryMutex)
#else
#define slibInitMemoryMutex()
#define slibFreeMemoryMutex()
#define slibEnterMemorySection()
#define slibExitMemorySection()
#endif



void slibDumpMemory()
{
  if (_slibMemoryList)
  {
    slibMemory_t *tmpmem = _slibMemoryList;
    while (tmpmem)
    {
      printf("address: %p  size: %d  count: %d  user: %s\n",
              tmpmem->address, tmpmem->size, tmpmem->count,
              tmpmem->user ? "TRUE" : "FALSE");
      tmpmem = tmpmem->next;
    }
  }
  else
    printf("No memory allocated\n");
}

unsigned qword SlibMemUsed()
{
  return(_slibMemoryUsed);
}

void *SlibAllocBuffer(unsigned dword bytes)
{
  unsigned char *address;
  _SlibDebug(_MEMORY_,
    printf("SlibAllocBuffer(%d) MemoryCount=%d Used=%d\n", 
            bytes, _slibMemoryCount, _slibMemoryUsed));
  if (bytes<=0)
    return(NULL);
  address=ScAlloc(bytes);
  if (address)
  {
    slibMemory_t *tmpmem = ScAlloc(sizeof(slibMemory_t));
    if (!tmpmem)
    {
      ScFree(address);
      return(NULL);
    }
    tmpmem->address = address;
    tmpmem->shmid = -1;
    tmpmem->size = bytes;
    tmpmem->count = 1;
    tmpmem->user = FALSE;
    tmpmem->sinfo = NULL;
    tmpmem->uinfo = NULL;
    slibInitMemoryMutex();
    slibEnterMemorySection();
    tmpmem->next = _slibMemoryList;
    if (_slibMemoryList == NULL)
      _slibMemoryListTail = tmpmem;
    _slibMemoryList = tmpmem;
    _slibMemoryCount++;
    _slibMemoryUsed+=bytes;
    slibExitMemorySection();
  }
  _SlibDebug(_WARN_ && address==NULL, 
                printf("SlibAllocBuffer() couldn't alloc\n") );
  return(address);
}

/*
** Name: SlibAllocBufferEx
** Desc: Allocate a buffer that is associated with a specific handle
*/
void *SlibAllocBufferEx(SlibHandle_t handle, unsigned dword bytes)
{
  unsigned char *address;
  _SlibDebug(_MEMORY_,
    printf("SlibAllocBufferEx(%p, bytes=%d) MemoryCount=%d Used=%d\n", 
            handle, bytes, _slibMemoryCount, _slibMemoryUsed));
  if (bytes<=0)
    return(NULL);
  address=ScAlloc(bytes);
  if (address)
  {
    slibMemory_t *tmpmem = ScAlloc(sizeof(slibMemory_t));
    if (!tmpmem)
    {
      ScFree(address);
      return(NULL);
    }
    tmpmem->address = address;
    tmpmem->shmid = -1;
    tmpmem->size = bytes;
    tmpmem->count = 1;
    tmpmem->user = FALSE;
    tmpmem->sinfo = handle;
    tmpmem->uinfo = NULL;
    slibInitMemoryMutex();
    slibEnterMemorySection();
    tmpmem->next = _slibMemoryList;
    if (_slibMemoryList == NULL)
      _slibMemoryListTail = tmpmem;
    _slibMemoryList = tmpmem;
    _slibMemoryCount++;
    _slibMemoryUsed+=bytes;
    slibExitMemorySection();
  }
  _SlibDebug(_WARN_ && address==NULL, 
                printf("SlibAllocBufferEx() couldn't alloc\n") );
  return(address);
}

void *SlibAllocSharedBuffer(unsigned dword bytes, int *shmid)
{
  unsigned char *address;
  long id;
  _SlibDebug(_MEMORY_, printf("SlibAllocSharedBuffer(%d)\n", bytes) );
  if (bytes<=0)
    return(NULL);
#ifdef _SHM_
  id = shmget(IPC_PRIVATE, bytes, IPC_CREAT|0777);
  if (id < 0)
    return(NULL);
  address = (unsigned char *)shmat(id, 0, 0);
  if (address == ((caddr_t) -1))
    return(NULL);
#else
  address=(unsigned char *)ScPaMalloc(bytes);
  id=0;
#endif

  if (address)
  {
    slibMemory_t *tmpmem = ScAlloc(sizeof(slibMemory_t));
    _SlibDebug((_MEMORY_||_WARN_) && (((unsigned dword)address)&0x03),
             printf("SlibAllocSharedBuffer(%d) Unaligned address=%p shmid=%d\n",
                 bytes, address, id) );
    if (!tmpmem)
    {
#ifdef _SHM_
      shmdt (address);
      shmctl(id, IPC_RMID, 0);
#else
      ScPaFree(address);
#endif
      return(NULL);
    }
    tmpmem->address = address;
    tmpmem->shmid = id;
    _SlibDebug(_MEMORY_ && id>=0,
             printf("SlibAllocSharedBuffer(%d) address=%p shmid=%d\n",
                 bytes, address, id) );
    tmpmem->size = bytes;
    tmpmem->count = 1;
    tmpmem->user = FALSE;
    tmpmem->sinfo = NULL;
    tmpmem->uinfo = NULL;
    slibInitMemoryMutex();
    slibEnterMemorySection();
    tmpmem->next = _slibMemoryList;
    if (_slibMemoryList == NULL)
      _slibMemoryListTail = tmpmem;
    _slibMemoryList = tmpmem;
    _slibMemoryCount++;
    _slibMemoryUsed+=bytes;
    slibExitMemorySection();
    if (shmid)
      *shmid = id;
  }
  return(address);
}

dword SlibGetSharedBufferID(void *address)
{
  dword shmid=-1;
  _SlibDebug(_MEMORY_,
    printf("SlibGetSharedBufferID(%p) _slibMemoryCount=%d\n", 
                         address, _slibMemoryCount));
  slibEnterMemorySection();
  if (_slibMemoryList)
  {
    slibMemory_t *tmpmem = _slibMemoryList;
    while (tmpmem)
    {
      if ((unsigned char *)address>=tmpmem->address && 
          (unsigned char *)address<tmpmem->address+tmpmem->size)
      {
        shmid=tmpmem->shmid;
        break;
      }
      tmpmem = tmpmem->next;
    }
  }
  slibExitMemorySection();
  return(shmid);
}

/*
** Name: SlibValidBuffer
** Desc: Check if an address is in a SLIB allocated buffer.
*/
SlibBoolean_t SlibValidBuffer(void *address)
{
  SlibBoolean_t isvalid=FALSE;
  _SlibDebug(_MEMORY_,
    printf("SlibValidBuffer(%p) _slibMemoryCount=%d\n", 
                         address, _slibMemoryCount));
  slibEnterMemorySection();
  if (_slibMemoryList)
  {
    slibMemory_t *tmpmem = _slibMemoryList;
    while (tmpmem)
    {
      if ((unsigned char *)address>=tmpmem->address && 
          (unsigned char *)address<tmpmem->address+tmpmem->size)
      {
        isvalid=TRUE;
        break;
      }
      tmpmem = tmpmem->next;
    }
  }
  slibExitMemorySection();
  return(isvalid);
}

SlibStatus_t SlibFreeBuffer(void *address)
{
  _SlibDebug(_MEMORY_>1,
    printf("SlibFreeBuffer(%p) MemoryCount=%d Used=%d\n", 
            address, _slibMemoryCount, _slibMemoryUsed));
  slibEnterMemorySection();
  if (_slibMemoryList)
  {
    slibMemory_t *tmpmem = _slibMemoryList;
    slibMemory_t *lastmem = NULL;
    while (tmpmem)
    {
      if ((unsigned char *)address>=tmpmem->address &&
	  (unsigned char *)address<tmpmem->address+tmpmem->size)
      {
        if (--tmpmem->count>0)  /* memory was allocated more than once */
        {
          slibExitMemorySection();
          return(SlibErrorNone);
        }
        _SlibDebug(_MEMORY_,  
                    printf("SlibFreeBuffer(%p) final free: shmid=%d size=%d\n",
                        tmpmem->address, tmpmem->shmid, tmpmem->size) );
        /* remove memory from mem list */
        if (tmpmem == _slibMemoryList)
          _slibMemoryList = tmpmem->next;
        else
          lastmem->next = tmpmem->next;
        if (tmpmem == _slibMemoryListTail)
          _slibMemoryListTail = lastmem;
        /* now actually free the memory */
        if (tmpmem->user)
        {
          if (tmpmem->sinfo && tmpmem->sinfo->SlibCB)
          {
            slibExitMemorySection();
            _SlibDebug(_VERBOSE_,
              printf("SlibFreeBuffer() SlibCB(SLIB_MSG_BUFDONE, %p, %d)\n",
                     tmpmem->address, tmpmem->size) );
            tmpmem->user=FALSE;
            (*(tmpmem->sinfo->SlibCB))((SlibHandle_t)tmpmem->sinfo,
                        SLIB_MSG_BUFDONE, (SlibCBParam1_t)tmpmem->address, 
                                          (SlibCBParam2_t)tmpmem->size,
                        tmpmem->uinfo?tmpmem->uinfo
                                     :(void *)tmpmem->sinfo->SlibCBUserData);
            slibEnterMemorySection();
          }
        }
        else if (tmpmem->shmid < 0)
        {
          _SlibDebug(_MEMORY_, printf("SlibFreeBuffer() ScFree(%p) %d bytes\n",
                     tmpmem->address, tmpmem->size) );
          ScFree(tmpmem->address);
        }
        else  /* shared memory */
#ifdef _SHM_
        {
          _SlibDebug(_MEMORY_, printf("SlibFreeBuffer() shmdt(%p) %d bytes\n",
                     tmpmem->address, tmpmem->size) );
          shmdt (tmpmem->address);
          shmctl(tmpmem->shmid, IPC_RMID, 0);
        }
#else
        {
          _SlibDebug(_MEMORY_,
                printf("SlibFreeBuffer() ScPaFree(%p) %d bytes\n",
                     tmpmem->address, tmpmem->size) );
          ScPaFree(tmpmem->address);
        }
#endif
        _slibMemoryCount--;
        _slibMemoryUsed-=tmpmem->size;
        ScFree(tmpmem);
        slibExitMemorySection();
        if (_slibMemoryList==NULL) /* last memory in list was freed */
        {
          slibFreeMemoryMutex();
        }
        return(SlibErrorNone);
      }
      lastmem = tmpmem;
      _SlibDebug(_VERIFY_ && (tmpmem == tmpmem->next),
                 printf("SlibFreeBuffer() tmpmem == tmpmem->next\n");
                 return(SlibErrorMemory) );
      _SlibDebug(_VERIFY_ && (tmpmem->next==_slibMemoryList),
                 printf("SlibFreeBuffer() tmpmem->next == _slibMemoryList\n");
                 return(SlibErrorMemory) );
      tmpmem = tmpmem->next;
    }
  }
  _SlibDebug(_WARN_, printf("SlibFreeBuffer(%p) couldn't free\n",address) );
  slibExitMemorySection();
  return(SlibErrorBadArgument);
}

/*
** Name:    SlibFreeBuffers
** Purpose: Free all buffers associated with a handle.
**          If handle==NULL free all memory.
*/
SlibStatus_t SlibFreeBuffers(SlibHandle_t handle)
{
  _SlibDebug(_MEMORY_>1,
    printf("SlibFreeBuffers() MemoryCount=%d Used=%d\n", 
            _slibMemoryCount, _slibMemoryUsed));
  slibEnterMemorySection();
  if (_slibMemoryList)
  {
    slibMemory_t *tmpmem = _slibMemoryList;
    slibMemory_t *lastmem = NULL, *nextmem=NULL;
    while (tmpmem)
    {
      nextmem = tmpmem->next;
      if (handle==NULL || tmpmem->sinfo==handle)
      {
        _SlibDebug(_MEMORY_,  
                    printf("SlibFreeBuffer(%p) final free: shmid=%d size=%d\n",
                        tmpmem->address, tmpmem->shmid, tmpmem->size) );
        /* remove memory from mem list */
        if (tmpmem == _slibMemoryList)
          _slibMemoryList = tmpmem->next;
        else
          lastmem->next = tmpmem->next;
        if (tmpmem == _slibMemoryListTail)
          _slibMemoryListTail = lastmem;
        /* now actually free the memory */
        if (tmpmem->user)
        {
          if (tmpmem->sinfo && tmpmem->sinfo->SlibCB)
          {
            slibExitMemorySection();
            _SlibDebug(_VERBOSE_,
              printf("SlibFreeBuffer() SlibCB(SLIB_MSG_BUFDONE, %p, %d)\n",
                     tmpmem->address, tmpmem->size) );
            tmpmem->user=FALSE;
            (*(tmpmem->sinfo->SlibCB))((SlibHandle_t)tmpmem->sinfo,
                        SLIB_MSG_BUFDONE, (SlibCBParam1_t)tmpmem->address, 
                                          (SlibCBParam2_t)tmpmem->size,
                        tmpmem->uinfo?tmpmem->uinfo
                                     :(void *)tmpmem->sinfo->SlibCBUserData);
            slibEnterMemorySection();
          }
        }
        else if (tmpmem->shmid < 0)
        {
          _SlibDebug(_MEMORY_, printf("SlibFreeBuffer() ScFree(%p) %d bytes\n",
                     tmpmem->address, tmpmem->size) );
          ScFree(tmpmem->address);
        }
        else  /* shared memory */
#ifdef _SHM_
        {
          _SlibDebug(_MEMORY_, printf("SlibFreeBuffer() shmdt(%p) %d bytes\n",
                     tmpmem->address, tmpmem->size) );
          shmdt (tmpmem->address);
          shmctl(tmpmem->shmid, IPC_RMID, 0);
        }
#else
        {
          _SlibDebug(_MEMORY_,
                printf("SlibFreeBuffer() ScPaFree(%p) %d bytes\n",
                     tmpmem->address, tmpmem->size) );
          ScPaFree(tmpmem->address);
        }
#endif
        _slibMemoryCount--;
        _slibMemoryUsed-=tmpmem->size;
        ScFree(tmpmem);
        if (_slibMemoryList==NULL) /* last memory in list was freed */
        {
          slibExitMemorySection();
          slibFreeMemoryMutex();
          return(SlibErrorNone);
        }
      }
      lastmem = tmpmem;
      _SlibDebug(_VERIFY_ && (tmpmem == nextmem),
                 printf("SlibFreeBuffer() tmpmem == tmpmem->next\n");
                 return(SlibErrorMemory) );
      _SlibDebug(_VERIFY_ && (nextmem==_slibMemoryList),
                 printf("SlibFreeBuffer() tmpmem->next == _slibMemoryList\n");
                 return(SlibErrorMemory) );
      tmpmem = nextmem;
    }
  }
  slibExitMemorySection();
  return(SlibErrorNone);
}

/*
** Name:    SlibAllocSubBuffer
** Purpose: Allocate a subsection of a buffer.
*/
SlibStatus_t SlibAllocSubBuffer(void *address, unsigned dword bytes)
{
  _SlibDebug(_MEMORY_>1, printf("SlibAllocSubBuffer() _slibMemoryCount=%d\n",
                                                _slibMemoryCount) );
  slibEnterMemorySection();
  if (_slibMemoryList)
  {
    slibMemory_t *tmpmem = _slibMemoryList;
    while (tmpmem)
    {
      if ((unsigned char *)address>=tmpmem->address && 
	  (unsigned char *)address<tmpmem->address+tmpmem->size)
      {
        if ((char *)address+bytes>tmpmem->address+tmpmem->size)
        {
          _SlibDebug(_VERIFY_, 
              printf("SlibAllocSubBuffer(bytes=%d) out of range by %d bytes\n",
                bytes,(unsigned long)(tmpmem->address+tmpmem->size)
                      -(unsigned long)((char *)address+bytes)) );
          slibExitMemorySection();
          return(SlibErrorMemory);
        }
        tmpmem->count++;
        slibExitMemorySection();
        return(SlibErrorNone);
      }
      _SlibDebug(_VERIFY_ && (tmpmem == tmpmem->next),
               printf("SlibAllocSubBuffer() tmpmem == tmpmem->next\n");
               return(SlibErrorMemory) );
      _SlibDebug(_VERIFY_ && (tmpmem->next==_slibMemoryList),
               printf("SlibAllocSubBuffer() tmpmem->next == _slibMemoryList\n");
               return(SlibErrorMemory) );
      tmpmem = tmpmem->next;
    }
  }
  _SlibDebug(_WARN_ && address==NULL, 
                printf("SlibAllocSubBuffer() couldn't alloc\n") );
  slibExitMemorySection();
  return(SlibErrorBadArgument);
}

/*
** Name:    SlibManageUserBuffer
** Purpose: Add a user's buffer to the memory queue, in order to keep
**          track of it.
*/
SlibStatus_t slibManageUserBuffer(SlibInfo_t *Info, void *address, 
                                  unsigned dword bytes, void *userdata)
{
  _SlibDebug(_MEMORY_, printf("slibManageUserBuffer() _slibMemoryCount=%d\n",
                                                _slibMemoryCount) );
  slibEnterMemorySection();
  if (_slibMemoryList)
  {
    slibMemory_t *tmpmem = _slibMemoryList;
    while (tmpmem)
    {
      if ((unsigned char *)address>=tmpmem->address && 
	  (unsigned char *)address<tmpmem->address+tmpmem->size)
      {
        if ((char *)address+bytes>tmpmem->address+tmpmem->size)
        {
          _SlibDebug(_VERIFY_, 
              printf("SlibAllocSubBuffer(bytes=%d) out of range by %d bytes\n",
                bytes,(unsigned long)(tmpmem->address+tmpmem->size)
                      -(unsigned long)((char *)address+bytes)) );
          slibExitMemorySection();
          return(SlibErrorMemory);
        }
        if (tmpmem->user == TRUE) /* already a user buffer */
          tmpmem->count++;
        else
          tmpmem->user = TRUE;
        if (Info)
          tmpmem->sinfo=Info;
        if (userdata)
          tmpmem->uinfo = userdata;
        _SlibDebug(_MEMORY_,
                   printf("slibManageUserBuffer() Allocated by SLIB: %p\n",
                            address) );
        slibExitMemorySection();
        return(SlibErrorNone);
      }
      tmpmem = tmpmem->next;
    }
  }
  if (address)
  {
    slibMemory_t *tmpmem = ScAlloc(sizeof(slibMemory_t));
    if (!tmpmem)
      return(SlibErrorMemory);
    tmpmem->address = address;
    tmpmem->shmid = -1;
    tmpmem->size = bytes;
    tmpmem->count = 1;   /* was not allocated by SLIB */
    tmpmem->user = TRUE;
    tmpmem->sinfo = Info;
    tmpmem->uinfo = userdata;
    tmpmem->next = _slibMemoryList;
    if (_slibMemoryList == NULL)
      _slibMemoryListTail = tmpmem;
    _slibMemoryList = tmpmem;
    _slibMemoryCount++;
    _slibMemoryUsed+=bytes;
    _SlibDebug(_MEMORY_,
                   printf("slibManageUserBuffer() New memory entry\n") );
    slibExitMemorySection();
    return(SlibErrorNone);
  }
  slibExitMemorySection();
  return(SlibErrorBadArgument);
}


/************************** Internal Buffer Stuff ***********************/

#define _getbyte(var) \
     if (top==bot) { \
        var = *buf++; \
        if (--bufsize==0) { \
          if (discard) { \
            SlibFreeBuffer(bufstart); \
            buf=bufstart=slibGetBufferFromPin(Info, pin, &bufsize, NULL); \
          } \
          else \
            buf=slibPeekNextBufferOnPin(Info, pin, buf-1, &bufsize, NULL); \
          if (!buf) return(NULL); \
        } \
     } else var=sbyte[top++];

#define _storebyte(val)  if (top==bot) {top=0; bot=1; sbyte[0]=val; } \
                             else sbyte[bot++]=val;

unsigned char *slibSearchBuffersOnPin(SlibInfo_t *Info, SlibPin_t *pin,
                                 unsigned char *lastbuf, unsigned dword *size,
                                 unsigned dword code, int codebytes,
                                 ScBoolean_t discard)
{
  unsigned char *buf, *bufstart;
  unsigned char abyte, byte0, byte1, byte2, byte3, sbyte[16];
  int bot, top;
  unsigned dword bufsize;
  _SlibDebug(_DEBUG_>1, 
        printf("slibSearchBuffersOnPin(%s, code=0x%08lX, codebytes=%d)\n",
                          pin->name, code, codebytes) );
  if (!Info || !pin)
    return(NULL);
  for (top=codebytes-1; top>=0; top--)
  {
    sbyte[top]=code & 0xFF;
    code>>=8;
  }
  byte0=sbyte[0];
  byte1=sbyte[1];
  byte2=sbyte[2];
  byte3=sbyte[3];
  top=bot=0;
  if (lastbuf)
  {
    buf=bufstart=lastbuf;
    bufsize=*size;
  }
  else if (discard)
  {
    buf=bufstart=slibGetBufferFromPin(Info, pin, &bufsize, NULL);
  }
  else
    buf=slibPeekBufferOnPin(Info, pin, &bufsize, NULL);
  if (!buf || codebytes<=0 || !bufsize)
  {
    _SlibDebug(_WARN_ && buf==lastbuf, 
             printf("slibSearchBuffersOnPin(%s) no search made\n",pin->name) );
    return(buf);
  }
/*
  ScDumpChar(buf,bufsize,0);
*/
  while (buf)
  {
/*
    printf("level=0 top=%d bot=%d\n", top, bot);
    printf("buf=%p abyte=%d\n",buf, abyte);
*/
    _getbyte(abyte);
    if (abyte == byte0)
    {
      if (codebytes==1)
      {
        if (discard)
          { SlibAllocSubBuffer(buf, bufsize); SlibFreeBuffer(bufstart); }
        *size=bufsize;
        return(buf);
      }
      _getbyte(abyte);
      if (abyte == byte1)
      {
        if (codebytes==2)
        {
          if (discard)
            { SlibAllocSubBuffer(buf, bufsize); SlibFreeBuffer(bufstart); }
          *size=bufsize;
          return(buf);
        }
        _getbyte(abyte);
        if (abyte == byte2)
        {
          if (codebytes==3)
          {
            if (discard)
              { SlibAllocSubBuffer(buf, bufsize); SlibFreeBuffer(bufstart); }
            *size=bufsize;
            return(buf);
          }
          _getbyte(abyte);
          if (abyte == byte3)
          {
            if (codebytes==4)
            {
              if (discard)
                { SlibAllocSubBuffer(buf, bufsize); SlibFreeBuffer(bufstart); }
              *size=bufsize;
              return(buf);
            }
          }
          else
          {
            _storebyte(byte1);
            _storebyte(byte2);
            _storebyte(abyte);
          }
        }
        else
        {
          _storebyte(byte1);
          _storebyte(abyte);
        }
      }
      else
        _storebyte(abyte);
    }
  }
  _SlibDebug(_DEBUG_, printf("slibSearchBuffersOnPin() Not found\n") );
  return(NULL);
}

#define _getbyte2(var) \
     if (top==bot) { \
        var = *buf++; totallen++; \
        if (--bufsize==0) { \
          buf=slibPeekNextBufferOnPin(Info, pin, buf-1, &bufsize, NULL); \
          if (!buf) { \
            _SlibDebug(_VERBOSE_,printf("slibCountCodesOnPin() out (EOI)\n")); \
            return(count); } \
        } \
     } else var=sbyte[top++];

/*
** Name: slibCountCodesOnPin
** Description: Count the occurrances of a particular code in a Pin's 
**              data stream.
**     maxlen: 0  counts till end of data
**             -1 counts buffers already loaded on pin
*/
dword slibCountCodesOnPin(SlibInfo_t *Info, SlibPin_t *pin,
                                 unsigned dword code, int codebytes, 
                                 unsigned dword maxlen)
{
  unsigned char *buf;
  unsigned char abyte, byte0, byte1, byte2, byte3, sbyte[16];
  int bot, top, count=0;
  unsigned dword bufsize;
  unsigned long totallen=0;
  _SlibDebug((_DEBUG_||_WARN_) && (!pin || !pin->name), 
            printf("slibCountCodesOnPin() bad pin\n") );
  if (!Info || !pin)
    return(count);
  _SlibDebug(_DEBUG_||_VERBOSE_, 
            printf("slibCountCodesOnPin(%s) in\n", pin->name) );
  for (top=codebytes-1; top>=0; top--)
  {
    sbyte[top]=code & 0xFF;
    code>>=8;
  }
  byte0=sbyte[0];
  byte1=sbyte[1];
  byte2=sbyte[2];
  byte3=sbyte[3];
  top=bot=0;
  buf=slibPeekBufferOnPin(Info, pin, &bufsize, NULL);
  if (!buf || codebytes<=0)
    return(count);
  while (buf && (maxlen<=0 || totallen<maxlen))
  {
    _getbyte2(abyte);
    if (abyte == byte0)
    {
      if (codebytes==1)
      {
        count++;
        top=bot=0;
        continue;
      }
      _getbyte2(abyte);
      if (abyte == byte1)
      {
        if (codebytes==2)
        {
          count++;
          top=bot=0;
          continue;
        }
        _getbyte2(abyte);
        if (abyte == byte2)
        {
          if (codebytes==3)
          {
            count++;
            top=bot=0;
            continue;
          }
          _getbyte2(abyte);
          if (abyte == byte3)
          {
            if (codebytes==4)
            {
              count++;
              top=bot=0;
              continue;
            }
          }
          else
          {
            _storebyte(byte1);
            _storebyte(byte2);
            _storebyte(abyte);
          }
        }
        else
        {
          _storebyte(byte1);
          _storebyte(abyte);
        }
      }
      else
        _storebyte(abyte);
    }
  }
  _SlibDebug(_VERBOSE_, printf("slibCountCodesOnPin() out\n") );
  return(count);
}

/*
** Name:    SlibGetBuffer
** Purpose: Read the next buffer from the data source.
*/
unsigned char *SlibGetBuffer(SlibInfo_t *Info, int pinid,
                             unsigned dword *psize, SlibTime_t *ptime)
{
  unsigned char *address=NULL;
  SlibPin_t *pin;
  _SlibDebug(_DEBUG_>1, printf("SlibGetBuffer\n") );
  if (!Info)
    return(NULL);
  if (!psize)
    return(NULL);
  pin=slibLoadPin(Info, pinid);
  if (pin)
    return(slibGetBufferFromPin(Info, pin, psize, ptime));
  else
  {
    if (psize)
      *psize=0;
    if (ptime)
      *ptime=SLIB_TIME_NONE;
    _SlibDebug(_WARN_, 
                printf("SlibGetBuffer(pinid=%d) couldn't get\n",pinid) );
    return(NULL);
  }
}

/*
** Name:    SlibPeekBuffer
** Purpose: Read the next buffer from the data source.
*/
unsigned char *SlibPeekBuffer(SlibInfo_t *Info, int pinid,
                              unsigned dword *psize, SlibTime_t *ptime)
{
  unsigned char *address=NULL;
  SlibPin_t *pin;
  _SlibDebug(_DEBUG_>1, printf("SlibPeekBuffer\n") );
  if (!Info)
    return(NULL);
  pin=slibLoadPin(Info, pinid);
  if (pin)
    return(slibPeekBufferOnPin(Info, pin, psize, ptime));
  else
  {
    if (psize)
      *psize=0;
    if (ptime)
      *ptime=SLIB_TIME_NONE;
    _SlibDebug(_WARN_, 
                printf("SlibPeekBuffer(pinid=%d) couldn't peek\n",pinid) );
    return(NULL);
  }
}

/************************** Pins ***********************/
SlibBoolean_t slibPinOverflowing(SlibInfo_t *Info, SlibPin_t *pin)
{
  if (pin==NULL)
    return(TRUE);
/*
  _SlibDebug(_WARN_ && pin->DataSize>(Info->OverflowSize*2)/3,
        printf("Data almost overflowing: %d bytes\n", pin->DataSize) );
*/
  return(pin->DataSize>(long)Info->OverflowSize ? TRUE : FALSE);
}

void slibRemovePins(SlibInfo_t *Info)
{
  _SlibDebug(_VERBOSE_, printf("slibRemovePins()\n") );
  while (Info->Pins)
    slibRemovePin(Info, Info->Pins->ID);
}

void slibEmptyPins(SlibInfo_t *Info)
{
  SlibPin_t *pin=Info->Pins;
  _SlibDebug(_VERBOSE_, printf("slibEmptyPins()\n") );
  while (pin)
  {
    slibEmptyPin(Info, pin->ID);
    pin = pin->next;
  }
}

SlibPin_t *slibGetPin(SlibInfo_t *Info, int pinid)
{
  SlibPin_t *pin=Info->Pins;
  while (pin)
  {
    if (pin->ID == pinid)
      return(pin);
    pin = pin->next;
  }
  return(NULL);
}

SlibPin_t *slibRenamePin(SlibInfo_t *Info, int oldpinid,
                                           int newpinid, char *newname)
{
  SlibPin_t *pin=Info->Pins;
  pin=slibGetPin(Info, oldpinid);
  if (pin==NULL) /* pin doesn't exist */
    return(NULL);
  /* if a pin with the new ID already exists, delete it */
  slibRemovePin(Info, newpinid);
  /* rename it */
  pin->ID=newpinid;
  if (newname)
    strcpy(pin->name, newname);
  return(pin);
}

SlibPin_t *slibAddPin(SlibInfo_t *Info, int pinid, char *name)
{
  SlibPin_t *pin=Info->Pins, *newpin;
  int i;
  _SlibDebug(_DEBUG_||_VERBOSE_, printf("slibAddPin(%s)\n",name) );
  while (pin)
  {
    if (pin->ID == pinid)
      return(pin);
    pin = pin->next;
  }
  if ((newpin = ScAlloc(sizeof(SlibPin_t)))==NULL)
    return(NULL);
  newpin->ID = pinid;
  for (i=0; i<(sizeof(newpin->name)-1) && name && *name; i++)
    newpin->name[i]=*name++;
  newpin->name[i]=0;
  newpin->next=Info->Pins;
  newpin->Buffers=NULL;
  newpin->BuffersTail=NULL;
  newpin->BufferCount=0;
  newpin->DataSize=0;
  newpin->Offset=0;
  Info->Pins = newpin;
  Info->PinCount++;
  
  return(newpin);
}

/*
** Name:    slibAddBufferToPin
** Purpose: Add a buffer to data source buffer queue.
*/
SlibStatus_t slibAddBufferToPin(SlibPin_t *pin, 
                     void *buffer, unsigned dword size, SlibTime_t time)
{
  SlibBuffer_t *newbuf;
  _SlibDebug(_DEBUG_,
     printf("slibAddBufferToPin(%s, %d)\n", pin->name, size) );
  _SlibDebug(_WARN_ && size==0,
      printf("slibAddBufferToPin(%s, %p, size=%d)\n", pin->name, buffer, size) );
  if (!pin || !buffer || !size)
    return(SlibErrorBadArgument);
  if ((newbuf = ScAlloc(sizeof(SlibBuffer_t)))==NULL)
    return(SlibErrorMemory);
  newbuf->address = buffer;
  newbuf->size = size;
  if (pin->BuffersTail)
    newbuf->offset = pin->BuffersTail->offset+pin->BuffersTail->size;
  else
    newbuf->offset = pin->Offset;
  newbuf->time = time;
  newbuf->next = NULL;
  if (pin->BuffersTail==NULL)
    pin->Buffers=newbuf;
  else
    pin->BuffersTail->next=newbuf;
  pin->BuffersTail = newbuf;
  pin->BufferCount++;
  pin->DataSize+=newbuf->size;
  return(SlibErrorNone);
}

/*
** Name:    slibInsertBufferOnPin
** Purpose: Add a buffer at the head of a data source's buffer queue.
*/
SlibStatus_t slibInsertBufferOnPin(SlibPin_t *pin, void *buffer,
                                 unsigned dword size, SlibTime_t time)
{
  SlibBuffer_t *newbuf;
  _SlibDebug(_DEBUG_>1, 
      printf("slibInsertBufferOnPin(%s, size=%d)\n", pin->name, size) );
  _SlibDebug((_WARN_ && !_DEBUG_) && size==0, 
      printf("slibInsertBufferOnPin(%s, size=%d)\n", pin->name, size) );
  if (!pin || !buffer || !size)
    return(SlibErrorBadArgument);
  if ((newbuf = ScAlloc(sizeof(SlibBuffer_t)))==NULL)
    return(SlibErrorMemory);
  newbuf->address = buffer;
  newbuf->size = size;
  pin->Offset-=size;
  newbuf->offset = pin->Offset;
  newbuf->time = time;
  newbuf->next = pin->Buffers;
  pin->Buffers=newbuf;
  if (pin->BuffersTail == NULL)
    pin->BuffersTail = newbuf;
  pin->BufferCount++;
  pin->DataSize+=newbuf->size;
  return(SlibErrorNone);
}

qword slibSkipDataOnPin(SlibInfo_t *Info, SlibPin_t *pin, 
                                qword totalbytes)
{
  qword skippedbytes=0;
  _SlibDebug(_VERBOSE_ || 1, printf("slibSkipDataOnPin() in\n") );
  if (pin && totalbytes>0)
  {
    qword startsize;
    unsigned char *buf;
    unsigned dword size;
    SlibTime_t time, newtime;
    startsize=pin->DataSize;
    buf=slibGetBufferFromPin(Info, pin, &size, &time);
    while (buf && skippedbytes+size<totalbytes)
    {
      skippedbytes+=size;
      SlibFreeBuffer(buf);
      buf=slibGetBufferFromPin(Info, pin, &size, &newtime);
      if (newtime!=SLIB_TIME_NONE)
        time=newtime;
    }
    if (buf && skippedbytes+size>=totalbytes)
    {
      size-=(unsigned dword)(totalbytes-skippedbytes);
      if (size) /* put remainer of buffer back on pin */
      {
        SlibAllocSubBuffer(buf+totalbytes-skippedbytes, size);
        slibInsertBufferOnPin(pin, buf+totalbytes-skippedbytes, size, time);
      }
      SlibFreeBuffer(buf);
      skippedbytes=totalbytes;
    }
    _SlibDebug(_WARN_ && pin->DataSize+skippedbytes!=startsize,
      printf("slibSkipDataOnPin() Skipped %d bytes, startsize=%d newsize=%d\n",
            skippedbytes, startsize, pin->DataSize) );
  }
  _SlibDebug(_VERBOSE_ || 1, printf("slibSkipDataOnPin() out\n") );
  return(skippedbytes);
}

unsigned dword slibFillBufferFromPin(SlibInfo_t *Info, SlibPin_t *pin,
                           unsigned char *fillbuf, unsigned dword bufsize,
                           SlibTime_t *ptime)
{
  unsigned dword filledbytes=0;
  if (pin && fillbuf)
  {
    unsigned char *buf;
    unsigned dword size;
    SlibTime_t time, nexttime=SLIB_TIME_NONE;
    buf=slibGetBufferFromPin(Info, pin, &size, &time);
    while (buf && size<bufsize)
    {
      memcpy(fillbuf, buf, size);
      bufsize-=size;
      filledbytes+=size;
      fillbuf+=size;
      SlibFreeBuffer(buf);
      buf=slibGetBufferFromPin(Info, pin, &size, &nexttime);
      if (time==SLIB_TIME_NONE)
        time=nexttime;
    }
    if (buf && size>=bufsize)
    {
      memcpy(fillbuf, buf, bufsize);
      size-=bufsize;
      if (size) /* put remainer of buffer back on pin */
      {
        SlibAllocSubBuffer(buf+bufsize, size);
        slibInsertBufferOnPin(pin, buf+bufsize, size, nexttime);
      }
      SlibFreeBuffer(buf);
      filledbytes+=bufsize;
    }
    if (ptime)
      *ptime=time;
  }
  return(filledbytes);
}

word slibGetWordFromPin(SlibInfo_t *Info, SlibPin_t *pin)
{
  word value=0;
  if (pin)
  {
    unsigned char *buf;
    unsigned dword size;
    SlibTime_t time;
    buf=slibGetBufferFromPin(Info, pin, &size, &time);
    if (buf && size>=sizeof(value))
    {
      value=((int)buf[3]<<24) | (int)buf[2]<<16 |
             (int)buf[1]<<8 | (int)buf[0];
      size-=sizeof(value);
      if (size) /* put remainer of buffer back on pin */
      {
        SlibAllocSubBuffer(buf+sizeof(value), size);
        slibInsertBufferOnPin(pin, buf+sizeof(value), size, time);
      }
      SlibFreeBuffer(buf);
    }
  }
  return(value);
}

dword slibGetDWordFromPin(SlibInfo_t *Info, SlibPin_t *pin)
{
  dword value=0;
  if (pin)
  {
    unsigned char *buf;
    unsigned dword size;
    SlibTime_t time;
    _SlibDebug(_VERBOSE_, printf("slibGetDWordFromPin(%s)\n", pin->name) );
    buf=slibGetBufferFromPin(Info, pin, &size, &time);
    if (buf && size>=sizeof(value))
    {
      value=((int)buf[3]<<24) | (int)buf[2]<<16 |
             (int)buf[1]<<8 | (int)buf[0];
      size-=sizeof(value);
      if (size) /* put remainer of buffer back on pin */
      {
        SlibAllocSubBuffer(buf+sizeof(value), size);
        slibInsertBufferOnPin(pin, buf+sizeof(value), size, time);
      }
      SlibFreeBuffer(buf);
    }
  }
  return(value);
}

SlibStatus_t slibRemovePin(SlibInfo_t *Info, int pinid)
{
  SlibPin_t *lastpin=NULL, *pin=Info->Pins;
  SlibBuffer_t *lastbuf, *buf;
  _SlibDebug(_VERBOSE_, printf("slibRemovePin(%d)\n", pinid) );
  while (pin)
  {
    if (pin->ID == pinid)
    {
      if (lastpin)
        lastpin->next = pin->next;
      else
        Info->Pins = pin->next;
      buf=pin->Buffers;
      while (buf)
      {
        if (buf->address)
          SlibFreeBuffer(buf->address);
        lastbuf=buf;
        buf=lastbuf->next;
        ScFree(lastbuf);
      }
      ScFree(pin);
      Info->PinCount--;
      return(TRUE);
    }
    lastpin = pin;
    pin = pin->next;
  }
  return(FALSE);
}

SlibStatus_t slibEmptyPin(SlibInfo_t *Info, int pinid)
{
  SlibPin_t *pin=Info->Pins;
  SlibBuffer_t *lastbuf, *buf;
  _SlibDebug(_DEBUG_ || _VERBOSE_, printf("slibEmptyPin(%d)\n",pinid) );
  while (pin)
  {
    if (pin->ID == pinid)
    {
      buf=pin->Buffers;
      while (buf)
      {
        pin->Offset+=buf->size;
        if (buf->address)
          if (SlibFreeBuffer(buf->address))
          {
            _SlibDebug(_WARN_,
               printf("slibEmptyPin(%d) freeing buffer %p failed\n",
                                        pinid, buf->address));
          }
        lastbuf=buf;
        buf=buf->next;
        ScFree(lastbuf);
      }
      pin->Buffers = NULL;
      pin->BuffersTail = NULL;
      pin->BufferCount = 0;
      pin->DataSize = 0;
      return(TRUE);
    }
    pin = pin->next;
  }
  _SlibDebug(_WARN_, printf("slibEmptyPin(%d) Unable to locate pin\n",pinid) );
  return(FALSE);
}

SlibPin_t *slibLoadPin(SlibInfo_t *Info, int pinid)
{
  SlibPin_t *pin;
  _SlibDebug(_DEBUG_>1, printf("slibLoadPin(%d)\n",pinid) );
  if ((pin=slibGetPin(Info, pinid))==NULL)
  {
    switch(pinid)
    {
      case SLIB_DATA_COMPRESSED: pin=slibAddPin(Info, pinid, "Input");
                                 break;
      case SLIB_DATA_VIDEO:      pin=slibAddPin(Info, pinid, "Video");
                                 break;
      case SLIB_DATA_AUDIO:      pin=slibAddPin(Info, pinid, "Audio");
                                 break;
    }
  }
  if (pin)
  {
    if (pin->Buffers)
      return(pin);
    else if (Info->Mode==SLIB_MODE_DECOMPRESS)
    {
      pin=slibPreLoadPin(Info, pin);
      if (pin && pin->Buffers)
        return(pin);
    }
    _SlibDebug(_WARN_, 
         if (Info->Mode!=SLIB_MODE_DECOMPRESS)
           printf("slibLoadPin(%d) Mode is not SLIB_MODE_DECOMPRESS\n", pinid);
         else
           printf("slibLoadPin(%d) Unable to load pin\n", pinid));
    return(NULL);
  }
  return(NULL);
}

qword slibDataOnPin(SlibInfo_t *Info, int pinid)
{
  SlibPin_t *pin=slibGetPin(Info, pinid);
  if (!pin || pin->Buffers==NULL)
    return((qword)0);
  else
    return(pin->DataSize>0?pin->DataSize:(qword)1);
}

qword slibDataOnPins(SlibInfo_t *Info)
{
  SlibPin_t *pin=Info->Pins;
  qword totalbytes=(qword)0;
  while (pin)
  {
    if (pin->DataSize>0)
     totalbytes+=pin->DataSize;
    pin = pin->next;
  }
  _SlibDebug(_VERBOSE_, printf("slibDataOnPins() returns %d\n", totalbytes) );
  return(totalbytes);
}

/************************** Data Stream helper functions **************/
#ifdef MPEG_SUPPORT
#define PACKET_SIZE         0x8F0
#define PACKET_BUFFER_SIZE  0x8F0+50
#define BYTES_PER_PACK      0x1200
#define PTIME_ADJUST        300
#define AUDIOTIME_ADJUST    10
#endif

void slibValidateBitrates(SlibInfo_t *Info)
{
  if (Info->Svh)
    Info->VideoBitRate=(dword)SvGetParamInt(Info->Svh, SV_PARAM_BITRATE);
  if (Info->Sah)
    Info->AudioBitRate=(dword)SaGetParamInt(Info->Sah, SA_PARAM_BITRATE);
  _SlibDebug(_VERBOSE_, printf("AudioBitRate=%d VideoBitRate=%d\n",
                     Info->AudioBitRate,Info->VideoBitRate) );
#ifdef MPEG_SUPPORT
  if (Info->Type==SLIB_TYPE_MPEG_SYSTEMS ||
      Info->Type==SLIB_TYPE_MPEG_SYSTEMS_MPEG2)
  {
    qword totalbitrate=Info->AudioBitRate+Info->VideoBitRate;
    if (Info->Mode==SLIB_MODE_COMPRESS)
    {
      Info->KeySpacing=(int)SvGetParamInt(Info->Svh, SV_PARAM_KEYSPACING);
      Info->SubKeySpacing=(int)SvGetParamInt(Info->Svh, SV_PARAM_SUBKEYSPACING);
    }
    totalbitrate+=(9*(totalbitrate/(PACKET_SIZE-3)))+ /* Packet headers */
                  (qword)(4*8*Info->FramesPerSec)+ /* Presentation timestamps */
                  (qword)(4*8*Info->FramesPerSec*10/  /* Decoding */
                       Info->SubKeySpacing);          /* timestamps */
    Info->MuxBitRate=(dword)(12*(totalbitrate/BYTES_PER_PACK));/*Pack Headers*/
  }
#endif
  Info->TotalBitRate=Info->AudioBitRate+Info->VideoBitRate+Info->MuxBitRate;
}

/************************** Data Stream Writers ***********************/
#ifdef MPEG_SUPPORT
static int slibCreateMpegPackHeader(unsigned char *buf,
                                    unsigned qword sys_clock,
                                    unsigned dword mux_rate)
{
  buf[0]=0x00;
  buf[1]=0x00;
  buf[2]=0x01;
  buf[3]=MPEG_PACK_START_BASE;
  /* store system clock */
  buf[4]=0x21|(unsigned char)(((sys_clock>>30)&0x07)<<1);
  buf[5]=(unsigned char)(sys_clock>>22)&0xFF;
  buf[6]=0x01|(unsigned char)((sys_clock>>14)&0xFE);
  buf[7]=(unsigned char)((sys_clock>>7)&0xFF);
  buf[8]=0x01|(unsigned char)((sys_clock<<1)&0xFE);
  /* store mux rate */
  buf[9]=0x80|(unsigned char)((mux_rate>>15)&0xEF);
  buf[10]=(unsigned char)(mux_rate>>7)&0xFF;
  buf[11]=0x01|(unsigned char)((mux_rate<<1)&0xFE);
  return(12);  /* bytes written */
}

/*
** Function: slibWriteMpeg1Systems()
** Descript: Writes  out MPEG Video & Audio data conatined on Pins.
** Returns:  TRUE if data was written, otherwise FALSE.
*/
static SlibBoolean_t slibWriteMpeg1Systems(SlibInfo_t *Info, 
                                           SlibBoolean_t flush)
{
  SlibPin_t *audiopin, *videopin;
  unsigned char *buf=NULL;
  unsigned dword size=0, len;
  unsigned char packet_data[PACKET_BUFFER_SIZE];
  unsigned dword header_len;
  SlibTime_t ptimestamp, dtimestamp, timediff=0;
  SlibTime_t atime=SLIB_TIME_NONE, vtime=SLIB_TIME_NONE;
  const unsigned dword std_audio_buf_size=Info->AudioBitRate ?
                                     Info->AudioBitRate/8000 : 32;
  const unsigned dword std_video_buf_size=Info->VideoBitRate ?
                                     Info->VideoBitRate/25000 : 46;
  int i;
  _SlibDebug(_VERBOSE_||_WRITE_,
         printf("slibWriteMpeg1Systems(flush=%d) BytesProcessed=%ld\n",
                                       flush, Info->BytesProcessed) );
  videopin = slibGetPin(Info, SLIB_DATA_VIDEO);
  audiopin = slibGetPin(Info, SLIB_DATA_AUDIO);
  if (!videopin && !audiopin)
    return(FALSE);
  if (!Info->HeaderProcessed || Info->BytesSincePack>=BYTES_PER_PACK)
  {
    /* mux_rate is in units of 50 bytes/s rounded up */
    unsigned dword mux_rate=Info->TotalBitRate/(50*8) 
                             + ((Info->TotalBitRate%(50*8))?1:0);
    Info->SystemTimeStamp=(Info->BytesProcessed*8000)/Info->TotalBitRate;
    _SlibDebug(_VERBOSE_ || _WRITE_,
       printf("   TotalBitRate=%d sys_clock=%d (%d ms) BytesSincePack=%d\n",
               Info->TotalBitRate, Info->SystemTimeStamp*90, 
               Info->SystemTimeStamp, Info->BytesSincePack) );
      len=slibCreateMpegPackHeader(packet_data,
                                   Info->SystemTimeStamp*90, /* 90 Khz clock */
                                   mux_rate);
    if (slibPutBuffer(Info, packet_data, len)==SlibErrorNone)
    {
      Info->BytesProcessed+=len;
      Info->BytesSincePack+=len;
      if (Info->BytesSincePack>=BYTES_PER_PACK)
        Info->BytesSincePack-=BYTES_PER_PACK;
    }
  }
  if (!Info->HeaderProcessed)
  {
    if (!Info->IOError)
    {
      /* mux_rate is in units of 50 bytes/s rounded up */
      unsigned dword mux_rate=Info->TotalBitRate/(50*8) 
                             + ((Info->TotalBitRate%(50*8))?1:0);
      /******** systems header **********/
      header_len=6+3*(Info->AudioStreams+Info->VideoStreams);
      packet_data[0]=0x00;
      packet_data[1]=0x00;
      packet_data[2]=0x01;
      packet_data[3]=(unsigned char)MPEG_SYSTEM_HEADER_START;
      packet_data[4]=header_len>>8;
      packet_data[5]=header_len & 0xFF;
      packet_data[6]=0x80|((mux_rate>>15)&0xEF);
      packet_data[7]=(mux_rate>>7)&0xFF;
      packet_data[8]=0x01|((mux_rate<<1)&0xFE);
      /* audio_bound(6 bits) + fixed_flag(1) + CSPS_falg(1) */
      packet_data[9]=0x05;
      /* sys_audio_lock_flag(1)+sys_video_lock_flag(1)+marker(1)+
         video_bound(5 bits) */
      packet_data[10]=0x80|0x40|0x20|0x01;
      packet_data[11]=0xFF; /* reserved byte */
      len=12;
      for (i=0; i<Info->VideoStreams; i++)
      {
        packet_data[len++]=MPEG_VIDEO_STREAM_BASE+i;
        packet_data[len++]=0xE0 | (std_video_buf_size>>8);
        packet_data[len++]=std_video_buf_size & 0xFF;
      }
      for (i=0; i<Info->AudioStreams; i++)
      {
        packet_data[len++]=MPEG_AUDIO_STREAM_BASE+i;
        packet_data[len++]=0xC0 | (std_audio_buf_size>>8);
        packet_data[len++]=std_audio_buf_size & 0xFF;
      }
      _SlibDebug(_VERBOSE_ || _WRITE_,
         printf("slibPutBuffer(%d) %d bytes of system header\n",
             Info->Fd, len) );
      if (slibPutBuffer(Info, packet_data, len)==SlibErrorNone)
      {
        Info->BytesProcessed+=len;
        Info->BytesSincePack+=len;
      }
    }
    Info->HeaderProcessed=TRUE;
  }
  atime=slibGetNextTimeOnPin(Info, audiopin, PACKET_SIZE-3);
  vtime=slibGetNextTimeOnPin(Info, videopin, PACKET_SIZE-3);
  if (SlibTimeIsInValid(atime))
    atime=Info->LastAudioPTimeCode;
  if (SlibTimeIsInValid(vtime))
    vtime=Info->LastVideoPTimeCode;
  if (!flush &&
       (audiopin->DataSize<PACKET_SIZE-3 || videopin->DataSize<PACKET_SIZE-3))
    return(TRUE); /* we need more data before writing */
  if (!flush && audiopin && SlibTimeIsValid(atime) &&
                videopin && SlibTimeIsValid(vtime))
    timediff=atime-vtime-AUDIOTIME_ADJUST;
  else
    timediff=0;
  /* write out complete Audio and/or Video packets */
  while (!Info->IOError &&
          ((audiopin && timediff<=0 && audiopin->DataSize>=PACKET_SIZE-3) ||
           (videopin && timediff>=0 && videopin->DataSize>=PACKET_SIZE-3)))
  {
    Info->SystemTimeStamp=(Info->BytesProcessed*8000)/Info->TotalBitRate;
    _SlibDebug(_VERBOSE_ || _WRITE_,
      printf(" TotalBitRate=%d sys_clock=%d (%d ms) BytesProcessed=%ld\n",
               Info->TotalBitRate, Info->SystemTimeStamp*90, 
               Info->SystemTimeStamp, Info->BytesProcessed) );
    if (Info->BytesSincePack>=BYTES_PER_PACK)
    {
      /* mux_rate is in units of 50 bytes/s rounded up */
      unsigned dword mux_rate=Info->TotalBitRate/(50*8) 
                             + ((Info->TotalBitRate%(50*8))?1:0);
      Info->SystemTimeStamp=(Info->BytesProcessed*8000)/Info->TotalBitRate;
      _SlibDebug(_VERBOSE_ || _WRITE_,
        printf("   TotalBitRate=%d sys_clock=%d (%d ms) mux_rate=%d BytesSincePack=%d\n",
               Info->TotalBitRate, Info->SystemTimeStamp*90, 
               Info->SystemTimeStamp, mux_rate, Info->BytesSincePack) );
      len=slibCreateMpegPackHeader(packet_data,
                                   Info->SystemTimeStamp*90, /* 90 Khz clock */
                                   mux_rate);
      if (slibPutBuffer(Info, packet_data, len)==SlibErrorNone)
      {
        Info->BytesProcessed+=len;
        Info->BytesSincePack+=len;
        Info->BytesSincePack-=BYTES_PER_PACK;
      }
    }
    if ((SlibTimeIsValid(atime) && atime-Info->SystemTimeStamp>300) ||
        (SlibTimeIsValid(vtime) && vtime-Info->SystemTimeStamp>300))
    {
      /* we need a Padding packet */
      _SlibDebug(_WRITE_||_TIMECODE_, printf("Padding\n") );
      packet_data[0]=0x00;
      packet_data[1]=0x00;
      packet_data[2]=0x01;
      packet_data[3]=MPEG_PADDING_STREAM_BASE;
      packet_data[4]=PACKET_SIZE>>8;   /* packet size - high byte */
      packet_data[5]=PACKET_SIZE&0xFF; /* packet size - low byte */
      packet_data[6]=0xFF;
      packet_data[7]=0x0F;  /* no presentation or time stamps */
      size=PACKET_SIZE+6;
      for (len=8; len<size; len++)
        packet_data[len]=0xFF;
      if (slibPutBuffer(Info, packet_data, size)==SlibErrorNone)
      {
        Info->BytesProcessed+=size;
        Info->BytesSincePack+=size;
        Info->PacketCount++;
      }
    }
    else if (!flush && (atime>0 || vtime>0) &&
                   (atime+300<Info->SystemTimeStamp &&
                    vtime+300<Info->SystemTimeStamp))
    {
      /* we're not able to keep the bitrate low enough */
      /* increase the Mux rate */
      dword oldrate=Info->TotalBitRate;
      SlibTime_t mintime=(vtime<atime) ? atime : vtime;
      if (atime>0 && vtime>0)
        mintime=(vtime<atime) ? vtime : atime;
      Info->TotalBitRate=(dword)((Info->BytesProcessed*8000)/mintime);
      if (Info->TotalBitRate==oldrate)
        Info->TotalBitRate+=50*8;
      Info->MuxBitRate=Info->TotalBitRate-Info->VideoBitRate-Info->AudioBitRate;
      _SlibDebug(_WRITE_||_TIMECODE_, 
      printf("Bad Mux rate: atime=%ld vtime=%ld systime=%ld total=%ld -> %ld\n",
            atime, vtime, Info->SystemTimeStamp, oldrate, Info->TotalBitRate) );
    }
    if (audiopin && timediff<=0 && audiopin->DataSize>=PACKET_SIZE-3)
    {
      packet_data[0]=0x00;
      packet_data[1]=0x00;
      packet_data[2]=0x01;
      packet_data[3]=MPEG_AUDIO_STREAM_BASE;
      packet_data[4]=PACKET_SIZE>>8;   /* packet size - high byte */
      packet_data[5]=PACKET_SIZE&0xFF; /* packet size - low byte */
      /* 01 + STD_buffer_scale + STD_buffer_size[12..8] */
      packet_data[6]=0x40 | 0x00 | (std_audio_buf_size>>8);
      packet_data[7]=std_audio_buf_size & 0xFF;
      ptimestamp=slibGetNextTimeOnPin(Info, audiopin, PACKET_SIZE-3);
      if (SlibTimeIsValid(ptimestamp))
      {
        unsigned qword sys_clock=ptimestamp*90; /* 90 Khz clock */
        _SlibDebug(_WRITE_||_TIMECODE_,
               printf("LastAudioPTimeCode=%ld\n", Info->LastAudioPTimeCode) );
        _SlibDebug(_WARN_ && (ptimestamp-(qword)Info->SystemTimeStamp>400 ||
                         (qword)Info->SystemTimeStamp-ptimestamp>400),
           printf("Bad MuxRate(%d): SystemTimeStamp=%d ptimestamp=%d\n",
                                    Info->SystemTimeStamp, ptimestamp) );
        Info->LastAudioPTimeCode=ptimestamp;
        sys_clock+=PTIME_ADJUST*90;
        packet_data[8]=0x21|(unsigned char)(((sys_clock>>30)&0x07)<<1);
        packet_data[9]=(unsigned char)(sys_clock>>22)&0xFF;
        packet_data[10]=0x01|(unsigned char)((sys_clock>>14)&0xFE);
        packet_data[11]=(unsigned char)((sys_clock>>7)&0xFF);
        packet_data[12]=0x01|(unsigned char)((sys_clock<<1)&0xFE);
        size=slibFillBufferFromPin(Info, audiopin, packet_data+13,
                                      PACKET_SIZE-7, NULL);
        size+=13;
      }
      else
      {
        packet_data[8]=0x0F;  /* no presentation or time stamps */
        size=slibFillBufferFromPin(Info, audiopin, packet_data+9,
                                      PACKET_SIZE-3, NULL);
        size+=9;
      }
      _SlibDebug(_VERBOSE_ || _WRITE_,
          printf("slibPutBuffer(%d) %d bytes of audio\n", Info->Fd, size) );
      if (slibPutBuffer(Info, packet_data, size)==SlibErrorNone)
      {
        Info->BytesProcessed+=size;
        Info->BytesSincePack+=size;
        Info->PacketCount++;
      }
    }
    if (videopin && !Info->IOError && timediff>=0 &&
                              videopin->DataSize>=PACKET_SIZE-3)
    {
      packet_data[0]=0x00;
      packet_data[1]=0x00;
      packet_data[2]=0x01;
      packet_data[3]=MPEG_VIDEO_STREAM_BASE;
      packet_data[4]=PACKET_SIZE>>8;    /* packet size - high byte */
      packet_data[5]=PACKET_SIZE&0xFF;  /* packet size - low byte */
      /* 01 + STD_buffer_scale + STD_buffer_size[12..8] */
      packet_data[6]=0x40 | 0x20 | (std_video_buf_size>>8);
      packet_data[7]=std_video_buf_size & 0xFF;
      /* store presentation time stamp */
      ptimestamp=slibGetNextTimeOnPin(Info, videopin, PACKET_SIZE-3);
      if (SlibTimeIsValid(ptimestamp))
      {
        unsigned qword sys_clock=ptimestamp*90; /* 90 Khz clock */
        _SlibDebug(_WRITE_||_TIMECODE_,
               printf("LastVideoPTimeCode=%ld LastVideoDTimeCode=%ld\n",
                                   Info->LastVideoPTimeCode,
                                   Info->LastVideoDTimeCode) );
        if (SlibTimeIsInValid(Info->LastVideoDTimeCode))
          dtimestamp=ptimestamp-(qword)(1000/Info->FramesPerSec);
        else if (ptimestamp-Info->LastVideoPTimeCode>33*3)
          dtimestamp=Info->LastVideoDTimeCode;
        else
          dtimestamp=SLIB_TIME_NONE;
        Info->LastVideoPTimeCode=ptimestamp;
        sys_clock+=PTIME_ADJUST*90;
        packet_data[8]=(dtimestamp!=SLIB_TIME_NONE)?0x30:0x20;
        packet_data[8]|=0x01|(unsigned char)(((sys_clock>>30)&0x07)<<1);
        packet_data[9]=(unsigned char)(sys_clock>>22)&0xFF;
        packet_data[10]=0x01|(unsigned char)((sys_clock>>14)&0xFE);
        packet_data[11]=(unsigned char)((sys_clock>>7)&0xFF);
        packet_data[12]=0x01|(unsigned char)((sys_clock<<1)&0xFE);
        if (dtimestamp!=SLIB_TIME_NONE)
        {
          sys_clock=dtimestamp*90; /* 90 Khz clock */
          Info->LastVideoDTimeCode=ptimestamp;
          sys_clock+=PTIME_ADJUST*90;
          packet_data[13]=0x01|(unsigned char)(((sys_clock>>30)&0x07)<<1);
          packet_data[14]=(unsigned char)(sys_clock>>22)&0xFF;
          packet_data[15]=0x01|(unsigned char)((sys_clock>>14)&0xFE);
          packet_data[16]=(unsigned char)((sys_clock>>7)&0xFF);
          packet_data[17]=0x01|(unsigned char)((sys_clock<<1)&0xFE);
          size=slibFillBufferFromPin(Info, videopin, packet_data+18,
                                      PACKET_SIZE-12, NULL);
          size+=18;
        }
        else
        {
          size=slibFillBufferFromPin(Info, videopin, packet_data+13,
                                      PACKET_SIZE-7, NULL);
          size+=13;
        }
      }
      else
      {
        packet_data[8]=0x0F;  /* no presentation or time stamps */
        size=slibFillBufferFromPin(Info, videopin, packet_data+9,
                                         PACKET_SIZE-3, NULL);
        size+=9;
      }
      _SlibDebug(_VERBOSE_ || _WRITE_,
         printf("slibPutBuffer(%d) %d bytes of video\n", Info->Fd, size) );
      if (slibPutBuffer(Info, packet_data, size)==SlibErrorNone)
      {
        Info->BytesProcessed+=size;
        Info->BytesSincePack+=size;
        Info->PacketCount++;
      }
    }
    /* need to wait until we get enough data on both audio and video pin */
    if (audiopin && videopin && !flush &&
        (audiopin->DataSize<PACKET_SIZE-3 || videopin->DataSize<PACKET_SIZE-3))
    {
      _SlibDebug(_VERBOSE_ || _WRITE_,
        printf("atime=%d vtime=%ld audiodata=%d videodata=%d\n",
          atime, vtime, audiopin->DataSize, videopin->DataSize) );
      break;
    }
    /* recalculate time differences */
    timediff=slibGetNextTimeOnPin(Info, audiopin, PACKET_SIZE-3);
    if (SlibTimeIsValid(timediff)) atime=timediff;
    timediff=slibGetNextTimeOnPin(Info, videopin, PACKET_SIZE-3);
    if (SlibTimeIsValid(timediff)) vtime=timediff;
    if (!flush && audiopin && SlibTimeIsValid(atime) &&
                  videopin && SlibTimeIsValid(vtime))
      timediff=atime-vtime-AUDIOTIME_ADJUST;
    else
      timediff=0;
  }
  /* flushing: write out remained Audio and/or Video data */
  if (flush && !Info->IOError)
  {
    if (audiopin && audiopin->DataSize)
    {
      packet_data[0]=0x00;
      packet_data[1]=0x00;
      packet_data[2]=0x01;
      packet_data[3]=MPEG_AUDIO_STREAM_BASE;
      packet_data[4]=(unsigned char)((audiopin->DataSize+3)>>8);
      packet_data[5]=(unsigned char)((audiopin->DataSize+3)&0xFF);
      packet_data[6]=0x40 | (std_audio_buf_size>>8);
      packet_data[7]=std_audio_buf_size & 0xFF;
      packet_data[8]=0x0F;  /* no presentation or time stamps */
      size=slibFillBufferFromPin(Info, audiopin, packet_data+9,
                                   (unsigned long)audiopin->DataSize, NULL);
      size+=9;
      _SlibDebug(_VERBOSE_ || _WRITE_,
        printf("slibPutBuffer(%d) %d bytes of audio (flush)\n", Info->Fd, size));
      if (slibPutBuffer(Info, packet_data, size)==SlibErrorNone)
      {
        Info->BytesProcessed+=size;
        Info->BytesSincePack+=size;
        Info->PacketCount++;
      }
    }
    if (videopin && videopin->DataSize && !Info->IOError)
    {
      packet_data[0]=0x00;
      packet_data[1]=0x00;
      packet_data[2]=0x01;
      packet_data[3]=MPEG_VIDEO_STREAM_BASE;
      packet_data[4]=(unsigned char)((videopin->DataSize+3)>>8);
      packet_data[5]=(unsigned char)((videopin->DataSize+3)&0xFF);
      packet_data[6]=0x60 | (std_video_buf_size>>8);
      packet_data[7]=std_video_buf_size & 0xFF;
      packet_data[8]=0x0F;  /* no presentation or time stamps */
      size=slibFillBufferFromPin(Info,videopin,packet_data+9,
                                    (unsigned long)videopin->DataSize, NULL);
      size+=9;
      _SlibDebug(_VERBOSE_ || _WRITE_,
                     printf("slibPutBuffer(%d) %d bytes of video (flush)\n",
                               Info->Fd, size) );
      if (slibPutBuffer(Info, packet_data, size)==SlibErrorNone)
      {
        Info->BytesProcessed+=size;
        Info->BytesSincePack+=size;
        Info->PacketCount++;
      }
    }
  }
  if (flush && !Info->IOError) /* write End-Of-Sequence code */
  {
    unsigned char sys_trailer[4] = { 0x00, 0x00, 0x01, 0xB9 };
    if (slibPutBuffer(Info, sys_trailer, sizeof(sys_trailer))==SlibErrorNone)
    {
      Info->BytesProcessed+=sizeof(sys_trailer);
      Info->BytesSincePack+=sizeof(sys_trailer);
    }
  }
  
  return(TRUE);
}
#endif /* MPEG_SUPPORT */


#ifdef MPEG_SUPPORT
/*
** Function: slibWriteMpegAudio()
** Descript: Writes  out MPEG Audio stream data contained on Audio Pin.
** Returns:  TRUE if data was written, otherwise FALSE.
*/
static SlibBoolean_t slibWriteMpegAudio(SlibInfo_t *Info, SlibBoolean_t flush)
{
  SlibPin_t *srcpin=NULL;
  unsigned char *buf=NULL;
  unsigned dword size=0;
  _SlibDebug(_VERBOSE_, printf("slibWriteMpegAudio()\n") );
  if ((srcpin = slibGetPin(Info, SLIB_DATA_AUDIO))==NULL)
    return(FALSE);
  while ((buf=slibGetBufferFromPin(Info, srcpin, &size, NULL))!=NULL)
  {
    _SlibDebug(_VERBOSE_ || _WRITE_,
       printf("==SlibErrorNone(%d) %d bytes\n", Info->Fd, size) );
    if (slibPutBuffer(Info, buf, size)==SlibErrorNone)
      Info->HeaderProcessed=TRUE;
  }
  return(TRUE);
}
#endif /* MPEG_SUPPORT */


#ifdef MPEG_SUPPORT
/*
** Function: slibWriteMpegVideo()
** Descript: Writes  out MPEG Video stream data contained on Video Pin.
** Returns:  TRUE if data was written, otherwise FALSE.
*/
static SlibBoolean_t slibWriteMpegVideo(SlibInfo_t *Info, SlibBoolean_t flush)
{
  SlibPin_t *srcpin=NULL;
  unsigned char *buf=NULL;
  unsigned dword size=0;
  _SlibDebug(_VERBOSE_, printf("slibWriteMpegVideo()\n") );
  if ((srcpin = slibGetPin(Info, SLIB_DATA_VIDEO))==NULL)
    return(FALSE);
  while ((buf=slibGetBufferFromPin(Info, srcpin, &size, NULL))!=NULL)
  {
    if (slibPutBuffer(Info, buf, size)==SlibErrorNone)
      Info->HeaderProcessed=TRUE;
  }
  return(TRUE);
}
#endif /* MPEG_SUPPORT */

#ifdef H261_SUPPORT
/*
** Function: slibWriteH261()
** Descript: Writes out H261 Video stream data contained on Video Pin.
** Returns:  TRUE if data was written, otherwise FALSE.
*/
static SlibBoolean_t slibWriteH261(SlibInfo_t *Info, SlibBoolean_t flush)
{
  SlibPin_t *srcpin=NULL;
  unsigned char *buf=NULL;
  unsigned dword size=0;
  _SlibDebug(_VERBOSE_, printf("slibWriteH261()\n") );
  if ((srcpin = slibGetPin(Info, SLIB_DATA_VIDEO))==NULL)
    return(FALSE);
  while ((buf=slibGetBufferFromPin(Info, srcpin, &size, NULL))!=NULL)
  {
    if (slibPutBuffer(Info, buf, size)==SlibErrorNone)
      Info->HeaderProcessed=TRUE;
  }
  return(TRUE);
}
#endif /* H261_SUPPORT */

#ifdef H263_SUPPORT
/*
** Function: slibWriteH263()
** Descript: Writes out H263 Video stream data contained on Video Pin.
** Returns:  TRUE if data was written, otherwise FALSE.
*/
static SlibBoolean_t slibWriteH263(SlibInfo_t *Info, SlibBoolean_t flush)
{
  SlibPin_t *srcpin=NULL;
  unsigned char *buf=NULL;
  unsigned dword size=0;
  _SlibDebug(_VERBOSE_, printf("slibWriteH263()\n") );
  if ((srcpin = slibGetPin(Info, SLIB_DATA_VIDEO))==NULL)
    return(FALSE);
  while ((buf=slibGetBufferFromPin(Info, srcpin, &size, NULL))!=NULL)
  {
    if (slibPutBuffer(Info, buf, size)==SlibErrorNone)
      Info->HeaderProcessed=TRUE;
  }
  return(TRUE);
}
#endif /* H263_SUPPORT */

#ifdef HUFF_SUPPORT
/*
** Function: slibWriteSlibHuff()
** Descript: Writes out SLIB Huff Video stream data contained on Video Pin.
** Returns:  TRUE if data was written, otherwise FALSE.
*/
static SlibBoolean_t slibWriteSlibHuff(SlibInfo_t *Info, SlibBoolean_t flush)
{
  SlibPin_t *srcpin=NULL;
  unsigned char *buf=NULL;
  unsigned dword size=0;
  _SlibDebug(_VERBOSE_, printf("slibWriteSlibHuff()\n") );
  if ((srcpin = slibGetPin(Info, SLIB_DATA_VIDEO))==NULL)
    return(FALSE);
  if (!Info->HeaderProcessed)
  {
    if (!Info->IOError)
    {
      char header[] = { 'S','L','I','B','H','U','F','F' };
      _SlibDebug(_VERBOSE_ || _WRITE_,
         printf("slibPutBuffer(%d) %d bytes of header\n",
             Info->Fd, sizeof(header)) );
      slibPutBuffer(Info, header, sizeof(header));
    }
    Info->HeaderProcessed=TRUE;
  }
  while ((buf=slibGetBufferFromPin(Info, srcpin, &size, NULL))!=NULL)
  {
    _SlibDebug(_VERBOSE_ || _WRITE_,
       printf("slibPutBuffer(%d) %d bytes\n", Info->Fd, size) );
    slibPutBuffer(Info, buf, size);
  }
  return(TRUE);
}
#endif /* HUFF_SUPPORT */

#ifdef G723_SUPPORT
/*
** Function: slibWriteG723Audio()
** Descript: Writes  out G723 Audio stream data contained on Audio Pin.
** Returns:  TRUE if data was written, otherwise FALSE.
*/
static SlibBoolean_t slibWriteG723Audio(SlibInfo_t *Info, SlibBoolean_t flush)
{
  SlibPin_t *srcpin=NULL;
  unsigned char *buf=NULL;
  unsigned dword size=0;
  _SlibDebug(_VERBOSE_, printf("slibWriteG723Audio()\n") );
  if ((srcpin = slibGetPin(Info, SLIB_DATA_AUDIO))==NULL)
    return(FALSE);
  //MVP: There is no header to write for G723 codec
  //After successful first "Write" set the "headerProcessed to TRUE
  if (!Info->HeaderProcessed)
  {
     if ((buf=slibGetBufferFromPin(Info, srcpin, &size, NULL))!=NULL)
        slibPutBuffer(Info, buf, size);
    //Set Header processed flag to True
    if (!Info->IOError)
      Info->HeaderProcessed=TRUE;
  }
  
  while ((buf=slibGetBufferFromPin(Info, srcpin, &size, NULL))!=NULL)
    slibPutBuffer(Info, buf, size);
  return(TRUE);
}
#endif /* G723_SUPPORT */

/*
** Name: slibCommitBuffers
** Desc: Move buffers queued for output to there destination.
*/
SlibBoolean_t slibCommitBuffers(SlibInfo_t *Info, SlibBoolean_t flush)
{
  SlibPin_t *srcpin=NULL;
  unsigned char *buf=NULL;
  unsigned dword size=0;

  switch (Info->Type)
  {
#ifdef H261_SUPPORT
    case SLIB_TYPE_H261:
           slibWriteH261(Info, flush);
           break;
#endif /* H261_SUPPORT */
#ifdef H263_SUPPORT
    case SLIB_TYPE_H263:
           slibWriteH263(Info, flush);
           break;
#endif /* H263_SUPPORT */
#ifdef MPEG_SUPPORT
    case SLIB_TYPE_MPEG1_VIDEO:
    case SLIB_TYPE_MPEG2_VIDEO:
           slibWriteMpegVideo(Info, flush);
           break;
    case SLIB_TYPE_MPEG1_AUDIO:
           slibWriteMpegAudio(Info, flush);
           break;
    case SLIB_TYPE_MPEG_SYSTEMS:
    case SLIB_TYPE_MPEG_SYSTEMS_MPEG2:
           slibWriteMpeg1Systems(Info, flush);
           break;
#endif /* MPEG_SUPPORT */
#ifdef HUFF_SUPPORT
    case SLIB_TYPE_SHUFF:
           slibWriteSlibHuff(Info, flush);
           break;
#endif /* HUFF_SUPPORT */
#ifdef G723_SUPPORT
    case SLIB_TYPE_G723:
           slibWriteG723Audio(Info, flush);
           break;
#endif /* G723_SUPPORT */
    default:
           _SlibDebug(_VERBOSE_ || _WARN_,
                 printf("slibCommitBuffers() Unknown type\n") );
           return(FALSE);
  }
  return(Info->IOError ? FALSE : TRUE);
}

/************************** Data Stream Parsers ***********************/
/*
** Function: slibParseWave()
** Descript: Parse Wave (RIFF) and add Audio data to Audio Pin.
** Returns:  TRUE if data was added to dstpin, otherwise FALSE.
*/
SlibBoolean_t slibParseWave(SlibInfo_t *Info, SlibPin_t *srcpin,
                                              SlibPin_t *dstpin)
{
  if (!srcpin)
    srcpin = slibLoadPin(Info, SLIB_DATA_COMPRESSED);
  if (!dstpin)
    dstpin = slibGetPin(Info, SLIB_DATA_AUDIO);
  if (srcpin && dstpin)
  {
    unsigned char *buf;
    unsigned dword size;
    SlibTime_t time;
    if (Info->AudioTimeStamp==0)
    {
      /* Discard header data from Compressed Pin */
      buf = slibSearchBuffersOnPin(Info, srcpin,
                              NULL, &size, RIFF_DATA, 4, TRUE);
      if (buf)
      {
        slibInsertBufferOnPin(srcpin, buf, size, SLIB_TIME_NONE);
        slibGetDWordFromPin(Info, srcpin); /* discard Chunk size */
        Info->AudioTimeStamp=1;
      }
    }
    if ((buf=slibGetBufferFromPin(Info, srcpin, &size, &time))!=NULL)
    {
      _SlibDebug(_DEBUG_, printf("slibParseWave() adding %d bytes\n", size));
      slibAddBufferToPin(dstpin, buf, size, time);
      return(TRUE);
    }
  }
  return(FALSE);
}

#ifdef AC3_SUPPORT
/*
** Function: slibParseAC3Audio()
** Descript: Parse Dolby AC-3 Audio stream and add Audio data to Audio Pin.
** Returns:  TRUE if data was added to dstpin, otherwise FALSE.
*/
SlibBoolean_t slibParseAC3Audio(SlibInfo_t *Info, SlibPin_t *srcpin,
                                                  SlibPin_t *dstpin)
{
  _SlibDebug(_DEBUG_, printf("slibParseMpegAudio()\n"));
  if (!srcpin)
    srcpin = slibLoadPin(Info, SLIB_DATA_COMPRESSED);
  if (!dstpin)
    dstpin = slibGetPin(Info, SLIB_DATA_AUDIO);
  if (srcpin && dstpin)
  {
    unsigned char *buf;
    unsigned dword size;
    SlibTime_t time;
    if ((buf=slibGetBufferFromPin(Info, srcpin, &size, &time))!=NULL)
    {
      slibAddBufferToPin(dstpin, buf, size, time);
      _SlibDebug(_DEBUG_, printf("slibParseAC3Audio() added %d bytes\n",
                            size));
      return(TRUE);
    }
  }
  return(FALSE);
}
#endif /* AC3_SUPPORT */

#ifdef MPEG_SUPPORT
/*
** Function: slibParseMpegAudio()
** Descript: Parse MPEG Audio stream and add Audio data to Audio Pin.
** Returns:  TRUE if data was added to dstpin, otherwise FALSE.
*/
SlibBoolean_t slibParseMpegAudio(SlibInfo_t *Info, SlibPin_t *srcpin,
                                                    SlibPin_t *dstpin)
{
  _SlibDebug(_DEBUG_, printf("slibParseMpegAudio()\n"));
  if (!srcpin)
    srcpin = slibLoadPin(Info, SLIB_DATA_COMPRESSED);
  if (!dstpin)
    dstpin = slibGetPin(Info, SLIB_DATA_AUDIO);
  if (srcpin && dstpin)
  {
    unsigned char *buf;
    unsigned dword size;
    SlibTime_t time;
    if ((buf=slibGetBufferFromPin(Info, srcpin, &size, &time))!=NULL)
    {
      slibAddBufferToPin(dstpin, buf, size, time);
      _SlibDebug(_DEBUG_, printf("slibParseMpegAudio() added %d bytes\n",
                            size));
      return(TRUE);
    }
  }
  return(FALSE);
}
#endif /* MPEG_SUPPORT */

#ifdef MPEG_SUPPORT
/*
** Function: slibParseMpegVideo()
** Descript: Parse MPEG Video stream and add Video data to Video Pin.
** Returns:  TRUE if data was added to dstpin, otherwise FALSE.
*/
SlibBoolean_t slibParseMpegVideo(SlibInfo_t *Info, SlibPin_t *srcpin,
                                                    SlibPin_t *dstpin)
{
  _SlibDebug(_DEBUG_, printf("slibParseMpegVideo()\n"));
  if (!srcpin)
    srcpin = slibLoadPin(Info, SLIB_DATA_COMPRESSED);
  if (!dstpin)
    dstpin = slibGetPin(Info, SLIB_DATA_VIDEO);
  if (srcpin && dstpin)
  {
    unsigned char *buf;
    unsigned dword size;
    SlibTime_t time;
    if ((buf=slibGetBufferFromPin(Info, srcpin, &size, &time))!=NULL)
    {
      slibAddBufferToPin(dstpin, buf, size, time);
      _SlibDebug(_DEBUG_, printf("slibParseMpegVideo() added %d bytes\n",
                            size));
      return(TRUE);
    }
    _SlibDebug(_DEBUG_, 
          printf("slibParseMpegVideo() couldn't get COMPRESSED data\n"));
  }
  _SlibDebug(_DEBUG_, printf("slibParseMpegVideo() pins not ready\n"));
  return(FALSE);
}
#endif /* MPEG_SUPPORT */

#ifdef MPEG_SUPPORT
#define skipbytes(b) if (size<=b) { \
                      oldsize = size; SlibFreeBuffer(bufstart); \
                buf=bufstart=slibGetBufferFromPin(Info, srcpin, &size, NULL); \
                      if (!buf) return(FALSE); \
                      buf+=b-oldsize; size-=b-oldsize; \
                     } else { buf+=b; size-=b; }
/*
** Function: slibParseMpeg1Sytems()
** Descript: Parse MPEG I Systems stream and add Video data to Video Pin
**           and Audio to the Audio Pin.
** Returns:  TRUE if data was added to fillpin, otherwise FALSE.
*/
SlibBoolean_t slibParseMpeg1Systems(SlibInfo_t *Info, SlibPin_t *srcpin,
                                                      SlibPin_t *fillpin)
{
  if (!srcpin)
    srcpin = slibLoadPin(Info, SLIB_DATA_COMPRESSED);
  _SlibDebug(_DEBUG_ || _PARSE_, printf("slibParseMpeg1Systems()\n"));
  if (srcpin)
  {
    unsigned char abyte, packettype;
    unsigned dword PacketLength;
    unsigned char *buf, *bufstart=NULL;
    unsigned dword size, oldsize;
    SlibTime_t ptimestamp=SLIB_TIME_NONE;
    SlibPin_t *dstpin;
    while ((buf = bufstart = slibSearchBuffersOnPin(Info, srcpin, NULL,
             &size, MPEG_START_CODE, MPEG_START_CODE_LEN/8, TRUE))!=NULL)
    {
      _SlibDebug(_VERIFY_ && size<1, printf("Insufficient bytes #1\n") );
      packettype = *buf;
      skipbytes(1);
      if (packettype > 0xBB) /* it's a packet */
      {
        _SlibDebug(_DEBUG_||_PARSE_, printf("Found Packet size=%d\n", size));
        PacketLength=(unsigned dword)(*buf<<8);
        skipbytes(1);
        PacketLength|=(unsigned dword)*buf;
        skipbytes(1);
        _SlibDebug(_DEBUG_||_PARSE_, printf(" PacketLength=%d\n",PacketLength));
        while (*buf == 0xFF) /* Stuffing bytes */
        {
          skipbytes(1);
          PacketLength--;
        }
        _SlibDebug(_VERIFY_ && size<1, printf("Insufficient bytes #3\n") );
        abyte=*buf;
        if ((abyte & 0xC0)==0x40)  /* STD_buffer stuff */
        {
          skipbytes(2);
          PacketLength-=2;
          abyte=*buf;
        }
        _SlibDebug(_VERIFY_ && size<1, printf("Insufficient bytes #4\n") );
        
        if ((abyte & 0xF0)==0x20 || (abyte & 0xF0)==0x30)
        {
          if (packettype!=Info->VideoMainStream &&
              packettype!=Info->AudioMainStream)
          {
            skipbytes(5); /* skip Presentation Time Stamp */
            PacketLength-=5;
            if ((abyte & 0xF0)==0x30) /* skip Decoding timestamp */
            {
              skipbytes(5);
              PacketLength-=5;
            }
          }
          else
          {
            /* Presentation Time Stamp */
            ptimestamp=(*buf)&0x0E; ptimestamp<<=7;
            skipbytes(1);
            ptimestamp|=(*buf); ptimestamp<<=8;
            skipbytes(1);
            ptimestamp|=(*buf)&0xFE; ptimestamp<<=7;
            skipbytes(1);
            ptimestamp|=(*buf); ptimestamp<<=7;
            skipbytes(1);
            ptimestamp|=(*buf)&0xFE;
            skipbytes(1);
            ptimestamp/=90;
            if (packettype==Info->VideoMainStream)
            {
              if (!SlibTimeIsValid(Info->VideoPTimeBase) ||
                     ptimestamp<Info->VideoPTimeBase)
              {
                Info->VideoPTimeBase=ptimestamp;
                _SlibDebug(_PARSE_ || _TIMECODE_,
                  printf("slibParseMpeg1Systems() VideoPTimeBase=%ld\n",
                      Info->VideoPTimeBase));
              }
            }
            else if (packettype==Info->AudioMainStream)
            {
              if (!SlibTimeIsValid(Info->AudioPTimeBase) ||
                     ptimestamp<Info->AudioPTimeBase)
              {
                Info->AudioPTimeBase=ptimestamp;
                _SlibDebug(_PARSE_ || _TIMECODE_,
                  printf("slibParseMpeg1Systems() AudioPTimeBase=%ld\n",
                      Info->AudioPTimeBase));
              }
            }
            PacketLength-=5;
            /* Decoding timestamp */
            if ((abyte & 0xF0)==0x30)
            {
              SlibTime_t dtimestamp;
              dtimestamp=(*buf)&0x0E; dtimestamp<<=7;
              skipbytes(1);
              dtimestamp|=(*buf); dtimestamp<<=8;
              skipbytes(1);
              dtimestamp|=(*buf)&0xFE; dtimestamp<<=7;
              skipbytes(1);
              dtimestamp|=(*buf); dtimestamp<<=7;
              skipbytes(1);
              dtimestamp|=(*buf)&0xFE;
              skipbytes(1);
              dtimestamp/=90;
              if (packettype==Info->VideoMainStream)
              {
                _SlibDebug(_TIMECODE_, 
                      printf("Video DTimeCode=%d\n", dtimestamp) );
                Info->VideoDTimeCode=dtimestamp;
              }
              else if (packettype==Info->AudioMainStream)
              {
                _SlibDebug(_TIMECODE_, 
                      printf("Audio DTimeCode=%d\n", dtimestamp) );
                Info->AudioDTimeCode=dtimestamp;
              }
              PacketLength-=5;
            }
          }
        }
        else if (abyte != 0x0F)
        {
          _SlibDebug(_VERIFY_, printf("Last byte before data not 0x0F\n") );
          /* add remaining buffer data back to input pin */
          if (size)
          {
            SlibAllocSubBuffer(buf, size);
            slibInsertBufferOnPin(srcpin, buf, size, SLIB_TIME_NONE);
          }
          SlibFreeBuffer(bufstart);
          _SlibDebug(_VERIFY_, printf("Searching for next packet\n") );
          continue;  /* try to recover */
        }
        else
        {
          skipbytes(1);
          PacketLength--;
        }
        if (packettype==Info->VideoMainStream)
          dstpin = slibGetPin(Info, SLIB_DATA_VIDEO);
        else if (packettype==Info->AudioMainStream)
          dstpin = slibGetPin(Info, SLIB_DATA_AUDIO);
        else
          dstpin = NULL;
        if (dstpin && slibPinOverflowing(Info, dstpin))
        {
          slibPinPrepareReposition(Info, dstpin->ID);
          _SlibDebug(_WARN_,
                 printf("Skipped data on Overflowing pin %s: time %d->",
                                     dstpin->name, Info->VideoTimeStamp) );
          if (dstpin->ID == SLIB_DATA_VIDEO)
          {
            dword frames=slibCountCodesOnPin(Info, dstpin,
                                 MPEG_PICTURE_START, 4, Info->OverflowSize/2);
            if (Info->FramesPerSec)
              Info->VideoTimeStamp+=slibFrameToTime(Info, frames);
          }
          _SlibDebug(_WARN_,
              printf("new videotime=%ld\n", Info->VideoTimeStamp) );
          slibSkipDataOnPin(Info, dstpin, Info->OverflowSize/2);
          slibPinFinishReposition(Info, dstpin->ID);
          if (dstpin->ID == SLIB_DATA_VIDEO) /* move to key frame */
            SlibSeek((SlibHandle_t *)Info, SLIB_STREAM_MAINVIDEO,
                                           SLIB_SEEK_NEXT_KEY, 0);
        }
        if (dstpin && !slibPinOverflowing(Info, dstpin))
        {
          _SlibDebug(_DEBUG_>1, printf("Adding Packet %X\n", packettype) );
          /* add the packet to the destination pin */
          while (PacketLength>size)
          {
            _SlibDebug(_WARN_>1,
                       printf("PacketLength=%d but buffer is %d bytes\n",
                       PacketLength, size) );
            _SlibDebug(_VERIFY_ && Info->Fd>=0 && size>Info->FileBufSize,
                      printf("#1 size = %d\n", size));
            if (size)
            {
              SlibAllocSubBuffer(buf, size);
              slibAddBufferToPin(dstpin, buf, size, ptimestamp);
              ptimestamp=SLIB_TIME_NONE;
              PacketLength-=size;
            }
            SlibFreeBuffer(bufstart);
            buf=bufstart=slibGetBufferFromPin(Info, srcpin, &size, NULL);
            if (!buf)
              return(fillpin==dstpin ? TRUE : FALSE);
          }
          if (PacketLength)
          {
            SlibAllocSubBuffer(buf, PacketLength);
            slibAddBufferToPin(dstpin, buf, PacketLength, ptimestamp);
            ptimestamp=SLIB_TIME_NONE;
            size-=PacketLength;
            buf+=PacketLength;
            _SlibDebug(_VERIFY_ && Info->Fd>=0 && size>Info->FileBufSize,
                         printf("#3 size = %d\n", size));
          }
          /* add remaining buffer data back to input pin */
          if (size)
          {
            SlibAllocSubBuffer(buf, size);
            slibInsertBufferOnPin(srcpin, buf, size, SLIB_TIME_NONE);
          }
          SlibFreeBuffer(bufstart);
          if (fillpin==dstpin)
            return(TRUE);
          if (fillpin==NULL)
            return(FALSE);
        }
        else /* dump the packet */
        {
          _SlibDebug(_WARN_ && dstpin,
                    printf("Dumping packet %X (Overflow)\n", packettype) );
          _SlibDebug((_WARN_>1 && !dstpin)||packettype==Info->VideoMainStream
                                          ||packettype==Info->AudioMainStream, 
                    printf("Dumping packet %X (No pin)\n", packettype) );
          while (PacketLength>size)
          {
            PacketLength-=size;
            SlibFreeBuffer(bufstart);
            buf=bufstart=slibGetBufferFromPin(Info, srcpin, &size, NULL);
            _SlibDebug(_VERIFY_ && !buf,
                     printf("Dumping Packet: no more buffers\n"));
            if (buf==NULL)
              return(FALSE);
          }
          buf+=PacketLength;
          size-=PacketLength;
          _SlibDebug(_VERIFY_ && Info->Fd>=0 && size>Info->FileBufSize,
                  printf("#5 size = %d\n", size));
          /* add remaining buffer data back to input pin */
          if (size)
          {
            SlibAllocSubBuffer(buf, size);
            slibInsertBufferOnPin(srcpin, buf, size, SLIB_TIME_NONE);
          }
          SlibFreeBuffer(bufstart);
          ptimestamp=SLIB_TIME_NONE;
        }
      } /* packet */
      else /* put buffer back on the input pin */
      {
        _SlibDebug(_DEBUG_, printf("Not a packet %X - putting back buffer\n",
                                  packettype) );
        _SlibDebug(_VERIFY_ && Info->Fd>=0 && size>Info->FileBufSize,
                      printf("#6 size = %d\n", size));
        if (size)
        {
          SlibAllocSubBuffer(buf, size);
          slibInsertBufferOnPin(srcpin, buf, size, SLIB_TIME_NONE);
        }
        SlibFreeBuffer(bufstart);
      }
    } /* while */
  }
  return(FALSE);
}
#endif /* MPEG_SUPPORT */

#ifdef MPEG_SUPPORT
static SlibBoolean_t slibParsePESHeader(SlibInfo_t *Info, SlibPin_t *srcpin,
                           unsigned char **bufferstart, unsigned char **buffer,
                           unsigned dword *buffersize,
                           int *headerlen, unsigned dword *packetlen,
                           int *packettype, SlibTime_t *ptimestamp)
{
  unsigned dword bytesprocessed=0;
  unsigned dword PES_packet_length=0;
  unsigned char *buf, *bufstart;
  unsigned dword size, oldsize, header_len;
  _SlibDebug(_DEBUG_||_VERBOSE_||_PARSE_, printf("slibParsePESHeader()\n"));
  if (*buffer==NULL)
  {
    *packettype=0;
    _SlibDebug(_VERIFY_,
         buf=slibPeekBufferOnPin(Info, srcpin, &size, NULL);
         if (buf && size>=8 && (buf[0]!=0x00 || buf[1]!=0x00 || buf[2]!=0x01))
           ScDebugPrintf(Info->dbg,
              "slibParsePESHeader() lost start code: %02X %02X %02X %02X %02X %02X %02X %02X\n",
                          buf[0], buf[1], buf[2], buf[3],
                          buf[4], buf[5], buf[6], buf[7]) );
    do {
      size=0;
      buf = bufstart = slibSearchBuffersOnPin(Info, srcpin, NULL,
             &size, MPEG_START_CODE, MPEG_START_CODE_LEN/8, TRUE);
      if (!buf) return(FALSE);
      *packettype=*buf;
      if (*packettype>0xBB) /* useful packet start code */
      {
        skipbytes(1); /* skip packettype */
        break;
      }
      _SlibDebug(_DEBUG_||_PARSE_,
        ScDebugPrintf(Info->dbg,
          "slibParsePESHeader() skipping packettype=%02X\n", *packettype));
      /* put buffer back on the input pin */
      if (size)
      {
        SlibAllocSubBuffer(buf, size);
        slibInsertBufferOnPin(srcpin, buf, size, SLIB_TIME_NONE);
      }
      SlibFreeBuffer(bufstart);
    } while (1);
  }
  else
  {
    buf=*buffer;
    bufstart=*bufferstart;
    size=*buffersize;
    _SlibDebug(_VERIFY_ && size<4, ScDebugPrintf(Info->dbg,"Insufficient bytes #5\n") );
    if (buf[0]==0x00 && buf[1]==0x00 && buf[2]==0x01)
    {
      *packettype=buf[3];
      if (*packettype>0xBB)
      {
        skipbytes(4); /* skip start code */
        bytesprocessed+=4;
      }
    }
    else
      *packettype=0;
  }
  if (*packettype>0xBB) /* useful packet start code */
  {
    unsigned short PTS_DTS_flags;
    _SlibDebug(_DEBUG_||_PARSE_,
            printf("slibParsePESHeader() packettype=%02X\n", *packettype));
    _SlibDebug(_VERIFY_ && size<4, ScDebugPrintf(Info->dbg,"Insufficient bytes #6\n") );
    /* PES_packet_length */
    PES_packet_length=((unsigned dword)buf[0])<<8;
    skipbytes(1);
    PES_packet_length|=buf[0];
    skipbytes(1);
    bytesprocessed+=2;
    if (*packettype==MPEG_PROGRAM_STREAM ||
        *packettype==MPEG_PADDING_STREAM_BASE ||
        *packettype==MPEG_PRIVATE_STREAM2_BASE)
    {
      PTS_DTS_flags=0;
      header_len=0;
      _SlibDebug(_DEBUG_||_PARSE_,
           ScDebugPrintf(Info->dbg,"PES Packet 0x%02X, Length=%d, Header Len=%d\n",
                  *packettype, PES_packet_length, header_len));
    }
    else
    {
      /* PES_packet_length-=18; */
      /* PES header stuff */
      _SlibDebug(_PARSE_ && size>4, ScDebugPrintf(Info->dbg,
          "PES Packet 0x%02X, header stuff: 0x%02X %02X %02X %02X\n",
              *packettype, buf[0], buf[1], buf[2], buf[3]));
      skipbytes(1);
      PTS_DTS_flags=buf[0]>>6;
      skipbytes(1);
      header_len=buf[0];/* get PES header len */
      skipbytes(1); /* PES header len */
      bytesprocessed+=3;
      PES_packet_length-=3;
      PES_packet_length-=header_len;
      _SlibDebug(_DEBUG_||_PARSE_,
       ScDebugPrintf(Info->dbg,
         "PES Packet 0x%02X, Length=%d, Header Len=%d, PTS_DTS_flags=%d\n",
                 *packettype, PES_packet_length, header_len, PTS_DTS_flags ));
      if (header_len>0 && (PTS_DTS_flags==2 || PTS_DTS_flags==3))
      {
        /* Presentation Time Stamp */
        unsigned long timestamp;
        timestamp=(*buf)&0x0E; timestamp<<=7;
        skipbytes(1);
        timestamp|=(*buf); timestamp<<=8;
        skipbytes(1);
        timestamp|=(*buf)&0xFE; timestamp<<=7;
        skipbytes(1);
        timestamp|=(*buf); timestamp<<=7;
        skipbytes(1);
        timestamp|=(*buf)&0xFE;
        skipbytes(1);
        timestamp/=90;
        *ptimestamp = timestamp;
        bytesprocessed+=5;
        header_len-=5;
        /* Decoding timestamp */
        if (PTS_DTS_flags==3)
        {
          timestamp=(*buf)&0x0E; timestamp<<=7;
          skipbytes(1);
          timestamp|=(*buf); timestamp<<=8;
          skipbytes(1);
          timestamp|=(*buf)&0xFE; timestamp<<=7;
          skipbytes(1);
          timestamp|=(*buf); timestamp<<=7;
          skipbytes(1);
          timestamp|=(*buf)&0xFE;
          skipbytes(1);
          timestamp/=90;
          if (*packettype==Info->VideoMainStream ||
              (Info->Type==SLIB_TYPE_MPEG_TRANSPORT &&
              *packettype>=MPEG_VIDEO_STREAM_START &&
              *packettype<=MPEG_VIDEO_STREAM_END))
          {
            _SlibDebug(_TIMECODE_,
                   ScDebugPrintf(Info->dbg,"Video DTimeCode=%d\n",timestamp));
            Info->VideoDTimeCode=timestamp;
          }
          else if (*packettype==Info->AudioMainStream ||
                   (Info->Type==SLIB_TYPE_MPEG_TRANSPORT &&
                   *packettype>=MPEG_AUDIO_STREAM_START &&
                   *packettype<=MPEG_AUDIO_STREAM_END))
          {
            _SlibDebug(_TIMECODE_,
                   ScDebugPrintf(Info->dbg,"Audio DTimeCode=%d\n",timestamp));
            Info->AudioDTimeCode=timestamp;
          }
          bytesprocessed+=5;
          header_len-=5;
        }
      } 
    }
    if (header_len>0)
    {
      _SlibDebug(_PARSE_,
       ScDebugPrintf(Info->dbg,"slibParsePESHeader() skipping header: %d bytes\n",
                             header_len));
      while ((int)size<=header_len)
      {
        _SlibDebug(_PARSE_,
         ScDebugPrintf(Info->dbg,"slibParsePESHeader() size=%d <= header_len=%d\n",
                             size, header_len));
        SlibFreeBuffer(bufstart);
        header_len-=size;
        bytesprocessed+=size;
        buf=bufstart=slibGetBufferFromPin(Info, srcpin, &size, NULL);
        if (!buf) return(FALSE);
      }
      buf+=header_len;
      _SlibDebug(_VERIFY_ && size<(unsigned dword)header_len, 
                   ScDebugPrintf(Info->dbg,"Insufficient bytes\n") );
      size-=header_len;
      bytesprocessed+=header_len;
    }
  }
  
  /* If this is private data containing AC3, skip private header */
  if (*packettype==MPEG_PRIVATE_STREAM1_BASE && (size<=0 || *buf==0x80))
  {
    /* header = 4 bytes = Hex: 80 0X XX XX */
    skipbytes(4);
    bytesprocessed+=4;
    PES_packet_length-=4;
  }
  *buffer=buf;
  *bufferstart=bufstart;
  *buffersize=size;
  if (headerlen)
    *headerlen=bytesprocessed;
  if (packetlen)
    *packetlen=PES_packet_length;
  _SlibDebug(_PARSE_,
   ScDebugPrintf(Info->dbg,"slibParsePESHeader() bytesprocessed=%d packetlen=%d\n",
                            bytesprocessed, PES_packet_length));
  return(TRUE);
}
#endif /* MPEG_SUPPORT */

#ifdef MPEG_SUPPORT
/*
** Function: slibParseMpeg2Program()
** Descript: Parse MPEG II Program stream and add Video data to Video Pin
**           and Audio to the Audio Pin.
** Returns:  TRUE if data was added to fillpin, otherwise FALSE.
*/
SlibBoolean_t slibParseMpeg2Program(SlibInfo_t *Info, SlibPin_t *srcpin,
                                                      SlibPin_t *fillpin)
{
  _SlibDebug(_DEBUG_||_PARSE_, ScDebugPrintf(Info->dbg,"slibParseMpeg2Program()\n"));
  if (!srcpin)
    srcpin = slibLoadPin(Info, SLIB_DATA_COMPRESSED);
  if (srcpin)
  {
    unsigned dword PacketLength;
    unsigned char *buf, *bufstart=NULL;
    unsigned dword size;
    SlibTime_t ptimestamp = SLIB_TIME_NONE;
    int header_len, packettype;
    SlibPin_t *dstpin;
    do {
      buf=NULL;
      if (!slibParsePESHeader(Info, srcpin, &bufstart, &buf, &size,
                          &header_len, &PacketLength, &packettype,
                          &ptimestamp))
      {
        _SlibDebug(_WARN_, ScDebugPrintf(Info->dbg,"slibParsePESHeader() failed\n") );
        return(FALSE);
      }
      if (packettype)
      {
        if (packettype==Info->VideoMainStream)
        {
          _SlibDebug(_PARSE_,
              ScDebugPrintf(Info->dbg,"slibParseMpeg2Program() VIDEO packet\n"));
          dstpin = slibGetPin(Info, SLIB_DATA_VIDEO);
          if (SlibTimeIsValid(ptimestamp) && 
               (!SlibTimeIsValid(Info->VideoPTimeBase) ||
                  ptimestamp<Info->VideoPTimeBase))
          {
            Info->VideoPTimeBase=ptimestamp;
            _SlibDebug(_PARSE_ || _TIMECODE_,
               ScDebugPrintf(Info->dbg,"slibParseMpeg2Program() VideoPTimeBase=%ld\n",
                     Info->VideoPTimeBase));
          }
        }
        else if (packettype==Info->AudioMainStream)
        {
          _SlibDebug(_PARSE_,
              ScDebugPrintf(Info->dbg,"slibParseMpeg2Program() AUDIO packet\n"));
          dstpin = slibGetPin(Info, SLIB_DATA_AUDIO);
          if (SlibTimeIsValid(ptimestamp) && 
               (!SlibTimeIsValid(Info->AudioPTimeBase) ||
                  ptimestamp<Info->AudioPTimeBase))
          {
            Info->AudioPTimeBase=ptimestamp;
            _SlibDebug(_PARSE_ || _TIMECODE_,
               ScDebugPrintf(Info->dbg,"slibParseMpeg2Program() AudioPTimeBase=%ld\n",
                     Info->AudioPTimeBase));
          }
        }
        else if (packettype==MPEG_PRIVATE_STREAM1_BASE)
        {
          _SlibDebug(_PARSE_, printf("slibParseMpeg2Program() PRIVATE packet\n"));
          dstpin = slibGetPin(Info, SLIB_DATA_PRIVATE);
        }
        else
        {
          _SlibDebug(_PARSE_,
            ScDebugPrintf(Info->dbg,
             "slibParseMpeg2Program() unknown packet 0x%02X, %d bytes\n",
                               packettype, PacketLength));
          dstpin = NULL;
        }
        if (dstpin && slibPinOverflowing(Info, dstpin))
        {
          slibPinPrepareReposition(Info, dstpin->ID);
          _SlibDebug(_WARN_,
            ScDebugPrintf(Info->dbg,"Skipped data on Overflowing pin %s: time %d->",
                                     dstpin->name, Info->VideoTimeStamp) );
          if (dstpin->ID == SLIB_DATA_VIDEO)
          {
            dword frames=slibCountCodesOnPin(Info, dstpin,
                                 MPEG_PICTURE_START, 4, Info->OverflowSize/2);
            if (Info->FramesPerSec)
              Info->VideoTimeStamp+=slibFrameToTime(Info, frames);
          }
          _SlibDebug(_WARN_, ScDebugPrintf(Info->dbg,"%d\n", Info->VideoTimeStamp) );
          slibSkipDataOnPin(Info, dstpin, Info->OverflowSize/2);
          slibPinFinishReposition(Info, dstpin->ID);
          if (dstpin->ID == SLIB_DATA_VIDEO) /* move to key frame */
            SlibSeek((SlibHandle_t *)Info, SLIB_STREAM_MAINVIDEO,
                                           SLIB_SEEK_NEXT_KEY, 0);
        }
        if (dstpin && !slibPinOverflowing(Info, dstpin))
        {
          _SlibDebug(_DEBUG_, ScDebugPrintf(Info->dbg,"Adding Packet %X, %d bytes\n",
                     packettype, PacketLength) );
          /* add the packet to the destination pin */
          while (PacketLength>size)
          {
            _SlibDebug(_WARN_>1,
                   ScDebugPrintf(Info->dbg,"PacketLength=%d but buffer is %d bytes\n",
                       PacketLength, size) );
            _SlibDebug(_VERIFY_ && Info->Fd>=0 && size>Info->FileBufSize,
                      printf("#1 size = %d\n", size));
            if (size)
            {
              SlibAllocSubBuffer(buf, size);
              /* ScDumpChar(buf, size, 0); */
              slibAddBufferToPin(dstpin, buf, size, ptimestamp);
              ptimestamp=SLIB_TIME_NONE;
              PacketLength-=size;
            }
            SlibFreeBuffer(bufstart);
            buf=bufstart=slibGetBufferFromPin(Info, srcpin, &size, NULL);
            if (!buf)
              return(fillpin==dstpin ? TRUE : FALSE);
          }
          if (PacketLength)
          {
            SlibAllocSubBuffer(buf, PacketLength);
            /* ScDumpChar(buf, PacketLength, 0); */
            slibAddBufferToPin(dstpin, buf, PacketLength, ptimestamp);
            ptimestamp=SLIB_TIME_NONE;
            size-=PacketLength;
            buf+=PacketLength;
            _SlibDebug(_VERIFY_ && Info->Fd>=0 && size>Info->FileBufSize,
                         ScDebugPrintf(Info->dbg,"#3 size = %d\n", size));
          }
          /* add remaining buffer data back to input pin */
          if (size)
          {
            SlibAllocSubBuffer(buf, size);
            slibInsertBufferOnPin(srcpin, buf, size, SLIB_TIME_NONE);
          }
          SlibFreeBuffer(bufstart);
          if (fillpin==dstpin)
            return(TRUE);
          if (fillpin==NULL)
            return(FALSE);
        }
        else /* dump the packet */
        {
          _SlibDebug(_WARN_ && dstpin,
               ScDebugPrintf(Info->dbg,"Dumping packet %X (Overflow)\n", packettype) );
          _SlibDebug((_WARN_>1 && !dstpin)||packettype==Info->VideoMainStream
                                          ||packettype==Info->AudioMainStream, 
               ScDebugPrintf(Info->dbg,"Dumping packet %X (No pin)\n", packettype) );
          while (PacketLength>size)
          {
            PacketLength-=size;
            SlibFreeBuffer(bufstart);
            buf=bufstart=slibGetBufferFromPin(Info, srcpin, &size, NULL);
            _SlibDebug(_VERIFY_ && !buf,
                   ScDebugPrintf(Info->dbg,"Dumping Packet: no more buffers\n"));
            if (buf==NULL)
              return(FALSE);
          }
          buf+=PacketLength;
          size-=PacketLength;
          _SlibDebug(_VERIFY_ && Info->Fd>=0 && size>Info->FileBufSize,
                  ScDebugPrintf(Info->dbg,"#5 size = %d\n", size));
          /* add remaining buffer data back to input pin */
          if (size)
          {
            SlibAllocSubBuffer(buf, size);
            slibInsertBufferOnPin(srcpin, buf, size, SLIB_TIME_NONE);
          }
          SlibFreeBuffer(bufstart);
        }
      } /* packet */
      else /* put buffer back on the input pin */
      {
        _SlibDebug(_DEBUG_,
            ScDebugPrintf(Info->dbg,"Not a packet %X - putting back buffer\n",
                                  packettype) );
        _SlibDebug(_VERIFY_ && Info->Fd>=0 && size>Info->FileBufSize,
                      ScDebugPrintf(Info->dbg,"#6 size = %d\n", size));
        if (size)
        {
          SlibAllocSubBuffer(buf, size);
          slibInsertBufferOnPin(srcpin, buf, size, SLIB_TIME_NONE);
        }
        SlibFreeBuffer(bufstart);
      }
    } while (1);
  }
  return(FALSE);
}
#endif /* MPEG_SUPPORT */

#ifdef MPEG_SUPPORT
/*
** Function: slibParseMpeg2Transport()
** Descript: Parse MPEG II Systems stream and add Video data to Video Pin.
** Returns:  TRUE if data was added to fillpin, otherwise FALSE.
*/
SlibBoolean_t slibParseMpeg2Transport(SlibInfo_t *Info, SlibPin_t *srcpin,
                                                      SlibPin_t *fillpin)
{
  _SlibDebug(_DEBUG_, ScDebugPrintf(Info->dbg,"slibParseMpeg2Transport()\n"));
  if (!srcpin)
    srcpin = slibLoadPin(Info, SLIB_DATA_COMPRESSED);
  if (srcpin)
  {
    int pid, adapt_field, payload_len, header_len, packettype;
    unsigned char *buf, *bufstart=NULL;
    unsigned dword size, oldsize;
    SlibPin_t *dstpin;
    /* SlibTime_t ptimestamp=SLIB_TIME_NONE; */
    while ((buf = bufstart = slibSearchBuffersOnPin(Info, srcpin, NULL,
             &size, MPEG_TSYNC_CODE, MPEG_TSYNC_CODE_LEN/8, TRUE))!=NULL)
    {
      _SlibDebug(_VERIFY_ && size<2, ScDebugPrintf(Info->dbg,"Insufficient bytes #2\n") );
      pid=(int)(buf[0]&0x1F)<<8 | (int)buf[1]; /* 13 bits for PID */
      skipbytes(2);
      _SlibDebug(_VERIFY_ && size<1, ScDebugPrintf(Info->dbg,"Insufficient bytes #3\n") );
      adapt_field=(buf[0]>>4)&0x03; /* 2 bits for adapt_field */
      skipbytes(1);
      payload_len=184; /* PES are 184 bytes */
      if (adapt_field == 2 || adapt_field == 3)
      {
        _SlibDebug(_VERIFY_ && size<1, ScDebugPrintf(Info->dbg,"Insufficient bytes #4\n") );
        header_len=*buf;
        skipbytes(1);
        payload_len--;
        if (header_len) /* skip adaptation_field */
        {
          while ((int)size<=header_len)
          {
            SlibFreeBuffer(bufstart);
            header_len-=size;
            payload_len-=size;
            buf=bufstart=slibGetBufferFromPin(Info, srcpin, &size, NULL);
            if (!buf) return(FALSE);
          }
          _SlibDebug(_VERIFY_ && size<(unsigned dword)header_len, 
                      ScDebugPrintf(Info->dbg,"Insufficient bytes\n") );
          buf+=header_len;
          size-=header_len;
          payload_len-=header_len;
        }
      }
      if ((adapt_field == 1 || adapt_field == 3)
             && (Info->VideoPID<0 || Info->VideoPID==pid ||
                 Info->AudioPID<0 || Info->AudioPID==pid)) /* payload */
      {
        unsigned dword packet_len;
        SlibTime_t ptimestamp = SLIB_TIME_NONE;
        /* see if PES packet header */
        if (slibParsePESHeader(Info, srcpin, &bufstart, &buf, &size,
                          &header_len, &packet_len, &packettype, &ptimestamp))
        {
          payload_len-=header_len;
          _SlibDebug(_VERIFY_ && payload_len<0, 
               ScDebugPrintf(Info->dbg,"payload_len<header_len, header_len=%d\n",
                              header_len) );
          if (pid!=MPEG_PID_NULL)
          {
            if (Info->VideoPID<0 && packettype>=MPEG_VIDEO_STREAM_START &&
                                    packettype<=MPEG_VIDEO_STREAM_END)
            {
              _SlibDebug(_VERBOSE_,
                  ScDebugPrintf(Info->dbg,"Selecting Video PID %d\n", pid) );
              Info->VideoPID=pid;
            }
            else if (Info->AudioPID<0 && packettype>=MPEG_AUDIO_STREAM_START &&
                                         packettype<=MPEG_AUDIO_STREAM_END)
            {
              _SlibDebug(_VERBOSE_,
                  ScDebugPrintf(Info->dbg,"Selecting Audio PID %d\n", pid) );
              Info->AudioPID=pid;
            }
          }
        }
        if (payload_len>0 && (Info->VideoPID==pid || Info->AudioPID==pid))
        {
          if (Info->VideoPID==pid)
            dstpin = slibGetPin(Info, SLIB_DATA_VIDEO);
          else
            dstpin = slibGetPin(Info, SLIB_DATA_AUDIO);
          if (dstpin && slibPinOverflowing(Info, dstpin))
          {
            slibPinPrepareReposition(Info, dstpin->ID);
            _SlibDebug(_WARN_,
                 ScDebugPrintf(Info->dbg,"Skipped data on Overflowing pin %s: time %d->",
                                     dstpin->name, Info->VideoTimeStamp) );
            if (dstpin->ID == SLIB_DATA_VIDEO)
            {
              dword frames=slibCountCodesOnPin(Info, dstpin,
                                 MPEG_PICTURE_START, 4, Info->OverflowSize/2);
              if (Info->FramesPerSec)
                Info->VideoTimeStamp+=slibFrameToTime(Info, frames);
            }
            _SlibDebug(_WARN_, ScDebugPrintf(Info->dbg,"%d\n", Info->VideoTimeStamp) );
            slibSkipDataOnPin(Info, dstpin, Info->OverflowSize/2);
            slibPinFinishReposition(Info, dstpin->ID);
            if (dstpin->ID == SLIB_DATA_VIDEO) /* move to key frame */
              SlibSeek((SlibHandle_t *)Info, SLIB_STREAM_MAINVIDEO,
                                           SLIB_SEEK_NEXT_KEY, 0);
          }
          if (dstpin && !slibPinOverflowing(Info, dstpin))
          {
            _SlibDebug(_DEBUG_>1, 
                  ScDebugPrintf(Info->dbg,"Adding Packet: Head=%02X %02X %02X %02X\n",
                             buf[0], buf[1], buf[2], buf[3]) );
            /* add the packet to the destination pin */
            while ((int)size<payload_len)
            {
              _SlibDebug(_DEBUG_,
                         printf("payload_len=%d but buffer is %d bytes\n", 
                              payload_len, size) );
              if (size)
              {
                SlibAllocSubBuffer(buf, size);
                slibAddBufferToPin(dstpin, buf, size, ptimestamp);
                ptimestamp=SLIB_TIME_NONE;
                payload_len-=size;
              }
              SlibFreeBuffer(bufstart);
              buf=bufstart=slibGetBufferFromPin(Info, srcpin, &size, NULL);
              if (!buf) return(fillpin==dstpin?TRUE:FALSE);
            }
            if (payload_len)
            {
              SlibAllocSubBuffer(buf, payload_len);
              slibAddBufferToPin(dstpin, buf, payload_len, ptimestamp);
              ptimestamp=SLIB_TIME_NONE;
              size-=payload_len;
              buf+=payload_len;
            }
            /* add remaining buffer data back to input pin */
            if (size)
            {
              SlibAllocSubBuffer(buf, size);
              _SlibDebug(_WARN_ && buf[0]!=MPEG_TSYNC_CODE, 
                ScDebugPrintf(Info->dbg,
                    "Next code not Transport Sync: %02X %02X %02X %02X\n",
                             buf[0], buf[1], buf[2], buf[3]) );
              slibInsertBufferOnPin(srcpin, buf, size, SLIB_TIME_NONE);
            }
            SlibFreeBuffer(bufstart);
            payload_len=0;
            size=0;
            if (fillpin==dstpin)
              return(TRUE);
            else if (fillpin==NULL)
              return(FALSE);
            continue;
          }
          _SlibDebug(_WARN_, ScDebugPrintf(Info->dbg,
             "ParseMpeg2Transport() Data not added: payload_len=%d PID=%d\n",
                                payload_len, pid) );
        }
      }
      if (payload_len>0) /* dump the payload */
      {
        if (payload_len>(int)size)
        {
          payload_len-=size;
          SlibFreeBuffer(bufstart);
          bufstart=slibGetBufferFromPin(Info, srcpin, &size, NULL);
          if (!bufstart)
            return(FALSE);
          buf=bufstart+payload_len;
          size-=payload_len;
        }
        else
        {
          buf+=payload_len;
          size-=payload_len;
        }
      }
      /* add remaining buffer data back to input pin */
      if (size)
      {
        SlibAllocSubBuffer(buf, size);
        _SlibDebug(_WARN_ && buf[0]!=MPEG_TSYNC_CODE, 
             ScDebugPrintf(Info->dbg,
                "Next code not Transport Sync: %02X %02X %02X %02X\n",
                          buf[0], buf[1], buf[2], buf[3]) );
        slibInsertBufferOnPin(srcpin, buf, size, SLIB_TIME_NONE);
      }
      SlibFreeBuffer(bufstart);
    } /* while */
  }
  return(FALSE);
}
#endif /* MPEG_SUPPORT */

#ifdef H261_SUPPORT
/*
** Function: slibParseH261()
** Descript: Parse H.261 Video stream and add Video data to Video Pin.
** Returns:  TRUE if data was added to dstpin, otherwise FALSE.
*/
SlibBoolean_t slibParseH261(SlibInfo_t *Info, SlibPin_t *srcpin,
                                              SlibPin_t *dstpin)
{
  if (!srcpin)
    srcpin = slibLoadPin(Info, SLIB_DATA_COMPRESSED);
  if (!dstpin)
    dstpin = slibGetPin(Info, SLIB_DATA_VIDEO);
  _SlibDebug(_DEBUG_, printf("slibParseH261()\n"));
  if (srcpin && dstpin)
  {
    unsigned char *buf;
    unsigned dword size;
    SlibTime_t time;
    if ((buf=slibGetBufferFromPin(Info, srcpin, &size, &time))!=NULL)
    {
      slibAddBufferToPin(dstpin, buf, size, time);
      return(TRUE);
    }
  }
  return(FALSE);
}
#endif /* H261_SUPPORT */

#ifdef H263_SUPPORT
/*
** Function: slibParseH261()
** Descript: Parse H.261 Video stream and add Video data to Video Pin.
** Returns:  TRUE if data was added to dstpin, otherwise FALSE.
*/
SlibBoolean_t slibParseH263(SlibInfo_t *Info, SlibPin_t *srcpin,
                                              SlibPin_t *dstpin)
{
  if (!srcpin)
    srcpin = slibLoadPin(Info, SLIB_DATA_COMPRESSED);
  if (!dstpin)
    dstpin = slibGetPin(Info, SLIB_DATA_VIDEO);
  _SlibDebug(_DEBUG_, printf("slibParseH263()\n"));
  if (srcpin && dstpin)
  {
    unsigned char *buf;
    unsigned dword size;
    SlibTime_t time;
    if (Info->Type==SLIB_TYPE_RTP_H263)
    {
      word  rtp_start, sequence_no;
      dword sync_src, pay_start;
      /* RTP header */
      rtp_start=slibGetWordFromPin(Info, srcpin);
      sequence_no=slibGetWordFromPin(Info, srcpin);
      time=slibGetDWordFromPin(Info, srcpin);
      sync_src=slibGetDWordFromPin(Info, srcpin);
      /* RTP payload header */
      pay_start=slibGetDWordFromPin(Info, srcpin);
      if ((pay_start&0x80000000) == 0) /* Mode A */
      {
        size=Info->PacketSize-16;
        buf=SlibAllocBuffer(size);
      }
      else if ((pay_start&0x40000000) == 0) /* Mode B */
      {
        dword pay_start2=slibGetDWordFromPin(Info, srcpin);
        size=Info->PacketSize-20;
      }
      else /* Mode C */
      {
        dword pay_start2=slibGetDWordFromPin(Info, srcpin);
        size=Info->PacketSize-20;
      }
      buf=SlibAllocBuffer(size);
      if (buf==NULL) return(FALSE);
      size=slibFillBufferFromPin(Info, srcpin, buf, size, NULL);
      if (size)
        slibAddBufferToPin(dstpin, buf, size, time);
    }
    else
    {
      if ((buf=slibGetBufferFromPin(Info, srcpin, &size, &time))!=NULL)
      {
        slibAddBufferToPin(dstpin, buf, size, time);
        return(TRUE);
      }
    }
  }
  return(FALSE);
}
#endif /* H263_SUPPORT */

#ifdef HUFF_SUPPORT
/*
** Function: slibParseSlibHuff()
** Descript: Parse SLIB Huffman Video stream and add Video data to Video Pin.
** Returns:  TRUE if data was added to dstpin, otherwise FALSE.
*/
SlibBoolean_t slibParseSlibHuff(SlibInfo_t *Info, SlibPin_t *srcpin,
                                              SlibPin_t *dstpin)
{
  if (!srcpin)
    srcpin = slibLoadPin(Info, SLIB_DATA_COMPRESSED);
  if (!dstpin)
    dstpin = slibGetPin(Info, SLIB_DATA_VIDEO);
  _SlibDebug(_DEBUG_, printf("slibParseSlibHuff()\n"));
  if (srcpin && dstpin)
  {
    unsigned char *buf;
    unsigned dword size;
    SlibTime_t time;
    _SlibDebug(_VERBOSE_, printf("slibParseSlibHuff(%s)\n", srcpin->name) );
    if (!Info->HeaderProcessed)
    {
      _SlibDebug(_VERBOSE_, printf("slibParseSlibHuff() Header\n") );
      slibGetDWordFromPin(Info, srcpin); /* SLIB */
      slibGetDWordFromPin(Info, srcpin); /* HUFF */
      Info->HeaderProcessed=TRUE;
    }
    if ((buf=slibGetBufferFromPin(Info, srcpin, &size, &time))!=NULL)
    {
      slibAddBufferToPin(dstpin, buf, size, time);
      return(TRUE);
    }
  }
  return(FALSE);
}
#endif /* HUFF_SUPPORT */

#ifdef G723_SUPPORT
/*
** Function: slibParseG723Audio()
** Descript: Parse G723 Audio stream and add Audio data to Audio Pin.
** Returns:  TRUE if data was added to dstpin, otherwise FALSE.
*/
SlibBoolean_t slibParseG723Audio(SlibInfo_t *Info, SlibPin_t *srcpin,
                                                    SlibPin_t *dstpin)
{
  _SlibDebug(_DEBUG_, printf("slibParseG723Audio()\n"));
  if (!srcpin)
    srcpin = slibLoadPin(Info, SLIB_DATA_COMPRESSED);
  if (!dstpin)
    dstpin = slibGetPin(Info, SLIB_DATA_AUDIO);
  if (srcpin && dstpin)
  {
    unsigned char *buf;
    unsigned dword size;
    SlibTime_t time;
    if ((buf=slibGetBufferFromPin(Info, srcpin, &size, &time))!=NULL)
    {
      slibAddBufferToPin(dstpin, buf, size, time);
      _SlibDebug(_DEBUG_, printf("slibParseG723Audio() added %d bytes\n",
                            size));
      return(TRUE);
    }
  }
  return(FALSE);
}
#endif /* G723_SUPPORT */

/*
** Function: slibParseAVI()
** Descript: Parse AVI data and add Video data to Video Pin.
** Returns:  TRUE if data was added to fillpin, otherwise FALSE.
*/
SlibBoolean_t slibParseAVI(SlibInfo_t *Info, SlibPin_t *srcpin,
                                             SlibPin_t *fillpin)
{
  unsigned char *buf, *bufstart=NULL;
  unsigned dword size;
  SlibTime_t time=SLIB_TIME_NONE;
  SlibPin_t *dstpin;
  _SlibDebug(_DEBUG_, printf("slibParseAVI()\n") );
  if (!srcpin && (srcpin = slibLoadPin(Info, SLIB_DATA_COMPRESSED))==NULL)
    return(FALSE);
  /* only searching for video, for now */
  dstpin = slibGetPin(Info, SLIB_DATA_VIDEO);
  do {
    buf = bufstart = slibSearchBuffersOnPin(Info, srcpin, NULL, &size,
               (('0'<<16) | ('0'<<8) | 'd'), 3, TRUE);
                                  /* AVI_DIBcompressed or AVI_DIBbits */
    if (buf==NULL || *buf=='c' || *buf=='b')
      break;
    /* put buffer back on input to be search again */
    slibInsertBufferOnPin(srcpin, buf, size, SLIB_TIME_NONE);
  } while (buf);
  if (buf && dstpin)
  {
    unsigned dword framesize;
    buf++;  /* skip 'c' or 'b' */
    size--;
    framesize=((int)buf[3]<<24)|((int)buf[2]<<16)|
                    ((int)buf[1]<<8)|buf[0];
    buf+=4;
    size-=4;
    if (framesize==0)
      return(FALSE);
    else if (size>=framesize)
    {
      SlibAllocSubBuffer(buf, framesize);
      slibAddBufferToPin(dstpin, buf, framesize, time);
    }
    else
    {
      /* frame data crosses over into next buffer */
      unsigned char *newbuf=SlibAllocBuffer(framesize);
      slibAddBufferToPin(dstpin, newbuf, framesize, time);
      _SlibDebug(_DEBUG_, printf("Copying in sections\n") );
      do {
        _SlibDebug(_DEBUG_,
          printf("Copying %d bytes (framesize=%d)\n", size, framesize) );
        memcpy(newbuf, buf, size);
        newbuf+=size;
        framesize-=size;
        SlibFreeBuffer(bufstart);
        buf=bufstart=slibGetBufferFromPin(Info, srcpin, &size, &time);
        if (buf==NULL)
          return(FALSE);
      } while (size<framesize);
      if (framesize>0)
        memcpy(newbuf, buf, framesize);
    }
    buf+=framesize;
    size-=framesize;
    if (size>0) /* add remaining data back onto src pin */
    {
      SlibAllocSubBuffer(buf, size);
      slibInsertBufferOnPin(srcpin, buf, size, SLIB_TIME_NONE);
    }
    SlibFreeBuffer(bufstart);
    if (fillpin==dstpin)
      return(TRUE);
  }
  else
    _SlibDebug(_DEBUG_, printf("Failed to find JPEG frame\n") );
  return(FALSE);
}

/*
** Function: slibParseRaster()
** Descript: Parse Sun Raster data and add Video data to Video Pin.
** Returns:  TRUE if data was added to fillpin, otherwise FALSE.
*/
SlibBoolean_t slibParseRaster(SlibInfo_t *Info, SlibPin_t *srcpin,
                                             SlibPin_t *fillpin)
{
  unsigned char *buf, *bufstart=NULL;
  unsigned dword size;
  SlibTime_t time=SLIB_TIME_NONE;
  SlibPin_t *dstpin;
  _SlibDebug(_DEBUG_, printf("slibParseRaster()\n") );
  if (!srcpin && (srcpin = slibLoadPin(Info, SLIB_DATA_COMPRESSED))==NULL)
    return(FALSE);
  /* only searching for video, for now */
  dstpin = slibGetPin(Info, SLIB_DATA_VIDEO);
  buf = bufstart = slibSearchBuffersOnPin(Info, srcpin, NULL, &size,
               0x59a66a95, 4, TRUE);
  if (buf && dstpin)
  {
    unsigned dword framesize;
    buf+=28;  /* skip header */
    size-=28;
    if (Info->CompVideoFormat)
      framesize=Info->CompVideoFormat->biWidth*Info->CompVideoFormat->biHeight*3;
    else
      framesize=Info->Width*Info->Height*3;
    if (size>=framesize)
    {
      SlibAllocSubBuffer(buf, framesize);
      slibAddBufferToPin(dstpin, buf, framesize, time);
    }
    else
    {
      /* frame data crosses over into next buffer */
      unsigned char *newbuf=SlibAllocBuffer(framesize);
      slibAddBufferToPin(dstpin, newbuf, framesize, time);
      _SlibDebug(_DEBUG_, printf("Copying in sections\n") );
      do {
        _SlibDebug(_DEBUG_,
          printf("Copying %d bytes (framesize=%d)\n", size, framesize) );
        memcpy(newbuf, buf, size);
        newbuf+=size;
        framesize-=size;
        SlibFreeBuffer(bufstart);
        buf=bufstart=slibGetBufferFromPin(Info, srcpin, &size, &time);
        if (buf==NULL)
          return(FALSE);
      } while (size<framesize);
      if (framesize>0)
        memcpy(newbuf, buf, framesize);
    }
    buf+=framesize;
    size-=framesize;
    if (size>0) /* add remaining data back onto src pin */
    {
      SlibAllocSubBuffer(buf, size);
      slibInsertBufferOnPin(srcpin, buf, size, SLIB_TIME_NONE);
    }
    SlibFreeBuffer(bufstart);
    if (fillpin==dstpin)
      return(TRUE);
  }
  else
    _SlibDebug(_DEBUG_, printf("Failed to find Raster frame\n") );
  return(FALSE);
}

/*
** Name: slibSetMaxInput
** Desc: Set the maximum number of bytes allowed to be input.
**       Use maxbytes=0 for no limit.
*/
void slibSetMaxInput(SlibInfo_t *Info, unsigned dword maxbytes)
{
  Info->MaxBytesInput=maxbytes;
  if (maxbytes)
  {
    SlibPin_t *pin = slibGetPin(Info, SLIB_DATA_COMPRESSED);
    if (pin)
      Info->InputMarker=pin->Offset;
    else
      Info->MaxBytesInput=0;
  }
}

/*
** Name: slibGetPinPosition
** Desc: Get the current byte position counter for a pin.
** Return: -1 if pin doesn't exist
*/
SlibPosition_t slibGetPinPosition(SlibInfo_t *Info, int pinid)
{
  SlibPin_t *pin;
  _SlibDebug(_DEBUG_>1, printf("slibGetPinPosition(pinid=%d)\n", pinid) );
  if ((pin=slibGetPin(Info, pinid))!=NULL)
    return(pin->Offset);
  else
    return((SlibPosition_t)-1);
}

/*
** Name: slibSetPinPosition
** Desc: Set the byte position counter for a pin.
**       Called when seeking to a new offset.
** Return: old position
**         -1 if pin doesn't exist
*/
SlibPosition_t slibSetPinPosition(SlibInfo_t *Info, int pinid,
                                                    SlibPosition_t pos)
{
  SlibPin_t *pin;
  SlibPosition_t oldpos;
  _SlibDebug(_DEBUG_, printf("slibSetPinPosition(pinid=%d, pos=%ld)\n",
                                     pinid, pos) );
  if ((pin=slibGetPin(Info, pinid))!=NULL)
  {
    oldpos=pin->Offset;
    pin->Offset=pos;
    return(oldpos);
  }
  else
    return((SlibPosition_t)-1);
}

/*
** Name: slibPreLoadPin
** Desc: Load a buffer onto a particular pin (try to get it from the 
**       appropriate source).
*/
SlibPin_t *slibPreLoadPin(SlibInfo_t *Info, SlibPin_t *pin)
{
  unsigned char *buf, *bufstart=NULL;
  unsigned dword size;
  _SlibDebug(_DEBUG_, printf("slibPreLoadPin(%s)\n",pin->name) );
  if (!pin || Info->Mode!=SLIB_MODE_DECOMPRESS)
    return(NULL);
  switch (pin->ID)
  {
      case SLIB_DATA_COMPRESSED:
            _SlibDebug(_DEBUG_ && Info->MaxBytesInput,
                        printf("Offset=%d InputMarker=%d\n",
                             pin->Offset, Info->InputMarker) );
            if (Info->MaxBytesInput && 
                 (pin->Offset-Info->InputMarker)>=Info->MaxBytesInput)
              return(NULL);
            if (Info->SlibCB) /* data source is an application callback */
            {
              SlibMessage_t result;
              _SlibDebug(_VERBOSE_,
                 printf("slibPreLoadPin(%s) SlibCB(SLIB_MSG_ENDOFDATA)\n",
                      pin->name) );
              result=(*(Info->SlibCB))((SlibHandle_t)Info,
                             SLIB_MSG_ENDOFDATA, (SlibCBParam1_t)0, 
                            (SlibCBParam2_t)0, (void *)Info->SlibCBUserData);
              switch (result)
              {
                case SLIB_MSG_CONTINUE:
                      return(pin);
                case SLIB_MSG_ENDOFSTREAM:
                case SLIB_MSG_ENDOFDATA:
                case SLIB_MSG_BADPOSITION:
                      Info->IOError=TRUE;
                      break;
                default:
                      return(NULL);
              }
            }
            else if (Info->Fd>=0) /* data source is a file */
            {
              if ((buf=SlibAllocBuffer(Info->FileBufSize))==NULL)
                return(NULL);
              _SlibDebug(_VERBOSE_,
                 printf("slibPreLoadPin(%s) ScFileRead(%d, %d bytes)\n",
                                  pin->name, Info->Fd, Info->FileBufSize) );
              size = ScFileRead(Info->Fd, buf, Info->FileBufSize);
              if (size<Info->FileBufSize)
                Info->IOError=TRUE;
              if (size <= 0)
              {
                SlibFreeBuffer(buf);
                return(NULL);
              }
              else
              {
                slibAddBufferToPin(pin, buf, size, SLIB_TIME_NONE);
                return(pin);
              }
            }
            break;
      case SLIB_DATA_AUDIO:
            switch (Info->Type)
            {
                case SLIB_TYPE_PCM_WAVE:
                      if (slibParseWave(Info, NULL, pin))
                        return(pin);
                      break;
#ifdef MPEG_SUPPORT
                case SLIB_TYPE_MPEG1_AUDIO:
                      if (slibParseMpegAudio(Info, NULL, pin))
                        return(pin);
                      break;
                case SLIB_TYPE_MPEG_SYSTEMS:
                case SLIB_TYPE_MPEG_SYSTEMS_MPEG2:
                      if (slibParseMpeg1Systems(Info, NULL, pin))
                        return(pin);
                      break;
                case SLIB_TYPE_MPEG_PROGRAM:
                      if (slibParseMpeg2Program(Info, NULL, pin))
                        return(pin);
                      break;
                case SLIB_TYPE_MPEG_TRANSPORT:
                      if (slibParseMpeg2Transport(Info, NULL, pin))
                        return(pin);
                      break;
#endif /* MPEG_SUPPORT */
#ifdef AC3_SUPPORT
                case SLIB_TYPE_AC3_AUDIO:
                      if (slibParseAC3Audio(Info, NULL, pin))
                        return(pin);
                      break;
#endif /* AC3_SUPPORT */
#ifdef G723_SUPPORT
                case SLIB_TYPE_G723:
                      if (slibParseG723Audio(Info, NULL, pin))
                        return(pin);
                      break;
#endif /* G723_SUPPORT */
            }
            break;
      case SLIB_DATA_VIDEO:
            switch (Info->Type)
            {
                case SLIB_TYPE_AVI:
                case SLIB_TYPE_YUV_AVI:
                      if (slibParseAVI(Info, NULL, pin))
                        return(pin);
                      break;
                case SLIB_TYPE_RASTER:
                      if (slibParseRaster(Info, NULL, pin))
                        return(pin);
                      break;
#ifdef MPEG_SUPPORT
                case SLIB_TYPE_MPEG1_VIDEO:
                case SLIB_TYPE_MPEG2_VIDEO:
                      if (slibParseMpegVideo(Info, NULL, pin))
                        return(pin);
                      break;
                case SLIB_TYPE_MPEG_SYSTEMS:
                case SLIB_TYPE_MPEG_SYSTEMS_MPEG2:
                      if (slibParseMpeg1Systems(Info, NULL, pin))
                        return(pin);
                      break;
                case SLIB_TYPE_MPEG_PROGRAM:
                      if (slibParseMpeg2Program(Info, NULL, pin))
                        return(pin);
                      break;
                case SLIB_TYPE_MPEG_TRANSPORT:
                      if (slibParseMpeg2Transport(Info, NULL, pin))
                        return(pin);
                      break;
#endif /* MPEG_SUPPORT */
#ifdef H261_SUPPORT
                case SLIB_TYPE_H261:
                case SLIB_TYPE_RTP_H261:
                      if (slibParseH261(Info, NULL, pin))
                        return(pin);
                      break;
#endif /* H261_SUPPORT */
#ifdef H263_SUPPORT
                case SLIB_TYPE_H263:
                case SLIB_TYPE_RTP_H263:
                      if (slibParseH263(Info, NULL, pin))
                        return(pin);
                      break;
#endif /* H263_SUPPORT */
#ifdef JPEG_SUPPORT
                case SLIB_TYPE_JPEG_AVI:
                case SLIB_TYPE_MJPG_AVI:
                      if (slibParseAVI(Info, NULL, pin))
                        return(pin);
                      break;
#endif /* JPEG_SUPPORT */
#ifdef HUFF_SUPPORT
                case SLIB_TYPE_SHUFF:
                      if (slibParseSlibHuff(Info, NULL, pin))
                        return(pin);
                      break;
#endif /* HUFF_SUPPORT */
            }
            break;
      case SLIB_DATA_PRIVATE:
            switch (Info->Type)
            {
#ifdef MPEG_SUPPORT
                case SLIB_TYPE_MPEG_SYSTEMS:
                case SLIB_TYPE_MPEG_SYSTEMS_MPEG2:
                      if (slibParseMpeg1Systems(Info, NULL, pin))
                        return(pin);
                      break;
                case SLIB_TYPE_MPEG_PROGRAM:
                      if (slibParseMpeg2Program(Info, NULL, pin))
                        return(pin);
                      break;
                case SLIB_TYPE_MPEG_TRANSPORT:
                      if (slibParseMpeg2Transport(Info, NULL, pin))
                        return(pin);
                      break;
#endif /* MPEG_SUPPORT */
            }
            break;
  }
  return(NULL);
}

/*
** Name:    slibPutBuffer
** Purpose: Send a buffer to the appropriate output.
*/
SlibStatus_t slibPutBuffer(SlibInfo_t *Info, unsigned char *buffer,
                                             unsigned dword bufsize)
{
  _SlibDebug(_VERBOSE_ || _WRITE_,
        printf("slibPutBuffer(%d) %d bytes\n", Info->Fd, bufsize) );
  if (bufsize==0)
    return(SlibErrorNone);
  if (Info->IOError || buffer==NULL)
    return(SlibErrorWriting);
  if (Info->Fd>=0) /* writing to a file */
  {
    if ((unsigned dword)ScFileWrite(Info->Fd, buffer, bufsize)<bufsize)
      Info->IOError=TRUE;
    if (SlibValidBuffer(buffer))
      SlibFreeBuffer(buffer);
  }
  else if (Info->SlibCB) /* sending data back to app through a callback */
  {
    _SlibDebug(_WARN_,
        printf("slibPutBuffer(%d) callbacks not yet supported\n") );
    if (SlibValidBuffer(buffer))
      SlibFreeBuffer(buffer);
  }
  else /* adding buffer to compress data pin */
  {
    unsigned char *bufptr=buffer;
    SlibPin_t *pin=slibGetPin(Info, SLIB_DATA_COMPRESSED);
    if (!SlibValidBuffer(bufptr))
    {
      /* we need to create a SLIB allocated buffer to copy the
       * output to and then add to the compressed data pin
       */
      bufptr=SlibAllocBuffer(bufsize);
      if (!bufptr)
        return(SlibErrorMemory);
      memcpy(bufptr, buffer, bufsize);
    }
    if (slibAddBufferToPin(pin, bufptr, bufsize, SLIB_TIME_NONE)!=SlibErrorNone)
     return(SlibErrorWriting);
  }
  return(SlibErrorNone);
}

/*
** Name:    slibGetBufferFromPin
** Purpose: Read the next buffer from the data source.
*/
unsigned char *slibGetBufferFromPin(SlibInfo_t *Info, SlibPin_t *pin,
                                    unsigned dword *size, SlibTime_t *time)
{
  unsigned char *address=NULL;
  _SlibDebug(_DEBUG_>1, printf("slibGetBufferFromPin(%s)\n", pin->name) );
  if (slibLoadPin(Info, pin->ID) != NULL)
  {
    SlibBuffer_t *tmpbuf = pin->Buffers;
    pin->Offset=tmpbuf->offset+tmpbuf->size;
    if (tmpbuf->next == NULL)
      pin->BuffersTail = NULL;
    pin->Buffers = tmpbuf->next;
    address=tmpbuf->address;
    if (size)
      *size = tmpbuf->size;
    if (time)
      *time = tmpbuf->time;
    pin->BufferCount--;
    pin->DataSize-=tmpbuf->size;
    ScFree(tmpbuf);
  }
  else
  {
    _SlibDebug(_WARN_ && pin->DataSize,
     printf("slibGetBufferFromPin() No more buffers on pin, yet DataSize=%d\n",
                     pin->DataSize) );
    if (size)
      *size = 0;
    address=NULL;
  }
  return(address);
}

/*
** Name:    slibGetBufferFromPin
** Purpose: Get a pointer to the next buffer on a pin, but don't
**          remove it.
*/
unsigned char *slibPeekBufferOnPin(SlibInfo_t *Info, SlibPin_t *pin,
                                   unsigned dword *psize, SlibTime_t *ptime)
{
  _SlibDebug(_DEBUG_, printf("slibPeekBufferOnPin(%s)\n",pin->name) );
  if (slibLoadPin(Info, pin->ID) != NULL)
  {
    if (psize)
      *psize = pin->Buffers->size;
    if (ptime)
      *ptime = pin->Buffers->time;
    return(pin->Buffers->address);
  }
  else
    return(NULL);
}

/*
** Name:    slibGetNextTimeOnPin
** Purpose: Get the next time on a pin.
*/
SlibTime_t slibGetNextTimeOnPin(SlibInfo_t *Info, SlibPin_t *pin,
                                   unsigned dword maxbytes)
{
  unsigned dword bytesread=0, size;
  unsigned char *buf;
  SlibTime_t timefound=SLIB_TIME_NONE;
  _SlibDebug(_DEBUG_,
       printf("slibGetNextTimeOnPin(%s)\n",pin?"NULL":pin->name) );
  if (!pin)
    return(SLIB_TIME_NONE);
  buf=slibPeekBufferOnPin(Info, pin, &size, &timefound);
  bytesread+=size;
  while (buf && timefound==SLIB_TIME_NONE && bytesread<maxbytes)
  {
    buf=slibPeekNextBufferOnPin(Info, pin, buf, &size, &timefound);
    bytesread+=size;
  }
  return(timefound);
}

/*
** Name:    slibPeekNextBufferOnPin
** Purpose: Get a pointer to the next buffer on a pin after the buffer
**          specified by "lastbuffer"; don't remove it.
*/
unsigned char *slibPeekNextBufferOnPin(SlibInfo_t *Info, SlibPin_t *pin, 
                                       unsigned char *lastbuffer,
                                       unsigned dword *size, SlibTime_t *time)
{
  unsigned char *address=NULL;
  SlibBuffer_t *tmpbuf;
  _SlibDebug(_DEBUG_, printf("slibPeekNextBufferOnPin(lastbuffer=%p,pin=%s)\n",
                   lastbuffer, pin->name) );
  /* check the last loaded buffer first */
  tmpbuf=pin->BuffersTail;
  if (tmpbuf &&
      lastbuffer>=tmpbuf->address && lastbuffer<tmpbuf->address+tmpbuf->size)
  {
    /* load a new buffer onto the pin */
    slibPreLoadPin(Info, pin);
    if (tmpbuf != pin->BuffersTail)
    {
      address=pin->BuffersTail->address;
      if (size)
        *size=pin->BuffersTail->size;
      if (time)
        *time=pin->BuffersTail->time;
      return(address);
    }
    _SlibDebug(_WARN_, printf("slibPeekNextBufferOnPin() End of data\n") );
    return(NULL);
  }
  /* search through all the buffers on the pin */
  if (pin->Buffers==NULL)
    slibPreLoadPin(Info, pin);
  tmpbuf = pin->Buffers;
  while (tmpbuf)
  {
    if (lastbuffer>=tmpbuf->address && lastbuffer<tmpbuf->address+tmpbuf->size)
    {
      tmpbuf=tmpbuf->next;
      if (tmpbuf)
      {
        _SlibDebug(_WARN_ && 
         lastbuffer>=tmpbuf->address && lastbuffer<tmpbuf->address+tmpbuf->size,
                 printf("slibPeekNextBufferOnPin() same addresses\n") );
        if (size)
          *size=tmpbuf->size;
        if (time)
          *time=tmpbuf->time;
        return(tmpbuf->address);
      }
      else
      {
        _SlibDebug(_WARN_, printf("slibPeekNextBufferOnPin() End of bufs\n") );
        return(NULL);
      }
    }
    tmpbuf=tmpbuf->next;
  }
  _SlibDebug(_WARN_, printf("slibPeekNextBufferOnPin() address no found\n") );
  return(NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech261\dech26x.h ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: h26x.h,v $
 * $EndLog$
 */
/*
**++
** FACILITY:  Workstation Multimedia  (WMM)  v1.0 
** 
** FILE NAME:   h26x.h  
** MODULE NAME: h26x.h
**
** MODULE DESCRIPTION: h261/h263 include file.
** 
** DESIGN OVERVIEW: 
** 
**--
*/
#ifndef _H26X_H_
#define _H26X_H_

#define VIDEO_FORMAT_DIGITAL_H261  mmioFOURCC('D', '2', '6', '1')
#define VIDEO_FORMAT_DIGITAL_H263  mmioFOURCC('D', '2', '6', '3')

/* H.263 encoder controls */
#define DECH26X_CUSTOM_ENCODER_CONTROL  0x6009

#define EC_RTP_HEADER      0
#define EC_RESILIENCY	   1
#define EC_PACKET_SIZE     2
#define EC_PACKET_LOSS     3
#define EC_BITRATE_CONTROL 4
#define EC_BITRATE         5

#define EC_SET_CURRENT                0
#define EC_GET_FACTORY_DEFAULT        1
#define EC_GET_FACTORY_LIMITS         2
#define EC_GET_CURRENT                3
#define EC_RESET_TO_FACTORY_DEFAULTS  4

/***** Settings for EC_RTP_HEADER ******/
#define EC_RTP_MODE_OFF               0
#define EC_RTP_MODE_A                 1
#define EC_RTP_MODE_B                 2
#define EC_RTP_MODE_C                 4

/***** example Custom Encoder call ******
  lRet = ICSendMessage(hIC,
                       DECH26X_CUSTOM_ENCODER_CONTROL,
                       MAKELPARAM(EC_RTP_HEADER, EC_SET_CURRENT),
                       (LPARAM)EC_RTP_MODE_A
                      );
  DWORD retval;
  lRet = ICSendMessage(hIC,
                       DECH26X_CUSTOM_ENCODER_CONTROL,
                       MAKELPARAM(EC_PACKET_SIZE, EC_GET_CURRENT),
                       (LPARAM)&retval
                      );
*****************************************/
#endif /* _H26X_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech261\decomp.c ===
/* File: sv_h261_decompress.c */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995, 1997                 **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/
/*************************************************************
This file handle the decompression of an H.261 compressed data source.
*************************************************************/

  
#include <stdio.h>
#include <stdlib.h> 

#ifdef __osf__
#include <sys/time.h>
#else
#include <time.h>
#endif
 
#include "sv_intrn.h"
#include "sv_h261.h"
#include "proto.h"
#include "sv_proto.h"
#include "SC_err.h"  

/*PUBLIC*/
extern int   QuantMType[]; 
extern int   CBPMType[];
extern int   IntraMType[];
extern int   MFMType[];
extern int   FilterMType[]; 
extern int   TCoeffMType[];
extern int   bit_set_mask[];

static SvStatus_t p64DecodeGOB (SvH261Info_t *H261, ScBitstream_t *bs);
static SvStatus_t SetCCITT(SvH261Info_t *H261);
extern void ReadPictureHeader(SvH261Info_t *H261, ScBitstream_t *bs);
/*
** Read up to the Sequence header and get the image size
*/
SvStatus_t sv_GetH261ImageInfo(int fd, SvImageInfo_t *iminfo)
{
  ScBitstream_t *bs;
  SvStatus_t stat;
  int input;
  int GRead;
  int PType;
  int PSpareEnable;
  int TemporalReference;
  int PSpare;
  int ImageType;
  stat=ScBSCreateFromFile(&bs, fd, NULL, 2048);

  /* ReadHeaderHeader */
  input = (int) ScBSGetBits(bs, 16);
  if ((input != 1) || (bs->EOI ))
    {
      /* not implemented
        if (seof()==0)
        {*/
         /* printf("Illegal GOB Start Code. Read: %d\n",input);
         }*/
      return(-1);
    }
  /* ReadHeaderTrailer */
  GRead = (int)ScBSGetBits(bs,4)-1;
  if (GRead < 0)  /* End Of Frame */
	{
	/* ReadPictureHeader */  
  	TemporalReference =  (int) ScBSGetBits(bs,5);

 	PType = (int) ScBSGetBits(bs,6);
  	for(PSpareEnable = 0;ScBSGetBit(bs);)
            {		
            PSpareEnable=1;
            PSpare = (int)ScBSGetBits(bs,8);
            }
	}
/* printf ("PType : %d \n",PType);*/
  if (PType&0x04)
      {
      if (PSpareEnable&&PSpare==0x8c)
          ImageType=IT_NTSC;
      else
          ImageType=IT_CIF;
      }
  else
      ImageType=IT_QCIF;
/* printf ("ImageType %d \n", ImageType);*/

  /*  iminfo->width     = (ScBSGetBits(bs,SV_HORIZONTAL_SIZE_LEN)+15) & (~15);
    iminfo->height    = (ScBSGetBits(bs,SV_VERTICAL_SIZE_LEN)+15) & (~15);
  */
  switch(ImageType)
  {
    case IT_NTSC:
      iminfo->width = 352;
      iminfo->height = 240;
      break;
    case IT_CIF:
      iminfo->width = 352;
      iminfo->height = 288;
      break;
    case IT_QCIF:
      iminfo->width = 176;
      iminfo->height = 144;
      break;
    default:
      sc_dprintf("Unknown ImageType: %d\n",ImageType);
      return (SvErrorUnrecognizedFormat);
  }

  ScBSReset(bs);  /* insure the file position is at the beginning */

  if (bs->EOI)
    stat=SvErrorEndBitstream;
  ScBSDestroy(bs);
  return(stat);
}

/*
** Function: svH261Decompress()
** Purpose: Decodes a single H261 Frame.
*/
SvStatus_t svH261Decompress(SvCodecInfo_t *Info, 
                             u_char *MultiBuf, u_char **ImagePtr)
{
  SvStatus_t status;
  SvH261Info_t *H261=Info->h261;
  ScBitstream_t *bs=Info->BSIn;
  ScCallbackInfo_t CB;
  unsigned char *dummy_y, *dummy_u, *dummy_v;  
  if (MultiBuf)
    H261->DecompData = MultiBuf;
  if (Info->BSIn->EOI)
    status = SvErrorEndBitstream;

  /* Initialize the read buffer position and general info */
  status =  ReadHeaderHeader(H261,bs); /* nonzero on error or eof */
  if (status != NoErrors)
    return (status);
  if (H261->CurrentFrame == 0)
  { 
    DGenScaleMat(); /* Generate the scaling matrix - should be done in 'begin' */
    if (H261->PICSIZE==0) /* something not initialized correctly */
      return(SvErrorBadImageSize);
    /* set up current frame pointers */
    H261->Y = H261->DecompData;
    H261->U = H261->DecompData + H261->PICSIZE;
    H261->V = H261->DecompData + H261->PICSIZE + (H261->PICSIZE/4);
    /* initialize image buffer with black */
    memset(H261->Y, 16, H261->PICSIZE);
    memset(H261->U, 128, H261->PICSIZE/4);
    memset(H261->V, 128, H261->PICSIZE/4);
    /* set up reference frame pointers */
    H261->YREF = H261->V + H261->PICSIZE/4;
    H261->UREF = H261->YREF +  H261->PICSIZE;
    H261->VREF = H261->UREF + H261->PICSIZE/4;
    /* initialize image buffer with black */
    memset(H261->YREF, 16, H261->PICSIZE);
    memset(H261->UREF, 128, H261->PICSIZE/4);
    memset(H261->VREF, 128, H261->PICSIZE/4);
    if (H261->CallbackFunction)
    {
      CB.Message = CB_SEQ_HEADER;
      CB.Data = NULL;
      CB.DataSize = 0;
      CB.DataUsed = 0;
      CB.DataType = CB_DATA_NONE;
      CB.Action  = CB_ACTION_CONTINUE;
      (*H261->CallbackFunction)(Info, &CB, NULL);
      sc_dprintf("Callback: CB_SEQ_HEADER. Data=0x%X, Action = %d\n",
                                                        CB.Data, CB.Action);
      if (CB.Action == CB_ACTION_END)
        return (ScErrorClientEnd);
    }
  }
  else
  {
    /* Switch Y,U,V with YREF, UREF, VREF */
    dummy_y = H261->Y;
    dummy_u = H261->U;
    dummy_v = H261->V;
    H261->Y = H261->YREF;
    H261->U = H261->UREF;
    H261->V = H261->VREF;
    H261->YREF = dummy_y;
    H261->UREF = dummy_u;
    H261->VREF = dummy_v;
    memcpy(H261->Y, H261->YREF, H261->PICSIZE);
    memcpy(H261->U, H261->UREF, H261->PICSIZEBY4);
    memcpy(H261->V, H261->VREF, H261->PICSIZEBY4);
}
  while(1) 
  {
    ReadHeaderTrailer(H261,bs); /* Reads the trailer of the PSC or GBSC code...
                                   Determines if GOB or new picture */
    if (bs->EOI)
      return (SvErrorEndBitstream);

    if ((H261->GRead < 0))  /* End Of Frame - Reading new picture */
    {
      ReadPictureHeader(H261,bs);
      if (H261->CallbackFunction)
      {
        CB.Message = CB_FRAME_FOUND;
        CB.Data = NULL;
        CB.DataSize = 0;
        CB.DataUsed = 0;
        CB.DataType = CB_DATA_NONE;
        CB.Action  = CB_ACTION_CONTINUE;
        (*H261->CallbackFunction)(Info, &CB, NULL);
        sc_dprintf("Callback: CB_FRAME_FOUND. Data=0x%X, Action=%d\n",
                                                     CB.Data, CB.Action);
        if (CB.Action == CB_ACTION_END)
          return (ScErrorClientEnd);
      }

      /* This should already be done by begin */
      if (H261->CurrentFrame == 0)  
      {
        /* This should already be done by begin */
        if (H261->PType&0x04)
        {
          if (H261->PSpareEnable&&H261->PSpare==0x8c) 
            H261->ImageType=IT_NTSC;
          else 
            H261->ImageType=IT_CIF;
        }
        else 
          H261->ImageType=IT_QCIF;
        /* set here */
        status = SetCCITT(H261);
        if (status != NoErrors)
          return (status);
        H261->TemporalOffset=(H261->TemporalReference-H261->CurrentFrame)%32;
        /* ywidth = H261->YWidth; */
        H261->CWidth = (H261->YWidth/2);  
        H261->YW4 = (H261->YWidth/4); 
        H261->CW4 = (H261->CWidth/4);  
        /* yheight = H261->YHeight; */
        /* printf("\n Init.. ImageType is %d", H261->ImageType);*/ 

      }/* End of first frame */
      else /* already initialized  */
      {
        while (((H261->CurrentFrame+H261->TemporalOffset)%32) !=
                        H261->TemporalReference)
          H261->CurrentFrame++;
      }
#if 0 /* def WIN32 */
      if (H261->CurrentGOB == 11)
      {
        H261->CurrentGOB = 0;
        memcpy(H261->YREF, H261->Y, H261->PICSIZE);
        memcpy(H261->UREF, H261->U, H261->PICSIZEBY4);
        memcpy(H261->VREF, H261->V, H261->PICSIZEBY4);
        *ImagePtr = H261->Y;
        return (NoErrors);
      }
#endif
      /* Reads the header off of the stream.
         This is a precursor to PSC or GOB read. 
         nonzero on error or eof */
      status = ReadHeaderHeader(H261,bs); 
      /* if true, indicates that this could be EOF */
      if (status != NoErrors)
        return (status);
      continue; 
    } /* End of Read New Picture Header */ 
	/* printf ("Now doing the DecodeGOB \n");*/
    status = p64DecodeGOB(H261,bs);           /* Else decode the GOB */
    if (H261->CurrentGOB == (H261->NumberGOB-1))
    {
      H261->CurrentFrame++;
      *ImagePtr = H261->Y;
      H261->CurrentGOB = 0;
      return (NoErrors); 
    } 
    if (status != NoErrors)
      return (status);
  } /* End of while loop */
}

/*
** Function: p64DecodeGOB
** Purpose: Decodes the GOB block of the current frame.
*/
static SvStatus_t p64DecodeGOB (SvH261Info_t *H261, ScBitstream_t *bs)
{ 
  int i, i8, tempmbh;
  SvStatus_t status;
  unsigned int *y0ptr, *y1ptr, *y2ptr, *y3ptr;
  unsigned int *uptr, *vptr;
  int Odct[6][64];
  int VIndex; 
  int HIndex;
  float ipfloat[64];

/* printf ("bs->EOI %d \n " , bs->EOI); 
*/
  ReadGOBHeader(H261,bs);             /* Read the group of blocks header  */
  if (bs->EOI)
    return (SvErrorEndBitstream);

  switch(H261->ImageType)
  {
      case IT_NTSC:
      case IT_CIF:
          H261->CurrentGOB = H261->GRead;
          break;
      case IT_QCIF:
          H261->CurrentGOB = (H261->GRead>>1);
          break;
      default:
          return (SvErrorUnrecognizedFormat);
          /* printf("Unknown Image Type: %d.\n",H261->ImageType);*/
          break;
  }
  if (H261->CurrentGOB > H261->NumberGOB)
  {
    return (SvErrorCompBufOverflow);
	/* 
      printf("Buffer Overflow: Current:%d  Number:%d\n",
	     H261->CurrentGOB, H261->NumberGOB);
      return;
	*/
  }
  
  H261->LastMBA = -1;               /* Reset the MBA and the other predictors  */ 
  H261->LastMVDH = 0;
  H261->LastMVDV = 0;

  tempmbh = ReadMBHeader(H261, bs);
  if (bs->EOI)
    return(SvErrorEndBitstream);
 
  while (tempmbh==0)
  {
    H261->LastMBA = H261->LastMBA + H261->MBA;
    H261->CurrentMDU = H261->LastMBA;
        
    if (H261->CurrentMDU > 32)
      return (NoErrors);
    if (!CBPMType[H261->MType])
      H261->CBP = 0x3f;
    if (QuantMType[H261->MType])
    {
      H261->UseQuant=H261->MQuant;
      H261->GQuant=H261->MQuant;
    }
    else
      H261->UseQuant=H261->GQuant;
    switch (H261->ImageType)
    {
        case IT_QCIF:
            HIndex = ((H261->CurrentMDU % 11) * 16);  
            VIndex =  (H261->CurrentGOB*48) + ((H261->CurrentMDU/11) * 16);  
            break;
        case IT_NTSC:
        case IT_CIF:
            HIndex = ((((H261->CurrentGOB & 1)*11) + (H261->CurrentMDU%11)) * 16);  
            VIndex = ((H261->CurrentGOB/2)*48) + ((H261->CurrentMDU/11) * 16);  
            break;
        default:
            /* printf("\n Unknown Image Type \n");*/
            return (SvErrorUnrecognizedFormat);
     }
     i = VIndex*H261->YWidth;  
     H261->VYWH = i + HIndex; 
     H261->VYWH2 = (((i/2) + HIndex) /2);   
     i8 = H261->MVDV*H261->YWidth + H261->MVDH;   
     H261->VYWHMV = H261->VYWH + i8;   
     H261->VYWHMV2 = H261->VYWH2 + ((H261->MVDV /2)*H261->CWidth) + (H261->MVDH /2);  
     for(i8=0; i8<6; i8++)
     {
       if ((H261->CBP & bit_set_mask[5-i8])&&(TCoeffMType[H261->MType]))
       {
         if (CBPMType[H261->MType])
           status = CBPDecodeAC_Scale(H261, bs, 0, H261->UseQuant, IntraMType[H261->MType], ipfloat); 
         else
         {
           *ipfloat = DecodeDC_Scale(H261,bs,IntraMType[H261->MType],H261->UseQuant);
           status =  DecodeAC_Scale(H261,bs,1,H261->UseQuant, ipfloat);
         }
         ScScaleIDCT8x8(ipfloat, &Odct[i8][0]);  
       }
       else 
         memset(&Odct[i8][0], 0, 256);
     }  
     y0ptr = (unsigned int *) (H261->Y+H261->VYWH); 
     y1ptr = y0ptr + 2;   
     y2ptr = y0ptr + ((H261->YWidth)<<1);       
     y3ptr = y2ptr + 2;   
     uptr  = (unsigned int *) (H261->U+H261->VYWH2);  
     vptr  = (unsigned int *) (H261->V+H261->VYWH2);  
/* printf ("IntraMType[H261->MType] : %d \n",IntraMType[H261->MType]);*/ 
     if (!IntraMType[H261->MType])
	 {
       if (FilterMType[H261->MType])
	   { 
         ScCopyMB16(&H261->YREF[H261->VYWHMV], &H261->mbRecY[0], H261->YWidth, 16);  
         ScCopyMB8(&H261->UREF[H261->VYWHMV2], &H261->mbRecU[0], H261->CWidth, 8);
         ScCopyMB8(&H261->VREF[H261->VYWHMV2], &H261->mbRecV[0], H261->CWidth, 8);
         ScLoopFilter(&H261->mbRecY[0], H261->workloc, 16); 
         ScLoopFilter(&H261->mbRecY[8], H261->workloc, 16); 
         ScLoopFilter(&H261->mbRecY[128], H261->workloc, 16);
         ScLoopFilter(&H261->mbRecY[136], H261->workloc, 16);
         ScLoopFilter(&H261->mbRecU[0], H261->workloc, 8);
         ScLoopFilter(&H261->mbRecV[0], H261->workloc, 8);  
       }  
       else if (MFMType[H261->MType])
	   { 
         ScCopyMB16(&H261->YREF[H261->VYWHMV], &H261->mbRecY[0], H261->YWidth, 16);  
         ScCopyMB8(&H261->UREF[H261->VYWHMV2], &H261->mbRecU[0], H261->CWidth, 8);
         ScCopyMB8(&H261->VREF[H261->VYWHMV2], &H261->mbRecV[0], H261->CWidth, 8);
       }  
       else
	   {
         ScCopyMB16(&H261->YREF[H261->VYWH], &H261->mbRecY[0], H261->YWidth, 16);  
         ScCopyMB8(&H261->UREF[H261->VYWH2], &H261->mbRecU[0], H261->CWidth, 8);
         ScCopyMB8(&H261->VREF[H261->VYWH2], &H261->mbRecV[0], H261->CWidth, 8);
       }  
       if (H261->CBP & 0x20) 
         ScCopyAddClip(&H261->mbRecY[0], &Odct[0][0], y0ptr, 16, H261->YW4);
       else
         ScCopyMV8(&H261->mbRecY[0], y0ptr, 16, H261->YW4);
       if (H261->CBP & 0x10) 
         ScCopyAddClip(&H261->mbRecY[8], &Odct[1][0], y1ptr, 16, H261->YW4);
       else
         ScCopyMV8(&H261->mbRecY[8], y1ptr, 16, H261->YW4);
       if (H261->CBP & 0x08) 
         ScCopyAddClip(&H261->mbRecY[128], &Odct[2][0], y2ptr, 16, H261->YW4);
       else
         ScCopyMV8(&H261->mbRecY[128], y2ptr, 16, H261->YW4);
       if (H261->CBP & 0x04) 
         ScCopyAddClip(&H261->mbRecY[136], &Odct[3][0], y3ptr, 16, H261->YW4);
       else
         ScCopyMV8(&H261->mbRecY[136], y3ptr, 16, H261->YW4);
       if (H261->CBP & 0x02) 
         ScCopyAddClip(&H261->mbRecU[0], &Odct[4][0], uptr, 8, H261->CW4);
       else
         ScCopyMV8(&H261->mbRecU[0], uptr, 8, H261->CW4);
       if (H261->CBP & 0x01) 
         ScCopyAddClip(&H261->mbRecV[0], &Odct[5][0], vptr, 8, H261->CW4);
       else
         ScCopyMV8(&H261->mbRecV[0], vptr, 8, H261->CW4);
    }
    else
    {
	  ScCopyClip(&Odct[0][0], y0ptr, H261->YW4); 
      ScCopyClip(&Odct[1][0], y1ptr, H261->YW4); 
      ScCopyClip(&Odct[2][0], y2ptr, H261->YW4); 
      ScCopyClip(&Odct[3][0], y3ptr, H261->YW4); 
      ScCopyClip(&Odct[4][0], uptr, H261->CW4); 
      ScCopyClip(&Odct[5][0], vptr, H261->CW4); 
    } 
    if (H261->CurrentMDU >= 32)
    {
      if (H261->CurrentGOB < (H261->NumberGOB-1))
        tempmbh = ReadMBHeader(H261, bs);
      return (NoErrors);
    }
    tempmbh = ReadMBHeader(H261, bs);
    if (bs->EOI)
      return (SvErrorEndBitstream);
  } 
  return(NoErrors);
}

/*
** Function: SetCCITT() 
** Purpose:  Sets the CImage and CFrame parameters for CCITT coding.
*/
static SvStatus_t SetCCITT(SvH261Info_t *H261)
{
  BEGIN("SetCCITT");

  switch(H261->ImageType)
    {
    case IT_NTSC:
      H261->NumberGOB = 10;  /* Parameters for NTSC design */
      H261->NumberMDU = 33;
      H261->YWidth = 352;
      H261->YHeight = 240;
      break;
    case IT_CIF:
      H261->NumberGOB = 12;  /* Parameters for NTSC design */
      H261->NumberMDU = 33;
      H261->YWidth = 352;
      H261->YHeight = 288;
      break;
    case IT_QCIF:
      H261->NumberGOB = 3;  /* Parameters for NTSC design */
      H261->NumberMDU = 33;
      H261->YWidth = 176;
      H261->YHeight = 144;
      break;
    default:
      return (SvErrorUnrecognizedFormat);
	/* printf("Unknown ImageType: %d\n",H261->ImageType);*/
      /* exit(ERROR_BOUNDS);*/
      /* break;*/
    }
    return (NoErrors);
}

SvStatus_t svH261DecompressFree(SvHandle_t Svh)
{
  SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;
  SvH261Info_t *H261 = (SvH261Info_t *) Info->h261;
  if (!H261->inited)
    return(NoErrors);
  sv_H261HuffFree(Info->h261);
  if (Info->h261->workloc)
    ScFree(Info->h261->workloc);
  H261->inited=FALSE;
  return (NoErrors);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech261\dispatch.c ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: h263_dispatch.c,v $
  * $EndLog$
 */
/*
**++
** FACILITY:  Workstation Multimedia  (WMM)  v1.0
**
** FILE NAME:   h263_dispatch.c
** MODULE NAME: h263_dispatch.c
**
** MODULE DESCRIPTION:
**    H.263 ICM driver message dispatch routine.
**
**    Functions
**
**      DriverProc              (Entry point into codec)
**      ICH263Message           (ICM message handler. Calls routines in h263.c)
**      ICH263ClientThread      (Thread for processing most messages)
**      ICH263ProcessThread     (Thread for processing compress/decompress)
**
**    Private functions:
**
** DESIGN OVERVIEW:
** 	Accept the DriverProc message and dispatch to the proper
**      handler.
**
**--
*/

#include <stdio.h>
#include <windows.h>
#include "h26x_int.h"

#ifdef _SLIBDEBUG_
#define _DEBUG_     0  /* detailed debuging statements */
#define _VERBOSE_   1  /* show progress */
#define _VERIFY_    1  /* verify correct operation */
#define _WARN_      1  /* warnings about strange behavior */
#endif

static CRITICAL_SECTION h263CritSect; /* Critical section for multi-thread protection */
static HMODULE ghModule=NULL;         /* Global handle to Module */

#define BOGUS_DRIVER_ID -1	/* Used during open on NT */

#ifdef WIN32
#define CHECKANDLOCK(x) if (((void *)lParam1==NULL) || (int)lParam2<sizeof(x)) \
	                        return ((unsigned int)ICERR_BADPARAM);
#define UNLOCK
#else
#define CHECKANDLOCK(x) { \
      int size = lParam2; \
      if (noChecklParam2 && size < sizeof(x)) \
	size = sizeof(x); \
      if (((void *)lParam1 == NULL) || size < sizeof(x)) \
	return ((unsigned int)ICERR_BADPARAM); \
}
#define UNLOCK
#endif


/***************************************************************************
 ***************************************************************************/

MMRESULT CALLBACK ICH263Message(DWORD_PTR driverHandle,
				    UINT      uiMessage,
				    LPARAM    lParam1,
				    LPARAM    lParam2,
				    H26XINFO *info)
{
    ICINFO *icinfo;
    LPBITMAPINFOHEADER lpbiIn;
    LPBITMAPINFOHEADER lpbiOut;
    ICDECOMPRESS *icDecompress;

    DWORD biSizeIn;
    DWORD biSizeOut;
    MMRESULT ret;

    _SlibDebug(_DEBUG_,
		ScDebugPrintf("ICH263Message(DriverID=%p, message=%d, lParam1=%p,lParam1=%p, info=%p)\n",
             driverHandle, uiMessage, lParam1, lParam2, info) );

    switch (uiMessage)
    {
        /*********************************************************************

	  ICM messages

	 *********************************************************************/	
    case ICM_CONFIGURE:
	/*
	 *  return ICERR_OK if you will do a configure box, error otherwise
	 */
	_SlibDebug(_VERBOSE_, ScDebugPrintf("------ICM_CONFIGURE:\n") );
	if (lParam1 == -1)
	    return ICH263QueryConfigure(info) ? ICERR_OK :
		ICERR_UNSUPPORTED;
	else
	    return ICH263Configure(info);

    case ICM_ABOUT:
	/*
	 *  return ICERR_OK if you will do a about box, error otherwise
	 */
	_SlibDebug(_VERBOSE_, ScDebugPrintf("------ICM_ABOUT::\n") );
	if (lParam1 == -1)
	    return ICH263QueryAbout(info) ? ICERR_OK :
		ICERR_UNSUPPORTED;
	else
	    return ICH263About(info);

    case ICM_GETSTATE:
	_SlibDebug(_VERBOSE_, ScDebugPrintf("------ICM_GETSTATE::\n") );
    if ((LPVOID)lParam1!=NULL) /* getting state size */
    {
      char *stateinfo=(char *)lParam1;  /* for debugging break point */
      memset(stateinfo, 0, 0x60);
    }
    return (0x60);

    case ICM_SETSTATE:
	_SlibDebug(_VERBOSE_, ScDebugPrintf("------ICM_SETSTATE::\n") );
    if ((LPVOID)lParam1!=NULL) /* getting state size */
    {
      char *stateinfo=(char *)lParam1; /* for debugging break point */
      int i=0;
      i=i+1;
    }
    if (info->dwRTP==EC_RTP_MODE_OFF) /* must be NetMeeting, turn on RTP */
      info->dwRTP=EC_RTP_MODE_A;
    return (0x60);

    case ICM_GETINFO:
	_SlibDebug(_VERBOSE_, ScDebugPrintf("------ICM_GETINFO::\n") );
	icinfo = (ICINFO FAR *)lParam1;
	if (icinfo == NULL)
	    return sizeof(ICINFO);

	if ((DWORD)lParam2 < sizeof(ICINFO))
	    return 0;
	ret = ICH263GetInfo(info, icinfo, (DWORD)lParam2);

	UNLOCK;
	return ret;

    case ICM_GETDEFAULTQUALITY:
	_SlibDebug(_VERBOSE_, ScDebugPrintf("------ICM_GETDEFAULTQUALITY::\n") );
	CHECKANDLOCK(DWORD);
	ret = ICH263GetDefaultQuality(info, (DWORD *)lParam1);
	UNLOCK;
	return ret;

    case ICM_GETQUALITY:
	_SlibDebug(_VERBOSE_, ScDebugPrintf("------ICM_GETQUALITY::\n") );
	CHECKANDLOCK(DWORD);
	ret = ICH263GetQuality(info, (DWORD *)lParam1);
	UNLOCK;
	return ret;

	case ICM_SETQUALITY:
	_SlibDebug(_VERBOSE_, ScDebugPrintf("------ICM_SETQUALITY::\n") );
	CHECKANDLOCK(DWORD);
	ret = ICH263SetQuality(info, (DWORD)lParam1);
	UNLOCK;
	return ret;

    case ICM_GETDEFAULTKEYFRAMERATE:
	_SlibDebug(_VERBOSE_, ScDebugPrintf("------ICM_GETDEFAULTKEYFRAMERATE:::\n") );
	return ((unsigned int)ICERR_UNSUPPORTED);


    case DECH26X_CUSTOM_ENCODER_CONTROL:
	_SlibDebug(_VERBOSE_, ScDebugPrintf("------DECH26X_CUSTOM_ENCODER_CONTROL:::\n") );
    return(ICH263CustomEncoder(info, (DWORD)lParam2, (DWORD)lParam2));
	

	/*********************************************************************

	  compression messages

    *********************************************************************/

    case ICM_COMPRESS_QUERY:
	_SlibDebug(_DEBUG_, ScDebugPrintf("------ICM_COMPRESS_QUERY::\n") );
	if ((lpbiIn = (LPBITMAPINFOHEADER)lParam1) == NULL)
	    return ((unsigned int)ICERR_BADPARAM);
	lpbiOut = (LPBITMAPINFOHEADER)lParam2;
    _SlibDebug(_DEBUG_, ScDebugPrintf(" lpbiIn: %s\n", BMHtoString(lpbiIn)) );
    _SlibDebug(_DEBUG_, ScDebugPrintf(" lpbiOut: %s\n", BMHtoString(lpbiOut)) );

	/* Lock the memory - have to lock the structure first, and iff
	* that works, lock the rest
	*/
	biSizeIn = lpbiIn->biSize;
	if (lpbiOut)
	    biSizeOut = lpbiOut->biSize;
	if ((biSizeIn != sizeof(BITMAPINFOHEADER))
	||  (lpbiOut && biSizeOut != sizeof(BITMAPINFOHEADER))) {
	    UNLOCK;
	    if ((biSizeIn < sizeof(BITMAPINFOHEADER))
	    ||  (lpbiOut && (biSizeOut < sizeof(BITMAPINFOHEADER))))
		return ((unsigned int)ICERR_BADPARAM);
	}

	ret = ICH263CompressQuery(info, lpbiIn, lpbiOut);

	UNLOCK;
	return ret;

    case ICM_COMPRESS_BEGIN:
	_SlibDebug(_VERBOSE_, ScDebugPrintf("------ICM_COMPRESS_BEGIN::\n") );
	lpbiIn = (LPBITMAPINFOHEADER)lParam1;
	lpbiOut = (LPBITMAPINFOHEADER)lParam2;
    _SlibDebug(_VERBOSE_, ScDebugPrintf(" lpbiIn: %s\n", BMHtoString(lpbiIn)) );
    _SlibDebug(_VERBOSE_, ScDebugPrintf(" lpbiOut: %s\n", BMHtoString(lpbiOut)) );
	if (lpbiIn == NULL || lpbiOut  == NULL)
	   return ((unsigned int)ICERR_BADPARAM);

	/* Lock the memory - have to lock the structure first, and iff
	* that works, lock the rest
	*/
	biSizeIn = lpbiIn->biSize;
	biSizeOut = lpbiOut->biSize;
	if (biSizeIn != sizeof(BITMAPINFOHEADER) ||
	    biSizeOut != sizeof(BITMAPINFOHEADER))
	{
      _SlibDebug(_VERBOSE_,
	 	ScDebugPrintf("biSizeIn or biSizeOut > sizeof(BITMAPINFOHEADER)\n") );
	  UNLOCK;
	  if ((biSizeIn < sizeof(BITMAPINFOHEADER))
	    ||  (biSizeOut < sizeof(BITMAPINFOHEADER)))
		return ((unsigned int)ICERR_BADPARAM);
	}

	ret = ICH263CompressBegin(info, lpbiIn, lpbiOut);
	UNLOCK;
	_SlibDebug(_VERBOSE_, ScDebugPrintf("------ICM_COMPRESS_BEGIN:: Done\n") );
	return ret;

    case ICM_COMPRESS_GET_FORMAT:
	_SlibDebug(_DEBUG_, ScDebugPrintf("------ICM_COMPRESS_GET_FORMAT::\n") );
	/* Nobody uses lpbiIn in this function.  Don't lock anything,
	* the lower layers will have to do any necessary locking.
	*/
	return ICH263CompressGetFormat(info,
				       (LPBITMAPINFOHEADER)lParam1,
				       (LPBITMAPINFOHEADER)lParam2);

    case ICM_COMPRESS_GET_SIZE:
	_SlibDebug(_VERBOSE_, ScDebugPrintf("------ICM_COMPRESS_GET_SIZE::\n") );
	lpbiIn = (LPBITMAPINFOHEADER)lParam1;
	lpbiOut = (LPBITMAPINFOHEADER)lParam2;
    return(ICH263CompressGetSize(lpbiIn));

    case ICM_COMPRESS:
	_SlibDebug(_DEBUG_, ScDebugPrintf("------ICM_COMPRESS::\n") );
	ret = ICH263Compress(info, (ICCOMPRESS *) lParam1, (DWORD)lParam2);
	return ret;

    case ICM_COMPRESS_END:
    _SlibDebug(_VERBOSE_, ScDebugPrintf("------ICM_COMPRESS_END::\n") );
	return ICH263CompressEnd(info);
     /*********************************************************************

	  decompress messages

	 *********************************************************************/

    case ICM_DECOMPRESS_GET_FORMAT:
	_SlibDebug(_VERBOSE_, ScDebugPrintf("------ICM_DECOMPRESS_GET_FORMAT::\n") );
	/* Nobody uses lpbiIn in this function.  Don't lock anything,
	* the lower layers will have to do any necessary locking.
	*/
	return ICH263DecompressGetFormat(info,
					     (LPBITMAPINFOHEADER)lParam1,
					     (LPBITMAPINFOHEADER)lParam2);

    case ICM_DECOMPRESS_GET_PALETTE:
	_SlibDebug(_VERBOSE_, ScDebugPrintf("------ICM_DECOMPRESS_GET_PALETTE::\n") );
	if ((lpbiIn = (LPBITMAPINFOHEADER)lParam1) == NULL)
	    return ((unsigned int)ICERR_BADPARAM);
	if ((biSizeIn = lpbiIn->biSize) != sizeof(BITMAPINFOHEADER)) {
	    UNLOCK;
	    if (biSizeIn < sizeof(BITMAPINFOHEADER))
		return (unsigned int)ICERR_BADPARAM;
	}

	/*ret = ICH263DecompressGetPalette(info,
					 (LPBITMAPINFOHEADER)lParam1,
					 (LPBITMAPINFOHEADER)lParam2);
	*/
    ret = (MMRESULT)ICERR_BADPARAM;
	UNLOCK;
	return ret;

    case ICM_DECOMPRESS_SET_PALETTE:
	_SlibDebug(_VERBOSE_, ScDebugPrintf("------ICM_DECOMPRESS_SET_PALETTE::\n") );
    return ((unsigned int)ICERR_UNSUPPORTED);

    case ICM_DECOMPRESS_QUERY:
	_SlibDebug(_VERBOSE_, ScDebugPrintf("------ICM_DECOMPRESS_QUERY::\n") );
	if ((lpbiIn = (LPBITMAPINFOHEADER)lParam1) == NULL)
	    return ((unsigned int)ICERR_BADPARAM);
	lpbiOut = (LPBITMAPINFOHEADER)lParam2;
    _SlibDebug(_VERBOSE_, ScDebugPrintf(" lpbiIn: %s\n", BMHtoString(lpbiIn)) );
    _SlibDebug(_VERBOSE_, ScDebugPrintf(" lpbiOut: %s\n", BMHtoString(lpbiOut)) );
	/* Lock the memory - have to lock the structure first, and iff
	* that works, lock the rest
	*/
	biSizeIn = lpbiIn->biSize;
	if (lpbiOut)
	    biSizeOut = lpbiOut->biSize;
	if ((biSizeIn != sizeof(BITMAPINFOHEADER))
	||  (lpbiOut && biSizeOut != sizeof(BITMAPINFOHEADER))) {
	    UNLOCK;

	    if ((biSizeIn < sizeof(BITMAPINFOHEADER))
	    ||  (lpbiOut && (biSizeOut < sizeof(BITMAPINFOHEADER))))
		return (unsigned int)ICERR_BADPARAM;
	}

	ret = ICH263DecompressQuery(info, lpbiIn, lpbiOut);

	UNLOCK;
	return ret;

    case ICM_DECOMPRESS_BEGIN:
	_SlibDebug(_VERBOSE_, ScDebugPrintf("------ICM_DECOMPRESS_BEGIN::\n") );
	if (((lpbiIn = (LPBITMAPINFOHEADER)lParam1) == NULL)
	||  ((lpbiOut = (LPBITMAPINFOHEADER)lParam2) == NULL))
	    return ((unsigned int)ICERR_BADPARAM);
	/* Lock the memory - have to lock the structure first, and iff
	* that works, lock the rest
	*/
	biSizeIn = lpbiIn->biSize;
	biSizeOut = lpbiOut->biSize;
	if ((biSizeIn != sizeof(BITMAPINFOHEADER))
	||  (biSizeOut != sizeof(BITMAPINFOHEADER))) {
	    UNLOCK;
	    if ((biSizeIn < sizeof(BITMAPINFOHEADER))
	    ||  (biSizeOut < sizeof(BITMAPINFOHEADER)))
		return ((unsigned int)ICERR_BADPARAM);
	}

	ret = ICH263DecompressBegin(info, lpbiIn, lpbiOut);
	UNLOCK;
	return ret;

    case ICM_DECOMPRESS:
	_SlibDebug(_DEBUG_, ScDebugPrintf("------ICM_DECOMPRESS::\n") );
	icDecompress = (ICDECOMPRESS *)(void *)lParam1;
    if ((void *)lParam1==NULL && (void *)lParam2==NULL)
      return (unsigned int)ICERR_BADPARAM;
	ret = ICH263Decompress(info, (ICDECOMPRESS *) lParam1, (DWORD)lParam2);
	return ret;

    case ICM_DECOMPRESS_END:
	_SlibDebug(_VERBOSE_, ScDebugPrintf("------ICM_DECOMPRESS_END::\n") );
    ret = ICH263DecompressEnd(info);
	return ret;

    case ICM_COMPRESS_FRAMES_INFO:
	_SlibDebug(_VERBOSE_, ScDebugPrintf("------ICM_COMPRESS_FRAMES_INFO\n") );
    if ((LPVOID)lParam1==NULL ||
		lParam2<sizeof(ICCOMPRESSFRAMES))
		return (unsigned int)ICERR_BADPARAM;
    {
      ICCOMPRESSFRAMES *cf=(ICCOMPRESSFRAMES*)lParam1;
      _SlibDebug(_VERBOSE_,
		 ScDebugPrintf("Start=%ld, Count=%ld, Quality=%ld, DataRate=%ld (%5.1f Kb/s), KeyRate=%ld, FPS=%4.1f\n",
		  cf->lStartFrame,cf->lFrameCount,cf->lQuality,
		  cf->lDataRate, cf->lDataRate*8.0/1000, cf->lKeyRate, cf->dwRate*1.0/cf->dwScale) );
      /* info->dwBitrate=cf->lDataRate*8; */
      info->dwQuality=cf->lQuality;
      /* info->fFrameRate=(float)(cf->dwRate*1.0/cf->dwScale); */
    }
	return (unsigned int)ICERR_OK;
}
_SlibDebug(_VERBOSE_,
		ScDebugPrintf("ICH263Message(DriverID=%p, message=%d, lParam1=%p,lParam1=%p, info=%p) Unsupported\n",
             driverHandle, uiMessage, lParam1, lParam2, info) );
return ((unsigned int)ICERR_UNSUPPORTED);
}

/*
**++
**  FUNCTIONAL_NAME:            DriverProc
**
**  FUNCTIONAL_DESCRIPTION:
**      main and only entry point for the server into this driver
**
**  FORMAL PARAMETERS:
**      client pointer
**      driverHandle, returned by us on a DRV_OPEN message
**      driverID allocated and passed by the server
**      message to handle
**      parameters
**
**  RETURN VALUE:
**
**  COMMENTS:
**
**  DESIGN:
**
**/

#define DLLEXPORT	

MMRESULT DLLEXPORT APIENTRY
DriverProc(
        DWORD_PTR       dwDriverID,
        HDRVR	        hDriver,
        UINT            message,
        LPARAM          lParam1,
        LPARAM          lParam2
)

{
  MMRESULT ret = DRV_OK;
  BOOL notfound = FALSE;
  H26XINFO *info = NULL;
  void     *client = 0;  /* Dummy client pointer for other calls. */
  /*
   * On NT, use __try {} __except() {} to catch
   * error conditions.
   */
#ifdef HANDLE_EXCEPTIONS
 __try { /* try..except */
  __try { /* try..finally */
#endif
    /*
     * Protect threads from interfering with each other.
     * To protect against a crash at shutdown, make sure
     * that the critical section has not been deleted.
     */
  if( h263CritSect.DebugInfo )
      EnterCriticalSection( &h263CritSect ) ;
  _SlibDebug(_DEBUG_,
	  ScDebugPrintf("DriverProc(DriverID=%p,hDriver=%p,message=%d,lParam1=%p,lParam2=%p)\n",
           dwDriverID, hDriver, message, lParam1, lParam2) );
	

  switch (message) {
    case DRV_LOAD:
        ret = DRV_OK;
	    _SlibDebug(_VERBOSE_, ScDebugPrintf("------DRV_LOAD returns %d\n", ret) );
        break;

    case DRV_ENABLE:
	    ret = 0;
	    _SlibDebug(_VERBOSE_, ScDebugPrintf("------DRV_ENABLE returns %d\n", ret) );
        break;

    case DRV_DISABLE:
        ret = DRV_OK;
	    _SlibDebug(_VERBOSE_, ScDebugPrintf("------DRV_DISABLE returns %d\n", ret) );
        break;

    case DRV_FREE:
        ret = DRV_OK;
	    _SlibDebug(_VERBOSE_, ScDebugPrintf("------DRV_FREE returns %d\n", ret) );
        break;

    case DRV_OPEN:
	    /* If lParam2 is NULL, then the app is trying to do a CONFIGURE.
         * Return BOGUS_DRIVER_ID, since we don't support CONFIGURE.
	     */
	    if( lParam2 == (LONG_PTR) NULL )
	    	ret = (MMRESULT)BOGUS_DRIVER_ID;
	    else /* lParam2 is an ICOPEN structure, let's really open */
	        ret = (MMRESULT)((ULONG_PTR)ICH263Open((void *) lParam2));
	    _SlibDebug(_VERBOSE_, ScDebugPrintf("------DRV_OPEN returns %d\n", ret) );
	    break;

	case DRV_CLOSE:
	    _SlibDebug(_VERBOSE_,
			ScDebugPrintf("------DRV_CLOSE. client %d DriverID %p\n",
                 client, dwDriverID) );
        ret = 0 ;
        if ((INT_PTR)dwDriverID != BOGUS_DRIVER_ID)
        {
          info = IChic2info((HIC)dwDriverID);
          if (info)
	    	ICH263Close(info, FALSE);
          else
            ret = ((unsigned int)ICERR_BADHANDLE);
        }
		break;

    case DRV_QUERYCONFIGURE:
	    /*
	     * this is a GLOBAL query configure
	     */
	    ret = ICH263QueryConfigure(info);
		break;

    case DRV_CONFIGURE:
	    /*
	     * this is a GLOBAL configure ('cause we don't get a configure
	     * for each of our procs, we must have just one configure)
	     */

	    ret = ICH263Configure(info);
		break;

    case DRV_INSTALL:
    case DRV_REMOVE:
    case DRV_EXITSESSION:
        break;

    default:
        info = IChic2info((HIC)dwDriverID);
        if (info)
	      ret = ICH263Message(dwDriverID,
                              message,
                              lParam1,
                              lParam2,
                              info ) ;
        else
	      ret = ((unsigned int)ICERR_BADHANDLE) ;
   }

#ifdef HANDLE_EXCEPTIONS
} __finally {
#endif /* HANDLE_EXCEPTIONS */
    /*
     * Leave the critical section, so we don't
     * deadlock.
     */
  if( h263CritSect.DebugInfo )
      LeaveCriticalSection( &h263CritSect );
#ifdef HANDLE_EXCEPTIONS
} /* try..finally */
} __except(EXCEPTION_EXECUTE_HANDLER) {
 /*
  * NT exception handler. If anything went
  * wrong in the __try {} section, we will
  * end up here.
  */
#if defined(EXCEPTION_MESSAGES) && defined(H263_SUPPORT)
    // MessageBox(NULL, "Exception in H263 DriverProc", "Warning", MB_OK);
#elif defined(EXCEPTION_MESSAGES)
    // MessageBox(NULL, "Exception in H261 DriverProc", "Warning", MB_OK);
#endif
    /*
     * Return an error code.
     */
    return((MMRESULT)ICERR_INTERNAL);
} /* try..except */
#endif /* HANDLE_EXCEPTIONS */
  _SlibDebug(_DEBUG_||_VERBOSE_, ScDebugPrintf("return is %d\n", ret) );
  return ret;
}


/*
 * Dummy DriverPostReply routine, it does nothing.
 * It should never be called on NT.
 */

DriverPostReply(void *client,
		DWORD ret,
		DWORD arg )
{
    return 0;
}

#ifndef INITCRT
#define INITCRT
#endif
#ifdef INITCRT
BOOL WINAPI     _CRT_INIT(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved);
#endif

/*
 * This DllEntryPoint is needed on NT in order for
 * an application to connect to a dll properly.
 */

DLLEXPORT BOOL WINAPI
DllEntryPoint(
	      HINSTANCE hinstDLL,
	      DWORD fdwReason,
	      LPVOID lpReserved)
{

    switch (fdwReason) {
    case DLL_PROCESS_ATTACH:

      /*
       * We're being loaded - save our handle in a global.
       */

      ghModule = (HMODULE) hinstDLL;

      /*
       * Initialize the Critical Section that we use
       * to ensure Threads don't stomp on each other.
       */

      InitializeCriticalSection( &h263CritSect ) ;

      /*
       * A Process is also a thread, so deliberately
       * fall into DLL_THREAD_ATTACH.
       */

    case DLL_THREAD_ATTACH:

      /*
       * A Thread have been created that may
       * be calling this DLL.
       * Initialize the C run_time library.
       */

#ifdef INITCRT

      if( !_CRT_INIT( hinstDLL, fdwReason, lpReserved ) )
	return FALSE ;

#endif /* INITCRT */

      break;

    case DLL_PROCESS_DETACH:

      /*
       * We are shutting down. Perform some cleanup
       * so that lingering threads won't try to work
       * and maybe access violate.
       */

      TerminateH263() ;

      /*
       * Delete the Critical Section that we created
       * at load time.
       */

      DeleteCriticalSection( &h263CritSect ) ;

      /*
       * A Process is also a thread so deliberately
       * fall through to DLL_THREAD_DETACH.
       */

    case DLL_THREAD_DETACH:

      /*
       * Close down the C run-time library.
       */

#ifdef INITCRT

      if( !_CRT_INIT( hinstDLL, fdwReason, lpReserved ) )
	return FALSE ;

#endif /* INITCRT */

      break;
    }

    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech261\h263.h ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: h263.h,v $
 * $EndLog$
 */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

#ifndef _H263_H_
#define _H263_H_

/************** H263 parsing definitions **************/
#define H263_PSC                             1
#define H263_PSC_LENGTH                      17

#define H263_MODE_INTER                      0
#define H263_MODE_INTER_Q                    1
#define H263_MODE_INTER4V                    2
#define H263_MODE_INTRA                      3
#define H263_MODE_INTRA_Q                    4

#define H263_PBMODE_NORMAL                   0
#define H263_PBMODE_MVDB                     1
#define H263_PBMODE_CBPB_MVDB                2

#define H263_ESCAPE                          7167

#define H263_PCT_INTER                       1
#define H263_PCT_INTRA                       0

#define H263_SF_SQCIF                        1  /* 001 */
#define H263_SF_QCIF                         2  /* 010 */
#define H263_SF_CIF                          3  /* 011 */
#define H263_SF_4CIF                         4  /* 100 */
#define H263_SF_16CIF                        5  /* 101 */

/* From sim.h */
#define H263_SE_CODE                         31
#define H263_ESCAPE_INDEX                    102

#endif /* _H263_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech261\h261.h ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: h261.h,v $
 * Revision 1.1.2.2  1995/11/06  18:47:40  Hans_Graves
 * 	First time under SLIB
 * 	[1995/11/06  18:34:27  Hans_Graves]
 *
 * $EndLog$
 */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

#ifndef _H261_H_
#define _H261_H_

/************** MPEG 1 parsing definitions **************/
#define H261_START_CODE              0x0001
#define H261_START_CODE_LEN          16
#define H261_GOB_START_CODE          0x0001
#define H261_GOB_START_CODE_LEN      16

#define H261_PICTURE_START_CODE      0x00010
#define H261_PICTURE_START_CODE_LEN  20

#endif _H261_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech261\h26x.c ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: h263.c,v $
 * $EndLog$
 */
/*
**++
** FACILITY:  Workstation Multimedia  (WMM)  v1.0
**
** FILE NAME:   h263.c
** MODULE NAME: h263.c
**
** MODULE DESCRIPTION:
**    H.263ICM driver
**
**    Microsoft file I/O functions
**	Implemented as functions:
**	H263Close
**	H263Compress
**	H263Decompress
**	H263DecompressEnd
**	H263DecompressGetPalette
**	H263DecompressGetSize
**	H263DecompressQuery
**	H263GetInfo
**	H263Info
**	H263Locate
**	H263Open
**	H263SendMessage
**
**    Private functions:
**
** DESIGN OVERVIEW:
**
**--
*/
/*-------------------------------------------------------------------------
**  Modification History: sc_mem.c
**      04-15-97  HWG          Added debug statements to help with checking
**                               for memory leaks
--------------------------------------------------------------------------*/

#include <stdlib.h>
#include <windows.h>
#include <mmsystem.h>
#include "h26x_int.h"

#ifdef _SLIBDEBUG_
#define _DEBUG_     0  /* detailed debuging statements */
#define _VERBOSE_   1  /* show progress */
#define _VERIFY_    1  /* verify correct operation */
#define _WARN_      1  /* warnings about strange behavior */
#define _MEMORY_    0  /* memory debugging */

dword scMemDump();
#endif


/* For shared mem */
static H26XINFO    *pValidHandles = NULL;
static int          NextH263Hic = 1;
static int          OpenCount = 0;
static HANDLE       InfoMutex = NULL;

#define InitInfoMutex()  if (InfoMutex==NULL) InfoMutex=CreateMutex(NULL, FALSE, NULL)
#define FreeInfoMutex()  if (InfoMutex!=NULL) \
                               CloseHandle(InfoMutex); InfoMutex=NULL
#define LockInfo()      WaitForSingleObject(InfoMutex, 5000);
#define ReleaseInfo()   ReleaseMutex(InfoMutex)

/*
 * Macros
 */
#define _ICH263CheckFlags(info, flag) ((info->openFlags & flag) ? TRUE : FALSE)
#define FREE_AND_CLEAR(s)      if (s) {ScFree(s); (s)=NULL;}
#define FREE_AND_CLEAR_PA(s)   if (s) {ScPaFree(s); (s)=NULL;}

/*
 *   Default LPBI format
 */
static BITMAPINFOHEADER __defaultDecompresslpbiOut =
{
   sizeof(BITMAPINFOHEADER),		// DWORD  biSize;
   0,					// LONG   biWidth;
   0, 					// LONG   biHeight;
   1,					// WORD   biPlanes;
   24,					// WORD   biBitCount
   BI_RGB,				// DWORD  biCompression;
   0,					// DWORD  biSizeImage;
   0,					// LONG   biXPelsPerMeter;
   0,					// LONG   biYPelsPerMeter;
   0,					// DWORD  biClrUsed;
   0					// DWORD  biClrImportant;
};

static BITMAPINFOHEADER __defaultCompresslpbiOut =
{
   sizeof(BITMAPINFOHEADER),		// DWORD  biSize;
   0,					// LONG   biWidth;
   0, 					// LONG   biHeight;
   1,					// WORD   biPlanes;
   24,					// WORD   biBitCount
#ifdef H261_SUPPORT
   VIDEO_FORMAT_DIGITAL_H261, // DWORD  biCompression;
#else
   VIDEO_FORMAT_DIGITAL_H263, // DWORD  biCompression;
#endif
   0,					// DWORD  biSizeImage;
   0,					// LONG   biXPelsPerMeter;
   0,					// LONG   biYPelsPerMeter;
   0,					// DWORD  biClrUsed;
   0					// DWORD  biClrImportant;
};

typedef struct SupportList_s {
  int   InFormat;   /* Input format */
  int   InBits;     /* Input number of bits */
  int   OutFormat;  /* Output format */
  int   OutBits;    /* Output number of bits */
} SupportList_t;

/*
** Input & Output Formats supported by H.261 Compression
*/
static SupportList_t _ICCompressionSupport[] = {
  BI_DECYUVDIB,        16, H26X_FOURCC,   24, /* YUV 4:2:2 Packed */
  BI_YUY2,             16, H26X_FOURCC,   24, /* YUV 4:2:2 Packed */
  BI_YU12SEP,          24, H26X_FOURCC,   24, /* YUV 4:1:1 Planar */
  BI_YVU9SEP,          24, H26X_FOURCC,   24, /* YUV 16:1:1 Planar */
  BI_RGB,              16, H26X_FOURCC,   24, /* RGB 16 */
  BI_RGB,              24, H26X_FOURCC,   24, /* RGB 24 */
  0, 0, 0, 0
};

/*
** Input & Output Formats supported by H.261 Decompression
*/
static SupportList_t _ICDecompressionSupport[] = {
  H26X_FOURCC,   24, BI_DECYUVDIB,        16, /* YUV 4:2:2 Packed */
  H26X_FOURCC,   24, BI_YUY2,             16, /* YUV 4:2:2 Packed */
  H26X_FOURCC,   24, BI_YU12SEP,          24, /* YUV 4:1:1 Planar */
  H26X_FOURCC,   24, BI_YVU9SEP,          24, /* YUV 16:1:1 Planar */
  H26X_FOURCC,   24, BI_BITFIELDS,        32, /* BITFIELDS */
  H26X_FOURCC,   24, BI_RGB,              16, /* RGB 16 */
  H26X_FOURCC,   24, BI_RGB,              24, /* RGB 24 */
  H26X_FOURCC,   24, BI_RGB,              32, /* RGB 32 */
  H26X_FOURCC,   24, BI_RGB,              8,  /* RGB 8 */
  0, 0, 0, 0
};


/*
** Name: IsSupported
** Desc: Lookup the a given input and output format to see if it
**       exists in a SupportList.
** Note: If OutFormat==-1 and OutBits==-1 then only input format
**          is checked for support.
**       If InFormat==-1 and InBits==-1 then only output format
**          is checked for support.
** Return: NULL       Formats not supported.
**         not NULL   A pointer to the list entry.
*/
static SupportList_t *IsSupported(SupportList_t *list,
                                  int InFormat, int InBits,
                                  int OutFormat, int OutBits)
{
  if (OutFormat==-1 && OutBits==-1) /* Looking up only the Input format */
  {
    while (list->InFormat || list->InBits)
      if (list->InFormat == InFormat && list->InBits==InBits)
        return(list);
      else
        list++;
    return(NULL);
  }
  if (InFormat==-1 && InBits==-1) /* Looking up only the Output format */
  {
    while (list->InFormat || list->InBits)
      if (list->OutFormat == OutFormat && list->OutBits==OutBits)
        return(list);
      else
        list++;
    return(NULL);
  }
  /* Looking up both Input and Output */
  while (list->InFormat || list->InBits)
    if (list->InFormat == InFormat && list->InBits==InBits &&
         list->OutFormat == OutFormat && list->OutBits==OutBits)
        return(list);
    else
      list++;
  return(NULL);
}

unsigned int CalcImageSize(unsigned int fourcc, int w, int h, int bits)
{
  if (h<0) h=-h;
  if (IsYUV411Sep(fourcc))
    return((w * h * 3) / 2);
  else if (IsYUV422Sep(fourcc) || IsYUV422Packed(fourcc))
    return(w * h * 2);
  else if (IsYUV1611Sep(fourcc))
    return((w * h * 9) / 8);
#ifdef BICOMP_DECXIMAGEDIB
  else if (fourcc==BICOMP_DECXIMAGEDIB)
    return(bits<=8 ? w * h : (w * h * 4));
#endif
  else /* RGB */
    return(w * h * (bits+7)/8);
}

/*
**++
**  FUNCTIONAL_NAME: InitBitmapinfo
**
**  FUNCTIONAL_DESCRIPTION:
**	Allocate and copy our local copies of the input and output
**      BITMAPINFOHEADERs
**
**  FORMAL PARAMETERS:
**	info        pointer to the driver handle
**      lpbiIn      pointer to the input BITMAPINFOHEADER
**      lpbiOut     pointer to the output BITMAPINFOHEADER
**
**  RETURN VALUE:
**
**      ICERR_OK        Success
**      ICERR_MEMORY    Malloc failed
**
**  COMMENTS:
**
**  DESIGN:
**
**/

static MMRESULT InitBitmapinfo(H26XINFO *info,
			       LPBITMAPINFOHEADER lpbiIn,
			       LPBITMAPINFOHEADER lpbiOut)
{
    _SlibDebug(_DEBUG_,
		ScDebugPrintf("In InitBitmapinfo(), IN: 0x%x, OUT: 0x%x\n", lpbiIn, lpbiOut));

    if (info->lpbiIn == NULL)
    {
        if ((info->lpbiIn = (VOID *)ScAlloc(lpbiIn->biSize)) == NULL)
            return(unsigned int)(ICERR_MEMORY);
    }
    bcopy(lpbiIn, info->lpbiIn, lpbiIn->biSize);

    if (info->lpbiOut == NULL)
    {
        if ((info->lpbiOut = (VOID *)ScAlloc(lpbiOut->biSize)) == NULL)
	    return(unsigned int)(ICERR_MEMORY);
    }
    bcopy(lpbiOut, info->lpbiOut, lpbiOut->biSize);

    _SlibDebug(_DEBUG_, ScDebugPrintf("Out InitBitmapinfo()\n"));
    return(ICERR_OK);
}

/*
**++
**  FUNCTIONAL_NAME: ICclient2info
**
**  FUNCTIONAL_DESCRIPTION:
**	Translate the client pointer to an H26XINFO pointer
**
**  FORMAL PARAMETERS:
**	client  the client ptr to look up
**
**  RETURN VALUE:
**
**      pointer to the H26XINFO structure or NULL
**
**  COMMENTS:
**
**  DESIGN:
**
**/

H26XINFO *ICclient2info(void *client)
{
   return (H26XINFO *) NULL;
}


/*
**++
**  FUNCTIONAL_NAME: IChic2info
**
**  FUNCTIONAL_DESCRIPTION:
**	Translate the HIC integer to an H26XINFO pointer
**
**  FORMAL PARAMETERS:
**	hic     the hic managed by icm.c
**
**  RETURN VALUE:
**
**      pointer to the H26XINFO structure or NULL
**
**  COMMENTS:
**
**  DESIGN:
**
**/

H26XINFO *IChic2info(HIC hic)
{
  H26XINFO *retptr=NULL, *ptr;

  InitInfoMutex();
  LockInfo();

#ifdef HANDLE_EXCEPTIONS
  __try {
    /* pointers go wrong when driver closes */
#endif /* HANDLE_EXCEPTIONS */
  for (ptr = pValidHandles; ptr; ptr=ptr->next)
    if (ptr->hic == hic)
    {
      retptr=ptr;
      break;
    }
#ifdef HANDLE_EXCEPTIONS
  } __finally {
#endif /* HANDLE_EXCEPTIONS */
    ReleaseInfo();
#ifdef HANDLE_EXCEPTIONS
    return(retptr);
  } /* try..except */
#endif /* HANDLE_EXCEPTIONS */
  return(retptr);
}


/*
**++
**  FUNCTIONAL_NAME: ICHandle2hic
**
**  FUNCTIONAL_DESCRIPTION:
**	Translate the SLIB codec handle to an ICM HIC value
**
**  FORMAL PARAMETERS:
**	Sh     SLIB handle returned on the SlibOpen call
**
**  RETURN VALUE:
**
**      hic     the hic managed by icm.c
**
**  COMMENTS:
**
**  DESIGN:
**
**/
HIC ICHandle2hic(SlibHandle_t Sh)
{
    H26XINFO *ptr;

    InitInfoMutex();
    LockInfo();
    for (ptr = pValidHandles; ptr; ptr=ptr->next)
        if (ptr->Sh == Sh)
	    break;
    ReleaseInfo();

    return(ptr->hic);
}


/*
**++
**  FUNCTIONAL_NAME: ICclientGone
**
**  FUNCTIONAL_DESCRIPTION:
**	Sets the clientGone flag in client's H26XINFO
**
**  FORMAL PARAMETERS:
**	client  the client ptr to look up
**
**  RETURN VALUE:
**
**  COMMENTS:
**
**  DESIGN:
**
**/

BOOL ICclientGone(void *client)
{
    H26XINFO    *ptr;

    LockInfo();
    for (ptr = pValidHandles; ptr; ptr = ptr->next) {
        if (ptr->client == client)
	  ptr->clientGone = TRUE;
    }
    ReleaseInfo();
    return(ptr != NULL);
}


/*
**++
**  FUNCTIONAL_NAME: ICH263Open
**
**  FUNCTIONAL_DESCRIPTION:
**	Open the Software CODEC
**
**  FORMAL PARAMETERS:
**	client
**
**  RETURN VALUE:
**      driverHandle
**
**  COMMENTS:
**
**  DESIGN:
**
**/

HIC  ICH263Open(void *client)
{
  H26XINFO    *info;

  ICOPEN *icopen =(ICOPEN *) client;
  DWORD fccType = icopen->fccType;
  UINT  dwFlags = icopen->dwFlags;

  _SlibDebug(_VERBOSE_, ScDebugPrintf("ICH263Open()\n") );

  /*
   * fccType must be 'vidc'
   */
  if (fccType != ICTYPE_VIDEO)
    return(0);

  /*
   * We don't support draw operations.
   */
  if ( dwFlags & ICMODE_DRAW )
    return 0;

  /*
   * We don't support compress and decompress
   * with the same handler.
   */
  if ( (dwFlags & ICMODE_COMPRESS) &&
       (dwFlags & ICMODE_DECOMPRESS) )
    return 0;

  /*
   * At least one of these flags must be set:
   * COMPRESS, DECOMPRESS or QUERY.
   */
  if ( !(dwFlags & ICMODE_COMPRESS) &&
       !(dwFlags & ICMODE_DECOMPRESS) &&
       !(dwFlags & ICMODE_QUERY) )
    return 0;
  info = (H26XINFO *) ScAlloc(sizeof(H26XINFO));
  if (info)
  {
    InitInfoMutex();
    LockInfo();
    OpenCount++;
    bzero(info, sizeof(H26XINFO));
    info->next = pValidHandles;
    pValidHandles = info;
    info->hic = (HANDLE) NextH263Hic++;  /* !!! check for used entry! */
    info->client = client;
    info->fFrameRate=H26X_DEFAULT_FRAMERATE;
    info->dwBitrate=H26X_DEFAULT_BITRATE;
    info->dwPacketSize=H26X_DEFAULT_PACKETSIZE;
    info->dwRTP=H26X_DEFAULT_RTP;

    info->dwQuality=H26X_DEFAULT_QUALITY;
    info->dwMaxQuality=H26X_DEFAULT_QUALITY;
    info->dwQi=H26X_DEFAULT_CIF_QI;
    info->dwQp=H26X_DEFAULT_CIF_QP;
    info->dwMaxQi=H26X_DEFAULT_CIF_QI;
    info->dwMaxQp=H26X_DEFAULT_CIF_QP;

    info->openFlags = dwFlags;
    _SlibDebug(_VERBOSE_, ScDebugPrintf("ICH263Open() info=%p hic=%d\n", info, info->hic) );
    ReleaseInfo();
    return(info->hic);
  }
  else
  {
    _SlibDebug(_VERBOSE_, ScDebugPrintf("ICH263Open() alloc failed\n") );
    return(NULL);
  }
}

/*
**++
**  FUNCTIONAL_NAME: H263Close
**
**  FUNCTIONAL_DESCRIPTION:
**	Close the Software CODEC
**
**  FORMAL PARAMETERS:
**	driverID
**
**  RETURN VALUE:
**
**  COMMENTS:
**	Does it's own post reply.
**
**  DESIGN:
**
**/

void ICH263Close(H26XINFO *info, BOOL postreply)
{
    H26XINFO *ptr;
    int status;

    _SlibDebug(_VERBOSE_, ScDebugPrintf("ICH263Close() In: info=%p\n", info) );
    if (info==NULL)
      return;
    if (info->Sh)
    {
      _SlibDebug(_VERBOSE_, ScDebugPrintf("SlibClose()\n") );
      status=SlibClose(info->Sh);
      info->Sh = NULL;
      _SlibDebug(_VERBOSE_, ScDebugPrintf("SlibMemUsed = %ld (after SlibClose)\n", SlibMemUsed()) );
    }

    _SlibDebug(_VERBOSE_, ScDebugPrintf("Freeing memory\n") );
    FREE_AND_CLEAR(info->lpbiIn);
    FREE_AND_CLEAR(info->lpbiOut);
    LockInfo();
    if (pValidHandles == info)
        pValidHandles = info->next;
    else
    {
      for (ptr = pValidHandles; ptr && ptr->next; ptr = ptr->next)
        if (ptr->next == info) /* found info, remove from linked list */
        {
          ptr->next = info->next;
          break;
        }
    }
    OpenCount--;
    if (pValidHandles==NULL) /* all instances closed, reset driver ID */
    {
      NextH263Hic=1;
      ReleaseInfo();
      FreeInfoMutex();
    }
    else
    {
      ptr = pValidHandles;
      ReleaseInfo();
    }
    _SlibDebug(_VERBOSE_, ScDebugPrintf("DriverPostReply\n") );
    if (postreply &&  !info->clientGone)
    {
      _SlibDebug(_VERBOSE_, ScDebugPrintf("DriverPostReply\n") );
      DriverPostReply(info->client, ICERR_OK, 0);
    }
    ScFree(info);
    _SlibDebug(_MEMORY_, scMemDump() );
    _SlibDebug(_VERBOSE_, ScDebugPrintf("ICH263Close() Out\n") );
}


/*
**++
**  FUNCTIONAL_NAME: ICH263QueryConfigure
**
**  FUNCTIONAL_DESCRIPTION:
**	We don't do configure.  Say so.
**
**  FORMAL PARAMETERS:
**	Handle
**
**  RETURN VALUE:
**
**  COMMENTS:
**
**  DESIGN:
**
**/

BOOL     ICH263QueryConfigure(H26XINFO *info)
{
    return(FALSE);
}


/*
**++
**  FUNCTIONAL_NAME: ICH263Configure
**
**  FUNCTIONAL_DESCRIPTION:
**	Unsupported function
**
**  FORMAL PARAMETERS:
**	driverID
**
**  RETURN VALUE:
**
**  COMMENTS:
**
**  DESIGN:
**
**/

MMRESULT ICH263Configure(H26XINFO *info)
{
    return(MMRESULT)(ICERR_UNSUPPORTED);
}

MMRESULT ICH263CustomEncoder(H26XINFO *info, DWORD param1, DWORD param2)
{
  SlibHandle_t Sh;
  SlibStream_t stream=SLIB_STREAM_ALL;
  WORD task=HIWORD(param1);
  WORD control=LOWORD(param1);
  Sh = info->Sh;
  if (task==EC_SET_CURRENT)
  {
    switch (control)
    {
	  case EC_RTP_HEADER: /* Turn on/off RTP */
        info->dwRTP=param2;
        switch (info->dwRTP)
        {
          case EC_RTP_MODE_OFF:
		    SlibSetParamInt (Sh, stream, SLIB_PARAM_FORMATEXT, 0);
            break;
          default:
          case EC_RTP_MODE_A:
		    SlibSetParamInt (Sh, stream, SLIB_PARAM_FORMATEXT, PARAM_FORMATEXT_RTPA);
            break;
          case EC_RTP_MODE_B:
		    SlibSetParamInt (Sh, stream, SLIB_PARAM_FORMATEXT, PARAM_FORMATEXT_RTPB);
            break;
          case EC_RTP_MODE_C:
		    SlibSetParamInt (Sh, stream, SLIB_PARAM_FORMATEXT, PARAM_FORMATEXT_RTPC);
            break;
        }
		return (ICERR_OK);
	  case EC_PACKET_SIZE: /* Set Packet Size */
        info->dwPacketSize=param2;
 		SlibSetParamInt (Sh, stream, SLIB_PARAM_PACKETSIZE, info->dwPacketSize);
		return (ICERR_OK);
      case EC_BITRATE: /* Set Bitrate */
        info->dwBitrate=param2;
		SlibSetParamInt (Sh, stream, SLIB_PARAM_BITRATE, info->dwBitrate);
		return (ICERR_OK);
      case EC_BITRATE_CONTROL: /* Turn constant bitrate on/off */
        if (param2==0)
          info->dwBitrate=0;
        else if (info->dwBitrate)
          info->dwBitrate=H26X_DEFAULT_BITRATE;
		SlibSetParamInt (Sh, stream, SLIB_PARAM_BITRATE, info->dwBitrate);
		return (ICERR_OK);
    }
  }
  else if (task==EC_GET_CURRENT)
  {
    DWORD *pval=(DWORD *)param2;
    if (pval==NULL)
      return((MMRESULT)ICERR_BADPARAM);
    switch (control)
    {
	  case EC_RTP_HEADER:
        *pval=info->dwRTP;
		return (ICERR_OK);
	  case EC_PACKET_SIZE:
        *pval=info->dwPacketSize;
		return (ICERR_OK);
      case EC_BITRATE:
        *pval=info->dwBitrate;
		return (ICERR_OK);
      case EC_BITRATE_CONTROL: /* Turn constant bitrate on/off */
        *pval=info->dwBitrate?1:0;
		return (ICERR_OK);
    }
  }
  else if (task==EC_GET_FACTORY_DEFAULT)
  {
    DWORD *pval=(DWORD *)param2;
    if (pval==NULL)
      return((MMRESULT)ICERR_BADPARAM);
    *pval=0;
    return (ICERR_OK);
  }
  else if (task==EC_GET_FACTORY_LIMITS)
  {
    DWORD *pval=(DWORD *)param2;
    if (pval==NULL)
      return((MMRESULT)ICERR_BADPARAM);
    *pval=0;
    return (ICERR_OK);
  }
  else if (task==EC_RESET_TO_FACTORY_DEFAULTS)
  {
    return (ICERR_OK);
  }
  return((MMRESULT)ICERR_UNSUPPORTED);
}


/*
**++
**  FUNCTIONAL_NAME: ICH263QueryAbout
**
**  FUNCTIONAL_DESCRIPTION:
**	Tell 'em we don't do about
**
**  FORMAL PARAMETERS:
**	driverID
**
**  RETURN VALUE:
**
**  COMMENTS:
**
**  DESIGN:
**
**/

BOOL    ICH263QueryAbout(H26XINFO *info)
{
    return(FALSE);
}

/*
**++
**  FUNCTIONAL_NAME: ICH263About
**
**  FUNCTIONAL_DESCRIPTION:
**	About box
**
**  FORMAL PARAMETERS:
**	driverID
**
**  RETURN VALUE:
**
**  COMMENTS:
**
**  DESIGN:
**
**/

MMRESULT ICH263About (H26XINFO *info)
{
    return(MMRESULT)(ICERR_UNSUPPORTED);
}
/*
**++
**  FUNCTIONAL_NAME: ICH263GetInfo
**
**  FUNCTIONAL_DESCRIPTION:
**	Return info about codec
**
**  FORMAL PARAMETERS:
**	driverID
**
**  RETURN VALUE:
**
**  COMMENTS:
**
**  DESIGN:
**
**/

MMRESULT ICH263GetInfo(H26XINFO *info, ICINFO *icinfo, DWORD dwSize)
{
    _SlibDebug(_VERBOSE_, ScDebugPrintf("In H263GetInfo\n") );

    icinfo->dwSize = sizeof(ICINFO);
    icinfo->fccType = ICTYPE_VIDEO;
    icinfo->fccHandler = H26X_FOURCC;
    icinfo->dwFlags = VIDCF_QUALITY|VIDCF_CRUNCH|VIDCF_TEMPORAL|VIDCF_FASTTEMPORALC;

    icinfo->dwVersion = H26X_VERSION;
    icinfo->dwVersionICM = ICVERSION;

    wcscpy(icinfo->szDescription, H26X_DESCRIPTION);
    wcscpy(icinfo->szName, H26X_NAME);
#if 0
    /* we shouldn't change the szDriver field */
    wcscpy(icinfo->szDriver, _wgetenv(L"SystemRoot"));
    if( icinfo->szDriver[0] != 0 )
        wcscat(icinfo->szDriver, L"\\System32\\" );
    wcscat(icinfo->szDriver, H26X_DRIVER);
#endif
    return (dwSize);
}


/*
**++
**  FUNCTIONAL_NAME: ICH263CompressQuery
**
**  FUNCTIONAL_DESCRIPTION:
**	Determine compression capability
**
**  FORMAL PARAMETERS:
**	driverID
**      lpbiIn          input BITMAPINFOHEADER
**      lpbiOut         output BITMAPINFOHEADER
**
**  RETURN VALUE:
**
**  COMMENTS:
**
**  DESIGN:
**
**/

MMRESULT ICH263CompressQuery(H26XINFO *info,
                             LPBITMAPINFOHEADER lpbiIn,
                             LPBITMAPINFOHEADER lpbiOut)
{
    _SlibDebug(_VERBOSE_, ScDebugPrintf("In ICH263CompressQuery\n") );

    if (
		(!_ICH263CheckFlags(info, ICMODE_QUERY)) &&
		(
		(!_ICH263CheckFlags(info, ICMODE_COMPRESS)) ||
		(!_ICH263CheckFlags(info, ICMODE_FASTCOMPRESS))
		)
	   )
	return (MMRESULT)ICERR_BADHANDLE;

    /*
     * Must query at least an input or an output format
     */
    if (!lpbiIn && !lpbiOut)
      return (MMRESULT)(ICERR_BADPARAM);

    if (!IsSupported(_ICCompressionSupport,
                    lpbiIn ? lpbiIn->biCompression : -1,
                    lpbiIn ? lpbiIn->biBitCount : -1,
                    lpbiOut ? lpbiOut->biCompression : -1,
                    lpbiOut ? lpbiOut->biBitCount : -1))
      return(MMRESULT)(ICERR_BADFORMAT);

    return ICERR_OK;
}


/*
**++
**  FUNCTIONAL_NAME: ICH263CompressBegin
**
**  FUNCTIONAL_DESCRIPTION:
**	Prepare to start a Compression operation
**
**  FORMAL PARAMETERS:
**	driverID
**      lpbiIn          input BITMAPINFOHEADER
**      lpbiOut         output BITMAPINFOHEADER
**
**  RETURN VALUE:
**
**  COMMENTS:
**
**  DESIGN:
**
**/

MMRESULT ICH263CompressBegin(H26XINFO *info,
                             LPBITMAPINFOHEADER lpbiIn,
                             LPBITMAPINFOHEADER lpbiOut)
{
    MMRESULT            status;
    SlibStatus_t        sstatus;
#ifdef H261_SUPPORT
	SlibType_t stype = SLIB_TYPE_H261;
#else
	SlibType_t stype = SLIB_TYPE_H263;
#endif
	SlibHandle_t Sh;

    _SlibDebug(_VERBOSE_, ScDebugPrintf("In ICH263CompressBegin\n") );

    if ((!_ICH263CheckFlags(info, ICMODE_COMPRESS)) || (!_ICH263CheckFlags(info, ICMODE_FASTCOMPRESS)))
      return (MMRESULT)ICERR_BADHANDLE;

    if (!lpbiIn || !lpbiOut)
      return (MMRESULT)(ICERR_BADPARAM);
    if ((status = ICH263CompressQuery(info, lpbiIn, lpbiOut)) != ICERR_OK)
      return status;
    if ((status = InitBitmapinfo(info, lpbiIn, lpbiOut)) != ICERR_OK)
      return status;
    info->bUsesCodec = TRUE;
    lpbiIn=info->lpbiIn;
    lpbiOut=info->lpbiOut;

    lpbiIn->biHeight=-lpbiIn->biHeight; /* SLIB assume first line is top */

    info->dwMaxQuality=H26X_DEFAULT_QUALITY;
    if (lpbiIn->biWidth<168) /* Sub-QCIF */
    {
      info->dwMaxQi=H26X_DEFAULT_SQCIF_QI;
      info->dwMaxQp=H26X_DEFAULT_SQCIF_QP;
    }
    if (lpbiIn->biWidth<300) /* QCIF */
    {
      info->dwMaxQi=H26X_DEFAULT_QCIF_QI;
      info->dwMaxQp=H26X_DEFAULT_QCIF_QP;
    }
    else /* CIF */
    {
      info->dwMaxQi=H26X_DEFAULT_CIF_QI;
      info->dwMaxQp=H26X_DEFAULT_CIF_QP;
    }
    info->lastFrameNum=0;
    info->lastCompBytes=0;
    /* Synchronized SLIB SYSTEMS calls */
    _SlibDebug(_VERBOSE_, ScDebugPrintf("SlibMemUsed = %ld (before SlibOpen)\n", SlibMemUsed()) );
	sstatus = SlibOpenSync (&Sh, SLIB_MODE_COMPRESS, &stype, NULL, 0);
    if (sstatus!=SlibErrorNone) return((MMRESULT)ICERR_BADPARAM);
	SlibSetParamInt(Sh, SLIB_STREAM_MAINVIDEO, SLIB_PARAM_WIDTH, lpbiIn->biWidth);
	SlibSetParamInt(Sh, SLIB_STREAM_MAINVIDEO, SLIB_PARAM_HEIGHT, lpbiIn->biHeight);
#if 0
	SlibSetParamInt(Sh, SLIB_STREAM_MAINVIDEO, SLIB_PARAM_VIDEOFORMAT, lpbiIn->biCompression);
	SlibSetParamInt(Sh, SLIB_STREAM_MAINVIDEO, SLIB_PARAM_VIDEOBITS, lpbiIn->biBitCount);
#else
	SlibSetParamStruct(Sh, SLIB_STREAM_MAINVIDEO, SLIB_PARAM_VIDEOFORMAT, lpbiIn, lpbiIn->biSize);
#endif
//    SlibSetParamInt(Sh, SLIB_STREAM_MAINVIDEO, SLIB_PARAM_VIDEOQUALITY, info->dwQuality/100);
    SlibSetParamInt(Sh, SLIB_STREAM_MAINVIDEO, SLIB_PARAM_QUANTI, info->dwQi);
    SlibSetParamInt(Sh, SLIB_STREAM_MAINVIDEO, SLIB_PARAM_QUANTP, info->dwQp);
    SlibSetParamInt(Sh, SLIB_STREAM_MAINVIDEO, SLIB_PARAM_BITRATE, info->dwBitrate);
    SlibSetParamInt(Sh, SLIB_STREAM_MAINVIDEO, SLIB_PARAM_PACKETSIZE, info->dwPacketSize);
    SlibSetParamInt(Sh, SLIB_STREAM_MAINVIDEO, SLIB_PARAM_ALGFLAGS, H26X_DEFAULT_MODE);
    SlibSetParamInt(Sh, SLIB_STREAM_MAINVIDEO, SLIB_PARAM_KEYSPACING, 132);
#ifdef H261_SUPPORT
    SlibSetParamInt(Sh, SLIB_STREAM_MAINVIDEO, SLIB_PARAM_MOTIONALG, 1);
#else
    SlibSetParamInt(Sh, SLIB_STREAM_MAINVIDEO, SLIB_PARAM_MOTIONALG, 2);
#endif
    SlibSetParamFloat(Sh, SLIB_STREAM_MAINVIDEO, SLIB_PARAM_FPS, info->fFrameRate);
    switch (info->dwRTP)
    {
      case EC_RTP_MODE_OFF:
            break;
      case EC_RTP_MODE_A:
	        SlibSetParamInt(Sh, SLIB_STREAM_ALL, SLIB_PARAM_FORMATEXT, PARAM_FORMATEXT_RTPA);
            break;
      case EC_RTP_MODE_B:
	        SlibSetParamInt(Sh, SLIB_STREAM_ALL, SLIB_PARAM_FORMATEXT, PARAM_FORMATEXT_RTPB);
            break;
      case EC_RTP_MODE_C:
	        SlibSetParamInt(Sh, SLIB_STREAM_ALL, SLIB_PARAM_FORMATEXT, PARAM_FORMATEXT_RTPC);
            break;
    }
	info->Sh = Sh;
	lpbiIn->biSizeImage = SlibGetParamInt (Sh, SLIB_STREAM_MAINVIDEO, SLIB_PARAM_IMAGESIZE);
    info->dwMaxCompBytes = ICH263CompressGetSize(lpbiIn);
    info->bCompressBegun = TRUE;

	return ICERR_OK;
}


DWORD ICH263CompressGetSize(LPBITMAPINFOHEADER lpbiIn)
{
  if (lpbiIn==NULL)
    return(0);
  else if (lpbiIn->biWidth<=168)
    return(0x1800); /* Sub-QCIF */
  else if (lpbiIn->biWidth<=300)
    return(0x2000); /* QCIF */
  else
    return(0x8000); /* CIF */
}

/*
**++
**  FUNCTIONAL_NAME: ICH263CompressGetFormat
**
**  FUNCTIONAL_DESCRIPTION:
**	Get the format for compression
**
**  FORMAL PARAMETERS:
**	driverID
**      lpbiIn          input BITMAPINFOHEADER
**      lpbiOut         output BITMAPINFOHEADER
**
**  RETURN VALUE:
**
**  COMMENTS:
**
**  DESIGN:
**
**/

MMRESULT ICH263CompressGetFormat(H26XINFO *info,
                                          LPBITMAPINFOHEADER lpbiIn,
                                          LPBITMAPINFOHEADER lpbiOut)
{

    _SlibDebug(_DEBUG_, ScDebugPrintf("In ICH263CompressGetFormat\n") );

    if ((!_ICH263CheckFlags(info, ICMODE_COMPRESS)) &&
        (!_ICH263CheckFlags(info, ICMODE_FASTCOMPRESS)) &&
        (!_ICH263CheckFlags(info, ICMODE_QUERY)))

		return (MMRESULT)ICERR_BADHANDLE;

    if (lpbiIn == NULL)
	return (MMRESULT)ICERR_BADPARAM;

    if (lpbiOut == NULL)
        return (sizeof(BITMAPINFOHEADER));

    bcopy(&__defaultCompresslpbiOut, lpbiOut, sizeof(BITMAPINFOHEADER));
    lpbiOut->biWidth = lpbiIn->biWidth;
    lpbiOut->biHeight= lpbiIn->biHeight;
    lpbiOut->biSizeImage = ICH263CompressGetSize(lpbiIn);
    _SlibDebug(_DEBUG_, ScDebugPrintf(" lpbiOut filled: %s\n",
		                     BMHtoString(lpbiOut)) );
    return(ICERR_OK);
}





/*
**++
**  FUNCTIONAL_NAME: ICH263CompressEnd
**
**  FUNCTIONAL_DESCRIPTION:
**	Terminate the compression cycle
**
**  FORMAL PARAMETERS:
**	driverID
**
**  RETURN VALUE:
**
**  COMMENTS:
**
**  DESIGN:
**
**/

MMRESULT ICH263CompressEnd(H26XINFO *info)
{
  _SlibDebug(_VERBOSE_, ScDebugPrintf("In ICH263CompressEnd\n") );

  if ((!_ICH263CheckFlags(info, ICMODE_COMPRESS))
      || (!_ICH263CheckFlags(info, ICMODE_FASTCOMPRESS)))
    return (MMRESULT)ICERR_BADHANDLE;

  if (info->Sh)
  {
    _SlibDebug(_VERBOSE_, ScDebugPrintf("SlibClose()\n") );
    SlibClose (info->Sh);
    info->Sh=NULL;
    _SlibDebug(_VERBOSE_, ScDebugPrintf("SlibMemUsed = %ld (after SlibClose)\n", SlibMemUsed()) );
  }
  info->bCompressBegun = FALSE;
  return(ICERR_OK);
}


/*
**++
**  FUNCTIONAL_NAME: ICH263DecompressQuery
**
**  FUNCTIONAL_DESCRIPTION:
**	Query the codec to determine if it can decompress specified formats
**
**  FORMAL PARAMETERS:
**	driverID
**      lpbiIn          input BITMAPINFOHEADER
**      lpbiOut         output BITMAPINFOHEADER
**
**  RETURN VALUE:
**
**  COMMENTS:
**
**  DESIGN:
**
**/

MMRESULT ICH263DecompressQuery(H26XINFO *info,
                               LPBITMAPINFOHEADER lpbiIn,
                               LPBITMAPINFOHEADER lpbiOut)
{
    _SlibDebug(_VERBOSE_, ScDebugPrintf("In ICH263DecompressQuery\n") );

    if (!_ICH263CheckFlags(info, ICMODE_QUERY) &&
	!_ICH263CheckFlags(info, ICMODE_DECOMPRESS))
	return (MMRESULT)ICERR_BADHANDLE;

    /*
     * Must query at least an input or an output format
     */
    if (!lpbiIn && !lpbiOut)
      return (MMRESULT)(ICERR_BADPARAM);

    if (!IsSupported(_ICDecompressionSupport,
                    lpbiIn ? lpbiIn->biCompression : -1,
                    lpbiIn ? lpbiIn->biBitCount : -1,
                    lpbiOut ? lpbiOut->biCompression : -1,
                    lpbiOut ? lpbiOut->biBitCount : -1))
      return(MMRESULT)(ICERR_BADFORMAT);

    _SlibDebug(_VERBOSE_, ScDebugPrintf("Out ICH263DecompressQuery\n") );
    return ICERR_OK;
}



/*
**++
**  FUNCTIONAL_NAME: ICH263DecompressBegin
**
**  FUNCTIONAL_DESCRIPTION:
**	Begin the decompression process
**
**  FORMAL PARAMETERS:
**	driverID
**      lpbiIn          input BITMAPINFOHEADER
**      lpbiOut         output BITMAPINFOHEADER
**
**  RETURN VALUE:
**
**  ICERR_OK            No error
**  ICERR_MEMORY        Insufficient memory
**  ICERR_BADFORMAT     Invalid image format
**  ICERR_BADPARAM      Invalid image size
**
**  COMMENTS:
**
**
**  DESIGN:
**
**/

MMRESULT ICH263DecompressBegin(H26XINFO *info,
                               LPBITMAPINFOHEADER lpbiIn,
                               LPBITMAPINFOHEADER lpbiOut)
{
    MMRESULT            status;
    _SlibDebug(_VERBOSE_, ScDebugPrintf("In ICH263DecompressBegin\n") );

    if (!_ICH263CheckFlags(info, ICMODE_DECOMPRESS))
	  return (MMRESULT)ICERR_BADHANDLE;

	if ((status = ICH263DecompressQuery(info, lpbiIn, lpbiOut))
        != ICERR_OK)
       return status;

    if (lpbiIn && lpbiOut)
    {
      if ((status = InitBitmapinfo(info, lpbiIn, lpbiOut)) != ICERR_OK)
	    return status;

      info->bUsesCodec = TRUE;
      info->bUsesRender = ((lpbiOut->biBitCount == 8) &&
			     ((lpbiOut->biCompression == BI_DECXIMAGEDIB)||
			      (lpbiOut->biCompression == BI_DECGRAYDIB) ||
			      (lpbiOut->biCompression == BI_RGB)
			      )
			     );

      if (!info->bUsesCodec && !info->bUsesRender)
	    return (MMRESULT)ICERR_BADFORMAT;

      /* SLIB expects first pixel to be top line */
      info->lpbiOut->biHeight=-info->lpbiOut->biHeight;
    }
	info->bDecompressBegun = TRUE;
    _SlibDebug(_VERBOSE_, ScDebugPrintf("Out ICH263DecompressBegin\n") );
    return ICERR_OK;
}


/*
**++
**  FUNCTIONAL_NAME: ICH263DecompressGetFormat
**
**  FUNCTIONAL_DESCRIPTION:
**	Get the recommended decompressed format of the codec
**
**  FORMAL PARAMETERS:
**	driverID
**      lpbiIn          input BITMAPINFOHEADER
**      lpbiOut         output BITMAPINFOHEADER
**
**  RETURN VALUE:
**
**  COMMENTS:
**
**  DESIGN:
**
**/

MMRESULT ICH263DecompressGetFormat(H26XINFO *info,
                                            LPBITMAPINFOHEADER lpbiIn,
                                            LPBITMAPINFOHEADER lpbiOut)
{

    _SlibDebug(_DEBUG_, ScDebugPrintf("In ICH263DecompressGetFormat\n") );

    if (!_ICH263CheckFlags(info, ICMODE_DECOMPRESS) &&
        (!_ICH263CheckFlags(info, ICMODE_QUERY)))
      return((MMRESULT)ICERR_BADHANDLE);

    if (lpbiIn == NULL)
      return((MMRESULT)ICERR_BADPARAM);

    if (lpbiOut == NULL)
        return (sizeof(BITMAPINFOHEADER));

    _SlibDebug(_DEBUG_,
		ScDebugPrintf("lpbiOut is being filled in DecompressGetFormat\n") );
    bcopy(&__defaultDecompresslpbiOut, lpbiOut, sizeof(BITMAPINFOHEADER));
    lpbiOut->biWidth = lpbiIn->biWidth;
    lpbiOut->biHeight= lpbiIn->biHeight;
    /*
    ** Return biSizeImage = 1.5 * width * height to let application know
    ** how big the image buffers must be when passed to ICAddBuffer.
    ** Internal to the codec, they are used to first store a YUV image,
    ** then the ICM layer renders it (if rendered data is what's called for
    */
    lpbiOut->biSizeImage = CalcImageSize(lpbiOut->biCompression,
                           lpbiOut->biWidth, lpbiOut->biHeight, lpbiOut->biBitCount);
    if (lpbiOut->biCompression==BI_RGB && lpbiOut->biBitCount==8)
      lpbiOut->biClrUsed = 1<<lpbiOut->biBitCount;
    else
      lpbiOut->biClrUsed = 0;
    return(0);
}


/*
**++
**  FUNCTIONAL_NAME: ICH263DecompressGetSize
**
**  FUNCTIONAL_DESCRIPTION:
**
**
**  FORMAL PARAMETERS:
**	driverID
**      lpbiIn          input BITMAPINFOHEADER
**      lpbiOut         output BITMAPINFOHEADER
**
**  RETURN VALUE:
**
**  COMMENTS:
**
**  DESIGN:
**
**/

MMRESULT ICH263DecompressGetSize(H26XINFO *info,
                                 LPBITMAPINFOHEADER lpbiIn,
								 LPBITMAPINFOHEADER lpbiOut)
{
    return(MMRESULT)(ICERR_UNSUPPORTED);
}



/*
**++
**  FUNCTIONAL_NAME: ICH263DecompressEnd
**
**  FUNCTIONAL_DESCRIPTION:
**	End the decompression process
**
**  FORMAL PARAMETERS:
**	driverID
**
**  RETURN VALUE:
**
**  COMMENTS:
**
**  DESIGN:
**
**/

MMRESULT ICH263DecompressEnd(H26XINFO *info)
{
    _SlibDebug(_VERBOSE_, ScDebugPrintf("In ICH263DecompressEnd\n") );

    if (!_ICH263CheckFlags(info, ICMODE_DECOMPRESS))
	return (MMRESULT)ICERR_BADHANDLE;

	if (info->Sh)
    {
      _SlibDebug(_VERBOSE_, ScDebugPrintf("SlibClose()\n") );
	  SlibClose(info->Sh);
      info->Sh=NULL;
      _SlibDebug(_VERBOSE_, ScDebugPrintf("SlibMemUsed = %ld (after SlibClose)\n", SlibMemUsed()) );
    }
    info->bDecompressBegun = FALSE;
    return(ICERR_OK);
}



MMRESULT ICH263GetDefaultQuality(H26XINFO *info, DWORD * quality)
{
  *quality = H26X_DEFAULT_QUALITY;
  return((MMRESULT)ICERR_OK);
}

MMRESULT ICH263GetQuality(H26XINFO *info, DWORD * quality)
{
  *quality = info->dwQuality;
  return((MMRESULT)ICERR_OK);
}

MMRESULT ICH263SetQuality(H26XINFO *info, DWORD quality)
{
  if (quality>10000)
    info->dwQuality=10000;
  else
    info->dwQuality=quality;
  // SlibSetParamInt(info->Sh, SLIB_STREAM_MAINVIDEO, SLIB_PARAM_VIDEOQUALITY,
  //                info->dwQuality/100);
  return((MMRESULT)ICERR_OK);
}


/*
**++
**  FUNCTIONAL_NAME: ICH263Compress
**
**  FUNCTIONAL_DESCRIPTION:
**	Compress a frame
**
**  FORMAL PARAMETERS:
**	driverID
**      lpbiIn          input BITMAPINFOHEADER
**      lpbiOut         output BITMAPINFOHEADER
**
**  RETURN VALUE:
**
**  COMMENTS:
**
**  DESIGN:
**
**/
MMRESULT ICH263Compress(H26XINFO *info,
                            ICCOMPRESS  *icCompress,
                            DWORD   dwSize)
{
    MMRESULT            status;
    LPBITMAPINFOHEADER  lpbiIn;
    LPBITMAPINFOHEADER  lpbiOut;
    LPVOID              lpIn;
    LPVOID              lpOut;
	SlibHandle_t		Sh;
    int			        compBytes, reqBytes;
    DWORD               newQi, newQp;
    RTPTRAILER_t       *ptrail;
    BOOL                keyframe=icCompress->dwFlags&ICCOMPRESS_KEYFRAME;

    if (icCompress->dwFrameSize==0 || icCompress->dwFrameSize>64*1024)
      reqBytes = info->dwMaxCompBytes;
    else
      reqBytes = icCompress->dwFrameSize;

#ifdef H261_SUPPORT
    _SlibDebug(_VERBOSE_, ScDebugPrintf("ICH261Compress() FrameNum=%d FrameSize=%d Quality=%d reqBytes=%d\n",
                        icCompress->lFrameNum, icCompress->dwFrameSize, icCompress->dwQuality,
                        reqBytes) );
#else
    _SlibDebug(_VERBOSE_, ScDebugPrintf("ICH263Compress() FrameNum=%d FrameSize=%d Quality=%d reqBytes=%d\n",
                        icCompress->lFrameNum, icCompress->dwFrameSize, icCompress->dwQuality,
                        reqBytes) );
#endif

    if ((!_ICH263CheckFlags(info, ICMODE_COMPRESS))
		|| (!_ICH263CheckFlags(info, ICMODE_FASTCOMPRESS)))
      return (MMRESULT)ICERR_BADHANDLE;

    status = ICERR_OK;

    lpbiIn = icCompress->lpbiInput;
    lpbiOut = icCompress->lpbiOutput;
    lpIn = icCompress->lpInput;
    lpOut = icCompress->lpOutput;
    lpbiOut->biSizeImage = 0;

	
	/* Synchronized SLIB SYSTEMS calls */
	Sh = info->Sh;
compress_frame:
    newQi=newQp=(((10000-icCompress->dwQuality)*30)/10000)+1;
    if (info->dwRTP!=EC_RTP_MODE_OFF) /* if using RTP, check Quant limits */
    {
      if (newQi<info->dwMaxQi)
        newQi=info->dwMaxQi;
      if (newQp<info->dwMaxQp)
        newQp=info->dwMaxQp;
    }
    if (info->dwQi!=newQi)
    {
      SlibSetParamInt(Sh, SLIB_STREAM_MAINVIDEO, SLIB_PARAM_QUANTI, newQi);
      info->dwQi=newQi;
    }
    if (info->dwQp!=newQp)
    {
      SlibSetParamInt(Sh, SLIB_STREAM_MAINVIDEO, SLIB_PARAM_QUANTP, newQp);
      info->dwQp=newQp;
    }
	if (keyframe)
    {
      _SlibDebug(_VERBOSE_, ScDebugPrintf("ICH263Compress() I Frame: Qi=%d\n", newQi) );
      SlibSetParamInt(Sh, SLIB_STREAM_MAINVIDEO, SLIB_PARAM_FRAMETYPE, FRAME_TYPE_I);
    }
    else
    {
      _SlibDebug(_VERBOSE_, ScDebugPrintf("ICH263Compress() P Frame: Qp=%d\n", newQp) );
    }
#ifdef HANDLE_EXCEPTIONS
  __try {
#endif /* HANDLE_EXCEPTIONS */
      status=SlibErrorWriting; /* in case there's an exception */
	  status = SlibWriteVideo (Sh, SLIB_STREAM_MAINVIDEO, lpIn, lpbiIn->biSizeImage);
#ifdef HANDLE_EXCEPTIONS
    } __finally {
#endif /* HANDLE_EXCEPTIONS */
      if (status != SlibErrorNone)
      {
#if defined(EXCEPTION_MESSAGES) && defined(H263_SUPPORT)
        // MessageBox(NULL, "Error in H263 SlibWriteVideo", "Warning", MB_OK);
#elif defined(EXCEPTION_MESSAGES)
        // MessageBox(NULL, "Error in H261 SlibWriteVideo", "Warning", MB_OK);
#endif
        /* make the next frame a key */
        SlibSetParamInt(Sh, SLIB_STREAM_MAINVIDEO, SLIB_PARAM_FRAMETYPE, FRAME_TYPE_I);
        status=(MMRESULT)ICERR_INTERNAL;
	    goto bail;
      }
#ifdef HANDLE_EXCEPTIONS
    }
#endif /* HANDLE_EXCEPTIONS */
	info->lastFrameNum=icCompress->lFrameNum;
    compBytes=reqBytes;
	status = SlibReadData(Sh, SLIB_STREAM_ALL, &lpOut, &compBytes, NULL);
	if (status != SlibErrorNone)
    {
      info->lastCompBytes=0;
      status=(MMRESULT)ICERR_BADSIZE;
	  goto bail;
    }
    else /* check the amount of compressed data */
    {
      int extraBytes=0;
      /* query to see if any more data is left in the codec
       * if there is then the quant step was too high, reduce it and try again
       */
	  status = SlibReadData(Sh, SLIB_STREAM_ALL, NULL, &extraBytes, NULL);
      if (extraBytes)
      {
        _SlibDebug(_VERBOSE_, ScDebugPrintf("ICH263Compress() Too much data: extraBytes=%d\n",
                    extraBytes) );
        if (newQi==31 && newQp==31) /* can't compress to any fewer bytes */
          return((MMRESULT)ICERR_BADSIZE);
        info->dwMaxQi+=1+(newQi/4); /* decrease I frame quality */
        if (info->dwMaxQi>31) info->dwMaxQi=31;
        info->dwMaxQp+=1+(newQp/4); /* decrease P frame quality */
        if (info->dwMaxQp>31) info->dwMaxQp=31;
        /* empty out the compressed data */
        SlibSeekEx(Sh, SLIB_STREAM_ALL, SLIB_SEEK_RESET, 0, 0, NULL);
        /* try to compress again, but make it a key frame */
        keyframe=TRUE;
        goto compress_frame;
      }
      /* we have compressed data less than or equal to request size */
      info->lastCompBytes=compBytes;
      lpbiOut->biSizeImage = compBytes;
      status = ICERR_OK;
    }
    if (info->dwRTP!=EC_RTP_MODE_OFF) /* RTP is on */
    {
      ptrail=(RTPTRAILER_t *)((unsigned char *)lpOut+compBytes-sizeof(RTPTRAILER_t));
      /* check for valid RTP trailer */
      if (compBytes<sizeof(RTPTRAILER_t) || ptrail->dwUniqueCode!=H26X_FOURCC)
        return((MMRESULT)ICERR_INTERNAL);
    }
    if (icCompress->dwFlags&ICCOMPRESS_KEYFRAME) /* I frame */
    {
      if (compBytes>(reqBytes>>2))
      {
        info->dwMaxQi+=1+(newQi>>2); /* decrease quality */
        if (info->dwMaxQi>31) info->dwMaxQi=31;
      }
      else if (newQi==info->dwMaxQi && compBytes<=(reqBytes>>2) && info->dwMaxQi>0)
        info->dwMaxQi--;  /* increase quality */
    }
    else /* P frame */
    {
      if (compBytes>(reqBytes>>1))
      {
        info->dwMaxQp+=1+(newQp>>2); /* decrease max quality */
        if (info->dwMaxQp>31) info->dwMaxQp=31;
        /* also decrease I quality, since P limits are based on I limits */
        info->dwMaxQi+=1+(newQi>>2);
        if (info->dwMaxQi>31) info->dwMaxQi=31;
      }
      else if (newQp==info->dwMaxQp && compBytes<(reqBytes>>1)
                && info->dwMaxQp>(info->dwMaxQi+3)/2)
        info->dwMaxQp--;  /* increase max quality */
    }
#ifdef H261_SUPPORT
    _SlibDebug(_VERBOSE_||_WARN_,
      ScDebugPrintf("ICH261Compress(%c) lpOut=%p reqBytes=%d compBytes=%d Qi=%d Qp=%d MaxQi=%d MaxQp=%d\n",
                          (icCompress->dwFlags&ICCOMPRESS_KEYFRAME)?'I':'P',
                          lpOut, reqBytes, compBytes,
                          newQi, newQp, info->dwMaxQi, info->dwMaxQp) );
#else
    _SlibDebug(_VERBOSE_||_WARN_,
      ScDebugPrintf("ICH263Compress(%c) lpOut=%p reqBytes=%d compBytes=%d Qi=%d Qp=%d MaxQi=%d MaxQp=%d\n",
                          (icCompress->dwFlags&ICCOMPRESS_KEYFRAME)?'I':'P',
                          lpOut, reqBytes, compBytes,
                          newQi, newQp, info->dwMaxQi, info->dwMaxQp) );
#endif
    _SlibDebug(_DEBUG_,
    {
      RTPTRAILER_t *ptrail=(RTPTRAILER_t *)
        ((unsigned char *)lpOut+compBytes-sizeof(RTPTRAILER_t));
      ScDebugPrintf("  Trailer: \n"
                    "           dwVersion=%d\n"
                    "           dwFlags=0x%04X\n"
                    "           dwUniqueCode=%c%c%c%c\n"
                    "           dwCompressedSize=%d\n"
                    "           dwNumberOfPackets=%d\n"
                    "           SourceFormat=%d\n"
                    "           TR=%d TRB=%d DBQ=%d\n",
	                ptrail->dwVersion,
                    ptrail->dwFlags,
	                ptrail->dwUniqueCode&0xFF, (ptrail->dwUniqueCode>>8)&0xFF,
	                (ptrail->dwUniqueCode>>16)&0xFF, (ptrail->dwUniqueCode>>24)&0xFF,
	                 ptrail->dwCompressedSize,
	                 ptrail->dwNumberOfPackets,
	                 ptrail->SourceFormat,
	                 ptrail->TR,ptrail->TRB,ptrail->DBQ);
    }
    ); /* _SlibDebug */
#ifdef H261_SUPPORT
    _SlibDebug((_DEBUG_ || _WARN_) && (info->dwRTP!=EC_RTP_MODE_OFF),
      {
        RTPTRAILER_t *ptrail=(RTPTRAILER_t *)
              ((unsigned char *)lpOut+compBytes-sizeof(RTPTRAILER_t));
        SvH261BITSTREAM_INFO *pinfo;
        BOOL rtperror=FALSE;
        unsigned int i;
        pinfo=(SvH261BITSTREAM_INFO *)((unsigned char *)ptrail
                                    -(ptrail->dwNumberOfPackets*16));
        if (ptrail->dwNumberOfPackets==0 || pinfo[0].dwBitOffset!=0)
        {
          // MessageBox(NULL, "Critical Error in H.261", "Warning", MB_OK);
          rtperror=TRUE;
        }
        /* check for sequential BitOffsets */
        for (i=1; i<ptrail->dwNumberOfPackets; i++)
          if (pinfo[i-1].dwBitOffset>=pinfo[i].dwBitOffset)
          {
            // MessageBox(NULL, "Critical Error in H.261", "Warning", MB_OK);
            rtperror=TRUE;
            break;
          }
        if (pinfo[ptrail->dwNumberOfPackets-1].dwBitOffset>ptrail->dwCompressedSize*8)
        {
          // MessageBox(NULL, "Critical Error in H.261", "Warning", MB_OK);
          rtperror=TRUE;
        }
        if (_DEBUG_ || rtperror)
        {
          if (ptrail->dwNumberOfPackets>64*2)
            ptrail->dwNumberOfPackets=32;
          for (i=0; i<ptrail->dwNumberOfPackets; i++)
          {
            ScDebugPrintf("  H261 Packet %2d: dwFlag=0x%04X  dwBitOffset=%d\n"
                          "                   MBAP=%d Quant=%d\n"
                          "                   GOBN=%d HMV=%d VMV=%d\n",
                    i, pinfo[i].dwFlag, pinfo[i].dwBitOffset,
                       pinfo[i].MBAP, pinfo[i].Quant,
                       pinfo[i].GOBN, pinfo[i].HMV, pinfo[i].VMV);
          }
        }
      }
    ); /* _SlibDebug */
#else /* H263 */
    _SlibDebug((_DEBUG_ || _WARN_) && (info->dwRTP!=EC_RTP_MODE_OFF),
      {
        RTPTRAILER_t *ptrail=(RTPTRAILER_t *)
              ((unsigned char *)lpOut+compBytes-sizeof(RTPTRAILER_t));
        SvH263BITSTREAM_INFO *pinfo;
        BOOL rtperror=FALSE;
        unsigned int i;
        pinfo=(SvH263BITSTREAM_INFO *)((unsigned char *)ptrail
                                    -(ptrail->dwNumberOfPackets*16));
        if (ptrail->dwNumberOfPackets==0 || pinfo[0].dwBitOffset!=0)
        {
          // MessageBox(NULL, "Critical Error in H.263", "Warning", MB_OK);
          rtperror=TRUE;
        }
        /* check for sequential BitOffsets */
        for (i=1; i<ptrail->dwNumberOfPackets; i++)
          if (pinfo[i-1].dwBitOffset>=pinfo[i].dwBitOffset)
          {
            // MessageBox(NULL, "Critical Error in H.263", "Warning", MB_OK);
            rtperror=TRUE;
            break;
          }
        if (pinfo[ptrail->dwNumberOfPackets-1].dwBitOffset>ptrail->dwCompressedSize*8)
        {
          // MessageBox(NULL, "Critical Error in H.263", "Warning", MB_OK);
          rtperror=TRUE;
        }
        if (_DEBUG_ || rtperror)
        {
          if (ptrail->dwNumberOfPackets>64*2)
            ptrail->dwNumberOfPackets=32;
          for (i=0; i<ptrail->dwNumberOfPackets; i++)
          {
            ScDebugPrintf("  H263 Packet %2d: dwFlag=0x%04X  dwBitOffset=%d Mode=%d\n"
                          "                   MBA=%d Quant=%d\n"
                          "                   GOBN=%d HMV1=%d VMV1=%d HMV2=%d VMV2=%d\n",
                    i, pinfo[i].dwFlag, pinfo[i].dwBitOffset, pinfo[i].Mode,
                       pinfo[i].MBA, pinfo[i].Quant,
                       pinfo[i].GOBN, pinfo[i].HMV1, pinfo[i].VMV1,
                       pinfo[i].HMV2, pinfo[i].VMV2);
          }
        }
      }
    ); /* _SlibDebug */
#endif
bail:
    return status;
}
/*
**++
**  FUNCTIONAL_NAME: ICH263Decompress
**
**  FUNCTIONAL_DESCRIPTION:
**	Open the Software CODEC
**
**  FORMAL PARAMETERS:
**	driverID
**      lpbiIn          input BITMAPINFOHEADER
**      lpbiOut         output BITMAPINFOHEADER
**
**  RETURN VALUE:
**
**  COMMENTS:
**
**  DESIGN:
**
**/

MMRESULT ICH263Decompress(H26XINFO *info,
                          ICDECOMPRESS  *icDecompress,
                          DWORD dwSize)

{
  MMRESULT            result=(MMRESULT)ICERR_OK;
  LPBITMAPINFOHEADER  lpbiIn;
  LPBITMAPINFOHEADER  lpbiOut;
  LPVOID              lpIn;
  LPVOID              lpOut;
  SlibHandle_t		Sh;
  SlibStatus_t		status;
#ifdef H261_SUPPORT
  SlibType_t stype = SLIB_TYPE_H261;
#else
  SlibType_t stype = SLIB_TYPE_H263;
#endif

  _SlibDebug(_VERBOSE_, ScDebugPrintf("In ICH263Decompress lpIn is %d\n",lpIn) );

  if (!_ICH263CheckFlags(info, ICMODE_DECOMPRESS))
    return((MMRESULT)ICERR_BADHANDLE);

  lpIn = icDecompress->lpInput;
  lpOut = icDecompress->lpOutput;

  lpbiIn = icDecompress->lpbiInput;
  lpbiOut = icDecompress->lpbiOutput;
  if (!info->bDecompressBegun &&
	  (result = ICH263DecompressBegin(info, lpbiIn, lpbiOut))!=ICERR_OK)
    return(result);

  if (icDecompress->dwFlags & ICDECOMPRESS_HURRYUP)
    return((MMRESULT)ICERR_OK);

  info->lpbiIn->biSizeImage = lpbiIn->biSizeImage;
  info->lpbiOut->biClrImportant = lpbiOut->biClrImportant;
  info->lpbiOut->biSizeImage = lpbiOut->biSizeImage; // they don't set it

  lpbiIn=info->lpbiIn;
  lpbiOut=info->lpbiOut;
  if (!info->Sh)
  {
    _SlibDebug(_VERBOSE_, ScDebugPrintf("SlibMemUsed = %ld (before SlibOpen)\n", SlibMemUsed()) );
    status = SlibOpenSync (&Sh, SLIB_MODE_DECOMPRESS, &stype, lpIn, icDecompress->lpbiInput->biSizeImage);
    SlibSetParamInt (Sh, SLIB_STREAM_MAINVIDEO, SLIB_PARAM_HEIGHT, lpbiOut->biHeight);
    SlibSetParamInt (Sh, SLIB_STREAM_MAINVIDEO, SLIB_PARAM_WIDTH, lpbiOut->biWidth);
    SlibSetParamInt (Sh, SLIB_STREAM_MAINVIDEO, SLIB_PARAM_VIDEOFORMAT, lpbiOut->biCompression);
    SlibSetParamInt (Sh, SLIB_STREAM_MAINVIDEO, SLIB_PARAM_VIDEOBITS, lpbiOut->biBitCount);
    info->Sh = Sh;
    _SlibDebug(_WARN_ && status!=SlibErrorNone,
       ScDebugPrintf("ICH263Decompress() SlibOpenSync: %s\n", SlibGetErrorText(status)) );
  }
  else
  {
    DWORD dwPadding=0xFFFFFFFF;
	status=SlibAddBuffer (info->Sh, SLIB_DATA_COMPRESSED, lpIn, icDecompress->lpbiInput->biSizeImage);
    _SlibDebug(_WARN_ && status!=SlibErrorNone,
       ScDebugPrintf("ICH263Decompress() SlibAddBuffer(%p, %d): %s\n",
	       lpIn, lpbiIn->biSizeImage, SlibGetErrorText(status)) );
    /* Add some padding bits to the end because the codecs try to peek
     * forward past the very last bits of the buffer
     */
	status=SlibAddBuffer (info->Sh, SLIB_DATA_COMPRESSED, (char *)&dwPadding, sizeof(DWORD));
  }
  if (status==SlibErrorNone)
  {
#ifdef HANDLE_EXCEPTIONS
  __try {
#endif /* HANDLE_EXCEPTIONS */
    status = SlibErrorReading;  /* in case there's an exception */
    status = SlibReadVideo(info->Sh, SLIB_STREAM_MAINVIDEO, &lpOut, &lpbiOut->biSizeImage);
#ifdef HANDLE_EXCEPTIONS
    } __finally {
#endif /* HANDLE_EXCEPTIONS */
	  if (status!=SlibErrorNone)
      {
        _SlibDebug(_WARN_ && status!=SlibErrorNone,
         ScDebugPrintf("ICH263Decompress() SlibReadVideo: %s\n", SlibGetErrorText(status)) );
	    status=(MMRESULT)ICERR_BADFORMAT;
	  }
      else
        status=(MMRESULT)ICERR_OK;
      goto bail;
#ifdef HANDLE_EXCEPTIONS
    }
#endif /* HANDLE_EXCEPTIONS */
  }
  else
    status=(MMRESULT)ICERR_BADFORMAT;
bail:
  return(status);
}





/*
 * This routine just nulls out the pValidHandles
 * pointer so that no lingering threads will be
 * able to use it. It's only called at dll
 * shutdown on NT.
 */

int TerminateH263()
{
    pValidHandles = NULL;
	return 0;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech261\h26x_int.h ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: h26x_int.h,v $
  * $EndLog$
 */
/*
**++
** FACILITY:  Workstation Multimedia  (WMM)  v1.0
**
** FILE NAME:    h26x_int.h
** MODULE NAME:  h26x_int.h
**
** MODULE DESCRIPTION: Internal H.261/H.263 header - used by h26x.c
**
** DESIGN OVERVIEW:
**
**--
*/
#ifndef _H26X_INT_H_
#define _H26X_INT_H_
#if !defined(_DEBUG) && defined(WIN32)
#define HANDLE_EXCEPTIONS
// #define EXCEPTION_MESSAGES /* dialog boxes appear on critical exceptions */
#endif

#ifdef __osf__ /* NOT needed for NT */
/*
 * For loading .so.
 */
#include <stdlib.h>
#include <dlfcn.h>
#endif

#define _huge
#define _loadds	
	
#include <windows.h>
#include <VFW.H>
// #include "cmm.h"
#include "slib.h"
// #include "SR.h"
#include "dech26x.h"



#ifdef H261_SUPPORT
#define H26X_FOURCC         VIDEO_FORMAT_DIGITAL_H261
#ifdef WIN32
#define H26X_NAME           L"Digital H.261"
#define H26X_DESCRIPTION    L"Digital H261 Video CODEC"
#define H26X_DRIVER         L"dech261.dll"
#else  /* !WIN32 */
#define H26X_NAME           "Digital H.261"
#define H26X_DESCRIPTION    "Digital H.261 Video CODEC"
#define H26X_DRIVER         "libh261.so"
#endif
#define H26X_KEYNAME        "vidc.d261"
#define H26X_KEYNAME_PRE    "vidc"
#define H26X_KEYNAME_POST   "d261"
#else /* H263 */
#define H26X_FOURCC         VIDEO_FORMAT_DIGITAL_H263
#ifdef WIN32
#define H26X_NAME           L"Digital H.263"
#define H26X_DESCRIPTION    L"Digital H263 Video CODEC"
#define H26X_DRIVER         L"dech263.dll"
#else  /* !WIN32 */
#define H26X_NAME           "Digital H.263"
#define H26X_DESCRIPTION    "Digital H.263 Video CODEC"
#define H26X_DRIVER         "libh263.so"
#endif
#define H26X_KEYNAME        "vidc.d263"
#define H26X_KEYNAME_PRE    "vidc"
#define H26X_KEYNAME_POST   "d263"
#endif /* H263 */

#define H26X_VERSION	        0x001
#define H26X_DEFAULT_SATURATION	5000.0
#define H26X_DEFAULT_CONTRAST	5000.0
#define H26X_DEFAULT_BRIGHTNESS	5000.0
#define H26X_DEFAULT_QUALITY    5000
#define H26X_DEFAULT_FRAMERATE  15.0F
#define H26X_DEFAULT_BITRATE    0 /* 57344*2 */
#define H26X_DEFAULT_MODE       0 /* PARAM_ALGFLAG_UMV|PARAM_ALGFLAG_ADVANCED */
#define H26X_DEFAULT_PACKETSIZE 512
#define H26X_DEFAULT_RTP        EC_RTP_MODE_OFF
#define H26X_DEFAULT_SQCIF_QI   8
#define H26X_DEFAULT_SQCIF_QP   8
#define H26X_DEFAULT_QCIF_QI    9
#define H26X_DEFAULT_QCIF_QP    9
#define H26X_DEFAULT_CIF_QI     14
#define H26X_DEFAULT_CIF_QP     14

#define IsH263Codec(h) ((_ICMGetType(h) == VIDEO_FORMAT_DIGITAL_H263) ? TRUE : FALSE)
#define IsH261Codec(h) ((_ICMGetType(h) == VIDEO_FORMAT_DIGITAL_H261) ? TRUE : FALSE)

/*
 * For the loading of the .so (H26X_DRIVER)
 */
#define H26X_LDLIB_PATH_COMP  	"mmeserver"
#define H26X_DRIVERPROC_ENTRY  	"ICH263Message"
#define H26X_OPENPROC_ENTRY  	"ICH263Open"

/*
** Standard Image sizes
*/
#define FULL_WIDTH      640
#define FULL_HEIGHT     480
#define NTSC_WIDTH      320
#define NTSC_HEIGHT     240
#define SIF_WIDTH       352
#define SIF_HEIGHT      240
#define CIF_WIDTH       352
#define CIF_HEIGHT      288
#define SQCIF_WIDTH     128
#define SQCIF_HEIGHT    96
#define QCIF_WIDTH      176
#define QCIF_HEIGHT     144
#define CIF4_WIDTH      (CIF_WIDTH*2)
#define CIF4_HEIGHT     (CIF_HEIGHT*2)
#define CIF16_WIDTH     (CIF_WIDTH*4)
#define CIF16_HEIGHT    (CIF_HEIGHT*4)

typedef struct SvH261_T_BSINFO_TRAILER{
	unsigned dword	dwVersion;
	unsigned dword	dwFlags;
	unsigned dword	dwUniqueCode;
	unsigned dword  dwCompressedSize;
	unsigned dword  dwNumberOfPackets;
	unsigned char	SourceFormat;
	unsigned char	TR;
	unsigned char   TRB;
	unsigned char   DBQ;
} RTPTRAILER_t;

typedef struct SvH263_T_EX_BITSTREAM_INFO{
	unsigned dword	dwFlag;
	unsigned dword	dwBitOffset;
	unsigned char	Mode;
	unsigned char	MBA;
	unsigned char	Quant;
	unsigned char	GOBN;
	char			HMV1;
	char			VMV1;
	char			HMV2;
	char			VMV2;
} SvH263BITSTREAM_INFO;

typedef struct SvH261_T_EX_BITSTREAM_INFO{
	unsigned dword	dwFlag;
	unsigned dword	dwBitOffset;
	unsigned char	MBAP;
	unsigned char	Quant;
	unsigned char	GOBN;
	char			HMV;
	char			VMV;
    char			padding0;
    short			padding1;
} SvH261BITSTREAM_INFO;


typedef struct _h26Xinfo
{
    struct _h26Xinfo    *next;
    HIC                 hic;
    BOOL                bCompressBegun;
    BOOL                bDecompressBegun;
    BOOL                bPaletteInitialized;
    BOOL                bUsesCodec;
    BOOL                bUsesRender;
    DWORD               fccType;
    DWORD               fccHandler;
    SlibHandle_t        Sh;
    LPBITMAPINFOHEADER  lpbiOut;
    LPBITMAPINFOHEADER  lpbiIn;
    void               *client;
    BOOL                clientGone;
    DWORD               openFlags;
    DWORD               dwMaxCompBytes;
    /****** Frame-by-frame Modified Params ******/
    DWORD		dwMaxQuality;
    DWORD		dwMaxQi;
    DWORD		dwMaxQp;
    DWORD		dwQi;
    DWORD		dwQp;
    /********* Custom Settings ******/
    float		fFrameRate;
    long        lastFrameNum;
    DWORD       lastCompBytes;
    DWORD		dwQuality;
    DWORD		dwBitrate;
    DWORD		dwPacketSize;
    DWORD       dwRTP;
    DWORD		dwBrightness;
    DWORD		dwContrast;
    DWORD		dwSaturation;
} H26XINFO;

extern H26XINFO  *IChic2info(HIC hic);
extern H26XINFO  *ICclient2info(void *client);
extern BOOL	     ICclientGone(void *client);
extern MMRESULT  CALLBACK ICH263Message(DWORD_PTR driverHandle,
					UINT uiMessage,
					LPARAM lParam1,
					LPARAM lParam2,
					H26XINFO *info);
extern HIC	     ICH263Open(void *client);
extern void      ICH263Close(H26XINFO *info, BOOL postreply);
extern BOOL      ICH263QueryConfigure(H26XINFO *info);
extern MMRESULT  ICH263Configure(H26XINFO *info);
extern BOOL      ICH263QueryAbout(H26XINFO *info);
extern MMRESULT  ICH263About(H26XINFO *info);
extern MMRESULT  ICH263GetInfo(H26XINFO *info, ICINFO * pic, DWORD dwSize);
extern MMRESULT	 ICH263GetDefaultQuality(H26XINFO *info, DWORD *lParam1);
extern MMRESULT	 ICH263GetQuality(H26XINFO *info, DWORD *lParam1);
extern MMRESULT	 ICH263SetQuality(H26XINFO *info, DWORD lParam1);

extern MMRESULT  ICH263CompressQuery(H26XINFO *info,
				     LPBITMAPINFOHEADER lpbiIn,
				     LPBITMAPINFOHEADER lpbiOut);
extern MMRESULT  ICH263CompressBegin(H26XINFO *info,
				     LPBITMAPINFOHEADER lpbiIn,
				     LPBITMAPINFOHEADER lpbiOut);
extern MMRESULT  ICH263CompressGetFormat(H26XINFO *info,
					 LPBITMAPINFOHEADER lpbiIn,
					 LPBITMAPINFOHEADER lpbiOut);
extern DWORD ICH263CompressGetSize(LPBITMAPINFOHEADER lpbiIn);
extern MMRESULT  ICH263Compress(H26XINFO *info,
				ICCOMPRESS  *icCompress,
				DWORD   dwSize);
extern MMRESULT  ICH263CompressEnd(H26XINFO *info);

extern MMRESULT  ICH263DecompressQuery(H26XINFO *info,
				       LPBITMAPINFOHEADER lpbiIn,
				       LPBITMAPINFOHEADER lpbiOut);
extern MMRESULT  ICH263DecompressBegin(H26XINFO *info,
				       LPBITMAPINFOHEADER lpbiIn,
				       LPBITMAPINFOHEADER lpbiOut);
extern MMRESULT  ICH263DecompressGetFormat(H26XINFO *info,
					   LPBITMAPINFOHEADER lpbiIn,
					   LPBITMAPINFOHEADER lpbiOut);


extern MMRESULT  ICH263DecompressGetSize(H26XINFO *info,
					 LPBITMAPINFOHEADER lpbiIn,
					 LPBITMAPINFOHEADER lpbiOut);

extern MMRESULT  ICH263Decompress(H26XINFO *info,
				  ICDECOMPRESS  *icDecompress,
				  DWORD dwSize);

extern MMRESULT  ICH263DecompressEnd(H26XINFO *info);
extern MMRESULT  ICH263PrepareHeader(H26XINFO *info,
				     ICDECOMPRESS  *icDecompress,
				     DWORD dwSize);
extern MMRESULT  ICH263UnprepareHeader(H26XINFO *info,
				       ICDECOMPRESS  *icDecompress,
				       DWORD dwSize);
extern MMRESULT  ICH263SetQuality(H26XINFO *info, DWORD dwValue);

extern MMRESULT  ICH263CustomEncoder (H26XINFO *info, DWORD lParam1, DWORD lParam2);


extern void      WaitMsec(long waitTimeInMsec);
extern int TerminateH263();
extern int DriverPostReply(void *client, DWORD ret, DWORD arg);

/*
 * Windows NT debugging.
 */
#ifdef _SLIBDEBUG_
#include <stdio.h>
static int ScDebugPrintf(char *fmtstr, ...)
{
  int cnt;
  if (fmtstr)
  {
	char text[255];
    va_list argptr;
    va_start(argptr, fmtstr);
    cnt=vsprintf(text, fmtstr, argptr);
    va_end(argptr);
    OutputDebugString(text);
  }
  return(cnt);
}

static char *BMHtoString(LPBITMAPINFOHEADER lpbi)
{
  static char text[255];
  if (lpbi)
  {
    DWORD format=lpbi->biCompression;
    if (format==BI_RGB)
      sprintf(text, "%dx%d,%d bits (RGB)",
            lpbi->biWidth, lpbi->biHeight, lpbi->biBitCount);
    else if (format==BI_BITFIELDS)
      sprintf(text, "%dx%d,%d bits (BITFIELDS)",
            lpbi->biWidth, lpbi->biHeight, lpbi->biBitCount);
    else
      sprintf(text, "%dx%d,%d bits (%c%c%c%c)",
            lpbi->biWidth, lpbi->biHeight, lpbi->biBitCount,
            (char)(format&0xFF), (char)((format>>8)&0xFF),
            (char)((format>>16)&0xFF), (char)((format>>24)&0xFF));
  }
  else
    sprintf(text, "NULL");
  return(text);
}

#define DPF ScDebugPrintf
#define DPF2 ScDebugPrintf
#else
#define DPF
#define DPF2
#endif

#endif /* _H26X_INT_H_ */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech261\huffman.c ===
/* File: sv_h261_huffman.c */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995, 1997                 **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/
/*************************************************************
This file contains the Huffman routines.
*************************************************************/

/*
#define _SLIBDEBUG_
*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "SV.h"
#include "sv_intrn.h"
#include "sv_h261.h"
#include "proto.h"

#ifdef _SLIBDEBUG_
#define _DEBUG_   0  /* detailed debuging statements */
#define _VERBOSE_ 0  /* show progress */
#define _VERIFY_  1  /* verify correct operation */
#define _WARN_    0  /* warnings about strange behavior */
#endif

static DHUFF *MakeDhuff();
static EHUFF *MakeEhuff(int n);
static void LoadETable(int *array, EHUFF *table);
static void LoadDTable(int *array, DHUFF *table);
static int GetNextState(DHUFF *huff);
static void DestroyDhuff(DHUFF **huff);
static void DestroyEhuff(EHUFF **huff);
static void AddCode(int n, int code, int value, DHUFF *huff);

/* Actual Tables */
#define GetLeft(sval,huff) ((huff->state[(sval)] >> 16) & 0xffff)
#define GetRight(sval,huff) (huff->state[(sval)] & 0xffff)

#define SetLeft(number,sval,huff) huff->state[(sval)]=\
  (((huff->state[(sval)]) & 0xffff)|(number<<16));
#define SetRight(number,sval,huff) huff->state[(sval)]=\
  (((huff->state[(sval)]) & 0xffff0000)|(number));

#define EmptyState 0xffff
#define Numberp(value) ((value & 0x8000) ? 1 : 0)
#define MakeHVal(value) (value | 0x8000)
#define GetHVal(value) (value & 0x7fff)

int MTypeCoeff[] = {
0,4,1,
1,7,1,
2,1,1,
3,5,1,
4,9,1,
5,8,1,
6,10,1,
7,3,1,
8,2,1,
9,6,1,
-1,-1};

int MBACoeff[] = {
1,1,1,
2,3,3,
3,3,2,
4,4,3,
5,4,2,
6,5,3,
7,5,2,
8,7,7,
9,7,6,
10,8,11,
11,8,10,
12,8,9,
13,8,8,
14,8,7,
15,8,6,
16,10,23,
17,10,22,
18,10,21,
19,10,20,
20,10,19,
21,10,18,
22,11,35,
23,11,34,
24,11,33,
25,11,32,
26,11,31,
27,11,30,
28,11,29,
29,11,28,
30,11,27,
31,11,26,
32,11,25,
33,11,24,
34,11,15, /* Stuffing */
35,16,1, /* Start */
-1,-1};

int MVDCoeff[] = {
16,11,25,
17,11,27,
18,11,29,
19,11,31,
20,11,33,
21,11,35,
22,10,19,
23,10,21,
24,10,23,
25,8,7,
26,8,9,
27,8,11,
28,7,7,
29,5,3,
30,4,3,
31,3,3,
0,1,1,
1,3,2,
2,4,2,
3,5,2,
4,7,6,
5,8,10,
6,8,8,
7,8,6,
8,10,22,
9,10,20,
10,10,18,
11,11,34,
12,11,32,
13,11,30,
14,11,28,
15,11,26,
-1,-1};

int CBPCoeff[] = {
60,3,7,
4,4,13,
8,4,12,
16,4,11,
32,4,10,
12,5,19,
48,5,18,
20,5,17,
40,5,16,
28,5,15,
44,5,14,
52,5,13,
56,5,12,
1,5,11,
61,5,10,
2,5,9,
62,5,8,
24,6,15,
36,6,14,
3,6,13,
63,6,12,
5,7,23,
9,7,22,
17,7,21,
33,7,20,
6,7,19,
10,7,18,
18,7,17,
34,7,16,
7,8,31,
11,8,30,
19,8,29,
35,8,28,
13,8,27,
49,8,26,
21,8,25,
41,8,24,
14,8,23,
50,8,22,
22,8,21,
42,8,20,
15,8,19,
51,8,18,
23,8,17,
43,8,16,
25,8,15,
37,8,14,
26,8,13,
38,8,12,
29,8,11,
45,8,10,
53,8,9,
57,8,8,
30,8,7,
46,8,6,
54,8,5,
58,8,4,
31,9,7,
47,9,6,
55,9,5,
59,9,4,
27,9,3,
39,9,2,
-1,-1};

int TCoeff1[] = {
0,2,2, /* EOF */
1,2,3, /* Not First Coef */
2,4,4,
3,5,5,
4,7,6,
5,8,38,
6,8,33,
7,10,10,
8,12,29,
9,12,24,
10,12,19,
11,12,16,
12,13,26,
13,13,25,
14,13,24,
15,13,23,
257,3,3,
258,6,6,
259,8,37,
260,10,12,
261,12,27,
262,13,22,
263,13,21,
513,4,5,
514,7,4,
515,10,11,
516,12,20,
517,13,20,
769,5,7,
770,8,36,
771,12,28,
772,13,19,
1025,5,6,
1026,10,15,
1027,12,18,
1281,6,7,
1282,10,9,
1283,13,18,
1537,6,5,
1538,12,30,
1793,6,4,
1794,12,21,
2049,7,7,
2050,12,17,
2305,7,5,
2306,13,17,
2561,8,39,
2562,13,16,
2817,8,35,
3073,8,34,
3329,8,32,
3585,10,14,
3841,10,13,
4097,10,8,
4353,12,31,
4609,12,26,
4865,12,25,
5121,12,23,
5377,12,22,
5633,13,31,
5889,13,30,
6145,13,29,
6401,13,28,
6657,13,27,
6913,6,1, /* Escape */
-1,-1
};

/* Excludes EOB */

int TCoeff2[] = {
1,1,1, /* First Coef */
2,4,4,
3,5,5,
4,7,6,
5,8,38,
6,8,33,
7,10,10,
8,12,29,
9,12,24,
10,12,19,
11,12,16,
12,13,26,
13,13,25,
14,13,24,
15,13,23,
257,3,3,
258,6,6,
259,8,37,
260,10,12,
261,12,27,
262,13,22,
263,13,21,
513,4,5,
514,7,4,
515,10,11,
516,12,20,
517,13,20,
769,5,7,
770,8,36,
771,12,28,
772,13,19,
1025,5,6,
1026,10,15,
1027,12,18,
1281,6,7,
1282,10,9,
1283,13,18,
1537,6,5,
1538,12,30,
1793,6,4,
1794,12,21,
2049,7,7,
2050,12,17,
2305,7,5,
2306,13,17,
2561,8,39,
2562,13,16,
2817,8,35,
3073,8,34,
3329,8,32,
3585,10,14,
3841,10,13,
4097,10,8,
4353,12,31,
4609,12,26,
4865,12,25,
5121,12,23,
5377,12,22,
5633,13,31,
5889,13,30,
6145,13,29,
6401,13,28,
6657,13,27,
6913,6,1, /* Escape */
-1,-1
};


/*
 * Function: inithuff()
 * Purpose:  Initializes all of the Huffman structures to the
 *           appropriate values. It must be called before any of
 *           the tables are used.
 */
void sv_H261HuffInit(SvH261Info_t *H261)
{
  H261->NumberBitsCoded = 0;
  H261->MBADHuff = MakeDhuff();
  H261->MVDDHuff = MakeDhuff();
  H261->CBPDHuff = MakeDhuff();
  H261->T1DHuff = MakeDhuff();
  H261->T2DHuff = MakeDhuff();
  H261->T3DHuff = MakeDhuff();
  H261->MBAEHuff = MakeEhuff(40);
  H261->MVDEHuff = MakeEhuff(40);
  H261->CBPEHuff = MakeEhuff(70);
  H261->T1EHuff = MakeEhuff(8192);
  H261->T2EHuff = MakeEhuff(8192);
  H261->T3EHuff = MakeEhuff(20);
  LoadDTable(MBACoeff,H261->MBADHuff);
  LoadETable(MBACoeff,H261->MBAEHuff);
  LoadDTable(MVDCoeff,H261->MVDDHuff);
  LoadETable(MVDCoeff,H261->MVDEHuff);
  LoadDTable(CBPCoeff,H261->CBPDHuff);
  LoadETable(CBPCoeff,H261->CBPEHuff);
  LoadDTable(TCoeff1,H261->T1DHuff);
  LoadETable(TCoeff1,H261->T1EHuff);
  LoadDTable(TCoeff2,H261->T2DHuff);
  LoadETable(TCoeff2,H261->T2EHuff);
  LoadDTable(MTypeCoeff,H261->T3DHuff);
  LoadETable(MTypeCoeff,H261->T3EHuff);
}

/*
 * Function: freehuff()
 * Purpose:  Frees all memory allocated for the Huffman structures.
 */
void sv_H261HuffFree(SvH261Info_t *H261)
{
  DestroyDhuff(&H261->MBADHuff);
  DestroyDhuff(&H261->MVDDHuff);
  DestroyDhuff(&H261->CBPDHuff);
  DestroyDhuff(&H261->T1DHuff);
  DestroyDhuff(&H261->T2DHuff);
  DestroyDhuff(&H261->T3DHuff);
  DestroyEhuff(&H261->MBAEHuff);
  DestroyEhuff(&H261->MVDEHuff);
  DestroyEhuff(&H261->CBPEHuff);
  DestroyEhuff(&H261->T1EHuff);
  DestroyEhuff(&H261->T2EHuff);
  DestroyEhuff(&H261->T3EHuff);
}


/*
** Function: MakeDhuff()
** Purpose:  Constructs a decoder Huffman table and returns
**           the structure.
*/
static DHUFF *MakeDhuff()
{
  int i;
  DHUFF *temp;
  _SlibDebug(_DEBUG_, printf("MakeDhuff()\n") );

  temp = (DHUFF *)ScAlloc(sizeof(DHUFF));
  temp->NumberStates=1;
  for(i=0; i<512; i++)
    temp->state[i] = -1;
  return(temp);
}

static void DestroyDhuff(DHUFF **huff)
{
  if (huff)
  {
    ScFree(*huff);
    *huff=NULL;
  }
}

/*
** Function: MakeEhuff()
** Purpose:  Constructs an encoder huff with a designated table-size.
**           This table-size, n, is used for the lookup of Huffman values,
**           and must represent the largest positive Huffman value.
*/
static EHUFF *MakeEhuff(int n)
{
  int i;
  EHUFF *temp;
  _SlibDebug(_DEBUG_, printf("MakeEhuff()\n") );

  temp = (EHUFF *)ScAlloc(sizeof(EHUFF));
  temp->n = n;
  temp->Hlen = (int *)ScAlloc(n*sizeof(int));
  temp->Hcode = (int *)ScAlloc(n*sizeof(int));
  for(i=0; i<n; i++)
  {
    temp->Hlen[i] = -1;
    temp->Hcode[i] = -1;
  }
  return(temp);
}

static void DestroyEhuff(EHUFF **huff)
{
  if (huff)
  {
    if ((*huff)->Hlen)
      ScFree((*huff)->Hlen);
    if ((*huff)->Hcode)
      ScFree((*huff)->Hcode);
    ScFree(*huff);
    *huff=NULL;
  }
}


/*
** Function: LoadETable()
** Purpose:  Used to load an array into an encoder table.  The
**           array is grouped in triplets and the first negative value
**           signals the end of the table.
*/
static void LoadETable(int *array, EHUFF *table)
{
  _SlibDebug(_DEBUG_, printf("LoadETable()\n") );

  while(*array>=0)
    {
      if (*array>table->n)
	{
	  printf("Table overflow.\n");
	}
      table->Hlen[*array] = array[1];
      table->Hcode[*array] = (int )array[2];
      array+=3;
    }
}

/*
** Function: LoadDHUFF()
** Purpose:  Used to load an array into the DHUFF structure. The
**           array consists of trios of Huffman definitions, the
**           first one the value, the next one the size, and the
**           third one the code.
*/
static void LoadDTable(int *array, DHUFF *table)
{
  _SlibDebug(_DEBUG_, printf("LoadDTable()\n") );

  while(*array>=0)
  {
    AddCode(array[1],array[2],array[0],table);
    array+=3;
  }
}

/*
** Function: GetNextState()
**           Returns the next free state of the decoder Huffman
**           structure.  It no longer exits an error upon overflow.
*/
static int GetNextState(DHUFF *huff)
{
  _SlibDebug(_DEBUG_, printf("GetNextState()\n") );
/*
  if (huff->NumberStates==512)
    {
      _SlibDebug(_DEBUG_, printf("Overflow\n") );
      exit(ERROR_BOUNDS);
    }
*/
  return(huff->NumberStates++);
}

/*
** Function: sv_H261HuffEncode()
** Purpose:  Encodes a value according to a designated encoder Huffman
**           table out to the stream. It returns the number of bits
**           written to the stream and a zero on error.
*/
int sv_H261HuffEncode(SvH261Info_t *H261, ScBitstream_t *bs, int val, EHUFF *huff)
{
  _SlibDebug(_DEBUG_, printf("Encode(val=%d)\n", val) );
  if (val < 0)
  {
    _SlibDebug(_DEBUG_, printf("Encode() Out of bounds val: %d.\n",val) );
    return(0);
  }
  else if (val>=huff->n)
    return(0); /* No serious error, can occur with some values */
  else if (huff->Hlen[val]<0)
    return(0);  /* No serious error: can pass thru by alerting routine.*/
  else
  {
    _SlibDebug(_DEBUG_,
             printf("Encode() Value: %d|%x  Length: %d  Code: %d\n",
	            val,val,huff->Hlen[val],huff->Hcode[val]) );
    H261->NumberBitsCoded+=huff->Hlen[val];
    ScBSPutBits(bs, huff->Hcode[val], huff->Hlen[val]);
    return(huff->Hlen[val]);
  }
}


/*
** Function: sv_H261HuffDecode()
** Purpose:  Returns an integer read off the stream using the designated
**           Huffman structure.
*/
#if 1
int sv_H261HuffDecode(SvH261Info_t *H261, ScBitstream_t *bs, DHUFF *huff)
{
  register int State=0, bits;
  register unsigned short cb;
  _SlibDebug(_DEBUG_, printf("Decode()\n") );

  cb = (unsigned short)ScBSPeekBits(bs, 16);
  if (bs->EOI)
    return(0);
  if ((State = nextstate(huff, State, 0x8000)) & 0x8000) {
    bits=1;
    State = (State == 0xffff) ? 0 : State & 0x7fff;
  } else if ((State = nextstate(huff, State, 0x4000)) & 0x8000) {
    bits=2;
    State = (State == 0xffff) ? 0 : State & 0x7fff;
  } else if ((State = nextstate(huff, State, 0x2000)) & 0x8000) {
    bits=3;
    State = (State == 0xffff) ? 0 : State & 0x7fff;
  } else if ((State = nextstate(huff, State, 0x1000)) & 0x8000) {
    bits=4;
    State = (State == 0xffff) ? 0 : State & 0x7fff;
  } else if ((State = nextstate(huff, State, 0x0800)) & 0x8000) {
    bits=5;
    State = (State == 0xffff) ? 0 : State & 0x7fff;
  } else if ((State = nextstate(huff, State, 0x0400)) & 0x8000) {
    bits=6;
    State = (State == 0xffff) ? 0 : State & 0x7fff;
  } else if ((State = nextstate(huff, State, 0x0200)) & 0x8000) {
    bits=7;
    State = (State == 0xffff) ? 0 : State & 0x7fff;
  } else if ((State = nextstate(huff, State, 0x0100)) & 0x8000) {
    bits=8;
    State = (State == 0xffff) ? 0 : State & 0x7fff;
  } else if ((State = nextstate(huff, State, 0x0080)) & 0x8000) {
    bits=9;
    State = (State == 0xffff) ? 0 : State & 0x7fff;
  } else if ((State = nextstate(huff, State, 0x0040)) & 0x8000) {
    bits=10;
    State = (State == 0xffff) ? 0 : State & 0x7fff;
  } else if ((State = nextstate(huff, State, 0x0020)) & 0x8000) {
    bits=11;
    State = (State == 0xffff) ? 0 : State & 0x7fff;
  } else if ((State = nextstate(huff, State, 0x0010)) & 0x8000) {
    bits=12;
    State = (State == 0xffff) ? 0 : State & 0x7fff;
  } else if ((State = nextstate(huff, State, 0x0008)) & 0x8000) {
    bits=13;
    State = (State == 0xffff) ? 0 : State & 0x7fff;
  } else if ((State = nextstate(huff, State, 0x0004)) & 0x8000) {
    bits=14;
    State = (State == 0xffff) ? 0 : State & 0x7fff;
  } else if ((State = nextstate(huff, State, 0x0002)) & 0x8000) {
    bits=15;
    State = (State == 0xffff) ? 0 : State & 0x7fff;
  } else if ((State = nextstate(huff, State, 0x0001)) & 0x8000) {
    bits=16;
    State = (State == 0xffff) ? 0 : State & 0x7fff;
  }

  ScBSSkipBits(bs, bits);
  return(State);
}
#else
int sv_H261HuffDecode(SvH261Info_t *H261, ScBitstream_t *bs, DHUFF *huff)
{
  int Next,cb;
  int CurrentState=0;
  _SlibDebug(_DEBUG_, printf("Decode()\n") );

  while(1)
  {
    cb = ScBSGetBit(bs);
    if (bs->EOI)
      return(0);
    Next = cb ? GetLeft(CurrentState,huff) : GetRight(CurrentState,huff);
    if (Next == EmptyState)
      return(0);
    else if (Numberp(Next))
      return(GetHVal(Next));
    else
      CurrentState = Next;
  }
}
#endif

/*
** Function: AddCode()
** Purpose:  Adds a Huffman code to the decoder structure. It is called
**           everytime a new Huffman code is to be defined. This function
**           exits when an invalid code is attempted to be placed in
**           the structure.
*/
static void AddCode(int n, int code, int value, DHUFF *huff)
{
  int i,Next;
  int CurrentState=0;
  _SlibDebug(_DEBUG_, printf("AddCode()\n") );

  if (value < 0)
     return;

  for(i=n-1;i>0;i--)
    {
      if (code & (1 << i))
	{
	  Next = GetLeft(CurrentState,huff);
	  if (Next == EmptyState)
	    {
	      Next = GetNextState(huff);
	      SetLeft(Next,CurrentState,huff);
	      CurrentState = Next;
	    }
	  else /* if (Numberp(Next))
	    {
	      printf("Bad Value/State match:\n");
	      printf("Length: %d   Code: %d  Value: %d\n",
		     n,code,value);
	      exit(ERROR_BOUNDS);
	    }
	  else
		*/
	    {
	      CurrentState = Next;
	    }
	}
      else
	{
	  Next = GetRight(CurrentState,huff);
	  if (Next == EmptyState)
	    {
	      Next = GetNextState(huff);
	      SetRight(Next,CurrentState,huff);
	      CurrentState = Next;
	    }
	  else /* if (Numberp(Next))
	    {
	      printf("Bad Value/State match:\n");
	      printf("Length: %d   Code: %d  Value: %d\n",
		     n,code,value);
	      exit(ERROR_BOUNDS);
	    }
	  else
	*/
	    {
	      CurrentState = Next;
	    }
	}
    }
  if (code & 1)
    {
      Next = GetLeft(CurrentState,huff);
      /* if (Next != EmptyState)
	{
	  printf("Overflow on Huffman Table: Nonunique prefix.\n");
	  printf("Length: %d   Code: %d|%x  Value: %d|%x\n",
		 n,code,code,value,value);
	  exit(ERROR_BOUNDS);
	}
	*/
      SetLeft(MakeHVal(value),CurrentState,huff);
    }
  else
    {
      Next = GetRight(CurrentState,huff);
      /* if (Next != EmptyState)
	{
	  printf("Overflow on Huffman Table: Nonunique prefix.\n");
	  printf("Length: %d   Code: %d|%x  Value: %d|%x\n",
		 n,code,code,value,value);
	  exit(ERROR_BOUNDS);
	}
	*/
      SetRight(MakeHVal(value),CurrentState,huff);
    }
}

/*
** Function: PrintDHUFF()
** Purpose:  Prints out the decoder Huffman structure that is passed
**           into it.
*/
void PrintDhuff(DHUFF *huff)
{
  int i;

  printf("Modified Huffman Decoding Structure: %p\n",huff);
  printf("Number of states %d\n",huff->NumberStates);
  for(i=0;i<huff->NumberStates;i++)
    {
      printf("State: %d  Left State: %x  Right State: %x\n",
	     i,
	     GetLeft(i,huff),
	     GetRight(i,huff));
    }
}

/*
** Function: PrintEhuff()
** Purpose:  Prints the encoder Huffman structure passed into it.
*/
void PrintEhuff(EHUFF *huff)
{
  BEGIN("PrintEhuff");
  int i;

  printf("Modified Huffman Encoding Structure: %p\n",huff);
  printf("Number of values %d\n",huff->n);
  for(i=0;i<huff->n;i++)
    {
      if (huff->Hlen[i]>=0)
	{
	  printf("Value: %x  Length: %d  Code: %x\n",
	     i,huff->Hlen[i],huff->Hcode[i]);
	}
    }
}

/*
** Function: PrintTable()
** Purpose:  Prints out 256 elements in a nice byte ordered fashion.
*/
void PrintTable(int *table)
{
  int i,j;

  for(i=0;i<16;i++)
    {
      for(j=0;j<16;j++)
	{
	  printf("%2x ",*(table++));
	}
      printf("\n");
    }
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech261\jpeg.h ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: jpeg.h,v $
 * Revision 1.1.2.2  1995/12/07  19:35:59  Hans_Graves
 * 	Created under SLIB
 * 	[1995/12/07  19:34:59  Hans_Graves]
 *
 * $EndLog$
 */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

#ifndef _JPEG_H_
#define _JPEG_H_

/************** MPEG 1 parsing definitions **************/
#define JPEG_MARKER                  0xFF
#define JPEG_MARKER_LEN              8
#define JPEG_SOF0                    0xC0 /* Baseline DCT */
#define JPEG_SOF1                    0xC1 /* Extended sequential DCT */
#define JPEG_SOF2                    0xC2 /* Progressive DCT */
#define JPEG_SOF3                    0xC3 /* Lossless (sequential) */

#endif _JPEG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech261\init.c ===
/* File: sv_h261_init.c */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1994, 1997                 **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

/*
#define _SLIBDEBUG_
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "SC_err.h"
#include "sv_intrn.h"
#include "sv_h261.h"
#include "proto.h"
#include "sv_proto.h"

#ifdef WIN32
#include <mmsystem.h>
#endif

#ifdef _SLIBDEBUG_
#define _DEBUG_    0  /* detailed debuging statements */
#define _VERBOSE_  0  /* show progress */
#define _VERIFY_   1  /* verify correct operation */
#define _WARN_     1  /* warnings about strange behavior */
#endif

/*
** Name:    sv_InitH261
** Purpose: Initalize fields for compression or decompression.
**
** Note:    XXX - This version is hardcode to handle 4:2:2 subsampling
**                eg. the calculation of numMCU
*/
SvStatus_t svH261Init(SvCodecInfo_t *Info)
{
    SvH261Info_t *H261;

    if (!Info || !Info->h261)
      return (SvErrorMemory);
    H261=Info->h261;
    if (H261->inited)
      return(SvErrorNone);

    H261->YWidth = Info->Width;
    H261->YHeight = Info->Height;
    H261->PICSIZE = Info->Width*Info->Height;
    H261->PICSIZEBY4 = Info->h261->PICSIZE>>2;
/* common  - compression & decompression */
    H261->C_U_Frames=0;
    H261->CodedFrames=0;
    H261->TemporalReference=1;
    H261->TemporalOffset = 0;
    H261->PType=0x0;
    H261->Type2=0x0;
    H261->MType=0x0;
    H261->GQuant=8;
    H261->MQuant=8;
    H261->ParityEnable=0;
    H261->PSpareEnable=0;
    H261->GSpareEnable=0;
    H261->Parity=0;
    H261->PSpare=0;
    H261->GSpare=0;
    H261->NumberMDU=0;
    H261->CurrentMDU=0;
    H261->NumberGOB=0;
    H261->CurrentGOB=0;
    H261->CurrentFrame=0;
    H261->StartFrame = 0;
    H261->LastFrame=0;
    H261->PreviousFrame = 0;
    H261->NumberFrames=0;
    H261->TransmittedFrames=0;
    H261->InitialQuant=0;
/* compression */
    H261->MVDH=0;
    H261->MVDV=0;
    H261->CBP=0x3f;
    H261->CBPThreshold = 1;
    H261->VAR = 0;
    H261->VAROR = 0;
    H261->MWOR=0;
    H261->LastMVDV=0;
    H261->LastMVDH=0;
    H261->GRead=0;
    H261->MBA=0;
    H261->LastMBA=0;
    H261->LastMType=0;
    H261->FrameSkip=1;
    /* these are initialized by sv_api.c */
    /* H261->ME_search = 5;
    H261->ME_method = ME_FASTEST;
    H261->ME_threshold = 600;
    H261->frame_rate=(float)30.0F;
    H261->bit_rate=0;
    */
    H261->FileSizeBits=0;
    H261->BufferOffset=0;
    H261->QDFact=1;
    H261->QUpdateFrequency=11;
    H261->QUse=0;
    H261->QSum=0;
    H261->CBPThreshold=1;
    H261->ForceCIF=0;
    H261->NumberNZ=0;
    H261->FirstFrameBits=0;
    H261->NumberOvfl=0;
    H261->YCoefBits=0;
    H261->UCoefBits=0;
    H261->VCoefBits=0;
    H261->ForceCIF = 1;
/* decompression */
    H261->NumberNZ = 0;
    H261->TemporalReference=1;
    H261->TemporalOffset=0;
    H261->PType=0x0;
    H261->Type2=0x0;
    H261->MType=0x0;
    H261->GQuant=8;
    H261->MQuant=8;
    H261->MVDH=0;
    H261->MVDV=0;
    H261->VAR=0;
    H261->VAROR=0;
    H261->MWOR=0;
    H261->LastMVDV=0;
    H261->LastMVDH=0;
    H261->CBP=0x3f;
    H261->GRead=0;
    H261->MBA=0;
    H261->LastMBA=0;
    H261->ImageType=IT_NTSC;
    H261->LastMType=0;
    H261->CBPThreshold=1;  /* abs threshold before we use CBP */
    /* H261->ErrorValue=0;*/
    /* H261->Trace=NULL;*/
    H261->ForceCIF=0;
    H261->UseQuant = 8;
    if ((Info->h261->workloc=(unsigned int *)ScAlloc(512*sizeof(int)))
                       ==NULL)
      return(SvErrorMemory);
    sv_H261HuffInit(Info->h261);    /* Put Huffman tables on */
    H261->makekey = 0;    /* disable key-frame trigger */
    H261->inited=TRUE;
    return (NoErrors);
}

/*
** Name:    sv_InitH261Encoder
** Purpose: Prepare the encoder by loading default values
**
*/
SvStatus_t svH261CompressInit(SvCodecInfo_t *Info)
{
    SvH261Info_t *H261;
    SvStatus_t status;
    int i;

    if (!Info || !Info->h261)
      return (SvErrorMemory);
    H261=Info->h261;
    if (H261->inited)
      return(SvErrorNone);
    /* init common stuff */
    status=svH261Init(Info);
    if (status!=SvErrorNone)
      return(status);
    /*
     * Initialize size-related paramters
     */
    H261->YWidth = Info->Width;
    H261->YHeight = Info->Height;
    if (H261->YWidth == CIF_WIDTH && H261->YHeight == CIF_HEIGHT)
    {
      H261->ImageType = IT_CIF;
      H261->NumberGOB = 12;  /* Parameters for CIF design */
      H261->NumberMDU = 33;
      H261->PType=0x04;
    }
    else if (H261->YWidth == QCIF_WIDTH && H261->YHeight == QCIF_HEIGHT)
    {
      H261->ImageType = IT_QCIF;
      H261->NumberGOB = 3;  /* Parameters for QCIF design */
      H261->NumberMDU = 33;
      H261->PType=0x00;
    }
    else if (H261->YWidth == NTSC_WIDTH && H261->YHeight == NTSC_HEIGHT)
    {
      H261->ImageType = IT_NTSC;
      H261->NumberGOB = 10;  /* Parameters for NTSC design */
      H261->NumberMDU = 33;
      H261->PType=0x04;
      H261->PSpareEnable=1;
      H261->PSpare=0x8c;
    }
    else
    {
      H261->ImageType = 0;
      return (SvErrorUnrecognizedFormat);
    }
    H261->CWidth = H261->YWidth/2;
    H261->CHeight = H261->YHeight/2;
    H261->YW4  = H261->YWidth/4;
    H261->CW4  = H261->CWidth/4;
    H261->PICSIZE = H261->YWidth*H261->YHeight;
    H261->PICSIZEBY4 = H261->PICSIZE>>2;
    /*
     * Allocate memory
     */
    if ((H261->LastIntra = (unsigned char **)
            ScAlloc(H261->NumberGOB*sizeof(unsigned char *)))==NULL)
      return(SvErrorMemory);
    for(i=0; i<H261->NumberGOB; i++)
    {
      H261->LastIntra[i] = (unsigned char *)ScAlloc(H261->NumberMDU);
      if (H261->LastIntra[i]==NULL)
        return(SvErrorMemory);
      memset(H261->LastIntra[i],0,H261->NumberMDU);
    }
    if ((H261->YREF=(unsigned char *)ScAlloc(H261->PICSIZE))==NULL)
      return(SvErrorMemory);
    if ((H261->YRECON=(unsigned char *)ScAlloc(H261->PICSIZE))==NULL)
      return(SvErrorMemory);
    if ((H261->UREF=(unsigned char *)ScAlloc(H261->PICSIZEBY4))==NULL)
      return(SvErrorMemory);
    if ((H261->URECON=(unsigned char *)ScAlloc(H261->PICSIZEBY4))==NULL)
      return(SvErrorMemory);
    if ((H261->VREF=(unsigned char *)ScAlloc(H261->PICSIZEBY4))==NULL)
      return(SvErrorMemory);
    if ((H261->VRECON=(unsigned char *)ScAlloc(H261->PICSIZEBY4))==NULL)
      return (SvErrorMemory);
    if ((H261->Y=(unsigned char *)ScAlloc(H261->PICSIZE))==NULL)
      return(SvErrorMemory);
    if ((H261->U=(unsigned char *)ScAlloc(H261->PICSIZEBY4))==NULL)
      return(SvErrorMemory);
    if ((H261->V=(unsigned char *)ScAlloc(H261->PICSIZEBY4))==NULL)
      return(SvErrorMemory);
    if ((H261->YDEC=(unsigned char *)ScAlloc(H261->PICSIZE))==NULL)
      return(SvErrorMemory);
    if ((H261->UDEC=(unsigned char *)ScAlloc(H261->PICSIZEBY4))==NULL)
      return(SvErrorMemory);
    if ((H261->VDEC=(unsigned char *)ScAlloc(H261->PICSIZEBY4))==NULL)
      return(SvErrorMemory);
 
    if (H261->extbitstream) 
    {
      H261->RTPInfo = (SvH261RTPInfo_t *) ScAlloc(sizeof(SvH261RTPInfo_t));
      if (H261->RTPInfo==NULL)
        return(SvErrorMemory);
      memset(H261->RTPInfo, 0, sizeof(SvH261RTPInfo_t)) ;
    }
    H261->PBUFF = 3;
    H261->PBUFF_Factor = 3;
    H261->CodeLength = 100;
    H261->TotalByteOffset = 0;
    H261->TotalMB[0] = 0;
    H261->TotalMB[1] = 0;
    H261->SkipMB = 0;
    H261->MBBits[0] = 0;
    H261->MBBits[1] = 0;
    if (H261->frame_rate>0)
      H261->NBitsPerFrame = (int)((float)H261->bit_rate/H261->frame_rate);
    else
      H261->NBitsPerFrame = 0;
    H261->Buffer_All = H261->PBUFF*H261->NBitsPerFrame;
    H261->BitsLeft = H261->Buffer_All;
    H261->MAX_MQUANT = 31;
    H261->MIN_MQUANT = 4;
    H261->alpha1 = 4.5;
    H261->alpha2 = 2.5;
    H261->LowerQuant = 0;
    H261->LowerQuant_FIX = 0;
    H261->FineQuant = 0;
    H261->ZBDecide = 30.0;
    H261->MSmooth = 1;

    if(H261->frame_rate==30)
        H261->MIN_MQUANT += 2;
    H261->ActThr2 = ACTIVE_THRESH;
    H261->ActThr = ACTIVE_THRESH;
    H261->ActThr5 = H261->ActThr2;
    H261->ActThr6 = H261->ActThr;

#if 0
    if (H261->bit_rate > 300000)
#else                                 
    if ((H261->bit_rate > 300000) ||    /* for VBR */
	    (H261->bit_rate == 0 && H261->QP < 10))
#endif
    {
        H261->ActThr4 = ACTIVE_THRESH*24/32;
        H261->ActThr2 = H261->ActThr4;
        H261->ActThr = H261->ActThr2;
        H261->LowerQuant_FIX=12;
        H261->FineQuant = 0;
        H261->ZBDecide = 30.0;
        H261->CBPThreshold = 2;
        H261->MSmooth = 2;
        H261->PBUFF=3;
    }
#if 0
    if (H261->frame_rate < 20)
#else
    if ((H261->frame_rate < 20) ||        /* for VBR */
	    (H261->bit_rate == 0 && H261->QP > 30))
#endif
    {
        H261->ActThr3 = ACTIVE_THRESH*23/40;
        H261->LowerQuant_FIX=12;
    }
#if 0
    if (H261->bit_rate<128001)
#else
    if ((H261->bit_rate<128001) ||         /* for VBR */
	    (H261->bit_rate == 0 && H261->QP > 20))
#endif
    {
        H261->ActThr2 = ACTIVE_THRESH;
        H261->ActThr  = ACTIVE_THRESH;
        H261->ActThr5 = H261->ActThr2;
        H261->ActThr6 = H261->ActThr;
        H261->ZBDecide = 32.0;
        H261->PBUFF=3;
        H261->FineQuant = 0;
        H261->MSmooth = 3;
        H261->CBPThreshold = 1;
    }
#if 0
    if(H261->bit_rate<70001)
#else
    if ((H261->bit_rate<70001) ||         /* for VBR */
	    (H261->bit_rate == 0 && H261->QP > 28))
#endif
    {
        H261->ActThr2 = ACTIVE_THRESH;
        H261->ActThr  = ACTIVE_THRESH;
        H261->ActThr5 = H261->ActThr2;
        H261->ActThr6 = H261->ActThr;
        H261->ZBDecide = 36.0;
        H261->FineQuant = 0;
        H261->PBUFF=4;
        H261->PBUFF_Factor=4;
        H261->MSmooth = 4;
        H261->CBPThreshold = 1;
    }
    /* ndef WIN32 */
    if(H261->bit_rate) {	    /* CBR */
      if(H261->NBitsPerFrame < 31000)
  	     H261->GQuant = (31 - (int)H261->NBitsPerFrame/1000);
	  else  
	     H261->GQuant = 1;
	}
	else
      H261->GQuant = H261->QPI; /* VBR */

    H261->InitialQuant = H261->GQuant;
    memset(H261->CBPFreq, 0, sizeof(H261->CBPFreq));
    GenScaleMat();

    if (H261->FileSizeBits)  /* Rate is determined by bits/second. */
       H261->bit_rate=(int)(H261->FileSizeBits*H261->frame_rate)/
        (H261->FrameSkip*(H261->LastFrame-H261->CurrentFrame+1));

    if (H261->bit_rate)
    {
      H261->QDFact = (H261->bit_rate/320);
      H261->QOffs = 1;
    }
    H261->GQuant=H261->MQuant=H261->InitialQuant;
    H261->BufferOffset=0;
    H261->TotalBits=0;
    H261->NumberOvfl=0;
    H261->FirstFrameBits=0;
    H261->TransmittedFrames=0;
    H261->QDFact = 1;
    H261->QOffs= 1;
    H261->QUpdateFrequency = 11;
    return (NoErrors);
}


SvStatus_t svH261SetParamInt(SvHandle_t Svh, SvParameter_t param, 
                                qword value)
{
  SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;
  if (!Svh)
    return(SvErrorCodecHandle);
  if (Info->mode == SV_H261_DECODE)
    switch (param)
    {
      case SV_PARAM_QUALITY:
             if (value>99)
               Info->h261->quality=99;
             else if (value<0)
               Info->h261->quality=0;
             else
               Info->h261->quality=(int)value;
             break;
      case SV_PARAM_DEBUG:
             Info->h261->dbg=(void *)value;
             break;
    }
  else if (Info->mode == SV_H261_ENCODE)
    switch (param)
    {
      case SV_PARAM_MOTIONALG:
             Info->h261->ME_method=(int)value;
             return(SvErrorNone);
      case SV_PARAM_MOTIONSEARCH:
             Info->h261->ME_search=(int)value;
             break;
      case SV_PARAM_MOTIONTHRESH:
             Info->h261->ME_threshold=(int)value;
             break;
      case SV_PARAM_BITRATE:
             if (value>=0)
               Info->h261->bit_rate = (int)value;
             break;
      case SV_PARAM_QUALITY:
             if (value>99)
               Info->h261->quality=99;
             else if (value<0)
               Info->h261->quality=0;
             else
               Info->h261->quality=(int)value;
             break;
      case SV_PARAM_DEBUG:
             Info->h261->dbg=(void *)value;
             break;
      case SV_PARAM_FORMATEXT:
             Info->h261->extbitstream = (int)value;
             return(SvErrorNone);
      case SV_PARAM_PACKETSIZE:
             Info->h261->packetsize = (int)value * 8;
             break;
      case SV_PARAM_QUANTI:              /* for VBR */
             Info->h261->QPI = (int)value;
             break;
      case SV_PARAM_QUANTP:				 /* for VBR */
             Info->h261->QP = (int)value;
             break;
      case SV_PARAM_KEYSPACING:
             break;
      case SV_PARAM_FRAMETYPE:
             if (value==FRAME_TYPE_I)
               Info->h261->makekey = 1;    /* send key-frame */
             return(SvErrorNone);
  }
  return(SvErrorNone);
}

SvStatus_t svH261SetParamFloat(SvHandle_t Svh, SvParameter_t param, 
                                float value)
{
  SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;
  if (!Svh)
    return(SvErrorCodecHandle);
  if (Info->mode == SV_H261_ENCODE)
    switch (param)
    {
      case SV_PARAM_FPS:
             if (value<1.0)
               Info->h261->frame_rate = 1.0F;
             else if (value>30.0)
               Info->h261->frame_rate = 30.0F;
             else
               Info->h261->frame_rate = value;
             Info->h261->FrameRate_Fix=(int)(Info->h261->frame_rate+0.5);
             _SlibDebug(_DEBUG_,
                  printf("frame_rate = %f\n", Info->h261->frame_rate) );
             return(SvErrorNone);
    }
  return(svH261SetParamInt(Svh, param, (long)value));
}

qword svH261GetParamInt(SvHandle_t Svh, SvParameter_t param)
{
  SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;

  if (!Svh)
    return((qword)0);
  if (Info->mode == SV_H261_ENCODE)
    switch (param)
    {
      case SV_PARAM_BITRATE:
            return((qword)Info->h261->bit_rate);
      case SV_PARAM_FPS:
            return((qword)svH261GetParamFloat(Svh, param));
      case SV_PARAM_QUALITY:
            return((qword)Info->h261->quality);
      case SV_PARAM_NATIVEFORMAT:
            return((qword)BI_YU12SEP);
      case SV_PARAM_FINALFORMAT:
            return((qword)BI_YU12SEP);
      case SV_PARAM_ALGFLAGS:
             {
               qword flags=0;
               /* flags|=Info->h261->extbitstream ? PARAM_ALGFLAG_EXTBS : 0; */
               return(flags);
             }
             break;
      case SV_PARAM_PACKETSIZE:
            return((qword)Info->h261->packetsize/8);
      case SV_PARAM_MOTIONALG:
            return((qword)Info->h261->ME_method);
      case SV_PARAM_MOTIONSEARCH:
            return((qword)Info->h261->ME_search);
      case SV_PARAM_MOTIONTHRESH:
            return((qword)Info->h261->ME_threshold);
    }
  else if (Info->mode == SV_H261_DECODE)
    switch (param)
    {
      case SV_PARAM_BITRATE:
            return((qword)Info->h261->bit_rate);
      case SV_PARAM_FPS:
            return((qword)svH261GetParamFloat(Svh, param));
      case SV_PARAM_WIDTH:
            return((qword)Info->h261->YWidth);
      case SV_PARAM_HEIGHT:
            return((qword)Info->h261->YHeight);
      case SV_PARAM_FRAME:
            return((qword)Info->h261->CurrentFrame);
      case SV_PARAM_NATIVEFORMAT:
            return((qword)BI_YU12SEP);
      case SV_PARAM_FINALFORMAT:
            return((qword)BI_YU12SEP);
      case SV_PARAM_QUALITY:
            return((qword)Info->h261->quality);
    }
  return((qword)0);
}

float svH261GetParamFloat(SvHandle_t Svh, SvParameter_t param)
{
  SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;

  if (!Svh)
    return((float)0.0);
  if (Info->mode == SV_H261_ENCODE)
    switch (param)
    {
      case SV_PARAM_FPS:
            return((float)Info->h261->frame_rate);
    }
  else if (Info->mode == SV_H261_DECODE)
    switch (param)
    {
      case SV_PARAM_FPS:
            return((float)Info->h261->frame_rate);
    }
  return((float)svH261GetParamInt(Svh, param));
}

SvStatus_t svH261SetParamBoolean(SvHandle_t Svh, SvParameter_t param,
                                                  ScBoolean_t value)
{
  SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;

  if (!Svh)
    return(0);
#if 0
  if (Info->mode == SV_H261_ENCODE)
    switch (param)
    {
    }
#endif
  return(SvErrorNone);
}

ScBoolean_t svH261GetParamBoolean(SvHandle_t Svh, SvParameter_t param)
{
  SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;

  if (!Svh)
    return(0);
  if (Info->mode == SV_H261_ENCODE)
    switch (param)
    {
      case SV_PARAM_BITSTREAMING:
                    return(TRUE);
    }
  else if (Info->mode == SV_H261_DECODE)
    switch (param)
    {
      case SV_PARAM_BITSTREAMING:
                    return(TRUE);
    }
  return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech261\idct.c ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: sc_idct.c,v $
 * Revision 1.1.4.3  1996/03/20  22:32:42  Hans_Graves
 * 	Moved ScScaleIDCT8x8i_C to sc_idct_scaled.c
 * 	[1996/03/20  22:13:55  Hans_Graves]
 *
 * Revision 1.1.4.2  1996/03/08  18:46:17  Hans_Graves
 * 	Changed ScScaleIDCT8x8i_C() back to 20-bit
 * 	[1996/03/08  18:31:42  Hans_Graves]
 * 
 * Revision 1.1.2.6  1996/02/21  22:52:40  Hans_Graves
 * 	Changed precision of ScScaleIDCT8x8i_C() from 20 to 19 bits
 * 	[1996/02/21  22:45:34  Hans_Graves]
 * 
 * Revision 1.1.2.5  1996/01/26  19:01:34  Hans_Graves
 * 	Fix bug in ScScaleIDCT8x8i_C()
 * 	[1996/01/26  18:59:08  Hans_Graves]
 * 
 * Revision 1.1.2.4  1996/01/24  19:33:15  Hans_Graves
 * 	Optimization of ScScaleIDCT8x8i_C
 * 	[1996/01/24  18:09:55  Hans_Graves]
 * 
 * Revision 1.1.2.3  1996/01/08  20:19:31  Bjorn_Engberg
 * 	Removed unused local variable to get rid of a warning on NT.
 * 	[1996/01/08  20:17:34  Bjorn_Engberg]
 * 
 * Revision 1.1.2.2  1996/01/08  16:41:17  Hans_Graves
 * 	Moved IDCT routines from sc_dct.c
 * 	[1996/01/08  15:30:46  Hans_Graves]
 * 
 * $EndLog$
 */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/
/*
** Filename: sc_idct.c
** Inverse DCT related functions.
*/


/*
#define _SLIBDEBUG_
*/

#include <math.h>
#include "SC.h"

#ifdef _SLIBDEBUG_
#define _DEBUG_   1  /* detailed debuging statements */
#define _VERBOSE_ 1  /* show progress */
#define _VERIFY_  1  /* verify correct operation */
#define _WARN_    1  /* warnings about strange behavior */
#endif

#define F (float)
#define RSQ2    F 0.7071067811865
#define COSM1P3 F 1.3065629648764
#define COS1M3  F 0.5411961001462
#define COS3    F 0.3826834323651

#define Point 14

/*
** Name:      ScIDCT8x8
** Purpose:   2-d Inverse DCT.  Customized for (8x8) blocks
**
** Note:      This scheme uses the direct transposition of the forward
**            DCT. This may not be the preferred way in Hardware
**            Implementations
**
** Reference: FEIGs
**
*/
void ScIDCT8x8(int *outbuf)
{
        register int *outptr, itmp, *spptr, *interptr;
        register int t0, t1, t2, t3, t4, t5, t6, t7, tmp, mtmp;
        int i;
        static int tempptr[64];

        spptr    = outbuf;
        interptr = tempptr;

        /*
        ** Row Computations:
        */
        for (i = 0; i < 8; i++) {
           /*
           ** Check for zeros:
           */
           t0 = spptr[0];
                t1 = spptr[32];
                t2 = spptr[16];
                t3 = spptr[48];

                t4 = spptr[40];
                t5 = spptr[8];
                t6 = spptr[56];
                t7 = spptr[24];

                if (!(t1|t2|t3|t4|t5|t6|t7))  {
                    interptr[0]  = t0;
                    interptr[1]  = t0;
                    interptr[2]  = t0;
                    interptr[3]  = t0;
                    interptr[4]  = t0;
                    interptr[5]  = t0;
                    interptr[6]  = t0;
                    interptr[7]  = t0;
                    interptr += 8;
                }
                else {
                /* Compute B1-t P'     */
                tmp  = t4;
                t4  -= t7;
                t7  += tmp;

                tmp = t6;
                t6  = t5 -t6;
                t5 += tmp;

                /* Compute B2-t  */
                tmp = t3;
                t3 += t2;
                t2 -= tmp;

                tmp = t7;
                t7 += t5;
                t5 -= tmp;

                /* Compute M  */
                tmp = t2 + (t2 >> 2);
                tmp += (tmp >> 3);
                t2 = (tmp + (t2 >> 7)) >> 1;

                tmp = t5 + (t5 >> 2);
                tmp += (tmp >> 3);
                t5 = (tmp + (t5 >> 7)) >> 1;

                tmp = t6 - t4;
                mtmp = tmp + (tmp >> 1) + (tmp >> 5) - (tmp >> 11);
                tmp = mtmp >> 2;

                mtmp = t4 + (t4 >> 2) + (t4 >> 4) - (t4 >> 7) + (t4 >> 9);
                t4 = -mtmp - tmp;

                mtmp = (t6 + (t6 >> 4) + (t6 >> 6) + (t6 >> 8)) >> 1;
                t6 = mtmp + tmp;

                /* Compute A1-t  */
                tmp = t0;
                t0 += t1;
                t1  = tmp - t1;
                t3  = t2 + t3;

                /* Compute A2-t  */
                tmp = t0;
                t0 += t3;
                t3  = tmp - t3;

                tmp = t1;
                t1 += t2;
                t2  = tmp - t2;

                t7 += t6;
                t6 += t5;
                t5 -= t4;

                /* Compute A3-t  */
                 interptr[0]  = t0 + t7;
                interptr[1]  = t1 + t6;
                interptr[2]  = t2 + t5;
                interptr[3]  = t3 - t4;  /* Note in the prev. stage no
                                            t4 = -t4  */
                interptr[4]  = t3 + t4;
                interptr[5]  = t2 - t5;
                interptr[6]  = t1 - t6;
                interptr[7]  = t0 - t7;
                interptr += 8;
                }
                spptr++;
        }

        spptr = tempptr;
        outptr = outbuf;

        /*
        ** Column Computations
        */
        for (i = 0; i < 8; i++) {
                /* Check for zeros  */
                t0 = spptr[0];
                t1 = spptr[32];
                t2 = spptr[16];
                t3 = spptr[48];

                t4 = spptr[40];
                t5 = spptr[8];
                t6 = spptr[56];
                t7 = spptr[24];

                if (!(t1|t2|t3|t4|t5|t6|t7))  {
                     itmp = (t0 >> Point) + 128;
                     outptr[0]  = itmp;
                     outptr[1]  = itmp;
                     outptr[2]  = itmp;
                     outptr[3]  = itmp;
                     outptr[4]  = itmp;
                     outptr[5]  = itmp;
                     outptr[6]  = itmp;
                     outptr[7]  = itmp;
                     outptr += 8;
                }
                else
                {
                /* Compute B1-t P'     */
                tmp = t4;
                t4  -= t7;
                t7  += tmp;

                tmp = t6;
                t6  = t5 -t6;
                t5 += tmp;

                /* Compute B2-tilde  */
                tmp = t3;
                t3 += t2;
                t2 -= tmp;

                tmp = t7;
                t7 += t5;
                t5 -= tmp;

                /* Compute M-Tilde  */
                tmp = t2 + (t2 >> 2);
                tmp += (tmp >> 3);
                t2 = (tmp + (t2 >> 7)) >> 1;

                tmp = t5 + (t5 >> 2);
                tmp += (tmp >> 3);
                t5 = (tmp + (t5 >> 7)) >> 1;

                tmp = t6 - t4;
                mtmp = tmp + (tmp >> 1) + (tmp >> 5) - (tmp >> 11);
                tmp = mtmp >> 2;

                mtmp = t4 + (t4 >> 2) + (t4 >> 4) - (t4 >> 7) + (t4 >> 9);
                t4 = -mtmp - tmp;

                mtmp = (t6 + (t6 >> 4) + (t6 >> 6) + (t6 >> 8)) >> 1;
                t6 = mtmp + tmp;

                /* Compute A1-t  */
                tmp = t0;
                t0 += t1;
                t1  = tmp - t1;
                t3  = t2 + t3;

                /* Compute A2-t  */
                tmp = t0;
                t0 += t3;
                t3  = tmp - t3;

                tmp = t1;
                t1 += t2;
                t2  = tmp - t2;

                t7 += t6;
                t6 += t5;
                t5 -= t4;

                /* Compute A3-t  */

                outptr[0]  = ((t0 + t7) >> Point) + 128;
                outptr[1]  = ((t1 + t6) >> Point) + 128;
                outptr[2]  = ((t2 + t5) >> Point) + 128;
                outptr[3]  = ((t3 - t4) >> Point) + 128;
                outptr[4]  = ((t3 + t4) >> Point) + 128;
                outptr[5]  = ((t2 - t5) >> Point) + 128;
                outptr[6]  = ((t1 - t6) >> Point) + 128;
                outptr[7]  = ((t0 - t7) >> Point) + 128;

                outptr += 8;
                }
                spptr++;
        }
}


/*
** Function: ScScaleIDCT8x8
** Note:     This scheme uses the direct transposition of the forward
**           DCT.  This may not be the preferred way in Hardware 
**           Implementations
*/
void ScScaleIDCT8x8_C(float *ipbuf, int *outbuf)
{
  int i;
  int *outptr;
  register int itmp;
  register float t0, t1, t2, t3, t4, t5, t6, t7, tmp;
  float *spptr, *interptr;
  float tempptr[64];

  spptr = ipbuf;
  interptr = tempptr;

  /* Perform Row Computations  */
  for (i=0; i<8; i++)
  {
    /* Check for zeros  */
    t0 = spptr[0];
    t1 = spptr[4];
    t2 = spptr[2];
    t3 = spptr[6];

    t4 = spptr[5];
    t5 = spptr[1];
    t6 = spptr[7];
    t7 = spptr[3];

    if (!(t1||t2||t3||t4||t5||t6||t7))
    {
      interptr[0]  = t0;
      interptr[8]  = t0;
      interptr[16] = t0;
      interptr[24] = t0;
      interptr[32] = t0;
      interptr[40] = t0;
      interptr[48] = t0;
      interptr[56] = t0;
    }
    else
    {
      /* Compute B1-t P'     */
      tmp = t4;
      t4  -= t7;
      t7  += tmp;

      tmp = t6;
      t6  = t5 -t6;
      t5 += tmp;

      /* Compute B2-t  */
      tmp = t3;
      t3 += t2;
      t2 -= tmp;

      tmp = t7;
      t7 += t5;
      t5 -= tmp;

      /* Compute M  */
      t2  = t2*RSQ2;
      t5  = t5*RSQ2;
      tmp = (t6 - t4)*COS3;
      t4  = -t4*COSM1P3 - tmp;
      t6  = COS1M3*t6 + tmp;

      /* Compute A1-t  */
      tmp = t0;
      t0 += t1;
      t1  = tmp - t1;
      t3  = t2 + t3;

      /* Compute A2-t  */
      tmp = t0;
      t0 += t3;
      t3  = tmp - t3;

      tmp = t1;
      t1 += t2;
      t2  = tmp - t2;

      t7 += t6;
      t6 += t5;
      t5 -= t4;

      /* Compute A3-t  */
      interptr[0]  = t0 + t7;
      interptr[56] = t0 - t7;
      interptr[8]  = t1 + t6;
      interptr[48] = t1 - t6;
      interptr[16] = t2 + t5;
      interptr[40] = t2 - t5;
      interptr[24] = t3 - t4;  /* Note in the prev. stage no
                                            t4 = -t4  */
      interptr[32] = t3 + t4;
    }
    spptr  += 8;
    interptr++;
  }

  spptr = tempptr;
  outptr = outbuf;

  /* Perform Column Computations  */
  for (i=0; i<8; i++)
  {
    /* Check for zeros  */
    t0 = spptr[0];
    t1 = spptr[4];
    t2 = spptr[2];
    t3 = spptr[6];

    t4 = spptr[5];
    t5 = spptr[1];
    t6 = spptr[7];
    t7 = spptr[3];

    if (!(t1||t2||t3||t4||t5||t6||t7))
    {
      itmp = (int) (t0);
      outptr[0]  = itmp;
      outptr[8]  = itmp;
      outptr[16] = itmp;
      outptr[24] = itmp;
      outptr[32] = itmp;
      outptr[40] = itmp;
      outptr[48] = itmp;
      outptr[56] = itmp;
    }
    else
    {
      /* Compute B1-t P'     */
      tmp = t4;
      t4  -= t7;
      t7  += tmp;

      tmp = t6;
      t6  = t5 -t6;
      t5 += tmp;

      /* Compute B2-tilde  */
      tmp = t3;
      t3 += t2;
      t2 -= tmp;

      tmp = t7;
      t7 += t5;
      t5 -= tmp;

      /* Compute M-Tilde  */
      t2  = t2*RSQ2 ;
      t5  = t5*RSQ2 ;
      tmp = (t6 - t4)*COS3;
      t4  = -t4*COSM1P3 - tmp;
      t6  = COS1M3*t6 + tmp ;

      /* Compute A1-t  */
      tmp = t0;
      t0 += t1;
      t1  = tmp - t1;
      t3  = t2 + t3;

      /* Compute A2-t  */
      tmp = t0;
      t0 += t3;
      t3  = tmp - t3;
      tmp = t1;
      t1 += t2;
      t2  = tmp - t2;

      t7 += t6;
      t6 += t5;
      t5 -= t4;

      /* Compute A3-t  */
      outptr[0]  = (int)(t0+t7);
      outptr[56] = (int)(t0-t7);
      outptr[8]  = (int)(t1+t6);
      outptr[48] = (int)(t1-t6);
      outptr[16] = (int)(t2+t5);
      outptr[40] = (int)(t2-t5);
      outptr[24] = (int)(t3-t4);
      outptr[32] = (int)(t3+t4);
    }
    outptr++;
    spptr  += 8;
  }
}

/*
** Function: ScIDCT8x8s
** Note:     This scheme uses the direct transposition of the forward
**           DCT.  This may not be the preferred way in Hardware 
**           Implementations
*/
#define W1 2841 /* 2048*sqrt(2)*cos(1*pi/16) */
#define W2 2676 /* 2048*sqrt(2)*cos(2*pi/16) */
#define W3 2408 /* 2048*sqrt(2)*cos(3*pi/16) */
#define W5 1609 /* 2048*sqrt(2)*cos(5*pi/16) */
#define W6 1108 /* 2048*sqrt(2)*cos(6*pi/16) */
#define W7 565  /* 2048*sqrt(2)*cos(7*pi/16) */

#define IDCTSHIFTR  8
#define IDCTSHIFTC  (14+0)
#if 1
#define limit(var, min, max)  (var<=min ? min : (var>=max ? max : var))
#else
#define limit(var, min, max)  var
#endif

void ScIDCT8x8s_C(short *inbuf, short *outbuf)
{
  int i;
  register tmp0, tmp1, tmp2, tmp3, x0, x1, x2, x3, x4, x5, x6, x7, x8;
  register short *inblk, *outblk;
  register int *tmpblk;
  int tmpbuf[64];

  inblk = inbuf;
  tmpblk = tmpbuf;
  for (i=0; i<8; i++, inblk+=8, tmpblk+=8)
  {
    x0 = inblk[0];
    x1 = inblk[4];
    x1 = x1<<11;
    x2 = inblk[6];
    x3 = inblk[2];
    x4 = inblk[1];
    x5 = inblk[7];
    x6 = inblk[5];
    x7 = inblk[3];
    if (!(x1 | x2 | x3 | x4 | x5 | x6 | x7))
    {
      tmpblk[0]=tmpblk[1]=tmpblk[2]=tmpblk[3]=tmpblk[4]=tmpblk[5]=tmpblk[6]=
        tmpblk[7]=x0<<3;
    }
    else
    {
      tmp0 = x4 + x5;
      tmp0 = W7*tmp0;
      x0 = x0<<11;
      x0 = x0 + 128;
      x8 = x0 + x1;
      tmp1 = x6 + x7;
      x0 = x0 - x1;
      tmp1 = W3*tmp1;
      tmp2 = (W2+W6)*x2;
      tmp3 = (W2-W6)*x3;
      x4 = (W1-W7)*x4;
      x5 = (W1+W7)*x5;
      x4 = tmp0 + x4;
      x1 = x3 + x2;
      x5 = tmp0 - x5;
      x1 = W6*x1;
      tmp0 = (W3-W5)*x6;
      x7 = (W3+W5)*x7;
      x2 = x1 - tmp2;
      x3 = x1 + tmp3;
      tmp0 = tmp1 - tmp0;
      x7 = tmp1 - x7;
      x1 = x4 + tmp0;
      x4 = x4 - tmp0;
      x6 = x5 + x7;    /* F */
      x5 = x5 - x7;    /* F */
      tmp0 = x4 + x5;
      tmp0 = 181*tmp0;
      x7 = x8 + x3;    /* F */
      tmp1 = x4 - x5;
      x8 = x8 - x3;    /* F */
      tmp1 = 181*tmp1;
      x3 = x0 + x2;    /* F */
      x0 = x0 - x2;    /* F */
      x2 = tmp0 + 128;
      x4 = tmp1 + 128;
      x2 = x2>>8;      /* F */
      x4 = x4>>8;      /* F */
      tmp0 = x7+x1;
      tmp0 = tmp0>>IDCTSHIFTR;
      tmp1 = x3+x2;
      tmp1 = tmp1>>IDCTSHIFTR;
      tmp2 = x0+x4;
      tmp2 = tmp2>>IDCTSHIFTR;
      tmp3 = x8+x6;
      tmp3 = tmp3>>IDCTSHIFTR;
      tmpblk[0] = tmp0;
      tmpblk[1] = tmp1;
      tmpblk[2] = tmp2;
      tmpblk[3] = tmp3;
      tmp0 = x8-x6;
      tmp0 = tmp0>>IDCTSHIFTR;
      tmp1 = x0-x4;
      tmp1 = tmp1>>IDCTSHIFTR;
      tmp2 = x3-x2;
      tmp2 = tmp2>>IDCTSHIFTR;
      tmp3 = x7-x1;
      tmp3 = tmp3>>IDCTSHIFTR;
      tmpblk[4] = tmp0;
      tmpblk[5] = tmp1;
      tmpblk[6] = tmp2;
      tmpblk[7] = tmp3;
    }
  }

  tmpblk = tmpbuf;
  outblk = outbuf;
  for (i=0; i<8; i++, tmpblk++, outblk++)
  {
    /* shortcut */
    x0 = tmpblk[8*0];
    x1 = tmpblk[4*8]<<8;
    x2 = tmpblk[6*8];
    x3 = tmpblk[2*8];
    x4 = tmpblk[1*8];
    x5 = tmpblk[7*8];
    x6 = tmpblk[5*8];
    x7 = tmpblk[3*8];
    if (!(x1 | x2 | x3 | x4 | x5 | x6 | x7))
    {
      tmp0=(x0+32)>>6;
      outblk[8*0]=outblk[8*1]=outblk[8*2]=outblk[8*3]=outblk[8*4]=outblk[8*5]=
       outblk[8*6]=outblk[8*7]=limit(tmp0, -256, 255);
    }
    else
    {
      x0 = tmpblk[8*0];
      tmp0 = x4+x5;
      x0 = x0<<8;
      tmp0 = W7*tmp0;
      x0 = x0 + 8192;
      tmp1 = x6+x7;
      tmp0 = tmp0 + 4;
      tmp1 = W3*tmp1;
      tmp1 = tmp1 + 4;
      x8 = x0 + x1;
      tmp2 = (W2+W6)*x2;
      x0 = x0 - x1;
      x1 = x3 + x2;
      x1 = W6*x1;
      tmp3 = (W2-W6)*x3;
      x1 = x1 + 4;
      x4 = (W1-W7)*x4;
      x4 = tmp0 + x4;
      x4 = x4>>3;
      x5 = (W1+W7)*x5;
      x2 = x1 - tmp2;
      x3 = x1 + tmp3;
      x6 = (W3-W5)*x6;
      x2 = x2>>3;
      x5 = tmp0 - x5;
      x5 = x5>>3;
      x6 = tmp1 - x6;
      x6 = x6>>3;
      x7 = (W3+W5)*x7;
      x7 = tmp1 - x7;
      x3 = x3>>3;
      x7 = x7>>3;
      x1 = x4 + x6;    /* F */
      x4 = x4 - x6;
      x6 = x5 + x7;    /* F */
      x5 = x5 - x7;    /* F */
      tmp1 = x4 + x5;
      x7 = x8 + x3;    /* F */
      tmp1 = 181*tmp1;
      x8 = x8 - x3;    /* F */
      x3 = x0 + x2;    /* F */
      tmp2 = x4 - x5;
      x0 = x0 - x2;    /* F */
      tmp2 = 181*tmp2;
      x2 = tmp1+128;
      x4 = tmp2+128;
      x2 = x2>>8;      /* F */
      x4 = x4>>8;      /* F */

      /* fourth stage */
      tmp0=x7+x1;
      tmp1=x3+x2;
      tmp0=tmp0>>IDCTSHIFTC;
      tmp2=x0+x4;
      tmp1=tmp1>>IDCTSHIFTC;
      tmp3=x8+x6;
      tmp2=tmp2>>IDCTSHIFTC;
      tmp3=tmp3>>IDCTSHIFTC;
      outblk[8*0] = limit(tmp0, -256, 255);
      outblk[8*1] = limit(tmp1, -256, 255);
      outblk[8*2] = limit(tmp2, -256, 255);
      outblk[8*3] = limit(tmp3, -256, 255);
      tmp0=x8-x6;
      tmp1=x0-x4;
      tmp0=tmp0>>IDCTSHIFTC;
      tmp2=x3-x2;
      tmp1=tmp1>>IDCTSHIFTC;
      tmp3=x7-x1;
      tmp2=tmp2>>IDCTSHIFTC;
      tmp3=tmp3>>IDCTSHIFTC;
      outblk[8*4] = limit(tmp0, -256, 255);
      outblk[8*5] = limit(tmp1, -256, 255);
      outblk[8*6] = limit(tmp2, -256, 255);
      outblk[8*7] = limit(tmp3, -256, 255);
    }
  }
}

#if 0
void ScIDCT8x8s_C(short *inbuf, short *outbuf)
{
  register int i, tmp, x0, x1, x2, x3, x4, x5, x6, x7, x8;
  register short *inblk, *outblk;
  register int *tmpblk;
  int tmpbuf[64];

  inblk = inbuf;
  tmpblk = tmpbuf;
  for (i=0; i<8; i++, inblk+=8, tmpblk+=8)
  {
    if (!((x1 = inblk[4]<<11) | (x2 = inblk[6]) | (x3 = inblk[2]) |
        (x4 = inblk[1]) | (x5 = inblk[7]) | (x6 = inblk[5]) | (x7 = inblk[3])))
    {
      tmpblk[0]=tmpblk[1]=tmpblk[2]=tmpblk[3]=tmpblk[4]=tmpblk[5]=tmpblk[6]=
        tmpblk[7]=inblk[0]<<3;
    }
    else
    {
      x0 = (inblk[0]<<11) + 128; /* for proper rounding in the fourth stage */

      /* first stage */
      x8 = W7*(x4+x5);
      x4 = x8 + (W1-W7)*x4;
      x5 = x8 - (W1+W7)*x5;
      x8 = W3*(x6+x7);
      x6 = x8 - (W3-W5)*x6;
      x7 = x8 - (W3+W5)*x7;

      /* second stage */
      x8 = x0 + x1;
      x0 -= x1;
      x1 = W6*(x3+x2);
      x2 = x1 - (W2+W6)*x2;
      x3 = x1 + (W2-W6)*x3;
      x1 = x4 + x6;
      x4 -= x6;
      x6 = x5 + x7;
      x5 -= x7;

      /* third stage */
      x7 = x8 + x3;
      x8 -= x3;
      x3 = x0 + x2;
      x0 -= x2;
      x2 = (181*(x4+x5)+128)>>8;
      x4 = (181*(x4-x5)+128)>>8;

      /* fourth stage */
      tmpblk[0] = (x7+x1)>>8;
      tmpblk[1] = (x3+x2)>>8;
      tmpblk[2] = (x0+x4)>>8;
      tmpblk[3] = (x8+x6)>>8;
      tmpblk[4] = (x8-x6)>>8;
      tmpblk[5] = (x0-x4)>>8;
      tmpblk[6] = (x3-x2)>>8;
      tmpblk[7] = (x7-x1)>>8;
    }
  }

  tmpblk = tmpbuf;
  outblk = outbuf;
  for (i=0; i<8; i++, tmpblk++, outblk++)
  {
    /* shortcut */
    if (!((x1 = (tmpblk[4*8]<<8)) | (x2 = tmpblk[6*8]) | (x3 = tmpblk[2*8]) |
          (x4 = tmpblk[1*8]) | (x5 = tmpblk[7*8]) | (x6 = tmpblk[5*8]) |
          (x7 = tmpblk[3*8])))
    {
      tmp=(tmpblk[8*0]+32)>>6;
      if (tmp<-256) tmp=-256; else if (tmp>255) tmp=255;
      outblk[8*0]=outblk[8*1]=outblk[8*2]=outblk[8*3]=outblk[8*4]=outblk[8*5]=
       outblk[8*6]=outblk[8*7]=tmp;
    }
    else
    {
      x0 = (tmpblk[8*0]<<8) + 8192;

      /* first stage */
      x8 = W7*(x4+x5) + 4;
      x4 = (x8+((W1-W7)*x4))>>3;
      x5 = (x8-((W1+W7)*x5))>>3;
      x8 = W3*(x6+x7) + 4;
      x6 = (x8-((W3-W5)*x6))>>3;
      x7 = (x8-((W3+W5)*x7))>>3;

      /* second stage */
      x8 = x0 + x1;
      x0 -= x1;
      x1 = W6*(x3+x2) + 4;
      x2 = (x1-((W2+W6)*x2))>>3;
      x3 = (x1+((W2-W6)*x3))>>3;
      x1 = x4 + x6;
      x4 -= x6;
      x6 = x5 + x7;
      x5 -= x7;

      /* third stage */
      x7 = x8 + x3;
      x8 -= x3;
      x3 = x0 + x2;
      x0 -= x2;
      x2 = ((181*(x4+x5))+128)>>8;
      x4 = ((181*(x4-x5))+128)>>8;

      /* fourth stage */
      outblk[8*0] = ((tmp=(x7+x1)>>14)<=-256 ? -256 : (tmp>=255 ? 255 : tmp));
      outblk[8*1] = ((tmp=(x3+x2)>>14)<=-256 ? -256 : (tmp>=255 ? 255 : tmp));
      outblk[8*2] = ((tmp=(x0+x4)>>14)<=-256 ? -256 : (tmp>=255 ? 255 : tmp));
      outblk[8*3] = ((tmp=(x8+x6)>>14)<=-256 ? -256 : (tmp>=255 ? 255 : tmp));
      outblk[8*4] = ((tmp=(x8-x6)>>14)<=-256 ? -256 : (tmp>=255 ? 255 : tmp));
      outblk[8*5] = ((tmp=(x0-x4)>>14)<=-256 ? -256 : (tmp>=255 ? 255 : tmp));
      outblk[8*6] = ((tmp=(x3-x2)>>14)<=-256 ? -256 : (tmp>=255 ? 255 : tmp));
      outblk[8*7] = ((tmp=(x7-x1)>>14)<=-256 ? -256 : (tmp>=255 ? 255 : tmp));
    }
  }
}
#endif
#if 0
/* row (horizontal) IDCT
 *
 *           7                       pi         1
 * dst[k] = sum c[l] * src[l] * cos( -- * ( k + - ) * l )
 *          l=0                      8          2
 *
 * where: c[0]    = 128
 *        c[1..7] = 128*sqrt(2)
 */
static void idctrow(short *inblk, short *outblk)
{
  int x0, x1, x2, x3, x4, x5, x6, x7, x8;
  /* shortcut */
  if (!((x1 = inblk[4]<<11) | (x2 = inblk[6]) | (x3 = inblk[2]) |
        (x4 = inblk[1]) | (x5 = inblk[7]) | (x6 = inblk[5]) | (x7 = inblk[3])))
  {
    outblk[0]=outblk[1]=outblk[2]=outblk[3]=outblk[4]=outblk[5]=outblk[6]=
      outblk[7]=inblk[0]<<3;
    return;
  }

  x0 = (inblk[0]<<11) + 128; /* for proper rounding in the fourth stage */

  /* first stage */
  x8 = W7*(x4+x5);
  x4 = x8 + (W1-W7)*x4;
  x5 = x8 - (W1+W7)*x5;
  x8 = W3*(x6+x7);
  x6 = x8 - (W3-W5)*x6;
  x7 = x8 - (W3+W5)*x7;

  /* second stage */
  x8 = x0 + x1;
  x0 -= x1;
  x1 = W6*(x3+x2);
  x2 = x1 - (W2+W6)*x2;
  x3 = x1 + (W2-W6)*x3;
  x1 = x4 + x6;
  x4 -= x6;
  x6 = x5 + x7;
  x5 -= x7;

  /* third stage */
  x7 = x8 + x3;
  x8 -= x3;
  x3 = x0 + x2;
  x0 -= x2;
  x2 = (181*(x4+x5)+128)>>8;
  x4 = (181*(x4-x5)+128)>>8;

  /* fourth stage */
  outblk[0] = (x7+x1)>>8;
  outblk[1] = (x3+x2)>>8;
  outblk[2] = (x0+x4)>>8;
  outblk[3] = (x8+x6)>>8;
  outblk[4] = (x8-x6)>>8;
  outblk[5] = (x0-x4)>>8;
  outblk[6] = (x3-x2)>>8;
  outblk[7] = (x7-x1)>>8;
}

/* column (vertical) IDCT
 *
 *             7                         pi         1
 * dst[8*k] = sum c[l] * src[8*l] * cos( -- * ( k + - ) * l )
 *            l=0                        8          2
 *
 * where: c[0]    = 1/1024
 *        c[1..7] = (1/1024)*sqrt(2)
 */
static void idctcol(short *inblk, short *outblk)
{
  int tmp, x0, x1, x2, x3, x4, x5, x6, x7, x8;

  /* shortcut */
  if (!((x1 = (inblk[8*4]<<8)) | (x2 = inblk[8*6]) | (x3 = inblk[8*2]) |
        (x4 = inblk[8*1]) | (x5 = inblk[8*7]) | (x6 = inblk[8*5]) |
        (x7 = inblk[8*3])))
  {
    tmp=(inblk[8*0]+32)>>6;
    if (tmp<-256) tmp=-256; else if (tmp>255) tmp=255;
    outblk[8*0]=outblk[8*1]=outblk[8*2]=outblk[8*3]=outblk[8*4]=outblk[8*5]=
     outblk[8*6]=outblk[8*7]=tmp;
    return;
  }

  x0 = (inblk[8*0]<<8) + 8192;

  /* first stage */
  x8 = W7*(x4+x5) + 4;
  x4 = (x8+(W1-W7)*x4)>>3;
  x5 = (x8-(W1+W7)*x5)>>3;
  x8 = W3*(x6+x7) + 4;
  x6 = (x8-(W3-W5)*x6)>>3;
  x7 = (x8-(W3+W5)*x7)>>3;

  /* second stage */
  x8 = x0 + x1;
  x0 -= x1;
  x1 = W6*(x3+x2) + 4;
  x2 = (x1-(W2+W6)*x2)>>3;
  x3 = (x1+(W2-W6)*x3)>>3;
  x1 = x4 + x6;
  x4 -= x6;
  x6 = x5 + x7;
  x5 -= x7;

  /* third stage */
  x7 = x8 + x3;
  x8 -= x3;
  x3 = x0 + x2;
  x0 -= x2;
  x2 = (181*(x4+x5)+128)>>8;
  x4 = (181*(x4-x5)+128)>>8;

  /* fourth stage */
  tmp=(x7+x1)>>14;
  outblk[8*0] = (tmp<=-256 ? -256 : (tmp>=255 ? 255 : tmp));
  tmp=(x3+x2)>>14;
  outblk[8*1] = (tmp<=-256 ? -256 : (tmp>=255 ? 255 : tmp));
  tmp=(x0+x4)>>14;
  outblk[8*2] = (tmp<=-256 ? -256 : (tmp>=255 ? 255 : tmp));
  tmp=(x8+x6)>>14;
  outblk[8*3] = (tmp<=-256 ? -256 : (tmp>=255 ? 255 : tmp));
  tmp=(x8-x6)>>14;
  outblk[8*4] = (tmp<=-256 ? -256 : (tmp>=255 ? 255 : tmp));
  tmp=(x0-x4)>>14;
  outblk[8*5] = (tmp<=-256 ? -256 : (tmp>=255 ? 255 : tmp));
  tmp=(x3-x2)>>14;
  outblk[8*6] = (tmp<=-256 ? -256 : (tmp>=255 ? 255 : tmp));
  tmp=(x7-x1)>>14;
  outblk[8*7] = (tmp<=-256 ? -256 : (tmp>=255 ? 255 : tmp));
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech261\idct_scl.c ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: sc_idct_scaled.c,v $
 * Revision 1.1.2.3  1996/04/03  21:41:08  Hans_Graves
 * 	Fix bug in 8x8 IDCT
 * 	[1996/04/03  21:40:19  Hans_Graves]
 *
 * Revision 1.1.2.2  1996/03/20  22:32:44  Hans_Graves
 * 	Moved ScScaleIDCT8x8i_C from sc_idct.c; Added 1x1,2x1,1x2,3x3,4x4,6x6
 * 	[1996/03/20  22:14:59  Hans_Graves]
 * 
 * $EndLog$
 */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/
/*
** Filename: sc_idct_scaled.c
** Scaled Inverse DCT related functions.
*/

/*
#define _SLIBDEBUG_
*/

#include <math.h>
#include "SC.h"

#ifdef _SLIBDEBUG_
#define _DEBUG_   1  /* detailed debuging statements */
#define _VERBOSE_ 1  /* show progress */
#define _VERIFY_  1  /* verify correct operation */
#define _WARN_    1  /* warnings about strange behavior */
#endif

#define USE_MUL          0  /* Use multiplies vs. shift and adds */
#define CHECK_FOR_ZEROS  1  /* check for zero rows/columns */

#define BSHIFT  10
#define B1      (759250125L>>(30-BSHIFT))
#define B3      B1
#define B2      (-1402911301L>>(30-BSHIFT))
#define B4      (581104888L>>(30-BSHIFT))
#define B5      (410903207L>>(30-BSHIFT))


#define POINT      20
#define POINTROUND (0x101 << (POINT - 1))

#define IDCTAdjust(val)  (((val + POINTROUND) >> POINT) - 128)

/*   printf("In: %d,%d\n", inbuf[0*8],inbuf[1*8]);
     printf("Out: %d,%d,%d,%d,%d,%d,%d,%d\n", inbuf[0*8],inbuf[1*8],
       inbuf[2*8],inbuf[3*8],inbuf[4*8],inbuf[5*8],inbuf[6*8],inbuf[7*8]);
  */

/* Function: ScScaleIDCT8x8i_C()
** Purpose:  Used by MPEG video decompression.
**           20 Bit precision.
*/
void ScScaleIDCT8x8i_C(int *inbuf, int *outbuf)
{
  register int *inblk;
  register int tmp1, tmp2, tmp3;
  register int x0, x1, x2, x3, x4, x5, x6, x7, x8;
  int i;
  _SlibDebug(_DEBUG_, printf("ScScaleIDCT8x8i_C()\n") );

  /* Perform Row Computations  */
  inblk = inbuf;
  for(i=0; i<8; i++)
  {
    /* Check for zeros  */
    x0 = inblk[0*8];
    x1 = inblk[1*8];
    x2 = inblk[2*8];
    x3 = inblk[3*8];
    x4 = inblk[4*8];
    x5 = inblk[5*8];
    x6 = inblk[6*8];
    x7 = inblk[7*8];
#if CHECK_FOR_ZEROS
    if(!(x1|x3|x5|x7))
    {
      if(!(x2|x6))
      {
        tmp1 = x0 + x4;
        tmp2 = x0 - x4;

        inblk[0*8] = tmp1;
        inblk[1*8] = tmp2;
        inblk[2*8] = tmp2;
        inblk[3*8] = tmp1;
        inblk[4*8] = tmp1;
        inblk[5*8] = tmp2;
        inblk[6*8] = tmp2;
        inblk[7*8] = tmp1;
      }
      else
      {
        /* Stage 2 */
        x8 = x2 - x6;
        x6 = x2 + x6;
        /* Stage 3 */
#if USE_MUL
        x2=(x8*B1)>>BSHIFT;
#else
        tmp1 = x8 + (x8 >> 2);  /* x2=x8*B1 */
        tmp1 += (tmp1 >> 3);
        x2 = (tmp1 + (x8 >> 7)) >> 1;
#endif
        /* Stage 5 */
        tmp1 = x0 - x4;
        x0 = x0 + x4;
        tmp2 = x2 + x6;
        /* Stage 6 */
        x6 = x0 - tmp2;
        x0 = x0 + tmp2;
        x4 = tmp1 + x2;
        x2 = tmp1 - x2;
        /* Final Stage */
        inblk[0*8] = x0;
        inblk[1*8] = x4;
        inblk[2*8] = x2;
        inblk[3*8] = x6;
        inblk[4*8] = x6;
        inblk[5*8] = x2;
        inblk[6*8] = x4;
        inblk[7*8] = x0;
      }
    }
    else
#endif
    {
      /* Stage 1 */
      tmp1 = x5 + x3;
      x5 = x5 - x3;
      tmp2 = x1 + x7;
      x7 = x1 - x7;
      /* Stage 2 */
      tmp3 = x2 - x6;
      x6 = x2 + x6;
      x3 = tmp2 + tmp1;
      x1 = tmp2 - tmp1;
      x8 = x7 - x5;
      /* Stage 3 */
#if USE_MUL
      x5=(x5*B2)>>BSHIFT;
      x1=(x1*B3)>>BSHIFT;
      x2=(tmp3*B1)>>BSHIFT;
      x7=(x7*B4)>>BSHIFT;
      x8=(x8*B5)>>BSHIFT;
#else
      x5 = x5 + (x5 >> 2) + (x5 >> 4) - (x5 >> 7) + (x5 >> 9); /* x5=x5*B2 */
      x5 = -x5;
      tmp1 = x1 + (x1 >> 2);  /* x1=x1*B3 */
      tmp1 += (tmp1 >> 3);
      x1 = (tmp1 + (x1 >> 7)) >> 1;
      tmp1 = tmp3 + (tmp3 >> 2);  /* x2=tmp3*B1 */
      tmp1 += (tmp1 >> 3);
      x2 = (tmp1 + (tmp3 >> 7)) >> 1;
      x7 = (x7 + (x7 >> 4) + (x7 >> 6) + (x7 >> 8)) >> 1; /* x7=x7*B4 */
      x8 = (x8 + (x8 >> 1) + (x8 >> 5) - (x8 >> 11)) >> 2; /* x8=x8*B5 */
#endif /* USE_MUL */
      /* Stage 4 */
      x5=x5 - x8;
      x7=x7 + x8;
      /* Stage 5  */
      tmp3 = x0 - x4;
      x0 = x0 + x4;
      tmp2 = x2 + x6;
      x3 = x3 + x7;
      x7 = x1 + x7;
      x1 = x1 - x5;
      /* Stage 6 */
      x6 = x0 - tmp2;
      x0 = x0 + tmp2;
      x4 = tmp3 + x2;
      x2 = tmp3 - x2;
      /* Final Stage */
      inblk[0*8] = x0 + x3;
      inblk[1*8] = x4 + x7;
      inblk[2*8] = x2 + x1;
      inblk[3*8] = x6 - x5;
      inblk[4*8] = x6 + x5;
      inblk[5*8] = x2 - x1;
      inblk[6*8] = x4 - x7;
      inblk[7*8] = x0 - x3;
    }
    inblk++;
  }

  /* Perform Column Computations  */
  inblk = inbuf;
  for(i=0; i<8; i++)
  {
    /* Check for zeros  */
    x0 = inblk[0];
    x1 = inblk[1];
    x2 = inblk[2];
    x3 = inblk[3];
    x4 = inblk[4];
    x5 = inblk[5];
    x6 = inblk[6];
    x7 = inblk[7];

#if CHECK_FOR_ZEROS
    if(!(x1|x3|x5|x7))
    {
      if(!(x2|x6))
      {
        tmp1 = x0 + x4;
        tmp2 = x0 - x4;
        x1 = IDCTAdjust(tmp1);
        x0 = IDCTAdjust(tmp2);
        outbuf[0]  = x0;
        outbuf[1]  = x1;
        outbuf[2]  = x1;
        outbuf[3]  = x0;
        outbuf[4]  = x0;
        outbuf[5]  = x1;
        outbuf[6]  = x1;
        outbuf[7]  = x0;
      }
      else
      {
        /* Stage 2 */
        x8 = x2 - x6;
        x6 = x2 + x6;

        /* Stage 3 */
#if USE_MUL
        x2=(x8*B1)>>BSHIFT;
#else
        tmp1 = x8 + (x8 >> 2);  /* x2=x8*B1 */
        tmp1 += (tmp1 >> 3);
        x2 = (tmp1 + (x8 >> 7)) >> 1;
#endif
        /* Stage 5 */
        tmp1 = x0 - x4;
        x0 = x0 + x4;
        tmp2  = x2 + x6;
        /* Stage 6 */
        x6 = x0 - tmp2;
        x0 = x0 + tmp2;
        x4 = tmp1 + x2;
        x2 = tmp1 - x2;
        /* Final Stage */
        tmp1 = IDCTAdjust(x0);
        outbuf[0] = tmp1;
        outbuf[7] = tmp1;

        tmp2 = IDCTAdjust(x4);
        outbuf[1] = tmp2;
        outbuf[6] = tmp2;

        tmp3 = IDCTAdjust(x2);
        outbuf[2] = tmp3;
        outbuf[5] = tmp3;

        tmp1 = IDCTAdjust(x6);
        outbuf[3] = tmp1;
        outbuf[4] = tmp1;
      }
    }
    else
#endif
    {
      /* Stage 1 */
      tmp1  = x5 + x3;
      x5  = x5 - x3;
      tmp2 = x1 + x7;
      x7 = x1 - x7;
      /* Stage 2 */
      tmp3 = x2 - x6;
      x6 = x2 + x6;
      x3 = tmp2 + tmp1;
      x1 = tmp2 - tmp1;
      x8 = x7 - x5;
      /* Stage 3 */
#if USE_MUL
      x5=(x5*B2)>>BSHIFT;
      x1=(x1*B3)>>BSHIFT;
      x2=(tmp3*B1)>>BSHIFT;
      x7=(x7*B4)>>BSHIFT;
      x8=(x8*B5)>>BSHIFT;
#else
      x5 = x5 + (x5 >> 2) + (x5 >> 4) - (x5 >> 7) + (x5 >> 9); /* x5=x5*B2 */
      x5 = -x5;
      tmp1 = x1 + (x1 >> 2);  /* x1=x1*B3 */
      tmp1 += (tmp1 >> 3);
      x1 = (tmp1 + (x1 >> 7)) >> 1;
      tmp1 = tmp3 + (tmp3 >> 2);  /* x2=tmp3*B1 */
      tmp1 += (tmp1 >> 3);
      x2 = (tmp1 + (tmp3 >> 7)) >> 1;
      x7 = (x7 + (x7 >> 4) + (x7 >> 6) + (x7 >> 8)) >> 1; /* x7=x7*B4 */
      x8 = (x8 + (x8 >> 1) + (x8 >> 5) - (x8 >> 11)) >> 2; /* x8=x8*B5 */
#endif /* USE_MUL */
      /* Stage 4 */
      x5=x5 - x8;
      x7=x7 + x8;
      /* Stage 5  */
      tmp3 = x0 - x4;
      x0 = x0 + x4;
      tmp2 = x2 + x6;
      x3 = x3 + x7;
      x7 = x1 + x7;
      x1 = x1 - x5;
      /* Stage 6 */
      x6 = x0 - tmp2;
      x0 = x0 + tmp2;
      x4 = tmp3 + x2;
      x2 = tmp3 - x2;
      /* Final Stage */
      outbuf[0] = IDCTAdjust(x0 + x3);
      outbuf[1] = IDCTAdjust(x4 + x7);
      outbuf[2] = IDCTAdjust(x2 + x1);
      outbuf[3] = IDCTAdjust(x6 - x5);
      outbuf[4] = IDCTAdjust(x6 + x5);
      outbuf[5] = IDCTAdjust(x2 - x1);
      outbuf[6] = IDCTAdjust(x4 - x7);
      outbuf[7] = IDCTAdjust(x0 - x3);
    }
    outbuf+=8;
    inblk+=8;
  }
}

#define IDCTAdjust128(val)  ((val + POINTROUND) >> POINT)

/* Function: ScScaleIDCT8x8i128_C()
** Purpose:  Used by H263 video decompression.
**           20 Bit precision.
*/
void ScScaleIDCT8x8i128_C(int *inbuf, int *outbuf)
{
  register int *inblk;
  register int tmp1, tmp2, tmp3;
  register int x0, x1, x2, x3, x4, x5, x6, x7, x8;
  int i;
  _SlibDebug(_DEBUG_, printf("ScScaleIDCT8x8i128_C()\n") );

  /* Perform Row Computations  */
  inblk = inbuf;
  for(i=0; i<8; i++)
  {
    /* Check for zeros  */
    x0 = inblk[0*8];
    x1 = inblk[1*8];
    x2 = inblk[2*8];
    x3 = inblk[3*8];
    x4 = inblk[4*8];
    x5 = inblk[5*8];
    x6 = inblk[6*8];
    x7 = inblk[7*8];
#if CHECK_FOR_ZEROS
    if(!(x1|x3|x5|x7))
    {
      if(!(x2|x6))
      {
        tmp1 = x0 + x4;
        tmp2 = x0 - x4;

        inblk[0*8] = tmp1;
        inblk[1*8] = tmp2;
        inblk[2*8] = tmp2;
        inblk[3*8] = tmp1;
        inblk[4*8] = tmp1;
        inblk[5*8] = tmp2;
        inblk[6*8] = tmp2;
        inblk[7*8] = tmp1;
      }
      else
      {
        /* Stage 2 */
        x8 = x2 - x6;
        x6 = x2 + x6;
        /* Stage 3 */
#if USE_MUL
        x2=(x8*B1)>>BSHIFT;
#else
        tmp1 = x8 + (x8 >> 2);  /* x2=x8*B1 */
        tmp1 += (tmp1 >> 3);
        x2 = (tmp1 + (x8 >> 7)) >> 1;
#endif
        /* Stage 5 */
        tmp1 = x0 - x4;
        x0 = x0 + x4;
        tmp2 = x2 + x6;
        /* Stage 6 */
        x6 = x0 - tmp2;
        x0 = x0 + tmp2;
        x4 = tmp1 + x2;
        x2 = tmp1 - x2;
        /* Final Stage */
        inblk[0*8] = x0;
        inblk[1*8] = x4;
        inblk[2*8] = x2;
        inblk[3*8] = x6;
        inblk[4*8] = x6;
        inblk[5*8] = x2;
        inblk[6*8] = x4;
        inblk[7*8] = x0;
      }
    }
    else
#endif
    {
      /* Stage 1 */
      tmp1 = x5 + x3;
      x5 = x5 - x3;
      tmp2 = x1 + x7;
      x7 = x1 - x7;
      /* Stage 2 */
      tmp3 = x2 - x6;
      x6 = x2 + x6;
      x3 = tmp2 + tmp1;
      x1 = tmp2 - tmp1;
      x8 = x7 - x5;
      /* Stage 3 */
#if USE_MUL
      x5=(x5*B2)>>BSHIFT;
      x1=(x1*B3)>>BSHIFT;
      x2=(tmp3*B1)>>BSHIFT;
      x7=(x7*B4)>>BSHIFT;
      x8=(x8*B5)>>BSHIFT;
#else
      x5 = x5 + (x5 >> 2) + (x5 >> 4) - (x5 >> 7) + (x5 >> 9); /* x5=x5*B2 */
      x5 = -x5;
      tmp1 = x1 + (x1 >> 2);  /* x1=x1*B3 */
      tmp1 += (tmp1 >> 3);
      x1 = (tmp1 + (x1 >> 7)) >> 1;
      tmp1 = tmp3 + (tmp3 >> 2);  /* x2=tmp3*B1 */
      tmp1 += (tmp1 >> 3);
      x2 = (tmp1 + (tmp3 >> 7)) >> 1;
      x7 = (x7 + (x7 >> 4) + (x7 >> 6) + (x7 >> 8)) >> 1; /* x7=x7*B4 */
      x8 = (x8 + (x8 >> 1) + (x8 >> 5) - (x8 >> 11)) >> 2; /* x8=x8*B5 */
#endif /* USE_MUL */
      /* Stage 4 */
      x5=x5 - x8;
      x7=x7 + x8;
      /* Stage 5  */
      tmp3 = x0 - x4;
      x0 = x0 + x4;
      tmp2 = x2 + x6;
      x3 = x3 + x7;
      x7 = x1 + x7;
      x1 = x1 - x5;
      /* Stage 6 */
      x6 = x0 - tmp2;
      x0 = x0 + tmp2;
      x4 = tmp3 + x2;
      x2 = tmp3 - x2;
      /* Final Stage */
      inblk[0*8] = x0 + x3;
      inblk[1*8] = x4 + x7;
      inblk[2*8] = x2 + x1;
      inblk[3*8] = x6 - x5;
      inblk[4*8] = x6 + x5;
      inblk[5*8] = x2 - x1;
      inblk[6*8] = x4 - x7;
      inblk[7*8] = x0 - x3;
    }
    inblk++;
  }

  /* Perform Column Computations  */
  inblk = inbuf;
  for(i=0; i<8; i++)
  {
    /* Check for zeros  */
    x0 = inblk[0];
    x1 = inblk[1];
    x2 = inblk[2];
    x3 = inblk[3];
    x4 = inblk[4];
    x5 = inblk[5];
    x6 = inblk[6];
    x7 = inblk[7];

#if CHECK_FOR_ZEROS
    if(!(x1|x3|x5|x7))
    {
      if(!(x2|x6))
      {
        tmp1 = x0 + x4;
        tmp2 = x0 - x4;
        x1 = IDCTAdjust128(tmp1);
        x0 = IDCTAdjust128(tmp2);
        outbuf[0]  = x0;
        outbuf[1]  = x1;
        outbuf[2]  = x1;
        outbuf[3]  = x0;
        outbuf[4]  = x0;
        outbuf[5]  = x1;
        outbuf[6]  = x1;
        outbuf[7]  = x0;
      }
      else
      {
        /* Stage 2 */
        x8 = x2 - x6;
        x6 = x2 + x6;

        /* Stage 3 */
#if USE_MUL
        x2=(x8*B1)>>BSHIFT;
#else
        tmp1 = x8 + (x8 >> 2);  /* x2=x8*B1 */
        tmp1 += (tmp1 >> 3);
        x2 = (tmp1 + (x8 >> 7)) >> 1;
#endif
        /* Stage 5 */
        tmp1 = x0 - x4;
        x0 = x0 + x4;
        tmp2  = x2 + x6;
        /* Stage 6 */
        x6 = x0 - tmp2;
        x0 = x0 + tmp2;
        x4 = tmp1 + x2;
        x2 = tmp1 - x2;
        /* Final Stage */
        tmp1 = IDCTAdjust128(x0);
        outbuf[0] = tmp1;
        outbuf[7] = tmp1;

        tmp2 = IDCTAdjust128(x4);
        outbuf[1] = tmp2;
        outbuf[6] = tmp2;

        tmp3 = IDCTAdjust128(x2);
        outbuf[2] = tmp3;
        outbuf[5] = tmp3;

        tmp1 = IDCTAdjust128(x6);
        outbuf[3] = tmp1;
        outbuf[4] = tmp1;
      }
    }
    else
#endif
    {
      /* Stage 1 */
      tmp1  = x5 + x3;
      x5  = x5 - x3;
      tmp2 = x1 + x7;
      x7 = x1 - x7;
      /* Stage 2 */
      tmp3 = x2 - x6;
      x6 = x2 + x6;
      x3 = tmp2 + tmp1;
      x1 = tmp2 - tmp1;
      x8 = x7 - x5;
      /* Stage 3 */
#if USE_MUL
      x5=(x5*B2)>>BSHIFT;
      x1=(x1*B3)>>BSHIFT;
      x2=(tmp3*B1)>>BSHIFT;
      x7=(x7*B4)>>BSHIFT;
      x8=(x8*B5)>>BSHIFT;
#else
      x5 = x5 + (x5 >> 2) + (x5 >> 4) - (x5 >> 7) + (x5 >> 9); /* x5=x5*B2 */
      x5 = -x5;
      tmp1 = x1 + (x1 >> 2);  /* x1=x1*B3 */
      tmp1 += (tmp1 >> 3);
      x1 = (tmp1 + (x1 >> 7)) >> 1;
      tmp1 = tmp3 + (tmp3 >> 2);  /* x2=tmp3*B1 */
      tmp1 += (tmp1 >> 3);
      x2 = (tmp1 + (tmp3 >> 7)) >> 1;
      x7 = (x7 + (x7 >> 4) + (x7 >> 6) + (x7 >> 8)) >> 1; /* x7=x7*B4 */
      x8 = (x8 + (x8 >> 1) + (x8 >> 5) - (x8 >> 11)) >> 2; /* x8=x8*B5 */
#endif /* USE_MUL */
      /* Stage 4 */
      x5=x5 - x8;
      x7=x7 + x8;
      /* Stage 5  */
      tmp3 = x0 - x4;
      x0 = x0 + x4;
      tmp2 = x2 + x6;
      x3 = x3 + x7;
      x7 = x1 + x7;
      x1 = x1 - x5;
      /* Stage 6 */
      x6 = x0 - tmp2;
      x0 = x0 + tmp2;
      x4 = tmp3 + x2;
      x2 = tmp3 - x2;
      /* Final Stage */
      outbuf[0] = IDCTAdjust128(x0 + x3);
      outbuf[1] = IDCTAdjust128(x4 + x7);
      outbuf[2] = IDCTAdjust128(x2 + x1);
      outbuf[3] = IDCTAdjust128(x6 - x5);
      outbuf[4] = IDCTAdjust128(x6 + x5);
      outbuf[5] = IDCTAdjust128(x2 - x1);
      outbuf[6] = IDCTAdjust128(x4 - x7);
      outbuf[7] = IDCTAdjust128(x0 - x3);
    }
    outbuf+=8;
    inblk+=8;
  }
}

void ScScaleIDCT1x1i_C(int *inbuf, int *outbuf)
{
  register int x0;
  int i;
  _SlibDebug(_DEBUG_, printf("ScScaleIDCT1x1i_C()\n") );

  x0=inbuf[0];
  x0=((x0 + POINTROUND) >> POINT) - 128;
  for (i=0; i<64; i++)
    outbuf[i]=x0;
}

void ScScaleIDCT1x2i_C(int *inbuf, int *outbuf)
{
  register int x0, x1, x3, x5, x7, x8, tmp1;
  _SlibDebug(_DEBUG_, printf("ScScaleIDCT1x2i_C()\n") );

  x0 = inbuf[0*8];
  x1 = inbuf[1*8];
  /* Stage 2 */
  x3=x1;
  /* Stage 3 */
#if USE_MUL
  x7=(x1*B4)>>BSHIFT;
  x8=(x1*B5)>>BSHIFT;
  x1=(x1*B3)>>BSHIFT;
#else
  x7 = (x1 + (x1 >> 4) + (x1 >> 6) + (x1 >> 8)) >> 1; /* x7=x7*B4 */
  x8 = (x1 + (x1 >> 1) + (x1 >> 5) - (x1 >> 11)) >> 2; /* x8=x8*B5 */
  tmp1 = x1 + (x1 >> 2);  /* x1=x1*B3 */
  tmp1 += (tmp1 >> 3);
  x1 = (tmp1 + (x1 >> 7)) >> 1;
#endif /* USE_MUL */
  /* Stage 4 */
  x5=-x8;
  x7+=x8;
  /* Stage 5 */
  x3+=x7;
  x8=x1;
  x1-=x5;
  x7+=x8;
  /* Final Stage */
  outbuf[0*8+0]=outbuf[0*8+1]=outbuf[0*8+2]=outbuf[0*8+3]=
    outbuf[0*8+4]=outbuf[0*8+5]=outbuf[0*8+6]=outbuf[0*8+7]=IDCTAdjust(x0 + x3);
  outbuf[1*8+0]=outbuf[1*8+1]=outbuf[1*8+2]=outbuf[1*8+3]=
    outbuf[1*8+4]=outbuf[1*8+5]=outbuf[1*8+6]=outbuf[1*8+7]=IDCTAdjust(x0 + x7);
  outbuf[2*8+0]=outbuf[2*8+1]=outbuf[2*8+2]=outbuf[2*8+3]=
    outbuf[2*8+4]=outbuf[2*8+5]=outbuf[2*8+6]=outbuf[2*8+7]=IDCTAdjust(x0 + x1);
  outbuf[3*8+0]=outbuf[3*8+1]=outbuf[3*8+2]=outbuf[3*8+3]=
    outbuf[3*8+4]=outbuf[3*8+5]=outbuf[3*8+6]=outbuf[3*8+7]=IDCTAdjust(x0 - x5);
  outbuf[4*8+0]=outbuf[4*8+1]=outbuf[4*8+2]=outbuf[4*8+3]=
    outbuf[4*8+4]=outbuf[4*8+5]=outbuf[4*8+6]=outbuf[4*8+7]=IDCTAdjust(x0 + x5);
  outbuf[5*8+0]=outbuf[5*8+1]=outbuf[5*8+2]=outbuf[5*8+3]=
    outbuf[5*8+4]=outbuf[5*8+5]=outbuf[5*8+6]=outbuf[5*8+7]=IDCTAdjust(x0 - x1);
  outbuf[6*8+0]=outbuf[6*8+1]=outbuf[6*8+2]=outbuf[6*8+3]=
    outbuf[6*8+4]=outbuf[6*8+5]=outbuf[6*8+6]=outbuf[6*8+7]=IDCTAdjust(x0 - x7);
  outbuf[7*8+0]=outbuf[7*8+1]=outbuf[7*8+2]=outbuf[7*8+3]=
    outbuf[7*8+4]=outbuf[7*8+5]=outbuf[7*8+6]=outbuf[7*8+7]=IDCTAdjust(x0 - x3);
}

void ScScaleIDCT2x1i_C(int *inbuf, int *outbuf)
{
  register int x0, x1, x3, x5, x7, x8, tmp1;
  _SlibDebug(_DEBUG_, printf("ScScaleIDCT1x2i_C()\n") );

  x0 = inbuf[0];
  x1 = inbuf[1];
  /* Stage 2 */
  x3=x1;
  /* Stage 3 */
#if USE_MUL
  x7=(x1*B4)>>BSHIFT;
  x8=(x1*B5)>>BSHIFT;
  x1=(x1*B3)>>BSHIFT;
#else
  x7 = (x1 + (x1 >> 4) + (x1 >> 6) + (x1 >> 8)) >> 1; /* x7=x7*B4 */
  x8 = (x1 + (x1 >> 1) + (x1 >> 5) - (x1 >> 11)) >> 2; /* x8=x8*B5 */
  tmp1 = x1 + (x1 >> 2);  /* x1=x1*B3 */
  tmp1 += (tmp1 >> 3);
  x1 = (tmp1 + (x1 >> 7)) >> 1;
#endif /* USE_MUL */
  /* Stage 4 */
  x5=-x8;
  x7+=x8;
  /* Stage 5 */
  x3+=x7;
  x8=x1;
  x1-=x5;
  x7+=x8;
  /* Final Stage */
  outbuf[0*8+0]=outbuf[1*8+0]=outbuf[2*8+0]=outbuf[3*8+0]=
    outbuf[4*8+0]=outbuf[5*8+0]=outbuf[6*8+0]=outbuf[7*8+0]=IDCTAdjust(x0 + x3);
  outbuf[0*8+1]=outbuf[1*8+1]=outbuf[2*8+1]=outbuf[3*8+1]=
    outbuf[4*8+1]=outbuf[5*8+1]=outbuf[6*8+1]=outbuf[7*8+1]=IDCTAdjust(x0 + x7);
  outbuf[0*8+2]=outbuf[1*8+2]=outbuf[2*8+2]=outbuf[3*8+2]=
    outbuf[4*8+2]=outbuf[5*8+2]=outbuf[6*8+2]=outbuf[7*8+2]=IDCTAdjust(x0 + x1);
  outbuf[0*8+3]=outbuf[1*8+3]=outbuf[2*8+3]=outbuf[3*8+3]=
    outbuf[4*8+3]=outbuf[5*8+3]=outbuf[6*8+3]=outbuf[7*8+3]=IDCTAdjust(x0 - x5);
  outbuf[0*8+4]=outbuf[1*8+4]=outbuf[2*8+4]=outbuf[3*8+4]=
    outbuf[4*8+4]=outbuf[5*8+4]=outbuf[6*8+4]=outbuf[7*8+4]=IDCTAdjust(x0 + x5);
  outbuf[0*8+5]=outbuf[1*8+5]=outbuf[2*8+5]=outbuf[3*8+5]=
    outbuf[4*8+5]=outbuf[5*8+5]=outbuf[6*8+5]=outbuf[7*8+5]=IDCTAdjust(x0 - x1);
  outbuf[0*8+6]=outbuf[1*8+6]=outbuf[2*8+6]=outbuf[3*8+6]=
    outbuf[4*8+6]=outbuf[5*8+6]=outbuf[6*8+6]=outbuf[7*8+6]=IDCTAdjust(x0 - x7);
  outbuf[0*8+7]=outbuf[1*8+7]=outbuf[2*8+7]=outbuf[3*8+7]=
    outbuf[4*8+7]=outbuf[5*8+7]=outbuf[6*8+7]=outbuf[7*8+7]=IDCTAdjust(x0 - x3);
}

void ScScaleIDCT2x2i_C(int *inbuf, int *outbuf)
{
#if 1
  register unsigned int i;
  register int x0, x1, x3, x5, x7, x8, tmp1;
  _SlibDebug(_DEBUG_, printf("ScScaleIDCT2x2i_C()\n") );

  /* Column 1 */
  x0 = inbuf[0*8];
  x1 = inbuf[1*8];
  x3=x1;              /* Stage 2 */
#if USE_MUL
  x7=(x1*B4)>>BSHIFT;
  x8=(x1*B5)>>BSHIFT;
  x1=(x1*B3)>>BSHIFT;
#else
  x7 = (x1 + (x1 >> 4) + (x1 >> 6) + (x1 >> 8)) >> 1; /* x7=x7*B4 */
  x8 = (x1 + (x1 >> 1) + (x1 >> 5) - (x1 >> 11)) >> 2; /* x8=x8*B5 */
  tmp1 = x1 + (x1 >> 2);  /* x1=x1*B3 */
  tmp1 += (tmp1 >> 3);
  x1 = (tmp1 + (x1 >> 7)) >> 1;
#endif /* USE_MUL */
  x5=-x8;             /* Stage 4 */
  x7+=x8;
  x3+=x7;             /* Stage 5 */
  x8=x1;
  x1-=x5;
  x7+=x8;
  inbuf[0*8]=x0 + x3;
  inbuf[1*8]=x0 + x7;
  inbuf[2*8]=x0 + x1;
  inbuf[3*8]=x0 - x5;
  inbuf[4*8]=x0 + x5;
  inbuf[5*8]=x0 - x1;
  inbuf[6*8]=x0 - x7;
  inbuf[7*8]=x0 - x3;
  /* Column 2 */
  x0 = inbuf[0*8+1];
  x1 = inbuf[1*8+1];
  x3=x1;              /* Stage 2 */
#if USE_MUL
  x7=(x1*B4)>>BSHIFT;
  x8=(x1*B5)>>BSHIFT;
  x1=(x1*B3)>>BSHIFT;
#else
  x7 = (x1 + (x1 >> 4) + (x1 >> 6) + (x1 >> 8)) >> 1; /* x7=x7*B4 */
  x8 = (x1 + (x1 >> 1) + (x1 >> 5) - (x1 >> 11)) >> 2; /* x8=x8*B5 */
  tmp1 = x1 + (x1 >> 2);  /* x1=x1*B3 */
  tmp1 += (tmp1 >> 3);
  x1 = (tmp1 + (x1 >> 7)) >> 1;
#endif /* USE_MUL */
  x5=-x8;             /* Stage 4 */
  x7+=x8;
  x3+=x7;             /* Stage 5 */
  x8=x1;
  x1-=x5;
  x7+=x8;
  inbuf[0*8+1]=x0 + x3;
  inbuf[1*8+1]=x0 + x7;
  inbuf[2*8+1]=x0 + x1;
  inbuf[3*8+1]=x0 - x5;
  inbuf[4*8+1]=x0 + x5;
  inbuf[5*8+1]=x0 - x1;
  inbuf[6*8+1]=x0 - x7;
  inbuf[7*8+1]=x0 - x3;

  /* Rows */
  for (i=0; i<8; i++)
  {
    x0 = inbuf[0];
    x1 = inbuf[1];
    x3=x1;              /* Stage 2 */
#if USE_MUL
    x7=(x1*B4)>>BSHIFT;
    x8=(x1*B5)>>BSHIFT;
    x1=(x1*B3)>>BSHIFT;
#else
    x7 = (x1 + (x1 >> 4) + (x1 >> 6) + (x1 >> 8)) >> 1; /* x7=x7*B4 */
    x8 = (x1 + (x1 >> 1) + (x1 >> 5) - (x1 >> 11)) >> 2; /* x8=x8*B5 */
    tmp1 = x1 + (x1 >> 2);  /* x1=x1*B3 */
    tmp1 += (tmp1 >> 3);
    x1 = (tmp1 + (x1 >> 7)) >> 1;
#endif /* USE_MUL */
    x5=-x8;             /* Stage 4 */
    x7+=x8;
    x3+=x7;             /* Stage 5 */
    x8=x1;
    x1-=x5;
    x7+=x8;
    outbuf[0] = IDCTAdjust(x0 + x3);
    outbuf[1] = IDCTAdjust(x0 + x7);
    outbuf[2] = IDCTAdjust(x0 + x1);
    outbuf[3] = IDCTAdjust(x0 - x5);
    outbuf[4] = IDCTAdjust(x0 + x5);
    outbuf[5] = IDCTAdjust(x0 - x1);
    outbuf[6] = IDCTAdjust(x0 - x7);
    outbuf[7] = IDCTAdjust(x0 - x3);
    outbuf+=8;
    inbuf+=8;
  }
#else
  /* Register only version */
  register int x3, x5, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7, tmp8;
  register int x0a, x1a, x3a, x5a, x7a;
  register int x0b, x1b, x3b, x5b, x7b;
  _SlibDebug(_DEBUG_, printf("ScScaleIDCT2x2i_C()\n") );

#define Calc2x2(col, x0_calc, x1_calc, x0, x1, x3, x5, x7, x8) \
  x0 = x0_calc; \
  x1 = x1_calc; \
  x3=x1;              /* Stage 2 */ \
  x7=(x1*B4)>>BSHIFT; /* Stage 3 */ \
  x8=(x1*B5)>>BSHIFT; \
  x1=(x1*B3)>>BSHIFT; \
  x5=-x8;             /* Stage 4 */ \
  x7+=x8; \
  x3+=x7;             /* Stage 5 */ \
  x8=x1; \
  x1-=x5; \
  x7+=x8; \
  outbuf[0+col*8] = IDCTAdjust(x0 + x3); \
  outbuf[1+col*8] = IDCTAdjust(x0 + x7); \
  outbuf[2+col*8] = IDCTAdjust(x0 + x1); \
  outbuf[3+col*8] = IDCTAdjust(x0 - x5); \
  outbuf[4+col*8] = IDCTAdjust(x0 + x5); \
  outbuf[5+col*8] = IDCTAdjust(x0 - x1); \
  outbuf[6+col*8] = IDCTAdjust(x0 - x7); \
  outbuf[7+col*8] = IDCTAdjust(x0 - x3);

  /****** Row 0 ******/
  x0a = inbuf[0*8];
  x1a = inbuf[1*8];
  x3a=x1a;              /* Stage 2 */
  x7a=(x1a*B4)>>BSHIFT; /* Stage 3 */
  tmp1=(x1a*B5)>>BSHIFT;
  x1a=(x1a*B3)>>BSHIFT;
  x5a=-tmp1;            /* Stage 4 */
  x7a+=tmp1;
  x3a+=x7a;             /* Stage 5 */
  tmp1=x1a;
  x1a-=x5a;
  x7a+=tmp1;
  /****** Row 1 ******/
  x0b = inbuf[0*8+1];
  x1b = inbuf[1*8+1];
  x3b=x1b;              /* Stage 2 */
  x7b=(x1b*B4)>>BSHIFT; /* Stage 3 */
  tmp2=(x1b*B5)>>BSHIFT;
  x1b=(x1b*B3)>>BSHIFT;
  x5b=-tmp2;            /* Stage 4 */
  x7b+=tmp2;
  x3b+=x7b;             /* Stage 5 */
  tmp2=x1b;
  x1b-=x5b;
  x7b+=tmp2;

  Calc2x2(0, x0a+x3a, x0b+x3b, tmp1, tmp2, x3, x5, tmp3, tmp4);
  Calc2x2(1, x0a+x7a, x0b+x7b, tmp5, tmp6, x3, x5, tmp7, tmp8);
  Calc2x2(2, x0a+x1a, x0b+x1b, tmp1, tmp2, x3, x5, tmp3, tmp4);
  Calc2x2(3, x0a-x5a, x0b-x5b, tmp5, tmp6, x3, x5, tmp7, tmp8);
  Calc2x2(4, x0a+x5a, x0b+x5b, tmp1, tmp2, x3, x5, tmp3, tmp4);
  Calc2x2(5, x0a-x1a, x0b-x1b, tmp5, tmp6, x3, x5, tmp7, tmp8);
  Calc2x2(6, x0a-x7a, x0b-x7b, tmp1, tmp2, x3, x5, tmp3, tmp4);
  Calc2x2(7, x0a-x3a, x0b-x3b, tmp5, tmp6, x3, x5, tmp7, tmp8);
#endif
}

void ScScaleIDCT3x3i_C(int *inbuf, int *outbuf)
{
  register int *inblk;
  register int tmp1;
  register int x0, x1, x2, x3, x4, x6, x7, x8;
  int i;
  _SlibDebug(_DEBUG_, printf("ScScaleIDCT3x3i_C()\n") );

  /* Perform Row Computations  */
  inblk = inbuf;
  for(i=0; i<3; i++)
  {
    x0 = inblk[0*8];
    x1 = inblk[1*8];
    x2 = inblk[2*8];
    /* Stage 2 */
    x6=x2;
    x3=x1;
    /* Stage 3 */
#if USE_MUL
    x2=(x2*B1)>>BSHIFT;
    x7=(x1*B4)>>BSHIFT;
    x8=(x1*B5)>>BSHIFT;
    x1=(x1*B3)>>BSHIFT;
#else
    tmp1 = x2 + (x2 >> 2);  /* x2=x2*B1 */
    tmp1 += (tmp1 >> 3);
    x2 = (tmp1 + (x2 >> 7)) >> 1;
    x7 = (x1 + (x1 >> 4) + (x1 >> 6) + (x1 >> 8)) >> 1; /* x7=x1*B4 */
    x8 = (x1 + (x1 >> 1) + (x1 >> 5) - (x1 >> 11)) >> 2; /* x8=x1*B5 */
    tmp1 = x1 + (x1 >> 2);  /* x1=x1*B3 */
    tmp1 += (tmp1 >> 3);
    x1 = (tmp1 + (x1 >> 7)) >> 1;
#endif /* USE_MUL */
    /* Stage 4 */
    x7+=x8;
    /* Stage 5 */
    tmp1=x6+x2;
    x3+=x7;
    x7+=x1;
    x1+=x8;
    /* Stage 6 */
    x4=x0+x2;
    x2=x0-x2;
    x6=x0-tmp1;
    x0=x0+tmp1;
    /* Final Stage */
    inblk[0*8]  = x0 + x3;
    inblk[1*8]  = x4 + x7;
    inblk[2*8]  = x2 + x1;
    inblk[3*8]  = x6 + x8;
    inblk[4*8]  = x6 - x8;
    inblk[5*8]  = x2 - x1;
    inblk[6*8]  = x4 - x7;
    inblk[7*8]  = x0 - x3;
    inblk++;
  }

  /* Perform Column Computations  */
  inblk = inbuf;
  for(i=0; i<8; i++)
  {
    x0 = inblk[0];
    x1 = inblk[1];
    x2 = inblk[2];
    /* Stage 2 */
    x6=x2;
    x3=x1;
    /* Stage 3 */
#if USE_MUL
    x2=(x2*B1)>>BSHIFT;
    x7=(x1*B4)>>BSHIFT;
    x8=(x1*B5)>>BSHIFT;
    x1=(x1*B3)>>BSHIFT;
#else
    tmp1 = x2 + (x2 >> 2);  /* x2=x2*B1 */
    tmp1 += (tmp1 >> 3);
    x2 = (tmp1 + (x2 >> 7)) >> 1;
    x7 = (x1 + (x1 >> 4) + (x1 >> 6) + (x1 >> 8)) >> 1; /* x7=x1*B4 */
    x8 = (x1 + (x1 >> 1) + (x1 >> 5) - (x1 >> 11)) >> 2; /* x8=x1*B5 */
    tmp1 = x1 + (x1 >> 2);  /* x1=x1*B3 */
    tmp1 += (tmp1 >> 3);
    x1 = (tmp1 + (x1 >> 7)) >> 1;
#endif /* USE_MUL */
    /* Stage 4 */
    x7+=x8;
    /* Stage 5 */
    tmp1=x6+x2;
    x3+=x7;
    x7+=x1;
    x1+=x8;
    /* Stage 6 */
    x4=x0+x2;
    x2=x0-x2;
    x6=x0-tmp1;
    x0=x0+tmp1;
    /* Final Stage */
    outbuf[0] = IDCTAdjust(x0 + x3);
    outbuf[1] = IDCTAdjust(x4 + x7);
    outbuf[2] = IDCTAdjust(x2 + x1);
    outbuf[3] = IDCTAdjust(x6 + x8);
    outbuf[4] = IDCTAdjust(x6 - x8);
    outbuf[5] = IDCTAdjust(x2 - x1);
    outbuf[6] = IDCTAdjust(x4 - x7);
    outbuf[7] = IDCTAdjust(x0 - x3);

    outbuf+=8;
    inblk+=8;
  }
}

void ScScaleIDCT4x4i_C(int *inbuf, int *outbuf)
{
  register int *inblk;
  register int tmp1, tmp2;
  register int x0, x1, x2, x3, x4, x5, x6, x7, x8;
  int i;
  _SlibDebug(_DEBUG_, printf("ScScaleIDCT4x4i_C()\n") );

  /* Perform Row Computations  */
  inblk = inbuf;
  for(i=0; i<4; i++)
  {
    x0 = inblk[0*8];
    x1 = inblk[1*8];
    x2 = inblk[2*8];
    x3 = inblk[3*8];
    /* Stage 1 */
    x5=-x3;
    /* Stage 2 */
    x6=x2;
    tmp1=x1-x3;
    x3=x1+x3;
    /* Stage 3 */
#if USE_MUL
    x5=(x5*B2)>>BSHIFT;
    x2=(x2*B1)>>BSHIFT;
    x7=(x1*B4)>>BSHIFT;
    x8=(x3*B5)>>BSHIFT;
    x1=(tmp1*B3)>>BSHIFT;
#else
    x5 = x5 + (x5 >> 2) + (x5 >> 4) - (x5 >> 7) + (x5 >> 9); /* x5=x5*B2 */
    x5 = -x5;
    tmp2 = x2 + (x2 >> 2);  /* x2=x2*B1 */
    tmp2 += (tmp2 >> 3);
    x2 = (tmp2 + (x2 >> 7)) >> 1;
    x7 = (x1 + (x1 >> 4) + (x1 >> 6) + (x1 >> 8)) >> 1; /* x7=x1*B4 */
    x8 = (x3 + (x3 >> 1) + (x3 >> 5) - (x3 >> 11)) >> 2; /* x8=x3*B5 */
    tmp2 = tmp1 + (tmp1 >> 2);  /* x1=tmp1*B3 */
    tmp2 += (tmp2 >> 3);
    x1 = (tmp2 + (tmp1 >> 7)) >> 1;
#endif /* USE_MUL */
    /* Stage 4 */
    x5-=x8;
    x7+=x8;
    /* Stage 5 */
    tmp1=x6+x2;
    x3+=x7;
    x7+=x1;
    x1-=x5;
    /* Stage 6 */
    x4=x0+x2;
    x2=x0-x2;
    x6=x0-tmp1;
    x0=x0+tmp1;
    /* Final Stage */
    inblk[0*8] = x0 + x3;
    inblk[1*8] = x4 + x7;
    inblk[2*8] = x2 + x1;
    inblk[3*8] = x6 - x5;
    inblk[4*8] = x6 + x5;
    inblk[5*8] = x2 - x1;
    inblk[6*8] = x4 - x7;
    inblk[7*8] = x0 - x3;
    inblk++;
  }

  /* Perform Column Computations  */
  inblk = inbuf;
  for(i=0; i<8; i++)
  {
    x0 = inblk[0];
    x1 = inblk[1];
    x2 = inblk[2];
    x3 = inblk[3];
    /* Stage 1 */
    x5=-x3;
    /* Stage 2 */
    x6=x2;
    tmp1=x1-x3;
    x3=x1+x3;
    /* Stage 3 */
#if USE_MUL
    x5=(x5*B2)>>BSHIFT;
    x2=(x2*B1)>>BSHIFT;
    x7=(x1*B4)>>BSHIFT;
    x8=(x3*B5)>>BSHIFT;
    x1=(tmp1*B3)>>BSHIFT;
#else
    x5 = x5 + (x5 >> 2) + (x5 >> 4) - (x5 >> 7) + (x5 >> 9); /* x5=x5*B2 */
    x5 = -x5;
    tmp2 = x2 + (x2 >> 2);  /* x2=x2*B1 */
    tmp2 += (tmp2 >> 3);
    x2 = (tmp2 + (x2 >> 7)) >> 1;
    x7 = (x1 + (x1 >> 4) + (x1 >> 6) + (x1 >> 8)) >> 1; /* x7=x1*B4 */
    x8 = (x3 + (x3 >> 1) + (x3 >> 5) - (x3 >> 11)) >> 2; /* x8=x3*B5 */
    tmp2 = tmp1 + (tmp1 >> 2);  /* x1=tmp1*B3 */
    tmp2 += (tmp2 >> 3);
    x1 = (tmp2 + (tmp1 >> 7)) >> 1;
#endif /* USE_MUL */
    /* Stage 4 */
    x5-=x8;
    x7+=x8;
    /* Stage 5 */
    tmp1=x6+x2;
    x3+=x7;
    x7+=x1;
    x1-=x5;
    /* Stage 6 */
    x4=x0+x2;
    x2=x0-x2;
    x6=x0-tmp1;
    x0=x0+tmp1;
    /* Final Stage */
    outbuf[0] = IDCTAdjust(x0 + x3);
    outbuf[1] = IDCTAdjust(x4 + x7);
    outbuf[2] = IDCTAdjust(x2 + x1);
    outbuf[3] = IDCTAdjust(x6 - x5);
    outbuf[4] = IDCTAdjust(x6 + x5);
    outbuf[5] = IDCTAdjust(x2 - x1);
    outbuf[6] = IDCTAdjust(x4 - x7);
    outbuf[7] = IDCTAdjust(x0 - x3);

    outbuf+=8;
    inblk+=8;
  }
}

void ScScaleIDCT6x6i_C(int *inbuf, int *outbuf)
{
  register int *inblk;
  register int tmp1;
  register int x0, x1, x2, x3, x4, x5, x6, x7, x8;
  int i;
  _SlibDebug(_DEBUG_, printf("ScScaleIDCT6x6i_C()\n") );

  /* Perform Row Computations  */
  inblk = inbuf;
  for(i=0; i<6; i++)
  {
    x0 = inblk[0*8];
    x1 = inblk[1*8];
    x2 = inblk[2*8];
    x3 = inblk[3*8];
    x4 = inblk[4*8];
    x5 = inblk[5*8];
    /* Stage 1 */
    x7=x1;
    tmp1=x5;
    x5-=x3;
    x3+=tmp1;
    /* Stage 2 */
    x6=x2;
    tmp1=x3;
    x3+=x1;
    x1-=tmp1;
    x8=x7-x5;
    /* Stage 3 */
#if USE_MUL
    x5=(x5*B2)>>BSHIFT;
    x2=(x2*B1)>>BSHIFT;
    x1=(x1*B3)>>BSHIFT;
    x7=(x7*B4)>>BSHIFT;
    x8=(x8*B5)>>BSHIFT;
#else
    x5 = x5 + (x5 >> 2) + (x5 >> 4) - (x5 >> 7) + (x5 >> 9); /* x5=x5*B2 */
    x5 = -x5;
    tmp1 = x2 + (x2 >> 2);  /* x2=x2*B1 */
    tmp1 += (tmp1 >> 3);
    x2 = (tmp1 + (x2 >> 7)) >> 1;
    x7 = (x7 + (x7 >> 4) + (x7 >> 6) + (x7 >> 8)) >> 1; /* x7=x7*B4 */
    x8 = (x8 + (x8 >> 1) + (x8 >> 5) - (x8 >> 11)) >> 2; /* x8=x8*B5 */
    tmp1 = x1 + (x1 >> 2);  /* x1=x1*B3 */
    tmp1 += (tmp1 >> 3);
    x1 = (tmp1 + (x1 >> 7)) >> 1;
#endif /* USE_MUL */
    /* Stage 4 */
    x5-=x8;
    x7+=x8;
    /* Stage 5 */
    x6+=x2;
    tmp1=x4;
    x4=x0-x4;
    x0+=tmp1;
    x3+=x7;
    x7+=x1;
    x1-=x5;
    /* Stage 6 */
    tmp1=x0;
    x0+=x6;
    x6=tmp1-x6;
    tmp1=x2;
    x2=x4-x2;
    x4+=tmp1;
    /* Final Stage */
    inblk[0*8] = x0 + x3;
    inblk[1*8] = x4 + x7;
    inblk[2*8] = x2 + x1;
    inblk[3*8] = x6 - x5;
    inblk[4*8] = x5 + x6;
    inblk[5*8] = x2 - x1;
    inblk[6*8] = x4 - x7;
    inblk[7*8] = x0 - x3;
    inblk++;
  }

  /* Perform Column Computations  */
  inblk = inbuf;
  for(i=0; i<8; i++)
  {
    x0 = inblk[0];
    x1 = inblk[1];
    x2 = inblk[2];
    x3 = inblk[3];
    x4 = inblk[4];
    x5 = inblk[5];
    /* Stage 1 */
    x7=x1;
    tmp1=x5;
    x5-=x3;
    x3+=tmp1;
    /* Stage 2 */
    x6=x2;
    tmp1=x3;
    x3+=x1;
    x1-=tmp1;
    x8=x7-x5;
#if USE_MUL
    x5=(x5*B2)>>BSHIFT;
    x2=(x2*B1)>>BSHIFT;
    x1=(x1*B3)>>BSHIFT;
    x7=(x7*B4)>>BSHIFT;
    x8=(x8*B5)>>BSHIFT;
#else
    x5 = x5 + (x5 >> 2) + (x5 >> 4) - (x5 >> 7) + (x5 >> 9); /* x5=x5*B2 */
    x5 = -x5;
    tmp1 = x2 + (x2 >> 2);  /* x2=x2*B1 */
    tmp1 += (tmp1 >> 3);
    x2 = (tmp1 + (x2 >> 7)) >> 1;
    x7 = (x7 + (x7 >> 4) + (x7 >> 6) + (x7 >> 8)) >> 1; /* x7=x7*B4 */
    x8 = (x8 + (x8 >> 1) + (x8 >> 5) - (x8 >> 11)) >> 2; /* x8=x8*B5 */
    tmp1 = x1 + (x1 >> 2);  /* x1=x1*B3 */
    tmp1 += (tmp1 >> 3);
    x1 = (tmp1 + (x1 >> 7)) >> 1;
#endif /* USE_MUL */
    /* Stage 4 */
    x5-=x8;
    x7+=x8;
    /* Stage 5 */
    x6+=x2;
    tmp1=x4;
    x4=x0-x4;
    x0+=tmp1;
    x3+=x7;
    x7+=x1;
    x1-=x5;
    /* Stage 6 */
    tmp1=x0;
    x0+=x6;
    x6=tmp1-x6;
    tmp1=x2;
    x2=x4-x2;
    x4+=tmp1;
    /* Final Stage */
    outbuf[0] = IDCTAdjust(x0 + x3);
    outbuf[1] = IDCTAdjust(x4 + x7);
    outbuf[2] = IDCTAdjust(x2 + x1);
    outbuf[3] = IDCTAdjust(x6 - x5);
    outbuf[4] = IDCTAdjust(x6 + x5);
    outbuf[5] = IDCTAdjust(x2 - x1);
    outbuf[6] = IDCTAdjust(x4 - x7);
    outbuf[7] = IDCTAdjust(x0 - x3);

    outbuf+=8;
    inblk+=8;
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech261\me2.c ===
/* File: sv_h261_me2.c */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995, 1997                 **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/
/*************************************************************
This file does much of the motion estimation and compensation.
*************************************************************/

/*
#define USE_C
#define _SLIBDEBUG_
*/

#include <stdio.h>
#include <stdlib.h>
#include <math.h> 

#include "sv_intrn.h"
#include "SC_err.h"
#include "sv_h261.h"
#include "proto.h"

#ifdef _SLIBDEBUG_
#define _DEBUG_   0  /* detailed debuging statements */
#define _VERBOSE_ 0  /* show progress */
#define _VERIFY_  1  /* verify correct operation */
#define _WARN_    0  /* warnings about strange behavior */
#endif

#define Abs(value) ( (value < 0) ? (-value) : value)
/*
#define MEBUFSIZE  1024
int MeVAR[MEBUFSIZE];
int MeVAROR[MEBUFSIZE];
int MeMWOR[MEBUFSIZE];
int MeX[MEBUFSIZE];
int MeY[MEBUFSIZE];
int MeVal[MEBUFSIZE];
int MeOVal[MEBUFSIZE];
int PreviousMeOVal[MEBUFSIZE];
*/


/*
** Function: CrawlMotionEstimation()
** Purpose:  Does motion estimation on all aligned
**           16x16 blocks in two memory structures.
*/
void CrawlMotionEstimation(SvH261Info_t *H261, unsigned char *pm,
                           unsigned char *rm, unsigned char *cm)
{
  const int SearchLimit=H261->ME_search, Threshold=H261->ME_threshold;
  const int height=H261->YHeight, width=H261->YWidth;
  const int ylimit=height-16, xlimit=width-16;
  unsigned char *pptr, *cptr;
  register int x, y, xd, yd;
  int MeN, MV;

  int i, j, val;
  int VAROR, MWOR;
  unsigned char *cptr2;


  _SlibDebug(_VERBOSE_,
             printf("CrawlMotionEstimation(H261=0x%p, %p, %p, %p) In\n", 
                         H261, pm, rm, cm) );
  for(MeN=0, y=0; y<height; y+=16)
  {
    cptr=cm + (y * width);
    pptr=rm + (y * width);
    _SlibDebug(_VERIFY_ && ((int)cptr)%8,
               printf("FastBME() cm Not quad word aligned\n") );
  
    for(x=0; x<width; x+=16, MeN++,cptr+=16,pptr+=16)
    {
      xd=yd=0;
#ifdef USE_C
      MV = blockdiff16_C(cptr, pptr, width,400000);
#else
      MV = blockdiff16(cptr, pptr, width,400000);
#endif
      _SlibDebug(_DEBUG_, printf("First MV=%d\n",MV) );
      H261->PreviousMeOVal[MeN] = H261->MeOVal[MeN];  
      H261->MeOVal[MeN] = MV;

      if (MV >= Threshold)
      { 
        int d=0, MVnew, bestxd, bestyd, lastxd, lastyd;  
        
#ifdef USE_C
#define bd(nxd, nyd) {MVnew=blockdiff16_C(cptr, pptr+nxd+(nyd*width), width, MV); \
          if (MVnew<MV) {bestxd=nxd; bestyd=nyd; MV=MVnew;} \
           _SlibDebug(_DEBUG_, printf("MVnew=%d x=%d y=%d\n",MVnew,nxd,nyd) );}
#else
#define bd(nxd, nyd) {MVnew=blockdiff16(cptr, pptr+nxd+(nyd*width), width, MV); \
          if (MVnew<MV) {bestxd=nxd; bestyd=nyd; MV=MVnew;} \
           _SlibDebug(_DEBUG_, printf("MVnew=%d x=%d y=%d\n",MVnew,nxd,nyd) );}
#endif
        lastxd=0;
        lastyd=0;
        while (MV >= Threshold && 
                xd>-SearchLimit && xd<SearchLimit &&
                yd>-SearchLimit && yd<SearchLimit)
        {
          bestxd=xd;
          bestyd=yd;
          _SlibDebug(_DEBUG_, printf("xd=%d yd=%d d=%d MV=%d\n",xd, yd, d, MV));
          switch (d) /* d is a vector for movement */
          {
            case -4:  /* moved down & right */
                      if (x+xd<xlimit)
                      {
                        bd(xd+1, yd-1);
                        bd(xd+1, yd);
                        if (y+yd<ylimit)
                        {
                          bd(xd+1, yd+1);
                          bd(xd, yd+1);
                          bd(xd-1, yd+1);
                        }
                      }
                      else if (y+yd<ylimit)
                      {
                        bd(xd, yd+1);
                        bd(xd-1, yd+1);
                      }
                      break;
            case -3:  /* moved down */
                      if (y+yd>0)
                      {
                        bd(xd-1, yd-1);
                        bd(xd, yd-1);
                        bd(xd+1, yd-1);
                      }
                      break;
            case -2:  /* moved up & right */
                      if (x+xd<xlimit)
                      {
                        bd(xd+1, yd+1);
                        bd(xd+1, yd);
                        if (y+yd>0)
                        {
                          bd(xd+1, yd-1);
                          bd(xd, yd-1);
                          bd(xd-1, yd-1);
                        }
                      }
                      else if (y+yd>0)
                      {
                        bd(xd, yd-1);
                        bd(xd-1, yd-1);
                      }
                      break;
            case -1:  /* moved left */
                      if (x+xd>0)
                      {
		        if (y+yd > 0)
                          bd(xd-1, yd-1);
                        bd(xd-1, yd);
                        bd(xd-1, yd+1);
                      }
                      break;
            case 0:   /* no movement */
                      if (x+xd<=0)  /* at left edge */
                      {
                        if (y+yd<=0) /* at top-left corner */
                        {
                          bd(xd+1, yd);
                          bd(xd+1, yd+1);
                          bd(xd, yd+1);
                        }
                        else if (y+yd>=ylimit) /* at bottom-left corner */
                        {
                          bd(xd+1, yd);
                          bd(xd+1, yd-1);
                          bd(xd, yd-1);
                        }
                        else /* at left edge, y within limits */
                        {
                          bd(xd, yd+1);
                          bd(xd, yd-1);
                          bd(xd+1, yd-1);
                          bd(xd+1, yd);
                          bd(xd+1, yd+1);
                        }
                      }
                      else if (x+xd>=xlimit) /* at right edge */
                      {
                        if (y+yd<=0) /* at top-right corner */
                        {
                          bd(xd-1, yd);
                          bd(xd-1, yd+1);
                          bd(xd, yd+1);
                        }
                        else if (y+yd>=ylimit) /* at bottom-right corner */
                        {
                          bd(xd-1, yd);
                          bd(xd-1, yd-1);
                          bd(xd, yd-1);
                        }
                        else /* at right edge, y within limits */
                        {
                          bd(xd, yd+1);
                          bd(xd, yd-1);
                          bd(xd-1, yd-1);
                          bd(xd-1, yd);
                          bd(xd-1, yd+1);
                        }
                      }
                      else if (y+yd<=0) /* at top edge, x within limits */
                      {
                        bd(xd-1, yd);
                        bd(xd+1, yd);
                        bd(xd-1, yd+1);
                        bd(xd, yd+1);
                        bd(xd+1, yd+1);
                      }
                      else if (y+yd>=ylimit) /* at bottom edge, x within limits */
                      {
                        bd(xd-1, yd);
                        bd(xd+1, yd);
                        bd(xd-1, yd-1);
                        bd(xd, yd-1);
                        bd(xd+1, yd-1);
                      }
                      else /* within all limits */
                      {
                        bd(xd-1, yd);
                        bd(xd+1, yd);
                        bd(xd-1, yd-1);
                        bd(xd-1, yd+1);
                        bd(xd+1, yd-1);
                        bd(xd+1, yd+1);
                        bd(xd, yd-1);
                        bd(xd, yd+1);
                      }
                      break;
            case 1:   /* moved right */
                      if (x+xd<xlimit)
                      {
		        if (y+yd > 0)
                          bd(xd+1, yd-1);
                        bd(xd+1, yd);
                        bd(xd+1, yd+1);
                      }
                      break;
            case 2:   /* moved down & left */
                      if (x+xd>0)
                      {
		      if (y+yd > 0)
                        bd(xd-1, yd-1);
                        bd(xd-1, yd);
                        if (y+yd<ylimit)
                        {
                          bd(xd-1, yd+1);
                          bd(xd, yd+1);
                          bd(xd+1, yd+1);
                        }
                      }
                      else if (y+yd<ylimit)
                      {
                        bd(xd, yd+1);
                        bd(xd+1, yd+1);
                      }
                      break;
            case 3:   /* moved down */
                      if (y+yd<ylimit)
                      {
                        bd(xd-1, yd+1);
                        bd(xd, yd+1);
                        bd(xd+1, yd+1);
                      }
                      break;
            case 4:   /* moved down & right */
                      if (x+xd>0)
                      {
                        bd(xd-1, yd);
                        bd(xd-1, yd+1);
                        if (y+yd>0)
                        {
                          bd(xd-1, yd-1);
                          bd(xd, yd-1);
                          bd(xd+1, yd-1);
                        }
                      }
                      else if (y+yd>0)
                      {
                        bd(xd, yd-1);
                        bd(xd+1, yd-1);
                      }
                      break;
            default:
                      _SlibDebug(_VERIFY_, 
                         printf("Illegal movement: d = %d\n", d) );
          }
          if (bestxd==xd && bestyd==yd) /* found closest motion vector */
            break;
          lastxd=xd;
          lastyd=yd;
          xd=bestxd;
          yd=bestyd;
          d = (xd-lastxd) + 3*(yd-lastyd);  /* calculate the movement */
        }
      }
      H261->MeX[MeN] = xd;
      H261->MeY[MeN] = yd;
      H261->MeVal[MeN] = MV;
      H261->MeVAR[MeN] = MV;
      _SlibDebug(_DEBUG_ && (xd || yd),
              printf("New MeN=%d x=%d y=%d MX=%d MY=%d MV=%d\n", 
                                    MeN, x, y, xd, yd, MV) );  
  
#if 1
      for(cptr2 = cptr, MWOR=0, i=0; i<16; i++)
      {
        for(j=0; j<16; j++)
          MWOR += *cptr2++;
        cptr2 += width-16;
      }
      MWOR /= 256;
      H261->MeMWOR[MeN] = MWOR; 

      for(cptr2 = cptr, VAROR=0, i=0; i<16; i++)
      {
        for (j=0; j<16; j++)
        {
          val=*cptr2++ - MWOR; if (val>0) VAROR += val; else VAROR -= val;
        }
        cptr2 += width-16;
      }
      H261->MeVAROR[MeN] = VAROR;

      _SlibDebug(_DEBUG_,
        printf("x=%d y=%d MV=%d MWOR=%d VAROR=%d\n", x, y, MV, MWOR, VAROR) );
#if 0
      for(cptr2 = cptr, MWOR=0, i=0; i<16; i++)
      {
        for(j=0; j<16; j++)
          MWOR += *cptr2++;
        cptr2 += width-16;
      }
      MWOR /= 256;
      H261->MeMWOR[MeN] = MV/10; /* MWOR; */

      for(cptr2 = cptr, VAROR=0, i=0; i<16; i++)
      {
        for (j=0; j<16; j++)
        {
          val=*cptr2++ - MWOR; if (val>0) VAROR += val; else VAROR -= val;
        }
        cptr2 += width-16;
      }
      H261->MeVAROR[MeN] = MV; /* VAROR; */
      _SlibDebug(_DEBUG_,
        printf("x=%d y=%d MV=%d MWOR=%d VAROR=%d\n", x, y, MV, MWOR, VAROR) );
#endif
#else
      H261->MeMWOR[MeN] = 0;
      H261->MeVAROR[MeN] = 0;
#endif
    }
  }
  _SlibDebug(_DEBUG_, printf("CrawlMotionEstimation() Out\n") );
}

/*
** Function: BruteMotionEstimation()
** Purpose:  Does a brute-force motion estimation on all aligned
**           16x16 blocks in two memory structures.
*/
void BruteMotionEstimation(SvH261Info_t *H261, unsigned char *rm,
                           unsigned char *rrm, unsigned char *cm)
{
  const int SearchLimit=H261->ME_search, Threshold=H261->ME_threshold/8;
  const int YHeight=H261->YHeight, YWidth=H261->YWidth;
  const int YHeight16=YHeight-16, YWidth16=YWidth-16;
  unsigned char *bptr, *cptr, *baseptr;
  register int MeN, i, j, x, y, px, py;
  int MX, MY, MV, val;
  int VAR, VAROR, MWOR;
  const int jump = YWidth;
  unsigned char data;

  _SlibDebug(_VERBOSE_, 
        printf("BruteMotionEstimation(H261=0x%p, %p, %p, %p) In\n", 
                         H261, rm, rrm, cm) );
  _SlibDebug(_VERIFY_ && ((int)cm)%8,
           printf("FastBME() cm Not quad aligned\n") );
  
  for(MeN=0, y=0; y<YHeight; y+=16)
  {
    baseptr=cm + (y * YWidth);
    for(x=0; x<YWidth; x+=16, MeN++,baseptr+=16)
    {
      MX=MY=0;
      bptr = rrm + x + (y * YWidth);

#if 1
#ifdef USE_C
      MV = fblockdiff16_C(baseptr, bptr, YWidth, 65536) / 4;
#else
      MV = blockdiff16(baseptr, bptr, YWidth, 65536) / 4;
#endif

#else

#ifdef USE_C
      MV = fblockdiff16_sub_C(baseptr, bptr, jump);
#else
      MV = fblockdiff16_sub(baseptr, bptr, jump);
#endif
#endif
      H261->PreviousMeOVal[MeN] = H261->MeOVal[MeN];  
      H261->MeOVal[MeN] = MV*4;
      _SlibDebug(_DEBUG_, printf("[00]MX %d MY %d MV %d\n",MX,MY,MV) );

      if (MV >= Threshold)
      { 
        int Xl, Xh, Yl, Yh; 
	
        /*  MV = 362182; */  
        Xl = ((x-SearchLimit)/2)*2;
        Xh = ((x+SearchLimit)/2)*2;
        Yl = ((y-SearchLimit)/2)*2;
        Yh = ((y+SearchLimit)/2)*2;
        if (Xl < 0) Xl = 0;
        if (Xh > YWidth16) Xh = YWidth16;
        if (Yl < 0) Yl = 0;
        if (Yh > YHeight16) Yh = YHeight16;

        for (px=Xl; px<=Xh && MV >= Threshold; px +=2)
        {
          bptr = rrm + px + (Yl * YWidth);
          for (py=Yl; py<=Yh && MV >= Threshold; py += 2, bptr+=YWidth*2)
          {
            _SlibDebug(_DEBUG_, printf("blockdiff16_sub(%p, %p, %d, %d)\n",
                                         baseptr,bptr,YWidth,MV) );
#ifdef USE_C
            val = blockdiff16_sub_C(baseptr, bptr, jump, MV);
#else
            val = blockdiff16_sub(baseptr, bptr, jump, MV);
#endif
            _SlibDebug(_DEBUG_, printf("blockdiff16_sub() Out val=%d\n", val) );
            if (val < MV)
            {
              MV = val;
              MX = px - x;
              MY = py - y;
            }
          }
        } 

        px = MX + x;
        py = MY + y;    
        MV = 65536;  
		
        Xl = px - 1;
        Xh = px + 1;
        Yl = py - 1;
        Yh = py + 1;
        if (Xl < 0) Xl = 0;
        if (Xh > YWidth16) Xh = YWidth16;
        if (Yl < 0) Yl = 0;
        if (Yh > YHeight16) Yh = YHeight16;
        for (px=Xl; px<=Xh && MV>=Threshold; px++)
        {
          bptr = rrm + px + (Yl * YWidth);
          for (py=Yl; py<=Yh && MV>=Threshold; py++, bptr+=YWidth)
          {
#ifdef USE_C
		    val = blockdiff16_C(baseptr, bptr, YWidth, MV);
#else
            val = blockdiff16(baseptr, bptr, YWidth, MV);
#endif
            if (val < MV)
            {
              MV = val;
              MX = px - x;
              MY = py - y;
            }
          }
        }
      }

      _SlibDebug(_DEBUG_, printf("MeN=%d x=%d y=%d MX=%d MY=%d MV=%d\n", 
                                    MeN, x, y, MX, MY, MV) );  
      H261->MeX[MeN] = MX;
      H261->MeY[MeN] = MY;
      H261->MeVal[MeN] = MV;

      bptr = rrm + MX + x + ((MY+y) * YWidth);
      cptr = baseptr;
      for(VAR=0, MWOR=0, i=0; i<16; i++)
      {
        for(j=0; j<16; j++)
        {
          MWOR += (data=*cptr++);
          val = *bptr++ - data;
          VAR += (val > 0) ? val : -val;
        }
        bptr += YWidth16;
        cptr += YWidth16;
      }
      H261->MeVAR[MeN] = VAR;
      MWOR /= 256;
      H261->MeMWOR[MeN] = MWOR;

      cptr = baseptr;
      for(VAROR=0, i=0; i<16; i++)
      {
        for (j=0; j<16; j++)
        {
          val=*cptr++ - MWOR; if (val>0) VAROR += val; else VAROR -= val;
        }
        cptr += YWidth16;
      }
      H261->MeVAROR[MeN] = VAROR;
    }
  }
  _SlibDebug(_DEBUG_, printf("BruteMotionEstimation() Out\n") );
}


/*
 * logarithmetic search block matching
 *
 * blk: top left pel of (16*h) block
 * h: height of block
 * lx: distance (in bytes) of vertically adjacent pels in ref,blk
 * org: top left pel of source reference picture
 * ref: top left pel of reconstructed reference picture
 * i0,j0: center of search window
 * sx,sy: half widths of search window
 * xmax,ymax: right/bottom limits of search area
 * iminp,jminp: pointers to where the result is stored
 *              result is given as half pel offset from ref(0,0)
 *              i.e. NOT relative to (i0,j0)
 */
void Logsearch(SvH261Info_t *H261, unsigned char *rm, unsigned char *rrm, unsigned char *cm)
{
  const int SearchLimit=H261->ME_search, Threshold=H261->ME_threshold/8;
  const int YHeight=H261->YHeight, YWidth=H261->YWidth;
  const int YHeight16=YHeight-16, YWidth16=YWidth-16;
  unsigned char *bptr, *cptr, *baseptr;
  register int MeN, i, j, x, y, px, py;
  int MX, MY, MV, val;
  int VAR, VAROR, MWOR;
  const int jump = YWidth;
  unsigned char data;

  int bsx,bsy,ijk;
  int srched_loc[33][33] ;
  struct five_loc{int  x ; int y ;} ij[5] ; 

  _SlibDebug(_VERBOSE_, 
        printf("BruteMotionEstimation(H261=0x%p, %p, %p, %p) In\n", 
                         H261, rm, rrm, cm) );
  _SlibDebug(_VERIFY_ && ((int)cm)%8,
           printf("FastBME() cm Not quad aligned\n") );

  for(MeN=0, y=0; y<YHeight; y+=16)
  {
    baseptr=cm + (y * YWidth);
    for(x=0; x<YWidth; x+=16, MeN++,baseptr+=16)
    {
      MX=MY=0;
      bptr = rrm + x + (y * YWidth);

#if 1
#ifdef USE_C
      MV = blockdiff16_C(baseptr, bptr, YWidth, 65536) / 4;
#else
      MV = blockdiff16(baseptr, bptr, YWidth, 65536) / 4;
#endif

#else

#ifdef USE_C
      MV = fblockdiff16_sub_C(baseptr, bptr, jump);
#else
      MV = fblockdiff16_sub(baseptr, bptr, jump);
#endif
#endif

      H261->PreviousMeOVal[MeN] = H261->MeOVal[MeN];  
      H261->MeOVal[MeN] = MV*4;
      _SlibDebug(_DEBUG_, printf("[00]MX %d MY %d MV %d\n",MX,MY,MV) );

      if (MV >= Threshold)
      { 
        int Xl, Xh, Yl, Yh;  

        Xl = x-SearchLimit;
        Xh = x+SearchLimit;
        Yl = y-SearchLimit;
        Yh = y+SearchLimit;
        if (Xl < 0) Xl = 0;
        if (Xh > YWidth16) Xh = YWidth16;
        if (Yl < 0) Yl = 0;
        if (Yh > YHeight16) Yh = YHeight16;

        /* x-y step size */
        if(SearchLimit > 8) bsx = bsy = 8 ;
        else if(SearchLimit > 4) bsx = bsy = 4 ;
        else  bsx = bsy = 2 ;

        /* initialized searched locations */
        for(i=0;i<33;i++)
           for(j=0;j<33;j++) srched_loc[i][j] = 0 ;

        /* The center of the seach window */
        i = x; 
		j = y;

        /* reduce window size by half until the window is 3x3 */
        for(;bsx > 1;bsx /= 2, bsy /= 2){

          /* five searched locations for each step */ 
          ij[0].x = i ;       ij[0].y = j ;     
          ij[1].x = i - bsx ; ij[1].y = j ;  
          ij[2].x = i + bsx ; ij[2].y = j ;    
          ij[3].x = i ;       ij[3].y = j - bsy;  
          ij[4].x = i ;       ij[4].y = j + bsy;  

          /* search */
          for(ijk = 0; ijk < 5; ijk++) {
            if(ij[ijk].x>=Xl && ij[ijk].x<=Xh && 
               ij[ijk].y>=Yl && ij[ijk].y<=Yh &&
               srched_loc[ij[ijk].x - x + 16][ij[ijk].y - y + 16] == 0)
            {
#ifdef USE_C
			  val = fblockdiff16_sub_C(baseptr, rrm +ij[ijk].x+ij[ijk].y*YWidth, jump);
#else
              val = fblockdiff16_sub(baseptr, rrm +ij[ijk].x+ij[ijk].y*YWidth, jump);
#endif
              srched_loc[ij[ijk].x - x + 16][ij[ijk].y - y + 16] = 1 ;

              if(val<MV)
              {
                MV = val ;
                MX = ij[ijk].x - x;  
				MY = ij[ijk].y - y;
              }
            }
          }

          /* if the best point was found, stop the search */
          if(MV == 0 ) break ; 
          else {      /* else, go to next step */
            i = MX + x;  
            j = MY + y;       
          }
        }

        px = MX + x;
        py = MY + y;    
        MV = 65536;  

		Xl = px - 1; 
		Xh = px + 1;
		Yl = py -1;
		Yh = py + 1;

        if (Xl < 0) Xl = 0;
        if (Xh > YWidth16) Xh = YWidth16;
        if (Yl < 0) Yl = 0;
        if (Yh > YHeight16) Yh = YHeight16;

        for (px=Xl; px<=Xh && MV>=Threshold; px++)
        {
          bptr = rrm + px + (Yl * YWidth);
          for (py=Yl; py<=Yh && MV>=Threshold; py++, bptr+=YWidth)
		  {
#ifdef USE_C
            val = blockdiff16_C(baseptr, bptr, YWidth, MV);
#else
            val = blockdiff16(baseptr, bptr, YWidth, MV);
#endif
            if (val < MV)
            {
              MV = val;
              MX = px - x;
              MY = py - y;
            }
          }
        }
      }

      _SlibDebug(_DEBUG_, printf("MeN=%d x=%d y=%d MX=%d MY=%d MV=%d\n", 
                                    MeN, x, y, MX, MY, MV) );  
      H261->MeX[MeN] = MX;
      H261->MeY[MeN] = MY;
      H261->MeVal[MeN] = MV;

      bptr = rrm + MX + x + ((MY+y) * YWidth);
      cptr = baseptr;
      for(VAR=0, MWOR=0, i=0; i<16; i++)
      {
        for(j=0; j<16; j++)
        {
          MWOR += (data=*cptr++);
          val = *bptr++ - data;
          VAR += (val > 0) ? val : -val;
        }
        bptr += YWidth16;
        cptr += YWidth16;
      }

      H261->MeVAR[MeN] = VAR;
      MWOR /= 256;
      H261->MeMWOR[MeN] = MWOR;

      cptr = baseptr;
      for(VAROR=0, i=0; i<16; i++)
      {
        for (j=0; j<16; j++)
        {
          val=*cptr++ - MWOR; if (val>0) VAROR += val; else VAROR -= val;
        }
        cptr += YWidth16;
      }
      H261->MeVAROR[MeN] = VAROR;
    }
  }

  _SlibDebug(_DEBUG_, printf("BruteMotionEstimation() Out\n") );
}


#if 0
/*************** This is the original BME *********************/
/*
** Function: FastBME()
** Purpose:  Does a fast brute-force motion estimation with two indexes
**           into two memory structures. The motion estimation has a
**           short-circuit abort to speed up calculation.
*/
void FastBME(SvH261Info_t *H261, int rx, int ry, 
             unsigned char *rm, unsigned char *rrm,
             int cx, int cy, unsigned char *cm, int MeN)
{
  int px,py;
  int MX, MY, MV, OMV;
  int Xl, Xh, Yl, Yh;  
  int VAR, VAROR, MWOR;
  int i,j,data,val;
  unsigned char *bptr,*cptr;
  unsigned char *baseptr;
  int count = 0;
  const int jump = 2*H261->YWidth;
  _SlibDebug(_DEBUG_, printf("FastBME(H261=0x%p) YWidth=%d YHeight=%d\n",
                             H261,H261->YWidth,H261->YHeight) );
  MX=MY=MV=0;
  bptr=rm + rx + (ry * H261->YWidth);
  baseptr=cm + cx + (cy * H261->YWidth);
  _SlibDebug(_VERIFY_ && ((int)baseptr)%8,
         printf(((int)baseptr)%8, "FastBME() baseptr Not quad aligned\n") );
  cptr=baseptr;
#ifdef USE_C
  MV = fblockdiff16_sub_C(baseptr, bptr, H261->YWidth);
#else
  MV = fblockdiff16_sub(baseptr, bptr, jump);
#endif
  OMV=MV*4;
  _SlibDebug(_DEBUG_, printf("[00]MX %d MY %d MV %d\n",MX,MY,MV) );
  cptr = baseptr;
  px=rx;
  py=ry;
  if(OMV > H261->MotionThreshold)
   { 
    MV = 362182; 
    Xl = ((rx-H261->SearchLimit)/2)*2;
    Xh = ((rx+H261->SearchLimit)/2)*2;
    Yl = ((ry-H261->SearchLimit)/2)*2;
    Yh = ((ry+H261->SearchLimit)/2)*2;
    Xl = (Xl < 0) ? 0 : Xl;
    Xh = (Xh > H261->YWidth-16) ? (H261->YWidth-16) : Xh;
    Yl = (Yl < 0) ? 0 : Yl;
    Yh = (Yh > H261->YHeight-16) ? (H261->YHeight-16) : Yh;
    for(px=Xl; px <=Xh ; px += 2)  {
        for(py=Yl; py <=Yh; py += 2)  {
              bptr = rm + px + (py * H261->YWidth);
              _SlibDebug(_DEBUG_, printf("blockdiff16_sub(%p, %p, %d, %d)\n",
                                         baseptr,bptr,H261->YWidth,MV) );
#ifdef USE_C
              val = blockdiff16_sub_C(baseptr, bptr, H261->YWidth);
#else
              val = blockdiff16_sub(baseptr, bptr, jump, MV);
#endif
              _SlibDebug(_DEBUG_, printf("blockdiff16_sub() Out val=%d\n",val));
		if (val < MV)
                {
                  MV = val;
                  MX = px - rx;
                  MY = py - ry;
                }
        }
    } 

    px = MX + rx;
    py = MY + ry;    
    bptr = rrm + px +(py*H261->YWidth); 

    MV = 232141;  
    Xl = px -1;
    Xh = px +1;
    Yl = py -1;
    Yh = py +1;
    Xl = (Xl < 0) ? 0 : Xl;
    Xh = (Xh > (H261->YWidth-16)) ? (H261->YWidth-16) : Xh;
    Yl = (Yl < 0) ? 0 : Yl;
    Yh = (Yh > (H261->YHeight-16)) ? (H261->YHeight-16) : Yh;
    count = 0;
    for(px=Xl;px<=Xh;px++) {
        for(py=Yl;py<=Yh;py++) {
              bptr = rrm + px + (py * H261->YWidth);
#ifdef USE_C
              val = blockdiff16_C(baseptr, bptr, H261->YWidth);
#else
              val = blockdiff16(baseptr, bptr, H261->YWidth,MV);
#endif
		if (val < MV)
                {
                  MV = val;
                  MX = px - rx;
                  MY = py - ry;
                }
            }
       }
  }
  
  bptr = rm + (MX+rx) + ((MY+ry) * H261->YWidth);
  cptr = baseptr;

  for(VAR=0,MWOR=0,i=0;i<16;i++)
      {
      for(j=0;j<16;j++)
          {
          data = *bptr - *cptr;
          VAR += Abs(data);
          MWOR += *cptr;
          bptr++;
          cptr++;
          }
      bptr += (H261->YWidth - 16);
      cptr += (H261->YWidth - 16);
      }
  MWOR = MWOR/256;
  VAR  = VAR;  
  cptr = baseptr;

  for(VAROR=0,i=0;i<16;i++)
      {
      for(j=0;j<16;j++)
          {
          VAROR += Abs(*cptr-MWOR);
          cptr++;
          }
      cptr += (H261->YWidth - 16);
      }
  /* VAROR = VAROR; */
  _SlibDebug(_DEBUG_, printf("\n Pos  %d  MX  %d  MY  %d", MeN, MX, MY) );  
  H261->MeVAR[MeN] = VAR;
  H261->MeVAROR[MeN] = VAROR;
  H261->MeMWOR[MeN] = MWOR;
  H261->MeX[MeN] = MX;
  H261->MeY[MeN] = MY;
  H261->MeVal[MeN] = MV;
  H261->PreviousMeOVal[MeN] = H261->MeOVal[MeN];  
  H261->MeOVal[MeN] = OMV;
 
  _SlibDebug(_DEBUG_, printf("FastBME() Out\n") );
}


/*
** Function: BruteMotionEstimation2()
** Purpose:  Does a brute-force motion estimation on all aligned
**           16x16 blocks in two memory structures.
*/
void BruteMotionEstimation2(SvH261Info_t *H261, unsigned char *pmem,
                           unsigned char *recmem, unsigned char *fmem)
{
  BEGIN("BruteMotionEstimation2");
  const int YHeight=H261->YHeight, YWidth=H261->YWidth;
  int x,y,MeN;
  _SlibDebug(_DEBUG_, printf("BruteMotionEstimation(H261=0x%p,%p,%p,%p) In\n", 
                         H261, pmem, recmem, fmem) );

  for(MeN=0,y=0; y<YHeight; y+=16)
      for(x=0; x<YWidth; x+=16, MeN++)
	  FastBME(H261,x,y,pmem,recmem, x,y,fmem,MeN);
  _SlibDebug(_DEBUG_, printf("BruteMotionEstimation2() Out\n") );
}
#endif

int blockdiff16_C(unsigned char* ptr1, unsigned char *ptr2, int Jump, int mv)
{
    int Sum=0, Pixel_diff, i, j, inc=Jump-16;
    _SlibDebug(_DEBUG_, 
               printf("blockdiff16_C(ptr1=%p, ptr2=%p, Jump=%d, MV=%d)\n",
                                   ptr1, ptr2, Jump, mv) );

    for(j=0;j<16;j++)  { 
        for(i=0;i<16;i++)  {
	    Pixel_diff = (*ptr1++ - *ptr2++);
            Sum +=  Abs(Pixel_diff); 
        }
	_SlibDebug(_DEBUG_, printf ("Sum: %d MV: %d \n" , Sum, mv) );
	if (Sum > mv)
	  break;  
        ptr1 += inc; 
        ptr2 += inc;
    } 
    return(Sum);
}  


int blockdiff16_sub_C(unsigned char* ptr1, unsigned char *ptr2, 
                      int Jump, int mv)
{
    int Sum=0, Pixel_diff, i,j,inc=2*Jump-16;
    _SlibDebug(_DEBUG_, 
               printf("blockdiff16_sub_C(ptr1=%p, ptr2=%p, Jump=%d, MV=%d)\n",
                                   ptr1, ptr2, Jump, mv) );
    for(j=0; j<8; j++)  {
        for(i=0; i<8; i++)  {
            Pixel_diff = (*ptr1 - *ptr2);
            ptr1 += 2;
            ptr2 += 2;
            Sum +=  Abs(Pixel_diff);
        }
        _SlibDebug(_DEBUG_, printf("Sum: %d MV: %d \n", Sum, mv) );

	if (Sum > mv)
	    break;

        ptr1 += inc;
        ptr2 += inc;
    }
    _SlibDebug(_DEBUG_, printf("blockdiff16_sub_C() Out\n") );

    return(Sum);
}

/*
** Function: fblockdiff16_sub_C
** Purpose:  First blcok diff.
*/
int fblockdiff16_sub_C(unsigned char* ptr1, unsigned char *ptr2, 
                           int Jump)
{
    int Sum=0, Pixel_diff, i,j, inc=2*Jump-16;
    _SlibDebug(_DEBUG_, 
               printf("fblockdiff16_sub_C(ptr1=%p, ptr2=%p, Jump=%d)\n",
                                   ptr1, ptr2, Jump) );
    for(j=0; j<8; j++)  {
        for(i=0; i<8; i++)  {
            Pixel_diff = (*ptr1 - *ptr2);
            ptr1 += 2;
            ptr2 += 2;
            Sum +=  Abs(Pixel_diff);
        }
        ptr1 += inc;
        ptr2 += inc;
    }

    return(Sum);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech261\marker.c ===
/* File: sv_h261_marker.c */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995, 1997                 **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/
/*************************************************************
This file contains most of the marker information.
*************************************************************/

/*
#define _VERBOSE_
*/

/*LABEL marker.c */
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "sv_intrn.h"
#include "SC.h"
#include "SC_err.h"
#include "sv_h261.h"
#include "proto.h"
#include "sv_proto.h"
#include "h261.h"

/*PRIVATE*/
/*extern int TemporalReference;
extern int PType;
*/
extern int Type2;
/*
extern int MType;
extern int GQuant;
extern int MQuant;
*/
/*
extern int MVDH;
extern int MVDV;
extern int CBP;
*/
/*
extern int ParityEnable;
extern int PSpareEnable;
extern int GSpareEnable;
extern int Parity;
extern int PSpare;
extern int GSpare;
extern int GRead;
extern int MBA;
extern int LastMBA;

extern int LastMVDV;
extern int LastMVDH;

extern int LastMType;
*/
extern int QuantMType[];
extern int CBPMType[];
extern int MFMType[];


extern int extend_mask[];


const int bit_set_mask[] =
{0x00000001,0x00000002,0x00000004,0x00000008,
0x00000010,0x00000020,0x00000040,0x00000080,
0x00000100,0x00000200,0x00000400,0x00000800,
0x00001000,0x00002000,0x00004000,0x00008000,
0x00010000,0x00020000,0x00040000,0x00080000,
0x00100000,0x00200000,0x00400000,0x00800000,
0x01000000,0x02000000,0x04000000,0x08000000,
0x10000000,0x20000000,0x40000000,0x80000000};

/*
** Function: WritePictureHeader()
** Purpose:  Writes the header of picture out to the stream.
**           One of these is necessary before every frame is transmitted.
*/
void WritePictureHeader(SvH261Info_t *H261, ScBitstream_t *bs)
{
  sc_vprintf("WritePictureHeader()\n");
  ScBSPutBits(bs, H261_PICTURE_START_CODE, H261_PICTURE_START_CODE_LEN);
  ScBSPutBits(bs, H261->TemporalReference, 5);
  ScBSPutBits(bs, H261->PType, 6);
  if (H261->PSpareEnable)
  {
    ScBSPutBit(bs, 1);
    ScBSPutBits(bs, H261->PSpare, 8);
  }
  ScBSPutBit(bs, 0);
}


/*
** Function: ReadPictureHeader()
** Purpose:  Reads the header off of the stream. It assumes that the
**           first PSC has already been read in. (Necessary to tell the
**           difference between a new picture and another GOB.)
*/
void ReadPictureHeader(SvH261Info_t *H261, ScBitstream_t *bs)
{
  sc_vprintf ("ReadPictureHeader \n");

  H261->TemporalReference = (int) ScBSGetBits(bs,5);

  H261->PType = (int)ScBSGetBits(bs,6);
  for(H261->PSpareEnable = 0;ScBSGetBit(bs);)
  {
    H261->PSpareEnable=1;
    H261->PSpare = (int)ScBSGetBits(bs,8);
  }
}


/*
** Function: WriteGOBHeader()
** Purpose:  Writes a GOB out to the stream.
*/
void WriteGOBHeader(SvH261Info_t *H261, ScBitstream_t *bs)
{
  sc_vprintf("WriteGOBHeader()\n");

  ScBSPutBits(bs, H261_GOB_START_CODE, H261_GOB_START_CODE_LEN);
  ScBSPutBits(bs, H261->GRead+1, 4);
  ScBSPutBits(bs, H261->GQuant, 5);
  if (H261->GSpareEnable)
  {
    ScBSPutBit(bs, 1);
    ScBSPutBits(bs, H261->GSpare, 8);
  }
  ScBSPutBit(bs, 0);
}


/*
** Function: ReadHeaderTrailer()
** Purpose:  Reads the trailer of the PSC or H261_GOB_START_CODE code. It is
**           used to determine whether it is just a GOB or a new picture.
*/
void ReadHeaderTrailer(SvH261Info_t *H261, ScBitstream_t *bs)
{
  sc_vprintf("ReadHeaderTrailer \n");

  H261->GRead = (int)ScBSGetBits(bs, 4)-1;
}

/*
** Function: ReadHeaderHeader()
** Purpose:  Reads the header header off of the stream. This is
**           a precursor to the GOB read or the PSC read. 
** Return:   -1 on error
*/
SvStatus_t ReadHeaderHeader(SvH261Info_t *H261, ScBitstream_t *bs)
{
  int input;

  sc_vprintf("ReadHeaderHeader\n");

  input = (int)ScBSPeekBits(bs, H261_GOB_START_CODE_LEN);
  if (input != H261_GOB_START_CODE)
  {
    if (!ScBSSeekStopBefore(bs, H261_GOB_START_CODE, H261_GOB_START_CODE_LEN))
    {
      sc_dprintf("Illegal GOB Start Code. Read: %d\n",input);
      return(SvErrorIllegalGBSC);
    }
  }
  input = (int)ScBSGetBits(bs, H261_GOB_START_CODE_LEN);
  return(NoErrors);
}


/*
** Function: ReadGOBHeader()
** Purpose:  Reads the GOB information off of the stream. We assume
**           that the first bits have been read in by ReadHeaderHeader... 
**           or some such routine.
*/
void ReadGOBHeader(SvH261Info_t *H261, ScBitstream_t *bs)
{
  sc_vprintf("ReadGOBHeader()\n");

  H261->GQuant =(int)ScBSGetBits(bs,5);
  for(H261->GSpareEnable=0; ScBSGetBit(bs);)
  {
    H261->GSpareEnable = 1;
    H261->GSpare =  (int)ScBSGetBits(bs,8);
  }
}

/*
** Function: WriteMBHeader()
** Purpose:  Writes a macro-block out to the stream.
*/
SvStatus_t WriteMBHeader(SvH261Info_t *H261, ScBitstream_t *bs)
{
 
  int TempH,TempV;
  ScBSPosition_t Start;
  sc_vprintf("WriteMBHeader()\n");
  
  sc_dprintf("\n Macro Block Type is %d and MQuant is %d", 
                                  H261->MType, H261->MQuant); 
  Start=ScBSBitPosition(bs);  /* Start=swtellb(H261); */
  if (!sv_H261HuffEncode(H261,bs,H261->MBA,H261->MBAEHuff))
    {
      sc_dprintf("Attempting to write an empty Huffman code.\n");
      return (SvErrorEmptyHuff);

    }
  if (!sv_H261HuffEncode(H261,bs,H261->MType,H261->T3EHuff))
    {
      sc_dprintf("Attempting to write an empty Huffman code.\n");
      return (SvErrorEmptyHuff);

    }
  if (QuantMType[H261->MType])
    ScBSPutBits(bs, H261->MQuant, 5);  /* mputvb(H261, 5, H261->MQuant); */

  H261->NumberBitsCoded=0;
  if (MFMType[H261->MType])
    {
      if ((!MFMType[H261->LastMType])||(H261->MBA!=1)||
	  (H261->LastMBA==-1)||(H261->LastMBA==10)||(H261->LastMBA==21))
	{
	  if (!sv_H261HuffEncode(H261,bs,(H261->MVDH&0x1f),H261->MVDEHuff)||
	       !sv_H261HuffEncode(H261,bs,(H261->MVDV&0x1f),H261->MVDEHuff))
	    {
            sc_dprintf("Cannot encode motion vectors.\n");
	    return (SvErrorEncodingMV);
	    }
	}
      else
	{
	  TempH = H261->MVDH - H261->LastMVDH;
	  if (TempH < -16) TempH += 32;
	  if (TempH > 15) TempH -= 32;
	  TempV = H261->MVDV - H261->LastMVDV;
	  if (TempV < -16) TempV += 32;
	  if (TempV > 15) TempV -= 32;
	  if (!sv_H261HuffEncode(H261,bs,TempH&0x1f,H261->MVDEHuff)||
              !sv_H261HuffEncode(H261,bs,TempV&0x1f,H261->MVDEHuff))
            {
	    sc_dprintf("Cannot encode motion vectors.\n");
	    return  (SvErrorEncodingMV);
	    }
	}
      H261->LastMVDV = H261->MVDV;
      H261->LastMVDH = H261->MVDH;
    }
  else
    {
      H261->LastMVDV=H261->LastMVDH=H261->MVDV=H261->MVDH=0; /* Redundant in most cases */
    }

  H261->MotionVectorBits+=H261->NumberBitsCoded;
  if (CBPMType[H261->MType])
    {
      if (!sv_H261HuffEncode(H261,bs,H261->CBP,H261->CBPEHuff))
	{
	sc_dprintf("CBP write error\n");
	return (SvErrorCBPWrite);
	}
    }
  H261->Current_MBBits = ScBSBitPosition(bs)-Start; /* (swtellb(H261)-Start); */
  H261->MacroAttributeBits+=H261->Current_MBBits ;
return (NoErrors);

}

/*
** Function: ReadMBHeader()
** Purpose:  Reads the macroblock header from the stream.
*/
int ReadMBHeader(SvH261Info_t *H261, ScBitstream_t *bs)
{
  DHUFF *huff = H261->MBADHuff;
  register unsigned short cb;
  register int State, temp;

  do {
    DecodeHuff(bs, huff, State, cb, temp);
  } while (State == 34 && ! bs->EOI);  /* Get rid of stuff bits */
  H261->MBA = State;
  if (H261->MBA == 35 || bs->EOI)
    return(-1); /* Start of Picture Headers */

  H261->LastMType = H261->MType;
  huff = H261->T3DHuff;
  DecodeHuff(bs, huff, State, cb, temp);
  H261->MType = State;
  if (QuantMType[H261->MType])
     H261->MQuant = (int)ScBSGetBits(bs,5);
  huff = H261->MVDDHuff;
  if (MFMType[H261->MType])
  {
    if ((!MFMType[H261->LastMType])||(H261->MBA!=1)||
	  (H261->LastMBA==-1)||(H261->LastMBA==10)||(H261->LastMBA==21))
    {
      DecodeHuff(bs, huff, State, cb, temp);
      if (State & bit_set_mask[4])
        H261->MVDH = State | extend_mask[4];
      else
        H261->MVDH = State;

      DecodeHuff(bs, huff, State, cb, temp);
      if (State & bit_set_mask[4])
        H261->MVDV = State | extend_mask[4];
      else
        H261->MVDV = State;
    }
    else
    {
      DecodeHuff(bs, huff, State, cb, temp);
      if (State & bit_set_mask[4])
        State |= extend_mask[4];
      H261->MVDH += State;
	  
      DecodeHuff(bs, huff, State, cb, temp);
      if (State & bit_set_mask[4])
        State |= extend_mask[4];
      H261->MVDV += State;

      if (H261->MVDH < -16) H261->MVDH += 32;
      if (H261->MVDH > 15) H261->MVDH -= 32;
      if (H261->MVDV < -16) H261->MVDV += 32;
      if (H261->MVDV > 15) H261->MVDV -= 32;
    }
  }
  else
    H261->MVDV=H261->MVDH=0;  /* Theoretically redundant */
  if (CBPMType[H261->MType])
  {
    huff = H261->CBPDHuff;
    DecodeHuff(bs, huff, State, cb, temp);
    H261->CBP = State;
  }
  return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech261\render.c ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: slib_render.c,v $
 * Revision 1.1.2.3  1996/10/28  17:32:35  Hans_Graves
 * 	MME-1402, 1431, 1435: Timestamp related changes.
 * 	[1996/10/28  17:23:09  Hans_Graves]
 *
 * Revision 1.1.2.2  1996/10/12  17:18:58  Hans_Graves
 * 	Move render related code out of slib_api.c
 * 	[1996/10/11  21:19:37  Hans_Graves]
 * 
 * $EndLog$
 */

/*
#define _SLIBDEBUG_
*/

#define SLIB_INTERNAL
#include "slib.h"
#include "SC_err.h"
#include "SC_conv.h"

#ifdef _SLIBDEBUG_
#include "sc_debug.h"
#define _DEBUG_     0  /* detailed debuging statements */
#define _VERBOSE_   1  /* show progress */
#define _VERIFY_    1  /* verify correct operation */
#define _WARN_      1  /* warnings about strange behavior */
#endif

SlibStatus_t slibConvertAudio(SlibInfo_t *Info,
                              void *inbuf, unsigned dword inbufsize,
                              unsigned int insps, unsigned int inbps,
                              void **poutbuf, unsigned dword *poutbufsize,
                              unsigned int outsps, unsigned int outbps,
                              unsigned int channels)
{
  char *fromptr, *toptr;
  unsigned dword outbufsize, samples, count;
  unsigned dword ratio, spsratio;
  char *outbuf;
  if (inbps==outbps && insps==outsps)/* input and output formats are the same */
  {
    if (*poutbuf==NULL)
    {
      SlibAllocSubBuffer(inbuf, inbufsize);
      *poutbuf=inbuf;
    }
    else
      memcpy(*poutbuf, inbuf, inbufsize);
    *poutbufsize=inbufsize;
    return(SlibErrorNone);
  }
  samples = inbufsize/(inbps/2);
  ratio=(insps*inbps*256)/(outsps*outbps);
  outbufsize = (inbufsize*256)/ratio;
  spsratio=(insps*256)/outsps;
  if (spsratio!=64 && spsratio!=128 && spsratio!=256 && spsratio!=512)
    return(SlibErrorUnsupportedFormat);
  if (*poutbuf==NULL)
  {
    outbuf=SlibAllocBuffer(outbufsize);
    *poutbuf=outbuf;
    if (outbuf==NULL)
      return(SlibErrorMemory);
  }
  else
    outbuf=*poutbuf;
  *poutbufsize=outbufsize;
  fromptr = (char *)inbuf;
  toptr = (char *)outbuf;
  if (inbps==16 && outbps==8) /* 16 bit -> 8 bit */
  {
    fromptr++;
    if (spsratio==64) /* insps==outsps/4 */
    {
      if (channels==1)
        for (count=inbufsize/2; count; count--, fromptr+=2)
        {
          *toptr++ = *fromptr+128;
          *toptr++ = *fromptr+128;
          *toptr++ = *fromptr+128;
          *toptr++ = *fromptr+128;
        }
      else
        for (count=inbufsize/4; count; count--, fromptr+=4)
        {
          *toptr++ = fromptr[0]+128;
          *toptr++ = fromptr[2]+128;
          *toptr++ = fromptr[0]+128;
          *toptr++ = fromptr[2]+128;
          *toptr++ = fromptr[0]+128;
          *toptr++ = fromptr[2]+128;
          *toptr++ = fromptr[0]+128;
          *toptr++ = fromptr[2]+128;
        }
      return(SlibErrorNone);
    }
    else if (spsratio==128) /* insps==outsps/2 */
    {
      if (channels==1)
        for (count=inbufsize/2; count; count--, fromptr+=2)
        {
          *toptr++ = *fromptr+128;
          *toptr++ = *fromptr+128;
        }
      else
        for (count=inbufsize/4; count; count--, fromptr+=4)
        {
          *toptr++ = fromptr[0]+128;
          *toptr++ = fromptr[2]+128;
          *toptr++ = fromptr[0]+128;
          *toptr++ = fromptr[2]+128;
        }
      return(SlibErrorNone);
    }
    else if (spsratio==256) /* insps==outsps */
    {
      for (count=inbufsize/2; count; count--, fromptr+=2)
        *toptr++ = *fromptr+128;
      return(SlibErrorNone);
    }
    else if (spsratio==512) /* insps==outsps*2 */
    {
      if (channels==1)
        for (count=inbufsize/4; count; count--, fromptr+=4)
          *toptr++ = *fromptr+128;
      else
        for (count=inbufsize/8; count; count--, fromptr+=8)
        {
          *toptr++ = fromptr[0]+128;
          *toptr++ = fromptr[2]+128;
        }
      return(SlibErrorNone);
    }
  }
  else if (inbps==8 && outbps==16) /* 8 bit -> 16 bit */
  {
    unsigned word left, right;
    if (spsratio==64) /* insps==outsps/4 */
    {
      if (channels==1)
        for (count=inbufsize; count; count--, fromptr++)
        {
          left=(*fromptr-128)<<8;
          *toptr++ = left&0xFF;
          *toptr++ = left>>8;
          *toptr++ = left&0xFF;
          *toptr++ = left>>8;
          *toptr++ = left&0xFF;
          *toptr++ = left>>8;
          *toptr++ = left&0xFF;
          *toptr++ = left>>8;
        }
      else /* stereo */
        for (count=inbufsize/2; count; count--, fromptr+=2)
        {
          left=(fromptr[0]-128)<<8;
          right=(fromptr[1]-128)<<8;
          *toptr++ = left&0xFF;
          *toptr++ = left>>8;
          *toptr++ = right&0xFF;
          *toptr++ = right>>8;
          *toptr++ = left&0xFF;
          *toptr++ = left>>8;
          *toptr++ = right&0xFF;
          *toptr++ = right>>8;
          *toptr++ = left&0xFF;
          *toptr++ = left>>8;
          *toptr++ = right&0xFF;
          *toptr++ = right>>8;
          *toptr++ = left&0xFF;
          *toptr++ = left>>8;
          *toptr++ = right&0xFF;
          *toptr++ = right>>8;
        }
      return(SlibErrorNone);
    }
    else if (spsratio==128) /* insps==outsps/2 */
    {
      if (channels==1)
        for (count=inbufsize; count; count--, fromptr++)
        {
          left=(*fromptr-128)<<8;
          *toptr++ = left&0xFF;
          *toptr++ = left>>8;
          *toptr++ = left&0xFF;
          *toptr++ = left>>8;
        }
      else /* stereo */
        for (count=inbufsize/2; count; count--, fromptr+=2)
        {
          left=(fromptr[0]-128)<<8;
          right=(fromptr[1]-128)<<8;
          *toptr++ = left&0xFF;
          *toptr++ = left>>8;
          *toptr++ = right&0xFF;
          *toptr++ = right>>8;
          *toptr++ = left&0xFF;
          *toptr++ = left>>8;
          *toptr++ = right&0xFF;
          *toptr++ = right>>8;
        }
      return(SlibErrorNone);
    }
    else if (spsratio==256) /* insps==outsps */
    {
      if (channels==1)
        for (count=inbufsize; count; count--, fromptr++)
        {
          left=(*fromptr-128)<<8;
          *toptr++ = left&0xFF;
          *toptr++ = left>>8;
        }
      else /* stereo */
        for (count=inbufsize/2; count; count--, fromptr+=2)
        {
          left=(fromptr[0]-128)<<8;
          right=(fromptr[1]-128)<<8;
          *toptr++ = left&0xFF;
          *toptr++ = left>>8;
          *toptr++ = right&0xFF;
          *toptr++ = right>>8;
        }
      return(SlibErrorNone);
    }
    else if (spsratio==512) /* insps==outsps*2 */
    {
      if (channels==1)
        for (count=inbufsize/2; count; count--, fromptr+=2)
        {
          left=(*fromptr-128)<<8;
          *toptr++ = left&0xFF;
          *toptr++ = left>>8;
        }
      else /* stereo */
        for (count=inbufsize/4; count; count--, fromptr+=4)
        {
          left=(fromptr[0]-128)<<8;
          right=(fromptr[1]-128)<<8;
          *toptr++ = left&0xFF;
          *toptr++ = left>>8;
          *toptr++ = right&0xFF;
          *toptr++ = right>>8;
        }
      return(SlibErrorNone);
    }
  }
  else if (inbps==16 && outbps==16) /* 16 bit -> 16 bit */
  {
    if (spsratio==64) /* insps==outsps/4 */
    {
      if (channels==1)
        for (count=inbufsize/2; count; count--, fromptr+=2)
        {
          *toptr++ = fromptr[0];
          *toptr++ = fromptr[1];
          *toptr++ = fromptr[0];
          *toptr++ = fromptr[1];
          *toptr++ = fromptr[0];
          *toptr++ = fromptr[1];
          *toptr++ = fromptr[0];
          *toptr++ = fromptr[1];
        }
      else /* stereo */
        for (count=inbufsize/4; count; count--, fromptr+=4)
        {
          *toptr++ = fromptr[0];
          *toptr++ = fromptr[1];
          *toptr++ = fromptr[2];
          *toptr++ = fromptr[3];
          *toptr++ = fromptr[0];
          *toptr++ = fromptr[1];
          *toptr++ = fromptr[2];
          *toptr++ = fromptr[3];
          *toptr++ = fromptr[0];
          *toptr++ = fromptr[1];
          *toptr++ = fromptr[2];
          *toptr++ = fromptr[3];
          *toptr++ = fromptr[0];
          *toptr++ = fromptr[1];
          *toptr++ = fromptr[2];
          *toptr++ = fromptr[3];
        }
      return(SlibErrorNone);
    }
    else if (spsratio==128) /* insps==outsps/2 */
    {
      if (channels==1)
        for (count=inbufsize/2; count; count--, fromptr+=2)
        {
          *toptr++ = fromptr[0];
          *toptr++ = fromptr[1];
          *toptr++ = fromptr[0];
          *toptr++ = fromptr[1];
        }
      else /* stereo */
        for (count=inbufsize/4; count; count--, fromptr+=4)
        {
          *toptr++ = fromptr[0];
          *toptr++ = fromptr[1];
          *toptr++ = fromptr[2];
          *toptr++ = fromptr[3];
          *toptr++ = fromptr[0];
          *toptr++ = fromptr[1];
          *toptr++ = fromptr[2];
          *toptr++ = fromptr[3];
        }
      return(SlibErrorNone);
    }
    else if (spsratio==512) /* insps==outsps*2 */
    {
      if (channels==1)
        for (count=inbufsize/4; count; count--, fromptr+=4)
        {
          *toptr++ = fromptr[0];
          *toptr++ = fromptr[1];
        }
      else /* stereo */
        for (count=inbufsize/8; count; count--, fromptr+=8)
        {
          *toptr++ = fromptr[0];
          *toptr++ = fromptr[1];
          *toptr++ = fromptr[2];
          *toptr++ = fromptr[3];
        }
      return(SlibErrorNone);
    }
  }
  else if (inbps==8 && outbps==8) /* 8 bit -> 8 bit */
  {
    if (spsratio==64) /* insps==outsps/4 */
    {
      if (channels==1)
        for (count=inbufsize; count; count--, fromptr++)
        {
          *toptr++ = *fromptr;
          *toptr++ = *fromptr;
          *toptr++ = *fromptr;
          *toptr++ = *fromptr;
        }
      else /* stereo */
        for (count=inbufsize/2; count; count--, fromptr+=2)
        {
          *toptr++ = fromptr[0];
          *toptr++ = fromptr[1];
          *toptr++ = fromptr[0];
          *toptr++ = fromptr[1];
          *toptr++ = fromptr[0];
          *toptr++ = fromptr[1];
          *toptr++ = fromptr[0];
          *toptr++ = fromptr[1];
        }
      return(SlibErrorNone);
    }
    else if (spsratio==128) /* insps==outsps/2 */
    {
      if (channels==1)
        for (count=inbufsize; count; count--, fromptr++)
        {
          *toptr++ = *fromptr;
          *toptr++ = *fromptr;
        }
      else /* stereo */
        for (count=inbufsize/2; count; count--, fromptr+=2)
        {
          *toptr++ = fromptr[0];
          *toptr++ = fromptr[1];
          *toptr++ = fromptr[0];
          *toptr++ = fromptr[1];
        }
      return(SlibErrorNone);
    }
    else if (spsratio==512) /* insps==outsps*2 */
    {
      if (channels==1)
        for (count=inbufsize/2; count; count--, fromptr+=2)
          *toptr++ = *fromptr;
      else /* stereo */
        for (count=inbufsize/4; count; count--, fromptr+=4)
        {
          *toptr++ = fromptr[0];
          *toptr++ = fromptr[1];
        }
      return(SlibErrorNone);
    }
  }
  *poutbufsize=0;
  return(SlibErrorUnsupportedFormat);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech261\param.c ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: slib_param.c,v $
 * Revision 1.1.6.25  1996/12/13  18:19:09  Hans_Graves
 * 	Adjust file size in NEED_ACCURACY, if end of file is bad.
 * 	[1996/12/13  18:13:11  Hans_Graves]
 *
 * Revision 1.1.6.24  1996/12/12  20:54:47  Hans_Graves
 * 	Fixed NT compile warning with use of ftime.
 * 	[1996/12/12  20:51:38  Hans_Graves]
 * 
 * Revision 1.1.6.23  1996/12/05  20:10:18  Hans_Graves
 * 	Change max choosen MPEG audio bitrate to 192kbits
 * 	[1996/12/05  20:09:25  Hans_Graves]
 * 
 * Revision 1.1.6.22  1996/12/04  22:34:34  Hans_Graves
 * 	Make seeking in NEEDACCURACY quicker when seeks fail.
 * 	[1996/12/04  22:20:18  Hans_Graves]
 * 
 * Revision 1.1.6.21  1996/12/03  23:15:18  Hans_Graves
 * 	MME-1498: Made seeks with PERCENT100 more accurate
 * 	[1996/12/03  23:10:48  Hans_Graves]
 * 
 * Revision 1.1.6.20  1996/12/03  00:08:36  Hans_Graves
 * 	Handling of End Of Sequence points. Added PERCENT100 support.
 * 	[1996/12/03  00:06:06  Hans_Graves]
 * 
 * Revision 1.1.6.19  1996/11/18  23:07:38  Hans_Graves
 * 	Make use of presentation timestamps. Make seeking time-based.
 * 	[1996/11/18  22:48:00  Hans_Graves]
 * 
 * Revision 1.1.6.18  1996/11/14  22:32:10  Hans_Graves
 * 	AUDIOCHANNELS can only be changed under AC3 decompression.
 * 	[1996/11/14  22:31:39  Hans_Graves]
 * 
 * Revision 1.1.6.17  1996/11/14  21:49:29  Hans_Graves
 * 	Multichannel setting using AUDIOCHANNELS param.
 * 	[1996/11/14  21:44:44  Hans_Graves]
 * 
 * Revision 1.1.6.16  1996/11/11  18:21:10  Hans_Graves
 * 	Added SlibGetParamString() support for SLIB_PARAM_TYPE.
 * 	[1996/11/11  18:01:25  Hans_Graves]
 * 
 * Revision 1.1.6.15  1996/11/08  21:51:08  Hans_Graves
 * 	Added new PARAMs VIDEOMAINSTREAM, AUDIOMAINSTREAM and TYPE
 * 	[1996/11/08  21:31:08  Hans_Graves]
 * 
 * Revision 1.1.6.14  1996/10/28  17:32:34  Hans_Graves
 * 	MME-1402, 1431, 1435: Timestamp related changes.
 * 	[1996/10/28  17:23:07  Hans_Graves]
 * 
 * Revision 1.1.6.13  1996/10/17  00:23:36  Hans_Graves
 * 	Added SLIB_PARAM_VIDEOFRAME and SLIB_PARAM_FRAMEDURATION.
 * 	[1996/10/17  00:19:44  Hans_Graves]
 * 
 * Revision 1.1.6.12  1996/10/12  17:18:56  Hans_Graves
 * 	Added SLIB_PARAM_SKIPPEL and SLIB_PARAM_HALFPEL support.
 * 	[1996/10/12  17:02:37  Hans_Graves]
 * 
 * Revision 1.1.6.11  1996/10/03  19:14:26  Hans_Graves
 * 	Added Presentation and Decoding timestamp support.
 * 	[1996/10/03  19:10:42  Hans_Graves]
 * 
 * Revision 1.1.6.10  1996/09/29  22:19:44  Hans_Graves
 * 	Added STRIDE param.
 * 	[1996/09/29  21:31:34  Hans_Graves]
 * 
 * Revision 1.1.6.9  1996/09/25  19:16:50  Hans_Graves
 * 	Added SLIB_INTERNAL define.
 * 	[1996/09/25  19:01:56  Hans_Graves]
 * 
 * Revision 1.1.6.8  1996/09/23  18:04:05  Hans_Graves
 * 	Added STATS params.
 * 	[1996/09/23  17:58:54  Hans_Graves]
 * 
 * Revision 1.1.6.7  1996/09/18  23:47:17  Hans_Graves
 * 	Added new PARAMs: VBV, ASPECTRATIO, TIMECODE, VERSION
 * 	[1996/09/18  22:07:17  Hans_Graves]
 * 
 * Revision 1.1.6.6  1996/08/09  20:51:53  Hans_Graves
 * 	Allows deselecting of SLIB_PARAM_VIDEOSTREAMS and SLIB_PARAM_AUDIOSTREAMS
 * 	[1996/08/09  20:12:16  Hans_Graves]
 * 
 * Revision 1.1.6.5  1996/07/30  20:25:38  Wei_Hsu
 * 	Add motion algorithm param.
 * 	[1996/07/30  15:59:07  Wei_Hsu]
 * 
 * Revision 1.1.6.4  1996/07/19  02:11:17  Hans_Graves
 * 	Added SLIB_PARAM_DEBUG support
 * 	[1996/07/19  01:59:50  Hans_Graves]
 * 
 * Revision 1.1.6.3  1996/05/23  18:46:38  Hans_Graves
 * 	Merge MME-1220 & MME-1221 - Multiply MPEG audio bitrates by 1000 instead of 1024
 * 	[1996/05/23  18:46:09  Hans_Graves]
 * 
 * Revision 1.1.6.2  1996/05/10  21:17:47  Hans_Graves
 * 	Allow FILESIZE param to be set, for callbacks.
 * 	[1996/05/10  20:46:23  Hans_Graves]
 * 
 * Revision 1.1.4.13  1996/04/30  17:05:35  Hans_Graves
 * 	Report SlibErrorSettingNotEqual correctly under SetParamFloat(). Fixes MME-01173
 * 	[1996/04/30  16:49:06  Hans_Graves]
 * 
 * Revision 1.1.4.12  1996/04/24  22:33:48  Hans_Graves
 * 	MPEG encoding bitrate fixups.
 * 	[1996/04/24  22:27:16  Hans_Graves]
 * 
 * Revision 1.1.4.11  1996/04/23  21:01:42  Hans_Graves
 * 	Fix SlibValidateParams(). Add error checking for SlibErrorSettingNotEqual
 * 	[1996/04/23  20:59:03  Hans_Graves]
 * 
 * Revision 1.1.4.10  1996/04/22  15:04:54  Hans_Graves
 * 	Added SlibValidateParams()
 * 	[1996/04/22  14:43:04  Hans_Graves]
 * 
 * Revision 1.1.4.9  1996/04/19  21:52:26  Hans_Graves
 * 	Fix BITRATE parameter settings
 * 	[1996/04/19  21:47:01  Hans_Graves]
 * 
 * Revision 1.1.4.8  1996/04/11  14:14:12  Hans_Graves
 * 	Fix NT warnings
 * 	[1996/04/11  14:10:21  Hans_Graves]
 * 
 * Revision 1.1.4.7  1996/04/10  21:47:43  Hans_Graves
 * 	Added params: FASTENCODE, FASTDECODE, and QUALITY
 * 	[1996/04/10  21:40:18  Hans_Graves]
 * 
 * Revision 1.1.4.6  1996/04/09  16:04:43  Hans_Graves
 * 	Handle setting negative Height
 * 	[1996/04/09  14:42:13  Hans_Graves]
 * 
 * Revision 1.1.4.5  1996/04/01  19:07:57  Hans_Graves
 * 	And some error checking
 * 	[1996/04/01  19:04:40  Hans_Graves]
 * 
 * Revision 1.1.4.4  1996/04/01  16:23:17  Hans_Graves
 * 	NT porting
 * 	[1996/04/01  16:16:03  Hans_Graves]
 * 
 * Revision 1.1.4.3  1996/03/12  16:15:54  Hans_Graves
 * 	Added SLIB_PARAM_FILEBUFSIZE param
 * 	[1996/03/12  15:54:22  Hans_Graves]
 * 
 * Revision 1.1.4.2  1996/03/08  18:46:49  Hans_Graves
 * 	Added SlibGetParamString()
 * 	[1996/03/08  18:34:51  Hans_Graves]
 * 
 * Revision 1.1.2.6  1996/02/07  23:23:59  Hans_Graves
 * 	Added SEEK_EXACT. Fixed most frame counting problems.
 * 	[1996/02/07  23:20:37  Hans_Graves]
 * 
 * Revision 1.1.2.5  1996/02/06  22:54:08  Hans_Graves
 * 	Seek fix-ups. More accurate MPEG frame counts.
 * 	[1996/02/06  22:45:21  Hans_Graves]
 * 
 * Revision 1.1.2.4  1996/02/02  17:36:05  Hans_Graves
 * 	Enhanced audio info. Cleaned up API
 * 	[1996/02/02  17:29:49  Hans_Graves]
 * 
 * Revision 1.1.2.3  1996/01/15  16:26:32  Hans_Graves
 * 	Added Audio Params
 * 	[1996/01/15  15:48:20  Hans_Graves]
 * 
 * Revision 1.1.2.2  1996/01/11  16:17:35  Hans_Graves
 * 	First time under SLIB
 * 	[1996/01/11  16:11:45  Hans_Graves]
 * 
 * $EndLog$
 */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

/*
#define _SLIBDEBUG_
*/

#include <stdio.h>
#ifdef WIN32
#include  <time.h>
#include  <sys/timeb.h>
#else
#include  <sys/time.h>
#endif /* WIN32 */
#define SLIB_INTERNAL
#include "slib.h"
#include "SC_err.h"

#ifdef _SLIBDEBUG_
#define _DEBUG_     1  /* detailed debuging statements */
#define _VERBOSE_   1  /* show progress */
#define _VERIFY_    1  /* verify correct operation */
#define _WARN_      1  /* warnings about strange behavior */
#endif

static float _version       = 2.10F;
static char _version_date[] = { __DATE__ };

SlibTime_t slibGetSystemTime()
{
  SlibTime_t mstime;
#ifdef WIN32
  struct _timeb t ;
  _ftime(&t);
  mstime = (SlibTime_t)(t.time * 1000 + t.millitm);
#else
  struct timeval t;
  struct timezone tz;

  gettimeofday(&t, &tz);
  mstime = (SlibTime_t)(t.tv_sec * 1000 + t.tv_usec / 1000);
#endif
  return(mstime);
}

qword SlibGetFrameNumber(SlibHandle_t handle, SlibStream_t stream)
{
  SlibInfo_t *Info=(SlibInfo_t *)handle;
  if (Info && Info->FramesPerSec>0.0F)
    return(slibTimeToFrame(Info, Info->VideoTimeStamp
                                 +(Info->VideoFrameDuration/200)));
  else
    return((qword)-1);
}

SlibTime_t SlibGetVideoTime(SlibHandle_t handle, SlibStream_t stream)
{
  if (!handle)
    return(0);
  return((long)((SlibInfo_t *)handle)->VideoTimeStamp);
}

SlibTime_t SlibGetAudioTime(SlibHandle_t handle, SlibStream_t stream)
{
  if (!handle)
    return(0);
  return((long)((SlibInfo_t *)handle)->AudioTimeStamp);
}

SlibBoolean_t SlibCanSetParam(SlibHandle_t handle, SlibStream_t stream,
                              SlibParameter_t param)
{
  return(TRUE);
}

SlibBoolean_t SlibCanGetParam(SlibHandle_t handle, SlibStream_t stream,
                              SlibParameter_t param)
{
  return(TRUE);
}

SlibStatus_t SlibSetParamInt(SlibHandle_t handle, SlibStream_t stream,
                             SlibParameter_t param, long value)
{
  SlibInfo_t *Info=(SlibInfo_t *)handle;
  SlibStatus_t status=SlibErrorNone;
  long actvalue=value;
  if (!handle)
    return(SlibErrorBadHandle);
  _SlibDebug(_DEBUG_, printf("SlibSetParamInt(stream=%d, param=%d, %d)\n",
                   stream, param, value) );
  switch (param)
  {
    case SLIB_PARAM_FPS:
          _SlibDebug(_DEBUG_, printf("SlibSetParamInt(SLIB_PARAM_FPS)\n") );
          status=SlibSetParamFloat(handle, stream, param, (float)value);
          break;
    case SLIB_PARAM_BITRATE:
          _SlibDebug(_DEBUG_,
              printf("SlibSetParamInt(SLIB_PARAM_BITRATE, %d)\n", value) );
          if (stream==SLIB_STREAM_MAINAUDIO)
            status=SlibSetParamInt(handle, stream, SLIB_PARAM_AUDIOBITRATE,
                                   value);
          else if (stream==SLIB_STREAM_MAINVIDEO)
            status=SlibSetParamInt(handle, stream, SLIB_PARAM_VIDEOBITRATE,
                                   value);
          else /* setting overall bitrate: try to calc best audio+video rates */
          {
            long vbitrate=value;
            /* spread total bitrate across all streams */
            if (Info->AudioStreams)
            {
              long abitrate=Info->VideoStreams ? (value*Info->Channels)/10 
                                            : value;
              /* don't set bitrates higher than necessary */
              if (Info->Channels==1 && abitrate>112*1000)
                abitrate=112*1000;
              else if (abitrate>192*1000)
                abitrate=192*1000;
              status=SlibSetParamInt(handle, stream, SLIB_PARAM_AUDIOBITRATE,
                                abitrate);
              abitrate=SlibGetParamInt(handle, stream, SLIB_PARAM_AUDIOBITRATE);
              vbitrate=value-abitrate; /* subtract bitrate allocated to audio */
            }
            if (Info->VideoStreams)
              status=SlibSetParamInt(handle, stream, SLIB_PARAM_VIDEOBITRATE,
                                  vbitrate);
            slibValidateBitrates(Info);  /* check the bitrate setting */
            if (Info->VideoStreams && Info->TotalBitRate>value)
            {
              /*
               * Since the total bitrate is over the desired bitrate
               * subtract the difference from the video bitrate
               */
              vbitrate=Info->VideoBitRate-(Info->TotalBitRate-value);
              status=SlibSetParamInt(handle, stream, SLIB_PARAM_VIDEOBITRATE,
                                     vbitrate);
            }
          }
          slibValidateBitrates(Info);
          actvalue=Info->TotalBitRate;
          _SlibDebug(_DEBUG_,
            printf("MuxBitRate=%d TotalBitRate=%d abitrate=%d vbitrate=%d\n",
               Info->MuxBitRate, Info->TotalBitRate, 
                SlibGetParamInt(handle, stream, SLIB_PARAM_AUDIOBITRATE),
                SlibGetParamInt(handle, stream, SLIB_PARAM_VIDEOBITRATE) ) );
          break;
    case SLIB_PARAM_VIDEOBITRATE:
          _SlibDebug(_DEBUG_,
            printf("SlibSetParamInt(SLIB_PARAM_VIDEOBITRATE, %d)\n", value) );
          if (Info->Svh)
          {
            SvSetParamInt(Info->Svh, SV_PARAM_BITRATE, value);
            actvalue=(long)SvGetParamInt(Info->Svh, SV_PARAM_BITRATE);
          }
          if (actvalue>0)
            Info->VideoBitRate=actvalue;
          slibValidateBitrates(Info);
          break;
    case SLIB_PARAM_VIDEOSTREAMS:
          if (Info->VideoStreams!=(int)value)
          {
            Info->VideoStreams=(int)value;
            if (Info->VideoStreams)
              slibAddPin(Info, SLIB_DATA_VIDEO, "Video");
            else
            {
              slibPinPrepareReposition(Info, SLIB_DATA_VIDEO);
              slibRemovePin(Info, SLIB_DATA_VIDEO);
            }
          }
          break;
    case SLIB_PARAM_MOTIONALG:
          if (Info->Svh)
            SvSetParamInt(Info->Svh, SV_PARAM_MOTIONALG, value);
          break;
    case SLIB_PARAM_ALGFLAGS:
          if (Info->Svh)
            SvSetParamInt(Info->Svh, SV_PARAM_ALGFLAGS, value);
          break;
    case SLIB_PARAM_MOTIONSEARCH:
          if (Info->Svh)
            SvSetParamInt(Info->Svh, SV_PARAM_MOTIONSEARCH, value);
          break;
    case SLIB_PARAM_MOTIONTHRESH:
          if (Info->Svh)
            SvSetParamInt(Info->Svh, SV_PARAM_MOTIONTHRESH, value);
          break;
    case SLIB_PARAM_QUANTI:
          if (Info->Svh)
            SvSetParamInt(Info->Svh, SV_PARAM_QUANTI, value);
          break;
    case SLIB_PARAM_QUANTP:
          if (Info->Svh)
            SvSetParamInt(Info->Svh, SV_PARAM_QUANTP, value);
          break;
    case SLIB_PARAM_QUANTB:
          if (Info->Svh)
            SvSetParamInt(Info->Svh, SV_PARAM_QUANTB, value);
          break;
    case SLIB_PARAM_KEYSPACING:
          if (Info->Svh)
            SvSetParamInt(Info->Svh, SV_PARAM_KEYSPACING, value);
          break;
    case SLIB_PARAM_SUBKEYSPACING:
          if (Info->Svh)
            SvSetParamInt(Info->Svh, SV_PARAM_SUBKEYSPACING, value);
          break;
    case SLIB_PARAM_FRAMETYPE:
          if (Info->Svh)
            SvSetParamInt(Info->Svh, SV_PARAM_FRAMETYPE, value);
          break;
    case SLIB_PARAM_VIDEOPROGRAM:
          Info->VideoPID=(int)value;
          break;
    case SLIB_PARAM_AUDIOPROGRAM:
          Info->AudioPID=(int)value;
          break;
    case SLIB_PARAM_VIDEOMAINSTREAM:
          Info->VideoMainStream=(int)value;
          break;
    case SLIB_PARAM_AUDIOMAINSTREAM:
          Info->AudioMainStream=(int)value;
          break;
    case SLIB_PARAM_WIDTH:
          _SlibDebug(_DEBUG_,
                printf("SlibSetParamInt(SLIB_PARAM_WIDTH)\n") );
          Info->Width=(short)value;
          if (Info->Mode==SLIB_MODE_COMPRESS && Info->CompVideoFormat)
            Info->CompVideoFormat->biWidth=Info->Width;
          if (Info->Mode==SLIB_MODE_COMPRESS && Info->CodecVideoFormat)
            Info->CodecVideoFormat->biWidth=Info->Width;
          if (Info->VideoFormat)
            Info->VideoFormat->biWidth=Info->Width;
          return(slibValidateVideoParams(Info));
    case SLIB_PARAM_STRIDE:
          _SlibDebug(_DEBUG_,
                printf("SlibSetParamInt(SLIB_PARAM_STRIDE)\n") );
          Info->Stride=(long)value;
          if (Info->Sch && Info->Mode==SLIB_MODE_DECOMPRESS)
            SconSetParamInt(Info->Sch, SCON_OUTPUT, SCON_PARAM_STRIDE, Info->Stride);
          break;
    case SLIB_PARAM_HEIGHT:
          _SlibDebug(_DEBUG_,
                printf("SlibSetParamInt(SLIB_PARAM_HEIGHT)\n") );
          Info->Height=(short)value<0 ? (short)-value : (short)value;
          if (Info->Mode==SLIB_MODE_COMPRESS && Info->CompVideoFormat)
            Info->CompVideoFormat->biHeight=Info->Height;
          if (Info->Mode==SLIB_MODE_COMPRESS && Info->CodecVideoFormat)
            Info->CodecVideoFormat->biHeight=Info->Height;
          if (Info->VideoFormat)
            Info->VideoFormat->biHeight=(short)value;
          return(slibValidateVideoParams(Info));
    case SLIB_PARAM_VIDEOFORMAT:
          _SlibDebug(_DEBUG_,
             printf("SlibSetParamInt(SLIB_PARAM_VIDEOFORMAT, '%c%c%c%c')\n",
              value&0xFF, (value>>8)&0xFF, (value>>16)&0xFF,(value>>24)&0xFF) );
          if (Info->VideoFormat)
            Info->VideoFormat->biCompression=(dword)value;
#if 0
          if (Info->Mode==SLIB_MODE_COMPRESS && Info->CodecVideoFormat)
            Info->CodecVideoFormat->biCompression=(dword)value;
#endif
          return(slibValidateVideoParams(Info));
    case SLIB_PARAM_VIDEOBITS:
          _SlibDebug(_DEBUG_,
                printf("SlibSetParamInt(SLIB_PARAM_VIDEOBITS, %d)\n", value) );
          if (Info->VideoFormat)
            Info->VideoFormat->biBitCount=(word)value;
          if (Info->Mode==SLIB_MODE_COMPRESS && Info->CodecVideoFormat)
            Info->CodecVideoFormat->biBitCount=(dword)value;
          return(slibValidateVideoParams(Info));
    case SLIB_PARAM_AUDIOSTREAMS:
          if (Info->AudioStreams!=(int)value)
          {
            Info->AudioStreams=(int)value;
            if (Info->AudioStreams)
              slibAddPin(Info, SLIB_DATA_AUDIO, "Audio");
            else
            {
              slibPinPrepareReposition(Info, SLIB_DATA_AUDIO);
              slibRemovePin(Info, SLIB_DATA_AUDIO);
            }
          }
          break;
    case SLIB_PARAM_AUDIOBITRATE:
          _SlibDebug(_DEBUG_,
            printf("SlibSetParamInt(SLIB_PARAM_AUDIOBITRATE, %d)\n", value) );
          if (Info->Sah)
          {
            SaSetParamInt(Info->Sah, SA_PARAM_BITRATE, value);
            actvalue=(long)SaGetParamInt(Info->Sah, SA_PARAM_BITRATE);
          }
          if (actvalue>0)
            Info->AudioBitRate=actvalue;
          slibValidateBitrates(Info);
          break;
    case SLIB_PARAM_AUDIOCHANNELS:
          if (Info->Mode==SLIB_MODE_COMPRESS ||
              Info->AudioType==SLIB_TYPE_AC3_AUDIO)
          {
            Info->Channels=value;
            if (Info->AudioFormat)
              Info->AudioFormat->nChannels=(word)value;
            SaSetParamInt(Info->Sah, SA_PARAM_CHANNELS, value);
          }
          actvalue=Info->Channels;
          break;
    case SLIB_PARAM_SAMPLESPERSEC:
          {
            unsigned dword nativesps;
            Info->SamplesPerSec=value;
            nativesps=value;
#ifdef MPEG_SUPPORT
            if (SlibTypeIsMPEG(Info->Type))
            {
              /* choose a MPEG supported native sample rate */
              if (value%11025 == 0) /* multiples of 11025 can be converted */
                nativesps=44100;
              else if (value==48000)
                nativesps=48000;
              else if (value%8000 == 0) /* multiples of 8000 can be converted */
                nativesps=32000;
            }
#endif /* MPEG_SUPPORT */
            if (Info->AudioFormat)
              Info->AudioFormat->nSamplesPerSec=nativesps;
          }
          break;
    case SLIB_PARAM_NATIVESAMPLESPERSEC:
          if (Info->AudioFormat)
            Info->AudioFormat->nSamplesPerSec=(dword)value;
          break;
    case SLIB_PARAM_BITSPERSAMPLE:
          Info->BitsPerSample=value;
          if (Info->AudioFormat && value==16)
            Info->AudioFormat->wBitsPerSample=(word)value;
          break;
    case SLIB_PARAM_NATIVEBITSPERSAMPLE:
          if (Info->AudioFormat)
            Info->AudioFormat->wBitsPerSample=(word)value;
          break;
    case SLIB_PARAM_VIDEOQUALITY:
          if (Info->Svh)
            SvSetParamInt(Info->Svh, SV_PARAM_QUALITY, (ScBoolean_t)value);
          break;
    case SLIB_PARAM_AUDIOQUALITY:
          if (Info->Sah)
            SaSetParamInt(Info->Sah, SA_PARAM_QUALITY, (ScBoolean_t)value);
          break;
    case SLIB_PARAM_FILESIZE:
          Info->FileSize=(unsigned long)value;
          break;
    case SLIB_PARAM_FILEBUFSIZE:
          Info->FileBufSize=(unsigned dword)value;
          break;
    case SLIB_PARAM_COMPBUFSIZE:
          if (value<=0)
            Info->CompBufSize=(unsigned dword)2*1024; /* default */
          else
            Info->CompBufSize=(unsigned dword)value;
          break;
    case SLIB_PARAM_PACKETSIZE:
          if (Info->Svh)
            SvSetParamInt(Info->Svh, SV_PARAM_PACKETSIZE, value);
          break;
    case SLIB_PARAM_FORMATEXT:
          if (Info->Svh)
            SvSetParamInt(Info->Svh, SV_PARAM_FORMATEXT, value);
          break;
    case SLIB_PARAM_OVERFLOWSIZE:
          Info->OverflowSize=(unsigned long)value;
          break;
    case SLIB_PARAM_DEBUG:
          Info->dbg=(void *)value;
          if (Info->Svh)
            SvSetParamInt(Info->Svh, SV_PARAM_DEBUG, value);
          if (Info->Sah)
            SaSetParamInt(Info->Sah, SA_PARAM_DEBUG, value);
          break;
    default:
          return(SlibErrorUnsupportedParam);
  }
  if (actvalue!=value)
  {
    _SlibDebug(_DEBUG_ || _WARN_, 
         printf("SlibSetParamFloat() SettingNotEqual: %ld(req) != %ld(act)\n",
                     value, actvalue) );
    return(SlibErrorSettingNotEqual);
  }
  return(status);
}

SlibStatus_t SlibSetParamLong(SlibHandle_t handle, SlibStream_t stream,
                             SlibParameter_t param, qword value)
{
  SlibInfo_t *Info=(SlibInfo_t *)handle;
  SlibStatus_t status=SlibErrorNone;
  qword actvalue=value;
  if (!handle)
    return(SlibErrorBadHandle);
  _SlibDebug(_DEBUG_, printf("SlibSetParamLong(stream=%d, param=%d, %ld)\n",
                   stream, param, value) );
  /* this needs to be implemented */
  return(SlibSetParamInt(handle, stream, param, (long)value));
}

SlibStatus_t SlibSetParamFloat(SlibHandle_t handle, SlibStream_t stream,
                               SlibParameter_t param, float value)
{
  SlibInfo_t *Info=(SlibInfo_t *)handle;
  SlibStatus_t status=SlibErrorNone;
  float actvalue=value;
  if (!handle)
    return(SlibErrorBadHandle);
  _SlibDebug(_DEBUG_, printf("SlibSetParamFloat()\n") );
  switch (param)
  {
    case SLIB_PARAM_FPS:
          _SlibDebug(_DEBUG_,
                printf("SlibSetParamFloat(SLIB_PARAM_FPS)\n") );
          if (Info->Svh)
          {
            SvSetParamFloat(Info->Svh, SV_PARAM_FPS, value);
            actvalue=SvGetParamFloat(Info->Svh, SV_PARAM_FPS);
          }
          if (actvalue>0.0F)
            Info->FramesPerSec=actvalue;
          break;
    default:
          return(SlibSetParamInt(handle, stream, param, (long)value));
  }
  if (actvalue>value+(float)0.0000001 ||
      actvalue<value-(float)0.0000001)
  {
    _SlibDebug(_DEBUG_ || _WARN_, 
        printf("SlibSetParamFloat() SettingNotEqual: %.3f(req) != %.3f(act)\n",
                     value, actvalue) );
    return(SlibErrorSettingNotEqual);
  }
  return(status);
}

SlibStatus_t SlibSetParamBoolean(SlibHandle_t handle, SlibStream_t stream,
                                 SlibParameter_t param, SlibBoolean_t value)
{
  SlibInfo_t *Info=(SlibInfo_t *)handle;
  if (!handle)
    return(SlibErrorBadHandle);
  _SlibDebug(_DEBUG_, printf("SlibSetParamFloat()\n") );
  switch (param)
  {
    case SLIB_PARAM_STATS:
          if (value)
          {
            if (Info->stats==NULL)
            {
              Info->stats = (SlibStats_t *)ScAlloc(sizeof(SlibStats_t));
              if (Info->stats==NULL)
                return(SlibErrorMemory);
              SlibSetParamBoolean(handle, stream, SLIB_PARAM_STATS_RESET, TRUE);
            }
            else
              Info->stats->StartTime=slibGetSystemTime();
            Info->stats->Record=TRUE;
          }
          else if (Info->stats)
          {
            Info->stats->Record=FALSE;
            Info->stats->StopTime=slibGetSystemTime();
          }
          break;
    case SLIB_PARAM_STATS_RESET:
          if (Info->stats)
          {
            Info->stats->StartTime=Info->stats->StopTime=
                slibGetSystemTime();
            Info->stats->FramesProcessed=0;
            Info->stats->FramesSkipped=0;
          }
          break;
    case SLIB_PARAM_NEEDACCURACY:
          Info->NeedAccuracy = value ? TRUE : FALSE;
          if (Info->NeedAccuracy && slibHasTimeCode(Info))
          {
            /*
             * We'll seek toward the end of the file so the frame count
             * can be more accurately measured
             */
            if (!Info->VideoLengthKnown && Info->FileSize>0)
            {
              int minpercent=0, maxpercent=9900, lastpercent=0, trypercent=9900;
              int tries=0;
              unsigned qword newfilesize=Info->FileSize;
              qword stime = Info->VideoTimeStamp;
              SlibStatus_t status;
              if (SlibTimeIsInValid(stime)) stime=0;
              while (!Info->VideoLengthKnown && maxpercent-minpercent>200 && tries<5)
              {
                status=SlibSeekEx(handle, SLIB_STREAM_ALL, SLIB_SEEK_KEY, 
                                  trypercent, SLIB_UNIT_PERCENT100, NULL);
                if (status==SlibErrorEndOfStream)
                  break;
                else if (status==SlibErrorNoBeginning)
                {
                  /* adjust the file size, data at end must be invalid */
                  newfilesize=(Info->FileSize*(trypercent/100))/100;
                  lastpercent=trypercent;
                  maxpercent=trypercent;
                  trypercent=(minpercent+maxpercent)/2; /* try half way between min and max */
                }
                else if (status==SlibErrorNone)
                {
                  if (maxpercent-trypercent<=300)
                    break;
                  else
                  {
                    lastpercent=trypercent;
                    minpercent=trypercent;
                    trypercent=(minpercent+maxpercent)/2; /* try half way between min and max */
                  }
                }
                else
                {
                  lastpercent=trypercent;
                  trypercent=((trypercent-minpercent)*3)/4;
                }
                tries++;
              }
              Info->FileSize=newfilesize;
              while (status==SlibErrorNone && !Info->VideoLengthKnown)
                status=SlibSeek(handle, SLIB_STREAM_ALL, SLIB_SEEK_NEXT_KEY, 0);
              SlibSeekEx(handle, SLIB_STREAM_ALL, SLIB_SEEK_KEY, stime,
                                                  SLIB_UNIT_MS, NULL);
            }
          }
          break;
    case SLIB_PARAM_FASTENCODE:
          if (Info->Svh)
            SvSetParamBoolean(Info->Svh, SV_PARAM_FASTENCODE, 
                                         (ScBoolean_t)value);
          if (Info->Sah)
            SvSetParamBoolean(Info->Sah, SV_PARAM_FASTENCODE, 
                                         (ScBoolean_t)value);
          break;
    case SLIB_PARAM_FASTDECODE:
          if (Info->Svh)
            SvSetParamBoolean(Info->Svh, SV_PARAM_FASTDECODE, 
                                         (ScBoolean_t)value);
          if (Info->Sah)
            SvSetParamBoolean(Info->Sah, SV_PARAM_FASTDECODE, 
                                         (ScBoolean_t)value);
          break;
    case SLIB_PARAM_MOTIONALG:
          SlibSetParamInt(handle, stream, param, value?1:0);
          break;
    default:
         return(SlibErrorUnsupportedParam);
  }
  return(SlibErrorNone);
}

SlibStatus_t SlibSetParamStruct(SlibHandle_t handle, SlibStream_t stream,
                             SlibParameter_t param,
                             void *data, unsigned dword datasize)
{
  SlibInfo_t *Info=(SlibInfo_t *)handle;
  SlibStatus_t status=SlibErrorNone;
  if (!handle)
    return(SlibErrorBadHandle);
  if (data==NULL || datasize==0)
    return(SlibErrorBadArgument);
  _SlibDebug(_DEBUG_, printf("SlibSetParamStruct(stream=%d, param=%d, data=%p datasize=%ld)\n",
                   stream, param, data, datasize) );
  switch (param)
  {
    case SLIB_PARAM_VIDEOFORMAT:
         {
           BITMAPINFOHEADER *bmh=(BITMAPINFOHEADER *)data;
           _SlibDebug(_DEBUG_,
             printf("SlibSetParamStruct(SLIB_PARAM_VIDEOFORMAT)\n") );
           if (Info->VideoFormat==NULL || Info->VideoFormat->biSize<datasize)
           {
             ScFree(Info->VideoFormat);
             Info->VideoFormat=NULL;
           }
           if (Info->VideoFormat==NULL)
             Info->VideoFormat=(BITMAPINFOHEADER *)ScAlloc(datasize);
           Info->Width=(word)bmh->biWidth;
           Info->Height=abs(bmh->biHeight);
           if (Info->VideoFormat)
           {
             memcpy(Info->VideoFormat, bmh, datasize);
             return(slibValidateVideoParams(Info));
           }
           else
             return(SlibErrorMemory);
         }
    default:
         return(SlibErrorUnsupportedParam);
  }
  /* this needs to be implemented */
  return(SlibErrorNone);
}

long SlibGetParamInt(SlibHandle_t handle, SlibStream_t stream,
                                          SlibParameter_t param)
{
  SlibInfo_t *Info=(SlibInfo_t *)handle;
  if (!handle)
    return(0);
  switch (param)
  {
    case SLIB_PARAM_TYPE:
          if (stream==SLIB_STREAM_MAINAUDIO)
            return((long)Info->AudioType);
          else if (stream==SLIB_STREAM_MAINVIDEO)
            return((long)Info->VideoType);
          else
            return((long)Info->Type);
          break;
    case SLIB_PARAM_FPS:
          return((long)Info->FramesPerSec);
          break;
    case SLIB_PARAM_BITRATE:
          return((long)Info->TotalBitRate);
    case SLIB_PARAM_VIDEOBITRATE:
          return((long)Info->VideoBitRate);
    case SLIB_PARAM_WIDTH:
          return((long)Info->Width);
    case SLIB_PARAM_HEIGHT:
          return((long)Info->Height);
    case SLIB_PARAM_STRIDE:
          return((long)Info->Stride);
    case SLIB_PARAM_NATIVEWIDTH:
          if (Info->CompVideoFormat)
            return((long)Info->CompVideoFormat->biWidth);
          else
            return((long)Info->Width);
    case SLIB_PARAM_NATIVEHEIGHT:
          if (Info->CompVideoFormat)
            return((long)Info->CompVideoFormat->biHeight);
          else
            return((long)Info->Height);
    case SLIB_PARAM_NATIVEVIDEOFORMAT:
          {
            long format=(long)SvGetParamInt(Info->Svh, SV_PARAM_NATIVEFORMAT);
            if (format==0)
              format=Info->CodecVideoFormat
                             ? Info->CodecVideoFormat->biCompression
                             : Info->VideoFormat->biCompression;
            return(format);
          }
    case SLIB_PARAM_IMAGESIZE:
          return((long)Info->ImageSize);
    case SLIB_PARAM_MININPUTSIZE:
          {
            long size=0;
            if (Info->Mode==SLIB_MODE_COMPRESS)
            {
              if (slibHasVideo(Info))
                size+=Info->ImageSize;
              if (slibHasAudio(Info))
                switch (Info->AudioType)
                {
                  case SLIB_TYPE_G723:
                       size+=480;
                       break;
                  default:
                       if (Info->AudioFormat)
                         size+=Info->AudioFormat->nBlockAlign;
                }
            }
            else if (Info->Mode==SLIB_MODE_DECOMPRESS)
            {
              if (slibHasVideo(Info))
                switch (Info->AudioType)
                {
                  case SLIB_TYPE_H263:
                       size+=Info->VideoBitRate>0?(Info->VideoBitRate/8):(64*1024);
                       break;
                  default:
                       size+=Info->VideoBitRate>0?(Info->VideoBitRate/8):(64*1024);
                }
              if (slibHasAudio(Info))
                switch (Info->AudioType)
                {
                  case SLIB_TYPE_G723:
                       size+=(Info->AudioBitRate>=6000)?24:20;
                       break;
                  default:
                       if (Info->AudioFormat)
                         size+=Info->AudioFormat->nBlockAlign;
                }
            }
            return(size);
          }
          break;
    case SLIB_PARAM_INPUTSIZE:
          {
            long size=0;
            size+=SlibGetParamInt(handle, stream, SLIB_PARAM_MININPUTSIZE);
            if (size<=8) size=8*1024;
            if (Info->Mode==SLIB_MODE_DECOMPRESS)
            {
              if (slibHasVideo(Info))
                switch (Info->Type) /* add in bytes for header */
                {
                  case SLIB_TYPE_AVI:      size+=64; break;
                }
              if (slibHasAudio(Info))
              {
                if (!Info->HeaderProcessed) /* add in header */
                  switch (Info->Type)
                  {
                    case SLIB_TYPE_PCM_WAVE: size+=40; break;
                  }
              }
            }
            return(size);
          }
          break;
    case SLIB_PARAM_VIDEOFRAME:
          if (Info->FramesPerSec)
            return((long)slibTimeToFrame(Info, Info->VideoTimeStamp
                                               +(Info->VideoFrameDuration/200)));
          break;
    case SLIB_PARAM_FRAMEDURATION:
          if (Info->FramesPerSec)
            return((long)(10000000L/Info->FramesPerSec));
          else
            return((long)0);
    case SLIB_PARAM_VIDEOFORMAT:
          if (Info->VideoFormat)
            return((long)Info->VideoFormat->biCompression);
          else
            return(0L);
          break;
    case SLIB_PARAM_VIDEOBITS:
          if (Info->VideoFormat)
            return((long)Info->VideoFormat->biBitCount);
          else
            return(0L);
    case SLIB_PARAM_VIDEOPROGRAM:
          return((long)Info->VideoPID);
    case SLIB_PARAM_AUDIOPROGRAM:
          return((long)Info->AudioPID);
    case SLIB_PARAM_VIDEOMAINSTREAM:
          return((long)Info->VideoMainStream);
    case SLIB_PARAM_AUDIOMAINSTREAM:
          return((long)Info->AudioMainStream);
    case SLIB_PARAM_KEYSPACING:
          if (Info->Svh)
            return((long)SvGetParamInt(Info->Svh, SV_PARAM_KEYSPACING));
          else
            return((long)Info->KeySpacing);
    case SLIB_PARAM_SUBKEYSPACING:
          if (Info->Svh)
            return((long)SvGetParamInt(Info->Svh, SV_PARAM_SUBKEYSPACING));
          else
            return((long)Info->SubKeySpacing);
    case SLIB_PARAM_AUDIOFORMAT:
          if (Info->AudioFormat)
            return((long)Info->AudioFormat->wFormatTag);
          else
            return(0);
          break;
    case SLIB_PARAM_AUDIOBITRATE:
          if (Info->AudioBitRate==0 && Info->Sah)
            Info->AudioBitRate=(dword)SaGetParamInt(Info->Sah, SA_PARAM_BITRATE);
          return((long)Info->AudioBitRate);
    case SLIB_PARAM_VIDEOSTREAMS:
          return((long)Info->VideoStreams);
    case SLIB_PARAM_AUDIOSTREAMS:
          return((long)Info->AudioStreams);
    case SLIB_PARAM_AUDIOCHANNELS:
          return((long)Info->Channels);
    case SLIB_PARAM_SAMPLESPERSEC:
          return((long)Info->SamplesPerSec);
    case SLIB_PARAM_NATIVESAMPLESPERSEC:
          if (Info->AudioFormat)
            return((long)Info->AudioFormat->nSamplesPerSec);
          break;
    case SLIB_PARAM_BITSPERSAMPLE:
          return((long)Info->BitsPerSample);
    case SLIB_PARAM_NATIVEBITSPERSAMPLE:
          if (Info->AudioFormat)
            return((long)Info->AudioFormat->wBitsPerSample);
          break;
    case SLIB_PARAM_FILESIZE:
          return((long)Info->FileSize);
    case SLIB_PARAM_FILEBUFSIZE:
          return((long)Info->FileBufSize);
    case SLIB_PARAM_COMPBUFSIZE:
          return((long)Info->CompBufSize);
    case SLIB_PARAM_OVERFLOWSIZE:
          return((long)Info->OverflowSize);
    case SLIB_PARAM_VIDEOQUALITY:
          if (Info->Svh)
            return((long)SvGetParamInt(Info->Svh, SV_PARAM_QUALITY));
          break;
    case SLIB_PARAM_AUDIOQUALITY:
          if (Info->Sah)
            return((long)SaGetParamInt(Info->Sah, SA_PARAM_QUALITY));
          break;
    case SLIB_PARAM_VBVBUFFERSIZE:
          {
            dword vbv;
            if (Info->Svh)
              vbv=(dword)SvGetParamInt(Info->Svh, SV_PARAM_VBVBUFFERSIZE);
            if (vbv<=0)
              vbv=Info->VBVbufSize;
            return(vbv);
          }
    case SLIB_PARAM_VBVDELAY:
          if (Info->Svh)
            return((long)SvGetParamInt(Info->Svh, SV_PARAM_VBVDELAY));
          break;
    case SLIB_PARAM_MOTIONALG:
          if (Info->Svh)
            return((long)SvGetParamInt(Info->Svh, SV_PARAM_MOTIONALG));
          break;
    case SLIB_PARAM_ALGFLAGS:
          if (Info->Svh)
            return((long)SvGetParamInt(Info->Svh, SV_PARAM_ALGFLAGS));
          break;
    case SLIB_PARAM_MOTIONSEARCH:
          if (Info->Svh)
            return((long)SvGetParamInt(Info->Svh, SV_PARAM_MOTIONSEARCH));
          break;
    case SLIB_PARAM_MOTIONTHRESH:
          if (Info->Svh)
            return((long)SvGetParamInt(Info->Svh, SV_PARAM_MOTIONTHRESH));
          break;
    case SLIB_PARAM_PACKETSIZE:
          if (Info->Svh)
            return((long)SvGetParamInt(Info->Svh, SV_PARAM_PACKETSIZE));
          break;
    case SLIB_PARAM_FORMATEXT:
          if (Info->Svh)
            return((long)SvGetParamInt(Info->Svh, SV_PARAM_FORMATEXT));
          break;
    case SLIB_PARAM_QUANTI:
          if (Info->Svh)
            return((long)SvGetParamInt(Info->Svh, SV_PARAM_QUANTI));
          break;
    case SLIB_PARAM_QUANTP:
          if (Info->Svh)
            return((long)SvGetParamInt(Info->Svh, SV_PARAM_QUANTP));
          break;
    case SLIB_PARAM_QUANTB:
          if (Info->Svh)
            return((long)SvGetParamInt(Info->Svh, SV_PARAM_QUANTB));
          break;
    case SLIB_PARAM_FRAMETYPE:
          if (Info->Svh)
            return((long)SvGetParamInt(Info->Svh, SV_PARAM_FRAMETYPE));
          break;
    case SLIB_PARAM_STATS_FPS:
          return((long)SlibGetParamFloat(handle, stream, SLIB_PARAM_STATS_FPS));
    default:
          return((long)SlibGetParamLong(handle, stream, param));
  }
  return(0);
}

qword SlibGetParamLong(SlibHandle_t handle, SlibStream_t stream,
                                          SlibParameter_t param)
{
  SlibInfo_t *Info=(SlibInfo_t *)handle;
  if (!handle)
    return((qword)0);
  switch (param)
  {
    case SLIB_PARAM_VIDEOFRAMES:
          if (Info->FramesPerSec)
            return(slibTimeToFrame(Info, Info->VideoLength
                                         +(Info->VideoFrameDuration/200)));
          break;
    case SLIB_PARAM_VIDEOLENGTH:
          return(Info->VideoLength);
    case SLIB_PARAM_AUDIOLENGTH:
          return((long)Info->AudioLength);
    case SLIB_PARAM_STATS_TIME:
          if (Info->stats)
          {
            if (Info->stats->Record) /* still recording */
              Info->stats->StopTime=slibGetSystemTime();
            return((long)(Info->stats->StopTime-Info->stats->StartTime));
          }
          break;
    case SLIB_PARAM_STATS_FRAMESPROCESSED:
          if (Info->stats)
            return(Info->stats->FramesProcessed);
          break;
    case SLIB_PARAM_STATS_FRAMESSKIPPED:
          if (Info->stats)
            return(Info->stats->FramesSkipped);
          break;
    case SLIB_PARAM_STATS_FRAMES:
          if (Info->stats)
            return(Info->stats->FramesSkipped+
                   Info->stats->FramesProcessed);
          break;
    case SLIB_PARAM_TIMECODE:
          if (Info->Svh)
            return(SvGetParamInt(Info->Svh, SV_PARAM_TIMECODE));
          break;
    case SLIB_PARAM_CALCTIMECODE:
          if (Info->Svh)
            return(SvGetParamInt(Info->Svh, SV_PARAM_CALCTIMECODE));
          break;
    case SLIB_PARAM_PTIMECODE:
          if (stream==SLIB_STREAM_MAINAUDIO)
            return(Info->AudioPTimeCode);
          else if (Info->VideoPTimeCode==SLIB_TIME_NONE && Info->Svh &&
                   SvGetParamInt(Info->Svh, SV_PARAM_TIMECODE)>0)
            return(SvGetParamInt(Info->Svh, SV_PARAM_TIMECODE));
          else
            return(Info->VideoPTimeCode);
    case SLIB_PARAM_DTIMECODE:
          if (stream==SLIB_STREAM_MAINAUDIO)
            return(Info->AudioDTimeCode);
          else if (Info->VideoDTimeCode==SLIB_TIME_NONE && Info->Svh &&
                   SvGetParamInt(Info->Svh, SV_PARAM_TIMECODE)>0)
            return(SvGetParamInt(Info->Svh, SV_PARAM_TIMECODE));
          else
            return(Info->VideoDTimeCode);
    case SLIB_PARAM_PERCENT100:
          if (Info->FileSize>0)
          {
            ScBitstream_t *bs;
            SlibPosition_t pos=slibGetPinPosition(Info, SLIB_DATA_COMPRESSED);
            /* subtract all the unused data from the input position */
            pos-=slibDataOnPin(Info, SLIB_DATA_VIDEO);
            pos-=slibDataOnPin(Info, SLIB_DATA_AUDIO);
            if ((bs=SvGetDataSource(Info->Svh))!=NULL)
              pos-=ScBSBufferedBytesUnused(bs); /* Video Codec unused bytes */
            if ((bs=SaGetDataSource(Info->Sah))!=NULL)
              pos-=ScBSBufferedBytesUnused(bs); /* Audio Codec unused bytes */
            if (pos>=(SlibPosition_t)Info->FileSize)
              return(10000);
            else if (pos>=0)
              return((pos*10000)/Info->FileSize);
            else
              return(0);
          }
          else
          {
            if (stream==SLIB_STREAM_MAINAUDIO &&
                   SlibTimeIsValid(Info->AudioTimeStamp) &&
                   Info->AudioLength>0)
              return((Info->AudioTimeStamp*10000)/Info->AudioLength);
            else if (SlibTimeIsValid(Info->VideoTimeStamp)
                      && Info->VideoLength>0)
              return((Info->VideoTimeStamp*10000)/Info->VideoLength);
          }
          return((qword)-1);
  }
  return((qword)0);
}

float SlibGetParamFloat(SlibHandle_t handle, SlibStream_t stream,
                        SlibParameter_t param)
{
  SlibInfo_t *Info=(SlibInfo_t *)handle;
  switch (param)
  {
    case SLIB_PARAM_VERSION:
          return(_version);
  }
  if (!handle)
    return((float)0.0);
  switch (param)
  {
    case SLIB_PARAM_FPS:
          return((float)Info->FramesPerSec);
    case SLIB_PARAM_VIDEOASPECTRATIO:
          if (Info->Svh)
            return(SvGetParamFloat(Info->Svh, SV_PARAM_ASPECTRATIO));
          break;
    case SLIB_PARAM_STATS_FPS:
          if (Info->stats)
          {
            float fps=0.0F;
            if (Info->stats->Record) /* still recording */
              Info->stats->StopTime=slibGetSystemTime();
            if (Info->stats->StartTime<Info->stats->StopTime)
            {
              qword ellapsedtime=Info->stats->StopTime-Info->stats->StartTime;
              fps=(float)(Info->stats->FramesProcessed*1000)/ellapsedtime;
            }
            return(fps);
          }
          else
            return(0.0F);
  }
  return((float)SlibGetParamInt(handle, stream, param));
}

SlibBoolean_t SlibGetParamBoolean(SlibHandle_t handle, SlibStream_t stream,
                                  SlibParameter_t param)
{
  SlibInfo_t *Info=(SlibInfo_t *)handle;
  if (!handle)
    return(SlibErrorBadHandle);
  switch (param)
  {
    case SLIB_PARAM_STATS:
          return(Info->stats ? Info->stats->Record : FALSE);
    case SLIB_PARAM_NEEDACCURACY:
          return((SlibBoolean_t)Info->NeedAccuracy);
    case SLIB_PARAM_FASTENCODE:
          if (Info->Svh)
            return((SlibBoolean_t)SvGetParamBoolean(Info->Svh, 
                                     SV_PARAM_FASTENCODE));
          break;
    case SLIB_PARAM_FASTDECODE:
          if (Info->Svh)
            return((SlibBoolean_t)SvGetParamBoolean(Info->Svh, 
                                     SV_PARAM_FASTDECODE));
          break;
  }
  return(FALSE);
}

char *SlibGetParamString(SlibHandle_t handle, SlibStream_t stream,
                                              SlibParameter_t param)
{
  SlibInfo_t *Info=(SlibInfo_t *)handle;
  static char result[100];
  strcpy(result, "Unknown");
  switch (param)
  {
    case SLIB_PARAM_VERSION_DATE:
          return(_version_date);
          break;
  }
  if (!handle)
    return(result);
  switch (param)
  {
    case SLIB_PARAM_NATIVEVIDEOFORMAT:
          if (Info->CodecVideoFormat)
            switch(Info->CodecVideoFormat->biCompression)
            {
              case BI_YUY2:
              case BI_DECYUVDIB:        strcpy(result, "YUV 4:2:2 Interleaved");
                                        break;
              case BI_BITFIELDS:        strcpy(result, "BITFIELDS");
                                        break;
              case BI_DECXIMAGEDIB:     sprintf(result, "XIMAGE %d",
                                           Info->VideoFormat->biBitCount);
                                        break;
              case BI_YU12SEP:          strcpy(result, "YUV 4:1:1 Separated");
                                        break;
              case BI_YU16SEP:          strcpy(result, "YUV 4:2:2 Separated");
                                        break;
              case BI_RGB:              sprintf(result, "RGB %d",
                                           Info->VideoFormat->biBitCount);
                                        break;
            }
          break;
    case SLIB_PARAM_VIDEOFORMAT:
          if (Info->VideoFormat)
            switch(Info->VideoFormat->biCompression)
            {
              case BI_YUY2:
              case BI_DECYUVDIB:        strcpy(result, "YUV 4:2:2 Interleaved");
                                        break;
              case BI_BITFIELDS:        strcpy(result, "BITFIELDS");
                                        break;
              case BI_DECXIMAGEDIB:     sprintf(result, "XIMAGE %d",
                                           Info->VideoFormat->biBitCount);
                                        break;
              case BI_YU12SEP:          strcpy(result, "YUV 4:1:1 Separated");
                                        break;
              case BI_YU16SEP:          strcpy(result, "YUV 4:2:2 Separated");
                                        break;
              case BI_RGB:              sprintf(result, "RGB %d",
                                           Info->VideoFormat->biBitCount);
                                        break;
            }
          break;
    case SLIB_PARAM_AUDIOFORMAT:
          if (Info->AudioFormat)
            switch (Info->AudioFormat->wFormatTag)
            {
              case WAVE_FORMAT_PCM:    strcpy(result, "PCM");
                                       break;
            }
          break;
    case SLIB_PARAM_TYPE:
          if (stream==SLIB_STREAM_MAINAUDIO)
            return(SlibQueryForDesc(SLIB_QUERY_TYPES, Info->AudioType));
          else if (stream==SLIB_STREAM_MAINVIDEO)
            return(SlibQueryForDesc(SLIB_QUERY_TYPES, Info->VideoType));
          else
            return(SlibQueryForDesc(SLIB_QUERY_TYPES, Info->Type));
          break;
  }
  return(result);
}

/*
** Name:    SlibValidateParams
** Purpose: Ensure that the the Video and Audio parameter settings are
**          valid and supported.
*/
SlibStatus_t SlibValidateParams(SlibHandle_t handle)
{
  SlibInfo_t *Info=(SlibInfo_t *)handle;
  if (Info->VideoStreams>0 && slibValidateVideoParams(Info)!=SlibErrorNone)
    return(slibValidateVideoParams(Info));
  if (Info->AudioStreams>0 && slibValidateAudioParams(Info)!=SlibErrorNone)
    return(slibValidateAudioParams(Info));
  if (Info->Svh)
  {
    SvStatus_t status;
    _SlibDebug(_DEBUG_, printf("SvQuery(%c%c%c%c,%d bits,%dx%d,%c%c%c%c,%d bits,%dx%d)\n",
                     (Info->CodecVideoFormat->biCompression)&0xFF,
                     (Info->CodecVideoFormat->biCompression>>8)&0xFF,
                     (Info->CodecVideoFormat->biCompression>>16)&0xFF,
                     (Info->CodecVideoFormat->biCompression>>24)&0xFF,
                      Info->CodecVideoFormat->biBitCount,
                      Info->CodecVideoFormat->biWidth,
                      Info->CodecVideoFormat->biHeight,
                     (Info->CompVideoFormat->biCompression)&0xFF,
                     (Info->CompVideoFormat->biCompression>>8)&0xFF,
                     (Info->CompVideoFormat->biCompression>>16)&0xFF,
                     (Info->CompVideoFormat->biCompression>>24)&0xFF,
                      Info->CompVideoFormat->biBitCount,
                      Info->CompVideoFormat->biWidth,
                      Info->CompVideoFormat->biHeight) );
    if (Info->Mode==SLIB_MODE_COMPRESS)
      status=SvCompressQuery(Info->Svh, Info->CodecVideoFormat,
                                        Info->CompVideoFormat);
    else
      status=SvDecompressQuery(Info->Svh, Info->CompVideoFormat,
                                          Info->CodecVideoFormat);
    if (status!=NoErrors)
    {
      _SlibDebug(_WARN_, printf("SlibValidateParams() SvQuery failed\n");
                       ScGetErrorText(status,0,0) );
      return(SlibErrorUnsupportedFormat);
    }
  }
  if (Info->Sah)
  {
    SaStatus_t status;
    if (Info->Mode==SLIB_MODE_COMPRESS)
      status=SaCompressQuery(Info->Sah, Info->AudioFormat,
                                        Info->CompAudioFormat);
    else
      status=SaDecompressQuery(Info->Sah, Info->CompAudioFormat,
                                          Info->AudioFormat);
    if (status!=NoErrors)
    {
      _SlibDebug(_WARN_, printf("SlibValidateParams() SaBegin failed\n");
                       ScGetErrorText(status,0,0) );
      return(SlibErrorUnsupportedFormat);
    }
  }
  return(SlibErrorNone);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech261\mpeg.h ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: mpeg.h,v $
 * Revision 1.1.4.2  1996/11/08  21:50:41  Hans_Graves
 * 	Added MPEG1_AUDIO_FRAME_SIZE
 * 	[1996/11/08  21:17:44  Hans_Graves]
 *
 * Revision 1.1.2.4  1996/01/11  16:17:24  Hans_Graves
 * 	Added more MPEG II System codes
 * 	[1996/01/11  16:14:20  Hans_Graves]
 * 
 * Revision 1.1.2.3  1996/01/08  16:41:24  Hans_Graves
 * 	Added MPEG II codes
 * 	[1996/01/08  15:44:39  Hans_Graves]
 * 
 * Revision 1.1.2.2  1995/11/06  18:47:43  Hans_Graves
 * 	First time under SLIB
 * 	[1995/11/06  18:34:29  Hans_Graves]
 * 
 * $EndLog$
 */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

#ifndef _MPEG_H_
#define _MPEG_H_

#define MPEG1_AUDIO_FRAME_SIZE       1152

/************** MPEG I parsing definitions **************/
#define MPEG_SYNC_WORD               0xfff
#define MPEG_SYNC_WORD_LEN           12
#define MPEG_PACK_START              0x000001ba
#define MPEG_PACK_START_LEN          32
#define MPEG_SYSTEM_HEADER_START     0x000001bb
#define MPEG_SYSTEM_HEADER_START_LEN 32
#define MPEG_SEQ_HEAD                0x000001b3
#define MPEG_SEQ_HEAD_LEN            32
#define MPEG_EXT_START               0x000001b5
#define MPEG_EXT_START_LEN           32
#define MPEG_PICTURE_START           0x00000100
#define MPEG_GROUP_START             0x000001b8
#define MPEG_VIDEO_PACKET            0x000001e0
#define MPEG_AUDIO_PACKET            0x000001c0

#define MPEG_START_CODE              0x000001
#define MPEG_START_CODE_LEN          24

#define MPEG_PICTURE_START_BASE      0x00
#define MPEG_PACK_START_BASE         0xba
#define MPEG_SYSTEM_HEADER_BASE      0xbb
#define MPEG_PRIVATE_STREAM1_BASE    0xbd
#define MPEG_PADDING_STREAM_BASE     0xbe
#define MPEG_PRIVATE_STREAM2_BASE    0xbf
#define MPEG_AUDIO_STREAM_BASE       0xc0
#define MPEG_VIDEO_STREAM_BASE       0xe0
#define MPEG_USER_DATA_BASE          0xb2
#define MPEG_SEQ_HEAD_BASE           0xb3
#define MPEG_EXT_START_BASE          0xb5
#define MPEG_SEQ_END_BASE            0xb7
#define MPEG_GROUP_START_BASE        0xb8
#define MPEG_END_BASE                0xb9

#define MPEG_AUDIO_STREAM_START      0xC0
#define MPEG_AUDIO_STREAM_END        0xDF
#define MPEG_VIDEO_STREAM_START      0xE0
#define MPEG_VIDEO_STREAM_END        0xEF

/************** MPEG II parsing definitions **************/
/* stream id's - all reserved in MPEG I */
#define MPEG_PROGRAM_STREAM           0xBC
#define MPEG_ECM_STREAM               0xF0
#define MPEG_EMM_STREAM               0xF1
#define MPEG_DSM_CC_STREAM            0xF1
#define MPEG_13522_STREAM             0xF2
#define MPEG_PROGRAM_DIRECTORY_STREAM 0xFF

/* program id's */
#define MPEG_PID_NULL                 0x1FFF

/* transport codes */
#define MPEG_TSYNC_CODE         0x47
#define MPEG_TSYNC_CODE_LEN     8

/* extension start code IDs */
#define MPEG_SEQ_ID       1
#define MPEG_DISP_ID      2
#define MPEG_QUANT_ID     3
#define MPEG_SEQSCAL_ID   5
#define MPEG_PANSCAN_ID   7
#define MPEG_CODING_ID    8
#define MPEG_SPATSCAL_ID  9
#define MPEG_TEMPSCAL_ID 10

/* picture coding type */
#define MPEG_I_TYPE 1
#define MPEG_P_TYPE 2
#define MPEG_B_TYPE 3
#define MPEG_D_TYPE 4

#endif /* _MPEG_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech261\proto.h ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: $
 * $EndLog$
 */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1994                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

#ifndef _SV_H261_PROTO_H_
#define _SV_H261_PROTO_H_

#include "sv_intrn.h"

#define nextstate(huff, laststate, mask) ( (cb & mask \
                          ? huff->state[laststate] >> 16 \
                          : huff->state[laststate] ) & 0xffff )

#define DecodeHuff(bs, huff, State, cb, bits) \
  State=0; bits=1; cb = (unsigned short)ScBSPeekBits(bs, 16); \
  if (bs->EOI) return(SvErrorEndBitstream); \
  while (1) { \
   if ((State = nextstate(huff, State, 0x8000)) & 0x8000) { \
     ScBSSkipBits(bs, bits); \
     State = (State == 0xffff) ? 0 : State & 0x7fff; \
     break; \
   } \
   cb<<=1; bits++; \
  }

#define DecodeHuffA(bs, huff, State, cb, bits) \
  State=0; bits=1; cb = (unsigned short)ScBSPeekBits(bs, 16); \
  while (1) { \
   if ((State = nextstate(huff, State, 0x8000)) & 0x8000) { \
    if (bs->EOI && bs->shift<(unsigned int)bits) return(SvErrorEndBitstream); \
    ScBSSkipBits(bs, bits); \
    if (State==0xffff || State==0x8000) return(0); \
    else { State&=0x7fff; break; } \
   } \
   cb<<=1; bits++; \
  }

#define DecodeHuffB(bs, huff, StateR, StateL, cb, bits) \
  StateR=0; bits=1; cb = (unsigned short)ScBSPeekBits(bs, 16); \
  while (1) { \
   if ((StateR = nextstate(huff, StateR, 0x8000)) & 0x8000) { \
    if (StateR==0xffff || StateR==0x8000) { ScBSSkipBits(bs, bits); \
       return(0);} \
    else { \
     StateR &= 0x7fff; \
     if (StateR == HUFFMAN_ESCAPE) { ScBSSkipBits(bs, bits); \
       if (bs->EOI && bs->shift<14) return(SvErrorEndBitstream); \
       StateR=(int)ScBSGetBits(bs,6); StateL=(int)ScBSGetBits(bs,8); } \
     else { ScBSSkipBits(bs, bits+1); \
       StateL = (cb&0x4000) ? -(StateR & 0xff) : (StateR & 0xff); \
       StateR = StateR >> 8; } \
     break; } \
   } \
   cb<<=1; bits++; \
  }

/*
** sv_h261_cdD6.c
*/
extern SvStatus_t DecodeAC_Scale(SvH261Info_t *H261, ScBitstream_t *bs, 
	int index, int QuantUse, float *fmatrix);

extern float DecodeDC_Scale(SvH261Info_t *H261, ScBitstream_t *bs,
                            int BlockType, int QuantUse);

extern SvStatus_t CBPDecodeAC_Scale(SvH261Info_t *H261, ScBitstream_t *bs, 
	int index, int QuantUse, int BlockType, float *fmatrix);

extern void DGenScaleMat();
extern void ScaleIdct_64(float *ipbuf, int *outbuf);
extern int DecodeDC(SvH261Info_t *H261, ScBitstream_t *bs);


/*
** sv_h261_cdenc.c
*/
extern void GenScaleMat();
extern SvStatus_t EncodeAC(SvH261Info_t *H261,ScBitstream_t *bs,int index,
                     int *matrix);
extern SvStatus_t CBPEncodeAC(SvH261Info_t *H261,ScBitstream_t *bs,int index,
                        int *matrix);
extern void EncodeDC(SvH261Info_t *H261,ScBitstream_t *bs,int coef);
extern void InterQuant(float *tdct,int *dct,int mq);
extern void IntraQuant(float *tdct,int *dct, int mq);

extern void ZigzagMatrix(int *imatrix,int *omatrix);
extern void Inv_Quant(int *matrix,int QuantUse,int BlockType,float *fmatrix);
extern void ScaleIdct_64(float *ipbuf, int *outbuf);
extern void ScaleDct(int * ipbuf, float * outbuf);

/*
** sv_h261_marker.c
*/
extern void WritePictureHeader(SvH261Info_t *H261, ScBitstream_t *bs);
extern void WriteGOBHeader(SvH261Info_t *H261, ScBitstream_t *bs);
extern void ReadHeaderTrailer(SvH261Info_t *H261, ScBitstream_t *bs);
extern SvStatus_t ReadHeaderHeader(SvH261Info_t *H261, ScBitstream_t *bs);
extern void ReadGOBHeader(SvH261Info_t *H261, ScBitstream_t *bs);
extern SvStatus_t WriteMBHeader(SvH261Info_t *H261, ScBitstream_t *bs);
extern int ReadMBHeader(SvH261Info_t *H261, ScBitstream_t *bs);

/*
** sv_h261_me2.c
*/
extern void BruteMotionEstimation(SvH261Info_t *H261, unsigned char *pmem,
                           unsigned char *recmem, unsigned char *fmem);
extern void Logsearch(SvH261Info_t *H261, unsigned char *pmem,
                           unsigned char *recmem, unsigned char *fmem);
extern void CrawlMotionEstimation(SvH261Info_t *H261, unsigned char *pmem,
                           unsigned char *recmem, unsigned char *fmem);
extern int blockdiff16_C(unsigned char* ptr1, unsigned char *ptr2, 
                            int Jump, int mv);
extern int blockdiff16_sub_C(unsigned char* ptr1, unsigned char *ptr2,
                             int Jump, int mv);
extern int fblockdiff16_sub_C(unsigned char* ptr1, unsigned char *ptr2,
                                  int Jump);

/*
** sv_h261_blockdiff.s
*/
extern int blockdiff16(unsigned char* ptr1, unsigned char *ptr2, int Jump,
                       int);
extern int blockdiff16_sub(unsigned char* ptr1, unsigned char *ptr2,
                             int Jump, int);
extern int fblockdiff16_sub(unsigned char* ptr1, unsigned char *ptr2,
                                  int Jump);
/*
** sv_h261_huffman.c
*/
extern void sv_H261HuffInit();
extern void sv_H261HuffFree();

extern int sv_H261HuffEncode(SvH261Info_t *H261, ScBitstream_t *bs, int val,
                  EHUFF *huff);
extern int sv_H261HuffDecode(SvH261Info_t *H261, ScBitstream_t *bs, DHUFF *huff);


#endif /* _SV_H263_PROTO_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech261\sa.h ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: SA.h,v $
 * Revision 1.1.8.4  1996/11/14  21:49:22  Hans_Graves
 * 	Added SaDecompressEx() for AC3 multichannels.
 * 	[1996/11/14  21:46:20  Hans_Graves]
 *
 * Revision 1.1.8.3  1996/11/08  21:50:34  Hans_Graves
 * 	Added AC3 enum types.
 * 	[1996/11/08  21:16:32  Hans_Graves]
 * 
 * Revision 1.1.8.2  1996/07/19  02:11:00  Hans_Graves
 * 	Added SA_PARAM_DEBUG.
 * 	[1996/07/19  01:22:50  Hans_Graves]
 * 
 * Revision 1.1.6.5  1996/04/23  21:01:39  Hans_Graves
 * 	Added protos for SaDecompressQuery() and SaCompressQuery()
 * 	[1996/04/23  20:57:15  Hans_Graves]
 * 
 * Revision 1.1.6.4  1996/04/15  14:18:34  Hans_Graves
 * 	Change proto for SaCompress() - returns bytes processed
 * 	[1996/04/15  14:10:30  Hans_Graves]
 * 
 * Revision 1.1.6.3  1996/04/10  21:47:05  Hans_Graves
 * 	Added PARAMs. Replaced externs with EXTERN.
 * 	[1996/04/10  21:22:49  Hans_Graves]
 * 
 * Revision 1.1.6.2  1996/03/29  22:20:59  Hans_Graves
 * 	Changed include <mme/mmsystem.h> to <mmsystem.h>
 * 	[1996/03/29  22:16:43  Hans_Graves]
 * 
 * Revision 1.1.4.3  1996/02/06  22:53:52  Hans_Graves
 * 	Added PARAM enums
 * 	[1996/02/06  22:18:04  Hans_Graves]
 * 
 * Revision 1.1.4.2  1996/01/15  16:26:21  Hans_Graves
 * 	Added prototypes for SaSetDataDestination() and SaSetBitrate()
 * 	[1996/01/15  15:42:41  Hans_Graves]
 * 
 * Revision 1.1.2.8  1995/09/14  17:28:10  Bjorn_Engberg
 * 	Ported to NT
 * 	[1995/09/14  17:17:18  Bjorn_Engberg]
 * 
 * Revision 1.1.2.7  1995/07/21  17:41:00  Hans_Graves
 * 	Moved Callback related stuff to SC.h
 * 	[1995/07/21  17:27:29  Hans_Graves]
 * 
 * Revision 1.1.2.6  1995/07/17  22:01:30  Hans_Graves
 * 	Defined SaBufferInfo_t as ScBufferInfo_t.
 * 	[1995/07/17  21:41:54  Hans_Graves]
 * 
 * Revision 1.1.2.5  1995/06/27  17:40:59  Hans_Graves
 * 	Added include <mme/mmsystem.h>.
 * 	[1995/06/27  17:39:26  Hans_Graves]
 * 
 * Revision 1.1.2.4  1995/06/27  13:54:20  Hans_Graves
 * 	Added SA_GSM_DECODE and SA_GSM_ENCODE
 * 	[1995/06/26  21:01:12  Hans_Graves]
 * 
 * Revision 1.1.2.3  1995/06/09  18:33:29  Hans_Graves
 * 	Added SaGetInputBitstream() prototype.
 * 	[1995/06/09  17:41:59  Hans_Graves]
 * 
 * Revision 1.1.2.2  1995/05/31  18:09:17  Hans_Graves
 * 	Inclusion in new SLIB location.
 * 	[1995/05/31  15:19:33  Hans_Graves]
 * 
 * Revision 1.1.2.3  1995/04/17  18:26:57  Hans_Graves
 * 	Added ENCODE Codec defs
 * 	[1995/04/17  18:26:33  Hans_Graves]
 * 
 * Revision 1.1.2.2  1995/04/07  19:35:31  Hans_Graves
 * 	Inclusion in SLIB
 * 	[1995/04/07  19:22:48  Hans_Graves]
 * 
 * $EndLog$
 */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/


#ifndef _SA_H_
#define _SA_H_

#ifdef WIN32
#include <windows.h>  /* Windows NT        */
#endif
#include <mmsystem.h> /* needed for WAVEFORMATEX structure def */

#include "SC.h"

typedef enum {
   SA_MPEG_DECODE = 102,
   SA_MPEG_ENCODE = 103,
   SA_PCM_DECODE =  104,
   SA_PCM_ENCODE =  105,
   SA_GSM_DECODE =  106,
   SA_GSM_ENCODE =  107,
   SA_AC3_DECODE =  108,
   SA_AC3_ENCODE =  109,
   SA_G723_DECODE = 110,
   SA_G723_ENCODE = 111,
   SA_TMP_DECODE =  200,  /* temp - used for testing */
   SA_TMP_ENCODE =  201,
} SaCodecType_e;

#define SA_USE_SAME           STREAM_USE_SAME
#define SA_USE_FILE           STREAM_USE_FILE
#define SA_USE_BUFFER_QUEUE   STREAM_USE_QUEUE
#define SA_USE_BUFFER         STREAM_USE_BUFFER

/*
** Parameters
*/
typedef enum {
  SA_PARAM_NATIVEFORMAT,  /* native/preferred decompressed format (FOURCC) */
  SA_PARAM_BITRATE,       /* bitrate - bits per second */
  SA_PARAM_CHANNELS,      /* channels - 1=mono, 2=stereo, 4/5=surround */
  SA_PARAM_AUDIOLENGTH,   /* milliseconds of audio */
  SA_PARAM_SAMPLESPERSEC, /* samples per second (8000, 11025, 22050, etc.)
  SA_PARAM_BITSPERSAMPLE, /* bits per sample (8 or 16) */
  SA_PARAM_TIMECODE,      /* audio time code */
  SA_PARAM_MPEG_LAYER,    /* MPEG Layer: I, II, or III */
  SA_PARAM_PSY_MODEL,     /* Psy Acoustic Model */
  SA_PARAM_ALGFLAGS,      /* Algorithm flags */
  SA_PARAM_QUALITY,       /* Quality: 0=worst 99>=best */
  SA_PARAM_FASTDECODE,    /* Fast decode desired */
  SA_PARAM_FASTENCODE,    /* Fast encode desired */
  SA_PARAM_DEBUG,         /* Setup debug */
} SaParameter_t;

/*
** Type definitions
*/
typedef int SaStatus_t;
typedef void *SaHandle_t;
typedef ScCallbackInfo_t SaCallbackInfo_t;

/*
** Store basic info for user about the codec
*/
typedef struct SaInfo_s {
  SaCodecType_e Type;     /* Codec Type */
  char          Name[20];         /* Codec name (i.e. "MPEG-Decode") */
  char          Description[128]; /* Codec description */
  unsigned int  Version;          /* Codec version number */
  int           CodecStarted;     /* SaDecompressBegin/End */
  unsigned int  MS;               /* Number of milliseconds processed */
  unsigned int  NumBytesIn;       /* Number of bytes input */
  unsigned int  NumBytesOut;      /* Number of bytes output */
  unsigned int  NumFrames;        /* Number of ellapsed frames */
  unsigned long TotalFrames;      /* Total number of frames */
  unsigned long TotalMS;          /* Total number of milliseconds */
} SaInfo_t;

/***************************** Prototypes ********************************/
EXTERN SaStatus_t SaOpenCodec (SaCodecType_e CodecType, SaHandle_t *Sah);
EXTERN SaStatus_t SaCloseCodec (SaHandle_t Sah);
EXTERN SaStatus_t SaRegisterCallback (SaHandle_t Sah,
           int (*Callback)(SaHandle_t, SaCallbackInfo_t *, SaInfo_t *),
           void *UserData);
EXTERN ScBitstream_t *SaGetInputBitstream (SaHandle_t Sah);
EXTERN SaStatus_t SaDecompressQuery(SaHandle_t Sah, WAVEFORMATEX *wfIn,
                                             WAVEFORMATEX *wfOut);
EXTERN SaStatus_t SaDecompressBegin (SaHandle_t Sah, WAVEFORMATEX *wfIn,
                                              WAVEFORMATEX *wfOut);
EXTERN SaStatus_t SaDecompress (SaHandle_t Sah, u_char *CompData, 
                                       unsigned int CompLen,
                           u_char *DcmpData, unsigned int *DcmpLen);
PRIVATE_EXTERN SaStatus_t SaDecompressEx (SaHandle_t Sah, u_char *CompData, 
                                       unsigned int CompLen,
                           u_char **DcmpData, unsigned int *DcmpLen);
EXTERN SaStatus_t SaDecompressEnd (SaHandle_t Sah);
EXTERN SaStatus_t SaCompressQuery(SaHandle_t Sah, WAVEFORMATEX *wfIn,
                                             WAVEFORMATEX *wfOut);
EXTERN SaStatus_t SaCompressBegin (SaHandle_t Sah, WAVEFORMATEX *wfIn,
                                            WAVEFORMATEX *wfOut);
EXTERN SaStatus_t SaCompress (SaHandle_t Sah,
                           u_char *DcmpData, unsigned int *DcmpLen,
                           u_char *CompData, unsigned int *CompLen);
EXTERN SaStatus_t SaCompressEnd (SaHandle_t Sah);
EXTERN SaStatus_t SaSetDataSource(SaHandle_t Sah, int Source, int Fd,
                            void *Buffer_UserData, int BufSize);
EXTERN SaStatus_t SaSetDataDestination(SaHandle_t Sah, int Dest, int Fd,
                            void *Buffer_UserData, int BufSize);
EXTERN ScBitstream_t *SaGetDataSource (SaHandle_t Sah);
EXTERN ScBitstream_t *SaGetDataDestination(SaHandle_t Sah);
EXTERN SaStatus_t SaAddBuffer (SaHandle_t Sah, SaCallbackInfo_t *BufferInfo);
#ifdef MPEG_SUPPORT
EXTERN SaStatus_t sa_GetMpegAudioInfo(int fd, WAVEFORMATEX *wf, 
                                      SaInfo_t *info);
#endif /* MPEG_SUPPORT */
EXTERN SaStatus_t SaSetParamBoolean(SaHandle_t Sah, SaParameter_t param,
                                             ScBoolean_t value);
EXTERN SaStatus_t SaSetParamInt(SaHandle_t Sah, SaParameter_t param,
                                             qword value);
EXTERN ScBoolean_t SaGetParamBoolean(SaHandle_t Sah, SaParameter_t param);
EXTERN qword SaGetParamInt(SaHandle_t Sah, SaParameter_t param);

#endif _SA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech261\sa_api.c ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: sa_api.c,v $
 * Revision 1.1.8.6  1996/11/25  18:21:14  Hans_Graves
 * 	Fix compile warnings under unix.
 * 	[1996/11/25  18:21:00  Hans_Graves]
 *
 * Revision 1.1.8.5  1996/11/14  21:49:21  Hans_Graves
 * 	AC3 buffering fixes.
 * 	[1996/11/14  21:45:14  Hans_Graves]
 * 
 * Revision 1.1.8.4  1996/11/13  16:10:44  Hans_Graves
 * 	AC3 frame size calculation change.
 * 	[1996/11/13  15:53:44  Hans_Graves]
 * 
 * Revision 1.1.8.3  1996/11/08  21:50:27  Hans_Graves
 * 	Added AC3 support.
 * 	[1996/11/08  21:08:35  Hans_Graves]
 * 
 * Revision 1.1.8.2  1996/09/18  23:45:23  Hans_Graves
 * 	Add some some MPEG memory freeing
 * 	[1996/09/18  21:42:12  Hans_Graves]
 * 
 * Revision 1.1.6.8  1996/04/23  21:01:38  Hans_Graves
 * 	Added SaDecompressQuery() and SaCompressQuery()
 * 	[1996/04/23  20:57:47  Hans_Graves]
 * 
 * Revision 1.1.6.7  1996/04/17  16:38:31  Hans_Graves
 * 	Add casts where ScBitBuf_t and ScBitString_t types are used
 * 	[1996/04/17  16:34:14  Hans_Graves]
 * 
 * Revision 1.1.6.6  1996/04/15  14:18:32  Hans_Graves
 * 	Change proto for SaCompress() - returns bytes processed
 * 	[1996/04/15  14:10:27  Hans_Graves]
 * 
 * Revision 1.1.6.5  1996/04/10  21:46:51  Hans_Graves
 * 	Added SaGet/SetParam functions
 * 	[1996/04/10  21:25:16  Hans_Graves]
 * 
 * Revision 1.1.6.4  1996/04/09  16:04:23  Hans_Graves
 * 	Remove warnings under NT
 * 	[1996/04/09  15:55:26  Hans_Graves]
 * 
 * Revision 1.1.6.3  1996/03/29  22:20:48  Hans_Graves
 * 	Added MPEG_SUPPORT and GSM_SUPPORT
 * 	[1996/03/29  21:51:24  Hans_Graves]
 * 
 * Revision 1.1.6.2  1996/03/08  18:46:05  Hans_Graves
 * 	Removed debugging printf
 * 	[1996/03/08  18:42:52  Hans_Graves]
 * 
 * Revision 1.1.4.5  1996/02/22  21:55:04  Bjorn_Engberg
 * 	Removed a compiler warning on NT.
 * 	[1996/02/22  21:54:39  Bjorn_Engberg]
 * 
 * Revision 1.1.4.4  1996/02/06  22:53:51  Hans_Graves
 * 	Moved ScBSReset() from DecompressBegin() to DecompressEnd(). Disabled FRAME callbacks.
 * 	[1996/02/06  22:19:16  Hans_Graves]
 * 
 * Revision 1.1.4.3  1996/01/19  15:29:27  Bjorn_Engberg
 * 	Removed compiler wanrnings for NT.
 * 	[1996/01/19  15:03:46  Bjorn_Engberg]
 * 
 * Revision 1.1.4.2  1996/01/15  16:26:18  Hans_Graves
 * 	Added SaSetBitrate(). SOme MPEG Audio encoding fix-ups
 * 	[1996/01/15  16:07:48  Hans_Graves]
 * 
 * Revision 1.1.2.7  1995/07/21  17:40:57  Hans_Graves
 * 	Renamed Callback related stuff.
 * 	[1995/07/21  17:25:44  Hans_Graves]
 * 
 * Revision 1.1.2.6  1995/06/27  17:40:57  Hans_Graves
 * 	Removed include <mmsystem.h>.
 * 	[1995/06/27  17:32:20  Hans_Graves]
 * 
 * Revision 1.1.2.5  1995/06/27  13:54:14  Hans_Graves
 * 	Added GSM Encoding and Decoding
 * 	[1995/06/26  21:04:12  Hans_Graves]
 * 
 * Revision 1.1.2.4  1995/06/09  18:33:27  Hans_Graves
 * 	Added SaGetInputBitstream().
 * 	[1995/06/09  18:32:35  Hans_Graves]
 * 
 * Revision 1.1.2.3  1995/06/07  19:34:39  Hans_Graves
 * 	Enhanced sa_GetMpegAudioInfo().
 * 	[1995/06/07  19:33:25  Hans_Graves]
 * 
 * Revision 1.1.2.2  1995/05/31  18:07:17  Hans_Graves
 * 	Inclusion in new SLIB location.
 * 	[1995/05/31  17:28:50  Hans_Graves]
 * 
 * Revision 1.1.2.3  1995/04/17  18:47:31  Hans_Graves
 * 	Added MPEG Compression functionality
 * 	[1995/04/17  18:47:00  Hans_Graves]
 * 
 * Revision 1.1.2.2  1995/04/07  19:55:45  Hans_Graves
 * 	Inclusion in SLIB
 * 	[1995/04/07  19:55:15  Hans_Graves]
 * 
 * $EndLog$
 */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

/*
#define _DEBUG_
#define _VERBOSE_
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "SC.h"
#include "SC_err.h"
#include "SA.h"
#ifdef MPEG_SUPPORT
#include "sa_mpeg.h"
#endif /* MPEG_SUPPORT */
#ifdef GSM_SUPPORT
#include "sa_gsm.h"
#endif /* GSM_SUPPORT */
#ifdef AC3_SUPPORT
#include "sa_ac3.h"
#endif /* AC3_SUPPORT */
#include "sa_intrn.h"
#include "sa_proto.h"

#ifdef MPEG_SUPPORT
static int MPEGAudioFilter(ScBitstream_t *bs)
{
  int type, stat=NoErrors;
  unsigned dword PacketStartCode;
  ScBSPosition_t PacketStart, PacketLength=0;

  while (!bs->EOI)
  {
    if ((int)ScBSPeekBits(bs, MPEG_SYNC_WORD_LEN)==MPEG_SYNC_WORD)
    {
      ScBSSetFilter(bs, NULL);
      return(0);
    }
    PacketStartCode=(unsigned int)ScBSGetBits(bs, PACKET_START_CODE_PREFIX_LEN);
    if (PacketStartCode!=PACKET_START_CODE_PREFIX) {
      fprintf(stderr,"Packet cannot be located at Byte pos 0x%X; got 0x%X\n",
                      ScBSBytePosition(bs),PacketStartCode);
      bs->EOI=TRUE;
      return(-1);
    }
    type=(int)ScBSGetBits(bs, 8);
    switch (type)
    {
      case AUDIO_STREAM_BASE:
             PacketLength=(unsigned int)ScBSGetBits(bs, 16)*8;
             PacketStart=ScBSBitPosition(bs);
             sc_dprintf("Audio Packet Start=0x%X Length=0x%X (0x%X)\n",
                          PacketStart/8, PacketLength/8, PacketLength/8);
             while (ScBSPeekBits(bs, 8)==0xFF) /* Stuffing bytes */
               ScBSSkipBits(bs, 8);
             if (ScBSPeekBits(bs, 2)==1)       /* STD_buffer stuff */
               ScBSSkipBits(bs, 2*8);
             if (ScBSPeekBits(bs, 4)==2)       /* Time Stamps */
               ScBSSkipBits(bs, 5*8);
             else if (ScBSPeekBits(bs, 4)==3)  /* Time Stamps */
               ScBSSkipBits(bs, 10*8);
             else if (ScBSGetBits(bs, 8)!=0x0F)
               fprintf(stderr, "Last byte before data not 0x0F at pos 0x%X\n",
                                             ScBSBytePosition(bs));
             return((int)(PacketStart+PacketLength));
             break;
      case PACK_START_BASE:
             sc_dprintf("Pack Start=0x%X Length=0x%X\n",
                          ScBSBytePosition(bs), 8);
             ScBSSkipBits(bs, 8*8);
             break;
      default:
             PacketLength=(unsigned int)ScBSGetBits(bs, 16)*8;
             ScBSSkipBits(bs, (unsigned int)PacketLength);
             break;
    }
  }
  return(0);
}
#endif /* MPEG_SUPPORT */

/*
** Name:     SaOpenCodec
** Purpose:  Open the specified codec. Return stat code.
**
** Args:     CodecType = SA_MPEG_ENCODE & SA_MPEG_DECODE are the only
**           recognized codec for now.
**           Sah = handle to software codec's Info structure.
*/
SaStatus_t SaOpenCodec (SaCodecType_e CodecType, SaHandle_t *Sah)
{
   int stat;
   SaCodecInfo_t          *Info = NULL;

   if ((CodecType != SA_PCM_DECODE)
       && (CodecType != SA_PCM_ENCODE)
#ifdef MPEG_SUPPORT
       && (CodecType != SA_MPEG_DECODE)
       && (CodecType != SA_MPEG_ENCODE)
#endif /* MPEG_SUPPORT */
#ifdef GSM_SUPPORT
       && (CodecType != SA_GSM_DECODE)
       && (CodecType != SA_GSM_ENCODE)
#endif /* GSM_SUPPORT */
#ifdef AC3_SUPPORT
       && (CodecType != SA_AC3_DECODE)
       /* && (CodecType != SA_AC3_ENCODE) */
#endif /* AC3_SUPPORT */
#ifdef G723_SUPPORT
       && (CodecType != SA_G723_DECODE)
       && (CodecType != SA_G723_ENCODE)
#endif /* G723_SUPPORT */
     )
     return(SaErrorCodecType);

   if (!Sah)
     return (SaErrorBadPointer);

   /*
   ** Allocate memory for the Codec Info structure:
   */
   if ((Info = (SaCodecInfo_t *)ScAlloc(sizeof(SaCodecInfo_t))) == NULL)
       return (SaErrorMemory);

   Info->Type = CodecType;
   Info->CallbackFunction=NULL;
   Info->BSIn = NULL;
   Info->BSOut = NULL;
   stat = ScBufQueueCreate(&Info->Q);
   if (stat != NoErrors)
     return(stat);

   /*
   ** Allocate memory for Info structure and clear it
   */
   switch(CodecType)
   {
     case SA_PCM_DECODE:
     case SA_PCM_ENCODE:
          break;

#ifdef MPEG_SUPPORT
     case SA_MPEG_DECODE:
          {
            SaMpegDecompressInfo_t *MDInfo;
            if ((MDInfo = (SaMpegDecompressInfo_t *)
                  ScAlloc (sizeof(SaMpegDecompressInfo_t))) == NULL)
              return(SaErrorMemory);
            Info->MDInfo = MDInfo;
            stat = sa_InitMpegDecoder (Info);
            RETURN_ON_ERROR(stat);
          }
          break;

     case SA_MPEG_ENCODE:
          {
            SaMpegCompressInfo_t *MCInfo;
            if ((MCInfo = (SaMpegCompressInfo_t *)
                  ScAlloc (sizeof(SaMpegCompressInfo_t))) == NULL)
              return(SaErrorMemory);
            Info->MCInfo = MCInfo;
            stat = sa_InitMpegEncoder (Info);
            RETURN_ON_ERROR(stat);
          }
          break;
#endif /* MPEG_SUPPORT */

#ifdef AC3_SUPPORT
     case SA_AC3_DECODE:
     /* case SA_AC3_ENCODE: */
          {
            SaAC3DecompressInfo_t *AC3Info;
            if ((AC3Info = (SaAC3DecompressInfo_t *)
                       ScAlloc (sizeof(SaAC3DecompressInfo_t))) == NULL)
              return(SaErrorMemory);
            Info->AC3Info = AC3Info;

            /* Initialize Dolby subroutine */
            stat = sa_InitAC3Decoder(Info);
          }
          break;
#endif /* AC3_SUPPORT */


#ifdef GSM_SUPPORT
     case SA_GSM_DECODE:
     case SA_GSM_ENCODE:
          {
            SaGSMInfo_t *GSMInfo;
            if ((GSMInfo = (SaGSMInfo_t *)ScAlloc (sizeof(SaGSMInfo_t)))==NULL)
              return(SaErrorMemory);
            Info->GSMInfo = GSMInfo;
            stat = sa_InitGSM(GSMInfo);
            RETURN_ON_ERROR(stat);
          }
          break;
#endif /* GSM_SUPPORT */

#ifdef G723_SUPPORT
     case SA_G723_DECODE:
          {
            SaG723Info_t *pSaG723Info;
            if ((pSaG723Info = (SaG723Info_t *)
                  ScAlloc (sizeof(SaG723Info_t))) == NULL)
              return(SaErrorMemory);

            Info->pSaG723Info = pSaG723Info;
            saG723DecompressInit(pSaG723Info);
          }
          break;

     case SA_G723_ENCODE:
          {
            SaG723Info_t *pSaG723Info;
            if ((pSaG723Info = (SaG723Info_t *)
                  ScAlloc (sizeof(SaG723Info_t))) == NULL)
              return(SaErrorMemory);

            Info->pSaG723Info = pSaG723Info;
            saG723CompressInit(pSaG723Info);
            SaSetParamInt((SaHandle_t)Info, SA_PARAM_BITRATE, 6400);
          }
          break;
#endif /* G723_SUPPORT */

    default:
          return(SaErrorCodecType);
   }
   *Sah = (SaHandle_t) Info;        /* Return handle */
   Info->wfIn=NULL;
   Info->wfOut=NULL;

   return(NoErrors);
}

/*
** Name:     SaCloseCodec
** Purpose:  Closes the specified codec. Free the Info structure
**
** Args:     Sah = handle to software codec's Info structure.
**
*/
SaStatus_t SaCloseCodec (SaHandle_t Sah)
{
   SaCodecInfo_t *Info = (SaCodecInfo_t *)Sah;

   if (!Info)
     return(SaErrorCodecHandle);

   ScBufQueueDestroy(Info->Q);

   switch (Info->Type)
   {
#ifdef MPEG_SUPPORT
       case SA_MPEG_DECODE:
            if (Info->MDInfo) 
            {
              sa_EndMpegDecoder(Info);
              ScFree(Info->MDInfo);
            }
            break;
       case SA_MPEG_ENCODE:
            if (Info->MCInfo)
            {
              sa_EndMpegEncoder(Info);
              ScFree(Info->MCInfo);
            }
            break;
#endif /* MPEG_SUPPORT */
#ifdef AC3_SUPPORT
     case SA_AC3_DECODE:
     /* case SA_AC3_ENCODE: */
            sa_EndAC3Decoder(Info);
            if (Info->AC3Info)
              ScFree(Info->AC3Info);
            break;
#endif /* AC3_SUPPORT */
#ifdef GSM_SUPPORT
     case SA_GSM_DECODE:
     case SA_GSM_ENCODE:
            if (Info->GSMInfo)
              ScFree(Info->GSMInfo);
            break;
#endif /* GSM_SUPPORT */

#ifdef G723_SUPPORT
       case SA_G723_DECODE:
            if (Info->pSaG723Info) 
            {
              saG723DecompressFree(Info->pSaG723Info);
              ScFree(Info->pSaG723Info);
            }
            break;
       case SA_G723_ENCODE:
            if (Info->pSaG723Info)
            {
              saG723CompressFree(Info->pSaG723Info);
              ScFree(Info->pSaG723Info);
            }
            break;
#endif /* G723_SUPPORT */
   }

   if (Info->wfIn)
     ScFree(Info->wfIn);
   if (Info->wfOut)
     ScFree(Info->wfOut);

   /*
   ** Free Info structure
   */
   if (Info->BSIn)
     ScBSDestroy(Info->BSIn);
   if (Info->BSOut)
     ScBSDestroy(Info->BSOut);

   ScFree(Info);

   return(NoErrors);
}

/*
** Name:     SaRegisterCallback
** Purpose:  Specify the user-function that will be called during processing
**           to determine if the codec should abort the frame.
** Args:     Sah          = handle to software codec's Info structure.
**           Callback     = callback function to register
**
*/
SaStatus_t SaRegisterCallback (SaHandle_t Sah,
           int (*Callback)(SaHandle_t, SaCallbackInfo_t *, SaInfo_t *),
           void *UserData)
{
  SaCodecInfo_t *Info = (SaCodecInfo_t *)Sah;

  if (!Info)
    return(SaErrorCodecHandle);

  if (!Callback)
     return(SaErrorBadPointer);

  Info->CallbackFunction = Callback;
  if (Info->BSIn)
  {
    Info->BSIn->Callback=(int (*)(ScHandle_t, ScCallbackInfo_t *, void *))Callback;
    Info->BSIn->UserData=UserData;
  }
  if (Info->BSOut)
  {
    Info->BSOut->Callback=(int (*)(ScHandle_t, ScCallbackInfo_t *, void *))Callback;
    Info->BSOut->UserData=UserData;
  }
  return(NoErrors);
}

/*
** Name: SaGetInputBitstream
** Purpose: Returns the current input bitstream being used by
**          the Codec.
** Return:  NULL if there no associated bitstream
*/
ScBitstream_t *SaGetInputBitstream (SaHandle_t Sah)
{
  SaCodecInfo_t *Info = (SaCodecInfo_t *)Sah;

  if (Info)
    return(Info->BSIn);
  return(NULL);
}

/***************************** Decompression *******************************/
/*
** Name:     SaDecompressQuery
** Purpose:  Check if input and output formats are supported.
*/
SaStatus_t SaDecompressQuery(SaHandle_t Sah, WAVEFORMATEX *wfIn,
                                             WAVEFORMATEX *wfOut)
{
  SaCodecInfo_t *Info = (SaCodecInfo_t *)Sah;

  /*
   * This stuff should really be pushed down to the individual codecs
   * unless it has to be here - tfm 
   */
  if (!Info)
    return(SaErrorCodecHandle);

  if (wfIn)
  {
    if (wfIn->nChannels!=1 && wfIn->nChannels!=2)
      return(SaErrorUnrecognizedFormat);
  }
  if (wfOut)
  {
    if (wfOut->wFormatTag != WAVE_FORMAT_PCM)
      return(SaErrorUnrecognizedFormat);
    if (wfOut->nChannels!=1 && wfOut->nChannels!=2 && wfOut->nChannels!=4)
      return(SaErrorUnrecognizedFormat);
  }
  if (wfIn && wfOut)
  {
    if (wfIn->nSamplesPerSec != wfOut->nSamplesPerSec)
      return(SaErrorUnrecognizedFormat);

    if (wfIn->wBitsPerSample !=16 && 
        (wfOut->wBitsPerSample !=16 || wfOut->wBitsPerSample !=8))
      return(SaErrorUnrecognizedFormat);
  }
  return(SaErrorNone);
}

/*
** Name:     SaDecompressBegin
** Purpose:  Initialize the Decompression Codec. Call after SaOpenCodec &
**           before SaDecompress (SaDecompress will call SaDecompressBegin
**           on first call to codec after open if user doesn't call it)
**
** Args:     Sah = handle to software codec's Info structure.
**           wfIn  = format of input (compressed) audio
**           wfOut = format of output (uncompressed) audio
*/
SaStatus_t SaDecompressBegin (SaHandle_t Sah, WAVEFORMATEX *wfIn,
                                              WAVEFORMATEX *wfOut)
{
  SaCodecInfo_t *Info = (SaCodecInfo_t *)Sah;
  SaStatus_t status;

  if (!Info)
    return(SaErrorCodecHandle);

  if (!wfIn || !wfOut)
    return(SaErrorBadPointer);

  status=SaDecompressQuery(Sah, wfIn, wfOut);
  if (status!=SaErrorNone)
    return(status);

  switch (Info->Type)
  {
     case SA_PCM_DECODE:
        break;
#ifdef MPEG_SUPPORT
     case SA_MPEG_DECODE:
        if (Info->MDInfo->DecompressStarted = FALSE)
           Info->MDInfo->DecompressStarted = TRUE;
        break;
#endif /* MPEG_SUPPORT */
#ifdef AC3_SUPPORT
     case SA_AC3_DECODE:
        if (Info->AC3Info->DecompressStarted = FALSE)
           Info->AC3Info->DecompressStarted = TRUE;
        break;
#endif /* AC3_SUPPORT */

#ifdef G723_SUPPORT
     /*
     case SA_G723_DECODE:
        if (Info->pSaG723Info->DecompressStarted = FALSE)
           Info->pSaG723Info->DecompressStarted = TRUE;
        break;
      */
#endif /* G723_SUPPORT */
  }
  if ((Info->wfIn = (WAVEFORMATEX *)ScAlloc(sizeof(WAVEFORMATEX)+
            wfIn->cbSize)) == NULL)
       return (SaErrorMemory);
  if ((Info->wfOut = (WAVEFORMATEX *)ScAlloc(sizeof(WAVEFORMATEX)+
           wfOut->cbSize)) == NULL)
       return (SaErrorMemory);
  memcpy(Info->wfOut, wfOut, sizeof(WAVEFORMATEX)+wfOut->cbSize);
  memcpy(Info->wfIn, wfIn, sizeof(WAVEFORMATEX)+wfIn->cbSize);
  return(NoErrors);
}

/*
** Name:     SaDecompress
** Purpose:  Decompress a frame CompData -> PCM
**
** Args:     Sah        = handle to software codec's Info structure.
**           CompData   = Pointer to compressed data (INPUT)
**           CompLen    = Length of CompData buffer
**           DcmpData   = buffer for decompressed data (OUTPUT)
**           DcmpLen    = Size of output buffer
**
*/
SaStatus_t SaDecompress (SaHandle_t Sah, u_char *CompData, unsigned int CompLen,
                           u_char *DcmpData, unsigned int *DcmpLen)
{
  SaCodecInfo_t *Info = (SaCodecInfo_t *)Sah;
  unsigned int MaxDcmpLen = *DcmpLen;
  int stat=NoErrors;


  if (Sah==NULL)
    return(SaErrorCodecHandle);

  if (!DcmpData || !DcmpLen)
    return(SaErrorBadPointer);

  switch (Info->Type)
  {
#ifdef MPEG_SUPPORT
    case SA_MPEG_DECODE:
       stat=sa_DecompressMPEG(Info, DcmpData, MaxDcmpLen, DcmpLen);
       Info->Info.NumBytesOut += *DcmpLen;
       break; 
    case SA_PCM_DECODE:
       stat=ScBSGetBytes(Info->BSIn, DcmpData, MaxDcmpLen, DcmpLen);
       Info->Info.NumBytesIn += *DcmpLen;
       Info->Info.NumBytesOut += *DcmpLen;
       break;
#endif /* MPEG_SUPPORT */

#ifdef AC3_SUPPORT
    case SA_AC3_DECODE:
       stat=sa_DecompressAC3(Info, &DcmpData, MaxDcmpLen, DcmpLen);
	    Info->Info.NumBytesOut += *DcmpLen;
       break;
#endif /* AC3_SUPPORT */

#ifdef GSM_SUPPORT
    case SA_GSM_DECODE:
       stat=sa_GSMDecode(Info->GSMInfo, CompData, (word *)DcmpData);
       if (stat==NoErrors)
       {
         *DcmpLen = 160 * 2;
         Info->Info.NumBytesIn += 33;
         Info->Info.NumBytesOut += 160 * 2;
       }
       else
         *DcmpLen = 0;
       break;
#endif /* GSM_SUPPORT */

#ifdef G723_SUPPORT
    case SA_G723_DECODE:
       //Can add a Param for to have CRC or not
       {
         word Crc = 0;

         stat = saG723Decompress( Info,(word *)DcmpData,
                                       (char *)CompData, Crc ) ;
         if(stat == SaErrorNone)
         {
            *DcmpLen = 480; //G723 240 samples(16-bit)= 240*2 = 480 bytes
            Info->Info.NumBytesOut += *DcmpLen;
         }
         else
            *DcmpLen = 0;
       }  
       break; 
    /*
    case SA_PCM_DECODE:
       stat=ScBSGetBytes(Info->BSIn, DcmpData, MaxDcmpLen, DcmpLen);
       Info->Info.NumBytesIn += *DcmpLen;
       Info->Info.NumBytesOut += *DcmpLen;
       break;
    */
#endif /* G723_SUPPORT */
    default:
       *DcmpLen=0;
       return(SaErrorUnrecognizedFormat);
  }
#if 0
  if (*DcmpLen && Info->CallbackFunction)
  {
    SaCallbackInfo_t CB;
    CB.Message       = CB_FRAME_READY;
    CB.Data          = DcmpData;
    CB.DataSize      = CB_DATA_AUDIO;
    CB.DataSize      = MaxDcmpLen;
    CB.DataUsed      = *DcmpLen;
    CB.Action        = CB_ACTION_CONTINUE;
    (*Info->CallbackFunction)(Sah, &CB, &Info->Info);
  }
#endif

  return(stat);
}

/*
** Name:     SaDecompressEx
** Purpose:  Decompress a frame CompData -> PCM
**
** Args:     Sah        = handle to software codec's Info structure.
**           CompData   = Pointer to compressed data (INPUT)
**           CompLen    = Length of CompData buffer
**           DcmpData   = Array of pointers to buffer for decompressed data (OUTPUT)
**           DcmpLen    = Size of decompressed buffers (all must be the same size)
**
*/
SaStatus_t SaDecompressEx (SaHandle_t Sah, u_char *CompData, unsigned int CompLen,
                           u_char **DcmpData, unsigned int *DcmpLen)
{
  SaCodecInfo_t *Info = (SaCodecInfo_t *)Sah;
  unsigned int MaxDcmpLen = *DcmpLen;
  int stat=NoErrors;


  if (Sah==NULL)
    return(SaErrorCodecHandle);

  if (!DcmpData || !DcmpLen)
    return(SaErrorBadPointer);

  switch (Info->Type)
  {
#ifdef AC3_SUPPORT
    case SA_AC3_DECODE:

       stat=sa_DecompressAC3(Info, DcmpData, MaxDcmpLen, DcmpLen);
	   Info->Info.NumBytesOut += *DcmpLen;
       break;
#endif /* AC3_SUPPORT */
  }

  return(stat);
}


/*
** Name:     SaDecompressEnd
** Purpose:  Terminate the Decompression Codec. Call after all calls to
**           SaDecompress are done.
**
** Args:     Sah = handle to software codec's Info structure.
*/
SaStatus_t SaDecompressEnd (SaHandle_t Sah)
{
  SaCodecInfo_t *Info = (SaCodecInfo_t *)Sah;

  if (!Info)
    return(SaErrorCodecHandle);

  switch (Info->Type)
  {
#ifdef MPEG_SUPPORT
     case SA_MPEG_DECODE:
        Info->MDInfo->DecompressStarted = FALSE;
        break;
#endif /* MPEG_SUPPORT */
#ifdef AC3_SUPPORT
     case SA_AC3_DECODE:
        Info->AC3Info->DecompressStarted = FALSE;
        break;
#endif /* AC3_SUPPORT */
#ifdef G723_SUPPORT
     case SA_G723_DECODE:
        //Info->pSaG723Info->DecompressStarted = FALSE;
        break;
#endif /* G723_SUPPORT */
     default:
        break;
  }
  if (Info->BSIn)
    ScBSReset(Info->BSIn); /* frees up any remaining compressed buffers */
  return(NoErrors);
}

/****************************** Compression ********************************/
/*
** Name:     SaCompressQuery
** Purpose:  Check if input and output formats are supported.
*/
SaStatus_t SaCompressQuery(SaHandle_t Sah, WAVEFORMATEX *wfIn,
                                           WAVEFORMATEX *wfOut)
{
  SaCodecInfo_t *Info = (SaCodecInfo_t *)Sah;
  if (!Info)
    return(SaErrorCodecHandle);

  if (!wfIn || !wfOut)
    return(SaErrorBadPointer);

  if (wfIn)
  {
    if (wfIn->wFormatTag != WAVE_FORMAT_PCM)
      return(SaErrorUnrecognizedFormat);
    if (wfIn->nChannels!=1 && wfIn->nChannels!=2)
      return(SaErrorUnrecognizedFormat);
  }
  if (wfOut)
  {
    if (wfOut->nChannels!=1 && wfOut->nChannels!=2)
      return(SaErrorUnrecognizedFormat);
  }

  if (wfIn && wfOut)
  {
    if (wfIn->nSamplesPerSec != wfOut->nSamplesPerSec)
      return(SaErrorUnrecognizedFormat);

    if (wfIn->wBitsPerSample!=16 && 
        (wfOut->wBitsPerSample !=16 || wfOut->wBitsPerSample !=8))
      return(SaErrorUnrecognizedFormat);
  }
  return(SaErrorNone);
}

/*
** Name:     SaCompressBegin
** Purpose:  Initialize the Compression Codec. Call after SaOpenCodec &
**           before SaCompress (SaCompress will call SaCompressBegin
**           on first call to codec after open if user doesn't call it)
**
** Args:     Sah = handle to software codec's Info structure.
**           wfIn  = format of input (uncompressed) audio
**           wfOut = format of output (compressed) audio
*/
SaStatus_t SaCompressBegin (SaHandle_t Sah, WAVEFORMATEX *wfIn,
                                            WAVEFORMATEX *wfOut)
{
  SaCodecInfo_t *Info = (SaCodecInfo_t *)Sah;
  SaStatus_t status;

  if (!Info)
    return(SaErrorCodecHandle);

  if (!wfIn || !wfOut)
    return(SaErrorBadPointer);

  status=SaCompressQuery(Sah, wfIn, wfOut);
  if (status!=SaErrorNone)
    return(status);

  switch (Info->Type)
  {
#ifdef MPEG_SUPPORT
     case SA_MPEG_ENCODE:
        SaSetParamInt(Sah, SA_PARAM_SAMPLESPERSEC, wfIn->nSamplesPerSec);
        SaSetParamInt(Sah, SA_PARAM_CHANNELS, wfIn->nChannels);
        sa_MpegVerifyEncoderSettings(Sah);
        if (Info->MCInfo->CompressStarted = FALSE)
           Info->MCInfo->CompressStarted = TRUE;
        break;
#endif /* MPEG_SUPPORT */
#ifdef GSM_SUPPORT
     case SA_GSM_ENCODE:
        break;
#endif /* GSM_SUPPORT */
#ifdef AC3_SUPPORT
#if 0
     case SA_AC3_ENCODE:
        break;
#endif
#endif /* AC3_SUPPORT */
#ifdef G723_SUPPORT
     case SA_G723_ENCODE:
        //SaSetParamInt(Sah, SA_PARAM_SAMPLESPERSEC, wfIn->nSamplesPerSec);
        //SaSetParamInt(Sah, SA_PARAM_CHANNELS, wfIn->nChannels);
        //sa_MpegVerifyEncoderSettings(Sah);
        /*
        if (Info->pSaG723Info->CompressStarted = FALSE)
           Info->pSaG723Info->CompressStarted = TRUE;
        */
        break;
#endif /* G723_SUPPORT */
     case SA_PCM_ENCODE:
        break;
     default:
        return(SaErrorUnrecognizedFormat);
  }
  if ((Info->wfIn = (WAVEFORMATEX *)ScAlloc(sizeof(WAVEFORMATEX)+
            wfIn->cbSize)) == NULL)
       return (SaErrorMemory);
  if ((Info->wfOut = (WAVEFORMATEX *)ScAlloc(sizeof(WAVEFORMATEX)+
           wfOut->cbSize)) == NULL)
       return (SaErrorMemory);
  memcpy(Info->wfOut, wfOut, sizeof(WAVEFORMATEX)+wfOut->cbSize);
  memcpy(Info->wfIn, wfIn, sizeof(WAVEFORMATEX)+wfIn->cbSize);
  return(NoErrors);
}

/*
** Name:     SaCompress
** Purpose:  Compress PCM audio  ->CompData 
**
** Args:     Sah        = handle to software codec's Info structure.
**           DcmpData   = buffer for decompressed data (INPUT)
**           DcmpLen    = Number of Bytes Compressed (return bytes processed)
**           CompData   = Pointer to compressed data (OUTPUT)
**           CompLen    = Length of CompData buffer
**
*/
SaStatus_t SaCompress(SaHandle_t Sah, 
                           u_char *DcmpData, unsigned int *DcmpLen,
                           u_char *CompData, unsigned int *CompLen)
{
  SaCodecInfo_t *Info = (SaCodecInfo_t *)Sah;
  unsigned int MaxCompLen = *CompLen, NumBytesIn=0;
  int stat=NoErrors;

  if (Sah==NULL)
    return(SaErrorCodecHandle);

  if (!DcmpData || !DcmpLen || !CompLen)
    return(SaErrorBadPointer);

  *CompLen = 0;
  switch (Info->Type)
  {
#ifdef MPEG_SUPPORT
    case SA_MPEG_ENCODE:
       {
         unsigned int DcmpBytes, CompBytes, Offset;
         Offset=0;
         *CompLen=0;
         do  {
           DcmpBytes=*DcmpLen-Offset;
           if (DcmpBytes<sa_GetMPEGSampleSize(Info)*2)
             break;
           _SlibDebug(_DEBUG_,
               printf("sa_CompressMPEG(Offset=%d) Address=%p Len=%d\n", Offset,
                          DcmpData, DcmpBytes) );
           stat=sa_CompressMPEG(Info, DcmpData+Offset, &DcmpBytes, 
                                                       &CompBytes);
           if (stat==NoErrors)
           {
             if (CompBytes && Info->CallbackFunction)
             {
               SaCallbackInfo_t CB;
               CB.Message       = CB_FRAME_READY;
               CB.Data          = DcmpData+Offset;
               CB.DataType      = CB_DATA_COMPRESSED;
               CB.DataSize      = *DcmpLen-Offset;
               CB.DataUsed      = CompBytes;
               CB.Action        = CB_ACTION_CONTINUE;
               (*Info->CallbackFunction)(Sah, &CB, &Info->Info);
             }
             Offset+=DcmpBytes;
             NumBytesIn += DcmpBytes;
             *CompLen+=CompBytes;
           }
         } while (stat==NoErrors && DcmpBytes>0 && Offset<*DcmpLen);
       }
       break; 
#endif /* MPEG_SUPPORT */
#ifdef GSM_SUPPORT
    case SA_GSM_ENCODE:
       {
         unsigned int DcmpBytes, CompBytes, Offset;
         Offset=0;
         *CompLen=0;
         if (!Info->BSOut && !CompData)
           return(SaErrorBadPointer);
         do  {
           DcmpBytes=*DcmpLen-Offset;
           stat=sa_GSMEncode(Info->GSMInfo, (word *)(DcmpData+Offset),
                                          &DcmpBytes, CompData, Info->BSOut);
           if (stat==NoErrors)
           {
             Offset+=DcmpBytes;
             NumBytesIn += DcmpBytes;
             *CompLen += 33;
             if (CompData)
               CompData += 33;
           }
         } while (stat==NoErrors && Offset<*DcmpLen);
       }
       break;
#endif /* GSM_SUPPORT */
#ifdef AC3_SUPPORT
#if 0 /* no AC-3 Encode yet */
    case SA_AC3_ENCODE:
       {
         unsigned int DcmpBytes, CompBytes, Offset;
         Offset=0;
         *CompLen=0;
         if (!Info->BSOut && !CompData)
           return(SaErrorBadPointer);
         do  {
           DcmpBytes=*DcmpLen-Offset;
           stat=sa_AC3Encode(Info->AC3Info, (word *)(DcmpData+Offset),
                                      &DcmpBytes, CompData, Info->BSOut);
           if (stat==NoErrors)
           {
             Offset+=DcmpBytes;
             NumBytesIn += DcmpBytes;
             *CompLen += 33;
             if (CompData)
               CompData += 33;
           }
         } while (stat==NoErrors && Offset<*DcmpLen);
       }
       break;
#endif
#endif /* AC3_SUPPORT */
#ifdef G723_SUPPORT
    case SA_G723_ENCODE:
       {
         /* Call SaG723Compress (audiobufsize/480) times
          * Need to store unprocessed stuff in Info->AudiobufUsed.
          * (This is done in SlibWriteAudio)
          * G723 encodes 240 samples at a time.=240*2 =480
          */
         unsigned int Offset;
         int iTimes = (int)(*DcmpLen / 480);
         int iLoop =0;
         Offset=0;
         *CompLen=0;
         while (stat==SaErrorNone && iLoop<iTimes)
         {
           stat = saG723Compress(Info,(word *)(DcmpData+Offset),
                                            (char *)CompData);
           Offset+=480; /* Input :240 samples (240*2 = 480 bytes) */
           NumBytesIn += 480;
           *CompLen+=24;/* 24 for 6.3 ;20 for 5.3 rate */
           iLoop++;
         }
       }
       break; 
#endif /* G723_SUPPORT */
    case SA_PCM_ENCODE:
       ScBSPutBytes(Info->BSOut, DcmpData, *DcmpLen);
       *CompLen = *DcmpLen;
       NumBytesIn = *DcmpLen;
       break;
    default:
       *CompLen=0;
       return(SaErrorUnrecognizedFormat);
  }
  *DcmpLen = NumBytesIn;
  Info->Info.NumBytesIn += NumBytesIn;
  Info->Info.NumBytesOut += *CompLen;

  return(stat);
}

/*
** Name:     SaCompressEnd
** Purpose:  Terminate the Compression Codec. Call after all calls to
**           SaCompress are done.
**
** Args:     Sah = handle to software codec's Info structure.
*/
SaStatus_t SaCompressEnd (SaHandle_t Sah)
{
  SaCodecInfo_t *Info = (SaCodecInfo_t *)Sah;

  if (!Info)
    return(SaErrorCodecHandle);

  switch (Info->Type)
  {
#ifdef MPEG_SUPPORT
    case SA_MPEG_ENCODE:
       Info->MCInfo->CompressStarted = FALSE;
       break;
#endif /* MPEG_SUPPORT */
#ifdef G723_SUPPORT
    case SA_G723_ENCODE:
       //Info->pSaG723Info->CompressStarted = FALSE;
       break;
#endif /* G723_SUPPORT */
    default:
       break;
  }
  if (Info->BSOut)
    ScBSFlush(Info->BSOut);  /* flush out any remaining compressed buffers */

/*
  if (Info->CallbackFunction)
  {
    CB.Message = CB_CODEC_DONE;
    CB.Data = NULL;
    CB.DataSize = 0;
    CB.DataUsed = 0;
    CB.DataType = CB_DATA_NONE;
    CB.TimeStamp = 0;
    CB.Flags = 0;
    CB.Value = 0;
    CB.Format = NULL;
    CB.Action  = CB_ACTION_CONTINUE;
    (*Info->CallbackFunction)(Sah, &CB, NULL);
    _SlibDebug(_DEBUG_,
            printf("SaDecompressEnd Callback: CB_CODEC_DONE Action = %d\n",
                    CB.Action) );
    if (CB.Action == CB_ACTION_END)
      return (ScErrorClientEnd);
  }
*/
  return(NoErrors);
}


/***************************** Miscellaneous *******************************/
/*
** Name:     SaSetDataSource
** Purpose:  Set the data source used by the MPEG bitstream parsing code
**           to either the Buffer Queue or File input. The default is
**           to use the Buffer Queue where data buffers are added by calling
**           SaAddBuffer. When using file IO, the data is read from a file
**           descriptor into a buffer supplied by the user.
**
** Args:     Sah    = handle to software codec's Info structure.
**           Source = SU_USE_QUEUE or SU_USE_FILE
**           Fd     = File descriptor to use if Source = SV_USE_FILE
**           Buf    = Pointer to buffer to use if Source = SV_USE_FILE
**           BufSize= Size of buffer when Source = SV_USE_FILE
*/
SaStatus_t SaSetDataSource (SaHandle_t Sah, int Source, int Fd,
                            void *Buffer_UserData, int BufSize)
{
  SaCodecInfo_t *Info = (SaCodecInfo_t *)Sah;
  int stat=NoErrors;
  int DataType;

  if (!Info)
    return(SaErrorCodecHandle);

  if (Info->Type==SA_MPEG_DECODE || Info->Type==SA_GSM_DECODE ||
	  Info->Type==SA_AC3_DECODE || Info->Type == SA_G723_DECODE )
    DataType=CB_DATA_COMPRESSED;
  else
    DataType=CB_DATA_AUDIO;

  if (Info->BSIn)
  {
    ScBSDestroy(Info->BSIn);
    Info->BSIn=NULL;
  }

  switch (Source)
  {
#ifdef MPEG_SUPPORT
     case SA_USE_SAME:
       if (Info->Type==SA_MPEG_DECODE)
         ScBSSetFilter(Info->BSIn, MPEGAudioFilter);
       break;
#endif /* MPEG_SUPPORT */
     case SA_USE_BUFFER:
       stat=ScBSCreateFromBuffer(&Info->BSIn, Buffer_UserData, BufSize); 
#ifdef MPEG_SUPPORT
       if (stat==NoErrors && Info->Type==SA_MPEG_DECODE)
         ScBSSetFilter(Info->BSIn, MPEGAudioFilter);
#endif /* MPEG_SUPPORT */
       break;

     case SA_USE_BUFFER_QUEUE:
       stat=ScBSCreateFromBufferQueue(&Info->BSIn, Sah, DataType, Info->Q, 
         (int (*)(ScHandle_t, ScCallbackInfo_t *, void *))Info->CallbackFunction,
         (void *)Buffer_UserData);
       break;

     case SA_USE_FILE:
       stat=ScBSCreateFromFile(&Info->BSIn, Fd, Buffer_UserData, BufSize);
#ifdef MPEG_SUPPORT
       if (stat==NoErrors && Info->Type==SA_MPEG_DECODE)
         ScBSSetFilter(Info->BSIn, MPEGAudioFilter);
#endif /* MPEG_SUPPORT */
       break;

     default:
       stat=SaErrorBadArgument;
  }
  if (stat==NoErrors && Info->BSIn)
    ScBSReset(Info->BSIn);
  return(stat);
}

SaStatus_t SaSetDataDestination (SaHandle_t Sah, int Dest, int Fd,
                            void *Buffer_UserData, int BufSize)
{
  SaCodecInfo_t *Info = (SaCodecInfo_t *)Sah;
  int stat=NoErrors;
  int DataType;

  if (!Info)
    return(SaErrorCodecHandle);

  if (Info->Type==SA_MPEG_ENCODE || Info->Type==SA_GSM_ENCODE 
	  /* || Info->Type==SA_AC3_ENCODE */ ||Info->Type==SA_G723_ENCODE)
    DataType=CB_DATA_COMPRESSED;
  else
    DataType=CB_DATA_AUDIO;

  if (Info->BSOut)
  {
    ScBSDestroy(Info->BSOut);
    Info->BSOut=NULL;
  }

  switch (Dest)
  {
     case SA_USE_SAME:
       break;
     case SA_USE_BUFFER:
       stat=ScBSCreateFromBuffer(&Info->BSOut, Buffer_UserData, BufSize); 
       break;

     case SA_USE_BUFFER_QUEUE:
       stat=ScBSCreateFromBufferQueue(&Info->BSOut, Sah, DataType, Info->Q, 
         (int (*)(ScHandle_t, ScCallbackInfo_t *, void *))Info->CallbackFunction,
         (void *)Buffer_UserData);
       break;

     case SA_USE_FILE:
       stat=ScBSCreateFromFile(&Info->BSOut, Fd, Buffer_UserData, BufSize);
       break;

     default:
       stat=SaErrorBadArgument;
  }
/*
  if (stat==NoErrors && Info->BSOut)
    ScBSReset(Info->BSOut);
*/
  return(stat);
}


/*
** Name: SaGetDataSource
** Purpose: Returns the current input bitstream being used by
**          the Codec.
** Return:  NULL if there no associated bitstream
*/
ScBitstream_t *SaGetDataSource (SaHandle_t Sah)
{
  SaCodecInfo_t *Info = (SaCodecInfo_t *)Sah;

  if (!Info)
    return(NULL);

  return(Info->BSIn);
}

/*
** Name: SaGetDataDestination
** Purpose: Returns the current input bitstream being used by
**          the Codec.
** Return:  NULL if there no associated bitstream
*/
ScBitstream_t *SaGetDataDestination(SaHandle_t Sah)
{
  SaCodecInfo_t *Info = (SaCodecInfo_t *)Sah;

  if (!Info)
    return(NULL);

  return(Info->BSOut);
}

/*
** Name:     SaAddBuffer
** Purpose:  Add a buffer of MPEG bitstream data to the CODEC or add an image
**           buffer to be filled by the CODEC (in streaming mode)
**
** Args:     Sah = handle to software codec's Info structure.
**           BufferInfo = structure describing buffer's address, type & size
*/
SaStatus_t SaAddBuffer (SaHandle_t Sah, SaCallbackInfo_t *BufferInfo)
{
   SaCodecInfo_t *Info = (SaCodecInfo_t *)Sah;

   if (!Info)
     return(SaErrorCodecHandle);

   if (BufferInfo->DataType != CB_DATA_COMPRESSED)
     return(SaErrorBadArgument);

   if (!BufferInfo->Data || (BufferInfo->DataSize <= 0))
     return(SaErrorBadArgument);

   ScBufQueueAdd(Info->Q, BufferInfo->Data, BufferInfo->DataSize);

   return(NoErrors);
}

#ifdef MPEG_SUPPORT
/*
** Name:  sa_GetMpegAudioInfo()
** Purpose: Extract info about audio packets in an MPEG file.
** Notes:   If an "info" structure is passed to this function,
**          the entire file will be read for extended info.
** Return:  Not 0 = error
*/
SaStatus_t sa_GetMpegAudioInfo(int fd, WAVEFORMATEX *wf, SaInfo_t *info)
{
  int stat, sync;
  ScBitstream_t *bs;
  SaFrameParams_t fr_ps;
  SaLayer_t layer;
  unsigned long aframes=0, samples=0;
  /* Default info parameters */
  if (info)
  {
    info->Name[0]=0;
    info->Description[0]=0;
    info->Version=0;
    info->CodecStarted=FALSE;
    info->MS=0;
    info->NumBytesIn=0;
    info->NumBytesOut=0;
    info->NumFrames=0;
    info->TotalFrames=0;
    info->TotalMS=0;
  }

  /* Default wave parameters */
  wf->wFormatTag = WAVE_FORMAT_PCM;
  wf->nChannels = 2;
  wf->nSamplesPerSec = 44100;
  wf->wBitsPerSample = 16; 
  wf->cbSize = 0; 

  stat=ScBSCreateFromFile(&bs, fd, NULL, 1024);
  if (stat!=NoErrors)
  {
    fprintf(stderr, "Error creating bitstream.\n");
    return(-1);
  }
  if (ScBSPeekBits(bs, PACK_START_CODE_LEN)!=PACK_START_CODE_BIN
      && ScBSPeekBits(bs, MPEG_SYNC_WORD_LEN)!=MPEG_SYNC_WORD)
    stat=SaErrorUnrecognizedFormat;
  else
  {
    if (ScBSPeekBits(bs, MPEG_SYNC_WORD_LEN)==MPEG_SYNC_WORD)
      printf("No MPEG packs found in file; assuming Audio stream only.\n");
    else
      ScBSSetFilter(bs, MPEGAudioFilter); /* Use the MPEG audio filter */

    fr_ps.header = &layer;
    fr_ps.tab_num = -1;   /* no table loaded */
    fr_ps.alloc = NULL;

    sync = ScBSSeekAlign(bs, MPEG_SYNC_WORD, MPEG_SYNC_WORD_LEN);
    if (!sync) {
      sc_vprintf(stderr,"sa_GetMpegAudioInfo: Frame cannot be located\n");
      return(SaErrorSyncLost);
    }
    /* Decode the first header to see what kind of audio we have */
    sa_DecodeInfo(bs, &fr_ps);
    sa_hdr_to_frps(&fr_ps);
#ifdef _VERBOSE_
    sa_ShowHeader(&fr_ps);
#endif

    /* Save no. of channels & sample rate return parameters for caller */
    wf->nChannels = fr_ps.stereo;
    wf->nSamplesPerSec = s_freq_int[fr_ps.header->sampling_frequency];
    wf->wBitsPerSample = 16; 
    stat=SaErrorNone;
    if (info) /* Read through all frames if there's a info structure */
    {
      sc_vprintf("Counting frames...\n");
      aframes=0;
      while (!bs->EOI && sync)
      {
        sync = ScBSSeekAlign(bs, MPEG_SYNC_WORD, MPEG_SYNC_WORD_LEN);
        if (sync)
        {
          sc_dprintf("0x%X: Frame found\n", 
                      ScBSBytePosition(bs)-4);
          aframes++;
        }
        sa_DecodeInfo(bs, &fr_ps);
        if (wf->nChannels<2)  /* take the maximum number of channels */
        {
          sa_hdr_to_frps(&fr_ps);
          wf->nChannels = fr_ps.stereo;
        }
        if (layer.lay==1)
          samples+=384;
        else
          samples+=1152;

      }
      info->TotalFrames=aframes;
      info->TotalMS=(samples*1000)/wf->nSamplesPerSec;
      info->NumBytesOut=samples * wf->nChannels * 2;
      sc_vprintf("Total Audio Frames = %u Bytes = %d MS = %d\n", 
                       info->TotalFrames, info->NumBytesOut, info->TotalMS);
    }
  }
  /* Reset the bitstream back to the beginning */
  ScBSReset(bs);
  /* Close the bit stream */
  ScBSDestroy(bs);
  /* Calculate additional parameters */
  wf->nBlockAlign = (wf->wBitsPerSample>>3) * wf->nChannels; 
  wf->nAvgBytesPerSec = wf->nBlockAlign*wf->nSamplesPerSec;
  return(stat);
}
#endif /* MPEG_SUPPORT */

/*
** Name:  sa_ConvertFormat()
** Purpose: Do simple PCM data conversion (i.e. 16 to 8 bit,
**          Stereo to Mono, etc.)
*/
static int sa_ConvertPCMFormat(SaCodecInfo_t *Info, u_char *data, int length)
{
  int skip, rbytes;
  u_char *fromptr, *toptr;
  /* convert 16 bit to 8 bit if necessary */
  if (Info->wfOut->wBitsPerSample == 8)
  {
    if (Info->wfOut->nChannels==1 && Info->wfOut->nChannels==2)
      skip=4;
    else
      skip=2;
    length/=skip;
    toptr = data;
    fromptr = data+1;
    for (rbytes=length; rbytes; rbytes--, toptr++, fromptr+=skip)
      *toptr = *fromptr;
  }
  return(length);
}

SaStatus_t SaSetParamBoolean(SaHandle_t Sah, SaParameter_t param, 
                                             ScBoolean_t value)
{
  SaCodecInfo_t *Info = (SaCodecInfo_t *)Sah;
  if (!Info)
    return(SaErrorCodecHandle);
  _SlibDebug(_VERBOSE_, printf("SaSetParamBoolean()\n") );
  switch (Info->Type)
  {
#ifdef MPEG_SUPPORT
    case SA_MPEG_ENCODE:
           saMpegSetParamBoolean(Sah, param, value);
           break;
#endif

#ifdef G723_SUPPORT
    case SA_G723_ENCODE:
           saG723SetParamBoolean(Sah, param, value);
           break;
#endif
    default:
           return(SaErrorCodecType);
  }
  return(NoErrors);
}

SaStatus_t SaSetParamInt(SaHandle_t Sah, SaParameter_t param, qword value)
{
  SaCodecInfo_t *Info = (SaCodecInfo_t *)Sah;
  if (!Info)
    return(SaErrorCodecHandle);
  _SlibDebug(_VERBOSE_, printf("SaSetParamInt()\n") );
  switch (Info->Type)
  {
#ifdef MPEG_SUPPORT
    case SA_MPEG_DECODE:
    case SA_MPEG_ENCODE:
           saMpegSetParamInt(Sah, param, value);
           break;
#endif

#ifdef AC3_SUPPORT
    case SA_AC3_DECODE:
    /* case SA_AC3_ENCODE: */
           saAC3SetParamInt(Sah, param, value);
           break;
#endif

#ifdef G723_SUPPORT
    case SA_G723_DECODE:
    case SA_G723_ENCODE:
           saG723SetParamInt(Sah, param, value);
           break;
#endif

    default:
           return(SaErrorCodecType);
  }
  return(NoErrors);
}

ScBoolean_t SaGetParamBoolean(SaHandle_t Sah, SaParameter_t param)
{
  SaCodecInfo_t *Info = (SaCodecInfo_t *)Sah;
  if (!Info)
    return(FALSE);
  switch (Info->Type)
  {
#ifdef MPEG_SUPPORT
    case SA_MPEG_DECODE:
    case SA_MPEG_ENCODE:
           return(saMpegGetParamBoolean(Sah, param));
           break;
#endif

#ifdef G723_SUPPORT
    case SA_G723_DECODE:
    case SA_G723_ENCODE:
           return(saG723GetParamBoolean(Sah, param));
           break;
#endif
  }
  return(FALSE);
}

qword SaGetParamInt(SaHandle_t Sah, SaParameter_t param)
{
  SaCodecInfo_t *Info = (SaCodecInfo_t *)Sah;
  if (!Info)
    return(0);
  switch (Info->Type)
  {
#ifdef MPEG_SUPPORT
    case SA_MPEG_DECODE:
    case SA_MPEG_ENCODE:
           return(saMpegGetParamInt(Sah, param));
           break;
#endif

#ifdef G723_SUPPORT
    case SA_G723_DECODE:
    case SA_G723_ENCODE:
           return(saG723GetParamInt(Sah, param));
           break;
#endif
  }
  return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech261\sa_intrn.h ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: sa_internals.h,v $
 * Revision 1.1.6.2  1996/11/08  21:50:56  Hans_Graves
 * 	Added AC3 stuff.
 * 	[1996/11/08  21:18:56  Hans_Graves]
 *
 * Revision 1.1.4.2  1996/03/29  22:21:09  Hans_Graves
 * 	Added MPEG_SUPPORT and GSM_SUPPORT ifdefs
 * 	[1996/03/29  21:47:46  Hans_Graves]
 * 
 * Revision 1.1.2.4  1995/07/21  17:41:04  Hans_Graves
 * 	Renamed Callback related stuff.
 * 	[1995/07/21  17:28:24  Hans_Graves]
 * 
 * Revision 1.1.2.3  1995/06/27  13:54:25  Hans_Graves
 * 	Added SaGSMInfo_t structure.
 * 	[1995/06/27  13:17:39  Hans_Graves]
 * 
 * Revision 1.1.2.2  1995/05/31  18:09:41  Hans_Graves
 * 	Inclusion in new SLIB location.
 * 	[1995/05/31  15:30:39  Hans_Graves]
 * 
 * Revision 1.1.2.3  1995/04/17  18:25:06  Hans_Graves
 * 	Added BSOut to CodecInfo struct for streaming
 * 	[1995/04/17  18:24:31  Hans_Graves]
 * 
 * Revision 1.1.2.2  1995/04/07  19:36:05  Hans_Graves
 * 	Inclusion in SLIB
 * 	[1995/04/07  19:25:01  Hans_Graves]
 * 
 * $EndLog$
 */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

#ifndef _SA_INTERNALS_H_
#define _SA_INTERNALS_H_

#include "SC.h"
#include "SA.h"

#ifdef MPEG_SUPPORT
#include "sa_mpeg.h"
#endif /* MPEG_SUPPORT */

#ifdef GSM_SUPPORT
#include "sa_gsm.h"
#endif /* GSM_SUPPORT */

#ifdef AC3_SUPPORT
#include "sa_ac3.h"
#endif /* AC3_SUPPORT */

#ifdef G723_SUPPORT
#include "sa_g723.h"
#endif /* G723_SUPPORT */

typedef struct SaCodecInfo_s {
  SaCodecType_e           Type;
  ScBoolean_t             started;           /* begin was called? */
  SaInfo_t                Info;

  union {
    void *info;
#ifdef MPEG_SUPPORT
    SaMpegDecompressInfo_t *MDInfo;
    SaMpegCompressInfo_t   *MCInfo;
#endif /* !MPEG_SUPPORT */
#ifdef GSM_SUPPORT
    SaGSMInfo_t            *GSMInfo;
#endif /* !GSM_SUPPORT */
#ifdef AC3_SUPPORT
    SaAC3DecompressInfo_t  *AC3Info;
#endif /* !AC3_SUPPORT */
#ifdef G723_SUPPORT
    SaG723Info_t  *pSaG723Info;
#endif /* !G723_SUPPORT */
  }; /* union */

  ScQueue_t              *Q;
  ScBitstream_t          *BSIn;
  ScBitstream_t          *BSOut;
  WAVEFORMATEX           *wfIn;
  WAVEFORMATEX           *wfOut;
  /*
   ** Callback function to control processing
   */
  int (* CallbackFunction)(SaHandle_t, SaCallbackInfo_t *, SaInfo_t *);
} SaCodecInfo_t; 

#endif _SA_INTERNALS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech261\sa_proto.h ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: sa_prototypes.h,v $
 * Revision 1.1.8.4  1996/11/14  21:49:25  Hans_Graves
 * 	Added sa_AC3SetParamInt() proto.
 * 	[1996/11/14  21:48:29  Hans_Graves]
 *
 * Revision 1.1.8.3  1996/11/08  21:50:58  Hans_Graves
 * 	Added AC3 stuff.
 * 	[1996/11/08  21:18:58  Hans_Graves]
 * 
 * Revision 1.1.8.2  1996/09/18  23:46:14  Hans_Graves
 * 	Changed proto for sa_PsychoAnal()
 * 	[1996/09/18  21:58:47  Hans_Graves]
 * 
 * Revision 1.1.6.4  1996/04/10  21:47:34  Hans_Graves
 * 	Added sa_MpegGet/SetParam functions
 * 	[1996/04/10  21:38:49  Hans_Graves]
 * 
 * Revision 1.1.6.3  1996/04/09  16:04:38  Hans_Graves
 * 	Fix protos for sa_SetMPEGBitrate and sa_SetMPEGParams)
 * 	[1996/04/09  16:02:14  Hans_Graves]
 * 
 * Revision 1.1.6.2  1996/03/29  22:21:11  Hans_Graves
 * 	Added MPEG_SUPPORT and GSM_SUPPORT ifdefs
 * 	[1996/03/29  22:13:39  Hans_Graves]
 * 
 * Revision 1.1.4.3  1996/01/19  15:29:34  Bjorn_Engberg
 * 	Removed compiler wanrnings for NT.
 * 	[1996/01/19  14:57:39  Bjorn_Engberg]
 * 
 * Revision 1.1.4.2  1996/01/15  16:26:24  Hans_Graves
 * 	Added prototype for sa_SetMPEGBitrate()
 * 	[1996/01/15  15:43:13  Hans_Graves]
 * 
 * Revision 1.1.2.3  1995/06/27  13:54:26  Hans_Graves
 * 	Added prototypes for GSM.
 * 	[1995/06/27  13:24:34  Hans_Graves]
 * 
 * Revision 1.1.2.2  1995/05/31  18:09:45  Hans_Graves
 * 	Inclusion in new SLIB location.
 * 	[1995/05/31  15:34:15  Hans_Graves]
 * 
 * Revision 1.1.2.3  1995/04/17  18:38:58  Hans_Graves
 * 	Added MPEG Encoding prototypes
 * 	[1995/04/17  18:32:28  Hans_Graves]
 * 
 * Revision 1.1.2.2  1995/04/07  19:36:59  Hans_Graves
 * 	Inclusion in SLIB
 * 	[1995/04/07  19:31:43  Hans_Graves]
 * 
 * $EndLog$
 */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

/*--------------------------------------------------------------------------
 * SLIB Internals Prototype file (externals are in SA.h)
 *
 * Modification History: sa_prototypes.h
 *
 *      29-Jul-94  PSG  Created
 *---------------------------------------------------------------------------*/

#ifndef _SA_PROTOTYPES_H
#define _SA_PROTOTYPES_H

#ifdef MPEG_SUPPORT
#include "sa_mpeg.h"
#endif /* MPEG_SUPPORT */
#ifdef GSM_SUPPORT
#include "sa_gsm.h"
#endif /* GSM_SUPPORT */
#ifdef AC3_SUPPORT
#include "sa_ac3.h"
#endif /* GSM_SUPPORT */
#include "sa_intrn.h"

/*---------------------------------------------------------------------------*/
/*                     Compress/Decompress Codec Prototypes                  */
/*---------------------------------------------------------------------------*/

#ifdef MPEG_SUPPORT
/*
 *  sa_mpeg_common.c
 */
extern SaStatus_t saMpegSetParamInt(SaHandle_t Sah, SaParameter_t param,
                                qword value);
extern SaStatus_t saMpegSetParamBoolean(SaHandle_t Sah, SaParameter_t param,
                                  ScBoolean_t value);
extern qword saMpegGetParamInt(SaHandle_t Sah, SaParameter_t param);
extern ScBoolean_t saMpegGetParamBoolean(SaHandle_t Svh, SaParameter_t param);

extern int sa_PickTable(SaFrameParams_t *fr_ps);
extern void sa_ShowHeader(SaFrameParams_t *fr_ps);
extern void sa_ShowBitAlloc(unsigned int bit_alloc[2][SBLIMIT],
                            SaFrameParams_t *f_p);
extern void sa_ShowScale(unsigned int bit_alloc[2][SBLIMIT],
                  unsigned int scfsi[2][SBLIMIT],
                  unsigned int scalar[2][3][SBLIMIT],
                  SaFrameParams_t *fr_ps);
extern void sa_ShowSamples(int ch, unsigned int FAR sample[SBLIMIT],
                    unsigned int bit_alloc[SBLIMIT], SaFrameParams_t *fr_ps);
extern int sa_BitrateIndex(int layr, int bRate);
extern int sa_SmpFrqIndex(long sRate);
extern void sa_CRCupdate(unsigned int data, unsigned int length, unsigned int *crc);
extern void sa_CRCcalcI(SaFrameParams_t *fr_ps, unsigned int bit_alloc[2][SBLIMIT],
                                        unsigned int *crc);
extern void sa_CRCcalcII(SaFrameParams_t *fr_ps, unsigned int bit_alloc[2][SBLIMIT],
                             unsigned int scfsi[2][SBLIMIT], unsigned int *crc);
extern SaStatus_t sa_hdr_to_frps(SaFrameParams_t *fr_ps);


/*
 *   sa_mpeg_decode.c
 */
extern SaStatus_t sa_DecompressMPEG(SaCodecInfo_t *Info,
                              unsigned char *buffer, unsigned int size,
                              unsigned int *ret_length);
extern SaStatus_t sa_DecodeInfo(ScBitstream_t *bs, SaFrameParams_t *fr_ps);
extern SaStatus_t sa_InitMpegDecoder(SaCodecInfo_t *Info);
extern SaStatus_t sa_EndMpegDecoder(SaCodecInfo_t *Info);

/*
 *   sa_mpeg_encode.c
 */
extern SaStatus_t sa_MpegVerifyEncoderSettings(SaHandle_t Sah);
extern SaStatus_t sa_CompressMPEG(SaCodecInfo_t *Info,
                           unsigned char *dcmp_buf, unsigned int *dcmp_len,
                           unsigned int *comp_len);
extern SaStatus_t sa_InitMpegEncoder(SaCodecInfo_t *Info);
extern SaStatus_t sa_EndMpegEncoder(SaCodecInfo_t *Info);
extern unsigned int sa_GetMPEGSampleSize(SaCodecInfo_t *Info);

/*
** sa_mpeg_tonal.c
*/
extern void sa_II_Psycho_One(float buffer[2][1152], float scale[2][SBLIMIT],
                      float ltmin[2][SBLIMIT], SaFrameParams_t *fr_ps);
extern void sa_I_Psycho_One(float buffer[2][1152], float scale[2][SBLIMIT],
                      float ltmin[2][SBLIMIT], SaFrameParams_t *fr_ps);
/*
** sa_mpeg_psy.c
*/
extern void sa_PsychoAnal(SaMpegCompressInfo_t *MCInfo, float *buffer,
                          float savebuf[1056],int chn,int lay,
                          float snr32[32],float sfreq,int num_pass);
#endif /* MPEG_SUPPORT */

#ifdef GSM_SUPPORT
/*
** sa_gsm_common.c
*/
SaStatus_t sa_InitGSM(SaGSMInfo_t *info);

extern word  gsm_mult(word a, word b);
extern dword gsm_L_mult(word a, word b);
extern word  gsm_mult_r(word a, word b);
extern word  gsm_div(word num, word denum);
extern word  gsm_add( word a, word b );
extern dword gsm_L_add(dword a, dword b );
extern word  gsm_sub(word a, word b);
extern dword gsm_L_sub(dword a, dword b);
extern word  gsm_abs(word a);
extern word  gsm_norm(dword a);
extern dword gsm_L_asl(dword a, int n);
extern word  gsm_asl(word a, int n);
extern dword gsm_L_asr(dword a, int n);
extern word  gsm_asr(word a, int n);

/*
** sa_gsm_encode.c
*/
extern SaStatus_t sa_GSMEncode(SaGSMInfo_t *s, word *dcmp_buf, 
                               unsigned int *dcmp_len,
                               unsigned char *comp_buf,
                               ScBitstream_t *bsout);
extern void Gsm_Long_Term_Predictor(SaGSMInfo_t *S, word *d, word *dp, word *e, word *dpp,
                                    word *Nc, word *bc);
extern void Gsm_Encoding(SaGSMInfo_t *S, word *e, word *ep, word *xmaxc, 
                          word *Mc, word *xMc);
extern void Gsm_Short_Term_Analysis_Filter(SaGSMInfo_t *S,word *LARc,word *d);
/*
** sa_gsm_decode.c
*/
extern int sa_GSMDecode(SaGSMInfo_t *s, unsigned char *comp_buf, word *dcmp_buf);
extern void Gsm_Decoding(SaGSMInfo_t *S, word xmaxcr, word Mcr, word *xMcr, word *erp);
extern void Gsm_Long_Term_Synthesis_Filtering(SaGSMInfo_t *S, word Ncr, word bcr,
                                               word *erp, word *drp);
void Gsm_RPE_Decoding(SaGSMInfo_t *S, word xmaxcr, word Mcr, word * xMcr, word * erp);
void Gsm_RPE_Encoding(SaGSMInfo_t *S, word *e, word *xmaxc, word *Mc, word *xMc);
/*
** sa_gsm_filter.c
*/
extern void Gsm_Short_Term_Synthesis_Filter(SaGSMInfo_t *S, word *LARcr, 
                                            word *drp, word *s);
extern void Gsm_Update_of_reconstructed_short_time_residual_signal(word *dpp,
                                                              word *ep, word *dp);
/*
** sa_gsm_table.c
*/
extern word gsm_A[8], gsm_B[8], gsm_MIC[8], gsm_MAC[8];
extern word gsm_INVA[8];
extern word gsm_DLB[4], gsm_QLB[4];
extern word gsm_H[11];
extern word gsm_NRFAC[8];
extern word gsm_FAC[8];
#endif /* GSM_SUPPORT */

#ifdef AC3_SUPPORT

/* AC-3 specific stuff goes here */
/*
 *   sa_ac3_decode.c
 */
extern SaStatus_t sa_DecompressAC3(SaCodecInfo_t *Info,
                              unsigned char **buffer, unsigned int size,
                              unsigned int *ret_length);
extern SaStatus_t sa_InitAC3Decoder(SaCodecInfo_t *Info);
extern SaStatus_t sa_EndAC3Decoder(SaCodecInfo_t *Info);
extern SaStatus_t saAC3SetParamInt(SaHandle_t Sah, SaParameter_t param,
                                qword value);


#endif /* AC3_SUPPORT */

#ifdef G723_SUPPORT
/* G723 encoder functions. 
   sa_g723_coder.c
*/
typedef  short int   Flag  ;
extern void saG723CompressInit(SaG723Info_t *psaG723Info);

//DataBuff :Input frame (480 bytes)
//Vout     :Encoded frame (20 bytes :5.3K bits/s
//                        (24 bytes :6.3K bits/s)
extern SaStatus_t  saG723Compress( SaCodecInfo_t *Info,word *DataBuff, char *Vout );

extern void saG723CompressFree(SaG723Info_t *psaG723Info);

/* G723 decoder functions. 
   sa_g723_decod.c
*/
extern void saG723DecompressInit(SaG723Info_t *psaG723Info);

//DataBuff :Empty Buffer to hold decoded frame(480 bytes)
//Vinp     :Encoded frame (20 bytes :5.3K bits/s
//                        (24 bytes :6.3K bits/s)
//Crc      : Transmission Error code (Cyclic Redundant code)
extern SaStatus_t  saG723Decompress( SaCodecInfo_t *Info,word *DataBuff, 
               char *Vinp, word Crc );

extern void saG723DecompressFree(SaG723Info_t *psaG723Info);

extern SaStatus_t saG723SetParamInt(SaHandle_t Sah, SaParameter_t param,
                                qword value);

extern SaStatus_t saG723SetParamBoolean(SaHandle_t Sah, SaParameter_t param,
                                  ScBoolean_t value);

extern qword saG723GetParamInt(SaHandle_t Sah, SaParameter_t param);

extern ScBoolean_t saG723GetParamBoolean(SaHandle_t Svh, SaParameter_t param);

#endif /* G723_SUPPORT */

#endif _SA_PROTOTYPES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech261\sc.h ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: SC.h,v $
 * Revision 1.1.8.10  1996/12/03  23:15:11  Hans_Graves
 * 	Added ScBSBufferedBytes() macros.
 * 	[1996/12/03  23:11:06  Hans_Graves]
 *
 * Revision 1.1.8.9  1996/11/13  16:10:47  Hans_Graves
 * 	Addition of ScBitstreamSave_t.
 * 	[1996/11/13  15:58:26  Hans_Graves]
 * 
 * Revision 1.1.8.8  1996/11/08  21:50:36  Hans_Graves
 * 	Protos fixed for use with C++. Added bitstream protos for AC3.
 * 	[1996/11/08  21:17:23  Hans_Graves]
 * 
 * Revision 1.1.8.7  1996/10/28  17:32:20  Hans_Graves
 * 	MME-01402. Added TimeStamp support to Callbacks.
 * 	[1996/10/28  16:56:21  Hans_Graves]
 * 
 * Revision 1.1.8.6  1996/10/12  17:18:11  Hans_Graves
 * 	Added ScImageSize().
 * 	[1996/10/12  16:53:38  Hans_Graves]
 * 
 * Revision 1.1.8.5  1996/09/18  23:45:46  Hans_Graves
 * 	Added ScFileClose() proto; ISIZE() macro
 * 	[1996/09/18  23:37:33  Hans_Graves]
 * 
 * Revision 1.1.8.4  1996/08/20  22:11:48  Bjorn_Engberg
 * 	For NT - Made several routines public to support JV3.DLL and SOFTJPEG.DLL.
 * 	[1996/08/20  21:53:23  Bjorn_Engberg]
 * 
 * Revision 1.1.8.3  1996/05/24  22:21:27  Hans_Graves
 * 	Added ScPatScaleIDCT8x8i_S proto
 * 	[1996/05/24  21:56:31  Hans_Graves]
 * 
 * Revision 1.1.8.2  1996/05/07  19:55:49  Hans_Graves
 * 	Added BI_DECHUFFDIB
 * 	[1996/05/07  17:24:17  Hans_Graves]
 * 
 * Revision 1.1.6.9  1996/04/17  16:38:36  Hans_Graves
 * 	Change NT bitstream buffer sizes from 32 to 64-bit
 * 	[1996/04/17  16:37:04  Hans_Graves]
 * 
 * Revision 1.1.6.8  1996/04/15  21:08:39  Hans_Graves
 * 	Define ScBitBuff_t and ScBitString_t as dword or qword
 * 	[1996/04/15  21:05:46  Hans_Graves]
 * 
 * Revision 1.1.6.7  1996/04/10  21:47:16  Hans_Graves
 * 	Added definition for EXTERN
 * 	[1996/04/10  21:23:23  Hans_Graves]
 * 
 * Revision 1.1.6.6  1996/04/09  16:04:32  Hans_Graves
 * 	Added USE_C ifdef.
 * 	[1996/04/09  14:48:04  Hans_Graves]
 * 
 * Revision 1.1.6.5  1996/04/01  16:23:09  Hans_Graves
 * 	NT porting
 * 	[1996/04/01  16:15:48  Hans_Graves]
 * 
 * Revision 1.1.6.4  1996/03/20  22:32:46  Hans_Graves
 * 	{** Merge Information **}
 * 		{** Command used:	bsubmit **}
 * 		{** Ancestor revision:	1.1.6.2 **}
 * 		{** Merge revision:	1.1.6.3 **}
 * 	{** End **}
 * 	Added protos for IDCT1x1,1x2,2x1,2x2,3x3,4x4,6x6
 * 	[1996/03/20  22:25:47  Hans_Graves]
 * 
 * Revision 1.1.6.3  1996/03/16  19:22:51  Karen_Dintino
 * 	added NT port changes
 * 	[1996/03/16  19:20:07  Karen_Dintino]
 * 
 * Revision 1.1.6.2  1996/03/08  18:46:27  Hans_Graves
 * 	Added proto for ScScaleIDCT8x8m_S()
 * 	[1996/03/08  18:41:45  Hans_Graves]
 * 
 * Revision 1.1.4.14  1996/02/07  23:23:50  Hans_Graves
 * 	Added prototype for ScFileSeek()
 * 	[1996/02/07  23:18:32  Hans_Graves]
 * 
 * Revision 1.1.4.13  1996/02/01  17:15:50  Hans_Graves
 * 	Added ScBSSkipBitsFast() and ScBSPeekBitsFast() macros
 * 	[1996/02/01  17:14:17  Hans_Graves]
 * 
 * Revision 1.1.4.12  1996/01/24  19:33:18  Hans_Graves
 * 	Added prototype for ScScaleIDCT8x8i_S
 * 	[1996/01/24  18:13:51  Hans_Graves]
 * 
 * Revision 1.1.4.11  1996/01/08  20:15:13  Bjorn_Engberg
 * 	Added one more cast to avoid warnings.
 * 	[1996/01/08  20:14:55  Bjorn_Engberg]
 * 
 * Revision 1.1.4.10  1996/01/08  16:41:21  Hans_Graves
 * 	Added protos for more IDCT routines.
 * 	[1996/01/08  15:44:17  Hans_Graves]
 * 
 * Revision 1.1.4.9  1996/01/02  18:31:13  Bjorn_Engberg
 * 	Added casts to avoid warning messages when compiling.
 * 	[1996/01/02  15:02:16  Bjorn_Engberg]
 * 
 * Revision 1.1.4.8  1995/12/07  19:31:18  Hans_Graves
 * 	Added protos for ScFDCT8x8s_C() and ScIDCT8x8s_C(), Added ScBSAlignPutBits() macro.
 * 	[1995/12/07  17:58:36  Hans_Graves]
 * 
 * Revision 1.1.4.7  1995/11/16  12:33:34  Bjorn_Engberg
 * 	Add BI_BITFIELDS to IsRGBPacked macro
 * 	[1995/11/16  12:33:17  Bjorn_Engberg]
 * 
 * Revision 1.1.4.6  1995/10/13  21:01:42  Hans_Graves
 * 	Added macros for format classes.
 * 	[1995/10/13  20:59:15  Hans_Graves]
 * 
 * Revision 1.1.4.5  1995/09/22  19:41:00  Hans_Graves
 * 	Moved ValidBI_BITFIELDSKinds to SC_convert.h
 * 	[1995/09/22  19:40:42  Hans_Graves]
 * 
 * Revision 1.1.4.4  1995/09/20  18:27:59  Hans_Graves
 * 	Added Bjorn's NT defs
 * 	[1995/09/15  13:21:00  Hans_Graves]
 * 
 * Revision 1.1.4.3  1995/09/14  12:35:22  Hans_Graves
 * 	Added ScCopyClipToPacked422() prototypes.
 * 	[1995/09/14  12:34:58  Hans_Graves]
 * 
 * Revision 1.1.4.2  1995/09/13  14:51:45  Hans_Graves
 * 	Added ScScaleIDCT8x8(). Added buffer Type to queues.
 * 	[1995/09/13  14:29:10  Hans_Graves]
 * 
 * Revision 1.1.2.18  1995/09/11  19:17:23  Hans_Graves
 * 	Moved ValidateBI_BITFIELDS() prototype to SC_convert.h - Removed mmsystem.h include.
 * 	[1995/09/11  19:14:27  Hans_Graves]
 * 
 * Revision 1.1.2.17  1995/09/11  18:51:25  Farokh_Morshed
 * 	Support BI_BITFIELDS format
 * 	[1995/09/11  18:50:48  Farokh_Morshed]
 * 
 * Revision 1.1.2.16  1995/08/31  14:15:43  Farokh_Morshed
 * 	transfer BI_BITFIELDS stuff to SV.h
 * 	[1995/08/31  14:15:20  Farokh_Morshed]
 * 
 * Revision 1.1.2.15  1995/08/31  13:51:53  Farokh_Morshed
 * 	{** Merge Information **}
 * 		{** Command used:	bsubmit **}
 * 		{** Ancestor revision:	1.1.2.13 **}
 * 		{** Merge revision:	1.1.2.14 **}
 * 	{** End **}
 * 	Add BI_BITFIELDS support
 * 	[1995/08/31  13:50:46  Farokh_Morshed]
 * 
 * Revision 1.1.2.14  1995/08/29  22:17:05  Hans_Graves
 * 	Fixed-up Bitstream prototypes. Added BI_ image formats and defined BI_DECSEPYUV411DIB == BI_YU12SEP
 * 	[1995/08/29  22:15:27  Hans_Graves]
 * 
 * Revision 1.1.2.13  1995/08/14  19:40:26  Hans_Graves
 * 	Added Flush, ScCopySubClip_S() and ScCopyRev_S() prototypes.
 * 	[1995/08/14  18:43:11  Hans_Graves]
 * 
 * Revision 1.1.2.12  1995/07/21  17:41:01  Hans_Graves
 * 	Mirrored Callbacks with MME structure/naming.
 * 	[1995/07/21  17:30:04  Hans_Graves]
 * 
 * Revision 1.1.2.11  1995/07/17  22:01:31  Hans_Graves
 * 	Added BufSize and BufType to ScCallback_t.
 * 	[1995/07/17  21:42:45  Hans_Graves]
 * 
 * Revision 1.1.2.10  1995/07/12  19:48:23  Hans_Graves
 * 	Added H261_FILE type.
 * 	[1995/07/12  19:33:18  Hans_Graves]
 * 
 * Revision 1.1.2.9  1995/07/11  15:24:30  Hans_Graves
 * 	Fixed ScCopySubClip and ScCopyRev macros.
 * 	[1995/07/11  15:24:09  Hans_Graves]
 * 
 * Revision 1.1.2.8  1995/07/11  14:50:44  Hans_Graves
 * 	Added prototypes for sc_mc2.s and sc_copy2.s
 * 	[1995/07/11  14:23:18  Hans_Graves]
 * 
 * Revision 1.1.2.7  1995/06/27  13:54:21  Hans_Graves
 * 	Added STREAM_USE_NET and prototype for ScBSCreateFromNet()
 * 	[1995/06/26  21:00:17  Hans_Graves]
 * 
 * Revision 1.1.2.6  1995/06/22  21:35:03  Hans_Graves
 * 	Moved filetypes from SV.h to here
 * 	[1995/06/22  21:29:11  Hans_Graves]
 * 
 * Revision 1.1.2.5  1995/06/21  18:37:58  Hans_Graves
 * 	Added prototype for ScBSPutBytes()
 * 	[1995/06/21  18:36:43  Hans_Graves]
 * 
 * Revision 1.1.2.4  1995/06/15  21:17:59  Hans_Graves
 * 	Added prototypes for sc_copy.c
 * 	[1995/06/15  20:41:40  Hans_Graves]
 * 
 * Revision 1.1.2.3  1995/06/01  19:35:36  Hans_Graves
 * 	Added prototype for ScCopyClip()
 * 	[1995/06/01  19:31:28  Hans_Graves]
 * 
 * Revision 1.1.2.2  1995/05/31  18:09:20  Hans_Graves
 * 	Inclusion in new SLIB location.
 * 	[1995/05/31  15:17:35  Hans_Graves]
 * 
 * Revision 1.1.2.2  1995/05/03  19:26:38  Hans_Graves
 * 	Included in SLIB (Oct 95)
 * 	[1995/05/03  19:26:26  Hans_Graves]
 * 
 * Revision 1.1.2.3  1995/04/17  18:04:26  Hans_Graves
 * 	Added math prototypes and defs. Expanding Bitstream defs.
 * 	[1995/04/17  18:02:16  Hans_Graves]
 * 
 * Revision 1.1.2.2  1995/04/07  19:18:43  Hans_Graves
 * 	Inclusion in SLIB
 * 	[1995/04/07  19:04:13  Hans_Graves]
 * 
 * $EndLog$
 */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/


#ifndef _SC_H_
#define _SC_H_

#define SLIB_VERSION 0x300

/************************* Debug Handling ***********************/
#ifdef _VERBOSE_
#define sc_vprintf printf
#else
#define sc_vprintf
#endif

#ifdef _DEBUG_
#define sc_dprintf printf
#else
#define sc_dprintf
#endif

#ifdef _TEST_
#define sc_tprintf(test, msg)  if (test) printf(msg)
#else
#define sc_tprintf
#endif

#ifdef _SLIBDEBUG_
#define _SlibDebug(test, statements) { if (test) { statements; } }
#else
#define _SlibDebug(test, statements)
#endif

#ifndef EXTERN
#ifdef __cplusplus
#if !defined(WIN32) || defined(STATIC_BUILD)
#define EXTERN extern "C"
#else
#define EXTERN __declspec( dllexport ) extern "C"
#endif
#else
#if !defined(WIN32) || defined(STATIC_BUILD)
#define EXTERN extern
#else
#define EXTERN __declspec( dllexport ) extern
#endif
#endif /* __cplusplus */
#endif /* EXTERN */

#ifndef PRIVATE_EXTERN
#ifdef __cplusplus
#define PRIVATE_EXTERN extern "C"
#else /* __cplusplus */
#define PRIVATE_EXTERN extern
#endif /* __cplusplus */
#endif /* PRIVATE_EXTERN */

#ifdef WIN32
/*
 * These b* routines are mem* routines on NT.
 */
#define bcopy(_src_,_dst_,_len_) memcpy(_dst_,_src_,_len_)
#define bzero(_dst_,_len_)	 memset(_dst_,0,_len_)
#define bcmp(_src_,_dst_,_len_)  memcmp(_src_,_dst_,_len_)
/*
 * These cma routines are doing nothing for NT.
 * Avoid lots of ifdefs on the code by defining
 * null macros for them. 
 */
#define cma_mutex_lock(foo)
#define cma_mutex_unlock(foo)
#endif /* WIN32 */

/************************* Elementary Types ***********************/
#ifndef UNALIGNED
#if defined(WIN95) || defined(INTEL)
#define UNALIGNED
#else
#define UNALIGNED __unaligned
#endif
#endif

#ifndef u_char
#if defined( __VMS ) || defined( WIN32 )
typedef unsigned char  u_char;			/*  8 bits */
typedef unsigned short u_short;			/* 16 bits */
typedef unsigned int   u_int;			/* 32 bits */
typedef unsigned long  u_long;			/* 32 bits */
#else
typedef unsigned char  u_char;			/*  8 bits */
typedef unsigned short u_short;			/* 16 bits */
typedef unsigned int   u_int;			/* 32 bits */
typedef unsigned long  u_long;			/* 64 bits */
#endif
#endif /* u_char */

#ifndef WIN32
#ifndef byte   /* 8 bit */
#define byte   char
#endif
#endif /* !WIN32 */

#ifndef word   /* 16 bit */
#define word   short
#endif /* word */

#ifndef dword  /* 32 bit */
#define dword  int
#endif /* dword */

#ifndef qword  /* 64 bit */
#if defined(__VMS) || defined(WIN32)
#define qword  _int64
#else
#define qword  long
#endif
#endif /* qword */

#define MIN_WORD     ((-32767)-1)
#define MAX_WORD     ( 32767)
#define MIN_DWORD    ((-2147483647)-1)
#define MAX_DWORD    ( 2147483647)

/************************** Definitions ****************************/
#define RETURN_ON_ERROR(A)      {if (A) return (A);}

#ifndef NULL
#define NULL   0L
#endif

#ifndef TRUE
#define TRUE  1 
#define FALSE 0
#endif

#ifndef WIN32
#ifndef FAR
#define FAR
#endif
#endif

#ifndef PI
#define PI      3.14159265358979
#define PI4     PI/4
#define PI64    PI/64
#endif

/*
** public parameter settings
*/
/* Algorithm Flags - video */
#define PARAM_ALGFLAG_HALFPEL  0x0001  /* Half pixel accuracy */
#define PARAM_ALGFLAG_SKIPPEL  0x0002  /* Skip-pixel error calculation */
#define PARAM_ALGFLAG_PB       0x0004  /* PB frame encoding */
#define PARAM_ALGFLAG_SAC      0x0008  /* Syntax Arithmetic Coding */
#define PARAM_ALGFLAG_UMV      0x0010  /* Unrestricted Motion Vectors */
#define PARAM_ALGFLAG_ADVANCED 0x0020  /* Advanced Prediction Mode */
/* Algorithm Flags - audio */
#define PARAM_ALGFLAG_VAD      0x1000  /* Voice Activity Detection (G.723) */
/* Format Extensions */
#define PARAM_FORMATEXT_RTPA   0x0001  /* RTP Mode A */
#define PARAM_FORMATEXT_RTPB   0x0002  /* RTP Mode B */
#define PARAM_FORMATEXT_RTPC   0x0004  /* RTP Mode C */

/* Frame types */
#define FRAME_TYPE_NONE        0x0000
#define FRAME_TYPE_I           0x0001  /* Key frame */
#define FRAME_TYPE_P           0x0002  /* Partial frame */
#define FRAME_TYPE_B           0x0004  /* Bi-directional frame */
#define FRAME_TYPE_D           0x0008  /* Preview frame */

/************************** Formats (FOURCC's) ***************************/
/*
** Image formats
*/
#define BI_MSH261DIB            mmioFOURCC('M','2','6','1')
#define BI_MSH263DIB            mmioFOURCC('M','2','6','3')
#define BI_DECH261DIB           mmioFOURCC('D','2','6','1')
#define BI_DECH263DIB           mmioFOURCC('D','2','6','3')
#define BI_DECJPEGDIB           mmioFOURCC('J','P','E','G')
#define BI_DECMJPGDIB           mmioFOURCC('M','J','P','G')
#define BI_DECYUVDIB            mmioFOURCC('D','Y','U','V')
#define BI_DECXIMAGEDIB         mmioFOURCC('D','X','I','M')	
#define BI_DECSEPYUVDIB         mmioFOURCC('D','S','Y','U')
#define BI_DECMPEGDIB           mmioFOURCC('D','M','P','G')
#define BI_DECHUFFDIB           mmioFOURCC('D','H','U','F')
#define BI_DECSEPRGBDIB         mmioFOURCC('D','S','R','G')
#define BI_DECGRAYDIB           mmioFOURCC('D','G','R','Y')
#define BI_YVU9SEP              mmioFOURCC('Y','V','U','9')
#define BI_YU12SEP              mmioFOURCC('Y','U','1','2')
#define BI_YU16SEP              mmioFOURCC('Y','U','1','6')
#define BI_DECSEPYUV411DIB      mmioFOURCC('Y','U','1','2')
#define BI_S422                 mmioFOURCC('S','4','2','2')
#define BI_YUY2                 mmioFOURCC('Y','U','Y','2')

/*
 * FYI - Other image formats that are defined elsewhere:
 */
#if 0
#define BI_RGB              0
#define BI_BITFIELDS        3
#define BICOMP_JFIF         mmioFOURCC('J','F','I','F')
#endif

/*
 * Macros to identify classes of image formats.
 */
#define IsJPEG(s)         (((s) == JPEG_DIB)            || \
                           ((s) == MJPG_DIB))
#define IsYUV422Packed(s) (((s) == BI_DECYUVDIB)        || \
                           ((s) == BI_S422)             || \
                           ((s) == BI_YUY2))
#define IsYUV422Sep(s)    (((s) == BI_DECSEPYUVDIB)     || \
                           ((s) == BI_YU16SEP))
#define IsYUV411Sep(s)    (((s) == BI_DECSEPYUV411DIB)  || \
                           ((s) == BI_YU12SEP))
#define IsYUV1611Sep(s)   (((s) == BI_YVU9SEP))
#define IsYUVSep(s)       ((IsYUV422Sep(s))             || \
                           (IsYUV411Sep(s))             || \
                           (IsYUV1611Sep(s)))
#define IsYUV(s)          ((IsYUV422Packed(s))          || \
                           (IsYUVSep(s)))

#define IsRGBPacked(s)    (((s) == BI_RGB)              || \
                           ((s) == BI_DECXIMAGEDIB)     || \
                           ((s) == BI_BITFIELDS))
#define IsRGBSep(s)       (((s) == BI_DECSEPRGBDIB))
#define IsRGB(s)          ((IsRGBPacked(s))             || \
                           (IsRGBSep(s)))

#define IsGray(s)         (((s) == BI_DECGRAYDIB))

#define ISIZE(w,h,c) \
        (IsYUV411Sep(c)) ? ((w) * (h) * 3 / 2) : \
                ((IsYUV1611Sep(c)) ? \
                        ((w) * (h) * 9 / 8) : \
                                ((IsYUV422Sep(c) || IsYUV422Packed(c)) ? \
                                        ((w) * (h) * 2) : ((w) * (h) * 3)));

/*
** File Types (returned from ScGetFileType)
*/
#define UNKNOWN_FILE        0
#define AVI_FILE            201
#define MPEG_VIDEO_FILE     202
#define MPEG_AUDIO_FILE     203
#define MPEG_SYSTEM_FILE    204
#define JFIF_FILE           205
#define QUICKTIME_JPEG_FILE 206
#define GSM_FILE            207
#define WAVE_FILE           208
#define PCM_FILE            209
#define H261_FILE           210
#define AC3_FILE            211

/*
** Callback messages
*/
#define CB_RELEASE_BUFFER       1   /* buffer finished */
#define CB_END_BUFFERS          2   /* no more buffers */
#define CB_RESET_BUFFERS        3   /* reset to beginning */
#define CB_SEQ_HEADER           4   /* sequence header */
#define CB_SEQ_END              5   /* sequence end */
#define CB_FRAME_FOUND          6   /* frame found */
#define CB_FRAME_READY          7   /* frame completed */
#define CB_FRAME_START          8   /* frame starting to be processed */
#define CB_PROCESSING           9   /* processing data */
#define CB_CODEC_DONE          10   /* codec done ended */

/*
** Data types for callback message
*/
#define CB_DATA_NONE            0x0000 /* no data */
#define CB_DATA_COMPRESSED      0x0001 /* data is compressed */
#define CB_DATA_IMAGE           0x0002 /* data is decompressed image */
#define CB_DATA_AUDIO           0x0004 /* data is decompressed audio */
/*
** Frame flags for callback message
*/
#define CB_FLAG_TYPE_KEY        0x0001 /* key frame */
#define CB_FLAG_TYPE_MPEGB      0x0002 /* MPEG B-Frame */
#define CB_FLAG_FRAME_DROPPED   0x0008 /* frame dropped */
#define CB_FLAG_FRAME_BAD       0x0010 /* could not de/compress */
/*
** Action values in response to callback message
*/
#define CB_ACTION_WAIT          0x0000 /* wait - callback still busy */
#define CB_ACTION_CONTINUE      0x0001 /* accept a frame */
#define CB_ACTION_DROP          0x0002 /* drop a frame */
#define CB_ACTION_DUPLICATE     0x0004 /* duplicate a frame */
#define CB_ACTION_END           0x0080 /* end de/compression */

/* These are old definitions
#define CLIENT_CONTINUE        CB_ACTION_CONTINUE
#define CLIENT_ABORT           CB_ACTION_END
#define CLIENT_PROCESS         CB_ACTION_CONTINUE
#define CLIENT_DROP            CB_ACTION_DROP
#define CB_IMAGE_BUFFER_READY  CB_FRAME_READY
#define CB_PICTURE_FOUND       CB_FRAME_FOUND
#define CB_PICTURE_PROCEESSED  CB_FRAME_READY
#define CB_FRAME               CB_FRAME_FOUND
*/


/*
 * Stream sources/destinations
 */
#define STREAM_USE_SAME     -1
#define STREAM_USE_NULL     0
#define STREAM_USE_QUEUE    1
#define STREAM_USE_FILE     2
#define STREAM_USE_BUFFER   3
#define STREAM_USE_DEVICE   4
#define STREAM_USE_STDOUT   5
#define STREAM_USE_NET      6
#define STREAM_USE_NET_TCP  6  /* reliable transport */
#define STREAM_USE_NET_UDP  7  /* unreliable transport */

/************************** Type Definitions *******************************/
typedef int           ScStatus_t;
typedef void         *ScHandle_t;
typedef unsigned char ScBoolean_t;
#if !defined( _VMS ) && !defined( WIN32 )
typedef long          _int64;
#endif

/*
** Bitstream stuff
*/
#if defined( _VMS ) || defined( WIN95 )
#define SC_BITBUFFSZ    32
typedef unsigned dword ScBitBuff_t;
typedef unsigned dword ScBitString_t;
#else
#define SC_BITBUFFSZ    64
typedef unsigned qword ScBitBuff_t;
typedef unsigned qword ScBitString_t;
#endif
#define SC_BITBUFFMASK  (ScBitBuff_t)-1
#define ALIGNING        8
#define ScBSPreLoad(bs, bits) if ((int)bs->shift<(bits)) sc_BSLoadDataWord(bs);
#define ScBSPreLoadW(bs, bits) if ((int)bs->shift<(bits)) sc_BSLoadDataWordW(bs);
#define ScBSByteAlign(bs) { \
      int len=bs->shift%8; \
      if (len) { \
        bs->OutBuff=(bs->OutBuff<<len)|(bs->InBuff>>(SC_BITBUFFSZ-len)); \
        bs->InBuff<<=len; bs->CurrentBit+=len; bs->shift-=len; } \
        }
#define ScBSAlignPutBits(bs) if (bs->shift%8) \
                               ScBSPutBits(bs, 0, 8-(bs->shift%8));
#define ScBSBitPosition(bs)  (bs->CurrentBit)
#define ScBSBytePosition(bs) (bs->CurrentBit>>3)
#define ScBSBufferedBytes(bs) (bs->bufftop)
#define ScBSBufferedBytesUsed(bs) (bs->buffp)
#define ScBSBufferedBytesUnused(bs) (bs->bufftop-bs->buffp)
#define ScBSSkipBit(bs)      ScBSSkipBits(bs, 1)
#define ScBSSkipBitsFast(bs, len) { if ((u_int)(len)<=bs->shift) { \
     if ((len)==SC_BITBUFFSZ) \
       { bs->OutBuff=bs->InBuff; bs->InBuff=0; } \
     else { \
       bs->OutBuff=(bs->OutBuff<<(len))|(bs->InBuff>>(SC_BITBUFFSZ-(len))); \
       bs->InBuff<<=(len); } \
       bs->CurrentBit+=len; bs->shift-=len; \
     } else ScBSSkipBits(bs, len); }
#define ScBSSkipBitFast(bs) ScBSSkipBitsFast(bs, 1)
#define ScBSPeekBitsFast(bs, len) (!(len) ? 0 \
     : (((len)<=bs->shift || !sc_BSLoadDataWord(bs)) && (len)==SC_BITBUFFSZ \
            ? bs->OutBuff : (bs->OutBuff >> (SC_BITBUFFSZ-len))) )
#define ScBSPeekBitsFull(bs, result) \
        { ScBSPreLoad(bs, SC_BITBUFFSZ); result = bs->OutBuff; }

/*
** Sort stuff
*/
typedef struct ScSortDouble_s {
  int    index;   /* index to actual data */
  double num;     /* the number to sort by */
} ScSortDouble_t;

typedef struct ScSortFloat_s {
  int    index;   /* index to actual data */
  double num;     /* the number to sort by */
} ScSortFloat_t;

/*
** ScBuf_s structure used in Buffer/Image Queue management.
** Contains info for one buffer.
*/
struct ScBuf_s {
  u_char *Data;                 /* Pointer to buffer's data            */
  int    Size;                  /* Length of buffer in bytes           */
  int    Type;                  /* Type of buffer                      */
  struct ScBuf_s *Prev;         /* Pointer to previous buffer in queue */
};

/*
** Buffer queue structure. One for each queue.
*/
typedef struct ScQueue_s {
  int NumBufs;                  /* Number of buffers currently in queue */
  struct ScBuf_s *head, *tail;  /* pointers to head & tail of queue     */
} ScQueue_t;

/*
** ScCallbackInfo_t passes info back & forth during callback
*/
typedef struct ScCallbackInfo_s {
  int     Message;    /* Callback reason: CB_FRAME_READY, etc. */
  int     DataType;   /* Buffer data type */
  u_char *Data;       /* Pointer to data buffer. */
  dword   DataSize;   /* Length of data buffer */
  dword   DataUsed;   /* Actual bytes used in buffer */
  void   *UserData;   /* User defined data */
  qword   TimeStamp;  /* Timestamp of decompressed img/audio */
                      /* relative to start of sequence */
  dword   Flags;      /* decomp/compression details */
  int     Action;     /* drop frame or continue */
  dword   Value;      /* a value for special flags/actions */
  void   *Format;     /* BITMAPINFOHEADER or WAVEFORMATEX */
} ScCallbackInfo_t;

typedef qword ScBSPosition_t;
/*
** State info for the input bitstream
*/
typedef struct ScBitstream_s {
  dword DataSource;             /* STREAM_USE_BUFFER, _USE_QUEUE,_USE_FILE,   */
                                /* or _USE_DEVICE                             */
  char Mode;                    /* 'r'=read, 'w'=write, 'b'=both              */
  ScQueue_t *Q;                 /* Buffer Queue (STREAM_USE_QUEUE)            */
  int (*Callback)(ScHandle_t,   /* Callback to supply Bufs (STREAM_USE_QUEUE) */
             ScCallbackInfo_t *, void *);
  int (*FilterCallback)(struct  /* Callback to filter data from bitstream     */
               ScBitstream_s *);
  unsigned qword FilterBit;     /* Bit to call filter callback at             */
  unsigned char  InFilterCallback; /* TRUE when FilterCallback is busy           */
  ScHandle_t     Sch;           /* Handle passed to Callback                  */
  dword          DataType;      /* Data type passed to Callback               */
  void          *UserData;      /* User Data passed to Callback               */
  int            FileFd;        /* File descriptor (STREAM_USE_FILE/NET)      */
  unsigned char *RdBuf;         /* Buf to use if (_USE_BUFFER,_USE_FILE)      */
  unsigned dword RdBufSize;     /* Size of RdBuf                              */
  char           RdBufAllocated;/* = TRUE if RdBuf was internally allocated   */
  dword          Device;        /* Device to use (STREAM_USE_DEVICE)          */
  ScBitBuff_t    InBuff, OutBuff; /* 64-bit or 32-bit data buffers            */
  unsigned int   shift;         /* Shift value for current bit position       */
  ScBSPosition_t CurrentBit;    /* Current bit position in bitstream          */
  unsigned char *buff;          /* pointer to bitstream data buffer           */
  unsigned dword buffstart;     /* byte offset of start of buff               */
  unsigned dword buffp;         /* byte offset in buffer                      */
  unsigned dword bufftop;       /* number of bytes in buffer                  */
  ScBoolean_t    EOI;           /* = TRUE when no more data in data source    */
  ScBoolean_t    Flush;         /* = TRUE to signal a flush at next 32/64 bit */
} ScBitstream_t;

/*
** Bitstream context block to save current position of input stream
*/
typedef struct ScBitstreamSave_s {
  ScBitBuff_t    InBuff, OutBuff;  /* 64-bit or 32-bit data buffers              */
  unsigned dword shift;            /* Shift value for current bit position       */
  ScBSPosition_t CurrentBit;       /* Current bit position in bitstream          */
  unsigned char *buff;             /* pointer to bitstream data buffer           */
  unsigned dword buffp;            /* byte offset in buffer                      */
  ScBoolean_t    EOI;              /* = TRUE when no more data in data source    */
  ScBoolean_t    Flush;            /* = TRUE to signal a flush at next 32/64 bit */
} ScBitstreamSave_t;


/************************** Prototypes *****************************/
/*
 * sc_file.c
 */
PRIVATE_EXTERN ScBoolean_t ScFileExists(char *filename);
PRIVATE_EXTERN int         ScFileOpenForReading(char *filename);
PRIVATE_EXTERN int         ScFileOpenForWriting(char *filename, ScBoolean_t truncate);
PRIVATE_EXTERN ScStatus_t  ScFileSize(char *filename, unsigned qword *size);
PRIVATE_EXTERN dword       ScFileRead(int fd, void *buffer, unsigned dword bytes);
PRIVATE_EXTERN dword       ScFileWrite(int fd, void *buffer, unsigned dword bytes);
PRIVATE_EXTERN ScStatus_t  ScFileSeek(int fd, qword bytepos);
PRIVATE_EXTERN void        ScFileClose(int fd);
PRIVATE_EXTERN ScStatus_t  ScFileMap(char *filename, int *fd, u_char **buffer,
                                         unsigned qword *size);
PRIVATE_EXTERN ScStatus_t  ScFileUnMap(int fd, u_char *buffer, unsigned int size);
PRIVATE_EXTERN int         ScGetFileType(char *filename);

/*
 * sc_mem.c
 */
PRIVATE_EXTERN void     *ScAlloc(unsigned long bytes);
PRIVATE_EXTERN void     *ScAlloc2(unsigned long bytes, char *name);
PRIVATE_EXTERN void     *ScCalloc(unsigned long bytes);
PRIVATE_EXTERN void      ScFree(void *);
PRIVATE_EXTERN int       ScMemCheck(char *array,int test,int num);
EXTERN char     *ScPaMalloc(int);
EXTERN void      ScPaFree(void *);
EXTERN int       getpagesize();

/*
 * sc_util.c
 */
extern int       sc_Dummy();
PRIVATE_EXTERN unsigned int ScImageSize(unsigned int fourcc, int w, int h, int bits);
extern void      ScReadCommandSwitches(char *argv[],int argc,
                                 void (*error_routine)(),char *,...);
extern void      ScShowBuffer(unsigned char *, int);
extern void      ScShowBufferFloat(float *, int);
extern void      ScShowBufferInt(int *, int);
extern int       ScDumpChar(unsigned char *ptr, int nbytes, int startpos);



/*
 * sc_errors.c
 */
PRIVATE_EXTERN ScStatus_t ScGetErrorText (int errno, char *ReturnMsg, u_int MaxChars);
PRIVATE_EXTERN char *ScGetErrorStr(int errno);
extern char _serr_msg[80];

/*
 * sc_buf.c
 */
PRIVATE_EXTERN ScStatus_t ScBSSetFilter(ScBitstream_t *BS,
                    int (*Callback)(ScBitstream_t *BS));
PRIVATE_EXTERN ScStatus_t ScBSCreate(ScBitstream_t **BS);
PRIVATE_EXTERN ScStatus_t ScBSCreateFromBuffer(ScBitstream_t **BS,
                                    u_char *Buffer, unsigned int BufSize);
PRIVATE_EXTERN ScStatus_t ScBSCreateFromBufferQueue(ScBitstream_t **BS,
                                ScHandle_t Sch, int DataType, ScQueue_t *Q,
                         int (*Callback)(ScHandle_t,ScCallbackInfo_t *,void *),
                         void *UserData);
PRIVATE_EXTERN ScStatus_t ScBSCreateFromFile(ScBitstream_t **BS,int FileFd,
                                u_char *Buffer, int BufSize);
PRIVATE_EXTERN ScStatus_t ScBSCreateFromNet(ScBitstream_t **BS, int SocketFd, 
                                u_char *Buffer, int BufSize);
PRIVATE_EXTERN ScStatus_t ScBSCreateFromDevice(ScBitstream_t **BS, int device);
PRIVATE_EXTERN ScStatus_t ScBSDestroy(ScBitstream_t *BS);
PRIVATE_EXTERN ScStatus_t ScBSFlush(ScBitstream_t *BS);
PRIVATE_EXTERN ScStatus_t ScBSFlushSoon(ScBitstream_t *BS);
PRIVATE_EXTERN ScStatus_t ScBSReset(ScBitstream_t *BS);
PRIVATE_EXTERN ScStatus_t ScBSResetCounters(ScBitstream_t *BS);

PRIVATE_EXTERN ScStatus_t ScBSSkipBits(ScBitstream_t *BS, u_int length);
PRIVATE_EXTERN ScStatus_t ScBSSkipBitsW(ScBitstream_t *BS, u_int length);
PRIVATE_EXTERN ScStatus_t ScBSSkipBytes(ScBitstream_t *BS, u_int length);
PRIVATE_EXTERN int        ScBSPeekBit(ScBitstream_t *BS);
PRIVATE_EXTERN ScBitString_t ScBSPeekBits(ScBitstream_t *BS, u_int length);
PRIVATE_EXTERN ScBitString_t ScBSPeekBytes(ScBitstream_t *BS, u_int length);

PRIVATE_EXTERN int ScBSGetBytes(ScBitstream_t *BS, u_char *buffer, u_int length,
                                                 u_int *ret_length);
PRIVATE_EXTERN int ScBSGetBytesStopBefore(ScBitstream_t *BS, u_char *buffer, 
                              u_int length, u_int *ret_length,
                              ScBitString_t seek_word, int word_len);
PRIVATE_EXTERN ScBitString_t ScBSGetBits(ScBitstream_t *BS, u_int length);
PRIVATE_EXTERN ScBitString_t ScBSGetBitsW(ScBitstream_t *BS, u_int length);
PRIVATE_EXTERN int        ScBSGetBitsVarLen(ScBitstream_t *BS, const int *table, 
                                                     int len);
PRIVATE_EXTERN ScStatus_t ScBSPutBytes(ScBitstream_t *BS, u_char *buffer,
                                                 u_int length);
PRIVATE_EXTERN ScStatus_t ScBSPutBits(ScBitstream_t *BS, ScBitString_t bits, 
                                                 u_int length);
PRIVATE_EXTERN ScStatus_t ScBSPutBit(ScBitstream_t *BS, char bit);
PRIVATE_EXTERN int        ScBSGetBit(ScBitstream_t *BS);

PRIVATE_EXTERN ScStatus_t ScBSSeekToPosition(ScBitstream_t *BS, unsigned long pos);
PRIVATE_EXTERN int        ScBSSeekStopBefore(ScBitstream_t *BS, ScBitString_t seek_word, int word_len);
PRIVATE_EXTERN int        ScBSSeekAlign(ScBitstream_t *BS, ScBitString_t seek_word,int word_len);
PRIVATE_EXTERN int        ScBSSeekAlignStopBefore(ScBitstream_t *BS,ScBitString_t seek_word,int word_len);
PRIVATE_EXTERN int        ScBSSeekAlignStopBeforeW(ScBitstream_t *BS,ScBitString_t seek_word,int word_len);
PRIVATE_EXTERN int        ScBSSeekAlignStopAt(ScBitstream_t *BS,
                                      ScBitString_t seek_word,
                                      int word_len, unsigned long end_byte_pos);
extern ScStatus_t sc_BSLoadDataWord(ScBitstream_t *BS);
extern ScStatus_t sc_BSStoreDataWord(ScBitstream_t *BS, ScBitBuff_t Buff);

PRIVATE_EXTERN ScStatus_t ScBufQueueCreate(ScQueue_t **Q);
PRIVATE_EXTERN ScStatus_t ScBufQueueDestroy(ScQueue_t *Q);
PRIVATE_EXTERN ScStatus_t ScBufQueueAdd(ScQueue_t *Q, u_char *Data, int Size);
PRIVATE_EXTERN ScStatus_t ScBufQueueAddExt(ScQueue_t *Q, u_char *Data, int Size,
                                   int Type);
PRIVATE_EXTERN ScStatus_t ScBufQueueRemove(ScQueue_t *Q);
PRIVATE_EXTERN int        ScBufQueueGetNum(ScQueue_t *Q);
PRIVATE_EXTERN ScStatus_t ScBufQueueGetHead(ScQueue_t *Q, u_char **Data,
                                                          int *Size);
PRIVATE_EXTERN ScStatus_t ScBufQueueGetHeadExt(ScQueue_t *Q, u_char **Data,
                                               int *Size, int *Type);


/*
** sc_math.c
*/
/* #define ScAbs(val) (val > 0.0) ? val : -val */
extern float ScAbs(float val);
extern double ScSqr(double x);
extern double ScDistance(double x1, double y1, double z1,
                         double x2, double y2, double z2);
extern void  ScDigrv4(float *real, float *imag, int n);
extern float ScArcTan(float Q,float I);

/*
** sc_dct.c
*/
extern void ScFDCT(float in_block[32], float out_block1[32],
                   float out_block2[32]);
extern void ScIFDCT(float in_block[32], float out_block[32]);
extern void ScFDCT8x8_C(float *ipbuf, float *outbuf);
extern void ScFDCT8x8s_C(short *inbuf, short *outbuf);

/*
** sc_dct2.c
*/
extern void ScFDCT8x8_S(float *ipbuf, float *outbuf);

/*
** sc_idct.c
*/
extern void ScIDCT8x8(int *outbuf);
extern void ScScaleIDCT8x8_C(float *ipbuf, int *outbuf);
extern void ScIDCT8x8s_C(short *inbuf, short *outbuf);

/*
** sc_idct_scaled.c
*/
extern void ScScaleIDCT8x8i_C(int *inbuf, int *outbuf);
extern void ScScaleIDCT8x8i128_C(int *inbuf, int *outbuf);
extern void ScScaleIDCT1x1i_C(int *inbuf, int *outbuf);
extern void ScScaleIDCT1x2i_C(int *inbuf, int *outbuf);
extern void ScScaleIDCT2x1i_C(int *inbuf, int *outbuf);
extern void ScScaleIDCT2x2i_C(int *inbuf, int *outbuf);
extern void ScScaleIDCT3x3i_C(int *inbuf, int *outbuf);
extern void ScScaleIDCT4x4i_C(int *inbuf, int *outbuf);
extern void ScScaleIDCT6x6i_C(int *inbuf, int *outbuf);

/*
** sc_idct2.s
*/
extern void ScIDCT8x8s_S(short *inbuf, short *outbuf);
extern void ScScaleIDCT8x8i_S(int *inbuf, int *outbuf);

/*
** sc_idct3.s
*/
extern void ScScaleIDCT8x8m_S(int *inbuf);

/*
** sc_idctp2.s
*/
extern void ScPatScaleIDCT8x8i_S(int *inbuf, int *outbuf);

/*
** sc_fft.c
*/
extern void  ScFFTtrl(float *real,float *imag,int n,int max_fft,float *c1,
                      float *s1,float *c2,float *s2,float *c3,float *s3);
extern void  ScFFTtl(float *real, float *imag, int n, int max_fft, float *c1,
                     float *s1, float *c2, float *s2, float *c3, float *s3);
extern void  ScFFTt4l(float *real, float *imag, int n, int *angle_increment,
                      int max_fft, float *c1, float *s1, float *c2, float *s2,
                      float *c3, float *s3);

/*
** sc_sort.c
*/
extern void ScSortDoubles(ScSortDouble_t *a, int n);

/*
** sc_copy.c
*/
extern void ScCopyClip_C(int *buf, unsigned int *pos, int inc);
extern void ScCopyClipToPacked422_C(int *buf, unsigned char *pos, int inc);
extern void ScCopyAddClip_C(unsigned char *mvbuf, int *idctbuf,
                unsigned int *pbuf, int mvinc, int pwidth);
extern void ScCopySubClip_C(unsigned char *mvbuf, float *idctbuf, 
                unsigned int *pbuf, int mvinc, int pwidth);
extern void ScCopyRev_C(unsigned int *yptr, float *Idctptr, int Inc);
extern void ScCopyMV8_C(unsigned char *mvbuf, unsigned int *pbuf,
                        int mvinc, int pwidth);
extern void ScLoopFilter_C(unsigned char *input, unsigned int *work, int inc);
extern void ScCopyBlock_C(unsigned char *linmemu, unsigned char *linmemv,
                 int xpos, unsigned char *blkmemu,
                 unsigned char *blkmemv, int cwidth, int wsis);
extern void ScCopyMB_C(unsigned char *ysrc, int xpos, unsigned char *ymb,
                  int ywidth, int yywidth);
extern void ScCopyMB8_C(unsigned char *ysrc, unsigned char *ymb,
                         int ywidth, int yywidth);
extern void ScCopyMB16_C(unsigned char *ysrc, unsigned char *ymb,
                         int ywidth, int yywidth);

/*
** sc_copy2.s
*/
extern void ScCopyClip_S(int *buf, unsigned int *pos, int inc);
extern void ScCopyClipToPacked422_S(int *buf, unsigned char *pos, int inc);
extern void ScCopyAddClip_S(unsigned char *mvbuf, int *idctbuf,
                unsigned int *pbuf, int mvinc, int pwidth);
extern void ScCopySubClip_S(unsigned char *mvbuf, float *idctbuf, 
                unsigned int *pbuf, int mvinc, int pinc);
extern void ScCopyRev_S(unsigned int *yptr, float *Idctptr, int yinc);
extern void ScLoopFilter_S(unsigned char *input, unsigned int *work, int inc);
extern void ScCopyMV8_S(unsigned char *mvbuf, unsigned int *pbuf,
                         int mvinc, int pwidth);
extern void ScCopyMV16_S(unsigned char *mvbuf, unsigned int *pbuf,
                         int mvinc, int pwidth);
extern void ScCopyMB8_S(unsigned char *ysrc, unsigned char *ymb,
                         int ywidth, int yywidth);
extern void ScCopyMB16_S(unsigned char *ysrc, unsigned char *ymb,
                         int ywidth, int yywidth);
extern void ScAvgMV_S(unsigned char *, unsigned char *);


/*
** sc_mc2.s
*/
extern void ScMCy8(unsigned char *, unsigned char *, int);
extern void ScMCy16(unsigned char *, unsigned char *, int);
extern void ScMCx8(unsigned char *, unsigned char *, int);
extern void ScMCx16(unsigned char *, unsigned char *, int);
extern void ScMCxy8(unsigned char *, unsigned char *, int);
extern void ScMCxy16(unsigned char *, unsigned char *, int);

/*
**  macros for using C or assembly versions
*/
#ifdef USE_C
#define ScCopyClip             ScCopyClip_C
#define ScCopyClipToPacked422  ScCopyClipToPacked422_C
#define ScCopyAddClip          ScCopyAddClip_C
#define ScCopySubClip          ScCopySubClip_C
#define ScCopyRev              ScCopyRev_C
#define ScLoopFilter           ScLoopFilter_C
#define ScCopyMV8              ScCopyMV8_C
#define ScCopyMV16             ScCopyMV16_C
#define ScCopyMB8              ScCopyMB8_C
#define ScCopyMB16             ScCopyMB16_C
#define ScAvgMV                ScAvgMV_C
#define ScScaleIDCT8x8         ScScaleIDCT8x8_C
#define ScScaleIDCT8x8i        ScScaleIDCT8x8i_C
#define ScScaleIDCT8x8i128     ScScaleIDCT8x8i128_C
#define ScPatScaleIDCT8x8i     ScScaleIDCT8x8i_C
#define ScFDCT8x8              ScFDCT8x8_C
#define ScFDCT8x8s             ScFDCT8x8s_C
#define ScIDCT8x8s             ScIDCT8x8s_C
#define ScIDCT8x8sAndCopy      ScIDCT8x8sAndCopy_C
#else /* USE_C */
#define ScCopyClip             ScCopyClip_S
#define ScCopyClipToPacked422  ScCopyClipToPacked422_S
#define ScCopyAddClip          ScCopyAddClip_S
#define ScCopySubClip          ScCopySubClip_S
#define ScCopyRev              ScCopyRev_S
#define ScLoopFilter           ScLoopFilter_S
#define ScCopyMV8              ScCopyMV8_S
#define ScCopyMV16             ScCopyMV16_S
#define ScCopyMB8              ScCopyMB8_S
#define ScCopyMB16             ScCopyMB16_S
#define ScAvgMV                ScAvgMV_S
#define ScScaleIDCT8x8         ScScaleIDCT8x8_C
#define ScScaleIDCT8x8i        ScScaleIDCT8x8i_C
#define ScScaleIDCT8x8i128     ScScaleIDCT8x8i128_C
#define ScPatScaleIDCT8x8i     ScPatScaleIDCT8x8i_S
#define ScFDCT8x8              ScFDCT8x8_S
#define ScFDCT8x8s             ScFDCT8x8s_C
#define ScIDCT8x8s             ScIDCT8x8s_S
#define ScIDCT8x8sAndCopy      ScIDCT8x8sAndCopy_S
#endif /* USE_C */

#endif /* _SC_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech261\scon_vid.c ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: scon_video.h,v $
 * $EndLog$
 */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1997                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/
/*
 * SLIB Conversion API - Video
 */

/*
#define _SLIBDEBUG_
*/

#include "scon_int.h"
#include "SC_err.h"
#include "SC_conv.h"

#ifdef WIN32
#include <mmsystem.h>
#endif

#ifdef _SLIBDEBUG_
#include "sc_debug.h"

#define _DEBUG_     1  /* detailed debuging statements */
#define _VERBOSE_   1  /* show progress */
#define _VERIFY_    1  /* verify correct operation */
#define _WARN_      1  /* warnings about strange behavior */
#endif

unsigned dword sconCalcImageSize(SconVideoInfo_t *vinfo)
{
  vinfo->Pixels=vinfo->Width*vinfo->Height;
  switch (vinfo->FourCC)
  {
      case BI_YVU9SEP:       /* YUV 16:1:1 Planar */
          vinfo->ImageSize = (vinfo->Pixels*5)/4;
          break;
      case BI_YU12SEP:       /* YUV 4:1:1 Planar */
          vinfo->ImageSize = (vinfo->Pixels*3)/2;
          break;
      case BI_DECYUVDIB:     /* YUV 4:2:2 Packed */
      case BI_YUY2:          /* YUV 4:2:2 Packed */
      case BI_YU16SEP:       /* YUV 4:2:2 Planar */
          vinfo->ImageSize = vinfo->Pixels*2;
          break;
#ifndef WIN32
      case BI_DECXIMAGEDIB:
          vinfo->ImageSize = vinfo->Pixels*(vinfo->BPP==24 ? 4 : 1);
          break;
#endif /* !WIN32 */
      case BI_RGB:
      case BI_BITFIELDS:
          vinfo->ImageSize = vinfo->Pixels*((vinfo->BPP+7)/8);
          break;
      default:
          vinfo->ImageSize = vinfo->Pixels;
  }
  return(vinfo->ImageSize);
}

static void sconScaleFrame(unsigned word bytesperpixel,
                           void *inbuf, int inw, int inh,
                           void *outbuf, int outw, int outh, int stride)
{
  int inx, outx, iny=0, outy=0;
  int deltax, deltay;
  _SlibDebug(_VERBOSE_,
         ScDebugPrintf(NULL, "sconScaleFrame(byteperpixel=%d) %dx%d -> %dx%d\n",
                      bytesperpixel, inw, inh, outw, outh) );
  if (inh<0)  inh=-inh;   /* no flipping supported */
  if (outh<0) outh=-outh; /* no flipping supported */
  if (bytesperpixel==4)
  {
    unsigned dword *inscan, *outscan;
    deltay=0;
    while (iny<inh)
    {
      inscan=(unsigned dword *)inbuf;
      while (deltay<outh)
      {
        outscan=(unsigned dword *)outbuf;
        inx=0; outx=0;
        deltax=0;
        while (inx<inw)
        {
          while (deltax<outw)
          {
            outscan[outx]=inscan[inx];
            deltax+=inw;
            outx++;
          }
          inx++;
          deltax-=outw;
        }
        outy++;
        deltay+=inh;
        (unsigned char *)outbuf+=stride;
      }
      iny++;
      deltay-=outh;
      ((unsigned dword *)inbuf)+=inw;
    }
  }
  else if (bytesperpixel==3)
  {
    unsigned char *inscan, *outscan;
    deltay=0;
    inw*=3;
    outw*=3;
    while (iny<inh)
    {
      inscan=(unsigned char *)inbuf;
      _SlibDebug(_DEBUG_>1,
          ScDebugPrintf(NULL, "deltay=%d iny=%d outy=%d inh=%d outh=%d\n",
                 deltay, iny, outy, inh, outh) );
      while (deltay<outh)
      {
        outscan=(unsigned char *)outbuf;
        inx=0; outx=0;
        deltax=0;
        while (inx<inw)
        {
          while (deltax<outw)
          {
            outscan[outx]=inscan[inx];
            outscan[outx+1]=inscan[inx+1];
            outscan[outx+2]=inscan[inx+2];
            deltax+=inw;
            outx+=3;
          }
          inx+=3;
          deltax-=outw;
        }
        outy++;
        deltay+=inh;
        (unsigned char *)outbuf+=stride;
      }
      iny++;
      deltay-=outh;
      ((unsigned char *)inbuf)+=inw;
    }
  }
  else if (bytesperpixel==2)
  {
    unsigned word *inscan, *outscan;
    deltay=0;
    while (iny<inh)
    {
      inscan=(unsigned word *)inbuf;
      while (deltay<outh)
      {
        outscan=(unsigned word *)outbuf;
        inx=0; outx=0;
        deltax=0;
        while (inx<inw)
        {
          while (deltax<outw)
          {
            outscan[outx]=inscan[inx];
            deltax+=inw;
            outx++;
          }
          inx++;
          deltax-=outw;
        }
        outy++;
        deltay+=inh;
        (unsigned char *)outbuf+=stride;
      }
      iny++;
      deltay-=outh;
      ((unsigned word *)inbuf)+=inw;
    }
  }
  else /* bytesperpixel==1 */
  {
    unsigned char *inscan, *outscan;
    deltay=0;
    while (iny<inh)
    {
      inscan=(unsigned char *)inbuf;
      _SlibDebug(_DEBUG_>1,
          ScDebugPrintf(NULL, "deltay=%d iny=%d outy=%d inh=%d outh=%d\n",
                 deltay, iny, outy, inh, outh) );
      while (deltay<outh)
      {
        outscan=(unsigned char *)outbuf;
        inx=0; outx=0;
        deltax=0;
        while (inx<inw)
        {
          while (deltax<outw)
          {
            outscan[outx]=inscan[inx];
            deltax+=inw;
            outx++;
          }
          inx++;
          deltax-=outw;
        }
        outy++;
        deltay+=inh;
        (unsigned char *)outbuf+=stride;
      }
      iny++;
      deltay-=outh;
      ((unsigned char *)inbuf)+=inw;
    }
  }
}


SconStatus_t sconConvertVideo(SconInfo_t *Info, void *inbuf, dword inbufsize,
                                                void *outbuf, dword outbufsize)
{
  unsigned dword informat, outformat;
  unsigned char *prescalebuf=inbuf;
  dword inwidth, inheight, outwidth, outheight, inbpp, outbpp, stride;
  SconStatus_t retval=SconErrorNone;
  SconBoolean_t scale, flip, sameformat;
  _SlibDebug(_VERBOSE_, printf("sconConvertVideo()\n") );
  if (inbuf==NULL || outbuf==NULL)
    return(SconErrorBadArgument);
  inwidth=Info->Input.vinfo.Width;
  inheight=Info->Input.vinfo.Height;
  informat=Info->Input.vinfo.FourCC;
  inbpp=Info->Input.vinfo.BPP;
  outwidth=Info->Output.vinfo.Width,
  outheight=Info->Output.vinfo.Height;
  outformat=Info->Output.vinfo.FourCC;
  outbpp=Info->Output.vinfo.BPP;
  scale=(Info->ScaleUp || Info->ScaleDown)?TRUE:FALSE;
  flip=Info->Flip;
  sameformat=Info->SameFormat;
  _SlibDebug(_VERBOSE_, ScDebugPrintf(NULL, "SconConvert() %dx%d(%c%c%c%c)->%dx%d(%c%c%c%c)\n",
            inwidth, inheight, informat&0xFF, (informat>>8)&0xFF, (informat>>16)&0xFF, (informat>>24)&0xFF,
            outwidth, outheight, outformat&0xFF, (outformat>>8)&0xFF, (outformat>>16)&0xFF, (outformat>>24)&0xFF) );
  _SlibDebug(_DEBUG_, ScDebugPrintf(NULL, "SconConvert() scale=%d flip=%d sameformat=%d\n",
                            scale, flip, sameformat) );
  if (scale || flip)
  {
    if (Info->SImage==NULL && !sameformat)
    {
      SconVideoInfo_t int_vinfo;
      memcpy(&int_vinfo, &Info->Output.vinfo, sizeof(SconVideoInfo_t));
      int_vinfo.Width=inwidth;
      int_vinfo.Height=inheight;
      Info->SImageSize=sconCalcImageSize(&int_vinfo);
      if ((Info->SImage=ScPaMalloc(Info->SImageSize))==NULL)
        return(SconErrorMemory);
    }
  }
  else if (sameformat)
  {
    memcpy(outbuf, inbuf, Info->Input.vinfo.ImageSize);
    return(SconErrorNone);
  }
  if (sameformat)
    prescalebuf=(unsigned char *)inbuf;
  else
  {
    prescalebuf=(unsigned char *)(scale?Info->SImage:outbuf);
    stride=scale?(inwidth*((outbpp+7)>>3)):Info->Output.vinfo.Stride;
    if (flip) stride=-stride;
    if (IsYUV411Sep(informat)) /* YUV 4:1:1 Planar */
    {
      switch (outformat)
      {
        case BI_DECYUVDIB: /* YUV 4:2:2 Packed */
        case BI_YUY2:      /* YUV 4:2:2 Packed */
          _SlibDebug(_VERBOSE_,
               ScDebugPrintf(NULL, "SconConvert() BI_YU12SEP->BI_YUY2\n") );
          ScSepYUVto422i((unsigned char *)inbuf,
                     (unsigned char *)inbuf+(inwidth*inheight),
                     (unsigned char *)inbuf+(inwidth*inheight*5)/4,
                     (unsigned char *)prescalebuf, inwidth, inheight);
          break;
        case BI_YU16SEP: /* YUV 4:2:2 Planar */
        case BI_DECSEPYUVDIB:
          _SlibDebug(_VERBOSE_,
               ScDebugPrintf(NULL, "SconConvert() BI_YU12SEP->BI_YU16SEP\n") );
          {
            register int i;
            unsigned char *Ue=(unsigned char *)prescalebuf+inwidth*inheight,
                          *Uo=Ue+inwidth/2;
            memcpy(prescalebuf, inbuf, inwidth*inheight);
            ((unsigned char *)inbuf)+=inwidth*inheight;
            for (i=inheight; i; i--)
            {
              memcpy(Ue, inbuf, inwidth/2);
              memcpy(Uo, inbuf, inwidth/2);
              ((unsigned char *)inbuf)+=inwidth/2;
              Ue+=inwidth;
              Uo+=inwidth;
            }
          }
          break;
        case BI_YVU9SEP: /* YUV 16:1:1 Planar */
          _SlibDebug(_VERBOSE_,
              ScDebugPrintf(NULL, "SconConvert() BI_YU12SEP->BI_YVU9\n") );
          ScConvert411sTo1611s((unsigned char *)inbuf,
                           (unsigned char *)prescalebuf,
                           ((unsigned char *)prescalebuf)+(outwidth*outheight),
                           ((unsigned char *)prescalebuf)+(outwidth*outheight*9)/8,
                           inwidth, flip?-inheight:inheight);
          break;
        case BI_RGB:
        case BI_BITFIELDS:
        case BI_DECXIMAGEDIB:
          if (outbpp==16)
          {
            if (Info->Table==NULL)
              sconInitYUVtoRGB(Info);
            if (Info->Output.vinfo.RGBmasks==565)
              scon420ToRGB565((unsigned char *)inbuf,
                              (unsigned char *)prescalebuf,
                              inwidth, inheight, stride, Info->Table);
          }
          else if (outbpp=24)
          {
            if (Info->Table==NULL)
              sconInitYUVtoRGB(Info);
            scon420ToRGB888((unsigned char *)inbuf,
                            (unsigned char *)prescalebuf,
                            inwidth, inheight, stride, Info->Table);
          }
          else
          {
            BITMAPINFOHEADER outbmh;
            outbmh.biWidth=inwidth;
            outbmh.biHeight=inheight;
            outbmh.biCompression=outformat;
            outbmh.biBitCount=(WORD)outbpp;
            stride=scale?inwidth:outwidth;
            _SlibDebug(_VERBOSE_,
               ScDebugPrintf(NULL, "SconConvert() BI_YU12SEP->RGB\n") );
            ScYuv411ToRgb(&outbmh, (unsigned char *)inbuf,
                     (unsigned char *)inbuf+(inwidth*inheight),
                     (unsigned char *)inbuf+(inwidth*inheight*5)/4,
                     (unsigned char *)prescalebuf,
                     inwidth, inheight, stride);
          }
          break;
        default:
          _SlibDebug(_VERBOSE_,
                ScDebugPrintf(NULL, "SconConvert() BI_YU12SEP->Unsupported\n") );
      }
    }
    else if (IsYUV422Sep(informat)) /* YUV 4:2:2 Planar */
    {
      switch (outformat)
      {
        case BI_YU12SEP: /* YUV 4:1:1 Planar */
          _SlibDebug(_VERBOSE_,
               ScDebugPrintf(NULL, "SconConvert() 422 Planar->BI_YU12SEP\n") );
          ScConvert422PlanarTo411_C((unsigned char *)inbuf,
                           (unsigned char *)prescalebuf,
                           ((unsigned char *)prescalebuf)+(outwidth*outheight),
                           ((unsigned char *)prescalebuf)+(outwidth*outheight*5)/4,
                           inwidth, inheight);
          break;
        case BI_DECYUVDIB: /* YUV 4:2:2 Packed */
        case BI_YUY2:
          ScConvert422PlanarTo422i_C((unsigned char *)inbuf,
                           ((unsigned char *)inbuf)+(inwidth*inheight),
                           ((unsigned char *)inbuf)+(inwidth*inheight*3)/2,
                           (unsigned char *)prescalebuf,
                           inwidth, inheight);
          break;
        case BI_RGB:
        case BI_BITFIELDS:
        case BI_DECXIMAGEDIB:
          _SlibDebug(_VERBOSE_,
                ScDebugPrintf(NULL, "SconConvert() BI_YU16SEP->BI_RGB Unsupported\n") );
          if (outbpp==16)
          {
            if (Info->Table==NULL)
              sconInitYUVtoRGB(Info);
            if (Info->Output.vinfo.RGBmasks==565)
              scon422ToRGB565((unsigned char *)inbuf,
                            (unsigned char *)prescalebuf,
                            inwidth, inheight, stride, Info->Table);
          }
          else if (outbpp==24)
          {
            if (Info->Table==NULL)
              sconInitYUVtoRGB(Info);
            scon422ToRGB888((unsigned char *)inbuf,
                            (unsigned char *)prescalebuf,
                            inwidth, inheight, stride, Info->Table);
          }
          else
            retval=SconErrorUnsupportedFormat;
          break;
        default:
          retval=SconErrorUnsupportedFormat;
          _SlibDebug(_VERBOSE_,
                ScDebugPrintf(NULL, "SconConvert() BI_YU16SEP->Unsupported\n") );
      }
    }
    else if (IsYUV422Packed(informat)) /* YUV 4:2:2 Packed */
    {
      switch (outformat)
      {
        case BI_YU12SEP: /* YUV 4:1:1 Planar */
          _SlibDebug(_VERBOSE_,
               ScDebugPrintf(NULL, "SconConvert() 422 Packed->BI_YU12SEP\n") );
          ScConvert422ToYUV_char((unsigned char *)inbuf,
                           (unsigned char *)prescalebuf,
                           ((unsigned char *)prescalebuf)+(outwidth*outheight),
                           ((unsigned char *)prescalebuf)+(outwidth*outheight*5)/4,
                           inwidth, flip?-inheight:inheight);
          break;
        case BI_YU16SEP: /* 4:2:2 Packed -> 4:2:2 Planar */
        case BI_DECSEPYUVDIB:
          _SlibDebug(_VERBOSE_,
               ScDebugPrintf(NULL, "SconConvert() BI_YUY2->BI_YU16SEP\n") );
          {
            register int i;
            unsigned char *Y=prescalebuf,
                          *U=(unsigned char *)prescalebuf+(inwidth*inheight),
                          *V=U+(inwidth*inheight)/2;
            for (i=(inwidth*inheight)/2; i; i--)
            {
              *Y++ = *((unsigned char *)inbuf)++;
              *U++ = *((unsigned char *)inbuf)++;
              *Y++ = *((unsigned char *)inbuf)++;
              *V++ = *((unsigned char *)inbuf)++;
            }
          }
          break;
        case BI_RGB: /* 4:2:2 Packed -> RGB */
          if (outbpp!=16)
            return(SconErrorUnsupportedFormat);
          else
          {
            u_short *Sout;
            int i, Y1, Y2, U, V, Luma;
            int R1,R2, G1,G2, B1,B2;
            _SlibDebug(_VERBOSE_,
               ScDebugPrintf(NULL, "SconConvert() BI_YUY2->BI_RGB\n") );
            Sout = (u_short *)prescalebuf;
            for (i=(inwidth*inheight)/4; i; i--)
            {
              Y1=(int)*((unsigned char *)inbuf)++;
              U=(int)(*((unsigned char *)inbuf)++) - 128;
              Y2=(int)*((unsigned char *)inbuf)++;
              V=(int)(*((unsigned char *)inbuf)++) - 128;
               if (U || V) {
                 R1 = R2 = (int) (              + (1.596 * V));
                 G1 = G2 = (int) (- (0.391 * U) - (0.813 * V));
                 B1 = B2 = (int) (+ (2.018 * U)              );
               } else { R1=R2=G1=G2=B1=B2=0; }
                   Luma = (int) ((float)(Y1 - 16) * (float)1.164);
               R1 += Luma; G1 += Luma; B1 += Luma;
                   Luma = (int) ((float)(Y2 - 16) * (float)1.164);
               R2 += Luma; G2 += Luma; B2 += Luma;
               if ((R1 | G1 | B1 | R2 | G2 | B2) & 0xffffff00) {
                 if (R1<0) R1=0; else if (R1>255) R1=255;
                 if (G1<0) G1=0; else if (G1>255) G1=255;
                 if (B1<0) B1=0; else if (B1>255) B1=255;
                 if (R2<0) R2=0; else if (R2>255) R2=255;
                 if (G2<0) G2=0; else if (G2>255) G2=255;
                 if (B2<0) B2=0; else if (B2>255) B2=255;
               }
#if 1 /* RGB 565 - 16 bit */
               *(Sout++) = ((R1&0xf8)<<8)|((G1&0xfC)<<3)|((B1&0xf8)>>3);
               *(Sout++) = ((R2&0xf8)<<8)|((G2&0xfC)<<3)|((B2&0xf8)>>3);
#else /* RGB 555 - 15 bit */
               *(Sout++) = ((R1&0xf8)<<7)|((G1&0xf8)<<2)|((B1&0xf8)>>3);
               *(Sout++) = ((R2&0xf8)<<7)|((G2&0xf8)<<2)|((B2&0xf8)>>3);
#endif
            }
          }
          break;
        default:
          retval=SconErrorUnsupportedFormat;
          _SlibDebug(_VERBOSE_,
                ScDebugPrintf(NULL, "SconConvert() BI_YUY2->Unsupported\n") );
      }
    }
    else if (IsRGBPacked(informat)) /* RGB Packed */
    {
      switch (outformat)
      {
        case BI_YU12SEP: /* YUV 4:1:1 Planar */
          if (inbpp==16)
            ScConvertRGB555To411s((unsigned char *)inbuf,
                                (unsigned char *)prescalebuf,
                                inwidth, flip?-inheight:inheight);
          else
          {
            if (Info->Table==NULL)
              sconInitRGBtoYUV(Info);
            sconRGB888To420((unsigned char *)inbuf,
                            (unsigned char *)prescalebuf,
                            inwidth, inheight, (flip?-inwidth:inwidth)*3, Info->Table);
            // ScConvertRGB24To411s((unsigned char *)inbuf,
            //                    (unsigned char *)prescalebuf,
            //                    ((unsigned char *)prescalebuf)+(inwidth*inheight),
            //                    ((unsigned char *)prescalebuf)+(inwidth*inheight*5)/4,
            //                    inwidth, flip?-inheight:inheight);
          }
          break;
        case BI_RGB: /* RGB */
          retval=SconErrorUnsupportedFormat;
          break;
        default:
          retval=SconErrorUnsupportedFormat;
          _SlibDebug(_VERBOSE_,
                ScDebugPrintf(NULL, "SconConvert() BI_RGB->Unsupported\n") );
      }
    }
    else if (IsYUV1611Sep(informat)) /* YUV 16:1:1 Planar */
    {
      switch (outformat)
      {
        case BI_YU12SEP: /* YUV 4:1:1 Planar */
          _SlibDebug(_VERBOSE_,
              ScDebugPrintf(NULL, "SconConvert() BI_YVU9->BI_YU12SEP\n") );
          ScConvert1611sTo411s((unsigned char *)inbuf,
                           (unsigned char *)prescalebuf,
                           ((unsigned char *)prescalebuf)+(outwidth*outheight),
                           ((unsigned char *)prescalebuf)+(outwidth*outheight*5)/4,
                           inwidth, flip?-inheight:inheight);
          break;
        case BI_YU16SEP: /* YUV 4:2:2 Planar */
          _SlibDebug(_VERBOSE_,
              ScDebugPrintf(NULL, "SconConvert() BI_YVU9->BI_YU16SEP\n") );
          ScConvert1611sTo422s((unsigned char *)inbuf,
                           (unsigned char *)prescalebuf,
                           ((unsigned char *)prescalebuf)+(outwidth*outheight),
                           ((unsigned char *)prescalebuf)+(outwidth*outheight*3)/2,
                           inwidth, flip?-inheight:inheight);
          break;
        case BI_DECYUVDIB: /* YUV 4:2:2 Packed */
        case BI_YUY2:
          _SlibDebug(_VERBOSE_,
              ScDebugPrintf(NULL, "SconConvert() BI_YVU9->BI_YUY2\n") );
          ScConvert1611sTo422i((unsigned char *)inbuf,
                           (unsigned char *)prescalebuf, inwidth, flip?-inheight:inheight);
          break;
        default:
          retval=SconErrorUnsupportedFormat;
          _SlibDebug(_VERBOSE_,
                ScDebugPrintf(NULL, "SconConvert() BI_YVU9->Unsupported\n") );
      }
    }
    _SlibDebug(_VERBOSE_ && retval==SconErrorUnsupportedFormat,
              ScDebugPrintf(NULL, "SconConvert() Unsupported->Unsupported\n"));
  }
  if (retval==SconErrorNone && scale)
  {
    if (IsRGBPacked(outformat))
    {
      /* Scaling RGB */
      _SlibDebug(_VERBOSE_,
           ScDebugPrintf(NULL, "SconConvert() Scaling BI_RGB\n") );
      stride=Info->Output.vinfo.Stride;
      sconScaleFrame((unsigned word)((outbpp+7)>>3),
                   prescalebuf, inwidth, inheight,
                   outbuf, outwidth, outheight, stride);
    }
    else if (IsYUV411Sep(outformat)) /* YUV 4:1:1 Planar */
    {
      _SlibDebug(_VERBOSE_, ScDebugPrintf(NULL, "SconConvert() Scaling BI_YU12SEP\n") );
      sconScaleFrame(1,
                         prescalebuf, inwidth, inheight,
                         outbuf, outwidth, outheight, outwidth);
      sconScaleFrame(1,
                         ((unsigned char *)prescalebuf)+(inwidth*inheight),
                               inwidth/2, inheight,
                         ((unsigned char *)outbuf)+(outwidth*outheight),
                               outwidth/2, outheight, outwidth/2);
    }
    else if (IsYUV422Packed(outformat)) /* YUV 4:2:2 Packed */
    {
      stride=Info->Output.vinfo.Stride;
      sconScaleFrame(4,
                     prescalebuf, inwidth/2, inheight,
                     outbuf, outwidth/2, outheight, stride);
    }
    else if (IsYUV422Sep(outformat)) /* YUV 4:2:2 Planar */
    {
      sconScaleFrame(1,
                         prescalebuf, inwidth, inheight,
                         outbuf, outwidth, outheight, outwidth);
      sconScaleFrame(1,
                         ((unsigned char *)prescalebuf)+(inwidth*inheight),
                               inwidth, inheight,
                         ((unsigned char *)outbuf)+(outwidth*outheight),
                               outwidth, outheight, outwidth);
    }
    else if (IsYUV1611Sep(outformat)) /* YUV 16:1:1 Planar */
    {
      sconScaleFrame(1,
                         prescalebuf, inwidth, inheight,
                         outbuf, outwidth, outheight, outwidth);
      sconScaleFrame(1,
                         ((unsigned char *)prescalebuf)+(inwidth*inheight),
                               inwidth/8, inheight,
                         ((unsigned char *)outbuf)+(outwidth*outheight),
                               outwidth/8, outheight, outwidth/8);
    }
    else
    {
      retval=SconErrorUnsupportedFormat;
      _SlibDebug(_VERBOSE_,
                ScDebugPrintf(NULL, "SconConvert() Scaling Unsupported\n") );
    }
  }
  return(retval);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech261\sc_buf.c ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: sc_buf.c,v $
 * Revision 1.1.8.4  1996/12/12  20:54:41  Hans_Graves
 * 	Fixed reading of last odd bits.
 * 	[1996/12/12  20:54:05  Hans_Graves]
 *
 * Revision 1.1.8.3  1996/11/13  16:10:46  Hans_Graves
 * 	Tom's changes to ScBSGetBitsW() and ScBSSeekAlignStopBeforeW().
 * 	[1996/11/13  15:57:34  Hans_Graves]
 *
 * Revision 1.1.8.2  1996/11/08  21:50:32  Hans_Graves
 * 	Added ScBSGetBitsW(), ScBSSkipBitsW() and sc_BSLoadDataWordW() for AC3.
 * 	[1996/11/08  21:25:52  Hans_Graves]
 *
 * Revision 1.1.6.4  1996/04/17  16:38:33  Hans_Graves
 * 	Correct some type casting to support 64-bit buffers under NT
 * 	[1996/04/17  16:36:08  Hans_Graves]
 *
 * Revision 1.1.6.3  1996/04/15  21:08:37  Hans_Graves
 * 	Declare mask and imask as ScBitString_t
 * 	[1996/04/15  21:06:32  Hans_Graves]
 *
 * Revision 1.1.6.2  1996/04/01  16:23:05  Hans_Graves
 * 	Replace File I/O with ScFile calls
 * 	[1996/04/01  16:22:27  Hans_Graves]
 *
 * Revision 1.1.4.7  1996/02/19  14:29:25  Bjorn_Engberg
 * 	Enable FILTER_SUPPORT for NT, so Mview can play audio.
 * 	This is only until we port the MPEG Systems code to NT.
 * 	[1996/02/19  14:29:07  Bjorn_Engberg]
 *
 * Revision 1.1.4.6  1996/02/01  17:15:48  Hans_Graves
 * 	Added FILTER_SUPPORT ifdef; disabled it
 * 	[1996/02/01  17:13:29  Hans_Graves]
 *
 * Revision 1.1.4.5  1996/01/08  16:41:12  Hans_Graves
 * 	Remove NT compiler warnings, and minor fixes for NT.
 * 	[1996/01/08  14:14:10  Hans_Graves]
 *
 * Revision 1.1.4.3  1995/11/06  18:47:37  Hans_Graves
 * 	Added support for small buffer: 1-7 bytes
 * 	[1995/11/06  18:46:49  Hans_Graves]
 *
 * Revision 1.1.4.2  1995/09/13  14:51:34  Hans_Graves
 * 	Added ScBufQueueGetHeadExt() and ScBufQueueAddExt().
 * 	[1995/09/13  14:47:11  Hans_Graves]
 *
 * Revision 1.1.2.18  1995/08/30  19:37:49  Hans_Graves
 * 	Fixed compiler warning about #else and #elif.
 * 	[1995/08/30  19:36:15  Hans_Graves]
 *
 * Revision 1.1.2.17  1995/08/29  22:17:04  Hans_Graves
 * 	Disabled debugging statements.
 * 	[1995/08/29  22:11:38  Hans_Graves]
 *
 * 	PTT 00938 - MPEG Seg Faulting fixes, Repositioning problem.
 * 	[1995/08/29  22:04:06  Hans_Graves]
 *
 * Revision 1.1.2.16  1995/08/14  19:40:24  Hans_Graves
 * 	Added Flush routines. Some optimization.
 * 	[1995/08/14  18:40:33  Hans_Graves]
 *
 * Revision 1.1.2.15  1995/08/02  15:26:58  Hans_Graves
 * 	Fixed writing bitstreams directly to files.
 * 	[1995/08/02  14:11:00  Hans_Graves]
 *
 * Revision 1.1.2.14  1995/07/28  20:58:37  Hans_Graves
 * 	Initialized all variables in callback messages.
 * 	[1995/07/28  20:52:04  Hans_Graves]
 *
 * Revision 1.1.2.13  1995/07/28  17:36:04  Hans_Graves
 * 	Fixed END_BUFFER callback from GetNextBuffer()
 * 	[1995/07/28  17:31:30  Hans_Graves]
 *
 * Revision 1.1.2.12  1995/07/27  18:28:52  Hans_Graves
 * 	Fixed buffer queues in PutData and StoreDataWord.
 * 	[1995/07/27  18:23:30  Hans_Graves]
 *
 * Revision 1.1.2.11  1995/07/27  12:20:35  Hans_Graves
 * 	Renamed SvErrorClientAbort to SvErrorClientEnd
 * 	[1995/07/27  12:19:12  Hans_Graves]
 *
 * Revision 1.1.2.10  1995/07/21  17:40:59  Hans_Graves
 * 	Renamed Callback related stuff. Added DataType.
 * 	[1995/07/21  17:26:48  Hans_Graves]
 *
 * Revision 1.1.2.9  1995/07/17  22:01:27  Hans_Graves
 * 	Added Callback call in PutData().
 * 	[1995/07/17  21:50:49  Hans_Graves]
 *
 * Revision 1.1.2.8  1995/07/12  19:48:21  Hans_Graves
 * 	Added Queue debugging statements.
 * 	[1995/07/12  19:30:37  Hans_Graves]
 *
 * Revision 1.1.2.7  1995/07/07  20:11:23  Hans_Graves
 * 	Fixed ScBSGetBit() so it returns the bit.
 * 	[1995/07/07  20:07:27  Hans_Graves]
 *
 * Revision 1.1.2.6  1995/06/27  13:54:17  Hans_Graves
 * 	Added ScBSCreateFromNet() and STREAM_USE_NET cases.
 * 	[1995/06/27  13:27:38  Hans_Graves]
 *
 * Revision 1.1.2.5  1995/06/21  18:37:56  Hans_Graves
 * 	Added ScBSPutBytes()
 * 	[1995/06/21  18:37:08  Hans_Graves]
 *
 * Revision 1.1.2.4  1995/06/15  21:17:55  Hans_Graves
 * 	Changed return type for GetBits() and PeekBits() to ScBitString_t. Added some debug statements.
 * 	[1995/06/15  20:40:54  Hans_Graves]
 *
 * Revision 1.1.2.3  1995/06/09  18:33:28  Hans_Graves
 * 	Fixed up some problems with Bitstream reads from Buffer Queues
 * 	[1995/06/09  16:27:50  Hans_Graves]
 *
 * Revision 1.1.2.2  1995/05/31  18:07:25  Hans_Graves
 * 	Inclusion in new SLIB location.
 * 	[1995/05/31  16:05:37  Hans_Graves]
 *
 * Revision 1.1.2.3  1995/04/17  18:41:05  Hans_Graves
 * 	Added ScBSPutBits, BSStoreWord, and BSPutData functions
 * 	[1995/04/17  18:40:44  Hans_Graves]
 *
 * Revision 1.1.2.2  1995/04/07  18:22:55  Hans_Graves
 * 	Bitstream and Buffer Queue functions pulled from Sv sources.
 * 	     Added functionality and cleaned up API.
 * 	[1995/04/07  18:21:58  Hans_Graves]
 *
 * $EndLog$
 */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/
/*
** Bitstream and queue routines
**
** Note: For reading, "BS->shift" refers to the number of bits stored across
**       BS->OutBuff and BS->InBuff
*/
/*
#define _SLIBDEBUG_
*/

#include "SC.h"
#include "SC_err.h"
#include <string.h>
#ifdef WIN32
#include <io.h>
#include <windows.h>
#include <assert.h>
#endif

#ifdef _SLIBDEBUG_
#include <stdio.h>
#define _DEBUG_   0  /* detailed debuging statements */
#define _VERBOSE_ 0  /* show progress */
#define _VERIFY_  1  /* verify correct operation */
#define _WARN_    1  /* warnings about strange behavior */
#define _QUEUE_   0  /* show queue progress */
#define _DUMP_    0  /* dump out buffer data in hex */

int _debug_getbits=TRUE;
long _debug_start=0, _debug_stop=0;
#endif

#define USE_FAST_SEEK   0  /* fast seeking for words in the bistream */

#define FILTER_SUPPORT  0  /* data filtering callback support */

#ifdef __VMS
#define USE_MASK_TABLES
#else
#define USE_MASK_TABLES
#endif

#ifdef USE_MASK_TABLES
/* to mask the n least significant bits of an integer */
#if SC_BITBUFFSZ == 64
const static ScBitString_t mask[65] =
{
(ScBitString_t)0x0000000000000000,(ScBitString_t)0x0000000000000001,
(ScBitString_t)0x0000000000000003,(ScBitString_t)0x0000000000000007,
(ScBitString_t)0x000000000000000f,(ScBitString_t)0x000000000000001f,
(ScBitString_t)0x000000000000003f,(ScBitString_t)0x000000000000007f,
(ScBitString_t)0x00000000000000ff,(ScBitString_t)0x00000000000001ff,
(ScBitString_t)0x00000000000003ff,(ScBitString_t)0x00000000000007ff,
(ScBitString_t)0x0000000000000fff,(ScBitString_t)0x0000000000001fff,
(ScBitString_t)0x0000000000003fff,(ScBitString_t)0x0000000000007fff,
(ScBitString_t)0x000000000000ffff,(ScBitString_t)0x000000000001ffff,
(ScBitString_t)0x000000000003ffff,(ScBitString_t)0x000000000007ffff,
(ScBitString_t)0x00000000000fffff,(ScBitString_t)0x00000000001fffff,
(ScBitString_t)0x00000000003fffff,(ScBitString_t)0x00000000007fffff,
(ScBitString_t)0x0000000000ffffff,(ScBitString_t)0x0000000001ffffff,
(ScBitString_t)0x0000000003ffffff,(ScBitString_t)0x0000000007ffffff,
(ScBitString_t)0x000000000fffffff,(ScBitString_t)0x000000001fffffff,
(ScBitString_t)0x000000003fffffff,(ScBitString_t)0x000000007fffffff,
(ScBitString_t)0x00000000ffffffff,(ScBitString_t)0x00000001ffffffff,
(ScBitString_t)0x00000003ffffffff,(ScBitString_t)0x00000007ffffffff,
(ScBitString_t)0x0000000fffffffff,(ScBitString_t)0x0000001fffffffff,
(ScBitString_t)0x0000003fffffffff,(ScBitString_t)0x0000007fffffffff,
(ScBitString_t)0x000000ffffffffff,(ScBitString_t)0x000001ffffffffff,
(ScBitString_t)0x000003ffffffffff,(ScBitString_t)0x000007ffffffffff,
(ScBitString_t)0x00000fffffffffff,(ScBitString_t)0x00001fffffffffff,
(ScBitString_t)0x00003fffffffffff,(ScBitString_t)0x00007fffffffffff,
(ScBitString_t)0x0000ffffffffffff,(ScBitString_t)0x0001ffffffffffff,
(ScBitString_t)0x0003ffffffffffff,(ScBitString_t)0x0007ffffffffffff,
(ScBitString_t)0x000fffffffffffff,(ScBitString_t)0x001fffffffffffff,
(ScBitString_t)0x003fffffffffffff,(ScBitString_t)0x007fffffffffffff,
(ScBitString_t)0x00ffffffffffffff,(ScBitString_t)0x01ffffffffffffff,
(ScBitString_t)0x03ffffffffffffff,(ScBitString_t)0x07ffffffffffffff,
(ScBitString_t)0x0fffffffffffffff,(ScBitString_t)0x1fffffffffffffff,
(ScBitString_t)0x3fffffffffffffff,(ScBitString_t)0x7fffffffffffffff,
(ScBitString_t)0xffffffffffffffff
};
/* inverse mask */
const static ScBitString_t imask[65] =
{
(ScBitString_t)0xffffffffffffffff,(ScBitString_t)0xfffffffffffffffe,
(ScBitString_t)0xfffffffffffffffc,(ScBitString_t)0xfffffffffffffff8,
(ScBitString_t)0xfffffffffffffff0,(ScBitString_t)0xffffffffffffffe0,
(ScBitString_t)0xffffffffffffffc0,(ScBitString_t)0xffffffffffffff80,
(ScBitString_t)0xffffffffffffff00,(ScBitString_t)0xfffffffffffffe00,
(ScBitString_t)0xfffffffffffffc00,(ScBitString_t)0xfffffffffffff800,
(ScBitString_t)0xfffffffffffff000,(ScBitString_t)0xffffffffffffe000,
(ScBitString_t)0xffffffffffffc000,(ScBitString_t)0xffffffffffff8000,
(ScBitString_t)0xffffffffffff0000,(ScBitString_t)0xfffffffffffe0000,
(ScBitString_t)0xfffffffffffc0000,(ScBitString_t)0xfffffffffff80000,
(ScBitString_t)0xfffffffffff00000,(ScBitString_t)0xffffffffffe00000,
(ScBitString_t)0xffffffffffc00000,(ScBitString_t)0xffffffffff800000,
(ScBitString_t)0xffffffffff000000,(ScBitString_t)0xfffffffffe000000,
(ScBitString_t)0xfffffffffc000000,(ScBitString_t)0xfffffffff8000000,
(ScBitString_t)0xfffffffff0000000,(ScBitString_t)0xffffffffe0000000,
(ScBitString_t)0xffffffffc0000000,(ScBitString_t)0xffffffff80000000,
(ScBitString_t)0xffffffff00000000,(ScBitString_t)0xfffffffe00000000,
(ScBitString_t)0xfffffffc00000000,(ScBitString_t)0xfffffff800000000,
(ScBitString_t)0xfffffff000000000,(ScBitString_t)0xffffffe000000000,
(ScBitString_t)0xffffffc000000000,(ScBitString_t)0xffffff8000000000,
(ScBitString_t)0xffffff0000000000,(ScBitString_t)0xfffffe0000000000,
(ScBitString_t)0xfffffc0000000000,(ScBitString_t)0xfffff80000000000,
(ScBitString_t)0xfffff00000000000,(ScBitString_t)0xffffe00000000000,
(ScBitString_t)0xffffc00000000000,(ScBitString_t)0xffff800000000000,
(ScBitString_t)0xffff000000000000,(ScBitString_t)0xfffe000000000000,
(ScBitString_t)0xfffc000000000000,(ScBitString_t)0xfff8000000000000,
(ScBitString_t)0xfff0000000000000,(ScBitString_t)0xffe0000000000000,
(ScBitString_t)0xffc0000000000000,(ScBitString_t)0xff80000000000000,
(ScBitString_t)0xff00000000000000,(ScBitString_t)0xfe00000000000000,
(ScBitString_t)0xfc00000000000000,(ScBitString_t)0xf800000000000000,
(ScBitString_t)0xf000000000000000,(ScBitString_t)0xe000000000000000,
(ScBitString_t)0xc000000000000000,(ScBitString_t)0x8000000000000000,
(ScBitString_t)0x0000000000000000
};
#else
const static ScBitString_t mask[33] =
{
  0x00000000,0x00000001,0x00000003,0x00000007,
  0x0000000f,0x0000001f,0x0000003f,0x0000007f,
  0x000000ff,0x000001ff,0x000003ff,0x000007ff,
  0x00000fff,0x00001fff,0x00003fff,0x00007fff,
  0x0000ffff,0x0001ffff,0x0003ffff,0x0007ffff,
  0x000fffff,0x001fffff,0x003fffff,0x007fffff,
  0x00ffffff,0x01ffffff,0x03ffffff,0x07ffffff,
  0x0fffffff,0x1fffffff,0x3fffffff,0x7fffffff,
  0xffffffff
};
/* inverse mask */
const static ScBitString_t imask[33] =
{
  0xffffffff,0xfffffffe,0xfffffffc,0xfffffff8,
  0xfffffff0,0xffffffe0,0xffffffc0,0xffffff80,
  0xffffff00,0xfffffe00,0xfffffc00,0xfffff800,
  0xfffff000,0xffffe000,0xffffc000,0xffff8000,
  0xffff0000,0xfffe0000,0xfffc0000,0xfff80000,
  0xfff00000,0xffe00000,0xffc00000,0xff800000,
  0xff000000,0xfe000000,0xfc000000,0xf8000000,
  0xf0000000,0xe0000000,0xc0000000,0x80000000,
  0x00000000
};
#endif
#endif USE_MASK_TABLES
/*********************** Bitstream/Buffer Management *************************/
/*
** sc_GetNextBuffer()
** Release current buffer and return info about buffer at head of queue
** Callbacks are made to 1) release old buffer and 2) ask for more buffers
*/
static u_char *sc_GetNextBuffer(ScBitstream_t *BS, int *BufSize)
{
  u_char *Data;
  int Size;
  ScCallbackInfo_t CB;
  ScQueue_t *Q=BS->Q;

  _SlibDebug(_VERBOSE_, printf("sc_GetNextBuffer(Q=%p)\n", Q) );
  if (ScBufQueueGetNum(Q))
  {
    /*
    ** Get pointer to current buffer so we can release it with a callback
    */
    ScBufQueueGetHead(Q, &Data, &Size);

    /*
    ** Remove current buffer from head of queue, replacing it with next in line
    */
    ScBufQueueRemove(Q);

    /*
    ** Make callback to client to tell that old buffer can be reused.
    ** Client may tell us to abort processing. If so, return 0 for BufSize.
    */
    if (BS->Callback && Data) {
      CB.Message = CB_RELEASE_BUFFER;
      CB.Data  = Data;
      CB.DataSize = Size;
      CB.DataUsed = Size;
      CB.DataType = BS->DataType;
      CB.UserData = BS->UserData;
      CB.Action  = CB_ACTION_CONTINUE;
      (*(BS->Callback))(BS->Sch, &CB, NULL);
      _SlibDebug(_DEBUG_,
         printf("Callback: RELEASE_BUFFER. Addr = 0x%x, Client response = %d\n",
                CB.Data, CB.Action) );
      if (CB.Action == CB_ACTION_END)
      {
        *BufSize = 0;
        return(NULL);
      }
    }
  }

  /*
  ** If there's no more buffers in queue, make a callback telling client.
  ** Hopefully, client will call ScAddBuffer to add one or more buffers.
  ** If not, or if client tells us to abort, return 0 for BufSize.
  */
  if (!ScBufQueueGetNum(Q)) {
    if (BS->Callback) {
      CB.Message = CB_END_BUFFERS;
      CB.Data     = NULL;
      CB.DataSize = 0;
      CB.DataUsed = 0;
      CB.DataType = BS->DataType;
      CB.UserData = BS->UserData;
      CB.Action   = CB_ACTION_CONTINUE;
      (*(BS->Callback))(BS->Sch, &CB, NULL);
      if (CB.Action == CB_ACTION_END)
      {
	_SlibDebug(_DEBUG_,
           printf("sc_GetNextBuffer() CB.Action = CB_ACTION_END\n") );
        *BufSize = 0;
        return(NULL);
      }
      else
        _SlibDebug(_VERBOSE_, printf("sc_GetNextBuffer() CB.Action = %d\n",
                                  CB.Action) );
    }
    if (!ScBufQueueGetNum(Q)) {
      _SlibDebug(_DEBUG_, printf("sc_GetNextBuffer() no more buffers\n") );
      *BufSize = 0;
      return(NULL);
    }
  }

  /*
  ** Get & return pointer & size of new current buffer
  */
  ScBufQueueGetHead(Q, &Data, BufSize);
  _SlibDebug(_VERBOSE_, printf("New buffer: Addr = 0x%p, size = %d\n",
                                  Data, *BufSize) );
  return(Data);
}

/*************************** Bitstream Management ***************************/
/* Name:  ScBSSetFilter
** Purpose: Set the callback used to filter out data from the Bitstream
*/
ScStatus_t ScBSSetFilter(ScBitstream_t *BS,
                    int (*Callback)(ScBitstream_t *))
{
  if (!BS)
    return(ScErrorBadPointer);
  BS->FilterCallback=Callback;
  BS->FilterBit=BS->CurrentBit;
  BS->InFilterCallback=FALSE;
  return(ScErrorNone);
}

/* Name:  ScBSCreate
** Purpose: Open a Bitstream (no data source)
*/
ScStatus_t ScBSCreate(ScBitstream_t **BS)
{
  _SlibDebug(_VERBOSE_, printf("ScBSCreate()\n"));

  if ((*BS = (ScBitstream_t *)ScAlloc(sizeof(ScBitstream_t))) == NULL)
    return(ScErrorMemory);

  (*BS)->DataSource = STREAM_USE_NULL;
  (*BS)->Mode='r';
  (*BS)->Q=NULL;
  (*BS)->Callback=NULL;
  (*BS)->FilterCallback=NULL;
  (*BS)->FilterBit=0;
  (*BS)->InFilterCallback=FALSE;
  (*BS)->Sch=0;
  (*BS)->DataType=0;
  (*BS)->UserData=NULL;
  (*BS)->FileFd=0;
  (*BS)->RdBuf=NULL;
  (*BS)->RdBufSize=0;
  (*BS)->RdBufAllocated=FALSE;
  (*BS)->shift=0;
  (*BS)->CurrentBit=0;
  (*BS)->buff=0;
  (*BS)->buffstart=0;
  (*BS)->buffp=0;
  (*BS)->bufftop=0;
  (*BS)->OutBuff = 0;
  (*BS)->InBuff = 0;
  (*BS)->Flush = FALSE;
  (*BS)->EOI = FALSE;
  return(ScErrorNone);
}

/* Name:  ScBSCreateFromBuffer
** Purpose: Open a Bitstream using a single Buffer as a data source
*/
ScStatus_t ScBSCreateFromBuffer(ScBitstream_t **BS, u_char *Buffer,
                                    unsigned int BufSize)
{
  _SlibDebug(_VERBOSE_, printf("ScBSCreateFromBuffer()\n") );
  if (!Buffer)
     return(ScErrorBadPointer);
  if (BufSize <= 0)
    return(ScErrorBadArgument);
  if (ScBSCreate(BS) != ScErrorNone)
     return (ScErrorMemory);

  (*BS)->DataSource = STREAM_USE_BUFFER;
  (*BS)->RdBuf=Buffer;
  (*BS)->RdBufSize=BufSize;
  (*BS)->RdBufAllocated=FALSE;
  return(ScErrorNone);
}

/* Name:  ScBSCreateFromBufferQueue
** Purpose: Open a Bitstream using a Buffer Queue as a data source
*/
ScStatus_t ScBSCreateFromBufferQueue(ScBitstream_t **BS, ScHandle_t Sch,
                                  int DataType, ScQueue_t *Q,
                    int (*Callback)(ScHandle_t,ScCallbackInfo_t *, void *),
                    void *UserData)
{
  _SlibDebug(_VERBOSE_, printf("ScBSCreateFromBufferQueue()\n") );
  if (!Q)
     return(ScErrorNullStruct);
  if (!Callback)
     return(ScErrorBadPointer);
  if (ScBSCreate(BS) != ScErrorNone)
     return (ScErrorMemory);

  (*BS)->DataSource = STREAM_USE_QUEUE;
  (*BS)->Q=Q;
  (*BS)->Callback=Callback;
  (*BS)->Sch=Sch;
  (*BS)->DataType=DataType;
  (*BS)->UserData=UserData;
  return(ScErrorNone);
}


/* Name:  ScBSCreateFromFile
** Purpose: Open a Bitstream using a file as a data source
*/
ScStatus_t ScBSCreateFromFile(ScBitstream_t **BS, int FileFd,
                                 u_char *Buffer, int BufSize)
{
  _SlibDebug(_VERBOSE_, printf("ScBSCreateFromFile()\n") );

  if (BufSize < SC_BITBUFFSZ)
    return(ScErrorBadArgument);
  if (FileFd < 0)
    return(ScErrorBadArgument);

  if (ScBSCreate(BS) != ScErrorNone)
     return (ScErrorMemory);

  (*BS)->DataSource = STREAM_USE_FILE;
  (*BS)->FileFd=FileFd;
  if (Buffer==NULL)  /* if no buffer provided, alloc one */
  {
    if (((*BS)->RdBuf=(u_char *)ScAlloc(BufSize))==NULL)
    {
      ScFree(*BS);
      *BS=NULL;
      return (ScErrorMemory);
    }
    (*BS)->RdBufAllocated=TRUE;
  }
  else
  {
    (*BS)->RdBufAllocated=FALSE;
    (*BS)->RdBuf=Buffer;
  }
  (*BS)->RdBufSize=BufSize;
  return(ScErrorNone);
}

/* Name:  ScBSCreateFromNet
** Purpose: Open a Bitstream using a network socket as a data source
*/
ScStatus_t ScBSCreateFromNet(ScBitstream_t **BS, int SocketFd,
                                u_char *Buffer, int BufSize)
{
  ScStatus_t stat;
  _SlibDebug(_VERBOSE_, printf("ScBSCreateFromNet(SocketFd=%d)\n", SocketFd) );
  stat=ScBSCreateFromFile(BS, SocketFd, Buffer, BufSize);
  if (stat!=NoErrors)
    return(stat);
  (*BS)->DataSource = STREAM_USE_NET;
  return(ScErrorNone);
}

/* Name:  ScBSCreateFromDevice
** Purpose: Open a Bitstream using a device (i.e. WAVE_MAPPER)
*/
ScStatus_t ScBSCreateFromDevice(ScBitstream_t **BS, int device)
{
  _SlibDebug(_VERBOSE_, printf("ScBSCreateFromBuffer()\n") );
  if (ScBSCreate(BS) != ScErrorNone)
     return (ScErrorMemory);

  (*BS)->DataSource = STREAM_USE_DEVICE;
  (*BS)->Device=device;
  return(ScErrorNone);
}


/*
** Name:    ScBSSeekToPosition()
** Purpose: Position the bitstream to a specific byte offset.
*/
ScStatus_t ScBSSeekToPosition(ScBitstream_t *BS, unsigned long pos)
{
#ifndef SEEK_SET
#define SEEK_SET 0
#endif
  ScCallbackInfo_t CB;
  _SlibDebug(_VERBOSE_,
             printf("ScBSSeekToPosition(pos=%d 0x%X) from %d (0x%X)\n",
                       pos, pos, ScBSBytePosition(BS),ScBSBytePosition(BS)) );
  BS->shift=0;
  BS->OutBuff = 0;
  BS->InBuff = 0;
  switch (BS->DataSource)
  {
    case STREAM_USE_BUFFER:
          if (pos==0)
          {
            if (BS->Mode=='w')
            {
              BS->buff = BS->RdBuf;
              BS->bufftop = BS->RdBufSize;
            }
            else
            {
              BS->buff = 0;
              BS->bufftop = 0;
            }
            BS->buffp=0;
            BS->EOI = FALSE;
          }
          else if (pos>=BS->buffstart && pos<(BS->buffstart+BS->bufftop))
          {
            BS->buffp=pos-BS->buffstart;
            BS->EOI = FALSE;
          }
          else
            BS->EOI = TRUE;
          break;
    case STREAM_USE_QUEUE:
          if (pos>=BS->buffstart && pos<(BS->buffstart+BS->bufftop) && pos>0)
          {
            BS->buffp=pos-BS->buffstart;
            BS->EOI = FALSE;
          }
          else /* use callback to reset buffer position */
          {
            int datasize;
            /* Release the current buffer */
            if (BS->Callback && BS->buff)
            {
              CB.Message = CB_RELEASE_BUFFER;
              CB.Data = BS->buff;
              CB.DataSize = BS->bufftop;
              CB.DataUsed = BS->buffp;
              CB.DataType = BS->DataType;
              CB.UserData = BS->UserData;
              CB.Action  = CB_ACTION_CONTINUE;
              (*(BS->Callback))(BS->Sch, &CB, NULL);
              _SlibDebug(_VERBOSE_,
                         printf("Callback: RELEASE_BUFFER. Addr = 0x%x, Client response = %d\n",
                           CB.Data, CB.Action) );
            }
            /* Remove all buffers from queue */
            while (ScBufQueueGetNum(BS->Q))
            {
              ScBufQueueGetHead(BS->Q, &CB.Data, &datasize);
              ScBufQueueRemove(BS->Q);
              if (BS->Callback && CB.Data)
              {
                CB.Message = CB_RELEASE_BUFFER;
                CB.DataSize = datasize;
                CB.DataUsed = 0;
                CB.DataType = BS->DataType;
                CB.UserData = BS->UserData;
                CB.Action  = CB_ACTION_CONTINUE;
                (*(BS->Callback))(BS->Sch, &CB, NULL);
                _SlibDebug(_VERBOSE_,
                           printf("Callback: RELEASE_BUFFER. Addr = 0x%x, Client response = %d\n",
                           CB.Data, CB.Action) );
              }
            }
            BS->buffp=0;
            BS->buff=NULL;
            if (CB.Action == CB_ACTION_END)
            {
              BS->EOI = TRUE;
              return(ScErrorClientEnd);
            }
            else
            {
              BS->buffstart=pos;
              BS->bufftop=0;
              BS->EOI = FALSE;
            }
          }
          break;
    case STREAM_USE_FILE:
          /*
          ** check if the desired position is within the
          ** current buffer
          */
          if (pos>=BS->buffstart && pos<(BS->buffstart+BS->bufftop))
          {
            _SlibDebug(_VERBOSE_, printf("pos is in BS->buff, BS->bufftop=%d\n",
                                        BS->bufftop) );
            BS->buffp=pos-BS->buffstart;
            BS->EOI = FALSE;
          }
          /* otherwise seek to it */
	  else if (ScFileSeek(BS->FileFd, pos)==NoErrors)
          {
            _SlibDebug(_VERBOSE_, printf("seek(%d 0x%X)\n",pos,pos) );
            BS->buffstart=pos;
            BS->bufftop=0;
            BS->buffp=0;
            BS->EOI = FALSE;
          }
          else
          {
            _SlibDebug(_VERBOSE_, printf("seek(%d 0x%X) failed\n",pos,pos) );
            BS->buffstart=0;
            BS->bufftop=0;
            BS->buffp=0;
            BS->EOI = TRUE;
          }
          break;
    default:
          BS->buffstart=0;
          BS->EOI = FALSE;
  }
  BS->CurrentBit=pos<<3;
  _SlibDebug(_VERBOSE_, printf("ScBSSeekToPosition() done\n") );
  return(ScErrorNone);
}

/*
** Name:    ScBSReset()
** Purpose: Reset the bitstream back to the beginning.
*/
ScStatus_t ScBSReset(ScBitstream_t *BS)
{
  _SlibDebug(_VERBOSE_, printf("ScBSReset()\n") );
  BS->EOI=FALSE;
  if (BS->DataSource==STREAM_USE_FILE)
  {
    /*
    ** for files always empty buffer and seek to beginning
    ** just in case the file descriptor was used for something else
    */
    _SlibDebug(_VERBOSE_, printf("seek(0)\n") );
	ScFileSeek(BS->FileFd, 0);
    BS->bufftop=0;  /* empty buffer */
    BS->buffp=0;
    BS->buffstart=0;
  }
  BS->Flush=FALSE;
  return(ScBSSeekToPosition(BS, 0));
}

/*
** Name:    sc_BSGetData()
** Purpose: Set the bitstream pointer to the next buffer in the buffer
**          queue, or if we're using simple file IO, read from the file.
** Returns: TRUE if data read
**          FALSE if none read (EOI)
*/
static u_int sc_BSGetData(ScBitstream_t *BS)
{
  int BufSize;

  _SlibDebug(_VERBOSE_, printf("sc_BSGetData\n") );
  BS->buffp = 0;
  if (BS->EOI)
  {
    BS->buff = NULL;
    BS->bufftop = 0;
    return(FALSE);
  }
  switch (BS->DataSource)
  {
    case STREAM_USE_BUFFER:
          if (BS->buff == BS->RdBuf)
          {
            BS->buff = NULL;
            BS->bufftop = 0;
          }
          else
          {
            BS->buff = BS->RdBuf;
            BS->bufftop = BS->RdBufSize;
          }
          break;
    case STREAM_USE_QUEUE:
          BS->buffstart+=BS->bufftop;
          _SlibDebug(_VERIFY_ && BS->buffstart<(BS->CurrentBit/8),
            printf("ScBSGetData() QUEUE buffstart(%d/0x%X) < currentbyte(%d/0x%X)\n",
             BS->buffstart, BS->buffstart, BS->CurrentBit/8, BS->CurrentBit/8);
            return(FALSE) );
          BS->buff = sc_GetNextBuffer(BS, &BufSize);
          BS->bufftop = BufSize;
          break;
    case STREAM_USE_NET:
    case STREAM_USE_NET_UDP:
    case STREAM_USE_FILE:
          BS->buff = BS->RdBuf;
          BS->buffstart+=BS->bufftop;
          _SlibDebug(_VERIFY_ && BS->buffstart<(BS->CurrentBit/8),
            printf("ScBSGetData() FILE buffstart(%d/0x%X) < currentbyte(%d/0x%X)\n",
             BS->buffstart, BS->buffstart, BS->CurrentBit/8, BS->CurrentBit/8);
            return(FALSE) );
          BufSize = ScFileRead(BS->FileFd, BS->buff, BS->RdBufSize);
          if (BufSize<0)
            BS->bufftop = 0;
          else
            BS->bufftop = BufSize;
          _SlibDebug(_VERBOSE_,
                      printf("%d bytes read from fd %d: BytePosition=%d (0x%X) RdBufSize=%d\n buffstart=%d (0x%X)",
                        BS->bufftop,BS->FileFd,ScBSBytePosition(BS),
                        ScBSBytePosition(BS),BS->RdBufSize,
                        BS->buffstart,BS->buffstart) );
          break;
    case STREAM_USE_NULL:
          BS->buff = NULL;
          BS->bufftop   =10240;
          BS->buffstart+=10240;
          break;
  }
  _SlibDebug(_DUMP_ && BS->buff && BS->bufftop &&
                      BS->DataSource==STREAM_USE_QUEUE,
            printf("sc_BSGetData():\n");
            ScDumpChar(BS->buff, BS->bufftop, BS->buffstart);
            if (BS->bufftop>0x8000)  /* show end of buffer */
              ScDumpChar(BS->buff+BS->bufftop-0x500, 0x500,
                         BS->buffstart+BS->bufftop-0x500) );

  if (BS->buff && BS->bufftop)
    return(TRUE);
  else
    return(FALSE);
}

/*
** Name:    sc_BSPutData()
** Purpose: Set the bitstream pointer to the next buffer in the buffer
**          queue, or if we're using simple file IO, read from the file.
*/
static ScStatus_t sc_BSPutData(ScBitstream_t *BS)
{
  ScStatus_t stat;
  int written;

  _SlibDebug(_VERBOSE_, printf("sc_BSPutData\n") );
  BS->Flush=FALSE;
  switch (BS->DataSource)
  {
    case STREAM_USE_BUFFER:
          stat=ScErrorEndBitstream;
          break;
    case STREAM_USE_QUEUE:
          if (BS->Callback)
          {
            ScCallbackInfo_t CB;
            if (BS->buff)
            {
              _SlibDebug(_VERBOSE_, printf("Callback CB_RELEASE_BUFFERS\n"));
              CB.Message = CB_RELEASE_BUFFER;
              CB.Data  = BS->buff;
              CB.DataSize = BS->buffp;
              CB.DataUsed = CB.DataSize;
              CB.DataType = BS->DataType;
              CB.UserData = BS->UserData;
              CB.Action  = CB_ACTION_CONTINUE;
              (*BS->Callback)(BS->Sch, &CB, NULL);
              BS->buff = 0;
              BS->bufftop = 0;
              BS->buffp=0;
              if (CB.Action == CB_ACTION_END)
                return(ScErrorClientEnd);
            }
            else
              BS->bufftop = 0;
            if (!BS->Q)
              stat=ScErrorEndBitstream;
            else
            {
              _SlibDebug(_DEBUG_, printf("Callback CB_END_BUFFERS\n") );
              CB.Message  = CB_END_BUFFERS;
              CB.Data     = NULL;
              CB.DataSize = 0;
              CB.DataUsed = 0;
              CB.DataType = BS->DataType;
              CB.UserData = BS->UserData;
              CB.Action   = CB_ACTION_CONTINUE;
              (*BS->Callback)(BS->Sch, &CB, NULL);
              if (CB.Action != CB_ACTION_CONTINUE ||
                   ScBufQueueGetNum(BS->Q)==0)
                stat=ScErrorEndBitstream;
              else
              {
                int size;
                ScBufQueueGetHead(BS->Q, &BS->buff, &size);
                BS->bufftop=size;
                ScBufQueueRemove(BS->Q);
                if (!BS->buff || size<=0)
                  stat=ScErrorEndBitstream;
                else
                  stat=NoErrors;
              }
            }
          }
          else
          {
            BS->buff = 0;
            BS->bufftop = 0;
          }
          BS->buffp=0;
          break;
    case STREAM_USE_FILE:
    case STREAM_USE_NET:
    case STREAM_USE_NET_UDP:
          if (BS->buffp>0)
          {
            written=ScFileWrite(BS->FileFd, BS->buff, BS->buffp);
            _SlibDebug(_VERBOSE_,
                       printf("%d bytes written to fd %d (buffer=%d bytes)\n",
                                             written, BS->FileFd, BS->buffp) );
            _SlibDebug(_DUMP_,
                printf("sc_BSPutData():\n");
                ScDumpChar(BS->buff, BS->buffp, BS->buffstart));
            if (written<(int)BS->buffp)
            {
              BS->buff = BS->RdBuf;
              BS->buffp=0;
              BS->bufftop=0;
              stat=ScErrorEndBitstream;
            }
            else
            {
              BS->buff = BS->RdBuf;
              BS->buffp=0;
              BS->bufftop = BS->RdBufSize;
              stat=NoErrors;
            }
          }
          break;
    case STREAM_USE_NULL:
          BS->buff = NULL;
          BS->buffp=0;
          BS->bufftop = 10240;
          break;
    default:
          stat=ScErrorEndBitstream;
  }

  return(stat);
}

/*
** Name:    sc_BSLoadDataWord
** Purpose: Copy a longword from the bitstream buffer into local working buffer
*/
ScStatus_t sc_BSLoadDataWord(ScBitstream_t *BS)
{
  int i, bcount;
  register ScBitBuff_t InBuff;
  const int shift=BS->shift;
  const u_int buffp=BS->buffp;
  register u_char *buff=BS->buff+buffp;

  _SlibDebug(_DEBUG_,
          printf("sc_BSLoadDataWord(BS=%p) shift=%d bit=%d byte=%d (0x%X)\n",
          BS, BS->shift, BS->CurrentBit, BS->CurrentBit/8, BS->CurrentBit/8) );
  /* If we have plenty of room, use fast path */
  if (BS->bufftop - buffp >= SC_BITBUFFSZ/8)
  {
#if SC_BITBUFFSZ == 64
    InBuff=(ScBitBuff_t)buff[7];
    InBuff|=(ScBitBuff_t)buff[6]<<8;
    InBuff|=(ScBitBuff_t)buff[5]<<16;
    InBuff|=(ScBitBuff_t)buff[4]<<24;
    InBuff|=(ScBitBuff_t)buff[3]<<32;
    InBuff|=(ScBitBuff_t)buff[2]<<40;
    InBuff|=(ScBitBuff_t)buff[1]<<48;
    InBuff|=(ScBitBuff_t)buff[0]<<56;
    _SlibDebug(_VERIFY_ && (u_char)((InBuff>>24)&0xFF)!=buff[4],
           printf("sc_BSLoadDataWord(BS=%p) InBuff>>24(%X)!=buff[4](%X)\n",
           BS, (InBuff>>24)&0xFF, buff[4]) );
    _SlibDebug(_VERIFY_ && (u_char)(InBuff>>56)!=buff[0],
           printf("sc_BSLoadDataWord(BS=%p) InBuff>>56(%X)!=buff[0](%X)\n",
           BS, (InBuff>>56), buff[0]) );
#elif SC_BITBUFFSZ == 32
    InBuff=(ScBitBuff_t)buff[3];
    InBuff|=(ScBitBuff_t)buff[2]<<8;
    InBuff|=(ScBitBuff_t)buff[1]<<16;
    InBuff|=(ScBitBuff_t)buff[0]<<24;
    _SlibDebug(_VERIFY_ && (InBuff>>24)!=buff[0],
           printf("sc_BSLoadDataWord(BS=%p) InBuff>>24(%X)!=buff[0](%X)\n",
           BS, InBuff>>24, buff[0]) );
#else
    printf("SC_BITBUFFSZ <> 32\n");
    for (InBuff=0, i = SC_BITBUFFSZ/8; i > 0; i--, buff++)
      InBuff = (InBuff << 8) | (ScBitBuff_t)*buff;
#endif
    BS->buffp=buffp+SC_BITBUFFSZ/8;
    bcount = SC_BITBUFFSZ/8;
  }
  /* Near or at end of buffer */
  else
  {
    /* Get remaining bytes */
    bcount = BS->bufftop - buffp;
    for (InBuff=0, i = bcount; i > 0; i--, buff++)
      InBuff = (InBuff << 8) | (ScBitBuff_t)*buff;
    BS->buffp=buffp+bcount;
    /* Attempt to get more data - if successful, shuffle rest of bytes */
    if (sc_BSGetData(BS))
    {
      BS->EOI = FALSE;
      i = (SC_BITBUFFSZ/8) - bcount;
      if (i>(int)BS->bufftop)
      {
        _SlibDebug(_WARN_,
           printf("ScBSLoadDataWord() Got small buffer. Expected %d bytes got %d bytes.\n",
                     i, BS->bufftop) );
        i=BS->bufftop;
        bcount+=i;
        while (i > 0)
        {
	  InBuff = (InBuff << 8) | (ScBitBuff_t)BS->buff[BS->buffp++];
          i--;
        }
        InBuff<<=SC_BITBUFFSZ-(bcount*8);
      }
      else
      {
        bcount = SC_BITBUFFSZ/8;
        while (i > 0)
        {
	  InBuff = (InBuff << 8) | (ScBitBuff_t)BS->buff[BS->buffp++];
          i--;
        }
      }
    }
    else if (bcount==0)
      BS->EOI = TRUE;
    else
      InBuff <<= SC_BITBUFFSZ-bcount*8;
  }

  _SlibDebug(_VERIFY_ && BS->shift>SC_BITBUFFSZ,
           printf("sc_BSLoadDataWord(BS=%p) shift (%d) > SC_BITBUFFSZ (%d)\n",
           BS, BS->shift, SC_BITBUFFSZ) );
  if (!shift) /* OutBuff is empty */
  {
    BS->OutBuff = InBuff;
    BS->InBuff = 0;
    BS->shift=bcount*8;
  }
  else if (shift<SC_BITBUFFSZ)
  {
    BS->OutBuff |= InBuff >> shift;
    BS->InBuff = InBuff << (SC_BITBUFFSZ-shift);
    BS->shift=shift+(bcount*8);
  }
  else /* shift == SC_BITBUFFSZ - OutBuff is full */
  {
    BS->InBuff = InBuff;
    BS->shift=bcount*8;
  }
  _SlibDebug(_VERIFY_,
    if (BS->shift<SC_BITBUFFSZ)
    {
      if (BS->OutBuff & (SC_BITBUFFMASK>>BS->shift))
        printf("sc_BSLoadDataWord(BS=%p) Non-zero bits to right of OutBuff: shift=%d\n", BS, BS->shift);
      else if (BS->InBuff)
        printf("sc_BSLoadDataWord(BS=%p) Non-zero bits in InBuff: shift=%d\n",
           BS, BS->shift);
    }
    else if (BS->InBuff&(SC_BITBUFFMASK>>(BS->shift-SC_BITBUFFSZ)))
      printf("sc_BSLoadDataWord(BS=%p) Non-zero bits to right of InBuff: shift=%d\n", BS->shift);
    if ((BS->CurrentBit%8) && !(BS->shift%8))
      printf("sc_BSLoadDataWord(BS=%p) CurrentBit (%d) and shift (%d) not aligned.\n", BS, BS->CurrentBit, BS->shift);
    if ((BS->CurrentBit+BS->shift)/8!=BS->buffstart+BS->buffp)
    {
      printf("sc_BSLoadDataWord(BS=%p) (CurrentBit+shift)/8 (%d) <> buffstart+buffp (%d)\n", BS, (BS->CurrentBit+BS->shift)/8, BS->buffstart+BS->buffp);
      BS->EOI = TRUE;
      return(ScErrorEndBitstream);
    }
  );
  return(NoErrors);
}
/*
** Name:    sc_BSLoadDataWordW
** Purpose: Copy a longword from the bitstream buffer into local working buffer
**		** This version operates a word at a time for Dolby **
*/
ScStatus_t sc_BSLoadDataWordW(ScBitstream_t *BS)
{
  int i, wcount;
  register ScBitBuff_t InBuff;
  const int shift=BS->shift;
  const u_int buffp=BS->buffp;
  register u_short *buff=(u_short *)BS->buff+(buffp/2);

  _SlibDebug(_DEBUG_,
          printf("sc_BSLoadDataWord(BS=%p) shift=%d bit=%d byte=%d (0x%X)\n",
          BS, BS->shift, BS->CurrentBit, BS->CurrentBit/8, BS->CurrentBit/8) );
  /* If we have plenty of room, use fast path */
  if (BS->bufftop - buffp >= SC_BITBUFFSZ/8)
  {
#if SC_BITBUFFSZ == 64
    InBuff=(ScBitBuff_t)buff[3];
    InBuff|=(ScBitBuff_t)buff[2]<<16;
    InBuff|=(ScBitBuff_t)buff[1]<<32;
    InBuff|=(ScBitBuff_t)buff[0]<<48;
    _SlibDebug(_VERIFY_ && (InBuff>>24)&0xFFFF!=buff[4],
           printf("sc_BSLoadDataWord(BS=%p) InBuff>>24(%X)!=buff[0](%X)\n",
           BS, (InBuff>>24)&0xFF, buff[4]) );
    _SlibDebug(_VERIFY_ && (InBuff>>56)!=buff[0],
           printf("sc_BSLoadDataWord(BS=%p) InBuff>>56(%X)!=buff[0](%X)\n",
           BS, (InBuff>>56), buff[0]) );
#elif SC_BITBUFFSZ == 32
    InBuff=(ScBitBuff_t)buff[1];
    InBuff|=(ScBitBuff_t)buff[0]<<16;
    _SlibDebug(_VERIFY_ && (InBuff>>16)!=buff[0],
           printf("sc_BSLoadDataWord(BS=%p) InBuff>>24(%X)!=buff[0](%X)\n",
           BS, InBuff>>24, buff[0]) );
#else
    printf("SC_BITBUFFSZ <> 32\n");
    for (InBuff=0, i = SC_BITBUFFSZ/16; i > 0; i--, buff++)
      InBuff = (InBuff << 16) | (ScBitBuff_t)*buff;
#endif
    BS->buffp=buffp+SC_BITBUFFSZ/8;
    wcount = SC_BITBUFFSZ/16;
  }
  /* Near or at end of buffer */
  else
  {
    /* Get remaining bytes */
    wcount = (BS->bufftop - buffp)/2;
    for (InBuff=0, i = wcount; i > 0; i--, buff++)
      InBuff = (InBuff << 16) | (ScBitBuff_t)*buff;
    BS->buffp=buffp+wcount*2;
    /* Attempt to get more data - if successful, shuffle rest of bytes */
    if (sc_BSGetData(BS))
    {
	  int wordp=BS->buffp/2;	/* Pointer is stored as a byte count, but we need words */

      BS->EOI = FALSE;
      i = (SC_BITBUFFSZ/16) - wcount;
      if (i>(int)BS->bufftop)
      {
        _SlibDebug(_WARN_,
           printf("ScBSLoadDataWord() Got small buffer. Expected %d words got %d words.\n",
                     i, BS->bufftop) );
        i=BS->bufftop;
        wcount+=i;
        while (i >= 0)
        {
	  InBuff = (InBuff << 16) | (ScBitBuff_t)((u_short *)BS->buff)[wordp++];
          i--;
        }
        InBuff<<=SC_BITBUFFSZ-(wcount*16);
      }
      else
      {
        wcount = SC_BITBUFFSZ/16;
        while (i > 0)
        {
	  InBuff = (InBuff << 16) | (ScBitBuff_t)((u_short *)BS->buff)[wordp++];
          i--;
        }
      }
	  BS->buffp=wordp*2;
    }
    else
      BS->EOI = TRUE;
  }
  _SlibDebug(_VERIFY_ && BS->shift>SC_BITBUFFSZ,
           printf("sc_BSLoadDataWordW(BS=%p) shift (%d) > SC_BITBUFFSZ (%d)\n",
           BS, BS->shift, SC_BITBUFFSZ) );
  if (!shift) /* OutBuff is empty */
  {
    BS->OutBuff = InBuff;
    BS->InBuff = 0;
    BS->shift=wcount*16;
  }
  else if (shift<SC_BITBUFFSZ)
  {
    BS->OutBuff |= InBuff >> shift;
    BS->InBuff = InBuff << (SC_BITBUFFSZ-shift);
    BS->shift=shift+(wcount*16);
  }
  else /* shift == SC_BITBUFFSZ - OutBuff is full */
  {
    BS->InBuff = InBuff;
    BS->shift=wcount*16;
  }
  _SlibDebug(_VERIFY_,
    if (BS->shift<SC_BITBUFFSZ)
    {
      if (BS->OutBuff & (SC_BITBUFFMASK>>BS->shift))
        printf("sc_BSLoadDataWord(BS=%p) Non-zero bits to right of OutBuff: shift=%d\n", BS, BS->shift);
      else if (BS->InBuff)
        printf("sc_BSLoadDataWord(BS=%p) Non-zero bits in InBuff: shift=%d\n",
           BS, BS->shift);
    }
    else if (BS->InBuff&(SC_BITBUFFMASK>>(BS->shift-SC_BITBUFFSZ)))
      printf("sc_BSLoadDataWord(BS=%p) Non-zero bits to right of InBuff: shift=%d\n", BS->shift);
    if ((BS->CurrentBit%8) && !(BS->shift%8))
      printf("sc_BSLoadDataWord(BS=%p) CurrentBit (%d) and shift (%d) not aligned.\n", BS, BS->CurrentBit, BS->shift);
    if ((BS->CurrentBit+BS->shift)/8!=BS->buffstart+BS->buffp)
    {
      printf("sc_BSLoadDataWord(BS=%p) (CurrentBit+shift)/8 (%d) <> buffstart+buffp (%d)\n", BS, (BS->CurrentBit+BS->shift)/8, BS->buffstart+BS->buffp);
      BS->EOI = TRUE;
      return(ScErrorEndBitstream);
    }
  );
  return(NoErrors);
}

/*
** Name:    sc_BSStoreDataWord
** Purpose: Copy a longword from the local working buffer to the
**          bitstream buffer
*/
ScStatus_t sc_BSStoreDataWord(ScBitstream_t *BS, ScBitBuff_t OutBuff)
{
  int i, bcount, shift=SC_BITBUFFSZ-8;
  ScStatus_t stat=NoErrors;

  _SlibDebug(_VERBOSE_,
             printf("sc_BSStoreDataWord(0x%lX 0x%lX) buffp=%d\n",
                            OutBuff>>32, OutBuff&0xFFFFFFFF, BS->buffp) );
  if (BS->EOI)
    return(ScErrorEndBitstream);
  if (!BS->buff || BS->bufftop<=0)
  {
    if (BS->DataSource==STREAM_USE_QUEUE)
    {
      if (BS->Callback && BS->Q)
      {
        ScCallbackInfo_t CB;
        _SlibDebug(_DEBUG_, printf("Callback CB_END_BUFFERS\n") );
        CB.Message  = CB_END_BUFFERS;
        CB.Data     = NULL;
        CB.DataSize = 0;
        CB.DataUsed = 0;
        CB.DataType = BS->DataType;
        CB.UserData = BS->UserData;
        CB.Action   = CB_ACTION_CONTINUE;
        (*BS->Callback)(BS->Sch, &CB, NULL);
        if (CB.Action != CB_ACTION_CONTINUE || ScBufQueueGetNum(BS->Q)==0)
        {
          BS->EOI = TRUE;
          return(ScErrorEndBitstream);
        }
        else
        {
          int size;
          ScBufQueueGetHead(BS->Q, &BS->buff, &size);
          BS->bufftop=size;
          ScBufQueueRemove(BS->Q);
          if (!BS->buff || size<=0)
          {
            BS->EOI = TRUE;
            return(ScErrorEndBitstream);
          }
          BS->EOI = FALSE;
        }
      }
      else
      {
        BS->EOI = TRUE;
        return(ScErrorEndBitstream);
      }
    }
    else if (BS->RdBuf)
    {
      BS->buff=BS->RdBuf;
      BS->bufftop=BS->RdBufSize;
    }
  }
  bcount = BS->bufftop - BS->buffp;
  /* If we have plenty of room, use fast path */
  if (bcount >= SC_BITBUFFSZ>>3) {
    u_char *buff=BS->buff+BS->buffp;
#if SC_BITBUFFSZ == 64
    buff[0]=(unsigned char)(OutBuff>>56);
    buff[1]=(unsigned char)(OutBuff>>48);
    buff[2]=(unsigned char)(OutBuff>>40);
    buff[3]=(unsigned char)(OutBuff>>32);
    buff[4]=(unsigned char)(OutBuff>>24);
    buff[5]=(unsigned char)(OutBuff>>16);
    buff[6]=(unsigned char)(OutBuff>>8);
    buff[7]=(unsigned char)OutBuff;
#elif SC_BITBUFFSZ == 32
    buff[0]=(unsigned char)(OutBuff>>24);
    buff[1]=(unsigned char)(OutBuff>>16);
    buff[2]=(unsigned char)(OutBuff>>8);
    buff[3]=(unsigned char)OutBuff;
#else
    for (bcount = SC_BITBUFFSZ/8; bcount; shift-=8, bcount--, buff++)
      *buff=(Buff>>shift)&0xFF;
#endif
    BS->buffp+=SC_BITBUFFSZ/8;
    if (BS->Flush && sc_BSPutData(BS)!=NoErrors)
      BS->EOI=TRUE;
  }
  else /* Near end of buffer */
  {
    /* Fill up current buffer */
    for (i=0; i<bcount; shift-=8, i++)
      BS->buff[BS->buffp++]=(unsigned char)(OutBuff>>shift);
    /* Commit the buffer */
    if ((stat=sc_BSPutData(BS))==NoErrors)
    {
      /* Successful, so copy rest of bytes to new buffer */
      bcount = (SC_BITBUFFSZ>>3) - bcount;
      for (i=0; i<bcount; shift-=8, i++)
        BS->buff[BS->buffp++]=(unsigned char)(OutBuff>>shift);
    }
    else
      BS->EOI=TRUE;
  }
  BS->Mode='w';
  return(stat);
}

/*
** ScBSSkipBits()
** Skip a certain number of bits
**
*/
ScStatus_t ScBSSkipBits(ScBitstream_t *BS, u_int length)
{
  register u_int skipbytes, skipbits;
  register int shift;
  _SlibDebug(_DEBUG_, printf("ScBSSkipBits(%d): Byte offset = 0x%X\n",length,
                                                    ScBSBytePosition(BS)) );
  _SlibDebug(_WARN_ && length==0,
         printf("ScBSSkipBits(%d) length==0\n", length) );
  _SlibDebug(_WARN_ && length>SC_BITBUFFSZ,
         printf("ScBSSkipBits(%d) length > SC_BITBUFFSZ (%d)\n",
                        length, SC_BITBUFFSZ) );
  if (length<=SC_BITBUFFSZ)
    ScBSPreLoad(BS, length);
  if ((shift=BS->shift)>0)
  {
    if (length<=(u_int)shift) /* all the bits are already in OutBuff & InBuff */
    {
      if (length==SC_BITBUFFSZ)
      {
        BS->OutBuff=BS->InBuff;
        BS->InBuff=0;
      }
      else
      {
        BS->OutBuff=(BS->OutBuff<<length)|(BS->InBuff>>(SC_BITBUFFSZ-length));
        BS->InBuff<<=length;
      }
      BS->CurrentBit+=length;
      BS->shift=shift-length;
      return(NoErrors);
    }
    else /* discard all the bits in OutBuff & InBuff */
    {
      length-=shift;
      BS->OutBuff=BS->InBuff=0;
      BS->CurrentBit+=shift;
      BS->shift=0;
    }
  }
  _SlibDebug(_VERIFY_ && (BS->shift || BS->CurrentBit%8),
            printf("ScBSSkipBits() Bad Alignment - shift=%d CurrentBit=%d\n",
                BS->shift, BS->CurrentBit) );

  skipbytes=length>>3;
  skipbits=length%8;
  _SlibDebug(_WARN_ && skipbits,
     printf("ScBSSkipBits() Skipping odd amount: skipbytes=%d skipbits=%d\n",
               skipbytes, skipbits) );
  if (BS->EOI)
    return(ScErrorEndBitstream);
  while (skipbytes>=(BS->bufftop - BS->buffp))
  {
    /* discard current block of data */
    BS->CurrentBit+=(BS->bufftop - BS->buffp)<<3;
    skipbytes-=BS->bufftop - BS->buffp;
    BS->buffp=0;
    /* get another block */
    if (sc_BSGetData(BS))
      BS->EOI = FALSE;
    else
    {
      BS->EOI = TRUE;
      BS->shift=0;
      return(ScErrorEndBitstream);
    }
  }
  if (skipbytes)
  {
    /* skip forward in current block of data */
    BS->buffp+=skipbytes;
    BS->CurrentBit+=skipbytes<<3;
  }
  if (skipbits)
  {
    /* skip odd number of bits - between 0 and 7 bits */
    ScBSPreLoad(BS, skipbits);
    BS->OutBuff<<=skipbits;
    BS->CurrentBit += skipbits;
    BS->shift-=skipbits;
  }
  return(NoErrors);
}


/*
** ScBSSkipBitsW()
** Skip a certain number of bits
** ** Dolby version **
*/
ScStatus_t ScBSSkipBitsW(ScBitstream_t *BS, u_int length)
{
  register u_int skipwords, skipbits;
  register int shift;
  _SlibDebug(_DEBUG_, printf("ScBSSkipBitsW(%d): Byte offset = 0x%X\n",length,
                                                    ScBSBytePosition(BS)) );
  _SlibDebug(_WARN_ && length==0,
         printf("ScBSSkipBitsW(%d) length==0\n", length) );
  _SlibDebug(_WARN_ && length>SC_BITBUFFSZ,
         printf("ScBSSkipBits(%d) length > SC_BITBUFFSZ (%d)\n",
                        length, SC_BITBUFFSZ) );
  if (length<=SC_BITBUFFSZ)
    ScBSPreLoadW(BS, length);
  if ((shift=BS->shift)>0)
  {
    if (length<=(u_int)shift) /* all the bits are already in OutBuff & InBuff */
    {
      if (length==SC_BITBUFFSZ)
      {
        BS->OutBuff=BS->InBuff;
        BS->InBuff=0;
      }
      else
      {
        BS->OutBuff=(BS->OutBuff<<length)|(BS->InBuff>>(SC_BITBUFFSZ-length));
        BS->InBuff<<=length;
      }
      BS->CurrentBit+=length;
      BS->shift=shift-length;
      return(NoErrors);
    }
    else /* discard all the bits in OutBuff & InBuff */
    {
      length-=shift;
      BS->OutBuff=BS->InBuff=0;
      BS->CurrentBit+=shift;
      BS->shift=0;
    }
  }
  _SlibDebug(_VERIFY_ && (BS->shift || BS->CurrentBit%8),
            printf("ScBSSkipBitsW() Bad Alignment - shift=%d CurrentBit=%d\n",
                BS->shift, BS->CurrentBit) );

  skipwords=length>>4;
  skipbits=length%16;
  _SlibDebug(_WARN_ && skipbits,
     printf("ScBSSkipBitsW() Skipping odd amount: skipwords=%d skipbits=%d\n",
               skipwords, skipbits) );
  if (BS->EOI)
    return(ScErrorEndBitstream);
  while (skipwords>=(BS->bufftop - BS->buffp)/2)
  {
    /* discard current block of data */
    BS->CurrentBit+=((BS->bufftop - BS->buffp)/2)<<4;
    skipwords-=(BS->bufftop - BS->buffp)/2;
    BS->buffp=0;
    /* get another block */
    if (sc_BSGetData(BS))
      BS->EOI = FALSE;
    else
    {
      BS->EOI = TRUE;
      BS->shift=0;
      return(ScErrorEndBitstream);
    }
  }
  if (skipwords)
  {
    /* skip forward in current block of data */
    BS->buffp+=skipwords*2;
    BS->CurrentBit+=skipwords<<4;
  }
  if (skipbits)
  {
    /* skip odd number of bits - between 0 and 7 bits */
    ScBSPreLoadW(BS, skipbits);
    BS->OutBuff<<=skipbits;
    BS->CurrentBit += skipbits;
    BS->shift-=skipbits;
  }
  return(NoErrors);
}


/*
** ScBSSkipBytes()
** Skip a certain number of bytes
**
*/
ScStatus_t ScBSSkipBytes(ScBitstream_t *BS, u_int length)
{
  return(ScBSSkipBits(BS, length<<3));
}


/*
** ScBSPeekBits()
** Return the next length bits from the bitstream without
** removing them.
*/
ScBitString_t ScBSPeekBits(ScBitstream_t *BS, u_int length)
{
  _SlibDebug(_DEBUG_,
         printf("ScBSPeekBits(%d): Byte offset = 0x%X OutBuff=0x%lX\n",length,
                                   ScBSBytePosition(BS),BS->OutBuff) );
  _SlibDebug(_VERIFY_ && length>SC_BITBUFFSZ,
         printf("ScBSPeekBits(%d) length > SC_BITBUFFSZ\n", length) );
  _SlibDebug(_WARN_ && length==0,
         printf("ScBSPeekBits(%d) length==0\n", length) );
  if (length==0)
    return(0);
  ScBSPreLoad(BS, length);
  _SlibDebug(_VERIFY_ && BS->shift<length,
    printf("ScBSPeekBits(%d) shift (%d) < length (%d) at byte pos %d (0x%X)\n",
             length, BS->shift, length, BS->CurrentBit/8, BS->CurrentBit/8) );
  if (length == SC_BITBUFFSZ)
    return(BS->OutBuff);
  else
    return(BS->OutBuff >> (SC_BITBUFFSZ-length));
}


/*
** ScBSPeekBit()
** Return the next bit from the bitstream without
** removing it.
*/
int ScBSPeekBit(ScBitstream_t *BS)
{
  _SlibDebug(_DEBUG_,
             printf("ScBSPeekBit(): Byte offset = 0x%X OutBuff=0x%lX\n",
                                   ScBSBytePosition(BS),BS->OutBuff) );
  ScBSPreLoad(BS, 1);
  return((int)(BS->OutBuff >> (SC_BITBUFFSZ-1)));
}


/*
** ScBSPeekBytes()
** Return the next length bytes from the bitstream without
** removing them.
*/
ScBitString_t ScBSPeekBytes(ScBitstream_t *BS, u_int length)
{
  if (length==0)
    return(0);
  length*=8;
  ScBSPreLoad(BS, length);
  if (length == SC_BITBUFFSZ)
    return(BS->OutBuff);
  else
    return(BS->OutBuff >> (SC_BITBUFFSZ-length));
}

/*
** ScBSGetBytes()
** Return the next length bytes from the bitstream
*/
ScStatus_t ScBSGetBytes(ScBitstream_t *BS, u_char *buffer, u_int length,
                                                 u_int *ret_length)
{
  int i, shift;
  unsigned int offset=0;
  _SlibDebug(_VERBOSE_, printf("ScBSGetBytes(%d): Byte offset = 0x%X\n",
                             length, ScBSBytePosition(BS)) );
  _SlibDebug(_WARN_ && length==0,
         printf("ScBSGetBytes(%d) length==0\n", length) );

  if (BS->EOI)
  {
    *ret_length=0;
    return(ScErrorEndBitstream);
  }
  if (length<(SC_BITBUFFSZ>>3))
  {
    while (offset<length && !BS->EOI)
    {
      *(buffer+offset)=(unsigned char)ScBSGetBits(BS,8);
      offset++;
    }
    *ret_length=offset;
    if (BS->EOI)
      return(ScErrorEndBitstream);
    else
      return(ScErrorNone);
  }
  else if (BS->bufftop>0)
  {
    ScBSByteAlign(BS);
    shift=BS->shift;
    /* remove bytes already in OutBuff and InBuff */
    for (i=0; shift>0 && offset<length; i++, shift-=8, offset++)
    {
      *(buffer+offset)=(unsigned char)(BS->OutBuff>>(SC_BITBUFFSZ-8));
      if (shift<=SC_BITBUFFSZ) /* only bits in OutBuff */
        BS->OutBuff <<= 8;
      else
      {
        BS->OutBuff=(BS->OutBuff<<8)|(BS->InBuff>>(SC_BITBUFFSZ-8));
        BS->InBuff<<=8;
      }
    }
    BS->shift=shift;
    BS->CurrentBit+=i*8;
  }
  while (offset<length)
  {
    i=BS->bufftop-BS->buffp;
    if (offset+i>length)
      i=length-offset;
    memcpy(buffer+offset, BS->buff+BS->buffp, i);
    offset+=i;
    BS->buffp+=i;
    BS->CurrentBit+=i<<3;
    _SlibDebug(_VERIFY_,
         if ((BS->CurrentBit+BS->shift)/8!=BS->buffstart+BS->buffp)
         {
           printf("ScBSGetBytes() (CurrentBit+shift)/8 (%d) <> buffstart+buffp (%d)\n", (BS->CurrentBit+BS->shift)/8, BS->buffstart+BS->buffp);
           BS->EOI = TRUE;
           return(ScErrorEndBitstream);
         } );
    if (offset<length)
      if (!sc_BSGetData(BS))
      {
        BS->EOI = TRUE;
        *ret_length=offset;
        return(ScErrorEndBitstream);
      }
  }
  *ret_length=offset;
  return(ScErrorNone);
}

/*
** ScBSGetBits()
** Return the next length bits from the bitstream
*/
ScBitString_t ScBSGetBits(ScBitstream_t *BS, u_int length)
{
  ScBitString_t val;

  _SlibDebug(_DEBUG_ && _debug_getbits,
             printf("ScBSGetBits(%d): Byte offset = 0x%X shift=%d ",
                             length, ScBSBytePosition(BS), BS->shift) );
  _SlibDebug(_VERIFY_ && length>SC_BITBUFFSZ,
         printf("ScBSPeekBits(%d) length > SC_BITBUFFSZ\n", length) );
  _SlibDebug(_WARN_ && length==0,
         printf("ScBSGetBits(%d) length==0\n", length) );

#if FILTER_SUPPORT
  if (BS->FilterCallback && BS->InFilterCallback==FALSE
      && BS->FilterBit<(BS->CurrentBit+length))
  {
    const int tmp=BS->FilterBit-BS->CurrentBit;
    BS->InFilterCallback=TRUE;
    _SlibDebug(_DEBUG_,
          printf("FilterCallback at bitpos=0x%X bytepos=0x%X GetBits(%d/%d)\n",
                  ScBSBitPosition(BS), ScBSBytePosition(BS),
                  tmp, length-tmp) );
    if (tmp>0)
    {
      length-=tmp;
      val=ScBSGetBits(BS,tmp)<<length;
    }
    else
      val=0;
    _SlibDebug(_VERIFY_ && (BS->FilterBit != BS->CurrentBit),
          printf("ScBSGetBits() FilterCallback not at FilterBit (%d) CurrentBit=%d\n", BS->FilterBit, BS->CurrentBit) );

    BS->FilterBit=(BS->FilterCallback)(BS);
    BS->InFilterCallback=FALSE;
  }
  else
    val=0;
  if (!length)
    return(val);
#else
  if (!length)
    return(0);
#endif
  ScBSPreLoad(BS, length);
  if (BS->shift<length) /* End of Input - ran out of bits */
  {
#if FILTER_SUPPORT
    val |= BS->OutBuff >> (SC_BITBUFFSZ-length); /* return whatever's there */
#else
    val = BS->OutBuff >> (SC_BITBUFFSZ-length); /* return whatever's there */
#endif
    BS->shift=0;
    BS->OutBuff=0;
    return(val);
  }
  else
  {
    _SlibDebug(_VERIFY_ && BS->shift<length,
     printf("ScBSGetBits(%d) shift (%d) < length (%d) at byte pos %d (0x%X)\n",
             length, BS->shift, length, BS->CurrentBit/8, BS->CurrentBit/8) );
    if (length!=SC_BITBUFFSZ)
    {
      const ScBitBuff_t OutBuff=BS->OutBuff;
      const ScBitString_t InBuff=BS->InBuff;
      const int shift=BS->shift;
#if FILTER_SUPPORT
      val |= OutBuff >> (SC_BITBUFFSZ-length);
#else
      val = OutBuff >> (SC_BITBUFFSZ-length);
#endif
      BS->OutBuff=(OutBuff<<length)|(InBuff>>(SC_BITBUFFSZ-length));
      BS->InBuff = InBuff<<length;
      BS->shift=shift-length;
      BS->CurrentBit += length;
    }
    else /* length == SC_BITBUFFSZ */
    {
      val = BS->OutBuff;
      BS->OutBuff = BS->InBuff;
      BS->InBuff = 0;
      BS->shift-=SC_BITBUFFSZ;
      BS->CurrentBit += SC_BITBUFFSZ;
    }
  }
  _SlibDebug(_DEBUG_ && _debug_getbits, printf(" Return 0x%lX\n",val) );
  return(val);
}

/*
** ScBSGetBitsW()
** Return the next length bits from the bitstream
*/
ScBitString_t ScBSGetBitsW(ScBitstream_t *BS, u_int length)
{
  ScBitString_t val;

  _SlibDebug(_DEBUG_ && _debug_getbits,
             printf("ScBSGetBitsW(%d): Byte offset = 0x%X shift=%d ",
                             length, ScBSBytePosition(BS), BS->shift) );
  _SlibDebug(_VERIFY_ && length>SC_BITBUFFSZ,
         printf("ScBSPeekBits(%d) length > SC_BITBUFFSZ\n", length) );
  _SlibDebug(_WARN_ && length==0,
         printf("ScBSGetBitsW(%d) length==0\n", length) );

#if FILTER_SUPPORT
  if (BS->FilterCallback && BS->InFilterCallback==FALSE
      && BS->FilterBit<(BS->CurrentBit+length))
  {
    const int tmp=BS->FilterBit-BS->CurrentBit;
    BS->InFilterCallback=TRUE;
    _SlibDebug(_DEBUG_,
          printf("FilterCallback at bitpos=0x%X bytepos=0x%X GetBits(%d/%d)\n",
                  ScBSBitPosition(BS), ScBSBytePosition(BS),
                  tmp, length-tmp) );
    if (tmp>0)
    {
      length-=tmp;
      val=ScBSGetBitsW(BS,tmp)<<length;
    }
    else
      val=0;
    _SlibDebug(_VERIFY_ && (BS->FilterBit != BS->CurrentBit),
          printf("ScBSGetBits() FilterCallback not at FilterBit (%d) CurrentBit=%d\n", BS->FilterBit, BS->CurrentBit) );

    BS->FilterBit=(BS->FilterCallback)(BS);
    BS->InFilterCallback=FALSE;
  }
  else
    val=0;
  if (!length)
    return(val);
#else
  if (!length)
    return(0);
#endif
  ScBSPreLoadW(BS, length);
  if (BS->shift<length) /* End of Input - ran out of bits */
  {
#if FILTER_SUPPORT
    val |= BS->OutBuff >> (SC_BITBUFFSZ-length); /* return whatever's there */
#else
    val = BS->OutBuff >> (SC_BITBUFFSZ-length); /* return whatever's there */
#endif
    BS->shift=0;
    BS->OutBuff=0;
    return(val);
  }
  else
  {
    _SlibDebug(_VERIFY_ && BS->shift<length,
     printf("ScBSGetBits(%d) shift (%d) < length (%d) at byte pos %d (0x%X)\n",
             length, BS->shift, length, BS->CurrentBit/8, BS->CurrentBit/8) );
    if (length!=SC_BITBUFFSZ)
    {
      const ScBitBuff_t OutBuff=BS->OutBuff;
      const ScBitString_t InBuff=BS->InBuff;
      const int shift=BS->shift;
#if FILTER_SUPPORT
      val |= OutBuff >> (SC_BITBUFFSZ-length);
#else
      val = OutBuff >> (SC_BITBUFFSZ-length);
#endif
      BS->OutBuff=(OutBuff<<length)|(InBuff>>(SC_BITBUFFSZ-length));
      BS->InBuff = InBuff<<length;
      BS->shift=shift-length;
      BS->CurrentBit += length;
    }
    else /* length == SC_BITBUFFSZ */
    {
      val = BS->OutBuff;
      BS->OutBuff = BS->InBuff;
      BS->InBuff = 0;
      BS->shift-=SC_BITBUFFSZ;
      BS->CurrentBit += SC_BITBUFFSZ;
    }
  }
  _SlibDebug(_DEBUG_ && _debug_getbits, printf(" Return 0x%lX\n",val) );
  return(val);
}


/*
** ScBSGetBit()
** Put a single bit onto the bitstream
*/
int ScBSGetBit(ScBitstream_t *BS)
{
  int val;
  _SlibDebug(_DEBUG_ && _debug_getbits,
    printf("ScBSGetBit(): Byte offset = 0x%X shift=%d ",
                                         ScBSBytePosition(BS), BS->shift) );

#if FILTER_SUPPORT
  if (BS->FilterCallback && BS->InFilterCallback==FALSE
      && BS->FilterBit==BS->CurrentBit)
  {
    BS->InFilterCallback=TRUE;
    _SlibDebug(_DEBUG_,
          printf("FilterCallback at bitpos=0x%X bytepos=0x%X\n",
                  ScBSBitPosition(BS), ScBSBytePosition(BS)) );
    BS->FilterBit=(BS->FilterCallback)(BS);
    BS->InFilterCallback=FALSE;
  }
#endif

  ScBSPreLoad(BS, 1);
  if (!BS->EOI)
  {
    const ScBitBuff_t OutBuff=BS->OutBuff;
    val=(int)(OutBuff>>(SC_BITBUFFSZ-1));
    if (--BS->shift>=SC_BITBUFFSZ)
    {
      const ScBitBuff_t InBuff=BS->InBuff;
      BS->OutBuff = (OutBuff<<1)|(InBuff >> (SC_BITBUFFSZ-1));
      BS->InBuff = InBuff<<1;
    }
    else
      BS->OutBuff = OutBuff<<1;
    BS->CurrentBit++;
  }
  else
    val=0;
  _SlibDebug(_DEBUG_ && _debug_getbits, printf(" Return 0x%lX\n",val) );
  return(val);
}

/*
** ScBSPutBits()
** Put a number of bits onto the bitstream
*/
ScStatus_t ScBSPutBits(ScBitstream_t *BS, ScBitString_t bits, u_int length)
{
  ScStatus_t stat;
  const int newshift=BS->shift+length;

  if (length<SC_BITBUFFSZ)
    bits &= ((ScBitString_t)1<<length)-1;
  _SlibDebug(_DEBUG_, printf("ScBSPutBits(0x%lX, %d): Byte offset = 0x%X ",
                                       bits, length, ScBSBytePosition(BS)) );
  _SlibDebug(_VERIFY_&&length<SC_BITBUFFSZ && bits>=((ScBitString_t)1<<length),
            printf("ScBSPutBits(%d): bits (0x%X) to large\n", length, bits) );
  if (!length)
    return(NoErrors);
  else if (newshift < SC_BITBUFFSZ)
  {
    BS->OutBuff=(BS->OutBuff<<length) | bits;
    BS->shift=newshift;
    stat=NoErrors;
  }
  else if (newshift == SC_BITBUFFSZ)
  {
    stat=sc_BSStoreDataWord(BS, (BS->OutBuff<<length)|bits);
    BS->OutBuff=0;
    BS->shift=0;
  }
  else
  {
    const int bitsavail=SC_BITBUFFSZ-BS->shift;
    const int bitsleft=length-bitsavail;
    const ScBitString_t outbits=bits>>bitsleft;
    _SlibDebug(_DEBUG_, printf("ScBSPutBits(%d) Storing 0x%lX\n",
                               length, (BS->OutBuff<<bitsavail)|outbits) );
    stat=sc_BSStoreDataWord(BS, (BS->OutBuff<<bitsavail)|outbits);
    _SlibDebug(_VERIFY_ && (bitsavail<=0 || bitsleft>=SC_BITBUFFSZ),
               printf("ScBSPutBits(%d) bad bitsleft (%d)\n",
               bitsleft) );
    _SlibDebug(_VERIFY_ && (bitsavail<=0 || bitsavail>=SC_BITBUFFSZ),
               printf("ScBSPutBits(%d) bad bitsavail (%d)\n", bitsavail) );
#if 1
    BS->OutBuff=bits & (((ScBitBuff_t)1<<bitsleft)-1);
#else
    BS->OutBuff=bits-(outbits<<bitsleft);
#endif
    BS->shift=bitsleft;
  }
  BS->CurrentBit += length;
  return(stat);
}

/*
** ScBSPutBytes()
** Put a number of bits onto the bitstream
*/
ScStatus_t ScBSPutBytes(ScBitstream_t *BS, u_char *buffer, u_int length)
{
  ScStatus_t stat=NoErrors;
  _SlibDebug(_VERIFY_, printf("ScBSPutBytes(length=%d): Byte offset = 0x%X