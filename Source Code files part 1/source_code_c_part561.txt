_MACHINE, strStandAlone );

		tstring strNodeTypes( strMMCKey );
		strNodeTypes += _T("\\NodeTypes");
		CUDDIRegistryKey::Create( HKEY_LOCAL_MACHINE, strNodeTypes );
		//
		// No NodeTypes to register
		// We do not allow extensions of our nodes
		//

		//
		// Register as a dynamic extension to computer management
		//
		tstring strExtKey( g_szMMCBasePath );
		strExtKey += _T("\\NodeTypes\\");
		strExtKey += g_szServerAppsGuid;
		strExtKey += _T("\\Dynamic Extensions");
		CUDDIRegistryKey dynamicExtensions( strExtKey );
		dynamicExtensions.SetValue( wszCLSID, szSnapInName );
		dynamicExtensions.Close();

		//
		// Register as a namespace extension to computer management
		//
		tstring strNameSpaceExtensionKey( g_szMMCBasePath );
		strNameSpaceExtensionKey += _T("\\NodeTypes\\");
		strNameSpaceExtensionKey += g_szServerAppsGuid;
		strNameSpaceExtensionKey += _T("\\Extensions\\NameSpace");

		CUDDIRegistryKey hkeyNameSpace( strNameSpaceExtensionKey );
		hkeyNameSpace.SetValue( wszCLSID, szSnapInName );
		hkeyNameSpace.Close();

		CoTaskMemFree( wszCLSID );
		CoTaskMemFree( wszCLSIDAbout );
		return hr;
	}
	catch( ... )
	{
		return E_FAIL;
	}
}

STDAPI DllUnregisterServer()
{
	LPOLESTR wszCLSID = NULL;
	try
	{
		HRESULT hr = S_OK;

		UnRegisterServer( CLSID_CUDDIServices );
		if( FAILED(hr) )
			return hr;

		UnRegisterServer( CLSID_CSnapinAbout );
		if( FAILED(hr) )
			return hr;

		//
		// Remove \\SnapIns\\ entry
		//
		hr = StringFromCLSID( CLSID_CUDDIServices, &wszCLSID );
		if( FAILED( hr) || ( NULL == wszCLSID ) )
		{
			return hr;
		}

		tstring strMMCKey( g_szMMCBasePath );
		strMMCKey += _T("\\SnapIns\\");
		strMMCKey += wszCLSID;
		
		CUDDIRegistryKey::DeleteKey( HKEY_LOCAL_MACHINE, strMMCKey );

		//
		// Remove \\Dynamic Extensions key
		//
		tstring strExtKey( g_szMMCBasePath );
		strExtKey += _T("\\NodeTypes\\");
		strExtKey += g_szServerAppsGuid;
		strExtKey += _T("\\Dynamic Extensions");
		CUDDIRegistryKey dynamicExtensions( strExtKey );
		dynamicExtensions.DeleteValue( wszCLSID );
		dynamicExtensions.Close();

		//
		// Delete \\NodeTypes\\...\\Extensions\\Namespace Value
		//
		tstring strNameSpaceExtensionKey( g_szMMCBasePath );
		strNameSpaceExtensionKey += _T("\\NodeTypes\\");
		strNameSpaceExtensionKey += g_szServerAppsGuid;
		strNameSpaceExtensionKey += _T("\\Extensions\\NameSpace");

		CUDDIRegistryKey hkeyNameSpace( strNameSpaceExtensionKey );
		hkeyNameSpace.DeleteValue( wszCLSID );
		hkeyNameSpace.Close();

		CoTaskMemFree( wszCLSID );
		return S_OK;
	}
	catch(...)
	{
		CoTaskMemFree( wszCLSID );
		return E_FAIL;
	}

}

//
// Remove the component from the registry.
//
LONG UnRegisterServer( const CLSID& clsid )
{
    LPOLESTR wszCLSID = NULL;
	try
	{
		//
		// Get CLSID
		//
		HRESULT hr = StringFromCLSID( clsid, &wszCLSID );
		if( FAILED(hr) || ( NULL == wszCLSID ) )
		{
			return hr;
		}

		//
		// Build the key CLSID\\{...}
		//
		wstring wstrKey( L"CLSID\\" );
		wstrKey += wszCLSID;

		//
		// Delete the CLSID Key - CLSID\{...}
		//
		CUDDIRegistryKey::DeleteKey( HKEY_CLASSES_ROOT, wstrKey );
	}
	catch( ... )
	{
		//
		// Free memory.
		//
	    CoTaskMemFree( wszCLSID );
		return E_OUTOFMEMORY;
	}

	//
    // Free memory.
	//
    CoTaskMemFree( wszCLSID );
    return S_OK ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\mmc\dataobj.h ===
#ifndef _SAMPDATAOBJECT_H_
#define _SAMPDATAOBJECT_H_

#include <mmc.h>
#include "delebase.h"

class CDataObject : public IDataObject
{
private:
    ULONG				m_cref;
    MMC_COOKIE			m_lCookie;
    DATA_OBJECT_TYPES   m_context;
    
public:
    CDataObject( MMC_COOKIE cookie, DATA_OBJECT_TYPES context );
    ~CDataObject();
    
    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    ///////////////////////////////
    // IDataObject methods 
    ///////////////////////////////
    STDMETHODIMP GetDataHere ( FORMATETC *pformatetc, STGMEDIUM *pmedium );
    
	//
    // The rest are not implemented
	//
    STDMETHODIMP GetData (LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium)
    { return E_NOTIMPL; };
    
    STDMETHODIMP EnumFormatEtc (DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc)
    { return E_NOTIMPL; };
    
    STDMETHODIMP QueryGetData (LPFORMATETC lpFormatetc) 
    { return E_NOTIMPL; };
    
    STDMETHODIMP GetCanonicalFormatEtc (LPFORMATETC lpFormatetcIn, LPFORMATETC lpFormatetcOut)
    { return E_NOTIMPL; };
    
    STDMETHODIMP SetData (LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium, BOOL bRelease)
    { return E_NOTIMPL; };
    
    STDMETHODIMP DAdvise (LPFORMATETC lpFormatetc, DWORD advf, LPADVISESINK pAdvSink, LPDWORD pdwConnection)
    { return E_NOTIMPL; };
    
    STDMETHODIMP DUnadvise (DWORD dwConnection)
    { return E_NOTIMPL; };
    
    STDMETHODIMP EnumDAdvise (LPENUMSTATDATA* ppEnumAdvise)
    { return E_NOTIMPL; };
    
    ///////////////////////////////
    // Custom Methods
    ///////////////////////////////
    
    CDelegationBase *GetBaseNodeObject() 
	{
        return (CDelegationBase *)m_lCookie;
    }
    
    DATA_OBJECT_TYPES GetContext() 
	{
        return m_context;
    }
    
public:

	//
    // Clipboard formats
	//
    static UINT s_cfSZNodeType;
    static UINT s_cfDisplayName;
    static UINT s_cfNodeType;
    static UINT s_cfSnapinClsid;
    static UINT s_cfInternal;
    
};

HRESULT ExtractFromDataObject( IDataObject *lpDataObject, UINT cf, ULONG cb, HGLOBAL *phGlobal );
CDataObject* GetOurDataObject( IDataObject *lpDataObject );
BOOL IsMMCMultiSelectDataObject( IDataObject *lpDataObject );

#endif _SAMPDATAOBJECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\mmc\localres.h ===
#ifndef __LocalResource_H__
#define __LocalResource_H__

#define INDEX_NONE          -1
#define INDEX_WEBSERVER		0
#define INDEX_DBSERVER		1
#define INDEX_UDDISERVICES  2
#define INDEX_OPENFOLDER	5

#endif // __LocalResource_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\mmc\dataobj.cpp ===
#include "dataobj.h"
#include "guids.h"
#include "delebase.h"

//
// This is the minimum set of clipboard formats we must implement.
// MMC uses these to get necessary information from our snapin about
// our nodes.
//

//
// We need to do this to get around MMC.IDL - it explicitly defines
// the clipboard formats as WCHAR types...
//
#define _T_CCF_DISPLAY_NAME _T("CCF_DISPLAY_NAME")
#define _T_CCF_NODETYPE _T("CCF_NODETYPE")
#define _T_CCF_SZNODETYPE _T("CCF_SZNODETYPE")
#define _T_CCF_SNAPIN_CLASSID _T("CCF_SNAPIN_CLASSID")

#define _T_CCF_INTERNAL_SNAPIN _T("{2479DB32-5276-11d2-94F5-00C04FB92EC2}")

//
// These are the clipboard formats that we must supply at a minimum.
// mmc.h actually defined these. We can make up our own to use for
// other reasons. We don't need any others at this time.
//
UINT CDataObject::s_cfDisplayName = RegisterClipboardFormat(_T_CCF_DISPLAY_NAME);
UINT CDataObject::s_cfNodeType    = RegisterClipboardFormat(_T_CCF_NODETYPE);
UINT CDataObject::s_cfSZNodeType  = RegisterClipboardFormat(_T_CCF_SZNODETYPE);
UINT CDataObject::s_cfSnapinClsid = RegisterClipboardFormat(_T_CCF_SNAPIN_CLASSID);
UINT CDataObject::s_cfInternal    = RegisterClipboardFormat(_T_CCF_INTERNAL_SNAPIN);

CDataObject::CDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES context)
	: m_lCookie(cookie)
	, m_context(context)
	, m_cref(0)
{
}

CDataObject::~CDataObject()
{
}

///////////////////////
// IUnknown implementation
///////////////////////
STDMETHODIMP CDataObject::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if( !ppv )
        return E_FAIL;

    *ppv = NULL;

    if( IsEqualIID(riid, IID_IUnknown) )
        *ppv = static_cast<IDataObject *>(this);
    else if( IsEqualIID( riid, IID_IDataObject ) )
        *ppv = static_cast<IDataObject *>(this);

    if( *ppv )
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CDataObject::AddRef()
{
    return InterlockedIncrement( (LONG *)&m_cref );
}

STDMETHODIMP_(ULONG) CDataObject::Release()
{
    if( 0 == InterlockedDecrement( (LONG *) &m_cref ) )
    {
        delete this;
        return 0;
    }

    return m_cref;
}

/////////////////////////////////////////////////////////////////////////////
// IDataObject implementation
//
HRESULT CDataObject::GetDataHere(
                                 FORMATETC *pFormatEtc,     // [in]  Pointer to the FORMATETC structure
                                 STGMEDIUM *pMedium         // [out] Pointer to the STGMEDIUM structure
                                 )
{
	if( ( NULL == pFormatEtc ) || ( NULL == pMedium ) )
	{
		return E_INVALIDARG;
	}

	const CLIPFORMAT cf = pFormatEtc->cfFormat;
    IStream *pStream = NULL;

    HRESULT hr = CreateStreamOnHGlobal( pMedium->hGlobal, FALSE, &pStream );
    if( FAILED(hr) )
        return hr;                       // Minimal error checking

    hr = DV_E_FORMATETC;                 // Unknown format

	CDelegationBase *base = GetBaseNodeObject();
	if( NULL == base )
	{
		pStream->Release();
		return E_FAIL;
	}

    if( s_cfDisplayName == cf )
	{
        const _TCHAR *pszName = base->GetDisplayName();
		if( NULL == pszName )
		{
			pStream->Release();
			return E_OUTOFMEMORY;
		}

		//
        // Get length of original string and convert it accordingly
		//
        ULONG ulSizeofName = lstrlen( pszName );

		//
		// Count null character
		//
        ulSizeofName++;
        ulSizeofName *= sizeof(WCHAR);

        hr = pStream->Write(pszName, ulSizeofName, NULL);
    }
	else if( s_cfNodeType == cf )
	{
        const GUID *pGUID = (const GUID *)&base->getNodeType();

        hr = pStream->Write(pGUID, sizeof(GUID), NULL);
    }
	else if( s_cfSZNodeType == cf )
	{
        LPOLESTR pszGuid = NULL;
        hr = StringFromCLSID( base->getNodeType(), &pszGuid );

        if( SUCCEEDED(hr) )
		{
            hr = pStream->Write( pszGuid, wcslen(pszGuid), NULL );
            CoTaskMemFree( pszGuid );
        }
    } 
	else if( s_cfSnapinClsid == cf )
	{
        const GUID *pGUID = NULL;
        pGUID = &CLSID_CUDDIServices;
        hr = pStream->Write( pGUID, sizeof(GUID), NULL );
    }
	else if( s_cfInternal == cf )
	{
		//
        // We are being asked to get our this pointer from the IDataObject interface
        // only our own snap-in objects will know how to do this.
		//
        CDataObject *pThis = this;
        hr = pStream->Write( &pThis, sizeof(CDataObject*), NULL );
    }

    pStream->Release();

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// Global helper functions to help work with dataobjects and
// clipboard formats


//---------------------------------------------------------------------------
//  Returns the current object based on the s_cfInternal clipboard format
//
CDataObject* GetOurDataObject( LPDATAOBJECT lpDataObject )
{
	HRESULT       hr      = S_OK;
    CDataObject *pSDO     = NULL;

	//
	// Check to see if the data object is a special data object.
	//
	if( IS_SPECIAL_DATAOBJECT( lpDataObject ) )
	{
		//
		//Code for handling a special data object goes here.
		//
		
		// 
		// We do not handle special data objects, so we exit if we get one.
		//
		return NULL;
	}

    STGMEDIUM stgmedium = { TYMED_HGLOBAL,  NULL  };
    FORMATETC formatetc = { ( CLIPFORMAT ) CDataObject::s_cfInternal, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };

	//
    // Allocate memory for the stream
	//
    stgmedium.hGlobal = GlobalAlloc( GMEM_SHARE, sizeof(CDataObject *) );

    if( !stgmedium.hGlobal )     
	{
        hr = E_OUTOFMEMORY;
    }

    if( SUCCEEDED(hr) )
	{
		//
        // Attempt to get data from the object
		//
        hr = lpDataObject->GetDataHere( &formatetc, &stgmedium );
	}

	//
    // stgmedium now has the data we need
	//
    if( SUCCEEDED(hr) )  
	{
        pSDO = *(CDataObject **)(stgmedium.hGlobal);
    }

	//
    // If we have memory free it
	//
    if( stgmedium.hGlobal )
        GlobalFree(stgmedium.hGlobal);

    return pSDO;

} // end GetOurDataObject()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\mmc\delebase.cpp ===
#include "delebase.h"

const GUID CDelegationBase::thisGuid = { 0x786c6f77, 0x6be7, 0x11d3, {0x91, 0x56, 0x0, 0xc0, 0x4f, 0x65, 0xb3, 0xf9} };
// {786C6F77-6BE7-11d3-9156-00C04F65B3F9}
//DEFINE_GUID(<<name>>, 
//0x786c6f77, 0x6be7, 0x11d3, 0x91, 0x56, 0x0, 0xc0, 0x4f, 0x65, 0xb3, 0xf9);

HBITMAP CDelegationBase::m_pBMapSm = NULL;
HBITMAP CDelegationBase::m_pBMapLg = NULL;

//==============================================================
//
// CDelegationBase implementation
//
//
CDelegationBase::CDelegationBase() 
: m_bExpanded(FALSE)
, m_wstrHelpFile(L"")
, m_bIsExtension(FALSE)
, m_hsiParent( 0 )
, m_hsiThis( 0 )
{ 
    if( ( NULL == m_pBMapSm ) || ( NULL == m_pBMapLg ) )
        LoadBitmaps(); 
}

CDelegationBase::~CDelegationBase() 
{ 
}

//
// CDelegationBase::AddImages sets up the collection of images to be displayed
// by the IComponent in the result pane as a result of its MMCN_SHOW handler
//
HRESULT CDelegationBase::OnAddImages(IImageList *pImageList, HSCOPEITEM hsi) 
{
    return pImageList->ImageListSetStrip((long *)m_pBMapSm, // pointer to a handle
        (long *)m_pBMapLg, // pointer to a handle
        0, // index of the first image in the strip
        RGB(0, 128, 128)  // color of the icon mask
        );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\mmc\delebase.h ===
#ifndef _BRANCHES_H
#define _BRANCHES_H

#include <mmc.h>
#include <crtdbg.h>
#include "globals.h"
#include "resource.h"
#include "localres.h"
#include "uddi.h"

class CComponent;
class CComponentData;

class CDelegationBase
{
public:
    CDelegationBase();
    virtual ~CDelegationBase();

    virtual const _TCHAR *GetDisplayName( int nCol = 0 ) = 0;
    virtual const GUID & getNodeType(){ _ASSERT(FALSE); return IID_NULL; }

    virtual const LPARAM GetCookie(){ return reinterpret_cast<LPARAM>(this); }
    virtual const int GetBitmapIndex() = 0;
    virtual HRESULT GetResultViewType( LPOLESTR *ppViewType, long *pViewOptions ) { return S_FALSE; }
    virtual void SetScopeItemValue( HSCOPEITEM hscopeitem ) { m_hsiThis = hscopeitem; }
	virtual HSCOPEITEM GetScopeItemValue() { return m_hsiThis; }
    virtual HSCOPEITEM GetParentScopeItem() { return m_hsiParent; }
	virtual void SetParentScopeItem( HSCOPEITEM hscopeitem ) { m_hsiParent = hscopeitem; }
	virtual BOOL IsDirty() { return FALSE; }
	virtual HRESULT Load( IStream *pStm ){ return S_OK; }
	virtual HRESULT Save( IStream *pStm, BOOL fClearDirty ){ return S_OK; }
	virtual ULONG GetSizeMax(){ return 0UL; }
	virtual const wstring& GetHelpFile()
	{ 
		if( 0 == m_wstrHelpFile.length() )
		{
			WCHAR szWindowsDir[ MAX_PATH ];
			if( 0 == GetWindowsDirectoryW( szWindowsDir, MAX_PATH ) )
				return m_wstrHelpFile;

			m_wstrHelpFile = szWindowsDir;
			m_wstrHelpFile += L"\\Help\\uddi.mmc.chm";
		}

		return m_wstrHelpFile; 
	}

	virtual BOOL IsExtension(){ return m_bIsExtension; }
	virtual void SetExtension( BOOL bExtension ){ m_bIsExtension = bExtension; }
	virtual BOOL HasChildren() { return TRUE; }
	virtual BOOL ChildExists( const WCHAR *pwszName ) { return FALSE; }
	virtual HRESULT RemoveChildren( IConsoleNameSpace *pNS ) { return S_FALSE; }

public:
	//
    // Virtual functions go here (for MMCN_*)
	//
    virtual HRESULT OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent) { return S_FALSE; }
    virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem) { return S_FALSE; }
    virtual HRESULT OnAddImages(IImageList *pImageList, HSCOPEITEM hsi);
    virtual HRESULT OnRename(LPOLESTR pszNewName) { return S_FALSE; }
    virtual HRESULT OnSelect(CComponent *pComponent, IConsole *pConsole, BOOL bScope, BOOL bSelect) { return S_FALSE; }
    virtual HRESULT OnUpdateItem(IConsole *pConsole, long item, ITEM_TYPE itemtype) { return S_FALSE; }
    virtual HRESULT OnRefresh(IConsole *pConsole) { return S_FALSE; }
    virtual HRESULT OnDelete(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsoleComp) { return S_FALSE; }
    virtual HRESULT OnPropertyChange(IConsole *pConsole, CComponent *pComponent) { return S_OK; }
    virtual HRESULT OnAddMenuItems(IContextMenuCallback *pContextMenuCallback, long *pInsertionsAllowed) { return S_FALSE; }
    virtual HRESULT OnMenuCommand(IConsole *pConsole, IConsoleNameSpace *pConsoleNameSpace, long lCommandID, IDataObject *piDataObject) { return S_FALSE; }
    virtual HRESULT OnToolbarCommand(IConsole *pConsole, MMC_CONSOLE_VERB verb, IDataObject *pDataObject) { return S_FALSE; }
    virtual HRESULT OnSetToolbar(IControlbar *pControlbar, IToolbar *pToolbar, BOOL bScope, BOOL bSelect) { return S_FALSE; }
    virtual HRESULT OnShowContextHelp(IDisplayHelp *m_ipDisplayHelp, LPOLESTR helpFile) { return S_FALSE; }
	virtual HRESULT CreatePropertyPages(IPropertySheetCallback *lpProvider, LONG_PTR handle){ return S_FALSE; }
    virtual HRESULT HasPropertySheets() { return S_FALSE; }
    virtual HRESULT GetWatermarks(  HBITMAP *lphWatermark, HBITMAP *lphHeader, HPALETTE *lphPalette, BOOL *bStretch ) { return S_FALSE; }

public:
    static HBITMAP m_pBMapSm;
    static HBITMAP m_pBMapLg;

protected:
    static void LoadBitmaps()
	{
        m_pBMapSm = LoadBitmap( g_hinst, MAKEINTRESOURCE(IDR_SMICONS) );
        m_pBMapLg = LoadBitmap( g_hinst, MAKEINTRESOURCE(IDR_LGICONS) );
    }

    BOOL m_bExpanded;
	wstring m_wstrHelpFile;
	BOOL m_bIsExtension;

	HSCOPEITEM m_hsiParent;
	HSCOPEITEM m_hsiThis;

private:
    static const GUID thisGuid;         
};

#endif // _BRANCHES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\mmc\guids.h ===
// {7503DD53-4B8C-4192-8A63-8679F35D933A}
DEFINE_GUID(CLSID_CUDDIServices, 
0x7503dd53, 0x4b8c, 0x4192, 0x8a, 0x63, 0x86, 0x79, 0xf3, 0x5d, 0x93, 0x3a);

// {EBDA171E-D0C6-41df-BFB3-1DC27786E8DA}
DEFINE_GUID(CLSID_CSnapinAbout,
0xebda171e, 0xd0c6, 0x41df, 0xbf, 0xb3, 0x1d, 0xc2, 0x77, 0x86, 0xe8, 0xda);

DEFINE_GUID(CLSID_CServicesAndApplications,
0x476e6449, 0xaaff, 0x11d0, 0xb9, 0x44, 0x00, 0xc0, 0x4f, 0xd8, 0xd5, 0xb0);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\mmc\net_bindingtemplate_tmodelinstanceinfos_get.h ===
// net_bindingTemplate_tModelInstanceInfos_get.h : Declaration of the net_bindingTemplate_tModelInstanceInfos_get class

#ifndef __NET_BINDINGTEMPLATE_TMODELINSTANCEINFOS_GET_H_
#define __NET_BINDINGTEMPLATE_TMODELINSTANCEINFOS_GET_H_

class net_bindingTemplate_tModelInstanceInfos_getAccessor
{
public:
	LONG m_RETURNVALUE;
	TCHAR m_bindingKey[ 100 ];
	LARGE_INTEGER m_colinstanceID;
	TCHAR m_coltModelKey[ 100 ];
	TCHAR m_coloverviewURL[4001];
	TCHAR m_colinstanceParms[4001];
	CComBSTR m_connectionString;

BEGIN_PARAM_MAP(net_bindingTemplate_tModelInstanceInfos_getAccessor)
	SET_PARAM_TYPE(DBPARAMIO_OUTPUT)
	COLUMN_ENTRY(1, m_RETURNVALUE)
	SET_PARAM_TYPE(DBPARAMIO_INPUT)
	COLUMN_ENTRY(2, m_bindingKey)
END_PARAM_MAP()

BEGIN_COLUMN_MAP(net_bindingTemplate_tModelInstanceInfos_getAccessor)
	COLUMN_ENTRY(1, m_colinstanceID)
	COLUMN_ENTRY(2, m_coltModelKey)
	COLUMN_ENTRY(3, m_coloverviewURL)
	COLUMN_ENTRY(4, m_colinstanceParms)
END_COLUMN_MAP()

DEFINE_COMMAND(net_bindingTemplate_tModelInstanceInfos_getAccessor, _T("{ ? = CALL dbo.net_bindingTemplate_tModelInstanceInfos_get;1 (?) }"))

	// You may wish to call this function if you are inserting a record and wish to
	// initialize all the fields, if you are not going to explicitly set all of them.
	void ClearRecord()
	{
		memset(this, 0, sizeof(*this));
	}
};

class net_bindingTemplate_tModelInstanceInfos_get : public CCommand<CAccessor<net_bindingTemplate_tModelInstanceInfos_getAccessor>, CRowset, CMultipleResults >
{
public:
	HRESULT Open()
	{
		HRESULT		hr;

		hr = OpenDataSource();
		if( FAILED(hr) )
			return hr;

		return OpenRowset();
	}
	HRESULT OpenDataSource()
	{
		HRESULT		hr;
		CDataSource db;

		hr = db.OpenFromInitializationString( m_connectionString );
		if( FAILED(hr) )
			return hr;

		return m_session.Open(db);
	}
	HRESULT OpenRowset()
	{
		return __super::Open(m_session, NULL, NULL, 0, DBGUID_DBSQL, false);
	}
	CSession	m_session;
};

#endif // __NET_BINDINGTEMPLATE_TMODELINSTANCEINFOS_GET_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\mmc\globals.h ===
#pragma once

//#include <commctrl.h>
#include <mmc.h>
#include <tchar.h>
#include <iostream>
#include <sstream>

#ifndef STRINGS_ONLY
		
enum UPDATE_VIEWS_HINT {UPDATE_SCOPEITEM = 1000, DELETE_SCOPEITEM, UPDATE_RESULTITEM, DELETE_RESULTITEM}; 
enum ITEM_TYPE {SCOPE = 10, RESULT}; 

#define IDM_BUTTON1    0x100
#define IDM_BUTTON2    0x101

extern HINSTANCE g_hinst;
extern ULONG g_uObjects;

#define OBJECT_CREATED InterlockedIncrement( (long *) &g_uObjects );
#define OBJECT_DESTROYED InterlockedDecrement( (long *) &g_uObjects );

//
// Uncomment the following #define to enable message cracking
//
//#define MMC_CRACK_MESSAGES

void MMCN_Crack(
				BOOL bComponentData,
                IDataObject *pDataObject,
                IComponentData *pCompData,
                IComponent *pComp,
                MMC_NOTIFY_TYPE event,
                LPARAM arg,
                LPARAM param );


#endif

#define ARRAYLEN(x) (sizeof(x) / sizeof((x)[0]))

#define DEBUG_ENTER \
	OutputDebugString( _T("Entering ") ); \
	OutputDebugString( _T(__FUNCTION__) );	 \
	OutputDebugString( _T("...\n") );	 

#define DEBUG_LEAVE \
	OutputDebugString( _T("...Leaving ") ); \
	OutputDebugString( _T(__FUNCTION__) );	 \
	OutputDebugString( _T("\n") );	 

#ifdef UNICODE
#define tstring wstring
#define tstringstream wstringstream
#else
#define tstring string
#define tstringstream stringstream
#endif

//
// Convert wszBuf to upper case in-place (ie, modify the existing string).
//
void ToUpper( WCHAR *wszBuf );

//
// Convert wszBuf to lower case in-place (ie, modify the existing string).
//
void ToLower( WCHAR *wszBuf );

struct PropertyPages
{
	DWORD id;
	DLGPROC dlgproc;
};

class CDelegationBase;

struct DatabaseData
{
	CDelegationBase* pBase;
	TCHAR szServerName[ 256 ];
	TCHAR szInstanceName[ 256 ];
};

LPCTSTR InstanceDisplayName( LPCTSTR szName );
LPCTSTR InstanceRealName( LPCTSTR szName );
_TCHAR* DefaultInstanceDisplayName();

HRESULT IsStandardServer( LPCTSTR szRemoteServer, BOOL *bResult );

#define UDDI_SNAPIN_VERSION				_T( "1.0" )

#define UDDI_RUN						_T( "Run" )
#define UDDI_AUTHENTICATION_MODE		_T( "Security.AuthenticationMode" )
#define UDDI_REQUIRE_SSL				_T( "Security.HTTPS" )
#define UDDI_ADMIN_GROUP				_T( "GroupName.Administrators" )
#define UDDI_COORDINATOR_GROUP			_T( "GroupName.Coordinators" )
#define UDDI_PUBLISHER_GROUP			_T( "GroupName.Publishers" )
#define UDDI_USER_GROUP					_T( "GroupName.Users" )
#define UDDI_TICKET_TIMEOUT				_T( "Security.Timeout" )
#define UDDI_KEY_TIMEOUT				_T( "Security.KeyTimeout" )
#define UDDI_KEY_RESET_DATE				_T( "Security.KeyLastResetDate" )
#define UDDI_KEY_AUTORESET				_T( "Security.KeyAutoReset" )
#define UDDI_DISCOVERY_URL				_T( "DefaultDiscoveryURL" )
#define UDDI_FIND_MAXROWS				_T( "Find.MaxRowsDefault" )
#define UDDI_READER_CXN					_T( "Database.ReaderConnectionString" )
#define UDDI_WRITER_CXN					_T( "Database.WriterConnectionString" )
#define UDDI_EVENTLOG_LEVEL				_T( "Debug.EventLogLevel" )
#define UDDI_FILELOG_LEVEL				_T( "Debug.FileLogLevel" )
#define UDDI_LOG_FILENAME				_T( "Debug.LogFilename" )
#define UDDI_SETUP_DB					_T( "Setup.DBServer" )
#define UDDI_SETUP_WEB					_T( "Setup.WebServer" )
#define UDDI_SETUP_ADMIN				_T( "Setup.Admin" )
#define UDDI_SETUP_DATE					_T( "Setup.Date" )
#define UDDI_SETUP_LANGUAGE				_T( "Setup.Language" )
#define UDDI_SETUP_NAME					_T( "Setup.Name" )
#define UDDI_SETUP_FRAMEWORK_VERSION	_T( "Setup.FrameworkVersion" )
#define UDDI_SETUP_MANUFACTURER			_T( "Setup.Manufacturer" )
#define UDDI_SETUP_VERSION				_T( "Setup.Version" )
#define UDDI_SETUP_LOCATION				_T( "Setup.TargetDir" )
#define UDDI_SITE_KEY					_T( "Site.Key" )
#define UDDI_SITE_NAME					_T( "Site.Name" )
#define UDDI_SITE_DESCRIPTION			_T( "Site.Description" )
#define UDDI_DBSCHEMA_VERSION			_T( "Database.Version" )
#define UDDI_SITE_WEBSERVERS			_T( "Site.WebServers" )
//#define UDDI_SITE_WEBSERVERS				_T( "Site.Readers" )
//#define UDDI_SITE_WEBSERVERS				_T( "Site.Writers" )


const LPCTSTR UDDI_OPERATOR_NAME	= _T("Operator");
const LPCTSTR g_szMMCBasePath		= _T("Software\\Microsoft\\MMC");
const LPCTSTR g_szSnapins			= _T("Snapins");
const LPCTSTR g_szNameString		= _T("NameString");
const LPCTSTR g_szNameStringInd		= _T("NameStringIndirect");
const LPCTSTR g_szProvider			= _T("Provider");
const LPCTSTR g_szVersion			= _T("Version");
const LPCTSTR g_szStandAlone		= _T("StandAlone");
const LPCTSTR g_szNodeTypes			= _T("NodeTypes");
const LPCTSTR g_szAbout				= _T("About");
const LPCTSTR g_szExtensions		= _T("Extensions");
const LPCTSTR g_szExtensionsView	= _T("Extensions\\View");
const LPCTSTR g_szNameSpace			= _T("NameSpace");
const LPCTSTR g_szServerAppsGuid	= _T("{476e6449-aaff-11d0-b944-00c04fd8d5b0}");
const LPCTSTR g_szUDDIAdminSites	= _T( "Software\\Microsoft\\UDDI\\Admin\\Sites" );
// const LPCTSTR g_szServerAppsLoc   = _T("System\\CurrentControlSet\\Control\\Server Applications");

const LPWSTR g_wszUddiServicesNodeHelp= L"::/default.htm";
const LPWSTR g_wszUddiSiteNodeHelp = L"::/uddi.mmc.site.htm";
const LPWSTR g_wszUddiWebServerNodeHelp = L"::/uddi.mmc.webserver.htm";
const LPWSTR g_wszUddiSiteGeneralPageHelp = L"::/uddi.mmc.sitegeneraltab.htm";
const LPWSTR g_wszUddiRolesPageHelp = L"::/uddi.mmc.siterolestab.htm";
const LPWSTR g_wszUddiSecurityPageHelp = L"::/uddi.mmc.sitesecuritytab.htm";
const LPWSTR g_wszUddiCryptographyHelp = L"::/uddi.mmc.sitecryptography.htm";
const LPWSTR g_wszUddiActiveDirectoryPageHelp = L"::/uddi.mmc.siteactivedirectorytab.htm";
const LPWSTR g_wszUddiAdvancedPageHelp = L"::/uddi.mmc.siteadvancedtab.htm";
const LPWSTR g_wszUddiEditPropertyHelp = L"::/uddi.mmc.editproperty.htm";
const LPWSTR g_wszUddiWebGeneralPageHelp = L"::/uddi.mmc.webgeneraltab.htm"; 
const LPWSTR g_wszUddiLoggingPageHelp = L"::/uddi.mmc.webloggingtab.htm";
const LPWSTR g_wszUddiDatabaseConnectionPageHelp = L"::/uddi.mmc.webdatabaseconnectiontab.htm";
const LPWSTR g_wszUddiAddSiteHelp = L"::/uddi.mmc.addsite.htm";
const LPWSTR g_wszUddiAddWebServerHelp = L"::/uddi.mmc.addsite.htm";
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\mmc\net_businessentity_bindingtemplates_get.h ===
// net_bindings_get.h : Declaration of the net_businessEntity_bindingTemplates_get class

#ifndef __NET_BINDINGS_GET_H_
#define __NET_BINDINGS_GET_H_

class net_businessEntity_bindingTemplates_getAccessor
{
public:
	LONG m_RETURNVALUE;
	TCHAR m_businessKey[ 50 ];
	TCHAR m_colbindingKey[ 50 ];
	TCHAR m_colserviceKey[ 50 ];
	TCHAR m_colURLType[451];
	TCHAR m_colaccessPoint[4001];
	TCHAR m_colhostingRedirector[ 50 ];
	CComBSTR m_connectionString;

BEGIN_PARAM_MAP(net_businessEntity_bindingTemplates_getAccessor)
	SET_PARAM_TYPE(DBPARAMIO_OUTPUT)
	COLUMN_ENTRY(1, m_RETURNVALUE)
	SET_PARAM_TYPE(DBPARAMIO_INPUT)
	COLUMN_ENTRY(2, m_businessKey)
END_PARAM_MAP()

BEGIN_COLUMN_MAP(net_businessEntity_bindingTemplates_getAccessor)
	COLUMN_ENTRY(1, m_colbindingKey)
	COLUMN_ENTRY(2, m_colserviceKey)
	COLUMN_ENTRY(3, m_colURLType)
	COLUMN_ENTRY(4, m_colaccessPoint)
	COLUMN_ENTRY(5, m_colhostingRedirector)
END_COLUMN_MAP()

DEFINE_COMMAND(net_businessEntity_bindingTemplates_getAccessor, _T("{ ? = CALL dbo.net_businessEntity_bindingTemplates_get;1 (?) }"))

	// You may wish to call this function if you are inserting a record and wish to
	// initialize all the fields, if you are not going to explicitly set all of them.
	void ClearRecord()
	{
		memset(this, 0, sizeof(*this));
	}
};

class net_businessEntity_bindingTemplates_get : public CCommand<CAccessor<net_businessEntity_bindingTemplates_getAccessor>, CRowset, CMultipleResults >
{
public:
	HRESULT Open()
	{
		HRESULT		hr;

		hr = OpenDataSource();
		if( FAILED(hr) )
			return hr;

		return OpenRowset();
	}
	HRESULT OpenDataSource()
	{
		HRESULT		hr;
		CDataSource db;
		hr = db.OpenFromInitializationString( m_connectionString );
		if( FAILED(hr) )
			return hr;

		return m_session.Open(db);
	}
	HRESULT OpenRowset()
	{
		return __super::Open(m_session, NULL, NULL, 0, DBGUID_DBSQL, false);
	}
	CSession	m_session;
};

#endif // __NET_BINDINGS_GET_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\mmc\mmccrack.cpp ===
#include <mmc.h>
#include <winuser.h>
#include <tchar.h>

#include "globals.h"

#define MMC_CRACK_MESSAGES 1

static TCHAR *MMCN_CrackVerb(MMC_CONSOLE_VERB verb)
{
	static TCHAR error[64];

	switch( verb ) 
	{
    case MMC_VERB_NONE:
		return _T("NONE");
    case MMC_VERB_OPEN:
		return _T("OPEN");
    case MMC_VERB_COPY:
		return _T("COPY");
    case MMC_VERB_PASTE:
		return _T("PASTE");
    case MMC_VERB_DELETE:
		return _T("DELETE");
    case MMC_VERB_PROPERTIES:
        return _T("PROPERTIES");
    case MMC_VERB_RENAME:
        return _T("RENAME");
    case MMC_VERB_REFRESH:
        return _T("REFRESH");
    case MMC_VERB_PRINT:
        return _T("PRINT");
    case MMC_VERB_CUT:
        return _T("CUT");
    default:
        _sntprintf( error, ARRAYLEN(error) - 1, _T("Unknown verb id %d"), verb );
		error[ ARRAYLEN(error) - 1 ] = NULL;
        return error;
	}
}

void MMCN_Crack(
		BOOL bComponentData,
        IDataObject *pDataObject,
        IComponentData *pCompData,
        IComponent *pComp,
        MMC_NOTIFY_TYPE event,
        LPARAM arg,
        LPARAM param )
{

#ifdef MMC_CRACK_MESSAGES

	TCHAR message[256] = {0};

	if( TRUE == bComponentData )
		OutputDebugString(_T("IComponentData::Notify( "));
	else
		OutputDebugString(_T("IComponent::Notify( "));

	_sntprintf( message, ARRAYLEN( message ), _T( "DataObject: %08p, CompData: %08p, Comp: %08p ) - "), pDataObject, pCompData, pComp );
	message[ ARRAYLEN(message) - 1 ] = NULL;
	OutputDebugString( message );

	switch( event )
	{
	case MMCN_ACTIVATE:
			_sntprintf( message, ARRAYLEN(message) - 1, _T("MMCN_ACTIVATE\n\tActivate: %d\n"), arg);
			break;

	case MMCN_ADD_IMAGES:
			_sntprintf( message, ARRAYLEN(message) - 1, _T("MMCN_ADD_IMAGES\n\tImage List: %08x\n\tScope Item: %08x\n"), arg, param);
			break;

	case MMCN_BTN_CLICK:
			_sntprintf( message, ARRAYLEN(message) - 1, _T("MMCN_BTN_CLICK\n\tVerb: %ws\n"), MMCN_CrackVerb((MMC_CONSOLE_VERB)param));
			break;

	case MMCN_COLUMN_CLICK:
			_sntprintf( message, ARRAYLEN(message) - 1, _T("MMCN_COLUMN_CLICK\n\tColumn: %d\n\tSort Option: %d\n"), arg,       param);
			break;

	case MMCN_COLUMNS_CHANGED:
			_sntprintf( message, ARRAYLEN(message) - 1, _T("MMCN_COLUMNS_CHANGED\n"));
			break;

	case MMCN_CONTEXTHELP:
			_sntprintf( message, ARRAYLEN(message) - 1, _T("MMCN_CONTEXTHELP\n"));
			break;

	case MMCN_CONTEXTMENU:
			_sntprintf( message, ARRAYLEN(message) - 1, _T("MMCN_CONTEXTMENU\n"));
			break;

	case MMCN_CUTORMOVE:
			_sntprintf( message, ARRAYLEN(message) - 1, _T("MMCN_CUTORMOVE\n"));
			break;

	case MMCN_DBLCLICK:
			_sntprintf( message, ARRAYLEN(message) - 1, _T("MMCN_DBLCLICK\n"));
			break;

	case MMCN_DELETE:
			_sntprintf( message, ARRAYLEN(message) - 1, _T("MMCN_DELETE\n"));
			break;

	case MMCN_DESELECT_ALL:
			_sntprintf( message, ARRAYLEN(message) - 1, _T("MMCN_DESELECT_ALL\n"));
			break;

	case MMCN_EXPAND:
			_sntprintf( message, ARRAYLEN(message) - 1, _T("MMCN_EXPAND\n\tExpand: %d\n\tScope Item: %08x\n"), arg, param);
			break;

	case MMCN_EXPANDSYNC:
			_sntprintf( message, ARRAYLEN(message) - 1, _T("MMCN_EXPANDSYNC\n"));
			break;

	case MMCN_FILTERBTN_CLICK:
			_sntprintf( message, ARRAYLEN(message) - 1, _T("MMCN_FILTERBTN_CLICK\n\tColumn: %d\n"), arg);
			break;

	case MMCN_FILTER_CHANGE:
			_sntprintf( message, ARRAYLEN(message) - 1, _T("MMCN_FILTER_CHANGE\n\tColumn: %d\n"), param);
			break;

	case MMCN_HELP:
			_sntprintf( message, ARRAYLEN(message) - 1, _T("MMCN_HELP\n"));
			break;

	case MMCN_INITOCX:
			_sntprintf( message, ARRAYLEN(message) - 1, _T("MMCN_INITOCX\n\tIUnknown: %08x\n"), param);
			break;

	case MMCN_LISTPAD:
			_sntprintf( message, ARRAYLEN(message) - 1, _T("MMCN_LISTPAD\n\tConnect: %d\n"), arg);
			break;

	case MMCN_MENU_BTNCLICK:
			_sntprintf( message, ARRAYLEN(message) - 1, _T("MMCN_MENU_BTNCLICK\n"));
			break;

	case MMCN_MINIMIZED:
			_sntprintf( message, ARRAYLEN(message) - 1, _T("MMCN_MINIMIZED\n\tMinimized: %d\n"), arg);
			break;

	case MMCN_PASTE:
			_sntprintf( message, ARRAYLEN(message) - 1, _T("MMCN_PASTE\n\tCopy: %d\n"), NULL == param );
			break;

	case MMCN_PRELOAD:
			_sntprintf( message, ARRAYLEN(message) - 1, _T("MMCN_PRELOAD\n\tScope Item: %08x\n"), arg);
			break;

	case MMCN_PRINT:
			_sntprintf( message, ARRAYLEN(message) - 1, _T("MMCN_PRINT\n"));
			break;

	case MMCN_PROPERTY_CHANGE:
			_sntprintf( message, ARRAYLEN(message) - 1, _T("MMCN_PROPERTY_CHANGE\n\tScope: %d\n\tArg: %08x\n"), arg, param);
			break;

	case MMCN_QUERY_PASTE:
			_sntprintf( message, ARRAYLEN(message) - 1, _T("MMCN_QUERY_PASTE\n"));
			break;

	case MMCN_REFRESH:
			_sntprintf( message, ARRAYLEN(message) - 1, _T("MMCN_REFRESH\n"));
			break;

	case MMCN_REMOVE_CHILDREN:
			_sntprintf( message, ARRAYLEN(message) - 1, _T("MMCN_REMOVE_CHILDREN\n\tScope Item: %08x\n"), arg);
			break;

	case MMCN_RENAME:
			_sntprintf( message, ARRAYLEN(message) - 1, _T("MMCN_RENAME\n\tNew Name: '%ws'\n"), (LPOLESTR)param);
			break;

	case MMCN_RESTORE_VIEW:
			_sntprintf( message, ARRAYLEN(message) - 1, _T("MMCN_RESTORE_VIEW\n"));
			break;

	case MMCN_SELECT:
			_sntprintf( message, ARRAYLEN(message) - 1, _T("MMCN_SELECT\n\tScope: %d\n\tSelect: %08x\n"), LOWORD(arg), HIWORD(arg));
			break;

	case MMCN_SHOW:
			_sntprintf( message, ARRAYLEN(message) - 1, _T("MMCN_SHOW\n\tShow: %d\n\tScope Item: %08x\n"), arg, param);
			break;

	case MMCN_SNAPINHELP:
			_sntprintf( message, ARRAYLEN(message) - 1, _T("MMCN_SNAPINHELP\n"));
			break;

	case MMCN_VIEW_CHANGE:
			_sntprintf( message, ARRAYLEN(message) - 1, _T("MMCN_VIEW_CHANGE\n\tData: %08x\n\tHint: %08x\n"), arg, param);
			break;
	}
	
	message[ ARRAYLEN(message) - 1 ] = NULL;

	if( message[0] != 0 )
		OutputDebugString(message);
	else
		OutputDebugString(_T("unknown event\n"));
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\mmc\net_config_get.h ===
// net_config_get.h : Declaration of the net_config_get class

#ifndef __NET_CONFIG_GET_H_
#define __NET_CONFIG_GET_H_

class net_config_getAccessor
{
public:
	TCHAR m_configName[257];
	TCHAR m_configValue[8001];
	DBSTATUS m_dwconfigNameStatus;
	DBSTATUS m_dwconfigValueStatus;
	DBLENGTH m_dwconfigNameLength;
	DBLENGTH m_dwconfigValueLength;
	CComBSTR m_connectionString;
	LONG	m_RETURN_VALUE;

BEGIN_COLUMN_MAP(net_config_getAccessor)
	COLUMN_ENTRY_LENGTH_STATUS(1, m_configName, m_dwconfigNameLength, m_dwconfigNameStatus)
	COLUMN_ENTRY_LENGTH_STATUS(2, m_configValue, m_dwconfigValueLength, m_dwconfigValueStatus)
END_COLUMN_MAP()

BEGIN_PARAM_MAP(net_config_getAccessor)
    SET_PARAM_TYPE(DBPARAMIO_OUTPUT)
    COLUMN_ENTRY(1, m_RETURN_VALUE)
END_PARAM_MAP()


DEFINE_COMMAND(net_config_getAccessor, _T("{ ? = CALL dbo.net_config_get }"))

	// You may wish to call this function if you are inserting a record and wish to
	// initialize all the fields, if you are not going to explicitly set all of them.
	void ClearRecord()
	{
		memset(this, 0, sizeof(*this));
	}
};

class net_config_get : public CCommand<CAccessor<net_config_getAccessor>, CRowset, CMultipleResults >
{
public:
	HRESULT Open()
	{
		HRESULT		hr;
		m_configName[ 0 ] = 0x00;
		m_configValue[ 0 ] = 0x00;

		hr = OpenDataSource();
		if( FAILED(hr) )
			return hr;

		return OpenRowset();
	}
	HRESULT OpenDataSource()
	{
		HRESULT		hr;
		CDataSource db;
		hr = db.OpenFromInitializationString( m_connectionString );

		if( FAILED(hr) )
			return hr;

		return m_session.Open(db);
	}
	HRESULT OpenRowset()
	{
		return __super::Open(m_session, NULL, NULL, 0, DBGUID_DBSQL, false);
	}
	CSession	m_session;
};

#endif // __NET_CONFIG_GET_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\mmc\net_config_save.h ===
// net_config_save.h : Declaration of the net_config_save class

#ifndef __NET_CONFIG_SAVE_H_
#define __NET_CONFIG_SAVE_H_

class net_config_saveAccessor
{
public:
	LONG m_RETURNVALUE;
	TCHAR m_configName[257];
	TCHAR m_configValue[8001];
	CComBSTR m_connectionString;

BEGIN_PARAM_MAP(net_config_saveAccessor)
	SET_PARAM_TYPE(DBPARAMIO_OUTPUT)
	COLUMN_ENTRY(1, m_RETURNVALUE)
	SET_PARAM_TYPE(DBPARAMIO_INPUT)
	COLUMN_ENTRY(2, m_configName)
	COLUMN_ENTRY(3, m_configValue)
END_PARAM_MAP()

DEFINE_COMMAND(net_config_saveAccessor, _T("{ ? = CALL dbo.net_config_save;1 (?,?) }"))

	// You may wish to call this function if you are inserting a record and wish to
	// initialize all the fields, if you are not going to explicitly set all of them.
	void ClearRecord()
	{
		memset(this, 0, sizeof(*this));
	}
};

class net_config_save : public CCommand<CAccessor<net_config_saveAccessor> >
{
public:
	HRESULT Open()
	{
		HRESULT		hr;

		hr = OpenDataSource();
		if( FAILED(hr) )
			return hr;

		return OpenRowset();
	}
	HRESULT OpenDataSource()
	{
		HRESULT		hr;
		CDataSource db;
		hr = db.OpenFromInitializationString(m_connectionString);
		if( FAILED(hr) )
			return hr;

		return m_session.Open(db);
	}
	HRESULT OpenRowset()
	{
		return __super::Open(m_session);
	}
	CSession	m_session;
};

#endif // __NET_CONFIG_SAVE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\mmc\objectpicker.h ===
#pragma once

//
// These are the supported types
//
enum ObjectType
{
	OT_User        = 0,
	OT_Computer,
	OT_Group,
	OT_GroupSID
};

bool ObjectPicker( HWND hwndParent, ObjectType oType, PTCHAR szObjectName, ULONG uBufSize, PTCHAR szTargetName = NULL );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\mmc\objectpicker.cpp ===
//--------------------------------------------------------------------------

#ifndef _WIN32_WINNT 
#define _WIN32_WINNT 0x0510
#endif

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
#endif

#define SECURITY_WIN32
#include <windows.h>
#include <tchar.h>
#include <assert.h>
#include <objbase.h>
#include <objsel.h>
#include <Security.h>
#include <sddl.h>
#include <Secext.h>

#include "objectpicker.h"

#define OP_GENERIC_EXCEPTION ( ( DWORD ) 1 )

//--------------------------------------------------------------------------

UINT g_cfDsObjectPicker = RegisterClipboardFormat( CFSTR_DSOP_DS_SELECTION_LIST );

static HRESULT InitObjectPicker( ObjectType oType, 
								 IDsObjectPicker *pDsObjectPicker, 
								 PTCHAR szTarget );

static HRESULT InitObjectPickerForComputers( IDsObjectPicker *pDsObjectPicker );

static HRESULT InitObjectPickerForGroups( IDsObjectPicker *pDsObjectPicker,
										  BOOL fMultiselect,
										  LPCTSTR pszMachineName,
										  BOOL fWantSidPath );

static HRESULT InitObjectPickerForUsers( IDsObjectPicker *pDsObjectPicker,
										 BOOL fMultiselect,
										 LPCTSTR pszMachineName );

static bool ProcessSelectedObjects( IDataObject *pdo,
								    ObjectType oType,
									PTCHAR szObjectName,
									ULONG uBufSize );

//--------------------------------------------------------------------------
// returns true if no errors, false otherwise
// use GetLastError() to get error code
//
bool
ObjectPicker( HWND hwndParent,
			  ObjectType oType,
			  PTCHAR szObjectName,
			  ULONG uBufSize,
			  PTCHAR szTarget )
{
	IDsObjectPicker *pDsObjectPicker = NULL;
	IDataObject *pdo = NULL;
	bool bRet = true; // assume no errors

	try
	{
		HRESULT hr = CoInitializeEx( NULL, COINIT_APARTMENTTHREADED );
		if( FAILED( hr ) )
		{
			throw (DWORD)HRESULT_CODE( hr );
		}

		//
		// Create an instance of the object picker.
		//
		hr = CoCreateInstance( CLSID_DsObjectPicker,
							   NULL,
							   CLSCTX_INPROC_SERVER,
							   IID_IDsObjectPicker,
							   reinterpret_cast<void **>( &pDsObjectPicker ) );

		if( FAILED( hr ) )
		{
			throw (DWORD)HRESULT_CODE(hr);
		}

		//
		// Initialize the object picker instance.
		//
		hr = InitObjectPicker( oType, pDsObjectPicker, szTarget );
		if( FAILED( hr ) )
		{
			throw (DWORD)HRESULT_CODE(hr);
		}

		//
		// Invoke the modal dialog.
		//
		hr = pDsObjectPicker->InvokeDialog( hwndParent, &pdo );
		if( S_OK == hr )
		{
			if( !ProcessSelectedObjects( pdo, oType, szObjectName, uBufSize ))
			{
				throw GetLastError();
			}
		}
		else if( S_FALSE == hr ) // user pressed cancel
		{
			throw (DWORD)OP_GENERIC_EXCEPTION;
		}
		else
		{
			throw (DWORD)HRESULT_CODE(hr);
		}
	}
	catch( DWORD dwErr )
	{
		SetLastError( dwErr );
		bRet = false;
	}
	catch( ... )
	{
		bRet = false;
	}

	//
	// Cleanup.
	//
	if( pdo )
		pdo->Release();

	if( pDsObjectPicker )
		pDsObjectPicker->Release();

	CoUninitialize();

	return bRet;
}


static HRESULT
InitObjectPicker( ObjectType oType, IDsObjectPicker *pDsObjectPicker, PTCHAR szTarget )
{
	if( NULL == pDsObjectPicker )
	{
		return E_INVALIDARG;
	}

	HRESULT hr = E_FAIL;

	if( OT_Computer == oType )
	{
		hr = InitObjectPickerForComputers( pDsObjectPicker );
	}
	else if( OT_User == oType )
	{
		hr = InitObjectPickerForUsers( pDsObjectPicker, FALSE, szTarget );
	}
	else if( OT_Group == oType )
	{
		hr = InitObjectPickerForGroups( pDsObjectPicker, FALSE, szTarget, FALSE );
	}
	else if( OT_GroupSID == oType )
	{
		hr = InitObjectPickerForGroups( pDsObjectPicker, FALSE, szTarget, TRUE );
	}

	return hr;
}

static bool
ProcessSelectedObjects( IDataObject *pdo, ObjectType oType, PTCHAR szObjectName, ULONG uBufSize )
{
	PDS_SELECTION_LIST pDsSelList = NULL;
	bool dwRet = true; // assume ok

	STGMEDIUM stgmedium =
	{
		TYMED_HGLOBAL,
		NULL,
		NULL
	};

	FORMATETC formatetc =
	{
		( CLIPFORMAT ) g_cfDsObjectPicker,
		NULL,
		DVASPECT_CONTENT,
		-1,
		TYMED_HGLOBAL
	};

	try
	{
		//
		// Get the global memory block containing a user's selections.
		//
		HRESULT hr = pdo->GetData( &formatetc, &stgmedium );
		if( FAILED( hr ) )
			throw HRESULT_CODE( hr );

		//
		// Retrieve pointer to DS_SELECTION_LIST structure.
		//
		pDsSelList = ( PDS_SELECTION_LIST ) GlobalLock( stgmedium.hGlobal );
		if( !pDsSelList )
		{
			throw GetLastError();
		}

		//
		// assume there is only 1 item returned because
		// we have multi-select turned off
		//
		if( pDsSelList->cItems != 1 )
		{
			assert( false );
			throw OP_GENERIC_EXCEPTION;
		}

		UINT i = 0;

		//
		// did we request a computer name? If so, we get it directly in the pwzName field
		//
		if( 0 == _tcsicmp( pDsSelList->aDsSelection[i].pwzClass, TEXT( "computer" )) )
		{
			assert( uBufSize > _tcslen( pDsSelList->aDsSelection[i].pwzName ) );
			_tcsncpy( szObjectName, pDsSelList->aDsSelection[i].pwzName, uBufSize - 1 );
			szObjectName[ uBufSize - 1 ] = NULL;
		}
		//
		// user name or group takes some post-processsing...
		//
		else if( 0 == _tcsicmp( pDsSelList->aDsSelection[i].pwzClass, TEXT( "user" ) ) ||
			     0 == _tcsicmp( pDsSelList->aDsSelection[i].pwzClass, TEXT( "group" ) ) )
		{
			//
			// user names from the domain begin with "LDAP:"
			// strip off the prefix info, up to the first "cn="
			// then use the TranslateName API to get the form "domain\user" or "domain\group"
			//
			if( 0 == _tcsnicmp( pDsSelList->aDsSelection[i].pwzADsPath, TEXT( "LDAP:" ), 5 ) )
			{
				if( OT_Group == oType )
				{
					PTCHAR p = _tcsstr( pDsSelList->aDsSelection[i].pwzADsPath, TEXT( "CN=" ) );
					if( NULL == p )
						p = _tcsstr( pDsSelList->aDsSelection[i].pwzADsPath, TEXT( "cn=" ) );

					if( NULL == p )
					{
						assert( false );
						throw OP_GENERIC_EXCEPTION;
					}

					if( !TranslateName( p, NameFullyQualifiedDN, NameSamCompatible, szObjectName, &uBufSize ) )
						throw GetLastError();
				}
				else if( OT_GroupSID == oType )
				{
					//
					// If we are here, then we should expect a string LDAP://SID=<xxxxx>
					//
					if( 0 == _tcsnicmp( pDsSelList->aDsSelection[i].pwzADsPath, TEXT( "LDAP:" ), 5 ) )
					{
						LPTSTR p = _tcsstr( pDsSelList->aDsSelection[i].pwzADsPath, TEXT( "=" ) );
						if( p )
						{
							p++;
							p[ _tcslen( p ) - 1 ] = NULL;

							LPTSTR	szSID = NULL;
							BYTE	sidArray[ 512 ];
							TCHAR	szDigit[ 3 ];

							ZeroMemory( sidArray, sizeof sidArray );
							ZeroMemory( szDigit, sizeof szDigit );

							size_t len = _tcslen(p) / 2;
							for (size_t j=0; j < len; j++)
							{
								_tcsncpy( szDigit, p, 2 );
								LPTSTR stopPtr = NULL;

								sidArray[ j ] = (BYTE)_tcstoul( szDigit, &stopPtr, 16 );

								p+=2;
							}

							if( !ConvertSidToStringSid( sidArray, &szSID ) )
							{
								assert( false );
								throw OP_GENERIC_EXCEPTION;
							}
							else
							{
								_tcsncpy( szObjectName, szSID, uBufSize - 1 );
								LocalFree( szSID );
							}
						}
						else
						{
							assert( false );
							throw OP_GENERIC_EXCEPTION;
						}
					}
					else
					{
						assert( false );
						throw OP_GENERIC_EXCEPTION;
					}
				}
				else
				{
					assert( false );
					throw OP_GENERIC_EXCEPTION;
				}
			}
			//
			// otherwise, names on the local box begin with "winnt:"
			// and we are only interested in the last two sections of the string,
			// delimited by "/"
			//
			else if( 0 == _tcsnicmp( pDsSelList->aDsSelection[i].pwzADsPath, TEXT( "WINNT:" ), 6 ) )
			{
				PTCHAR p = pDsSelList->aDsSelection[i].pwzADsPath;
				PTCHAR pend = p + _tcslen( p );
				UINT uCount = 0;
				while( pend > p )
				{
					if( '/' == *pend )
					{
						*pend = '\\';
						uCount++;

						if( uCount == 2 )
						{
							p = pend + 1;
							break;
						}
					}
					pend--;
				}

				//
				// if this fails, assert during debug but do not stop
				//
				if( p == pend )
					assert( false );

				assert( uBufSize > _tcslen( p ) );
				_tcsncpy( szObjectName, p, uBufSize - 1 );
				szObjectName[ uBufSize - 1 ] = NULL;
			}
			else
			{
				assert( false );
				throw OP_GENERIC_EXCEPTION;
			}
		}
		else
		{
			assert( false );
			throw OP_GENERIC_EXCEPTION;
		}
	}

	catch( DWORD dwErr )
	{
		SetLastError( dwErr );
		dwRet = false;
	}

	if( pDsSelList )
		GlobalUnlock( stgmedium.hGlobal );

	ReleaseStgMedium( &stgmedium );

	return dwRet;
}


//+--------------------------------------------------------------------------
//
//  Function:   InitObjectPickerForGroups
//
//  Synopsis:   Call IDsObjectPicker::Initialize with arguments that will
//              set it to allow the user to pick one or more groups.
//
//  Arguments:  [pDsObjectPicker] - object picker interface instance
//
//  Returns:    Result of calling IDsObjectPicker::Initialize.
//
//  History:    10-14-1998   DavidMun   Created
//              1-8-2000     SergeiA    Adapted for IIS
//				9-6-2002	 a-dsebes	Adapted for UDDI
//
//---------------------------------------------------------------------------
HRESULT
InitObjectPickerForGroups( IDsObjectPicker *pDsObjectPicker, 
                           BOOL fMultiselect,
                           LPCTSTR pszMachineName,
						   BOOL fWantSidPath )
{
    //
    // Prepare to initialize the object picker.
    // Set up the array of scope initializer structures.
    //

    static const int SCOPE_INIT_COUNT = 5;
    DSOP_SCOPE_INIT_INFO aScopeInit[ SCOPE_INIT_COUNT ];

    ZeroMemory( aScopeInit, sizeof( DSOP_SCOPE_INIT_INFO ) * SCOPE_INIT_COUNT );

    //
    // Target computer scope.  This adds a "Look In" entry for the
    // target computer.  Computer scopes are always treated as
    // downlevel (i.e., they use the WinNT provider).
    //
    aScopeInit[ 0 ].cbSize = sizeof( DSOP_SCOPE_INIT_INFO );
    aScopeInit[ 0 ].flType = DSOP_SCOPE_TYPE_TARGET_COMPUTER;
    aScopeInit[ 0 ].flScope = DSOP_SCOPE_FLAG_STARTING_SCOPE;

	aScopeInit[ 0 ].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_BUILTIN_GROUPS;
    aScopeInit[ 0 ].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_LOCAL_GROUPS;

	if( fWantSidPath )
	{
		aScopeInit[ 0 ].flScope |= DSOP_SCOPE_FLAG_WANT_SID_PATH;
	}

    //
    // The domain to which the target computer is joined.  Note we're
    // combining two scope types into flType here for convenience.
    //
    aScopeInit[ 1 ].cbSize = sizeof( DSOP_SCOPE_INIT_INFO );
    aScopeInit[ 1 ].flScope = 0;
    aScopeInit[ 1 ].flType = DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN | 
				   		     DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN;

	aScopeInit[ 1 ].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_GLOBAL_GROUPS_SE |
													DSOP_FILTER_UNIVERSAL_GROUPS_SE |
													DSOP_FILTER_DOMAIN_LOCAL_GROUPS_SE;
    aScopeInit[ 1 ].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_GLOBAL_GROUPS;

	if( fWantSidPath )
	{
		aScopeInit[ 1 ].flScope |= DSOP_SCOPE_FLAG_WANT_SID_PATH;
	}

    //
    // The domains in the same forest (enterprise) as the domain to which
    // the target machine is joined.  Note these can only be DS-aware
    //

    aScopeInit[ 2 ].cbSize = sizeof( DSOP_SCOPE_INIT_INFO );
    aScopeInit[ 2 ].flType = DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN;
    aScopeInit[ 2 ].flScope = 0;

	aScopeInit[ 2 ].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_GLOBAL_GROUPS_SE |
													  DSOP_FILTER_UNIVERSAL_GROUPS_SE;

	if( fWantSidPath )
	{
		aScopeInit[ 2 ].flScope |= DSOP_SCOPE_FLAG_WANT_SID_PATH;
	}

    //
    // Domains external to the enterprise but trusted directly by the
    // domain to which the target machine is joined.
    //
    // If the target machine is joined to an NT4 domain, only the
    // external downlevel domain scope applies, and it will cause
    // all domains trusted by the joined domain to appear.
    //

    aScopeInit[ 3 ].cbSize = sizeof( DSOP_SCOPE_INIT_INFO );
    aScopeInit[ 3 ].flScope = 0;
    aScopeInit[ 3 ].flType = DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN |
							 DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN;

	aScopeInit[ 3 ].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_GLOBAL_GROUPS_SE |
													  DSOP_FILTER_UNIVERSAL_GROUPS_SE;
    aScopeInit[ 3 ].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_GLOBAL_GROUPS;

	if( fWantSidPath )
	{
		aScopeInit[ 3 ].flScope |= DSOP_SCOPE_FLAG_WANT_SID_PATH;
	}

    //
    // The Global Catalog
    //

    aScopeInit[ 4 ].cbSize = sizeof( DSOP_SCOPE_INIT_INFO );
    aScopeInit[ 4 ].flScope = 0;
    aScopeInit[ 4 ].flType = DSOP_SCOPE_TYPE_GLOBAL_CATALOG;

	//
    // Only native mode applies to gc scope.
	//
    aScopeInit[ 4 ].FilterFlags.Uplevel.flNativeModeOnly = DSOP_FILTER_GLOBAL_GROUPS_SE |
														   DSOP_FILTER_UNIVERSAL_GROUPS_SE;

	if( fWantSidPath )
	{
		aScopeInit[ 4 ].flScope |= DSOP_SCOPE_FLAG_WANT_SID_PATH;
	}

    //
    // Put the scope init array into the object picker init array
    //

    DSOP_INIT_INFO InitInfo;
    ZeroMemory( &InitInfo, sizeof( InitInfo ) );
    InitInfo.cbSize = sizeof( InitInfo );

    //
    // The pwzTargetComputer member allows the object picker to be
    // retargetted to a different computer.  It will behave as if it
    // were being run ON THAT COMPUTER.
    //

    InitInfo.pwzTargetComputer = pszMachineName;
    InitInfo.cDsScopeInfos = SCOPE_INIT_COUNT;
    InitInfo.aDsScopeInfos = aScopeInit;
    InitInfo.flOptions = fMultiselect ? DSOP_FLAG_MULTISELECT : 0;

    //
    // Note object picker makes its own copy of InitInfo.  Also note
    // that Initialize may be called multiple times, last call wins.
    //

    HRESULT hr = pDsObjectPicker->Initialize( &InitInfo );

	return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   InitObjectPickerForGroups
//
//  Synopsis:   Call IDsObjectPicker::Initialize with arguments that will
//              set it to allow the user to pick one or more groups.
//
//  Arguments:  [pDsObjectPicker] - object picker interface instance
//
//  Returns:    Result of calling IDsObjectPicker::Initialize.
//
//  History:    9-6-2002	 a-dsebes	Created.
//				
//
//---------------------------------------------------------------------------
HRESULT
InitObjectPickerForUsers( IDsObjectPicker *pDsObjectPicker, 
                          BOOL fMultiselect,
                          LPCTSTR pszMachineName )
{
    //
    // Prepare to initialize the object picker.
    // Set up the array of scope initializer structures.
    //

    static const int SCOPE_INIT_COUNT = 5;
    DSOP_SCOPE_INIT_INFO aScopeInit[ SCOPE_INIT_COUNT ];

    ZeroMemory( aScopeInit, sizeof( DSOP_SCOPE_INIT_INFO ) * SCOPE_INIT_COUNT );

    //
    // Target computer scope.  This adds a "Look In" entry for the
    // target computer.  Computer scopes are always treated as
    // downlevel (i.e., they use the WinNT provider).
    //
    aScopeInit[ 0 ].cbSize = sizeof( DSOP_SCOPE_INIT_INFO );
    aScopeInit[ 0 ].flType = DSOP_SCOPE_TYPE_TARGET_COMPUTER;
    aScopeInit[ 0 ].flScope = DSOP_SCOPE_FLAG_STARTING_SCOPE;

	aScopeInit[ 0 ].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_USERS;
    aScopeInit[ 0 ].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_USERS;

    //
    // The domain to which the target computer is joined.  Note we're
    // combining two scope types into flType here for convenience.
    //
    aScopeInit[ 1 ].cbSize = sizeof( DSOP_SCOPE_INIT_INFO );
    aScopeInit[ 1 ].flScope = 0;
    aScopeInit[ 1 ].flType = DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN | 
				   		     DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN;

	aScopeInit[ 1 ].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_USERS;
    aScopeInit[ 1 ].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_USERS;

    //
    // The domains in the same forest (enterprise) as the domain to which
    // the target machine is joined.  Note these can only be DS-aware
    //
    aScopeInit[ 2 ].cbSize = sizeof( DSOP_SCOPE_INIT_INFO );
    aScopeInit[ 2 ].flType = DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN;
    aScopeInit[ 2 ].flScope = 0;

	aScopeInit[ 2 ].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_USERS;

    //
    // Domains external to the enterprise but trusted directly by the
    // domain to which the target machine is joined.
    //
    // If the target machine is joined to an NT4 domain, only the
    // external downlevel domain scope applies, and it will cause
    // all domains trusted by the joined domain to appear.
    //
    aScopeInit[ 3 ].cbSize = sizeof( DSOP_SCOPE_INIT_INFO );
    aScopeInit[ 3 ].flScope = 0;
    aScopeInit[ 3 ].flType = DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN |
							 DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN;

	aScopeInit[ 3 ].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_USERS;
    aScopeInit[ 3 ].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_USERS;

    //
    // The Global Catalog
    //
    aScopeInit[ 4 ].cbSize = sizeof( DSOP_SCOPE_INIT_INFO );
    aScopeInit[ 4 ].flScope = 0;
    aScopeInit[ 4 ].flType = DSOP_SCOPE_TYPE_GLOBAL_CATALOG;

	//
    // Only native mode applies to gc scope.
	//
	aScopeInit[ 4 ].FilterFlags.Uplevel.flNativeModeOnly = DSOP_FILTER_USERS;

    //
    // Put the scope init array into the object picker init array
    //
    DSOP_INIT_INFO InitInfo;
    ZeroMemory( &InitInfo, sizeof( InitInfo ) );
    InitInfo.cbSize = sizeof( InitInfo );

    //
    // The pwzTargetComputer member allows the object picker to be
    // retargetted to a different computer.  It will behave as if it
    // were being run ON THAT COMPUTER.
    //
    InitInfo.pwzTargetComputer = pszMachineName;
    InitInfo.cDsScopeInfos = SCOPE_INIT_COUNT;
    InitInfo.aDsScopeInfos = aScopeInit;
    InitInfo.flOptions = fMultiselect ? DSOP_FLAG_MULTISELECT : 0;

    //
    // Note object picker makes its own copy of InitInfo.  Also note
    // that Initialize may be called multiple times, last call wins.
    //
    HRESULT hr = pDsObjectPicker->Initialize( &InitInfo );

	return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   InitObjectPickerForComputers
//
//  Synopsis:   Call IDsObjectPicker::Initialize with arguments that will
//              set it to allow the user to pick a single computer object.
//
//  Arguments:  [pDsObjectPicker] - object picker interface instance
//
//  Returns:    Result of calling IDsObjectPicker::Initialize.
//
//  History:    10-14-1998   DavidMun   Created
//              08-06-2002   a-dsebes   Adapted for UDDI.
//
//---------------------------------------------------------------------------

HRESULT
InitObjectPickerForComputers( IDsObjectPicker *pDsObjectPicker )
{
    //
    // Prepare to initialize the object picker.
    // Set up the array of scope initializer structures.
    //

    static const int SCOPE_INIT_COUNT = 2;
    DSOP_SCOPE_INIT_INFO aScopeInit[ SCOPE_INIT_COUNT ];

    ZeroMemory( aScopeInit, sizeof( DSOP_SCOPE_INIT_INFO ) * SCOPE_INIT_COUNT );

    //
    // Build a scope init struct for everything except the joined domain.
    //

    aScopeInit[ 0 ].cbSize = sizeof( DSOP_SCOPE_INIT_INFO );
    aScopeInit[ 0 ].flType = DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN
                             | DSOP_SCOPE_TYPE_GLOBAL_CATALOG
                             | DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN
                             | DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN
                             | DSOP_SCOPE_TYPE_WORKGROUP
                             | DSOP_SCOPE_TYPE_USER_ENTERED_UPLEVEL_SCOPE
                             | DSOP_SCOPE_TYPE_USER_ENTERED_DOWNLEVEL_SCOPE;

	aScopeInit[ 0 ].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_COMPUTERS;
    aScopeInit[ 0 ].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_COMPUTERS;


    //
    // scope for the joined domain, make it the default
    //
    aScopeInit[ 1 ].cbSize = sizeof( DSOP_SCOPE_INIT_INFO );
    aScopeInit[ 1 ].flType = DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN
                             | DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN;

	aScopeInit[ 1 ].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_COMPUTERS;
    aScopeInit[ 1 ].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_COMPUTERS;
    aScopeInit[ 1 ].flScope = DSOP_SCOPE_FLAG_STARTING_SCOPE;

    //
    // Put the scope init array into the object picker init array
    //

    DSOP_INIT_INFO InitInfo;
    ZeroMemory( &InitInfo, sizeof( InitInfo ) );

    InitInfo.cbSize = sizeof( InitInfo );
    InitInfo.pwzTargetComputer = NULL;  // NULL == local machine
    InitInfo.cDsScopeInfos = SCOPE_INIT_COUNT;
    InitInfo.aDsScopeInfos = aScopeInit;

    //
    // Note object picker makes its own copy of InitInfo.  Also note
    // that Initialize may be called multiple times, last call wins.
    //

    return pDsObjectPicker->Initialize(&InitInfo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\mmc\scp.h ===
#pragma once
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0500
#endif
#define SECURITY_WIN32

#include <atlbase.h>
#include <iads.h>
#include <adshlp.h>
#include <security.h>
#include <activeds.h>
#include <windows.h>
#include <string>
#include <vector>
#include <map>

class CUDDIServiceCxnPt
{
public:
	CUDDIServiceCxnPt( LPWSTR szName, LPWSTR szClassName );
	void AddDefaultKeywords();
	void Create( IDirectoryObject* pDirObject );
	static void CreateSiteContainer( LPWSTR pszName, LPWSTR pszDisplayName, IDirectoryObject** ppContainer );
	static void CreateContainer( IDirectoryObject* pObj, LPWSTR szName, IDirectoryObject** ppContainer );
	static void DeleteSiteContainer( LPWSTR pszName, BOOL bFailIfNotThere = FALSE );

	static LPWSTR GetRootDSE();

	std::vector<std::wstring> keywords;
	std::map<std::wstring, std::wstring> attributes;

	const static LPWSTR UDDI_KEYWORD;
	const static LPWSTR UDDI_VERSION_KEYWORD;

	const static LPWSTR VENDOR_KEYWORD;
	const static LPWSTR VENDOR_GUID_KEYWORD;

	const static LPWSTR PRODUCT_KEYWORD;
	const static LPWSTR PRODUCT_GUID_KEYWORD;

	const static LPWSTR DISCOVERY_URL_KEYWORD;
	const static LPWSTR DISCOVERYURL_GUID_KEYWORD;
	const static LPWSTR DISCOVERYURL_SERVICE_CLASS_NAME;

	const static LPWSTR PUBLISH_KEYWORD;
	const static LPWSTR PUBLISH_GUID_KEYWORD;
	const static LPWSTR PUBLISH_SERVICE_CLASSNAME;
	const static LPWSTR PUBLISH_KEY_V2;

	const static LPWSTR INQUIRE_KEYWORD;
	const static LPWSTR INQUIRE_GUID_KEYWORD;
	const static LPWSTR INQUIRE_SERVICE_CLASS_NAME;
	const static LPWSTR INQUIRE_KEY_V2;

	const static LPWSTR ADD_WEB_REFERENCE_KEYWORD;
	const static LPWSTR ADD_WEB_REFERENCE_GUID_KEYWORD;
	const static LPWSTR ADD_WEB_REFERENCE_SERVICE_CLASS_NAME;

	const static LPWSTR WEB_SITE_KEYWORD;
	const static LPWSTR WEB_SITE_GUID_KEYWORD;
	const static LPWSTR WEB_SITE_SERVICE_CLASS_NAME;

	const static LPWSTR WINDOWS_AUTHENTICATION_KEYWORD;
	const static LPWSTR WINDOWS_AUTHENTICATION_GUID_KEYWORD;

	const static LPWSTR UDDI_AUTHENTICATION_KEYWORD;
	const static LPWSTR UDDI_AUTHENTICATION_GUID_KEYWORD;

	const static LPWSTR ANONYMOUS_AUTHENTICATION_KEYWORD;
	const static LPWSTR ANONYMOUS_AUTHENTICATION_GUID_KEYWORD;

private:
	CUDDIServiceCxnPt();
	std::wstring strName;
	std::wstring strClassName;
	static std::wstring strRootDSE;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\mmc\scppublisher.h ===
#pragma once

#include <windows.h>
#include <stdio.h>
#include <string>
#include <vector>
#include <oledberr.h>
#include "scp.h"

class CUDDIServiceCxnPtPublisher : public std::vector<CUDDIServiceCxnPt*>
{
public:
	CUDDIServiceCxnPtPublisher( 
		const std::wstring& strConnectionString, 
		const std::wstring& strSiteKey = L"", 
		const std::wstring& strSiteName = L"", 
		const std::wstring& strDefaultDiscoveryUrl = L"" );

	~CUDDIServiceCxnPtPublisher();

	void GetSiteInfo();
	void ProcessSite();	
	void DeleteSiteContainer();
	void CreateSiteContainer();
	void PublishServiceCxnPts( IDirectoryObject *pDirObject = NULL );
	std::wstring StripBraces( LPWSTR szKey );

private:
	void ProcessBinding( const std::wstring& strBindingKey, const std::wstring& strAccessPoint );
	void AddInquireScp( const std::wstring& strBindingKey, const std::wstring& strAccessPoint, const std::wstring& strTModelKey, const std::wstring& strAuthenticationKey, const std::wstring& strAuthenticationVerb );
	void AddPublishScp( const std::wstring& strBindingKey, const std::wstring& strAccessPoint, const std::wstring& strTModelKey, const std::wstring& strAuthenticationKey, const std::wstring& strAuthenticationVerb );
	void AddAddWebReferenceScp( const std::wstring& strBindingKey, const std::wstring& strAccessPoint, const std::wstring& strTModelKey, const std::wstring& strAuthenticationKey, const std::wstring& strAuthenticationVerb );
	void AddWebSiteScp( const std::wstring& strBindingKey, const std::wstring& strAccessPoint, const std::wstring& strTModelKey, const std::wstring& strAuthenticationKey, const std::wstring& strAuthenticationVerb );
	void AddDiscoveryUrlScp();

	CUDDIServiceCxnPtPublisher();
	std::wstring m_strSiteKey;
	std::wstring m_strSiteName;
	std::wstring m_strDefaultDiscoveryUrl;
	std::wstring m_strConnectionString;
	CComPtr<IDirectoryObject> m_pSiteContainer;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\mmc\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by resource.rc
//
#define IDB_SMBMP                       3
#define IDB_LGBMP                       4
#define IDR_SMICONS                     5
#define IDR_LGICONS                     6
#define IDR_TOOLBAR1                    7
#define IDS_UDDIMMC_HELPFILE            99
#define IDI_UDDIMMC                     100
#define IDS_UDDIMMC_SNAPINDESC          100
#define IDS_UDDIMMC_NAME                101
#define IDS_UDDIMMC_PROVIDER            102
#define IDS_UDDIMMC_SNAPINNAME          103
#define IDS_UDDIMMC_ABOUTNAME           104
#define IDS_UDDIMMC_COMPONENT_DESCRIPTION 105
#define IDS_UDDIMMC_CONNECTELLIPSISDESCRIPTION 120
#define IDS_UDDIMMC_TYPE                121
#define IDS_UDDIMMC_DESCRIPTION         122
#define IDS_UDDIMMC_NODBSERVER          123
#define IDS_UDDIMMC_NOINSTANCE          124
#define IDS_UDDIMMC_WARNING             125
#define IDS_ERROR_ADDSVC                168
#define IDS_ERROR_ADDNODE               169
#define IDS_ERROR_ADDWEBSITE            169
#define IDS_INVALID_VERSION_FORMAT      170
#define IDS_DOT_NET_SERVER              171
#define IDI_DATABASE_SERVER             200
#define IDS_DATABASE_SERVER_DESCRIPTION 202
#define IDS_DATABASE_SERVER_SELECTION_ERROR 204
#define IDS_DATABASE_SERVER_ALREADY_EXISTS 204
#define IDS_DATABASE_SERVER_SELECTION_ERROR_TITLE 205
#define IDS_DATABASE_SERVER_SELECT_ERROR 206
#define IDS_DATABASE_SERVER_SELECT_ERROR_TITLE 207
#define IDS_DATABASE_SERVER_ADD         208
#define IDS_DATABASE_SERVER_DEFAULT_INSTANCE 209
#define IDS_DATABASE_SERVER_COMPONENT_DESCRIPTION 210
#define IDS_DATABASE_SERVER             211
#define IDS_DATABASE_SERVER_DEFAULT_SITE_NAME_PREFIX 212
#define IDS_DATABASE_SERVER_COLUMN_NAME 213
#define IDS_DATABASE_SERVER_COLUMN_COMPUTER 214
#define IDS_DATABASE_SERVER_COLUMN_INSTANCE 215
#define IDS_DATABASE_SERVER_COLUMN_DESCRIPTION 216
#define IDS_SITE_CONNECT_INSTANCE_FOUND_TEMPLATE 217
#define IDS_SITE_CONNECT_NO_INSTANCES_FOUND 218
#define IDS_DATABASE_SERVER_REGISTRY_READ_FAILED 219
#define IDS_DATABASE_SERVER_OLEDB_READ_FAILED 220
#define IDS_DATABASE_SERVER_GENERIC_GETDATA_ERROR 221
#define IDS_DATABASE_SERVER_GETDATA_ERROR_TITLE 221
#define IDS_ACCOUNT_ERROR               222
#define IDS_ACCOUNT_GROUP_ERROR         222
#define IDS_ERROR_TITLE                 223
#define IDS_WEBSERVER_REMOVE_FAILED     224
#define IDS_WEBSERVER_REMOVE_FAILED_DETAIL 225
#define IDS_WEBSERVER_WEBFARM           226
#define IDS_WEBSERVER_WEBFARM_DETAIL    227
#define IDS_DATABASE_SERVER_DBSCHEMA_VERSION_READ_FAILED 228
#define IDS_DATABASE_STANDARD_SERVER    229
#define IDS_DATABASE_STANDARD_SERVER_DETAIL 230
#define IDS_WEBSERVER_ADD_FAILED_DETAIL 231
#define IDS_WEBSERVER_ADD_FAILED        232
#define IDS_UDDIMMC_UNSPECIFIED         233
#define IDS_GENERAL_EXCEPTION_TITLE     234
#define IDS_GENERAL_EXCEPTION           235
#define IDI_WEBSERVER                   300
#define IDS_WEBSERVER_COMPONENT_DESCRIPTION 300
#define IDS_WEBSERVER                   301
#define IDS_WEBSERVER_START             303
#define IDS_WEBSERVER_STOP              304
#define IDS_WEBSERVER_START_DESCRIPTION 305
#define IDS_WEBSERVER_STOP_DESCRIPTION  306
#define IDS_WEBSERVER_RUNNING           307
#define IDS_WEBSERVER_STOPPED           308
#define IDS_WEBSERVER_DESCRIPTION       309
#define IDS_WEBSERVER_ADD               310
#define IDS_WEBSERVER_COLUMN_NAME       311
#define IDS_WEBSERVER_COLUMN_STATUS     312
#define IDS_WEBSERVER_DISPLAYNAME_TEMPLATE 313
#define IDS_WEBSERVER_SELECT_ERROR      314
#define IDS_WEBSERVER_SELECT_ERROR_TITLE 315
#define IDS_WEBSERVER_ALREADY_EXISTS    316
#define IDS_WEBSERVER_ASSIGNED          317
#define IDS_WEBSERVER_ASSIGNED_DETAIL   318
#define IDS_WEBSERVER_NOT_ASSIGNABLE    319
#define IDS_WEBSERVER_NOT_ASSIGNABLE_DETAIL 320
#define IDS_WEBSERVER_SERVER_DBSCHEMA_VERSION_READ_FAILED 321
#define IDS_WEBSERVER_SERVER_INVALID_DBSCHEMA_VERSION 322
#define IDD_CRYPTOGRAPHY                400
#define IDS_CRYPTOGRAPHY_TIMEOUT_ERROR  402
#define IDS_CRYPTOGRAPHY_RESET_NOW_CONFIRM 403
#define IDS_CRYPTOGRAPHY_RESET_NOW_TITLE 404
#define IDS_CRYPTOGRAPHY_RESET_NOW_SUCCESS 405
#define IDS_CRYPTOGRAPHY_RESET_NOW_SUCCESS_TITLE 406
#define IDS_CRYPTOGRAPHY_RESET_NOW_FAILED 407
#define IDS_CRYPTOGRAPHY_RESET_NOW_FAILED_TITLE 408
#define IDS_CRYPTOGRAPHY_TICKET_TIMEOUT_ERROR 409
#define IDS_CRYPTOGRAPHY_TICKET_TIMEOUT_ERROR_TITLE 410
#define IDC_CRYPTOGRAPHY_EDIT_TIMEOUT   449
#define IDC_CRYPTOGRAPHY_SPIN_TIMEOUT   450
#define IDC_CRYPTOGRAPHY_TXT_RESET_DATE 451
#define IDC_CRYPTOGRAPHY_EDIT_TICKET_TIMEOUT 453
#define IDC_CRYPTOGRAPHY_BTN_CHANGE     454
#define IDC_CRYPTOGRAPHY_BTN_RESET_NOW  455
#define IDC_CRYPTOGRAPHY_CHECK_AUTO_RESET 456
#define IDC_CRYPTOGRAPHY_SPIN_TICKET_TIMEOUT 459
#define IDD_ADVANCED_PROPPAGE           500
#define IDI_ADVANCED                    500
#define IDS_ADVANCED_NAME_COLUMN_NAME   501
#define IDS_ADVANCED_VALUE_COLUMN_NAME  502
#define IDS_ADVANCED_CHANGED_COLUMN_NAME 503
#define IDC_ADVANCED_BTN_EDIT           504
#define IDD_ACTIVEDIRECTORY_PROPPAGE    600
#define IDI_ACTIVEDIRECTORY             600
#define IDS_ACTIVEDIRECTORY_PUBLISH_FAILED 601
#define IDS_ACTIVEDIRECTORY_DELETE_FAILED 602
#define IDS_ACTIVEDIRECTORY_PUBLISH_SUCCEEDED 603
#define IDS_ACTIVEDIRECTORY_DELETE_SUCCEDED 604
#define IDS_ACTIVEDIRECTORY_NO_BINDINGS 605
#define IDC_ACTIVEDIRECTORY_LIST_ADVANCED 651
#define IDC_ACTIVEDIRECTORY_BTN_REFRESH 652
#define IDC_ACTIVEDIRECTORY_BTN_REMOVE  653
#define IDC_ACTIVEDIRECTORY_BTN_ADD     655
#define IDD_ROLES_PROPPAGE              700
#define IDI_ROLES                       700
#define IDC_ROLES_EDIT_ADMIN_GROUP_NAME 751
#define IDC_ROLES_EDIT_ADMIN_GROUP_NAME2 752
#define IDC_ROLES_BTN_ADMINISTRATOR_SELECT 753
#define IDC_ROLES_EDIT_COORDINATOR_GROUP_NAME 754
#define IDC_ROLES_BTN_COORDINATOR_SELECT 756
#define IDC_ROLES_EDIT_PUBLISHER_GROUP_NAME 757
#define IDC_ROLES_BTN_PUBLISHER_SELECT  758
#define IDC_ROLES_EDIT_USER_GROUP_NAME  759
#define IDC_ROLES_BTN_USER_SELECT       760
#define IDD_SECURITY_PROPPAGE           800
#define IDI_SECURITY_CRYPTOGRAPHY       801
#define IDI_SECURITY_REQUIRESSL         802
#define IDI_SECURITY_AUTHENTICATION     803
#define IDC_SECURITY_RADIO_AUTHENTICATION_BOTH 851
#define IDC_SECURITY_RADIO_AUTHENTICATION_UDDI 852
#define IDC_SECURITY_CHECK_AUTHENTICATED_READS 853
#define IDC_SECURITY_RADIO_AUTHENTICATION_WINDOWS 854
#define IDC_SECURITY_CHECK_REQUIRE_SSL  855
#define IDD_SITE_CONNECT                900
#define IDC_SITE_CONNECT_CB_DATABASE_INSTANCE 902
#define IDC_SITE_CONNECT_EDIT_ANOTHERCOMPUTER 906
#define IDC_SITE_CONNECT_BTN_BROWSE     907
#define IDC_SITE_CONNECT_RADIO_LOCALCOMPUTER 908
#define IDC_SITE_CONNECT_RADIO_ANOTHERCOMPUTER 909
#define IDC_SITE_CONNECT_READER         910
#define IDC_SITE_CONNECT_RADIO_READER   910
#define IDC_SITE_CONNECT_WRITER         911
#define IDC_SITE_CONNECT_RADIO_WRITER   911
#define IDC_SITE_CONNECT_BOTH           912
#define IDC_SITE_CONNECT_RADIO_BOTH     912
#define IDC_SITE_CONNECT_RADIO_WRITER2  913
#define IDC_GENERAL_SITE_TXT_DESCRIPTION 1054
#define IDC_SITE_CONNECT_TXT_DATABASE_INSTANCE 1055
#define IDS_REGISTRY_OPEN_ERROR         1160
#define IDS_REGISTRY_OPEN_REMOTE_ERROR  1161
#define IDS_REGISTRY_UNABLE_TO_OPEN_KEY 1162
#define IDS_REGISTRY_FAILED_TO_READ_VALUE 1163
#define IDS_REGISTRY_FAILED_TO_WRITE_VALUE 1164
#define IDD_WEBSERVER_NEW               2000
#define IDD_LOGGING_PROPPAGE            2100
#define IDI_LOGGING_FILELOG             2101
#define IDI_LOGGING_EVENTLOG            2102
#define IDC_LOGGING_SLIDER_FILELOG      2151
#define IDC_LOGGING_TXT_LOGFILE_LOCATION 2152
#define IDC_LOGGING_SLIDER_EVENTLOG     2153
#define IDD_ADVANCED_EDIT               2200
#define IDC_ADVANCED_EDIT_VALUE         2201
#define IDC_ADVANCED_EDIT_TXT_NAME      2202
#define IDC_ADVANCED_EDIT_TXT_DISPLAYNAME 2203
#define IDD_GENERAL_WEB_PROPPAGE        2300
#define IDD_GENERAL_SITE_PROPPAGE       2400
#define IDC_GENERAL_SITE_TXT_UDDI_VERSION 2450
#define IDC_GENERAL_SITE_TXT_UDDI_LANGUAGE 2451
#define IDC_GENERAL_SITE_TXT_FRAMEWORK_VERSION 2452
#define IDC_GENERAL_SITE_LIST_SERVICES  2453
#define IDC_GENERAL_SITE_TXT_INSTALL_LOCATION 2454
#define IDC_GENERAL_SITE_TXT_INSTALL_DATE 2455
#define IDC_GENERAL_SITE_TXT_DISPLAYNAME 2456
#define IDC_GENERAL_SITE_TXT_PROVIDER_KEY 2457
#define IDD_DB_CONNECTION_PROPPAGE      2500
#define IDI_DB_CONNECTION               2500
#define IDC_DB_CONNECTION_TXT_READER_SERVER 2501
#define IDC_DB_CONNECTION_TXT_READER_INSTANCE 2502
#define IDC_DB_CONNECTION_TXT_WRITER_SERVER 2503
#define IDC_DB_CONNECTION_TXT_WRITER_INSTANCE 2504
#define IDC_DB_CONNECTION_BTN_READER_SELECT 2505
#define IDC_DB_CONNECTION_BTN_WRITER_SELECT 2506
#define ID_BUTTONSTART                  40021
#define ID_BUTTONSTOP                   40023

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        171
#define _APS_NEXT_COMMAND_VALUE         40016
#define _APS_NEXT_CONTROL_VALUE         1056
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\mmc\scp.cpp ===
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0500
#endif
#define SECURITY_WIN32

#include <atlbase.h>
#include <iads.h>
#include <adshlp.h>
#include <security.h>
#include <activeds.h>
#include "uddi.h"
#include "scp.h"
using namespace std;

wstring CUDDIServiceCxnPt::strRootDSE = L"";
const LPWSTR CUDDIServiceCxnPt::UDDI_KEYWORD = L"UDDI";
const LPWSTR CUDDIServiceCxnPt::UDDI_VERSION_KEYWORD = L"2.0";

const LPWSTR CUDDIServiceCxnPt::VENDOR_KEYWORD = L"Microsoft Corporation";
const LPWSTR CUDDIServiceCxnPt::VENDOR_GUID_KEYWORD = L"83C29870-1DFC-11D3-A193-0000F87A9099";

const LPWSTR CUDDIServiceCxnPt::PRODUCT_KEYWORD = L"UDDI Services";
const LPWSTR CUDDIServiceCxnPt::PRODUCT_GUID_KEYWORD = L"09A92664-D144-49DB-A600-2B3ED04BF639";

const LPWSTR CUDDIServiceCxnPt::DISCOVERY_URL_KEYWORD = L"DiscoveryUrl";
const LPWSTR CUDDIServiceCxnPt::DISCOVERYURL_GUID_KEYWORD = L"1276768A-1488-4C6F-A8D8-19556C6BE583";
const LPWSTR CUDDIServiceCxnPt::DISCOVERYURL_SERVICE_CLASS_NAME = L"UddiDiscoveryUrl";

const LPWSTR CUDDIServiceCxnPt::PUBLISH_KEYWORD = L"Publish API";
const LPWSTR CUDDIServiceCxnPt::PUBLISH_GUID_KEYWORD = L"64C756D1-3374-4E00-AE83-EE12E38FAE63";
const LPWSTR CUDDIServiceCxnPt::PUBLISH_SERVICE_CLASSNAME = L"UddiPublishUrl";
const LPWSTR CUDDIServiceCxnPt::PUBLISH_KEY_V2 = L"A2F36B65-2D66-4088-ABC7-914D0E05EB9E";

const LPWSTR CUDDIServiceCxnPt::INQUIRE_KEYWORD = L"Inquire API";
const LPWSTR CUDDIServiceCxnPt::INQUIRE_GUID_KEYWORD = L"4CD7E4BC-648B-426D-9936-443EAAC8AE23";
const LPWSTR CUDDIServiceCxnPt::INQUIRE_SERVICE_CLASS_NAME = L"UddiInquireUrl";
const LPWSTR CUDDIServiceCxnPt::INQUIRE_KEY_V2 = L"AC104DCC-D623-452F-88A7-F8ACD94D9B2B";

const LPWSTR CUDDIServiceCxnPt::ADD_WEB_REFERENCE_KEYWORD = L"Add Web Reference";
const LPWSTR CUDDIServiceCxnPt::ADD_WEB_REFERENCE_GUID_KEYWORD = L"CE653789-F6D4-41B7-B7F4-31501831897D";
const LPWSTR CUDDIServiceCxnPt::ADD_WEB_REFERENCE_SERVICE_CLASS_NAME = L"UddiAddWebReferenceUrl";

const LPWSTR CUDDIServiceCxnPt::WEB_SITE_KEYWORD = L"Web Site";
const LPWSTR CUDDIServiceCxnPt::WEB_SITE_GUID_KEYWORD = L"4CEC1CEF-1F68-4B23-8CB7-8BAA763AEB89";
const LPWSTR CUDDIServiceCxnPt::WEB_SITE_SERVICE_CLASS_NAME = L"UddiWebSiteUrl";

const LPWSTR CUDDIServiceCxnPt::WINDOWS_AUTHENTICATION_KEYWORD = L"WindowsAuthentication";
const LPWSTR CUDDIServiceCxnPt::ANONYMOUS_AUTHENTICATION_KEYWORD = L"AnonymousAuthentication";
const LPWSTR CUDDIServiceCxnPt::UDDI_AUTHENTICATION_KEYWORD = L"UddiAuthentication";

const LPWSTR CUDDIServiceCxnPt::WINDOWS_AUTHENTICATION_GUID_KEYWORD = L"0C61E2C3-73C5-4743-8163-6647AF5B4B9E";
const LPWSTR CUDDIServiceCxnPt::ANONYMOUS_AUTHENTICATION_GUID_KEYWORD = L"E4A56494-4946-4805-ACA5-546B8D08EEFD";
const LPWSTR CUDDIServiceCxnPt::UDDI_AUTHENTICATION_GUID_KEYWORD = L"F358808C-E939-4813-A407-8873BFDC3D57";

CUDDIServiceCxnPt::
CUDDIServiceCxnPt( LPWSTR szName, LPWSTR szClassName )
	: strName( szName )
	, strClassName( szClassName )
{
}

CUDDIServiceCxnPt::
~CUDDIServiceCxnPt()
{
}

LPWSTR
CUDDIServiceCxnPt::GetRootDSE()
{
	if( 0 == strRootDSE.length() )
	{
		HRESULT hr = 0;
		CComPtr<IADs> pRoot = NULL;
		hr = ADsGetObject( L"LDAP://RootDSE", IID_IADs, (void**) &pRoot );
		if( FAILED(hr) )
		{
			throw CUDDIException( E_FAIL, L"Unable to acquire the root naming context. The domain may not exist or is not available." );
		}

		CComVariant var = 0;
		USES_CONVERSION;

		CComBSTR bstrDNC( L"defaultNamingContext" );
		pRoot->Get( bstrDNC, &var );
		strRootDSE = var.bstrVal;
	}

	return (LPWSTR) strRootDSE.c_str();
}

void
CUDDIServiceCxnPt::AddDefaultKeywords()
{
	keywords.push_back( VENDOR_KEYWORD );
	keywords.push_back( VENDOR_GUID_KEYWORD );
	keywords.push_back( PRODUCT_KEYWORD );
	keywords.push_back( PRODUCT_GUID_KEYWORD );
	keywords.push_back( UDDI_KEYWORD );
	keywords.push_back( UDDI_VERSION_KEYWORD );
}

void
CUDDIServiceCxnPt::DeleteSiteContainer( LPWSTR pszName, BOOL bFailIfNotThere )
{
	if( NULL == pszName || 0 == wcslen( pszName ) )
	{
		throw CUDDIException( E_INVALIDARG, L"Site container name must be specified" );
	}

	wstring strSitesPath;
	wstring strPath;
	try
	{
		strSitesPath = L",CN=Sites,CN=UDDI,CN=Microsoft,CN=System,";
		strSitesPath += GetRootDSE();

		strPath = L"LDAP://";

		if( NULL != pszName && 0 != _wcsnicmp( L"cn=", pszName, 3 ) )
			strPath += L"CN=";

		strPath += pszName;
		strPath += strSitesPath;
	}
	catch( ... )
	{
		throw CUDDIException( E_OUTOFMEMORY, L"Ran out of available memory in function: CUDDIServiceCxnPt::DeleteSiteContainer." );
	}

	//
	// Get a reference to the System container
	//
	CComPtr<IDirectoryObject> pSite = NULL;

	HRESULT hr = ADsGetObject( (LPWSTR) strPath.c_str(), IID_IDirectoryObject, (void**) &pSite );
	if( FAILED(hr) )
	{
		throw CUDDIException( hr, L"CUDDIServiceCxnPt::DeleteSiteContainer failed. Unable to acquire the site container" );
	}

	CComPtr<IADsDeleteOps> pDelete = NULL;
	hr = pSite->QueryInterface( IID_IADsDeleteOps, (void**) &pDelete );
	if( FAILED(hr) )
	{
		throw CUDDIException( hr, L"CUDDIServiceCxnPt::DeleteSiteContainer failed. Unable to acquire the IADsDeleteOps for site container" );
	}

	hr = pDelete->DeleteObject( 0 );
	if( FAILED(hr) )
	{
		throw CUDDIException( hr, L"CUDDIServiceCxnPt::DeleteSiteContainer failed on call to IADsDeleteObject::DeleteObject" );
	}
}

void
CUDDIServiceCxnPt::Create( IDirectoryObject* pDirObject )
{
	if( 0 == attributes.size() || 0 == keywords.size() )
	{
		throw CUDDIException( E_INVALIDARG, L"Error occurred in CUDDIServiceCxnPt::Create attributes and keywords must be present" );
	}

	if( NULL == pDirObject )
	{
		throw CUDDIException( E_INVALIDARG, L"The parent container was not specified for this service connection point." );
	}
	else
	{
		//
		// THE PURPOSE OF HAVING THIS CODE IN THE "IF" BLOCK IS TO 
		// APPEASE PREFAST, OTHERWISE PREFAST THROWS ERROR ON THE USE
		// OF pDirObject WITHOUT CHECKING FOR NULL
		//

		ADSVALUE cn, objclass, serviceclass;

		//
		// Setup the container and class name values
		//
		cn.dwType                   = ADSTYPE_CASE_IGNORE_STRING;
		cn.CaseIgnoreString         = (LPWSTR) strName.c_str();
		objclass.dwType             = ADSTYPE_CASE_IGNORE_STRING;
		objclass.CaseIgnoreString   = L"serviceConnectionPoint";
		serviceclass.dwType         = ADSTYPE_CASE_IGNORE_STRING;
		serviceclass.CaseIgnoreString = (LPWSTR) strClassName.c_str();

		//
		// Populate the keywords values array
		//
		ADSVALUE* pKeywordValues = new ADSVALUE[ keywords.size() ];
		if( NULL == pKeywordValues )
		{
			throw CUDDIException( E_OUTOFMEMORY, L"Ran out of memory allocating memory for pKeywordValues." );
		}

		int n = 0;
		for( vector<wstring>::iterator iter = keywords.begin();
			iter != keywords.end(); iter++ )
		{
			pKeywordValues[ n ].CaseIgnoreString = (LPWSTR) (*iter).c_str();
			pKeywordValues[ n ].dwType = ADSTYPE_CASE_IGNORE_STRING;
			n++;
		}

		//
		// Create and populate the attribute array
		//
		size_t nAttribs = attributes.size();
		size_t nTotalAttributes = nAttribs + 4;

		ADSVALUE* pValues = new ADSVALUE[ nAttribs ];
		if( NULL == pValues )
		{
			delete [] pKeywordValues;
			throw CUDDIException( E_OUTOFMEMORY, L"Ran out of memory allocating memory for pValues." );
		}

		ADS_ATTR_INFO* pAttrs = new ADS_ATTR_INFO[ nTotalAttributes ];
		if( NULL == pAttrs )
		{
			delete [] pKeywordValues;
			delete [] pValues;
			throw CUDDIException( E_OUTOFMEMORY, L"Ran out of memory allocating memory for pAttrs." );
		}

		pAttrs[ nAttribs ].pszAttrName = L"cn";
		pAttrs[ nAttribs ].dwControlCode = ADS_ATTR_UPDATE;
		pAttrs[ nAttribs ].dwADsType = ADSTYPE_CASE_IGNORE_STRING;
		pAttrs[ nAttribs ].dwNumValues = 1;
		pAttrs[ nAttribs ].pADsValues = &cn;

		pAttrs[ nAttribs + 1 ].pszAttrName = L"objectClass";
		pAttrs[ nAttribs + 1 ].dwControlCode = ADS_ATTR_UPDATE;
		pAttrs[ nAttribs + 1 ].dwADsType = ADSTYPE_CASE_IGNORE_STRING;
		pAttrs[ nAttribs + 1 ].dwNumValues = 1;
		pAttrs[ nAttribs + 1 ].pADsValues = &objclass;

		pAttrs[ nAttribs + 2 ].pszAttrName = L"keywords";
		pAttrs[ nAttribs + 2 ].dwControlCode = ADS_ATTR_UPDATE;
		pAttrs[ nAttribs + 2 ].dwADsType = ADSTYPE_CASE_IGNORE_STRING;
		pAttrs[ nAttribs + 2 ].dwNumValues = (DWORD) keywords.size();
		pAttrs[ nAttribs + 2 ].pADsValues = pKeywordValues;

		pAttrs[ nAttribs + 3 ].pszAttrName = L"serviceClassName";
		pAttrs[ nAttribs + 3 ].dwControlCode = ADS_ATTR_UPDATE;
		pAttrs[ nAttribs + 3 ].dwADsType = ADSTYPE_CASE_IGNORE_STRING;
		pAttrs[ nAttribs + 3 ].dwNumValues = 1;
		pAttrs[ nAttribs + 3 ].pADsValues = &serviceclass;

		map<wstring, wstring>::iterator attributeIter = attributes.begin();
	    	
		for( size_t i=0; i<attributes.size(); i++ )
		{
			pValues[ i ].CaseIgnoreString = (LPWSTR) (*attributeIter).second.c_str();
			pValues[ i ].dwType = ADSTYPE_CASE_IGNORE_STRING;

			pAttrs[ i ].pszAttrName = (LPWSTR) (*attributeIter).first.c_str();
			pAttrs[ i ].dwControlCode = ADS_ATTR_UPDATE;
			pAttrs[ i ].dwADsType = ADSTYPE_CASE_IGNORE_STRING;
			pAttrs[ i ].dwNumValues = 1;
			pAttrs[ i ].pADsValues = &pValues[ i ];

			attributeIter++;
		}

		wstring strRDN( L"CN=" );
		strRDN += strName;

		CComPtr<IDispatch> pDisp = NULL;

		HRESULT hr = pDirObject->CreateDSObject( (LPWSTR) strRDN.c_str(), pAttrs, (DWORD) nTotalAttributes, &pDisp );

		delete [] pAttrs;
		delete [] pValues;
		delete [] pKeywordValues;

		if( FAILED(hr) )
		{
			throw CUDDIException( hr, L"CUDDIServiceCxnPt::Create failed in call to CreateDSObject" );
		}
	}
}

void 
CUDDIServiceCxnPt::CreateSiteContainer( 
	LPWSTR pszName, 
	LPWSTR pszDisplayName, 
	IDirectoryObject** ppContainer )
{
	//
	// Check pre-conditions
	//
	if( NULL == pszName     || NULL == pszDisplayName || 
		NULL == ppContainer || 0 == wcslen( pszName ) || 
		0 == wcslen( pszDisplayName ) )

	{
		throw CUDDIException( E_INVALIDARG, L"CUDDIServiceConnetionPoint::CreateSiteContainer failed. All arguments must be specified." );
	}

	HRESULT hr = NULL;

	//
	// Get a reference to the System container
	//
	wstring strSystemPath( L"LDAP://CN=System," );
	strSystemPath += GetRootDSE();

	CComPtr<IDirectoryObject> pSystem = NULL;
	hr = ADsGetObject( (LPWSTR) strSystemPath.c_str(), IID_IDirectoryObject, (void**) &pSystem );
	if( FAILED(hr) )
	{
		throw CUDDIException( hr, L"CUDDIServiceCxnPt::CreateSiteContainer failed. Unable to acquire the System container in Active Directory." );
	}

	//
	// Get a reference to the CN=Microsoft,CN=System container
	//
	wstring strMicrosoftPath( L"LDAP://CN=Microsoft,CN=System," );
	strMicrosoftPath += GetRootDSE();

	CComPtr<IDirectoryObject> pMicrosoft = NULL;
	hr = ADsGetObject( strMicrosoftPath.c_str(), IID_IDirectoryObject, (void**) &pMicrosoft );
	
	if( FAILED(hr) )
	{
		//
		// Create the Microsoft Container
		//
		CreateContainer( pSystem, L"CN=Microsoft", &pMicrosoft );
	}

	//
	// Get a reference to the CN=UDDI,CN=Microsoft,CN=System container
	//
	wstring strUddiPath( L"LDAP://CN=UDDI,CN=Microsoft,CN=System," );
	strUddiPath += GetRootDSE();

	CComPtr<IDirectoryObject> pUddi = NULL;
	hr = ADsGetObject( strUddiPath.c_str(),	IID_IDirectoryObject, (void**) &pUddi );
	if( FAILED(hr) )
	{
		//
		// Create the UDDI Container
		//
		CreateContainer( pMicrosoft, L"CN=UDDI", &pUddi );
	}

	//
	// Get a reference to the CN=Sites,CN=UDDI,CN=Microsoft,CN=System container
	//
	wstring strSitesPath( L"LDAP://CN=Sites,CN=UDDI,CN=Microsoft,CN=System," );
	strSitesPath += GetRootDSE();

	CComPtr<IDirectoryObject> pSites = NULL;
	hr = ADsGetObject( strSitesPath.c_str(), IID_IDirectoryObject, (void**) &pSites );
	if( FAILED(hr) )
	{
		//
		// Create the Sites Container
		//
		CreateContainer( pUddi, L"CN=Sites", &pSites );
	}

	//
	// Get a reference to the CN=<Site Name>,CN=Sites,CN=UDDI,CN=Microsoft,CN=System container
	//
	wstring strSitePath( L"LDAP://CN=" );
	strSitePath += pszName;
	strSitePath += L",CN=Sites,CN=UDDI,CN=Microsoft,CN=System,";
	strSitePath += GetRootDSE();

	hr = ADsGetObject( strSitePath.c_str(), IID_IDirectoryObject, (void**) ppContainer );
	if( FAILED(hr) )
	{
		//
		// Create the Sites Container
		//
		wstring strSiteName( L"CN=" );
		strSiteName += pszName;
		CreateContainer( pSites, (LPWSTR) strSiteName.c_str(), ppContainer );
	}

	//
	// Set the display name on the site container
	//
	CComPtr<IADs> pADs = NULL;
	hr = (*ppContainer)->QueryInterface( IID_IADs, (void**) &pADs );
	if( FAILED(hr) )
	{
		throw CUDDIException( hr, L"CUDDIServiceCxnPt::CreateSiteContainer failed. Unable to acquire IADs interface pointer." );
	}

	CComBSTR bstrDispName( L"displayName" );
	hr = pADs->Put( bstrDispName, CComVariant( pszDisplayName ) );
	if( FAILED(hr) )
	{
		throw CUDDIException( hr, L"CUDDIServiceCxnPt::CreateSiteContainer failed. Attempt to Put displayName failed." );
	}

	CComBSTR bstrDesc( L"description" );
	hr = pADs->Put( bstrDesc, CComVariant( pszDisplayName ) );
	if( FAILED(hr) )
	{
		throw CUDDIException( hr, L"CUDDIServiceCxnPt::CreateSiteContainer failed. Attempt to Put displayName failed." );
	}

	hr = pADs->SetInfo();
	if( FAILED(hr) )
	{
		throw CUDDIException( hr, L"CUDDIServiceCxnPt::CreateSiteContainer failed. Attempt to SetInfo failed." );
	}
}

void 
CUDDIServiceCxnPt::CreateContainer( 
	IDirectoryObject* pObj, 
	LPWSTR szName, 
	IDirectoryObject** ppContainer )
{
	//
	// Check pre-conditions
	//
	if( NULL == pObj || NULL == ppContainer || NULL == szName )
	{
		throw CUDDIException( E_INVALIDARG, L"CUDDIServiceCxnPt::CreateContainer failed. All arguments must be specified." );
	}

	//
	// Create the value structure for the objectClass
	//
	HRESULT hr = 0;
	ADSVALUE classValue;
	ADS_ATTR_INFO attrInfo[] = 
	{  
		{ L"objectClass", ADS_ATTR_UPDATE, ADSTYPE_CASE_IGNORE_STRING, &classValue, 1 },
	};

	DWORD dwAttrs = sizeof(attrInfo)/sizeof(ADS_ATTR_INFO); 

	classValue.dwType = ADSTYPE_CASE_IGNORE_STRING;
	classValue.CaseIgnoreString = L"container";

	//
	// Create the container as a child of the specified parent
	//
	IDispatch* pDisp = NULL;
	if( pObj )
	{
		hr = pObj->CreateDSObject( szName, attrInfo, dwAttrs, &pDisp );

		if( FAILED(hr) )
		{
			throw CUDDIException( hr, L"CreateContainer() failed on CreateDSObject" );
		}
	}

	//
	// QI for an IDirectoryObject interface
	//
	if( pDisp )
	{
		hr = pDisp->QueryInterface( IID_IDirectoryObject, (void**) ppContainer );
		pDisp->Release();

		if( FAILED(hr) )
		{
			throw CUDDIException( hr, L"QueryInterface failed looking for IDirectoryObject" );
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\mmc\servercheck.cpp ===
#ifndef _WIN32_WINNT 
#define _WIN32_WINNT 0x0510
#endif

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
#endif

#define SECURITY_WIN32

#include <windows.h>
#include <objbase.h>
#include <atlbase.h>
#include <Security.h>
#include <wbemidl.h>
#include <string.h>
#include "globals.h"

static HRESULT GetOSProductSuiteMask( LPCTSTR pszRemoteServer, UINT *pdwMask );

HRESULT
GetOSProductSuiteMask( LPCTSTR szRemoteServer, UINT *pdwMask )
{
	HRESULT hr = S_OK;

	if( IsBadWritePtr( pdwMask, sizeof( UINT ) ) )
	{
		return E_INVALIDARG;
	}

	try
	{
		DWORD		retCount = 0;
		TCHAR		buf[ 512 ] = {0};
		LPCTSTR		locatorPath = L"//%s/root/cimv2";	
		CComBSTR	objQry = L"SELECT * FROM Win32_OperatingSystem";

		CComPtr<IWbemClassObject>		pWMIOS;
		CComPtr<IWbemServices>			pWMISvc;	
		CComPtr<IWbemLocator>			pWMILocator;
		CComPtr<IEnumWbemClassObject>	pWMIEnum;

		//
		// First, compose the locator string
		//
		if( szRemoteServer )
		{
			_stprintf( buf, locatorPath, szRemoteServer );
		}
		else
		{
			_stprintf( buf, locatorPath, _T(".") );
		}

		hr = pWMILocator.CoCreateInstance( CLSID_WbemLocator );
		if( FAILED(hr) )
		{
			throw hr;
		}

		BSTR bstrBuf = ::SysAllocString( buf );
		if( NULL == bstrBuf )
		{
			throw E_OUTOFMEMORY;
		}

		hr = pWMILocator->ConnectServer( bstrBuf, NULL, NULL, NULL, 
										WBEM_FLAG_CONNECT_USE_MAX_WAIT, 
										NULL, NULL, &pWMISvc );
		::SysFreeString( bstrBuf );
		if( FAILED(hr) )
		{
			throw hr;
		}

		hr = CoSetProxyBlanket( pWMISvc,
								RPC_C_AUTHN_WINNT,
								RPC_C_AUTHZ_NONE,
								NULL,
								RPC_C_AUTHN_LEVEL_CALL,
								RPC_C_IMP_LEVEL_IMPERSONATE,
								NULL,
								EOAC_NONE );
		if( FAILED(hr) )
		{
			throw hr;
		}

		//
		// Now get the Win32_OperatingSystem instances and check the first one found
		//
		hr = pWMISvc->ExecQuery( CComBSTR( L"WQL" ), objQry, 
								 WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_ENSURE_LOCATABLE, 
								 NULL, &pWMIEnum );
		if( FAILED(hr) )
		{
			throw hr;
		}
	
		hr = pWMIEnum->Next( 60000, 1, &pWMIOS, &retCount );
		if( WBEM_S_NO_ERROR == hr )
		{
			VARIANT vt;
			CIMTYPE	cimType;
			long	flavor = 0;

			ZeroMemory( &vt, sizeof( vt ) );
			VariantInit( &vt );

			hr = pWMIOS->Get( L"SuiteMask", 0, &vt, &cimType, &flavor );
			if( FAILED( hr ) )
			{
				VariantClear( &vt );
				throw hr;
			}

			if( VT_NULL == vt.vt || VT_EMPTY == vt.vt )
			{
				VariantClear( &vt );
				throw E_FAIL;
			}

			hr = VariantChangeType( &vt, &vt, 0, VT_UINT );
			if( FAILED( hr ) )
			{
				VariantClear( &vt );
				throw hr;
			}

			*pdwMask = vt.uintVal;
		}
	}
	catch( HRESULT hrErr )
	{
		hr = hrErr;
	}
	catch(...)
	{
		hr = E_UNEXPECTED;
	}

	return hr;
}


HRESULT
IsStandardServer( LPCTSTR szRemoteServer, BOOL *pbResult )
{
	if( IsBadWritePtr( pbResult, sizeof( BOOL ) ) )
	{
		return E_INVALIDARG;
	}

	HRESULT hr = E_FAIL;
	UINT uSuiteMask = 0;
	hr = GetOSProductSuiteMask( szRemoteServer, &uSuiteMask );
	if( FAILED(hr) )
	{
		return hr;
	}

	if( ( uSuiteMask & VER_SUITE_DATACENTER ) || ( uSuiteMask & VER_SUITE_ENTERPRISE ) )
	{
		*pbResult = FALSE;
	}
	else
	{
		*pbResult = TRUE;
	}

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\mmc\stringutil.cpp ===
#include "globals.h"
#include <ctype.h>


//
// Convert wszBuf to upper case in-place (ie, modify the existing string).
//
void
ToUpper( WCHAR *wszBuf )
{
	//
	// Param check.  strlen crashes when you pass it NULL, so the assumption
	// is that wcslen does also.
	//
	if( NULL == wszBuf )
	{
		return;
	}

	const int iLen = wcslen( wszBuf );

	//
	// For each character that needs to be converted to upper case, do
	// the conversion in-place.
	//
	for( int i = 0; i < iLen; i++ )
	{
		if( iswlower( wszBuf[ i ] ) )
		{
			wszBuf[ i ] = towupper( wszBuf[ i ] );
		}
	}
}


//
// Convert wszBuf to lower case in-place (ie, modify the existing string).
//
void
ToLower( WCHAR *wszBuf )
{
	//
	// Param check.  strlen crashes when you pass it NULL, so the assumption
	// is that wcslen does also.
	//
	if( NULL == wszBuf )
	{
		return;
	}

	const int iLen = wcslen( wszBuf );

	//
	// For each character that needs to be converted to upper case, do
	// the conversion in-place.
	//
	for( int i = 0; i < iLen; i++ )
	{
		if( iswupper( wszBuf[ i ] ) )
		{
			wszBuf[ i ] = towlower( wszBuf[ i ] );
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\mmc\scppublisher.cpp ===
#include <atldbcli.h>
#include <wchar.h>
#include "net_config_get.h"
#include "net_businessEntity_bindingTemplates_get.h"
#include "net_bindingTemplate_tModelInstanceInfos_get.h"
#include "uddi.h"
#include "globals.h"
#include "scppublisher.h"

using namespace std;

void HandleErrorRecords( HRESULT hrErr );

CUDDIServiceCxnPtPublisher::CUDDIServiceCxnPtPublisher( const wstring& strConnectionString, const wstring& strSiteKey, const wstring& strSiteName, const wstring& strDefaultDiscoveryUrl )
: m_strConnectionString( strConnectionString )
, m_strSiteKey(strSiteKey)
, m_strSiteName(strSiteName)
, m_strDefaultDiscoveryUrl(strDefaultDiscoveryUrl)
, m_pSiteContainer( NULL )
{
}

CUDDIServiceCxnPtPublisher::~CUDDIServiceCxnPtPublisher()
{
	//
	// Commit each the service connection points
	//
	for( CUDDIServiceCxnPtPublisher::iterator iter = this->begin(); iter != this->end(); iter++ )
	{
		delete (*iter);
	}
}

void CUDDIServiceCxnPtPublisher::PublishServiceCxnPts( IDirectoryObject *pDirObject )
{
	if( NULL != pDirObject )
		m_pSiteContainer = pDirObject;

	//
	// There is no binding for the discovery url so we must add it independently
	//
	AddDiscoveryUrlScp();

	//
	// Commit each the service connection points
	//
	for( CUDDIServiceCxnPtPublisher::iterator iter = this->begin(); iter != this->end(); iter++ )
	{
		(*iter)->Create( m_pSiteContainer );
	}
}

void CUDDIServiceCxnPtPublisher::CreateSiteContainer()
{
	CUDDIServiceCxnPt::CreateSiteContainer( (LPWSTR) m_strSiteKey.c_str(), (LPWSTR) m_strSiteName.c_str(), &m_pSiteContainer );
}

void CUDDIServiceCxnPtPublisher::DeleteSiteContainer()
{
	CUDDIServiceCxnPt::DeleteSiteContainer( (LPWSTR) m_strSiteKey.c_str() );
}

void CUDDIServiceCxnPtPublisher::ProcessSite()
{
	if( 0 == m_strConnectionString.length() ||
		0 == m_strSiteKey.length() ||
		0 == m_strSiteName.length() ||
		0 == m_strDefaultDiscoveryUrl.length() )
	{
		throw CUDDIException( E_INVALIDARG, L"The default provider information for this site was not found." );
	}

	//
	// Get all the bindings for the provider for the site
	//
	net_businessEntity_bindingTemplates_get getbindings;
	getbindings.m_connectionString = m_strConnectionString.c_str();
	wcsncpy( getbindings.m_businessKey, m_strSiteKey.c_str(), ARRAYLEN( getbindings.m_businessKey ) );
	getbindings.m_businessKey[ ARRAYLEN( getbindings.m_businessKey ) - 1 ] = NULL;

	DBROWCOUNT rowCount;
	HRESULT hr = getbindings.Open();
	
	while( SUCCEEDED(hr) && hr != DB_S_NORESULT )
	{
		if( NULL != getbindings.GetInterface() )
		{
			HRESULT hr2 = getbindings.Bind();
			if( SUCCEEDED( hr2 ) )
			{
				while( S_OK == getbindings.MoveNext() )
				{
					ProcessBinding( StripBraces( getbindings.m_colbindingKey ), getbindings.m_colaccessPoint );
				}
			}
		}

		hr = getbindings.GetNextResult( &rowCount );
	}

	if( FAILED(hr) )
		HandleErrorRecords(hr);

	getbindings.Close();
}

void CUDDIServiceCxnPtPublisher::ProcessBinding( const wstring& strBindingKey, const wstring& strAccessPoint )
{
	try
	{
		HRESULT hr = S_OK;
		wstring strAuthenticationKey( L"" );
		wstring strAuthenticationVerb( L"" );
		wstring strKey( L"" );

		//
		// Get all the tModelInstanceInfo records for each binding
		//
		net_bindingTemplate_tModelInstanceInfos_get gettmii;
		gettmii.m_connectionString = m_strConnectionString.c_str();
		wcsncpy( gettmii.m_bindingKey, strBindingKey.c_str(), sizeof( gettmii.m_bindingKey ) / sizeof( WCHAR ) );
		gettmii.m_bindingKey[ sizeof( gettmii.m_bindingKey ) / sizeof( WCHAR ) - 1 ] = NULL;

		DBROWCOUNT rowCount;
		hr = gettmii.Open();
		
		while( SUCCEEDED(hr) && hr != DB_S_NORESULT )
		{
			if( NULL != gettmii.GetInterface() )
			{
				HRESULT hr2 = gettmii.Bind();
				if( SUCCEEDED( hr2 ) )
				{
					while( S_OK == gettmii.MoveNext() )
					{
						//
						// We are going to compare these guids against
						// A number of constants so make it upper case
						// and remove the curly braces
						//
						_wcsupr( gettmii.m_coltModelKey );
						wstring strTModelKey = StripBraces( gettmii.m_coltModelKey );

						//
						// Determine the authentication mode( uddi, windows, anonymous )
						// and type( inquire, publish, addwebreference or web site )
						//
						if( CUDDIServiceCxnPt::WINDOWS_AUTHENTICATION_GUID_KEYWORD == strTModelKey ||
							CUDDIServiceCxnPt::ANONYMOUS_AUTHENTICATION_GUID_KEYWORD == strTModelKey ||
							CUDDIServiceCxnPt::UDDI_AUTHENTICATION_GUID_KEYWORD == strTModelKey )
						{
							strAuthenticationKey = strTModelKey;

							if( CUDDIServiceCxnPt::WINDOWS_AUTHENTICATION_GUID_KEYWORD == strTModelKey )
							{
								strAuthenticationVerb = CUDDIServiceCxnPt::WINDOWS_AUTHENTICATION_KEYWORD;
							}
							else if( CUDDIServiceCxnPt::UDDI_AUTHENTICATION_GUID_KEYWORD == strTModelKey )
							{
								strAuthenticationVerb = CUDDIServiceCxnPt::UDDI_AUTHENTICATION_KEYWORD;
							}
							else if( CUDDIServiceCxnPt::ANONYMOUS_AUTHENTICATION_GUID_KEYWORD == strTModelKey )
							{
								strAuthenticationVerb = CUDDIServiceCxnPt::ANONYMOUS_AUTHENTICATION_KEYWORD;
							}
						}
						else if( CUDDIServiceCxnPt::PUBLISH_GUID_KEYWORD == strTModelKey ||
								 CUDDIServiceCxnPt::PUBLISH_KEY_V2 == strTModelKey )
						{
							strKey = CUDDIServiceCxnPt::PUBLISH_GUID_KEYWORD;	
						}
						else if( CUDDIServiceCxnPt::INQUIRE_GUID_KEYWORD == strTModelKey ||
								 CUDDIServiceCxnPt::INQUIRE_KEY_V2 == strTModelKey )
						{
							strKey = CUDDIServiceCxnPt::INQUIRE_GUID_KEYWORD;	
						}
						else if( CUDDIServiceCxnPt::ADD_WEB_REFERENCE_GUID_KEYWORD == strTModelKey ||
								 CUDDIServiceCxnPt::WEB_SITE_GUID_KEYWORD == strTModelKey )
						{
							strKey = strTModelKey;
						}
					}
				}
			}

			hr = gettmii.GetNextResult( &rowCount );
		}

		if( FAILED(hr) )
			HandleErrorRecords(hr);

		gettmii.Close();

		//
		// We will only add service connection points for
		// bindings that specify both an authentication model
		// and a tmodel on our list of types.
		//
		if( strKey.length() && strAuthenticationKey.length() )
		{
			//
			// Add the appropriate Service Connection Point to
			// this collection. But don't publish yet.
			//
			if( CUDDIServiceCxnPt::PUBLISH_GUID_KEYWORD == strKey )
			{
				AddPublishScp( strBindingKey, strAccessPoint, strKey, strAuthenticationKey, strAuthenticationVerb );
			}
			else if( CUDDIServiceCxnPt::INQUIRE_GUID_KEYWORD == strKey )
			{
				AddInquireScp( strBindingKey, strAccessPoint, strKey, strAuthenticationKey, strAuthenticationVerb );
			}
			else if(  CUDDIServiceCxnPt::ADD_WEB_REFERENCE_GUID_KEYWORD == strKey )
			{
				AddAddWebReferenceScp( strBindingKey, strAccessPoint, strKey, strAuthenticationKey, strAuthenticationVerb );
			}
			else if( CUDDIServiceCxnPt::WEB_SITE_GUID_KEYWORD == strKey )
			{
				AddWebSiteScp( strBindingKey, strAccessPoint, strKey, strAuthenticationKey, strAuthenticationVerb );
			}
		}
		else
		{
			OutputDebugStringW( L"Binding not published:\n" );
			OutputDebugStringW( L"Binding Key:\n" );
			OutputDebugStringW( strBindingKey.c_str() );
			OutputDebugStringW( L"\ntModelKey: " );
			OutputDebugStringW( strKey.c_str() );
			OutputDebugStringW( L"\nAuthentication tModelKey: " );
			OutputDebugStringW( strAuthenticationKey.c_str() );
			OutputDebugStringW( L"\n" );
		}
	}
	catch( ... )
	{
	}
}

void CUDDIServiceCxnPtPublisher::AddInquireScp( const wstring& strBindingKey, const wstring& strAccessPoint, const wstring& strTModelKey, const wstring& strAuthenticationKey, const std::wstring& strAuthenticationVerb )
{
	try
	{
		wstring strDescription = L"UDDI Inquire API for ";
		strDescription += m_strSiteName;

		if( CUDDIServiceCxnPt::WINDOWS_AUTHENTICATION_GUID_KEYWORD == strAuthenticationKey )
			strDescription += L", binding supports Windows Authentication Model";
		else if( CUDDIServiceCxnPt::UDDI_AUTHENTICATION_GUID_KEYWORD == strAuthenticationKey )
			strDescription += L", binding supports UDDI Authentication Model";
		else if( CUDDIServiceCxnPt::ANONYMOUS_AUTHENTICATION_GUID_KEYWORD == strAuthenticationKey )
			strDescription += L", binding supports Anonymous Authentication Model";

		CUDDIServiceCxnPt* scp = new CUDDIServiceCxnPt( (LPWSTR)strBindingKey.c_str(), CUDDIServiceCxnPt::INQUIRE_SERVICE_CLASS_NAME );
		if( NULL == scp )
		{
			throw E_OUTOFMEMORY;
		}

		scp->AddDefaultKeywords();
		scp->keywords.push_back( CUDDIServiceCxnPt::INQUIRE_KEYWORD );
		scp->keywords.push_back( CUDDIServiceCxnPt::INQUIRE_GUID_KEYWORD );
		scp->keywords.push_back( strAuthenticationKey );
		scp->keywords.push_back( strAuthenticationVerb );
		scp->attributes[ L"serviceBindingInformation" ] = strAccessPoint.c_str();
		scp->attributes[ L"url" ] = strAccessPoint.c_str();
		scp->attributes[ L"description" ] = strDescription.c_str();
		scp->attributes[ L"displayName" ] = L"Inquire";
		push_back( scp );
	}
	catch( ... )
	{
		throw CUDDIException( E_FAIL, L"Execution of function CUDDIServiceCxnPtPublisher::AddPublishScp failed." );
	}
}

void CUDDIServiceCxnPtPublisher::AddPublishScp( const wstring& strBindingKey, const wstring& strAccessPoint, const wstring& strTModelKey, const wstring& strAuthenticationKey, const std::wstring& strAuthenticationVerb )
{
	try
	{
		wstring strDescription = L"UDDI Publish API for ";
		strDescription += m_strSiteName;

		if( CUDDIServiceCxnPt::WINDOWS_AUTHENTICATION_GUID_KEYWORD == strAuthenticationKey )
			strDescription += L", binding supports Windows Authentication Model";
		else if( CUDDIServiceCxnPt::UDDI_AUTHENTICATION_GUID_KEYWORD == strAuthenticationKey )
			strDescription += L", binding supports UDDI Authentication Model";
		else if( CUDDIServiceCxnPt::ANONYMOUS_AUTHENTICATION_GUID_KEYWORD == strAuthenticationKey )
			strDescription += L", binding supports Anonymous Authentication Model";

		CUDDIServiceCxnPt* scp = new CUDDIServiceCxnPt( (LPWSTR)strBindingKey.c_str(), CUDDIServiceCxnPt::PUBLISH_SERVICE_CLASSNAME );
		if( NULL == scp )
		{
			throw E_OUTOFMEMORY;
		}

		scp->AddDefaultKeywords();
		scp->keywords.push_back( CUDDIServiceCxnPt::PUBLISH_KEYWORD );
		scp->keywords.push_back( CUDDIServiceCxnPt::PUBLISH_GUID_KEYWORD );
		scp->keywords.push_back( strAuthenticationKey );
		scp->keywords.push_back( strAuthenticationVerb );
		scp->attributes[ L"serviceBindingInformation" ] = strAccessPoint.c_str();
		scp->attributes[ L"url" ] = strAccessPoint.c_str();
		scp->attributes[ L"description" ] = strDescription.c_str();
		scp->attributes[ L"displayName" ] = L"Publish";
		push_back( scp );
	}
	catch( ... )
	{
		throw CUDDIException( E_FAIL, L"Execution of function CUDDIServiceCxnPtPublisher::AddPublishScp failed." );
	}
}

void CUDDIServiceCxnPtPublisher::AddAddWebReferenceScp( const wstring& strBindingKey, const wstring& strAccessPoint, const wstring& strTModelKey, const wstring& strAuthenticationKey, const std::wstring& strAuthenticationVerb )
{
	try
	{
		wstring strDescription = L"Add Web Reference for ";
		strDescription += m_strSiteName;

		if( CUDDIServiceCxnPt::WINDOWS_AUTHENTICATION_GUID_KEYWORD == strAuthenticationKey )
			strDescription += L", binding supports Windows Authentication Model";
		else if(  CUDDIServiceCxnPt::UDDI_AUTHENTICATION_GUID_KEYWORD == strAuthenticationKey )
			strDescription += L", binding supports UDDI Authentication Model";
		else if( CUDDIServiceCxnPt::ANONYMOUS_AUTHENTICATION_GUID_KEYWORD == strAuthenticationKey )
			strDescription += L", binding supports Anonymous Authentication Model";

		CUDDIServiceCxnPt* scp = new CUDDIServiceCxnPt( (LPWSTR)strBindingKey.c_str(), CUDDIServiceCxnPt::ADD_WEB_REFERENCE_SERVICE_CLASS_NAME );
		if( NULL == scp )
		{
			throw E_OUTOFMEMORY;
		}

		scp->AddDefaultKeywords();
		scp->keywords.push_back( CUDDIServiceCxnPt::ADD_WEB_REFERENCE_KEYWORD );
		scp->keywords.push_back( CUDDIServiceCxnPt::ADD_WEB_REFERENCE_GUID_KEYWORD );
		scp->keywords.push_back( strAuthenticationKey );
		scp->keywords.push_back( strAuthenticationVerb );
		scp->attributes[ L"serviceBindingInformation" ] = strAccessPoint.c_str();
		scp->attributes[ L"url" ] = strAccessPoint.c_str();
		scp->attributes[ L"description" ] = strDescription.c_str();
		scp->attributes[ L"displayName" ] = L"Add Web Reference";
		push_back( scp );
	}
	catch( ... )
	{
		throw CUDDIException( E_FAIL, L"Execution of function CUDDIServiceCxnPtPublisher::AddAddWebReferenceScp failed." );
	}
}

void CUDDIServiceCxnPtPublisher::AddWebSiteScp( const wstring& strBindingKey, const wstring& strAccessPoint, const wstring& strTModelKey, const wstring& strAuthenticationKey, const std::wstring& strAuthenticationVerb )
{
	try
	{
		wstring strDescription = L"Web Site for ";
		strDescription += m_strSiteName;

		if(CUDDIServiceCxnPt::WINDOWS_AUTHENTICATION_GUID_KEYWORD == strAuthenticationKey )
			strDescription += L", binding supports Windows Authentication Model";
		else if( CUDDIServiceCxnPt::UDDI_AUTHENTICATION_GUID_KEYWORD == strAuthenticationKey )
			strDescription += L", binding supports UDDI Authentication Model";
		else if( CUDDIServiceCxnPt::ANONYMOUS_AUTHENTICATION_GUID_KEYWORD == strAuthenticationKey )
			strDescription += L", binding supports Anonymous Authentication Model";

		CUDDIServiceCxnPt* scp = new CUDDIServiceCxnPt( (LPWSTR)strBindingKey.c_str(), CUDDIServiceCxnPt::WEB_SITE_SERVICE_CLASS_NAME );
		if( NULL == scp )
		{
			throw E_OUTOFMEMORY;
		}

		scp->AddDefaultKeywords();
		scp->keywords.push_back( CUDDIServiceCxnPt::WEB_SITE_KEYWORD );
		scp->keywords.push_back( CUDDIServiceCxnPt::WEB_SITE_GUID_KEYWORD );
		scp->keywords.push_back( strAuthenticationKey );
		scp->keywords.push_back( strAuthenticationVerb );
		scp->attributes[ L"serviceBindingInformation" ] = strAccessPoint.c_str();
		scp->attributes[ L"url" ] = strAccessPoint.c_str();
		scp->attributes[ L"description" ] = strDescription.c_str();
		scp->attributes[ L"displayName" ] = L"Web Site";
		push_back( scp );
	}
	catch( ... )
	{
		throw CUDDIException( E_FAIL, L"Execution of function CUDDIServiceCxnPtPublisher::AddWebSiteScp failed." );
	}
}

void CUDDIServiceCxnPtPublisher::AddDiscoveryUrlScp()
{
	try
	{
		wstring strDescription = L"DiscoveryUrl for ";
		strDescription += m_strSiteName;

		//
		// No binding key exists for discovery Urls so create one
		//
		UUID uuid;
		RPC_STATUS rpcstatus = ::UuidCreate( &uuid );

		WCHAR wszUuid[ 50 ];
		::StringFromGUID2( uuid, wszUuid, sizeof( wszUuid ) / sizeof( WCHAR ) );

		CUDDIServiceCxnPt* scp = new CUDDIServiceCxnPt( (LPWSTR) StripBraces( wszUuid ).c_str(), CUDDIServiceCxnPt::DISCOVERYURL_SERVICE_CLASS_NAME );
		if( NULL == scp )
		{
			throw E_OUTOFMEMORY;
		}

		scp->AddDefaultKeywords();
		scp->keywords.push_back( CUDDIServiceCxnPt::DISCOVERY_URL_KEYWORD );
		scp->keywords.push_back( CUDDIServiceCxnPt::DISCOVERYURL_GUID_KEYWORD );

		wstring strUrl = m_strDefaultDiscoveryUrl;
		strUrl += m_strSiteKey;

		scp->attributes[ L"serviceBindingInformation" ] = strUrl;
		scp->attributes[ L"url" ] = strUrl;
		scp->attributes[ L"description" ] = strDescription.c_str();
		scp->attributes[ L"displayName" ] = L"DiscoveryUrl";
		push_back( scp );
	}
	catch( ... )
	{
		throw CUDDIException( E_OUTOFMEMORY, L"Ran out of memory inside the function AddDiscoveryUrlScp." );
		return;
	}
}


//
// This function will retrieve the UDDI Site information
// needed to publish the default provider information into
// Active Directory using Service Publication. It uses
// the net_config_get stored procedure.
//
void CUDDIServiceCxnPtPublisher::GetSiteInfo()
{
	if( 0 == m_strConnectionString.length() )
	{
		throw CUDDIException( E_INVALIDARG, L"An attempt to retrieve the UDDI site information failed because the connection string was not specified" );
	}

	try
	{
		//
		// Setup the net_config_get stored procedure object.
		//
		net_config_get rs;
		rs.m_connectionString = m_strConnectionString.c_str();
		DBROWCOUNT rowCount;
		HRESULT hr = rs.Open();
		
		while( SUCCEEDED(hr) && hr != DB_S_NORESULT )
		{
			if( NULL != rs.GetInterface() )
			{
				HRESULT hr2 = rs.Bind();
				if( SUCCEEDED( hr2 ) )
				{
					while( S_OK == rs.MoveNext() )
					{
						_ASSERT( !rs.m_dwconfigNameStatus );
						_ASSERT( !rs.m_dwconfigValueStatus );

						//
						// Save the Site.Key for follow on tests
						//
						if( 0 == _wcsicmp( rs.m_configName, L"Site.Key" ) )
							m_strSiteKey = rs.m_configValue;
						else if( 0 == _wcsicmp( rs.m_configName, L"Site.Name" ) )
						{
							//
							// Save the default provider name to use
							// for the displayName for the site container
							//
							m_strSiteName = rs.m_configValue;
						}
						else if( 0 == _wcsicmp( rs.m_configName, L"DefaultDiscoveryUrl" ) )
						{
							//
							// We'll also need the DefaultDiscoveryUrl prefix
							// to be able to publish the Service Connection Point
							// associated with it.
							//
							m_strSiteName = rs.m_configValue;
						}
					}
				}
			}

			hr = rs.GetNextResult( &rowCount );
		}

		if( FAILED(hr) )
		{
			HandleErrorRecords(hr);
		}
	}
	catch( ... )
	{
		throw CUDDIException( E_FAIL, L"An attempt to retrieve the UDDI site information failed." );
	}
}

wstring CUDDIServiceCxnPtPublisher::StripBraces( LPWSTR szKey )
{
	//
	// Converts {3172C204-058E-4E41-9CD3-7C1FD49FC44F} into 3172C204-058E-4E41-9CD3-7C1FD49FC44F
	//
	size_t n = wcslen( szKey );

	if( 38 == n && '{' == szKey[ 0 ] && '}' == szKey[ n - 1 ] )
	{
		return wstring( &szKey[ 1 ], 36 );
	}

	return wstring( szKey );
}

void HandleErrorRecords( HRESULT hrErr )
{
	CDBErrorInfo ErrorInfo;
	ULONG        cRecords = 0;
	HRESULT      hr;
	ULONG        i;
	CComBSTR     bstrDesc, bstrHelpFile, bstrSource, bstrMsg;
	GUID         guid;
	DWORD        dwHelpContext;
	WCHAR        wszGuid[ 40 ];
	USES_CONVERSION;

	ErrorInfo.m_spErrorInfo = NULL;
	ErrorInfo.m_spErrorRecords = NULL;

	//
	// If the user passed in an HRESULT then trace it
	//
	if( hrErr != S_OK )
	{
		TCHAR sz[ 256 ];
		_stprintf( sz, _T("OLE DB Error Record dump for hr = 0x%x\n"), hrErr );
		bstrMsg += sz;
	}

	LCID lcLocale = GetSystemDefaultLCID();

	hr = ErrorInfo.GetErrorRecords(&cRecords);
	if( FAILED(hr) && NULL == ErrorInfo.m_spErrorInfo.p )
	{
		TCHAR sz[ 256 ];
		_stprintf( sz, _T("No OLE DB Error Information found: hr = 0x%x\n"), hr );
		bstrMsg += sz;
	}
	else
	{
		for( i=0; i < cRecords; i++ )
		{
			hr = ErrorInfo.GetAllErrorInfo(i, lcLocale, &bstrDesc, &bstrSource, &guid,
										&dwHelpContext, &bstrHelpFile);
			if( FAILED(hr) )
			{
				TCHAR sz[ 256 ];
				_stprintf( sz, _T("OLE DB Error Record dump retrieval failed: hr = 0x%x\n"), hr );
				bstrMsg += sz;
				break;
			}

			StringFromGUID2( guid, wszGuid, sizeof(wszGuid) / sizeof(WCHAR) );
			TCHAR sz[ 256 ];
			_stprintf( 
				sz, 
				_T("Row #: %4d Source: \"%s\" Description: \"%s\" Help File: \"%s\" Help Context: %4d GUID: %s\n"),
		        i, OLE2T(bstrSource), OLE2T(bstrDesc), OLE2T(bstrHelpFile), dwHelpContext, OLE2T(wszGuid) );

			bstrMsg += sz;

			bstrSource.Empty();
			bstrDesc.Empty();
			bstrHelpFile.Empty();
		}

		bstrMsg += _T("OLE DB Error Record dump end\n");

		throw CUDDIException( hr, bstrMsg.m_str );
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\mmc\uddi.h ===
#pragma once

#include <windows.h>
#include <oleauto.h>
#include <limits.h>
#include <tchar.h>
#include <string>
#include <sstream>
#include <vector>
using namespace std;

#ifdef _UNICODE
#define tstring wstring
#define tstringstream wstringstream
#else	// #ifdef _UNICODE
#define tstring string
#define tstringstream stringstream
#endif 	// #ifdef _UNICODE

//
// useful debug macros
//

//
// pragma message macro
// usage:
//   #pragma UDDIMSG(Fix this later)
// outputs during compile:
//   C:\...\Foo.c(25) : Fix this later
//
#define UDDISTR2(x) #x
#define UDDISTR(x)  UDDISTR2(x)
#define UDDIMSG(x)  message(__FILE__ "(" UDDISTR(__LINE__) ") : " #x)

//
// Break macro - break in debugger
//
#ifdef _X86_
#define UDDIBREAK() _asm { int 3 }
#endif

//
// Assertion macro - trace a message and break if assertion failes
//
#if defined( _DEBUG ) || defined( DBG )
//
// Print the location and expression of the assertion and halt
//
#define UDDIASSERT(exp)													\
	if( !(exp) )														\
	{																	\
		char psz[256];													\
		::_snprintf(psz, 256, "%s(%d) : Assertion Failed! - %s\n",		\
					__FILE__, __LINE__, #exp);							\
		OutputDebugStringA(psz);										\
		UDDIBREAK();													\
	}
#else
#define UDDIASSERT(exp)
#endif

//
// Verify macro - like UDDIASSERT but remains in all builds
//

#define UDDIVERIFYST(exp, id, hinst) \
if( !(exp) ) \
{ \
	_TCHAR szLocalizedString[ 512 ];					\
	::LoadString( hinst, id, szLocalizedString, 512 ); \
	OutputDebugString( szLocalizedString );							\
	throw CUDDIException((HRESULT)E_FAIL,							\
				szLocalizedString, _T(__FILE__),					\
				__LINE__, _T(__TIMESTAMP__), _T(__FUNCTION__) );	\
}

#define UDDIVERIFY(exp, str) \
if( !(exp) ) \
{ \
	OutputDebugString( str );										\
	throw CUDDIException((HRESULT)E_FAIL,							\
				str, _T(__FILE__),									\
				__LINE__, _T(__TIMESTAMP__), _T(__FUNCTION__) );	\
}

//
// Verify an hresult - trace description of message if bad HRESULT
//
#define UDDIVERIFYHR(hr)												\
	if( !SUCCEEDED(hr) )												\
	{																	\
		LPWSTR lpMsg;													\
		int n = ::FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER |		\
								 FORMAT_MESSAGE_FROM_SYSTEM |			\
								 FORMAT_MESSAGE_IGNORE_INSERTS,			\
								 NULL, (hr), 0,							\
								 (LPWSTR)&lpMsg, 0, NULL);				\
		if( n != 0 ) {													\
			lpMsg[::wcslen(lpMsg) - 2] = 0;								\
		} else {														\
			lpMsg = L"Unknown";											\
		}																\
		wstring strMsg(lpMsg);											\
		::LocalFree(lpMsg);												\
		throw CUDDIException((HRESULT)(hr), strMsg, _T(__FILE__),			\
						   __LINE__, _T(__TIMESTAMP__), _T(__FUNCTION__));	\
	}


//
// Verify an API call - trace description of message if GetLastError fails
//
#define UDDIVERIFYAPI()													\
	if( ::GetLastError() != ERROR_SUCCESS )								\
	{																	\
		DWORD dwErr = ::GetLastError();									\
		LPWSTR lpMsg;													\
		int n = ::FormatMessageW( FORMAT_MESSAGE_ALLOCATE_BUFFER |		\
								  FORMAT_MESSAGE_FROM_SYSTEM |			\
								  FORMAT_MESSAGE_IGNORE_INSERTS,			\
								  NULL, dwErr, 0,						\
								  (LPWSTR)&lpMsg, 0, NULL);				\
		if( n != 0 ) {													\
			lpMsg[ ::wcslen(lpMsg) - 2 ] = 0;							\
		} else {														\
			lpMsg = L"Unknown";											\
		}																\
		wstring strMsg( lpMsg );										\
		::LocalFree(lpMsg);												\
		throw CUDDIException((dwErr), strMsg.c_str(), _T(__FILE__),		\
						   __LINE__, _T(__TIMESTAMP__), _T(__FUNCTION__) );	\
	}


//
// main tracing function
//
void UDDITRACE( const char* pszFile, int nLine,
			  int nSev, int nCat,
			  const wchar_t* pszContext,
			  const wchar_t* pszFormat, ... );

//
// Severity codes
//   use when calling UDDITRACE to pull in file/line number
//
#define UDDI_SEVERITY_ERR			__FILE__, __LINE__, 0x01	// EVENTLOG_ERROR_TYPE       These are in WINNT.H
#define UDDI_SEVERITY_WARN			__FILE__, __LINE__, 0x02	// EVENTLOG_WARNING_TYPE
#define UDDI_SEVERITY_INFO			__FILE__, __LINE__, 0x04	// EVENTLOG_INFORMATION_TYPE
#define UDDI_SEVERITY_PASS			__FILE__, __LINE__, 0x08	// EVENTLOG_AUDIT_SUCCESS
#define UDDI_SEVERITY_FAIL			__FILE__, __LINE__, 0x10	// EVENTLOG_AUDIT_FAILURE
#define UDDI_SEVERITY_VERB			__FILE__, __LINE__, 0x20	// most detailed output

//
// Category codes
//
#define UDDI_CATEGORY_NONE			0x00
#define UDDI_CATEGORY_UI			0x01
#define UDDI_CATEGORY_MMC			0x02
#define UDDI_CATEGORY_INSTALL		0x03

//
//  Class CUDDIException
//	General exception class used for exception handling throughout.
//
class CUDDIException
{
public:

	//
	//  Default constructor for CUDDIException
	//	Simply sets default parameters.
	//
	CUDDIException() 
		: m_dwErr( -1 )
		, m_hrErr( E_FAIL )
		, m_sErr( _T( "Unknown error" ) )
		, m_iLine( -1 ) {}

	//
	//  Copy constructor for CUDDIException
	//	Deep copy from _copy.
	//	Params:
	//		_copy	- the source object from which to copy.
	//
	CUDDIException( const CUDDIException& _copy ) 
		: m_dwErr( _copy.m_dwErr )
		, m_hrErr( _copy.m_hrErr )
		, m_sErr( _copy.m_sErr )
		, m_sBuildTimestamp( _copy.m_sBuildTimestamp )
		, m_sFile( _copy.m_sFile )
		, m_iLine( _copy.m_iLine )
		, m_sFunction( _copy.m_sFunction ) {}

	//
	//  Constructor for CUDDIException
	//	Generates error info from a DWORD, meaning that it assumes
	//	the DWORD was generated from GetLastError() and uses the
	//	system FormatMessage() function to get the error text.
	//	Params:
	//		_err		- a value returned from GetLastError().
	//		_file		- the source file name where the error occurred.
	//		_line		- the line number in the source where the error
	//					  occurred.
	//		_timestamp	- the build timestamp of the file where the
	//					  error occurred.
	//
	CUDDIException( DWORD _err, const tstring& _file = _T( "" ), int _line = -1, 
		     const tstring& _timestamp = _T( "" ), const tstring& _function = _T("") ) 
		: m_dwErr( _err )
		, m_hrErr( E_FAIL )
		, m_sBuildTimestamp( _timestamp )
		, m_sFile( _file )
		, m_iLine( _line )
		, m_sFunction( _function )
	{
		LPVOID lpMsgBuf;
		FormatMessage(	// Gets the error text from the OS
			FORMAT_MESSAGE_ALLOCATE_BUFFER |
			FORMAT_MESSAGE_FROM_SYSTEM |
			FORMAT_MESSAGE_IGNORE_INSERTS,
			NULL,
			_err,
			MAKELANGID( LANG_NEUTRAL, SUBLANG_DEFAULT ),
			( LPTSTR )&lpMsgBuf,
			0,
			NULL
		);
		m_sErr = ( LPTSTR )lpMsgBuf;
		LocalFree( lpMsgBuf );
	}

	//
	//  Constructor for CUDDIException
	//	Stores error info from a DWORD and passed-in string.
	//	Params:
	//		_err		- a DWORD error value.
	//		_str		- error text.
	//		_file		- the source file name where the error occurred.
	//		_line		- the line number in the source where the error
	//					  occurred.
	//		_timestamp	- the build timestamp of the file where the
	//					  error occurred.
	//
	CUDDIException( DWORD _err, const tstring& _str, const tstring& _file = _T( "" ), 
		     int _line = -1, const tstring& _timestamp = _T( "" ), const tstring& _function = _T("") )
		: m_dwErr( _err )
		, m_sErr( _str )
		, m_hrErr( E_FAIL )
		, m_sBuildTimestamp( _timestamp )
		, m_sFile( _file )
		, m_iLine( _line )
		, m_sFunction(_function) {}

	//
	//  Constructor for CUDDIException
	//	Stores error info from an HRESULT and an error string.
	//	Params:
	//		_hr			- an HRESULT.
	//		_str		- an error string.
	//		_file		- the source file name where the error occurred.
	//		_line		- the line number in the source where the error
	//					  occurred.
	//		_timestamp	- the build timestamp of the file where the
	//					  error occurred.
	//
	CUDDIException( HRESULT _hr, const tstring& _str, const tstring& _file = _T( "" ), 
		     int _line = -1, const tstring& _timestamp = _T( "" ), const tstring& _function = _T("") )
		: m_dwErr( -1 )
		, m_sErr( _str )
		, m_hrErr( _hr )
		, m_sBuildTimestamp( _timestamp )
		, m_sFile( _file )
		, m_iLine( _line )
		, m_sFunction( _function ) {}

	//
	//  Constructor for CUDDIException
	//	Stores error info from an error string.
	//	Params:
	//		_str		- an error string.
	//		_file		- the source file name where the error occurred.
	//		_line		- the line number in the source where the error
	//					  occurred.
	//		_timestamp	- the build timestamp of the file where the
	//					  error occurred.
	//
	CUDDIException( const tstring& _str, const tstring& _file = _T( "" ), 
		     int _line = -1, const tstring& _timestamp = _T( "" ), const tstring& _function = _T("") )
		: m_dwErr( -1 )
		, m_sErr( _str )
		, m_hrErr( E_FAIL )
		, m_sBuildTimestamp( _timestamp )
		, m_sFile( _file )
		, m_iLine( _line )
		, m_sFunction( _function ) {}

	//
	//  Assignment operator for CUDDIException
	//	Deep copy from _copy.
	//	Params:
	//		_copy	- the source object from which to copy.
	//
	CUDDIException& operator=( const CUDDIException& _copy ) 
	{
		m_dwErr = _copy.m_dwErr;
		m_hrErr = _copy.m_hrErr;
		m_sErr = _copy.m_sErr;
		m_sBuildTimestamp = _copy.m_sBuildTimestamp;
		m_sFile = _copy.m_sFile;
		m_iLine = _copy.m_iLine;
		m_sFunction = _copy.m_sFunction;
	}

	//
	//  Cast operators
	//	We use cast operators to return the various error values
	//	that can be stored in the error object.  Thus, the following
	//	code is possible:
	//		CUDDIException _err( GetLastError() );
	//		DWORD dwErr = _err;		// this will be GetLastError()
	//		HRESULT hrErr = _err;	// this will be E_FAIL
	//		Tstring strErr = _err;	// this will be the text description
	//								// of GetLastError
	//
	operator DWORD() const { return m_dwErr; }
	operator HRESULT() const { return m_hrErr; }
	operator const tstring&() const { return m_sErr; }
	operator LPCTSTR() const { return m_sErr.c_str(); }

	const tstring& GetTimeStamp() const { return m_sBuildTimestamp; }
	const tstring& GetFile() const { return m_sFile; }
	int GetLine() const { return m_iLine; }
	const tstring& GetFunction() const { return m_sFunction; }
	const tstring GetEntireError() const
	{
		tstringstream strm;
		strm	<< _T("Error: ")		<< m_sErr
				<< _T("\nCode: 0x")		<< hex << m_hrErr;

#if defined(_DEBUG) || defined(DBG)
		strm	<< _T("\nFile: ")		<< m_sFile
				<< _T("\nFunction: ")	<< m_sFunction
				<< _T("\nLine: ")		<< m_iLine;
#endif
		return strm.str();
	}

private:
	DWORD	m_dwErr;
	HRESULT m_hrErr;
	tstring m_sErr;
	
	tstring m_sBuildTimestamp;
	tstring m_sFile;
	tstring m_sFunction;
	int		m_iLine;
};

#define THROW_UDDIEXCEPTION_ST( _hr_, _id_, _hinst_ )				\
	_TCHAR szLocalizedString[ 1024 ];								\
	::LoadString( _hinst_, _id_, szLocalizedString, 1024 );			\
	throw CUDDIException((HRESULT)_hr_,								\
				szLocalizedString, _T(__FILE__),					\
				__LINE__, _T(__TIMESTAMP__), _T(__FUNCTION__) );	\


#define THROW_UDDIEXCEPTION( _hr_, _str_ )	\
	throw CUDDIException( (HRESULT)(_hr_), _str_, _T( __FILE__ ), __LINE__, _T( __TIMESTAMP__ ), _T( __FUNCTION__) );

#define THROW_UDDIEXCEPTION_RC( _rc_, _str_ )	\
	throw CUDDIException( (DWORD)(_rc_), _str_, _T( __FILE__ ), __LINE__, _T( __TIMESTAMP__ ), _T( __FUNCTION__) );

//
// 
//
typedef vector<tstring> StringVector;

class CUDDIRegistryKey
{
public:
	CUDDIRegistryKey( const tstring& szRoot, REGSAM access = KEY_ALL_ACCESS, const tstring& szComputer=_T("") );
	CUDDIRegistryKey( HKEY hHive, const tstring& szRoot, REGSAM access = KEY_ALL_ACCESS, const tstring& szComputer=_T("") );
	~CUDDIRegistryKey();
	void Close();
	DWORD GetDWORD( const LPCTSTR szName, DWORD dwDefault );
	DWORD GetDWORD( const LPCTSTR szName );
	tstring GetString( const LPCTSTR szName, const LPCTSTR szDefault );
	tstring GetString( const LPCTSTR szName );
	void GetMultiString( const LPCTSTR szName, StringVector& strs );
	void SetValue( const LPCTSTR szName, DWORD dwValue );
	void SetValue( const LPCTSTR szName, LPCTSTR szValue );
	void DeleteValue( const tstring& szValue );
	static void Create( HKEY hHive, const tstring& szPath, const tstring& szComputer=_T("") );
	static void DeleteKey( HKEY hHive, const tstring& szPath, const tstring& szComputer=_T("") );
	static BOOL KeyExists( HKEY hHive, const tstring& szPath, const tstring& szComputer=_T("") );
	//
	// implements the "get" property for the registry key handle
	//
	HKEY GetCurrentHandle()	{ return m_hkey; }

private:
	HKEY m_hHive;
	HKEY m_hkey;
	tstring m_szRoot;
};

void UDDIMsgBox( HWND hwndParent, int idMsg, int idTitle, UINT nType, LPCTSTR szDetail = NULL );
void UDDIMsgBox( HWND hwndParent, LPCTSTR szMsg, int idTitle, UINT nType, LPCTSTR szDetail = NULL );
wstring LocalizedDate( const wstring& str );
wstring LocalizedDateTime( const wstring& str );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\mmc\uddi.cpp ===
#include "uddi.h"
#include "globals.h"
#include "resource.h"
#include <shlwapi.h>

#define HKEY_CLASSES_ROOT           (( HKEY ) (ULONG_PTR)((LONG)0x80000000) )
#define HKEY_CURRENT_USER           (( HKEY ) (ULONG_PTR)((LONG)0x80000001) )
#define HKEY_LOCAL_MACHINE          (( HKEY ) (ULONG_PTR)((LONG)0x80000002) )
#define HKEY_USERS                  (( HKEY ) (ULONG_PTR)((LONG)0x80000003) )

CUDDIRegistryKey::CUDDIRegistryKey( HKEY hHive, const tstring& szRoot, REGSAM access, const tstring& szComputer )
	: m_szRoot( szRoot )
	, m_hHive( NULL )
	, m_hkey( NULL )
{
	BOOL bResult = FALSE;
	LONG lResult = 0;
	TCHAR szComputerName[ 256 ];
	DWORD dwSize = 256;
	szComputerName[ 0 ] = 0;
	bResult = GetComputerName( szComputerName, &dwSize );
	UDDIASSERT( bResult );

	//
	// Open a registry key to hHive on the remote or local server
	//
	if( szComputer == _T("") || 0 == _tcscmp( szComputerName, szComputer.c_str() ) )
	{
		lResult = RegOpenKeyEx( hHive, NULL, NULL, access, &m_hHive );
		UDDIVERIFYST( ERROR_SUCCESS == lResult, IDS_REGISTRY_OPEN_ERROR, g_hinst );
	}
	else
	{
		lResult = RegConnectRegistry( szComputer.c_str(), hHive, &m_hHive );
		UDDIVERIFYST( ERROR_SUCCESS == lResult, IDS_REGISTRY_OPEN_REMOTE_ERROR, g_hinst );
	}

	//
	// Open the UDDI sub key for READ and WRITE
	//
	lResult = RegOpenKeyEx( m_hHive, szRoot.c_str(), 0UL, access, &m_hkey );
	if( ERROR_SUCCESS != lResult )
	{
		_TCHAR szUnable[ 128 ];
		::LoadString( g_hinst, IDS_REGISTRY_UNABLE_TO_OPEN_KEY, szUnable, ARRAYLEN( szUnable ) );
		tstring str( szUnable );
		str += szRoot;

		RegCloseKey( m_hHive );
		THROW_UDDIEXCEPTION_RC( lResult, str );
	}
}

CUDDIRegistryKey::CUDDIRegistryKey( const tstring& szRoot, REGSAM access, const tstring& szComputer )
	: m_szRoot( szRoot )
	, m_hHive( NULL )
	, m_hkey( NULL )
{
	BOOL bResult = FALSE;
	LONG lResult = 0;
	TCHAR szComputerName[ 256 ];
	DWORD dwSize = 256;
	szComputerName[ 0 ] = 0;
	bResult = GetComputerName( szComputerName, &dwSize );

	//
	// Open a registry key to HKLM on the remote or local server
	//
	if( szComputer == _T("") || 0 == _tcscmp( szComputerName, szComputer.c_str() ) )
	{
		lResult = RegOpenKeyEx( HKEY_LOCAL_MACHINE, NULL, NULL, access, &m_hHive );
		UDDIVERIFYST( ERROR_SUCCESS == lResult, IDS_REGISTRY_OPEN_ERROR, g_hinst );
	}
	else
	{
		lResult = RegConnectRegistry( szComputer.c_str(), HKEY_LOCAL_MACHINE, &m_hHive );
		UDDIVERIFYST( ERROR_SUCCESS == lResult, IDS_REGISTRY_OPEN_REMOTE_ERROR, g_hinst );
	}

	//
	// Open the UDDI sub key for READ and WRITE
	//
	lResult = RegOpenKeyEx( m_hHive, szRoot.c_str(), 0UL, access, &m_hkey );
	if( ERROR_SUCCESS != lResult )
	{
		_TCHAR szUnable[ 128 ];
		::LoadString( g_hinst, IDS_REGISTRY_UNABLE_TO_OPEN_KEY, szUnable, ARRAYLEN( szUnable ) );
		tstring str( szUnable );
		str += szRoot;

		RegCloseKey( m_hHive );
		THROW_UDDIEXCEPTION_RC( lResult, str );
	}
}

CUDDIRegistryKey::~CUDDIRegistryKey()
{
	Close();
}

void 
CUDDIRegistryKey::Create( HKEY hHive, const tstring& szPath, const tstring& szComputer )
{
	BOOL bResult = FALSE;
	LONG lResult = 0;
	TCHAR szComputerName[ 256 ];
	DWORD dwSize = 256;
	szComputerName[ 0 ] = 0;
	bResult = GetComputerName( szComputerName, &dwSize );
	HKEY hRoot = NULL;
	HKEY hkey = NULL;

	UDDIASSERT( bResult );

	//
	// Open a registry key to hHive on the remote or local server
	//
	if( szComputer == _T("") || 0 == _tcscmp( szComputerName, szComputer.c_str() ) )
	{
		lResult = RegOpenKeyEx( hHive, NULL, NULL, KEY_ALL_ACCESS, &hRoot );
		UDDIVERIFYST( ERROR_SUCCESS == lResult, IDS_REGISTRY_OPEN_ERROR, g_hinst );
	}
	else
	{
		lResult = RegConnectRegistry( szComputer.c_str(), hHive, &hRoot );
		UDDIVERIFYST( ERROR_SUCCESS == lResult, IDS_REGISTRY_OPEN_REMOTE_ERROR, g_hinst );
	}

	//
	// Open the UDDI sub key for READ and WRITE
	//
	lResult = RegCreateKey( hHive, szPath.c_str(), &hkey );
	if( ERROR_SUCCESS != lResult )
	{
		_TCHAR szUnable[ 128 ];
		::LoadString( g_hinst, IDS_REGISTRY_UNABLE_TO_OPEN_KEY, szUnable, ARRAYLEN( szUnable ) );
		tstring str( szUnable );
		str += szPath;

		RegCloseKey( hRoot );
		THROW_UDDIEXCEPTION_RC( lResult, str );
	}

	RegCloseKey( hkey );
	RegCloseKey( hRoot );
}

void CUDDIRegistryKey::Close()
{
	if( m_hkey )
	{
		::RegCloseKey( m_hkey );
		m_hkey = NULL;
	}

	if( m_hHive )
	{
		::RegCloseKey( m_hHive );
		m_hHive = NULL;
	}
}

DWORD CUDDIRegistryKey::GetDWORD( const LPCTSTR szName, DWORD dwDefault )
{
	DWORD dwValue = dwDefault;

	try
	{
		dwValue = GetDWORD( szName );
	}
	catch(...)
	{
	}

	return dwValue;
}

DWORD CUDDIRegistryKey::GetDWORD( const LPCTSTR szName )
{
#if defined( _DEBUG ) || defined( DBG )
	OutputDebugString( _T("Reading Registry Value: " ) );
	OutputDebugString( szName );
	OutputDebugString( _T("\n") );
#endif
	DWORD dwValue = 0UL;
	DWORD dwSize = sizeof( dwValue );
	DWORD dwType = REG_DWORD;

	LONG lResult = RegQueryValueEx( m_hkey, szName, NULL, &dwType, (LPBYTE) &dwValue, &dwSize );
	UDDIVERIFYST( ERROR_SUCCESS == lResult, IDS_REGISTRY_FAILED_TO_READ_VALUE, g_hinst );

	return dwValue;
}

void CUDDIRegistryKey::GetMultiString( const LPCTSTR szName, StringVector& strs )
{
#if defined( _DEBUG ) || defined( DBG )
	OutputDebugString( _T("Reading Registry Value: " ) );
	OutputDebugString( szName );
	OutputDebugString( _T("\n") );
#endif
	TCHAR szValue[ 1024 ];
	DWORD dwSize = sizeof( szValue );
	DWORD dwType = REG_MULTI_SZ;

	LONG lResult = RegQueryValueEx( m_hkey, szName, NULL, &dwType, (LPBYTE) szValue, &dwSize );
	UDDIVERIFYST( ERROR_SUCCESS == lResult, IDS_REGISTRY_FAILED_TO_READ_VALUE, g_hinst );

	_TCHAR* psz = szValue;
	while( NULL != psz[ 0 ] )
	{
		strs.push_back( psz );
		psz += _tcslen( psz ) + 1;
	}
}

tstring CUDDIRegistryKey::GetString( const LPCTSTR szName, const LPCTSTR szDefault )
{
	tstring strReturn = szDefault;
	try
	{
		strReturn = GetString( szName );
	}
	catch(...)
	{
#if defined( _DEBUG ) || defined( DBG )

		OutputDebugString( _T("Failed using default value:: " ) );
		OutputDebugString( szDefault );
		OutputDebugString( _T("\n") );
#endif
	}

	return strReturn;
}

tstring CUDDIRegistryKey::GetString( const LPCTSTR szName )
{
#if defined( _DEBUG ) || defined( DBG )
	OutputDebugString( _T("Reading Registry Value: " ) );
	OutputDebugString( szName );
	OutputDebugString( _T("\n") );
#endif
	TCHAR szValue[ 1024 ];
	DWORD dwSize = sizeof( szValue );
	DWORD dwType = REG_SZ;

	LONG lResult = RegQueryValueEx( m_hkey, szName, NULL, &dwType, (LPBYTE) szValue, &dwSize );
	UDDIVERIFYST( ERROR_SUCCESS == lResult, IDS_REGISTRY_FAILED_TO_READ_VALUE, g_hinst );

	return tstring( szValue );
}

void CUDDIRegistryKey::SetValue( const LPCTSTR szName, DWORD dwValue )
{
	DWORD dwSize = sizeof( dwValue );
	LONG lResult = RegSetValueEx( m_hkey, szName, NULL, REG_DWORD, (LPBYTE) &dwValue, sizeof( dwValue ) );
	UDDIVERIFYST( ERROR_SUCCESS == lResult, IDS_REGISTRY_FAILED_TO_WRITE_VALUE, g_hinst );
}

void CUDDIRegistryKey::SetValue( const LPCTSTR szName, LPCTSTR szValue )
{
	DWORD dwSize = (DWORD) ( _tcslen( szValue ) + 1 ) * sizeof( TCHAR );
	LONG lResult = RegSetValueEx( m_hkey, szName, NULL, REG_SZ, (LPBYTE) szValue, dwSize );
	UDDIVERIFYST( ERROR_SUCCESS == lResult, IDS_REGISTRY_FAILED_TO_WRITE_VALUE, g_hinst );
}	

void CUDDIRegistryKey::DeleteValue( const tstring& szValue )
{
	LONG lResult = RegDeleteValue( m_hkey, szValue.c_str() );
	UDDIVERIFYST( ERROR_SUCCESS == lResult, IDS_REGISTRY_FAILED_TO_READ_VALUE, g_hinst );
}

BOOL CUDDIRegistryKey::KeyExists( HKEY hHive, const tstring& szPath, const tstring& szComputer )
{
	BOOL fRet = FALSE;

	TCHAR szComputerName[ 256 ];
	DWORD dwSize = 256;
	szComputerName[ 0 ] = 0;
	GetComputerName( szComputerName, &dwSize );
	HKEY hKey = NULL;
	HKEY hQueriedKey = NULL;
	LONG lResult;

	//
	// Open a registry key to HKLM on the remote or local server
	//
	if( szComputer == _T("") || 0 == _tcscmp( szComputerName, szComputer.c_str() ) )
	{
		lResult = RegOpenKeyEx( hHive, NULL, NULL, KEY_READ, &hKey );
	}
	else
	{
		lResult = RegConnectRegistry( szComputer.c_str(), hHive, &hKey );
	}

	if( ERROR_SUCCESS != lResult )
	{
		return FALSE;
	}

	lResult = RegOpenKeyEx( hKey, szPath.c_str(), 0, KEY_READ, &hQueriedKey );
	if( ERROR_SUCCESS != lResult )
	{
		fRet = FALSE;
	}
	else
	{
		fRet = TRUE;
		RegCloseKey( hQueriedKey );
	}

	RegCloseKey( hKey );
	return fRet;
}

void CUDDIRegistryKey::DeleteKey( HKEY hHive, const tstring& szPath, const tstring& szComputer )
{
	BOOL bResult = FALSE;
	LONG lResult = 0;
	TCHAR szComputerName[ 256 ];
	DWORD dwSize = 256;
	szComputerName[ 0 ] = 0;
	bResult = GetComputerName( szComputerName, &dwSize );
	HKEY hKey = NULL;

	//
	// Open a registry key to HKLM on the remote or local server
	//
	if( szComputer == _T("") || 0 == _tcscmp( szComputerName, szComputer.c_str() ) )
	{
		lResult = RegOpenKeyEx( hHive, NULL, NULL, KEY_READ, &hKey );
	}
	else
	{
		lResult = RegConnectRegistry( szComputer.c_str(), hHive, &hKey );
	}

	DWORD dwResult = SHDeleteKey( hKey, szPath.c_str() );
	UDDIVERIFYST( ERROR_SUCCESS == dwResult, IDS_REGISTRY_FAILED_TO_READ_VALUE, g_hinst );
}

void UDDIMsgBox( HWND hwndParent, int idMsg, int idTitle, UINT nType, LPCTSTR szDetail )
{
	_TCHAR szMessage[ 512 ];
	_TCHAR szTitle[ 256 ];
	
	int nResult = LoadString( g_hinst, idMsg, szMessage, ARRAYLEN( szMessage ) - 1 );
	if( nResult <= 0 )
	{
		_sntprintf( szMessage, ARRAYLEN(szMessage), _T("Message string missing. ID=%d"), idMsg );
		szMessage[ ARRAYLEN(szMessage) - 1 ] = NULL;
	}

    nResult = LoadString( g_hinst, idTitle, szTitle, ARRAYLEN( szTitle ) - 1 );
	if( nResult <= 0 )
	{
		_sntprintf( szMessage, ARRAYLEN(szTitle), _T("Title string missing. ID=%d"), idTitle );
	}

	tstring strMessage = szMessage;
#if defined(DBG) || defined(_DEBUG)
	if( szDetail )
	{
		strMessage += _T("\nDetail:\n\n");
		strMessage += szDetail;
	}
#endif
	MessageBox( hwndParent, strMessage.c_str(), szTitle, nType );
}


void UDDIMsgBox( HWND hwndParent, LPCTSTR szMsg, int idTitle, UINT nType, LPCTSTR szDetail )
{
	_TCHAR szMessage[ 512 ];
	_TCHAR szTitle[ 256 ];

	_tcsncpy( szMessage, szMsg, ARRAYLEN( szMessage ) - 1 );

    int nResult = LoadString( g_hinst, idTitle, szTitle, ARRAYLEN( szTitle ) - 1 );
	if( nResult <= 0 )
	{
		_sntprintf( szMessage, ARRAYLEN(szTitle), _T("Title string missing. ID=%d"), idTitle );
	}

	tstring strMessage = szMessage;
#if defined(DBG) || defined(_DEBUG)
	if( szDetail )
	{
		strMessage += _T("\nDetail:\n\n");
		strMessage += szDetail;
	}
#endif
	MessageBox( hwndParent, strMessage.c_str(), szTitle, nType );
}


//
// This function accepts a date expressed in the format
// mm/dd/yyyy or m/d/yyyy and returns the localized
// representation of that date in the long format.
//
wstring LocalizedDate( const wstring& str )
{
	try
	{
		size_t n = str.length();
		size_t nposMonth = str.find( L'/' );
		size_t nposDay = str.find( L'/', nposMonth + 2 );

		if( ( 1 != nposMonth && 2 != nposMonth ) ||
			( ( nposMonth + 2 != nposDay ) && 
			( nposMonth + 3 != nposDay ) )     ||
		( n < 8 || n > 10 ) )
		{
			throw "Invalid date format. Date must be of the form x/x/xxxx.";
		}

		SYSTEMTIME st;
		memset( &st, 0x00, sizeof( SYSTEMTIME ) );

		st.wYear = (WORD) _wtoi( str.substr( nposDay + 1, 4 ).c_str() );
		st.wMonth = (WORD) _wtoi( str.substr( 0, nposMonth ).c_str() );
		st.wDay = (WORD) _wtoi( str.substr( nposMonth + 1, nposDay - nposMonth ).c_str() );

		DWORD dwRC = ERROR_SUCCESS;
		wchar_t szDate[ 150 ];
		int nLen = GetDateFormatW(
			LOCALE_USER_DEFAULT,
			DATE_LONGDATE,	
			&st,			
			NULL,			
			szDate,			
			150 );			
		
		if( 0 == nLen )
		{
			throw "GetDateFormat failed";
		}

		return wstring( szDate );
	}
	catch(...)
	{
		return wstring(L"");
	}
}

wstring LocalizedDateTime( const wstring& str )
{
	try
	{
		const size_t nposMonth = 0;
		const size_t nposDay = 3;
		const size_t nposYear = 6;
		const size_t nposTime = 10;
		const size_t nposHour = 11;
		const size_t nposMinute = 14;
		const size_t nposSecond = 17;

		size_t n = str.length();

		if( L'/' != str.c_str()[nposDay - 1]		||
			L'/' != str.c_str()[nposYear - 1]		||
			L' ' != str.c_str()[nposHour - 1]		||
			L':' != str.c_str()[nposMinute - 1]	||
			L':' != str.c_str()[nposSecond - 1]	||
			n != 19 )
		{
			throw "Invalid datetime format. Date must be of the form MM/dd/yyyy HH:mm:ss";
		}

		SYSTEMTIME st;
		memset( &st, 0x00, sizeof( SYSTEMTIME ) );

		st.wYear = (WORD) _wtoi( str.substr( nposYear, 4 ).c_str() );
		st.wMonth = (WORD) _wtoi( str.substr( nposMonth, 2 ).c_str() );
		st.wDay = (WORD) _wtoi( str.substr( nposDay, 2 ).c_str() );
		st.wHour = (WORD) _wtoi( str.substr( nposHour, 2 ).c_str() );
		st.wMinute = (WORD) _wtoi( str.substr( nposMinute, 2 ).c_str() );
		st.wSecond = (WORD) _wtoi( str.substr( nposSecond, 2 ).c_str() );

		DWORD dwRC = ERROR_SUCCESS;
		wchar_t szDate[ 150 ];
		int nLen = GetDateFormat(
			LOCALE_USER_DEFAULT,
			DATE_LONGDATE,	
			&st,			
			NULL,			
			szDate,			
			ARRAYLEN( szDate ) );			
		
		if( 0 == nLen )
		{
			throw "GetDateFormat failed";
		}

		dwRC = ERROR_SUCCESS;
		wchar_t szTime[ 150 ];
		nLen = GetTimeFormat(
			LOCALE_USER_DEFAULT,
			0,	
			&st,			
			NULL,			
			szTime,			
			ARRAYLEN( szTime ) );			
		
		if( 0 == nLen )
		{
			throw "GetTimeFormat failed";
		}

		wstring strDateTime = szDate;
		strDateTime += L" ";
		strDateTime += szTime;
		return strDateTime;
	}
	catch(...)
	{
		return wstring(L"");
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\mmc\uddiservicesnode.h ===
#pragma once

#include "delebase.h"
#include <map>
using namespace std;
class CUDDISiteNode;

typedef map<int, CDelegationBase*> CChildMap;
typedef pair<int, CDelegationBase*> CChildMapEntry;

class CUDDIServicesNode : public CDelegationBase
{
public:
    CUDDIServicesNode();
    virtual ~CUDDIServicesNode();

    virtual const _TCHAR *GetDisplayName( int nCol = 0 );
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_UDDISERVICES; }
	virtual BOOL ChildExists( const WCHAR *pwszName );

	virtual BOOL IsDirty();
	virtual HRESULT Load( IStream *pStm );
	virtual HRESULT Save( IStream *pStm, BOOL fClearDirty );
	virtual ULONG GetSizeMax();

public:
	//
    // Virtual functions go here (for MMCN_*)
	//
    virtual HRESULT OnExpand( IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent );
    virtual HRESULT OnShowContextHelp( IDisplayHelp *m_ipDisplayHelp, LPOLESTR helpFile );
	virtual HRESULT OnShow( IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem );
	virtual HRESULT OnAddMenuItems( IContextMenuCallback *pContextMenuCallback, long *pInsertionsAllowed );
	virtual HRESULT OnMenuCommand( IConsole *pConsole, IConsoleNameSpace *pConsoleNameSpace, long lCommandID, IDataObject *pDataObject );
    virtual HRESULT OnRefresh( IConsole *pConsole );
    virtual HRESULT OnSelect( CComponent *pComponent, IConsole *pConsole, BOOL bScope, BOOL bSelect );
	virtual HRESULT RemoveChildren( IConsoleNameSpace *pNS );

	void SetRemoteComputerName( LPCTSTR szRemoteComputerName );
	LPCTSTR GetRemoteComputerName();
	CDelegationBase* FindChild( LPCTSTR szName );

private:
	BOOL LoadUDDISites( HWND hwndConsole, const tstring& szComputerName );
	BOOL SaveUDDISites();

	void ClearChildMap();

private:
	CChildMap m_mapChildren;
    LONG_PTR m_ppHandle;
	BOOL m_bIsDirty;
	tstring m_strDisplayName;
	tstring m_strRemoteComputerName;

    enum menuItems { IDM_NEW_DBSERVER = 1 };
    static const GUID thisGuid;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\mmc\uddiservicesnode.cpp ===
#include "uddiservicesnode.h"
#include "uddisitenode.h"
#include "webservernode.h"
#include <list>
#include <algorithm>

// {7334C141-C93C-4bb5-BB36-BDEE77BA2D87}
const GUID CUDDIServicesNode::thisGuid = { 0x7334c141, 0xc93c, 0x4bb5, { 0xbb, 0x36, 0xbd, 0xee, 0x77, 0xba, 0x2d, 0x87 } };

//==============================================================
//
// CUDDIServicesNode implementation
//
//
CUDDIServicesNode::CUDDIServicesNode()
	: m_strRemoteComputerName( _T("") )
{
}

void CUDDIServicesNode::SetRemoteComputerName( LPCTSTR szRemoteComputerName )
{
	m_strRemoteComputerName = szRemoteComputerName;
}

LPCTSTR CUDDIServicesNode::GetRemoteComputerName()
{
	return m_strRemoteComputerName.c_str();
}

CUDDIServicesNode::~CUDDIServicesNode()
{
	if( !IsExtension() )
	{
		SaveUDDISites();
	}
	ClearChildMap();
}


BOOL CUDDIServicesNode::IsDirty()
{
	return m_bIsDirty;
}

HRESULT CUDDIServicesNode::Load( IStream *pStm )
{
	return S_OK;
#if 0
	if( IsExtension() )
		return S_OK;

	ULONG ulSize = 0;
	ULONG ulRead = 0;
	HRESULT hr = pStm->Read( &ulSize, sizeof( ulSize ), &ulRead );
	if( FAILED(hr) )
	{
		return hr;
	}

	if( ulSize )
	{
		//
		// There are database servers saved in the file
		//

		//
		// Read the saved string into a buffer
		//
		PTCHAR szDatabaseNames = new TCHAR[ ulSize + 1 ];
		if( NULL == szDatabaseNames )
		{
			return E_OUTOFMEMORY;
		}

		hr =pStm->Read( szDatabaseNames, ulSize * sizeof( TCHAR ), &ulRead );
		if( FAILED(hr) )
		{
			delete [] szDatabaseNames;
			return hr;
		}

		//
		// Terminate the buffer
		//
		szDatabaseNames[ ulSize ] = NULL;
		
		//
		// Use begin and end to bracket each server name and 
		// instance name. When a pair is found add the database instance
		// node to the collection of child nodes.
		// A % character is used as the delimiter.
		//
		PTCHAR begin = szDatabaseNames;
		PTCHAR end = szDatabaseNames;
		int n = 0;
		PTCHAR szTempServerName = NULL;
		BOOL bLookingForServerName = TRUE;

		while( *end )
		{
			if( _T('%') == *end )
			{
				//
				// Found either the database name or the instance name
				//
				*end = NULL;

				if( bLookingForServerName )
				{
					//
					// Found the server name, save it and keep
					// searching for the instance name
					// before we add a node.
					//
					szTempServerName = begin;
					bLookingForServerName = FALSE;
				}
				else
				{
					//
					// Found the instance name
					// Construct and add the node to the collection
					//
					m_mapChildren[ n ] = CUDDISiteNode::Create( szTempServerName, begin, n, this, FALSE );
					n++;
					bLookingForServerName = TRUE;
				}

				//
				// Update the pointers past the delimiter
				//
				end++;
				begin = end;
			}
			else
			{
				end++;
			}
		}
	}
	return S_OK; 
#endif
}

HRESULT CUDDIServicesNode::Save( IStream *pStm, BOOL fClearDirty )
{ 
	return S_OK;

#if 0
	if( IsExtension() )
		return S_OK;

	//
	// Create a string buffer of strings delimited by %
	//
	tstring str( _T("") );

	for( CChildMap::iterator iter = m_mapChildren.begin();
 		iter != m_mapChildren.end(); iter++ )
	{
		CUDDISiteNode* pNode = (CUDDISiteNode*) iter->second;

		if( !pNode->IsDeleted() )
		{
			//
			// Server Name
			//
			str.append( pNode->GetName() );
			str.append( _T("%") );

			//
			// Database Instance Name
			//
			str.append( pNode->GetInstanceName() );
			str.append( _T("%") );
		}
	}

	//
	// Write out the size of the string into the stream
	//
	ULONG ulSize = (ULONG) str.length();
	ULONG ulWritten = 0;
	HRESULT hr = pStm->Write( &ulSize, sizeof( ulSize ), &ulWritten );
	_ASSERT( SUCCEEDED(hr) );

	//
	// Write the computer names out to the stream
	//
	hr = pStm->Write( str.c_str(), ulSize * sizeof( TCHAR ), &ulWritten );

	//
	// Clear the dirty flag if requested
	//
	if( fClearDirty )
		m_bIsDirty = FALSE;

	return hr; 
#endif

}

ULONG CUDDIServicesNode::GetSizeMax()
{ 
	ULONG ulSize = 0;

	return (ULONG) ( m_mapChildren.size() * 512 );
}

HRESULT CUDDIServicesNode::OnAddMenuItems( IContextMenuCallback *pContextMenuCallback, long *pInsertionsAllowed ) 
{
    HRESULT hr = S_OK;
	if( !IsExtension() )
	{
		WCHAR szDatabaseServerMenuText[ MAX_PATH ];
		WCHAR szDatabaseServerMenuDescription[ MAX_PATH ];

		LoadStringW( g_hinst, IDS_DATABASE_SERVER_ADD, szDatabaseServerMenuText, ARRAYLEN( szDatabaseServerMenuText ) );
		LoadStringW( g_hinst, IDS_DATABASE_SERVER_DESCRIPTION, szDatabaseServerMenuDescription, ARRAYLEN( szDatabaseServerMenuDescription ) );

		CONTEXTMENUITEM menuItemsNew[] =
		{
			{
				szDatabaseServerMenuText, szDatabaseServerMenuDescription,
				IDM_NEW_DBSERVER, CCM_INSERTIONPOINTID_PRIMARY_TOP, 0, 0
			},
			{ NULL, NULL, 0, 0, 0 }
		};

		//
		// Loop through and add each of the menu items, we
		// want to add to new menu, so see if it is allowed.
		//
		if( *pInsertionsAllowed & CCM_INSERTIONALLOWED_TOP )
		{
			for( LPCONTEXTMENUITEM m = menuItemsNew; m->strName; m++ )
			{
				hr = pContextMenuCallback->AddItem( m );
				if( FAILED(hr) )
					break;
			}
		}
	}

    return hr;
}

CDelegationBase *
CUDDIServicesNode::FindChild( LPCTSTR szName )
{
	for( CChildMap::iterator iter = m_mapChildren.begin();
 		iter != m_mapChildren.end(); iter++ )
	{
		CUDDISiteNode* pNode = reinterpret_cast<CUDDISiteNode *>( iter->second );
		if( NULL == pNode )
		{
			continue;
		}

		if( !pNode->IsDeleted() && ( 0 == _tcsicmp( szName, pNode->GetName() ) ) )
			return iter->second;
	}

	return NULL;
}

HRESULT CUDDIServicesNode::OnMenuCommand( IConsole *pConsole, IConsoleNameSpace *pConsoleNameSpace, long lCommandID, IDataObject *pDataObject )
{
	if( ( NULL == pConsole ) || ( NULL == pConsoleNameSpace ) || ( NULL == pDataObject ) )
	{
		return E_INVALIDARG;
	}

	if( IDM_NEW_DBSERVER != lCommandID )
	{
		return S_OK;
	}

	//
	// Add a new site to the console
	//
	HWND hwndConsole = NULL;
	HRESULT hr = pConsole->GetMainWindow( &hwndConsole );
	if( FAILED(hr) )
	{
		return hr;
	}

	DatabaseData data;
	data.pBase = this;
	INT_PTR nResult = DialogBoxParam( g_hinst, MAKEINTRESOURCE( IDD_SITE_CONNECT ), hwndConsole, CUDDISiteNode::NewDatabaseServerDialogProc, (LPARAM) &data );

	if( nResult )
    {
		try
		{
			//
			// Check to make sure this has the database component installed
			//
			if( !CUDDISiteNode::IsDatabaseServer( data.szServerName, data.szInstanceName ) )
			{
				_TCHAR szMessage[ 512 ];
				_TCHAR szTitle[ 128 ];
				LoadString( g_hinst, IDS_DATABASE_SERVER_SELECT_ERROR, szMessage, ARRAYLEN( szMessage ) );
				LoadString( g_hinst, IDS_DATABASE_SERVER_SELECT_ERROR_TITLE, szTitle, ARRAYLEN( szTitle ) );

				MessageBox( hwndConsole, 
							szMessage,
							szTitle,
							MB_OK );

				return S_OK;
			}
			
			if( FindChild( data.szServerName ) )
			{
				_TCHAR szMessage[ 512 ];
				_TCHAR szTitle[ 128 ];
				LoadString( g_hinst, IDS_DATABASE_SERVER_ALREADY_EXISTS, szMessage, ARRAYLEN( szMessage ) );
				LoadString( g_hinst, IDS_DATABASE_SERVER_SELECT_ERROR_TITLE, szTitle, ARRAYLEN( szTitle ) );

				MessageBox( hwndConsole, 
							szMessage,
							szTitle,
							MB_OK );

				return S_OK;
			}

			//
			// Create new UDDI Site node.  This call to Create will throw a CUDDIException
			// if it is unable to connect to the database on szServerName.
			//
			int n = (int) m_mapChildren.size();
			CUDDISiteNode *pSiteNode = CUDDISiteNode::Create( data.szServerName, data.szInstanceName, n, this, m_bIsExtension );
			m_mapChildren[ n ] = pSiteNode;

			SCOPEDATAITEM sdi;
			ZeroMemory( &sdi, sizeof(SCOPEDATAITEM) );

			sdi.mask = SDI_STR       |   // Displayname is valid
				SDI_PARAM     |   // lParam is valid
				SDI_IMAGE     |   // nImage is valid
				SDI_OPENIMAGE |   // nOpenImage is valid
				SDI_PARENT	  |
				SDI_CHILDREN;

			sdi.relativeID  = GetScopeItemValue();
			sdi.nImage      = m_mapChildren[ n ]->GetBitmapIndex();
			sdi.nOpenImage  = MMC_IMAGECALLBACK;
			sdi.displayname = MMC_CALLBACK;
			sdi.lParam      = (LPARAM) m_mapChildren[ n ];
			sdi.cChildren   = m_mapChildren[ n ]->HasChildren();

			hr = pConsoleNameSpace->InsertItem( &sdi );
			_ASSERT( SUCCEEDED(hr) );
	                    
			m_mapChildren[ n ]->SetScopeItemValue( sdi.ID );
			m_mapChildren[ n ]->SetParentScopeItem( sdi.relativeID );

			IConsoleNameSpace2 *pNS2 = NULL;
			hr = pConsoleNameSpace->QueryInterface( IID_IConsoleNameSpace2, reinterpret_cast<void **>( &pNS2 ) );
			if( FAILED(hr) )
			{
				return hr;
			}

			pNS2->Expand( sdi.ID );
			pNS2->Release();

			m_bIsDirty = TRUE;
		}
		catch( CUDDIException &e )
		{
			UDDIMsgBox( hwndConsole, (LPCTSTR) e, IDS_ERROR_TITLE, MB_ICONEXCLAMATION | MB_OK );
			return E_FAIL;
		}
		catch( ... )
		{
			UDDIMsgBox( hwndConsole, IDS_ERROR_ADDSVC, IDS_ERROR_TITLE, MB_ICONEXCLAMATION | MB_OK );
			return E_UNEXPECTED;
		}
	}
    return S_OK;
}

const _TCHAR *CUDDIServicesNode::GetDisplayName( int nCol )
{
    _TCHAR wszName[ 256 ];

	switch( nCol )
	{
	case 0:
		LoadString( g_hinst, IDS_UDDIMMC_SNAPINNAME, wszName, ARRAYLEN( wszName ) );
		break;

	case 1: 
		LoadString( g_hinst, IDS_UDDIMMC_TYPE, wszName, ARRAYLEN( wszName ) );
		break;

	case 2:
		LoadString( g_hinst, IDS_UDDIMMC_DESCRIPTION, wszName, ARRAYLEN( wszName ) );
		break;

	default:
		_tcscpy( wszName, _T("") );
		break;
	}

	m_strDisplayName = wszName;

	return m_strDisplayName.c_str();
}

HRESULT CUDDIServicesNode::OnShow( IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem )
{
    HRESULT      hr = S_OK;

    IHeaderCtrl *pHeaderCtrl = NULL;
    IResultData *pResultData = NULL;

    hr = pConsole->QueryInterface( IID_IHeaderCtrl, (void **)&pHeaderCtrl );
	if( FAILED(hr) )
	{
		return hr;
	}

    hr = pConsole->QueryInterface( IID_IResultData, (void **)&pResultData );
	if( FAILED(hr) )
	{
		pHeaderCtrl->Release();
		return hr;
	}

    if( bShow ) 
	{
		//
        // Set the column headers in the results pane
		//
		WCHAR szColumnName[ 256 ];
		::LoadStringW( g_hinst, IDS_DATABASE_SERVER_COLUMN_NAME, szColumnName, ARRAYLEN( szColumnName ) );
        hr = pHeaderCtrl->InsertColumn( 0, szColumnName, 0, 150 );
        _ASSERT( S_OK == hr );

		::LoadStringW( g_hinst, IDS_DATABASE_SERVER_COLUMN_COMPUTER, szColumnName, ARRAYLEN( szColumnName ) );
        hr = pHeaderCtrl->InsertColumn( 1, szColumnName, 0, 150 );
        _ASSERT( S_OK == hr );

		::LoadStringW( g_hinst, IDS_DATABASE_SERVER_COLUMN_INSTANCE, szColumnName, ARRAYLEN( szColumnName ) );
        hr = pHeaderCtrl->InsertColumn( 2, szColumnName, 0, 150 );
        _ASSERT( S_OK == hr );

		::LoadStringW( g_hinst, IDS_DATABASE_SERVER_COLUMN_DESCRIPTION, szColumnName, ARRAYLEN( szColumnName ) );
        hr = pHeaderCtrl->InsertColumn( 3, szColumnName, 0, 150 );
        _ASSERT( S_OK == hr );

        pHeaderCtrl->Release();
        pResultData->Release();
    }
	else
	{
//		pResultData->DeleteAllRsltItems();
	}

    return hr;
}

HRESULT
CUDDIServicesNode::OnExpand( IConsoleNameSpace *pConsoleNameSpace,
							 IConsole *pConsole,
							 HSCOPEITEM parent )
{
	if( ( NULL == pConsoleNameSpace ) || ( NULL == pConsole ) || ( NULL == parent ) )
	{
		return E_INVALIDARG;
	}

	HWND hwndConsole = NULL;
	HRESULT hr = pConsole->GetMainWindow( &hwndConsole );
	if( FAILED(hr) )
	{
		return hr;
	}

	//
    // Cache static node's HSCOPEITEM for future use
	//
    SetScopeItemValue( parent );
	
	wstring wszTargetComputerName;

	if( IsExtension() && m_strRemoteComputerName.length() > 0 )
	{
		//
		// The computer management console has been retargeted use the 
		// computer name from the console.
		//
		wszTargetComputerName = m_strRemoteComputerName;
	}
	else
	{
		//
		// Use the local machine name
		//
		WCHAR wszLocalComputerName[ 256 ];
		DWORD dwSize = ARRAYLEN( wszLocalComputerName );
		wszLocalComputerName[ 0 ] = 0x00;
		::GetComputerName( wszLocalComputerName, &dwSize );
		wszTargetComputerName = wszLocalComputerName;
	}

	LoadUDDISites( hwndConsole, wszTargetComputerName );

	//
    // Create the child nodes, then expand them
	//
	SCOPEDATAITEM sdi;
	for( CChildMap::iterator iter = m_mapChildren.begin();
	 	iter != m_mapChildren.end(); iter++ )
	{
        ZeroMemory( &sdi, sizeof(SCOPEDATAITEM) );

        sdi.mask =	SDI_STR       |   // Displayname is valid
					SDI_PARAM     |   // lParam is valid
					SDI_IMAGE     |   // nImage is valid
					SDI_OPENIMAGE |   // nOpenImage is valid
					SDI_PARENT	  |
					SDI_CHILDREN;

        sdi.relativeID  = (HSCOPEITEM) parent;
        sdi.nImage      = iter->second->GetBitmapIndex();
        sdi.nOpenImage  = MMC_IMAGECALLBACK;
        sdi.displayname = MMC_CALLBACK;
        sdi.lParam      = (LPARAM) iter->second;
        sdi.cChildren   = iter->second->HasChildren();

        hr = pConsoleNameSpace->InsertItem( &sdi );
        _ASSERT( SUCCEEDED(hr) );
                    
        iter->second->SetScopeItemValue( sdi.ID );
		iter->second->SetParentScopeItem( sdi.relativeID );

		IConsoleNameSpace2 *pNS2 = NULL;
		hr = pConsoleNameSpace->QueryInterface( IID_IConsoleNameSpace2, reinterpret_cast<void **>( &pNS2 ) );
		if( FAILED(hr) )
		{
			return hr;
		}

		pNS2->Expand( sdi.ID );
		pNS2->Release();
    }

	return hr;
}

HRESULT
CUDDIServicesNode::OnShowContextHelp( IDisplayHelp *pDisplayHelp, LPOLESTR helpFile )
{
	try
	{
		if( ( NULL == pDisplayHelp ) || ( NULL == helpFile ) )
		{
			return E_INVALIDARG;
		}

		wstring wstrTopicName = helpFile;
		wstrTopicName += g_wszUddiServicesNodeHelp;

		LPOLESTR pszTopic = static_cast<LPOLESTR>( CoTaskMemAlloc( ( wstrTopicName.length() + 1 ) * sizeof(WCHAR) ) );
		if( NULL == pszTopic )
		{
			return E_OUTOFMEMORY;
		}

		wcsncpy( pszTopic, wstrTopicName.c_str(), wstrTopicName.length() );
		pszTopic[ wstrTopicName.length() ] = NULL;

		return pDisplayHelp->ShowTopic( pszTopic );
	}
	catch( ... )
	{
		return E_OUTOFMEMORY;
	}
}


HRESULT
CUDDIServicesNode::RemoveChildren( IConsoleNameSpace *pNS )
{
	if( NULL == pNS )
	{
		return E_INVALIDARG;
	}

	for( CChildMap::iterator iter = m_mapChildren.begin();
 		iter != m_mapChildren.end(); iter++ )
	{
		CDelegationBase *pBase = reinterpret_cast<CDelegationBase *>( iter->second );
		pBase->RemoveChildren( pNS );

		HSCOPEITEM hsi = pBase->GetScopeItemValue();
		pNS->DeleteItem( hsi, TRUE );
    }
	
	ClearChildMap();

	pNS->DeleteItem( GetScopeItemValue(), TRUE );
	return S_OK;
}
HRESULT
CUDDIServicesNode::OnRefresh( IConsole *pConsole )
{
    if( NULL == pConsole )
    {
        return S_FALSE;
    }

    CChildMap::iterator it = m_mapChildren.begin();
    while( it != m_mapChildren.end() )
    {
        it->second->OnRefresh( pConsole );
        it++;
    }

    return S_OK;
}

HRESULT CUDDIServicesNode::OnSelect( CComponent *pComponent, IConsole *pConsole, BOOL bScope, BOOL bSelect )
{
	if( ( NULL == pComponent ) || ( NULL == pConsole ) )
	{
		return E_INVALIDARG;
	}

	HRESULT hr = E_FAIL;
	if( bSelect )
	{
		//
		// Enable refresh verb
		//
		IConsoleVerb *pConsoleVerb = NULL;

		hr = pConsole->QueryConsoleVerb( &pConsoleVerb );
		if( FAILED(hr) )
		{
			return hr;
		}

		hr = pConsoleVerb->SetVerbState( MMC_VERB_OPEN, ENABLED, TRUE );
		if( FAILED(hr) )
		{
			pConsoleVerb->Release();
			return hr;
		}

		hr = pConsoleVerb->SetVerbState( MMC_VERB_REFRESH, ENABLED, TRUE );
		if( FAILED(hr) )
		{
			pConsoleVerb->Release();
			return hr;
		}

		hr = pConsoleVerb->SetVerbState( MMC_VERB_DELETE, HIDDEN, TRUE );

		pConsoleVerb->Release();
	}

	return hr;
}

//
// The sole purpose of this function is to put the appropriate entries into
// m_mapChildren.  These entries are almost always CUDDISiteNode *'s, except
// in 1 case when there can be exactly 1 CUDDIWebServerNode *.
//
// The entries in m_mapChildren are determined by 3 factors:
//
// 1.  Wether we are running inside Computer Management as
//     an extension, or not.
// 2.  Wether the machine we are filling m_mapChildren for
//     hosts a UDDI Site, or not.
// 3.  Wether the machine we are filling m_mapChildren for
//     hosts a UDDI Web Server, or not.
//
// --------------------------------------------------------------------------
// Is Extension - If we are running as an extension of Computer Management,
//                then we want to show only the UDDI bits that are located
//                on the computer, AND NOTHING ELSE.
// --------------------------------------------------------------------------
// TRUE   :  Do nothing.
// --------------------------------------------------------------------------
// FALSE  :  Create 1 entry in m_mapChildren for each persisted UDDI Site.
// --------------------------------------------------------------------------
//
//
// --------------------------------------------------------------------------
// Host for UDDI Site - If szComputerName is host of a UDDI Site, then we
//                      must ensure that that UDDI Site is present
//                      in m_mapChildren.
// --------------------------------------------------------------------------
// TRUE  :  Attempt to add an entry to m_mapChildren which represents the
//          UDDI Site, if one does not already exist.
// --------------------------------------------------------------------------
// FALSE :  Do nothing.
// --------------------------------------------------------------------------
//
//
// --------------------------------------------------------------------------
// Host for UDDI Web Server - If we are running as an extension, we can only
//                            show the UDDI bits on this particular computer.
//                            So, show just the UDDI Web Server node.  If not
//                            running as an extension, add the UDDI Site that
//                            the UDDI Web Server belongs to.
// --------------------------------------------------------------------------
// TRUE  :  If Extension, add an entry for that UDDI Web Server node to
//          m_mapChildren.
//          If not, determine the UDDI Site that the UDDI Web Server belongs
//          to, and add an entry for that UDDI Site.
// --------------------------------------------------------------------------
// FALSE :  Do nothing.
// --------------------------------------------------------------------------
//
BOOL
CUDDIServicesNode::LoadUDDISites( HWND hwndConsole, const tstring& szComputerName )
{
	try
	{
		BOOL fRet = TRUE;

		list< wstring > failedSiteRefs;
		failedSiteRefs.clear();

		ClearChildMap();

		//
		// ---- #1 ----
		// 
		// If we are NOT running as an extension of Computer Management, then
		// load our list of persisted UDDI Sites.
		//
		if( FALSE == IsExtension() )
		{
			try
			{
				CUDDIRegistryKey sitesKey( HKEY_CURRENT_USER,
										g_szUDDIAdminSites,
										KEY_ALL_ACCESS,
										szComputerName.c_str() );

				HKEY hSitesKey = sitesKey.GetCurrentHandle();
				if( NULL == hSitesKey )
				{
					fRet = FALSE;
				}

				DWORD dwIndex = 0;
				int n = 0;

				WCHAR szComputer[ 128 ];
				WCHAR szInstance[ 128 ];
				DWORD dwNameSize;
				DWORD dwValueSize;
				DWORD dwType = REG_SZ;

				dwNameSize = 128;
				dwValueSize = 128 * sizeof( WCHAR );
				memset( szComputer, 0, 128 * sizeof( WCHAR ) );
				memset( szInstance, 0, 128 * sizeof( WCHAR ) );

				LONG lRet = RegEnumValue( hSitesKey,
	  									dwIndex,
										szComputer,
										&dwNameSize,
										NULL,
										&dwType,
										(LPBYTE)szInstance,
										&dwValueSize );

				while( ( ERROR_NO_MORE_ITEMS != lRet ) && ( ERROR_SUCCESS == lRet ) )
				{
					//
					// This call to Create will throw if it cannot connect to the
					// database on szComputer.  However, this might be 1 of many
					// UDDI Sites we are trying to create a reference to!  Instead
					// of exiting immediately here, just tell the user that there
					// was a problem, and continue on with the next Site in the list.
					//
					try
					{
						if( CUDDISiteNode::IsDatabaseServer( szComputer, szInstance ) )
						{
							ToUpper( szComputer );

							CUDDISiteNode *pSiteNode = CUDDISiteNode::Create( szComputer, szInstance, n, this, FALSE );
							m_mapChildren[ n ] = pSiteNode;
							n++;
						}
							dwIndex++;
					}
					catch( CUDDIException &e )
					{
						UDDIMsgBox( hwndConsole, e, IDS_ERROR_TITLE, MB_ICONEXCLAMATION | MB_OK );
						dwIndex++;

						failedSiteRefs.push_back( szComputer );
					}

					dwNameSize = 128;
					dwValueSize = 128 * sizeof( WCHAR );
					memset( szComputer, 0, 128 * sizeof( WCHAR ) );
					memset( szInstance, 0, 128 * sizeof( WCHAR ) );

					lRet = RegEnumValue( hSitesKey,
										dwIndex,
										szComputer,
										&dwNameSize,
										NULL,
										&dwType,
										(LPBYTE)szInstance,
										&dwValueSize );
				}
			}
			catch( ... )
			{
				//
				// If we are in here, it is most likely that the registry key containing
				// the names of the persisted UDDI Sites does not exist.  If this is the
				// case, continue on silently and try to determine if the local machine
				// is host for a UDDI Site and/or a UDDI Web Server.
				//
				fRet = FALSE;
			}

		}


		//
		// ---- #2 ----
		//
		// If the machine that we are running on is host for a
		// UDDI Site, and that Site is currently not in our list
		// of Sites that are to be displayed, then add it.
		//
		if( CUDDISiteNode::IsDatabaseServer( (WCHAR *)szComputerName.c_str() ) &&
			( NULL == FindChild( szComputerName.c_str() ) ) &&
			( failedSiteRefs.end() == find( failedSiteRefs.begin(), failedSiteRefs.end(), szComputerName ) ) )
		{
			try
			{
				CUDDIRegistryKey key( _T( "SOFTWARE\\Microsoft\\UDDI\\Setup\\DBServer" ),
									KEY_READ,
									szComputerName );
				int iSize = m_mapChildren.size();
				tstring strInstance;
				strInstance = key.GetString( _T("InstanceNameOnly"), _T("----") );
				CUDDISiteNode* pNode = CUDDISiteNode::Create( (WCHAR *)szComputerName.c_str(),
															  (WCHAR *)InstanceRealName( strInstance.c_str() ),
															  iSize,
															  this,
															  m_bIsExtension );
				m_mapChildren[ iSize ] = pNode;
			}
			catch( CUDDIException &e )
			{
				UDDIMsgBox( hwndConsole, e, IDS_ERROR_TITLE, MB_ICONEXCLAMATION | MB_OK );
				fRet = FALSE;
			}
			catch( ... )
			{
				fRet = FALSE;
			}
		}


		//
		// ---- #3 ----
		//
		// Determine if the local machine hosts a UDDI Web Server.  If it does,
		// determine which UDDI Site it is associated with, by examining the
		// connection string.
		//
		if( CUDDIWebServerNode::IsWebServer( szComputerName.c_str() ) )
		{
			wstring wszConnStrWriter;
			wstring wszDomain, wszServer, wszInstance;

			CUDDIWebServerNode::GetWriterConnectionString( szComputerName, wszConnStrWriter );
			CUDDIWebServerNode::CrackConnectionString( wszConnStrWriter,
													   wszDomain,
													   wszServer,
													   wszInstance );

			if( NULL == FindChild( wszServer.c_str() ) )
			{
				//
				// If we are running as an extension of Computer Management, then
				// display JUST THE UDDI WEB SERVER.
				//
				// If we are running as the UDDI Admin Console, then add a UDDI
				// Site Node which represents the Site which the Web Server is
				// part of.
				//
				if( IsExtension() )
				{
					try
					{
						int iSize = m_mapChildren.size();
						CUDDIWebServerNode* pNode = new CUDDIWebServerNode( szComputerName.c_str(), iSize, 0, IsExtension() );
						m_mapChildren[ iSize ] = pNode;
					}
					catch( CUDDIException &e )
					{
						UDDIMsgBox( hwndConsole, e, IDS_ERROR_TITLE, MB_ICONEXCLAMATION | MB_OK );
						fRet = FALSE;
					}
					catch( ... )
					{
						fRet = FALSE;
					}
				}
				else if( failedSiteRefs.end() == find( failedSiteRefs.begin(), failedSiteRefs.end(), wszServer ) )
				{
					try
					{
						if( ( 0 != wszServer.length() ) && CUDDISiteNode::IsDatabaseServer( (TCHAR *)wszServer.c_str() ) )
						{
							int iSize = m_mapChildren.size();
							CUDDISiteNode* pNode = CUDDISiteNode::Create( (WCHAR *)wszServer.c_str(),
																		  (WCHAR *)InstanceRealName( wszInstance.c_str() ),
																		  iSize,
																		  this,
																		  m_bIsExtension );
							m_mapChildren[ iSize ] = pNode;
						}
					}
					catch( CUDDIException &e )
					{
						UDDIMsgBox( hwndConsole, e, IDS_ERROR_TITLE, MB_ICONEXCLAMATION | MB_OK );
						fRet = FALSE;
					}
					catch( ... )
					{
						fRet = FALSE;
					}
				}
			}
		}

		return fRet;
	}
	catch( CUDDIException &e )
	{
		throw e;
	}
	catch(...)
	{
		return FALSE;
	}
}


BOOL
CUDDIServicesNode::SaveUDDISites()
{
	try
	{
		if( CUDDIRegistryKey::KeyExists( HKEY_CURRENT_USER, g_szUDDIAdminSites ) )
		{
			CUDDIRegistryKey::DeleteKey( HKEY_CURRENT_USER, g_szUDDIAdminSites );
		}

		CUDDIRegistryKey::Create( HKEY_CURRENT_USER, g_szUDDIAdminSites );

		CUDDIRegistryKey sitesKey( HKEY_CURRENT_USER, g_szUDDIAdminSites, KEY_ALL_ACCESS );

		for( CChildMap::iterator iter = m_mapChildren.begin(); iter != m_mapChildren.end(); iter++ )
		{
			CUDDISiteNode* pNode = reinterpret_cast<CUDDISiteNode *>( iter->second );
			if( ( NULL != pNode ) && ( !pNode->IsDeleted() ) )
			{
				sitesKey.SetValue( pNode->GetName(), pNode->GetInstanceName() );
			}
		}

		return TRUE;
	}
	catch(...)
	{
		return FALSE;
	}
}


void CUDDIServicesNode::ClearChildMap()
{
	for( CChildMap::iterator iter = m_mapChildren.begin();
 		iter != m_mapChildren.end(); iter++ )
	{
		delete iter->second;
		iter->second = NULL;
    }

	m_mapChildren.clear();
}


BOOL
CUDDIServicesNode::ChildExists( const WCHAR *pwszName )
{
	if( NULL == pwszName )
	{
		return FALSE;
	}

	return ( NULL == FindChild( pwszName ) ) ? FALSE : TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\operator\makefile.inc ===
foo.cs:
	..\version\$(O)\version.exe -outfile .\assemblyversioninfo.cs
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\mmc\uddisitenode.cpp ===
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0500
#endif

#include <stdio.h>
#include <windows.h>

#include "uddisitenode.h"
#include "webservernode.h"
#include "comp.h"
#include "compdata.h"
#include "dataobj.h"
#include "globals.h"
#include "resource.h"
#include "objectpicker.h"
#include <htmlhelp.h>
#include <windowsx.h>
#include <commctrl.h>

#include <atldbcli.h>
#include <oledberr.h>
#include <sddl.h>
#include "net_config_get.h"
#include "net_config_save.h"
#include "ADM_execResetKeyImmediate.h"
#include "ADM_setAdminAccount.h"

#include <algorithm>

#include "uddi.h"
#include "scppublisher.h"

BOOL RefreshInstances( HWND hwndList, PTCHAR szComputerName = _T("") );
BOOL GetInstances( PTCHAR szComputer, StringVector& instances );

// {53186FE3-F178-460c-8F3B-352549292B91}
const GUID CUDDISiteNode::thisGuid = { 0x53186fe3, 0xf178, 0x460c, { 0x8f, 0x3b, 0x35, 0x25, 0x49, 0x29, 0x2b, 0x91 } };

UINT CUDDISiteNode::m_nNextChildID = 0;

//==============================================================
//
// CDBSchemaVersion implementation
//
//
CDBSchemaVersion::CDBSchemaVersion() : 
	m_major( -1 ), 
	m_minor( -1 ), 
	m_build( -1 ), 
	m_rev( -1 )
{}

BOOL 
CDBSchemaVersion::IsCompatible( const CDBSchemaVersion& version )
{
	//
	// The major and minor versions MUST be equal in order for the versions to be
	// compatible.  Other values are ignored.
	//
	return ( m_major == version.m_major ) &&
		   ( m_minor == version.m_minor );
}

BOOL 
CDBSchemaVersion::Parse( const tstring& versionString )
{
	szVersion  = versionString;
	int length = versionString.length();

	_TCHAR *buffer = new _TCHAR[ length + 1];
	if( NULL == buffer )
	{
		throw E_OUTOFMEMORY;
		return FALSE;
	}
	_tcscpy( buffer, versionString.c_str() );
	
	m_major = GetPart( _tcstok( buffer, _T(".") ) );
	m_minor = GetPart( _tcstok( NULL, _T(".") ) );
	m_build = GetPart( _tcstok( NULL, _T(".") ) );
	m_rev	= GetPart( _tcstok( NULL, _T(".") ) );	
	
	delete[] buffer;
	buffer = NULL;

	return ( m_major != -1 &&
			 m_minor != -1 &&
			 m_build != -1 &&
			 m_rev	 != -1 );	
}

int 
CDBSchemaVersion::GetPart( const _TCHAR* token )
{
	if( NULL == token )
	{
		return -1;
	}

	int part = _tstoi( token );
	if( 0 == part && 0 != _tcscmp( token, _T( "0" ) ) )
	{
			return -1;
	}
	
	return part;
}

//==============================================================
//
// CUDDISiteNode implementation
//
//
CUDDISiteNode::CUDDISiteNode( _TCHAR *szName, _TCHAR *szInstanceName, int id, CUDDIServicesNode *parent, BOOL bExtension )
	: m_szName(NULL)
	, m_szInstanceName(NULL)
	, m_ppHandle( 0 )
	, m_isDeleted( FALSE )
	, m_pParent( parent )
	, m_bIsDirty( FALSE )
	, m_bStdSvr( TRUE )
{
	OutputDebugString( _T("Site Information Follows:\n" ) );
	OutputDebugString( _T("Computer: ") );
	OutputDebugString( szName );
	OutputDebugString( _T("\nInstance: " ) );
	OutputDebugString( szInstanceName );
	OutputDebugString( _T("\n") );

	m_szName = new _TCHAR[ ( _tcslen( szName ) + 1 ) ];
	_tcscpy( m_szName, szName );

	tstring strFullyQualifiedInstanceName;
	CUDDISiteNode::GetFullyQualifiedInstanceName( szName, strFullyQualifiedInstanceName );

	m_szInstanceName = new _TCHAR[ strFullyQualifiedInstanceName.length() + 1 ];
	_tcscpy( m_szInstanceName, strFullyQualifiedInstanceName.c_str() );

	m_bIsExtension = bExtension;
}

CUDDISiteNode::~CUDDISiteNode()
{
	ClearChildMap();

    if( m_szName )
		delete [] m_szName;

    if( m_szInstanceName )
		delete [] m_szInstanceName;

}

BOOL
CUDDISiteNode::ChildExists( const WCHAR *pwszName )
{
	if( NULL == pwszName )
	{
		return FALSE;
	}

	return ( NULL == FindChild( pwszName ) ) ? FALSE : TRUE;
}


BOOL
CUDDISiteNode::HasChildren()
{
	if( 0 == m_mapConfig.size() && !CUDDIWebServerNode::IsWebServer( m_szName ) )
		return FALSE;

	return TRUE;
}


CUDDIServicesNode *
CUDDISiteNode::GetStaticNode()
{
	return m_pParent;
}


HRESULT
CUDDISiteNode::GetData()
{
	HRESULT hr = E_FAIL;
	try
	{
		m_mapConfig.clear();

		//
		// Determine if the OS that this site node is running on is Windows Server 2003 Standard or not.
		//
		hr = IsStandardServer( m_szName, &m_bStdSvr );
		if( FAILED(hr) )
		{
			THROW_UDDIEXCEPTION_ST( hr, IDS_DOT_NET_SERVER, g_hinst );
		}

		//
		// Initialize the map to the default settings
		//
		m_mapConfig[ UDDI_AUTHENTICATION_MODE ] = _T( "3" );
		m_mapConfig[ UDDI_REQUIRE_SSL ] = _T( "1" );

		m_mapConfig[ UDDI_ADMIN_GROUP ] = _T( "S-1-5-32-544" );
		m_mapConfig[ UDDI_COORDINATOR_GROUP ] = _T( "S-1-5-32-544" );
		m_mapConfig[ UDDI_PUBLISHER_GROUP ] = _T( "S-1-5-32-544" );
		m_mapConfig[ UDDI_USER_GROUP ] = _T( "S-1-5-32-545" );
		m_mapConfig[ UDDI_TICKET_TIMEOUT ] = _T( "60" );
		m_mapConfig[ UDDI_KEY_TIMEOUT ] = _T( "7" );
		m_mapConfig[ UDDI_KEY_RESET_DATE ] = _T( "" );
		m_mapConfig[ UDDI_KEY_AUTORESET ] = _T( "0" );
		m_mapConfig[ UDDI_DISCOVERY_URL ] = _T( "" );
		m_mapConfig[ UDDI_FIND_MAXROWS ] = _T( "1000" );

		//
		// Build up the default Site Name in case Site.Name is not specified
		//
		_TCHAR szBuffer[ 256 ];
		LoadString( g_hinst, IDS_DATABASE_SERVER_DEFAULT_SITE_NAME_PREFIX, szBuffer, ARRAYLEN( szBuffer ) - 1 );
		m_mapConfig[ UDDI_SITE_NAME ] = szBuffer;
		m_mapConfig[ UDDI_SITE_NAME ] += m_szName;

		//
		// Get the setup information
		//
		CUDDIRegistryKey rootkey( _T( "SOFTWARE\\Microsoft\\UDDI"), KEY_READ, m_szName );
			m_mapConfig[ UDDI_SETUP_LOCATION ] = rootkey.GetString( _T("InstallRoot"), _T("") );
		rootkey.Close();

		_TCHAR szValue[ 256 ];
		CUDDIRegistryKey setupkey( _T( "SOFTWARE\\Microsoft\\UDDI\\Setup"), KEY_READ, m_szName );
			m_mapConfig[ UDDI_SETUP_DB ] = _itot( setupkey.GetDWORD( _T("DBServer"), 0 ), szValue, 10 );
			m_mapConfig[ UDDI_SETUP_WEB ] = _itot( setupkey.GetDWORD( _T("WebServer"), 0 ), szValue, 10 );
			m_mapConfig[ UDDI_SETUP_ADMIN ] = _itot( setupkey.GetDWORD( _T("Admin"), 0 ), szValue, 10 );
		setupkey.Close();

		CUDDIRegistryKey dbkey( _T( "SOFTWARE\\Microsoft\\UDDI\\Setup\\DBServer"), KEY_READ, m_szName );
			m_mapConfig[ UDDI_SETUP_DATE ] = dbkey.GetString( _T("InstallDate"), _T("") );
			m_mapConfig[ UDDI_SETUP_LANGUAGE ] = dbkey.GetString( _T("ProductLanguage"), _T("") );
			m_mapConfig[ UDDI_SETUP_NAME ] = dbkey.GetString( _T("ProductName"), _T("") );
			m_mapConfig[ UDDI_SETUP_FRAMEWORK_VERSION ] = dbkey.GetString( _T("FrameworkVersion"), _T("") );
			m_mapConfig[ UDDI_SETUP_MANUFACTURER ] = dbkey.GetString( _T("Manufacturer"), _T("") );
			m_mapConfig[ UDDI_SETUP_VERSION ] = dbkey.GetString( _T("ProductVersion"), _T("") );
		dbkey.Close();
	
		//
		// Populate the configuration map from the database
		//
		hr = GetConfig( m_mapConfig, GetConnectionStringOLEDB() );
		if( FAILED(hr) )
		{
			THROW_UDDIEXCEPTION_ST( E_FAIL, IDS_DATABASE_SERVER_OLEDB_READ_FAILED, g_hinst );
		}
		else
		{
			//
			// Get our version information
			//
			if( FALSE == m_siteVersion.Parse( m_mapConfig[ UDDI_DBSCHEMA_VERSION ] ) )
			{				
				_TCHAR szMessage[ 512 ];
				_TCHAR szMessageFormat[ 512 ];

				memset( szMessage, 0, 512 * sizeof( _TCHAR ) );
				memset( szMessageFormat, 0, 512 * sizeof( _TCHAR ) );

				LoadString( g_hinst, IDS_DATABASE_SERVER_DBSCHEMA_VERSION_READ_FAILED, szMessageFormat, ARRAYLEN( szMessageFormat ) );
				_sntprintf( szMessage, ARRAYLEN( szMessage ) - 1, szMessageFormat, m_szName );		
								
				THROW_UDDIEXCEPTION( E_FAIL, szMessage );
			}

			WCHAR wszBuf[ 256 ];
			wszBuf[ 0 ] = 0x00;
			LoadString( g_hinst, IDS_UDDIMMC_UNSPECIFIED, wszBuf, ARRAYLEN( wszBuf ) );

			if( _T( "unspecified" ) == m_mapConfig[ UDDI_SITE_DESCRIPTION ] )
			{
				m_mapConfig[ UDDI_SITE_DESCRIPTION ] = wszBuf;
			}

			if( _T( "unspecified" ) == m_mapConfig[ UDDI_SITE_NAME ] )
			{
				m_mapConfig[ UDDI_SITE_NAME ] = wszBuf;
			}
		}		
	}
	catch( CUDDIException &e )
	{
		// re-throw.
		throw e;
	}
	catch( ... )
	{
		if( FALSE == FAILED( hr ) )
		{
			hr = E_FAIL;
		}
	}

	return hr;
}

const _TCHAR *CUDDISiteNode::GetDisplayName( int nCol )
{
	switch( nCol )
	{
	case 0:
	{
		m_strDisplayName = m_mapConfig[ UDDI_SITE_NAME ];
		break;
	}
	case 1:
	{
		m_strDisplayName = m_szName;
		break;
	}

	case 2:
	{
		if( 0 == _tcslen( m_szInstanceName ) )
			m_strDisplayName = DefaultInstanceDisplayName();
		else
			m_strDisplayName = m_szInstanceName;

		break;
	}

	case 3:
	{
		m_strDisplayName = m_mapConfig[ UDDI_SITE_DESCRIPTION ];
		break;
	}

	default:
	{
		m_strDisplayName = _T("");
		break;
	}
	}

	return m_strDisplayName.c_str();
}

HRESULT CUDDISiteNode::OnShow( IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem )
{
    HRESULT      hr = S_OK;

    IHeaderCtrl *pHeaderCtrl = NULL;
    IResultData *pResultData = NULL;

    if( bShow ) 
	{
        hr = pConsole->QueryInterface( IID_IHeaderCtrl, (void **)&pHeaderCtrl );
        _ASSERT( SUCCEEDED(hr) );

        hr = pConsole->QueryInterface( IID_IResultData, (void **)&pResultData );
        _ASSERT( SUCCEEDED(hr) );

		//
        // Set the column headers in the results pane
		//
		
		WCHAR szColumnName[ 256 ];
		LoadStringW( g_hinst, IDS_WEBSERVER_COLUMN_NAME, szColumnName, ARRAYLEN( szColumnName ) );
        hr = pHeaderCtrl->InsertColumn( 0, szColumnName, 0, 150 );
        _ASSERT( S_OK == hr );

		LoadStringW( g_hinst, IDS_WEBSERVER_COLUMN_STATUS, szColumnName, ARRAYLEN( szColumnName ) );
        hr = pHeaderCtrl->InsertColumn( 1, szColumnName, 0, 100 );
        _ASSERT( S_OK == hr );

        pHeaderCtrl->Release();
        pResultData->Release();
    }

    return hr;
}

HRESULT CUDDISiteNode::OnExpand( IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent )
{
	//
    // Cache static node's HSCOPEITEM for future use
	//
//    m_hParentHScopeItem = parent;

    if( !m_bExpanded )
	{
		// Load up the child nodes.
		LoadChildMap( m_mapConfig[ UDDI_SITE_WEBSERVERS ] );

		return AddChildrenToScopePane( pConsoleNameSpace, GetScopeItemValue() );
	}

	return S_OK;
}

HRESULT
CUDDISiteNode::RemoveChildren( IConsoleNameSpace *pNS )
{
	if( NULL == pNS )
	{
		return E_INVALIDARG;
	}

	for( CUDDIWebServerNodeMap::iterator iter = m_mapChildren.begin();
 		iter != m_mapChildren.end(); iter++ )
	{
		CUDDIWebServerNode *pWSNode = (CUDDIWebServerNode *)iter->second;
		HSCOPEITEM hsi = pWSNode->GetScopeItemValue();
		pNS->DeleteItem( hsi, TRUE );
    }

	ClearChildMap();

	return S_OK;
}

HRESULT
CUDDISiteNode::OnPropertyChange( IConsole *pConsole, CComponent *pComponent )
{
    HRESULT hr = S_FALSE;

	try
	{
		hr = SaveData();
		if( S_OK != hr )
			return hr;

		hr = GetData();
		if( S_OK != hr )
			return hr;
	}
	catch( CUDDIException& e )
	{
		TCHAR szTitle[ 256 ];
		LoadString( g_hinst, IDS_DATABASE_SERVER_SELECT_ERROR_TITLE, szTitle, ARRAYLEN( szTitle ) );
		HWND hwnd;
		pConsole->GetMainWindow( &hwnd );
		MessageBox( hwnd, e.GetEntireError().c_str(), szTitle, MB_ICONERROR | MB_OK | MB_APPLMODAL );
		return E_FAIL;
	}
	catch(...)
	{
		return E_FAIL;
	}

	//
    // Call IConsole::UpdateAllViews to redraw the item
    // in all views. We need a data object because of the
    // way UpdateAllViews is implemented, and because
    // MMCN_PROPERTY_CHANGE doesn't give us one
	//
    hr = pConsole->UpdateAllViews( NULL, GetScopeItemValue(), 0 );

    return hr;
}

HRESULT CUDDISiteNode::OnShowContextHelp(IDisplayHelp *pDisplayHelp, LPOLESTR helpFile)
{
	if( ( NULL == pDisplayHelp ) || ( NULL == helpFile ) )
	{
		return E_INVALIDARG;
	}

	wstring wstrHelpInfo = helpFile;
	wstrHelpInfo += g_wszUddiSiteNodeHelp;

    LPOLESTR pszTopic = static_cast<LPOLESTR>(CoTaskMemAlloc((wstrHelpInfo.length() + 1) * sizeof(WCHAR)));
	if( NULL == pszTopic )
	{
		return E_OUTOFMEMORY;
	}

	wcsncpy( pszTopic, wstrHelpInfo.c_str(), wstrHelpInfo.length() );
	pszTopic[ wstrHelpInfo.length() ] = NULL;
	return pDisplayHelp->ShowTopic( pszTopic );
}

HRESULT CUDDISiteNode::OnSelect( CComponent *pComponent, IConsole *pConsole, BOOL bScope, BOOL bSelect )
{
	if( ( NULL == pComponent ) ||( NULL == pConsole ) )
	{
		return E_INVALIDARG;
	}

	HRESULT hr = E_FAIL;
	if( bSelect )
	{
		//
		// Enable refresh, and delete verbs
		//
		IConsoleVerb *pConsoleVerb = NULL;

		hr = pConsole->QueryConsoleVerb( &pConsoleVerb );
		if( FAILED(hr) )
		{
			return hr;
		}

		hr = pConsoleVerb->SetVerbState( MMC_VERB_REFRESH, ENABLED, TRUE );

		if( !IsExtension() )
		{
			hr = pConsoleVerb->SetVerbState( MMC_VERB_DELETE, ENABLED, TRUE );
			_ASSERT( S_OK == hr );
		}

		hr = pConsoleVerb->SetVerbState( MMC_VERB_OPEN, ENABLED, TRUE );
		if( FAILED(hr) )
		{
			pConsoleVerb->Release();
			return hr;
		}

		//
		// Can't get to properties (via the standard methods) unless
		// we tell MMC to display the Properties menu item and
		// toolbar button, this will give the user a visual cue that
		// there's "something" to do
		//
		hr = pConsoleVerb->SetVerbState( MMC_VERB_PROPERTIES, ENABLED, TRUE );

		//
		// Also set MMC_VERB_PROPERTIES as the default verb
		//
		hr = pConsoleVerb->SetDefaultVerb( MMC_VERB_PROPERTIES );

		pConsoleVerb->Release();
	}

	return S_FALSE;
}

BOOL CALLBACK CUDDISiteNode::GeneralDialogProc( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    static CUDDISiteNode *pDatabaseServer = NULL;

    switch( uMsg ) 
	{
		case WM_INITDIALOG:
		{
			//
			// Catch the "this" pointer so we can actually operate on the object
			//
			pDatabaseServer = reinterpret_cast<CUDDISiteNode *>(reinterpret_cast<PROPSHEETPAGE *>(lParam)->lParam);
			CConfigMap& m_mapProperties = pDatabaseServer->m_mapConfig;

			SetDlgItemText( hwndDlg, IDC_GENERAL_SITE_TXT_INSTALL_DATE, LocalizedDate( m_mapProperties[ UDDI_SETUP_DATE ] ).c_str() );
			SetDlgItemText( hwndDlg, IDC_GENERAL_SITE_TXT_UDDI_LANGUAGE, m_mapProperties[ UDDI_SETUP_LANGUAGE ].c_str() );
			SetDlgItemText( hwndDlg, IDC_GENERAL_SITE_TXT_DISPLAYNAME, m_mapProperties[ UDDI_SITE_NAME ].c_str() );
			SetDlgItemText( hwndDlg, IDC_GENERAL_SITE_TXT_DESCRIPTION, m_mapProperties[ UDDI_SITE_DESCRIPTION ].c_str() );
			SetDlgItemText( hwndDlg, IDC_GENERAL_SITE_TXT_PROVIDER_KEY, m_mapProperties[ UDDI_SITE_KEY ].c_str() );
			SetDlgItemText( hwndDlg, IDC_GENERAL_SITE_TXT_FRAMEWORK_VERSION, m_mapProperties[ UDDI_SETUP_FRAMEWORK_VERSION ].c_str() );
			SetDlgItemText( hwndDlg, IDC_GENERAL_SITE_TXT_UDDI_VERSION, m_mapProperties[ UDDI_SETUP_VERSION ].c_str() );
			SetDlgItemText( hwndDlg, IDC_GENERAL_SITE_TXT_INSTALL_LOCATION, m_mapProperties[ UDDI_SETUP_LOCATION ].c_str() );

			_TCHAR szServiceName[ 256 ];
			if( _T("1") == m_mapProperties[ UDDI_SETUP_WEB ] )
			{
				::LoadString( g_hinst, IDS_WEBSERVER_COMPONENT_DESCRIPTION, szServiceName, ARRAYLEN( szServiceName ) );
				ListBox_AddString( GetDlgItem( hwndDlg, IDC_GENERAL_SITE_LIST_SERVICES ), szServiceName );
			}

			if( _T("1") == m_mapProperties[ UDDI_SETUP_DB ] )
			{
				::LoadString( g_hinst, IDS_DATABASE_SERVER_COMPONENT_DESCRIPTION, szServiceName, ARRAYLEN( szServiceName ) );
				ListBox_AddString( GetDlgItem( hwndDlg, IDC_GENERAL_SITE_LIST_SERVICES ), szServiceName );
			}

			if( _T("1") == m_mapProperties[ UDDI_SETUP_ADMIN ] )
			{
				::LoadString( g_hinst, IDS_UDDIMMC_COMPONENT_DESCRIPTION, szServiceName, ARRAYLEN( szServiceName ) );
				ListBox_AddString( GetDlgItem( hwndDlg, IDC_GENERAL_SITE_LIST_SERVICES ), szServiceName );
			}
		}
		break;
		case WM_NOTIFY:
			if( PSN_HELP == ((NMHDR *) lParam)->code )
			{
				wstring strHelp( pDatabaseServer->GetHelpFile() );
				strHelp += g_wszUddiSiteGeneralPageHelp;

				::HtmlHelp( hwndDlg, strHelp.c_str(), HH_DISPLAY_TOPIC, NULL );
			}
		break;

		case WM_HELP:
		{
			wstring strHelp( pDatabaseServer->GetHelpFile() );
			strHelp += g_wszUddiSiteGeneralPageHelp;

			::HtmlHelp( hwndDlg, strHelp.c_str(), HH_DISPLAY_TOPIC, NULL );
		}
		break;
	}

    return FALSE;
}

void SplitGroupName( const PTCHAR szGroupName, StringVector& names )
{
	// 
	// Example: CREEVES\\Administrators
	//
	PTCHAR begin = szGroupName;
	PTCHAR end = begin;

	while( *end )
	{
		if( _T('\\') == *end )
		{
			TCHAR szNameTemp[ 256 ];
			_tcsncpy( szNameTemp, begin, end - begin );
			szNameTemp[ end - begin ] = NULL;
			names.push_back( szNameTemp );
			begin = end + 1;
		}
		end++;
	}

	//
	// Get the last one
	//
	if( begin != end )
	{
		names.push_back( begin );
	}
}

struct RolesData
{
	RolesData( CUDDISiteNode* pServer )
		: pDBServer( pServer )
		, bAdminChanged( false )
		, bCoordinatorChanged( false )
		, bPublishChanged( false )
		, bUserChanged( false )
		, bInitialized( false ){}

	CUDDISiteNode* pDBServer;
	bool bAdminChanged;
	bool bCoordinatorChanged;
	bool bPublishChanged;
	bool bUserChanged;
	bool bInitialized;

	//
	// These members get updated when the user picks a new role/group
	//
	tstring tsNewAdminSID;
	tstring tsNewCoordinatorSID;
	tstring tsNewPublisherSID;
	tstring tsNewUserSID;
};

tstring SidFromGroupName( const tstring& strGroupName, const LPCTSTR szTargetComputer )
{
	BYTE	sid[ 1024 ];
	TCHAR	domain[ 1024 ];
	LPTSTR	szSidBuf = NULL;
	DWORD	cbSID = ARRAYLEN( sid );
	DWORD	cbDomain = ARRAYLEN( domain );
	SID_NAME_USE	puse;
	tstring strSid = _T("");

	try
	{
		BOOL bRet = LookupAccountName( 
						NULL, 
						strGroupName.c_str(), 
						sid, 
						&cbSID, 
						domain, 
						&cbDomain, 
						&puse );
		if( !bRet )
			UDDIVERIFYAPI();// bRet, _T("The attempt to lookup the security identifer failed" ) );

		bRet = ConvertSidToStringSid( sid, &szSidBuf );
		UDDIASSERT( bRet );

		strSid = szSidBuf;

		if( szSidBuf )
			LocalFree( szSidBuf );
	}
	catch( CUDDIException& e )
	{
		MessageBox( NULL, e.GetEntireError().c_str(), _T("Security name conversion failed" ), MB_OK );
	}
	return strSid;
}

tstring GroupNameFromSid( const tstring& strGroupSid, const tstring& strTargetComputer )
{
	PSID	lpSid = NULL;
	TCHAR	domain[ 1024 ];
	TCHAR	name[ 1024 ];
	DWORD	cbDomain = ( sizeof domain / sizeof domain[0] );
	DWORD	cbName = ( sizeof name / sizeof name[0] );
	SID_NAME_USE	puse;
	tstring strGroupName = _T("");

	BOOL bRet = ConvertStringSidToSid( strGroupSid.c_str(), &lpSid );
	UDDIVERIFY( bRet, _T("Unable to convert the group security identifer into a textual name." ) );

	bRet = LookupAccountSid( strTargetComputer.c_str(), lpSid, name, &cbName, domain, &cbDomain, &puse ); 
	if( !bRet )
	{
		if( lpSid )
			LocalFree( lpSid );
		
		//
		// If we can't look up the account, we can't continue.
		// 		
		THROW_UDDIEXCEPTION_ST( GetLastError(), IDS_ACCOUNT_GROUP_ERROR, g_hinst );
	}
	
	strGroupName = domain;
	strGroupName += _T("\\");
	strGroupName += name;

	if( lpSid )
		LocalFree( lpSid );

	return strGroupName;
}

BOOL CALLBACK CUDDISiteNode::RolesDialogProc( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    switch( uMsg ) 
	{
    case WM_INITDIALOG:
	{
		//
		// Save the window data into the user data reference
		//
		CUDDISiteNode* pDBServer = reinterpret_cast<CUDDISiteNode *>(reinterpret_cast<PROPSHEETPAGE *>(lParam)->lParam);
		RolesData* pdata = new RolesData( pDBServer );
		SetWindowLongPtr( hwndDlg, GWLP_USERDATA, reinterpret_cast<LONG_PTR>( pdata ) );

		//
		// Admin group.
		//
		try
		{
			tstring strAdminGroup = GroupNameFromSid( pDBServer->m_mapConfig[ UDDI_ADMIN_GROUP ], pDBServer->m_szName );
			SetDlgItemText( hwndDlg, IDC_ROLES_EDIT_ADMIN_GROUP_NAME, strAdminGroup.c_str() );
		}
		catch( ... )
		{
			SetDlgItemText( hwndDlg, IDC_ROLES_EDIT_ADMIN_GROUP_NAME, pDBServer->m_mapConfig[ UDDI_ADMIN_GROUP ].c_str() );
		}

		//
		// Coordinator Group.
		//
		try
		{
			tstring strCoordinatorGroup = GroupNameFromSid( pDBServer->m_mapConfig[ UDDI_COORDINATOR_GROUP ], pDBServer->m_szName );
			SetDlgItemText( hwndDlg, IDC_ROLES_EDIT_COORDINATOR_GROUP_NAME, strCoordinatorGroup.c_str() );
		}
		catch( ... )
		{
			SetDlgItemText( hwndDlg, IDC_ROLES_EDIT_COORDINATOR_GROUP_NAME, pDBServer->m_mapConfig[ UDDI_ADMIN_GROUP ].c_str() );
		}

		//
		// Publisher Group.
		//
		try
		{
			tstring strPublisherGroup = GroupNameFromSid( pDBServer->m_mapConfig[ UDDI_PUBLISHER_GROUP ], pDBServer->m_szName );
			SetDlgItemText( hwndDlg, IDC_ROLES_EDIT_PUBLISHER_GROUP_NAME, strPublisherGroup.c_str() );
		}
		catch( ... )
		{
			SetDlgItemText( hwndDlg, IDC_ROLES_EDIT_PUBLISHER_GROUP_NAME, pDBServer->m_mapConfig[ UDDI_ADMIN_GROUP ].c_str() );
		}

		//
		// User Group.
		//
		try
		{
			tstring strUserGroup = GroupNameFromSid( pDBServer->m_mapConfig[ UDDI_USER_GROUP ], pDBServer->m_szName );
			SetDlgItemText( hwndDlg, IDC_ROLES_EDIT_USER_GROUP_NAME, strUserGroup.c_str() );
		}
		catch( ... )
		{
			SetDlgItemText( hwndDlg, IDC_ROLES_EDIT_USER_GROUP_NAME, pDBServer->m_mapConfig[ UDDI_USER_GROUP ].c_str() );
		}

		pdata->bInitialized = true;
	}

    case WM_COMMAND:
	{
		RolesData* pdata = reinterpret_cast<RolesData*>( GetWindowLongPtr( hwndDlg, GWLP_USERDATA ) );

        if( BN_CLICKED == HIWORD(wParam) )
		{
			try
			{
				TCHAR szGroupSID[ 1024 ];

				if( IDC_ROLES_BTN_ADMINISTRATOR_SELECT == LOWORD(wParam) )
				{
					if( ObjectPicker( hwndDlg, OT_GroupSID, szGroupSID, ARRAYLEN( szGroupSID ), pdata->pDBServer->m_szName ) )
					{
						try
						{
							tstring tstr = GroupNameFromSid( szGroupSID, pdata->pDBServer->m_szName );
							SetDlgItemText( hwndDlg, IDC_ROLES_EDIT_ADMIN_GROUP_NAME, tstr.c_str() );
						}
						catch( ... )
						{
							SetDlgItemText( hwndDlg, IDC_ROLES_EDIT_ADMIN_GROUP_NAME, szGroupSID );
						}

						pdata->bAdminChanged = true;
						pdata->tsNewAdminSID = szGroupSID;
						SendMessage( GetParent(hwndDlg), PSM_CHANGED, (WPARAM) hwndDlg, 0 );
					}
				}
				else if( IDC_ROLES_BTN_COORDINATOR_SELECT == LOWORD(wParam) )
				{
					if( ObjectPicker( hwndDlg, OT_GroupSID, szGroupSID, ARRAYLEN( szGroupSID ), pdata->pDBServer->m_szName ) )
					{
						try
						{
							tstring tstr = GroupNameFromSid( szGroupSID, pdata->pDBServer->m_szName );
							SetDlgItemText( hwndDlg, IDC_ROLES_EDIT_COORDINATOR_GROUP_NAME, tstr.c_str() );
						}
						catch( ... )
						{
							SetDlgItemText( hwndDlg, IDC_ROLES_EDIT_COORDINATOR_GROUP_NAME, szGroupSID );
						}

						pdata->bCoordinatorChanged = true;
						pdata->tsNewCoordinatorSID = szGroupSID;
						SendMessage( GetParent(hwndDlg), PSM_CHANGED, (WPARAM) hwndDlg, 0 );
					}
				}
				else if( IDC_ROLES_BTN_PUBLISHER_SELECT == LOWORD(wParam) )
				{
					if( ObjectPicker( hwndDlg, OT_GroupSID, szGroupSID, ARRAYLEN( szGroupSID ), pdata->pDBServer->m_szName ) )
					{
						try
						{
							tstring tstr = GroupNameFromSid( szGroupSID, pdata->pDBServer->m_szName );
							SetDlgItemText( hwndDlg, IDC_ROLES_EDIT_PUBLISHER_GROUP_NAME, tstr.c_str() );
						}
						catch( ... )
						{
							SetDlgItemText( hwndDlg, IDC_ROLES_EDIT_PUBLISHER_GROUP_NAME, szGroupSID );
						}

						pdata->bPublishChanged = true;
						pdata->tsNewPublisherSID = szGroupSID;
						SendMessage( GetParent(hwndDlg), PSM_CHANGED, (WPARAM) hwndDlg, 0 );
					}
				}
				else if( IDC_ROLES_BTN_USER_SELECT == LOWORD(wParam) )
				{
					if( ObjectPicker( hwndDlg, OT_GroupSID, szGroupSID, ARRAYLEN( szGroupSID ), pdata->pDBServer->m_szName ) )
					{
						try
						{
							tstring tstr = GroupNameFromSid( szGroupSID, pdata->pDBServer->m_szName );
							SetDlgItemText( hwndDlg, IDC_ROLES_EDIT_USER_GROUP_NAME, tstr.c_str() );
						}
						catch( ... )
						{
							SetDlgItemText( hwndDlg, IDC_ROLES_EDIT_USER_GROUP_NAME, szGroupSID );
						}

						pdata->bUserChanged = true;
						pdata->tsNewUserSID = szGroupSID;
						SendMessage( GetParent(hwndDlg), PSM_CHANGED, (WPARAM) hwndDlg, 0 );
					}
				}

				break;
			}
			catch( CUDDIException& exception )
			{	
				_TCHAR szTitle[256];
				::LoadString( g_hinst, IDS_UDDIMMC_SNAPINNAME, szTitle, ARRAYLEN( szTitle ) - 1 );

				MessageBox( hwndDlg, (LPCTSTR) exception, szTitle, MB_ICONERROR | MB_OK | MB_APPLMODAL );

				break;
			}
			catch( ... )
			{
				TCHAR wszTitle[ 128 ];
				TCHAR wszMsg[ 256 ];

				LoadString( g_hinst, IDS_GENERAL_EXCEPTION_TITLE, wszTitle, 128 );
				LoadString( g_hinst, IDS_GENERAL_EXCEPTION, wszMsg, 256 );
				MessageBox( hwndDlg, wszMsg, wszTitle, MB_OK );
				break;
			}
		}
		else if( EN_CHANGE == HIWORD(wParam) )
		{
			if( pdata->bInitialized )
			{
				switch( LOWORD(wParam) )
				{
					case IDC_ROLES_EDIT_USER_GROUP_NAME:
						pdata->bUserChanged = true;
						SendMessage( GetParent(hwndDlg), PSM_CHANGED, (WPARAM) hwndDlg, 0 );
						break;
					case IDC_ROLES_EDIT_PUBLISHER_GROUP_NAME:
						pdata->bPublishChanged = true;
						SendMessage( GetParent(hwndDlg), PSM_CHANGED, (WPARAM) hwndDlg, 0 );
						break;
					case IDC_ROLES_EDIT_COORDINATOR_GROUP_NAME:
						pdata->bCoordinatorChanged = true;
						SendMessage( GetParent(hwndDlg), PSM_CHANGED, (WPARAM) hwndDlg, 0 );
						break;
					case IDC_ROLES_EDIT_ADMIN_GROUP_NAME:
						pdata->bAdminChanged = true;
						SendMessage( GetParent(hwndDlg), PSM_CHANGED, (WPARAM) hwndDlg, 0 );
						break;
				}
			}
		}
		break;
	}

    case WM_DESTROY:
	{
		delete reinterpret_cast<RolesData*>( GetWindowLongPtr( hwndDlg, GWLP_USERDATA ) );
        break;
	}

	case WM_HELP:
	{
		RolesData* pdata = reinterpret_cast<RolesData*>( GetWindowLongPtr( hwndDlg, GWLP_USERDATA ) );
		wstring strHelp( pdata->pDBServer->GetHelpFile() );
		strHelp += g_wszUddiRolesPageHelp;

		::HtmlHelp( hwndDlg, strHelp.c_str(), HH_DISPLAY_TOPIC, NULL );
		break;
	}

    case WM_NOTIFY:
        switch( ((NMHDR *) lParam)->code ) 
		{
			case PSN_APPLY:
			{
				RolesData* pdata = reinterpret_cast<RolesData*>( GetWindowLongPtr( hwndDlg, GWLP_USERDATA ) );

				CUDDISiteNode* pDBServer = pdata->pDBServer;

				if( pdata->bAdminChanged )
				{
					pDBServer->m_mapChanges[ UDDI_ADMIN_GROUP ] = pdata->tsNewAdminSID;
					pdata->bAdminChanged = false;
				}

				if( pdata->bCoordinatorChanged )
				{
					pDBServer->m_mapChanges[ UDDI_COORDINATOR_GROUP ] = pdata->tsNewCoordinatorSID;
					pdata->bCoordinatorChanged = false;
				}
				
				if( pdata->bPublishChanged )
				{
					pDBServer->m_mapChanges[ UDDI_PUBLISHER_GROUP ] = pdata->tsNewPublisherSID;
					pdata->bPublishChanged = false;
				}

				if( pdata->bUserChanged )
				{
					pDBServer->m_mapChanges[ UDDI_USER_GROUP ] = pdata->tsNewUserSID;
					pdata->bUserChanged = false;
				}

				//
				// Ask MMC to send us a message (on the main thread) so
				// we know the Apply button was clicked.
				//
				HRESULT hr = MMCPropertyChangeNotify( pDBServer->m_ppHandle, reinterpret_cast<LONG_PTR>(pDBServer) );
				_ASSERT( SUCCEEDED(hr) );

				return PSNRET_NOERROR;
			}

			case PSN_HELP:
			{
				RolesData* pdata = reinterpret_cast<RolesData*>( GetWindowLongPtr( hwndDlg, GWLP_USERDATA ) );
				wstring strHelp( pdata->pDBServer->GetHelpFile() );
				strHelp += g_wszUddiRolesPageHelp;

				::HtmlHelp( hwndDlg, strHelp.c_str(), HH_DISPLAY_TOPIC, NULL );
				break;
			}
	        break;
        }
    }

    return FALSE;
}

struct SecurityData
{
	SecurityData( CUDDISiteNode* pDBServer )
		: pServer( pDBServer )
		, bModeChanged( false )
		, bSSLChanged( false )
		, bKeyTimeoutChanged( false )
		, bTicketTimeoutChanged( false )
		, bAutoKeyResetChanged( false )
		, bAutoKeyReset( false )
		, nKeyTimeout( 0 )
		, nTicketTimeout( 0 )
	{
		if( NULL != pServer )
		{
			bAutoKeyReset = ( 0 != _tcscmp( _T("0"), pServer->GetConfigMap()[ UDDI_KEY_AUTORESET ].c_str() ) );
			nKeyTimeout = _tstoi( pDBServer->GetConfigMap()[ UDDI_KEY_TIMEOUT ].c_str() );
			nTicketTimeout = _tstoi( pDBServer->GetConfigMap()[ UDDI_TICKET_TIMEOUT ].c_str() );
		}
	}

	bool bModeChanged;
	bool bSSLChanged;
	bool bKeyTimeoutChanged;
	bool bTicketTimeoutChanged;
	bool bAutoKeyResetChanged;
	bool bAutoKeyReset;
	int nKeyTimeout;
	int nTicketTimeout;
	CUDDISiteNode* pServer;
};

BOOL CALLBACK CUDDISiteNode::SecurityDialogProc( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    switch( uMsg ) 
	{
		case WM_INITDIALOG:
		{
			//
			// Catch the "this" pointer so we can actually operate on the object
			//
			CUDDISiteNode* pDBServer = reinterpret_cast<CUDDISiteNode *>(reinterpret_cast<PROPSHEETPAGE *>(lParam)->lParam);
			SecurityData* pdata = new SecurityData( pDBServer );
			SetWindowLongPtr( hwndDlg, GWLP_USERDATA, reinterpret_cast<LONG_PTR>( pdata ) );
			_TCHAR* pszMode = (_TCHAR*) pDBServer->m_mapConfig[ UDDI_AUTHENTICATION_MODE ].c_str();
			int nAuthenticationMode = _ttoi( pszMode  );
			switch( nAuthenticationMode )
			{
				case 1:
					SendDlgItemMessage( hwndDlg, IDC_SECURITY_RADIO_AUTHENTICATION_UDDI, BM_SETCHECK, BST_CHECKED, NULL );
					break;
				case 2:
				case 6:
					SendDlgItemMessage( hwndDlg, IDC_SECURITY_RADIO_AUTHENTICATION_WINDOWS, BM_SETCHECK, BST_CHECKED, NULL );
					EnableWindow( GetDlgItem( hwndDlg, IDC_SECURITY_CHECK_AUTHENTICATED_READS ), TRUE );
					break;
				case 3:
				default:
					SendDlgItemMessage( hwndDlg, IDC_SECURITY_RADIO_AUTHENTICATION_BOTH, BM_SETCHECK, BST_CHECKED, NULL );
					break;
			}

			if( 4 & nAuthenticationMode )
			{
				SendDlgItemMessage( hwndDlg, IDC_SECURITY_CHECK_AUTHENTICATED_READS, BM_SETCHECK, BST_CHECKED, NULL );
			}

			//
			// Setup the HTTPS requirement setting
			//
			_TCHAR* pszHttps = (_TCHAR*) pDBServer->m_mapConfig[ UDDI_REQUIRE_SSL ].c_str();
			int nhttps = _ttoi( pszHttps );
			if( 0 == nhttps )
			{
				SendDlgItemMessage( hwndDlg, IDC_SECURITY_CHECK_REQUIRE_SSL, BM_SETCHECK, BST_UNCHECKED, NULL );
			}
			else
			{
				SendDlgItemMessage( hwndDlg, IDC_SECURITY_CHECK_REQUIRE_SSL, BM_SETCHECK, BST_CHECKED, NULL );
			}
		}
		break;
		case WM_HELP:
		{
			SecurityData* pdata = reinterpret_cast<SecurityData*>( GetWindowLongPtr( hwndDlg, GWLP_USERDATA ) ) ;
			wstring strHelp( pdata->pServer->GetHelpFile() );
			strHelp += g_wszUddiSecurityPageHelp;

			::HtmlHelp( hwndDlg, strHelp.c_str(), HH_DISPLAY_TOPIC, NULL );
		}
		break;

		case WM_COMMAND:
		{
			SecurityData* pdata = reinterpret_cast<SecurityData*>( GetWindowLongPtr( hwndDlg, GWLP_USERDATA ) );
			CUDDISiteNode* pDBServer = pdata->pServer;

			//
			// Set the state of the Authenticated Reads check box
			//
			LRESULT nChecked = SendDlgItemMessage( hwndDlg, IDC_SECURITY_RADIO_AUTHENTICATION_WINDOWS, BM_GETCHECK, NULL, NULL );
			EnableWindow( GetDlgItem( hwndDlg, IDC_SECURITY_CHECK_AUTHENTICATED_READS ), BST_CHECKED == nChecked ? TRUE : FALSE );
			if( !nChecked )
			{
				SendDlgItemMessage( hwndDlg, IDC_SECURITY_CHECK_AUTHENTICATED_READS, BM_SETCHECK, FALSE, NULL );
			}

			if( IDC_CRYPTOGRAPHY_BTN_CHANGE == LOWORD(wParam) )
			{
				INT_PTR nResult = DialogBoxParam( g_hinst, MAKEINTRESOURCE( IDD_CRYPTOGRAPHY ), GetParent(hwndDlg), CryptographyDialogProc, (LPARAM) pdata );

				if( nResult )
				{
					SendMessage( GetParent(hwndDlg), PSM_CHANGED, (WPARAM)hwndDlg, 0 );
				}
			}
			else if( BN_CLICKED == HIWORD(wParam) && 
					( IDC_SECURITY_RADIO_AUTHENTICATION_BOTH == LOWORD(wParam)	||
					IDC_SECURITY_RADIO_AUTHENTICATION_UDDI == LOWORD(wParam)		||
					IDC_SECURITY_RADIO_AUTHENTICATION_WINDOWS == LOWORD(wParam)	||
					IDC_SECURITY_CHECK_AUTHENTICATED_READS == LOWORD(wParam) ) )
			{
				pdata->bModeChanged = true;
				SendMessage( GetParent(hwndDlg), PSM_CHANGED, (WPARAM)hwndDlg, 0 );
			}
			else if( BN_CLICKED == HIWORD(wParam) && IDC_SECURITY_CHECK_REQUIRE_SSL == LOWORD(wParam) )
			{
				pdata->bSSLChanged = true;
				SendMessage( GetParent(hwndDlg), PSM_CHANGED, (WPARAM)hwndDlg, 0 );
			}
		}
		break;

		case WM_DESTROY:
		{
			SecurityData* pdata = reinterpret_cast<SecurityData*>( GetWindowLongPtr( hwndDlg, GWLP_USERDATA ) );
			CUDDISiteNode* pDBServer = pdata->pServer;
			delete pdata;

			//
			// Tell MMC that we're done with the property sheet (we got this
			// handle in CreatePropertyPages
			//
			MMCFreeNotifyHandle( pDBServer->m_ppHandle ); 
		}
		break;

		case WM_NOTIFY:
		{
			switch( ((NMHDR *) lParam)->code ) 
			{
				case PSN_APPLY:
				{
					SecurityData* pdata = reinterpret_cast<SecurityData*>( GetWindowLongPtr( hwndDlg, GWLP_USERDATA ) );
					CUDDISiteNode* pDBServer = pdata->pServer;

					if( pdata->bAutoKeyResetChanged )
					{
						pDBServer->m_mapChanges[ UDDI_KEY_AUTORESET ] = pdata->bAutoKeyReset ? _T("1") : _T("0");
					}

					if( pdata->bKeyTimeoutChanged )
					{
						_TCHAR szValue[ 10 ];
						pDBServer->m_mapChanges[ UDDI_KEY_TIMEOUT ] = _itot( pdata->nKeyTimeout, szValue, 10 );
					}

					if( pdata->bTicketTimeoutChanged )
					{
						_TCHAR szValue[ 10 ];
						pDBServer->m_mapChanges[ UDDI_TICKET_TIMEOUT ] = _itot( pdata->nTicketTimeout, szValue, 10 );
					}

					if( pdata->bModeChanged )
					{
						if( BST_CHECKED == SendDlgItemMessage( hwndDlg, IDC_SECURITY_RADIO_AUTHENTICATION_BOTH, BM_GETCHECK, 0, 0 ) )
						{
							pDBServer->m_mapChanges[ UDDI_AUTHENTICATION_MODE ] = _T("3");
						}
						else if( BST_CHECKED == SendDlgItemMessage( hwndDlg, IDC_SECURITY_RADIO_AUTHENTICATION_UDDI, BM_GETCHECK, 0, 0 ) )
						{
							pDBServer->m_mapChanges[ UDDI_AUTHENTICATION_MODE ] = _T("1");
						}
						else if( BST_CHECKED == SendDlgItemMessage( hwndDlg, IDC_SECURITY_RADIO_AUTHENTICATION_WINDOWS, BM_GETCHECK, 0, 0 ) )
						{
							if( BST_CHECKED == SendDlgItemMessage( hwndDlg, IDC_SECURITY_CHECK_AUTHENTICATED_READS, BM_GETCHECK, 0, 0 ) )
								pDBServer->m_mapChanges[ UDDI_AUTHENTICATION_MODE ] = _T("6");
							else
								pDBServer->m_mapChanges[ UDDI_AUTHENTICATION_MODE ] = _T("2");
						}
					}

					if( pdata->bSSLChanged )
					{
						LRESULT nChecked = SendDlgItemMessage( hwndDlg, IDC_SECURITY_CHECK_REQUIRE_SSL, BM_GETCHECK, NULL, NULL );
						pDBServer->m_mapChanges[ UDDI_REQUIRE_SSL ] = ( BST_CHECKED == nChecked  ? _T("1") : _T("0") );
					}

					pdata->bAutoKeyResetChanged = false;
					pdata->bKeyTimeoutChanged = false;
					pdata->bModeChanged = false;
					pdata->bSSLChanged = false;
					pdata->bTicketTimeoutChanged = false;

					HRESULT hr = MMCPropertyChangeNotify( pDBServer->m_ppHandle, reinterpret_cast<LONG_PTR>(pDBServer) );
					_ASSERT( SUCCEEDED(hr) );
				}
				return PSNRET_NOERROR;

				case PSN_HELP:
				{
					SecurityData* pdata = reinterpret_cast<SecurityData*>( GetWindowLongPtr( hwndDlg, GWLP_USERDATA ) );
					wstring strHelp( pdata->pServer->GetHelpFile() );
					strHelp += g_wszUddiSecurityPageHelp;

					::HtmlHelp( hwndDlg, strHelp.c_str(), HH_DISPLAY_TOPIC, NULL );
				}
				break;
			}
		}
		break;
	}

    return FALSE;
}

size_t CUDDISiteNode::PublishToActiveDirectory()
{
	//
	// Build up the list of ServiceConnectionPoint classes
	//
	CUDDIServiceCxnPtPublisher publisher( 
		GetConnectionStringOLEDB(), 
		m_mapConfig[ UDDI_SITE_KEY ], 
		m_mapConfig[ UDDI_SITE_NAME ], 
		m_mapConfig[ UDDI_DISCOVERY_URL ] );

	//
	// Process the binding information for the default
	// provider for the site
	//
	publisher.ProcessSite();

	//
	// If there are no bindings don't publish anything
	//
	if( 0 == publisher.size() )
		return 0;

	//
	// Delete the Site container
	//
	try
	{
		publisher.DeleteSiteContainer();
	}
	catch(...)
	{
	}

	//
	// Publish the Site Container
	//
	publisher.CreateSiteContainer();

	//
	// Publish the Service Connection Points
	//
	publisher.PublishServiceCxnPts();

	return publisher.size();
}

void CUDDISiteNode::RemoveFromActiveDirectory()
{
	//
	// Build up the list of ServiceConnectionPoint classes
	//
	CUDDIServiceCxnPtPublisher publisher( 
		GetConnectionStringOLEDB(), 
		m_mapConfig[ UDDI_SITE_KEY ], 
		m_mapConfig[ UDDI_SITE_NAME ], 
		m_mapConfig[ UDDI_DISCOVERY_URL ] );

	publisher.DeleteSiteContainer();
}

BOOL CUDDISiteNode::CanPublishToActiveDirectory()
{
	return TRUE;
}

BOOL CALLBACK CUDDISiteNode::ActiveDirectoryDialogProc( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    static CUDDISiteNode *pDatabaseServer = NULL;

    switch( uMsg ) 
	{
    case WM_INITDIALOG:
		//
        // Catch the "this" pointer so we can actually operate on the object
		//
        pDatabaseServer = reinterpret_cast<CUDDISiteNode *>(reinterpret_cast<PROPSHEETPAGE *>(lParam)->lParam);

        break;
	case WM_HELP:
	{
		wstring strHelp( pDatabaseServer->GetHelpFile() );
		strHelp += g_wszUddiActiveDirectoryPageHelp;

		::HtmlHelp( hwndDlg, strHelp.c_str(), HH_DISPLAY_TOPIC, NULL );
	}
	break;

    case WM_COMMAND:
        if( IDC_ACTIVEDIRECTORY_BTN_ADD == LOWORD(wParam) )
		{
			try
			{
				size_t nCount = pDatabaseServer->PublishToActiveDirectory();

				//
				// Tell the user the publication job succeeded
				//
				_TCHAR szMessage[ 256 ];
				_TCHAR szTitle[ 256 ];

				if( nCount )
				{
					LoadString( g_hinst, IDS_ACTIVEDIRECTORY_PUBLISH_SUCCEEDED, szMessage, ARRAYLEN( szMessage ) );
					LoadString( g_hinst, IDS_UDDIMMC_NAME, szTitle, ARRAYLEN( szTitle ) );
				}
				else
				{					
					LoadString( g_hinst, IDS_ACTIVEDIRECTORY_NO_BINDINGS, szMessage, ARRAYLEN( szMessage ) );
					LoadString( g_hinst, IDS_UDDIMMC_NAME, szTitle, ARRAYLEN( szTitle ) );
				}

				MessageBox( hwndDlg, szMessage, szTitle, MB_OK );
			}
			catch( CUDDIException& e )
			{
				UDDIMsgBox( hwndDlg, IDS_ACTIVEDIRECTORY_PUBLISH_FAILED, IDS_UDDIMMC_SNAPINNAME, MB_ICONERROR, e.GetEntireError().c_str() );
			}
		}
        if( IDC_ACTIVEDIRECTORY_BTN_REMOVE == LOWORD(wParam) )
		{
			try
			{
				pDatabaseServer->RemoveFromActiveDirectory();

				//
				// Tell the user the publication job succeeded
				//
				_TCHAR szMessage[ 256 ];
				_TCHAR szTitle[ 256 ];
				LoadString( g_hinst, IDS_ACTIVEDIRECTORY_DELETE_SUCCEDED, szMessage, ARRAYLEN( szMessage ) );
				LoadString( g_hinst, IDS_UDDIMMC_NAME, szTitle, ARRAYLEN( szTitle ) );
				MessageBox( hwndDlg, szMessage, szTitle, MB_OK );
			}
			catch( CUDDIException& e )
			{
				UDDIMsgBox( hwndDlg, IDS_ACTIVEDIRECTORY_DELETE_FAILED, IDS_UDDIMMC_SNAPINNAME, MB_ICONERROR, e.GetEntireError().c_str() );
			}
		}
        break;

    case WM_NOTIFY:
        switch( ((NMHDR *) lParam)->code ) 
		{
        case PSN_APPLY:
            return PSNRET_NOERROR;

		case PSN_HELP:
			{
				wstring strHelp( pDatabaseServer->GetHelpFile() );
				strHelp += g_wszUddiActiveDirectoryPageHelp;

				::HtmlHelp( hwndDlg, strHelp.c_str(), HH_DISPLAY_TOPIC, NULL );
			}
			break;
        }
        break;
    }

    return FALSE;
}

HRESULT CUDDISiteNode::HasPropertySheets()
{
	//
    // Say "yes" when MMC asks if we have pages
	//
    return S_OK;
}

HRESULT
CUDDISiteNode::CreatePropertyPages( IPropertySheetCallback *lpProvider, LONG_PTR handle )
{
	if( ( NULL == lpProvider ) || ( 0 == handle ) )
	{
		return E_INVALIDARG;
	}

	HRESULT hr = S_OK;
	try
	{
		hr = GetData();
	}
	catch( CUDDIException& e )
	{
		IConsole *pConsole = NULL;
		HWND hwndConsole = NULL;

		//
		// This *should* always work.  If it does work, then we use
		// pConsole to get the main window handle for the mmc, and use
		// this main window handle to display a modal dialog.
		//
		// If this fails (which it never should), we then display dialog,
		// but with a NULL HWND.
		//
		hr = lpProvider->QueryInterface( IID_IConsole, (void **)&pConsole );

		if( NULL != pConsole )
		{
			pConsole->GetMainWindow( &hwndConsole );
		}

		TCHAR szTitle[ 256 ];
		LoadString( g_hinst, IDS_DATABASE_SERVER_GETDATA_ERROR_TITLE, szTitle, ARRAYLEN( szTitle ) );

		MessageBox( hwndConsole, e.GetEntireError().c_str(), szTitle, MB_ICONERROR | MB_OK | MB_APPLMODAL );

		if( NULL != pConsole )
		{
			pConsole->Release();
		}

		return E_FAIL;
	}
	catch(...)
	{
		return E_FAIL;
	}

	PropertyPages pps[] = { 
		{ IDD_GENERAL_SITE_PROPPAGE, GeneralDialogProc },
		{ IDD_ROLES_PROPPAGE, RolesDialogProc },
		{ IDD_SECURITY_PROPPAGE, SecurityDialogProc },
		{ IDD_ACTIVEDIRECTORY_PROPPAGE, ActiveDirectoryDialogProc },
		{ IDD_ADVANCED_PROPPAGE, AdvancedDialogProc } };
	
    PROPSHEETPAGE psp;
    HPROPSHEETPAGE hPage = NULL;

	//
    // Cache this handle so we can call MMCPropertyChangeNotify
	//
    m_ppHandle = handle;
	
	//
    // Create the property page for this node.
    // NOTE: if your node has multiple pages, put the following
    // in a loop and create multiple pages calling
    // lpProvider->AddPage() for each page.
	//
    psp.dwSize = sizeof(PROPSHEETPAGE);
    psp.dwFlags = PSP_DEFAULT | PSP_HASHELP;
    psp.hInstance = g_hinst;
    psp.lParam = reinterpret_cast<LPARAM>(this);

	for( int i=0; i < ARRAYLEN( pps ); i++ )
	{
		psp.pszTemplate = MAKEINTRESOURCE( pps[ i ].id );
		psp.pfnDlgProc = pps[ i ].dlgproc;

		hPage = CreatePropertySheetPage( &psp );
		_ASSERT( hPage );

		hr = lpProvider->AddPage( hPage );
		if( FAILED(hr) )
			break;
	}

    return hr;
}

HRESULT CUDDISiteNode::GetWatermarks(
								HBITMAP *lphWatermark,
								HBITMAP *lphHeader,
								HPALETTE *lphPalette,
								BOOL *bStretch )
{
    return S_FALSE;
}

HRESULT CUDDISiteNode::OnUpdateItem( IConsole *pConsole, long item, ITEM_TYPE itemtype )

{
    HRESULT hr = S_FALSE;

    _ASSERT( NULL != this || m_isDeleted || RESULT == itemtype );                   

	//
    // Redraw the item
	//
    IResultData *pResultData = NULL;

    hr = pConsole->QueryInterface( IID_IResultData, (void **)&pResultData );
    _ASSERT( SUCCEEDED(hr) );   

    HRESULTITEM myhresultitem;
    _ASSERT( NULL != &myhresultitem );    
        
	//
    // lparam == this. See CSpaceStation::OnShow
	//
    hr = pResultData->FindItemByLParam( (LPARAM)this, &myhresultitem );

    if( FAILED(hr) )
    {
		//
        // Failed : Reason may be that current view does not have this item.
        // So exit gracefully.
		//
        hr = S_FALSE;
    } 
	else
    {
        hr = pResultData->UpdateItem( myhresultitem );
        _ASSERT( SUCCEEDED(hr) );
    }

    pResultData->Release();
        
    return hr;
}

HRESULT CUDDISiteNode::OnRefresh( IConsole *pConsole )
{
	//
	// Call IConsole::UpdateAllViews to redraw all views
	// owned by the parent scope item
	//
	HRESULT hr = pConsole->UpdateAllViews( NULL, m_pParent->GetParentScopeItem(), UPDATE_SCOPEITEM );
	_ASSERT( S_OK == hr);

	if( TRUE == SUCCEEDED( hr ) )
	{
		CUDDIWebServerNodeMap::iterator it = m_mapChildren.begin();
		for ( it = m_mapChildren.begin(); it != m_mapChildren.end(); it++ )
		{
			CUDDIWebServerNode *pWSNode = it->second;
			if( NULL != pWSNode ) 
			{
				pWSNode->OnRefresh( pConsole );
			}
		}
	}
	
    return hr;
}

HRESULT CUDDISiteNode::OnAddMenuItems( IContextMenuCallback *pContextMenuCallback, long *pInsertionsAllowed ) 
{
	HRESULT hr = S_OK;

	if( !IsExtension() )
	{
		WCHAR szWebServerMenuText[ MAX_PATH ];
		WCHAR szWebServerMenuDescription[ MAX_PATH ];

		LoadStringW( g_hinst, IDS_WEBSERVER_ADD, szWebServerMenuText, ARRAYLEN( szWebServerMenuText ) );
		LoadStringW( g_hinst, IDS_WEBSERVER_DESCRIPTION, szWebServerMenuDescription, ARRAYLEN( szWebServerMenuDescription ) );

		CONTEXTMENUITEM menuItemsNew[] =
		{
			{
				szWebServerMenuText,
				szWebServerMenuDescription,
				IDM_NEW_WEBSERVER,
				CCM_INSERTIONPOINTID_PRIMARY_TOP,
				m_bStdSvr ? MF_GRAYED : 0,			// this menu option is disabled iff site node is on a Windows Server 2003 standard machine.
				0
			},
			{ NULL, NULL, 0, 0, 0 }
		};


		//
		// Loop through and add each of the menu items, we
		// want to add to new menu, so see if it is allowed.
		//
		if( *pInsertionsAllowed & CCM_INSERTIONALLOWED_TOP )
		{
			for( LPCONTEXTMENUITEM m = menuItemsNew; m->strName; m++ )
			{
				hr = pContextMenuCallback->AddItem( m );
				if( FAILED(hr) )
					break;
			}
		}
	}

#if defined( _DEBUG ) || defined( DBG )
		CONTEXTMENUITEM menuItemsNew[] =
		{
			{
				_T("Debug"), _T("Dump all the configuration data"),
				IDM_DEBUG, CCM_INSERTIONPOINTID_PRIMARY_TOP, 0, 0
			},
			{ NULL, NULL, 0, 0, 0 }
		};


		//
		// Loop through and add each of the menu items, we
		// want to add to new menu, so see if it is allowed.
		//
		if( *pInsertionsAllowed & CCM_INSERTIONALLOWED_TOP )
		{
			for( LPCONTEXTMENUITEM m = menuItemsNew; m->strName; m++ )
			{
				hr = pContextMenuCallback->AddItem( m );
				if( FAILED(hr) )
					break;
			}
		}
#endif

    return hr;
}

CUDDIWebServerNode* CUDDISiteNode::FindChild( LPCTSTR szName )
{
	CUDDIWebServerNodeMap::iterator it;
	for( it = m_mapChildren.begin(); it != m_mapChildren.end(); it++ )
	{
		CUDDIWebServerNode* pNode = it->second;

		if( ( NULL != pNode ) && ( !pNode->IsDeleted() ) && ( 0 == _tcsicmp( szName, pNode->GetName() ) ) )
		{
			return pNode;
		}
	}

	return NULL;
}

HRESULT CUDDISiteNode::OnMenuCommand( IConsole *pConsole, IConsoleNameSpace *pConsoleNameSpace, long lCommandID, IDataObject *pDataObject )
{
    switch( lCommandID )
    {
		case IDM_NEW_WEBSERVER:
		{
			//
			// Use these for some message boxes.
			//
			_TCHAR szMessage[ 512 ];
			_TCHAR szTitle[ 128 ];

			WebServerData wsData;
			wsData.pBase = this;

			HWND hwndConsole = NULL;
			HRESULT hr = pConsole->GetMainWindow( &hwndConsole );
			_ASSERT( S_OK == hr);

			INT_PTR nResult = DialogBoxParam( g_hinst, MAKEINTRESOURCE( IDD_WEBSERVER_NEW ), hwndConsole, CUDDIWebServerNode::NewWebServerDialogProc, (LPARAM)&wsData );

			if( nResult )
			{
				try
				{
					wstring strOldConnStr;
					CUDDIWebServerNode::GetWriterConnectionString( wsData.szName, strOldConnStr );

					if( !CUDDISiteNode::AddWebServerToSite( m_szName, wsData.szName, hwndConsole ) )
					{
						return E_FAIL;
					}

					if( 0 != strOldConnStr.length() )
					{
						wstring strDomain, strServer, strInstance;
						CUDDIWebServerNode::CrackConnectionString( strOldConnStr, strDomain, strServer, strInstance );
						
						CUDDISiteNode *pOldSite = static_cast<CUDDISiteNode *>( m_pParent->FindChild( strServer.c_str() ) );
						if( NULL != pOldSite )
						{
							CUDDIWebServerNode *pOldWS = pOldSite->FindChild( wsData.szName.c_str() );
							if( NULL != pOldSite )
							{
								pOldWS->DeleteFromScopePane( pConsoleNameSpace );
							}
						}
					}

					//
					// Make sure the version of the web server is compatible with the version on the site.
					//
					UINT n = m_nNextChildID;
					CUDDIWebServerNode *pNode = new CUDDIWebServerNode( wsData.szName.c_str(), n, this, m_bIsExtension );					
					if( TRUE == AddChildEntry( pNode, n ) )
					{
		
						//
						// Set the connection strings registry keys on the web server machine to point to this UDDI site.
						//
						tstring szConnStr = CUDDIWebServerNode::BuildConnectionString( m_szName );

						CUDDIWebServerNode::SetReaderConnectionString( wsData.szName.c_str(), szConnStr );
						CUDDIWebServerNode::SetWriterConnectionString( wsData.szName.c_str(), szConnStr );

						//
						// Add this new web server node to the list of web servers for this site.
						//						
						m_nNextChildID++;

						m_bIsDirty = TRUE;
							
						SCOPEDATAITEM sdi;
						ZeroMemory( &sdi, sizeof(SCOPEDATAITEM) );

						sdi.mask =	SDI_STR       |   // Displayname is valid
									SDI_PARAM     |   // lParam is valid
									SDI_IMAGE     |   // nImage is valid
									SDI_OPENIMAGE |   // nOpenImage is valid
									SDI_PARENT	  |
									SDI_CHILDREN;

						sdi.relativeID  = GetScopeItemValue();
						sdi.nImage      = m_mapChildren[ n ]->GetBitmapIndex();
						sdi.nOpenImage  = MMC_IMAGECALLBACK;
						sdi.displayname = MMC_CALLBACK;
						sdi.lParam      = (LPARAM) m_mapChildren[ n ];
						sdi.cChildren   = m_mapChildren[ n ]->HasChildren();

						hr = pConsoleNameSpace->InsertItem( &sdi );
						_ASSERT( SUCCEEDED(hr) );
				                    
						m_mapChildren[ n ]->SetScopeItemValue( sdi.ID );
						m_mapChildren[ n ]->SetParentScopeItem( sdi.relativeID );

						//
						// We created a new object in result pane. We need to insert this object
						// in all the views, call UpdateAllViews for this.
						// Pass pointer to data object passed into OnMenuCommand.
						//
						hr = pConsole->UpdateAllViews( pDataObject, GetScopeItemValue(), UPDATE_SCOPEITEM );
						_ASSERT( S_OK == hr);

						//
						// Prompt the user with a warning to tell them that they might have to alter their
						// machine.config settings if this web server is part of a web farm.
						//					
						memset( szMessage, 0, 512 * sizeof( _TCHAR ) );					
						memset( szTitle, 0, 128 * sizeof( _TCHAR ) );

						LoadString( g_hinst, IDS_WEBSERVER_WEBFARM_DETAIL, szMessage, ARRAYLEN( szMessage ) );
						LoadString( g_hinst, IDS_WEBSERVER_WEBFARM, szTitle, ARRAYLEN( szTitle ) );
						
						MessageBox( hwndConsole, szMessage, szTitle, MB_OK );
					}
				}
				catch( CUDDIException &e )
				{
					UDDIMsgBox( hwndConsole, (LPCTSTR) e, IDS_ERROR_TITLE, MB_ICONEXCLAMATION | MB_OK );
					return E_FAIL;
				}
				catch( ... )
				{
					UDDIMsgBox( hwndConsole, IDS_ERROR_ADDWEBSITE, IDS_ERROR_TITLE, MB_ICONEXCLAMATION | MB_OK );
					return E_UNEXPECTED;
				}
			}
		}
		break;

#if defined( _DEBUG ) || defined( DBG )
		case IDM_DEBUG:
		{
			try
			{
				GetData();
			}
			catch( CUDDIException& e )
			{
				TCHAR szTitle[ 256 ];
				LoadString( g_hinst, IDS_DATABASE_SERVER_GETDATA_ERROR_TITLE, szTitle, ARRAYLEN( szTitle ) );
				HWND hwnd;
				pConsole->GetMainWindow( &hwnd );
				MessageBox( hwnd, e.GetEntireError().c_str(), szTitle, MB_ICONERROR | MB_OK | MB_APPLMODAL );
				return E_FAIL;
			}

			for( CConfigMap::iterator iter = m_mapConfig.begin();
				iter != m_mapConfig.end(); iter++ )
			{
				OutputDebugString( (*iter).first.c_str() );
				OutputDebugString( _T(" = ") );
				OutputDebugString( (*iter).second.c_str() );
				OutputDebugString( _T("\n") );
			}
		}
		break;
#endif
    }

    return S_OK;
}

HRESULT
CUDDISiteNode::OnDelete( IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsoleComp )
{
	if( ( NULL == pConsoleNameSpace ) || ( NULL == pConsoleComp ) )
	{
		return E_INVALIDARG;
	}

    HRESULT hr;
	hr = pConsoleNameSpace->DeleteItem( GetScopeItemValue(), TRUE );

	//
    // Now set isDeleted member so that the parent doesn't try to
    // to insert it again in CUDDIServicesNode::OnShow. Admittedly, a hack...
	//
    m_isDeleted = TRUE;

    return hr;
}

const LPCTSTR CUDDISiteNode::GetName()
{
	return m_szName;
}


BOOL
CUDDISiteNode::GetFullyQualifiedInstanceName( LPCTSTR szName, tstring& strInstanceName )
{
	try
	{
		strInstanceName = _T( "" );

		CUDDIRegistryKey dbkey( _T( "SOFTWARE\\Microsoft\\UDDI" ), KEY_READ, szName );
		strInstanceName = dbkey.GetString( _T( "InstanceName" ) );
		dbkey.Close();

		return TRUE;
	}
	catch( ... )
	{
		strInstanceName = _T( "" );
		return FALSE;
	}
}

const _TCHAR *
CUDDISiteNode::GetInstanceName()
{
	return m_szInstanceName;
}

CUDDISiteNode* CUDDISiteNode::Create( _TCHAR *szName, _TCHAR *szInstanceName, int id, CUDDIServicesNode* parent, BOOL bExtension )
{
	CUDDISiteNode* pNode = new CUDDISiteNode( szName, szInstanceName, id, parent, bExtension );

	try
	{
		if( pNode )
			pNode->GetData();
	}
	catch( CUDDIException &e )
	{
		delete pNode;
		pNode = NULL;

		throw e;
	}
	catch(...)
	{
	}
	return pNode;
}

CConfigMap& CUDDISiteNode::GetConfigMap()
{
	return m_mapConfig;
}


tstring
CUDDISiteNode::GetConnectionStringOLEDB()
{
	try
	{
		tstring strConn = GetConnectionString();
		if( tstring::npos == strConn.find( _T( "Provider=SQLOLEDB.1" ) ) )
		{
			strConn += _T( ";Provider=SQLOLEDB.1" );
		}

		return strConn;
	}
	catch( ... )
	{
		return _T( "" );
	}
}

tstring
CUDDISiteNode::GetConnectionString()
{
	try
	{
		tstring strConn = _T( "Data Source=" );
		tstring strInstanceName = _T( "" );

		BOOL b = GetFullyQualifiedInstanceName( m_szName, strInstanceName );
		if( FALSE == b )
		{
			return _T( "" );
		}

		strConn += strInstanceName;

		strConn += _T(";Initial Catalog=uddi;Integrated Security=SSPI;");

		return strConn;
	}
	catch( ... )
	{
		return _T( "" );
	}
}


BOOL CALLBACK CUDDISiteNode::CryptographyDialogProc( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    CUDDISiteNode *pDatabaseServer = NULL;

    switch( uMsg ) 
	{
		case WM_INITDIALOG:
		{
			SecurityData* pdata = reinterpret_cast<SecurityData*>(lParam);
			CUDDISiteNode* pDBServer = pdata->pServer;
			SetWindowLongPtr( hwndDlg, GWLP_USERDATA, lParam );

			SetDlgItemText( hwndDlg, IDC_CRYPTOGRAPHY_TXT_RESET_DATE, LocalizedDateTime( pdata->pServer->GetConfigMap()[ UDDI_KEY_RESET_DATE ] ).c_str() );
			SendDlgItemMessage( hwndDlg, IDC_CRYPTOGRAPHY_SPIN_TICKET_TIMEOUT, UDM_SETRANGE32, (WPARAM) 1, (LPARAM) 1000 );
			SendDlgItemMessage( hwndDlg, IDC_CRYPTOGRAPHY_SPIN_TIMEOUT, UDM_SETRANGE32, (WPARAM) 1, (LPARAM) 365 );
			SendDlgItemMessage( hwndDlg, IDC_CRYPTOGRAPHY_SPIN_TICKET_TIMEOUT, UDM_SETPOS32, NULL, (LPARAM) pdata->nTicketTimeout );
			SendDlgItemMessage( hwndDlg, IDC_CRYPTOGRAPHY_SPIN_TIMEOUT, UDM_SETPOS32, NULL, (LPARAM) pdata->nKeyTimeout );
			SendDlgItemMessage( hwndDlg, IDC_CRYPTOGRAPHY_CHECK_AUTO_RESET, BM_SETCHECK, pdata->bAutoKeyReset ? BST_CHECKED : BST_UNCHECKED, NULL );
			EnableWindow( GetDlgItem( hwndDlg, IDC_CRYPTOGRAPHY_EDIT_TIMEOUT ), pdata->bAutoKeyReset );
			EnableWindow( GetDlgItem( hwndDlg, IDC_CRYPTOGRAPHY_SPIN_TIMEOUT ), pdata->bAutoKeyReset );
		}
		break;
		
		case WM_HELP:
		{
			SecurityData* pdata = reinterpret_cast<SecurityData*>( GetWindowLongPtr( hwndDlg, GWLP_USERDATA ) ) ;
			wstring strHelp( pdata->pServer->GetHelpFile() );
			strHelp += g_wszUddiCryptographyHelp;

			::HtmlHelp( hwndDlg, strHelp.c_str(), HH_DISPLAY_TOPIC, NULL );
		}
		break;

		case WM_COMMAND:
		{
			SecurityData* pdata = reinterpret_cast<SecurityData*>( GetWindowLongPtr( hwndDlg, GWLP_USERDATA ) ) ;
			_TCHAR szMessage[ 512 ];
			_TCHAR szTitle[ 256 ];

			switch( LOWORD(wParam) ) 
			{
				case IDC_CRYPTOGRAPHY_BTN_RESET_NOW:
					::LoadString( g_hinst, IDS_CRYPTOGRAPHY_RESET_NOW_CONFIRM, szMessage, ARRAYLEN( szMessage ) );
					::LoadString( g_hinst, IDS_CRYPTOGRAPHY_RESET_NOW_TITLE, szTitle, ARRAYLEN( szTitle ) );
					
					if( IDYES == MessageBox( hwndDlg, szMessage, szTitle, MB_YESNO | MB_ICONQUESTION ) )
					{
						if( TRUE == pdata->pServer->ResetCryptography() )
						{
							::LoadString( g_hinst, IDS_CRYPTOGRAPHY_RESET_NOW_SUCCESS, szMessage, ARRAYLEN( szMessage ) );
							::LoadString( g_hinst, IDS_CRYPTOGRAPHY_RESET_NOW_SUCCESS_TITLE, szTitle, ARRAYLEN( szTitle ) );

							SetDlgItemText( hwndDlg, IDC_CRYPTOGRAPHY_TXT_RESET_DATE, LocalizedDateTime( pdata->pServer->m_mapConfig[ UDDI_KEY_RESET_DATE ] ).c_str() );
							MessageBox( hwndDlg, szMessage, szTitle, MB_OK );
						}
						else
						{
							::LoadString( g_hinst, IDS_CRYPTOGRAPHY_RESET_NOW_FAILED, szMessage, ARRAYLEN( szMessage ) );
							::LoadString( g_hinst, IDS_CRYPTOGRAPHY_RESET_NOW_FAILED_TITLE, szTitle, ARRAYLEN( szTitle ) );
							MessageBox( hwndDlg, szMessage, szTitle, MB_OK );
						}
					}
				break;

				case IDC_CRYPTOGRAPHY_CHECK_AUTO_RESET:
				{
					LRESULT nChecked = SendDlgItemMessage( hwndDlg, IDC_CRYPTOGRAPHY_CHECK_AUTO_RESET, BM_GETCHECK, NULL, NULL );
					EnableWindow( GetDlgItem( hwndDlg, IDC_CRYPTOGRAPHY_EDIT_TIMEOUT ), BST_CHECKED == nChecked ? TRUE : FALSE );
					EnableWindow( GetDlgItem( hwndDlg, IDC_CRYPTOGRAPHY_SPIN_TIMEOUT ), BST_CHECKED == nChecked ? TRUE : FALSE );
					pdata->bAutoKeyResetChanged = true;
				}
				break;

				case IDC_CRYPTOGRAPHY_EDIT_TIMEOUT:
				{
					if( ( EN_CHANGE == HIWORD( wParam ) ) && ( NULL != pdata ) )
					{
						pdata->bKeyTimeoutChanged = true;
					}
				}
				break;

				case IDC_CRYPTOGRAPHY_EDIT_TICKET_TIMEOUT:
				{
					if( ( EN_CHANGE == HIWORD( wParam ) ) && ( NULL != pdata ) )
					{
						pdata->bTicketTimeoutChanged = true;
					}
				}
				break;

				case IDHELP:
				{
					wstring strHelp( pdata->pServer->GetHelpFile() );
					strHelp += g_wszUddiCryptographyHelp;

					::HtmlHelp( hwndDlg, strHelp.c_str(), HH_DISPLAY_TOPIC, NULL );
				}
				break;

				case IDOK:
				{
					//
					// Check that the ticket timeout is in proper range.
					//
					
					BOOL bError = FALSE;
					LRESULT lValue = SendDlgItemMessage( hwndDlg, IDC_CRYPTOGRAPHY_SPIN_TICKET_TIMEOUT, UDM_GETPOS32, NULL, (LPARAM) &bError );
					if( bError )
					{
						//
						// Value out of range
						//
						LoadString( g_hinst, IDS_CRYPTOGRAPHY_TICKET_TIMEOUT_ERROR, szMessage, ARRAYLEN( szMessage ) );
						LoadString( g_hinst, IDS_CRYPTOGRAPHY_TICKET_TIMEOUT_ERROR_TITLE, szTitle, ARRAYLEN( szTitle ) );
						
						MessageBox( hwndDlg, szMessage, szTitle, MB_ICONERROR );
						SendDlgItemMessage( hwndDlg, IDC_CRYPTOGRAPHY_SPIN_TICKET_TIMEOUT, UDM_SETPOS32, NULL, (LPARAM) 1000 );
						SetFocus( GetDlgItem( hwndDlg, IDC_CRYPTOGRAPHY_EDIT_TICKET_TIMEOUT ) );
						return FALSE;
					}

					if( pdata->bTicketTimeoutChanged )
					{
						pdata->nTicketTimeout = lValue;
					}

					if( IsWindowEnabled( GetDlgItem( hwndDlg, IDC_CRYPTOGRAPHY_EDIT_TIMEOUT ) ) )
					{
						//
						// Check that the cryptography expiration is within specs
						//
						lValue = SendDlgItemMessage( hwndDlg, IDC_CRYPTOGRAPHY_SPIN_TIMEOUT, UDM_GETPOS32, NULL, (LPARAM) &bError );
						
						if( bError )
						{
							//
							// Value out of range
							//
							LoadString( g_hinst, IDS_CRYPTOGRAPHY_TIMEOUT_ERROR, szMessage, ARRAYLEN( szMessage ) );
							LoadString( g_hinst, IDS_CRYPTOGRAPHY_TICKET_TIMEOUT_ERROR_TITLE, szTitle, ARRAYLEN( szTitle ) );
							
							MessageBox( hwndDlg, szMessage, szTitle, MB_ICONERROR );
							SendDlgItemMessage( hwndDlg, IDC_CRYPTOGRAPHY_SPIN_TIMEOUT, UDM_SETPOS32, NULL, (LPARAM) 365 );
							SetFocus( GetDlgItem( hwndDlg, IDC_CRYPTOGRAPHY_EDIT_TIMEOUT ) );
							return FALSE;
						}

						//
						// We won't update the key timeout unless auto
						// reset is enabled
						//
						if( pdata->bKeyTimeoutChanged )
						{
							pdata->nKeyTimeout = lValue;
						}
					}

					if( pdata->bAutoKeyResetChanged )
					{
						LRESULT nChecked = SendDlgItemMessage( hwndDlg, IDC_CRYPTOGRAPHY_CHECK_AUTO_RESET, BM_GETCHECK, NULL, NULL );
						pdata->bAutoKeyReset = BST_CHECKED == nChecked;
					}
					EndDialog( hwndDlg, TRUE );
				}
				break;

				case IDCANCEL:
				{
					//
					// Reset the change flags if the dialog is cancelled
					//
					pdata->bAutoKeyResetChanged = false;
					pdata->bKeyTimeoutChanged = false;
					pdata->bTicketTimeoutChanged = false;

					EndDialog( hwndDlg, FALSE );
				}
				break;
			} /* End switch(...)*/
		} /* End case WM_COMMAND */
		break;
		case WM_NOTIFY:
		{
			SecurityData* pdata = reinterpret_cast<SecurityData*>( GetWindowLongPtr( hwndDlg, GWLP_USERDATA ) ) ;
			LPNMHDR phdr = (LPNMHDR) lParam;

			if( UDN_DELTAPOS == phdr->code && IDC_CRYPTOGRAPHY_SPIN_TIMEOUT == phdr->idFrom )
			{
				pdata->bKeyTimeoutChanged = true;
			}
			else if( UDN_DELTAPOS == phdr->code && IDC_CRYPTOGRAPHY_SPIN_TICKET_TIMEOUT == phdr->idFrom )
			{
				pdata->bTicketTimeoutChanged = true;
			}
		}
		break;

		case WM_DESTROY:
		break;

	} /* End switch(nMsg) */

    return FALSE;
}

BOOL
CUDDISiteNode::IsDatabaseServer( PTCHAR szName )
{
	try
	{
		CUDDIRegistryKey key( _T( "SOFTWARE\\Microsoft\\UDDI\\Setup" ), KEY_READ, szName );
		DWORD dwDB = key.GetDWORD( _T( "DBServer" ), 0  );
		key.Close();

		return ( 0 == dwDB ) ? FALSE : TRUE;
	}
	catch( ... )
	{
		return FALSE;
	}
}

BOOL
CUDDISiteNode::IsDatabaseServer( PTCHAR szName, PTCHAR szInstance )
{
	try
	{
		CUDDIRegistryKey key( _T( "SOFTWARE\\Microsoft\\UDDI\\Setup" ), KEY_READ, szName );
		DWORD dwDB = key.GetDWORD( _T( "DBServer" ), 0  );
		key.Close();

		if( 0 == dwDB )
			return FALSE;

		CUDDIRegistryKey dbkey( _T( "SOFTWARE\\Microsoft\\UDDI" ), KEY_READ, szName );
		tstring strInstance = dbkey.GetString( _T( "InstanceName" ), _T("") );
		dbkey.Close();

		if( 0 != _tcsicmp( szInstance, InstanceRealName( strInstance.c_str() ) ) )
			return FALSE;
		
		return TRUE;
	}
	catch( ... )
	{
		return FALSE;
	}
}

BOOL CUDDISiteNode::ResetCryptography()
{
	BOOL fRet = FALSE;
	try
	{
		HRESULT hr = E_FAIL;
		ADM_execResetKeyImmediate resetkey;
		resetkey.m_connectionString = GetConnectionStringOLEDB().c_str();

		hr = resetkey.Open();

		if( FAILED(hr) || 0 != resetkey.m_RETURNVALUE )
		{
			CUDDISiteNode::HandleOLEDBError( hr );
		}

		m_mapConfig[ UDDI_KEY_RESET_DATE ] = resetkey.m_keyLastResetDate;
		fRet = TRUE;
	}
	catch( CUDDIException &e )
	{
		OutputDebugString( e );
		fRet = FALSE;
	}
	catch( ... )
	{
		fRet = FALSE;
	}

	return fRet;
}

HRESULT CUDDISiteNode::SaveData()
{
	HRESULT hr = S_OK;
	
	//
	// Save each modifed configuration value into the configuration table
	// using net_config_save
	//
	OutputDebugString( _T("Updating Values...\n") );

	for( CConfigMap::iterator iter = m_mapChanges.begin();
		iter != m_mapChanges.end(); iter++ )
	{
		if( 0 == _tcsicmp( (*iter).first.c_str(), UDDI_ADMIN_GROUP ) )
		{
			OutputDebugString( _T("The Administrator Group Name was modified\n") );

			//
			// The admin group has been changed. We need to update this independently because the
			// translation of the "S-1..." format to SID is very difficult in T-SQL
			//
			// TODO: This call should be bound inside a transaction. with net_config_save
			//
			ADM_setAdminAccount updateadmin;
			updateadmin.m_connectionString = GetConnectionStringOLEDB().c_str();
			_tcsncpy( updateadmin.m_accountName, GroupNameFromSid( (*iter).second, m_szName ).c_str(), ARRAYLEN( updateadmin.m_accountName ) );
			updateadmin.m_accountName[ ARRAYLEN( updateadmin.m_accountName ) - 1 ] = NULL;
			hr = updateadmin.Open();
			if( FAILED(hr) || 0 != updateadmin.m_RETURNVALUE )
			{
				try
				{
					CUDDISiteNode::HandleOLEDBError( hr );
				}
				catch( CUDDIException &e )
				{
					// leave 'hr' the same.
					OutputDebugString( e );
				}
				catch( ... )
				{
					// leave 'hr' the same.
				}

				break;
			}
		}

		OutputDebugString( (*iter).first.c_str() );
		OutputDebugString( _T(" = ") );
		OutputDebugString( (*iter).second.c_str() );
		OutputDebugString( _T("\n") );

		net_config_save rs;
		rs.m_connectionString = GetConnectionStringOLEDB().c_str();
		_tcsncpy( rs.m_configName, (*iter).first.c_str(), ARRAYLEN( rs.m_configName ) - 1 );
		rs.m_configName[ ARRAYLEN( rs.m_configName ) - 1 ] = 0x00;

		_tcsncpy( rs.m_configValue, (*iter).second.c_str(), ARRAYLEN( rs.m_configValue ) - 1 );
		rs.m_configValue[ ARRAYLEN( rs.m_configValue ) - 1 ] = 0x00;

		hr = rs.Open();
		if( FAILED(hr) || 0 != rs.m_RETURNVALUE )
		{
			try
			{
				CUDDISiteNode::HandleOLEDBError( hr );
			}
			catch( CUDDIException &e )
			{
				// leave 'hr' the same.
				OutputDebugString( e );
			}
			catch( ... )
			{
				// leave 'hr' the same.
			}

			break;
		}
	}

	//
	// Regardless of the outcome clear the change collection
	//
	m_mapChanges.clear();

	return hr;
}

struct PropertyData
{
	CUDDISiteNode* pServer;
	_TCHAR szName[ 512 ];
	_TCHAR szValue[ 512 ];
	_TCHAR szDefault[ 512 ];
	_TCHAR szHelpText[ 512 ];
};

BOOL CALLBACK CUDDISiteNode::AdvancedDialogProc( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    switch( uMsg ) 
	{
		case WM_INITDIALOG:
		{
			CUDDISiteNode* pDatabaseServer = reinterpret_cast<CUDDISiteNode *>(reinterpret_cast<PROPSHEETPAGE *>(lParam)->lParam);
			SetWindowLongPtr( hwndDlg, GWLP_USERDATA, reinterpret_cast<LONG_PTR>(pDatabaseServer) );

			CConfigMap& m_mapConfig = pDatabaseServer->m_mapConfig;
			HWND hwndList = GetDlgItem( hwndDlg, IDC_ACTIVEDIRECTORY_LIST_ADVANCED );
			
			ListView_SetExtendedListViewStyleEx( hwndList, 0, LVS_EX_BORDERSELECT | LVS_EX_FULLROWSELECT | LVS_EX_GRIDLINES );

			TCHAR szName[ 256 ];
			LVCOLUMN lvcol;
			LoadString( g_hinst, IDS_ADVANCED_NAME_COLUMN_NAME, szName, ARRAYLEN( szName ) );
			ZeroMemory( &lvcol, sizeof( lvcol ) );
			lvcol.mask = LVCF_TEXT | LVCF_WIDTH | LVCF_FMT;
			lvcol.fmt = LVCFMT_LEFT;
			lvcol.cx = 150;
			lvcol.pszText = szName;
			ListView_InsertColumn( hwndList, 0,  &lvcol );

			LoadString( g_hinst, IDS_ADVANCED_VALUE_COLUMN_NAME, szName, ARRAYLEN( szName ) );
			ZeroMemory( &lvcol, sizeof( lvcol ) );
			lvcol.mask = LVCF_TEXT | LVCF_WIDTH | LVCF_FMT;
			lvcol.fmt = LVCFMT_LEFT;
			lvcol.cx = 215;
			lvcol.pszText = szName;
			ListView_InsertColumn( hwndList, 1,  &lvcol );

			LPCTSTR ppszValues[] = { 
					UDDI_DISCOVERY_URL,
					UDDI_FIND_MAXROWS,
					UDDI_OPERATOR_NAME };
			
			for( int i=0; i< ARRAYLEN( ppszValues ); i++ )
			{
				LVITEM item;
				ZeroMemory( &item, sizeof( item ) );
				item.mask = LVIF_TEXT;
				item.pszText = _T("");
				int nIndex = ListView_InsertItem( hwndList, &item );

				ListView_SetItemText( hwndList, nIndex, 0, (PTCHAR) ppszValues[ i ] );
				ListView_SetItemText( hwndList, nIndex, 1, (_TCHAR*) m_mapConfig[ ppszValues[ i ] ].c_str() );
			}

			break;
		}
		case WM_COMMAND:
			if( IDC_ADVANCED_BTN_EDIT == LOWORD( wParam ) )
			{
				CUDDISiteNode* pDatabaseServer = reinterpret_cast<CUDDISiteNode*>( GetWindowLongPtr( hwndDlg, GWLP_USERDATA ) );

				HWND hwndList = GetDlgItem( hwndDlg, IDC_ACTIVEDIRECTORY_LIST_ADVANCED );
				int n = ListView_GetNextItem( hwndList, -1, LVNI_SELECTED );
				if( -1 != n )
				{
					PropertyData data;
					data.pServer = pDatabaseServer;

					ListView_GetItemText( hwndList, n, 0, data.szName, 256 );
					ListView_GetItemText( hwndList, n, 1, data.szValue, 256 );

					INT_PTR nResult = DialogBoxParam( g_hinst, MAKEINTRESOURCE( IDD_ADVANCED_EDIT ), hwndDlg, PropertyEditDialogProc, (LPARAM) &data );

					if( nResult )
					{
						ListView_SetItemText( hwndList, n, 1, data.szValue );
						SendMessage( GetParent(hwndDlg), PSM_CHANGED, (WPARAM) hwndDlg, 0 );
					}
				}
			}
		break;
		case WM_NOTIFY:
			if( IDC_ACTIVEDIRECTORY_LIST_ADVANCED == wParam && NM_DBLCLK == ((LPNMHDR)lParam)->code )
			{
				CUDDISiteNode* pDatabaseServer = reinterpret_cast<CUDDISiteNode*>( GetWindowLongPtr( hwndDlg, GWLP_USERDATA ) );

				HWND hwndList = GetDlgItem( hwndDlg, IDC_ACTIVEDIRECTORY_LIST_ADVANCED );

				//
				// The list was double-clicked
				// use hit test to determine the item index
				//
				LPNMITEMACTIVATE pitem = (LPNMITEMACTIVATE) lParam;
				LVHITTESTINFO htinfo;
				ZeroMemory( &htinfo, sizeof( LVHITTESTINFO ) );
				htinfo.pt = pitem->ptAction;
				int n = ListView_SubItemHitTest( GetDlgItem( hwndDlg, IDC_ACTIVEDIRECTORY_LIST_ADVANCED ),&htinfo );

				if( -1 != n )
				{
					PropertyData data;
					data.pServer = pDatabaseServer;

					ListView_GetItemText( hwndList, n, 0, data.szName, ARRAYLEN( data.szName ) );
					ListView_GetItemText( hwndList, n, 1, data.szValue, ARRAYLEN( data.szValue ) );

					INT_PTR nResult = DialogBoxParam( g_hinst, MAKEINTRESOURCE( IDD_ADVANCED_EDIT ), hwndDlg, PropertyEditDialogProc, (LPARAM) &data );

					if( nResult )
					{
						ListView_SetItemText( hwndList, n, 1, data.szValue );
						SendMessage( GetParent(hwndDlg), PSM_CHANGED, (WPARAM) hwndDlg, 0 );
					}
				}
			}
			else if( IDC_ACTIVEDIRECTORY_LIST_ADVANCED == wParam && 
					  LVN_ITEMCHANGED == ((LPNMHDR)lParam)->code )
			{
				HWND hwndList = GetDlgItem( hwndDlg, IDC_ACTIVEDIRECTORY_LIST_ADVANCED );
				EnableWindow( GetDlgItem( hwndDlg, IDC_ADVANCED_BTN_EDIT ), ( ListView_GetSelectedCount( hwndList ) > 0 ) );
			}
			else if( PSN_APPLY == ((NMHDR *) lParam)->code ) 
			{
				CUDDISiteNode* pDatabaseServer = reinterpret_cast<CUDDISiteNode*>( GetWindowLongPtr( hwndDlg, GWLP_USERDATA ) );

				//
				// Loop through the items and add modified items to the change collection
				//
				HWND hwndList = GetDlgItem( hwndDlg, IDC_ACTIVEDIRECTORY_LIST_ADVANCED );
				int n = ListView_GetNextItem( hwndList, -1, LVNI_ALL );
				while( -1 != n )
				{
					_TCHAR szModified[ 2 ];
					ListView_GetItemText( hwndList, n, 0, szModified, 2 );

					if( NULL != szModified[ 0 ] )
					{
						_TCHAR szName[ 256 ];
						_TCHAR szValue[ 256 ];
						ListView_GetItemText( hwndList, n, 0, szName, ARRAYLEN( szName ) );
						ListView_GetItemText( hwndList, n, 1, szValue, ARRAYLEN( szValue ) );
						pDatabaseServer->m_mapChanges[ szName ] = szValue;
					}

					n = ListView_GetNextItem( hwndList, n, LVNI_ALL );
				}

				//
				// Ask MMC to send us a message (on the main thread) so
				// we know the Apply button was clicked.
				//
				HRESULT hr = MMCPropertyChangeNotify( pDatabaseServer->m_ppHandle, reinterpret_cast<LONG_PTR>( pDatabaseServer ) );
				_ASSERT( SUCCEEDED(hr) );

				return PSNRET_NOERROR;
			}
			else if( PSN_HELP == ((NMHDR *) lParam)->code )
			{
				CUDDISiteNode* pDatabaseServer = reinterpret_cast<CUDDISiteNode*>( GetWindowLongPtr( hwndDlg, GWLP_USERDATA ) );
				wstring strHelp( pDatabaseServer->GetHelpFile() );
				strHelp += g_wszUddiAdvancedPageHelp;

				::HtmlHelp( hwndDlg, strHelp.c_str(), HH_DISPLAY_TOPIC, NULL );
			}

		break;
		case WM_HELP:
		{
			CUDDISiteNode* pDatabaseServer = reinterpret_cast<CUDDISiteNode*>( GetWindowLongPtr( hwndDlg, GWLP_USERDATA ) );
			wstring strHelp( pDatabaseServer->GetHelpFile() );
			strHelp += g_wszUddiAdvancedPageHelp;

			::HtmlHelp( hwndDlg, strHelp.c_str(), HH_DISPLAY_TOPIC, NULL );
		}
	}

    return FALSE;
}

BOOL CALLBACK CUDDISiteNode::PropertyEditDialogProc( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    switch( uMsg ) 
	{
		case WM_INITDIALOG:
		{
			PropertyData* pdata = (PropertyData*) lParam;
			SetWindowLongPtr( hwndDlg, GWLP_USERDATA, reinterpret_cast<LONG_PTR>( pdata ) );

			SetDlgItemText( hwndDlg, IDC_ADVANCED_EDIT_TXT_NAME, pdata->szName );
			SetDlgItemText( hwndDlg, IDC_ADVANCED_EDIT_VALUE, pdata->szValue );
			break;
		}
		case WM_HELP:
		{
			PropertyData* pdata = reinterpret_cast<PropertyData*>( GetWindowLongPtrA( hwndDlg, GWLP_USERDATA ) );
			wstring strHelp( pdata->pServer->GetHelpFile() );

			strHelp += g_wszUddiEditPropertyHelp;

			::HtmlHelp( hwndDlg, strHelp.c_str(), HH_DISPLAY_TOPIC, NULL );
			break;
		}
		case WM_COMMAND:

			if( IDOK == LOWORD( wParam ) )
			{
				PropertyData* pdata = reinterpret_cast<PropertyData*>( GetWindowLongPtrA( hwndDlg, GWLP_USERDATA ) );
				GetDlgItemText( hwndDlg, IDC_ADVANCED_EDIT_VALUE, pdata->szValue, sizeof( pdata->szValue ) / sizeof( _TCHAR ) );

				EndDialog( hwndDlg, TRUE );
				return FALSE;
			}
			else if( IDCANCEL == LOWORD( wParam ) )
			{
				EndDialog( hwndDlg, FALSE );
				return FALSE;
			}
			else if( IDHELP == LOWORD( wParam ) )
			{
				PropertyData* pdata = reinterpret_cast<PropertyData*>( GetWindowLongPtrA( hwndDlg, GWLP_USERDATA ) );
				wstring strHelp( pdata->pServer->GetHelpFile() );
				strHelp += g_wszUddiEditPropertyHelp;

				::HtmlHelp( hwndDlg, strHelp.c_str(), HH_DISPLAY_TOPIC, NULL );
			}
		break;
	}

    return FALSE;
}

BOOL CALLBACK CUDDISiteNode::NewDatabaseServerDialogProc( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
	static DatabaseData* pData = NULL;

    switch( uMsg ) 
	{
		case WM_INITDIALOG:
		{
			WCHAR wszBuf[ 256 ];
			wszBuf[ 0 ] = 0x00;
			DWORD dwBufSize = 256;

			GetComputerName( wszBuf, &dwBufSize );

			pData = reinterpret_cast<DatabaseData*>(lParam);

			BOOL fChildExists = FALSE;
			if( pData && pData->pBase )
			{
				if( pData->pBase->ChildExists( wszBuf ) )
				{
					fChildExists = TRUE;
				}
			}

			if( IsDatabaseServer( _T("") ) && !fChildExists )
			{
				SendDlgItemMessage( hwndDlg, IDC_SITE_CONNECT_RADIO_LOCALCOMPUTER, BM_SETCHECK, TRUE, NULL );
				EnableWindow( GetDlgItem( hwndDlg, IDOK ), TRUE );
				RefreshInstances( GetDlgItem( hwndDlg, IDC_SITE_CONNECT_TXT_DATABASE_INSTANCE ) );
			}
			else
			{
				EnableWindow( GetDlgItem( hwndDlg, IDC_SITE_CONNECT_RADIO_LOCALCOMPUTER ), FALSE );
				EnableWindow( GetDlgItem( hwndDlg, IDC_SITE_CONNECT_BTN_BROWSE ), TRUE );
				EnableWindow( GetDlgItem( hwndDlg, IDC_SITE_CONNECT_EDIT_ANOTHERCOMPUTER ), TRUE );
				EnableWindow( GetDlgItem( hwndDlg, IDOK ), FALSE );

				SetDlgItemText( hwndDlg, IDC_SITE_CONNECT_TXT_DATABASE_INSTANCE, _T("") );
				SendDlgItemMessage( hwndDlg, IDC_SITE_CONNECT_RADIO_ANOTHERCOMPUTER, BM_SETCHECK, TRUE, NULL );
				SetFocus( GetDlgItem( hwndDlg, IDC_SITE_CONNECT_EDIT_ANOTHERCOMPUTER ) );
			}
			break;
		}

		case WM_HELP:
		{
			wstring strHelp( pData->pBase->GetHelpFile() );
			strHelp += g_wszUddiAddSiteHelp;

			::HtmlHelp( hwndDlg, strHelp.c_str(), HH_DISPLAY_TOPIC, NULL );
			break;
		}

        case WM_COMMAND:
		{
            switch( LOWORD(wParam) ) 
            { 
				case IDC_SITE_CONNECT_RADIO_LOCALCOMPUTER:
				{
					EnableWindow( GetDlgItem( hwndDlg, IDC_SITE_CONNECT_BTN_BROWSE ), FALSE );
					EnableWindow( GetDlgItem( hwndDlg, IDC_SITE_CONNECT_EDIT_ANOTHERCOMPUTER ), FALSE );
					EnableWindow( GetDlgItem( hwndDlg, IDOK ), TRUE );

					RefreshInstances( GetDlgItem( hwndDlg, IDC_SITE_CONNECT_TXT_DATABASE_INSTANCE ) );
					break;
				}

				case IDC_SITE_CONNECT_RADIO_ANOTHERCOMPUTER:
				{
					EnableWindow( GetDlgItem( hwndDlg, IDC_SITE_CONNECT_BTN_BROWSE ), TRUE );
					EnableWindow( GetDlgItem( hwndDlg, IDC_SITE_CONNECT_EDIT_ANOTHERCOMPUTER ), TRUE );

					WCHAR wszComputerName[ 256 ];
					wszComputerName[ 0 ] = 0x00;
					GetDlgItemText( hwndDlg, IDC_SITE_CONNECT_EDIT_ANOTHERCOMPUTER, wszComputerName, ARRAYLEN( wszComputerName ) );

					//
					// Enable the OK button only if there is some sort of text
					// in the edit control where the computer name is supposed
					// to be typed in.
					//
					EnableWindow( GetDlgItem( hwndDlg, IDOK ), 0 == wcslen( wszComputerName ) ? FALSE : TRUE );

					if( 0 == _tcslen( wszComputerName ) )
						SetDlgItemText( hwndDlg, IDC_SITE_CONNECT_TXT_DATABASE_INSTANCE, _T("") );
					else
						RefreshInstances( GetDlgItem( hwndDlg, IDC_SITE_CONNECT_TXT_DATABASE_INSTANCE ), wszComputerName );

					break;
				}

				case IDC_SITE_CONNECT_EDIT_ANOTHERCOMPUTER:
				{
					if( EN_CHANGE == HIWORD(wParam) )
					{
						SetDlgItemText( hwndDlg, IDC_SITE_CONNECT_TXT_DATABASE_INSTANCE, _T("") );

						WCHAR wszComputerName[ 256 ];
						wszComputerName[ 0 ] = 0x00;
						GetDlgItemText( hwndDlg, IDC_SITE_CONNECT_EDIT_ANOTHERCOMPUTER, wszComputerName, ARRAYLEN( wszComputerName ) );
						
						//
						// Enable the OK button only if there is some sort of text
						// in the edit control where the computer name is supposed
						// to be typed in.
						//
						EnableWindow( GetDlgItem( hwndDlg, IDOK ), 0 == wcslen( wszComputerName ) ? FALSE : TRUE );
					}
					break;
				}

				case IDC_SITE_CONNECT_BTN_BROWSE:
				{
					_TCHAR szComputerName[ 256 ];
					if( ObjectPicker( hwndDlg, OT_Computer, szComputerName, ARRAYLEN( szComputerName ) ) )
					{
						SetDlgItemText( hwndDlg, IDC_SITE_CONNECT_EDIT_ANOTHERCOMPUTER, szComputerName );
						RefreshInstances( GetDlgItem( hwndDlg, IDC_SITE_CONNECT_TXT_DATABASE_INSTANCE ), szComputerName );
					}

					break;
				}

				case IDHELP:
				{
					wstring strHelp( pData->pBase->GetHelpFile() );
					strHelp += g_wszUddiAddSiteHelp;

					::HtmlHelp( hwndDlg, strHelp.c_str(), HH_DISPLAY_TOPIC, NULL );

					break;
				}
					
                case IDOK:
				{
					DWORD dwSize = 256;

					if( SendDlgItemMessage( hwndDlg, IDC_SITE_CONNECT_RADIO_LOCALCOMPUTER, BM_GETCHECK, NULL, NULL ) )
					{
						//
						// The user chose to use the database on the local computer.
						//
						pData->szServerName[ 0 ] = 0;
						GetComputerName( pData->szServerName, &dwSize );
					}
					else
					{
						//
						// The user chose to go with whatever they typed in for a computer name.
						//
						GetDlgItemText( hwndDlg, IDC_SITE_CONNECT_EDIT_ANOTHERCOMPUTER, pData->szServerName, dwSize );

						static const tstring szLocalhost = _T("localhost");

						//
						// If the user typed in 'localhost', we have to switch it.  Must be
						// careful though... 'localhostabc' is a 100% legal computer name.
						//
						if( ( szLocalhost.length() == _tcslen( pData->szServerName ) ) && ( 0 == _tcsncicmp( szLocalhost.c_str(), pData->szServerName, szLocalhost.length() ) ) )
						{
							dwSize = 256;
							pData->szServerName[ 0 ] = 0;
							GetComputerName( pData->szServerName, &dwSize );

							//
							// If there is no UDDI database installed on the local computer,
							// tell the user & force them to re-select.
							//
							if( !CUDDISiteNode::IsDatabaseServer( pData->szServerName ) )
							{
								_TCHAR szTitle[ 256 ];
								_TCHAR szMessage[ 1024 ];
								LoadString( g_hinst, IDS_DATABASE_SERVER_SELECT_ERROR, szMessage, ARRAYLEN( szMessage ) );
								LoadString( g_hinst, IDS_DATABASE_SERVER_SELECT_ERROR_TITLE, szTitle, ARRAYLEN( szTitle ) );
								MessageBox( hwndDlg, szMessage, szTitle, MB_ICONERROR );
								return FALSE;
							}
						}
					}
					
					if( 0 == _tcslen( pData->szServerName ) || !CUDDISiteNode::IsDatabaseServer( pData->szServerName ) )
					{
						_TCHAR szTitle[ 256 ];
						_TCHAR szMessage[ 1024 ];
						LoadString( g_hinst, IDS_DATABASE_SERVER_SELECT_ERROR, szMessage, ARRAYLEN( szMessage ) );
						LoadString( g_hinst, IDS_DATABASE_SERVER_SELECT_ERROR_TITLE, szTitle, ARRAYLEN( szTitle ) );
						MessageBox( hwndDlg, szMessage, szTitle, MB_ICONERROR );
						return FALSE;
					}

					//
					// Copy the instance name into the structure
					//
					tstring strLocalInstanceName;
					BOOL bSuccess = CUDDISiteNode::GetFullyQualifiedInstanceName( pData->szServerName, strLocalInstanceName );
					_tcsncpy( pData->szInstanceName, strLocalInstanceName.c_str(), ARRAYLEN( pData->szInstanceName ) );
					pData->szInstanceName[ ARRAYLEN( pData->szInstanceName ) - 1 ] = NULL;

					ToUpper( pData->szServerName );

                    EndDialog( hwndDlg, TRUE ); 
 					return TRUE;
				}

				case IDCANCEL:
				{
                    EndDialog( hwndDlg, FALSE );
					return TRUE;
				}
			}
		}

		case WM_DESTROY:
		{
			break;
		}
    }

    return FALSE;
}

BOOL GetInstances( PTCHAR szComputer, StringVector& instances )
{
	try
	{
		CUDDIRegistryKey key( _T("SOFTWARE\\Microsoft\\Microsoft SQL Server" ), KEY_READ, szComputer );
		key.GetMultiString( _T("InstalledInstances"), instances );
	}
	catch(...)
	{
	}

	return ( 0 != instances.size() );
}

//
// This function will look at the registry of the specifed
// computer and determine it hosts a UDDI Services Database
// Component. If it does it will set the text of the specified
// control and return TRUE.
//
BOOL RefreshInstances( HWND hwnd, PTCHAR szComputerName )
{
	try
	{
		_TCHAR szText[ 512 ];
		_TCHAR szComputer[ 256 ];
		DWORD dwSize = ARRAYLEN( szComputer );

		if( 0 == _tcslen( szComputerName ) )
		{
			szComputer[ 0 ] = 0;
			::GetComputerName( szComputer, &dwSize );
		}
		else
		{
			_tcsncpy( szComputer, szComputerName, ARRAYLEN( szComputer ) - 1 );
			szComputer[ ARRAYLEN( szComputer ) - 1 ] = NULL;
		}

		BOOL bFound = FALSE;

		StringVector instances;
		if( GetInstances( szComputer, instances ) )
		{
			CUDDIRegistryKey dbkey( _T( "SOFTWARE\\Microsoft\\UDDI\\Setup\\DBServer" ), KEY_READ, szComputer );
			tstring strInstance = dbkey.GetString( _T( "InstanceNameOnly" ), _T("----") );
			dbkey.Close();

			if( _T("----") != strInstance )
			{
				for( StringVector::iterator iter = instances.begin();
					iter != instances.end() && !bFound;	iter++ )
				{
					if( 0 == _tcsicmp( strInstance.c_str(), InstanceDisplayName( (*iter).c_str() ) ) )
					{
						_TCHAR szTemplate[ 512 ];
						LoadString( g_hinst, IDS_SITE_CONNECT_INSTANCE_FOUND_TEMPLATE, szTemplate, ARRAYLEN( szTemplate ) );
						_sntprintf( szText, ARRAYLEN( szText ), szTemplate, strInstance.c_str() );
						szText[ ARRAYLEN( szText ) - 1 ] = NULL;
						bFound = TRUE;
					}
				}
			}
		}

		if( !bFound )
		{
			LoadString( g_hinst, IDS_SITE_CONNECT_NO_INSTANCES_FOUND, szText, ARRAYLEN( szText ) );
		}

		SetWindowText( hwnd, szText );

		return TRUE;
	}
	catch( ... )
	{
		return FALSE;
	}
}

_TCHAR szDefaultInstance[ 256 ] = _T("");

_TCHAR* DefaultInstanceDisplayName()
{
	if( !szDefaultInstance[ 0 ] )
	{
		::LoadString( g_hinst, IDS_DATABASE_SERVER_DEFAULT_INSTANCE, szDefaultInstance, ARRAYLEN( szDefaultInstance ) );
	}
	
	return (_TCHAR*) szDefaultInstance;
}

const _TCHAR szDefaultRealName[] = _T("");

LPCTSTR InstanceDisplayName( LPCTSTR szName )
{
	if( tstring( szName ) == tstring( _T("MSSQLSERVER") ) ||
		0 == _tcslen( szName ) )
	{
		return DefaultInstanceDisplayName();
	}
	else
		return szName;
}

LPCTSTR InstanceRealName( LPCTSTR szName )
{
	if( tstring( szName ) == tstring( DefaultInstanceDisplayName() ) )
	{
		return szDefaultRealName;
	}
	else
		return szName;
}

void
CUDDISiteNode::HandleOLEDBError( HRESULT hrErr )
{
	CDBErrorInfo ErrorInfo;
	ULONG        cRecords = 0;
	HRESULT      hr;
	ULONG        i;
	CComBSTR     bstrDesc, bstrHelpFile, bstrSource, bstrMsg;
	GUID         guid;
	DWORD        dwHelpContext;
	WCHAR        wszGuid[40];
	USES_CONVERSION;

	// If the user passed in an HRESULT then trace it
	if( hrErr != S_OK )
	{
		TCHAR sz[ 256 ];
		_sntprintf( sz, 256, _T("OLE DB Error Record dump for hr = 0x%x\n"), hrErr );
		sz[ 255 ] = 0x00;
		bstrMsg += sz;
	}

	LCID lcLocale = GetSystemDefaultLCID();

	hr = ErrorInfo.GetErrorRecords(&cRecords);
	if( FAILED(hr) && ( ErrorInfo.m_spErrorInfo == NULL ) )
	{
		TCHAR sz[ 256 ];
		_sntprintf( sz, 256, _T("No OLE DB Error Information found: hr = 0x%x\n"), hr );
		sz[ 255 ] = 0x00;
		bstrMsg += sz;
	}
	else
	{
		for( i = 0; i < cRecords; i++ )
		{
			hr = ErrorInfo.GetAllErrorInfo(i, lcLocale, &bstrDesc, &bstrSource, &guid,
										&dwHelpContext, &bstrHelpFile);
			if( FAILED(hr) )
			{
				TCHAR sz[ 256 ];
				_sntprintf( sz, 256, _T("OLE DB Error Record dump retrieval failed: hr = 0x%x\n"), hr );
				sz[ 255 ] = 0x00;
				bstrMsg += sz;
				break;
			}

			StringFromGUID2( guid, wszGuid, sizeof(wszGuid) / sizeof(WCHAR) );
			TCHAR sz[ 256 ];
			_sntprintf( 
				sz, 256,
				_T("Row #: %4d Source: \"%s\" Description: \"%s\" Help File: \"%s\" Help Context: %4d GUID: %s\n"),
		        i, OLE2T(bstrSource), OLE2T(bstrDesc), OLE2T(bstrHelpFile), dwHelpContext, OLE2T(wszGuid) );

			sz[ 255 ] = 0x00;
			bstrMsg += sz;

			bstrSource.Empty();
			bstrDesc.Empty();
			bstrHelpFile.Empty();
		}

		bstrMsg += _T("OLE DB Error Record dump end\n");

		throw CUDDIException( hrErr, wstring( bstrMsg.m_str ) );
	}
}


void
CUDDISiteNode::ClearChildMap()
{
	for( CUDDIWebServerNodeMap::iterator iter = m_mapChildren.begin();
 		iter != m_mapChildren.end(); iter++ )
	{
		delete iter->second;
		iter->second = NULL;
    }

	m_mapChildren.clear();
}


BOOL
CUDDISiteNode::LoadChildMap( const tstring& szWebServers )
{
	BOOL fRet = FALSE;

	//
	// Blow away any current children.
	//
	ClearChildMap();

	if( IsExtension() )
	{
		if( CUDDIWebServerNode::IsWebServer( m_szName ) )
		{
			tstring strDomain, strServer, strInstance, strWriter;
			CUDDIWebServerNode::GetWriterConnectionString( m_szName, strWriter );

			if( !strWriter.empty() )
			{
				CUDDIWebServerNode::CrackConnectionString( strWriter, strDomain, strServer, strInstance );

				if( 0 == _tcsicmp( strServer.c_str(), m_szName ) )
				{
					UINT n = m_nNextChildID;
					m_nNextChildID++;
					CUDDIWebServerNode *pNode = new CUDDIWebServerNode( strServer.c_str(), n, this, m_bIsExtension );
					AddChildEntry( pNode, n );			
				}
			}
		}
	}
	else
	{
		CStringCollection webServers( szWebServers );
		int iWebServerCnt = webServers.Size();
		for( int i = 0; i < iWebServerCnt; i++ )
		{
			const wstring& webServer = webServers[ i ];

			//
			// If the machine is hosting the UDDI Web Server, and if that Web Server is not already
			// a part of this UDDI site, then add it.
			//
			if( CUDDIWebServerNode::IsWebServer( webServer.c_str() ) && ( NULL == FindChild( webServer.c_str() ) ) )
			{
				UINT n = m_nNextChildID;
				m_nNextChildID++;
				CUDDIWebServerNode *pNode = new CUDDIWebServerNode( webServer.c_str(), n, this, m_bIsExtension );
				AddChildEntry( pNode, n );			
			}
		}

		fRet = TRUE;

		if( 0 == m_mapChildren.size() )
		{
			if( CUDDIWebServerNode::IsWebServer( m_szName ) )
			{
				tstring szWriter, szDomain, szServer, szInstance;
				CUDDIWebServerNode::GetWriterConnectionString( m_szName, szWriter );

				if( !szWriter.empty() )
				{
					CUDDIWebServerNode::CrackConnectionString( szWriter, szDomain, szServer, szInstance );

					if( 0 == _tcsicmp( szServer.c_str(), m_szName ) )
					{
						// add a node in our child map, change our list of writers
						UINT n = m_mapChildren.size();

						CUDDIWebServerNode *pNode = new CUDDIWebServerNode( m_szName, n, this, m_bIsExtension );

						
						if( TRUE == AddChildEntry( pNode, n ) )
						{
							tstring szWriters;
							SaveChildMap( szWriters );

							m_mapChanges[ UDDI_SITE_WEBSERVERS ] = szWriters;
						}
					}
				}
			}
		}
	}
	return fRet;
}

int
CUDDISiteNode::SaveChildMap( tstring& szWebServers )
{
	szWebServers = _T("");
	BOOL fFirst = TRUE;
	CUDDIWebServerNodeMap::iterator it;
	int cnt = 0;

	for( it = m_mapChildren.begin(); it != m_mapChildren.end(); it++ )
	{
		CUDDIWebServerNode *pWS = it->second;

		if( !pWS->IsDeleted() )
		{
			if( fFirst )
			{
				fFirst = FALSE;
			}
			else
			{
				szWebServers.append( _T("%") );
			}

			szWebServers.append( pWS->GetName() );
			cnt++;
		}
	}

	return cnt;
}

void
CUDDISiteNode::OnDeleteChild( const tstring& szName )
{
	//
	// The child node has already removed itself from the scope pane.
	// We use this function to update our change map to reflect the
	// fact that we now have 1 less Web Server writing to this DB.
	//
	tstring szWebServers;
	SaveChildMap( szWebServers );

	m_mapChanges[ UDDI_SITE_WEBSERVERS ] = szWebServers;

	SaveData();

	m_mapConfig[ UDDI_SITE_WEBSERVERS ] = szWebServers;
}


HRESULT
CUDDISiteNode::AddChildrenToScopePane( IConsoleNameSpace *pConsoleNameSpace, HSCOPEITEM parent )
{
	HRESULT hr = E_FAIL;

	if( ( NULL == pConsoleNameSpace ) || ( NULL == parent ) )
	{
		return E_INVALIDARG;
	}

	//
    // Create the child nodes, then expand them
	//
    SCOPEDATAITEM sdi;
	CUDDIWebServerNodeMap::iterator it;

	for( it = m_mapChildren.begin(); it != m_mapChildren.end(); it++ )
	{
		CUDDIWebServerNode *pWSNode = it->second;
		if( NULL == pWSNode )
		{
			hr = E_FAIL;
			return hr;
		}

		if( !( pWSNode->IsDeleted() ) )
		{
			ZeroMemory( &sdi, sizeof(SCOPEDATAITEM) );

			sdi.mask =	SDI_STR       |   // Displayname is valid
						SDI_PARAM     |   // lParam is valid
						SDI_IMAGE     |   // nImage is valid
						SDI_OPENIMAGE |   // nOpenImage is valid
						SDI_PARENT	  |
						SDI_CHILDREN;

			sdi.relativeID  = parent;
			sdi.nImage      = pWSNode->GetBitmapIndex();
			sdi.nOpenImage  = MMC_IMAGECALLBACK; //INDEX_OPENFOLDER;
			sdi.displayname = MMC_CALLBACK;
			sdi.lParam      = (LPARAM)pWSNode;       // The cookie
			sdi.cChildren   = 0;

			hr = pConsoleNameSpace->InsertItem( &sdi );
			_ASSERT( SUCCEEDED(hr) );
	                    
			pWSNode->SetScopeItemValue( sdi.ID );
			pWSNode->SetParentScopeItem( sdi.relativeID );
		}
    }

	hr = S_OK;
	return hr;
}

HRESULT 
CUDDISiteNode::GetConfig( CConfigMap& configMap, const tstring& connectionString )
{
	tstring tempConnectionString( connectionString );
	if( connectionString.find( _T("Provider=SQLOLEDB.1") ) == std::wstring::npos )
	{
		tempConnectionString.append( _T(";Provider=SQLOLEDB.1") );
	}

	net_config_get configGet;
	configGet.m_connectionString = tempConnectionString.c_str();

	DBROWCOUNT rowCount;
	HRESULT hr = configGet.Open();

	while( SUCCEEDED(hr) && hr != DB_S_NORESULT )
	{
		if( NULL != configGet.GetInterface() )
		{
			HRESULT hr2 = configGet.Bind();
			
			if( SUCCEEDED( hr2 ) )
			{
				while( S_OK == configGet.MoveNext() )
				{
					_ASSERT( !configGet.m_dwconfigNameStatus );
					_ASSERT( !configGet.m_dwconfigValueStatus );

					configMap[ configGet.m_configName ] = configGet.m_configValue;
				}
			}
		}

		hr = configGet.GetNextResult( &rowCount );	
	}

	return hr;
}

HRESULT 
CUDDISiteNode::SaveConfig( CConfigMap& configMap, const tstring& connectionString )
{
	tstring tempConnectionString( connectionString );
	if( connectionString.find( _T("Provider=SQLOLEDB.1") ) == std::wstring::npos )
	{
		tempConnectionString.append( _T(";Provider=SQLOLEDB.1") );
	}

	HRESULT hr = E_FAIL;
	
	for( CConfigMap::iterator iterator = configMap.begin(); iterator != configMap.end(); iterator++ )
	{
		net_config_save configSave;
		configSave.m_connectionString = tempConnectionString.c_str();

		OutputDebugString( (*iterator).first.c_str() );
		OutputDebugString( _T(" = ") );
		OutputDebugString( (*iterator).second.c_str() );
		OutputDebugString( _T("\n") );

		_tcsncpy( configSave.m_configName, (*iterator).first.c_str(), ARRAYLEN( configSave.m_configName ) - 1 );
		configSave.m_configName[ ARRAYLEN( configSave.m_configName ) - 1 ] = 0x00;

		_tcsncpy( configSave.m_configValue, (*iterator).second.c_str(), ARRAYLEN( configSave.m_configValue ) - 1 );
		configSave.m_configValue[ ARRAYLEN( configSave.m_configValue ) - 1 ] = 0x00;

		hr = configSave.Open();
		if( FAILED(hr) || 0 != configSave.m_RETURNVALUE )
		{			
			break;
		}
	}

	return hr;	
}

const _TCHAR *
CUDDISiteNode::GetNextWebServer( tstring& webServerList, int& position )
{	
	int     length			= webServerList.length();
	int		nextPosition	= position;
	const _TCHAR* webServer = NULL;
	
	//
	// No point if there no string.
	//
	if( 0 == length)
	{
		return NULL;
	}

	while( nextPosition < length && webServerList[nextPosition] != WEBSERVER_LIST_DELIM )
	{
		nextPosition++;
	}
	
	if( nextPosition < length )
	{
		webServerList[ nextPosition ] = NULL_TERMINATOR;
		webServer = webServerList.c_str() + position;
	}
	else
	{
		webServer = ( 0 == position ) ? webServerList.c_str() : NULL;
	}
	position = nextPosition;

	return webServer;
}

void 
CUDDISiteNode::AddWebServer( tstring& webServerList, const tstring& webServer )
{
	if( webServerList.length() > 0 )
	{		
		webServerList += WEBSERVER_LIST_DELIM;
	}
	webServerList.append( webServer );
}

BOOL			
CUDDISiteNode::AddChildEntry( CUDDIWebServerNode *pNode, UINT position )
{		
	CUDDIWebServerNodeMapEntry entry( position, pNode );
	m_mapChildren.insert( entry );

	return TRUE;
}

void
CUDDISiteNode::AddChild( const wstring& strName, IConsole *pConsole )
{
	if( FindChild( strName.c_str() ) || ( NULL == pConsole ) )
	{
		return;
	}

	IConsoleNameSpace *pConsoleNameSpace = NULL;
	pConsole->QueryInterface( IID_IConsoleNameSpace, reinterpret_cast<void **>( &pConsoleNameSpace ) );
	if( NULL == pConsoleNameSpace )
	{
		return;
	}

	HRESULT hr;

	CUDDIWebServerNode *pNewWS = new CUDDIWebServerNode( strName.c_str(), m_nNextChildID, this, m_bIsExtension );
	m_nNextChildID++;

	AddChildEntry( pNewWS );

	SCOPEDATAITEM sdi;
	ZeroMemory( &sdi, sizeof( SCOPEDATAITEM ) );

	sdi.mask =	SDI_STR       |   // Displayname is valid
				SDI_PARAM     |   // lParam is valid
				SDI_IMAGE     |   // nImage is valid
				SDI_OPENIMAGE |   // nOpenImage is valid
				SDI_PARENT	  |
				SDI_CHILDREN;

	sdi.relativeID  = GetScopeItemValue();
	sdi.nImage      = pNewWS->GetBitmapIndex();
	sdi.nOpenImage  = MMC_IMAGECALLBACK;
	sdi.displayname = MMC_CALLBACK;
	sdi.lParam      = (LPARAM)pNewWS;
	sdi.cChildren   = pNewWS->HasChildren();

	hr = pConsoleNameSpace->InsertItem( &sdi );
	_ASSERT( SUCCEEDED(hr) );
				
	pNewWS->SetScopeItemValue( sdi.ID );
	pNewWS->SetParentScopeItem( sdi.relativeID );

	//
	// We created a new object in result pane. We need to insert this object
	// in all the views, call UpdateAllViews for this.
	// Pass pointer to data object passed into OnMenuCommand.
	//
	//hr = pConsole->UpdateAllViews( pDataObject, m_hParentHScopeItem, UPDATE_SCOPEITEM );
	//_ASSERT( S_OK == hr);

	//
	// Prompt the user with a warning to tell them that they might have to alter their
	// machine.config settings if this web server is part of a web farm.
	//
	WCHAR wszMessage[ 512 ];
	WCHAR wszTitle[ 512 ];
	memset( wszMessage, 0, 512 * sizeof( _TCHAR ) );					
	memset( wszTitle, 0, 128 * sizeof( _TCHAR ) );

	LoadString( g_hinst, IDS_WEBSERVER_WEBFARM_DETAIL, wszMessage, ARRAYLEN( wszMessage ) );
	LoadString( g_hinst, IDS_WEBSERVER_WEBFARM, wszTitle, ARRAYLEN( wszTitle ) );
	
	HWND hwndConsole = NULL;
	pConsole->GetMainWindow( &hwndConsole );

	MessageBox( hwndConsole, wszMessage, wszTitle, MB_OK );

	pConsoleNameSpace->Release();
}

BOOL
CUDDISiteNode::AddWebServerToSite( const wstring& strSite,
								   const wstring& strWebServer,
								   HWND hwndParent )
{
	try
	{
		//
		// Make sure our params at least have some sort of content!
		//
		if( ( 0 == strSite.length() ) || ( 0 == strWebServer.length() ) )
		{
			return FALSE;
		}

		//
		// If strSite does not contain the name of a machine/cluster
		// resource which hosts a UDDI Site, barf @ the user & exit
		// immediately.
		//
		if( !CUDDISiteNode::IsDatabaseServer( (PTCHAR)strSite.c_str() ) )
		{
			UDDIMsgBox( hwndParent,
						IDS_DATABASE_SERVER_SELECT_ERROR,
						IDS_DATABASE_SERVER_SELECT_ERROR_TITLE,
						MB_ICONEXCLAMATION | MB_OK );
			return FALSE;
		}

		//
		// If strWebServer does not contain the name of a machine
		// which hosts a UDDI Web Server, barf @ the user & exit
		// immediately.
		//
		if( !CUDDIWebServerNode::IsWebServer( strWebServer.c_str() ) )
		{
			UDDIMsgBox( hwndParent,
						IDS_WEBSERVER_SELECT_ERROR,
						IDS_WEBSERVER_SELECT_ERROR_TITLE,
						MB_ICONEXCLAMATION | MB_OK );
			return FALSE;
		}

		if( strSite != strWebServer )
		{
			//
			// In this particular case the user is attempting to add to the UDDI Site a
			// UDDI Web Server which is running on a Windows Server 2003 Standard machine.  This cannot
			// happen.
			//
			BOOL bWSRunsOnStdSvr = TRUE;
			HRESULT hr = E_FAIL;
			hr = ::IsStandardServer( strWebServer.c_str(), &bWSRunsOnStdSvr );
			if( FAILED(hr) )
			{
				UDDIMsgBox( hwndParent,
							IDS_DOT_NET_SERVER,
							IDS_ERROR_TITLE,
							MB_ICONEXCLAMATION | MB_OK );
				return FALSE;
			}

			if( TRUE == bWSRunsOnStdSvr )
			{
				UDDIMsgBox( hwndParent,
							IDS_WEBSERVER_NOT_ASSIGNABLE_DETAIL,
							IDS_WEBSERVER_NOT_ASSIGNABLE,
							MB_ICONEXCLAMATION | MB_OK );
				return FALSE;
			}

			//
			// In this particular case the user is attempting to add a UDDI Web Server
			// to a UDDI Site which is running on a Windows Server 2003 Standard machine.  This cannot
			// happen.
			//
			BOOL bDBRunsOnStdSvr = TRUE;
			hr = ::IsStandardServer( strSite.c_str(), &bDBRunsOnStdSvr );
			if( FAILED(hr) )
			{
				UDDIMsgBox( hwndParent,
							IDS_DOT_NET_SERVER,
							IDS_ERROR_TITLE,
							MB_ICONEXCLAMATION | MB_OK );
				return FALSE;
			}

			if( TRUE == bDBRunsOnStdSvr )
			{
				UDDIMsgBox( hwndParent,
							IDS_DATABASE_STANDARD_SERVER_DETAIL,
							IDS_DATABASE_STANDARD_SERVER,
							MB_ICONEXCLAMATION | MB_OK );

				return FALSE;
			}
		}

		//
		// Do a check here to make sure the db schema on the new site
		// is legit.
		//

		wstring strWSCurrentSite = _T( "" );
		BOOL fWSCurrentSiteIsValid = FALSE;
		BOOL fSameSite = FALSE;
		BOOL fOKToMoveWebServer = FALSE;

		//
		// 1.  Determine if the web server is:  currently assigned to a site, if that
		//     site is valid, and if that site is the same as the new site.
		//
		if( CUDDIWebServerNode::IsAssignedToSite( strWebServer, CM_Writer, strWSCurrentSite ) )
		{
			//
			// The web server thinks that it is currently assigned to a site.  However we
			// must take into consideration the following 2 cases:
			//
			// 1.  The web server's connection string contains garbage.
			// 2.  The web server's connection string is valid, but the site that it
			//     refers to does not exist anymore.
			//
			if( ( 0 == strWSCurrentSite.length() ) ||
				!CUDDISiteNode::IsDatabaseServer( (PTCHAR)strWSCurrentSite.c_str() ) )
			{
				fWSCurrentSiteIsValid = FALSE;
			}
			else
			{
				fWSCurrentSiteIsValid = TRUE;
			}

			//
			// The user is trying to add the web server back to the same site that the
			// web server thinks it belongs to.  This can happen when the user un-installs
			// and then re-installs the database.
			//
			fSameSite = ( 0 == _wcsicmp( strWSCurrentSite.c_str(), strSite.c_str() ) ) ? TRUE : FALSE;

			//
			// If the old site is valid, and if the site that the user wants isn't the
			// old site, ask them if they are really sure.
			//
			if( fWSCurrentSiteIsValid && !fSameSite )
			{
				//
				// First prompt the user to see if they really want to remove the web server from its current site.
				//				
				WCHAR wszMessage[ 512 ];
				WCHAR wszMessageFormat[ 512 ];
				WCHAR wszTitle[ 128 ];

				wszMessage[ 0 ] = 0x00;
				wszTitle[ 0 ] = 0x00;
				wszMessageFormat[ 0 ] = 0x00;

				LoadString( g_hinst, IDS_WEBSERVER_ASSIGNED_DETAIL, wszMessageFormat, ARRAYLEN( wszMessageFormat ) );
				_sntprintf( wszMessage,
							ARRAYLEN(wszMessage) - 1,
							wszMessageFormat,
							strWebServer.c_str(),
							strWSCurrentSite.c_str(),
							strWebServer.c_str(),
							strSite.c_str() );

				LoadString( g_hinst, IDS_WEBSERVER_ASSIGNED, wszTitle, ARRAYLEN( wszTitle ) );

				int iYesNo = MessageBox( hwndParent, wszMessage, wszTitle, MB_YESNO );
				if( IDNO == iYesNo )
				{
					return FALSE;
				}
				else
				{
					fOKToMoveWebServer = TRUE;
				}
			}
			//
			// If we're in here, either the old site is bogus, or it's the same site.
			// In either case, it's ok to move the web server.
			//
			else
			{
				fOKToMoveWebServer = TRUE;
			}
		}
		else
		{
			fOKToMoveWebServer = TRUE;
		}
	
		//
		// 2.  Get the list of Web Servers that the old Site contains.
		//
		if( ( FALSE == fSameSite ) && fWSCurrentSiteIsValid )
		{
			HRESULT hr = E_FAIL;
			CConfigMap configOldSite;
			wstring strOldConnStr;

			BOOL b = CUDDIWebServerNode::GetWriterConnectionString( strWebServer, strOldConnStr );

			CUDDIWebServerNode::SetWriterConnectionString( strWebServer, L"" );
			CUDDIWebServerNode::SetReaderConnectionString( strWebServer, L"" );

			hr = GetConfig( configOldSite, strOldConnStr );
			if( FAILED(hr) )
			{
				UDDIMsgBox( hwndParent,
							IDS_DATABASE_SERVER_OLEDB_READ_FAILED,
							IDS_DATABASE_SERVER_GETDATA_ERROR_TITLE,
							MB_OK );
				return FALSE;
			}

			CStringCollection oldSiteWebServers( configOldSite[ UDDI_SITE_WEBSERVERS ] );
			oldSiteWebServers.DeleteString( strWebServer );
			configOldSite[ UDDI_SITE_WEBSERVERS ] = oldSiteWebServers.GetDelimitedString();

			hr = SaveConfig( configOldSite, strOldConnStr );
			if( FAILED(hr) )
			{
				WCHAR wszMessageFormat[ 512 ];
				WCHAR wszTitle[ 128 ];

				memset( wszMessageFormat, 0, 512 * sizeof( WCHAR ) );
				memset( wszTitle, 0, 128 * sizeof( WCHAR ) );

				LoadString( g_hinst,
							IDS_WEBSERVER_REMOVE_FAILED_DETAIL,
							wszMessageFormat,
							ARRAYLEN( wszMessageFormat ) );

				TCHAR pwszFormatted[ 512 ];
				pwszFormatted[ 0 ] = 0x00;

				LPCTSTR pwszArgs[ 3 ] = { strWebServer.c_str(), strWSCurrentSite.c_str(), strSite.c_str() };
				DWORD dwBytesWritten = FormatMessage( FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
														(LPCVOID)wszMessageFormat,
														0,
														0,
														pwszFormatted,
														512,
														(va_list *)pwszArgs
														);

				LoadString( g_hinst,
							IDS_WEBSERVER_REMOVE_FAILED,
							wszTitle,
							ARRAYLEN( wszTitle ) );

				int iYesNo = MessageBox( hwndParent,
										 pwszFormatted,
										 wszTitle,
										 MB_ICONEXCLAMATION | MB_YESNO );

				//
				// User does not want to continue.
				//
				if( IDNO == iYesNo )
				{
					CUDDIWebServerNode::SetReaderConnectionString( strWebServer, strOldConnStr );
					CUDDIWebServerNode::SetWriterConnectionString( strWebServer, strOldConnStr );

					return FALSE;
				}
			}
		}


		//
		// 3.  Get the list of Web Servers that the new Site contains.
		//
		if( fOKToMoveWebServer )
		{
			HRESULT hr = E_FAIL;
			CConfigMap configNewSite;
			wstring strNewConnStr;

			strNewConnStr = CUDDIWebServerNode::BuildConnectionString( strSite );
			hr = GetConfig( configNewSite, strNewConnStr );
			if( FAILED(hr) )
			{
				UDDIMsgBox( hwndParent,
							IDS_DATABASE_SERVER_OLEDB_READ_FAILED,
							IDS_DATABASE_SERVER_GETDATA_ERROR_TITLE,
							MB_OK );
				return FALSE;
			}

			wstring strWSSchemaVersion;
			if( !CUDDIWebServerNode::GetDBSchemaVersion( strWebServer, strWSSchemaVersion ) )
			{
				WCHAR wszTitle[ 256 ];
				WCHAR wszMessageFormat[ 512 ];
				WCHAR wszMessage[ 512 ];

				memset( wszMessage, 0, 512 * sizeof( WCHAR ) );
				memset( wszMessageFormat, 0, 512 * sizeof( WCHAR ) );

				LoadString( g_hinst, IDS_ERROR_TITLE, wszTitle, ARRAYLEN( wszTitle ) );		
				LoadString( g_hinst, IDS_WEBSERVER_SERVER_DBSCHEMA_VERSION_READ_FAILED, wszMessageFormat, ARRAYLEN( wszMessageFormat ) );
				_sntprintf( wszMessage, ARRAYLEN( wszMessage ) - 1, wszMessageFormat, strWebServer.c_str() );
								
				MessageBox( hwndParent, wszMessage, wszTitle, MB_ICONERROR );

				return FALSE;
			}

			CDBSchemaVersion schemaVersionWS;
			if( !schemaVersionWS.Parse( strWSSchemaVersion ) )
			{
				_TCHAR szTitle[ 256 ];
				_TCHAR szMessageFormat[ 512 ];
				_TCHAR szMessage[ 512 ];

				memset( szMessage, 0, 512 * sizeof( _TCHAR ) );
				memset( szMessageFormat, 0, 512 * sizeof( _TCHAR ) );

				LoadString( g_hinst, IDS_ERROR_TITLE, szTitle, ARRAYLEN( szTitle ) );		
				LoadString( g_hinst, IDS_INVALID_VERSION_FORMAT, szMessageFormat, ARRAYLEN( szMessageFormat ) );
				_sntprintf( szMessage, ARRAYLEN( szMessage ) - 1, szMessageFormat, strWebServer );
								
				MessageBox( hwndParent, szMessage, szTitle, MB_ICONERROR );

				return FALSE;
			}

			CDBSchemaVersion schemaVersionNewSite;
			if( !schemaVersionNewSite.Parse( configNewSite[ UDDI_DBSCHEMA_VERSION ] ) )
			{
				_TCHAR szTitle[ 256 ];
				_TCHAR szMessageFormat[ 512 ];
				_TCHAR szMessage[ 512 ];

				memset( szMessage, 0, 512 * sizeof( _TCHAR ) );
				memset( szMessageFormat, 0, 512 * sizeof( _TCHAR ) );

				LoadString( g_hinst, IDS_ERROR_TITLE, szTitle, ARRAYLEN( szTitle ) );		
				LoadString( g_hinst, IDS_DATABASE_SERVER_DBSCHEMA_VERSION_READ_FAILED, szMessageFormat, ARRAYLEN( szMessageFormat ) );
				_sntprintf( szMessage, ARRAYLEN( szMessage ) - 1, szMessageFormat, strSite );
								
				MessageBox( hwndParent, szMessage, szTitle, MB_ICONERROR );

				return FALSE;
			}

			//
			// Make sure the web server version is compatible.
			//
			if( FALSE == schemaVersionNewSite.IsCompatible( schemaVersionWS ) )
			{
				_TCHAR szTitle[ 256 ];
				_TCHAR szMessage[ 1024 ];
				_TCHAR szMessageFormat[ 512 ];

				memset( szTitle, 0, 256 * sizeof( _TCHAR ) );
				memset( szMessage, 0, 1024 * sizeof( _TCHAR ) );
				memset( szMessageFormat, 0, 512 * sizeof( _TCHAR ) );

				LoadString( g_hinst, IDS_ERROR_TITLE, szTitle, ARRAYLEN( szTitle ) );
				LoadString( g_hinst, IDS_WEBSERVER_SERVER_INVALID_DBSCHEMA_VERSION, szMessageFormat, ARRAYLEN( szMessageFormat ) );
				_sntprintf( szMessage,
							ARRAYLEN( szMessage ) - 1,
							szMessageFormat,
							strWebServer.c_str(),
							schemaVersionWS.szVersion.c_str(),
							strSite.c_str(),
							schemaVersionNewSite.szVersion.c_str() );
				
				MessageBox( hwndParent, szMessage, szTitle, MB_ICONERROR );
				
				return FALSE;
			}

			CStringCollection newSiteWebServers( configNewSite[ UDDI_SITE_WEBSERVERS ] );

			if( newSiteWebServers.Exists( strWebServer ) && fSameSite )
			{
				WCHAR wszMessage[ 256 ];
				WCHAR wszTitle[ 256 ];
				wszMessage[ 0 ] = 0x00;
				wszTitle[ 0 ] = 0x00;

				LoadString( g_hinst, IDS_WEBSERVER_ALREADY_EXISTS, wszMessage, ARRAYLEN( wszMessage ) );
				LoadString( g_hinst, IDS_WEBSERVER_SELECT_ERROR_TITLE, wszTitle, ARRAYLEN( wszTitle ) );

				MessageBox( hwndParent, wszMessage, wszTitle, MB_OK );
				return FALSE;
			}

			newSiteWebServers.AddString( strWebServer );
			configNewSite[ UDDI_SITE_WEBSERVERS ] = newSiteWebServers.GetDelimitedString();

			hr = SaveConfig( configNewSite, strNewConnStr );
			if( FAILED(hr) )
			{
				WCHAR wszMessage[ 512 ];
				WCHAR wszMessageFormat[ 512 ];
				WCHAR wszTitle[ 128 ];

				memset( wszMessage, 0, 512 * sizeof( WCHAR ) );
				memset( wszMessageFormat, 0, 512 * sizeof( WCHAR ) );
				memset( wszTitle, 0, 128 * sizeof( WCHAR ) );

				LoadString( g_hinst,
							IDS_WEBSERVER_ADD_FAILED_DETAIL,
							wszMessageFormat,
							ARRAYLEN( wszMessageFormat ) );

				_sntprintf( wszMessage,
							ARRAYLEN(wszMessage) - 1,
							wszMessageFormat,
							strWebServer.c_str(), 
							strSite.c_str() );

				LoadString( g_hinst,
							IDS_WEBSERVER_ADD_FAILED,
							wszTitle,
							ARRAYLEN( wszTitle ) );

				MessageBox( hwndParent,
							 wszMessage,
							 wszTitle,
							 MB_ICONEXCLAMATION | MB_YESNO );

				CUDDIWebServerNode::SetReaderConnectionString( strWebServer, L"" );
				CUDDIWebServerNode::SetWriterConnectionString( strWebServer, L"" );

				return FALSE;
			}

			CUDDIWebServerNode::SetReaderConnectionString( strWebServer, strNewConnStr );
			CUDDIWebServerNode::SetWriterConnectionString( strWebServer, strNewConnStr );
		}

		return TRUE;
	}
	catch( CUDDIException &e )
	{
		UDDIMsgBox( hwndParent, (LPCTSTR) e, IDS_ERROR_TITLE, MB_ICONEXCLAMATION | MB_OK );
		return FALSE;
	}
	catch( ... )
	{
		UDDIMsgBox( hwndParent, IDS_ERROR_ADDWEBSITE, IDS_ERROR_TITLE, MB_ICONEXCLAMATION | MB_OK );
		return FALSE;
	}

}



CStringCollection::CStringCollection( const wstring& strDelimitedStrings,
									  const wstring& strDelim )
{
	_coll.clear();

	if( 0 == strDelimitedStrings.length() )
	{
		return;
	}

	_strDelim = strDelim;

	WCHAR *pwsz = new WCHAR[ strDelimitedStrings.length() + 1 ];
	if( NULL == pwsz )
	{
		return;
	}

	wcsncpy( pwsz, strDelimitedStrings.c_str(), strDelimitedStrings.length() );
	pwsz[ strDelimitedStrings.length() ] = 0x00;

	//
	// Convert to upper case.
	//
	pwsz = _wcsupr( pwsz );

	WCHAR *pwszToken = wcstok( pwsz, _strDelim.c_str() );
	while( NULL != pwszToken )
	{
		_coll.push_back( pwszToken );
		pwszToken = wcstok( NULL, _strDelim.c_str() );
	}

	delete [] pwsz;
}

CStringCollection::~CStringCollection()
{
	_coll.clear();
}

void
CStringCollection::DeleteString( const wstring& str )
{
	if( 0 == str.length() )
	{
		return;
	}

	vector< wstring >::iterator it = _coll.begin();
	for( ; it != _coll.end(); it++ )
	{
		if( 0 == _wcsicmp( str.c_str(), it->c_str() ) )
		{
			_coll.erase( it );
			break;
		}
	}
}

void
CStringCollection::AddString( const wstring& str )
{
	if( 0 == str.length() )
	{
		return;
	}

	WCHAR *pwsz = new WCHAR[ str.length() + 1 ];
	if( NULL == pwsz )
	{
		return;
	}

	wcsncpy( pwsz, str.c_str(), str.length() );
	pwsz[ str.length() ] = 0x00;

	pwsz = _wcsupr( pwsz );

	vector< wstring >::const_iterator cit;

	cit = find( _coll.begin(), _coll.end(), str );
	if( _coll.end() == cit )
	{
		_coll.push_back( str );
	}

	delete [] pwsz;
}

wstring
CStringCollection::GetDelimitedString() const
{
	wstring str;
	vector< wstring >::const_iterator cit;

	bool first = true;
	for( cit = _coll.begin(); cit != _coll.end(); cit++ )
	{
		first = ( _coll.begin() == cit ) ? true : false;

		if( !first )
		{
			str += _strDelim;
		}

		str += *cit;
	}

	return str;
}


BOOL
CStringCollection::Exists( const wstring& str ) const
{
	BOOL fRet = FALSE;
	if( 0 == str.length() )
	{
		return fRet;
	}

	vector< wstring >::const_iterator cit = _coll.begin();
	for( ; cit != _coll.end(); cit++ )
	{
		if( 0 == _wcsicmp( str.c_str(), cit->c_str() ) )
		{
			fRet = TRUE;
			break;
		}
	}

	return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\mmc\webservernode.cpp ===
#include <stdio.h>
#include <windows.h>
#include "webservernode.h"
#include "comp.h"
#include "compdata.h"
#include "dataobj.h"
#include "globals.h"
#include "resource.h"
#include "uddi.h"
#include "uddisitenode.h"
#include "objectpicker.h"
#include <htmlhelp.h>
#include <windowsx.h>
#include <commctrl.h>

// {8ACBC688-ADDB-4298-9475-76AC4BF01FB1}
const GUID CUDDIWebServerNode::thisGuid = { 0x8acbc688, 0xaddb, 0x4298, { 0x94, 0x75, 0x76, 0xac, 0x4b, 0xf0, 0x1f, 0xb1 } };


//==============================================================
//
// CUDDIWebServerNode implementation
//
//
CUDDIWebServerNode::CUDDIWebServerNode( const _TCHAR *szName, int id, CUDDISiteNode* parent, BOOL bExtension )
	: m_szName(NULL)
	, m_nId( id )
	, m_ppHandle( 0 )
	, m_isDeleted( FALSE )
	, m_pParent( parent )
	, m_pToolbar( NULL )
    , m_isScopeItem( TRUE )
	, m_bStdSvr( TRUE )
	, m_fDeleteFromScopePane( FALSE )
	, m_hwndPropSheet( NULL )
{
	int iLen = _tcslen( szName ) + 1;
	m_szName = new _TCHAR[ iLen ];
	memset( m_szName, 0, iLen * sizeof( _TCHAR ) );
	_tcsncpy( m_szName, szName, iLen - 1 );

	m_bIsExtension = bExtension;

    GetData();

    BOOL bW3SvcRunning = IsW3SvcRunning();
    if( ( FALSE == bW3SvcRunning ) && IsRunning() )
    {
        Stop();
        m_mapProperties[ UDDI_RUN ] = _T("0");
    }
}

CUDDIWebServerNode::~CUDDIWebServerNode()
{
    if( m_szName )
	{
		delete [] m_szName;
	}

	if( NULL != m_ppHandle )
	{
		MMCFreeNotifyHandle( m_ppHandle );
	}

	if( NULL != m_hwndPropSheet )
	{
		SendMessage( m_hwndPropSheet, WM_CLOSE, 0, 0 );
	}
}

HRESULT CUDDIWebServerNode::GetData()
{
	try
	{
		//
		// Determine if the OS that this web server is running on is Windows Server 2003 Standard or not.
		//
		HRESULT hr = E_FAIL;
		hr = IsStandardServer( m_szName, &m_bStdSvr );
		if( FAILED(hr) )
		{
			THROW_UDDIEXCEPTION_ST( hr, IDS_DOT_NET_SERVER, g_hinst );
		}

		m_mapProperties.clear();

		CUDDIRegistryKey rootkey( _T( "SOFTWARE\\Microsoft\\UDDI"), KEY_READ, m_szName );

		_TCHAR szRun[ 35 ];
		m_mapProperties[ UDDI_RUN ] = _itot( rootkey.GetDWORD( _T("Run"), 1 ), szRun, 10 );
		m_mapProperties[ UDDI_SETUP_LOCATION ] = rootkey.GetString( _T("InstallRoot"), _T("") );
		rootkey.Close();

		CUDDIRegistryKey databasekey( _T( "SOFTWARE\\Microsoft\\UDDI\\Database"), KEY_READ, m_szName );
		m_mapProperties[ UDDI_READER_CXN ] = databasekey.GetString( _T("ReaderConnectionString"), _T("") );
		m_mapProperties[ UDDI_WRITER_CXN ] = databasekey.GetString( _T("WriterConnectionString"), _T("") );
		databasekey.Close();

		//
		// Ensure that the UDDI Site that this web server thinks it communicates
		// with is still installed.
		//
		tstring strDomain, strServer, strInstance;
		CrackConnectionString( m_mapProperties[ UDDI_WRITER_CXN ], strDomain, strServer, strInstance );
		if( !CUDDISiteNode::IsDatabaseServer( (PTCHAR)strServer.c_str() ) )
		{
			m_mapProperties[ UDDI_READER_CXN ] = _T( "" );
			m_mapProperties[ UDDI_WRITER_CXN ] = _T( "" );
		}

		_TCHAR szValue[ 100 ];

		_TCHAR szDefaultLogFile[ _MAX_PATH + 1 ];
		memset( szDefaultLogFile, 0, ( _MAX_PATH + 1 ) * sizeof( _TCHAR ) );
		GetSystemDirectory( szDefaultLogFile, _MAX_PATH );

		tstring strDefaultLogFile( szDefaultLogFile );
		strDefaultLogFile += _T( "\\LogFiles\\UDDI\\uddi.log" );

		try
		{
			CUDDIRegistryKey debugkey( _T( "SOFTWARE\\Microsoft\\UDDI\\Debug"), KEY_READ, m_szName );
			m_mapProperties[ UDDI_EVENTLOG_LEVEL ] = _itot( debugkey.GetDWORD( _T("EventLogLevel"), 2 ), szValue, 10 );
			m_mapProperties[ UDDI_FILELOG_LEVEL ] = _itot( debugkey.GetDWORD( _T("FileLogLevel"), 0 ), szValue, 10 );
			m_mapProperties[ UDDI_LOG_FILENAME ] = debugkey.GetString( _T("LogFilename"), strDefaultLogFile.c_str() );
			debugkey.Close();
		}
		catch( ... )
		{
			m_mapProperties[ UDDI_EVENTLOG_LEVEL ] = _itot( 2, szValue, 10 );
			m_mapProperties[ UDDI_FILELOG_LEVEL ] = _itot( 0, szValue, 10 );
			m_mapProperties[ UDDI_LOG_FILENAME ] = strDefaultLogFile;
		}


		//
		// Get the setup information
		//
		CUDDIRegistryKey setupkey( _T( "SOFTWARE\\Microsoft\\UDDI\\Setup"), KEY_READ, m_szName );
		m_mapProperties[ UDDI_SETUP_DB ] = _itot( setupkey.GetDWORD( _T("DBServer"), 0 ), szValue, 10 );
		m_mapProperties[ UDDI_SETUP_WEB ] = _itot( setupkey.GetDWORD( _T("WebServer"), 0 ), szValue, 10 );
		m_mapProperties[ UDDI_SETUP_ADMIN ] = _itot( setupkey.GetDWORD( _T("Admin"), 0 ), szValue, 10 );
		setupkey.Close();

		CUDDIRegistryKey webkey( _T( "SOFTWARE\\Microsoft\\UDDI\\Setup\\WebServer"), KEY_READ, m_szName );
		m_mapProperties[ UDDI_SETUP_DATE ] = webkey.GetString( _T("InstallDate"), _T("") );
		m_mapProperties[ UDDI_SETUP_LANGUAGE ] = webkey.GetString( _T("ProductLanguage"), _T("") );
		m_mapProperties[ UDDI_SETUP_NAME ] = webkey.GetString( _T("ProductName"), _T("") );
		m_mapProperties[ UDDI_SETUP_FRAMEWORK_VERSION ] = webkey.GetString( _T("FrameworkVersion"), _T("") );
		m_mapProperties[ UDDI_SETUP_MANUFACTURER ] = webkey.GetString( _T("Manufacturer"), _T("") );
		m_mapProperties[ UDDI_SETUP_VERSION ] = webkey.GetString( _T("ProductVersion"), _T("") );
		webkey.Close();
	}
	catch(...)
	{
		return E_FAIL;
	}

	return S_OK;
}

const LPCTSTR CUDDIWebServerNode::GetName()
{
	return m_szName;
}

BOOL
CUDDIWebServerNode::ChildExists( const WCHAR *pwszName )
{
	if( NULL == pwszName )
	{
		return FALSE;
	}

	wstring strWriterConn;
	GetWriterConnectionString( m_szName, strWriterConn );

	wstring strDomain, strServer, strInstance;
	CrackConnectionString( strWriterConn, strDomain, strServer, strInstance );

	return ( 0 == _wcsicmp( pwszName, strServer.c_str() ) ) ? TRUE : FALSE;
}

HRESULT CUDDIWebServerNode::SaveData()
{
	try
	{
		//
		// Save the changed values
		//
		for( CPropertyMap::iterator iter = m_mapChanges.begin();
			iter != m_mapChanges.end(); iter++ )
		{
			if( _T("Database.ReaderConnectionString") == (*iter).first )
			{
				CUDDIRegistryKey databasekey( _T( "SOFTWARE\\Microsoft\\UDDI\\Database"), KEY_ALL_ACCESS, m_szName );
				databasekey.SetValue( _T( "ReaderConnectionString" ), m_mapChanges[ _T( "Database.ReaderConnectionString" ) ].c_str() );
				databasekey.Close();
			}
			else if( UDDI_WRITER_CXN == (*iter).first )
			{
				CUDDIRegistryKey databasekey( _T( "SOFTWARE\\Microsoft\\UDDI\\Database"), KEY_ALL_ACCESS, m_szName );
				databasekey.SetValue( _T( "WriterConnectionString" ), m_mapChanges[ _T( "Database.WriterConnectionString" ) ].c_str() );
				databasekey.Close();
			}
			else if(UDDI_EVENTLOG_LEVEL == (*iter).first )
			{
				DWORD dwValue = _ttoi( m_mapChanges[ UDDI_EVENTLOG_LEVEL ].c_str() );
				UDDIASSERT( dwValue < 7 );
				
				CUDDIRegistryKey debugkey( _T( "SOFTWARE\\Microsoft\\UDDI\\Debug"), KEY_ALL_ACCESS, m_szName );
				debugkey.SetValue( _T("EventLogLevel"), dwValue );
				debugkey.Close();
			}
			else if( (*iter).first == UDDI_FILELOG_LEVEL )
			{
				DWORD dwValue = _ttoi( m_mapChanges[ UDDI_FILELOG_LEVEL ].c_str() );				
				UDDIASSERT( dwValue < 7 );
				
				CUDDIRegistryKey debugkey( _T( "SOFTWARE\\Microsoft\\UDDI\\Debug"), KEY_ALL_ACCESS, m_szName );
				debugkey.SetValue( _T("FileLogLevel"), dwValue );
				debugkey.Close();
			}
		}

		//
		// Clear the changes collection
		//
		m_mapChanges.clear();

	}
	catch(...)
	{
		return E_FAIL;
	}

	return S_OK;
}

BOOL CUDDIWebServerNode::IsWebServer( const WCHAR *pwszName )
{
	if( ( NULL == pwszName ) || ( 0 == _tcslen( pwszName ) ) )
	{
		return FALSE;
	}

	try
	{
		CUDDIRegistryKey key( _T( "SOFTWARE\\Microsoft\\UDDI\\Setup" ), KEY_READ, pwszName );
		DWORD dwDB = key.GetDWORD( _T( "WebServer" ) );

		return TRUE;
	}
	catch(...)
	{
		return FALSE;
	}
}

BOOL CUDDIWebServerNode::Start()
{
	return SetRunState( TRUE );
}

BOOL CUDDIWebServerNode::SetRunState( BOOL bStart )
{
	try
	{
		CUDDIRegistryKey key( _T( "SOFTWARE\\Microsoft\\UDDI" ), KEY_ALL_ACCESS, m_szName );
		key.SetValue( _T("Run"), bStart ? 1UL : 0UL );
	}
	catch(...)
	{
		return FALSE;
	}

	return TRUE;
}

BOOL CUDDIWebServerNode::Stop()
{
	return SetRunState( FALSE );
}

const BOOL CUDDIWebServerNode::IsRunning()
{
	CPropertyMap::const_iterator it = m_mapProperties.find( UDDI_RUN );
	if( m_mapProperties.end() == it )
	{
		return FALSE;
	}
	else
	{
		return ( _T("0") == it->second ) ? FALSE : TRUE;
	}
}

const _TCHAR *CUDDIWebServerNode::GetDisplayName( int nCol )
{
	_TCHAR szRunning[ 256 ];
	memset( szRunning, 0, 256 * sizeof( _TCHAR ) );
	::LoadString( g_hinst, IDS_WEBSERVER_RUNNING, szRunning, ARRAYLEN(szRunning) );

	_TCHAR szStopped[ 256 ];
	memset( szStopped, 0, 256 * sizeof( _TCHAR ) );
	::LoadString( g_hinst, IDS_WEBSERVER_STOPPED, szStopped, ARRAYLEN(szStopped) );

	BOOL bIsRunning = IsRunning();

    switch( nCol )
	{
    case 0:
	{
		m_strDisplayName = m_szName;
		if( !bIsRunning )
		{
			m_strDisplayName += _T(" (");
			m_strDisplayName += szStopped;
			m_strDisplayName += _T(")");
		}
        break;
	}
    case 1:
	{
		m_strDisplayName = bIsRunning ? szRunning : szStopped;
        break;
	}
	default:
		m_strDisplayName = _T("");
    }

	return m_strDisplayName.c_str();
}

//
// Handle anything special when the user clicks Apply or Ok
// on the property sheet.  This sample directly accesses the
// operated-on object, so there's nothing special to do...
// ...except to update all views
//
HRESULT CUDDIWebServerNode::OnPropertyChange( IConsole *pConsole, CComponent *pComponent )
{
    HRESULT hr = S_FALSE;

	CPropertyMap::iterator it = m_mapChanges.find( UDDI_WRITER_CXN );
	BOOL fWriterChanged = ( m_mapChanges.end() == it ) ? FALSE : TRUE;

	if( TRUE == fWriterChanged )
	{
		wstring strDomain, strServer, strInstance;
		CUDDIWebServerNode::CrackConnectionString( m_mapChanges[ UDDI_WRITER_CXN ], strDomain, strServer, strInstance );

		HWND hwndConsole = NULL;
		pConsole->GetMainWindow( &hwndConsole );

		BOOL fSuccess = CUDDISiteNode::AddWebServerToSite( strServer,
														   m_szName,
														   ( NULL == m_hwndPropSheet ) ? hwndConsole : m_hwndPropSheet );
		if( fSuccess )
		{
			m_fDeleteFromScopePane = TRUE;

			//
			// If our parent pointer is not NULL, then this web server node is the child of
			// a UDDI Site node.
			//
			// If our parent pointer is NULL, then this web server node is a child of the
			// UDDI Services node.
			//
			if( NULL != m_pParent )
			{
				CUDDIServicesNode *pStaticNode = m_pParent->GetStaticNode();
				if( NULL != pStaticNode )
				{
					CUDDISiteNode *pSiteNode = reinterpret_cast<CUDDISiteNode *>( pStaticNode->FindChild( strServer.c_str() ) );
					if( NULL != pSiteNode )
					{
						pSiteNode->AddChild( m_szName, pConsole );
					}
				}
			}
			else
			{
				HSCOPEITEM hsiParent = GetParentScopeItem();
				IConsoleNameSpace *pNS = NULL;
				hr = pConsole->QueryInterface( IID_IConsoleNameSpace, reinterpret_cast<void **>( &pNS ) );
				if( FAILED(hr) )
				{
					return hr;
				}

				SCOPEDATAITEM sdi;
				memset( &sdi, 0, sizeof( SCOPEDATAITEM ) );

				sdi.ID = hsiParent;
				sdi.mask = SDI_PARAM;
				hr = pNS->GetItem( &sdi );
				if( FAILED(hr) )
				{
					pNS->Release();
					return hr;
				}

				pNS->Release();
				CUDDIServicesNode *pStaticNode = (CUDDIServicesNode *)sdi.lParam;

				CUDDISiteNode *pSiteNode = reinterpret_cast<CUDDISiteNode *>( pStaticNode->FindChild( strServer.c_str() ) );
				if( NULL != pSiteNode )
				{
					pSiteNode->AddChild( m_szName, pConsole );
				}

				DeleteFromScopePane( pNS );
			}
		}
	}

	//
	// The SaveData() method communicates any issues.
	//
	hr = SaveData();

	hr = pConsole->UpdateAllViews( NULL, GetScopeItemValue(), 0 );
	_ASSERT( S_OK == hr);

    return hr;
}

HRESULT
CUDDIWebServerNode::OnSelect( CComponent *pComponent, IConsole *pConsole, BOOL bScope, BOOL bSelect )
{
	if( ( NULL == pComponent ) || ( NULL == pConsole ) )
	{
		return E_INVALIDARG;
	}

	HRESULT hr = E_FAIL;
	if( bSelect )
	{
		//
		// Enable refresh, and delete verbs
		//
		IConsoleVerb *pConsoleVerb = NULL;

		hr = pConsole->QueryConsoleVerb( &pConsoleVerb );
		if( FAILED(hr) )
		{
			return hr;
		}

		hr = pConsoleVerb->SetVerbState( MMC_VERB_REFRESH, ENABLED, TRUE );

		if( !IsExtension() && !m_bStdSvr )
		{
			hr = pConsoleVerb->SetVerbState( MMC_VERB_DELETE, ENABLED, TRUE );
			_ASSERT( S_OK == hr );
		}

		//
		// Can't get to properties (via the standard methods) unless
		// we tell MMC to display the Properties menu item and
		// toolbar button, this will give the user a visual cue that
		// there's "something" to do
		//
		hr = pConsoleVerb->SetVerbState( MMC_VERB_PROPERTIES, ENABLED, TRUE );

		//
		// Also set MMC_VERB_PROPERTIES as the default verb
		//
		hr = pConsoleVerb->SetDefaultVerb( MMC_VERB_PROPERTIES );

		pConsoleVerb->Release();

	}

	return S_FALSE;
}

BOOL CALLBACK CUDDIWebServerNode::GeneralDialogProc( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    switch( uMsg ) 
	{
		case WM_INITDIALOG:
		{
		    CUDDIWebServerNode *pWebServer = NULL;
			pWebServer = reinterpret_cast<CUDDIWebServerNode *>(reinterpret_cast<PROPSHEETPAGE *>(lParam)->lParam);

			SetWindowLongPtr( hwndDlg, GWLP_USERDATA, (LONG_PTR)pWebServer );

			CPropertyMap& m_mapProperties = pWebServer->m_mapProperties;
			_TCHAR szComponentName[ 256 ];

			HWND hwndParent = GetParent( hwndDlg );
			pWebServer->m_hwndPropSheet = hwndParent;

			SetDlgItemText( hwndDlg, IDC_GENERAL_SITE_TXT_INSTALL_DATE, LocalizedDate( m_mapProperties[ UDDI_SETUP_DATE ] ).c_str() );
			SetDlgItemText( hwndDlg, IDC_GENERAL_SITE_TXT_UDDI_LANGUAGE, m_mapProperties[ UDDI_SETUP_LANGUAGE ].c_str() );
			SetDlgItemText( hwndDlg, IDC_GENERAL_SITE_TXT_FRAMEWORK_VERSION, m_mapProperties[ UDDI_SETUP_FRAMEWORK_VERSION ].c_str() );
			SetDlgItemText( hwndDlg, IDC_GENERAL_SITE_TXT_UDDI_VERSION, m_mapProperties[ UDDI_SETUP_VERSION ].c_str() );
			SetDlgItemText( hwndDlg, IDC_GENERAL_SITE_TXT_INSTALL_LOCATION, m_mapProperties[ UDDI_SETUP_LOCATION ].c_str() );

			//
			// Build up "Web Server Component on <computername>" string for heading
			//
			LoadString( g_hinst, IDS_WEBSERVER_DISPLAYNAME_TEMPLATE, szComponentName, ARRAYLEN( szComponentName ) - 1 );
			WCHAR wszBuf[ 512 ];
			memset( wszBuf, 0, 512 * sizeof( WCHAR ) );

			_sntprintf( wszBuf, 512, szComponentName, pWebServer->m_szName );
			wszBuf[ 511 ] = 0x00;

			tstring strDisplayName ( wszBuf );
			SetDlgItemText( hwndDlg, IDC_GENERAL_SITE_TXT_DISPLAYNAME, strDisplayName.c_str() );
			
			if( _T("1") == m_mapProperties[ UDDI_SETUP_WEB ] )
			{
				LoadString( g_hinst, IDS_WEBSERVER_COMPONENT_DESCRIPTION, szComponentName, ARRAYLEN( szComponentName ) - 1 );
				ListBox_AddString( GetDlgItem( hwndDlg, IDC_GENERAL_SITE_LIST_SERVICES ), szComponentName );
			}

			if( _T("1") == m_mapProperties[ UDDI_SETUP_DB ] )
			{
				LoadString( g_hinst, IDS_DATABASE_SERVER_COMPONENT_DESCRIPTION, szComponentName, ARRAYLEN( szComponentName ) - 1 );
				ListBox_AddString( GetDlgItem( hwndDlg, IDC_GENERAL_SITE_LIST_SERVICES ),  szComponentName );
			}

			if( _T("1") == m_mapProperties[ UDDI_SETUP_ADMIN ] )
			{
				LoadString( g_hinst, IDS_UDDIMMC_COMPONENT_DESCRIPTION, szComponentName, ARRAYLEN( szComponentName ) - 1 );
				ListBox_AddString( GetDlgItem( hwndDlg, IDC_GENERAL_SITE_LIST_SERVICES ), szComponentName );
			}
		}
        break;

		case WM_NOTIFY:
		{
			if( PSN_HELP == ((NMHDR *) lParam)->code )
			{
				CUDDIWebServerNode *pWebServer = (CUDDIWebServerNode *)GetWindowLongPtr( hwndDlg, GWLP_USERDATA );
				if( NULL != pWebServer )
				{
					wstring strHelp( pWebServer->GetHelpFile() );
					strHelp += g_wszUddiWebGeneralPageHelp;

					::HtmlHelp( hwndDlg, strHelp.c_str(), HH_DISPLAY_TOPIC, NULL );
				}
			}
			break;
		}

		case WM_CLOSE:
		{
			CUDDIWebServerNode *pWebServer = (CUDDIWebServerNode *)GetWindowLongPtr( hwndDlg, GWLP_USERDATA );

			if( NULL != pWebServer )
			{
				pWebServer->m_hwndPropSheet = NULL;
			}

			break;
		}

		case WM_HELP:
		{
			CUDDIWebServerNode *pWebServer = (CUDDIWebServerNode *)GetWindowLongPtr( hwndDlg, GWLP_USERDATA );
			if( NULL != pWebServer )
			{
				wstring strHelp( pWebServer->GetHelpFile() );
				strHelp += g_wszUddiWebGeneralPageHelp;

				::HtmlHelp( hwndDlg, strHelp.c_str(), HH_DISPLAY_TOPIC, NULL );
			}
		}
		break;
	}

    return FALSE;
}

int split( const TCHAR * pszConnection, TCHAR *pszA, TCHAR *pszB, TCHAR *pszC )
{
	// 
	// Example: Data Source=localhost;Initial Catalog=uddi;Integrated Security=SSPI
	//
	TCHAR strConnection[ 512 ];
	strConnection[ 0 ] = 0x00;
	_tcsncpy( strConnection, pszConnection, 512 );
	strConnection[ 511 ] = 0x00;

	_tcslwr( strConnection );

	//
	// Get Data Source value
	//
	PTCHAR begin = _tcsstr( strConnection, _T("data source=") );
	_ASSERT( begin );

	begin += 12;
	PTCHAR end = begin;
	int n = 0;
	BOOL bDone = FALSE;

	while( !bDone )
	{
		if( _T('\\') == *end )
		{
			if( 0 == n )
			{
				_tcsncpy( pszA, begin, end - begin );
				pszA[ end - begin ] = NULL;
			}
			else if( 1 == n )
			{
				_tcsncpy( pszB, begin, end - begin );
				pszB[ end - begin ] = NULL;
			}
			else
			{
				_tcsncpy( pszC, begin, end - begin );
				pszC[ end - begin ] = NULL;
			}
			begin = end + 1;
			end++;
			n++;
		}
		else if( NULL == *end  || _T(';') == *end )
		{
			if( 0 == n )
			{
				_tcsncpy( pszA, begin, end - begin );
				pszA[ end - begin ] = NULL;
			}
			else if( 1 == n )
			{
				_tcsncpy( pszB, begin, end - begin );
				pszB[ end - begin ] = NULL;
			}
			else
			{
				_tcsncpy( pszC, begin, end - begin );
				pszC[ end - begin ] = NULL;
			}
			bDone = TRUE;
			n++;
		}
		else
		{
			end++;
		}
	}

	return n;
}

//
// Cases:
//		1. <domain>\<machine>\<instance>
//
//		2. <domain>\<machine>
//
//		3. <machine>\<instance>
//		
//		4. <machine>
//

void
CUDDIWebServerNode::CrackConnectionString( const tstring& strConnection, tstring& strDomain, tstring& strServer, tstring& strInstance )
{
	if( 0 == strConnection.length() )
	{
		strDomain = _T( "" );
		strServer = _T( "" );
		strInstance = _T( "" );

		return;
	}

//	TCHAR *pstrs[3] = { new TCHAR[ 256 ], new TCHAR[ 256 ], new TCHAR[ 256 ] };
	TCHAR *pszA, *pszB, *pszC;
	pszA = new TCHAR[ 256 ];
	pszB = new TCHAR[ 256 ];
	pszC = new TCHAR[ 256 ];

	if( ( NULL == pszA ) || ( NULL == pszB ) || ( NULL == pszC ) )
	{
		strDomain = _T( "" );
		strServer = _T( "" );
		strInstance = _T( "" );

		return;
	}

	memset( pszA, 0, 256 * sizeof( TCHAR ) );
	memset( pszB, 0, 256 * sizeof( TCHAR ) );
	memset( pszC, 0, 256 * sizeof( TCHAR ) );

	_TCHAR szConnection[ 512 ];
	memset( szConnection, 0, 512 * sizeof( TCHAR ) );
	_tcscpy( szConnection, strConnection.c_str() );

	int n = split( szConnection, pszA, pszB, pszC );
	
	if( 1 == n )
	{
		//
		// Case 4: <machine>
		//
		strDomain = _T("");
		strServer = pszA;
		strInstance = _T("");
	}
	else if( 3 == n )
	{
		//
		// Case 1 <domain>\<machine>\<instancename>
		//
		strDomain = pszA;
		strServer = pszB;
		strInstance = pszC;
	}
	else
	{
		//
		// TODO: Write code to determine between case 2 and case 3
		//
		// Assume case 3: <machine>\<instancename>
		//
		strDomain = _T("");
		strServer = pszA;
		strInstance = pszB;
	}

	delete [] pszA;
	delete [] pszB;
	delete [] pszC;

	return;
}

struct DatabaseConnectionData
{
	DatabaseConnectionData( CUDDIWebServerNode *pWeb )
		: pWebServer( pWeb )
		, bReadChanged( false )
		, bWriteChanged( false ){}

	bool bReadChanged;
	bool bWriteChanged;
	CUDDIWebServerNode *pWebServer;
};


tstring
CUDDIWebServerNode::BuildConnectionString( const wstring& strComputer )
{
	try
	{
		tstring strInstanceName;

		BOOL fSuccess = CUDDISiteNode::GetFullyQualifiedInstanceName( strComputer.c_str(), strInstanceName );
		if( !fSuccess )
		{
			return _T( "" );
		}


		tstring strConnection( _T("Data Source=") );

		strConnection += strInstanceName;

		strConnection += _T(";Initial Catalog=uddi;Integrated Security=SSPI");

		return strConnection;
	}
	catch( ... )
	{
		return _T( "" );
	}
}

BOOL CALLBACK CUDDIWebServerNode::DatabaseConnectionDialogProc( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    switch( uMsg ) 
	{
    case WM_INITDIALOG:
	{
		//
		// Load up the "not found" strings in case of a future failure
		//
		TCHAR	szNoServer[ 256 ], 
				szNoInstance[ 256 ];

		ZeroMemory( szNoServer, sizeof szNoServer );
		ZeroMemory( szNoInstance, sizeof szNoInstance );

		LoadString( g_hinst, IDS_UDDIMMC_NODBSERVER, szNoServer, ARRAYLEN( szNoServer ) - 1 );
		LoadString( g_hinst, IDS_UDDIMMC_NOINSTANCE, szNoInstance, ARRAYLEN( szNoInstance ) - 1 );

		//
        // Catch the "this" pointer so we can actually operate on the object
		//
		CUDDIWebServerNode *pWebServer = reinterpret_cast<CUDDIWebServerNode *>(reinterpret_cast<PROPSHEETPAGE *>(lParam)->lParam);
		DatabaseConnectionData* pdata = new DatabaseConnectionData( pWebServer );
		SetWindowLongPtr( hwndDlg, GWLP_USERDATA, (LONG_PTR) pdata );

		//
		// User can select a new database to read from/write to ONLY if the machine the web server
		// is running on is NOT Windows Server 2003 Standard Server.
		//
		// EnableWindow( GetDlgItem( hwndDlg, IDC_DB_CONNECTION_BTN_READER_SELECT ), pWebServer->m_bStdSvr ? FALSE : TRUE );
		EnableWindow( GetDlgItem( hwndDlg, IDC_DB_CONNECTION_BTN_WRITER_SELECT ), pWebServer->m_bStdSvr ? FALSE : TRUE );

		//
		// For Heartland RC2, we are removing the distinction between reader &
		// writer connection strings.  There can be only 1 connection string,
		// so we will use just the writer.
		//
		EnableWindow( GetDlgItem( hwndDlg, IDC_DB_CONNECTION_BTN_READER_SELECT ), FALSE );

		//
		// 	Example: Data Source=localhost;Initial Catalog=uddi;Integrated Security=SSPI
		//
		tstring strDomain, strMachine, strInstance;
		tstring strReaderConn = pWebServer->m_mapProperties[ UDDI_READER_CXN ];
		tstring strWriterConn = pWebServer->m_mapProperties[ UDDI_WRITER_CXN ];

		if( strReaderConn.empty() )
		{
			strMachine = szNoServer;
			strInstance = szNoInstance;
		}
		else
		{
			CrackConnectionString( strReaderConn, strDomain, strMachine, strInstance );
		}

		tstring strServer( _T("") );

		if( !strDomain.empty() )
		{
			strServer = strDomain;
			strServer += _T("\\");
			strServer += strMachine;
		}
		else
		{
			strServer = strMachine;
		}

		SetDlgItemText( hwndDlg, IDC_DB_CONNECTION_TXT_READER_SERVER, strServer.c_str() );
		SetDlgItemText( hwndDlg, IDC_DB_CONNECTION_TXT_READER_INSTANCE, strInstance.empty() ? DefaultInstanceDisplayName() : strInstance.c_str() );

		if( strWriterConn.empty() )
		{
			strMachine = szNoServer;
			strInstance = szNoInstance;
		}
		else
		{
			CrackConnectionString( strWriterConn, strDomain, strMachine, strInstance );
		}

		if( !strDomain.empty() )
		{
			strServer = strDomain;
			strServer += _T("\\");
			strServer += strMachine;
		}
		else
		{
			strServer = strMachine;
		}

		CUDDISiteNode::GetFullyQualifiedInstanceName( strServer.c_str(), strInstance );

		WCHAR wszServer[ 128 ];
		WCHAR wszInstance[ 256 ];
		memset( wszServer, 0, 128 * sizeof( WCHAR ) );
		memset( wszInstance, 0, 256 * sizeof( WCHAR ) );

		wcsncpy( wszServer, strServer.c_str(), strServer.length() );
		wcsncpy( wszInstance, strInstance.c_str(), strInstance.length() );

		ToUpper( wszServer );
		ToUpper( wszInstance );

		SetDlgItemText( hwndDlg, IDC_DB_CONNECTION_TXT_WRITER_SERVER, wszServer );
		SetDlgItemText( hwndDlg, IDC_DB_CONNECTION_TXT_WRITER_INSTANCE, wszInstance );

		SetDlgItemText( hwndDlg, IDC_DB_CONNECTION_TXT_READER_SERVER, wszServer );
		SetDlgItemText( hwndDlg, IDC_DB_CONNECTION_TXT_READER_INSTANCE, wszInstance );
	}
    break;

    case WM_COMMAND:
	{
		DatabaseConnectionData* pdata = (DatabaseConnectionData*) GetWindowLongPtr( hwndDlg, GWLP_USERDATA );
		
        switch( LOWORD(wParam) ) 
        { 
			case IDC_DB_CONNECTION_BTN_READER_SELECT:
			{
				DatabaseData data;
				data.pBase = pdata->pWebServer;
				INT_PTR nResult = DialogBoxParam( g_hinst, MAKEINTRESOURCE( IDD_SITE_CONNECT ), hwndDlg, CUDDISiteNode::NewDatabaseServerDialogProc, (LPARAM) &data );

				if( nResult )
				{
					//
					// The user is not allowed to point the connection strings to a database
					// instance running on a Windows Server 2003 Standard machine.  So, tell them so.
					//
					BOOL bIsStandard = TRUE;
					HRESULT hr = ::IsStandardServer( data.szServerName, &bIsStandard );
					if( FAILED(hr) )
					{
						UDDIMsgBox( hwndDlg,
									IDS_DOT_NET_SERVER,
									IDS_ERROR_TITLE,
									MB_ICONEXCLAMATION | MB_OK );
						break;
					}

					if( TRUE == bIsStandard )
					{
						UDDIMsgBox( hwndDlg,
									IDS_DATABASE_STANDARD_SERVER_DETAIL,
									IDS_DATABASE_STANDARD_SERVER,
									MB_ICONEXCLAMATION | MB_OK );
					}
					else
					{
						SetDlgItemText( hwndDlg, IDC_DB_CONNECTION_TXT_READER_SERVER, data.szServerName );
						SetDlgItemText( hwndDlg, IDC_DB_CONNECTION_TXT_READER_INSTANCE, InstanceDisplayName(data.szInstanceName) );
						SendMessage( GetParent(hwndDlg), PSM_CHANGED, (WPARAM) hwndDlg, 0 );

						pdata->bReadChanged = true;
					}
				}

				break;
			}
			case IDC_DB_CONNECTION_BTN_WRITER_SELECT:
			{
				DatabaseData data;
				data.pBase = pdata->pWebServer;
				INT_PTR nResult = DialogBoxParam( g_hinst, MAKEINTRESOURCE( IDD_SITE_CONNECT ), hwndDlg, CUDDISiteNode::NewDatabaseServerDialogProc, (LPARAM) &data );

				if( nResult )
				{
					//
					// The user is not allowed to point the connection strings to a database
					// instance running on a Windows Server 2003 Standard machine.  So, tell them so.
					//
					BOOL bIsStandard = TRUE;
					HRESULT hr = ::IsStandardServer( data.szServerName, &bIsStandard );
					if( FAILED(hr) )
					{
						UDDIMsgBox( hwndDlg,
									IDS_DOT_NET_SERVER,
									IDS_ERROR_TITLE,
									MB_ICONEXCLAMATION | MB_OK );
						break;
					}

					if( TRUE == bIsStandard )
					{
						UDDIMsgBox( hwndDlg,
									IDS_DATABASE_STANDARD_SERVER_DETAIL,
									IDS_DATABASE_STANDARD_SERVER,
									MB_ICONEXCLAMATION | MB_OK );
					}
					else
					{
						SetDlgItemText( hwndDlg, IDC_DB_CONNECTION_TXT_WRITER_SERVER, data.szServerName );
						SetDlgItemText( hwndDlg, IDC_DB_CONNECTION_TXT_WRITER_INSTANCE, InstanceDisplayName(data.szInstanceName) );

						SetDlgItemText( hwndDlg, IDC_DB_CONNECTION_TXT_READER_SERVER, data.szServerName );
						SetDlgItemText( hwndDlg, IDC_DB_CONNECTION_TXT_READER_INSTANCE, InstanceDisplayName(data.szInstanceName) );

						SendMessage( GetParent(hwndDlg), PSM_CHANGED, (WPARAM) hwndDlg, 0 );

						pdata->bWriteChanged = true;
					}
				}
				break;
			}
		}
	}
	break;

	case WM_HELP:
	{
		DatabaseConnectionData* pdata = (DatabaseConnectionData*) GetWindowLongPtr( hwndDlg, GWLP_USERDATA );
		wstring strHelp( pdata->pWebServer->GetHelpFile() );
		strHelp += g_wszUddiDatabaseConnectionPageHelp;

		::HtmlHelp( hwndDlg, strHelp.c_str(), HH_DISPLAY_TOPIC, NULL );
		break;
	}

    case WM_DESTROY:
	{
		DatabaseConnectionData* pdata = (DatabaseConnectionData*) GetWindowLongPtr( hwndDlg, GWLP_USERDATA );

		//
        // Tell MMC that we're done with the property sheet (we got this
        // handle in CreatePropertyPages
		//
        MMCFreeNotifyHandle( pdata->pWebServer->m_ppHandle );
		pdata->pWebServer->m_ppHandle = NULL;
		delete pdata;
	    break;
	}

    case WM_NOTIFY:
        if( PSN_APPLY == ((NMHDR *) lParam)->code ) 
		{
			DatabaseConnectionData* pdata = (DatabaseConnectionData*) GetWindowLongPtr( hwndDlg, GWLP_USERDATA );
			
			if( pdata->bReadChanged )
			{
				_TCHAR szComputer[ 256 ];
				_TCHAR szInstance[ 256 ];
				GetDlgItemText( hwndDlg, IDC_DB_CONNECTION_TXT_READER_SERVER, szComputer, ARRAYLEN( szComputer ) );
				GetDlgItemText( hwndDlg, IDC_DB_CONNECTION_TXT_READER_INSTANCE, szInstance, ARRAYLEN( szInstance ) );

				pdata->pWebServer->m_mapChanges[ UDDI_READER_CXN ] = BuildConnectionString( szComputer );
			}

			if( pdata->bWriteChanged )
			{
				_TCHAR szComputer[ 256 ];
				_TCHAR szInstance[ 256 ];
				GetDlgItemText( hwndDlg, IDC_DB_CONNECTION_TXT_WRITER_SERVER, szComputer, ARRAYLEN( szComputer ) );
				GetDlgItemText( hwndDlg, IDC_DB_CONNECTION_TXT_WRITER_INSTANCE, szInstance, ARRAYLEN( szInstance ) );

				pdata->pWebServer->m_mapChanges[ UDDI_WRITER_CXN ] = BuildConnectionString( szComputer );
			}

			//
			// Ask MMC to send us a message (on the main thread) so
			// we know the Apply button was clicked.
			//
			HRESULT hr = MMCPropertyChangeNotify( pdata->pWebServer->m_ppHandle, reinterpret_cast<LONG_PTR>(pdata->pWebServer) );
			_ASSERT( SUCCEEDED(hr) );

			//
			// Reset the window data after migration to the change collection
			//
			pdata->bReadChanged = false;
			pdata->bWriteChanged = false;

			return PSNRET_NOERROR;
        }
		else if( PSN_HELP == ((NMHDR *) lParam)->code )
		{
			DatabaseConnectionData* pdata = (DatabaseConnectionData*) GetWindowLongPtr( hwndDlg, GWLP_USERDATA );
			wstring strHelp( pdata->pWebServer->GetHelpFile() );
			strHelp += g_wszUddiDatabaseConnectionPageHelp;

			::HtmlHelp( hwndDlg, strHelp.c_str(), HH_DISPLAY_TOPIC, NULL );
		}
		break;
    }

    return FALSE;
}

HRESULT CUDDIWebServerNode::HasPropertySheets()
{
	//
    // Say "yes" when MMC asks if we have pages
	//
    return S_OK;
}

HRESULT CUDDIWebServerNode::CreatePropertyPages( IPropertySheetCallback *lpProvider, LONG_PTR handle )
{

	if( ( NULL == lpProvider ) || ( 0 == handle ) )
	{
		return E_INVALIDARG;
	}

	//
	// Reinitialize the data before we display the property pages
	//
	HRESULT hr = GetData();
	_ASSERT( SUCCEEDED( hr ) );

	PropertyPages pps[] = { 
		{ IDD_GENERAL_WEB_PROPPAGE, GeneralDialogProc },
		{ IDD_LOGGING_PROPPAGE, LoggingDialogProc },
		{ IDD_DB_CONNECTION_PROPPAGE, DatabaseConnectionDialogProc } };
	
    PROPSHEETPAGE psp;
    HPROPSHEETPAGE hPage = NULL;

	//
    // Cache this handle so we can call MMCPropertyChangeNotify
	//
    m_ppHandle = handle;
	
	//
    // Create the property page for this node.
    // NOTE: if your node has multiple pages, put the following
    // in a loop and create multiple pages calling
    // lpProvider->AddPage() for each page.
	//
    psp.dwSize = sizeof(PROPSHEETPAGE);
    psp.dwFlags = PSP_DEFAULT | PSP_HASHELP;
    psp.hInstance = g_hinst;
    psp.lParam = reinterpret_cast<LPARAM>(this);

	for( int i = 0; i < ARRAYLEN( pps ); i++ )
	{
		psp.pszTemplate = MAKEINTRESOURCE( pps[ i ].id );
		psp.pfnDlgProc = pps[ i ].dlgproc;

		hPage = CreatePropertySheetPage( &psp );
		_ASSERT( hPage );
		
		hr = lpProvider->AddPage( hPage );
		if( FAILED(hr) )
		{
			break;
		}
	}

    return hr;
}

HRESULT
CUDDIWebServerNode::GetWatermarks(HBITMAP *lphWatermark,
                               HBITMAP *lphHeader,
                               HPALETTE *lphPalette,
                               BOOL *bStretch)
{
    return S_FALSE;
}

HRESULT
CUDDIWebServerNode::OnUpdateItem( IConsole *pConsole, long item, ITEM_TYPE itemtype )
{
	if( NULL == pConsole )
	{
		return E_INVALIDARG;
	}

	HRESULT hr = S_OK;

    hr = UpdateScopePaneItem( pConsole, GetScopeItemValue() );
    _ASSERT( S_OK == hr );

    return hr;
}

HRESULT
CUDDIWebServerNode::OnRefresh( IConsole *pConsole )
{
	if( TRUE == m_fDeleteFromScopePane )
	{
		IConsoleNameSpace *pNS = NULL;
		HRESULT hr = pConsole->QueryInterface( IID_IConsoleNameSpace, reinterpret_cast<void **>( &pNS ) );
		if( FAILED(hr) )
		{
			return hr;
		}

		DeleteFromScopePane( pNS );

		pNS->Release();

		return S_OK;
	}

    //
    // The web server that this node represents might very well live on
    // some other machine.  The state of that web server might have changed
    // since the last time we queried it... ie, m_mapProperties might be
    // out of sync with the true state of the web server.  So, re-get the
    // web server's info.
    //
    GetData();

    BOOL bW3SvcRunning = IsW3SvcRunning();
    if( ( FALSE == bW3SvcRunning ) && IsRunning() )
    {
        Stop();
        m_mapProperties[ UDDI_RUN ] = _T("0");
    }
       
	//
    // Call IConsole::UpdateAllViews to redraw all views
    // owned by the parent scope item
	//

    LPDATAOBJECT lpDataObj = new CDataObject( (MMC_COOKIE)this, CCT_SCOPE );
    HRESULT hr;

    UPDATE_VIEWS_HINT hint = ( TRUE == m_isScopeItem ) ? UPDATE_SCOPEITEM : UPDATE_RESULTITEM;
    hr = pConsole->UpdateAllViews( lpDataObj, GetScopeItemValue(), hint );

	_ASSERT( S_OK == hr);
    return hr;
}


HRESULT
CUDDIWebServerNode::OnDelete( IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsoleComp )
{
	DeleteFromScopePane( pConsoleNameSpace );

	m_mapChanges[ UDDI_WRITER_CXN ] = _T("");
	m_mapChanges[ UDDI_READER_CXN ] = _T("");

	SaveData();
	GetData();

	//
    // Now set isDeleted member so that the parent doesn't try to
    // to insert it again in CUDDIServicesNode::OnShow. Admittedly, a hack...
	//
    m_isDeleted = TRUE;

	m_pParent->OnDeleteChild( m_szName );
    return S_OK;
}

HRESULT
CUDDIWebServerNode::OnSetToolbar( IControlbar *pControlbar, IToolbar *pToolbar, BOOL bScope, BOOL bSelect )
{
    HRESULT hr = S_OK;

    if( bSelect ) 
	{
		pToolbar->SetButtonState( ID_BUTTONSTOP, BUTTONPRESSED, !IsRunning() );
		pToolbar->SetButtonState( ID_BUTTONSTART, BUTTONPRESSED, IsRunning() );

        pToolbar->SetButtonState( ID_BUTTONSTART, ENABLED, !IsRunning() && IsW3SvcRunning() );
		pToolbar->SetButtonState( ID_BUTTONSTOP, ENABLED, IsRunning() || !IsW3SvcRunning() );

		//
        // Always make sure the menuButton is attached
		//
        hr = pControlbar->Attach( TOOLBAR, pToolbar );

        m_isScopeItem = bScope;

    } else 
	{
		//
        // Always make sure the toolbar is detached
		//
        hr = pControlbar->Detach( pToolbar );
		m_pToolbar = NULL;
    }

	return hr;
}

HRESULT
CUDDIWebServerNode::OnToolbarCommand( IConsole *pConsole, MMC_CONSOLE_VERB verb, IDataObject *pDataObject )
{
    CDataObject *pDO = GetOurDataObject( pDataObject );
    if( NULL == pDO )
    {
        return S_OK;
    }

    CDelegationBase *pBase = pDO->GetBaseNodeObject();
    if( NULL == pBase )
    {
        return S_OK;
    }

    CUDDIWebServerNode *pWSNode = static_cast<CUDDIWebServerNode *>( pBase );
    UPDATE_VIEWS_HINT hint = ( TRUE == pWSNode->m_isScopeItem ) ? UPDATE_SCOPEITEM : UPDATE_RESULTITEM;


    switch( verb )
    {
    case ID_BUTTONSTART:
		Start();
        break;

    case ID_BUTTONSTOP:
		Stop();
        break;
    }

   
    HRESULT hr = GetData();
	if( FAILED( hr ) )
		return hr;

    hr = pConsole->UpdateAllViews( pDataObject, GetScopeItemValue(), hint );
    _ASSERT( S_OK == hr);

    return S_OK;
}

HRESULT CUDDIWebServerNode::OnShowContextHelp( IDisplayHelp *pDisplayHelp, LPOLESTR helpFile )
{
	if( ( NULL == pDisplayHelp ) || ( NULL == helpFile ) )
	{
		return E_INVALIDARG;
	}

	wstring wstrHelpInfo = helpFile;
	wstrHelpInfo += g_wszUddiWebServerNodeHelp;

    LPOLESTR pszTopic = static_cast<LPOLESTR>(CoTaskMemAlloc((wstrHelpInfo.length() + 1) * sizeof(WCHAR)));
	if( NULL == pszTopic )
	{
		return E_OUTOFMEMORY;
	}

	wcsncpy( pszTopic, wstrHelpInfo.c_str(), wstrHelpInfo.length() );
	pszTopic[ wstrHelpInfo.length() ] = NULL;
	return pDisplayHelp->ShowTopic( pszTopic );
}

HRESULT CUDDIWebServerNode::OnAddMenuItems( IContextMenuCallback *pContextMenuCallback, long *pInsertionsAllowed ) 
{
	WCHAR szStartMenuText[ MAX_PATH ];
	WCHAR szStartMenuDescription[ MAX_PATH ];

	WCHAR szStopMenuText[ MAX_PATH ];
	WCHAR szStopMenuDescription[ MAX_PATH ];

	LoadStringW( g_hinst, IDS_WEBSERVER_START, szStartMenuText, ARRAYLEN( szStartMenuText ) );
	LoadStringW( g_hinst, IDS_WEBSERVER_START_DESCRIPTION, szStartMenuDescription, ARRAYLEN( szStartMenuDescription ) );

	LoadStringW( g_hinst, IDS_WEBSERVER_STOP, szStopMenuText, ARRAYLEN( szStopMenuText ) );
	LoadStringW( g_hinst, IDS_WEBSERVER_STOP_DESCRIPTION, szStopMenuDescription, ARRAYLEN( szStopMenuDescription ) );

    HRESULT hr = S_OK;
    CONTEXTMENUITEM menuItemsNew[] =
    {
        {
            szStartMenuText, szStartMenuDescription,
            IDM_WEBSERVER_START, CCM_INSERTIONPOINTID_PRIMARY_TOP, 0, 0
        },
        {
            szStopMenuText, szStopMenuDescription,
            IDM_WEBSERVER_STOP, CCM_INSERTIONPOINTID_PRIMARY_TOP, 0, 0
        },
        { NULL, NULL, 0, 0, 0 }
    };

	menuItemsNew[ IsRunning() ? 0 : 1 ].fFlags = MF_GRAYED;

    if( !IsW3SvcRunning() )
    {
        menuItemsNew[ 0 ].fFlags = MF_GRAYED;
    }

	//
    // Loop through and add each of the menu items, we
    // want to add to new menu, so see if it is allowed.
	//
    if( *pInsertionsAllowed & CCM_INSERTIONALLOWED_TOP )
    {
        for( LPCONTEXTMENUITEM m = menuItemsNew; m->strName; m++ )
        {
            hr = pContextMenuCallback->AddItem( m );
            _ASSERT( SUCCEEDED(hr) );
        }
    }

    return hr;
}

HRESULT CUDDIWebServerNode::OnMenuCommand( IConsole *pConsole, IConsoleNameSpace *pConsoleNameSpace, long lCommandID, IDataObject *pDataObject )
{
    switch( lCommandID )
    {
	case IDM_WEBSERVER_START:
		OnToolbarCommand( pConsole, (MMC_CONSOLE_VERB) ID_BUTTONSTART, pDataObject );
        break;
	case IDM_WEBSERVER_STOP:
		OnToolbarCommand( pConsole, (MMC_CONSOLE_VERB) ID_BUTTONSTOP, pDataObject );
		break;
    }

    return S_OK;
}

struct LoggingData
{
	LoggingData()
		: bEventLogChanged( false )
		, bFileLogChanged( false )
		, pWebServer( NULL ){}

	bool bEventLogChanged;
	bool bFileLogChanged;
	CUDDIWebServerNode *pWebServer;
};

BOOL CALLBACK CUDDIWebServerNode::LoggingDialogProc( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    switch( uMsg ) 
	{
		case WM_INITDIALOG:
		{
			//
			// Setup the window data
			//
			CUDDIWebServerNode *pWebServer = reinterpret_cast<CUDDIWebServerNode *>(reinterpret_cast<PROPSHEETPAGE *>(lParam)->lParam);
			LoggingData *pdata = new LoggingData();
			if( NULL == pdata )
			{
				return FALSE;
			}

			pdata->pWebServer = pWebServer;
			SetWindowLongPtr( hwndDlg, GWLP_USERDATA, (LONG_PTR) pdata );

			CPropertyMap& m_mapProperties = pWebServer->m_mapProperties;

			int nEventLogLevel = _tstoi( m_mapProperties[ UDDI_EVENTLOG_LEVEL ].c_str() );
			int nFileLogLevel = _tstoi( m_mapProperties[ UDDI_FILELOG_LEVEL ].c_str() );

			SetDlgItemText( hwndDlg, IDC_LOGGING_TXT_LOGFILE_LOCATION, m_mapProperties[ UDDI_LOG_FILENAME ].c_str() );
			SendDlgItemMessage( hwndDlg, IDC_LOGGING_SLIDER_FILELOG, TBM_SETRANGE, (WPARAM) TRUE, (LPARAM) MAKELONG( 0, 6 ) );
			SendDlgItemMessage( hwndDlg, IDC_LOGGING_SLIDER_EVENTLOG, TBM_SETRANGE, (WPARAM) TRUE, (LPARAM) MAKELONG( 0, 6 ) );
			SendDlgItemMessage( hwndDlg, IDC_LOGGING_SLIDER_EVENTLOG, TBM_SETPOS, (WPARAM) TRUE, (LPARAM) nEventLogLevel );
			SendDlgItemMessage( hwndDlg, IDC_LOGGING_SLIDER_FILELOG, TBM_SETPOS, (WPARAM) TRUE, (LPARAM) nFileLogLevel );
			break;
		}
		case WM_DESTROY:
		{
			//
			// Release the window data
			//
			LoggingData* pData = (LoggingData*) GetWindowLongPtr( hwndDlg, GWLP_USERDATA );
			delete pData;
		}
		break;

		case WM_HELP:
		{
			LoggingData* pData = (LoggingData*) GetWindowLongPtr( hwndDlg, GWLP_USERDATA );
			wstring strHelp( pData->pWebServer->GetHelpFile() );
			strHelp += g_wszUddiLoggingPageHelp;

			::HtmlHelp( hwndDlg, strHelp.c_str(), HH_DISPLAY_TOPIC, NULL );
		}
		break;

		case WM_HSCROLL:
		{
			//
			// This message indicates that a slider has changed position
			//
			LoggingData* pData = (LoggingData*) GetWindowLongPtr( hwndDlg, GWLP_USERDATA );

			//
			// The handle of slider is in the LPARAM
			//
			if( IDC_LOGGING_SLIDER_EVENTLOG == GetDlgCtrlID( (HWND) lParam ) )
			{
				pData->bEventLogChanged = true;
	            SendMessage( GetParent(hwndDlg), PSM_CHANGED, (WPARAM)hwndDlg, 0 );
			}
			else if( IDC_LOGGING_SLIDER_FILELOG == GetDlgCtrlID( (HWND) lParam ) )
			{
				pData->bFileLogChanged = true;
	            SendMessage(GetParent(hwndDlg), PSM_CHANGED, (WPARAM)hwndDlg, 0);
			}

			break;
		}

		case WM_NOTIFY:
			if( PSN_APPLY == ( (NMHDR *) lParam )->code )
			{
				//
				// The Apply button or the OK Button was clicked
				//
				LoggingData* pdata = (LoggingData*) GetWindowLongPtr( hwndDlg, GWLP_USERDATA );
				if( pdata->bEventLogChanged )
				{
					_TCHAR szPos[ 34 ];
					int nPos = (int) SendDlgItemMessage( hwndDlg, IDC_LOGGING_SLIDER_EVENTLOG, TBM_GETPOS, 0, 0 );

					pdata->pWebServer->m_mapChanges[ UDDI_EVENTLOG_LEVEL ] = _itot( nPos, szPos, 10 );
				}

				if( pdata->bFileLogChanged )
				{
					_TCHAR szPos[ 34 ];
					int nPos = (int) SendDlgItemMessage( hwndDlg, IDC_LOGGING_SLIDER_FILELOG, TBM_GETPOS, 0, 0 );

					pdata->pWebServer->m_mapChanges[ UDDI_FILELOG_LEVEL ] = _itot( nPos, szPos, 10 );
				}

				//
				// Reset the change indicators so we don't update twice
				//
				pdata->bEventLogChanged = false;
				pdata->bFileLogChanged = false;

				//
				// Ask MMC to send us a message (on the main thread) so
				// we know the Apply button was clicked.
				//
				HRESULT hr = MMCPropertyChangeNotify( pdata->pWebServer->m_ppHandle, (LPARAM) pdata->pWebServer );
				_ASSERT(SUCCEEDED(hr));
				return PSNRET_NOERROR;
			}
			else if( PSN_HELP == ((NMHDR *) lParam)->code )
			{
				DatabaseConnectionData* pdata = (DatabaseConnectionData*) GetWindowLongPtr( hwndDlg, GWLP_USERDATA );
				tstring strHelp( pdata->pWebServer->GetHelpFile() );
				strHelp += g_wszUddiLoggingPageHelp;

				::HtmlHelp( hwndDlg, strHelp.c_str(), HH_DISPLAY_TOPIC, NULL );
			}
        break;
	}
	return FALSE;
}

BOOL CALLBACK CUDDIWebServerNode::NewWebServerDialogProc( HWND hwndDlg,	UINT uMsg, WPARAM wParam, LPARAM lParam )
{
	static WebServerData* pWSData = NULL;

    switch( uMsg ) 
	{
		case WM_INITDIALOG:
		{
			pWSData = reinterpret_cast<WebServerData *>(lParam);

			if( NULL == pWSData || NULL == pWSData->pBase )
			{
				return FALSE;
			}

			WCHAR wszBuf[ MAX_PATH ];
			DWORD dwBufSize = MAX_PATH;
			wszBuf[ 0 ] = 0x00;

			if( !GetComputerName( wszBuf, &dwBufSize ) )
			{
				return FALSE;
			}

			BOOL fChildExists = pWSData->pBase->ChildExists( wszBuf );

			if( IsWebServer( wszBuf ) && !fChildExists )
			{
				// Defaults for the groups of radio buttons are:  add this computer,
				// and add it as both a reader + writer.
				//
				SendDlgItemMessage( hwndDlg, IDC_SITE_CONNECT_RADIO_LOCALCOMPUTER, BM_SETCHECK, TRUE, NULL );
				SendDlgItemMessage( hwndDlg, IDC_SITE_CONNECT_RADIO_BOTH, BM_SETCHECK, TRUE, NULL );
				EnableWindow( GetDlgItem( hwndDlg, IDOK ), TRUE );

				pWSData->connectMode = CM_Both;
			}
			else
			{
				EnableWindow( GetDlgItem( hwndDlg, IDC_SITE_CONNECT_RADIO_LOCALCOMPUTER ), FALSE );
				EnableWindow( GetDlgItem( hwndDlg, IDC_SITE_CONNECT_BTN_BROWSE ), TRUE );
				EnableWindow( GetDlgItem( hwndDlg, IDC_SITE_CONNECT_EDIT_ANOTHERCOMPUTER ), TRUE );
				EnableWindow( GetDlgItem( hwndDlg, IDOK ), FALSE );

				SetDlgItemText( hwndDlg, IDC_SITE_CONNECT_TXT_DATABASE_INSTANCE, _T("") );
				SendDlgItemMessage( hwndDlg, IDC_SITE_CONNECT_RADIO_ANOTHERCOMPUTER, BM_SETCHECK, TRUE, NULL );
				SetFocus( GetDlgItem( hwndDlg, IDC_SITE_CONNECT_EDIT_ANOTHERCOMPUTER ) );
			}

			break;
		}

		case WM_HELP:
		{
			tstring strHelp( pWSData->pBase->GetHelpFile() );
			strHelp += g_wszUddiAddWebServerHelp;

			::HtmlHelp( hwndDlg, strHelp.c_str(), HH_DISPLAY_TOPIC, NULL );
			break;
		}

        case WM_COMMAND: 
            switch( LOWORD(wParam) ) 
            { 
				case IDC_SITE_CONNECT_RADIO_LOCALCOMPUTER:
				{
					EnableWindow( GetDlgItem( hwndDlg, IDC_SITE_CONNECT_BTN_BROWSE ), FALSE );
					EnableWindow( GetDlgItem( hwndDlg, IDC_SITE_CONNECT_EDIT_ANOTHERCOMPUTER ), FALSE );
					EnableWindow( GetDlgItem( hwndDlg, IDOK ), TRUE );

					break;
				}

				case IDC_SITE_CONNECT_RADIO_ANOTHERCOMPUTER:
				{
					EnableWindow( GetDlgItem( hwndDlg, IDC_SITE_CONNECT_BTN_BROWSE ), TRUE );
					EnableWindow( GetDlgItem( hwndDlg, IDC_SITE_CONNECT_EDIT_ANOTHERCOMPUTER ), TRUE );

					WCHAR wszComputerName[ 256 ];
					wszComputerName[ 0 ] = 0x00;
					GetDlgItemText( hwndDlg, IDC_SITE_CONNECT_EDIT_ANOTHERCOMPUTER, wszComputerName, ARRAYLEN( wszComputerName ) );
					
					//
					// Enable the OK button only if there is some sort of text
					// in the edit control where the computer name is supposed
					// to be typed in.
					//
					EnableWindow( GetDlgItem( hwndDlg, IDOK ), 0 == wcslen( wszComputerName ) ? FALSE : TRUE );

					break;
				}

				case IDC_SITE_CONNECT_EDIT_ANOTHERCOMPUTER:
				{
					if( EN_CHANGE == HIWORD(wParam) )
					{
						WCHAR wszComputerName[ 256 ];
						wszComputerName[ 0 ] = 0x00;
						GetDlgItemText( hwndDlg, IDC_SITE_CONNECT_EDIT_ANOTHERCOMPUTER, wszComputerName, ARRAYLEN( wszComputerName ) );
						
						//
						// Enable the OK button only if there is some sort of text
						// in the edit control where the computer name is supposed
						// to be typed in.
						//
						EnableWindow( GetDlgItem( hwndDlg, IDOK ), 0 == wcslen( wszComputerName ) ? FALSE : TRUE );
					}
					break;
				}
	
				case IDC_SITE_CONNECT_BTN_BROWSE:
				{
					_TCHAR szComputerName[ 256 ];
					if( ObjectPicker( hwndDlg, OT_Computer, szComputerName, ARRAYLEN( szComputerName ) ) )
					{
						SetDlgItemText( hwndDlg, IDC_SITE_CONNECT_EDIT_ANOTHERCOMPUTER, szComputerName );
					}

					break;
				}

				case IDHELP:
				{
					wstring strHelp( pWSData->pBase->GetHelpFile() );
					strHelp += g_wszUddiAddWebServerHelp;

					::HtmlHelp( hwndDlg, strHelp.c_str(), HH_DISPLAY_TOPIC, NULL );

					break;
				}

                case IDOK:
				{
					_TCHAR szBuf[ MAX_PATH + 1 ];
					DWORD dwSize = MAX_PATH + 1;
					memset( szBuf, 0, dwSize * sizeof( _TCHAR ) );

					if( SendDlgItemMessage( hwndDlg, IDC_SITE_CONNECT_RADIO_LOCALCOMPUTER, BM_GETCHECK, NULL, NULL ) )
					{
						szBuf[ 0 ] = 0;
						::GetComputerName( szBuf, &dwSize );
						ToUpper( szBuf );
						pWSData->szName = szBuf;
					}
					else
					{
						::GetDlgItemText( hwndDlg, IDC_SITE_CONNECT_EDIT_ANOTHERCOMPUTER, szBuf, dwSize );
						ToUpper( szBuf );
						pWSData->szName = szBuf;
					}
					
					if( !CUDDIWebServerNode::IsWebServer( pWSData->szName.c_str() ) )
					{
						_TCHAR szTitle[ 256 ];
						_TCHAR szMessage[ 1024 ];
						LoadString( g_hinst, IDS_WEBSERVER_SELECT_ERROR, szMessage, ARRAYLEN( szMessage ) );
						LoadString( g_hinst, IDS_WEBSERVER_SELECT_ERROR_TITLE, szTitle, ARRAYLEN( szTitle ) );
						MessageBox( hwndDlg, szMessage, szTitle, MB_ICONERROR );
						return FALSE;
					}
                    EndDialog( hwndDlg, TRUE ); 
 					return TRUE;
				}

                case IDCANCEL:
				{
                    EndDialog( hwndDlg, FALSE ); 
				}
			}
	    case WM_DESTROY:
        break;
    }

    return FALSE;
}


HRESULT
CUDDIWebServerNode::UpdateResultPaneItem(IConsole *pConsole, HRESULTITEM item)
{
    HRESULT hr = E_INVALIDARG;

    if( NULL == pConsole )
    {
        return E_INVALIDARG;
    }

    IResultData *pResultData = NULL;
    hr = pConsole->QueryInterface( IID_IResultData, (void **)&pResultData );
    if( S_OK != hr )
    {
        return hr;
    }

    RESULTDATAITEM rditem;
    ZeroMemory( &rditem, sizeof( RESULTDATAITEM ) );
    rditem.itemID = item;
    
    hr = pResultData->GetItem( &rditem );
    _ASSERT( S_OK == hr );

    rditem.mask &= RDI_STR;
    rditem.str = MMC_CALLBACK;
    hr = pResultData->SetItem( &rditem );
    _ASSERT( S_OK == hr );

    //
    // Update the "Status" column.  Because we are updating the text, we
    // don't change the mask in rditem.
    //
    rditem.nCol = 1;
    hr = pResultData->SetItem( &rditem );
    _ASSERT( S_OK == hr );

    pResultData->Release();

    return hr;
}


HRESULT
CUDDIWebServerNode::UpdateScopePaneItem( IConsole *pConsole, HSCOPEITEM item )
{
    HRESULT hr = E_INVALIDARG;

    if( NULL == pConsole )
    {
        return E_INVALIDARG;
    }

    IConsoleNameSpace *pNameSpace = NULL;
    hr = pConsole->QueryInterface( IID_IConsoleNameSpace, (void **)&pNameSpace );
    if( S_OK != hr )
    {
        return hr;
    }

    SCOPEDATAITEM sditem;
    ZeroMemory( &sditem, sizeof( SCOPEDATAITEM ) );
    sditem.ID = item;

    hr = pNameSpace->GetItem( &sditem );
    _ASSERT( S_OK == hr );

    sditem.mask &= SDI_STR;
    sditem.displayname = MMC_CALLBACK;

    hr = pNameSpace->SetItem( &sditem );
    _ASSERT( S_OK == hr );

    pNameSpace->Release();

    return hr;
}


BOOL
CUDDIWebServerNode::IsW3SvcRunning()
{
    BOOL bRet = FALSE;

    // 1.  Open the Service Control Manager on the machine which the
    //     Web Server is currently running on.
    //
    SC_HANDLE hSCManager = OpenSCManager( m_szName, SERVICES_ACTIVE_DATABASE, SC_MANAGER_CONNECT );
    if( NULL == hSCManager )
    {
        return bRet;
    }

    // 2.  Get a handle to the WWW Service on said machine.  Note the
    //     access permissions that we are using.
    //
    SC_HANDLE hW3Svc = OpenService( hSCManager, _T("w3svc"), SERVICE_QUERY_STATUS );
    if( NULL == hW3Svc )
    {
        CloseServiceHandle( hSCManager );
        return bRet;
    }

    // 3.  Query the status of the WWW Service.
    //
    SERVICE_STATUS stW3Svc;
    ZeroMemory( &stW3Svc, sizeof( SERVICE_STATUS ) );

    if( QueryServiceStatus( hW3Svc, &stW3Svc ) )
    {
        bRet = ( SERVICE_RUNNING == stW3Svc.dwCurrentState ) ? TRUE : FALSE;
    }

    CloseServiceHandle( hSCManager );
    CloseServiceHandle( hW3Svc );
    return bRet;
}


BOOL
CUDDIWebServerNode::GetReaderConnectionString( const tstring& szName, tstring &szReader )
{
	try
	{
		CUDDIRegistryKey key( _T( "SOFTWARE\\Microsoft\\UDDI\\Database" ), KEY_READ, szName.c_str() );
		szReader = key.GetString( _T("ReaderConnectionString"), _T("") );

		return TRUE;
	}
	catch( ... )
	{
		return FALSE;
	}
}

BOOL
CUDDIWebServerNode::GetWriterConnectionString( const tstring& szName, tstring &szWriter )
{
	try
	{
		CUDDIRegistryKey key( _T( "SOFTWARE\\Microsoft\\UDDI\\Database" ), KEY_READ, szName.c_str() );
		szWriter = key.GetString( _T("WriterConnectionString"), _T("") );

		return TRUE;
	}
	catch( ... )
	{
		return FALSE;
	}
}


BOOL
CUDDIWebServerNode::SetReaderConnectionString( const tstring& szName, const tstring& szReader )
{
	try
	{
		CUDDIRegistryKey key( _T( "SOFTWARE\\Microsoft\\UDDI\\Database" ), KEY_ALL_ACCESS, szName.c_str() );
		key.SetValue( _T("ReaderConnectionString"), szReader.c_str() );
		return TRUE;
	}
	catch( ... )
	{
		return FALSE;
	}
}


BOOL
CUDDIWebServerNode::SetWriterConnectionString( const tstring& szName, const tstring& szWriter )
{
	try
	{
		CUDDIRegistryKey key( _T( "SOFTWARE\\Microsoft\\UDDI\\Database" ), KEY_ALL_ACCESS, szName.c_str() );
		key.SetValue( _T("WriterConnectionString"), szWriter.c_str() );
		return TRUE;
	}
	catch( ... )
	{
		return FALSE;
	}
}


BOOL
CUDDIWebServerNode::IsAssignedToSite( const tstring& szWebServer, const ConnectMode& cm, tstring& szSite )
{
	try
	{
		tstring szConnStr = _T( "" );
		tstring szDomain = _T( "" );
		tstring szInstance = _T( "" );

		szSite = _T( "" );
		CUDDIRegistryKey key( _T( "SOFTWARE\\Microsoft\\UDDI\\Database" ), KEY_READ, szWebServer.c_str() );

		tstring szName = ( CM_Reader == cm ) ? _T("ReaderConnectionString") : _T("WriterConnectionString");

		szConnStr = key.GetString( szName.c_str() );
		if( 0 < szConnStr.length() )
		{
			CrackConnectionString( szConnStr, szDomain, szSite, szInstance );
		}

		return ( 0 == szSite.length() ) ? FALSE : TRUE;
	}
	catch( ... )
	{
		return FALSE;
	}
}

BOOL 
CUDDIWebServerNode::GetDBSchemaVersion( tstring& szVersion )
{
	try
	{
		CUDDIRegistryKey key( _T( "SOFTWARE\\Microsoft\\UDDI\\Setup\\WebServer" ), KEY_READ, m_szName );

		szVersion = key.GetString( _T( "DBSchemaVersion" ) );

		return ( 0 == szVersion.length() ) ? FALSE : TRUE;
	}
	catch( ... )
	{
		return FALSE;
	}
}


BOOL
CUDDIWebServerNode::GetDBSchemaVersion( const wstring& strComputer, wstring& strVersion )
{
	try
	{
		CUDDIRegistryKey key( _T( "SOFTWARE\\Microsoft\\UDDI\\Setup\\WebServer" ), KEY_READ, strComputer );

		strVersion = key.GetString( _T( "DBSchemaVersion" ) );

		return ( 0 == strVersion.length() ) ? FALSE : TRUE;
	}
	catch( ... )
	{
		return FALSE;
	}
}

void
CUDDIWebServerNode::DeleteFromScopePane( IConsoleNameSpace *pConsoleNameSpace )
{
	if( NULL != pConsoleNameSpace )
	{
		pConsoleNameSpace->DeleteItem( GetScopeItemValue(), TRUE );
		m_isDeleted = TRUE;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\mmc\uddisitenode.h ===
#pragma once

#include "globals.h"
#include "delebase.h"
#include <map>
#include <string>
#include <vector>

using namespace std;


#define WEBSERVER_LIST_DELIM _T( '%' )
#define NULL_TERMINATOR		 _T( '\0' )

class CUDDIServicesNode;
typedef map<tstring, tstring> CConfigMap;

class CUDDIWebServerNode;
typedef map<int, CUDDIWebServerNode *> CUDDIWebServerNodeMap;
typedef pair<int, CUDDIWebServerNode *> CUDDIWebServerNodeMapEntry;

//
// Utility class.
//
class CStringCollection
{
public:
	CStringCollection( const wstring& strDelimitedStrings, const wstring& strDelim = L"%" );
	virtual ~CStringCollection();

	void DeleteString( const wstring& str );
	void AddString( const wstring& str );

	wstring GetDelimitedString() const;
	BOOL Exists( const wstring& str ) const;
	inline int Size() const {return _coll.size();}
	inline const wstring& operator[]( const int &idx ) const {return _coll[idx];}

private:
	CStringCollection();
	CStringCollection( const CStringCollection& copy );
	CStringCollection& operator=( const CStringCollection& rhs );

	vector< wstring > _coll;
	wstring _strDelim;
};

//
// Helper class for working with versions.
//
class CDBSchemaVersion
{
public:
	CDBSchemaVersion();	

	BOOL Parse( const tstring& versionString );
	BOOL IsCompatible( const CDBSchemaVersion& version );

public:
	int		m_major;
	int		m_minor;
	int		m_build;
	int		m_rev;
	tstring szVersion;

private:
	int GetPart( const _TCHAR* token );
};

class CUDDISiteNode : public CDelegationBase 
{
public:
    CUDDISiteNode( _TCHAR *szName, _TCHAR *szInstanceName, int id, CUDDIServicesNode *parent, BOOL bExtension );
    virtual ~CUDDISiteNode();

	static CUDDISiteNode* Create( _TCHAR *szName, _TCHAR *szInstanceName, int id, CUDDIServicesNode* parent, BOOL bExtension );
	static BOOL IsDatabaseServer( PTCHAR szName );
	static BOOL IsDatabaseServer( PTCHAR szName, PTCHAR szInstance );
	static BOOL CALLBACK NewDatabaseServerDialogProc( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam );
	static BOOL GetFullyQualifiedInstanceName( LPCTSTR szName, tstring& strInstanceName );
	static BOOL AddWebServerToSite( const wstring& strSite, const wstring& strWebServer, HWND hwndConsole );

    virtual const _TCHAR *GetDisplayName( int nCol = 0 );
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_DBSERVER; }
	virtual BOOL ChildExists( const WCHAR *pwszName );
	virtual BOOL HasChildren();
    BOOL IsDeleted() { return m_isDeleted; }
	HRESULT GetData();
	HRESULT SaveData();
	HRESULT AddChildrenToScopePane( IConsoleNameSpace *pConsoleNameSpace, HSCOPEITEM parent );
	BOOL ResetCryptography();
	tstring GetConnectionString();
	CConfigMap& GetConfigMap();
	const LPCTSTR GetName();
	const _TCHAR *GetInstanceName();
	size_t PublishToActiveDirectory();
	void RemoveFromActiveDirectory();
	BOOL CanPublishToActiveDirectory();
	CUDDIWebServerNode* FindChild( LPCTSTR szName );
	CUDDIServicesNode *GetStaticNode();
	void OnDeleteChild( const tstring& szName );
	void AddChild( const wstring& strName, IConsole *pConsole );

public:
	//
    // Virtual functions go here (for MMCN_*)
	//
	virtual HRESULT OnSelect( CComponent *pComponent, IConsole *pConsole, BOOL bScope, BOOL bSelect );
    virtual HRESULT OnPropertyChange( IConsole *pConsole, CComponent *pComponent );
    virtual HRESULT OnUpdateItem( IConsole *pConsole, long item, ITEM_TYPE itemtype );
    virtual HRESULT OnRefresh( IConsole *pConsole );      
	virtual HRESULT OnDelete( IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsoleComp );
	virtual HRESULT OnShowContextHelp(IDisplayHelp *pDisplayHelp, LPOLESTR helpFile);
	virtual HRESULT OnShow( IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem );
    virtual HRESULT OnExpand( IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent );
	virtual HRESULT OnAddMenuItems( IContextMenuCallback *pContextMenuCallback, long *pInsertionsAllowed );
	virtual HRESULT OnMenuCommand( IConsole *pConsole, IConsoleNameSpace *pConsoleNameSpace, long lCommandID, IDataObject *pDataObject );
    virtual HRESULT CreatePropertyPages( IPropertySheetCallback *lpProvider, LONG_PTR handle );
    virtual HRESULT HasPropertySheets();
    virtual HRESULT GetWatermarks( HBITMAP *lphWatermark, HBITMAP *lphHeader, HPALETTE *lphPalette,	BOOL *bStretch );
	virtual HRESULT RemoveChildren( IConsoleNameSpace *pNS );

private:
	void			ClearChildMap();
	BOOL			LoadChildMap( const tstring& szWebServers );
	BOOL			SaveChildMap( tstring& szWebServers );	
	static HRESULT	GetConfig( CConfigMap& configMap, const tstring& connectionString );
	static HRESULT	SaveConfig( CConfigMap& configMap, const tstring& connectionString );
	const _TCHAR*	GetNextWebServer( tstring& webServerList, int& position );
	void			AddWebServer( tstring& webServerList, const tstring& webServer );
	BOOL			AddChildEntry( CUDDIWebServerNode *pNode, UINT position = -1 );
	tstring			GetConnectionStringOLEDB();

	static void		HandleOLEDBError( HRESULT hrErr );

private:
	//
	// Property page dialog procedures
	//
    static BOOL CALLBACK GeneralDialogProc( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam );
    static BOOL CALLBACK RolesDialogProc( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam );
    static BOOL CALLBACK SecurityDialogProc( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam );
    static BOOL CALLBACK ActiveDirectoryDialogProc( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam );
	static BOOL CALLBACK CryptographyDialogProc( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam );
	static BOOL CALLBACK AdvancedDialogProc( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam );
	static BOOL CALLBACK PropertyEditDialogProc( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam );

    static const GUID thisGuid;
    enum menuItems { IDM_NEW_WEBSERVER = 1, IDM_DEBUG };
	static UINT m_nNextChildID;

    _TCHAR*				  m_szName;
	_TCHAR*				  m_szInstanceName;
	tstring				  m_strDisplayName;
    LONG_PTR			  m_ppHandle;
    CUDDIServicesNode*	  m_pParent;
    BOOL				  m_isDeleted;
	CConfigMap			  m_mapConfig;
	CConfigMap			  m_mapChanges;
	CUDDIWebServerNodeMap m_mapChildren;
	CDBSchemaVersion	  m_siteVersion;

public:
	BOOL				m_bIsDirty;
	BOOL				m_bStdSvr;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\operator\graph.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using UDDI.API;
using UDDI;
using UDDI.Diagnostics;

namespace UDDI.Replication
{
	public class ControlledMessage
	{
		public static void Save( string fromOperatorKey, string toOperatorKey, MessageType messageType )
		{
			/*Debug.Enter();

			SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor();

			sp.ProcedureName = "net_replication_controlledMessage_save";

			sp.Parameters.Add( "@fromOperatorKey", SqlDbType.UniqueIdentifier );
			sp.Parameters.Add( "@toOperatorKey", SqlDbType.UniqueIdentifier );
			sp.Parameters.Add( "@messageType", SqlDbType.TinyInt );

			sp.Parameters.SetGuidFromString( "@fromOperatorKey", fromOperatorKey );
			sp.Parameters.SetGuidFromString( "@toOperatorKey", toOperatorKey );
			sp.Parameters.SetShort( "@messageType", (short)messageType );

			sp.ExecuteNonQuery();

			Debug.Leave();*/
		}
		
		public static void Test( string fromOperatorKey, string toOperatorKey, MessageType messageType )
		{
			/*Debug.Enter();

			SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor();

			sp.ProcedureName = "net_replication_controlledMessage_test";

			sp.Parameters.Add( "@fromOperatorKey", SqlDbType.UniqueIdentifier );
			sp.Parameters.Add( "@toOperatorKey", SqlDbType.UniqueIdentifier );
			sp.Parameters.Add( "@messageType", SqlDbType.TinyInt );

			sp.Parameters.SetGuidFromString( "@fromOperatorKey", fromOperatorKey );
			sp.Parameters.SetGuidFromString( "@toOperatorKey", toOperatorKey );
			sp.Parameters.SetShort( "@messageType", (short)messageType );

			sp.ExecuteNonQuery();

			Debug.Leave();*/
		}

		public static void Clear()
		{
			/*
			Debug.Enter();

			SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor();

			sp.ProcedureName = "net_replication_controlledMessage_clear";
			sp.ExecuteNonQuery();*/
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\mmc\webservernode.h ===
#pragma once

#include "globals.h"
#include "delebase.h"
#include <map>
using namespace std;

enum ConnectMode
{
	CM_Reader = 0,
	CM_Writer,
	CM_Both
};

struct WebServerData
{
	CDelegationBase *pBase;
	tstring szName;
	ConnectMode connectMode;
};

typedef map<tstring, tstring> CPropertyMap;

class CUDDISiteNode;

class CUDDIWebServerNode : public CDelegationBase 
{
	friend class CUDDISiteNode;

public:
    CUDDIWebServerNode( const _TCHAR *szName, int id, CUDDISiteNode* parent, BOOL bExtension );
    virtual ~CUDDIWebServerNode();

	static BOOL IsWebServer( const WCHAR *pwszName );
	static BOOL IsAssignedToSite( const tstring& szWebServer, const ConnectMode& cm, tstring& szSite );
	
	static BOOL GetReaderConnectionString( const tstring& szName, tstring &szReader );
	static BOOL GetWriterConnectionString( const tstring& szName, tstring &szWriter );
	static BOOL SetReaderConnectionString( const tstring& szName, const tstring& szReader );
	static BOOL SetWriterConnectionString( const tstring& szName, const tstring& szWriter );
	static void CrackConnectionString( const tstring& strConnection, tstring& strDomain, tstring& strServer, tstring& strInstance );
	static tstring BuildConnectionString( const wstring& strComputer );
	static BOOL GetDBSchemaVersion( const wstring& strComputer, wstring& strVersion );
	static BOOL CALLBACK NewWebServerDialogProc( HWND hwndDlg,	UINT uMsg, WPARAM wParam, LPARAM lParam );

	HRESULT GetData();
	HRESULT SaveData();
	BOOL Start();
	BOOL Stop();
	BOOL SetRunState( BOOL bStart );
	const BOOL IsRunning();
	const LPCTSTR GetName();
	BOOL GetDBSchemaVersion( tstring& szVersion );

    virtual const _TCHAR *GetDisplayName(int nCol = 0);
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_WEBSERVER; }
	virtual BOOL HasChildren() { return FALSE; }
	virtual BOOL ChildExists( const WCHAR *pwszName );
    BOOL IsDeleted() { return m_isDeleted; }
	void DeleteFromScopePane( IConsoleNameSpace *pConsoleNameSpace );

	//
    // Virtual functions go here (for MMCN_*)
	//
	virtual HRESULT OnAddMenuItems( IContextMenuCallback *pContextMenuCallback, long *pInsertionsAllowed );
	virtual HRESULT OnMenuCommand( IConsole *pConsole, IConsoleNameSpace *pConsoleNameSpace, long lCommandID, IDataObject *pDataObject );
    virtual HRESULT OnSelect(CComponent *pComponent, IConsole *pConsole, BOOL bScope, BOOL bSelect);
    virtual HRESULT OnPropertyChange(IConsole *pConsole, CComponent *pComponent);
    virtual HRESULT OnUpdateItem(IConsole *pConsole, long item, ITEM_TYPE itemtype);
    virtual HRESULT OnRefresh(IConsole *pConsole);      
    virtual HRESULT OnDelete( IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsoleComp);
	virtual HRESULT OnSetToolbar( IControlbar *pControlbar, IToolbar *pToolbar, BOOL bScope, BOOL bSelect );
	virtual HRESULT OnToolbarCommand( IConsole *pConsole, MMC_CONSOLE_VERB verb, IDataObject *pDataObject );
	virtual HRESULT OnShowContextHelp(IDisplayHelp *pDisplayHelp, LPOLESTR helpFile);
    virtual HRESULT CreatePropertyPages(IPropertySheetCallback *lpProvider, LONG_PTR handle);
    virtual HRESULT HasPropertySheets();
    virtual HRESULT GetWatermarks(HBITMAP *lphWatermark, HBITMAP *lphHeader, HPALETTE *lphPalette, BOOL *bStretch );

private:
    static const GUID thisGuid;
    enum WEBSERVER_STATUS { RUNNING, STOPPED } m_nStatus;
    enum menuItems { IDM_WEBSERVER_START = 1, IDM_WEBSERVER_STOP = 2 };
	BOOL m_bStdSvr;

    _TCHAR*			m_szName;
	int				m_nId;
    LONG_PTR		m_ppHandle;
    CUDDISiteNode	*m_pParent;
    BOOL			m_isDeleted;
	CPropertyMap	m_mapProperties;
	CPropertyMap	m_mapChanges;
	IToolbar		*m_pToolbar;
    BOOL            m_isScopeItem;
	BOOL			m_fDeleteFromScopePane;
	tstring			m_strDisplayName;
	HWND			m_hwndPropSheet;

    static BOOL CALLBACK GeneralDialogProc( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam );
	static BOOL CALLBACK DatabaseConnectionDialogProc( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam );
	static BOOL CALLBACK LoggingDialogProc( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam );

    HRESULT UpdateScopePaneItem( IConsole *pConsole, HSCOPEITEM item );
    HRESULT UpdateResultPaneItem( IConsole *pConsole, HRESULTITEM item );

    BOOL IsW3SvcRunning();

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\operator\assemblyinfo.cs ===
using System.Reflection;
using System.Security.Permissions;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("uddi.operator.dll")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft Corporation")]
[assembly: AssemblyProduct("UDDI Services")]
[assembly: AssemblyCopyright("Copyright(c) 2002 Microsoft Corporation")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]
[assembly: PermissionSetAttribute(SecurityAction.RequestMinimum, Name = "FullTrust")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("")]
[assembly: AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\operator\operator.cs ===
using System;
using System.IO;
using System.Web.Services;
using System.Web.Services.Protocols;
using System.Xml.Serialization;
using UDDI.API;
using UDDI;
using UDDI.Diagnostics;

namespace UDDI.Replication
{
	[SoapDocumentService( ParameterStyle = SoapParameterStyle.Bare, RoutingStyle = SoapServiceRoutingStyle.RequestElement )]
	[WebService( Namespace=UDDI.Replication.Constants.Namespace )]
	public class ReplicationMessages
	{
		/// ****************************************************************
		///   public GetChangeRecords
		///	----------------------------------------------------------------
		///	  <summary>
		///		Web method for getting change records
		///	  </summary>
		///	----------------------------------------------------------------
		///   <param name="message">
		///		An instance of the get_changeRecords message
		///	  </param>
		///	----------------------------------------------------------------
		///   <returns>
		///		Returns a changeRecords element
		///	  </returns>
		/// ****************************************************************
		/// 		
		[WebMethod, SoapDocumentMethod( Action = "\"\"", RequestElementName = "get_changeRecords" )]
		[UDDIExtension( transaction = true, https = true, certificate = true, messageType = "get_changeRecords" )]
		public ChangeRecordDetail GetChangeRecords( UDDI.Replication.GetChangeRecords message )
		{		
			//
			// Log more information than for a usual message to help diagnose possible replication errors.
			//
			StartOperatorMessageLog( "GetChangeRecords", message );
			
			//Debug.Enter();
			Debug.VerifySetting( "OperatorKey" );

			//
			// Make sure the request is allowed by the communication graph.
			//
			ControlledMessage.Test( message.RequestingNode,
									Config.GetString( "OperatorKey" ),
									MessageType.GetChangeRecords );
			
			//
			// Retrieve the change records.
			//
			ChangeRecordDetail detail = new ChangeRecordDetail();
			
			try
			{
				detail = message.Get();

				EndOperatorMessageLog( "GetChangeRecords", detail );
			}
			catch( Exception e )
			{
				DispositionReport.Throw( e );

				EndOperatorMessageLog( "GetChangeRecords", e );
			}
			
			//Debug.Leave();
	
			return detail;
		}

		/// ****************************************************************
		///   public NotifyChangeRecordsAvailable
		///	----------------------------------------------------------------
		///	  <summary>
		///	  </summary>
		///	----------------------------------------------------------------
		///   <param name="message">
		///		An instance of the notify_changeRecordsAvailable message.
		///	  </param>
		/// ****************************************************************
		/// 
		[WebMethod, SoapDocumentMethod( Action = "\"\"", RequestElementName = "notify_changeRecordsAvailable" )]
		[UDDIExtension( transaction = true, https = true, certificate = true, messageType = "notify_changeRecordsAvailable" )]
		public DispositionReport NotifyChangeRecordsAvailable( UDDI.Replication.NotifyChangeRecordsAvailable message )
		{
			//
			// Log more information than for a usual message to help diagnose possible replication errors.
			//
			StartOperatorMessageLog( "NotifyChangeRecordsAvailable", message );

			//Debug.Enter();
			Debug.VerifySetting( "OperatorKey" );

			DispositionReport dr = new DispositionReport();

			//
			// Make sure the request is allowed by the communication graph.
			//
			ControlledMessage.Test( message.NotifyingNode,
								    Config.GetString( "OperatorKey" ),
									MessageType.GetChangeRecords );
			
			try
			{
				message.Notify();

				EndOperatorMessageLog( "NotifyChangeRecordsAvailable", null );
			}
			catch( Exception e )
			{
				DispositionReport.Throw( e );
				EndOperatorMessageLog( "NotifyChangeRecordsAvailable", e );
			}

			//Debug.Leave();
			
			return dr;
		}

		/// ****************************************************************
		///   public DoPing
		///	----------------------------------------------------------------
		///	  <summary>
		///	  </summary>
		///	----------------------------------------------------------------
		///   <param name="message">
		///		An instance of the do_ping message
		///	  </param>
		///	----------------------------------------------------------------
		///   <returns>
		///		Returns an operator element with details on this operator
		///		node.
		///	  </returns>
		/// ****************************************************************
		/// 
		[WebMethod, SoapDocumentMethod( Action = "\"\"", RequestElementName = "do_ping" )]
		[UDDIExtension( transaction = true, https = true, certificate = true, messageType = "do_ping" )]
		[return: XmlElement( "operatorNodeID", Namespace=UDDI.Replication.Constants.Namespace, IsNullable=false )]
		public string DoPing( UDDI.Replication.DoPing message )
		{
			StartOperatorMessageLog( "DoPing", message );

			//Debug.Enter();
			
			//
			// Retrieve the change records.
			//
			string detail = null;
			
			try
			{
				detail = message.Ping();

				EndOperatorMessageLog( "DoPing", detail );
			}
			catch( Exception e )
			{
				DispositionReport.Throw( e );

				EndOperatorMessageLog( "DoPing", e );
			}
			
			//Debug.Leave();
	
			return detail;
		}

		/// ****************************************************************
		///   public GetHighWaterMarks
		///	----------------------------------------------------------------
		///	  <summary>
		///	  </summary>
		///	----------------------------------------------------------------
		///   <param name="message">
		///		An instance of the get_highWaterMarks message
		///	  </param>
		///	----------------------------------------------------------------
		///   <returns>
		///		Returns a list of high water marks seen by this node.
		///	  </returns>
		/// ****************************************************************
		/// 
		[WebMethod, SoapDocumentMethod( Action = "\"\"", RequestElementName = "get_highWaterMarks" )]
		[UDDIExtension( transaction = true, https = true, certificate = true, messageType = "get_highWaterMarks" )]
		public HighWaterMarkDetail GetHighWaterMarks( UDDI.Replication.GetHighWaterMarks message )
		{
			//
			// Log more information than for a usual message to help diagnose possible replication errors.
			//
			StartOperatorMessageLog( "GetHighWaterMarks", message );

			//Debug.Enter();
			
			//
			// Retrieve the change records.
			//
			HighWaterMarkDetail detail = null;
			
			try
			{
				detail = message.Get();

				EndOperatorMessageLog( "GetHighWaterMarks", detail );
			}
			catch( Exception e )
			{
				DispositionReport.Throw( e );

				EndOperatorMessageLog( "GetHighWaterMarks", e );
			}
			
			//Debug.Leave();
	
			return detail;
		}	
		
		//
		// The methods below help us log more information about the replication requests.  We need this information in order
		// to diagnose any possible problems that we have when replicating with other nodes.
		//
		private void StartOperatorMessageLog( string operationName, object message )
		{
			WriteOperatorMessage( "Started " + operationName + " request at ", message ); 
		}

		private void EndOperatorMessageLog( string operationName, object response )
		{
			WriteOperatorMessage( "Ended " + operationName + " request at ", response );
		}

		private void WriteOperatorMessage( string message, object payload )
		{			
			UTF8EncodedStringWriter writer = new UTF8EncodedStringWriter();
						
			writer.Write( message );						
			writer.Write( " " );
			writer.WriteLine( DateTime.Now );			
			writer.WriteLine( "\r\nRaw Request:" );						
			writer.WriteLine( "" );			

			if( null != payload )
			{
				try
				{
					XmlSerializer serializer = new XmlSerializer( payload.GetType() );							
					serializer.Serialize( writer, payload );
				}
				catch
				{
					writer.WriteLine( "Unable to serialize payload." );
				}
				finally
				{
					writer.Close();
				}
			}
			Debug.OperatorMessage( SeverityType.Info, 
								   CategoryType.Replication, 
								   OperatorMessageType.None,
							       writer.ToString() );
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\operator\nodes.cs ===
using System;
using System.Collections;
using System.Collections.Specialized;
using System.Data;
using System.Xml.Serialization;
using UDDI;
using UDDI.API.Business;
using UDDI.Diagnostics;

namespace UDDI.Replication
{
	public class OperatorNodeCollection : CollectionBase
	{
		public void Get()
		{
			Get( true );
		}

		public void Get( bool activeOperatorsOnly )
		{
			SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor();

			sp.ProcedureName = "net_operators_get";

			SqlDataReaderAccessor reader = sp.ExecuteReader();

			try
			{
				this.Clear();

				while( reader.Read() )
				{
					OperatorStatus operatorStatus = (OperatorStatus)reader.GetShort( "operatorStatusID" );
					string name = reader.GetString( "name" );

					if( !activeOperatorsOnly || 
						OperatorStatus.New == operatorStatus || 
						OperatorStatus.Normal == operatorStatus )
					{
						this.Add(
							reader.GetGuidString( "operatorKey" ),
							operatorStatus,
							name,
							reader.GetString( "soapReplicationURL" ) );
					}
					else
					{
						Debug.Write(
							SeverityType.Info,
							CategoryType.Replication,
							String.Format( 
								"Removing operator '{0}' with status '{1}' from list of replication operators",
								name,
								operatorStatus.ToString() ) );								
					}
				}
			}
			finally
			{
				reader.Close();
			}
		}

		public OperatorNode this[ int index ]
		{
			get { return (OperatorNode)List[ index ]; }
			set { List[index] = value; }
		}

		public int Add( OperatorNode value )
		{
			return List.Add( value );
		}

		public int Add( string operatorNodeID, OperatorStatus operatorStatus, string name, string soapReplicationURL )
		{
			return List.Add( new OperatorNode( operatorNodeID, operatorStatus, name, soapReplicationURL ) );
		}

		public void Insert( int index, OperatorNode value )
		{
			List.Insert( index, value );
		}
		
		public int IndexOf( string operatorNodeID )
		{
			for( int i = 0; i < this.Count; i ++ )
			{
				if(  0 == String.Compare( operatorNodeID, ((OperatorNode)List[ i ]).OperatorNodeID, true ) )
					return i;
			}
			
			return -1;
		}
		
		public bool Contains( string operatorNodeID )
		{
			foreach( OperatorNode node in this )
			{
				if( 0 == String.Compare( operatorNodeID, node.OperatorNodeID, true ) )
					return true;
			}
			
			return false;
		}
		
		public void Remove( string operatorNodeID )
		{
			foreach( OperatorNode node in this )
			{
				if( 0 == String.Compare( operatorNodeID, node.OperatorNodeID, true ) )
				{
					List.Remove( node );
					return;
				}
			}
		}
		
		public void CopyTo( OperatorNode[] array, int index )
		{
			List.CopyTo( array, index );
		}
	}

	/// ********************************************************************
	///   public class OperatorNode  
	/// --------------------------------------------------------------------
	///   <summary>
	///   </summary>
	/// ********************************************************************  
	/// 
	[XmlRoot( "operator", Namespace=UDDI.Replication.Constants.Namespace )]
	public class OperatorNode
	{
		//
		// Element: operatorNodeID
		//
		[XmlElement( "operatorNodeID" )]
		public string OperatorNodeID;

		//
		// Element: operatorStatus
		//
		[XmlElement( "operatorStatus" )]
		public UDDI.Replication.OperatorStatus OperatorStatus;

		//
		// Element: contact
		//
		private ContactCollection contacts;

		[XmlElement( "contact" )]
		public ContactCollection Contacts
		{
			get
			{
				if( null == contacts )
					contacts = new ContactCollection();

				return contacts;
			}

			set { contacts = value; }
		}

		//
		// Element: operatorCustodyName
		//
		[XmlElement( "operatorCustodyName" )]
		public string Name;

		//
		// Element: soapReplicationRootURL
		//
		[XmlElement( "soapReplicationRootURL" )]
		public string SoapReplicationURL;

		//
		// Element: certIssuerName
		//
		[XmlElement( "certIssuerName" )]
		public string CertIssuerName;

		//
		// Element: certSubjectName
		//
		[XmlElement( "certSubjectName" )]
		public string CertSubjectName;

		//
		// Element: certificate
		//
		[XmlElement( "certificate" )]
		public byte[] Certificate;

		public OperatorNode()
		{
		}

		public OperatorNode( string operatorNodeID )
		{
			this.OperatorNodeID = operatorNodeID;
		}

		public OperatorNode( string operatorNodeID, OperatorStatus operatorStatus, string name, string soapReplicationURL )
		{
			this.OperatorNodeID = operatorNodeID;
			this.OperatorStatus = operatorStatus;
			this.Name = name;
			this.SoapReplicationURL = soapReplicationURL;
		}

		public void Get()
		{
			Debug.Enter();

			SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor();

			sp.ProcedureName = "net_operator_get";

			sp.Parameters.Add( "@operatorKey", SqlDbType.UniqueIdentifier );
			sp.Parameters.SetGuidFromString( "@operatorKey", OperatorNodeID );

			SqlDataReaderAccessor reader = sp.ExecuteReader();

			try
			{
				if( reader.Read() )
				{
					OperatorStatus = (OperatorStatus)reader.GetShort( "operatorStatusID" );
					Name = reader.GetString( "name" );
					SoapReplicationURL = reader.GetString( "soapReplicationURL" );
					CertIssuerName = reader.GetString( "certIssuer" );
					CertSubjectName = reader.GetString( "certSubject" );
					Certificate = reader.GetBinary( "certificate" );
				}
			}
			finally
			{
				reader.Close();
			}

			Debug.Leave();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\operator\types.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using System.Xml.Serialization;
using UDDI.Diagnostics;

namespace UDDI.Replication
{
	public class Constants
	{
		public const string Namespace = "urn:uddi-org:repl";
	}

	public enum OperatorStatus
	{
		[ XmlEnum( "disabled" ) ]
		Disabled	= 0,
		[ XmlEnum( "new" ) ]
		New			= 1,
		[ XmlEnum( "normal" ) ]
		Normal		= 2,
		[ XmlEnum( "resigned" ) ]
		Resigned	= 3
	}

	public enum ReplicationStatus
	{
		// Retrieve replication status

		Success				= 0,
		CommunicationError	= 1,
		ValidationError		= 2,

		// Inbound replication status

		Notify				= 128
	}

	[ Flags ]
	public enum ChangeRecordFlags
	{
		AcknowledgementRequested	= 0x01
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\operator\messages.cs ===
using System;
using System.Collections;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using System.Text;
using System.Xml;
using System.Xml.Serialization;
using UDDI;
using UDDI.API;
using UDDI.API.Binding;
using UDDI.API.Business;
using UDDI.API.Service;
using UDDI.API.ServiceType;
using UDDI.Diagnostics;

namespace UDDI.Replication
{
	[XmlRoot( "changeRecords", Namespace=UDDI.Replication.Constants.Namespace )]
	public class ChangeRecordDetail
	{
		[XmlElement( "changeRecord" )]
		public ChangeRecordCollection ChangeRecords = new ChangeRecordCollection();

		public ChangeRecordDetail()
		{
		}
	}

	[XmlRoot( "highWaterMarks", Namespace=UDDI.Replication.Constants.Namespace )]
	public class HighWaterMarkDetail
	{
		[XmlElement( "highWaterMark" )]
		public ChangeRecordVectorCollection HighWaterMarks = new ChangeRecordVectorCollection();
	}

	[XmlRoot( "get_changeRecords", Namespace=UDDI.Replication.Constants.Namespace )]
	public class GetChangeRecords
	{
		//
		// Element: requestingNode
		//
		[XmlElement( "requestingNode" )]
		public string RequestingNode;

		//
		// Element: changesAlreadySeen
		//
		private ChangeRecordVectorCollection changesAlreadySeen;

		[XmlArray( "changesAlreadySeen" ), XmlArrayItem( "highWaterMark" )]
		public ChangeRecordVectorCollection ChangesAlreadySeen
		{
			get
			{
				if( null == changesAlreadySeen )
					changesAlreadySeen = new ChangeRecordVectorCollection();

				return changesAlreadySeen;
			}

			set { changesAlreadySeen = value; }
		}

		//
		// Element: responseLimitCount
		//
		private int responseLimitCount = -1;
        
		[XmlElement( "responseLimitCount" ), DefaultValue( -1 )]
		public int ResponseLimitCount
		{
			get { return responseLimitCount; }
			set	{ responseLimitCount = value; }
		}

		//
		// Element: responseLimitVector
		//
		private ChangeRecordVectorCollection responseLimitVector;

		[XmlArray( "responseLimitVector" ), XmlArrayItem( "highWaterMark" )]
		public ChangeRecordVectorCollection ResponseLimitVectorSerialize
		{
			get
			{
				if( -1 != ResponseLimitCount || Utility.CollectionEmpty( responseLimitVector ) )
					return null;

				return responseLimitVector;
			}

			set { responseLimitVector = value; }
		}

		[XmlIgnore]
		public ChangeRecordVectorCollection ResponseLimitVector
		{
			get
			{
				if( null == responseLimitVector )
					responseLimitVector = new ChangeRecordVectorCollection();

				return responseLimitVector;
			}
		}

		/// ****************************************************************
		///   public Get
		/// ----------------------------------------------------------------
		///   <summary>
		///   </summary>
		/// ****************************************************************
		/// 
		public ChangeRecordDetail Get()
		{
			Debug.VerifySetting( "OperatorKey" );

			ChangeRecordDetail detail = new ChangeRecordDetail();

			try
			{
				//
				// Get the list of known operators.
				//
				StringCollection operators = new StringCollection();

				SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor();

				sp.ProcedureName = "net_operators_get";				
				SqlDataReaderAccessor reader = sp.ExecuteReader();

				try
				{
					while( reader.Read() )
					{
						operators.Add( reader.GetGuidString( "operatorKey" ) );
					}
				}
				finally
				{
					reader.Close();
				}

				//
				// Set the search criteria for change records.
				//
				foreach( string operatorKey in operators )
				{
					long startUSN;
					long stopUSN;

					startUSN = 0;
					foreach( ChangeRecordVector mark in ChangesAlreadySeen )
					{
						if( 0 == String.Compare( operatorKey, mark.NodeID, true ) )
						{
							startUSN = mark.OriginatingUSN + 1;
							break;
						}
					}

					stopUSN = System.Int64.MaxValue;
					foreach( ChangeRecordVector mark in ResponseLimitVector )
					{
						if( 0 == String.Compare( operatorKey, mark.NodeID, true ) )
						{
							stopUSN = mark.OriginatingUSN;
							break;
						}
					}

					FindChangeRecords.SetRange( operatorKey, startUSN, stopUSN );
				}

				//
				// Retrieve the change records.
				//
				int limit = Config.GetInt( "Replication.ResponseLimitCountDefault" );

				if( ResponseLimitCount >= 0 && ResponseLimitCount <= limit )
					limit = ResponseLimitCount;
				
				reader = FindChangeRecords.RetrieveResults( limit );

				try
				{
					while( reader.Read() )
					{
						XmlSerializer serializer = null;

						switch( (ChangeRecordPayloadType)reader.GetShort( "changeTypeID" ) )
						{
							case ChangeRecordPayloadType.ChangeRecordNull:
								serializer = XmlSerializerManager.GetSerializer( typeof( ChangeRecordNull ) );
								break;

							case ChangeRecordPayloadType.ChangeRecordNewData:
								serializer = XmlSerializerManager.GetSerializer( typeof( ChangeRecordNewData ) );
								break;

							case ChangeRecordPayloadType.ChangeRecordDelete:
								serializer = XmlSerializerManager.GetSerializer( typeof( ChangeRecordDelete ) );
								break;

							case ChangeRecordPayloadType.ChangeRecordPublisherAssertion:
								serializer = XmlSerializerManager.GetSerializer( typeof( ChangeRecordPublisherAssertion ) );
								break;

							case ChangeRecordPayloadType.ChangeRecordHide:
								serializer = XmlSerializerManager.GetSerializer( typeof( ChangeRecordHide ) );
								break;

							case ChangeRecordPayloadType.ChangeRecordDeleteAssertion:
								serializer = XmlSerializerManager.GetSerializer( typeof( ChangeRecordDeleteAssertion ) );
								break;

							case ChangeRecordPayloadType.ChangeRecordAcknowledgement:
								serializer = XmlSerializerManager.GetSerializer( typeof( ChangeRecordAcknowledgement ) );
								break;

							case ChangeRecordPayloadType.ChangeRecordCorrection:
								serializer = XmlSerializerManager.GetSerializer( typeof( ChangeRecordCorrection ) );
								break;
						}

						StringReader stringReader = new StringReader( reader.GetString( "changeData" ) );
						
						try
						{
							ChangeRecord changeRecord = new ChangeRecord();
						
							changeRecord.AcknowledgementRequested = ( reader.GetInt( "flag" ) & (int)ChangeRecordFlags.AcknowledgementRequested ) > 0;
							changeRecord.ChangeID.NodeID		  = reader.GetString( "OperatorKey" );
							changeRecord.ChangeID.OriginatingUSN  = reader.GetLong( "USN" );
						
							ChangeRecordBase changeRecordBase = ( ChangeRecordBase ) serializer.Deserialize( stringReader );
							if( changeRecordBase is ChangeRecordCorrection )
							{
								//
								// The query to find change records will do correction 'fixups'.  That is, the changeData of this
								// change record will be replaced with the changeData from the correction.  The problem with this is 
								// that the original change data will now look like a correction.  To distinguish these types of 
								// change records, we look to see if the OriginatingUSN's match.  If the OriginatingUSN's match,
								// we want they payload of the change record in this correction.  This payload will contain the
								// corrected data that we want.
								//
								ChangeRecordCorrection changeRecordCorrection = ( ChangeRecordCorrection ) changeRecordBase;
								if( changeRecordCorrection.ChangeRecord.ChangeID.OriginatingUSN == changeRecord.ChangeID.OriginatingUSN )
								{
									changeRecordBase = changeRecordCorrection.ChangeRecord.Payload;
								}								
							}
							
							changeRecord.Payload = changeRecordBase;
														
							detail.ChangeRecords.Add( changeRecord );
						}
						finally
						{
							stringReader.Close();
						}
					}
				}
				finally
				{
					reader.Close();
				}
			}
			catch( Exception e )
			{
				Debug.OperatorMessage(
					SeverityType.Error,
					CategoryType.Replication,
					OperatorMessageType.None,
					"Could not retrieve change records:\r\n" + e.ToString() );
				
				FindChangeRecords.CleanUp();
				throw;
			}

			return detail;
		}

		public override string ToString()
		{
			XmlSerializer serializer = new XmlSerializer( GetType() );
			UTF8EncodedStringWriter stringWriter = new UTF8EncodedStringWriter();

			try
			{
				serializer.Serialize( stringWriter, this );
				return stringWriter.ToString();
			}
			finally
			{
				stringWriter.Close();
			}
		}
	}

	public class FindChangeRecords
	{
		public static int SetRange( string operatorKey, long startUSN, long stopUSN )
		{
			SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor();

			sp.ProcedureName = "net_find_changeRecords";

			sp.Parameters.Add( "@contextID", SqlDbType.UniqueIdentifier );
			sp.Parameters.Add( "@operatorKey", SqlDbType.UniqueIdentifier );
			sp.Parameters.Add( "@startUSN", SqlDbType.BigInt );
			sp.Parameters.Add( "@stopUSN", SqlDbType.BigInt );
			sp.Parameters.Add( "@rows", SqlDbType.Int, ParameterDirection.Output );
			
			sp.Parameters.SetGuid( "@contextID", Context.ContextID );
			sp.Parameters.SetGuidFromString( "@operatorKey", operatorKey );
			sp.Parameters.SetLong( "@startUSN", startUSN );
			sp.Parameters.SetLong( "@stopUSN", stopUSN );

			sp.ExecuteNonQuery();

			return sp.Parameters.GetInt( "@rows" );
		}

		public static SqlDataReaderAccessor RetrieveResults( int maxRows )
		{
			SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor();

			sp.ProcedureName = "net_find_changeRecords_commit";

			sp.Parameters.Add( "@contextID", SqlDbType.UniqueIdentifier );			
			sp.Parameters.Add( "@responseLimitCount", SqlDbType.Int );

			sp.Parameters.SetGuid( "@contextID", Context.ContextID );
			sp.Parameters.SetInt( "@responseLimitCount", maxRows );
			
			SqlDataReaderAccessor reader = sp.ExecuteReader();

			return reader;
		}

		public static void CleanUp()
		{
			SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor();

			sp.ProcedureName = "net_find_changeRecords_cleanup";

			sp.Parameters.Add( "@contextID", SqlDbType.UniqueIdentifier );			
			sp.Parameters.SetGuid( "@contextID", Context.ContextID );

			sp.ExecuteNonQuery();
		}
	}

	[XmlRoot( "notify_changeRecordsAvailable", Namespace=UDDI.Replication.Constants.Namespace )]
	public class NotifyChangeRecordsAvailable
	{
		//
		// Element: notifyingNode
		//
		[XmlElement( "notifyingNode" )]
		public string NotifyingNode;

		//
		// Element: changesAvailable
		//
		private ChangeRecordVectorCollection highWaterMarks;

		[XmlArray( "changesAvailable" ), XmlArrayItem( "highWaterMark" )]
		public ChangeRecordVectorCollection HighWaterMarks
		{
			get
			{
				if( null == highWaterMarks )
					highWaterMarks = new ChangeRecordVectorCollection();

				return highWaterMarks;
			}

			set { highWaterMarks = new ChangeRecordVectorCollection(); }
		}

		public void Notify()
		{
			ReplicationResult result = new ReplicationResult();

			result.OperatorNodeID = NotifyingNode;
			result.Description = null;
			result.LastNodeID = null;
			result.LastUSN = 0;
			result.LastChange = DateTime.Now.Ticks;
			result.ReplicationStatus = ReplicationStatus.Notify;
							
			result.Save();
		}
	}

	[XmlRoot( "do_ping", Namespace=UDDI.Replication.Constants.Namespace )]
	public class DoPing
	{
		public string Ping()
		{
			Debug.VerifySetting( "OperatorKey" );

			return Config.GetString( "OperatorKey" );
		}
	}

	[XmlRoot( "get_highWaterMarks", Namespace=UDDI.Replication.Constants.Namespace )]
	public class GetHighWaterMarks
	{
		public HighWaterMarkDetail Get()
		{
			HighWaterMarkDetail detail = new HighWaterMarkDetail();

			SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor();

			sp.ProcedureName = "net_highWaterMarks_get";

			SqlDataReaderAccessor reader = sp.ExecuteReader();

			try
			{
				while( reader.Read() )
				{
					detail.HighWaterMarks.Add(
						reader.GetString( "operatorKey" ), 
						reader.GetLong( "USN" ) );
				}
			}
			finally
			{
				reader.Close();
			}

			return detail;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\replicate\makefile.inc ===
foo.cs:
	..\version\$(O)\version.exe -outfile .\assemblyversioninfo.cs
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\operatorweb\assemblyinfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("")]
[assembly: AssemblyCopyright("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly: AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified, the assembly is not signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. KeyFile refers to a file which contains
//       a key.
//   (*) If the KeyFile and the KeyName values are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP, that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the KeyFile is installed into the CSP and used.
//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
//       When specifying the KeyFile, the location of the KeyFile should be
//       relative to the project output directory which is
//       %Project Directory%\obj\<configuration>. For example, if your KeyFile is
//       located in the project directory, you would specify the AssemblyKeyFile 
//       attribute as [assembly: AssemblyKeyFile("..\\..\\mykey.snk")]
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("")]
[assembly: AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\operatorweb\chagerecordsearch.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using System.Collections;
using System.Xml.Serialization;
using UDDI;
using UDDI.Diagnostics;
using UDDI.Replication;
namespace UDDI.Web
{
	/// <summary>
	/// Summary description for oepratorsearchcontrols.
	/// </summary>
	[ XmlRoot( "changeRecordCache" ) ]
	public class ChangeRecordsSessionCache
	{
		public ChangeRecordsSessionCache()
		{
			
		}

		private string key;//=Guid.NewGuid().ToString();
		[ XmlAttribute( "key" ) ]
		public string Key
		{
			get{ return key; }
			set{ key=value; }
		}

		private FindChangeRecordsHelper findCache;
		[ XmlElement( "findChangeRecordCache" ) ]
		public FindChangeRecordsHelper FindCache
		{
			get
			{
				if( null==findCache )
				{	
					findCache = new FindChangeRecordsHelper();
				}
				
				return findCache;
			}
		}
		
		private GetChangeRecords getCache;
		[ XmlElement( "getChangeRecordCache" ) ]
		public GetChangeRecords GetCache
		{
			get{ return getCache; }
			set{ getCache = (GetChangeRecords)value; }
		}

		private ChangeRecordDetail changes;
		[XmlIgnore]
		public ChangeRecordDetail Changes
		{
			get{ return changes; }
		}
		private ChangeRecordVectorCollection changelist;
		[XmlIgnore]
		public ChangeRecordVectorCollection ChangeList
		{
			get{ return changelist; }
		}
		

		public void GetChanges()
		{
			if( null!=GetCache )
			{
				changes = GetCache.Get();
			}
		}
		public void FindChanges()
		{
			
		}
		public void SaveCache()
		{
			Debug.Enter();
			
			//
			// Serialize the data into a stream.
			//
			XmlSerializer serializer = new XmlSerializer( this.GetType() );
			StringWriter writer = new StringWriter();
	
			serializer.Serialize( writer, this );

			//
			// Write the cache object to the database.
			//
			
			SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor( "UI_setSessionCache" );
			sp.Parameters.Add( "@PUID", SqlDbType.NVarChar  );
			sp.Parameters.Add( "@cacheValue", SqlDbType.NText );
			sp.Parameters.Add( "@context", SqlDbType.NVarChar );
			
			sp.Parameters.SetString( "@PUID",Key );
			sp.Parameters.SetString( "@cacheValue",writer.ToString() );
			sp.Parameters.SetString( "@context","ReplicationServer" );
		
			
			sp.ExecuteNonQuery();

			sp.Close();
			writer.Close();
			Debug.Leave();
		}
		
		public static ChangeRecordsSessionCache RetrieveCache( string key )
		{
			ChangeRecordsSessionCache session = RetrieveCacheFromDB( key );
			return session;
		}
		protected static ChangeRecordsSessionCache RetrieveCacheFromDB( string key )
		{
			Debug.Enter();
			
			//
			// Retrieve the cache object from the database.
			//
			string data = "";
			
			SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor( "UI_getSessionCache" );
			
			
			sp.Parameters.Add( "@PUID", SqlDbType.NVarChar );
			sp.Parameters.Add( "@context", SqlDbType.NVarChar );
			
			sp.Parameters.SetString( "@PUID" , key );
			sp.Parameters.SetString("@context" , "ReplicationServer" );

			data = (string)sp.ExecuteScalar();
			
			//
			// Deserialize into a cache object.
			//
			ChangeRecordsSessionCache cache = null;

			if( !Utility.StringEmpty( data ) )
			{
				XmlSerializer serializer = new XmlSerializer( typeof( ChangeRecordsSessionCache ) );
				StringReader reader = new StringReader( data );
				
				cache = (ChangeRecordsSessionCache)serializer.Deserialize( reader );
				cache.Key = key;
			}

			Debug.Leave();

			return cache;
		}
	}

	[XmlRoot( "findChangeRecordCache" )]
	public class FindChangeRecordsHelper
	{
		public FindChangeRecordsHelper()
		{

		}

		[ XmlAttribute( "startUSN" ) ]
		protected long StartUSN;
		
		[ XmlAttribute( "endUSN" ) ]
		protected long EndUSN;

		[ XmlAttribute( "maxRows" ) ]
		protected long MaxRows;
		
		[ XmlAttribute( "operatorID" ) ]
		protected string OperatorNodeID;

		private FindFilterCollection filters;
		[ XmlArray( "filters" ), XmlArrayItem( "filter" ) ]
		public FindFilterCollection Filters
		{
			get{ return filters; }
			set{ filters=(FindFilterCollection)value; }
		}	
		
		public ChangeRecordCollection GetChangeRecords( )
		{
			ChangeRecordCollection crc = new ChangeRecordCollection();
			
			

			return crc;
		}
	}
	[ XmlRoot( "filters" ) ]
	public class FindFilterCollection : CollectionBase
	{
		public FindFilter this[ int index ]
		{
			get{ return (FindFilter)this.List[ index ]; }
			set{ this.List[ index] = value; }
		}

		public FindFilter Add( string field, FilterOperator oper, string val )
		{
			return this.Add(	field, 
				oper, 
				val,
				( (this.Count > 0) ? FilterConjuctionOperator.And : FilterConjuctionOperator.None )  );
		}
		public FindFilter Add( string field, FilterOperator oper, string val, FilterConjuctionOperator conj )
		{
			return this.Add( new FindFilter( field,oper, val, conj ) );
		}
		public FindFilter Add( FindFilter filter )
		{
			this.List.Add( filter );
			return filter;
		}
		public void Remove( int index )
		{
			this.List.RemoveAt( index );
		}
		public void Remove( FindFilter filter )
		{
			this.List.Remove( filter );
		}
		public FindFilter Insert( int index, FindFilter filter )
		{
			this.List.Insert( index, filter );
			return filter;
		}

		public string GetFullFilterString()
		{
			string fullstring = "";
			foreach( FindFilter filter in this )
			{
				fullstring += filter.GetFilterString();
			}
			return fullstring;
		}

	}

	[ XmlRoot( "filter" ) ]
	public class FindFilter
	{
		public FindFilter( string field, FilterOperator oper, string val, FilterConjuctionOperator conj  )
		{
			this.fieldname = field;
			this.filteroperator = oper;
			this.filtervalue = val;
			this.conjuction = conj;
		}

		[ XmlAttribute( "conjuction" ) ]
		protected FilterConjuctionOperator conjuction;
		public FilterConjuctionOperator Conjuction
		{
			get{ return conjuction; }	
		}

		[ XmlAttribute( "fieldName" ) ]
		protected string fieldname;
		public string FieldName
		{
			get{ return fieldname; }
			
		}
		
		[ XmlAttribute( "operator" ) ]
		protected FilterOperator filteroperator;
		public FilterOperator Operator
		{
			get{ return filteroperator; }
			
		}

		[ XmlText ]
		protected string filtervalue; 
		public string FilterValue
		{
			get{ return filtervalue; }
			
		}


		protected bool Validate()
		{
			return (	IsValidFieldName() && 
				IsValidOperator() && 
				IsValidValue() );
		}

		bool IsValidOperator()
		{
			return true;
		}
		bool IsValidValue()
		{
			return true;
		}
		bool IsValidFieldName()
		{
			return true;
		}

		//
		// TODO:	Maybe make this a readonly property instead 
		//			and genarte the this string in the ctor.
		//
		public string GetFilterString()
		{
			string filter = "";
			
			if( Validate() )
			{
				//
				//if it is a valid filter, then fill the string.
				//

				//set the fielname
				filter = this.FieldName + " ";

				//set the operator
				filter+=GetFilterOperatorString();
				

				//set the value
				filter += GetFilterValueString(); 


				//set the conjuction operator
				filter += GetFilterConjuctionString();
			}
			
			return filter;
		}
		protected string GetFilterConjuctionString()
		{
			string conj = "";
			
			switch( this.Conjuction )
			{
				case FilterConjuctionOperator.And:
					conj = " AND ";
					break;

				case FilterConjuctionOperator.AndNot:
					conj = " AND NOT ";
					break;

				case FilterConjuctionOperator.Or:
					conj = " OR ";
					break;

				case FilterConjuctionOperator.OrNot:
					conj = " OR NOT ";
					break;
			}

			return conj;
		}
		protected string GetFilterValueString()
		{
			string val = "'";
			if( FilterOperator.Contains==this.Operator )
			{
				val += "*" + this.FilterValue + "*";
			}
			else
			{
				val += this.FilterValue ;
			}
			val += "'";

			return val;
		}
		protected string GetFilterOperatorString()
		{
			switch( this.Operator )
			{
				case FilterOperator.EqualTo:
					return " = ";
				
				case FilterOperator.NotEqualTo:
					return " <> ";
				
				case FilterOperator.LessThan:
					return " < ";
				
				case FilterOperator.GreaterThan:
					return " > ";
				
				case FilterOperator.Contains:
					
					return " LIKE ";

				default:
					return "";
			}
		}
	}
	
	public enum FilterOperator
	{
		[ XmlEnum( "equalTo" ) ]
		EqualTo,
		
		[ XmlEnum( "notEqualTo" ) ]
		NotEqualTo,

		[ XmlEnum( "greaterThan" ) ]
		GreaterThan,

		[ XmlEnum( "lessThan" ) ]
		LessThan,

		[ XmlEnum( "contains" ) ]
		Contains
	}
	public enum FilterConjuctionOperator
	{
		[ XmlEnum( "" ) ]
		None,

		[ XmlEnum( "and" ) ]
		And,

		[ XmlEnum( "andNot" ) ]
		AndNot,

		[ XmlEnum( "or" ) ]
		Or,

		[ XmlEnum( "orNot" ) ]
		OrNot
		
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\operatorweb\xmlviewer.cs ===
using System;

namespace UDDI.Web
{
	/// <summary>
	/// Summary description for xmlviewer.
	/// </summary>
	public class xmlviewer
	{
		public xmlviewer()
		{
			//
			// TODO: Add constructor logic here
			//
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\operatorweb\operator.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using UDDI;
using UDDI.Replication;
namespace UDDI.Web
{
	/// <summary>
	/// Summary description for operatorcontrols.
	/// </summary>
	public class OperatorHelper
	{
		public static OperatorNodeCollection GetOperators(  )
		{
			return GetOperators( false, -1 );
		}
		public static OperatorNodeCollection GetOperators( OperatorStatus status )
		{
			return GetOperators( true, (int)status );
		}
		protected static OperatorNodeCollection GetOperators( bool filter, int status )
		{
			OperatorNodeCollection operators = new OperatorNodeCollection();

			
			SqlStoredProcedureAccessor sp = null;
			SqlDataReaderAccessor data=null;
			try
			{
				sp = new SqlStoredProcedureAccessor( "UI_operatorsList_get" );
				if( filter && -1!=status )
				{
					sp.Parameters.Add( "@StatusID",SqlDbType.TinyInt );
					sp.Parameters.SetInt( "@StatusID", status );
				}
				data = sp.ExecuteReader();
				while( data.Read() )
				{
					operators.Add( data.GetString( "OperatorKey" ), (OperatorStatus)data.GetInt( "OperatorStatusID" ), data.GetString( "Name" ), data.GetString( "soapReplicationUrl" ) );				
				}
			}
			finally
			{
				if( null!=data )
					data.Close();
				
				if( null!=sp )
					sp.Close();
			}
			
			return operators;
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\operator\replication.cs ===
using System;
using System.Collections;
using System.Data;
using System.IO;
using System.Net;
using System.Security.Cryptography.X509Certificates;
using System.Text;
using System.Web.Services;
using System.Web.Services.Description;
using System.Web.Services.Protocols;
using System.Xml;
using System.Xml.Schema;
using System.Xml.Serialization;
using System.Data.SqlClient;

using UDDI;
using UDDI.API;
using UDDI.Diagnostics;

namespace UDDI.Replication
{
	/// ********************************************************************
	///   class ReplicationHelper
	/// --------------------------------------------------------------------
	///   <summary>
	///   </summary>
	/// ********************************************************************
	/// 
	public class ReplicationHelper
	{		
		private static OperatorNode LocalOperator = null;
		private static X509Certificate LocalCertificate = null;
		private static OperatorNodeCollection RemoteOperators = null;
		private static ChangeRecordVectorCollection ChangesAlreadySeen = null;		
		private static ReplicationSoapClient SoapClient = null;
		private static Hashtable NodeChangeRecordCounts = null;
		private static Hashtable SessionChangeRecordCounts = null;

		
		/// ****************************************************************
		///   private Initialize [static]
		/// ----------------------------------------------------------------
		///   <summary>
		///     Initializes replication variables.
		///   </summary>
		/// ****************************************************************
		///
		private static void Initialize()
		{
			Debug.Enter();
			Debug.VerifySetting( "OperatorKey" );
						
			//
			// Get information about the local operator node.
			//
			LocalOperator = new OperatorNode( Config.GetString( "OperatorKey" ) );
			LocalOperator.Get();
			
			//
			// Get the local certificate.
			//
			LocalCertificate = new X509Certificate( LocalOperator.Certificate );

			//
			// Get the list of operator nodes to which we can send 
			// get_changeRecords messages.  Remove ourself from the
			// list!
			//
			RemoteOperators = new OperatorNodeCollection();

			RemoteOperators.Get();
			RemoteOperators.Remove( LocalOperator.OperatorNodeID );

			//
			// Get a ChangesAlreadySeen list for each operator node (not
			// just the ones we are replicating with).
			//
			GetHighWaterMarks();

			//
			// Initialize our soap client.
			//
			string proxy = Config.GetString( "Proxy", null );

			SoapClient = new ReplicationSoapClient();
						
			SoapClient.ClientCertificates.Add( LocalCertificate );

			if( !Utility.StringEmpty( proxy ) )
				SoapClient.Proxy = new WebProxy( proxy, true );
			
			//
			// Setup the context for a replication session.
			//
			Context.ApiVersionMajor = 2;
			Context.ContextType = ContextType.Replication;
			Context.LogChangeRecords = false;

			//
			// Setup logging.
			//
			SessionChangeRecordCounts = new Hashtable();

			foreach( int payloadType in Enum.GetValues( typeof( ChangeRecordPayloadType ) ) )
			{
				SessionChangeRecordCounts[ payloadType ] = 0;
			}

			Debug.Leave();
		}

		private static void GetHighWaterMarks()
		{			
			try
			{
				GetHighWaterMarks getHighWaterMarks = new GetHighWaterMarks();

				HighWaterMarkDetail detail = getHighWaterMarks.Get();
				ChangesAlreadySeen = detail.HighWaterMarks;
			}
			catch( Exception e )
			{
#if never
				Debug.OperatorMessage(
					SeverityType.Error,
					CategoryType.Replication,
					OperatorMessageType.CannotRetrieveHighWaterMarks,
					"Could not retrive high water marks for operator nodes.\r\n\r\nDetail:\r\n" + e.ToString() );
#endif				
				Debug.OperatorMessage(
					SeverityType.Error,
					CategoryType.Replication,
					OperatorMessageType.CannotRetrieveHighWaterMarks,
					new UDDIText( "UDDI_ERROR_REPLICATION_HIGHWATER_MARKS", e.ToString() ).GetText() );

				throw new UDDIException( ErrorType.E_fatalError, "UDDI_ERROR_REPLICATION_HIGHWATER_MARKS", e );
			}
		}

		/// ****************************************************************
		///   public Replicate [static]
		/// ----------------------------------------------------------------
		///   <summary>
		///   </summary>
		/// ****************************************************************
		///
		public static void Replicate()
		{
			//
			// Initialize the replication session.
			//
			Initialize();

			//
			// Verify that we do in fact have operators to replicate
			// with.
			//
			if( RemoteOperators.Count < 1 )
			{
#if never
				Debug.OperatorMessage(
					SeverityType.Info,
					CategoryType.Replication,
					OperatorMessageType.NoReplicationOperators,
					"There are no operators to replicate with.  Please check the replication configuration." );
#endif
				Debug.OperatorMessage(
					SeverityType.Info,
					CategoryType.Replication,
					OperatorMessageType.NoReplicationOperators,
					new UDDIText( "UDDI_ERROR_REPLICATION_NO_OPERATORS" ).GetText() );

				return;
			}

			//
			// TODO: Get the node id of the last operator we replicated
			// with.
			//

			//
			// TODO: Re-order the operator node list so that we replicate
			// in a round-robin fashion.
			//


			//
			// Create the start replication session log entry.
			//
			LogSessionStart();

			//
			// Replicate with each operator node.
			//
			foreach( OperatorNode remoteNode in RemoteOperators )
			{
				ReplicationResult result = null;

				//
				// Log the node replication start.
				//
				LogOperatorStart( remoteNode );
				
				//
				// Get the branch list for the node.  The branch list is
				// the remote node itself, plus any alternatives that we
				// may try if we have trouble communicating with the first
				// node.  For now, we don't support alternate nodes, so
				// the remote node is the only node we add to this list.
				//
				OperatorNodeCollection branchNodes = new OperatorNodeCollection();

				branchNodes.Add( remoteNode );

				foreach( OperatorNode branchNode in branchNodes )
				{
					//
					// Get the last replication status for this node.
					//
					result = ReplicateWithNode( branchNode );
						
					if( ReplicationStatus.Success == result.ReplicationStatus )
						break;
					
					//
					// Determine what we should do based on this attempts result
					// and the result of the last replication cycle with this
					// node.  TODO: if it is a communication error, we'll need
					// to try alternate edges.  This is reserved until alternate
					// edges are actually used.
					//
				}
				
				//
				// Log the node replication end.
				//
				LogOperatorEnd( remoteNode, result );
			}

			//
			// Create the end replication session log entry.
			//
			LogSessionEnd();
			
			Debug.Leave();
		}

		
		/// ****************************************************************
		///   public ReplicateWithNode [static]
		/// ----------------------------------------------------------------
		///   <summary>
		///   </summary>
		/// ****************************************************************
		///
		public static ReplicationResult ReplicateWithNode( string operatorNodeID )
		{
			OperatorNode remoteNode = null;

			//
			// Initialize the replication session.
			//
			Initialize();

			//
			// Replicate with the specified node.
			//
			try
			{
				remoteNode = new OperatorNode( operatorNodeID );
				remoteNode.Get();
			}
			catch( Exception e )
			{
#if never
				string message = String.Format(
						"Could not get details for operator {{{0}}}.\r\n\r\nDetails:\r\n{1}",
						operatorNodeID,
						e.ToString() );

				Debug.OperatorMessage(
					SeverityType.Error,
					CategoryType.Replication,
					OperatorMessageType.UnknownOperator,
					message );

				throw new Exception( message, e );
#endif			
				UDDIText uddiText = new UDDIText( "UDDI_ERROR_REPLICATION_OPERATOR_DETAILS", operatorNodeID, e.ToString() );

				Debug.OperatorMessage(
					SeverityType.Error,
					CategoryType.Replication,
					OperatorMessageType.UnknownOperator,
					uddiText.GetText() );

				throw new UDDIException( ErrorType.E_fatalError, uddiText.GetText() );
 			}
			
			//
			// Log the node replication start.
			//
			LogOperatorStart( remoteNode );

			//
			// Replicate
			//
			ReplicationResult result = ReplicateWithNode( remoteNode );

			//
			// Log the node replication end.
			//
			LogOperatorEnd( remoteNode, result );

			return result;
		}


		/// ****************************************************************
		///   private ReplicateWithNode [static]
		/// ----------------------------------------------------------------
		///   <summary>
		///   </summary>
		/// ****************************************************************
		///
		private static ReplicationResult ReplicateWithNode( OperatorNode remoteNode )
		{
			//
			// Retrieve the change records from the remote node and process
			// them.
			//
			ChangeRecordCollection changeRecords = null;
			
			//
			// Keep track of the number of times we call GetChangeRecords on each operator.  We 
			// don't want to be in a situation where we call them infinitely if they keep updating
			// their data.
			//
			int maxIterations = Config.GetInt( "Replication.MaxGetChangeIterations", 100 );
			int iterations = 0;

			//
			// Keep getting change records until there are no more; we need to do this because some 
			// operators will limit the number of change records that they send back.
			//
			do
			{			
				try
				{
					changeRecords = GetChangeRecords( remoteNode );
				}				
				catch( Exception e )
				{
					return ReplicationResult.LogCommunicationError( remoteNode, e, ChangesAlreadySeen );
				}

				foreach( ChangeRecord changeRecord in changeRecords )
				{
					//
					// Make sure we haven't seen this change record before.
					//
					if( ChangesAlreadySeen.IsProcessed( changeRecord.ChangeID ) )
					{
						Debug.Write(
							SeverityType.Info,
							CategoryType.Replication,
							String.Format(
							"Change already seen.\r\nSkipping record {0}:{1} retrieved from node {2}",
							changeRecord.ChangeID.NodeID,
							changeRecord.ChangeID.OriginatingUSN,
							remoteNode.OperatorNodeID ) );

						continue;
					}

					//
					// Make sure we aren't trying to replicate one of our own
					// change records.
					//
					if( 0 == String.Compare( changeRecord.ChangeID.NodeID, LocalOperator.OperatorNodeID, true ) )
					{
						Debug.Write(
							SeverityType.Info,
							CategoryType.Replication,
							String.Format(
							"Skipping replication of local change record.\r\nSkipping record {0}:{1} retrieved from node {2}",
							changeRecord.ChangeID.NodeID,
							changeRecord.ChangeID.OriginatingUSN,
							remoteNode.OperatorNodeID ) );

						continue;
					}
							
					//
					// Begin a transaction.
					//
					ConnectionManager.BeginTransaction();

					try
					{
						//
						// Set user context information and process the 
						// change record.
						//
						Context.User.ID = changeRecord.ChangeID.NodeID;
						Context.TimeStamp = DateTime.Now;
							
						//
						// Validate the change record, then process it.  There is a very good
						// reason for doing this validation on a change record by change record
						// basis: if there is one error in the incoming change record stream,
						// we would reject the entire stream, not just the errant change record.
						//
						SchemaCollection.Validate( changeRecord );
					
						try
						{
							changeRecord.Process();
						}
						catch( Exception innerException )
						{
							//
							// Exceptions that are related to IN 60 are ignored.
							//
							if( Context.ExceptionSource == ExceptionSource.PublisherAssertion ||
								Context.ExceptionSource == ExceptionSource.BrokenServiceProjection )
							{								
								//
								// Log the error
								//
								ReplicationResult.LogInvalidKeyWarning( remoteNode, changeRecord, innerException );
							}
							else
							{
								//
								// Otherwise, throw the exception for real.
								//
								throw innerException;
							}
						}
				
						//
						// Commit the transaction.
						//
						ConnectionManager.Commit();

						//
						// Update our changeAlreadySeen vector for the
						// originating node.
						//
						ChangesAlreadySeen.MarkAsProcessed( changeRecord.ChangeID );

						//
						// Update log counts.
						//
						LogCounts( changeRecord );
					}
					catch( Exception e )
					{
						ConnectionManager.Abort();
								
						return ReplicationResult.LogValidationError( remoteNode, changeRecord, e, ChangesAlreadySeen );
					}
				}
				
				//
				// Refresh our highwater mark vector.  We do this instead of calling gethighwatermarks on the 
				// operator because hitting our DB is faster then making the SOAP call across HTTP.
				//
				GetHighWaterMarks();			
	
				iterations++;

			}while( 0 != changeRecords.Count && iterations < maxIterations );
			
			//
			// Log success!
			//
			return ReplicationResult.LogSuccess( remoteNode, null );
		}		

		/// ****************************************************************
		///   private GetChangeRecords [static]
		/// ----------------------------------------------------------------
		///   <summary>
		///   </summary>
		/// ****************************************************************
		///
		private static ChangeRecordCollection GetChangeRecords( OperatorNode remoteNode )
		{
			GetChangeRecords getChangeRecords = new GetChangeRecords();

			getChangeRecords.RequestingNode = LocalOperator.OperatorNodeID;
			getChangeRecords.ChangesAlreadySeen = ChangesAlreadySeen;
						
			SoapClient.Url = remoteNode.SoapReplicationURL;
			
			ChangeRecordDetail detail = SoapClient.GetChangeRecords( getChangeRecords );

			return detail.ChangeRecords;
		}
		
		
		/// ****************************************************************
		///   private LogSessionStart [static]
		/// ----------------------------------------------------------------
		///   <summary>
		///   </summary>
		/// ****************************************************************
		///
		private static void LogSessionStart()
		{
			StringWriter log = new StringWriter();
			
			try
			{
			//	log.WriteLine( "Replication cycle started." );
				log.WriteLine( new UDDIText( "UDDI_MSG_REPLICATION_START" ).GetText() );

				log.WriteLine();
			//	log.WriteLine( "REPLICATION NODES:" );
				log.WriteLine( new UDDIText( "UDDI_MSG_REPLICATION_NODES" ).GetText() );

				foreach( OperatorNode operatorNode in RemoteOperators )
				{
					log.Write( "    " );
					log.WriteLine( operatorNode.Name );
					log.Write( "    {" );
					log.Write( operatorNode.OperatorNodeID );
					log.WriteLine( "}" );
					log.Write( "    " );
					log.WriteLine( operatorNode.SoapReplicationURL );
					log.WriteLine();
				}
				
//				log.WriteLine( "CURRENT HIGHWATER MARKS:" );
				log.WriteLine( new UDDIText( "UDDI_MSG_REPLICATION_CURRENT_HIGHWATER_MARKS" ).GetText() );

				foreach( ChangeRecordVector vector in ChangesAlreadySeen )
				{
					log.Write( "    {" );
					log.Write( vector.NodeID );
					log.Write( "} : " );
					log.WriteLine( vector.OriginatingUSN );
				}

				Debug.OperatorMessage(
					SeverityType.Info,
					CategoryType.Replication,
					OperatorMessageType.StartingReplicationSession,
					log.ToString() );
			}
			finally
			{
				log.Close();
			}
		}

		
		/// ****************************************************************
		///   private LogOperatorStart [static]
		/// ----------------------------------------------------------------
		///   <summary>
		///   </summary>
		/// ****************************************************************
		///
		private static void LogOperatorStart( OperatorNode remoteNode )
		{
			NodeChangeRecordCounts = new Hashtable();
		
			foreach( int payloadType in Enum.GetValues( typeof( ChangeRecordPayloadType ) ) )
			{
				NodeChangeRecordCounts[ payloadType ] = 0;
			}
			
			StringWriter log = new StringWriter();
			
			try
			{				
				// log.WriteLine( "Starting replication with node.\r\n" );
				log.WriteLine( new UDDIText( "UDDI_MSG_REPLICATION_NODE_START" ).GetText() );

				// log.WriteLine( "REPLICATION NODE:" );
				log.WriteLine( new UDDIText( "UDDI_MSG_REPLICATION_NODE" ).GetText() );

				log.Write( "    " );
				log.WriteLine( remoteNode.Name );
				log.Write( "    {" );
				log.Write( remoteNode.OperatorNodeID );
				log.WriteLine( "}" );
				log.Write( "    " );
				log.WriteLine( remoteNode.SoapReplicationURL );
				log.WriteLine();

				// log.WriteLine( "CURRENT HIGHWATER MARKS:" );
				log.WriteLine( new UDDIText( "UDDI_MSG_REPLICATION_CURRENT_HIGHWATER_MARKS" ).GetText() );

				foreach( ChangeRecordVector vector in ChangesAlreadySeen )
				{
					log.Write( "    {" );
					log.Write( vector.NodeID );
					log.Write( "} : " );
					log.WriteLine( vector.OriginatingUSN );
				}

				Debug.OperatorMessage(
					SeverityType.Info,
					CategoryType.Replication,
					OperatorMessageType.StartingReplicationWithNode,
					log.ToString() );
			}
			finally
			{
				log.Close();
			}		
		}


		/// ****************************************************************
		///   private LogOperatorEnd [static]
		/// ----------------------------------------------------------------
		///   <summary>
		///   </summary>
		/// ****************************************************************
		///
		private static void LogOperatorEnd( OperatorNode remoteNode, ReplicationResult result )
		{
			StringWriter log = new StringWriter();
			
			try
			{
				if( ReplicationStatus.Success == result.ReplicationStatus )
				{
				//	log.WriteLine( "Replication with node complete." );
					log.WriteLine( new UDDIText( "UDDI_MSG_REPLICATION_COMPLETE" ).GetText() );
				}
				else
				{
				//	log.Write( "Replication with node interrupted\r\n    ERROR: " );
					log.Write( new UDDIText( "UDDI_MSG_REPLICATION_INTERRUPTED" ).GetText() );

					log.WriteLine( result.ReplicationStatus.ToString() );
				}

				log.WriteLine();
				
				// log.WriteLine( "REPLICATION NODE:" );
				log.WriteLine( new UDDIText( "UDDI_MSG_REPLICATION_NODE" ).GetText() );

				log.Write( "    " );
				log.WriteLine( remoteNode.Name );
				log.Write( "    {" );
				log.Write( remoteNode.OperatorNodeID );
				log.WriteLine( "}" );
				log.Write( "    " );
				log.WriteLine( remoteNode.SoapReplicationURL );
				log.WriteLine();

				// log.WriteLine( "CHANGE RECORDS PROCESSED:" );
				log.WriteLine( new UDDIText( "UDDI_MSG_REPLICATION_CHANGE_RECORDS_PROCESSED" ).GetText() );

				foreach( int payloadType in Enum.GetValues( typeof( ChangeRecordPayloadType ) ) )
				{
					string name = Enum.GetName( typeof( ChangeRecordPayloadType ), payloadType ) + ":";

					log.Write( "    " );
					log.Write( name.PadRight( 30 ) );
					log.Write( "\t" );
					log.WriteLine( NodeChangeRecordCounts[ payloadType ] );
				}

				log.WriteLine();
				//log.WriteLine( "NEW HIGHWATER MARKS:" );		
				log.WriteLine( new UDDIText( "UDDI_MSG_REPLICATION_NEW_HIGHWATER_MARKS" ).GetText() );		

				foreach( ChangeRecordVector vector in ChangesAlreadySeen )
				{					
					log.Write( "    {" );
					log.Write( vector.NodeID );
					log.Write( "} : " );
					log.WriteLine( vector.OriginatingUSN );
				}

				SeverityType severity = SeverityType.Info;

				if( ReplicationStatus.Success != result.ReplicationStatus )
					severity = SeverityType.Error;

				string message = log.ToString();

				//
				// Log results
				//
				Debug.OperatorMessage(
					severity,
					CategoryType.Replication,
					OperatorMessageType.EndingReplicationWithNode,
					message );

				//
				// Only send mail on success; if there was a failure, mail will be sent at the point of failure.
				//
				if( ReplicationStatus.Success == result.ReplicationStatus )
				{
					Debug.OperatorMail(
						SeverityType.None,
						CategoryType.Replication,
						OperatorMessageType.EndingReplicationWithNode,
						message );
				}
			}
			finally
			{
				log.Close();
			}

			//
			// Add the operator node counts to the totals.
			//
			foreach( int payloadType in Enum.GetValues( typeof( ChangeRecordPayloadType ) ) )
			{
				SessionChangeRecordCounts[ payloadType ] = (int)SessionChangeRecordCounts[ payloadType ] + (int)NodeChangeRecordCounts[ payloadType ];
			}
		}

		/// ****************************************************************
		///   private LogSessionEnd [static]
		/// ----------------------------------------------------------------
		///   <summary>
		///   </summary>
		/// ****************************************************************
		///
		private static void LogSessionEnd()
		{
			StringWriter log = new StringWriter();
			
			try
			{
			//	log.WriteLine( "Replication cycle complete." );
				log.WriteLine( new UDDIText( "UDDI_MSG_REPLICATION_END" ).GetText() );

				log.WriteLine();
				
				//log.WriteLine( "CHANGE RECORDS PROCESSED:" );
				log.WriteLine( new UDDIText( "UDDI_MSG_REPLICATION_CHANGERECORDS_PROCESSED" ).GetText() );

				foreach( int payloadType in Enum.GetValues( typeof( ChangeRecordPayloadType ) ) )
				{
					string name = Enum.GetName( typeof( ChangeRecordPayloadType ), payloadType ) + ":";

					log.Write( "    " );
					log.Write( name.PadRight( 30 ) );
					log.Write( "\t" );
					log.WriteLine( SessionChangeRecordCounts[ payloadType ] );
				}

				log.WriteLine();
				// log.WriteLine( "NEW HIGHWATER MARKS:" );
				log.WriteLine( new UDDIText( "UDDI_MSG_REPLICATION_NEW_HIGHWATER_MARKS" ).GetText() );

				foreach( ChangeRecordVector vector in ChangesAlreadySeen )
				{
					log.Write( "    {" );
					log.Write( vector.NodeID );
					log.Write( "} : " );
					log.WriteLine( vector.OriginatingUSN );
				}

				Debug.OperatorMessage(
					SeverityType.Info,
					CategoryType.Replication,
					OperatorMessageType.EndingReplicationWithNode,
					log.ToString() );
			}
			finally
			{
				log.Close();
			}
		}

		/// ****************************************************************
		///   private LogCounts [static]
		/// ----------------------------------------------------------------
		///   <summary>
		///   </summary>
		/// ****************************************************************
		///
		private static void LogCounts( ChangeRecord changeRecord )
		{
			int payloadType = (int)changeRecord.Payload.ChangeRecordPayloadType;
							
			NodeChangeRecordCounts[ payloadType ] = (int)NodeChangeRecordCounts[ payloadType ] + 1;
		}		
	}

	/// ********************************************************************
	///   class ReplicationResult
	/// --------------------------------------------------------------------
	///   <summary>
	///   </summary>
	/// ********************************************************************
	/// 
	public class ReplicationResult
	{
		public UDDI.Replication.ReplicationStatus ReplicationStatus;
		public string OperatorNodeID;
		public string Description;
		public string LastNodeID;
		public long LastUSN;
		public long LastChange;

		
		/// ****************************************************************
		///   public GetLast
		/// ----------------------------------------------------------------
		///   <summary>
		///   </summary>
		/// ****************************************************************
		///
		public void GetLast( string operatorNodeID, bool inboundStatus )
		{
			Debug.Enter();

			SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor();

			sp.ProcedureName = "net_operatorLogLast_get";

			sp.Parameters.Add( "@operatorKey", SqlDbType.UniqueIdentifier );
			sp.Parameters.Add( "@inboundStatus", SqlDbType.Bit );
			sp.Parameters.Add( "@replStatusID", SqlDbType.TinyInt, ParameterDirection.Output );
			sp.Parameters.Add( "@description", SqlDbType.NVarChar, UDDI.Constants.Lengths.Description, ParameterDirection.Output );
			sp.Parameters.Add( "@lastOperatorKey", SqlDbType.UniqueIdentifier, ParameterDirection.Output );
			sp.Parameters.Add( "@lastUSN", SqlDbType.BigInt, ParameterDirection.Output );		
			sp.Parameters.Add( "@lastChange", SqlDbType.BigInt, ParameterDirection.Output );

			sp.Parameters.SetGuidFromString( "@operatorKey", operatorNodeID );
			sp.Parameters.SetBool( "@inboundStatus", inboundStatus );
			
			sp.ExecuteNonQuery();

			this.OperatorNodeID = operatorNodeID;
			this.ReplicationStatus = (ReplicationStatus)sp.Parameters.GetShort( "@replStatusID" );
			this.Description = sp.Parameters.GetString( "@description" );
			this.LastNodeID = sp.Parameters.GetGuidString( "@lastOperatorKey" );
			this.LastUSN = sp.Parameters.GetLong( "@lastUSN" );
			this.LastChange = sp.Parameters.GetLong( "@lastChange" );

			Debug.Leave();
		}

		
		/// ****************************************************************
		///   public Save
		/// ----------------------------------------------------------------
		///   <summary>
		///   </summary>
		/// ****************************************************************
		///
		public void Save()
		{
			Debug.Enter();

			try
			{
				SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor();

				sp.ProcedureName = "net_operatorLog_save";

				sp.Parameters.Add( "@operatorKey", SqlDbType.UniqueIdentifier );
				sp.Parameters.Add( "@replStatusID", SqlDbType.TinyInt );
				sp.Parameters.Add( "@description", SqlDbType.NVarChar, UDDI.Constants.Lengths.Description );
				sp.Parameters.Add( "@lastOperatorKey", SqlDbType.UniqueIdentifier );
				sp.Parameters.Add( "@lastUSN", SqlDbType.BigInt );
				sp.Parameters.Add( "@lastChange", SqlDbType.BigInt );

				sp.Parameters.SetGuidFromString( "@operatorKey", OperatorNodeID );
				sp.Parameters.SetShort( "@replStatusID", (short)ReplicationStatus );
				sp.Parameters.SetString( "@description", Description );
				sp.Parameters.SetGuidFromString( "@lastOperatorKey", LastNodeID );
				sp.Parameters.SetLong( "@lastUSN", LastUSN );
				sp.Parameters.SetLong( "@lastChange", LastChange );
	
				sp.ExecuteNonQuery();
			}
			catch
			{
#if never
				Debug.OperatorMessage(
					SeverityType.Error,
					CategoryType.Replication,
					OperatorMessageType.ValidationError,
					String.Format(
						"Could not store last replication result.\r\n\r\n" +
						"REPLICATION NODE:\r\n" + 
						"    {{{0}}}\r\n\r\n" +
						"CHANGE RECORD:\r\n" +
						"	 {{{1}}} : {2}",
						OperatorNodeID,
						LastNodeID,
						LastUSN ) );
#endif
				Debug.OperatorMessage(
					SeverityType.Error,
					CategoryType.Replication,
					OperatorMessageType.ValidationError,
					new UDDIText( "UDDI_ERROR_REPLICATION_COULD_NOT_STORE_RESULT", OperatorNodeID, LastNodeID, LastUSN ).GetText() );
			}

			Debug.Leave();
		}

		
		/// ****************************************************************
		///   public LogSuccess [static]
		/// ----------------------------------------------------------------
		///   <summary>
		///   </summary>
		/// ****************************************************************
		///
		public static ReplicationResult LogSuccess( OperatorNode remoteNode, string description )
		{
			ReplicationResult result = new ReplicationResult();

			result.ReplicationStatus = ReplicationStatus.Success;
			result.Description = description;
			result.OperatorNodeID = remoteNode.OperatorNodeID;
			result.LastNodeID = null;
			result.LastUSN = 0;
			result.LastChange = DateTime.UtcNow.Ticks;

			result.Save();

			return result;
		}

		
		/// ****************************************************************
		///   public LogCommunicationError [static]
		/// ----------------------------------------------------------------
		///   <summary>
		///   </summary>
		/// ****************************************************************
		///
		public static ReplicationResult LogCommunicationError( OperatorNode remoteNode, Exception e, ChangeRecordVectorCollection changesAlreadySeen )
		{
			ReplicationResult result = new ReplicationResult();

			result.ReplicationStatus = ReplicationStatus.CommunicationError;
			result.Description = e.ToString();
			result.OperatorNodeID = remoteNode.OperatorNodeID;
			result.LastNodeID = null;
			result.LastUSN = 0;
			result.LastChange = DateTime.UtcNow.Ticks;

			result.Save();

			string response = e.ToString();

			if( e is WebException )
			{
				WebException we = (WebException)e;
								
				if( null != we.Response )
				{
					StreamReader reader = null;

					try
					{
						reader = new StreamReader( we.Response.GetResponseStream() );
				
						response += "\r\nRESPONSE:\r\n\r\n";
						response += reader.ReadToEnd();
					}
					catch
					{
					}
					finally
					{
						if( null != reader )
							reader.Close();
					}
				}
			}
			else if( e is SoapException )
			{
				SoapException se = (SoapException)e;

				if( null != se.Detail )
				{
					response += "\r\nSOAP FAULT DETAILS:\r\n\r\n";
					response += se.Detail.OuterXml;
				}
			}

			//
			// Also send the highwater marks.
			//
			StringWriter highWaterMarks = new StringWriter();
					
			foreach( ChangeRecordVector vector in changesAlreadySeen )
			{
				highWaterMarks.Write( "    {" );
				highWaterMarks.Write( vector.NodeID );
				highWaterMarks.Write( "} : " );
				highWaterMarks.WriteLine( vector.OriginatingUSN );
			}
#if never
			//
			// Communications Error
			//
			string message = String.Format( 
				"Error communicating with operator.\r\n\r\n" +
					"REPLICATION NODE:\r\n" + 
					"    {0}\r\n" +
					"    {{{1}}}\r\n" + 
					"    {2}\r\n\r\n" + 
					"DETAILS:\r\n\r\n{3}\r\n\r\nCURRENT HIGHWATER MARKS:\r\n\r\n{4}",
				remoteNode.Name,
				remoteNode.OperatorNodeID,
				remoteNode.SoapReplicationURL,
				response, 
				highWaterMarks.ToString() );
#endif					
			//
			// Communications Error
			//
			UDDIText message = new UDDIText( "UDDI_ERROR_REPLICATION_OPERATOR_COMMUNICATION_ERROR", 
											 remoteNode.Name,
											 remoteNode.OperatorNodeID,
											 remoteNode.SoapReplicationURL,
											 response, 
											 highWaterMarks.ToString() );
			Debug.OperatorMessage(
				SeverityType.Error,
				CategoryType.Replication,
				OperatorMessageType.ErrorCommunicatingWithNode,
				message.GetText() );
					
			Debug.OperatorMail(
				SeverityType.Error,
				CategoryType.Replication,
				OperatorMessageType.ErrorCommunicatingWithNode,
				message.GetText() );
			
			return result;
		}

		
		/// ****************************************************************
		///   public LogValidationError [static]
		/// ----------------------------------------------------------------
		///   <summary>
		///   </summary>
		/// ****************************************************************
		///
		public static ReplicationResult LogValidationError( OperatorNode remoteNode, ChangeRecord changeRecord, Exception e, ChangeRecordVectorCollection changesAlreadySeen )
		{
			ReplicationResult result = new ReplicationResult();

			result.ReplicationStatus = ReplicationStatus.ValidationError;
			result.Description = e.ToString();
			result.OperatorNodeID = remoteNode.OperatorNodeID;
			result.LastNodeID = changeRecord.ChangeID.NodeID;
			result.LastUSN = changeRecord.ChangeID.OriginatingUSN;
			result.LastChange = DateTime.UtcNow.Ticks;

			result.Save();
			
			//
			// Also send the highwater marks.
			//
			StringWriter highWaterMarks = new StringWriter();
					
			foreach( ChangeRecordVector vector in changesAlreadySeen )
			{
				highWaterMarks.Write( "    {" );
				highWaterMarks.Write( vector.NodeID );
				highWaterMarks.Write( "} : " );
				highWaterMarks.WriteLine( vector.OriginatingUSN );
			}
#if never
			string message = String.Format(
				"Could not process entity from remote operator.\r\n\r\n" +
					"REPLICATION NODE:\r\n" + 
					"    {0}\r\n" + 
					"    {{{1}}}\r\n" + 
					"    {2}\r\n\r\n" + 
					"DETAILS:\r\n\r\n" +
					"{3}\r\n\r\n" + 
					"CHANGE RECORD:\r\n" +
					"    {{{4}}} : {5}\r\n\r\n" + 
					"{6}\r\n\r\nCURRENT HIGHWATER MARKS:\r\n\r\n{7}",
				remoteNode.Name,
				remoteNode.OperatorNodeID,
				remoteNode.SoapReplicationURL,
				e.ToString(),
				changeRecord.ChangeID.NodeID,
				changeRecord.ChangeID.OriginatingUSN,
				changeRecord.ToString(),
				highWaterMarks.ToString() );
#endif
			UDDIText message = new UDDIText( "UDDI_ERROR_REPLICATION_COULD_NOT_PROCESS_ENTITY", 
											  remoteNode.Name,
											  remoteNode.OperatorNodeID,
											  remoteNode.SoapReplicationURL,
											  e.ToString(),
											  changeRecord.ChangeID.NodeID,
											  changeRecord.ChangeID.OriginatingUSN,
											  changeRecord.ToString(),
											  highWaterMarks.ToString() );
			Debug.OperatorMessage(
				SeverityType.Error,
				CategoryType.Replication,
				OperatorMessageType.ValidationError,
				message.GetText() );
								
			Debug.OperatorMail(
				SeverityType.Error,
				CategoryType.Replication,
				OperatorMessageType.ValidationError,
				message.GetText() );

			return result;
		}

		public static void LogInvalidKeyWarning( OperatorNode remoteNode, ChangeRecord changeRecord, Exception e )
		{
			ReplicationResult result = new ReplicationResult();
			
			result.ReplicationStatus = ReplicationStatus.CommunicationError;
			result.Description = e.ToString();
			result.OperatorNodeID = remoteNode.OperatorNodeID;
			result.LastNodeID = changeRecord.ChangeID.NodeID;
			result.LastUSN = changeRecord.ChangeID.OriginatingUSN;
			result.LastChange = DateTime.UtcNow.Ticks;

			result.Save();
#if never
			string message = String.Format(
				"Invalid key from remote operator.\r\n\r\n" +
				"REPLICATION NODE:\r\n" + 
				"    {0}\r\n" + 
				"    {{{1}}}\r\n" + 
				"    {2}\r\n\r\n" + 
				"DETAILS:\r\n\r\n" +
				"{3}\r\n\r\n" + 
				"CHANGE RECORD:\r\n" +
				"    {{{4}}} : {5}\r\n\r\n" + 
				"{6}",
				remoteNode.Name,
				remoteNode.OperatorNodeID,
				remoteNode.SoapReplicationURL,
				e.ToString(),
				changeRecord.ChangeID.NodeID,
				changeRecord.ChangeID.OriginatingUSN,
				changeRecord.ToString() );
#endif
			UDDIText message = new UDDIText( "UDDI_ERROR_REPLICATION_INVALID_KEY", 
											 remoteNode.Name,
											 remoteNode.OperatorNodeID,
											 remoteNode.SoapReplicationURL,
											 e.ToString(),
											 changeRecord.ChangeID.NodeID,
											 changeRecord.ChangeID.OriginatingUSN,
											 changeRecord.ToString() );
			Debug.OperatorMessage(
				SeverityType.Warning,
				CategoryType.Replication,
				OperatorMessageType.InvalidKey, 
				message.GetText() );

			//
			// TODO for now don't send mail on a warning.
			//
#if never								
			Debug.OperatorMail(
				SeverityType.Error,
				CategoryType.Replication,
				OperatorMessageType.ValidationError,
				message );
#endif			
		}		
	}

	
	/// ********************************************************************
	///   class ReplicationSoapClient
	/// --------------------------------------------------------------------
	///   <summary>
	///   </summary>
	/// ********************************************************************
	/// 
	[ WebServiceBinding( Name="ExternalMessagesSoap", Namespace=UDDI.Replication.Constants.Namespace ) ]
	internal sealed class ReplicationSoapClient : SoapHttpClientProtocol
	{
		/// ****************************************************************
		///   public GetChangeRecords
		/// ----------------------------------------------------------------
		///   <summary>
		///   </summary>
		/// ****************************************************************
		///
		[ System.Diagnostics.DebuggerStepThrough ]
		[ SoapDocumentMethod( "", Use=SoapBindingUse.Literal, ParameterStyle=SoapParameterStyle.Bare ) ]
		[ return: XmlElement( "changeRecords", Namespace=UDDI.Replication.Constants.Namespace, IsNullable=false ) ]
		public ChangeRecordDetail GetChangeRecords( GetChangeRecords get_changeRecords )
		{
			object[] results = Invoke( "GetChangeRecords", new object[] { get_changeRecords } );
			return (ChangeRecordDetail)results[ 0 ];
		}
		
		protected override WebRequest GetWebRequest( Uri uri )
		{
			WebRequest		innerWebRequest = base.GetWebRequest( uri );
			UDDIWebRequest  webRequest		= new UDDIWebRequest( innerWebRequest );

			return webRequest;			
		}
	}

	/// <summary>
	/// UDDIWebResponse allows us to return our own Stream object.
	/// </summary>
	internal class UDDIWebResponse : WebResponse
	{
		WebResponse			innerWebResponse;
		UDDIResponseStream	uddiResponseStream;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="innerWebResponse">This object should come from the WebResponse created by HttpSoapClientProtocol.</param>		
		public UDDIWebResponse( WebResponse innerWebResponse )
		{
			this.innerWebResponse = innerWebResponse;		
		}

		/// <summary>
		/// Return our response stream (UDDIResponseStream) instead of the Stream associated with our inner response.
		/// </summary>
		/// <returns></returns>
		public override Stream GetResponseStream() 
		{
			if( null == uddiResponseStream )
			{
				uddiResponseStream = new UDDIResponseStream( innerWebResponse.GetResponseStream() );
			}			

			return uddiResponseStream;
		}		

		/// <summary>
		/// Delegates to the inner web response.
		/// </summary>
		public override void Close() 
		{
			innerWebResponse.Close();
		}
	
		/// <summary>
		/// Delegates to the inner web response.
		/// </summary>
		public override long ContentLength 
		{
			get { return innerWebResponse.ContentLength; }						
			set { innerWebResponse.ContentLength = value; }			
		}

		/// <summary>
		/// Delegates to the inner web response.
		/// </summary>
		public override string ContentType 
		{
			get { return innerWebResponse.ContentType; }			
			set { innerWebResponse.ContentType = value; }			
		}
	
		/// <summary>
		/// Delegates to the inner web response.
		/// </summary>
		public override Uri ResponseUri 
		{			
			get  { return innerWebResponse.ResponseUri; }
		}
	
		/// <summary>
		/// Delegates to the inner web response.
		/// </summary>
		public override WebHeaderCollection Headers 
		{			
			get { return innerWebResponse.Headers; }			
		}		
	}

	/// <summary>
	/// UDDIResponseStream allows us to manipulate the XML sent back from the web service.
	/// </summary>
	internal class UDDIResponseStream : MemoryStream
	{		
		//
		// TODO: at some point it may be necessary to pass in the current version as a parameter if the transforms become 
		// more complicated.
		//

		/// <summary>
		/// Constructor.  We read all the XML sent from the server, do our version manipulation, then write the new XML
		/// into our inner responseStream object.
		/// </summary>
		/// <param name="responseStream">This object should be the responseStream from a WebResponse object.</param>
		public UDDIResponseStream( Stream responseStream )
		{
			try
			{
				//
				// Get the XML the server sent to us.
				//
				StreamReader reader = new StreamReader( responseStream );
				string responseXml = reader.ReadToEnd();
				reader.Close();
							
				//
				// Write this transformed XML into ourselves.
				//
				StreamUtility.WriteStringToStream( this, responseXml );

				//
				// Rewind ourselves
				//
				this.Position = 0;

				//
				// Validate the incoming XML.  We have to read the data from the stream first because it is not seekable
				//
				try
				{
					SchemaCollection.Validate( this );
				}
				catch( XmlSchemaException schemaException )
				{
					string message = schemaException.ToString() + "\r\n\r\nResponse XML:\r\n\r\n" + responseXml;
					Debug.OperatorMessage( SeverityType.Error, CategoryType.Replication, OperatorMessageType.ValidationError, message ); 

					throw schemaException;
				}
			}
			finally
			{
				//
				// Rewind ourselves
				//
				this.Position = 0;
			}
		}					
	}
	
	/// <summary>
	///  UDDIWebRequest allows us to return our own request and response objects.
	/// </summary>
	/// <summary>
	///  UDDIWebRequest allows us to return our own request and response objects.
	/// </summary>
	internal class UDDIWebRequest : WebRequest
	{
		WebRequest			innerWebRequest;
		UDDIRequestStream	uddiRequestStream;
		UDDIWebResponse		uddiWebResponse;
		
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="uri">Uri to the web service we are calling</param>
		/// <param name="uddiVersion">UDDI version to use for requests</param>
		public UDDIWebRequest( WebRequest innerWebRequest )
		{
			this.innerWebRequest = innerWebRequest;
		}
		
		/// <summary>
		/// Return a UDDIRequestStream object instead of the default one.
		/// </summary>
		/// <returns>UDDIRequestStream object</returns>
		public override Stream GetRequestStream()
		{
			if( null == uddiRequestStream )
			{
				uddiRequestStream = new UDDIRequestStream( innerWebRequest.GetRequestStream() );
			}

			return uddiRequestStream;
		}	
		
		/// <summary>
		/// Return a UDDIWebRequest object instead of the default one.
		/// </summary>
		/// <returns>UDDIWebResponse object</returns>
		public override WebResponse GetResponse() 
		{
			if( null == uddiWebResponse )
			{
				uddiWebResponse = new UDDIWebResponse( innerWebRequest.GetResponse() );
			}		
			return uddiWebResponse;
		}

		/// <summary>
		/// Delegates to our inner WebRequest
		/// </summary>
		public override string Method 
		{
			get { return innerWebRequest.Method; }
			set { innerWebRequest.Method = value; }
		}
		
		/// <summary>
		/// Delegates to our inner WebRequest
		/// </summary>
		public override Uri RequestUri 
		{                              
			get { return innerWebRequest.RequestUri; }
		}

		/// <summary>
		/// Delegates to our inner WebRequest
		/// </summary>
		public override string ConnectionGroupName 
		{
			get { return innerWebRequest.ConnectionGroupName; }
			set { innerWebRequest.ConnectionGroupName = value; }
		}

		/// <summary>
		/// Delegates to our inner WebRequest
		/// </summary>
		public override WebHeaderCollection Headers 
		{            
			get { return innerWebRequest.Headers; }
			set { innerWebRequest.Headers = value; }				
		}

		/// <summary>
		/// Delegates to our inner WebRequest
		/// </summary>
		public override long ContentLength 
		{
			get { return innerWebRequest.ContentLength; }			
			set { innerWebRequest.ContentLength = value; }				
		}

		/// <summary>
		/// Delegates to our inner WebRequest
		/// </summary>
		public override string ContentType 
		{
			get { return innerWebRequest.ContentType; }				
			set { innerWebRequest.ContentType = value; }			
		}
		
		/// <summary>
		/// Delegates to our inner WebRequest
		/// </summary>
		public override ICredentials Credentials 
		{
			get { return innerWebRequest.Credentials; }			
			set { innerWebRequest.Credentials = value; }			
		}
		
		/// <summary>
		/// Delegates to our inner WebRequest
		/// </summary>
		public override IWebProxy Proxy 
		{
			get { return innerWebRequest.Proxy; }			
			set { innerWebRequest.Proxy = value; }
		}

		/// <summary>
		/// Delegates to our inner WebRequest
		/// </summary>
		public override bool PreAuthenticate 
		{
			get { return innerWebRequest.PreAuthenticate; }			
			set { innerWebRequest.PreAuthenticate = value; }			
		}

		/// <summary>
		/// Delegates to our inner WebRequest
		/// </summary>
		public override int Timeout 
		{
			get { return innerWebRequest.Timeout; }			
			set { innerWebRequest.Timeout = value; }			
		}

		/// <summary>
		/// Delegates to our inner WebRequest
		/// </summary>
		public override IAsyncResult BeginGetResponse(AsyncCallback callback, object state) 
		{	
			return innerWebRequest.BeginGetResponse( callback, state );			
		}

		/// <summary>
		/// Delegates to our inner WebRequest
		/// </summary>
		public override WebResponse EndGetResponse(IAsyncResult asyncResult) 
		{
			return innerWebRequest.EndGetResponse( asyncResult );			
		}
		
		/// <summary>
		/// Delegates to our inner WebRequest
		/// </summary>
		public override IAsyncResult BeginGetRequestStream(AsyncCallback callback, Object state) 
		{
			return innerWebRequest.BeginGetRequestStream( callback, state );			
		}
		
		/// <summary>
		/// Delegates to our inner WebRequest
		/// </summary>
		public override Stream EndGetRequestStream(IAsyncResult asyncResult) 
		{
			return innerWebRequest.EndGetRequestStream( asyncResult );			
		}
		
		/// <summary>
		/// Delegates to our inner WebRequest
		/// </summary>
		public override void Abort() 
		{
			innerWebRequest.Abort();			
		}
	}

	/// <summary>
	/// UDDIRequestStream allows us to manipulate the XML before we send it to the client.  This class will accept all data that
	/// is written to it from the ASP.NET web service framework.  When the framework closes the stream (ie. wants to send the data), we
	/// will manipulate this XML so that it has the right UDDI version, then send it out using our innerStream object.
	/// </summary>
	internal class UDDIRequestStream : MemoryStream
	{
		Stream innerStream;
		
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="innerStream">Should be from a WebRequest object.</param>
		/// <param name="uddiVersion">The UDD version we should use to send to the server</param>
		public UDDIRequestStream( Stream innerStream )
		{
			this.innerStream = innerStream;							
		}
				
		/// <summary>
		/// Before we actually close the request stream, we want to manipulate the XML.
		/// </summary>
		public override void Close()
		{
			try
			{
				//
				// Rewind ourselves.
				//
				this.Position = 0;

				//
				// Read the XML that was written; this is the XML request that will be sent to the UDDI server.
				//
				StreamReader reader = new StreamReader( this );
				string requestXml   = reader.ReadToEnd();

				//
				// Rewind ourselves.
				//
				this.Position = 0;

#if DEBUG
				try
				{
					//
					// Validate the XML that we are about to send.
					// 
					SchemaCollection.Validate( this );
				}
				catch( XmlSchemaException schemaException )
				{					
					string message = schemaException.ToString() + "\r\n\r\nRequest XML:\r\n\r\n" + requestXml;
					Debug.OperatorMessage( SeverityType.Error, CategoryType.Replication, OperatorMessageType.ValidationError, message ); 

					throw schemaException;
				}
#endif
				//
				// Write the transformed data to the 'real' stream.
				//
				StreamUtility.WriteStringToStream( innerStream, requestXml );				
			}
			finally
			{
				//
				// Make sure we clean up properly.
				//
				innerStream.Close();			
				base.Close();
			}
		}		
	}
	
	/// <summary>
	/// Simple utility class to help us write string data to Stream objects.
	/// </summary>
	internal sealed class StreamUtility
	{		
		public static void WriteStringToStream( Stream stream, string stringToWrite )
		{					
			StreamWriter writer = new StreamWriter( stream );
			writer.Write( stringToWrite );
			writer.Flush();			
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\resources\makefile.inc ===
#
# tell the system how to compile the .resx file
# $(O) resolves to the obj\i386 folder
#

uddi.resources: uddi.txt
    resgen uddi.txt $(O)\uddi.resources
    copy /Y $(O)\uddi.resources $(O)\uddi.loc.resources
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\replicate\assemblyinfo.cs ===
using System.Reflection;
using System.Security.Permissions;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("replicate.exe")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft Corporation")]
[assembly: AssemblyProduct("UDDI Services")]
[assembly: AssemblyCopyright("Copyright(c) 2002 Microsoft Corporation")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]
[assembly: PermissionSetAttribute(SecurityAction.RequestMinimum, Name = "FullTrust")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("")]
[assembly: AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\replicate\replicate.cs ===
using System;
using System.Security.Principal;
using System.Threading;
using System.Diagnostics;
using System.Runtime.InteropServices;

using UDDI;
using UDDI.Replication;

namespace UDDI.Tools
{	
	[ StructLayout( LayoutKind.Sequential ) ]
	internal class SECURITY_ATTRIBUTES 
	{ 
		public int		nLength; 
		public object	lpSecurityDescriptor; 
		public bool		bInheritHandle; 
	
		public SECURITY_ATTRIBUTES()
		{
			nLength = Marshal.SizeOf( typeof( SECURITY_ATTRIBUTES ) );
			lpSecurityDescriptor = null;
			bInheritHandle = false;
		}
	} 

	internal enum SystemErrorCodes
	{
		ERROR_SUCCESS		 = 0,
		ERROR_ALREADY_EXISTS = 183
	}

	//
	// TODO add more values as we need them 
	//
	internal enum FileHandleValues
	{
		INVALID_HANDLE_VALUE = -1
	}

	//
	// TODO add more values as we need them 
	//
	internal enum SharedFileProtection : byte
	{
		PAGE_READONLY = 0x02
	}

	internal class SharedMemory
	{
		int				hSharedMemory;
		const	int		INVALID_HANDLE_VALUE = -1;
		
		public bool Create( string name )
		{
			hSharedMemory = -1;
			bool success  = false;

			try
			{
				SECURITY_ATTRIBUTES securityAttributes = new SECURITY_ATTRIBUTES();
	
				hSharedMemory = CreateFileMapping( ( int )FileHandleValues.INVALID_HANDLE_VALUE, 
													securityAttributes, 
													( int )SharedFileProtection.PAGE_READONLY, 
													0, 
													1, 
													name );									

				if( ( int )SystemErrorCodes.ERROR_SUCCESS == GetLastError() )
				{
					success = true;
				}
			}
			catch
			{
				if( -1 != hSharedMemory )
				{
					CloseHandle( hSharedMemory );
				}
			}	
		
			return success;
		}

		public void Release()
		{
			if( -1 != hSharedMemory )
			{
				CloseHandle( hSharedMemory );
			}
		}

		[DllImport( "user32.dll", CharSet=CharSet.Auto )]
		private static extern int MessageBox(int hWnd, String text, String caption, uint type);

		[DllImport( "kernel32.dll", SetLastError=true )]
		private static extern int CreateFileMapping( int						hFile, 
													SECURITY_ATTRIBUTES		lpAttributes,
													int						flProtect,
													int						dwMaximumSizeHigh,
													int						dwMaximumSizeLow,
													string					lpName );

		[DllImport( "kernel32.dll" )]
		private static extern bool CloseHandle( int hObject );

		[DllImport( "kernel32.dll" )]
		private static extern int GetLastError();
	}

	public class ReplicationUtility
	{
		public static string OperatorKey = null;

		/// ****************************************************************
		///   public Main [static]
		/// ----------------------------------------------------------------	
		///   <summary>
		///     Program entry point.
		///   </summary>
		/// ----------------------------------------------------------------
		///   <param name="args">
		///     Command-line arguments.
		///   </param>
		/// ****************************************************************
		/// 
		public static void Main( string[] args )
		{
			//
			// Use shared memory to make sure that only 1 instance of this process is running.  sharedMemory.Release() MUST
			// be called when this process exits in order to free up the shared memory.
			//
			SharedMemory sharedMemory = new SharedMemory();

			try
			{
				Console.WriteLine( "Microsoft (R) UDDI Replication Utility" );
				Console.WriteLine( "Copyright (C) Microsoft Corp. 2002. All rights reserved." );
				Console.WriteLine();
				
				if( false == sharedMemory.Create( "UDDI_replication_process" ) )
				{
					Console.WriteLine( "Only 1 instance of this process can be running." );
					System.Environment.Exit( 1 );
				}
				
				WindowsIdentity identity = WindowsIdentity.GetCurrent();
				WindowsPrincipal principal = new WindowsPrincipal( identity );
				
				Context.User.SetRole( principal );
				
				if( !Context.User.IsAdministrator )
				{
					Console.WriteLine( "Access denied.\r\n\r\nThis program must be executed by a member of the '" 
						+ Config.GetString( "GroupName.Administrators" ) + "'\r\ngroup.  The current user '" 
						+ identity.Name + "' is not a member of this group." );
					
					return;
				}
				
				ProcessCommandLine( args );
				
				ConnectionManager.Open( true, false );
				
				try
				{
					if( null == OperatorKey )
						ReplicationHelper.Replicate();
					else
						ReplicationHelper.ReplicateWithNode( OperatorKey );
				}
				finally
				{
					ConnectionManager.Close();
				}				
			}
			catch( CommandLineException e )
			{
				if( null != e.Message && e.Message.Length > 0 )
					Console.WriteLine( e.Message );
				else
					DisplayUsage();
			}
			catch( Exception e )
			{
				Console.WriteLine( e.ToString() );
			}
			finally
			{
				sharedMemory.Release();
			}
		}


		/// ****************************************************************
		///   internal ProcessCommandLine [static]
		/// ----------------------------------------------------------------
		///   <summary>
		///     Parse the command-line.
		///   </summary>
		/// ----------------------------------------------------------------
		///   <param name="args">
		///     Command-line arguments.
		///   </param>
		/// ****************************************************************
		internal static void ProcessCommandLine( string[] args )
		{
			int i = 0;
			
			while( i < args.Length )
			{
				if( '-' == args[ i ][ 0 ] || '/' == args[ i ][ 0 ] )
				{
					//
					// Process the switch.
					//
					switch( args[ i ].Substring( 1 ).ToLower() )
					{
						case "o":
							if( i + 1 >= args.Length )
								throw new CommandLineException( "Missing required parameter 'operatorkey'" );

							i ++;

							try
							{
								OperatorKey = new Guid( args[ i ] ).ToString();
							}
							catch
							{
								throw new CommandLineException( "Invalid operator key specified." );
							}

							break;

						case "?":
							goto case "help";

						case "help":
							throw new CommandLineException( "" );

						default:
							throw new CommandLineException( "Unknown switch '" + args[i] + "'." );
					}
				}
			
				i ++;
			}
		}

		public static void DisplayUsage()
		{
			Console.WriteLine( "Syntax:" );
			Console.WriteLine( "    replicate.exe <switches>" );
			Console.WriteLine();
			Console.WriteLine( "Switches:" );
			Console.WriteLine( "    -o <operatorkey> Replicates against the specified" );
			Console.WriteLine( "                     operator only." );
			Console.WriteLine( "    -?               Displays this help message." );
			Console.WriteLine();
			Console.WriteLine( "Examples:" );
			Console.WriteLine( "    replicate.exe" );
			Console.WriteLine( "    replicate.exe -o F6D80408-A206-4b85-B2F4-699EFA13A669" );
			Console.WriteLine();
		}
	}	

	/// ****************************************************************
	///   public class CommandLineException
	/// ----------------------------------------------------------------
	///   <summary>
	///     Exception class for errors encountered while parsing the
	///     command-line.
	///   </summary>
	/// ****************************************************************
	/// 
	public class CommandLineException : ApplicationException
	{
			/// ************************************************************
			///   public CommandLineException [constructor]
			/// ------------------------------------------------------------
			///   <summary>
			///     CommandLineException constructor.
			///   </summary>
			/// ************************************************************
			/// 
			public CommandLineException()
					: base()
			{
			}

			/// ************************************************************
			///   public CommandLineException [constructor]
			/// ------------------------------------------------------------
			///   <summary>
			///     CommandLineException constructor.
			///   </summary>
			/// ------------------------------------------------------------
			///   <param name="message">
			///     Exception message.
			///   </param>
			/// ************************************************************
			/// 
			public CommandLineException( string message )
					: base( message )
			{
			}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\sdk\address.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.Xml.Serialization;

using Microsoft.Uddi;

namespace Microsoft.Uddi.Business
{
	/// <summary>
	/// The address structure is a simple list of AddressLine elements within the address container.  
	/// Each addressLine element is a simple string.  Uddi compliant registries are responsible for 
	/// preserving the order of any addressLine data provided.  Address structures also have two optional 
	/// attributes for recording the useType (freeform text) and sortCode data.   The sortCode values 
	/// are not significant within a Uddi registry, but may be used by user interfaces that present 
	/// address information in some ordered fashion using the values provided in the sortCode attribute.
	/// </summary>
	public class Address : UddiCore
	{
		private string				  sortCode;
		private string				  useType;
		private string				  tModelKey;
		private AddressLineCollection addressLines;

		/// <summary>
		/// Optional attribute that can be used to drive the behavior of external display mechanisms 
		/// that sort addresses.  The suggested values for sortCode include numeric ordering values 
		/// (e.g. 1, 2, 3), alphabetic character ordering values (e.g. a, b, c) or the first n positions 
		/// of relevant data within the address.
		/// </summary>		
		[XmlAttribute("sortCode")]
		public string SortCode
		{
			get	{ return sortCode; }
			set	{ sortCode = value;	}
		}

		/// <summary>
		/// Optional attribute that is used to describe the type of address in freeform text.  
		/// Suggested examples include headquarters, sales office, billing department, etc.
		/// </summary>
		[XmlAttribute("useType")]
		public string UseType
		{
			get	{ return useType; }
			set	{ useType = value; }
		}

		/// <summary>
		/// Optional attribute that is used to describe the address using a tModel.  
		/// </summary>
		[XmlAttribute("tModelKey")]
		public string TModelKey
		{
			get	{ return tModelKey; }
			set	{ tModelKey = value; }
		}
		
		/// <summary>
		/// AddressLine elements contain string data with a suggested line length limit of 
		/// 40 character positions.  Address line order is significant and will always be 
		/// returned by the Uddi compliant registry in the order originally provided during 
		/// a call to save_business.
		/// </summary>
		[XmlElement("addressLine")]
		public AddressLineCollection AddressLines
		{
			get
			{
				if( null == addressLines )
				{
					addressLines = new AddressLineCollection();
				}

				return addressLines;
			}

			set { addressLines = value; }
		}

		public Address() : this( "", "" ) 
		{}

		public Address( string sortCode, string useType )
		{
			SortCode = sortCode;
			UseType  = useType;
		}

		public Address( string tModelKey )
		{
			SortCode  = sortCode;
			TModelKey = tModelKey;
		}
	}
	
	public class AddressLine : UddiCore
	{
		private string keyName;
		private string keyValue;
		private string text;

		public AddressLine() : this( "", null, null )
		{}

		public AddressLine( string text ) : this( text, null, null )
		{}

		public AddressLine( string text, string keyName, string keyValue )
		{
			Text     = text;
			KeyName  = keyName;
			KeyValue = keyValue;
		}

		[ XmlAttribute( "keyName" ) ]
		public string KeyName
		{
			get { return keyName; }
			set { keyName = value; }
		}

		[ XmlAttribute( "keyValue" ) ]
		public string KeyValue
		{
			get { return keyValue; }
			set { keyValue = value; }
		}

		[ XmlText ]
		public string Text
		{
			get { return text; }
			set { text = value; }
		}		
	}

	public class AddressCollection : CollectionBase
	{
		public Address this[ int index ]
		{
			get { return (Address)List[ index ]; }
			set { List[ index ] = value; }
		}
		
		public int Add( string sortCode, string useType  )
		{
			return List.Add( new Address( sortCode, useType  ) );
		}

		public int Add( string tModelKey )
		{
			return List.Add( new Address( tModelKey ) );
		}

		public int Add( Address value )
		{
			return List.Add( value );
		}

		public void Insert( int index, Address value )
		{
			List.Insert( index, value );
		}

		public int IndexOf( Address value )
		{
			return List.IndexOf( value );
		}

		public bool Contains( Address value )
		{
			return List.Contains( value );
		}

		public void Remove( Address value )
		{
			List.Remove( value );
		}

		public void CopyTo( Address[] array, int index )
		{
			List.CopyTo( array, index );
		}

		public new AddressEnumerator GetEnumerator() 
		{
			return new AddressEnumerator( List.GetEnumerator() );
		}
	}

	public sealed class AddressEnumerator : IEnumerator
	{
		private IEnumerator enumerator;

		public AddressEnumerator( IEnumerator enumerator )
		{
			this.enumerator = enumerator;
		}

		public Address Current
		{
			get  { return ( Address ) enumerator.Current; }			
		}

		object IEnumerator.Current
		{
			get{ return enumerator.Current; }
		}

		public bool MoveNext()
		{
			return enumerator.MoveNext();
		}

		public void Reset()
		{	
			enumerator.Reset();
		}
	}

	public class AddressLineCollection : CollectionBase
	{
		public AddressLine this[ int index ]
		{
			get { return (AddressLine)List[ index ]; }
			set { List[ index ] = value; }
		}
		
		public int Add( string text  )
		{
			return List.Add( new AddressLine( text ) );
		}

		public int Add( string text, string keyName, string keyValue  )
		{
			return List.Add( new AddressLine( text, keyName, keyValue ) );
		}

		public int Add( AddressLine value )
		{
			return List.Add( value );
		}

		public void Insert( int index, AddressLine value )
		{
			List.Insert( index, value );
		}

		public int IndexOf( AddressLine value )
		{
			return List.IndexOf( value );
		}

		public bool Contains( AddressLine value )
		{
			return List.Contains( value );
		}

		public void Remove( AddressLine value )
		{
			List.Remove( value );
		}

		public void CopyTo( AddressLine[] array, int index )
		{
			List.CopyTo( array, index );
		}

		public new AddressLineEnumerator GetEnumerator() 
		{
			return new AddressLineEnumerator( List.GetEnumerator() );
		}
	}

	public sealed class AddressLineEnumerator : IEnumerator
	{
		private IEnumerator enumerator;

		public AddressLineEnumerator( IEnumerator enumerator )
		{
			this.enumerator = enumerator;
		}

		public AddressLine Current
		{
			get  { return ( AddressLine ) enumerator.Current; }			
		}

		object IEnumerator.Current
		{
			get{ return enumerator.Current; }
		}

		public bool MoveNext()
		{
			return enumerator.MoveNext();
		}

		public void Reset()
		{	
			enumerator.Reset();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\sdk\context.cs ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\sdk\assemblyinfo.cs ===
using System;
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("Microsoft.Uddi")]
[assembly: AssemblyDescription("Assembly for processing Uddi SOAP messages")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft Corporation")]
[assembly: AssemblyProduct("Uddi")]
[assembly: AssemblyCopyright("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]		

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile(@"..\..\sdk.snk")]
[assembly: AssemblyKeyName("")]
[assembly: CLSCompliantAttribute(true)]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\sdk\authentication.cs ===
using System;
using System.Xml.Serialization;

using Microsoft.Uddi;

namespace Microsoft.Uddi.Authentication
{
	/// <summary>
	/// The discard_authToken message is used to inform an Operator Site that the 
	/// authentication token can be discarded.  Subsequent calls that use the same 
	/// authToken may be rejected.  This message is optional for Operator Sites that 
	/// do not manage session state or that do not support the get_authToken message.
	/// </summary>
	[XmlRootAttribute("discard_authToken", Namespace=Microsoft.Uddi.VersionSupport.UddiVersionSupport.CurrentNamespace)]
	public class DiscardAuthToken : UddiSecureMessage
	{		
	}

	/// <summary>
	/// The get_authToken message is used to obtain an authentication token.  
	/// This message returns the authentication information that should be used 
	/// in subsequent calls to the publishers API messages.
	/// </summary>
	[XmlRootAttribute("get_authToken", Namespace=Microsoft.Uddi.VersionSupport.UddiVersionSupport.CurrentNamespace)]
	public class GetAuthToken : UddiMessage
	{		
		private string userId;
		private string credentials;
						
		/// <summary>
		/// This required attribute argument is the user that an individual authorized user was assigned 
		/// by an Operator Site.  Operator Sites will each provide a way for individuals to obtain a 
		/// UserID and password that will be valid only at the given Operator Site.
		/// </summary>
		[XmlAttribute("userID")]
		public string UserID
		{						
			get	{ return userId; }
			set	{ userId = value; }
		}

		/// <summary>
		/// This required attribute argument is the password or credential that is associated with the user.
		/// </summary>
		[XmlAttribute("cred")]
		public string Credentials
		{
			//
			// TODO store this value using CryptProtectMemory
			//
			get	{ return credentials; }
			set	{ credentials = value; }
		}		
	}		

	/// <summary>
	/// The authToken message contains a single authInfo element that contains an access token 
	/// that is to be passed back in all of the publisher API messages that change data.  This 
	/// message is always returned using SSL encryption as a synchronous response to the 
	/// get_authToken message
	/// </summary>
	[XmlRootAttribute("authToken", Namespace=Microsoft.Uddi.VersionSupport.UddiVersionSupport.CurrentNamespace)]
	public class AuthToken : UddiCore
	{
		private string		 node;		
		private string		 authInfo;		
		private GetAuthToken originatingGetAuthToken;
		
		[XmlAttribute("operator")]
		public string Operator
		{
			get	{ return node; }
			set	{ node = value;	}
		}
		
		/// <summary>
		/// This element contains the requested authentication token.  Authentication tokens are opaque 
		/// values that are required for all other publisher API calls. 
		/// </summary>
		[XmlElement("authInfo")]
		public string AuthInfo
		{
			get	{ return authInfo; }
			set	{ authInfo = value; }
		}
	
		[XmlIgnore]
		internal GetAuthToken OriginatingAuthToken
		{
			get { return originatingGetAuthToken; }
			set { originatingGetAuthToken = value; }
		}		
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\sdk\binding.cs ===
using System;
using System.Diagnostics;
using System.Collections;
using System.ComponentModel;
using System.Xml.Serialization;
using System.Collections.Specialized;

using Microsoft.Uddi;
using Microsoft.Uddi.ServiceType;
using Microsoft.Uddi.Binding;

namespace Microsoft.Uddi.Binding
{
	[XmlRootAttribute("delete_binding", Namespace=Microsoft.Uddi.VersionSupport.UddiVersionSupport.CurrentNamespace)]
	public class DeleteBinding : UddiSecureMessage
	{				
		private StringCollection bindingKeys;
				
		[XmlElement("bindingKey")]
		public StringCollection BindingKeys
		{
			get
			{
				if( null == bindingKeys )
				{
					bindingKeys = new StringCollection();
				}

				return bindingKeys;
			}

			set { bindingKeys = value; }
		}
	}

	[XmlRootAttribute("find_binding", Namespace=Microsoft.Uddi.VersionSupport.UddiVersionSupport.CurrentNamespace)]
	public class FindBinding : UddiQueryMessage
	{				
		private string					serviceKey;		
		private StringCollection		tModelKeys;
						
		[XmlAttribute("serviceKey")]
		public string ServiceKey
		{
			get	{ return serviceKey; }
			set	{ serviceKey = value; }
		}
		
		[XmlArray("tModelBag"), XmlArrayItem("tModelKey")]
		public StringCollection TModelKeys
		{
			get
			{
				if( true == SerializeMode && 
					true == Utility.CollectionEmpty( tModelKeys ) )
				{
					return null;
				}

				if( null == tModelKeys )
				{
					tModelKeys = new StringCollection();
				}

				return tModelKeys;
			}

			set { tModelKeys = value; }
		}		
	}

	[XmlRootAttribute("save_binding", Namespace=Microsoft.Uddi.VersionSupport.UddiVersionSupport.CurrentNamespace)]
	public class SaveBinding : UddiSecureMessage
	{				
		private BindingTemplateCollection bindingTemplates;
		
		[XmlElement("bindingTemplate")]
		public BindingTemplateCollection BindingTemplates
		{
			get
			{
				if( null == bindingTemplates )
				{
					bindingTemplates = new BindingTemplateCollection();
				}

				return bindingTemplates;
			}

			set { bindingTemplates = value; }
		}
		
		public override bool SerializeMode
		{
			get { return base.SerializeMode; }
			set
			{
				if( false == Utility.CollectionEmpty( bindingTemplates ) )
				{
					foreach( BindingTemplate binding in bindingTemplates )
					{						
						binding.SerializeMode = value;
					}
				}
				base.SerializeMode = value;
			}
		}		
	}

	[XmlRootAttribute("get_bindingDetail", Namespace=Microsoft.Uddi.VersionSupport.UddiVersionSupport.CurrentNamespace)]
	public class GetBindingDetail : UddiMessage
	{
		private StringCollection bindingKeys;

		[XmlElement("bindingKey")]
		public StringCollection BindingKeys
		{
			get
			{
				if( null == bindingKeys )
				{
					bindingKeys = new StringCollection();
				}

				return bindingKeys;
			}

			set { bindingKeys = value; }
		}	
	}	

	[XmlRootAttribute("bindingDetail", Namespace=Microsoft.Uddi.VersionSupport.UddiVersionSupport.CurrentNamespace)]
	public class BindingDetail : UddiCore
	{		
		private string						node;
		private bool						truncated;
		private BindingTemplateCollection	bindingTemplates;
		
		[XmlAttribute("operator")]
		public string Operator
		{
			get { return node; }
			set { node = value; }
		}

		[XmlAttribute("truncated")]
		public bool Truncated
		{
			get { return truncated;  }			
			set { truncated = value; }
		}

		[XmlElement("bindingTemplate")]
		public BindingTemplateCollection BindingTemplates
		{
			get
			{
				if( null == bindingTemplates )
				{
					bindingTemplates = new BindingTemplateCollection();
				}

				return bindingTemplates;
			}

			set { bindingTemplates = value; }
		}
	}

	public class BindingTemplate : UddiCore
	{
		private string					serviceKey;
		private string					bindingKey;
		private AccessPoint				accessPoint;
		private HostingRedirector		hostingRedirector;
		private DescriptionCollection	descriptions;		
		private TModelInstanceDetail	tModelInstanceDetail;
				
		public BindingTemplate() : this( "", "" ) 
		{}

		public BindingTemplate( string serviceKey ) : this( serviceKey, "" )
		{}

		public BindingTemplate( string serviceKey, string bindingKey )
		{			
			ServiceKey = serviceKey;
			BindingKey = bindingKey;							
		}

		[XmlAttribute("serviceKey")]
		public string ServiceKey
		{
			get	{ return serviceKey; }
			set	{ serviceKey = value; }
		}

		[XmlAttribute("bindingKey")]
		public string BindingKey
		{
			get	{ return bindingKey; }
			set	{ bindingKey = value; }
		}

		[XmlElement("description")]
		public DescriptionCollection Descriptions
		{
			get
			{
				if( null == descriptions )
				{
					descriptions = new DescriptionCollection();
				}

				return descriptions;
			}

			set	{ descriptions = value; }
		}

		[XmlElement("accessPoint")]
		public AccessPoint AccessPoint
		{
			get
			{
				if( true == SerializeMode &&
					( null == accessPoint || Utility.StringEmpty( accessPoint.Text ) ) )
				{
					return null;
				}

				if( null == accessPoint )
				{
					accessPoint = new AccessPoint();
				}

				return accessPoint;
			}

			set { accessPoint = value; }
		}

		[XmlElement("hostingRedirector")]
		public HostingRedirector HostingRedirector
		{
			get
			{
				if( true == SerializeMode && 
					( null == hostingRedirector || Utility.StringEmpty( hostingRedirector.BindingKey ) ) )
				{
					return null;
				}

				if( null == hostingRedirector )
				{
					hostingRedirector = new HostingRedirector();
				}

				return hostingRedirector;
			}

			set { hostingRedirector = value; }
		}

		[XmlElement("tModelInstanceDetails")]
		public TModelInstanceDetail TModelInstanceDetail 
		{
			get 
			{ 
				if( null == tModelInstanceDetail )
				{
					tModelInstanceDetail = new TModelInstanceDetail();
				}

				return tModelInstanceDetail; 
			}
			set { tModelInstanceDetail = value; }
		}

		public override bool SerializeMode
		{
			get { return base.SerializeMode; }
			set
			{
				if( null != tModelInstanceDetail )
				{
					tModelInstanceDetail.SerializeMode = value;
				}
				base.SerializeMode = value;
			}
		}		
	}

	public class AccessPoint : UddiCore
	{
		private UrlType urlType;
		private string	text;

		public AccessPoint() 
		{}

		public AccessPoint( UrlType urlType ) : this( urlType, "" ) 
		{}

		public AccessPoint( UrlType urlType, string accessPoint )
		{
			UrlType = urlType;
			Text	= accessPoint;
		}

		[XmlAttribute( "urlType" )]
		public UrlType UrlType
		{
			get { return urlType; }
			set { urlType = value; }
		}

		[XmlText]
		public string Text
		{
			get	{ return text; }
			set	{ text = value; }
		}
	}

	public class HostingRedirector : UddiCore
	{
		private string bindingKey;
		
		[XmlAttribute("bindingKey")]
		public string BindingKey
		{
			get	{ return bindingKey; }
			set	{ bindingKey = value; }
		}
	}

	public class BindingTemplateCollection : CollectionBase
	{
		public BindingTemplate this[ int index ]
		{
			get { return (BindingTemplate)List[index]; }
			set { List[index] = value; }
		}

		public int Add( BindingTemplate bindingTemplate )
		{
			return List.Add(bindingTemplate);
		}

		public int Add( string serviceKey )
		{
			return List.Add( new BindingTemplate( serviceKey ) );
		}

		public int Add( string serviceKey, string bindingKey )
		{
			return List.Add( new BindingTemplate( serviceKey, bindingKey ) );
		}
		
		public void Insert(int index, BindingTemplate value)
		{
			List.Insert(index, value);
		}

		public int IndexOf(BindingTemplate value)
		{
			return List.IndexOf(value);
		}

		public bool Contains(BindingTemplate value)
		{
			return List.Contains(value);
		}

		public void Remove(BindingTemplate value)
		{
			List.Remove(value);
		}

		public void CopyTo(BindingTemplate[] array, int index)
		{
			List.CopyTo(array, index);
		}

		public new BindingTemplateEnumerator GetEnumerator() 
		{
			return new BindingTemplateEnumerator( List.GetEnumerator() );
		}
	}

	public sealed class BindingTemplateEnumerator : IEnumerator
	{
		private IEnumerator enumerator;

		public BindingTemplateEnumerator( IEnumerator enumerator )
		{
			this.enumerator = enumerator;
		}

		public BindingTemplate Current
		{
			get  { return ( BindingTemplate ) enumerator.Current; }			
		}

		object IEnumerator.Current
		{
			get{ return enumerator.Current; }
		}

		public bool MoveNext()
		{
			return enumerator.MoveNext();
		}

		public void Reset()
		{	
			enumerator.Reset();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\sdk\assertion.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.ComponentModel;
using System.Xml.Serialization;

using Microsoft.Uddi;
using Microsoft.Uddi.Business;
using Microsoft.Uddi.Service;
using Microsoft.Uddi.ServiceType;
using Microsoft.Uddi.VersionSupport;

namespace Microsoft.Uddi.Business
{
	[XmlRoot( "assertionStatusReport", Namespace=Microsoft.Uddi.VersionSupport.UddiVersionSupport.CurrentNamespace )]
	public class AssertionStatusReport : UddiCore
	{
		private string						  node;
		private AssertionStatusItemCollection assertionStatusItems;

		[XmlAttribute( "operator" )]
		public string Operator
		{
			get { return node; }
			set { node = value; }
		}
		
		[XmlElement( "assertionStatusItem" )]
		public AssertionStatusItemCollection AssertionStatusItems
		{
			get
			{
				if( null == assertionStatusItems )
				{
					assertionStatusItems = new AssertionStatusItemCollection();
				}

				return assertionStatusItems;
			}

			set { assertionStatusItems = value; }
		}
	}

	[XmlRoot( "publisherAssertions", Namespace=Microsoft.Uddi.VersionSupport.UddiVersionSupport.CurrentNamespace )]
	public class PublisherAssertionDetail : UddiCore
	{		
		private string						 node;
		private string						 authorizedName;
		private PublisherAssertionCollection publisherAssertions;

		[XmlAttribute( "operator" )]
		public string Operator
		{
			get { return node; }
			set { node = value; }
		}
		
		[XmlAttribute( "authorizedName" )]
		public string AuthorizedName
		{
			get { return authorizedName; }
			set { authorizedName = value; }
		}
		
		[XmlElement( "publisherAssertion" )]
		public PublisherAssertionCollection PublisherAssertions
		{
			get
			{
				if( null == publisherAssertions )
				{
					publisherAssertions = new PublisherAssertionCollection();
				}

				return publisherAssertions;
			}

			set { publisherAssertions = value; }
		}
	}

	[XmlRoot( "relatedBusinessesList", Namespace=Microsoft.Uddi.VersionSupport.UddiVersionSupport.CurrentNamespace )]
	public class RelatedBusinessList : UddiCore
	{
		private string						  operatorValue;
		private string						  businessKey;
		private bool						  truncated;
		private RelatedBusinessInfoCollection relatedBusinessInfos;

		[XmlAttribute( "operator" )]
		public string Operator
		{
			get { return operatorValue; }
			set { operatorValue = value; }
		}

		[XmlAttribute( "businessKey" )]
		public string BusinessKey
		{
			get { return businessKey; }
			set { businessKey = value; }
		}

		[XmlAttribute( "truncated" )]
		public bool Truncated
		{
			get { return truncated; }
			set { truncated = value; }
		}
		
		[ XmlArray( "relatedBusinessInfos" ), XmlArrayItem( "relatedBusinessInfo" ) ]
		public RelatedBusinessInfoCollection RelatedBusinessInfos
		{
			get
			{
				if( null == relatedBusinessInfos )
				{
					relatedBusinessInfos = new RelatedBusinessInfoCollection();
				}
				return relatedBusinessInfos;
			}

			set { relatedBusinessInfos = value; }
		}
	}

	[XmlRoot( "add_publisherAssertions", Namespace=Microsoft.Uddi.VersionSupport.UddiVersionSupport.CurrentNamespace )]
	public class AddPublisherAssertions : UddiSecureMessage
	{				
		private PublisherAssertionCollection publisherAssertions;
	
		[XmlElement( "publisherAssertion" )]
		public PublisherAssertionCollection PublisherAssertions
		{
			get
			{
				if( null == publisherAssertions )
				{
					publisherAssertions = new PublisherAssertionCollection();
				}
				return publisherAssertions;
			}

			set { publisherAssertions = value; }
		}		
	}
	
	[XmlRoot( "delete_publisherAssertions", Namespace=Microsoft.Uddi.VersionSupport.UddiVersionSupport.CurrentNamespace )]
	public class DeletePublisherAssertions : UddiSecureMessage
	{				
		private PublisherAssertionCollection publisherAssertions;

		[XmlElement( "publisherAssertion" )]
		public PublisherAssertionCollection PublisherAssertions
		{
			get 
			{ 
				if( null == publisherAssertions )
				{
					publisherAssertions = new PublisherAssertionCollection();
				}

				return publisherAssertions;
			}

			set { publisherAssertions = value; }
		}
	}
	
	[XmlRoot( "find_relatedBusinesses", Namespace=Microsoft.Uddi.VersionSupport.UddiVersionSupport.CurrentNamespace )]
	public class FindRelatedBusinesses : UddiQueryMessage
	{
		//
		// TODO this normally does not have max rows default 0, is that going to be a problem?
		//
				
		private string			businessKey;
		private KeyedReference	keyedReference;

		[XmlElement( "businessKey" )]
		public string BusinessKey
		{
			get { return businessKey; }
			set { businessKey = value; }
		}
		
		[XmlElement( "keyedReference" )]
		public KeyedReference KeyedReference
		{
			get 
			{ 
				if( null == keyedReference )
				{
					keyedReference = new KeyedReference();
				}

				return keyedReference; 
			}

			set { keyedReference = value; }
		}
	}

	[XmlRoot( "get_assertionStatusReport", Namespace=Microsoft.Uddi.VersionSupport.UddiVersionSupport.CurrentNamespace )]
	public class GetAssertionStatusReport : UddiSecureMessage
	{						
		private CompletionStatusType completionStatus;

		[XmlElement( "completionStatus" )]
		public CompletionStatusType CompletionStatus
		{
			get { return completionStatus; }
			set { completionStatus = value; }
		}		
	}
	
	[XmlRoot( "get_publisherAssertions", Namespace=Microsoft.Uddi.VersionSupport.UddiVersionSupport.CurrentNamespace )]
	public class GetPublisherAssertions : UddiSecureMessage
	{
	}

	[XmlRoot( "set_publisherAssertions", Namespace=Microsoft.Uddi.VersionSupport.UddiVersionSupport.CurrentNamespace )]
	public class SetPublisherAssertions : UddiSecureMessage
	{				
		private PublisherAssertionCollection publisherAssertions;

		[XmlElement( "publisherAssertion" )]
		public PublisherAssertionCollection PublisherAssertions
		{
			get
			{
				if( null == publisherAssertions )
				{
					publisherAssertions = new PublisherAssertionCollection();
				}

				return publisherAssertions;
			}

			set { publisherAssertions = value; }
		}		
	}

	public class PublisherAssertion : UddiCore
	{
		private string			fromKey;
		private string			toKey;
		private KeyedReference	keyedReference;

		public PublisherAssertion()
		{}

		public PublisherAssertion( PublisherAssertion assertion )
		{
			this.FromKey		= assertion.FromKey;
			this.ToKey			= assertion.ToKey;
			this.KeyedReference = assertion.KeyedReference;
		}
		
		public PublisherAssertion( string fromKey, string toKey, KeyedReference keyedReference )
		{
			this.FromKey		= fromKey;
			this.ToKey			= toKey;
			this.KeyedReference = keyedReference;
		}
		
		public PublisherAssertion( string fromKey, string toKey, string keyName, string keyValue, string tModelKey )
		{
			this.FromKey		= fromKey;
			this.ToKey			= toKey;
			this.KeyedReference = new KeyedReference( keyName, keyValue, tModelKey );
		}

		[XmlElement( "fromKey" )]
		public string FromKey
		{
			get { return fromKey; }
			set { fromKey = value; }
		}
		
		[XmlElement( "toKey" )]
		public string ToKey
		{
			get { return toKey; }
			set { toKey = value; }
		}
		
		[XmlElement( "keyedReference" )]
		public KeyedReference KeyedReference
		{
			get 
			{ 
				if( null == keyedReference )
				{
					keyedReference = new KeyedReference();
				}

				return keyedReference; 
			}

			set { keyedReference = value; }
		}		
	}
		
	public class AssertionStatusItem : UddiCore
	{	
		private string				 fromKey;
		private string				 toKey;
		private CompletionStatusType completionStatus;
		private KeyedReference		 keyedReference;
		private KeysOwned			 keysOwned;

		public AssertionStatusItem()
		{}

		public AssertionStatusItem( CompletionStatusType completionStatus, 
									string				 fromKey, 
									string				 toKey, 
									KeyedReference		 keyedReference, 
									KeysOwned			 keysOwned )
		{
			this.CompletionStatus = completionStatus;
			this.FromKey		  = fromKey;
			this.ToKey			  = toKey;
			this.KeyedReference	  = keyedReference;
			this.KeysOwned		  = keysOwned;
		}

		[XmlAttribute( "completionStatus" )]
		public CompletionStatusType CompletionStatus
		{
			get { return completionStatus; }
			set { completionStatus = value; }
		}

		[XmlElement( "fromKey" )]
		public string FromKey
		{
			get { return fromKey; }
			set { fromKey = value; }
		}
			
		[XmlElement( "toKey" )]
		public string ToKey
		{
			get { return toKey; }
			set { toKey = value; }
		}
	
		[XmlElement( "keyedReference" )]
		public KeyedReference KeyedReference
		{
			get { return keyedReference; }
			set { keyedReference = value; }
		}
		
		[XmlElement( "keysOwned" )]
		public KeysOwned KeysOwned
		{
			get
			{
				if( null == keysOwned )
				{
					keysOwned = new KeysOwned();
				}

				return keysOwned;
			}

			set { keysOwned = value; }
		}		
	}
	
	public class KeysOwned : UddiCore
	{
		private string fromKey;
		private string toKey;

		public KeysOwned()
		{}

		public KeysOwned( string fromKey, string toKey )
		{
			this.FromKey = fromKey;
			this.ToKey   = toKey;
		}

		[XmlElement( "fromKey" )]
		public string FromKey
		{
			get { return fromKey; }
			set { fromKey = value; }
		}
		
		[XmlElement( "toKey" )]
		public string ToKey
		{
			get { return toKey; }
			set { toKey = value; }
		}		
	}

	public class RelatedBusinessInfo : UddiCore
	{
		private string					businessKey;
		private NameCollection			names;
		private DescriptionCollection	descriptions;
		private SharedRelationships[]	sharedRelationships;

		public RelatedBusinessInfo()
		{}

		public RelatedBusinessInfo( string businessKey )
		{
			this.BusinessKey = businessKey;
		}

		[XmlElement( "businessKey" )]
		public string BusinessKey
		{
			get { return businessKey; }
			set { businessKey = value; }
		}
		
		[XmlElement( "name" )]
		public NameCollection Names
		{
			get
			{
				if( null == names )
				{
					names = new NameCollection();
				}

				return names;
			}

			set { names = value; }
		}
		
		[XmlElement( "description" )]
		public DescriptionCollection Descriptions
		{
			get
			{
				if( null == descriptions )
				{
					descriptions = new DescriptionCollection();
				}

				return descriptions;
			}

			set { descriptions = value; }
		}
		
		[XmlElement( "sharedRelationships" )]
		public SharedRelationships[] SharedRelationships
		{
			get	
			{ 
				if( null == sharedRelationships )
				{
					sharedRelationships = new SharedRelationships[ 2 ];
				}

				return sharedRelationships; 
			}

			set { sharedRelationships = value; }
		}		
	}

	public class SharedRelationships : UddiCore
	{		
		private DirectionType			 direction;
		private KeyedReferenceCollection keyedReferences;

		[XmlAttribute( "direction" )]
		public DirectionType Direction
		{
			get { return direction; }
			set { direction = value; }
		}
		
		[XmlElement( "keyedReference" )]
		public KeyedReferenceCollection KeyedReferencesSerialize
		{
			get 
			{
				if( null == keyedReferences )
				{
					keyedReferences = new KeyedReferenceCollection();
				}

				return keyedReferences;
			}
			set { keyedReferences = value; }
		}
	}

	public class PublisherAssertionCollection : CollectionBase
	{
		public PublisherAssertion this[ int index ]
		{
			get { return (PublisherAssertion)List[index]; }
			set { List[ index ] = value; }
		}

		public int Add()
		{
			return List.Add( new PublisherAssertion() );
		}

		public int Add( PublisherAssertion value )
		{
			return List.Add( value );
		}

		public int Add( string fromKey, string toKey, KeyedReference keyedReference )
		{
			return List.Add( new PublisherAssertion( fromKey, toKey, keyedReference ) );
		}
		
		public int Add( string fromKey, string toKey, string keyName, string keyValue, string tModelKey )
		{
			return List.Add( new PublisherAssertion( fromKey, toKey, keyName, keyValue, tModelKey ) );
		}
		
		public void Insert( int index, PublisherAssertion value )
		{
			List.Insert( index, value );
		}

		public int IndexOf( PublisherAssertion value )
		{
			return List.IndexOf( value );
		}

		public bool Contains( PublisherAssertion value )
		{
			return List.Contains( value );
		}

		public void Remove( PublisherAssertion value )
		{
			List.Remove( value );
		}

		public void CopyTo( PublisherAssertion[] array, int index )
		{
			List.CopyTo( array, index );
		}

		public new PublisherAssertionEnumerator GetEnumerator() 
		{
			return new PublisherAssertionEnumerator( List.GetEnumerator() );
		}
	}

	public sealed class PublisherAssertionEnumerator : IEnumerator
	{
		private IEnumerator enumerator;

		public PublisherAssertionEnumerator( IEnumerator enumerator )
		{
			this.enumerator = enumerator;
		}

		public PublisherAssertion Current
		{
			get  { return ( PublisherAssertion ) enumerator.Current; }			
		}

		object IEnumerator.Current
		{
			get{ return enumerator.Current; }
		}

		public bool MoveNext()
		{
			return enumerator.MoveNext();
		}

		public void Reset()
		{	
			enumerator.Reset();
		}
	}

	public class AssertionStatusItemCollection : CollectionBase
	{
		public AssertionStatusItem this[ int index ]
		{
			get { return (AssertionStatusItem)List[index]; }
			set { List[ index ] = value; }
		}

		public int Add()
		{
			return List.Add( new AssertionStatusItem() );
		}

		public int Add( AssertionStatusItem value )
		{
			return List.Add( value );
		}
	
		public void Insert( int index, AssertionStatusItem value )
		{
			List.Insert( index, value );
		}

		public int IndexOf( AssertionStatusItem value )
		{
			return List.IndexOf( value );
		}

		public bool Contains( AssertionStatusItem value )
		{
			return List.Contains( value );
		}

		public void Remove( AssertionStatusItem value )
		{
			List.Remove( value );
		}

		public void CopyTo( AssertionStatusItem[] array, int index )
		{
			List.CopyTo( array, index );
		}

		public new AssertionStatusItemEnumerator GetEnumerator() 
		{
			return new AssertionStatusItemEnumerator( List.GetEnumerator() );
		}
	}

	public sealed class AssertionStatusItemEnumerator : IEnumerator
	{
		private IEnumerator enumerator;

		public AssertionStatusItemEnumerator( IEnumerator enumerator )
		{
			this.enumerator = enumerator;
		}

		public AssertionStatusItem Current
		{
			get  { return ( AssertionStatusItem ) enumerator.Current; }			
		}

		object IEnumerator.Current
		{
			get{ return enumerator.Current; }
		}

		public bool MoveNext()
		{
			return enumerator.MoveNext();
		}

		public void Reset()
		{	
			enumerator.Reset();
		}
	}

	public class RelatedBusinessInfoCollection : CollectionBase
	{
		public RelatedBusinessInfo this[ int index ]
		{
			get { return (RelatedBusinessInfo)List[index]; }
			set { List[ index ] = value; }
		}
		
		public int Add( RelatedBusinessInfo relatedBusinessInfo )
		{
			return List.Add( relatedBusinessInfo );
		}
	
		public int Add( string businessKey )
		{
			return List.Add( new RelatedBusinessInfo( businessKey ) );
		}

		public void Insert( int index, RelatedBusinessInfo relatedBusinessInfo )
		{
			List.Insert( index, relatedBusinessInfo );
		}

		public int IndexOf( RelatedBusinessInfo relatedBusinessInfo )
		{
			return List.IndexOf( relatedBusinessInfo );
		}

		public bool Contains( RelatedBusinessInfo relatedBusinessInfo )
		{
			return List.Contains( relatedBusinessInfo );
		}

		public void Remove( RelatedBusinessInfo relatedBusinessInfo )
		{
			List.Remove( relatedBusinessInfo );
		}

		public void CopyTo( RelatedBusinessInfo[] array, int index )
		{
			List.CopyTo( array, index );
		}
		public new RelatedBusinessInfoEnumerator GetEnumerator() 
		{
			return new RelatedBusinessInfoEnumerator( List.GetEnumerator() );
		}
	}

	public sealed class RelatedBusinessInfoEnumerator : IEnumerator
	{
		private IEnumerator enumerator;

		public RelatedBusinessInfoEnumerator( IEnumerator enumerator )
		{
			this.enumerator = enumerator;
		}

		public RelatedBusinessInfo Current
		{
			get  { return ( RelatedBusinessInfo ) enumerator.Current; }			
		}

		object IEnumerator.Current
		{
			get{ return enumerator.Current; }
		}

		public bool MoveNext()
		{
			return enumerator.MoveNext();
		}

		public void Reset()
		{	
			enumerator.Reset();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\sdk\business.cs ===
using System;
using System.IO;
using System.Collections;
using System.Collections.Specialized;
using System.Diagnostics;
using System.ComponentModel;
using System.Xml.Serialization;

using Microsoft.Uddi;
using Microsoft.Uddi.Business;
using Microsoft.Uddi.Service;
using Microsoft.Uddi.ServiceType;

namespace Microsoft.Uddi.Business
{
	[XmlRootAttribute("delete_business", Namespace=Microsoft.Uddi.VersionSupport.UddiVersionSupport.CurrentNamespace)]
	public class DeleteBusiness : UddiSecureMessage
	{				
		private StringCollection businessKeys;
						
		[XmlElement("businessKey")]
		public StringCollection BusinessKeys
		{
			get
			{
				if( null == businessKeys )
				{
					businessKeys = new StringCollection();
				}

				return businessKeys;
			}

			set { businessKeys = value; }
		}
	}

	[XmlRootAttribute("find_business", Namespace=Microsoft.Uddi.VersionSupport.UddiVersionSupport.CurrentNamespace)]
	public class FindBusiness : UddiQueryMessage
	{		
		private NameCollection			 names;
		private KeyedReferenceCollection identifierBag;
		private KeyedReferenceCollection categoryBag;
		private StringCollection		 tModelKeys;
		private DiscoveryUrlCollection	 discoveryUrls;
		
		[XmlElement("name")]
		public NameCollection Names
		{
			get	
			{
				if( null == names )
				{
					names = new NameCollection();
				}
				return names; 
			}

			set	{ names = value; }
		}

		[XmlArray("identifierBag"), XmlArrayItem("keyedReference")]
		public KeyedReferenceCollection IdentifierBag
		{
			get
			{
				if( true == SerializeMode && 
					true == Utility.CollectionEmpty( identifierBag ) )
				{
					return null;
				}

				if( null == identifierBag )
				{
					identifierBag = new KeyedReferenceCollection();
				}

				return identifierBag;
			}

			set { identifierBag = value; }
		}

		[XmlArray("categoryBag"), XmlArrayItem("keyedReference")]
		public KeyedReferenceCollection CategoryBag
		{
			get
			{
				if( true == SerializeMode && 
					true == Utility.CollectionEmpty( categoryBag ) )
				{
					return null;
				}

				if( null == categoryBag )
				{
					categoryBag = new KeyedReferenceCollection();
				}

				return categoryBag;
			}

			set { categoryBag = value; }
		}

		[XmlArray("tModelBag"), XmlArrayItem("tModelKey")]
		public StringCollection TModelKeys
		{
			get
			{
				if( true == SerializeMode && 
					true == Utility.CollectionEmpty( tModelKeys ) )
				{
					return null;
				}

				if( null == tModelKeys )
				{
					tModelKeys = new StringCollection();
				}

				return tModelKeys;
			}

			set { tModelKeys = value; }
		}

		[XmlArray("discoveryURLs"), XmlArrayItem("discoveryURL")]
		public DiscoveryUrlCollection DiscoveryUrls
		{
			get
			{
				if( true == SerializeMode && 
					true == Utility.CollectionEmpty( discoveryUrls ) )
				{
					return null;
				}

				if( null == discoveryUrls )
				{
					discoveryUrls = new DiscoveryUrlCollection();
				}

				return discoveryUrls;
			}

			set { discoveryUrls = value; }
		}			
	}

	[XmlRootAttribute("get_businessDetail", Namespace=Microsoft.Uddi.VersionSupport.UddiVersionSupport.CurrentNamespace)]
	public class GetBusinessDetail : UddiMessage
	{
		private StringCollection businessKeys;
				
		[XmlElement("businessKey")]
		public StringCollection BusinessKeys
		{
			get
			{
				if( null == businessKeys )				
				{
					businessKeys = new StringCollection();
				}

				return businessKeys;
			}

			set { businessKeys = value; }
		}		
	}

	[XmlRootAttribute("save_business", Namespace=Microsoft.Uddi.VersionSupport.UddiVersionSupport.CurrentNamespace)]
	public class SaveBusiness : UddiSecureMessage
	{				
		private BusinessEntityCollection businessEntities;
		private StringCollection		 uploadRegisters;
						
		[XmlElement("businessEntity")]
		public BusinessEntityCollection BusinessEntities
		{
			get
			{
				if( true == SerializeMode && 
					true == Utility.CollectionEmpty( businessEntities ) )
				{
					return null;
				}

				if( null == businessEntities )
				{
					businessEntities = new BusinessEntityCollection();
				}

				return businessEntities;
			}

			set	{ businessEntities = value;	}
		}
		
		[XmlElement("uploadRegister")]
		public StringCollection UploadRegisters
		{
			get
			{
				if( true == SerializeMode && 
					true == Utility.CollectionEmpty( uploadRegisters ) )
				{
					return null;
				}

				if( null == uploadRegisters )
				{
					uploadRegisters = new StringCollection();
				}

				return uploadRegisters;
			}
			set	{ uploadRegisters = value; }
		}
		
		public override bool SerializeMode
		{
			get
			{
				return base.SerializeMode;
			}		
			set
			{
				if( !Utility.CollectionEmpty( businessEntities ) )
				{
					foreach( BusinessEntity business in businessEntities )
					{
						business.SerializeMode = value;
					}
				}
				base.SerializeMode = value;
			}			
		}		
	}

	[XmlRootAttribute("get_businessDetailExt", Namespace=Microsoft.Uddi.VersionSupport.UddiVersionSupport.CurrentNamespace)]
	public class GetBusinessDetailExt : UddiMessage
	{		
		private StringCollection businessKeys;
		
		[XmlElement("businessKey")]
		public StringCollection BusinessKeys
		{
			get
			{
				if( null == businessKeys )
				{
					businessKeys = new StringCollection();
				}

				return businessKeys;
			}

			set { businessKeys = value; }
		}		
	}

	[XmlRootAttribute("get_registeredInfo", Namespace=Microsoft.Uddi.VersionSupport.UddiVersionSupport.CurrentNamespace)]
	public class GetRegisteredInfo : UddiSecureMessage
	{				
	}

	[XmlRootAttribute("businessDetail", Namespace=Microsoft.Uddi.VersionSupport.UddiVersionSupport.CurrentNamespace)]
	public class BusinessDetail : UddiCore
	{		
		private string					 node;
		private bool					 truncated;
		private BusinessEntityCollection businessEntities;
		
		[XmlAttribute("operator")]
		public string Operator
		{
			get	{ return node; }
			set	{ node = value; }
		}
	
		[XmlAttribute("truncated")]
		public bool Truncated
		{
			get	{ return truncated;	}	
			set { truncated = value; }
		}
	
		[XmlElement("businessEntity")]
		public BusinessEntityCollection BusinessEntities
		{
			get
			{
				if( null == businessEntities )
				{
					businessEntities = new BusinessEntityCollection();
				}

				return businessEntities;
			}

			set	{ businessEntities = value;	}
		}
	}
	
	[XmlRootAttribute("businessDetailExt", Namespace=Microsoft.Uddi.VersionSupport.UddiVersionSupport.CurrentNamespace)]
	public class BusinessDetailExt : UddiCore
	{		
		private string						node;
		private bool						truncated;
		private BusinessEntityExtCollection businessEntitiesExt;
			
		[XmlAttribute("operator")]
		public string Operator
		{
			get	{ return node; }
			set	{ node = value; }
		}
		
		[XmlAttribute("truncated")]
		public bool Truncated
		{
			get	{ return truncated; }			
			set { truncated = value; }
		}
		
		[XmlElement("businessEntityExt")]
		public BusinessEntityExtCollection BusinessEntitiesExt
		{
			get
			{
				if( null == businessEntitiesExt )
				{
					businessEntitiesExt = new BusinessEntityExtCollection();
				}

				return businessEntitiesExt;
			}

			set	{ businessEntitiesExt = value;	}
		}
	}

	[XmlRootAttribute("businessList", Namespace=Microsoft.Uddi.VersionSupport.UddiVersionSupport.CurrentNamespace)]
	public class BusinessList : UddiCore
	{		
		private string					node;
		private bool					truncated;
		private BusinessInfoCollection	businessInfos;
		
		[XmlAttribute("operator")]
		public string Operator
		{
			get	{ return node; }
			set	{ node = value;	}
		}
		
		[XmlAttribute("truncated")]
		public bool Truncated
		{
			get	{ return truncated; }		
			set { truncated = value; }
		}
		
		[XmlArray("businessInfos"), XmlArrayItem("businessInfo")]
		public BusinessInfoCollection BusinessInfos
		{
			get
			{
				if( null == businessInfos )
				{
					businessInfos = new BusinessInfoCollection();
				}

				return businessInfos;
			}
			
			set { businessInfos = value; }
		}
	}

	public class BusinessEntity : UddiCore
	{
		private string						businessKey;
		private string						node;
		private string						authorizedName;
		private DiscoveryUrlCollection		discoveryUrls;
		private NameCollection				names;
		private DescriptionCollection		descriptions;
		private ContactCollection			contacts;
		private BusinessServiceCollection	businessServices;
		private KeyedReferenceCollection	identifierBag;
		private KeyedReferenceCollection	categoryBag;		
		
		public BusinessEntity() : this( "" )
		{}
	
		public BusinessEntity( string businessKey )
		{
			BusinessKey = businessKey;
		}

		[XmlAttribute("businessKey")]
		public string BusinessKey
		{
			get	{ return businessKey; }
			set	{ businessKey = value; }
		}

		[XmlAttribute("operator")]
		public string Operator
		{
			get	{ return node; }
			set	{ node = value; }
		}

		[XmlAttribute("authorizedName")]
		public string AuthorizedName
		{
			get	{ return authorizedName; }
			set	{ authorizedName = value; }
		}

		[XmlArray("discoveryURLs"), XmlArrayItem("discoveryURL")]
		public DiscoveryUrlCollection DiscoveryUrls 
		{
			get
			{
				if( true == SerializeMode && 
					true == Utility.CollectionEmpty( discoveryUrls ) )
				{
					return null;
				}

				if( null == discoveryUrls )
				{
					discoveryUrls = new DiscoveryUrlCollection();
				}

				return discoveryUrls;
			}

			set	{ discoveryUrls = value; }
		}
		
		[XmlElement("name")]
		public NameCollection Names
		{
			get	
			{ 
				if( null == names )
				{
					names = new NameCollection();
				}

				return names; 
			}

			set	{ names = value;	}
		}

		[XmlElement("description")]
		public DescriptionCollection Descriptions
		{
			get
			{
				if( true == SerializeMode && 
					true == Utility.CollectionEmpty( descriptions ) )
				{
					return null;
				}

				if( null == descriptions )
				{
					descriptions = new DescriptionCollection();
				}

				return descriptions;
			}

			set	{ descriptions = value; }
		}

		[XmlArray("contacts"),XmlArrayItem("contact")]
		public ContactCollection Contacts
		{
			get
			{
				if( true == SerializeMode && 
					true == Utility.CollectionEmpty( contacts ) )
				{
					return null;
				}

				if( null == contacts )
				{
					contacts = new ContactCollection();
				}

				return contacts;
			}

			set { contacts = value; }
		}

		[XmlArray("businessServices"), XmlArrayItem("businessService")]
		public BusinessServiceCollection BusinessServices
		{
			get
			{
				if( true == SerializeMode && 
					true == Utility.CollectionEmpty( businessServices ) )
				{
					return null;
				}

				if( null == businessServices )
				{
					businessServices = new BusinessServiceCollection();
				}

				return businessServices;
			}

			set { businessServices = value; }
		}

		[XmlArray("identifierBag"), XmlArrayItem("keyedReference")]
		public KeyedReferenceCollection IdentifierBag
		{
			get
			{
				if( true == SerializeMode && 
					true == Utility.CollectionEmpty( identifierBag ) )
				{
					return null;
				}

				if( null == identifierBag )
				{
					identifierBag = new KeyedReferenceCollection();
				}

				return identifierBag;
			}

			set { identifierBag = value; }
		}

		[XmlArray("categoryBag"), XmlArrayItem("keyedReference")]
		public KeyedReferenceCollection CategoryBag
		{
			get
			{
				if( true == SerializeMode && 
					true == Utility.CollectionEmpty( categoryBag ) )
				{
					return null;
				}

				if( null == categoryBag )
				{
					categoryBag = new KeyedReferenceCollection();
				}

				return categoryBag;
			}

			set { categoryBag = value; }
		}

		public override bool SerializeMode
		{
			get { return base.SerializeMode; }
			set
			{
				if( !Utility.CollectionEmpty( businessServices ) )
				{
					foreach( BusinessService service in businessServices )
					{
						service.SerializeMode = value;
					}
				}
				base.SerializeMode = value;
			}

		}
	}

	public class BusinessEntityExt : UddiCore
	{
		private BusinessEntity businessEntity;

		public BusinessEntityExt() : this( "" ) 
		{}

		public BusinessEntityExt( string businessKey )
		{
			BusinessEntity.BusinessKey = businessKey;
		}

		[XmlElement("businessEntity")]
		public BusinessEntity BusinessEntity
		{
			get
			{
				if( null == businessEntity )
				{
					businessEntity = new BusinessEntity();
				}

				return businessEntity;
			}

			set { businessEntity = value; }
		}		
	}

	public class BusinessInfo : UddiCore
	{
		private string				  businessKey;
		private string				  name;
		private DescriptionCollection descriptions;
		private ServiceInfoCollection serviceInfos;

		public BusinessInfo() : this( "", "" ) 
		{}

		public BusinessInfo( string businessKey, string name )
		{
			BusinessKey = businessKey;
			Name		= name;
		}

		[XmlAttribute("businessKey")]
		public string BusinessKey
		{
			get	{ return businessKey; }
			set	{ businessKey = value; }
		}

		[XmlElement("name")]
		public string Name
		{
			get	{ return name; }
			set	{ name = value;	}
		}

		[XmlElement("description")]
		public DescriptionCollection Descriptions
		{
			get
			{
				if( null == descriptions )
				{
					descriptions = new DescriptionCollection();
				}

				return descriptions;
			}

			set	{ descriptions = value; }
		}

		[XmlArray("serviceInfos"), XmlArrayItem("serviceInfo")]
		public ServiceInfoCollection ServiceInfos
		{
			get
			{
				if( null == serviceInfos )
				{
					serviceInfos = new ServiceInfoCollection();
				}

				return serviceInfos;
			}

			set	{ serviceInfos = value; }
		}
	}

	[XmlRootAttribute("registeredInfo", Namespace=Microsoft.Uddi.VersionSupport.UddiVersionSupport.CurrentNamespace)]
	public class RegisteredInfo : UddiCore
	{		
		private string					node;
		private bool					truncated;
		private BusinessInfoCollection	businessInfos;
		private TModelInfoCollection	tModelInfos;
		
		[XmlAttribute("operator")]
		public string Operator
		{
			get	{ return node; }
			set	{ node = value;	}
		}
		
		[XmlAttribute("truncated")]
		public bool Truncated
		{
			get	{ return truncated;	}	
			set { truncated = value; }
		}
		
		[XmlArray("businessInfos"), XmlArrayItem("businessInfo")]
		public BusinessInfoCollection BusinessInfos
		{
			get
			{
				if( null == businessInfos )
				{
					businessInfos = new BusinessInfoCollection();
				}

				return businessInfos;
			}
			
			set { businessInfos = value; }
		}
		
		[XmlArray("tModelInfos"), XmlArrayItem("tModelInfo")]
		public TModelInfoCollection TModelInfos
		{
			get
			{
				if( null == tModelInfos )
				{
					tModelInfos = new TModelInfoCollection();
				}

				return tModelInfos;
			}

			set { tModelInfos = value; }
		}
	}	

	public class BusinessInfoCollection : CollectionBase
	{
		public BusinessInfo this[int index]
		{
			get { return (BusinessInfo)List[index]; }
			set { List[index] = value; }
		}

		public int Add()
		{
			return List.Add( new BusinessInfo() );
		}

		public int Add( string businessKey, string name )
		{
			return List.Add( new BusinessInfo( businessKey, name ) );
		}

		public int Add(BusinessInfo businessInfo)
		{
			return List.Add(businessInfo);
		}

		public void Insert(int index, BusinessInfo value)
		{
			List.Insert(index, value);
		}

		public int IndexOf(BusinessInfo value)
		{
			return List.IndexOf(value);
		}

		public bool Contains(BusinessInfo value)
		{
			return List.Contains(value);
		}

		public void Remove(BusinessInfo value)
		{
			List.Remove(value);
		}

		public void CopyTo(BusinessInfo[] array, int index)
		{
			List.CopyTo(array, index);
		}

		public new BusinessInfoEnumerator GetEnumerator() 
		{
			return new BusinessInfoEnumerator( List.GetEnumerator() );
		}
	}

	public sealed class BusinessInfoEnumerator : IEnumerator
	{
		private IEnumerator enumerator;

		public BusinessInfoEnumerator( IEnumerator enumerator )
		{
			this.enumerator = enumerator;
		}

		public BusinessInfo Current
		{
			get  { return ( BusinessInfo ) enumerator.Current; }			
		}

		object IEnumerator.Current
		{
			get{ return enumerator.Current; }
		}

		public bool MoveNext()
		{
			return enumerator.MoveNext();
		}

		public void Reset()
		{	
			enumerator.Reset();
		}
	}

	public class BusinessEntityCollection : CollectionBase
	{
		public BusinessEntity this[int index]
		{
			get { return (BusinessEntity)List[index]; }
			set { List[index] = value; }
		}

		public int Add()
		{
			return List.Add( new BusinessEntity() );
		}
		
		public int Add( string businessKey )
		{
			return List.Add( new BusinessEntity( businessKey ) );
		}

		public int Add( BusinessEntity businessEntity )
		{
			return List.Add( businessEntity );
		}
		
		public void Insert( int index, BusinessEntity value )
		{
			List.Insert( index, value );
		}

		public int IndexOf( BusinessEntity value )
		{
			return List.IndexOf( value );
		}

		public bool Contains( BusinessEntity value )
		{
			return List.Contains( value );
		}

		public void Remove( BusinessEntity value )
		{
			List.Remove( value );
		}

		public void CopyTo( BusinessEntity[] array, int index )
		{
			List.CopyTo( array, index );
		}

		public new BusinessEntityEnumerator GetEnumerator() 
		{
			return new BusinessEntityEnumerator( List.GetEnumerator() );
		}
	}

	public sealed class BusinessEntityEnumerator : IEnumerator
	{
		private IEnumerator enumerator;

		public BusinessEntityEnumerator( IEnumerator enumerator )
		{
			this.enumerator = enumerator;
		}

		public BusinessEntity Current
		{
			get  { return ( BusinessEntity ) enumerator.Current; }			
		}

		object IEnumerator.Current
		{
			get{ return enumerator.Current; }
		}

		public bool MoveNext()
		{
			return enumerator.MoveNext();
		}

		public void Reset()
		{	
			enumerator.Reset();
		}
	}

	public class BusinessEntityExtCollection : CollectionBase
	{
		public BusinessEntityExt this[ int index ]
		{
			get { return ( BusinessEntityExt)List[index]; }
			set { List[ index ] = value; }
		}

		public int Add( string businessKey )
		{
			return List.Add( new BusinessEntityExt( businessKey ) );
		}

		public int Add( BusinessEntityExt businessEntityExt )
		{
			return List.Add( businessEntityExt );
		}
		
		public void Insert( int index, BusinessEntityExt value )
		{
			List.Insert( index, value );
		}

		public int IndexOf( BusinessEntityExt value )
		{
			return List.IndexOf( value );
		}

		public bool Contains( BusinessEntityExt value )
		{
			return List.Contains( value );
		}

		public void Remove( BusinessEntityExt value )
		{
			List.Remove( value );
		}

		public void CopyTo( BusinessEntityExt[] array, int index )
		{
			List.CopyTo( array, index );
		}

		public new BusinessEntityExtEnumerator GetEnumerator() 
		{
			return new BusinessEntityExtEnumerator( List.GetEnumerator() );
		}
	}

	public sealed class BusinessEntityExtEnumerator : IEnumerator
	{
		private IEnumerator enumerator;

		public BusinessEntityExtEnumerator( IEnumerator enumerator )
		{
			this.enumerator = enumerator;
		}

		public BusinessEntityExt Current
		{
			get  { return ( BusinessEntityExt ) enumerator.Current; }			
		}

		object IEnumerator.Current
		{
			get{ return enumerator.Current; }
		}

		public bool MoveNext()
		{
			return enumerator.MoveNext();
		}

		public void Reset()
		{	
			enumerator.Reset();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\sdk\contact.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.Xml.Serialization;

using Microsoft.Uddi;

namespace Microsoft.Uddi.Business
{	
	public class Contact : UddiCore
	{
		private string					useType;
		private string					personName;
		private DescriptionCollection	descriptions;		
		private PhoneCollection			phones;
		private EmailCollection			emails;
		private AddressCollection		addresses;

		public Contact() : this( "", "" ) 
		{}
		
		public Contact( string personName, string useType )
		{
			PersonName = personName;
			UseType	   = useType;
		}

		[XmlAttribute("useType")]
		public string UseType
		{
			get	{ return useType; }
			set { useType = value; }
		}

		[XmlElement("description")]
		public DescriptionCollection Descriptions
		{
			get
			{
				if( null == descriptions )
				{
					descriptions = new DescriptionCollection();
				}

				return descriptions;
			}

			set	{ descriptions = value; }
		}

		[XmlElement("personName")]
		public string PersonName
		{
			get { return personName; }
			set	{ personName = value; }
		}

		[XmlElement("phone")]
		public PhoneCollection Phones
		{
			get
			{
				if( null == phones )
				{
					phones = new PhoneCollection();
				}

				return phones;
			}

			set { phones = value; }
		}

		[XmlElement("email")]
		public EmailCollection Emails
		{
			get
			{
				if( null == emails )
				{
					emails = new EmailCollection();
				}

				return emails;
			}

			set { emails = value; }
		}

		[XmlElement("address")]
		public AddressCollection Addresses
		{
			get
			{
				if( null == addresses )
				{
					addresses = new AddressCollection();
				}

				return addresses;
			}

			set { addresses = value; }
		}	
	}

	public class ContactCollection : CollectionBase
	{
		public Contact this[ int index ]
		{
			get { return ( Contact)List[index]; }
			set { List[ index ] = value; }
		}

		public int Add( string personName )
		{
			return List.Add( new Contact( personName, null ) );
		}

		public int Add( string personName, string useType )
		{
			return List.Add( new Contact( personName, useType ) );
		}

		public int Add( Contact value )
		{
			return List.Add( value );
		}

		public void Insert( int index, Contact value )
		{
			List.Insert( index, value );
		}

		public int IndexOf( Contact value )
		{
			return List.IndexOf( value );
		}

		public bool Contains( Contact value )
		{
			return List.Contains( value );
		}

		public void Remove( Contact value )
		{
			List.Remove( value );
		}

		public void CopyTo( Contact[] array, int index )
		{
			List.CopyTo( array, index );
		}

		public new ContactEnumerator GetEnumerator() 
		{
			return new ContactEnumerator( List.GetEnumerator() );
		}
	}

	public sealed class ContactEnumerator : IEnumerator
	{
		private IEnumerator enumerator;

		public ContactEnumerator( IEnumerator enumerator )
		{
			this.enumerator = enumerator;
		}

		public Contact Current
		{
			get  { return ( Contact ) enumerator.Current; }			
		}

		object IEnumerator.Current
		{
			get{ return enumerator.Current; }
		}

		public bool MoveNext()
		{
			return enumerator.MoveNext();
		}

		public void Reset()
		{	
			enumerator.Reset();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\sdk\find.cs ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\sdk\coretypes.cs ===
using System;
using System.IO;
using System.Collections;
using System.Diagnostics;
using System.ComponentModel;
using System.Xml;
using System.Xml.Serialization;
using System.Collections.Specialized;

using Microsoft.Uddi.VersionSupport;

namespace Microsoft.Uddi
{		
	public enum AuthenticationMode
	{
		None					= 0,
		UddiAuthentication		= 1,
		WindowsAuthentication	= 2
	}
		
	public enum CompletionStatusType
	{
		[XmlEnum( "status:fromKey_incomplete" )]
		FromKeyIncomplete,
		[XmlEnum( "status:toKey_incomplete" )]
		ToKeyIncomplete,
		[XmlEnum( "status:complete" )]
		Complete,
	}
		
	public enum DirectionType
	{
		[XmlEnum( "fromKey" )]
		FromKey,
		[XmlEnum( "toKey" )]
		ToKey
	}

	public enum KeyType
	{
		[XmlEnum( "" )]
		Uninitialized,
		[XmlEnum( "businessKey" )]
		BusinessKey,
		[XmlEnum( "tModelKey" )]
		TModelKey,
		[XmlEnum( "serviceKey" )]
		ServiceKey,
		[XmlEnum( "bindingKey" )]
		BindingKey,
	}
	
	public enum UrlType
	{
		[XmlEnum( "mailto" )]
		Mailto = 1,
		[XmlEnum( "http" )]
		Http = 2,
		[XmlEnum( "https" )]
		Https = 3,
		[XmlEnum( "ftp" )]
		Ftp = 4,
		[XmlEnum( "fax" )]
		Fax = 5,
		[XmlEnum( "phone" )]
		Phone = 6,
		[XmlEnum( "other" )]
		Other = 7,
	}		
	
	public class UddiCore
	{
		private bool serializeMode;

		public UddiCore()
		{
			serializeMode = false;
		}

		//
		// This property should be internal virtual, but that will generate a warning CS0679 because the CLR does not support it.		
		// See (http://support.microsoft.com/default.aspx?scid=kb;EN-US;Q317129) for more information.
		//
		[XmlIgnore]
		public virtual bool SerializeMode
		{
			get { return serializeMode; }
			set { serializeMode = value; }
		}
	}

	public class UddiMessage : UddiCore
	{	
		private string generic;		
						
		public UddiMessage()
		{
			generic = UddiVersionSupport.CurrentGeneric;
		}		
		
		[XmlAttribute("generic")]
		public string Generic
		{
			get	{ return generic; }
			set	{ generic = value; }
		}				
	}

	public class UddiSecureMessage : UddiMessage
	{
		string authInfo;
	
		[XmlElement( "authInfo" )]
		public string AuthInfo
		{
			get { return authInfo; }
			set { authInfo = value; }
		}
	}

	public class UddiQueryMessage : UddiMessage
	{	
		protected int					  maxQueryRows;
		protected FindQualifierCollection queryFindQualifiers;
		
		public UddiQueryMessage()
		{
			maxQueryRows = Constants.DefaultMaxRows;			
		}
		
		[XmlAttribute("maxRows")]		
		public int MaxRows
		{
			get	{ return maxQueryRows; }
			set	{ maxQueryRows = value; }
		}

		[XmlArray("findQualifiers"), XmlArrayItem("findQualifier")]
		public FindQualifierCollection FindQualifiers
		{
			get
			{
				if( true == SerializeMode && 
					true == Utility.CollectionEmpty( queryFindQualifiers ) )
				{
					return null;
				}
				
				if( null == queryFindQualifiers )
				{
					queryFindQualifiers = new FindQualifierCollection();
				}

				return queryFindQualifiers;
			}

			set { queryFindQualifiers = value; }
		}		
	}

	public class FindQualifier
	{	
		public static readonly FindQualifier ExactNameMatch		 = new FindQualifier( "exactNameMatch" );
		public static readonly FindQualifier CaseSensitiveMatch	 = new FindQualifier( "caseSensitiveMatch" );
		public static readonly FindQualifier SortByNameAsc		 = new FindQualifier( "sortByNameAsc" );
		public static readonly FindQualifier SortByNameDesc		 = new FindQualifier( "sortByNameDesc" );
		public static readonly FindQualifier SortByDateAsc		 = new FindQualifier( "sortByDateAsc" );
		public static readonly FindQualifier SortByDateDesc		 = new FindQualifier( "sortByDateDesc" );
		public static readonly FindQualifier OrLikeKeys			 = new FindQualifier( "orLikeKeys" );
		public static readonly FindQualifier OrAllKeys			 = new FindQualifier( "orAllKeys" );
		public static readonly FindQualifier CombineCategoryBags = new FindQualifier( "combineCategoryBags" );
		public static readonly FindQualifier ServiceSubset		 = new FindQualifier( "serviceSubset" );
		public static readonly FindQualifier AndAllKeys			 = new FindQualifier( "andAllKeys" );
		
		private string findQualifier;

		public FindQualifier() 
		{}

		public FindQualifier( string findQualifier )
		{
			this.Value = findQualifier;
		}

		[XmlText]
		public string Value
		{
			get { return findQualifier; }
			set { findQualifier = value; }
		}		
	}

	public class ErrInfo
	{
		private string errCode;
		private string text;

		[XmlAttribute( "errCode" )]
		public string ErrCode
		{
			get	{ return errCode; }
			set	{ errCode = value; }
		}

		[XmlText]
		public string Text
		{
			get	{ return text; }
			set	{ text = value;	}
		}
	}

	public class Result
	{
		private KeyType keyType;
		private int		errNo;
		private ErrInfo errInfo;

		public Result()
		{			
			keyType = KeyType.Uninitialized;
			errNo   = 0;
			errInfo = new ErrInfo();
		}

		[XmlAttribute( "keyType" )]
		public KeyType KeyType
		{
			get { return keyType; }
			set	{ keyType = value; }
		}

		[XmlAttribute( "errno" )]
		public int Errno
		{
			get	{ return errNo; }
			set	{ errNo = value; }
		}

		[XmlElement( "errInfo" )]
		public ErrInfo ErrInfo
		{
			get{ return errInfo; }
			set { errInfo = value; }
		}
	}

	[XmlRootAttribute("dispositionReport", Namespace=Microsoft.Uddi.VersionSupport.UddiVersionSupport.CurrentNamespace)]
	public class DispositionReport
	{		
		private string				node;
		private bool				truncated;
		private ResultCollection	results;

		[XmlAttribute("operator")]
		public string Operator
		{
			get	{ return node; }
			set	{ node = value; }
		}
		
		[XmlAttribute("truncated")]
		public bool Truncated
		{
			get	{ return truncated; }		
			set { truncated = value; }
		}
		
		[XmlElement("result")]
		public ResultCollection Results
		{
			get
			{
				if( null == results )
				{
					results = new ResultCollection();
				}

				return results;
			}

			set { results = value; }
		}		
	}

	internal sealed class Constants
	{		
		public const int DefaultMaxRows = 1000;

		private Constants()
		{
			//
			// Don't let anyone construct an instance of this class.
			//
		}
	}

	internal sealed class Utility
	{
		internal static bool CollectionEmpty( StringCollection col )
		{
			return null == col || 0 == col.Count;
		}

		internal static bool CollectionEmpty( CollectionBase col )
		{
			return null == col || 0 == col.Count;
		}

		internal static bool StringEmpty( string str )
		{
			return null == str || 0 == str.Length;
		}

		private Utility()
		{
			//
			// Don't let anyone construct an instance of this class.
			//
		}
	}

	public class FindQualifierCollection : CollectionBase, IEnumerator
	{
		public FindQualifierCollection()
		{}

		public FindQualifier this[int index]
		{
			get { return (FindQualifier)List[index]; }
			set { List[index] = value; }
		}
				
		public int Add( string findQualifier )
		{
			return List.Add( new FindQualifier( findQualifier ) );
		}
		
		public int Add( FindQualifier findQualifier )
		{
			return List.Add( findQualifier );
		}
		
		public void Insert(int index, FindQualifier value)
		{
			List.Insert(index, value);
		}
		
		public int IndexOf(FindQualifier value)
		{
			return List.IndexOf(value);
		}
		
		public bool Contains(FindQualifier value)
		{
			return List.Contains(value);
		}
		
		public void Remove(FindQualifier value)
		{
			List.Remove(value);
		}
		
		public void CopyTo(FindQualifier[] array, int index)
		{
			InnerList.CopyTo(array, index);
		}

		//
		// IEnumerator methods
		//
		public FindQualifier Current
		{
			get  { return ( FindQualifier ) base.GetEnumerator().Current; }			
		}

		object IEnumerator.Current
		{
			get{ return base.GetEnumerator().Current; }
		}

		public bool MoveNext()
		{
			return base.GetEnumerator().MoveNext();
		}

		public void Reset()
		{	
			base.GetEnumerator().Reset();
		}
	}

	public class ResultCollection : CollectionBase
	{
		public Result this[int index]
		{
			get { return (Result)List[index]; }
			set { List[index] = value; }
		}
		
		public int Add(Result value)
		{
			return List.Add(value);
		}
		
		public void Insert(int index, Result value)
		{
			List.Insert(index, value);
		}
		
		public int IndexOf(Result value)
		{
			return List.IndexOf(value);
		}
		
		public bool Contains(Result value)
		{
			return List.Contains(value);
		}
		
		public void Remove(Result value)
		{
			List.Remove(value);
		}
		
		public void CopyTo(Result[] array, int index)
		{
			List.CopyTo(array, index);
		}

		public new ResultEnumerator GetEnumerator() 
		{
			return new ResultEnumerator( List.GetEnumerator() );
		}
	}

	public sealed class ResultEnumerator : IEnumerator
	{
		private IEnumerator enumerator;

		public ResultEnumerator( IEnumerator enumerator )
		{
			this.enumerator = enumerator;
		}

		public Result Current
		{
			get  { return ( Result ) enumerator.Current; }			
		}

		object IEnumerator.Current
		{
			get{ return enumerator.Current; }
		}

		public bool MoveNext()
		{
			return enumerator.MoveNext();
		}

		public void Reset()
		{	
			enumerator.Reset();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\sdk\category.cs ===
using System;
using System.Web;
using System.IO;
using System.Xml;
using System.Xml.Schema;
using System.Collections;
using System.Data.SqlClient;
using System.Xml.Serialization;

using Microsoft.Uddi;
using Microsoft.Uddi.Business;
using Microsoft.Uddi.ServiceType;
using Microsoft.Uddi.Service;
using Microsoft.Uddi.Binding;
using Microsoft.Uddi.VersionSupport;

namespace Microsoft.Uddi.Extensions
{	
	public enum RelationshipQualifier
	{
		root	= 1, 
		parent	= 2, 
		child	= 3
	}
	
	[XmlRoot( "get_relatedCategories", Namespace=Microsoft.Uddi.Extensions.Namespaces.GetRelatedCategories)]
	public class GetRelatedCategories : UddiCore
	{
		private CategoryCollection categories;
		
		[XmlElement("category")]
		public CategoryCollection Categories
		{
			get
			{
				if( true == SerializeMode &&
					true == Utility.CollectionEmpty( categories ) )
				{
					return null;
				}

				if( null == categories )
				{
					categories = new CategoryCollection();
				}

				return categories;
			}
			set
			{
				categories = value;
			}
		}		
	}

	[XmlRoot( "categoryList", Namespace=Microsoft.Uddi.Extensions.Namespaces.GetRelatedCategories)]
	public class CategoryList : UddiCore
	{	
		private bool				   truncated;
		private string				   operatorValue;		
		private CategoryInfoCollection categoryInfos;

		public CategoryList()
		{
			truncated = false;
		}

		[XmlAttribute( "truncated" )]
		public bool Truncated
		{
			get { return truncated; }
			set { truncated = value; }
		}
	    
		[XmlAttribute( "operator" )]
		public string Operator
		{
			get { return operatorValue; }
			set { operatorValue = value; }
		}
		
		[XmlElement( "categoryInfo" )]
		public CategoryInfoCollection CategoryInfosSerialize
		{
			get 
			{
				if( null == categoryInfos )
				{
					categoryInfos = new CategoryInfoCollection();
				}
				
				return categoryInfos;
			}
			set { categoryInfos = value; }
		}		
	}

	[XmlRoot("category", Namespace=Microsoft.Uddi.Extensions.Namespaces.GetRelatedCategories)]
	public class CategoryInfo : CategoryValue
	{		
		private CategoryValueCollection roots;
		private CategoryValueCollection parents;
		private CategoryValueCollection children;

		public CategoryInfo()
		{}

		public CategoryInfo( string tmodelkey, string keyvalue ) : base( tmodelkey, keyvalue )
		{}
			
		[XmlArray( "rootRelationship" ), XmlArrayItem( "categoryValue" )]
		public CategoryValueCollection Roots
		{
			get
			{
				if( null == roots )
				{
					roots = new CategoryValueCollection();
				}

				return roots;
			}
			set { roots = value; }
		}

		[XmlArray( "parentRelationship" ), XmlArrayItem( "categoryValue" )]
		public CategoryValueCollection Parents
		{
			get
			{
				if( null == parents )
				{
					parents = new CategoryValueCollection();
				}

				return parents;
			}
			set { parents = value; }
		}

		[XmlArray( "childRelationship" ), XmlArrayItem( "categoryValue" )]
		public CategoryValueCollection Children
		{
			get
			{
				if( null == children )
				{
					children = new CategoryValueCollection();
				}

				return children;
			}
			set { children = value; }
		}
	}
	
	[XmlInclude( typeof( CategoryInfo ) )]
	public class CategoryValue : UddiCore
	{	
		private bool	isValid;
		private string	tModelKey;
		private string	keyName;
		private string	keyValue;
		private string	parentKeyValue;
		
		public CategoryValue()
		{}

		public CategoryValue( string tModelKey, string keyValue )
		{
			TModelKey = tModelKey;
			KeyValue  = keyValue;
		}

		public CategoryValue( string keyName, string keyValue, string parentKeyValue, bool isValid )
		{
			KeyName			= keyName;
			KeyValue		= keyValue;
			ParentKeyValue	= parentKeyValue;
			IsValid			= isValid;
		}		

		[XmlAttribute( "tModelKey" )]
		public string TModelKey
		{
			get { return tModelKey; }
			set { tModelKey = value; }
		}

		[XmlAttribute( "keyName" )]
		public string KeyName
		{
			get { return keyName; }
			set { keyName = value; }
		}

		[XmlAttribute( "keyValue" )]
		public string KeyValue
		{
			get { return keyValue; }
			set { keyValue = value; }
		}

		[XmlAttribute( "parentKeyValue" )]
		public string ParentKeyValue
		{
			get { return parentKeyValue; }
			set { parentKeyValue = value; }
		}

		[XmlAttribute( "isValid" )]
		public bool IsValid
		{
			get { return isValid; }
			set { isValid = value; }
		}
	}

	public class Category : UddiCore
	{				
		private string							tModelKey;	    
		private string							keyValue;
		private RelationshipQualifierCollection relationshipQualifiers;	    	

		[XmlElement( "relationshipQualifier" )]
		public RelationshipQualifierCollection RelationshipQualifiers
		{
			get
			{
				if( true == SerializeMode &&
					true == Utility.CollectionEmpty( relationshipQualifiers ) )
				{
					return null;
				}

				if( null == relationshipQualifiers )
				{
					relationshipQualifiers = new RelationshipQualifierCollection();
				}

				return relationshipQualifiers;
			}
			set { relationshipQualifiers = value; }
		}
	    
		[XmlAttribute( "tModelKey" )]
		public string TModelKey
		{
			get { return tModelKey; }
			set { tModelKey = value; }
		}
	    
		[XmlAttribute( "keyValue" )]
		public string KeyValue
		{
			get { return keyValue; }
			set { keyValue = value; }
		}
	}
	
	public class RelationshipQualifierCollection : CollectionBase
	{
		public RelationshipQualifierCollection()
		{}

		public RelationshipQualifier this[int index]
		{
			get { return (RelationshipQualifier)List[index]; }
			set { List[index] = value; }
		}
		
		public int Add( RelationshipQualifier relationshipQualifier )
		{
			return List.Add( relationshipQualifier );
		}

		public void Insert( int index, CategoryValue value )
		{
			List.Insert(index, value);
		}
		
		public int IndexOf( RelationshipQualifier value )
		{
			return List.IndexOf( value );
		}
		
		public bool Contains( RelationshipQualifier value )
		{
			return List.Contains( value );
		}
		
		public void Remove( RelationshipQualifier value )
		{
			List.Remove( value );
		}
		
		public void CopyTo(RelationshipQualifier[] array, int index)
		{
			List.CopyTo( array, index );
		}

		public new RelationshipQualifierEnumerator GetEnumerator() 
		{
			return new RelationshipQualifierEnumerator( List.GetEnumerator() );
		}
	}

	public sealed class RelationshipQualifierEnumerator : IEnumerator
	{
		private IEnumerator enumerator;

		public RelationshipQualifierEnumerator( IEnumerator enumerator )
		{
			this.enumerator = enumerator;
		}

		public RelationshipQualifier Current
		{
			get  { return ( RelationshipQualifier ) enumerator.Current; }			
		}

		object IEnumerator.Current
		{
			get{ return enumerator.Current; }
		}

		public bool MoveNext()
		{
			return enumerator.MoveNext();
		}

		public void Reset()
		{	
			enumerator.Reset();
		}
	}

	
	public class CategoryValueCollection : CollectionBase
	{
		public CategoryValueCollection()
		{}

		public CategoryValue this[int index]
		{
			get { return (CategoryValue)List[index]; }
			set { List[index] = value; }
		}

		public int Add( string keyname, string keyvalue, string parent, bool isvalid )
		{
			return List.Add( new CategoryValue( keyname, keyvalue, parent, isvalid ) );
		}

		public int Add(CategoryValue value)
		{
			return List.Add(value);
		}

		public void Insert(int index, CategoryValue value)
		{
			List.Insert(index, value);
		}
		
		public int IndexOf( CategoryValue value )
		{
			return List.IndexOf( value );
		}
		
		public bool Contains( CategoryValue value )
		{
			return List.Contains( value );
		}
		
		public void Remove( CategoryValue value )
		{
			List.Remove( value );
		}
		
		public void CopyTo(CategoryValue[] array, int index)
		{
			List.CopyTo( array, index );
		}

		public new CategoryValueEnumerator GetEnumerator() 
		{
			return new CategoryValueEnumerator( List.GetEnumerator() );
		}
	}

	public sealed class CategoryValueEnumerator : IEnumerator
	{
		private IEnumerator enumerator;

		public CategoryValueEnumerator( IEnumerator enumerator )
		{
			this.enumerator = enumerator;
		}

		public CategoryValue Current
		{
			get  { return ( CategoryValue ) enumerator.Current; }			
		}

		object IEnumerator.Current
		{
			get{ return enumerator.Current; }
		}

		public bool MoveNext()
		{
			return enumerator.MoveNext();
		}

		public void Reset()
		{	
			enumerator.Reset();
		}
	}

	public class CategoryCollection : CollectionBase
	{
		public CategoryCollection()
		{}

		public Category this[int index]
		{
			get { return (Category)List[index]; }
			set { List[index] = value; }
		}

		public int Add(Category value)
		{
			return List.Add(value);
		}

		public void Insert(int index, Category value)
		{
			List.Insert(index, value);
		}
		
		public int IndexOf( Category value )
		{
			return List.IndexOf( value );
		}
		
		public bool Contains( Category value )
		{
			return List.Contains( value );
		}
		
		public void Remove( Category value )
		{
			List.Remove( value );
		}
		
		public void CopyTo(Category[] array, int index)
		{
			List.CopyTo( array, index );
		}

		public new CategoryEnumerator GetEnumerator() 
		{
			return new CategoryEnumerator( List.GetEnumerator() );
		}
	}

	public sealed class CategoryEnumerator : IEnumerator
	{
		private IEnumerator enumerator;

		public CategoryEnumerator( IEnumerator enumerator )
		{
			this.enumerator = enumerator;
		}

		public Category Current
		{
			get  { return ( Category ) enumerator.Current; }			
		}

		object IEnumerator.Current
		{
			get{ return enumerator.Current; }
		}

		public bool MoveNext()
		{
			return enumerator.MoveNext();
		}

		public void Reset()
		{	
			enumerator.Reset();
		}
	}

	public class CategoryInfoCollection : CollectionBase
	{
		public CategoryInfoCollection()
		{}

		public CategoryInfo this[int index]
		{
			get { return (CategoryInfo)List[index]; }
			set { List[index] = value; }
		}

		public int Add(CategoryInfo value)
		{
			return List.Add(value);
		}

		public void Insert(int index, CategoryInfo value)
		{
			List.Insert(index, value);
		}
		
		public int IndexOf( CategoryInfo value )
		{
			return List.IndexOf( value );
		}
		
		public bool Contains( CategoryInfo value )
		{
			return List.Contains( value );
		}
		
		public void Remove( CategoryInfo value )
		{
			List.Remove( value );
		}
		
		public void CopyTo(CategoryInfo[] array, int index)
		{
			List.CopyTo( array, index );
		}

		public CategoryInfo[] ToArray()
		{
			return (CategoryInfo[]) InnerList.ToArray( typeof( CategoryInfo ) );
		}

		public new CategoryInfoEnumerator GetEnumerator() 
		{
			return new CategoryInfoEnumerator( List.GetEnumerator() );
		}
	}

	public sealed class CategoryInfoEnumerator : IEnumerator
	{
		private IEnumerator enumerator;

		public CategoryInfoEnumerator( IEnumerator enumerator )
		{
			this.enumerator = enumerator;
		}

		public CategoryInfo Current
		{
			get  { return ( CategoryInfo ) enumerator.Current; }			
		}

		object IEnumerator.Current
		{
			get{ return enumerator.Current; }
		}

		public bool MoveNext()
		{
			return enumerator.MoveNext();
		}

		public void Reset()
		{	
			enumerator.Reset();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\sdk\discoveryurl.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.Xml.Serialization;

using Microsoft.Uddi;

namespace Microsoft.Uddi.Business
{
	public class DiscoveryUrl : UddiCore
	{
		private string text;
		private string useType;

		public DiscoveryUrl() : this( "", "" ) 
		{}

		public DiscoveryUrl( string url ) : this( url, "" ) 
		{}

		public DiscoveryUrl( string url, string useType )
		{
			Text	= url;
			UseType = useType;
		}

		[XmlText]
		public string Text
		{
			get { return text; }
			set	{ text = value; }
		}

		[XmlAttribute("useType")]
		public string UseType
		{
			get	{ return useType; }
			set	{ useType = value; }
		}		
	}

	public class DiscoveryUrlCollection : CollectionBase
	{
		public DiscoveryUrl this[int index]
		{
			get { return (DiscoveryUrl)List[index]; }
			set { List[index] = value; }
		}
		
		public int Add( DiscoveryUrl value )
		{
			return List.Add( value );
		}

		public int Add( string strUrl )
		{
			return List.Add( new DiscoveryUrl( strUrl ) );	
		}

		public int Add( string strUrl, string strUseType )
		{
			return List.Add( new DiscoveryUrl( strUrl, strUseType ) );
		}

		public void Insert( int index, DiscoveryUrl value )
		{
			List.Insert( index, value );
		}

		public int IndexOf( DiscoveryUrl value )
		{
			return List.IndexOf( value );
		}

		public bool Contains( DiscoveryUrl value )
		{
			return List.Contains( value );
		}

		public void Remove( DiscoveryUrl value )
		{
			List.Remove(value);
		}

		public void CopyTo( DiscoveryUrl[] array, int index )
		{
			List.CopyTo( array, index );
		}

		public new DiscoveryUrlEnumerator GetEnumerator() 
		{
			return new DiscoveryUrlEnumerator( List.GetEnumerator() );
		}
	}

	public sealed class DiscoveryUrlEnumerator : IEnumerator
	{
		private IEnumerator enumerator;

		public DiscoveryUrlEnumerator( IEnumerator enumerator )
		{
			this.enumerator = enumerator;
		}

		public DiscoveryUrl Current
		{
			get  { return ( DiscoveryUrl ) enumerator.Current; }			
		}

		object IEnumerator.Current
		{
			get{ return enumerator.Current; }
		}

		public bool MoveNext()
		{
			return enumerator.MoveNext();
		}

		public void Reset()
		{	
			enumerator.Reset();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\sdk\description.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.Xml.Serialization;

namespace Microsoft.Uddi
{
	public class Description : UddiCore
	{
		private string isoLanguageCode;
		private string text;
	
		public Description() : this( "", "" ) 
		{}

		public Description( string description ) : this( "en", description ) 
		{}

		public Description( string languageCode, string description )
		{
			IsoLanguageCode = languageCode;
			Text			= description;
		}

		[XmlAttribute("xml:lang")]
		public string IsoLanguageCode
		{
			get	{ return isoLanguageCode; }
			set { isoLanguageCode = value; }
		}

		[XmlText]
		public string Text
		{
			get	{ return text; }
			set	{ text = value; }
		}		
	}

	public class DescriptionCollection : CollectionBase
	{
		public Description this[int index]
		{
			get { return (Description)List[index]; }
			set { List[index] = value; }
		}

		public int Add(Description value)
		{
			return List.Add(value);
		}

		public int Add(string value)
		{
			return List.Add( new Description(value) );
		}

		public int Add(string langCode, string description)
		{
			return List.Add( new Description(langCode, description) );
		}

		public void Insert(int index, Description value)
		{
			List.Insert(index, value);
		}
		
		public int IndexOf(Description value)
		{
			return List.IndexOf(value);
		}
		
		public bool Contains(Description value)
		{
			return List.Contains(value);
		}
		
		public void Remove(Description value)
		{
			List.Remove(value);
		}
		
		public void CopyTo(Description[] array, int index)
		{
			List.CopyTo(array, index);
		}

		public new DescriptionEnumerator GetEnumerator() 
		{
			return new DescriptionEnumerator( List.GetEnumerator() );
		}
	}

	public sealed class DescriptionEnumerator : IEnumerator
	{
		private IEnumerator enumerator;

		public DescriptionEnumerator( IEnumerator enumerator )
		{
			this.enumerator = enumerator;
		}

		public Description Current
		{
			get  { return ( Description ) enumerator.Current; }			
		}

		object IEnumerator.Current
		{
			get{ return enumerator.Current; }
		}

		public bool MoveNext()
		{
			return enumerator.MoveNext();
		}

		public void Reset()
		{	
			enumerator.Reset();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\sdk\email.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.Xml.Serialization;

using Microsoft.Uddi;

namespace Microsoft.Uddi.Business
{
	public class Email : UddiCore
	{
		private string useType;
		private string text;
	
		public Email() : this( "", "" ) 
		{}

		public Email( string email, string useType )
		{
			Text	= email;
			UseType = useType;
		}

		[XmlAttribute("useType")]
		public string UseType
		{
			get	{ return useType; }
			set	{ useType = value; }
		}

		[XmlText()]
		public string Text
		{
			get	{ return text; }
			set { text = value; }
		}
	}

	public class EmailCollection : CollectionBase
	{
		public Email this[ int index ]
		{
			get { return (Email)List[index]; }
			set { List[ index ] = value; }
		}
		
		public int Add( Email emailObject )
		{
			return List.Add( emailObject );
		}

		public int Add( string email )
		{
			return ( Add( email, null ) );
		}

		public int Add( string email, string useType )
		{
			return List.Add( new Email( email, useType ) );
		}

		public void Insert( int index, Email value )
		{
			List.Insert( index, value );
		}

		public int IndexOf( Email value )
		{
			return List.IndexOf( value );
		}

		public bool Contains( Email value )
		{
			return List.Contains( value );
		}

		public void Remove( Email value )
		{
			List.Remove( value );
		}

		public void CopyTo( Email[] array, int index )
		{
			List.CopyTo( array, index );
		}

		public new EmailEnumerator GetEnumerator() 
		{
			return new EmailEnumerator( List.GetEnumerator() );
		}
	}

	public sealed class EmailEnumerator : IEnumerator
	{
		private IEnumerator enumerator;

		public EmailEnumerator( IEnumerator enumerator )
		{
			this.enumerator = enumerator;
		}

		public Email Current
		{
			get  { return ( Email ) enumerator.Current; }			
		}

		object IEnumerator.Current
		{
			get{ return enumerator.Current; }
		}

		public bool MoveNext()
		{
			return enumerator.MoveNext();
		}

		public void Reset()
		{	
			enumerator.Reset();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\sdk\exception.cs ===
using System;
using System.IO;
using System.Xml.Serialization;
using System.Web.Services.Protocols;

using Microsoft.Uddi.VersionSupport;

namespace Microsoft.Uddi
{
	public class UddiException : ApplicationException
	{		
		private DispositionReport	 dispositionReport;
		private bool				 hasDispositionReportData;						
		private static XmlSerializer serializer = null;
		
		public enum ErrorType
		{
			E_success					= 0,
			E_nameTooLong				= 10020,
			E_tooManyOptions			= 10030,
			E_unrecognizedVersion		= 10040,
			E_unsupported				= 10050,
			E_languageError				= 10060,
			E_authTokenExpired			= 10110,
			E_authTokenRequired			= 10120,
			E_operatorMismatch			= 10130,
			E_userMismatch				= 10140,
			E_unknownUser				= 10150,
			E_accountLimitExceeded		= 10160,
			E_invalidKeyPassed			= 10210,
			E_invalidURLPassed			= 10220,
			E_keyRetired				= 10310,
			E_busy						= 10400,
			E_fatalError				= 10500,
			E_invalidCategory			= 20000,
			E_categorizationNotAllowed	= 20100
		}


		public UddiException( string message ) : base( message )
		{
			dispositionReport		 = null;
			hasDispositionReportData = false;						
		}

		public UddiException( Exception exception ) : base( "", exception )
		{
			dispositionReport		 = null;
			hasDispositionReportData = false;			

		}

		public UddiException( SoapException soapException ) : base( "", soapException )
		{			
			dispositionReport		 = null;
			hasDispositionReportData = false;			
			
			//
			// The soap exception passed in SHOULD contain a disposition report.
			// Deserialize it into an object and use the error number in this exception
			//
			if( false == Utility.StringEmpty( soapException.Detail.InnerXml ) )
			{
				//
				// Translate the XML into the current version.
				//
				string dispositionReportXml = UddiVersionSupport.Translate( soapException.Detail.InnerXml, UddiVersionSupport.CurrentVersion );

				StringReader reader = new StringReader( dispositionReportXml );				
				if( null == serializer )
				{
					serializer = new XmlSerializer( typeof( DispositionReport ) );
				}

				dispositionReport = ( DispositionReport ) serializer.Deserialize( reader );
				reader.Close();									
			}			
			
			hasDispositionReportData = ( null != dispositionReport )&&
									   ( null != dispositionReport.Results ) &&
									   ( dispositionReport.Results.Count > 0 );
		}

		//
		// This property makes what we expect to be a commonly used piece of information more visible.
		//
		public ErrorType Type
		{
			get	
			{ 
				if( true == hasDispositionReportData )
				{
					//
					// Only return the first result, this is the most common case.  The use can access the 
					// full DispositionReport object if they are interested in the full results.
					//
					return ( ErrorType )dispositionReport.Results[0].Errno;
				}
				else
				{
					return ErrorType.E_fatalError;
				}
			}
		}		

		public override string Message
		{
			get
			{
				if( true == hasDispositionReportData )
				{	
					//
					// Only return the first result, this is the most common case.  The use can access the 
					// full DispositionReport object if they are interested in the full results.
					//
					return dispositionReport.Results[0].ErrInfo.Text;
				}
				else
				{
					return InnerException.Message;
				}
			}
		}		
		
		public DispositionReport DispositionReport
		{
			get { return dispositionReport; }
		}		
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\sdk\types.cs ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\sdk\keyedreference.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.Xml.Serialization;

namespace Microsoft.Uddi
{
	public class KeyedReference : UddiCore
	{
		private string tModelKey;
		private string keyName;
		private string keyValue;

		public KeyedReference() : this( "", "", "" ) 
		{}

		public KeyedReference(string keyName, string keyValue) : this( keyName, keyValue, "" ) 
		{}

		public KeyedReference(string keyName, string keyValue, string tModelKey )
		{
			KeyName  = keyName;
			KeyValue  = keyValue;
			TModelKey = tModelKey;
		}

		[XmlAttribute("tModelKey")]
		public string TModelKey
		{
			get	{ return tModelKey; }
			set	{ tModelKey = value; }
		}

		[XmlAttribute("keyName")]
		public string KeyName
		{
			get	{ return keyName; }
			set	{ keyName = value; }
		}

		[XmlAttribute("keyValue")]
		public string KeyValue
		{
			get	{ return keyValue; }
			set	{ keyValue = value; }
		}		
	}

	public class KeyedReferenceCollection : CollectionBase
	{
		public KeyedReference this[int index]
		{
			get { return (KeyedReference)List[index]; }
			set { List[index] = value; }
		}
		
		public int Add(KeyedReference value)
		{
			return List.Add(value);
		}
		
		public int Add( string name, string value )
		{
			return List.Add( new KeyedReference( name, value ) );
		}

		public int Add( string name, string value, string key )
		{
			return List.Add( new KeyedReference( name, value, key ) );
		}
				
		public void Insert(int index, KeyedReference value)
		{
			List.Insert(index, value);
		}
		
		public int IndexOf(KeyedReference value)
		{
			return List.IndexOf(value);
		}

		public bool Contains(KeyedReference value)
		{
			return List.Contains(value);
		}

		public void Remove(KeyedReference value)
		{
			List.Remove(value);
		}

		public void CopyTo(KeyedReference[] array, int index)
		{
			InnerList.CopyTo(array, index);
		}

		public new KeyedReferenceEnumerator GetEnumerator() 
		{
			return new KeyedReferenceEnumerator( List.GetEnumerator() );
		}
	}

	public sealed class KeyedReferenceEnumerator : IEnumerator
	{
		private IEnumerator enumerator;

		public KeyedReferenceEnumerator( IEnumerator enumerator )
		{
			this.enumerator = enumerator;
		}

		public KeyedReference Current
		{
			get  { return ( KeyedReference ) enumerator.Current; }			
		}

		object IEnumerator.Current
		{
			get{ return enumerator.Current; }
		}

		public bool MoveNext()
		{
			return enumerator.MoveNext();
		}

		public void Reset()
		{	
			enumerator.Reset();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\sdk\makefile.inc ===
foo.cs:
	..\version\$(O)\version.exe -outfile .\assemblyversioninfo.cs
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\sdk\extensions.cs ===
using System;
using System.Web;
using System.IO;
using System.Xml;
using System.Xml.Schema;
using System.Collections;
using System.Data.SqlClient;
using System.Xml.Serialization;

using Microsoft.Uddi;

namespace Microsoft.Uddi.Extensions
{
	//
	// All Extension namespaces should go in here
	//
	public sealed class Namespaces
	{			
		public const string GetRelatedCategories = "urn:uddi-microsoft-com:api_v2_extensions";

		private Namespaces()
		{
			//
			// Don't let anyone construct an instance of this class
			//
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\sdk\phone.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.Xml.Serialization;

namespace Microsoft.Uddi.Business
{
	public class Phone : UddiCore
	{
		private string text;
		private string useType;

		public Phone() : this( "", "" ) 
		{}

		public Phone(string phone, string useType)
		{
			Text	= phone;
			UseType = useType;
		}

		[XmlText]
		public string Text
		{
			get	{ return text; }
			set	{ text = value;	}
		}

		[XmlAttribute("useType")]
		public string UseType
		{
			get	{ return useType; }
			set	{ useType = value; }
		}		
	}

	public class PhoneCollection : CollectionBase
	{
		public Phone this[int index]
		{
			get { return ( Phone )List[ index]; }
			set { List[ index ] = value; }
		}

		public int Add( Phone phoneObject )
		{
			return List.Add( phoneObject );
		}

		public int Add( string phone )
		{
			return( Add( phone, null ) );
		}

		public int Add( string phone, string useType )
		{
			return List.Add( new Phone( phone, useType ) );
		}

		public void Insert( int index, Phone value )
		{
			List.Insert( index, value );
		}

		public int IndexOf( Phone value )
		{
			return List.IndexOf( value );
		}

		public bool Contains( Phone value )
		{
			return List.Contains( value );
		}

		public void Remove( Phone value )
		{
			List.Remove( value );
		}

		public void CopyTo( Phone[] array, int index )
		{
			List.CopyTo( array, index );
		}

		public new PhoneEnumerator GetEnumerator() 
		{
			return new PhoneEnumerator( List.GetEnumerator() );
		}
	}

	public sealed class PhoneEnumerator : IEnumerator
	{
		private IEnumerator enumerator;

		public PhoneEnumerator( IEnumerator enumerator )
		{
			this.enumerator = enumerator;
		}

		public Phone Current
		{
			get  { return ( Phone ) enumerator.Current; }			
		}

		object IEnumerator.Current
		{
			get{ return enumerator.Current; }
		}

		public bool MoveNext()
		{
			return enumerator.MoveNext();
		}

		public void Reset()
		{	
			enumerator.Reset();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\sdk\name.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.Xml.Serialization;

namespace Microsoft.Uddi
{
	public class Name : UddiCore
	{
		private string isoLanguageCode;
		private string text;
	
		public Name() : this( "", "" ) 
		{}

		public Name( string name ) : this( "en", name ) 
		{}

		public Name( string languageCode, string name )
		{
			IsoLanguageCode = languageCode;
			Text			= name;
		}

		[ XmlAttribute( "xml:lang" ) ]
		public string IsoLanguageCode
		{
			get	{ return isoLanguageCode; }
			set { isoLanguageCode = value; }
		}

		[ XmlText ]
		public string Text
		{
			get	{ return text; }
			set	{ text = value; }
		}		
	}

	public class NameCollection : CollectionBase
	{
		public Name this[ int index ]
		{
			get { return (Name)List[ index ]; }
			set { List[ index ] = value; }
		}

		public int Add( Name value )
		{
			return List.Add( value );
		}

		public int Add( string value )
		{
			return List.Add( new Name( value ) );
		}

		public int Add( string langCode, string name )
		{
			return List.Add( new Name( langCode, name ) );
		}

		public void Insert( int index, Name value )
		{
			List.Insert( index, value );
		}
		
		public int IndexOf( Name value )
		{
			return List.IndexOf( value );
		}
		
		public bool Contains( Name value )
		{
			return List.Contains( value );
		}
		
		public void Remove( Name value )
		{
			List.Remove( value );
		}
		
		public void CopyTo( Name[] array, int index )
		{
			List.CopyTo( array, index );
		}

		public new NameEnumerator GetEnumerator() 
		{
			return new NameEnumerator( List.GetEnumerator() );
		}
	}

	public sealed class NameEnumerator : IEnumerator
	{
		private IEnumerator enumerator;

		public NameEnumerator( IEnumerator enumerator )
		{
			this.enumerator = enumerator;
		}

		public Name Current
		{
			get  { return ( Name ) enumerator.Current; }			
		}

		object IEnumerator.Current
		{
			get{ return enumerator.Current; }
		}

		public bool MoveNext()
		{
			return enumerator.MoveNext();
		}

		public void Reset()
		{	
			enumerator.Reset();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\sdk\service.cs ===
using System;
using System.Collections;
using System.Collections.Specialized;
using System.Diagnostics;
using System.ComponentModel;
using System.Xml.Serialization;

using Microsoft.Uddi;
using Microsoft.Uddi.Binding;
using Microsoft.Uddi.Service;
using Microsoft.Uddi.ServiceType;

namespace Microsoft.Uddi.Service
{
	[XmlRootAttribute("delete_service", Namespace=Microsoft.Uddi.VersionSupport.UddiVersionSupport.CurrentNamespace)]
	public class DeleteService : UddiSecureMessage
	{				
		private StringCollection serviceKeys;
				
		[XmlElement("serviceKey")]
		public StringCollection ServiceKeys
		{
			get
			{
				if( null == serviceKeys )
				{
					serviceKeys = new StringCollection();
				}

				return serviceKeys;
			}

			set { serviceKeys = value; }
		}		
	}

	[XmlRootAttribute("find_service", Namespace=Microsoft.Uddi.VersionSupport.UddiVersionSupport.CurrentNamespace)]
	public class FindService : UddiQueryMessage
	{				
		private string					 businessKey;		
		private NameCollection			 names;
		private KeyedReferenceCollection categoryBag;
		private StringCollection		 tModelKeys;		
			
		[XmlAttribute("businessKey")]
		public string BusinessKey
		{
			get	{ return businessKey; }
			set	{ businessKey = value; }
		}
				
		[XmlElement("name")]
		public NameCollection Names
		{
			get	
			{ 
				if( null == names )
				{
					names = new NameCollection();
				}

				return names; 
			}

			set	{ names = value; }
		}

		[XmlArray("categoryBag"), XmlArrayItem("keyedReference")]
		public KeyedReferenceCollection CategoryBag
		{
			get
			{
				if( true == SerializeMode && 
					true == Utility.CollectionEmpty( categoryBag ) )
				{
					return null;
				}

				if( null == categoryBag )
				{
					categoryBag = new KeyedReferenceCollection();
				}

				return categoryBag;
			}

			set { categoryBag = value; }
		}

		[XmlArray("tModelBag"), XmlArrayItem("tModelKey")]
		public StringCollection TModelKeys
		{
			get
			{
				if( true == SerializeMode && 
					true == Utility.CollectionEmpty( tModelKeys ) )
				{
					return null;
				}

				if( null == tModelKeys )
				{
					tModelKeys = new StringCollection();
				}

				return tModelKeys;
			}

			set { tModelKeys = value; }
		}		
	}

	[XmlRootAttribute("get_serviceDetail", Namespace=Microsoft.Uddi.VersionSupport.UddiVersionSupport.CurrentNamespace)]
	public class GetServiceDetail : UddiMessage
	{		
		private StringCollection serviceKeys;
		
		[XmlElement("serviceKey")]
		public StringCollection ServiceKeys
		{
			get
			{
				if( null == serviceKeys )
				{
					serviceKeys = new StringCollection();
				}

				return serviceKeys;
			}

			set { serviceKeys = value; }
		}		
	}

	[XmlRootAttribute("save_service", Namespace=Microsoft.Uddi.VersionSupport.UddiVersionSupport.CurrentNamespace)]
	public class SaveService : UddiSecureMessage
	{				
		private BusinessServiceCollection businessServices;
				
		[XmlElement("businessService")]
		public BusinessServiceCollection BusinessServices
		{
			get
			{
				if( null == businessServices )
				{
					businessServices = new BusinessServiceCollection();
				}

				return businessServices;
			}

			set { businessServices = value; }
		}

		public override bool SerializeMode
		{
			get { return base.SerializeMode; }
			set
			{
				if( false == Utility.CollectionEmpty( businessServices ) )
				{
					foreach( BusinessService service in businessServices )
					{
						service.SerializeMode = value;					
					}
				}
				base.SerializeMode = value;
			}
		}		
	}

	[XmlRootAttribute("serviceDetail", Namespace=Microsoft.Uddi.VersionSupport.UddiVersionSupport.CurrentNamespace)]
	public class ServiceDetail : UddiCore
	{		
		private string						node;
		private bool						truncated;
		private BusinessServiceCollection	businessServices;
		
		[XmlAttribute("operator")]
		public string Operator
		{
			get	{ return node; }
			set	{ node = value;	}
		}
		
		[XmlAttribute("truncated")]
		public bool Truncated
		{
			get	{ return truncated; }		
			set { truncated = value; }
		}
		
		[XmlElement("businessService")]
		public BusinessServiceCollection BusinessServices
		{
			get
			{
				if( null == businessServices )
				{
					businessServices = new BusinessServiceCollection();
				}

				return businessServices;
			}

			set { businessServices = value; }
		}
	}

	[XmlRootAttribute("serviceList", Namespace=Microsoft.Uddi.VersionSupport.UddiVersionSupport.CurrentNamespace)]
	public class ServiceList : UddiCore
	{		
		private string				  node;
		private bool				  truncated;
		private ServiceInfoCollection serviceInfos;
		
		[XmlAttribute("operator")]
		public string Operator
		{
			get	{ return node; }
			set	{ node = value; }
		}

		[XmlAttribute("truncated")]
		public bool Truncated
		{
			get	{ return truncated; }
			set { truncated = value; }
		}

		[XmlArray("serviceInfos"), XmlArrayItem("serviceInfo")]
		public ServiceInfoCollection ServiceInfos
		{
			get
			{
				if( null == serviceInfos )
				{
					serviceInfos = new ServiceInfoCollection();
				}

				return serviceInfos;
			}

			set	{ serviceInfos = value; }
		}		
	}

	public class BusinessService : UddiCore
	{
		private string					  serviceKey;
		private string					  businessKey;
		private NameCollection			  names;
		private DescriptionCollection	  descriptions;
		private BindingTemplateCollection bindingTemplates;
		private KeyedReferenceCollection  categoryBag;
		
		public BusinessService() : this( "", "" ) 
		{}

		public BusinessService( string businessKey ) : this( businessKey, "" ) 
		{}

		public BusinessService(string businessKey, string serviceKey )
		{
			BusinessKey = businessKey;
			ServiceKey  = serviceKey;
		}

		[XmlAttribute("serviceKey")]
		public string ServiceKey
		{
			get	{ return serviceKey; }
			set	{ serviceKey = value; }
		}

		[XmlAttribute("businessKey")]
		public string BusinessKey
		{
			get	{ return businessKey; }
			set	{ businessKey = value; }
		}

		[XmlElement("name")]
		public NameCollection Names
		{
			get
			{ 
				if( null == names )
				{
					names = new NameCollection();
				}

				return names; 
			}

			set	{ names = value; }
		}

		[XmlElement("description")]
		public DescriptionCollection Descriptions
		{
			get
			{
				if( true == SerializeMode && 
					true == Utility.CollectionEmpty( descriptions ) )
				{
					return null;
				}

				if( null == descriptions )
				{
					descriptions = new DescriptionCollection();
				}

				return descriptions;
			}

			set	{ descriptions = value; }
		}

		[XmlArray("bindingTemplates"), XmlArrayItem("bindingTemplate")]
		public BindingTemplateCollection BindingTemplates
		{
			get
			{
				if( null == bindingTemplates )
				{
					bindingTemplates = new BindingTemplateCollection();
				}

				return bindingTemplates;
			}

			set { bindingTemplates = value; }
		}

		[XmlArray("categoryBag"), XmlArrayItem("keyedReference")]
		public KeyedReferenceCollection CategoryBag
		{
			get
			{
				if( true == SerializeMode && 
					true == Utility.CollectionEmpty( categoryBag ) )
				{
					return null;
				}

				if( null == categoryBag )
				{
					categoryBag = new KeyedReferenceCollection();
				}

				return categoryBag;
			}

			set { categoryBag = value; }
		}

		public override bool SerializeMode
		{
			get { return base.SerializeMode; }
			set
			{
				if( false == Utility.CollectionEmpty( bindingTemplates ) )
				{
					foreach( BindingTemplate binding in bindingTemplates )
					{
						binding.SerializeMode = value;
					}
				}
				base.SerializeMode = value;
			}			
		}
	}

	public class ServiceInfo : UddiCore
	{
		private string serviceKey;
		private string businessKey;
		private string name;

		public ServiceInfo()
		{}

		public ServiceInfo( string businessKey, string serviceKey, string name )
		{
			BusinessKey = businessKey;
			ServiceKey	= serviceKey;
			Name		= name;
		}

		[XmlAttribute("serviceKey")]
		public string ServiceKey
		{
			get	{ return serviceKey; }
			set	{ serviceKey = value; }
		}

		[XmlAttribute("businessKey")]
		public string BusinessKey
		{
			get	{ return businessKey; }
			set	{ businessKey = value; }
		}

		[XmlElement("name")]
		public string Name
		{
			get	{ return name; }
			set	{ name = value; }
		}
	}

	public class BusinessServiceCollection : CollectionBase
	{
		public BusinessService this[int index]
		{
			get { return (BusinessService)List[index]; }
			set { List[index] = value; }
		}

		public int Add(BusinessService businessService)
		{
			return List.Add(businessService);
		}

		public int Add( string businessKey )
		{
			return List.Add( new BusinessService( businessKey ) );
		}

		public int Add( string businessKey, string serviceKey )
		{
			return List.Add( new BusinessService( businessKey, serviceKey ) );
		}

		public void Insert(int index, BusinessService value)
		{
			List.Insert(index, value);
		}

		public int IndexOf(BusinessService value)
		{
			return List.IndexOf(value);
		}

		public bool Contains(BusinessService value)
		{
			return List.Contains(value);
		}

		public void Remove(BusinessService value)
		{
			List.Remove(value);
		}

		public void CopyTo(BusinessService[] array, int index)
		{
			List.CopyTo(array, index);
		}

		public new BusinessServiceEnumerator GetEnumerator() 
		{
			return new BusinessServiceEnumerator( List.GetEnumerator() );
		}
	}

	public sealed class BusinessServiceEnumerator : IEnumerator
	{
		private IEnumerator enumerator;

		public BusinessServiceEnumerator( IEnumerator enumerator )
		{
			this.enumerator = enumerator;
		}

		public BusinessService Current
		{
			get  { return ( BusinessService ) enumerator.Current; }			
		}

		object IEnumerator.Current
		{
			get{ return enumerator.Current; }
		}

		public bool MoveNext()
		{
			return enumerator.MoveNext();
		}

		public void Reset()
		{	
			enumerator.Reset();
		}
	}

	public class ServiceInfoCollection : CollectionBase
	{
		public ServiceInfo this[int index]
		{
			get { return (ServiceInfo)List[index]; }
			set { List[index] = value; }
		}

		public int Add( string businessKey, string serviceKey, string name )
		{
			return List.Add( new ServiceInfo( businessKey, serviceKey, name ) );
		}

		public int Add(ServiceInfo serviceInfo)
		{
			return List.Add(serviceInfo);
		}

		public void Insert(int index, ServiceInfo value)
		{
			List.Insert(index, value);
		}

		public int IndexOf(ServiceInfo value)
		{
			return List.IndexOf(value);
		}

		public bool Contains(ServiceInfo value)
		{
			return List.Contains(value);
		}

		public void Remove(ServiceInfo value)
		{
			List.Remove(value);
		}

		public void CopyTo(ServiceInfo[] array, int index)
		{
			List.CopyTo(array, index);
		}

		public new ServiceInfoEnumerator GetEnumerator() 
		{
			return new ServiceInfoEnumerator( List.GetEnumerator() );
		}
	}

	public sealed class ServiceInfoEnumerator : IEnumerator
	{
		private IEnumerator enumerator;

		public ServiceInfoEnumerator( IEnumerator enumerator )
		{
			this.enumerator = enumerator;
		}

		public ServiceInfo Current
		{
			get  { return ( ServiceInfo ) enumerator.Current; }			
		}

		object IEnumerator.Current
		{
			get{ return enumerator.Current; }
		}

		public bool MoveNext()
		{
			return enumerator.MoveNext();
		}

		public void Reset()
		{	
			enumerator.Reset();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\sdk\tmodel.cs ===
using System;
using System.Collections;
using System.Collections.Specialized;
using System.Diagnostics;
using System.ComponentModel;
using System.Xml.Serialization;

using Microsoft.Uddi;

namespace Microsoft.Uddi.ServiceType
{
	[XmlRootAttribute("delete_tModel", Namespace=Microsoft.Uddi.VersionSupport.UddiVersionSupport.CurrentNamespace)]
	public class DeleteTModel : UddiSecureMessage
	{				
		private StringCollection tModelKeys;
					
		[XmlElement("tModelKey")]
		public StringCollection TModelKeys
		{
			get
			{
				if( null == tModelKeys )
				{
					tModelKeys = new StringCollection();
				}

				return tModelKeys;
			}

			set { tModelKeys = value; }
		}
	}

	[XmlRootAttribute("find_tModel", Namespace=Microsoft.Uddi.VersionSupport.UddiVersionSupport.CurrentNamespace)]
	public class FindTModel : UddiQueryMessage
	{						
		private string					 name;
		private KeyedReferenceCollection identifierBag;
		private KeyedReferenceCollection categoryBag;
				
		[XmlElement("name")]
		public string Name
		{
			get	{ return name; }
			set	{ name = value;	}
		}

		[XmlArray("identifierBag"), XmlArrayItem("keyedReference")]
		public KeyedReferenceCollection IdentifierBag
		{
			get
			{
				if( true == SerializeMode && 
					true == Utility.CollectionEmpty( identifierBag ) )
				{
					return null;
				}

				if( null == identifierBag )
				{
					identifierBag = new KeyedReferenceCollection();
				}

				return identifierBag;
			}

			set { identifierBag = value; }
		}

		[XmlArray("categoryBag"), XmlArrayItem("keyedReference")]
		public KeyedReferenceCollection CategoryBag
		{
			get
			{
				if( true == SerializeMode && 
					true == Utility.CollectionEmpty( categoryBag ) )
				{
					return null;
				}

				if( null == categoryBag )
				{
					categoryBag = new KeyedReferenceCollection();
				}

				return categoryBag;
			}

			set { categoryBag = value; }
		}
	}

	[XmlRootAttribute("get_tModelDetail", Namespace=Microsoft.Uddi.VersionSupport.UddiVersionSupport.CurrentNamespace)]
	public class GetTModelDetail : UddiMessage
	{		
		private StringCollection tModelKeys;

		[XmlElement("tModelKey")]
		public StringCollection TModelKeys
		{
			get
			{
				if( null == tModelKeys )
				{
					tModelKeys = new StringCollection();
				}

				return tModelKeys;
			}

			set { tModelKeys = value; }
		}
	}

	[XmlRootAttribute("save_tModel", Namespace=Microsoft.Uddi.VersionSupport.UddiVersionSupport.CurrentNamespace)]
	public class SaveTModel : UddiSecureMessage
	{				
		private TModelCollection tModels;
		private StringCollection uploadRegisters;
		
		[XmlElement("tModel")]
		public TModelCollection TModels
		{
			get
			{
				if( true == SerializeMode && 
					true == Utility.CollectionEmpty( tModels ) )
				{
					return null;
				}

				if( null == tModels )
				{
					tModels = new TModelCollection();
				}

				return tModels;
			}

			set { tModels = value; }
		}

		[XmlElement("uploadRegister")]
		public StringCollection UploadRegisters
		{
			get
			{
				if( true == SerializeMode && 
					true == Utility.CollectionEmpty( uploadRegisters ) )
				{
					return null;
				}

				if( null == uploadRegisters )
				{
					uploadRegisters = new StringCollection();
				}

				return uploadRegisters;
			}
			set	{ uploadRegisters = value; }
		}
		
		public override bool SerializeMode
		{
			get { return base.SerializeMode; }
			set
			{
				if( false == Utility.CollectionEmpty( tModels ) )
				{
					foreach( TModel tModel in tModels )
					{
						tModel.SerializeMode = value;
					}
				}
				base.SerializeMode = value;			
			}
		}		
	}

	[XmlRootAttribute("tModelDetail", Namespace=Microsoft.Uddi.VersionSupport.UddiVersionSupport.CurrentNamespace)]
	public class TModelDetail : UddiCore
	{		
		private string			 node;
		private bool			 truncated;
		private TModelCollection tModels;

		[XmlAttribute("operator")]
		public string Operator
		{
			get	{ return node; }
			set	{ node = value;	}
		}

		[XmlAttribute("truncated")]
		public bool Truncated
		{
			get	{ return truncated;	}			
			set { truncated = value; }
		}

		[XmlElement("tModel")]
		public TModelCollection TModels
		{
			get
			{
				if( null == tModels )
				{
					tModels = new TModelCollection();
				}

				return tModels;
			}

			set { tModels = value; }
		}
	}

	[XmlRootAttribute("tModelList", Namespace=Microsoft.Uddi.VersionSupport.UddiVersionSupport.CurrentNamespace)]
	public class TModelList : UddiCore
	{		
		private string				 node;
		private bool				 truncated;
		private TModelInfoCollection tModelInfos;

		[XmlAttribute("operator")]
		public string Operator
		{
			get	{ return node; }
			set	{ node = value; }
		}
		
		[XmlAttribute("truncated")]
		public bool Truncated
		{
			get	{ return truncated;	}			
			set { truncated = value; }
		}

		[XmlArray("tModelInfos"), XmlArrayItem("tModelInfo")]
		public TModelInfoCollection TModelInfos
		{
			get
			{
				if( null == tModelInfos )
				{
					tModelInfos = new TModelInfoCollection();
				}

				return tModelInfos;
			}

			set { tModelInfos = value; }
		}
	}

	public class TModel : UddiCore
	{
		private string					 tModelKey;
		private string					 node;
		private string					 authorizedName;
		private string					 name;
		private OverviewDoc				 overviewDoc;
		private DescriptionCollection	 descriptions;		
		private KeyedReferenceCollection identifierBag;
		private KeyedReferenceCollection categoryBag;
		
		public TModel() : this( "" ) 
		{}

		public TModel( string tModelKey )
		{
			TModelKey = tModelKey;
		}

		[XmlAttribute("tModelKey")]
		public string TModelKey
		{
			get	{ return tModelKey;	}
			set	{ tModelKey = value; }
		}

		[XmlAttribute("operator")]
		public string Operator
		{
			get	{ return node; }
			set	{ node = value; }
		}

		[XmlAttribute("authorizedName")]
		public string AuthorizedName
		{
			get	{ return authorizedName; }
			set	{ authorizedName = value; }
		}

		[XmlElement("name")]
		public string Name
		{
			get	{ return name; }
			set	{ name = value; }
		}

		[XmlElement("description")]
		public DescriptionCollection Descriptions
		{
			get
			{
				if( true == SerializeMode && 
					true == Utility.CollectionEmpty( descriptions ) )
				{
					return null;
				}

				if( null == descriptions )
				{
					descriptions = new DescriptionCollection();
				}

				return descriptions;
			}

			set	{ descriptions = value; }
		}

		[XmlElement("overviewDoc")]
		public OverviewDoc OverviewDoc
		{
			get
			{
				if( true == SerializeMode && 
					( null == overviewDoc || 
						true == Utility.StringEmpty( overviewDoc.OverviewUrl )&&
						true == Utility.CollectionEmpty( overviewDoc.Descriptions ) 
					) )
				{
					return null;
				}

				if( null == overviewDoc )
				{
					overviewDoc = new OverviewDoc();
				}

				return overviewDoc;
			}

			set { overviewDoc = value; }
		}

		[XmlArray("identifierBag"), XmlArrayItem("keyedReference")]
		public KeyedReferenceCollection IdentifierBag
		{
			get
			{
				if( true == SerializeMode && 
					true == Utility.CollectionEmpty( identifierBag ) )
				{
					return null;
				}

				if( null == identifierBag )
				{
					identifierBag = new KeyedReferenceCollection();
				}

				return identifierBag;
			}

			set { identifierBag = value; }
		}

		[XmlArray("categoryBag"), XmlArrayItem("keyedReference")]
		public KeyedReferenceCollection CategoryBag
		{
			get
			{
				if( true == SerializeMode && 
					true == Utility.CollectionEmpty( categoryBag ) )
				{
					return null;
				}

				if( null == categoryBag )
				{
					categoryBag = new KeyedReferenceCollection();
				}

				return categoryBag;
			}

			set { categoryBag = value; }
		}
		
		public override bool SerializeMode
		{
			get { return base.SerializeMode; }
			set
			{
				if( null != overviewDoc )
				{
					overviewDoc.SerializeMode = value;
				}
				base.SerializeMode = value;
			}
		}
	}

	public class TModelInstanceDetail : UddiCore
	{
		private TModelInstanceInfoCollection tModelInstanceInfos;
		
		[XmlElement("tModelInstanceInfo")]
		public TModelInstanceInfoCollection TModelInstanceInfos
		{
			get
			{
				if( true == SerializeMode && 
					true == Utility.CollectionEmpty( tModelInstanceInfos ) )
				{																		
					return null;
				}

				if( null == tModelInstanceInfos )
				{
					tModelInstanceInfos = new TModelInstanceInfoCollection();
				}

				return tModelInstanceInfos;
			}
		
			set { tModelInstanceInfos = value; }
		}

		public override bool SerializeMode
		{
			get { return base.SerializeMode; }
			set 
			{
				if( false == Utility.CollectionEmpty( tModelInstanceInfos ) )
				{
					foreach( TModelInstanceInfo instanceInfo in tModelInstanceInfos )
					{
						instanceInfo.SerializeMode = value;
					}
				}

				base.SerializeMode = value;
			}
		}		
	}

	public class TModelInstanceInfo : UddiCore
	{
		private string					tModelKey;
		private DescriptionCollection	descriptions;
		private InstanceDetail			instanceDetails;		
	
		[XmlAttribute("tModelKey")]
		public string TModelKey
		{
			get	{ return tModelKey;	}
			set	{ tModelKey = value; }
		}

		[XmlElement("description")]
		public DescriptionCollection Descriptions
		{
			get
			{
				if( true == SerializeMode && 
					true == Utility.CollectionEmpty( descriptions ) )
				{
					return null;
				}

				if( null == descriptions )
				{
					descriptions = new DescriptionCollection();
				}

				return descriptions;
			}

			set	{ descriptions = value; }
		}

		[XmlElement("instanceDetails")]
		public InstanceDetail InstanceDetail
		{
			get
			{
				if( true == SerializeMode && 
					( null == instanceDetails || instanceDetails.IsEmpty() ) )
				{
					return null;
				}

				if( null == instanceDetails )
				{
					instanceDetails = new InstanceDetail();
				}

				return instanceDetails;
			}

			set { instanceDetails = value; }
		}

		public override bool SerializeMode
		{
			get { return base.SerializeMode; }
			set
			{
				if( null != instanceDetails )
				{
					instanceDetails.SerializeMode = value;
				}
				base.SerializeMode = value;
			}		
		}		
	}

	public class TModelInfo : UddiCore
	{
		private string tModelKey;
		private string name;

		public TModelInfo() : this( "", "" ) 
		{}

		public TModelInfo( string tModelKey, string name )
		{
			TModelKey = tModelKey;
			Name	  = name;
		}

		[XmlAttribute("tModelKey")]
		public string TModelKey
		{
			get	{ return tModelKey;	}
			set	{ tModelKey = value; }
		}

		[XmlElement("name")]
		public string Name
		{
			get	{ return name; }
			set	{ name = value; }
		}		
	}

	public class InstanceDetail : UddiCore
	{
		private string					instanceParms;
		private DescriptionCollection	descriptions;
		private OverviewDoc				overviewDoc;
		
		[XmlElement("description")]
		public DescriptionCollection Descriptions
		{
			get
			{
				if( true == SerializeMode && 
					true == Utility.CollectionEmpty( descriptions ) )
				{
					return null;
				}

				if( null == descriptions )
				{
					descriptions = new DescriptionCollection();
				}

				return descriptions;
			}

			set	{ descriptions = value; }
		}

		[XmlElement("overviewDoc")]
		public OverviewDoc OverviewDoc
		{
			get
			{
				if( true == SerializeMode && 
					( null == overviewDoc || overviewDoc.IsEmpty() ) )
				{
					return null;
				}

				if( null == overviewDoc )
				{
					overviewDoc = new OverviewDoc();
				}

				return overviewDoc;
			}

			set { overviewDoc = value; }
		}

		[XmlElement("instanceParms")]
		public string InstanceParm
		{
			get	{ return instanceParms; }
			set	{ instanceParms = value; }
		}

		internal bool IsEmpty()
		{
			return	Utility.CollectionEmpty( descriptions ) && 
					Utility.StringEmpty( instanceParms ) && 
					( null == overviewDoc || overviewDoc.IsEmpty() );			
		}
		
		public override bool SerializeMode
		{
			get { return base.SerializeMode; }
			set
			{
				if( null != overviewDoc )
				{
					overviewDoc.SerializeMode = value;
				}
				base.SerializeMode = value;
			}
		}
	}

	public class OverviewDoc : UddiCore
	{
		private string				  overviewUrl;
		private DescriptionCollection descriptions;
		
		[XmlElement("description")]
		public DescriptionCollection Descriptions
		{
			get
			{
				if( true == SerializeMode && 
					Utility.CollectionEmpty( descriptions ) )
				{
					return null;
				}

				if( null == descriptions )
				{
					descriptions = new DescriptionCollection();
				}

				return descriptions;
			}

			set	{ descriptions = value; }
		}

		[XmlElement("overviewURL")]
		public string OverviewUrl
		{
			get { return overviewUrl; }
			set { overviewUrl = value; }
		}

		internal bool IsEmpty()
		{
			return Utility.StringEmpty( overviewUrl ) &&
				   Utility.CollectionEmpty( descriptions );			
		}
	}

	public class TModelCollection : CollectionBase
	{
		public TModel this[int index]
		{
			get { return (TModel)List[index]; }
			set { List[index] = value; }
		}

		public int Add(TModel tModel)
		{
			return List.Add(tModel);
		}

		public int Add( string tModelKey )
		{
			return List.Add( new TModel( tModelKey ) );
		}

		public void Insert(int index, TModel value)
		{
			List.Insert(index, value);
		}

		public int IndexOf(TModel value)
		{
			return List.IndexOf(value);
		}

		public bool Contains(TModel value)
		{
			return List.Contains(value);
		}

		public void Remove(TModel value)
		{
			List.Remove(value);
		}

		public void CopyTo(TModel[] array, int index)
		{
			InnerList.CopyTo(array, index);
		}
		
		public new TModelEnumerator GetEnumerator() 
		{
			return new TModelEnumerator( List.GetEnumerator() );
		}
	}

	public sealed class TModelEnumerator : IEnumerator
	{
		private IEnumerator enumerator;

		public TModelEnumerator( IEnumerator enumerator )
		{
			this.enumerator = enumerator;
		}

		public TModel Current
		{
			get  { return ( TModel ) enumerator.Current; }			
		}

		object IEnumerator.Current
		{
			get{ return enumerator.Current; }
		}

		public bool MoveNext()
		{
			return enumerator.MoveNext();
		}

		public void Reset()
		{	
			enumerator.Reset();
		}
	}

	public class TModelInfoCollection : CollectionBase
	{
		public TModelInfo this[int index]
		{
			get { return (TModelInfo)List[index]; }
			set { List[index] = value; }
		}
		
		public int Add( string tModelKey, string name )
		{
			return List.Add( new TModelInfo( tModelKey, name ) );
		}

		public int Add(TModelInfo tModelInfo)
		{
			return List.Add(tModelInfo);
		}

		public void Insert(int index, TModelInfo value)
		{
			List.Insert(index, value);
		}

		public int IndexOf(TModelInfo value)
		{
			return List.IndexOf(value);
		}

		public bool Contains(TModelInfo value)
		{
			return List.Contains(value);
		}

		public void Remove(TModelInfo value)
		{
			List.Remove(value);
		}

		public void CopyTo(TModelInfo[] array, int index)
		{
			List.CopyTo(array, index);
		}

		public new TModelInfoEnumerator GetEnumerator() 
		{
			return new TModelInfoEnumerator( List.GetEnumerator() );
		}
	}

	public sealed class TModelInfoEnumerator : IEnumerator
	{
		private IEnumerator enumerator;

		public TModelInfoEnumerator( IEnumerator enumerator )
		{
			this.enumerator = enumerator;
		}

		public TModelInfo Current
		{
			get  { return ( TModelInfo ) enumerator.Current; }			
		}

		object IEnumerator.Current
		{
			get{ return enumerator.Current; }
		}

		public bool MoveNext()
		{
			return enumerator.MoveNext();
		}

		public void Reset()
		{	
			enumerator.Reset();
		}
	}

	public class TModelInstanceInfoCollection : CollectionBase
	{
		public TModelInstanceInfo this[int index]
		{
			get { return (TModelInstanceInfo)List[index]; }
			set { List[index] = value; }
		}

		public int Add(TModelInstanceInfo tModelInstanceInfo)
		{
			return List.Add(tModelInstanceInfo);
		}

		public void Insert( int index, TModelInstanceInfo tModelInstanceInfo )
		{
			List.Insert(index, tModelInstanceInfo );
		}

		public int IndexOf(TModelInstanceInfo value)
		{
			return List.IndexOf(value);
		}

		public bool Contains(TModelInstanceInfo value)
		{
			return List.Contains(value);
		}

		public void Remove(TModelInstanceInfo value)
		{
			List.Remove(value);
		}

		public void CopyTo(TModelInstanceInfo[] array, int index)
		{
			List.CopyTo(array, index);
		}

		public new TModelInstanceInfoEnumerator GetEnumerator() 
		{
			return new TModelInstanceInfoEnumerator( List.GetEnumerator() );
		}
	}

	public sealed class TModelInstanceInfoEnumerator : IEnumerator
	{
		private IEnumerator enumerator;

		public TModelInstanceInfoEnumerator( IEnumerator enumerator )
		{
			this.enumerator = enumerator;
		}

		public TModelInstanceInfo Current
		{
			get  { return ( TModelInstanceInfo ) enumerator.Current; }			
		}

		object IEnumerator.Current
		{
			get{ return enumerator.Current; }
		}

		public bool MoveNext()
		{
			return enumerator.MoveNext();
		}

		public void Reset()
		{	
			enumerator.Reset();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\sdk\uddiweb.cs ===
using System;
using System.IO;
using System.Diagnostics;
using System.Net;
using System.Web.Services;
using System.Web.Services.Description;
using System.Web.Services.Protocols;
using System.Xml;
using System.Xml.Serialization;
using System.Xml.Xsl;
using System.Xml.XPath;
using System.Text;

using Microsoft.Uddi;
using Microsoft.Uddi.Authentication;
using Microsoft.Uddi.VersionSupport;

namespace Microsoft.Uddi.Web
{		
	/// <summary>
	/// UddiWebResponse allows us to return our own Stream object.
	/// </summary>
	internal class UddiWebResponse : WebResponse
	{
		private WebResponse			innerWebResponse;
		private UddiResponseStream	uddiResponseStream;
		private UddiVersion			uddiVersion;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="innerWebResponse">This object should come from the WebResponse created by HttpSoapClientProtocol.</param>		
		public UddiWebResponse( WebResponse innerWebResponse )
		{
			this.innerWebResponse = innerWebResponse;
			this.uddiVersion      = uddiVersion;
		}

		/// <summary>
		/// Return our response stream (UddiResponseStream) instead of the Stream associated with our inner response.
		/// </summary>
		/// <returns></returns>
		public override Stream GetResponseStream() 
		{
			if( null == uddiResponseStream )
			{
				uddiResponseStream = new UddiResponseStream( innerWebResponse.GetResponseStream() );
			}			

			return uddiResponseStream;
		}		

		/// <summary>
		/// Delegates to the inner web response.
		/// </summary>
		public override void Close() 
		{
			innerWebResponse.Close();
		}
		
		/// <summary>
		/// Delegates to the inner web response.
		/// </summary>
		public override long ContentLength 
		{
			get { return innerWebResponse.ContentLength; }						
			set { innerWebResponse.ContentLength = value; }			
		}

		/// <summary>
		/// Delegates to the inner web response.
		/// </summary>
		public override string ContentType 
		{
			get { return innerWebResponse.ContentType; }			
			set { innerWebResponse.ContentType = value; }			
		}
		
		/// <summary>
		/// Delegates to the inner web response.
		/// </summary>
		public override Uri ResponseUri 
		{			
			get  { return innerWebResponse.ResponseUri; }
		}
		
		/// <summary>
		/// Delegates to the inner web response.
		/// </summary>
		public override WebHeaderCollection Headers 
		{			
			get { return innerWebResponse.Headers; }			
		}		
	}

	/// <summary>
	/// UddiResponseStream allows us to manipulate the XML sent back from the web service.
	/// </summary>
	internal class UddiResponseStream : MemoryStream
	{		
		//
		// TODO: at some point it may be necessary to pass in the current version as a parameter if the transforms become 
		// more complicated.
		//

		/// <summary>
		/// Constructor.  We read all the XML sent from the server, do our version manipulation, then write the new XML
		/// into our inner responseStream object.
		/// </summary>
		/// <param name="responseStream">This object should be the responseStream from a WebResponse object.</param>
		public UddiResponseStream( Stream responseStream )
		{
			try
			{
				//
				// Get the XML the server sent to us.
				//
				StreamReader reader = new StreamReader( responseStream );
				string responseXml = reader.ReadToEnd();
				reader.Close();

				//
				// TODO: Consider making this class more generic, ie. have a IUddiResponseHandler interface:
				//	IUddiResponseHandler
				//		string HandleResponse( string xml );
				//

				//
				// Translate the incoming XML into the current version.
				//				
				string transformedXml = UddiVersionSupport.Translate( responseXml, UddiVersionSupport.CurrentVersion );

				//
				// Write this transformed XML into the 'real' stream.
				//
				StreamUtility.WriteStringToStream( this, transformedXml );
			}
			finally
			{
				this.Position = 0;
			}
		}					
	}
		
	/// <summary>
	///  UddiWebRequest allows us to return our own request and response objects.
	/// </summary>
	internal class UddiWebRequest : WebRequest
	{
		private WebRequest			innerWebRequest;
		private UddiRequestStream	uddiRequestStream;
		private UddiWebResponse		uddiWebResponse;
		private UddiVersion			uddiVersion;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="uri">Uri to the web service we are calling</param>
		/// <param name="uddiVersion">Uddi version to use for requests</param>
		public UddiWebRequest( WebRequest innerWebRequest, UddiVersion uddiVersion )
		{
			this.innerWebRequest  = innerWebRequest;
			this.uddiVersion = uddiVersion;
		}
		
		/// <summary>
		/// Return a UddiRequestStream object instead of the default one.
		/// </summary>
		/// <returns>UddiRequestStream object</returns>
		public override Stream GetRequestStream()
		{
			if( null == uddiRequestStream )
			{
				uddiRequestStream = new UddiRequestStream( innerWebRequest.GetRequestStream(), uddiVersion );
			}

			return uddiRequestStream;
		}	
		
		/// <summary>
		/// Return a UddiWebRequest object instead of the default one.
		/// </summary>
		/// <returns>UddiWebResponse object</returns>
		public override WebResponse GetResponse() 
		{
			if( null == uddiWebResponse )
			{
				uddiWebResponse = new UddiWebResponse( innerWebRequest.GetResponse() );
			}		
			return uddiWebResponse;
		}

		/// <summary>
		/// Delegates to our inner WebRequest
		/// </summary>
		public override string Method 
		{
			get { return innerWebRequest.Method; }
			set { innerWebRequest.Method = value; }
		}
		
		/// <summary>
		/// Delegates to our inner WebRequest
		/// </summary>
		public override Uri RequestUri 
		{                              
			get { return innerWebRequest.RequestUri; }
		}

		/// <summary>
		/// Delegates to our inner WebRequest
		/// </summary>
		public override string ConnectionGroupName 
		{
			get { return innerWebRequest.ConnectionGroupName; }
			set { innerWebRequest.ConnectionGroupName = value; }
		}

		/// <summary>
		/// Delegates to our inner WebRequest
		/// </summary>
		public override WebHeaderCollection Headers 
		{            
			get { return innerWebRequest.Headers; }
			set { innerWebRequest.Headers = value; }				
		}

		/// <summary>
		/// Delegates to our inner WebRequest
		/// </summary>
		public override long ContentLength 
		{
			get { return innerWebRequest.ContentLength; }			
			set { innerWebRequest.ContentLength = value; }				
		}

		/// <summary>
		/// Delegates to our inner WebRequest
		/// </summary>
		public override string ContentType 
		{
			get { return innerWebRequest.ContentType; }				
			set { innerWebRequest.ContentType = value; }			
		}
		
		/// <summary>
		/// Delegates to our inner WebRequest
		/// </summary>
		public override ICredentials Credentials 
		{
			get { return innerWebRequest.Credentials; }			
			set { innerWebRequest.Credentials = value; }			
		}
		
		/// <summary>
		/// Delegates to our inner WebRequest
		/// </summary>
		public override IWebProxy Proxy 
		{
			get { return innerWebRequest.Proxy; }			
			set { innerWebRequest.Proxy = value; }
		}

		/// <summary>
		/// Delegates to our inner WebRequest
		/// </summary>
		public override bool PreAuthenticate 
		{
			get { return innerWebRequest.PreAuthenticate; }			
			set { innerWebRequest.PreAuthenticate = value; }			
		}

		/// <summary>
		/// Delegates to our inner WebRequest
		/// </summary>
		public override int Timeout 
		{
			get { return innerWebRequest.Timeout; }			
			set { innerWebRequest.Timeout = value; }			
		}

		/// <summary>
		/// Delegates to our inner WebRequest
		/// </summary>
		public override IAsyncResult BeginGetResponse(AsyncCallback callback, object state) 
		{	
			return innerWebRequest.BeginGetResponse( callback, state );			
		}

		/// <summary>
		/// Delegates to our inner WebRequest
		/// </summary>
		public override WebResponse EndGetResponse(IAsyncResult asyncResult) 
		{
			return innerWebRequest.EndGetResponse( asyncResult );			
		}
		
		/// <summary>
		/// Delegates to our inner WebRequest
		/// </summary>
		public override IAsyncResult BeginGetRequestStream(AsyncCallback callback, Object state) 
		{
			return innerWebRequest.BeginGetRequestStream( callback, state );			
		}
		
		/// <summary>
		/// Delegates to our inner WebRequest
		/// </summary>
		public override Stream EndGetRequestStream(IAsyncResult asyncResult) 
		{
			return innerWebRequest.EndGetRequestStream( asyncResult );			
		}
		
		/// <summary>
		/// Delegates to our inner WebRequest
		/// </summary>
		public override void Abort() 
		{
			innerWebRequest.Abort();			
		}
	}

	/// <summary>
	/// UddiRequestStream allows us to manipulate the XML before we send it to the client.  This class will accept all data that
	/// is written to it from the ASP.NET web service framework.  When the framework closes the stream (ie. wants to send the data), we
	/// will manipulate this XML so that it has the right Uddi version, then send it out using our innerStream object.
	/// </summary>
	internal class UddiRequestStream : MemoryStream
	{
		private Stream		 innerStream;
		private UddiVersion	 uddiVersion;
		
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="innerStream">Should be from a WebRequest object.</param>
		/// <param name="uddiVersion">The UDD version we should use to send to the server</param>
		public UddiRequestStream( Stream innerStream, UddiVersion uddiVersion )
		{
			this.innerStream = innerStream;				
			this.uddiVersion = uddiVersion;
		}
				
		/// <summary>
		/// Before we actually close the request stream, we want to manipulate the XML.
		/// </summary>
		public override void Close()
		{
			try
			{
				//
				// Rewind ourselves.
				//
				this.Position = 0;

				//
				// Read the XML that was written; this is the XML request that will be sent to the Uddi server.
				//
				StreamReader reader = new StreamReader( this );
				string requestXml   = reader.ReadToEnd();

				//
				// TODO: Consider making this class more generic, ie. have a IUddiRequestHandler interface:
				//	IUddiResponseHandler
				//		string HandleRequest( string xml );
				//

				//
				// Transform the content to a correct version on the server if we are not using the current version.
				//
				string transformedXml = requestXml;
				if( uddiVersion != UddiVersionSupport.CurrentVersion )
				{
					transformedXml = UddiVersionSupport.Translate( requestXml, uddiVersion );
				}
			
				//
				// Write the transformed data to the 'real' stream.
				//
				StreamUtility.WriteStringToStream( innerStream, transformedXml );				
			}
			finally
			{
				//
				// Make sure we clean up properly.
				//
				innerStream.Close();			
				base.Close();
			}
		}		
	}
	
	/// <summary>
	/// Simple utility class to help us write string data to Stream objects.
	/// </summary>
	internal sealed class StreamUtility
	{		
		public static void WriteStringToStream( Stream stream, string stringToWrite )
		{								
			for ( int i = 0; i < stringToWrite.Length; i++ )
			{
				stream.WriteByte( Convert.ToByte( stringToWrite[ i ] ) );
			}								
		}

		private StreamUtility()
		{
			//
			// Don't let anyone instantiate this class
			//
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\sdk\uddioperator.cs ===
using System;
using System.IO;
using System.Diagnostics;
using System.Net;
using System.Web.Services;
using System.Web.Services.Description;
using System.Web.Services.Protocols;
using System.Xml;
using System.Xml.Serialization;
using System.Xml.Xsl;
using System.Xml.XPath;
using System.Text;

using Microsoft.Uddi;
using Microsoft.Uddi.Authentication;
using Microsoft.Uddi.VersionSupport;
using Microsoft.Uddi.Binding;
using Microsoft.Uddi.Business;
using Microsoft.Uddi.Service;
using Microsoft.Uddi.ServiceType;
using Microsoft.Uddi.Extensions;
using Microsoft.Uddi.Web;

namespace Microsoft.Uddi
{
	/// <summary>
	/// UddiOperator is the class the user will use to send their Uddi messages.
	/// </summary>
	public class UddiOperator
	{
		private SoapClient			soapClient;		
		private AuthenticationMode	authenticationMode;
		private bool				refreshAuthToken;

		public UddiOperator()
		{
			soapClient = new SoapClient();						
		}

		public string Url
		{		
			get { return soapClient.Url; }
			set { soapClient.Url = value; }
		}	

		public SoapHttpClientProtocol HttpClient
		{
			get { return ( SoapHttpClientProtocol ) soapClient; }
		}		
		
		public bool RefreshAuthToken
		{
			get { return refreshAuthToken; }
			set { refreshAuthToken = value; }
		}

		public UddiVersion Version
		{
			get { return soapClient.Version; }
			set { soapClient.Version = value; }
		}

		public AuthenticationMode AuthenticationMode
		{
			get { return authenticationMode; }
			set 
			{
				authenticationMode = value;

				if( Microsoft.Uddi.AuthenticationMode.WindowsAuthentication == authenticationMode )
				{
					soapClient.Credentials     = CredentialCache.DefaultCredentials;
					soapClient.PreAuthenticate = true;
				}
			}
		}
		
		/////////////////////////////////////////////////////////////////////////////////////////////////
		/// Uddi Authentication API messages
		/////////////////////////////////////////////////////////////////////////////////////////////////
		public DispositionReport Send( DiscardAuthToken discardAuthToken, AuthToken authToken ) 
		{
			if( discardAuthToken.AuthInfo != authToken.AuthInfo )
			{
				discardAuthToken.AuthInfo = authToken.AuthInfo;
			}

			return soapClient.DiscardAuthToken( discardAuthToken );
		}
		
		public AuthToken Send( GetAuthToken getAuthToken) 
		{			
			AuthToken authToken = soapClient.GetAuthToken( getAuthToken );
			authToken.OriginatingAuthToken = getAuthToken;

			return authToken;
		}

		/////////////////////////////////////////////////////////////////////////////////////////////////
		/// Uddi Publish API messages
		/////////////////////////////////////////////////////////////////////////////////////////////////
		public RegisteredInfo Send( GetRegisteredInfo getRegisteredInfo, AuthToken authToken ) 
		{
			SetAuthToken( getRegisteredInfo, authToken );
			
			try
			{
				return soapClient.GetRegisteredInfo( getRegisteredInfo );		
			}
			catch( UddiException uddiException )
			{
				AttemptRefreshAuthInfo( uddiException, authToken );

				return soapClient.GetRegisteredInfo( getRegisteredInfo );				
			}
		}
        
		public DispositionReport Send( DeleteBinding deleteBinding, AuthToken authToken ) 
		{			
			SetAuthToken( deleteBinding, authToken );
			
			try
			{
				return soapClient.DeleteBinding( deleteBinding );		
			}
			catch( UddiException uddiException )
			{
				AttemptRefreshAuthInfo( uddiException, authToken );

				return soapClient.DeleteBinding( deleteBinding );				
			}
		}
	      
		public DispositionReport Send( DeleteBusiness deleteBusiness, AuthToken authToken ) 
		{
			SetAuthToken( deleteBusiness, authToken );
		
			try
			{
				return soapClient.DeleteBusiness( deleteBusiness );		
			}
			catch( UddiException uddiException )
			{
				AttemptRefreshAuthInfo( uddiException, authToken );

				return soapClient.DeleteBusiness( deleteBusiness );				
			}
		}

		public DispositionReport Send( DeleteService deleteService, AuthToken authToken ) 
		{
			SetAuthToken( deleteService, authToken );
		
			try
			{
				return soapClient.DeleteService( deleteService );		
			}
			catch( UddiException uddiException )
			{
				AttemptRefreshAuthInfo( uddiException, authToken );

				return soapClient.DeleteService( deleteService );				
			}
		}
		
		public DispositionReport Send( DeleteTModel deleteTModel, AuthToken authToken ) 
		{
			SetAuthToken( deleteTModel, authToken );
		
			try
			{
				return soapClient.DeleteTModel( deleteTModel );		
			}
			catch( UddiException uddiException )
			{
				AttemptRefreshAuthInfo( uddiException, authToken );

				return soapClient.DeleteTModel( deleteTModel );				
			}
		}

		public BindingDetail Send( SaveBinding saveBinding, AuthToken authToken ) 
		{
			SetAuthToken( saveBinding, authToken );
		
			try
			{
				return soapClient.SaveBinding( saveBinding );		
			}
			catch( UddiException uddiException )
			{
				AttemptRefreshAuthInfo( uddiException, authToken );

				return soapClient.SaveBinding( saveBinding );				
			}
		}

		public BusinessDetail Send( SaveBusiness saveBusiness, AuthToken authToken ) 
		{
			SetAuthToken( saveBusiness, authToken );
		
			try
			{
				return soapClient.SaveBusiness( saveBusiness );		
			}
			catch( UddiException uddiException )
			{
				AttemptRefreshAuthInfo( uddiException, authToken );

				return soapClient.SaveBusiness( saveBusiness );				
			}
		}
				
		public ServiceDetail Send( SaveService saveService, AuthToken authToken ) 
		{
			SetAuthToken( saveService, authToken );
		
			try
			{
				return soapClient.SaveService( saveService );		
			}
			catch( UddiException uddiException )
			{
				AttemptRefreshAuthInfo( uddiException, authToken );

				return soapClient.SaveService( saveService );				
			}
		}
	        
		public TModelDetail Send( SaveTModel saveTModel, AuthToken authToken ) 
		{
			SetAuthToken( saveTModel, authToken );
		
			try
			{
				return soapClient.SaveTModel( saveTModel );		
			}
			catch( UddiException uddiException )
			{
				AttemptRefreshAuthInfo( uddiException, authToken );

				return soapClient.SaveTModel( saveTModel );				
			}
		}

		public DispositionReport Send( AddPublisherAssertions addPublisherAssertions, AuthToken authToken) 
		{
			SetAuthToken( addPublisherAssertions, authToken );
		
			try
			{
				return soapClient.AddPublisherAssertions( addPublisherAssertions );		
			}
			catch( UddiException uddiException )
			{
				AttemptRefreshAuthInfo( uddiException, authToken );

				return soapClient.AddPublisherAssertions( addPublisherAssertions );				
			}
		}

		public DispositionReport Send( DeletePublisherAssertions deletePublisherAssertions, AuthToken authToken ) 
		{
			SetAuthToken( deletePublisherAssertions, authToken );
		
			try
			{
				return soapClient.DeletePublisherAssertions( deletePublisherAssertions );		
			}
			catch( UddiException uddiException )
			{
				AttemptRefreshAuthInfo( uddiException, authToken );

				return soapClient.DeletePublisherAssertions( deletePublisherAssertions );				
			}
		}

		public AssertionStatusReport Send( GetAssertionStatusReport getAssertionStatusReport, AuthToken authToken ) 
		{
			SetAuthToken( getAssertionStatusReport, authToken );
		
			try
			{
				return soapClient.GetAssertionStatusReport( getAssertionStatusReport );		
			}
			catch( UddiException uddiException )
			{
				AttemptRefreshAuthInfo( uddiException, authToken );

				return soapClient.GetAssertionStatusReport( getAssertionStatusReport );				
			}
		}

		public PublisherAssertionDetail Send( GetPublisherAssertions getPublisherAssertions, AuthToken authToken ) 
		{
			SetAuthToken( getPublisherAssertions, authToken );
		
			try
			{
				return soapClient.GetPublisherAssertions( getPublisherAssertions );		
			}
			catch( UddiException uddiException )
			{
				AttemptRefreshAuthInfo( uddiException, authToken );

				return soapClient.GetPublisherAssertions( getPublisherAssertions );				
			}
		}

		public PublisherAssertionDetail Send( SetPublisherAssertions setPublisherAssertions, AuthToken authToken ) 
		{
			SetAuthToken( setPublisherAssertions, authToken );
		
			try
			{
				return soapClient.SetPublisherAssertions( setPublisherAssertions );		
			}
			catch( UddiException uddiException )
			{
				AttemptRefreshAuthInfo( uddiException, authToken );

				return soapClient.SetPublisherAssertions( setPublisherAssertions );				
			}
		}

		/////////////////////////////////////////////////////////////////////////////////////////////////
		/// Uddi Inquire API messages
		/////////////////////////////////////////////////////////////////////////////////////////////////
		public BindingDetail Send( FindBinding findBinding ) 
		{			
			return soapClient.FindBinding( findBinding );
		}
	        	
		public BusinessList Send( FindBusiness findBusiness ) 
		{
			return soapClient.FindBusiness( findBusiness );
		}

		public RelatedBusinessList Send( FindRelatedBusinesses findRelatedBusinesses ) 
		{			
			return soapClient.FindRelatedBusinesses( findRelatedBusinesses );
		}

		public ServiceList Send( FindService findService ) 
		{
			return soapClient.FindService( findService );
		}
	        
		public TModelList Send( FindTModel findTModel ) 
		{
			return soapClient.FindTModel( findTModel );
		}
	        	        
		public BindingDetail Send( GetBindingDetail getBindingDetail ) 
		{
			return soapClient.GetBindingDetail( getBindingDetail );
		}
	        
		public BusinessDetail Send( GetBusinessDetail getBusinessDetail ) 
		{
			return soapClient.GetBusinessDetail( getBusinessDetail );
		}

		public BusinessDetailExt Send( GetBusinessDetailExt getBusinessDetailExt ) 
		{
			return soapClient.GetBusinessDetailExt( getBusinessDetailExt );
		}
	        
		public ServiceDetail Send( GetServiceDetail getServiceDetail ) 
		{
			return soapClient.GetServiceDetail( getServiceDetail );
		}
	        
		public TModelDetail Send( GetTModelDetail getTModelDetail ) 
		{
			return soapClient.GetTModelDetail( getTModelDetail );
		}			

		/////////////////////////////////////////////////////////////////////////////////////////////////
		/// Uddi Extensions API messages
		/////////////////////////////////////////////////////////////////////////////////////////////////
		public CategoryList Send( GetRelatedCategories getRelatedCategories )
		{
			return soapClient.GetRelatedCategories( getRelatedCategories );
		}
		
		private void SetAuthToken( UddiSecureMessage uddiSecureMessage, AuthToken authToken )
		{
			if( uddiSecureMessage.AuthInfo != authToken.AuthInfo )
			{
				uddiSecureMessage.AuthInfo = authToken.AuthInfo;
			}
		}

		private void AttemptRefreshAuthInfo( UddiException uddiException, AuthToken authToken )
		{
			if( UddiException.ErrorType.E_authTokenExpired == uddiException.Type && 
				true == RefreshAuthToken )
			{
				authToken = Send( authToken.OriginatingAuthToken );
			}		
			else
			{
				throw uddiException;
			}
		}
	}
	
	[System.Web.Services.WebServiceBindingAttribute( Name="MessageHandlersSoap", Namespace=Microsoft.Uddi.VersionSupport.UddiVersionSupport.CurrentNamespace )]
	internal class SoapClient : SoapHttpClientProtocol
	{
		private static readonly string UddiUserAgent;
		
		private UddiVersion uddiVersion;
		
		public SoapClient()
		{
			uddiVersion		= UddiVersion.Negotiate;			
			UserAgent       = UddiUserAgent;
		}

		static SoapClient()
		{
			System.Reflection.Assembly assembly = System.Reflection.Assembly.GetExecutingAssembly();

			//
			//
			// The assembly.FullName looks like this
			// Microsoft.Uddi.Sdk, Version=1.1.1.1, Culture=neutral, PublicKeyToken=a48752033f5d4384
			// I just want to use the first 2 sections.
			// To convert this: Mozilla/4.0 (compatible; MSIE 6.0; MS Web Services Client Protocol 1.0.3328.4)
			// To this: Mozilla/4.0 (compatible; MSIE 6.0; MS Web Services Client Protocol 1.0.3328.4; MS Uddi .Net SDK 1.0.xxxx.1)
			//
			
			UddiUserAgent = new Char[] { ' ', ')' } + "; MS Uddi .Net SDK " + FileVersionInfo.GetVersionInfo( assembly.Location ).FileVersion + ")";
		}

		public UddiVersion Version
		{
			get { return uddiVersion; }
			set { uddiVersion = value; }
		}

		protected override WebRequest GetWebRequest( Uri uri )
		{
			UddiWebRequest webRequest = new UddiWebRequest( base.GetWebRequest( uri ), uddiVersion );

			return webRequest;			
		}

		private object[] InvokeWebMethod( string webMethodName, object[] parameters )
		{				
			object[] results = null;

			//
			// The first (and only) parameter is the Uddi message we are about to send.
			// 
			UddiCore uddiMessage = parameters[ 0 ] as UddiCore;

			try
			{
				uddiMessage.SerializeMode = true;
				results = Invoke( webMethodName, parameters );				
				
			}			
			catch( SoapException soapException )
			{	
				//
				// We have no meaningful results at this point.
				//
				results						= null;
				UddiException uddiException = new UddiException( soapException );
				UddiVersion originalVersion = uddiVersion;

				//
				// If the exception is either a fatal error or a unrecognized version error, we will 
				// assume that the exception had something to do with a versioning problem.  This is about
				// the most reliable way to do this, since there is no standard way of reporting a version
				// mismatch.  If IterateOverVersions still does not return results, then we use the original
				// exception and assume that that exception was indeed not version related.
				//
				if( ( uddiException.Type == UddiException.ErrorType.E_unrecognizedVersion || 
					uddiException.Type == UddiException.ErrorType.E_fatalError ) && 
					uddiVersion == UddiVersion.Negotiate )
				{
					results = InvokeForVersions( webMethodName, parameters, ref uddiException);

					//
					// Restore the original version.  TODO: should we just keep this version as is?
					//
					uddiVersion = originalVersion;
				}

				if( null == results )
				{					
					throw uddiException;
				}				
			}
			finally
			{
				uddiMessage.SerializeMode = false;
			}

			return results;
		}

		private object[] InvokeForVersions( string webMethodName, object[] parameters, ref UddiException returnException )
		{
			object[] results = null;
				
			//
			// Try to invoke this web method for each supported version
			//
			int numVersions = UddiVersionSupport.SupportedVersions.Length;
			int index = 0;

			while( index < numVersions && null == results )
			{
				try
				{
					UddiVersion versionToTry = UddiVersionSupport.SupportedVersions[ index++ ];

					//
					// Don't repeat versions.
					//
					if( versionToTry != uddiVersion )
					{
						uddiVersion = versionToTry;
					}
					
					results = Invoke( webMethodName, parameters );
				}
				catch( UddiException uddiException )
				{
					returnException = uddiException;
				}
				catch( Exception exception )
				{ 
					returnException = new UddiException( exception );					
				}				
			}

			return results;
		}
	
		/////////////////////////////////////////////////////////////////////////////////////////////////
		/// Uddi Publish API messages
		/////////////////////////////////////////////////////////////////////////////////////////////////
		[SoapDocumentMethod("", Use=SoapBindingUse.Literal, ParameterStyle=SoapParameterStyle.Bare)]
		[return: XmlElement("registeredInfo", Namespace=Microsoft.Uddi.VersionSupport.UddiVersionSupport.CurrentNamespace, IsNullable=false)]
		public RegisteredInfo GetRegisteredInfo([XmlElement( Namespace=Microsoft.Uddi.VersionSupport.UddiVersionSupport.CurrentNamespace, IsNullable=false)] GetRegisteredInfo getRegisteredInfo) 
		{
			object[] results = InvokeWebMethod("GetRegisteredInfo", new object[] {getRegisteredInfo});
			return ((RegisteredInfo)results[0]);
		}
        
		[SoapDocumentMethod("", Use=SoapBindingUse.Literal, ParameterStyle=SoapParameterStyle.Bare)]
		[return: XmlElement("dispositionReport", Namespace=Microsoft.Uddi.VersionSupport.UddiVersionSupport.CurrentNamespace, IsNullable=false)]
		public DispositionReport DeleteBinding([XmlElement(Namespace=Microsoft.Uddi.VersionSupport.UddiVersionSupport.CurrentNamespace, IsNullable=false)] DeleteBinding deleteBinding) 
		{
			object[] results = InvokeWebMethod("DeleteBinding", new object[] {deleteBinding});
			return ((DispositionReport)results[0]);
		}
	        
		[SoapDocumentMethod("", Use=SoapBindingUse.Literal, ParameterStyle=SoapParameterStyle.Bare)]
		[return: XmlElement("dispositionReport", Namespace=Microsoft.Uddi.VersionSupport.UddiVersionSupport.CurrentNamespace, IsNullable=false)]
		public DispositionReport DeleteBusiness([XmlElement(Namespace=Microsoft.Uddi.VersionSupport.UddiVersionSupport.CurrentNamespace, IsNullable=false)] DeleteBusiness deleteBusiness) 
		{
			object[] results = InvokeWebMethod("DeleteBusiness", new object[] {deleteBusiness});
			return ((DispositionReport)results[0]);
		}

		[SoapDocumentMethod("", Use=SoapBindingUse.Literal, ParameterStyle=SoapParameterStyle.Bare)]
		[return: XmlElement("dispositionReport", Namespace=Microsoft.Uddi.VersionSupport.UddiVersionSupport.CurrentNamespace, IsNullable=false)]
		public DispositionReport DeleteService([XmlElement(Namespace=Microsoft.Uddi.VersionSupport.UddiVersionSupport.CurrentNamespace, IsNullable=false)] DeleteService deleteService) 
		{
			object[] results = InvokeWebMethod("DeleteService", new object[] {deleteService});
			return ((DispositionReport)results[0]);
		}

		[SoapDocumentMethod("", Use=SoapBindingUse.Literal, ParameterStyle=SoapParameterStyle.Bare)]
		[return: XmlElement("dispositionReport", Namespace=Microsoft.Uddi.VersionSupport.UddiVersionSupport.CurrentNamespace, IsNullable=false)]
		public DispositionReport DeleteTModel([XmlElement(Namespace=Microsoft.Uddi.VersionSupport.UddiVersionSupport.CurrentNamespace, IsNullable=false)] DeleteTModel deleteTModel) 
		{
			object[] results = InvokeWebMethod("DeleteTModel", new object[] {deleteTModel});
			return ((DispositionReport)results[0]);
		}

		[SoapDocumentMethod("", Use=SoapBindingUse.Literal, ParameterStyle=SoapParameterStyle.Bare)]
		[return: XmlElement("bindingDetail", Namespace=Microsoft.Uddi.VersionSupport.UddiVersionSupport.CurrentNamespace, IsNullable=false)]
		public BindingDetail SaveBinding([XmlElement(Namespace=Microsoft.Uddi.VersionSupport.UddiVersionSupport.CurrentNamespace, IsNullable=false)] SaveBinding saveBinding) 
		{
			object[] results = InvokeWebMethod("SaveBinding", new object[] {saveBinding});
			return ((BindingDetail)results[0]);
		}

		[SoapDocumentMethod("", Use=SoapBindingUse.Literal, ParameterStyle=SoapParameterStyle.Bare)]
		[return: XmlElement("businessDetail", Namespace=Microsoft.Uddi.VersionSupport.UddiVersionSupport.CurrentNamespace, IsNullable=false)]
		public BusinessDetail SaveBusiness([XmlElement(Namespace=Microsoft.Uddi.VersionSupport.UddiVersionSupport.CurrentNamespace, IsNullable=false)] SaveBusiness saveBusiness) 
		{
			object[] results = InvokeWebMethod("SaveBusiness", new object[] {saveBusiness});
			return ((BusinessDetail)results[0]);
		}

		[SoapDocumentMethod("", Use=SoapBindingUse.Literal, ParameterStyle=SoapParameterStyle.Bare)]
		[return: XmlElement("serviceDetail", Namespace=Microsoft.Uddi.VersionSupport.UddiVersionSupport.CurrentNamespace, IsNullable=false)]
		public ServiceDetail SaveService([XmlElement(Namespace=Microsoft.Uddi.VersionSupport.UddiVersionSupport.CurrentNamespace, IsNullable=false)] SaveService saveService) 
		{
			object[] results = InvokeWebMethod("SaveService", new object[] {saveService});
			return ((ServiceDetail)results[0]);
		}
	        
		[SoapDocumentMethod("", Use=SoapBindingUse.Literal, ParameterStyle=SoapParameterStyle.Bare)]
		[return: XmlElement("tModelDetail", Namespace=Microsoft.Uddi.VersionSupport.UddiVersionSupport.CurrentNamespace, IsNullable=false)]
		public TModelDetail SaveTModel([XmlElement(Namespace=Microsoft.Uddi.VersionSupport.UddiVersionSupport.CurrentNamespace, IsNullable=false)] SaveTModel saveTModel) 
		{
			object[] results = InvokeWebMethod("SaveTModel", new object[] {saveTModel});
			return ((TModelDetail)results[0]);
		}

		[SoapDocumentMethod("", Use=SoapBindingUse.Literal, ParameterStyle=SoapParameterStyle.Bare)]
		[return: XmlElement("dispositionReport", Namespace=Microsoft.Uddi.VersionSupport.UddiVersionSupport.CurrentNamespace, IsNullable=false)]
		public DispositionReport DiscardAuthToken([XmlElement(Namespace=Microsoft.Uddi.VersionSupport.UddiVersionSupport.CurrentNamespace, IsNullable=false)] DiscardAuthToken discardAuthToken) 
		{
			object[] results = InvokeWebMethod("DiscardAuthToken", new object[] {discardAuthToken});
			return ((DispositionReport)results[0]);
		}

		[SoapDocumentMethod("", Use=SoapBindingUse.Literal, ParameterStyle=SoapParameterStyle.Bare)]
		[return: XmlElement("authToken", Namespace=Microsoft.Uddi.VersionSupport.UddiVersionSupport.CurrentNamespace, IsNullable=false)]
		public AuthToken GetAuthToken([XmlElement(Namespace=Microsoft.Uddi.VersionSupport.UddiVersionSupport.CurrentNamespace, IsNullable=false)] GetAuthToken getAuthToken) 
		{
			object[] results = InvokeWebMethod("GetAuthToken", new object[] {getAuthToken});
			return ((AuthToken)results[0]);
		}

		[SoapDocumentMethod( "", Use=SoapBindingUse.Literal, ParameterStyle=SoapParameterStyle.Bare )]
		[return: XmlElement( "dispositionReport", Namespace=Microsoft.Uddi.VersionSupport.UddiVersionSupport.CurrentNamespace, IsNullable=false )]
		public DispositionReport AddPublisherAssertions( [XmlElement( Namespace=Microsoft.Uddi.VersionSupport.UddiVersionSupport.CurrentNamespace, IsNullable=false )] AddPublisherAssertions addPublisherAssertions) 
		{
			object[] results = InvokeWebMethod( "AddPublisherAssertions", new object[] { addPublisherAssertions });
			return ( (DispositionReport)results[ 0 ] );
		}

		[SoapDocumentMethod( "", Use=SoapBindingUse.Literal, ParameterStyle=SoapParameterStyle.Bare )]
		[return: XmlElement( "dispositionReport", Namespace=Microsoft.Uddi.VersionSupport.UddiVersionSupport.CurrentNamespace, IsNullable=false )]
		public DispositionReport DeletePublisherAssertions( [XmlElement( Namespace=Microsoft.Uddi.VersionSupport.UddiVersionSupport.CurrentNamespace, IsNullable=false )] DeletePublisherAssertions deletePublisherAssertions ) 
		{
			object[] results = InvokeWebMethod( "DeletePublisherAssertions", new object[] { deletePublisherAssertions } );
			return ( (DispositionReport)results[ 0 ] );
		}

		[SoapDocumentMethod( "", Use=SoapBindingUse.Literal, ParameterStyle=SoapParameterStyle.Bare )]
		[return: XmlElement( "assertionStatusReport", Namespace=Microsoft.Uddi.VersionSupport.UddiVersionSupport.CurrentNamespace, IsNullable=false )]
		public AssertionStatusReport GetAssertionStatusReport( [XmlElement( Namespace=Microsoft.Uddi.VersionSupport.UddiVersionSupport.CurrentNamespace, IsNullable=false )] GetAssertionStatusReport getAssertionStatusReport ) 
		{
			object[] results = InvokeWebMethod( "GetAssertionStatusReport", new object[] { getAssertionStatusReport } );
			return ( (AssertionStatusReport)results[ 0 ] );
		}

		[SoapDocumentMethod( "", Use=SoapBindingUse.Literal, ParameterStyle=SoapParameterStyle.Bare )]
		[return: XmlElement( "publisherAssertions", Namespace=Microsoft.Uddi.VersionSupport.UddiVersionSupport.CurrentNamespace, IsNullable=false )]
		public PublisherAssertionDetail GetPublisherAssertions( [XmlElement( Namespace=Microsoft.Uddi.VersionSupport.UddiVersionSupport.CurrentNamespace, IsNullable=false )] GetPublisherAssertions getPublisherAssertions ) 
		{
			object[] results = InvokeWebMethod( "GetPublisherAssertions", new object[] { getPublisherAssertions } );
			return ( (PublisherAssertionDetail)results[ 0 ] );
		}

		[SoapDocumentMethod( "", Use=SoapBindingUse.Literal, ParameterStyle=SoapParameterStyle.Bare )]
		[return: XmlElement("publisherAssertions", Namespace=Microsoft.Uddi.VersionSupport.UddiVersionSupport.CurrentNamespace, IsNullable=false)]
		public PublisherAssertionDetail SetPublisherAssertions( [XmlElement( Namespace=Microsoft.Uddi.VersionSupport.UddiVersionSupport.CurrentNamespace, IsNullable=false )] SetPublisherAssertions setPublisherAssertions ) 
		{
			object[] results = InvokeWebMethod( "SetPublisherAssertions", new object[] { setPublisherAssertions } );
			return ( (PublisherAssertionDetail)results[ 0 ] );
		}

		/////////////////////////////////////////////////////////////////////////////////////////////////
		/// Uddi Inquire API messages
		/////////////////////////////////////////////////////////////////////////////////////////////////
		[SoapDocumentMethod("", Use=SoapBindingUse.Literal, ParameterStyle=SoapParameterStyle.Bare)]
		[return: XmlElement("bindingDetail", Namespace=Microsoft.Uddi.VersionSupport.UddiVersionSupport.CurrentNamespace, IsNullable=false)]
		public BindingDetail FindBinding([XmlElement(Namespace=Microsoft.Uddi.VersionSupport.UddiVersionSupport.CurrentNamespace, IsNullable=false)] FindBinding findBinding) 
		{			
			object[] results = InvokeWebMethod("FindBinding", new object[] {findBinding});
			return ((BindingDetail)results[0]);
		}
	        	
		[SoapDocumentMethod("", Use=SoapBindingUse.Literal, ParameterStyle=SoapParameterStyle.Bare)]		
		[return: XmlElement("businessList", Namespace=Microsoft.Uddi.VersionSupport.UddiVersionSupport.CurrentNamespace, IsNullable=false)]		
		public BusinessList FindBusiness([XmlElement(Namespace=Microsoft.Uddi.VersionSupport.UddiVersionSupport.CurrentNamespace, IsNullable=false)] FindBusiness findBusiness) 
		{
			object[] results = InvokeWebMethod( "FindBusiness", new object[] { findBusiness } );

			return ( ( BusinessList )results[0] );
		}

		[SoapDocumentMethod("", Use=SoapBindingUse.Literal, ParameterStyle=SoapParameterStyle.Bare)]
		[return: XmlElement("relatedBusinessesList", Namespace=Microsoft.Uddi.VersionSupport.UddiVersionSupport.CurrentNamespace, IsNullable=false)]
		public RelatedBusinessList FindRelatedBusinesses([XmlElement(Namespace=Microsoft.Uddi.VersionSupport.UddiVersionSupport.CurrentNamespace, IsNullable=false)] FindRelatedBusinesses findRelatedBusinesses ) 
		{
			object[] results = InvokeWebMethod( "FindRelatedBusinesses", new object[] { findRelatedBusinesses });
			return ((RelatedBusinessList)results[0]);
		}

		[SoapDocumentMethod("", Use=SoapBindingUse.Literal, ParameterStyle=SoapParameterStyle.Bare)]
		[return: XmlElement("serviceList", Namespace=Microsoft.Uddi.VersionSupport.UddiVersionSupport.CurrentNamespace, IsNullable=false)]
		public ServiceList FindService([XmlElement(Namespace=Microsoft.Uddi.VersionSupport.UddiVersionSupport.CurrentNamespace, IsNullable=false)] FindService findService) 
		{
			object[] results = InvokeWebMethod("FindService", new object[] {findService});
			return ((ServiceList)results[0]);
		}
	        
		[SoapDocumentMethod( "", Use=SoapBindingUse.Literal, ParameterStyle=SoapParameterStyle.Bare )]
		[return: XmlElement( "tModelList", Namespace=Microsoft.Uddi.VersionSupport.UddiVersionSupport.CurrentNamespace, IsNullable=false )]
		public TModelList FindTModel( [XmlElement( Namespace=Microsoft.Uddi.VersionSupport.UddiVersionSupport.CurrentNamespace, IsNullable=false )] FindTModel findTModel ) 
		{
			object[] results = InvokeWebMethod( "FindTModel", new object[] { findTModel } );
			return ( (TModelList)results[ 0 ] );
		}
	        	        
		[SoapDocumentMethod("", Use=SoapBindingUse.Literal, ParameterStyle=SoapParameterStyle.Bare)]
		[return: XmlElement("bindingDetail", Namespace=Microsoft.Uddi.VersionSupport.UddiVersionSupport.CurrentNamespace, IsNullable=false)]
		public BindingDetail GetBindingDetail([XmlElement(Namespace=Microsoft.Uddi.VersionSupport.UddiVersionSupport.CurrentNamespace, IsNullable=false)] GetBindingDetail getBindingDetail) 
		{
			object[] results = InvokeWebMethod("GetBindingDetail", new object[] {getBindingDetail});
			return ((BindingDetail)results[0]);
		}
	        
		[SoapDocumentMethod("", Use=SoapBindingUse.Literal, ParameterStyle=SoapParameterStyle.Bare)]
		[return: XmlElement("businessDetail", Namespace=Microsoft.Uddi.VersionSupport.UddiVersionSupport.CurrentNamespace, IsNullable=false)]
		public BusinessDetail GetBusinessDetail([XmlElement(Namespace=Microsoft.Uddi.VersionSupport.UddiVersionSupport.CurrentNamespace, IsNullable=false)] GetBusinessDetail getBusinessDetail) 
		{
			object[] results = InvokeWebMethod("GetBusinessDetail", new object[] {getBusinessDetail});
			return ((BusinessDetail)results[0]);
		}

		[SoapDocumentMethod("", Use=SoapBindingUse.Literal, ParameterStyle=SoapParameterStyle.Bare)]
		[return: XmlElement("businessDetailExt", Namespace=Microsoft.Uddi.VersionSupport.UddiVersionSupport.CurrentNamespace, IsNullable=false)]
		public BusinessDetailExt GetBusinessDetailExt([XmlElement(Namespace=Microsoft.Uddi.VersionSupport.UddiVersionSupport.CurrentNamespace, IsNullable=false)] GetBusinessDetailExt getBusinessDetailExt ) 
		{
			object[] results = InvokeWebMethod("GetBusinessDetailExt", new object[] {getBusinessDetailExt});
			return ((BusinessDetailExt)results[0]);
		}
	        
		[SoapDocumentMethod("", Use=SoapBindingUse.Literal, ParameterStyle=SoapParameterStyle.Bare)]
		[return: XmlElement("serviceDetail", Namespace=Microsoft.Uddi.VersionSupport.UddiVersionSupport.CurrentNamespace, IsNullable=false)]
		public ServiceDetail GetServiceDetail([XmlElement(Namespace=Microsoft.Uddi.VersionSupport.UddiVersionSupport.CurrentNamespace, IsNullable=false)] GetServiceDetail getServiceDetail) 
		{
			object[] results = InvokeWebMethod("GetServiceDetail", new object[] {getServiceDetail});
			return ((ServiceDetail)results[0]);
		}
	        
		[SoapDocumentMethod("", Use=SoapBindingUse.Literal, ParameterStyle=SoapParameterStyle.Bare)]
		[return: XmlElement("tModelDetail", Namespace=Microsoft.Uddi.VersionSupport.UddiVersionSupport.CurrentNamespace, IsNullable=false)]
		public TModelDetail GetTModelDetail([XmlElement(Namespace=Microsoft.Uddi.VersionSupport.UddiVersionSupport.CurrentNamespace, IsNullable=false)] GetTModelDetail getTModelDetail) 
		{
			object[] results = InvokeWebMethod("GetTModelDetail", new object[] {getTModelDetail});
			return ((TModelDetail)results[0]);
		}		

		/////////////////////////////////////////////////////////////////////////////////////////////////
		/// Uddi Extensions API messages
		/////////////////////////////////////////////////////////////////////////////////////////////////
		[SoapDocumentMethod("", Use=SoapBindingUse.Literal, ParameterStyle=SoapParameterStyle.Bare)]
		[return: XmlElement("tModelDetail", Namespace=Microsoft.Uddi.Extensions.Namespaces.GetRelatedCategories, IsNullable=false)]				
		public CategoryList GetRelatedCategories( GetRelatedCategories getRelatedCategories )
		{
			object[] results = InvokeWebMethod("GetRelatedCategories", new object[] {getRelatedCategories});
			return ((CategoryList)results[0]);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\setup\db\ca\makefile.inc ===
foo.cs:
	..\..\..\version\$(O)\version.exe -outfile .\assemblyversioninfo.cs
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\sdk\versionsupport.cs ===
using System;
using System.Collections;
using System.IO;
using System.Diagnostics;
using System.Net;
using System.Web.Services;
using System.Web.Services.Description;
using System.Web.Services.Protocols;
using System.Xml;
using System.Xml.Serialization;
using System.Xml.Xsl;
using System.Xml.XPath;
using System.Text;
using System.Globalization;

using Microsoft.Uddi;
using Microsoft.Uddi.Web;

namespace Microsoft.Uddi
{	
	public enum UddiVersion
	{
		V1,
		V2,
		Negotiate
	}
}	

namespace Microsoft.Uddi.VersionSupport
{		
	internal abstract class IUddiVersion
	{				
		public abstract string Generic
		{ get; }

		public abstract string Namespace
		{ get; }
		
		public abstract string Translate( string xml );		
	}

	internal sealed class UddiVersionSupport
	{					
		internal readonly static UddiVersion[]	SupportedVersions;		
		internal readonly static UddiVersion	CurrentVersion;

		//
		// This is a bit awkward to store the current namespace and generic separately rather than using the UddiVersion class.  But, we need
		// to use these values in our XmlRoot attribute declaration that each serialize-able class uses.  Only const values can be used
		// in attribute declarations.  Make sure to update these values when you change the current version
		//
		internal const string CurrentNamespace = "urn:uddi-org:api_v2";
		internal const string CurrentGeneric   = "2.0";
		
		private static Hashtable UddiVersions;

		private UddiVersionSupport()
		{
			//
			// Don't let anyone construct an instance of this class.
			//
		}

		internal static string Translate( string xml, UddiVersion version )
		{
			//
			// Use the current version in this case
			//			
			if( version == UddiVersion.Negotiate )
			{
				version = CurrentVersion;
			}
			
			IUddiVersion uddiVersion = ( IUddiVersion ) UddiVersions[ version ];

			return uddiVersion.Translate( xml );
		}

		static UddiVersionSupport()
		{
			//
			// Increase this array if you want to support more previous versions.  Do not include
			// the current version in this array.
			//
			SupportedVersions = new UddiVersion[1];

			//
			// Add our supported previous versions
			//
			SupportedVersions[0] = UddiVersion.V1;					

			//
			// Current version is version 2.0
			//
			CurrentVersion = UddiVersion.V2;

			//
			// Store instances to versions
			//
			UddiVersions = new Hashtable();

			UddiVersions[ UddiVersion.V1 ] = new UddiVersion1();
			UddiVersions[ UddiVersion.V2 ] = new UddiVersion2();
		}	
	}

	internal class UddiVersion1 : IUddiVersion
	{		
		private XmlDocument input;
		
		public UddiVersion1()
		{
			input = new XmlDocument();
		}

		public override string Generic
		{
			get { return "1.0"; }
		}

		public override string Namespace
		{
			get { return "urn:uddi-org:api"; }
		}

		public override string Translate( string xml )
		{
			//
			// Load up the input into a DOM so we can make some queries to do replacements.  I considered
			// using a XSTL stylesheet here, but there didn't appear to be a good way of only replacing select items.
			// You pretty much have to take the input, and specify how every element in the output should look (or
			// do an exact copy); this results in too much error-prone XSLT code.
			//
			input.LoadXml( xml );

			//
			// There are a number of messages that version 1 just does not support.  Kick out now if we are trying to
			// call any of these messages.
			//

			//
			// Replace generic attribute value and default namespace
			//
			XmlNodeList nodes = input.SelectNodes( "descendant::*[@generic]" );			
			foreach( XmlNode node in nodes )
			{
				node.Attributes.GetNamedItem( "generic" ).Value = Generic;

				XmlNode xmlnsAttribute = node.Attributes.GetNamedItem( "xmlns" );
				if( null != xmlnsAttribute )
				{
					xmlnsAttribute.Value = Namespace;
				}					
			}

			//
			// Remove name@xml:lang values
			//
			nodes =input.SelectNodes( "descendant::*[@xml:lang]" , new XmlNamespaceManager( input.NameTable ) );
			foreach( XmlNode node in nodes )
			{
				if( node.LocalName.ToLower( CultureInfo.CurrentCulture ).Equals( "name" ) )
				{
					node.Attributes.RemoveNamedItem( "xml:lang" );
				}						
			}

			return input.OuterXml;
		}
	}

	internal class UddiVersion2 : IUddiVersion
	{		
		private XmlDocument input;
		
		public UddiVersion2()
		{
			input = new XmlDocument();
		}

		public override string Generic
		{
			get { return "2.0"; }
		}

		public override string Namespace
		{
			get { return "urn:uddi-org:api_v2"; }
		}

		public override string Translate( string xml )
		{			
			//
			// Load up the input into a DOM so we can make some queries to do replacements.  I considered
			// using a XSTL stylesheet here, but there didn't appear to be a good way of only replacing select items.
			// You pretty much have to take the input, and specify how every element in the output should look (or
			// do an exact copy); this results in too much error-prone XSLT code.
			//
			input.LoadXml( xml );

			//
			// Replace generic attribute value and default namespace
			//
			XmlNodeList nodes = input.SelectNodes( "descendant::*[@generic]" );			
			foreach( XmlNode node in nodes )
			{
				node.Attributes.GetNamedItem( "generic" ).Value = Generic;

				XmlNode xmlnsAttribute = node.Attributes.GetNamedItem( "xmlns" );
				if( null != xmlnsAttribute )
				{
					xmlnsAttribute.Value = Namespace;
				}					
			}

			return input.OuterXml;
		}
	}	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\setup\db\ca.unmanaged\apppool.cpp ===
#include "..\..\shared\apppool.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\setup\db\ca.unmanaged\common.cpp ===
#include "..\..\shared\common.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\setup\db\ca\assemblyinfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("dbca.dll")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft Corporation")]
[assembly: AssemblyProduct("UDDI Services")]
[assembly: AssemblyCopyright("Copyright (c) 2002 Microsoft Corporation")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]		

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified, the assembly is not signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. KeyFile refers to a file which contains
//       a key.
//   (*) If the KeyFile and the KeyName values are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP, that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the KeyFile is installed into the CSP and used.
//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
//       When specifying the KeyFile, the location of the KeyFile should be
//       relative to the project output directory which is
//       %Project Directory%\obj\<configuration>. For example, if your KeyFile is
//       located in the project directory, you would specify the AssemblyKeyFile 
//       attribute as [assembly: AssemblyKeyFile("..\\..\\mykey.snk")]
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("")]
[assembly: AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\setup\db\ca.unmanaged\dbcaum.h ===
#pragma once
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\setup\db\ca.unmanaged\dbcaum.cpp ===
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0500
#endif

#include <windows.h>
#include <string.h>
#include <tchar.h>
#include <assert.h>
#include <time.h>

#include <msi.h>
#include <msiquery.h>

#include "dbcaum.h"
#include "..\..\shared\apppool.h"
#include "..\..\shared\common.h"


#define DIM(x)	(sizeof x)/(sizeof x[0])

#define ROOT_REGPATH		"Software\\Microsoft\\UDDI"
#define INSTROOT_REGPATH	"InstallRoot"
#define RESROOT_REGPATH		"ResourceRoot"
#define BOOTSTRAP_DIR		"bootstrap"

//
// Forward declarations.
//
static int AddSharedDllRef( LPCSTR szFullPath );
static int ReleaseSharedDll ( LPCSTR szFullPath );
static bool AddAccessRights( TCHAR *lpszFileName, TCHAR *szUserName, DWORD dwAccessMask );
static LONG GetServiceStartupAccount( const TCHAR *pwszServiceName, TCHAR *pwszServiceAccount, int iLen );
static void GetUDDIDBServiceName( const TCHAR *pwszInstanceName, TCHAR *pwszServiceName, int iLen );
static void AddAccessRightsVerbose( TCHAR *pwszFileName, TCHAR *pwszUserName, DWORD dwMask );
//--------------------------------------------------------------------------

BOOL APIENTRY DllMain( HANDLE hModule, 
                       DWORD  ul_reason_for_call, 
                       LPVOID lpReserved
					 )
{
    return TRUE;
}

//--------------------------------------------------------------------------
//
// Install custom action used by the DB component installer to recycle the app pool
// This function is exported
//
UINT _stdcall Install( MSIHANDLE hInstall )
{
	ENTER();
	//
	// stop and start the app pool
	//
	CUDDIAppPool apppool;
	apppool.Recycle();

	return ERROR_SUCCESS;
}

UINT __stdcall InstallTaxonomy( LPCSTR szSrcResource, LPCSTR szDestResource )
{
	//
	// Now we parse the path out of the Source and copy the Destination right by it
	//
	CHAR  szPath[ _MAX_PATH + 1 ] = {0};

	PCHAR pSlash = strrchr( szSrcResource, '\\' );		
	if ( pSlash )
	{
		strncpy( szPath, szSrcResource, pSlash - szSrcResource + 1 );
		int iLen = _MAX_PATH - strlen( szPath );
		strncat( szPath, szDestResource, iLen );
	}
	else
	{
		strncpy( szPath, szDestResource, _MAX_PATH + 1 );
	}

	szPath[ _MAX_PATH ] = 0;

#if defined( DBG ) || defined( _DEBUG )
	TCHAR wszPath[ _MAX_PATH + 1 ];
	int iwszCount = _MAX_PATH;
	int ipszCount = strlen( szPath );

	memset( wszPath, 0, _MAX_PATH * sizeof( TCHAR ) );
	::MultiByteToWideChar( CP_THREAD_ACP, MB_ERR_INVALID_CHARS, szPath, ipszCount, wszPath, iwszCount );

	Log( _T( "Installing taxonomy file: %s." ), wszPath );
#endif

	if ( !CopyFileA( szSrcResource, szPath, FALSE ) )
		return ERROR_INSTALL_FAILURE;

	DeleteFileA( szSrcResource );

	return ERROR_SUCCESS;
}

UINT __stdcall InstallResource( LPCSTR szCultureID, LPCSTR szDefCulture, 
							    LPCSTR szSrcResource, LPCSTR szDestResource )
{
	//
	// Get the properties and then do the file manipulation
	//
	if ( _stricmp( szCultureID, szDefCulture ) )
	{
		//
		// Now we parse the path out of the Source and copy the Destination right by it
		//
		CHAR  szPath[ _MAX_PATH + 1 ] = {0};

		PCHAR pSlash = strrchr( szSrcResource, '\\' );		
		if ( pSlash )
		{
			strncpy( szPath, szSrcResource, pSlash - szSrcResource + 1 );
			int iLen = _MAX_PATH - strlen( szPath );
			strncat( szPath, szDestResource, iLen );
		}
		else
		{
			strncpy( szPath, szDestResource, _MAX_PATH + 1 );
		}

		szPath[ _MAX_PATH ] = 0;

#if defined( DBG ) || defined( _DEBUG )
		TCHAR wszPath[ _MAX_PATH + 1 ];
		int iwszCount = _MAX_PATH;
		int ipszCount = strlen( szPath );

		memset( wszPath, 0, _MAX_PATH * sizeof( TCHAR ) );
		::MultiByteToWideChar( CP_THREAD_ACP, MB_ERR_INVALID_CHARS, szPath, ipszCount, wszPath, iwszCount );

		Log( _T( "Installing resource file: %s." ), wszPath );
#endif

		if ( !CopyFileA( szSrcResource, szPath, FALSE ) )
			return ERROR_INSTALL_FAILURE;

		AddSharedDllRef( szPath );
	}

	DeleteFileA( szSrcResource );

	return ERROR_SUCCESS;
}


UINT __stdcall RemoveResource( LPCSTR szDestResource )
{
	HKEY hUddiKey = NULL;
	try
	{
		CHAR	szPath[ _MAX_PATH + 1 ] = {0};
		DWORD	cbPath = DIM( szPath );
		size_t	iLen = 0;

		LONG iRes = RegOpenKeyA( HKEY_LOCAL_MACHINE, ROOT_REGPATH, &hUddiKey );
		if ( iRes != ERROR_SUCCESS )
			return ERROR_INSTALL_FAILURE;

		iRes = RegQueryValueExA( hUddiKey, RESROOT_REGPATH, NULL, NULL, (LPBYTE)szPath, &cbPath );
		if ( iRes != ERROR_SUCCESS )
			return ERROR_INSTALL_FAILURE;

		RegCloseKey( hUddiKey );
		hUddiKey = NULL;

		iLen = strlen( szPath );
		if ( ( iLen < _MAX_PATH ) && ( szPath[ iLen - 1 ] != '\\' ) )
		{
			strncat( szPath, "\\", 2 );
		}

		iLen = _MAX_PATH - strlen( szPath );
		strncat( szPath, szDestResource, iLen );

		szPath[ _MAX_PATH ] = 0;

#if defined( DBG ) || defined( _DEBUG )
		TCHAR wszPath[ _MAX_PATH + 1 ];
		int iwszCount = _MAX_PATH;
		int ipszCount = strlen( szPath );

		memset( wszPath, 0, _MAX_PATH * sizeof( TCHAR ) );
		::MultiByteToWideChar( CP_THREAD_ACP, MB_ERR_INVALID_CHARS, szPath, ipszCount, wszPath, iwszCount );

		Log( _T( "Removing resource file: %s." ), wszPath );
#endif

		if ( ReleaseSharedDll( szPath ) == 0 )
			DeleteFileA( szPath );
	}
	catch (...)
	{
		if ( hUddiKey )
			RegCloseKey( hUddiKey );

		return ERROR_INSTALL_FAILURE;
	}

	return ERROR_SUCCESS;
}

UINT __stdcall RemoveTaxonomy( LPCSTR szDestResource )
{
	HKEY hUddiKey = NULL;

	try
	{
		CHAR	szPath[ _MAX_PATH + 1 ] = {0};
		DWORD	cbPath = DIM( szPath );
		size_t	iLen = 0;

		LONG iRes = RegOpenKeyA( HKEY_LOCAL_MACHINE, ROOT_REGPATH, &hUddiKey );
		if ( iRes != ERROR_SUCCESS )
			return ERROR_INSTALL_FAILURE;

		iRes = RegQueryValueExA( hUddiKey, INSTROOT_REGPATH, NULL, NULL, (LPBYTE)szPath, &cbPath );
		if ( iRes != ERROR_SUCCESS )
			return ERROR_INSTALL_FAILURE;

		RegCloseKey( hUddiKey );
		hUddiKey = NULL;

		iLen = strlen( szPath );
		if ( ( iLen < _MAX_PATH ) && ( szPath[ iLen - 1 ] != '\\' ) )
		{
			strncat( szPath, "\\", 2 );
		}

		//
		// Append \bootstrap\<resource filename> to InstallRoot
		//
		iLen = _MAX_PATH - strlen( szPath );
		strncat( szPath, BOOTSTRAP_DIR, iLen );

		strncat( szPath, "\\", 2 );

		iLen = _MAX_PATH - strlen( szPath );
		strncat( szPath, szDestResource, iLen );

		szPath[ _MAX_PATH ] = 0;

#if defined( DBG ) || defined( _DEBUG )
		TCHAR wszPath[ _MAX_PATH + 1 ];
		int iwszCount = _MAX_PATH;
		int ipszCount = strlen( szPath );

		memset( wszPath, 0, _MAX_PATH * sizeof( TCHAR ) );
		::MultiByteToWideChar( CP_THREAD_ACP, MB_ERR_INVALID_CHARS, szPath, ipszCount, wszPath, iwszCount );

		Log( _T( "Removing taxonomy file: %s." ), wszPath );
#endif

		DeleteFileA( szPath );
	}
	catch (...)
	{
		if ( hUddiKey )
			RegCloseKey( hUddiKey );

		return ERROR_INSTALL_FAILURE;
	}

	return ERROR_SUCCESS;
}

UINT __stdcall GrantExecutionRights( LPCSTR pszInstanceNameOnly )
{
	ENTER();

	TCHAR wszInstanceName[ 256 ];
	int iwszCount = 256;
	int ipszCount = strlen( pszInstanceNameOnly );

	memset( wszInstanceName, 0, 256 * sizeof( TCHAR ) );

	::MultiByteToWideChar( CP_THREAD_ACP, MB_ERR_INVALID_CHARS, pszInstanceNameOnly, ipszCount, wszInstanceName, iwszCount );
	Log( _T( "Instance Name only = %s" ), wszInstanceName );

	TCHAR wszServiceName[ 128 ];
	GetUDDIDBServiceName( wszInstanceName, wszServiceName, 128 );

	TCHAR wszServiceAccount[ 128 ];
	GetServiceStartupAccount( wszServiceName, wszServiceAccount, 128 );

	//
	// Get the UDDI installation point.  ie, C:\Inetpub\uddi\
	//
	HKEY hKey = NULL;
	LONG lRet = RegOpenKeyEx( HKEY_LOCAL_MACHINE, _T( "SOFTWARE\\Microsoft\\UDDI\\Setup\\DBServer" ), 0, KEY_QUERY_VALUE, &hKey );
	if( ERROR_SUCCESS != lRet )
	{
		Log( _T( "Call to RegOpenKeyEx failed." ) );
		return ERROR_SUCCESS;
	}

	DWORD dwType = 0;
	TCHAR wszUDDIRoot[ _MAX_PATH ];
	DWORD dwSize = _MAX_PATH * sizeof( TCHAR );
	memset( wszUDDIRoot, 0, dwSize );

	lRet = RegQueryValueEx( hKey, _T( "TargetDir" ), NULL, &dwType, (LPBYTE)wszUDDIRoot, &dwSize );
	RegCloseKey( hKey );
	if( ERROR_SUCCESS != lRet )
	{
		Log( _T( "Call to RegQueryValueEx failed." ) );
		return ERROR_SUCCESS;
	}

	//
	// Build the full path to the 3 files whose ACLs are being modified.
	//
	dwSize = _MAX_PATH + _MAX_FNAME;
	TCHAR wszResetKeyExe[ _MAX_PATH + _MAX_FNAME ];
	TCHAR wszRecalcStatsExe[ _MAX_PATH + _MAX_FNAME ];
	TCHAR wszXPDLL[ _MAX_PATH + _MAX_FNAME ];

	memset( wszResetKeyExe, 0, dwSize * sizeof( TCHAR ) );
	memset( wszRecalcStatsExe, 0, dwSize * sizeof( TCHAR ) ) ;
	memset( wszXPDLL, 0, dwSize * sizeof( TCHAR ) ) ;

	_tcscat( wszResetKeyExe, wszUDDIRoot );
	_tcscat( wszResetKeyExe, _T( "bin\\resetkey.exe" ) );

	_tcscat( wszRecalcStatsExe, wszUDDIRoot );
	_tcscat( wszRecalcStatsExe, _T( "bin\\recalcstats.exe" ) );

	_tcscat( wszXPDLL, wszUDDIRoot );
	_tcscat( wszXPDLL, _T( "bin\\uddi.xp.dll" ) );

	//
	// If the service startup account is a local account, it will be prefixed
	// with ".\"  For example: ".\Administrator".
	//
	// For some reason, LookupAccountName (which we rely on just below) wants
	// local accounts not to be prefixed with ".\".
	//
	TCHAR wszAccount[ 256 ];
	memset( wszAccount, 0, 256 * sizeof( TCHAR ) );
	if( 0 == _tcsnicmp( _T( ".\\" ), wszServiceAccount, 2 ) )
	{
		_tcsncpy( wszAccount, &wszServiceAccount[ 2 ], _tcslen( wszServiceAccount ) - 2 );
	}
	else
	{
		_tcsncpy( wszAccount, wszServiceAccount, _tcslen( wszServiceAccount ) );
	}

	Log( _T( "Account we will attempt to grant execute privilege = %s." ), wszAccount );

	//
	// We add an "execute" ACE to the ACL only if:
	//
	// 1.  There is some content in the wszAccount variable.
	// 2.  The content is not "LocalSystem".  We don't need to add an ACE if this is the case.
	//
	if( ( 0 != _tcslen( wszAccount ) ) && ( 0 != _tcsicmp( wszAccount, _T( "LocalSystem" ) ) ) )
	{
		DWORD dwAccessMask = GENERIC_EXECUTE;
		AddAccessRightsVerbose( wszResetKeyExe, wszAccount, dwAccessMask );
		AddAccessRightsVerbose( wszRecalcStatsExe, wszAccount, dwAccessMask );
		AddAccessRightsVerbose( wszXPDLL, wszAccount, dwAccessMask );
	}

	return ERROR_SUCCESS;
}

//*************************************************************************************
// Helper functions. Manage the Shared Dll counters
//
int AddSharedDllRef( LPCSTR szFullPath )
{
	LPCSTR	szRegPath = "Software\\Microsoft\\Windows\\CurrentVersion\\SharedDLLs";
	HKEY	hReg = NULL;
	DWORD	dwCount = 0;

	if ( IsBadStringPtrA( szFullPath, MAX_PATH ) )
		return E_INVALIDARG;

	try
	{
		DWORD cbData = sizeof dwCount;

		LONG iRes = RegOpenKeyA( HKEY_LOCAL_MACHINE, szRegPath, &hReg );
		if ( iRes != ERROR_SUCCESS )
			return iRes;

		iRes = RegQueryValueExA( hReg, szFullPath, NULL, NULL, (LPBYTE)&dwCount, &cbData );
		if ( iRes != ERROR_SUCCESS && iRes != ERROR_FILE_NOT_FOUND && iRes != ERROR_PATH_NOT_FOUND )
		{
			RegCloseKey( hReg );
			return iRes;
		}

		dwCount++;
		cbData = sizeof dwCount;
		iRes = RegSetValueExA( hReg, szFullPath, 0, REG_DWORD, (LPBYTE)&dwCount, cbData );

		RegCloseKey( hReg );
	}
	catch (...)
	{
		if ( hReg )
			RegCloseKey( hReg );
		return E_FAIL;
	}

	return dwCount;
}


int ReleaseSharedDll ( LPCSTR szFullPath )
{
	LPCSTR	szRegPath = "Software\\Microsoft\\Windows\\CurrentVersion\\SharedDLLs";
	HKEY	hReg = NULL;
	DWORD	dwCount = 0;

	if ( IsBadStringPtrA( szFullPath, MAX_PATH ) )
		return E_INVALIDARG;

	try
	{
		DWORD cbData = sizeof dwCount;

		LONG iRes = RegOpenKeyA( HKEY_LOCAL_MACHINE, szRegPath, &hReg );
		if ( iRes != ERROR_SUCCESS )
			return iRes;

		iRes = RegQueryValueExA( hReg, szFullPath, NULL, NULL, (LPBYTE)&dwCount, &cbData );
		if ( iRes != ERROR_SUCCESS )
		{
			RegCloseKey( hReg );
			return iRes;
		}

		if ( dwCount > 1 )
		{
			dwCount--;
			cbData = sizeof dwCount;
			iRes = RegSetValueExA( hReg, szFullPath, 0, REG_DWORD, (LPBYTE)&dwCount, cbData );
		}
		else
		{
			dwCount = 0;
			iRes = RegDeleteValueA( hReg, szFullPath );
		}

		RegCloseKey( hReg );
	}
	catch (...)
	{
		if ( hReg )
			RegCloseKey( hReg );
		return E_FAIL;
	}

	return dwCount;
}


bool AddAccessRights( TCHAR *lpszFileName, TCHAR *szUserName, DWORD dwAccessMask )
{
	//
	// SID variables.
	//
	SID_NAME_USE snuType;
	TCHAR * szDomain = NULL;
	DWORD cbDomain = 0;

	//
	// User name variables.
	//
	LPVOID pUserSID = NULL;
	DWORD cbUserSID = 0;
	DWORD cbUserName = 0;

	//
	// File SD variables.
	//
	PSECURITY_DESCRIPTOR pFileSD = NULL;
	DWORD cbFileSD = 0;

	//
	// New SD variables.
	//
	PSECURITY_DESCRIPTOR pNewSD = NULL;

	//
	// ACL variables.
	//
	PACL pACL = NULL;
	BOOL fDaclPresent;
	BOOL fDaclDefaulted;
	ACL_SIZE_INFORMATION AclInfo;

	//
	// New ACL variables.
	//
	PACL pNewACL = NULL;
	DWORD cbNewACL = 0;

	//
	// Temporary ACE.
	//
	LPVOID pTempAce = NULL;
	UINT CurrentAceIndex;
	bool fResult = false;
	BOOL fAPISuccess;

	// error code
	DWORD	lastErr = 0;

	try
	{
		//
		// Call this API once to get the buffer sizes ( it will return ERROR_INSUFFICIENT_BUFFER )
		//
		fAPISuccess = LookupAccountName( NULL, szUserName, pUserSID, &cbUserSID, szDomain, &cbDomain, &snuType );

		if( fAPISuccess )
		{
			throw E_FAIL; // we throw some fake error to skip through to the exit door
		}
		else if( GetLastError() != ERROR_INSUFFICIENT_BUFFER )
		{
			lastErr = GetLastError();
			LogError( TEXT( "LookupAccountName() failed" ), lastErr );
			throw lastErr;
		}

		//
		// allocate the buffers
		//
		pUserSID = calloc( cbUserSID, 1 );
		if( !pUserSID )
		{
			lastErr = GetLastError();
			LogError( TEXT( "Alloc() for UserSID failed" ), lastErr );
			throw lastErr;
		}

		szDomain = ( TCHAR * ) calloc( cbDomain + sizeof TCHAR, sizeof TCHAR );
		if( !szDomain )
		{
			lastErr = GetLastError();
			LogError( TEXT( "Alloc() for szDomain failed" ), lastErr );
			throw lastErr;
		}

		//
		// The LookupAccountName function accepts the name of a system and an account as input. 
		// It retrieves a security identifier ( SID ) for the account and 
		// the name of the domain on which the account was found
		//
		fAPISuccess = LookupAccountName( NULL /* = local computer */, szUserName, pUserSID, &cbUserSID, szDomain, &cbDomain, &snuType );
		if( !fAPISuccess )
		{
			lastErr = GetLastError();
			LogError( TEXT( "LookupAccountName() failed" ), lastErr );
			throw lastErr;
		}

		//
		// call this API once to get the buffer sizes
		// API should have failed with insufficient buffer.
		//
		fAPISuccess = GetFileSecurity( lpszFileName, DACL_SECURITY_INFORMATION, pFileSD, 0, &cbFileSD );
		if( fAPISuccess )
		{
			throw E_FAIL;
		}
		else if( GetLastError() != ERROR_INSUFFICIENT_BUFFER )
		{
			lastErr = GetLastError();
			LogError( TEXT( "GetFileSecurity() failed" ), lastErr );
			throw lastErr;
		}

		//
		// allocate the buffers
		//
		pFileSD = calloc( cbFileSD, 1 );
		if( !pFileSD )
		{
			lastErr = GetLastError();
			LogError( TEXT( "Alloc() for pFileSD failed" ), lastErr );
			throw lastErr;
		}

		//
		// call the api to get the actual data
		//
		fAPISuccess = GetFileSecurity( lpszFileName, DACL_SECURITY_INFORMATION, pFileSD, cbFileSD, &cbFileSD );
		if( !fAPISuccess )
		{
			lastErr = GetLastError();
			LogError( TEXT( "GetFileSecurity() failed" ), lastErr );
			throw lastErr;
		}

		//
		// Initialize new SD.
		//
		pNewSD = calloc( cbFileSD, 1 ); // Should be same size as FileSD.
		if( !pNewSD )
		{
			lastErr = GetLastError();
			LogError( TEXT( "Alloc() for pNewDS failed" ), GetLastError() );
			throw lastErr;
		}

		if( !InitializeSecurityDescriptor( pNewSD, SECURITY_DESCRIPTOR_REVISION ) )
		{
			lastErr = GetLastError();
			LogError( TEXT( "InitializeSecurityDescriptor() failed" ), lastErr );
			throw lastErr;
		}

		//
		// Get DACL from SD.
		//
		if( !GetSecurityDescriptorDacl( pFileSD, &fDaclPresent, &pACL, &fDaclDefaulted ) )
		{
			lastErr = GetLastError();
			LogError( TEXT( "GetSecurityDescriptorDacl() failed" ), lastErr );
			throw lastErr;
		}

		//
		// Get size information for DACL.
		//
		AclInfo.AceCount = 0; // Assume NULL DACL.
		AclInfo.AclBytesFree = 0;
		AclInfo.AclBytesInUse = sizeof( ACL );      // If not NULL DACL, gather size information from DACL.
		if( fDaclPresent && pACL )
		{
			if( !GetAclInformation( pACL, &AclInfo, sizeof( ACL_SIZE_INFORMATION ), AclSizeInformation ) )
			{
				lastErr = GetLastError();
				LogError( TEXT( "GetAclInformation() failed" ), lastErr );
				throw lastErr;
			}
		}

		//
		// Compute size needed for the new ACL.
		//
		cbNewACL = AclInfo.AclBytesInUse + sizeof( ACCESS_ALLOWED_ACE ) + GetLengthSid( pUserSID );

		//
		// Allocate memory for new ACL.
		//
		pNewACL = ( PACL ) calloc( cbNewACL, 1 );
		if( !pNewACL )
		{
			lastErr = GetLastError();
			LogError( TEXT( "HeapAlloc() failed" ), lastErr );
			throw lastErr;
		}

		//
		// Initialize the new ACL.
		//
		if( !InitializeAcl( pNewACL, cbNewACL, ACL_REVISION2 ) )
		{
			lastErr = GetLastError();
			LogError( TEXT( "InitializeAcl() failed" ), lastErr );
			throw lastErr;
		}

		//
		// Add the access-allowed ACE to the new DACL.
		//
		ACE_HEADER aceheader = {0};
		aceheader.AceFlags = CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE;
		aceheader.AceSize  = sizeof( ACE_HEADER );
		aceheader.AceType = ACCESS_ALLOWED_OBJECT_ACE_TYPE;
		if( !AddAccessAllowedAceEx( pNewACL, ACL_REVISION2, aceheader.AceFlags, dwAccessMask, pUserSID ) )
		{
			lastErr = GetLastError();
			LogError( TEXT( "AddAccessAllowedAce() failed" ),	lastErr );
			throw lastErr;
		}

		//
		// If DACL is present, copy it to a new DACL.
		//
		if( fDaclPresent )
		{
			//
			// Copy the file's ACEs to the new ACL
			//
			if( AclInfo.AceCount )
			{
				for( CurrentAceIndex = 0; CurrentAceIndex < AclInfo.AceCount; CurrentAceIndex++ )
				{
					//
					// Get an ACE.
					//
					if( !GetAce( pACL, CurrentAceIndex, &pTempAce ) )
					{
						lastErr = GetLastError();
						LogError( TEXT( "GetAce() failed" ), lastErr );
						throw lastErr;
					}

					//
					// Add the ACE to the new ACL.
					//
					if( !AddAce( pNewACL, ACL_REVISION, MAXDWORD, pTempAce,	( ( PACE_HEADER ) pTempAce )->AceSize ) )
					{
						lastErr = GetLastError();
						LogError( TEXT( "AddAce() failed" ), lastErr );
						throw lastErr;
					}
				}
			}
		}

		//
		// Set the new DACL to the file SD.
		//
		if( !SetSecurityDescriptorDacl( pNewSD, TRUE, pNewACL, FALSE ) )
		{
			lastErr = GetLastError();
			LogError( TEXT( "SetSecurityDescriptorDacl() failed" ), lastErr );
			lastErr;
		}

		//
		// Set the SD to the File.
		//
		if( !SetFileSecurity( lpszFileName, DACL_SECURITY_INFORMATION, pNewSD ) )
		{
			lastErr = GetLastError();
			LogError( TEXT( "SetFileSecurity() failed" ), lastErr );
			throw lastErr;
		}

		fResult = TRUE;
	}
	catch (...)
	{
		fResult = FALSE;
	}

	//
	// Free allocated memory
	//
	if( pUserSID )
		free( pUserSID );
	if( szDomain )
		free( szDomain );
	if( pFileSD )
		free( pFileSD );
	if( pNewSD )
		free( pNewSD );
	if( pNewACL )
		free( pNewACL );

	return fResult;
}

//
// This function takes in the name of a Service (ie, MSSQL$DAVESEBESTA), and
// fills a buffer with the name of the startup account for said Service.
//
// It does this by opening the Service Control Manager, getting a handle to
// said Service, and then querying the properties of the service.
//
// returns:  ERROR_SUCCESS if everything goes well.
//
LONG
GetServiceStartupAccount( const TCHAR *pwszServiceName, TCHAR *pwszServiceAccount, int iLen )
{
	memset( pwszServiceAccount, 0, iLen * sizeof( TCHAR ) );

	//
	// 1.  Open the Service Control Manager.
	//
	SC_HANDLE hSCM = OpenSCManager( NULL, NULL, SC_MANAGER_CONNECT );
	if( NULL == hSCM )
	{
		Log( _T( "Could not open the Service Control Manager." ) );
		return ERROR_SUCCESS;
	}
	else
	{
		Log( _T( "Successfully opened a handle to the Service Control Manager." ) );
	}

	//
	// 2.  Get a handle to the Service.
	//
	DWORD dwAccess = SERVICE_QUERY_CONFIG;
	SC_HANDLE hSvc = OpenService( hSCM, pwszServiceName, dwAccess );
	if( NULL == hSvc )
	{
		Log( _T( "Could not open a handle to the service %s." ), pwszServiceName );
		CloseServiceHandle( hSCM );
		return ERROR_SUCCESS;
	}
	else
	{
		Log( _T( "Successfully opened a handle to the service %s." ), pwszServiceName );
	}

	//
	// 3.  Call QueryServiceConfig.  This get us, among other things, the name of
	//     the account that is used to start the Service.
	//
	DWORD dwSizeNeeded = 0;
	BOOL b = QueryServiceConfig( hSvc, NULL, 0, &dwSizeNeeded );
	DWORD d = GetLastError();
	if( !b && ( ERROR_INSUFFICIENT_BUFFER == d ) )
	{
		Log( _T( "About to allocate memory for service config info..." ) );
	}
	else
	{
		Log( _T( "Something went wrong during the call to QueryServiceConfig." ) );
		CloseServiceHandle( hSvc );
		CloseServiceHandle( hSCM );
		return ERROR_SUCCESS;
	}

	LPQUERY_SERVICE_CONFIG pSvcQuery = (LPQUERY_SERVICE_CONFIG)malloc( dwSizeNeeded );
	if( NULL == pSvcQuery )
	{
		Log( _T( "Ran out of memory." ) );
		CloseServiceHandle( hSvc );
		CloseServiceHandle( hSCM );
		return ERROR_SUCCESS;
	}

	b = QueryServiceConfig( hSvc, pSvcQuery, dwSizeNeeded, &dwSizeNeeded );
	if( !b )
	{
		Log( _T( "Call to QueryServiceConfig failed." ) );
		free( (void *)pSvcQuery );
		CloseServiceHandle( hSvc );
		CloseServiceHandle( hSCM );
		return ERROR_SUCCESS;
	}


	Log( _T( "Service startup account = %s" ), pSvcQuery->lpServiceStartName );

	//
	// 4.  Copy the account into our output buffer, free up memory, and exit.
	//
	_tcsncpy( pwszServiceAccount, pSvcQuery->lpServiceStartName, iLen );

	free( (void *)pSvcQuery );
	CloseServiceHandle( hSvc );
	CloseServiceHandle( hSCM );
	return ERROR_SUCCESS;
}


//
// Use the instance name to determine the name of the SQL Service.
//
// From the database instance name, you can infer the name of the Service
// for that particular instance.
//
// Instance Name                  Service Name
// ===========================================
// (default)                      MSSQLSERVER
// NULL                           MSSQLSERVER
// <anything else>                MSSQL$<anything else>
//
void
GetUDDIDBServiceName( const TCHAR *pwszInstanceName, TCHAR *pwszServiceName, int iLen )
{
	memset( pwszServiceName, 0, iLen * sizeof( TCHAR ) );
	_tcscpy( pwszServiceName, _T( "MSSQL" ) );

	if( ( 0 == _tcslen( pwszInstanceName ) ) ||
		( 0 == _tcsicmp( pwszInstanceName, _T( "----" ) ) ) ||
		( 0 == _tcsicmp( pwszInstanceName, _T( "(default)" ) ) ) )
	{
		_tcsncat( pwszServiceName, _T( "SERVER" ), iLen );
	}
	else
	{
		_tcsncat( pwszServiceName, _T( "$" ), iLen );
		_tcsncat( pwszServiceName, pwszInstanceName, iLen );
	}

	Log( _T( "Database service name = %s" ), pwszServiceName );
}


void
AddAccessRightsVerbose( TCHAR *pwszFileName, TCHAR *pwszUserName, DWORD dwMask )
{
	BOOL b = AddAccessRights( pwszFileName, pwszUserName, dwMask );
	if( !b )
	{
		Log( _T( "ACL for file %s was NOT modified." ), pwszFileName );
	}
	else
	{
		Log( _T( "User: %s now has execute permissions on file: %s." ), pwszUserName, pwszFileName );
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\setup\db\ca.unmanaged\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by webcaum.rc

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\setup\msitoddf\msitoddf.cpp ===
//-----------------------------------------------------------------------------

#include "stdafx.h"
#include "msitoddf.h"

static PTCHAR GetFileLongName( PTCHAR szFileName );
static PTCHAR GetErrorMsg( UINT iRet );
static bool CreateCABDDF( void );
static bool FileExists( PTCHAR szFileName );
static bool CreateCabsTableDefinitionFile( void );
static bool LookupComponentTargetFolder( PTCHAR szComponent, PTCHAR szComponentFolder );
static void Log( LPCTSTR fmt, ... );

PMSIHANDLE g_hDatabase;
PMSIHANDLE g_hInstall;
UINT g_iFileCount;

TCHAR g_MSIFile[ MAX_PATH ];
TCHAR g_LogFile[ MAX_PATH ];
TCHAR g_DDFFile[ MAX_PATH ];
TCHAR g_CABFile[ MAX_PATH ];
TCHAR g_RootDir[ MAX_PATH ];

//--------------------------------------------------------------

int __cdecl _tmain( int argc, TCHAR* argv[], TCHAR* envp[] )
{
	UINT iRet = 0;

	if( argc < 2 )
	{
		_tprintf( TEXT( "Extracts the file list from an MSI installer database and creates a DDF file\n\n" ) );
		_tprintf( TEXT( "Usage: %s <MSI file path> [-L <error log file path>]\n\n" ), argv[ 0 ] );
		return 1;
	}

	//MessageBox( NULL, TEXT( "UDDI" ), TEXT( "UDDI" ), MB_OK) ;

	_tcscpy( g_MSIFile, argv[ 1 ] );

	TCHAR szDrive[ _MAX_DRIVE ];
	TCHAR szPath[ _MAX_DIR ];
	TCHAR szFileName[ _MAX_FNAME ];
	_tsplitpath( g_MSIFile, szDrive, szPath, szFileName, NULL );

	_stprintf( g_DDFFile, TEXT( "%s%s%s.DDF" ), szDrive, szPath, szFileName );
	_stprintf( g_CABFile, TEXT( "%s.CAB" ), szFileName );
	_stprintf( g_RootDir, TEXT( "%s%s" ), szDrive, szPath );

	if( argc > 3 && 0 == _tcsicmp( argv[ 2 ], TEXT( "-L" ) ) )
	{
		_tcsncpy( g_LogFile, argv[ 3 ], MAX_PATH );
	}
	else
	{
		*g_LogFile = NULL;
	}

	//
	// open the database
	//
	if( !FileExists( g_MSIFile ) )
	{
		Log(  TEXT( "*** Error: MSI File does not exist: %s" ), g_MSIFile );
		return 1;
	}

	iRet = MsiOpenDatabase( g_MSIFile, MSIDBOPEN_READONLY, &g_hDatabase );
	if( ERROR_SUCCESS != iRet )
	{
		Log(  TEXT( "*** Error: MsiOpenDatabase Error: %s" ), GetErrorMsg( iRet ) );
		return 1;
	}

	//
	// get a database handle
	//
	TCHAR szDBHandle[ 10 ];
	_stprintf( szDBHandle, TEXT( "#%d" ), (DWORD) (MSIHANDLE) g_hDatabase );

	iRet = MsiOpenPackage( szDBHandle, &g_hInstall );
	if( ERROR_SUCCESS != iRet )
	{
		Log(  TEXT( "*** Error: MsiOpenPackage Error: %s" ), GetErrorMsg( iRet ) );
	}
	else
	{
		if( ERROR_SUCCESS != MsiDoAction( g_hInstall, TEXT( "CostInitialize" ) ) )
			return 1;
		if( ERROR_SUCCESS != MsiDoAction( g_hInstall, TEXT( "FileCost" ) ) )
			return 1;
		if( ERROR_SUCCESS != MsiDoAction( g_hInstall, TEXT( "CostFinalize" ) ) )
			return 1;
		if( !CreateCABDDF() )
			return 1;
	}

	//
	// commit the changes
	//
	iRet = MsiDatabaseCommit( g_hDatabase );
	if( ERROR_SUCCESS != iRet )
	{
		Log(  TEXT( "*** Error: MsiDatabaseCommit Error: %s" ), GetErrorMsg( iRet ) );
		return 1;
	}

	return 0;
}

//--------------------------------------------------------------

static bool CreateCABDDF( void )
{
	UINT iRet;
	PMSIHANDLE hView;
	PMSIHANDLE hRecord = 0;

	//
	// the install dir will give us the root of the path that we
	// can use later and trim it off
	//
	TCHAR szInstallDir[ _MAX_PATH ];
	DWORD dwSize = _MAX_PATH;
	iRet = MsiGetProperty( g_hInstall, TEXT("uddi"), szInstallDir, &dwSize );
	if( ERROR_SUCCESS != iRet )
	{
		Log(  TEXT( "*** Error: MsiGetProperty Error: %s" ), GetErrorMsg( iRet ) );
		return false;
	}

	//
	// open a view and submit the SQL query
	//
	TCHAR szSQLQuery[ 256 ];
	_stprintf( szSQLQuery, TEXT( "select File, FileName, Component_, Sequence from File order by Sequence" ) );

	iRet = MsiDatabaseOpenView( g_hDatabase, szSQLQuery , &hView );

	if( ERROR_SUCCESS != iRet )
	{
		Log(  TEXT( "*** Error: MsiDatabaseOpenView Error: %s" ), GetErrorMsg( iRet ) );
		return false;
	}

	//
	// execute the SQL query
	//
	iRet = MsiViewExecute( hView, hRecord );

	if( ERROR_SUCCESS != iRet )
	{
		Log(  TEXT( "*** Error: MsiViewExecute Error: %s" ), GetErrorMsg( iRet ) );
		return false;
	}

	//
	// open the DDF file
	//
	FILE *file = _tfopen( g_DDFFile, TEXT( "w" ) );
	if( NULL == file )
	{
		Log(  TEXT( "*** Error: Unable to open output file: %s, Error code %d" ), g_DDFFile, GetLastError() );
		return false;
	}

	//
	// header in DDF file used by makecab.exe
	//
	_fputts( TEXT( ".Option Explicit\n" ), file );
	_fputts( TEXT( ".Set DiskDirectoryTemplate=.\n" ), file );
	_fputts( TEXT( ".Set CabinetName1=" ), file );
	_fputts( g_CABFile, file );
	_fputts( TEXT( "\n" ), file );
	_fputts( TEXT( ".Set RptFilename=nul\n" ), file );
	_fputts( TEXT( ".Set InfFileName=nul\n" ), file );
	_fputts( TEXT( ".Set InfAttr=\n" ), file );
	_fputts( TEXT( ".Set MaxDiskSize=CDROM\n" ), file );
	_fputts( TEXT( ".Set CompressionType=LZX\n" ), file );
	_fputts( TEXT( ".Set CompressionMemory=21\n" ), file );
	_fputts( TEXT( ".Set CompressionLevel=1\n" ), file );
	_fputts( TEXT( ".Set Compress=ON\n" ), file );
	_fputts( TEXT( ".Set Cabinet=ON\n" ), file );
	_fputts( TEXT( ".Set UniqueFiles=ON\n" ), file );
	_fputts( TEXT( ".Set FolderSizeThreshold=1000000\n" ), file );
	_fputts( TEXT( ".Set MaxErrors=300\n" ), file );

	//
	// fetch the data
	//
	TCHAR szFile[ 256 ];
	TCHAR szFileName[ 256 ];
	TCHAR szComponent[ 256 ];
	TCHAR szComponentFolder[ 256 ];
	TCHAR szFilePath[ 256 ];
	int iSequence;
	DWORD cchValueBuf;
	g_iFileCount = 0;

	while( ERROR_NO_MORE_ITEMS != MsiViewFetch( hView, &hRecord ) )
	{
		g_iFileCount++;
		cchValueBuf = 256;
		MsiRecordGetString( hRecord, 1, szFile, &cchValueBuf );

		cchValueBuf = 256;
		MsiRecordGetString( hRecord, 2, szFileName, &cchValueBuf );

		cchValueBuf = 256;
		MsiRecordGetString( hRecord, 3, szComponent, &cchValueBuf );

		iSequence = MsiRecordGetInteger( hRecord, 4 );

		//
		// query the MSI for the target folder for this file.
		// this will tell us where it is located in the \binaries folders.
		//
		if( !LookupComponentTargetFolder( szComponent, szComponentFolder ) )
		{
			Log(  TEXT( "**ERROR: Unable to find directory for component: %s" ), szComponent );
			return false;
		}

		TCHAR szWindowsDir[ MAX_PATH ];
		if( 0 == ExpandEnvironmentStrings( TEXT( "%systemroot%" ), szWindowsDir, MAX_PATH ) )
			return false;

		//_tprintf( TEXT( "windir=%s\n" ), szWindowsDir );
		//_tprintf( TEXT( "szComponentFolder=%s\n" ), szComponentFolder );

		//
		// look for files that are in the windows folder
		//
		if( 0 == _tcsnicmp( szComponentFolder, szWindowsDir, _tcslen( szWindowsDir ) ) )
		{
			//
			// create the full path to the file in \binaries folder. e.g. \binaries\uddi\windows\system32
			//
			_stprintf( szFilePath, TEXT( "%s%s%s" ),
				g_RootDir,											// start with the root (c:\binariesx\uddi\)
				szComponentFolder + _tcslen( szWindowsDir ) + 1,
				GetFileLongName( szFileName ) );					// add file name
		}
		else
		{
			//
			// create the full path to the file in \binaries folder
			//
			_stprintf( szFilePath, TEXT( "%s%s%s" ),
				g_RootDir,										// start with the root (c:\binariesx\uddi)
				&szComponentFolder[ _tcslen( szInstallDir ) ],	// strip installdir prefix and append
				GetFileLongName( szFileName ) );				// add file name
		}

		//
		// if it exists (and it should), trim the c:\binaries\... part on put the file
		// name into the DDF file
		//
		if( FileExists( szFilePath ) )
		{
			_fputts( TEXT( "\"" ), file );
			_fputts( &szFilePath[ _tcslen( g_RootDir ) ], file ); // trim the root dir
			_fputts( TEXT( "\"\t\"" ), file );
			_fputts( szFile, file );
			_fputts( TEXT( "\"\n" ), file );
		}
		else
		{
			fclose( file );
			Log( TEXT( "*** ERROR: Source File does not exist: %s" ), szFilePath );
			Log( TEXT( "File=%s, %s" ), szFile, szFileName );
			Log( TEXT( "Component=%s" ), szComponent );
			Log( TEXT( "Component Folder=%s" ), szComponentFolder );
			Log( TEXT( "systemroot=%s" ), szWindowsDir );
			return false;
		}
	}

	fclose( file );

	return true;
}

//--------------------------------------------------------------

static bool LookupComponentTargetFolder( PTCHAR szComponent, PTCHAR szComponentFolder )
{
	UINT iRet;
	PMSIHANDLE hView;
	PMSIHANDLE hRecord = 0;
	//
	// open a view and submit the SQL query
	//
	TCHAR szSQLQuery[ 256 ];

	_stprintf( szSQLQuery, TEXT( "select Directory_ from Component where Component = '%s'" ), szComponent );

	iRet = MsiDatabaseOpenView( g_hDatabase, szSQLQuery , &hView );

	if( ERROR_SUCCESS != iRet )
	{
		Log(  TEXT( "*** Error: MsiDatabaseOpenView Error: %s" ), GetErrorMsg( iRet ) );
		return false;
	}

	//
	// execute the SQL query
	//
	iRet = MsiViewExecute( hView, hRecord );

	if( ERROR_SUCCESS != iRet )
	{
		Log(  TEXT( "*** Error: MsiViewExecute Error: %s" ), GetErrorMsg( iRet ) );
		return false;
	}

	//
	// fetch the data
	//
	TCHAR szDirectoryKey[ 256 ];
	DWORD cchValueBuf = 256;
	if( ERROR_SUCCESS != MsiViewFetch( hView, &hRecord ) )
	{
		Log(  TEXT( "*** ERROR: Directory not found for component [ %s ]" ), szComponent );
		return false;
	}

	// get the key into the Directory table
	MsiRecordGetString( hRecord, 1, szDirectoryKey, &cchValueBuf );

	// look up the full path
	DWORD cchPathBuf = 256;
	iRet = MsiGetTargetPath( g_hInstall, szDirectoryKey, szComponentFolder, &cchPathBuf );

	if( ERROR_SUCCESS != iRet )
	{
		Log(  TEXT( "*** Error: MsiGetSourcePath Error component [ %s ] %s" ), szComponent, GetErrorMsg( iRet ) );
		return false;
	}

	return true;
}

//--------------------------------------------------------------
// returns the long file name out of a string that has both
// short and long name separated by a pipe character
static PTCHAR GetFileLongName( PTCHAR szFileName )
{
	PTCHAR pStart = _tcschr( szFileName, TEXT( '|' ) );

	if( pStart )
	{
		return pStart + 1; // add 1 to skip over the pipe symbol
	}

	return szFileName;
}

//--------------------------------------------------------------

static bool FileExists( PTCHAR szFileName )
{
	FILE *file = _tfopen( szFileName, TEXT( "rt" ) );
	if( NULL == file )
	{
		return false;
	}

	fclose( file );

	return true;
}

//--------------------------------------------------------------------------

static bool SetProperty( PTCHAR szProperty, PTCHAR szValue )
{
	UINT iRet = MsiSetProperty( g_hInstall, szProperty, szValue );

	if( ERROR_SUCCESS != iRet )
	{
		Log(  TEXT( "*** Error: SetProperty Error: %s, Property %s, Value %s" ),
			GetErrorMsg( iRet ),
			szProperty,
			szValue );

		return false;
	}

	return true;
}

//--------------------------------------------------------------

static PTCHAR GetErrorMsg( UINT iRet )
{
	static TCHAR szErrMsg[ 100 ];

	FormatMessage( 
		FORMAT_MESSAGE_FROM_SYSTEM | 
		FORMAT_MESSAGE_IGNORE_INSERTS,
		NULL,
		iRet,
		MAKELANGID( LANG_NEUTRAL, SUBLANG_DEFAULT ), // Default language
		( LPTSTR ) szErrMsg,
		100,
		NULL);

	return szErrMsg;
}

//--------------------------------------------------------------------------

static void Log( LPCTSTR fmt, ... )
{
	TCHAR szTime[ 10 ];
	TCHAR szDate[ 10 ];
	::_tstrtime( szTime );
	::_tstrdate( szDate );

	va_list marker;
	TCHAR szBuf[1024];

	size_t cbSize = ( sizeof( szBuf ) / sizeof( TCHAR ) ) - 1; // one byte for null
	_sntprintf( szBuf, cbSize, TEXT( "%s %s: " ), szDate, szTime );
	szBuf[ 1023 ] = '\0';
	cbSize -= _tcslen( szBuf );

	va_start( marker, fmt );

	_vsntprintf( szBuf + _tcslen( szBuf ), cbSize, fmt, marker );
	szBuf[ 1023 ] = '\0';
	cbSize -= _tcslen( szBuf );

	va_end( marker );

	_tcsncat(szBuf, TEXT("\r\n"), cbSize );

	_tprintf( TEXT( "%s" ), szBuf );

	if( 0 == _tcslen( g_LogFile ) )
		return;

	// write the data out to the log file
	char szBufA[ 1024 ];
	WideCharToMultiByte( CP_ACP, 0, szBuf, -1, szBufA, 1024, NULL, NULL );

	HANDLE hFile = CreateFile(
		g_LogFile,                    // file name
		GENERIC_WRITE,                // open for writing 
		0,                            // do not share 
		NULL,                         // no security 
		OPEN_ALWAYS,                  // open and create if not exists
		FILE_ATTRIBUTE_NORMAL,        // normal file 
		NULL);                        // no attr. template 

	if( hFile == INVALID_HANDLE_VALUE )
	{ 
		return;
	}

	//
	// move the file pointer to the end so that we can append
	//
	SetFilePointer( hFile, 0, NULL, FILE_END );

	DWORD dwNumberOfBytesWritten;
	BOOL bOK = WriteFile(
		hFile,
		szBufA,
		(UINT) strlen( szBufA ),     // number of bytes to write
		&dwNumberOfBytesWritten,                       // number of bytes written
		NULL);                                         // overlapped buffer

	FlushFileBuffers ( hFile );
	CloseHandle( hFile );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\setup\msitoddf\msitoddf.h ===
#pragma once
#include "resource.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\setup\msitoddf\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by CreateMSICABMakefile.rc
//
#define IDS_HELLO                       1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\setup\msitoddf\stdafx.cpp ===
#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\setup\msitoddf\stdafx.h ===
#pragma once

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include <msi.h>
#include <msiquery.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\setup\ocm\net_config_get.h ===
// net_config_get.h : Declaration of the net_config_get class

#ifndef __NET_CONFIG_GET_H_
#define __NET_CONFIG_GET_H_

class net_config_getAccessor
{
public:
	TCHAR m_configName[257];
	TCHAR m_configValue[8001];
	DBSTATUS m_dwconfigNameStatus;
	DBSTATUS m_dwconfigValueStatus;
	DBLENGTH m_dwconfigNameLength;
	DBLENGTH m_dwconfigValueLength;
	CComBSTR m_connectionString;
	LONG	m_RETURN_VALUE;

BEGIN_COLUMN_MAP(net_config_getAccessor)
	COLUMN_ENTRY_LENGTH_STATUS(1, m_configName, m_dwconfigNameLength, m_dwconfigNameStatus)
	COLUMN_ENTRY_LENGTH_STATUS(2, m_configValue, m_dwconfigValueLength, m_dwconfigValueStatus)
END_COLUMN_MAP()

BEGIN_PARAM_MAP(net_config_getAccessor)
    SET_PARAM_TYPE(DBPARAMIO_OUTPUT)
    COLUMN_ENTRY(1, m_RETURN_VALUE)
END_PARAM_MAP()


DEFINE_COMMAND(net_config_getAccessor, _T("{ ? = CALL dbo.net_config_get }"))

	// You may wish to call this function if you are inserting a record and wish to
	// initialize all the fields, if you are not going to explicitly set all of them.
	void ClearRecord()
	{
		memset(this, 0, sizeof(*this));
	}
};

class net_config_get : public CCommand<CAccessor<net_config_getAccessor>, CRowset, CMultipleResults >
{
public:
	HRESULT Open()
	{
		HRESULT		hr;
		m_configName[ 0 ] = 0x00;
		m_configValue[ 0 ] = 0x00;

		hr = OpenDataSource();
		if( FAILED(hr) )
			return hr;

		return OpenRowset();
	}
	HRESULT OpenDataSource()
	{
		HRESULT		hr;
		CDataSource db;
		hr = db.OpenFromInitializationString( m_connectionString );

		if( FAILED(hr) )
			return hr;

		return m_session.Open(db);
	}
	HRESULT OpenRowset()
	{
		return __super::Open(m_session, NULL, NULL, 0, DBGUID_DBSQL, false);
	}
	CSession	m_session;
};

#endif // __NET_CONFIG_GET_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\setup\ocm\appcompat.h ===
#ifndef _APPCOMPAT_H_
#define _APPCOMPAT_H_

HRESULT IsIIS5CompatMode( bool *pbIsIIS5CompatMode );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\setup\ocm\common.cpp ===
#include "..\shared\common.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\setup\ocm\adm_addserviceaccount.h ===
// ADM_addServiceAccount.h : Declaration of the CADM_addServiceAccount

#pragma once

// ADM_addServiceAccount.h : Declaration of the ADM_addServiceAccount class

#ifndef __ADM_addServiceAccount_H_
#define __ADM_addServiceAccount_H_

class ADM_addServiceAccountAccessor
{
public:
	LONG m_RETURNVALUE;
	TCHAR m_accountName[129];
	CComBSTR m_connectionString;

BEGIN_PARAM_MAP(ADM_addServiceAccountAccessor)
	SET_PARAM_TYPE(DBPARAMIO_OUTPUT)
	COLUMN_ENTRY(1, m_RETURNVALUE)
	SET_PARAM_TYPE(DBPARAMIO_INPUT)
	COLUMN_ENTRY(2, m_accountName)
END_PARAM_MAP()

DEFINE_COMMAND(ADM_addServiceAccountAccessor, _T("{ ? = CALL dbo.ADM_addServiceAccount;1 (?) }"))

	// You may wish to call this function if you are inserting a record and wish to
	// initialize all the fields, if you are not going to explicitly set all of them.
	void ClearRecord()
	{
		memset(this, 0, sizeof(*this));
	}
};

class ADM_addServiceAccount : public CCommand<CAccessor<ADM_addServiceAccountAccessor> >
{
public:
	HRESULT Open()
	{
		HRESULT		hr;

		hr = OpenDataSource();
		if( FAILED(hr) )
			return hr;

		return OpenRowset();
	}

	HRESULT OpenDataSource()
	{
		HRESULT		hr;
		CDataSource db;

		hr = db.OpenFromInitializationString( m_connectionString );
		if( FAILED(hr) )
			return hr;

		return m_session.Open(db);
	}

	HRESULT OpenRowset()
	{
		return CCommand<CAccessor<ADM_addServiceAccountAccessor> >::Open(m_session);
	}

	CSession	m_session;
};

#endif // __ADM_addServiceAccount_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\setup\ocm\appcompat.cpp ===
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0500
#endif

#ifndef INITGUID
#define INITGUID // must be before iadmw.h
#endif

#include <stdio.h>
#include <objbase.h>
#include <iadmw.h>      // Interface header
#include <iiscnfg.h>    // MD_ & IIS_MD_ defines

#include "appcompat.h"

#define REASONABLE_TIMEOUT 1000

HRESULT IsIIS5CompatMode( bool *pbIsIIS5CompatMode )
{
	IMSAdminBase* pIMSAdminBase = NULL;
	METADATA_HANDLE hMetabase = NULL;
	HRESULT hr = 0;

	*pbIsIIS5CompatMode = false;

	hr = CoInitializeEx( NULL, COINIT_MULTITHREADED );
	if( FAILED( hr ) )
	{
		return hr;
	}

	__try
	{
		hr = CoCreateInstance(
			CLSID_MSAdminBase,
			NULL,
			CLSCTX_ALL,
			IID_IMSAdminBase,
			(void**)&pIMSAdminBase );

		if( FAILED( hr ) )
		{
			// this occurs with a 1058 ERROR_SERVICE_DISABLED if the service is disabled
			__leave;
		}

		METADATA_RECORD mr = {0};

		//
		// open the key and get a handle
		//
		hr = pIMSAdminBase->OpenKey( METADATA_MASTER_ROOT_HANDLE,
							TEXT( "/LM/W3SVC" ),
							METADATA_PERMISSION_READ,
							REASONABLE_TIMEOUT,
							&hMetabase );
		if( FAILED( hr ) )
		{
			__leave;
		}

		DWORD dwIISIsolationModeEnabled = 0;
		mr.dwMDIdentifier = 9203; // iis5isolationmode=9203
		mr.dwMDAttributes = 0;
		mr.dwMDUserType   = IIS_MD_UT_SERVER;
		mr.dwMDDataType   = DWORD_METADATA;
		mr.dwMDDataLen    = sizeof( DWORD );
		mr.pbMDData       = reinterpret_cast<unsigned char *> ( &dwIISIsolationModeEnabled );

		//
		// See if MD_APPPOOL_FRIENDLY_NAME exists
		//
		DWORD dwMDRequiredDataLen = 0;
		hr = pIMSAdminBase->GetData( hMetabase, /* subkey= */ TEXT(""), &mr, &dwMDRequiredDataLen );
		if( FAILED( hr ) )
		{
			__leave;
		}

		*pbIsIIS5CompatMode = ( dwIISIsolationModeEnabled > 0 );
	}

	__finally
	{
		if( pIMSAdminBase && hMetabase )
			pIMSAdminBase->CloseKey( hMetabase );

		CoUninitialize();
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\setup\db\ca\dbca.cs ===
/// ************************************************************************
///   Microsoft UDDI version 2.0
///   Copyright (c) 2000-2002 Microsoft Corporation
///   All rights reserved
///
///   ** Microsoft Confidential **
/// ------------------------------------------------------------------------
///   <summary>
///   </summary>
/// ************************************************************************
///
using System;
using System.IO;
using System.Data;
using Microsoft.Win32;
using System.DirectoryServices;
using System.Diagnostics;
using System.Reflection;
using System.Globalization;
using System.Collections;
using System.Collections.Specialized;
using System.Data.SqlClient;
using System.ComponentModel;
using System.Configuration.Install;
using System.ServiceProcess;
using System.Security.Cryptography;
using System.Runtime.InteropServices;
using System.Windows.Forms;
using System.Security.Principal;

using UDDI;
using UDDI.API;
using UDDI.API.Business;
using UDDI.ActiveDirectory;


namespace UDDI.DBCA
{
	[ RunInstaller( true ) ]
	public class Installer : System.Configuration.Install.Installer
	{
		private SQLDMO.SQLServer2 server	= null;
		private SQLDMO.Database2 database	= null;
		private SQLDMO.Database2 masterdb	= null;
		
		private const string dbName			= "uddi";			//name of the uddi database
		private const string dataFolderName	= "data";			//name of the uddi data folder
		private const string resetkeyfile   = @"bin\resetkey.exe";
		private const string uddiXPFile		= @"bin\uddi.xp.dll";
		private const int SQL_ALREADY_STARTED =	-2147023840;		
		private StringCollection uninstDataFiles = null;
		
		private const string busEntityParamName = "UPRV";			 // context value expected
		private const string clustNodeTypeParam = "CNTYPE";			 // cluster node type
		private const string busEntityKeyName	= "Site.Key";		 // we use this name to save the key in the Config
		private const string siteVerKeyName		= "Site.Version";    // we use this name to save the product vesrion in the Config
		private const string siteLangKeyName	= "Site.Language";	 // we use this name to save the default product language in the Config
		private const string defaultOperatorkey = "Operator";

		private const string clustNodeActive	= "A";		// Denotes an "active" node
		private const string clustNodePassive	= "P";		// Denotes a "passive" aka non-owning node

		private const string regDBServerKeyName = "SOFTWARE\\Microsoft\\UDDI\\Setup\\DBServer";
		private const string regVersionKeyName	= "ProductVersion";

		private const string tmodelUddiOrgOpers = "uuid:327a56f0-3299-4461-bc23-5cd513e95c55";
		private const string tokenOBEKeyValue   = "operationalBusinessEntity";

		//
		// Database path and file name variables
		//
		private const string propSysFilePath		= "SFP";
		private const string propCoreFilePath_1		= "C1P";
		private const string propCoreFilePath_2		= "C2P";
		private const string propJournalFilePath	= "JRNLP";
		private const string propStagingFilePath	= "STGP";
		private const string propXactLogFilePath	= "XLP";
		
		private string SystemFilePath;
		private string SystemFileSpec;
		private string Core1FilePath;
		private string Core1FileSpec;
		private string Core2FilePath;
		private string Core2FileSpec;
		private string JournalFilePath;
		private string JournalFileSpec;
		private string StagingFilePath;
		private string StagingFileSpec;
		private string LogFilePath;
		private string LogFileSpec;

		const string RegisterXpSqlFormat = @"
IF EXISTS (SELECT * FROM sysobjects where name = 'xp_reset_key' and type = 'X')
	EXEC sp_dropextendedproc 'xp_reset_key'
GO

EXEC sp_addextendedproc 'xp_reset_key', '{0}'
GO

IF EXISTS (SELECT * FROM sysobjects where name= 'xp_recalculate_statistics' and type = 'X')
	EXEC sp_dropextendedproc 'xp_recalculate_statistics'	
GO

EXEC sp_addextendedproc 'xp_recalculate_statistics', '{0}'
GO";

		//
		// These sql scripts will get executed in the master database after the 
		// database is created.
		//
		string[] masterInstallScripts   = { "uddi.v2.messages.sql" }; 

		//
		// These sql scripts will get executed in the master database when the 
		// database is being uninstalled.
		//
		string[] masterUninstallScripts = { "uddi.v2.xp.uninstall.sql" }; 

		//
		// These sql scripts will get executed in the uddi database 
		// after the master database scripts are run
		//
		string[] uddiScripts = 	
					{
							"uddi.v2.ddl.sql", 
						"uddi.v2.tableopts.sql",
						"uddi.v2.ri.sql",
						"uddi.v2.dml.sql",
						"uddi.v2.func.sql",
						"uddi.v2.sp.sql",
						"uddi.v2.admin.sql",
						"uddi.v2.repl.sql",
						"uddi.v2.trig.sql",
						"uddi.v2.uisp.sql",
						"uddi.v2.tModel.sql",
						"uddi.v2.businessEntity.sql",
						"uddi.v2.businessService.sql",
						"uddi.v2.bindingTemplate.sql",
						"uddi.v2.publisher.sql",
						"uddi.v2.sec.sql" }; 
 
		private System.ComponentModel.Container components = null;

		public Installer()
		{
			Enter();

			try
			{
				//
				// This call is required by the Designer.
				//
				InitializeComponent();
				uninstDataFiles = new StringCollection();
			}
			catch ( Exception e )
			{
				LogException( "Installer()", e );
				throw e;
			}
			finally
			{
				Leave();
			}
		}

		#region Component Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			Enter();

			try
			{
				components = new System.ComponentModel.Container();
			}
			catch ( Exception e )
			{
				Debug.WriteLine( "Exception in 'InitializeComponent()': " + e.Message );
			}
			finally
			{
				Leave();
			}
		}
		#endregion

		
		private void InitializeSQLDMO()
		{
			Enter();

			try
			{
				server = new SQLDMO.SQLServer2Class();
			}
			catch( Exception e )
			{
				Log( "The database installer failed to construct an instance of the SQLDMO.SQLServer2 class. SQL Server may not be installed." );
								
				

				throw new InstallException( string.Format( "Exception occured during database install: '{0}'", "InitializeSQLDMO" ) , e );	
				
			}
			finally
			{
				Leave();
			}
		}


		public override void Install( System.Collections.IDictionary state )
		{
			Enter();

			try
			{
				// System.Windows.Forms.MessageBox.Show( "UDDI Application Installer Stop", "UDDI.Debug" );

				InitializeSQLDMO();
				InitializeDataFiles();
				
				//
				// Set up the cleanup data
				//
				uninstDataFiles.Clear();
				uninstDataFiles.Add( SystemFileSpec );
				uninstDataFiles.Add( Core1FileSpec );
				uninstDataFiles.Add( Core2FileSpec );
				uninstDataFiles.Add( JournalFileSpec );
				uninstDataFiles.Add( StagingFileSpec );
				uninstDataFiles.Add( LogFileSpec );

				//
				// Proceed with the base installer routine
				//
				base.Install( state );

				//
				// First, are we on a cluster node ?
				//
				bool bActiveNode = false;
				bool bStandalone = true;
				string sClusterNodeType = Context.Parameters[ clustNodeTypeParam ];

				if ( sClusterNodeType == null || sClusterNodeType == "" )
				{
					bActiveNode = false;
					bStandalone = true;
				}
				else if ( String.Compare( sClusterNodeType, clustNodeActive, true ) == 0 ) 
				{
					bActiveNode = true;
					bStandalone = false;
				}
				else
				{
					bActiveNode = false;
					bStandalone = false;
				}

				//
				// On a "passive" node we do not do most of the CA operations
				//

				if ( bActiveNode || bStandalone )
				{
					bool bDatabaseFound = false;

					//
					// Do the custom action here. Start with cleaning the stage
					//
					if ( bStandalone )
						CleanupDataFiles();

					//
					// Now proceed with the installation itself
					//
					StartSQLService();
					ConnectToDatabase();
					CheckDatabaseConfiguration();

					//
					// If we are on an active cluster node, we should not attempt
					// to overwrite the database
					//
					if ( bActiveNode )
					{
						bDatabaseFound = FindUDDIDatabase();
					}

					if ( !bDatabaseFound )
					{
						WriteDatabase();
						LocateDatabase();

						//
						// Register our extended stored procedures.  Need to do this first since our scripts refer to these.
						//
						RegisterExtendedStoredProcedures();

						//
						// Run the scripts.
						//
						foreach( string scriptName in masterInstallScripts )
						{
							string script = GetResource( scriptName );

							Log( string.Format( "Executing {0} SQL script.", scriptName ) ) ;	
							
							masterdb.ExecuteImmediate( script, SQLDMO.SQLDMO_EXEC_TYPE.SQLDMOExec_Default, script.Length );
						}
					
						foreach( string scriptName in uddiScripts )
						{
							string script = GetResource( scriptName );
							
							Log( string.Format( "Executing {0} SQL script.", scriptName ) ) ;
			
							database.ExecuteImmediate( script, SQLDMO.SQLDMO_EXEC_TYPE.SQLDMOExec_Default, script.Length );
						}
					
						//
						// Configure the database
						//
						SQLDMO.DBOption2 dboption2 = ( SQLDMO.DBOption2 ) database.DBOption;
						dboption2.RecoveryModel = SQLDMO.SQLDMO_RECOVERY_TYPE.SQLDMORECOVERY_Simple;

						SetSSLRequired();

						ImportBootstrapData();
						GenerateCryptoKey();

						string szSiteDesc = Localization.GetString( "DBCA_UDDI_DESC_SITE" );
						AssignOperator( Context.Parameters[ busEntityParamName ] );
						CreateBusinessEntity( Context.Parameters[ busEntityParamName ], szSiteDesc  );
						// RegisterWithActiveDirectory();

						RecalculateStatistics();
						UpdateVersionFromRegistry();
						UpdateSiteLanguage( 0 );
					}
				} // active Node

				try
				{
					StartService( "RemoteRegistry", 30 );
				}
				catch ( Exception e )
				{
					LogException( string.Format( "Exception occured during database install: '{0}'", "RemoteRegistry Start" ) , e );
				}
			}
			catch( Exception e )
			{
				throw new InstallException( LogException( string.Format( "Exception occured during database install: '{0}'", "Installer.Install" ) , e ) );
			}
			finally
			{
				Leave();
			}
		}

		public override void Uninstall( System.Collections.IDictionary state )
		{
			Enter();
			// System.Windows.Forms.MessageBox.Show( "UDDI Application Installer Stop Uninstall", "UDDI.Debug" );

			try
			{
				try
				{
					string userName = WindowsIdentity.GetCurrent().Name;
					Log( "Execuring uninstall as " + userName );
				}
				catch (Exception)
				{
				}
				//
				// try to shut down the database
				//
				try
				{
					InitializeSQLDMO();					
					uninstDataFiles.Clear();

					base.Uninstall( state );

					//
					// First, are we on a cluster node ?
					//
					bool bActiveNode = false;
					string sClusterNodeType = Context.Parameters[ clustNodeTypeParam ];

					if ( sClusterNodeType == null || sClusterNodeType == "" )
						bActiveNode = true;  // we are not on a node, assume "active" mode
					else if ( String.Compare( sClusterNodeType, clustNodeActive, true ) == 0 ) 
						bActiveNode = true;
					else
						bActiveNode = false;


					if ( bActiveNode )
					{
						StartSQLService();
						ConnectToDatabase();
					}

					//
					// Attempt to remove the AD entry
					//
					try
					{
						RemoveADSiteEntry();
					}
					catch ( Exception )
					{
					}

					if ( bActiveNode )
					{
						LocateDatabase();

						//
						// Run the uninstall SQL scripts
						//					
						foreach( string scriptName in masterUninstallScripts )
						{
							string script = GetResource( scriptName );

							Log( string.Format( "Executing {0} SQL script.", scriptName ) ) ;	
							
							masterdb.ExecuteImmediate( script, SQLDMO.SQLDMO_EXEC_TYPE.SQLDMOExec_Default, script.Length );
						}

						CollectDatafilePaths();						
						TakeDatabaseOffline();
						DetachDatabase();

						CleanupDataFiles();
					}
				}
				catch
				{
					// do not throw exceptions on uninstall
				}

			}
			finally
			{
				Leave();
			}
		}

		public override void Rollback( System.Collections.IDictionary state )
		{
			Enter();
			base.Rollback( state );
			Uninstall( state );
			Leave();
		}

		protected void StartSQLService()
		{
			Enter();

			string instanceName = "";

			try
			{
				// get the instance name from the registry
				instanceName = ( string ) Registry.LocalMachine.OpenSubKey( @"SOFTWARE\Microsoft\UDDI" ).GetValue( "InstanceName" );
				server.Name = instanceName;

				Log( string.Format( "Attempting to start database {0}.", instanceName ) );
				

				server.Start( false, instanceName, null, null );
				
				WaitForSQLServiceStartup();
				                
				Log( string.Format( "Database server {0} successfully started.", instanceName ) );
			}
			catch( COMException e )
			{
				if( SQL_ALREADY_STARTED != e.ErrorCode )
				{
					string excepstr = string.Format( "Unable to start the UDDI database server {0}.", ((""!=instanceName)?instanceName:"(UNKNOWN)" ));
					
					throw new InstallException( LogException( excepstr , e ) );
				}
				else
				{
					Log( string.Format( "Database {0} already started.", instanceName ) );
				}
			}
			catch( Exception e )
			{
				string excepstr = string.Format( "Unable to start the UDDI database server {0}.", ((null!=instanceName)?instanceName:"(UNKNOWN)" ));
				
				throw new InstallException( LogException( excepstr , e ) );
			}
			finally
			{
				Leave();
			}
		}

		protected void WaitForSQLServiceStartup()
		{
			Enter();

			try
			{
				//
				// wait for a while for the serice to start
				//

				Log( "Waiting for SQL Service to start..." );

				for( int i=0; i<15; i++ )
				{
					try
					{
						if( server.Status == SQLDMO.SQLDMO_SVCSTATUS_TYPE.SQLDMOSvc_Running )
							break;
					}
					catch( Exception e )
					{
						Log( string.Format( "Error testing the DB server status: {0}", e.Message ) );
					}

					System.Threading.Thread.Sleep( 3000 );
				}

				if( server.Status != SQLDMO.SQLDMO_SVCSTATUS_TYPE.SQLDMOSvc_Running )
				{
					throw new InstallException( "Unable to start the SQL database." );
				}

				Log( "SQL Service Started!" );
			}
			finally
			{
				Leave();
			}
		}

		protected void ConnectToDatabase()
		{
			Enter();

			server.LoginSecure = true;
			string instanceName = null;
			try
			{
				server.LoginTimeout = ( int ) Registry.LocalMachine.OpenSubKey( @"SOFTWARE\Microsoft\UDDI\Database" ).GetValue( "Timeout", 90 );
				
				instanceName = ( string ) Registry.LocalMachine.OpenSubKey( @"SOFTWARE\Microsoft\UDDI" ).GetValue( "InstanceName" );
				
				Log( string.Format( "Attempting to connect to database server: {0}", instanceName ) );
				
				server.Connect( instanceName, null, null );
			}
			catch( Exception e )
			{
				string excepstr = string.Format( "Unable to connect to database server {0}.", ( (null!=instanceName)?instanceName:"(UNKNOWN)" ) );
				throw new InstallException( LogException(  excepstr, e ) );
			}
			finally
			{
				Leave();
			}
		}

		protected void CheckDatabaseConfiguration()
		{
			Enter();

			try
			{
				string errStr = "";

				if( !server.Issysadmin )
				{
					errStr = "The current user does not have administrative privileges.";
					LogError( errStr );
					throw new InstallException( errStr );
				}

				if( server.VersionMajor < 8 )
				{
					errStr = "Unsupported release of SQL Server.";
					throw new InstallException( LogError( errStr ) );
				}
			}
			finally
			{
				Leave();
			}
		}


		protected bool FindUDDIDatabase()
		{
			Enter();

			bool found = false;
			try
			{
				for( int k=1; k <= server.Databases.Count; k++ )
				{
					string tempName = server.Databases.Item( k, null ).Name;

					if( tempName.Equals( dbName ) )
					{
						found = true;
						break;
					}
				}
			}
			catch( Exception e )
			{
				LogException( "FindUDDIDatabase", e );
			}
			finally
			{
				Leave();
			}

			return found;
		}


		protected void LocateDatabase()
		{
			Enter();

			try
			{
				for( int k=1; k <= server.Databases.Count; k++ )
				{
					string tempName = server.Databases.Item( k, null ).Name;

					if( tempName.Equals( dbName ) )
					{
						database = ( SQLDMO.Database2 ) server.Databases.Item( k, null );
					}
					else if( tempName.Equals( "master" ) )
					{
						masterdb = ( SQLDMO.Database2 ) server.Databases.Item( k, null );
					}
				}
			
				if( null == ( object ) database )
				{
					string errstr = string.Format( "Couldn't find the database: {0}", dbName );
					throw new InstallException( LogError( errstr ) );
				}
				if( null == ( object ) masterdb )
				{
					string errstr = string.Format( "Couldn't find the database: {0}", "master" );
					throw new InstallException( LogError( errstr ) );
				}
			}
			finally
			{
				Leave();
			}
		}

		protected string CheckForSlash( string str )
		{
			if( !str.EndsWith( @"\" ) )
			{
				return ( str + @"\" );
			}

			return str;
		}

		protected void WriteDatabase()
		{
			Enter();

			try
			{
				//
				// Create directories, clean up old files if they exist
				//
				Log( "SystemFilePath=" + SystemFilePath );
				if( !Directory.Exists( SystemFilePath ) )
					Directory.CreateDirectory( SystemFilePath );
				
				Log( "Core1FilePath=" + Core1FilePath );
				if( !Directory.Exists( Core1FilePath ) )
					Directory.CreateDirectory( Core1FilePath );

				Log( "Core2FilePath=" + Core2FilePath );
				if( !Directory.Exists( Core2FilePath ) )
					Directory.CreateDirectory( Core2FilePath );

				Log( "JournalFilePath=" + JournalFilePath );
				if( !Directory.Exists( JournalFilePath ) )
					Directory.CreateDirectory( JournalFilePath );

				Log( "StagingFilePath=" + StagingFilePath );
				if( !Directory.Exists( StagingFilePath ) )
					Directory.CreateDirectory( StagingFilePath );

				Log( "LogFilePath=" + LogFilePath );
				if( !Directory.Exists( LogFilePath ) )
					Directory.CreateDirectory( LogFilePath );

				//
				// Create database
				//

				try
				{
					database = new SQLDMO.Database2Class();
					database.Name = dbName;

					//
					// Create the system file in the primary filegroup
					//
					Log( "System database file = " + SystemFileSpec );
					
					SQLDMO.DBFile dbFile = new SQLDMO.DBFileClass();
					dbFile.Name = "UDDI_SYS";
					dbFile.PhysicalName = SystemFileSpec;
					database.FileGroups.Item( "PRIMARY" ).DBFiles.Add( dbFile );

					//
					// Create the database log file
					//
					Log( "Setting UDDI log file = " + LogFileSpec );
					
					SQLDMO.LogFile logFile = new SQLDMO.LogFileClass();
					logFile.Name = "UDDI_LOG";
					logFile.PhysicalName = LogFileSpec;
					database.TransactionLog.LogFiles.Add( logFile );

					server.Databases.Add( database );

					LocateDatabase();

					//
					// Create the core filegroup
					//

					SQLDMO.FileGroup2 corefilegroup = new SQLDMO.FileGroup2Class();
					corefilegroup.Name = "UDDI_CORE";
					database.FileGroups.Add( corefilegroup );

					//
					// Create the Core 1 file
					//

					Log( "Core 1 database file = " + Core1FileSpec );
					
					SQLDMO.DBFile core1file = new SQLDMO.DBFileClass();
					core1file.Name = "UDDI_CORE_1";
					core1file.PhysicalName = Core1FileSpec;
					database.FileGroups.Item( "UDDI_CORE" ).DBFiles.Add( core1file );

					//
					// Create the Core 2 file
					//

					Log( "Core 2 database file = " + Core2FileSpec );
					
					SQLDMO.DBFile core2file = new SQLDMO.DBFileClass();
					core2file.Name = "UDDI_CORE_2";
					core2file.PhysicalName = Core2FileSpec;
					database.FileGroups.Item( "UDDI_CORE" ).DBFiles.Add( core2file );

					//
					// Create the journal filegroup
					//

					SQLDMO.FileGroup2 journalfilegroup = new SQLDMO.FileGroup2Class();
					journalfilegroup.Name = "UDDI_JOURNAL";
					database.FileGroups.Add( journalfilegroup );

					//
					// Create the journal file
					//

					Log( "Journal database file = " + JournalFileSpec );
					
					SQLDMO.DBFile journalfile = new SQLDMO.DBFileClass();
					journalfile.Name = "UDDI_JOURNAL_1";
					journalfile.PhysicalName = JournalFileSpec;
					database.FileGroups.Item( "UDDI_JOURNAL" ).DBFiles.Add( journalfile );

					//
					// Create the staging filegroup
					//

					SQLDMO.FileGroup2 stagingfilegroup = new SQLDMO.FileGroup2Class();
					stagingfilegroup.Name = "UDDI_STAGING";
					database.FileGroups.Add( stagingfilegroup );

					//
					// Create the staging file
					//

					Log( "Staging database file = " + StagingFileSpec );
					
					SQLDMO.DBFile stagingfile = new SQLDMO.DBFileClass();
					stagingfile.Name = "UDDI_STAGING_1";
					stagingfile.PhysicalName = StagingFileSpec;
					database.FileGroups.Item( "UDDI_STAGING" ).DBFiles.Add( stagingfile );
				}
				catch ( Exception e )
				{
					string errstr = string.Format( "Unable to add the database: {0}", database );
					throw new InstallException( LogException( errstr, e ) );
				}
			}
			finally
			{
				Leave();
			}
		}

		protected void TakeDatabaseOffline()
		{
			Enter();

			Debug.Assert( null != masterdb, "masterdb is null" );
			Debug.Assert( null != dbName, "dbName is null" );

			string commandBatch = "ALTER DATABASE " + dbName + " SET OFFLINE WITH ROLLBACK IMMEDIATE";

			try
			{
				masterdb.ExecuteImmediate( commandBatch, SQLDMO.SQLDMO_EXEC_TYPE.SQLDMOExec_Default, commandBatch.Length );
			}
			catch ( Exception e )
			{
				string errstr = string.Format( "Couldn't take the following database offline: {0}",dbName );
				throw new InstallException( LogException( errstr, e ) );
			}
			finally
			{
				Leave();
			}
		}

		protected void DetachDatabase()
		{
			Enter();

			Debug.Assert( null != server, "server is null" );
			Debug.Assert( null != dbName, "dbName is null" );

			try
			{
				string status = server.DetachDB( dbName, false );
				Log( "DetachDatabase() returned: " + status );	
			}
			catch ( Exception e )
			{
				string errstr = string.Format( "Couldn't detach the following database: {0}", dbName );
				throw new InstallException( LogException( errstr, e ) );
			}
			finally
			{
				Leave();
			}
		}


		protected void CleanupDataFiles()
		{
			Enter();

			foreach ( string fileName in uninstDataFiles )
			{
				try
				{
					CleanupDatabaseFile( fileName );
				}
				catch (Exception)
				{
				}
			}

			Leave();
		}


		protected void CleanupDatabaseFile( string filespec )
		{
			Enter();

			try
			{
				Log( "Cleaning up: " + filespec );

				MoveDatabaseFile( filespec );
				DeleteDatabaseFile( filespec );
			}
			catch
			{
				string errstr = string.Format( "These file must be renamed or moved: '{0}'", filespec );
				throw new InstallException( LogError( errstr ) );
			}
			finally
			{
				Leave();
			}

			return;
		}

		protected void MoveDatabaseFile( string filespec )
		{
			Enter();

			//
			// rename data file
			//
			try
			{
				string fname = filespec.Trim();

				if ( !File.Exists( fname ) )
				{
					Log( "File not found: " + fname );
					return;
				}

				Log( "Renaming..." );

				for ( int i = 0; i < 10000; i++ )
				{
					string fileRename = fname;

					if ( i < 10 )
						fileRename += ".0" + i.ToString();
					else 
						fileRename += "."  + i.ToString();

					if( !File.Exists( fileRename ) )
					{
						File.Copy( fname, fileRename, /* overwrite= */ true );
						break;
					}
				}
			}
			catch( Exception e )
			{
				string errstr = string.Format( "Error renaming data file: '{0}'",filespec );
				throw new InstallException( LogException( errstr, e ) );
			}
			finally
			{
				Leave();
			}
		}

		protected void DeleteDatabaseFile( string filespec )
		{
			Enter();

			try
			{
				string fname = filespec.Trim();

				//
				// delete data file
				//
				if( File.Exists( fname ) )
				{
					Log( "Deleting..." );
					File.Delete( fname );
				}
		
			}
			catch( Exception e )
			{
				throw new InstallException( LogException( "Error deleting database files.", e ) );
			}
			finally
			{
				Leave();
			}
		}

		protected void SetSSLRequired()
		{
			Enter();

			string connectionString = "";

			try
			{
				//
				// The SSL setting (0 or 1) is passed to this custom action on the command line
				//
				string sslrequired = Context.Parameters[ "SSL" ];

				//
				// get the connection string and connect to the db
				//
				connectionString = ( string ) Registry.LocalMachine.OpenSubKey( @"SOFTWARE\Microsoft\UDDI\Database" ).GetValue( "WriterConnectionString" );
				SqlConnection conn = new SqlConnection( connectionString );
				SqlCommand cmd = new SqlCommand( "net_config_save", conn );
			
				conn.Open();
					
				try	
				{
					cmd.CommandType = CommandType.StoredProcedure;
					cmd.Parameters.Add( new SqlParameter( "@configName", SqlDbType.NVarChar, UDDI.Constants.Lengths.ConfigName ) ).Direction = ParameterDirection.Input;
					cmd.Parameters.Add( new SqlParameter( "@configValue", SqlDbType.NVarChar, UDDI.Constants.Lengths.ConfigValue ) ).Direction = ParameterDirection.Input;

					cmd.Parameters[ "@configName" ].Value = "Security.HTTPS";
					cmd.Parameters[ "@configValue" ].Value = sslrequired;
					cmd.ExecuteNonQuery();
				}
				finally
				{
					conn.Close();
				}
			}
			catch( Exception e )
			{
				string logstr = string.Format( "Exception occured during database install: '{0}'", "SetSSLRequired()", connectionString );
				Log( logstr );
				Log( string.Format( "SQL Server raised an exception in {0}. Connection string used: '{1}'", "SetSSLRequired()", connectionString ) );
				
				string errstr = string.Format( "Error setting value for: {0}", "Security.HTTPS" );
				throw new InstallException( LogException( errstr, e ) );
			}
			finally
			{
				Leave();
			}
		}


		public void SetStartType( string svcName, ServiceStartMode startType )
		{
			Enter();

			try
			{
				//
				// open the registry entry for the service
				//
				RegistryKey	HKLM = Registry.LocalMachine;
				RegistryKey svcKey = HKLM.OpenSubKey( "SYSTEM\\CurrentControlSet\\Services\\" + svcName, true );

				//
				// now set the start type
				//
				switch( startType )
				{
					case ServiceStartMode.Automatic:
						svcKey.SetValue ( "Start", 2 );
						break;

					case ServiceStartMode.Manual:
						svcKey.SetValue ( "Start", 3 );
						break;

					case ServiceStartMode.Disabled:
						svcKey.SetValue ( "Start", 4 );
						break;
				}

				svcKey.Close();
				HKLM.Close();
			}
			catch( Exception e )
			{
				throw new InstallException( LogException( string.Format( "Error setting value for: {0}", svcName ), e ) );
			}
			finally 
			{
				Leave();
			}
		}


		public void StartService ( string svcName, int timeoutSec )
		{
			Enter();
			
			try
			{
				ServiceController		controller;
				ServiceControllerStatus srvStatus;
				TimeSpan				timeout = new TimeSpan ( 0, 0, timeoutSec );  

				//
				// first, connect to the SCM on the local box
				// and attach to the service, then get its status
				//
				controller = new ServiceController ( svcName );
				srvStatus = controller.Status;
				
				//
				// what is the service state?
				//
				switch ( srvStatus)
				{
						//
						// stopped ?
						//
					case ServiceControllerStatus.Stopped:
						controller.Start();
						break;

						//
						// are we trying to start?
						//
					case ServiceControllerStatus.StartPending:
					case ServiceControllerStatus.ContinuePending:
						break;

						//
						// are we trying to stop?
						//
					case ServiceControllerStatus.StopPending:
						controller.WaitForStatus( ServiceControllerStatus.Stopped, timeout );
						controller.Start();
						break;

						//
						// pausing ?
						//
					case ServiceControllerStatus.PausePending:
						controller.WaitForStatus ( ServiceControllerStatus.Paused, timeout );
						controller.Continue();
						break;
					
					default: // the service is already running. Just leave it alone
						break;
				}

				//
				// wait 'till the service wakes up
				//
				controller.WaitForStatus ( ServiceControllerStatus.Running, timeout );
			}
			catch( Exception e )
			{
				throw new InstallException( LogException( string.Format( "Unable to start the service: {0}", svcName ), e ) );
			}
			finally
			{
				Leave();
			}
		}


		public void RegisterWithActiveDirectory()
		{
			try
			{
			}
			catch( Exception e )
			{
				LogException( "RegisterWithActiveDirectory", e );
				throw e;
			}
		}

		public void ImportBootstrapData()
		{
			Enter();

			try
			{
				//
				// load all the bootstrap files found in the \uddi\bootstrap folder
				//
				string targetDir = Registry.LocalMachine.OpenSubKey( @"SOFTWARE\Microsoft\UDDI" ).GetValue( "InstallRoot" ).ToString();
				string bootstrapdir = CheckForSlash(targetDir) + "bootstrap";
				string bootstrapexe = CheckForSlash(targetDir) + @"bin\bootstrap.exe";

				Log( "Getting list of bootstrap files from directory '" + bootstrapdir + "'" );

				//
				// 751411 - Explicitly sort the files we receive in alphabetical order.
				//				
				BootStrapFileOrder fileOrder = new BootStrapFileOrder();
				string[] filepaths = Directory.GetFiles( bootstrapdir, "*.xml" );

				//
				// Log if we could not obtain an expected order.  We can continue since BootStrapFileOrder
				// will use a default order.
				//
				if( false == fileOrder.UsingExpectedOrder )
				{
					Log( "Warning, bootstrap files were not sorted with the expected culture information (en-US).  This may cause incomplete data to be stored in the UDDI Services database, or cause the installation to fail." );
				}
				Array.Sort( filepaths, fileOrder );
				
				Log( "Writing " + filepaths.Length + " baseline resources to database." );
			
				foreach( string filepath in filepaths )
				{
					Log( "Importing bootstrap data from: " + filepath );

					ProcessStartInfo startInfo = new ProcessStartInfo( bootstrapexe, "/f \""+ filepath + "\"");

					startInfo.CreateNoWindow = true;
					startInfo.UseShellExecute = false;
					startInfo.RedirectStandardOutput = true;

					Process p = new Process();
					p = Process.Start( startInfo );

					//
					// grab the stdout string
					//
					string bootstrapOutput = p.StandardOutput.ReadToEnd();

					//
					// wait for bootstrap.exe to complete
					//
					p.WaitForExit();

					//
					// write the stdout string to the log
					//
					Log( bootstrapOutput );

					if( p.ExitCode != 0 )
					{
						LogError( "ImportBootstrapData failed!" );
					}
				}
			}
			catch( Exception e )
			{
				throw new InstallException( LogException( "Error importing the Bootstrap data.", e ) );
			}
			finally
			{
				Leave();
			}
		}
		
		protected void GenerateCryptoKey()
		{
			Enter();

			try
			{
				Log( "Generating cryptography key" );

				//
				// get the path to the exe we run
				//
				string targetDir = Registry.LocalMachine.OpenSubKey( @"SOFTWARE\Microsoft\UDDI" ).GetValue( "InstallRoot" ).ToString();
				string resetkeypath = targetDir + resetkeyfile;

				//
				// make sure that the resetkey.exe was installed ok
				//
				if( !File.Exists( resetkeypath ) )
				{
					throw new InstallException( LogError( string.Format( "Unable to find the following file: '{0}'", resetkeypath ) ) );
				}

				ProcessStartInfo startInfo = new ProcessStartInfo( resetkeypath );

				startInfo.Arguments = "/now";
				startInfo.CreateNoWindow = true;
				startInfo.UseShellExecute = false;
				startInfo.RedirectStandardOutput = true;

				Process p = new Process();
				p = Process.Start( startInfo );

				//
				// grab the stdout string
				//
				string output = p.StandardOutput.ReadToEnd();

				//
				// wait for exe to complete
				//
				p.WaitForExit();

				//
				// write the stdout string to the log
				//
				// don't put this data into the log!
				// Log( output );

				if( p.ExitCode != 0 )
				{
					throw new InstallException( LogError( string.Format( "Exception occured during database install: '{0}'", "resetkey.exe" ) ) );
				}
			}
			catch( Exception e )
			{
				throw new InstallException( LogException( "Unable to generate a crypto key.", e) );
			}
			finally
			{
				Leave();
			}
		}

		protected void RecalculateStatistics ()
		{
			Enter();

			string connectionString = "";

			try
			{
				// System.Windows.Forms.MessageBox.Show( "RecalculateStatistics" );

				//
				// get the connection string and connect to the db
				//
				connectionString = ( string ) Registry.LocalMachine.OpenSubKey( @"SOFTWARE\Microsoft\UDDI\Database" ).GetValue( "WriterConnectionString" );
				SqlConnection conn = new SqlConnection( connectionString );
				SqlCommand cmd = new SqlCommand( "net_statistics_recalculate", conn );
				cmd.CommandType = CommandType.StoredProcedure;

				conn.Open();
					
				try	
				{
					cmd.ExecuteNonQuery();
				}
				finally
				{
					conn.Close();
				}
			}
			catch( Exception e )
			{
				Log( string.Format( "SQL Server raised an exception in {0}. Connection string used: '{1}'", "RecalculateStatistics()", connectionString ) );
				throw new InstallException( LogException( "Unable to recalculate statistics.", e ) );
			}
			finally
			{
				Leave();
			}
		}


		protected void AssignOperator( string name )
		{
			Enter();

			try
			{
				// 
				// set up the connection and other environment settings
				//
				ConnectionManager.Open( true, true );
				UDDI.Context.User.SetRole( new WindowsPrincipal( WindowsIdentity.GetCurrent() ) );
				UDDI.Context.User.ID = UDDI.Utility.GetDefaultPublisher();

				UDDI.Config.SetString( defaultOperatorkey, name ); 
				
				ConnectionManager.Commit();
			}
			catch ( Exception e )
			{
				ConnectionManager.Abort();
				LogException( "AssignOperator", e );
				Log( string.Format( "Unable to change the Operator Name to '{0}'. Reason: {1}", name, e.Message ) );
				throw e;
			}
			finally
			{
				ConnectionManager.Close();
				Leave();
			}

		}


		protected void CreateBusinessEntity( string name, string description )
		{
			Enter();

			try
			{
				// 
				// set up the connection and other environment settings
				//
				ConnectionManager.Open( true, true );
				UDDI.Context.User.SetRole( new WindowsPrincipal( WindowsIdentity.GetCurrent() ) );
				UDDI.Context.User.ID = UDDI.Utility.GetDefaultPublisher();
				
				// 
				// set up the new entity attributes
				//
				BusinessEntity busEntity = new BusinessEntity();
				busEntity.Names.Add( name );
				busEntity.Descriptions.Add( description );
				busEntity.AuthorizedName = UDDI.Context.User.ID;
				busEntity.Operator = "";	// let it be default

				// now add the uddi-org:operators keyed reference
				busEntity.IdentifierBag.Add( "", tokenOBEKeyValue, tmodelUddiOrgOpers );

				//
				// Persist the business entity
				//
				busEntity.Save();

				//
				// now store the key value for future use
				//
				string key = busEntity.EntityKey;
				UDDI.Config.SetString( busEntityKeyName, key );

				ConnectionManager.Commit();
			}
			catch ( Exception e )
			{
				ConnectionManager.Abort();
				LogException( "CreateBusinessEntity", e );
				Log( string.Format( "Unable to create a new Business Entity '{0}'. Reason: {1}", name, e.Message ) );
				throw e;
			}
			finally
			{
				ConnectionManager.Close();
				Leave();
			}
		}


		//
		// Sets the Site.Language key to the ISO standard language code
		// corresponding to the localeID
		// If localeID = 0, then the system default language will be used
		//
		protected void UpdateSiteLanguage( int localeID )
		{
			Enter();

			try
			{
				// 
				// set up the connection and other environment settings
				//
				ConnectionManager.Open( true, true );
				UDDI.Context.User.SetRole( new WindowsPrincipal( WindowsIdentity.GetCurrent() ) );
				UDDI.Context.User.ID = UDDI.Utility.GetDefaultPublisher();

				CultureInfo culture;
				if ( localeID == 0 )
					culture = CultureInfo.CurrentCulture;
				else
					culture = new CultureInfo( localeID );

				string languageCode = culture.TwoLetterISOLanguageName;
				UDDI.Config.SetString( siteLangKeyName, languageCode );

				ConnectionManager.Commit();
			}
			catch ( Exception e )
			{
				ConnectionManager.Abort();
				LogException( "UpdateSiteLanguage", e );
			}
			finally
			{
				ConnectionManager.Close();
				Leave();
			}
		}


		protected void UpdateVersionFromRegistry()
		{
			Enter();

			try
			{
				// 
				// set up the connection and other environment settings
				//
				ConnectionManager.Open( true, true );
				UDDI.Context.User.SetRole( new WindowsPrincipal( WindowsIdentity.GetCurrent() ) );
				UDDI.Context.User.ID = UDDI.Utility.GetDefaultPublisher();
		
				string version = ( string ) Registry.LocalMachine.OpenSubKey( regDBServerKeyName ).GetValue( regVersionKeyName );
				UDDI.Config.SetString( siteVerKeyName, version );

				ConnectionManager.Commit();
			}
			catch ( Exception e )
			{
				ConnectionManager.Abort();
				LogException( "UpdateVersionFromRegistry", e );
			}
			finally
			{
				ConnectionManager.Close();
				Leave();
			}
		}


		protected string GetResource( string name )
		{
			string fullname = "";
			try
			{
				//
				// Prefix the resource name with the assembly name
				//
				Assembly assembly = Assembly.GetExecutingAssembly();
				//fullname = assembly.GetName().Name + "." + name;
				fullname = name;

				//
				// Read the resource.
				//
				Log( "Reading resource: " + fullname );
				Stream stream = assembly.GetManifestResourceStream( fullname );
				StreamReader reader = new StreamReader( stream );

				return reader.ReadToEnd();
			}
			catch ( Exception e )
			{
				throw new InstallException( LogException( string.Format( "Unable to get resource for: {0}", fullname ), e ) );
			}
		}

		public void Enter() 
		{
			System.Diagnostics.StackTrace trace = new System.Diagnostics.StackTrace( 1, false );
			System.Reflection.MethodBase method = trace.GetFrame( 0 ).GetMethod();

			Log( "Entering " + method.ReflectedType.FullName + "." + method.Name + "..." );
		}

		public void Leave()
		{
			System.Diagnostics.StackTrace trace = new System.Diagnostics.StackTrace( 1, false );
			System.Reflection.MethodBase method = trace.GetFrame( 0 ).GetMethod();

			Log( "Leaving " + method.ReflectedType.FullName + "." + method.Name );
		}


		private string LogError( string errmsg )
		{
			System.Diagnostics.StackTrace trace = new System.Diagnostics.StackTrace( 1, false );
			System.Reflection.MethodBase method = trace.GetFrame( 0 ).GetMethod();

			Log( "----------------------------------------------------------" );
			Log( "An error occurred during installation. Details follow:" );
			Log( "Method: " + method.ReflectedType.FullName + "." + method.Name );
			Log( "Message: " + errmsg );
			Log( "----------------------------------------------------------" );

			return errmsg;
		}

		private string LogException( string context, Exception e )
		{
			System.Diagnostics.StackTrace trace = new System.Diagnostics.StackTrace( 1, false );
			System.Reflection.MethodBase method = trace.GetFrame( 0 ).GetMethod();

			Log( "----------------------------------------------------------" );
			Log( "An exception occurred during installation. Details follow:" );
			Log( "Method: " + method.ReflectedType.FullName + "." + method.Name );
			Log( "Context: " + context );
			Log( "Stack Trace: " + e.StackTrace );
			Log( "Source: " + e.Source );
			Log( "Message: " + e.Message );
			Log( "----------------------------------------------------------" );

			return context + ": " + e.Message;
		}

		private void Log( string str )
		{
			try
			{
				Debug.WriteLine( str );

				FileStream f = new FileStream( System.Environment.ExpandEnvironmentVariables( "%systemroot%" ) + @"\uddisetup.log", FileMode.Append, FileAccess.Write );
				StreamWriter s = new StreamWriter( f, System.Text.Encoding.Unicode );
				s.WriteLine( "{0}: {1}", DateTime.Now.ToString(), str );
				s.Close();
				f.Close();
			}
			catch( Exception e )
			{
				Debug.WriteLine( "Error in Log():" + e.Message );
			}
		}


		private void InitializeDataFiles()
		{
			//
			// Initialize default data directory
			//
			string installroot = ( string ) Registry.LocalMachine.OpenSubKey( @"SOFTWARE\Microsoft\UDDI" ).GetValue( "InstallRoot" );
			Log( "InstallRoot=" + installroot );

			string defaultdatapath = CheckForSlash( installroot ) + dataFolderName;	//dir local to db server for data files
			Log( "DefaultDataPath=" + defaultdatapath );

			//
			// Get paths from properties passed from OCM dll, or set to default
			//

			SystemFilePath = Context.Parameters[ propSysFilePath ];
			if ( null == SystemFilePath ) 
				SystemFilePath = defaultdatapath;
			SystemFileSpec = CheckForSlash( SystemFilePath ) + dbName + ".sys.mdf";

			Core1FilePath = Context.Parameters[ propCoreFilePath_1 ];
			if ( null == Core1FilePath ) 
				Core1FilePath = defaultdatapath;
			Core1FileSpec = CheckForSlash( Core1FilePath ) + dbName + ".data.1.ndf";

			Core2FilePath = Context.Parameters[ propCoreFilePath_1 ];
			if ( null == Core2FilePath ) 
				Core2FilePath = defaultdatapath;
			Core2FileSpec = CheckForSlash( Core2FilePath ) + dbName + ".data.2.ndf";

			JournalFilePath = Context.Parameters[ propJournalFilePath ];
			if ( null == JournalFilePath ) 
				JournalFilePath = defaultdatapath;
			JournalFileSpec = CheckForSlash( JournalFilePath ) + dbName + ".journal.1.ndf";

			StagingFilePath = Context.Parameters[ propStagingFilePath ];
			if ( null == StagingFilePath ) 
				StagingFilePath = defaultdatapath;
			StagingFileSpec = CheckForSlash( StagingFilePath ) + dbName + ".staging.1.ndf";

			LogFilePath = Context.Parameters[ propXactLogFilePath ];
			if ( null == LogFilePath ) 
				LogFilePath = defaultdatapath;
			LogFileSpec = CheckForSlash( LogFilePath ) + dbName + ".log.ldf";
			
			return;
		}

	
		private void CollectDatafilePaths()
		{
			Enter();

			try
			{
				if ( database == null ) // we probably failed to locate the database
					return;

				//
				// first get the log
				//
				foreach ( SQLDMO._LogFile log in database.TransactionLog.LogFiles )
				{
					uninstDataFiles.Add( log.PhysicalName );
				}

				//
				// now take care of the data files
				//
				foreach ( SQLDMO._FileGroup fgrp in database.FileGroups )
				{
					foreach ( SQLDMO.DBFile dbfile in fgrp.DBFiles )
					{
						uninstDataFiles.Add( dbfile.PhysicalName );
					}
				}
			}
			catch (Exception e)
			{
				LogException( "CollectDatafilePaths()", e );
			}
			finally
			{
				Leave();
			}
		}


		//
		// Drops the Active Directory site entry. The site comes from the
		// Config table
		//
		protected void RemoveADSiteEntry()
		{
			Enter();

			try
			{
				// 
				// set up the connection and other environment settings
				//
				ConnectionManager.Open( false, false );
				UDDI.Context.User.SetRole( new WindowsPrincipal( WindowsIdentity.GetCurrent() ) );
				UDDI.Context.User.ID = UDDI.Utility.GetDefaultPublisher();

				//
				// Try loading the site key
				//
				string defSiteKey = UDDI.Config.GetString( busEntityKeyName, "*" );
				if ( defSiteKey.Equals( "*" ) )
					Log( "Unable to get a site key" );
				else
				{
					UDDIServiceConnPoint.DeleteSiteEntry( defSiteKey );
				}
			}
			catch ( Exception e )
			{
				LogException( "RemoveADSiteEntry", e );
			}
			finally
			{
				ConnectionManager.Close();
				Leave();
			}

		}

		//
		// Registering the extended stored procedure is a bit tricky because you need the absolute path to the DLL.
		//
		private void RegisterExtendedStoredProcedures()
		{			
			//
			// Build path to where the uddi.xp.dll file is going to be.
			//
			string targetDir = Registry.LocalMachine.OpenSubKey( @"SOFTWARE\Microsoft\UDDI" ).GetValue( "InstallRoot" ).ToString();
			string fullPath  = CheckForSlash( targetDir ) + uddiXPFile;

			//
			// Create the script that we need to register the extended stored proc.
			//
			string sqlScript = string.Format( RegisterXpSqlFormat, fullPath );

			//
			// Run this as a script using the master database DMO
			//
			masterdb.ExecuteImmediate( sqlScript, SQLDMO.SQLDMO_EXEC_TYPE.SQLDMOExec_Default, sqlScript.Length );
		}
	}

	//
	// 751411 - Explicitly sort the files we receive in alphabetical order.
	//
	internal class BootStrapFileOrder : IComparer
	{
		private CultureInfo usCultureInfo;

		public BootStrapFileOrder()
		{
			//
			// Try to create a US English culture info.  This should always work no matter
			// what the locale of the system, but do a catch just in case.
			//
			try
			{		
				usCultureInfo = CultureInfo.CreateSpecificCulture( "en-US" );
			}
			catch
			{		
				usCultureInfo = null;
			}
		}
	
		public bool UsingExpectedOrder
		{
			get
			{
				return null != usCultureInfo;
			}
		}

		public int Compare( object x, object y )
		{
			//
			// Use the US English culture info if we have one, otherwise 
			// take our chances with the system one.  Always ignore the case
			// of the file.
			//
			if( null != usCultureInfo )
			{
				return String.Compare( x as string , y as string, true, usCultureInfo );
			}
			else
			{						
				return String.Compare( x as string , y as string, true );
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\setup\ocm\objectpicker.h ===
//--------------------------------------------------------------------------

#pragma once

//
// These are the supported types
//
#define OP_USER		0
#define OP_COMPUTER	1
#define OP_GROUP	2

bool ObjectPicker( HWND hwndParent, UINT uObjectType, PTCHAR szObjectName, ULONG uBufSize );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\setup\ocm\strlist.cpp ===
#include "..\..\shared\strlist.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\setup\ocm\ocmcallback.h ===
//-----------------------------------------------------------------------------------------
//
// Singleton class that encapsulates the OCM callbacks
//

#pragma once

#include <windows.h>
#include <windef.h>
#include <tchar.h>
#include <setupapi.h>
#include "ocmanage.h"

class COCMCallback
{
public:
	static void SetOCMRoutines( POCMANAGER_ROUTINES pOCMRoutines );
	static void SetProgressText( LPCTSTR szText );
	static void AdvanceTickGauge();
	static void SetReboot();
	static DWORD QuerySelectionState( LPCTSTR szSubcomponentName, bool &bSelected );

private:
	static OCMANAGER_ROUTINES m_OCMRoutines;
	static bool m_bInitialized;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\setup\ocm\ocmcallback.cpp ===
//-----------------------------------------------------------------------------------------

#include "assert.h"
#include "ocmcallback.h"

OCMANAGER_ROUTINES COCMCallback::m_OCMRoutines;
bool COCMCallback::m_bInitialized = false;

//-----------------------------------------------------------------------------------------
// capture the struct of OCM callback funtion pointers

void COCMCallback::SetOCMRoutines( POCMANAGER_ROUTINES pOCMRoutines )
{
	m_OCMRoutines = *pOCMRoutines;
	m_bInitialized = true;
}

//-----------------------------------------------------------------------------------------
// set the text on the OCM progress dialog

void COCMCallback::SetProgressText( LPCTSTR szText )
{
	if( m_bInitialized )
		m_OCMRoutines.SetProgressText( m_OCMRoutines.OcManagerContext, szText );
}

//-----------------------------------------------------------------------------------------
// advances the OCM progress bar by 1 tick count

void COCMCallback::AdvanceTickGauge()
{
	if( m_bInitialized )
		m_OCMRoutines.TickGauge( m_OCMRoutines.OcManagerContext );
}

//-----------------------------------------------------------------------------------------
// tells the OCM that a reboot is needed

void COCMCallback::SetReboot()
{
	if( m_bInitialized )
		m_OCMRoutines.SetReboot( m_OCMRoutines.OcManagerContext, NULL );
}

//-----------------------------------------------------------------------------------------
// ask the OCM for the current selection state of the component

DWORD COCMCallback::QuerySelectionState( LPCTSTR szSubcomponentName, bool &bSelected )
{
	if( !m_bInitialized )
	{
		assert( false );
		return false;
	}

	BOOL bRet = m_OCMRoutines.QuerySelectionState(
		m_OCMRoutines.OcManagerContext,
		szSubcomponentName,
		OCSELSTATETYPE_CURRENT );

	if( bRet )
	{
		bSelected = true;
		return ERROR_SUCCESS;
	}
	else
	{
		bSelected = false;
		return GetLastError();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\setup\ocm\objectpicker.cpp ===
//--------------------------------------------------------------------------

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0510
#endif

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
#endif

#define SECURITY_WIN32
#include <windows.h>
#include <tchar.h>
#include <assert.h>
#include <objbase.h>
#include <objsel.h>
#include <Security.h>
#include <Secext.h>

#include "objectpicker.h"

#define OP_GENERIC_EXCEPTION ( ( DWORD ) 1 )

//--------------------------------------------------------------------------

extern HINSTANCE g_hInstance;

UINT g_cfDsObjectPicker = RegisterClipboardFormat( CFSTR_DSOP_DS_SELECTION_LIST );

static HRESULT InitObjectPicker( UINT uObjectType, IDsObjectPicker *pDsObjectPicker );

static HRESULT InitObjectPickerForComputers( IDsObjectPicker *pDsObjectPicker );

static HRESULT InitObjectPickerForGroups( IDsObjectPicker *pDsObjectPicker,
										  BOOL fMultiselect,
										  BOOL fWantSidPath );

static HRESULT InitObjectPickerForUsers( IDsObjectPicker *pDsObjectPicker,
										 BOOL fMultiselect );

static bool ProcessSelectedObjects( IDataObject *pdo, PTCHAR szObjectName, ULONG uBufSize );

//--------------------------------------------------------------------------
// returns true if no errors, false otherwise
// use GetLastError() to get error code
//
bool ObjectPicker( HWND hwndParent, UINT uObjectType, PTCHAR szObjectName, ULONG uBufSize )
{
	IDsObjectPicker *pDsObjectPicker = NULL;
	IDataObject *pdo = NULL;
	bool bRet = true; // assume no errors

	try
	{
		HRESULT hr = CoInitializeEx( NULL, COINIT_APARTMENTTHREADED );
		if( FAILED( hr ) )
			throw HRESULT_CODE( hr );

		//
		// Create an instance of the object picker.
		//
		hr = CoCreateInstance( 
			CLSID_DsObjectPicker,
			NULL,
			CLSCTX_INPROC_SERVER,
			IID_IDsObjectPicker,
			( void ** ) &pDsObjectPicker );

		if( FAILED( hr ) )
			throw HRESULT_CODE( hr );

		//
		// Initialize the object picker instance.
		//
		hr = InitObjectPicker( uObjectType, pDsObjectPicker );
		if( FAILED( hr ) )
			throw HRESULT_CODE( hr );

		//
		// Invoke the modal dialog.
		//
		hr = pDsObjectPicker->InvokeDialog( hwndParent, &pdo );
		if( S_OK == hr )
		{
			if( !ProcessSelectedObjects( pdo, szObjectName, uBufSize ))
				throw GetLastError();
		}
		else if( S_FALSE == hr ) // user pressed cancel
		{
			throw OP_GENERIC_EXCEPTION;
		}
		else
		{
			throw HRESULT_CODE( hr );
		}
	}
	catch( HRESULT hrErr )
	{
		SetLastError( hrErr );
		bRet = false;
	}
	catch( DWORD dwErr )
	{
		SetLastError( dwErr );
		bRet = false;
	}

	if( pdo )
		pdo->Release();

	if( pDsObjectPicker )
		pDsObjectPicker->Release();

	CoUninitialize();

	return bRet;
}

//--------------------------------------------------------------------------

static HRESULT InitObjectPicker( UINT uObjectType, IDsObjectPicker *pDsObjectPicker )
{
	if( NULL == pDsObjectPicker )
	{
		return E_INVALIDARG;
	}

	HRESULT hr = E_FAIL;

	if( OP_COMPUTER == uObjectType )
	{
		hr = InitObjectPickerForComputers( pDsObjectPicker );
	}
	else if( OP_USER == uObjectType )
	{
		hr = InitObjectPickerForUsers( pDsObjectPicker, FALSE );
	}
	else if( OP_GROUP == uObjectType )
	{
		hr = InitObjectPickerForGroups( pDsObjectPicker, FALSE, TRUE );
	}

	return hr;
}

//--------------------------------------------------------------------------

static bool ProcessSelectedObjects( IDataObject *pdo, PTCHAR szObjectName, ULONG uBufSize )
{
	PDS_SELECTION_LIST pDsSelList = NULL;
	bool dwRet = true; // assume ok

	STGMEDIUM stgmedium =
	{
		TYMED_HGLOBAL,
		NULL,
		NULL
	};

	FORMATETC formatetc =
	{
		( CLIPFORMAT ) g_cfDsObjectPicker,
		NULL,
		DVASPECT_CONTENT,
		-1,
		TYMED_HGLOBAL
	};

	try
	{
		//
		// Get the global memory block containing a user's selections.
		//
		HRESULT hr = pdo->GetData( &formatetc, &stgmedium );
		if( FAILED( hr ) )
			throw HRESULT_CODE( hr );

		//
		// Retrieve pointer to DS_SELECTION_LIST structure.
		//
		pDsSelList = ( PDS_SELECTION_LIST ) GlobalLock( stgmedium.hGlobal );
		if( !pDsSelList )
		{
			throw GetLastError();
		}

		//
		// assume there is only 1 item returned because
		// we have multi-select turned off
		//
		if( pDsSelList->cItems != 1 )
		{
			assert( false );
			throw OP_GENERIC_EXCEPTION;
		}

		UINT i = 0;

		//_tprintf( TEXT( "Object '%u'\n" ), i );
		//_tprintf( TEXT( "  Name '%ws'\n" ),  pDsSelList->aDsSelection[i].pwzName );
		//_tprintf( TEXT( "  Class '%ws'\n" ), pDsSelList->aDsSelection[i].pwzClass );
		//_tprintf( TEXT( "  Path '%ws'\n" ),  pDsSelList->aDsSelection[i].pwzADsPath );
		//_tprintf( TEXT( "  UPN '%ws'\n" ),   pDsSelList->aDsSelection[i].pwzUPN );

		//
		// did we request a computer name? If so, we get it directly in the pwzName field
		//
		if( 0 == _tcsicmp( pDsSelList->aDsSelection[i].pwzClass, TEXT( "computer" )) )
		{
			assert( uBufSize > _tcslen( pDsSelList->aDsSelection[i].pwzName ) );
			_tcsncpy( szObjectName, pDsSelList->aDsSelection[i].pwzName, uBufSize - 1 );
			szObjectName[ uBufSize - 1 ] = NULL;
		}
		//
		// user name or group takes some post-processsing...
		//
		else if( 0 == _tcsicmp( pDsSelList->aDsSelection[i].pwzClass, TEXT( "user" ) ) ||
			     0 == _tcsicmp( pDsSelList->aDsSelection[i].pwzClass, TEXT( "group" ) ) )
		{
			//
			// user names from the domain begin with "LDAP:"
			// strip off the prefix info, up to the first "cn="
			// then use the TranslateName API to get the form "domain\user" or "domain\group"
			//
			if( 0 == _tcsnicmp( pDsSelList->aDsSelection[i].pwzADsPath, TEXT( "LDAP:" ), 5 ) )
			{
				PTCHAR p = _tcsstr( pDsSelList->aDsSelection[i].pwzADsPath, TEXT( "CN=" ) );
				if( NULL == p )
					p = _tcsstr( pDsSelList->aDsSelection[i].pwzADsPath, TEXT( "cn=" ) );

				if( NULL == p )
				{
					assert( false );
					throw OP_GENERIC_EXCEPTION;
				}

				if( !TranslateName( p, NameFullyQualifiedDN, NameSamCompatible, szObjectName, &uBufSize ) )
					throw GetLastError();
			}
			//
			// otherwise, names on the local box begin with "winnt:"
			// and we are only interested in the last two sections of the string,
			// delimited by "/"
			//
			else if( 0 == _tcsnicmp( pDsSelList->aDsSelection[i].pwzADsPath, TEXT( "WINNT:" ), 6 ) )
			{
				PTCHAR p = pDsSelList->aDsSelection[i].pwzADsPath;
				PTCHAR pend = p + _tcslen( p );
				UINT uCount = 0;
				while( pend > p )
				{
					if( '/' == *pend )
					{
						*pend = '\\';
						uCount++;

						if( uCount == 2 )
						{
							p = pend + 1;
							break;
						}
					}
					pend--;
				}

				//
				// if this fails, assert during debug but do not stop
				//
				if( p == pend )
					assert( false );

				assert( uBufSize > _tcslen( p ) );
				_tcsncpy( szObjectName, p, uBufSize - 1 );
				szObjectName[ uBufSize - 1 ] = NULL;
			}
			else
			{
				assert( false );
				throw OP_GENERIC_EXCEPTION;
			}
		}
		else
		{
			assert( false );
			throw OP_GENERIC_EXCEPTION;
		}
	}

	catch( DWORD dwErr )
	{
		SetLastError( dwErr );
		dwRet = false;
	}

	if( pDsSelList )
		GlobalUnlock( stgmedium.hGlobal );

	ReleaseStgMedium( &stgmedium );

	return dwRet;
}

//+--------------------------------------------------------------------------
//
//  Function:   InitObjectPickerForGroups
//
//  Synopsis:   Call IDsObjectPicker::Initialize with arguments that will
//              set it to allow the user to pick one or more groups.
//
//  Arguments:  [pDsObjectPicker] - object picker interface instance
//
//  Returns:    Result of calling IDsObjectPicker::Initialize.
//
//  History:    10-14-1998   DavidMun   Created
//              1-8-2000     SergeiA    Adapted for IIS
//				9-6-2002	 a-dsebes	Adapted for UDDI
//
//---------------------------------------------------------------------------
HRESULT
InitObjectPickerForGroups( IDsObjectPicker *pDsObjectPicker, 
                           BOOL fMultiselect,
						   BOOL fWantSidPath )
{
    //
    // Prepare to initialize the object picker.
    // Set up the array of scope initializer structures.
    //

    static const int SCOPE_INIT_COUNT = 5;
    DSOP_SCOPE_INIT_INFO aScopeInit[ SCOPE_INIT_COUNT ];

    ZeroMemory( aScopeInit, sizeof( DSOP_SCOPE_INIT_INFO ) * SCOPE_INIT_COUNT );

    //
    // Target computer scope.  This adds a "Look In" entry for the
    // target computer.  Computer scopes are always treated as
    // downlevel (i.e., they use the WinNT provider).
    //
    aScopeInit[ 0 ].cbSize = sizeof( DSOP_SCOPE_INIT_INFO );
    aScopeInit[ 0 ].flType = DSOP_SCOPE_TYPE_TARGET_COMPUTER;
    aScopeInit[ 0 ].flScope = DSOP_SCOPE_FLAG_STARTING_SCOPE;

	aScopeInit[ 0 ].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_BUILTIN_GROUPS;
    aScopeInit[ 0 ].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_LOCAL_GROUPS;

	if( fWantSidPath )
	{
		aScopeInit[ 0 ].flScope |= DSOP_SCOPE_FLAG_WANT_SID_PATH;
	}

    //
    // The domain to which the target computer is joined.  Note we're
    // combining two scope types into flType here for convenience.
    //
    aScopeInit[ 1 ].cbSize = sizeof( DSOP_SCOPE_INIT_INFO );
    aScopeInit[ 1 ].flScope = 0;
    aScopeInit[ 1 ].flType = DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN | 
				   		     DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN;

	aScopeInit[ 1 ].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_GLOBAL_GROUPS_SE |
													DSOP_FILTER_UNIVERSAL_GROUPS_SE |
													DSOP_FILTER_DOMAIN_LOCAL_GROUPS_SE;
    aScopeInit[ 1 ].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_GLOBAL_GROUPS;

	if( fWantSidPath )
	{
		aScopeInit[ 1 ].flScope |= DSOP_SCOPE_FLAG_WANT_SID_PATH;
	}

    //
    // The domains in the same forest (enterprise) as the domain to which
    // the target machine is joined.  Note these can only be DS-aware
    //

    aScopeInit[ 2 ].cbSize = sizeof( DSOP_SCOPE_INIT_INFO );
    aScopeInit[ 2 ].flType = DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN;
    aScopeInit[ 2 ].flScope = 0;

	aScopeInit[ 2 ].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_GLOBAL_GROUPS_SE |
													  DSOP_FILTER_UNIVERSAL_GROUPS_SE;

	if( fWantSidPath )
	{
		aScopeInit[ 2 ].flScope |= DSOP_SCOPE_FLAG_WANT_SID_PATH;
	}

    //
    // Domains external to the enterprise but trusted directly by the
    // domain to which the target machine is joined.
    //
    // If the target machine is joined to an NT4 domain, only the
    // external downlevel domain scope applies, and it will cause
    // all domains trusted by the joined domain to appear.
    //

    aScopeInit[ 3 ].cbSize = sizeof( DSOP_SCOPE_INIT_INFO );
    aScopeInit[ 3 ].flScope = 0;
    aScopeInit[ 3 ].flType = DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN |
							 DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN;

	aScopeInit[ 3 ].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_GLOBAL_GROUPS_SE |
													  DSOP_FILTER_UNIVERSAL_GROUPS_SE;
    aScopeInit[ 3 ].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_GLOBAL_GROUPS;

	if( fWantSidPath )
	{
		aScopeInit[ 3 ].flScope |= DSOP_SCOPE_FLAG_WANT_SID_PATH;
	}

    //
    // The Global Catalog
    //

    aScopeInit[ 4 ].cbSize = sizeof( DSOP_SCOPE_INIT_INFO );
    aScopeInit[ 4 ].flScope = 0;
    aScopeInit[ 4 ].flType = DSOP_SCOPE_TYPE_GLOBAL_CATALOG;

	//
    // Only native mode applies to gc scope.
	//
    aScopeInit[ 4 ].FilterFlags.Uplevel.flNativeModeOnly = DSOP_FILTER_GLOBAL_GROUPS_SE |
														   DSOP_FILTER_UNIVERSAL_GROUPS_SE;

	if( fWantSidPath )
	{
		aScopeInit[ 4 ].flScope |= DSOP_SCOPE_FLAG_WANT_SID_PATH;
	}

    //
    // Put the scope init array into the object picker init array
    //

    DSOP_INIT_INFO InitInfo;
    ZeroMemory( &InitInfo, sizeof( InitInfo ) );
    InitInfo.cbSize = sizeof( InitInfo );

    //
    // The pwzTargetComputer member allows the object picker to be
    // retargetted to a different computer.  It will behave as if it
    // were being run ON THAT COMPUTER.
    //
    InitInfo.cDsScopeInfos = SCOPE_INIT_COUNT;
    InitInfo.aDsScopeInfos = aScopeInit;
    InitInfo.flOptions = fMultiselect ? DSOP_FLAG_MULTISELECT : 0;

    //
    // Note object picker makes its own copy of InitInfo.  Also note
    // that Initialize may be called multiple times, last call wins.
    //

    HRESULT hr = pDsObjectPicker->Initialize( &InitInfo );

	return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   InitObjectPickerForUsers
//
//  Synopsis:   Call IDsObjectPicker::Initialize with arguments that will
//              set it to allow the user to pick one or more groups.
//
//  Arguments:  [pDsObjectPicker] - object picker interface instance
//
//  Returns:    Result of calling IDsObjectPicker::Initialize.
//
//  History:    9-6-2002	 a-dsebes	Created.
//				
//
//---------------------------------------------------------------------------
HRESULT
InitObjectPickerForUsers( IDsObjectPicker *pDsObjectPicker, 
                          BOOL fMultiselect )
{
    //
    // Prepare to initialize the object picker.
    // Set up the array of scope initializer structures.
    //

    static const int SCOPE_INIT_COUNT = 5;
    DSOP_SCOPE_INIT_INFO aScopeInit[ SCOPE_INIT_COUNT ];

    ZeroMemory( aScopeInit, sizeof( DSOP_SCOPE_INIT_INFO ) * SCOPE_INIT_COUNT );

    //
    // Target computer scope.  This adds a "Look In" entry for the
    // target computer.  Computer scopes are always treated as
    // downlevel (i.e., they use the WinNT provider).
    //
    aScopeInit[ 0 ].cbSize = sizeof( DSOP_SCOPE_INIT_INFO );
    aScopeInit[ 0 ].flType = DSOP_SCOPE_TYPE_TARGET_COMPUTER;
    aScopeInit[ 0 ].flScope = DSOP_SCOPE_FLAG_STARTING_SCOPE;

	aScopeInit[ 0 ].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_USERS;
    aScopeInit[ 0 ].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_USERS;

    //
    // The domain to which the target computer is joined.  Note we're
    // combining two scope types into flType here for convenience.
    //
    aScopeInit[ 1 ].cbSize = sizeof( DSOP_SCOPE_INIT_INFO );
    aScopeInit[ 1 ].flScope = 0;
    aScopeInit[ 1 ].flType = DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN | 
				   		     DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN;

	aScopeInit[ 1 ].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_USERS;
    aScopeInit[ 1 ].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_USERS;

    //
    // The domains in the same forest (enterprise) as the domain to which
    // the target machine is joined.  Note these can only be DS-aware
    //
    aScopeInit[ 2 ].cbSize = sizeof( DSOP_SCOPE_INIT_INFO );
    aScopeInit[ 2 ].flType = DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN;
    aScopeInit[ 2 ].flScope = 0;

	aScopeInit[ 2 ].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_USERS;

    //
    // Domains external to the enterprise but trusted directly by the
    // domain to which the target machine is joined.
    //
    // If the target machine is joined to an NT4 domain, only the
    // external downlevel domain scope applies, and it will cause
    // all domains trusted by the joined domain to appear.
    //
    aScopeInit[ 3 ].cbSize = sizeof( DSOP_SCOPE_INIT_INFO );
    aScopeInit[ 3 ].flScope = 0;
    aScopeInit[ 3 ].flType = DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN |
							 DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN;

	aScopeInit[ 3 ].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_USERS;
    aScopeInit[ 3 ].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_USERS;

    //
    // The Global Catalog
    //
    aScopeInit[ 4 ].cbSize = sizeof( DSOP_SCOPE_INIT_INFO );
    aScopeInit[ 4 ].flScope = 0;
    aScopeInit[ 4 ].flType = DSOP_SCOPE_TYPE_GLOBAL_CATALOG;

	//
    // Only native mode applies to gc scope.
	//
	aScopeInit[ 4 ].FilterFlags.Uplevel.flNativeModeOnly = DSOP_FILTER_USERS;

    //
    // Put the scope init array into the object picker init array
    //
    DSOP_INIT_INFO InitInfo;
    ZeroMemory( &InitInfo, sizeof( InitInfo ) );
    InitInfo.cbSize = sizeof( InitInfo );

    //
    // The pwzTargetComputer member allows the object picker to be
    // retargetted to a different computer.  It will behave as if it
    // were being run ON THAT COMPUTER.
    //
    InitInfo.cDsScopeInfos = SCOPE_INIT_COUNT;
    InitInfo.aDsScopeInfos = aScopeInit;
    InitInfo.flOptions = fMultiselect ? DSOP_FLAG_MULTISELECT : 0;

    //
    // Note object picker makes its own copy of InitInfo.  Also note
    // that Initialize may be called multiple times, last call wins.
    //
    HRESULT hr = pDsObjectPicker->Initialize( &InitInfo );

	return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   InitObjectPickerForComputers
//
//  Synopsis:   Call IDsObjectPicker::Initialize with arguments that will
//              set it to allow the user to pick a single computer object.
//
//  Arguments:  [pDsObjectPicker] - object picker interface instance
//
//  Returns:    Result of calling IDsObjectPicker::Initialize.
//
//  History:    10-14-1998   DavidMun   Created
//              08-06-2002   a-dsebes   Adapted for UDDI.
//
//---------------------------------------------------------------------------

HRESULT
InitObjectPickerForComputers( IDsObjectPicker *pDsObjectPicker )
{
    //
    // Prepare to initialize the object picker.
    // Set up the array of scope initializer structures.
    //

    static const int SCOPE_INIT_COUNT = 2;
    DSOP_SCOPE_INIT_INFO aScopeInit[ SCOPE_INIT_COUNT ];

    ZeroMemory( aScopeInit, sizeof( DSOP_SCOPE_INIT_INFO ) * SCOPE_INIT_COUNT );

    //
    // Build a scope init struct for everything except the joined domain.
    //

    aScopeInit[ 0 ].cbSize = sizeof( DSOP_SCOPE_INIT_INFO );
    aScopeInit[ 0 ].flType = DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN
                             | DSOP_SCOPE_TYPE_GLOBAL_CATALOG
                             | DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN
                             | DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN
                             | DSOP_SCOPE_TYPE_WORKGROUP
                             | DSOP_SCOPE_TYPE_USER_ENTERED_UPLEVEL_SCOPE
                             | DSOP_SCOPE_TYPE_USER_ENTERED_DOWNLEVEL_SCOPE;

	aScopeInit[ 0 ].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_COMPUTERS;
    aScopeInit[ 0 ].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_COMPUTERS;


    //
    // scope for the joined domain, make it the default
    //
    aScopeInit[ 1 ].cbSize = sizeof( DSOP_SCOPE_INIT_INFO );
    aScopeInit[ 1 ].flType = DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN
                             | DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN;

	aScopeInit[ 1 ].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_COMPUTERS;
    aScopeInit[ 1 ].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_COMPUTERS;
    aScopeInit[ 1 ].flScope = DSOP_SCOPE_FLAG_STARTING_SCOPE;

    //
    // Put the scope init array into the object picker init array
    //

    DSOP_INIT_INFO InitInfo;
    ZeroMemory( &InitInfo, sizeof( InitInfo ) );

    InitInfo.cbSize = sizeof( InitInfo );
    InitInfo.pwzTargetComputer = NULL;  // NULL == local machine
    InitInfo.cDsScopeInfos = SCOPE_INIT_COUNT;
    InitInfo.aDsScopeInfos = aScopeInit;

    //
    // Note object picker makes its own copy of InitInfo.  Also note
    // that Initialize may be called multiple times, last call wins.
    //

    return pDsObjectPicker->Initialize(&InitInfo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\setup\ocm\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by uddiocm.rc
//
#define ID_MAINICON                     1
#define IDD_PROPPAGE_LARGE              101
#define IDD_WIZARD_SUMMARY              101
#define IDD_SITE_NAME                   101
#define IDD_DB_INSTANCE                 102
#define IDD_SSL                         103
#define IDD_CONFIRM_PW                  104
#define IDD_PROPPAGE_LARGE1             107
#define IDD_ADD_SERVICES                107
#define IDS_SUBTITLE                    111
#define IDS_TITLE                       111
#define IDS_DB_SUBTITLE                 112
#define IDS_NO_INSTANCE_MSG             113
#define IDD_REMOTE_DB                   114
#define IDS_LOGIN_ERROR                 114
#define IDS_MSDE_ALREADY_USED           115
#define IDD_LOGIN                       116
#define IDS_NO_LOCAL_ACCT_ALLOWED       116
#define IDS_WRONG_FRAMEWORK_VER         117
#define IDS_IIS_ISOLATION_MODE_ERROR    117
#define IDS_PLEASE_TYPE_INSTANCE_NAME   118
#define IDS_UDDI_DB_NOT_EXIST           118
#define IDS_SELECT_REMOTE_COMPUTER      119
#define IDS_SSL_SUBTITLE                120
#define IDS_REMOTE_DB_SUBTITLE          121
#define IDS_LOGIN_SUBTITLE              122
#define IDS_PW_MISMATCH                 123
#define IDS_ZERO_LEN_USER_NAME          124
#define IDS_INSTALL                     125
#define IDS_UNINSTALL                   126
#define IDS_REMOTE_DB_NOT_FOUND         127
#define IDD_DATAPATHS                   127
#define IDS_WIZARD_SUMMARY_SUBTITLE     128
#define IDS_WIZARD_SUMMARY_GENERAL      129
#define IDS_WIZARD_SUMMARY_DB           130
#define IDS_WIZARD_SUMMARY_WEB          131
#define IDS_WIZARD_SUMMARY_ADMIN        132
#define IDS_INSTALL_ERROR               133
#define IDS_MSDE_NAME                   134
#define IDS_DB_NAME                     135
#define IDS_WEB_NAME                    136
#define IDS_ADMIN_NAME                  137
#define IDS_IIS_SERVICE_DISABLED        138
#define IDS_IIS_UNKNOWN_ERROR           139
#define IDS_ZERO_LEN_PROVIDER_NAME      140
#define IDS_UDDIPROV_SUBTITLE           141
#define IDS_UDDIADDSVC_SUBTITLE         142
#define IDS_FILEPATHS_SUBTITLE          143
#define IDS_PROMPT_SELSYSDATAPATH       144
#define IDS_PROMPT_SELCOREPATH_1        145
#define IDS_PROMPT_SELCOREPATH_2        146
#define IDS_PROMPT_SELJRNLPATH          147
#define IDS_PROMPT_SELSTGPATH           148
#define IDS_PROMPT_SELXLOGPATH          149
#define IDS_LABEL_SYSPATHSIMPLE         150
#define IDS_LABEL_SYSPATH_ADV           151
#define IDD_EXISTING_DBINSTANCE         152
#define IDS_GETSID_ERROR                152
#define IDS_GETREMOTEACCT_ERROR         153
#define IDS_SQLSPVERSION_TOO_LOW        154
#define IDS_CANTOPENCLUSTER             155
#define IDD_CLUSTDATA                   156
#define IDS_NOCLUSTERRESAVAIL           156
#define IDS_GENERALCLUSTERR             157
#define IDS_PASSIVENODE_DB              158
#define IDS_DB_ANALYSING_MSG            159
#define IDS_WRONGLOGONTYPE              160
#define IDS_CANTCONNTOSTD               161
#define IDS_DB_EXISTS                   162
#define IDS_ACTIVENODE_DB				163
#define IDC_RADIO_INSTALL_MSDE          1002
#define IDC_RADIO_USE_EXISTING_INSTANCE 1003
#define IDC_LIST_DB_INSTANCES           1004
#define IDC_CHECK_USE_SSL               1005
#define IDC_SSL_YES                     1006
#define IDC_RADIO2                      1007
#define IDC_SSL_NO                      1008
#define IDC_RADIO_NETWORK_SERVICE       1009
#define IDC_RADIO_DOMAIN_ACCT           1010
#define IDC_REMOTE_MACHINE              1011
#define IDC_USER_NAME                   1012
#define IDC_PASSWORD                    1013
#define IDC_BROWSE_MACHINES             1014
#define IDC_REMOTE_INSTANCES            1015
#define IDC_BROWSE_USERS                1016
#define IDC_REMOTE_MACHINE_PROMPT       1017
#define IDC_REMOTE_INSTANCES_PROMPT     1018
#define IDC_CONFIRM_PW                  1019
#define IDC_REMOTE_DB                   1020
#define IDC_REMOTE_INSTANCE             1020
#define IDC_SUMMARY                     1021
#define IDC_USER_NAME_PROMPT            1022
#define IDC_PASSWORD_PROMPT             1023
#define IDC_SITE_NAME                   1024
#define IDC_CHECK_ADDSVC                1025
#define IDC_CHECK_UAD                   1026
#define IDC_SYSPATH                     1028
#define IDC_BROWSESYSPATH               1029
#define IDC_LESS_BTN                    1031
#define IDC_MORE_BTN                    1032
#define IDC_STATIC_SYS                  1033
#define IDC_COREPATH_1                  1034
#define IDC_BROWSECOREPATH1             1035
#define IDC_COREPATH_2                  1036
#define IDC_BROWSECOREPATH2             1037
#define IDC_JRNLPATH                    1038
#define IDC_BROWSEJRNLPATH              1039
#define IDC_STAGINGPATH                 1040
#define IDC_BROWSESTAGINGPATH           1041
#define IDC_XLOGPATH                    1042
#define IDC_BROWSEXLOGPATH              1043
#define IDC_STATIC_C1                   1044
#define IDC_STATIC_C2                   1045
#define IDC_STATIC_JRNL                 1046
#define IDC_STATIC_STG                  1047
#define IDC_STATIC_XLOG                 1048
#define IDC_INSTANCENAME                1049
#define IDS_EXISTINGDB_TITLE            1050
#define IDS_EXISTINGDB_SUBTITLE         1051
#define IDS_UDDI_ILLEGALCHARACTERS      1052

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        156
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1053
#define _APS_NEXT_SYMED_VALUE           105
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\setup\ocm\uddiinst.cpp ===
//-----------------------------------------------------------------------------------------


#define _WIN32_MSI 200

#ifndef OLEDBVER
#define OLEDBVER 0x0200
#endif

#ifndef _WIN32_WINNT		// Allow use of features specific to Windows NT 4 or later.
#define _WIN32_WINNT 0x0501		// Change this to the appropriate value to target Windows 98 and Windows 2000 or later.
#endif

#ifndef SECURITY_WIN32
#define SECURITY_WIN32
#endif

// Windows Header Files:
#include <windows.h>
#include <windef.h>
#include <tchar.h>
#include <lmcons.h>
#include <setupapi.h>
#include <Security.h>

#include <msi.h>
#include <assert.h>
#include <time.h>

#include <atldbcli.h>
#include <oledberr.h>

#include "uddiinst.h"
#include "..\shared\common.h"
#include "ocmcallback.h"
#include "net_config_get.h"
#include "ADM_addServiceAccount.h"
#include "resource.h"

using namespace ATL;

//
// The following block defines types and identifiers used by the clustering "discovery" unit
//
#define	RESTYPE_DISK	TEXT( "Physical Disk" )
#define RESTYPE_SQL		TEXT( "SQL Server" )

#define PROPNAME_VIRTUALSERVER		L"VirtualServerName"
#define PROPNAME_INSTANCENAME		L"InstanceName"

#define PROPNAME_DBSCHEMAVER		TEXT("Database.Version")

//
// Callback data blocks
//
typedef struct
{
	HCLUSTER	hCluster;
	cStrList	*pSqlDependencies;
	cDrvMap		*pPhysSrvMap;
}
DISK_CALLBACK_DATA, *LPDISK_CALLBACK_DATA;

typedef struct
{
	HCLUSTER	hCluster;
	tstring		sSqlInstanceName;
	cStrList	*pSqlDependencies;
}
SQL_CALLBACK_DATA, *LPSQL_CALLBACK_DATA;


typedef struct
{
	tstring		sSqlInstanceName;
	tstring		sNodeName;

	CLUSTER_RESOURCE_STATE	resState;
}
SQL_NODE_CALLBACK_DATA, *LPSQL_NODE_CALLBACK_DATA;


//
// Callback functions
//
static DWORD PhysDiskCallback( HRESOURCE hOriginal, HRESOURCE hResource, PVOID lpParams );
static DWORD SqlDepCallback( HRESOURCE hOriginal, HRESOURCE hResource, PVOID lpParams );
static DWORD SqlCallback( HRESOURCE hOriginal, HRESOURCE hResource, PVOID lpParams );

//
// Helper functions
//
static LPBYTE ParseDiskInfo( LPBYTE DiskInfo, DWORD DiskInfoSize, DWORD SyntaxValue );
static BOOL IsInList( LPCTSTR szStrToFind, cStrList *pList, BOOL bIgnoreCase = TRUE );
static DWORD GetClusterResourceControl( HRESOURCE hResource, DWORD dwControlCode, LPBYTE *pOutBuffer, DWORD *dwBytesReturned );

void HandleOLEDBError( HRESULT hrErr );

//-----------------------------------------------------------------------------------------
// General installation definitions
//
PTCHAR	szInstallStateText[] = { TEXT( "Uninstall" ), TEXT( "No Action" ), TEXT( "Install" ) };
LPCTSTR szWamPwdKey = TEXT( "C9E18" );

//-----------------------------------------------------------------------------------------
// Global objects and data items
//
extern CDBInstance g_dbLocalInstances;

//-----------------------------------------------------------------------------------------

CUDDIInstall::CUDDIInstall()
{
	ZeroMemory( m_package, sizeof( SINGLE_UDDI_PACKAGE_DEF ) * UDDI_PACKAGE_COUNT );

	m_package[ UDDI_MSDE  ].cMSIName = TEXT( "sqlrun.dat" ); // this is the "cloaked" name of sqlrun08.msi
	m_package[ UDDI_WEB   ].cMSIName = TEXT( "uddiweb.msi" );
	m_package[ UDDI_DB    ].cMSIName = TEXT( "uddidb.msi" );
	m_package[ UDDI_ADMIN ].cMSIName = TEXT( "uddiadm.msi" );

	m_package[ UDDI_MSDE  ].bOCMComponent = false;
	m_package[ UDDI_WEB   ].bOCMComponent = true;
	m_package[ UDDI_DB    ].bOCMComponent = true;
	m_package[ UDDI_ADMIN ].bOCMComponent = true;
	m_package[ UDDI_COMBO ].bOCMComponent = false;

	//
	// sql is the only package that has a cab file
	//

	m_package[ UDDI_MSDE ].cCABName = TEXT( "sqlrun.cab" );

	//
	// the following names must match the names given in UDDI.INF
	//
	m_package[ UDDI_MSDE  ].cOCMName = TEXT( "(n/a)" );
	m_package[ UDDI_WEB   ].cOCMName = TEXT( "uddiweb" );
	m_package[ UDDI_DB    ].cOCMName = TEXT( "uddidatabase" );
	m_package[ UDDI_ADMIN ].cOCMName = TEXT( "uddiadmin" );
	m_package[ UDDI_COMBO ].cOCMName = TEXT( "uddicombo" );

	//
	// 775306
	// A-DSEBES:  Swapped the product code for MSDE instance #8 with WMSDE instance #8.
	//
	_tcscpy( m_package[ UDDI_MSDE  ].szProductCode, TEXT( "{B42339CD-9F22-4A6A-A023-D12990E0B918}" ) );
	_tcscpy( m_package[ UDDI_WEB   ].szProductCode, TEXT( "{D9F718B1-61D5-41B3-81E6-C6B6B4FC712C}" ) );
	_tcscpy( m_package[ UDDI_DB    ].szProductCode, TEXT( "{22FD5ACF-9151-483E-8E8F-41B1DC28E671}" ) );
	_tcscpy( m_package[ UDDI_ADMIN ].szProductCode, TEXT( "{98F055D3-99CF-4BBB-BC35-3672F9A297C1}" ) );

	//
	// 775306
	// A-DSEBES:  Upgrade code has not changed.
	//
	_tcscpy( m_package[ UDDI_MSDE  ].szUpgradeCode, TEXT( "{421A321C-2214-4713-B3EB-253F2FBCCE49}" ) );
	_tcscpy( m_package[ UDDI_WEB   ].szUpgradeCode, TEXT( "{E2B9B8F4-D0F2-4810-92AB-81F8E60732A4}" ) );
	_tcscpy( m_package[ UDDI_DB    ].szUpgradeCode, TEXT( "{B7EB7DEC-9CCA-4EBD-96CB-801EABE06A17}" ) );
	_tcscpy( m_package[ UDDI_ADMIN ].szUpgradeCode, TEXT( "{50CA09F3-3FAE-4FE1-BEF2-C29980E95B9A}" ) );

	//
	// this property will turn off networking 
	//
	AddProperty( UDDI_MSDE,  TEXT( "DISABLENETWORKPROTOCOLS" ), TEXT( "1" ) );

	//
	// this property will prevent the agent from starting
	//
	AddProperty( UDDI_MSDE, TEXT( "DISABLEAGENTSTARTUP" ), TEXT( "1" ) );

	//
	// this property will allow MSDE to use a blank sa password.  
	//
	AddProperty( UDDI_MSDE, TEXT( "BLANKSAPWD" ), TEXT( "1" ) );

	//
	// this property will keep these components off ARP
	//
	AddProperty( UDDI_WEB,   TEXT( "ARPSYSTEMCOMPONENT" ), TEXT( "1" ) );
	AddProperty( UDDI_DB,    TEXT( "ARPSYSTEMCOMPONENT" ), TEXT( "1" ) );
	AddProperty( UDDI_ADMIN, TEXT( "ARPSYSTEMCOMPONENT" ), TEXT( "1" ) );

	//
	// this property will install for all users and not current user
	//
	AddProperty( UDDI_MSDE,  TEXT( "ALLUSERS" ), TEXT( "2" ) );
	AddProperty( UDDI_WEB,   TEXT( "ALLUSERS" ), TEXT( "2" ) );
	AddProperty( UDDI_DB,    TEXT( "ALLUSERS" ), TEXT( "2" ) );
	AddProperty( UDDI_ADMIN, TEXT( "ALLUSERS" ), TEXT( "2" ) );

	//
	// this property will prevent MSI from rebooting, but will return the reboot code back to us
	//
	AddProperty( UDDI_MSDE,  TEXT( "REBOOT" ), TEXT( "ReallySuppress" ) );
	AddProperty( UDDI_WEB,   TEXT( "REBOOT" ), TEXT( "ReallySuppress" ) );
	AddProperty( UDDI_DB,    TEXT( "REBOOT" ), TEXT( "ReallySuppress" ) );
	AddProperty( UDDI_ADMIN, TEXT( "REBOOT" ), TEXT( "ReallySuppress" ) );

	//
	// this property will prevent user from running the installation outside OCM
	//
	AddProperty( UDDI_WEB,   TEXT( "RUNFROMOCM" ), TEXT( "1" ) );
	AddProperty( UDDI_DB,    TEXT( "RUNFROMOCM" ), TEXT( "1" ) );
	AddProperty( UDDI_ADMIN, TEXT( "RUNFROMOCM" ), TEXT( "1" ) );

	//
	// now figure out the Windows volume and the target path
	//
	TCHAR szTargetPath[ MAX_PATH + 1 ];
	DWORD dwRet = ExpandEnvironmentStrings( TEXT( "%SystemDrive%\\Inetpub" ), szTargetPath, MAX_PATH );
	if ( !dwRet ) // fallback on C:\Inetpub
		_tcscpy( szTargetPath, TEXT( "C:\\Inetpub" ) );

	m_cDefaultDataDir = szTargetPath;
	m_cDefaultDataDir += TEXT( "\\uddi\\data" );

	AddProperty( UDDI_WEB,   TEXT( "TARGETDIR" ), szTargetPath );
	AddProperty( UDDI_DB,    TEXT( "TARGETDIR" ), szTargetPath );
	AddProperty( UDDI_ADMIN, TEXT( "TARGETDIR" ), szTargetPath );

	//
	// Now set up the install date property so that it goes to the registry in
	// a locale-independent fashion
	//
	TCHAR szMDYDate[ 256 ];
	time_t now = time( NULL );
	struct tm *today = localtime( &now );

	_tcsftime( szMDYDate, sizeof szMDYDate / sizeof szMDYDate[0], TEXT( "%m/%d/%Y" ), today );

	AddProperty( UDDI_WEB,   TEXT( "MDY" ), szMDYDate );
	AddProperty( UDDI_DB,    TEXT( "MDY" ), szMDYDate );
	AddProperty( UDDI_ADMIN, TEXT( "MDY" ), szMDYDate );

	m_hInstance = NULL;
	m_uSuiteMask = 0;
}

//-----------------------------------------------------------------------------------------
//
// set the install level of a component given the component index
//
void CUDDIInstall::SetInstallLevel( UDDI_PACKAGE_ID id, INSTALL_LEVEL iInstallLevel, BOOL bForceInstall )
{
	if( UDDI_INSTALL == iInstallLevel )
	{
		if ( bForceInstall )
		{
			m_package[ id ].iInstallLevel = UDDI_INSTALL;
			if ( UDDI_COMBO == id )
			{
				m_package[ UDDI_WEB ].iInstallLevel = UDDI_INSTALL;
				m_package[ UDDI_DB ].iInstallLevel = UDDI_INSTALL;
			}
		}
		else
		{
			m_package[ id ].iInstallLevel = IsInstalled( id ) ? UDDI_NOACTION : UDDI_INSTALL;
			if ( UDDI_COMBO == id )
			{
				m_package[ UDDI_WEB ].iInstallLevel = m_package[ id ].iInstallLevel;
				m_package[ UDDI_DB ].iInstallLevel = m_package[ id ].iInstallLevel;
			}
		}
	}
	else if( UDDI_UNINSTALL == iInstallLevel )
	{
		m_package[ id ].iInstallLevel = IsInstalled( id ) ? UDDI_UNINSTALL : UDDI_NOACTION;
		if ( UDDI_COMBO == id )
		{
			m_package[ UDDI_WEB ].iInstallLevel = m_package[ id ].iInstallLevel;
			m_package[ UDDI_DB ].iInstallLevel = m_package[ id ].iInstallLevel;
		}
	}
	else if( UDDI_NOACTION == iInstallLevel )
	{
		m_package[ id ].iInstallLevel = UDDI_NOACTION;
		if ( UDDI_COMBO == id )
		{
			m_package[ UDDI_WEB ].iInstallLevel = m_package[ id ].iInstallLevel;
			m_package[ UDDI_DB ].iInstallLevel = m_package[ id ].iInstallLevel;
		}
	}
	else
	{
		assert( false );
	}
}

//-----------------------------------------------------------------------------------------
//
// set the install level of a component give the component name
//
void CUDDIInstall::SetInstallLevel( LPCTSTR szOCMName, INSTALL_LEVEL iInstallLevel, BOOL bForceInstall )
{
	SetInstallLevel( GetPackageID( szOCMName ), iInstallLevel, bForceInstall );
}

//-----------------------------------------------------------------------------------------
//
// Get the install level of a component give the component name
//
LPCTSTR CUDDIInstall::GetInstallStateText( LPCTSTR szOCMName )
{
	return GetInstallStateText( GetPackageID( szOCMName ) );
}

//-----------------------------------------------------------------------------------------
//
// Get the install level of a component give the component index
//
LPCTSTR CUDDIInstall::GetInstallStateText( UDDI_PACKAGE_ID id )
{
	return szInstallStateText[ m_package[ id ].iInstallLevel ];
}

//-----------------------------------------------------------------------------------------
//
// look up the id ( index ) of the component based on the name.
// The name set in the constructor must match the name given in uddi.inf.
//
UDDI_PACKAGE_ID CUDDIInstall::GetPackageID( LPCTSTR szOCMName )
{
	for( UINT uid=UDDI_MSDE; uid <= UDDI_COMBO; uid++ )
	{
		UDDI_PACKAGE_ID id = ( UDDI_PACKAGE_ID ) uid;

		if( 0 == m_package[ id ].cOCMName.compare( szOCMName ) )
		{
			return id;
		}
	}

	assert( false );
	return ( UDDI_PACKAGE_ID ) 0;
}

//--------------------------------------------------------------------------------------
// Returns the default Data Files location (typically %SystemDrive%\Inetpub\uddi\data)
//
LPCTSTR CUDDIInstall::GetDefaultDataPath ()
{
	return m_cDefaultDataDir.c_str();
}


//-----------------------------------------------------------------------------------------

void CUDDIInstall::AddProperty( UDDI_PACKAGE_ID id, LPCTSTR szProperty, LPCTSTR szValue )
{
	m_package[ id ].installProperties.Add( szProperty, szValue );
}

//-----------------------------------------------------------------------------------------

void CUDDIInstall::AddProperty( UDDI_PACKAGE_ID id, LPCTSTR szProperty, DWORD dwValue )
{
	m_package[ id ].installProperties.Add( szProperty, dwValue );
}

//-----------------------------------------------------------------------------------------

LPCTSTR CUDDIInstall::GetProperty ( UDDI_PACKAGE_ID id, LPCTSTR szProperty, LPTSTR szOutBuf )
{
	return m_package[ id ].installProperties.GetString( szProperty, szOutBuf );
}

//-----------------------------------------------------------------------------------------

void CUDDIInstall::DeleteProperty( UDDI_PACKAGE_ID id, LPCTSTR szProperty )
{
	m_package[ id ].installProperties.Delete( szProperty );
}

//-----------------------------------------------------------------------------------------
//
// clear out all the properties for a component
//
void CUDDIInstall::DeleteProperties( UDDI_PACKAGE_ID id )
{
	m_package[ id ].installProperties.Clear();
}

//-----------------------------------------------------------------------------------------

bool CUDDIInstall::SetDBInstanceName( LPCTSTR szComputerName, LPCTSTR szNewInstanceName, 
									  bool bIsInstallingMSDE, bool bIsCluster )
{
	const cBUFFSIZE = 50;
	bool  bFullyQualifiedInstance = false;
	bool  bIsLocalComputer = false;
	TCHAR szTempInstanceName[ cBUFFSIZE ] = {0};
	TCHAR szCompNameBuf[ 256 ] = {0};
	TCHAR szInstNameBuf[ 256 ] = {0};

	assert( NULL != szNewInstanceName );
	
	//
	// First, should we parse the instance name out and separate the server name from the 
	// instance name ?
	//
	TCHAR *pChar = _tcschr( szNewInstanceName, TEXT( '\\') );
	if ( pChar )
	{
		//
		// We were given a fully-qualified instance name
		// Use the computer name from the instance, as it may differ from the physical
		// computer name when run on a cluster node
		//
		bFullyQualifiedInstance = true;
		bIsLocalComputer = false;
		_tcsncpy( szCompNameBuf, szNewInstanceName, (pChar - szNewInstanceName) );
		_tcsncpy( szInstNameBuf, pChar+1, cBUFFSIZE - 1 );
	}
	else
	{
		bFullyQualifiedInstance = false;
		_tcscpy( szInstNameBuf, szNewInstanceName );

		if( szComputerName )
		{
			bIsLocalComputer = false;
			_tcscpy( szCompNameBuf, szComputerName );
		}
		else
		{
			bIsLocalComputer = true;

			TCHAR szLocalComputerName[ MAX_COMPUTERNAME_LENGTH + 1 ] = {0};
			DWORD dwLen = MAX_COMPUTERNAME_LENGTH + 1;
			GetComputerName( szLocalComputerName, &dwLen );

			_tcscpy( szCompNameBuf, szLocalComputerName );
		}
	}

	//
	// now set up the dbInstance structure
	//
	m_dbinstance.bIsCluster = bIsCluster;
	m_dbinstance.cComputerName = szCompNameBuf;
	m_dbinstance.bIsLocalComputer = bIsLocalComputer;

	_tcsncpy( szTempInstanceName, szInstNameBuf, cBUFFSIZE - 1 );

	//
	// if we are creating a new db, make sure the name select is not already in use
	//
	if( bIsInstallingMSDE )
	{
		//
		// container class of all the local db instance names
		//
		CDBInstance localDBInstance;

		bool bUnusedNameFound = false;
		for( int i=1; i<100 && !bUnusedNameFound; i++ )
		{
			if( localDBInstance.IsInstanceInstalled( szTempInstanceName ) == -1 )
			{
				bUnusedNameFound = true;
			}
			else
			{
				Log( TEXT( "MSDE instance name %s is already in use." ), szTempInstanceName );
				_stprintf( szTempInstanceName, TEXT( "%s%d" ), szNewInstanceName, i );
			}
		}

		if( !bUnusedNameFound )
		{
			Log( TEXT( "FAIL: Unable to find an unused instance name" ) );
			return false;
		}
	}

	m_dbinstance.cSQLInstanceName = szTempInstanceName;
	m_dbinstance.cFullName = m_dbinstance.cComputerName;
	if( m_dbinstance.cSQLInstanceName.compare( DEFAULT_SQL_INSTANCE_NAME ) )
	{
		m_dbinstance.cFullName += TEXT( "\\" );
		m_dbinstance.cFullName += m_dbinstance.cSQLInstanceName;
	}

	//
	// add a property to the db and web install command line to note the instance name
	//
	AddProperty( UDDI_DB,  TEXT( "INSTANCENAMEONLY" ), m_dbinstance.cSQLInstanceName.c_str() );
	AddProperty( UDDI_DB,  TEXT( "INSTANCENAME" ), m_dbinstance.cFullName.c_str() );
	AddProperty( UDDI_WEB, TEXT( "INSTANCENAME" ), m_dbinstance.cFullName.c_str() );

	//
	// MSDE needs only the instance name, not the machine name
	//
	AddProperty( UDDI_MSDE,  TEXT( "INSTANCENAME" ), m_dbinstance.cSQLInstanceName.c_str() );

	return true;
}


//-----------------------------------------------------------------------------------------
// Counterpart routines for the Set above
//
LPCTSTR CUDDIInstall::GetDBInstanceName()
{
	return m_dbinstance.cSQLInstanceName.c_str();
}


LPCTSTR CUDDIInstall::GetFullDBInstanceName()
{
	return m_dbinstance.cFullName.c_str();
}


LPCTSTR CUDDIInstall::GetDBComputerName()
{
	return m_dbinstance.cComputerName.c_str();
}

//-----------------------------------------------------------------------------------------
//
// determine if a component is installed given the component name
//
bool CUDDIInstall::IsInstalled( LPCTSTR szOCMName )
{
	return IsInstalled( GetPackageID( szOCMName ) );
}

//-----------------------------------------------------------------------------------------
//
// determine if a component is installed given the component id
//
bool CUDDIInstall::IsInstalled( UDDI_PACKAGE_ID id )
{
	TCHAR szProductGuid[ MSI_GUID_LEN ];

	//
	// Here we handle the "virtual" component UDDI_COMBO that actually is a mix of DB and Web
	//
	if ( UDDI_COMBO == id )
	{
		bool bRes = IsInstalled( UDDI_WEB ) && IsInstalled( UDDI_DB );
		return bRes;
	}

	assert( MSI_GUID_LEN - 1 == _tcslen( m_package[ id ].szUpgradeCode ) );

	UINT iRet = MsiEnumRelatedProducts( m_package[ id ].szUpgradeCode, 0, 0, szProductGuid );

	if( ERROR_NO_MORE_ITEMS == iRet )
	{
		Log( TEXT( "%s is not already installed." ), m_package[ id ].cMSIName.c_str() );
		return false ;
	}
	else if( ERROR_SUCCESS  == iRet )
	{
		Log( TEXT( "A version of %s is already installed." ), m_package[ id ].cMSIName.c_str() );
		return true;
	}
	else if( ERROR_INVALID_PARAMETER  == iRet )
	{
		Log( TEXT( "FAIL: Invalid upgrade code %s passed to MsiEnumRelatedProducts() for %s." ),
			m_package[ id ].szUpgradeCode,
			m_package[ id ].cMSIName.c_str() );
		assert( false );
		return false;
	}
	else
	{
		Log( TEXT( "FAIL: Error calling MsiEnumRelatedProducts()." ) );
		assert( false );
		return false;
	}
}

//-----------------------------------------------------------------------------------------
//
// determine if any of the components are set to install
//
bool CUDDIInstall::IsAnyInstalling()
{
	for( UINT uid=UDDI_MSDE; uid <= UDDI_ADMIN; uid++ )
	{
		UDDI_PACKAGE_ID id = ( UDDI_PACKAGE_ID ) uid;

		if( IsInstalling( id ) )
		{
			return true;
		}
	}

	return false;
}

//-----------------------------------------------------------------------------------------
//
// determine if any of the components are set to install
//
bool CUDDIInstall::IsUninstalling( UDDI_PACKAGE_ID id )
{
	return ( UDDI_UNINSTALL == m_package[ id ].iInstallLevel );
}

//-----------------------------------------------------------------------------------------
//
// determine if any of the components are set to install
//
bool CUDDIInstall::IsInstalling( UDDI_PACKAGE_ID id )
{
	return ( UDDI_INSTALL == m_package[ id ].iInstallLevel );
}

//-----------------------------------------------------------------------------------------
//
// determine if any of the components are set to install
//
bool CUDDIInstall::IsInstalling( LPCTSTR szOCMName )
{
	return IsInstalling( GetPackageID( szOCMName ) );
}

//-----------------------------------------------------------------------------------------
//
// get the selection state from the OCM and updat the install level
//
void CUDDIInstall::UpdateAllInstallLevel()
{
	for( UINT uid=UDDI_MSDE; uid <= UDDI_ADMIN; uid++ )
	{
		UDDI_PACKAGE_ID id = ( UDDI_PACKAGE_ID ) uid;

		if( m_package[ id  ].bOCMComponent )
		{
			//
			// if this is an OCM component (i.e. NOT MSDE), check its selection state
			//
			bool bIsInstalling = false;
			if( ERROR_SUCCESS == COCMCallback::QuerySelectionState( m_package[ id ].cOCMName.c_str(), bIsInstalling ) )
			{
				SetInstallLevel( id, bIsInstalling ? UDDI_INSTALL : UDDI_UNINSTALL );
			}
		}
	}

	//
	// now as we updated the DB and Web components, we can take care of the "combo" one
	//
	bool bIsInstallingCombo = false;
	if( ERROR_SUCCESS == COCMCallback::QuerySelectionState( m_package[ UDDI_COMBO ].cOCMName.c_str(), bIsInstallingCombo ) )
	{
		SetInstallLevel( UDDI_COMBO, bIsInstallingCombo ? UDDI_INSTALL : UDDI_UNINSTALL );
	}
}

//-----------------------------------------------------------------------------------------
//
// install and uninstall any or all of the components
//
UINT CUDDIInstall::Install()
{
	ENTER();

	BOOL InstallingPackage[ UDDI_PACKAGE_COUNT ] = {0};

	//
	// if any errors, don't bail
	// keep going and report errors at the very end
	//
	UINT uFinalRetCode = ERROR_SUCCESS;

	//
	// uninstall ALL the packages that are set to uninstall
	//
	for( int id = UDDI_ADMIN; id >= UDDI_MSDE; id-- )
	{
		UDDI_PACKAGE_ID pkgid = (UDDI_PACKAGE_ID) id;

		if( IsUninstalling( pkgid ) )
		{
			COCMCallback::AdvanceTickGauge();

			UINT uRetCode = UninstallPackage( pkgid );

			if( ERROR_SUCCESS != uRetCode )
				uFinalRetCode = uRetCode;
		}
	}

	//
	// install ALL the packages that are set to install
	//
	for( UINT uid=UDDI_MSDE; uid <= UDDI_ADMIN; uid++ )
	{
		UDDI_PACKAGE_ID id = ( UDDI_PACKAGE_ID ) uid;
		InstallingPackage[ uid ] = IsInstalling( id );

		if( IsInstalling( id ) )
		{
			COCMCallback::AdvanceTickGauge();

			UINT uRetCode = InstallPackage( id );

			if( ERROR_SUCCESS != uRetCode )
			{
				uFinalRetCode = uRetCode;

				// 
				// on the Standard Server, the first failed component fails the whole thing
				//
				if ( IsStdServer() && ERROR_SUCCESS_REBOOT_REQUIRED != uRetCode )
				{
					for( int tmpid = id; tmpid > UDDI_MSDE; tmpid-- )
					{
						if( InstallingPackage[ tmpid ] )
						{
							COCMCallback::AdvanceTickGauge();
							UninstallPackage( (UDDI_PACKAGE_ID)tmpid );
						}
					}

					if ( InstallingPackage[ UDDI_MSDE ] )
						UninstallPackage( UDDI_MSDE );

					break;
				}
			}
			else
			{
				uRetCode = PostInstallPackage( id );
				if( ERROR_SUCCESS != uRetCode && ERROR_SUCCESS_REBOOT_REQUIRED != uRetCode )
				{
					uFinalRetCode = uRetCode;

					//
					// Remove the package that failed on post-installation phase
					//
					UninstallPackage( id );
				}
			}
		}
	}

	return uFinalRetCode;
}

//-----------------------------------------------------------------------------------------

UINT CUDDIInstall::InstallPackage( UDDI_PACKAGE_ID id )
{
	ENTER();
	DWORD dwRetCode = 0;

	//
	// Before we do anything else, try to enable the Remote Registry
	//
	if ( id == UDDI_DB || id == UDDI_WEB )
	{
		EnableRemoteRegistry();
	}

	//
	// 739722 - Change installing message to better suite localization.
	//

	//
	// create and display the text on the OCM progress dialog
	//
	TCHAR szBuffer[ 1024 ];
	TCHAR szComponent[ 256 ];
	TCHAR szMsgFormat[ 256 ];

	//
	// Get the Installing %S ... message.
	//
	if( !LoadString( m_hInstance, IDS_INSTALL, szMsgFormat, sizeof( szMsgFormat ) / sizeof( TCHAR ) ) )
		return GetLastError();

	//
	// Get the component that we are installing.
	//
	if( !LoadString( m_hInstance, IDS_MSDE_NAME + id, szComponent, sizeof( szComponent ) / sizeof( TCHAR ) ) )
		return GetLastError();

	//
	// Write out a formatted string that combines these 2.
	//
	_sntprintf( szBuffer, 1023, szMsgFormat, szComponent );		
	COCMCallback::SetProgressText( szBuffer );
	Log( szBuffer );

	//
	// create the path to the msi file
	//
	TCHAR szWindowsDir[ MAX_PATH + 1 ];
	if( 0 == GetWindowsDirectory( szWindowsDir, MAX_PATH ) )
	{
		return GetLastError();
	}
	tstring cMSIPath = szWindowsDir;
	cMSIPath.append( TEXT( "\\" ) );
	cMSIPath.append( m_package[ id ].cMSIName.c_str() );

	//
	// start the msiexec command line
	//
	tstring cMSIArgs = TEXT( "/i " );
	cMSIArgs.append( TEXT ("\"") );
	cMSIArgs.append( cMSIPath );
	cMSIArgs.append( TEXT ("\"") );

	//
	// add the "quiet" switch
	//
	cMSIArgs.append( TEXT( " /q" ) );

	//
	// turn logging on, put log into a file in the windows folder, 
	// same name as the MSI file, with a .log extension
	//
	cMSIArgs.append( TEXT( " /l* " ) );
	cMSIArgs.append( TEXT ("\"") );
	cMSIArgs.append( cMSIPath );
	cMSIArgs.append( TEXT( ".log" ) );
	cMSIArgs.append( TEXT ("\"") );

	//
	// append all the MSI properties to the command line
	//
	Log ( TEXT ("Composing the command-line") );

	//
	// 777143
	//
	if( UDDI_MSDE == id )
	{
		const WORD hongKongLangID = MAKELANGID( LANG_CHINESE, SUBLANG_CHINESE_HONGKONG );

		LCID systemLocale = ::GetSystemDefaultLCID();
		WORD systemLangID = LANGIDFROMLCID( systemLocale );
		if( hongKongLangID == systemLangID )
		{
			Log( TEXT( "**********Hong Kong system locale detected**********" ) );
			cMSIArgs.append( TEXT( " COLLATION=" ) );
			cMSIArgs.append( TEXT( "\"Chinese_PRC_CI_AS\" " ) );
		}
		else
		{
			Log( TEXT( "**********System locale is not Hong Kong************" ) );
		}
	}

	ATOM at = 0;
	TCHAR szWamPwd[ 1024 ];

	ZeroMemory( szWamPwd, sizeof szWamPwd );

	if ( m_package[ id ].installProperties.GetString( TEXT("WAM_PWD"), szWamPwd ) )
	{
		//
		// we found the property, now let's change it so it does not get passed across
		// in a clear text format
		//
		at = GlobalAddAtom( szWamPwd );
		m_package[ id ].installProperties.Delete( TEXT("WAM_PWD") );
		m_package[ id ].installProperties.Add ( szWamPwdKey, at );
	}

	TCHAR tmpBuf [4096];
	m_package[ id ].installProperties.ConcatValuePairs (_T(" "), tmpBuf);

	cMSIArgs.append ( _T(" ") );
	cMSIArgs.append ( tmpBuf );
	
	dwRetCode = RunMSIEXECCommandLine( cMSIArgs );

	if( ERROR_SUCCESS != dwRetCode )
	{
		LogError( TEXT( "Error Installing UDDI" ), dwRetCode );
	}

	//
	// delete the msi file and the cab file
	//
	DeleteFile( cMSIPath.c_str() );
	GlobalDeleteAtom( at );

	if( m_package[ id ].cCABName.length() )
	{
		tstring cCABPath = szWindowsDir;
		cCABPath.append( TEXT( "\\" ) );
		cCABPath.append( m_package[ id ].cCABName.c_str() );
		DeleteFile( cCABPath.c_str() );
	}

	return dwRetCode;
}

//-----------------------------------------------------------------------------------------
// Executes the post-installation tasks
// BEWARE: if the function returns an error code, then the whole package will be uninstalled
//
UINT CUDDIInstall::PostInstallPackage( UDDI_PACKAGE_ID id )
{
	Log( TEXT( "Executing the post-installation tasks for the package '%s'" ), m_package[ id ].cOCMName.c_str()  );

	return ERROR_SUCCESS;
}


//-----------------------------------------------------------------------------------------

UINT CUDDIInstall::UninstallPackage( UDDI_PACKAGE_ID id )
{
	tstring cMSIArgs, cOptionalParams;
	DWORD dwRetCode = 0;

	//
	// create and display the text on the OCM progress dialog
	//
	TCHAR szMask[ 256 ] = {0},
		szComponent[ 256 ] = {0},
		szStage[ 256 ] = {0},
		szBuf[ 512 ] = {0};

	if( !LoadString( m_hInstance, IDS_UNINSTALL, szMask, DIM( szMask ) ) )
		return GetLastError();
	
	//
	// concat the name of this component 
	//
	if( !LoadString( m_hInstance, IDS_MSDE_NAME + id, szComponent, DIM( szComponent ) ) )
		return GetLastError();

	//
	// First, format the message (in case we are on a cluster node, we need to say something)
	//
	if ( id == UDDI_DB )
	{
		if( !LoadString( m_hInstance, IDS_DB_ANALYSING_MSG, szStage, DIM( szStage ) ) )
			return GetLastError();
	}

	_stprintf( szBuf, szMask, szComponent, szStage );
	COCMCallback::SetProgressText( szBuf );
	Log( szBuf );

	//
	// Now, proceed with the cluster environment analysis
	//
	if ( id == UDDI_DB || id == UDDI_WEB )
	{
		TCHAR szInstance[ 1024 ] = {0};
		DWORD cbBuf = DIM( szInstance );
		bool  bCluster = false;

		//
		// We create a temp instance as we don't want to interfere with the other components
		//
		CDBInstance dbInstances;

		bool bRes = dbInstances.GetUDDIDBInstanceName( NULL, szInstance, &cbBuf, &bCluster );
		if ( !bRes )
		{
			//
			// apparently there is no instance to uninstall. Assume we are in the "normal" mode
			//
			bCluster = false;
		}

		//
		// Now we need to detect the cluster node (if any) and its state
		//
		if ( bCluster )
		{
			TCHAR szComputer[ 256 ];
			WCHAR szNode[ 256 ];
			DWORD cbNode = DIM( szNode );
			DWORD cbComputer = DIM( szComputer );
			bool  bIsActiveNode = true;

			DWORD dwErr = GetSqlNode( szInstance, szNode, cbNode - 1 );
			if ( dwErr == ERROR_SUCCESS && wcslen( szNode ) )
			{
				//
				// this is a node. Now let's see whether it's an owning one
				//
				GetComputerName( szComputer, &cbComputer );
				if ( _tcsicmp( szNode, szComputer ) )
					bIsActiveNode = false;
			}

			//
			// Now we will set the additional command-line parameters for the custome action,
			// indicating the type of the node
			//
			cOptionalParams += TEXT( " " );
			cOptionalParams += PROPKEY_CLUSTERNODETYPE;
			cOptionalParams += TEXT( "=\"" );
			cOptionalParams += bIsActiveNode ? PROPKEY_ACTIVENODE : PROPKEY_PASSIVENODE;
			cOptionalParams += TEXT( "\" " );
		}
	}

	//
	// create the path to the msi file
	//
	TCHAR szWindowsDir[ MAX_PATH + 1 ];
	if( 0 == GetWindowsDirectory( szWindowsDir, MAX_PATH ) )
	{
		return GetLastError();
	}
	tstring cMSIPath = szWindowsDir;
	cMSIPath.append( TEXT( "\\" ) );
	cMSIPath.append( m_package[ id ].cMSIName.c_str() );

	//
	// create the command line for the msiexec uninstall
	//
	cMSIArgs = TEXT( "/q /x " );

	cMSIArgs.append( m_package[ id ].szProductCode );

	//
	// turn logging on
	//
	cMSIArgs.append( TEXT( " /l* " ) );
	cMSIArgs.append( TEXT ("\"") );
	cMSIArgs.append( cMSIPath );
	cMSIArgs.append( TEXT( ".uninst.log" ) );
	cMSIArgs.append( TEXT ("\"") );

	//
	// 777143
	//
	if( UDDI_MSDE == id )
	{
		const WORD hongKongLangID = MAKELANGID( LANG_CHINESE, SUBLANG_CHINESE_HONGKONG );

		LCID systemLocale = ::GetSystemDefaultLCID();
		WORD systemLangID = LANGIDFROMLCID( systemLocale );
		if( hongKongLangID == systemLangID )
		{
			Log( TEXT( "**********Hong Kong system locale detected**********" ) );
			cMSIArgs.append( TEXT( " COLLATION=" ) );
			cMSIArgs.append( TEXT( "\"Chinese_PRC_CI_AS\" " ) );
		}
		else
		{
			Log( TEXT( "**********System locale is not Hong Kong************" ) );
		}
	}

	//
	// suppress MSI reboots!
	// The return code from msiexec will tell us if MSI needs a reboot,
	// we will then instruct the OCM to request a reboot
	//
	cMSIArgs.append( TEXT( " REBOOT=ReallySuppress RUNFROMOCM=1 " ) );
	cMSIArgs.append( cOptionalParams );

	dwRetCode = RunMSIEXECCommandLine( cMSIArgs );

	if( ERROR_SUCCESS != dwRetCode )
	{
		LogError( TEXT( "FAIL: Error Installing package" ), dwRetCode );
	}

	return dwRetCode;
}


//-----------------------------------------------------------------------------------------

HRESULT CUDDIInstall::DetectOSFlavor()
{
	return GetOSProductSuiteMask( NULL, &m_uSuiteMask );
}



//-----------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------

CDBInstance::CDBInstance( LPCTSTR szRemoteMachine )
{
   m_instanceCount = 0;
   GetInstalledDBInstanceNames( szRemoteMachine );
}

//-----------------------------------------------------------------------------------------

LONG CDBInstance::GetInstalledDBInstanceNames( LPCTSTR szRemoteMachine )
{
	HKEY hParentKey = NULL;
	TCHAR szInstanceVersion[ 256 ];
	TCHAR szCSDVersion[ 256 ];
	TCHAR szVirtualMachineName[ MAX_COMPUTERNAME_LENGTH + 1 ];
	TCHAR szComputerName[ MAX_COMPUTERNAME_LENGTH + 1 ];
	DWORD dwLen = MAX_COMPUTERNAME_LENGTH + 1;
	DWORD dwCSDVersion = 0;
	bool bIsLocalComputer;
	LONG iRet1 = 0;

	Log( TEXT( "Looking for installed instances on machine:  %s" ), szRemoteMachine );

	//
	// connect to the remote machine (NULL indicates local machine)
	//
	if( NULL != szRemoteMachine )
	{
		bIsLocalComputer = false;
		_tcsncpy( szComputerName, szRemoteMachine, MAX_COMPUTERNAME_LENGTH );
		iRet1 = RegConnectRegistry( szRemoteMachine, HKEY_LOCAL_MACHINE, &hParentKey );
		if( ERROR_SUCCESS != iRet1 )
		{
			LogError( TEXT( "Unable to connect to remote machine" ), iRet1 );
			return iRet1;
		}
	}
	//
	// or else connect to the local machine registry
	//
	else
	{
		bIsLocalComputer = true;
		if( !GetComputerName( szComputerName, &dwLen ) )
		{
			Log( TEXT( "GetComputerName() failed, error = %d" ), GetLastError() );
		}
		Log( TEXT( "Local computer name is:  %s" ), szComputerName );
		iRet1 = RegOpenKeyEx( HKEY_LOCAL_MACHINE, NULL, NULL, KEY_READ, &hParentKey );
		if( ERROR_SUCCESS != iRet1 )
		{
			LogError( TEXT( "Unable to open local registry" ), iRet1 );
			return iRet1;
		}
	}
	
	CRegKey key;
	assert( hParentKey );
	iRet1 = key.Open( hParentKey, TEXT( "SOFTWARE\\Microsoft\\Microsoft SQL Server" ), KEY_READ );
	if( ERROR_SUCCESS != iRet1 )
	{
		Log( TEXT( "Unable to open the SQL Server regkey - SQLServer must not be installed" ) );
		RegCloseKey( hParentKey );
		return iRet1;
	}

	TCHAR szInstanceNames[ 500 ];
	ULONG uLen = sizeof( szInstanceNames ) / sizeof( TCHAR );

	//
	// get the list of installed instances of SQL on this machine
	//
	Log( TEXT( "Looking for installed instances on machine:  %s" ), szComputerName );
	DWORD dwType = REG_MULTI_SZ;
	iRet1 = RegQueryValueEx( key.m_hKey, TEXT( "InstalledInstances" ), NULL, &dwType, (LPBYTE) szInstanceNames, &uLen );
	if( ERROR_SUCCESS != iRet1 )
	{
		Log( TEXT( "There is no InstalledInstances value on this machine - SQLServer must not be installed" ) );
		RegCloseKey( hParentKey );
		return iRet1;
	}

	m_instanceCount = 0;

	//
	// process all the instance names that were found
	//
	for( PTCHAR pInstance = szInstanceNames; 
		 _tcslen( pInstance ) && m_instanceCount < MAX_INSTANCE_COUNT; 
		 pInstance += _tcslen( pInstance ) + 1 )
	{
		//
		// get the version number of this instance
		//
		if( !GetSqlInstanceVersion( hParentKey, pInstance, szInstanceVersion, sizeof( szInstanceVersion ) / sizeof( TCHAR ), szCSDVersion, sizeof( szCSDVersion ) / sizeof( TCHAR ) ) )
		{
			Log( TEXT( "Error getting version for SQL instance %s" ), pInstance );
			continue;
		}

		//
		// if this is not sql 2000 (8.0.0) or later, do not add this one to the list
		//
		if( CompareVersions( szInstanceVersion , TEXT( "8.0.0" ) ) < 0 )
		{
			Log( TEXT( "SQL instance %s, version %s is not supported" ), pInstance, szInstanceVersion );
			continue;
		}

		//
		// if this is not sql sp3 or later, do not add this one to the list
		//
		if( CompareVersions( szCSDVersion , MIN_SQLSP_VERSION ) < 0 )
		{
			Log( TEXT( "Warning: SQL instance %s, SP Level [%s] is not supported" ), pInstance, szCSDVersion );
		}

		//
		// see if this is a cluster (virtual) instance
		//
		bool bIsClusterDB = IsClusteredDB( hParentKey, pInstance, szVirtualMachineName, sizeof( szVirtualMachineName ) );

		m_dbinstance[ m_instanceCount ].cComputerName = bIsClusterDB ? szVirtualMachineName : szComputerName;
		m_dbinstance[ m_instanceCount ].bIsLocalComputer = bIsLocalComputer;
		m_dbinstance[ m_instanceCount ].bIsCluster = bIsClusterDB;
		m_dbinstance[ m_instanceCount ].cSQLVersion = szInstanceVersion;
		m_dbinstance[ m_instanceCount ].cSPVersion = szCSDVersion;

		//
		// look for the default instance
		//
		if( _tcsicmp( pInstance, DEFAULT_SQL_INSTANCE_NATIVE ) == 0 )
		{
			//
			// if this is the default instance, use only the machine name
			//
			m_dbinstance[ m_instanceCount ].cSQLInstanceName = DEFAULT_SQL_INSTANCE_NAME;
			m_dbinstance[ m_instanceCount ].cFullName = m_dbinstance[ m_instanceCount ].cComputerName;
		}
		else
		{
			//
			// if this this a named instance, use "machine\instance"
			//
			m_dbinstance[ m_instanceCount ].cSQLInstanceName = pInstance;
			m_dbinstance[ m_instanceCount ].cFullName = m_dbinstance[ m_instanceCount ].cComputerName;
			m_dbinstance[ m_instanceCount ].cFullName.append( TEXT( "\\" ) );
			m_dbinstance[ m_instanceCount ].cFullName.append( m_dbinstance[ m_instanceCount ].cSQLInstanceName );
		}

		Log( TEXT( "SQL instance %s added to list" ), m_dbinstance[ m_instanceCount ].cFullName.c_str() );

		m_instanceCount++;
	}

	if( 0 == m_instanceCount )
	{
		Log( TEXT( "No acceptable SQL instances found" ) );
		return ERROR_SUCCESS;
	}

	return ERROR_SUCCESS;
}

//-----------------------------------------------------------------------------------------

bool CDBInstance::IsClusteredDB( HKEY hParentKey, LPCTSTR szInstanceName, LPTSTR szVirtualMachineName, DWORD dwLen )
{
	tstring cVersionKey;
	if( _tcsicmp( szInstanceName, DEFAULT_SQL_INSTANCE_NAME ) == 0 || _tcsicmp( szInstanceName, TEXT( "MSSQLSERVER" ) ) == 0 )
	{
		cVersionKey = TEXT( "SOFTWARE\\Microsoft\\MSSQLServer\\Cluster" );
	}
	else
	{
		cVersionKey  = TEXT( "SOFTWARE\\Microsoft\\Microsoft SQL Server\\" );
		cVersionKey.append( szInstanceName );
		cVersionKey.append( TEXT( "\\Cluster" ) );
	}

	CRegKey key;
	assert( hParentKey );
	LONG iRet1 = key.Open( hParentKey, cVersionKey.c_str(), KEY_READ );
	if( ERROR_SUCCESS == iRet1 )
	{
		DWORD dwType = REG_SZ;
		iRet1 = RegQueryValueEx( key.m_hKey, TEXT( "ClusterName" ), NULL, &dwType, (LPBYTE) szVirtualMachineName, &dwLen );
		if( ERROR_SUCCESS == iRet1 )
		{
			Log( TEXT( "DB Instance %s is a cluster, VM name = %s" ), szInstanceName, szVirtualMachineName );
			return true;
		}
		else
		{
			Log( TEXT( "Unable to read ClusterName value in regkey %s, error=%d" ), cVersionKey.c_str(), iRet1 );
		}
	}
	else
	{
		Log( TEXT( "Unable to open regkey %s, error=%d" ), cVersionKey.c_str(), iRet1 );
	}

	Log( TEXT( "DB Instance %s is NOT a cluster" ), szInstanceName );

	return false;
}

//-----------------------------------------------------------------------------------------

bool CDBInstance::GetSqlInstanceVersion( HKEY hParentKey, LPCTSTR szInstanceName, 
										 LPTSTR szInstanceVersion, DWORD dwVersionLen,
										 LPTSTR szCSDVersion, DWORD dwCSDVersionLen )
{
	tstring cVersionKey;

	if( _tcsicmp( szInstanceName, DEFAULT_SQL_INSTANCE_NAME ) == 0 || _tcsicmp( szInstanceName, TEXT( "MSSQLSERVER" ) ) == 0 )
	{
		cVersionKey = TEXT( "SOFTWARE\\Microsoft\\MSSQLServer\\MSSQLServer\\CurrentVersion" );
	}
	else
	{
		cVersionKey  = TEXT( "SOFTWARE\\Microsoft\\Microsoft SQL Server\\" );
		cVersionKey.append( szInstanceName );
		cVersionKey.append( TEXT( "\\MSSQLServer\\CurrentVersion" ) );
	}

	CRegKey key;
	assert( hParentKey );
	LONG iRet = key.Open( hParentKey, cVersionKey.c_str() );
	if( ERROR_SUCCESS != iRet )
	{
		return false;
	}

	DWORD dwType = REG_SZ;
	iRet = RegQueryValueEx( key.m_hKey, TEXT( "CurrentVersion" ), NULL, &dwType, (LPBYTE) szInstanceVersion, &dwVersionLen );
	if( ERROR_SUCCESS != iRet )
	{
		return false;
	}

	//
	// Now see if there a SP installed, and if yes - what version
	//
	dwType = REG_SZ;
	iRet = RegQueryValueEx( key.m_hKey, TEXT( "CSDVersion" ), NULL, &dwType, (LPBYTE) szCSDVersion, &dwCSDVersionLen );
	if ( ERROR_SUCCESS != iRet )
	{
		_tcscpy( szCSDVersion, TEXT( "" ) );
	}

	return true;
}

//-----------------------------------------------------------------------------------------
// retrieves the UDDI instance name on a local or remote computer
// looks for a string registry values that is created by the UDDI DB installer
bool CDBInstance::GetUDDIDBInstanceName( LPCTSTR szRemoteMachine, LPTSTR szInstanceName, PULONG puLen, bool *pbIsClustered )
{
	LONG	iRet;
	HKEY	hParentKey;
	ULONG	uBufSize = puLen ? *puLen : 0;
	TCHAR	szVirtualMachineName[ 2 * MAX_COMPUTERNAME_LENGTH + 1 ] = {0};

	Log( TEXT( "Looking for UDDI databases on machine %s" ), szRemoteMachine ? szRemoteMachine : TEXT( "( local )" ) );

	if( NULL != szRemoteMachine )
	{
		iRet = RegConnectRegistry( szRemoteMachine, HKEY_LOCAL_MACHINE, &hParentKey );
		if( ERROR_SUCCESS != iRet )
		{
			LogError( TEXT( "Unable to connect to remote machine" ), iRet );
			return false;
		}
	}
	else
	{
		iRet = RegOpenKeyEx( HKEY_LOCAL_MACHINE, NULL, NULL, KEY_READ, &hParentKey );
		if( ERROR_SUCCESS != iRet )
		{
			LogError( TEXT( "Unable to open local registry" ), iRet );
			return false;
		}
	}
	
	CRegKey key;
	assert( hParentKey );
	iRet = key.Open( hParentKey, TEXT( "SOFTWARE\\Microsoft\\UDDI\\Setup\\DBServer" ) );
	if( ERROR_SUCCESS != iRet )
	{
		LogError( TEXT( "Unable to open the UDDI\\Setup\\DBServer regkey" ), iRet );
		RegCloseKey( hParentKey );
		return false;
	}

	DWORD dwType = REG_SZ;
	iRet = RegQueryValueEx( key.m_hKey, TEXT( "InstanceNameOnly" ), NULL, &dwType, (LPBYTE) szInstanceName, &uBufSize );
	if( ERROR_SUCCESS != iRet )
	{
		LogError( TEXT( "There are no UDDI databases on this machine" ), iRet );
		RegCloseKey( hParentKey );
		return false;
	}

	// 
	// Now check whether the instance belongs to a cluster
	//
	if ( pbIsClustered )
		*pbIsClustered = false;

	if ( IsClusteredDB( hParentKey, szInstanceName, szVirtualMachineName, DIM( szVirtualMachineName ) - 1 ) )
	{
		_tcscat( szVirtualMachineName, TEXT( "\\" ) );
		_tcscat( szVirtualMachineName, szInstanceName );

		if ( puLen )
			*puLen = (ULONG)_tcslen( szVirtualMachineName );
		
		_tcsncpy( szInstanceName, szVirtualMachineName, uBufSize );

		if ( pbIsClustered )
			*pbIsClustered = true;
	}

	RegCloseKey( hParentKey );
	return true;
}

//-----------------------------------------------------------------------------------------

bool CDBInstance::GetInstanceName( int i, PTCHAR szBuffer, UINT uBufLen )
{
	if( NULL == szBuffer )
		return false;

	if( i >= 0 && i < m_instanceCount )
	{
		_tcsncpy( szBuffer, m_dbinstance[ i ].cSQLInstanceName.c_str(), uBufLen );
		return true;
	}
	else
	{
		*szBuffer = '\0';
		return false;
	}
}


//-----------------------------------------------------------------------------------------

int CDBInstance::IsInstanceInstalled( LPCTSTR szInstanceName )
{
	for( int i=0; i<m_instanceCount; i++ )
	{
		if( _tcsicmp( m_dbinstance[ i ].cSQLInstanceName.c_str(), szInstanceName ) == 0 )
		{
			return i;
		}
	}

	return -1;
}

//-----------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------

DWORD RunMSIEXECCommandLine( tstring &cMSIArgs )
{
	STARTUPINFO si = {0};
	si.cb = sizeof( si );

	PROCESS_INFORMATION pi = {0};
	
	TCHAR szSystemFolder[ MAX_PATH ];
	if( 0 == GetSystemDirectory( szSystemFolder, MAX_PATH ) )
	{
		return GetLastError();
	}

	tstring cApplicationName( szSystemFolder );
	cApplicationName.append( TEXT( "\\msiexec.exe" ) );

	tstring cCommandLine( cApplicationName );
	cCommandLine.append( TEXT( " " ) );
	cCommandLine.append( cMSIArgs );

	TCHAR szName[ 500 ];
	ULONG uLen = 500;
	GetUserNameEx( NameSamCompatible, szName, &uLen );
	Log( TEXT( "Creating Process as: %s" ), szName );

	MyOutputDebug( TEXT( "CreateProcess( \"%s\", \"%s\" )" ), cApplicationName.c_str(), cCommandLine.c_str() );
	Log( TEXT( "Using command line: [%s]" ), cCommandLine.c_str() );

	BOOL bOK = CreateProcess( 
		cApplicationName.c_str(),	//  LPCTSTR lpApplicationName,                 // name of executable module
		( LPTSTR ) cCommandLine.c_str(),	//  LPTSTR lpCommandLine,                      // command line string
		NULL,					//  LPSECURITY_ATTRIBUTES lpProcessAttributes, // SD
		NULL,					//  LPSECURITY_ATTRIBUTES lpThreadAttributes,  // SD
		NULL,					//  BOOL bInheritHandles,                      // handle inheritance option
		CREATE_NO_WINDOW,		//  DWORD dwCreationFlags,                     // creation flags
		NULL,					//  LPVOID lpEnvironment,                      // new environment block
		NULL,					//  LPCTSTR lpCurrentDirectory,                // current directory name
		&si,					//  LPSTARTUPINFO lpStartupInfo,               // startup information
		&pi );					//  LPPROCESS_INFORMATION lpProcessInformation // process information

	if( !bOK )
	{
		Log( TEXT( "FAIL: CreateProcess() failed, error code=%d" ), GetLastError() );
		return GetLastError();
	}

	DWORD dwRet = WaitForSingleObject( pi.hProcess, INFINITE );

	if( dwRet == WAIT_TIMEOUT )
	{
		Log( TEXT( "FAIL: CreateProcess() timed out" ) );
		return ERROR_SEM_TIMEOUT;
	}
	else if( dwRet == WAIT_ABANDONED )
	{
		Log( TEXT( "FAIL: WaitForSingleObject() failed on WAIT_ABANDONED" ) );
		return ERROR_SEM_TIMEOUT;
	}
	else if( dwRet == WAIT_FAILED )
	{
		LogError( TEXT( "FAIL: WaitForSingleObject() failed" ), GetLastError() );
		return GetLastError();
	}

	DWORD dwExitCode = 0;
	if( GetExitCodeProcess( pi.hProcess, &dwExitCode ) )
	{
		if( dwExitCode )
		{
			Log( TEXT( "FAIL: MSIExec() threw an error=%d" ), dwExitCode );
			return dwExitCode;
		}
		else
		{
			Log( TEXT( "CreateProcess() succeeded" ) );
		}
	}
	else
	{
		LogError( TEXT( "GetExitCodeProcess()" ), GetLastError() );
		return GetLastError();
	}

	return ERROR_SUCCESS;
}

//-----------------------------------------------------------------------------------------

bool IsSQLRun08AlreadyUsed( bool *pbIsUsed )
{
	//
	// 775306
	// A-DSEBES: swapped the Product Code for MSDE Instance #8 with WMSDE Instance #8's
	//           Product Code.
	//
	INSTALLSTATE istate = MsiQueryProductState( TEXT( "{B42339CD-9F22-4A6A-A023-D12990E0B918}" ) );

	if( INSTALLSTATE_ABSENT == istate )
	{
		Log( TEXT( "The product is installed for a different user." ) );
		*pbIsUsed = true;
	}
	else if( INSTALLSTATE_ADVERTISED == istate )
	{
		Log( TEXT( "The product is advertised but not installed." ) );
		*pbIsUsed = false;
	}
	else if( INSTALLSTATE_DEFAULT == istate )
	{
		Log( TEXT( "The product is installed for the current user." ) );
		*pbIsUsed = true;
	}
	else if( INSTALLSTATE_UNKNOWN == istate )
	{
		Log( TEXT( "The product is neither advertised nor installed." ) );
		*pbIsUsed = false;
	}
	else if( INSTALLSTATE_INVALIDARG == istate )
	{
		Log( TEXT( "FAIL: An invalid parameter was passed to MsiQueryProductState()." ) );
		return false;
	}
	else
	{
		Log( TEXT( "FAIL: MsiQueryProductState() returned an unrecognized code." ) );
		return false;
	}

	return true;
}

//-----------------------------------------------------------------------------------------

//-----------------------------------------------------------------------------------------

extern "C"
{
	typedef HRESULT (__stdcall* GetCORVersion)( LPWSTR, DWORD, PDWORD );
}

bool IsExistMinDotNetVersion( LPCTSTR szMinDotNetVersion )
{
	DWORD dwVersionLen = 100;
	TCHAR szVersion[ 100 ];
	bool bVersionOK = false;

	//
	// load the DLL
	//
	HMODULE hinstLib = LoadLibrary( TEXT( "mscoree.dll" ) );

	if( NULL == hinstLib )
	{
		Log( TEXT( "Unable to load the .NET framework DLL so I'm assuming it is not installed" ) );
		return false;
	}

	//
	// get a pointer to the function
	//
	GetCORVersion pfn = ( GetCORVersion ) GetProcAddress( hinstLib, "GetCORVersion" ); 
	
	//
	// If the function address is valid, call the function.
	//
	if( pfn )
	{
		( pfn )( szVersion, MAX_PATH, &dwVersionLen );

		// did we find a .NET version >= to our minimum version?
		if( CompareVersions( szVersion, szMinDotNetVersion ) >= 0 )
		{
			bVersionOK = true;
		}
	}

	FreeLibrary(hinstLib); 

	return bVersionOK;
}

//-----------------------------------------------------------------------------------------
// if version1 > version2 returns 1
// if version1 = version2 returns 0
// if version1 < version2 returns -1
int CompareVersions( LPCTSTR szVersion1, LPCTSTR szVersion2 )
{
	if( NULL == szVersion1 || NULL == szVersion2 )
	{
		return 0;
	}
	const cBUFFSIZE = 100;
	TCHAR szV1[ cBUFFSIZE ];
	TCHAR szV2[ cBUFFSIZE ];

	_tcsncpy( szV1, szVersion1, cBUFFSIZE - 1 );
	_tcsncpy( szV2, szVersion2, cBUFFSIZE - 1 );
	szV1[ cBUFFSIZE - 1 ] = NULL;
	szV2[ cBUFFSIZE - 1 ] = NULL;

	StrTrim( szV1, TEXT( " vV" ) );
	StrTrim( szV2, TEXT( " vV" ) );

	PTCHAR p1 = szV1;
	PTCHAR p2 = szV2;

	// look at up to four sections of the version string ( e.g. 1.0.3233.14 )
	for( int i=0; i<4; i++ )
	{
		UINT v1 = StrToInt( p1 );
		UINT v2 = StrToInt( p2 );

		if( v1 > v2 )
			return 1;

		if( v1 < v2 )
			return -1;

		// otherwise keep on going
		p1 = StrChr( p1, '.' );
		if( NULL == p1 )
			return 0;
		p1++;

		p2 = StrChr( p2, '.' );
		if( NULL == p2 )
			return 0;
		p2++;
	}

	return 0;  // assume we are equal
}
//-----------------------------------------------------------------------------------------

void RaiseErrorDialog( LPCTSTR szAction, DWORD dwErrorCode )
{
	LPVOID lpMsgBuf = NULL;

	FormatMessage( 
		FORMAT_MESSAGE_ALLOCATE_BUFFER | 
		FORMAT_MESSAGE_FROM_SYSTEM | 
		FORMAT_MESSAGE_IGNORE_INSERTS,
		NULL,
		dwErrorCode,
		MAKELANGID( LANG_NEUTRAL, SUBLANG_DEFAULT ), // Default language
		( LPTSTR ) &lpMsgBuf,
		0,
		NULL 
	 );

	TCHAR szMsg[ 1000 ];

	_sntprintf( szMsg, 1000, TEXT( "%s\n%s" ), szAction, ( LPCTSTR ) lpMsgBuf );
	szMsg[ 999 ] = NULL;

	// Display the string.
	if( 0 == MessageBox( NULL, szMsg, TEXT( "UDDI Services Setup Error" ), MB_OK | MB_ICONWARNING ) )
	{
		UINT uErr = GetLastError();
	}

	// Free the buffer.
	LocalFree( lpMsgBuf );
}

//-----------------------------------------------------------------------------------------

bool IsOsWinXP()
{
	OSVERSIONINFOEX osvi = { 0 };
	DWORDLONG dwlConditionMask = 0;

	// Initialize the OSVERSIONINFOEX structure.
	osvi.dwOSVersionInfoSize = sizeof( OSVERSIONINFOEX );
	osvi.dwMajorVersion = 5;
	osvi.dwMinorVersion = 1;
	osvi.wProductType = VER_NT_SERVER;

	// Initialize the condition mask.
	VER_SET_CONDITION( dwlConditionMask, VER_MAJORVERSION, VER_GREATER_EQUAL );
	VER_SET_CONDITION( dwlConditionMask, VER_MINORVERSION, VER_GREATER_EQUAL );
	VER_SET_CONDITION( dwlConditionMask, VER_PRODUCT_TYPE, VER_GREATER_EQUAL );

	// Perform the test.
	BOOL bIsServer = VerifyVersionInfo( 
		&osvi,
		VER_MAJORVERSION | VER_MINORVERSION | VER_PRODUCT_TYPE,
		dwlConditionMask );

	return( TRUE == bIsServer );
}

//-----------------------------------------------------------------------------------------

bool IsTSAppCompat()
{
	OSVERSIONINFOEX osvi = { 0 };
	DWORDLONG dwlConditionMask = 0;

	// Initialize the OSVERSIONINFOEX structure.
	osvi.dwOSVersionInfoSize = sizeof( OSVERSIONINFOEX );
	osvi.wSuiteMask = VER_SUITE_TERMINAL;

	// Initialize the condition mask.
	VER_SET_CONDITION( dwlConditionMask, VER_SUITENAME, VER_AND );

	// Perform the test.
	BOOL bIsServer = VerifyVersionInfo( 
		&osvi,
		VER_SUITENAME,
		dwlConditionMask );

	if( FALSE == bIsServer )
		return false;

	//
	// check to see if we are in application server mode
	//
	CRegKey key;
	DWORD dwValue = 0;
	LONG iRet = key.Open( HKEY_LOCAL_MACHINE, TEXT( "System\\CurrentControlSet\\Control\\Terminal Server" ), KEY_READ );
	if( ERROR_SUCCESS != iRet )
		return false;

	iRet = key.QueryValue( dwValue, TEXT( "TSAppCompat" ));
	if( ERROR_SUCCESS != iRet )
		return false;

	return ( 1 == dwValue );
}

//-----------------------------------------------------------------------------------------

bool CheckForAdminPrivs()
{
	BYTE	psidLocalAdmins[ SECURITY_MAX_SID_SIZE + 2 ];
	BOOL	isLocalAdmin = FALSE;
	DWORD	cbSid = DIM( psidLocalAdmins );
	DWORD	dwErr = 0;
	BOOL	bRet;

	cbSid = SECURITY_MAX_SID_SIZE;
	bRet = CreateWellKnownSid( WinBuiltinAdministratorsSid, NULL, psidLocalAdmins, &cbSid );
	dwErr = GetLastError();
	if ( !bRet )
	{
		Log( TEXT( "CheckForAdminPrivs: Error creating LocalAdmins SID. Error %d [%x]" ), dwErr, dwErr );
		return false;
	}

	CheckTokenMembership( NULL, psidLocalAdmins, &isLocalAdmin );
	return isLocalAdmin ? true : false;
}


//--------------------------------------------------------------------------------
// Enables the RemoteRegistry service and puts it into "AutoStart" mode
//
DWORD EnableRemoteRegistry()
{
	DWORD		dwRet = 0;
	SC_HANDLE	hSCM = NULL;
	SC_HANDLE	hService = NULL;
	SC_LOCK		hLock = NULL;

	try
	{
		hSCM = OpenSCManager( NULL, NULL, GENERIC_ALL );
		if ( !hSCM )
			throw ( dwRet = GetLastError() );

		hLock = LockServiceDatabase( hSCM );
		if ( !hLock )
			throw ( dwRet = GetLastError() );

		hService = OpenService( hSCM, _T( "RemoteRegistry" ), GENERIC_ALL );
		if ( !hService )
		{
			throw ( dwRet = GetLastError() );
		}

		BOOL bRes = ChangeServiceConfig( hService, SERVICE_NO_CHANGE,
										 SERVICE_AUTO_START,
										 SERVICE_NO_CHANGE,
										 NULL, NULL, NULL, NULL, NULL, NULL, NULL );
		if ( !bRes )
			throw ( dwRet = GetLastError() );
	}
	catch ( DWORD err )
	{
		LogError( TEXT( "EnableRemoteRegistry()" ), err );
		dwRet = err;
	}
	catch (...)
	{
		LogError( TEXT( "EnableRemoteRegistry()" ), E_UNEXPECTED );
		dwRet = E_UNEXPECTED;
	}

	if ( hService )
		CloseServiceHandle( hService );

	if ( hLock )
		UnlockServiceDatabase( hLock );

	if ( hSCM )
		CloseServiceHandle( hSCM );

	return dwRet;
}

//**************************************************************************************
// Clustering functions
//
//	Enumerates the physical drives and filters out online ones, then collects the 
//  drive data etc.
//
DWORD EnumPhysicalDrives( HCLUSTER hCls, cStrList *pSqlDependencies, cDrvMap *pMap )
{
	if ( IsBadReadPtr( pMap, sizeof cDrvMap ) || 
		 IsBadReadPtr( pSqlDependencies, sizeof cStrList ) )
		return E_INVALIDARG;

	DISK_CALLBACK_DATA callbackData;
	callbackData.hCluster = hCls;
	callbackData.pPhysSrvMap = pMap;
	callbackData.pSqlDependencies = pSqlDependencies;

	pMap->clear();
	DWORD dwErr = ResUtilEnumResources( NULL, RESTYPE_DISK, PhysDiskCallback, &callbackData );

	return dwErr;
}

//---------------------------------------------------------------------------------------
// Enumerates all SQL Server resources and their "Physical Drive" dependencies
//
DWORD EnumSQLDependencies( HCLUSTER hCls, cStrList *pList, LPCTSTR szInstanceName )
{
	if ( IsBadReadPtr( pList, sizeof cStrList ) )
		return E_INVALIDARG;

	pList->clear();

	SQL_CALLBACK_DATA callbackData;
	callbackData.hCluster = hCls;
	callbackData.pSqlDependencies = pList;
	callbackData.sSqlInstanceName = szInstanceName ? szInstanceName : TEXT( "" );

	DWORD dwErr = ResUtilEnumResources( NULL, RESTYPE_SQL, SqlDepCallback, &callbackData );

	return dwErr;
}


//----------------------------------------------------------------------------------------
// Retrieves the Sql instance owning node
//
DWORD GetSqlNode( LPCWSTR szInstanceName, LPWSTR szNodeNameBuf, DWORD cbBufSize )
{
	if ( IsBadWritePtr( szNodeNameBuf, cbBufSize * sizeof WCHAR ) || 
		 IsBadStringPtr( szInstanceName, 256 ) )
		return E_INVALIDARG;

	SQL_NODE_CALLBACK_DATA callbackData;
	callbackData.sSqlInstanceName = szInstanceName;
	callbackData.sNodeName = TEXT( "" );
	
	wcscpy( szNodeNameBuf, L"" );

	DWORD dwErr = ResUtilEnumResources( NULL, RESTYPE_SQL, SqlCallback, &callbackData );
	if ( dwErr == ERROR_SUCCESS )
	{
		wcsncpy( szNodeNameBuf, callbackData.sNodeName.c_str(), cbBufSize ); 
	}

	return dwErr;
}


//---------------------------------------------------------------------------------------
// Physical drive enumeration callback
// all the data filtering and property collecting happens here
//
DWORD PhysDiskCallback( HRESOURCE hOriginal, 
					    HRESOURCE hResource, 
						PVOID lpParams )
{
	DWORD		dwErr = 0;
	HCLUSTER	hCls = NULL;
	cStrList	*pSqlDeps = NULL;
	cDrvMap		*pMap = NULL;

	if ( IsBadReadPtr( lpParams, sizeof DISK_CALLBACK_DATA ) )
		return E_INVALIDARG;

	try
	{
		BOOL bFilterDependencies = FALSE;
		BOOL bSkipResource = FALSE;

		//
		// Grab the parameter block
		//
		hCls = ((LPDISK_CALLBACK_DATA) lpParams)->hCluster;
		pSqlDeps = ((LPDISK_CALLBACK_DATA) lpParams)->pSqlDependencies;
		pMap = ((LPDISK_CALLBACK_DATA) lpParams)->pPhysSrvMap;

		//
		// Do we need to filter out the SQL dependencies only ?
		//
		bFilterDependencies = ( pSqlDeps->size() > 0 );

		
		if ( ResUtilResourceTypesEqual( RESTYPE_DISK, hResource ) )
		{
			//
			// This is a physical disk. Let's collect more data on it
			//
			CLUSPROP_PARTITION_INFO *pInfo = NULL;
			WCHAR szNameBuf[ 512 ],
				szNodeBuf[ 512 ],
				szGroupBuf[ 512 ],
				szLetter[ MAX_PATH + 1 ];
			DWORD cbNameBuf = DIM( szNameBuf ),
				cbNodeBuf = DIM( szNodeBuf ),
				cbGroupBuf = DIM( szGroupBuf ),
				cbLetter = DIM( szLetter );

			ZeroMemory( szNameBuf, sizeof szNameBuf );
			ZeroMemory( szNodeBuf, sizeof szNodeBuf );
			ZeroMemory( szGroupBuf, sizeof szGroupBuf );
			ZeroMemory( szLetter, sizeof szLetter );

			dwErr = ResUtilGetResourceName( hResource, szNameBuf, &cbNameBuf );
			if ( dwErr != ERROR_SUCCESS )
				return dwErr;

			//
			// See if wee need to consider this resource at all
			//
			if ( bFilterDependencies )
				bSkipResource = ! IsInList( szNameBuf, pSqlDeps );

			if ( !bSkipResource )
			{
				CLUSTER_RESOURCE_STATE resState = GetClusterResourceState( hResource,
																		   szNodeBuf, &cbNodeBuf,
																		   szGroupBuf, &cbNodeBuf );
				if ( resState != ClusterResourceOnline ) 
					return ERROR_SUCCESS;

				//
				// Now we will retrieve the drive properties and grab the partition info
				//
				DWORD dwBytes = 0;
				LPBYTE pBuf = NULL;
				try
				{
					dwErr = GetClusterResourceControl( hResource, CLUSCTL_RESOURCE_STORAGE_GET_DISK_INFO,
														&pBuf, &dwBytes );
					if ( dwErr != ERROR_SUCCESS && dwErr != ERROR_MORE_DATA )
						return dwErr;

					if ( !pBuf )
						return E_UNEXPECTED;

					pInfo = (PCLUSPROP_PARTITION_INFO) ParseDiskInfo( pBuf, dwBytes, CLUSPROP_SYNTAX_PARTITION_INFO );
					if ( !pInfo )
					{
						//
						// failed to parse the property block - just skip the resource
						//
						LocalFree( pBuf );
						return ERROR_SUCCESS;
					}

					//
					// First, check the flags to make sure we are not dealing with removable device
					//
					if ( ! ( pInfo->dwFlags & CLUSPROP_PIFLAG_REMOVABLE ) &&
						( pInfo->dwFlags & CLUSPROP_PIFLAG_USABLE ) )
					{
						_tcsncpy( szLetter, pInfo->szDeviceName, MAX_PATH );
					}
					else
						bSkipResource = TRUE;
				}
				catch (...)
				{
				}

				LocalFree( pBuf );
				//
				// Add the resource to the map
				//
				if ( !bSkipResource )
					pMap->insert( cDrvMapPair( szNameBuf, cPhysicalDriveInfo( szNameBuf, szNodeBuf, szGroupBuf, szLetter ) ) );
			}
		}
	}
	catch (...)
	{
		return E_UNEXPECTED;
	}

	return ERROR_SUCCESS;
}


//--------------------------------------------------------------------------------------
// Sql resource enumerator callback
//
DWORD SqlDepCallback( HRESOURCE hOriginal, HRESOURCE hResource, PVOID lpParams )
{
	DWORD		dwErr = 0;
	HCLUSTER	hCls = NULL;
	cStrList	*pList = NULL;
	tstring		sSqlInstance;

	if ( IsBadReadPtr( lpParams, sizeof SQL_CALLBACK_DATA ) )
		return E_INVALIDARG;

	try
	{
		WCHAR szBuf[ 1024 ];
		DWORD dwIdx = 0;
		DWORD dwType;
		DWORD cbBuf = DIM( szBuf );
		
		hCls = ((LPSQL_CALLBACK_DATA) lpParams)->hCluster;
		pList = ((LPSQL_CALLBACK_DATA) lpParams)->pSqlDependencies;
		sSqlInstance = ((LPSQL_CALLBACK_DATA) lpParams)->sSqlInstanceName;

		//
		// if the resource is not a SQL Server, then we just skip it
		//
		if ( ! ResUtilResourceTypesEqual( RESTYPE_SQL, hResource ) )
			return ERROR_SUCCESS;

		//
		// Do we need to check the intance name ?
		//
		if ( sSqlInstance.length() > 0 )
		{
			LPBYTE	pBuf = NULL;
			LPWSTR	szVirtualName = NULL,
					szInstanceName = NULL;
			DWORD	dwReturned = 0;
			BOOL	bSkipInstance = FALSE;

			dwErr = GetClusterResourceControl( hResource, CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES, 
											   &pBuf, &dwReturned );
			if ( dwErr != ERROR_SUCCESS )
				return dwErr;

			try
			{
				dwErr = ResUtilFindSzProperty( pBuf, dwReturned, PROPNAME_VIRTUALSERVER, &szVirtualName );
				if ( dwErr != ERROR_SUCCESS )
					throw dwErr;

				dwErr = ResUtilFindSzProperty( pBuf, dwReturned, PROPNAME_INSTANCENAME, &szInstanceName );
				if ( dwErr != ERROR_SUCCESS )
					throw dwErr;

				//
				// Do the instance names match ?
				//
				tstring szTmpInstance = szVirtualName;
				szTmpInstance += TEXT( "\\" );
				szTmpInstance += szInstanceName;

				if ( _tcsicmp( sSqlInstance.c_str(), szTmpInstance.c_str() ) )
					bSkipInstance = TRUE;
			}
			catch (...)
			{
				if ( dwErr == ERROR_SUCCESS )
					dwErr = E_UNEXPECTED;
			}

			LocalFree( pBuf );
			LocalFree( szVirtualName );
			LocalFree( szInstanceName );

			if ( dwErr != ERROR_SUCCESS )
				return dwErr;

			if ( bSkipInstance )
				return ERROR_SUCCESS;
		}

		//
		// Now enumerate the dependent resources
		//
		HRESENUM hEnum = ClusterResourceOpenEnum( hResource, CLUSTER_RESOURCE_ENUM_DEPENDS );
		if ( !hEnum )
			return ERROR_SUCCESS;

		for ( dwErr = ClusterResourceEnum( hEnum, dwIdx, &dwType, szBuf, &cbBuf );
			  dwErr == ERROR_SUCCESS;
			  dwErr = ClusterResourceEnum( hEnum, ++dwIdx, &dwType, szBuf, &cbBuf ) )
		{
			cbBuf = DIM( szBuf );

			pList->push_back( szBuf );
		}

		ClusterResourceCloseEnum( hEnum );
		dwErr = ERROR_SUCCESS;
	}
	catch (...)
	{
		dwErr = E_UNEXPECTED;
	}

	return dwErr;
}


//---------------------------------------------------------------------------------------
// Filters out the specified instance of SqlServer and retrieves its owning node 
//
static DWORD SqlCallback( HRESOURCE hOriginal, HRESOURCE hResource, PVOID lpParams )
{
	DWORD	dwErr = ERROR_SUCCESS;

	if ( IsBadReadPtr( lpParams, sizeof SQL_NODE_CALLBACK_DATA ) )
		return E_INVALIDARG;

	try
	{
		WCHAR szBuf[ 1024 ];
		DWORD cbBuf = DIM( szBuf );

		LPBYTE	pBuf = NULL;
		LPWSTR	szVirtualName = NULL,
				szInstanceName = NULL;
		DWORD	dwReturned = 0;
		BOOL	bSkipInstance = FALSE;
		
		tstring sSqlInstance = ((LPSQL_NODE_CALLBACK_DATA) lpParams)->sSqlInstanceName;
		if ( sSqlInstance.length() == 0 )
			return E_INVALIDARG;

		((LPSQL_NODE_CALLBACK_DATA) lpParams)->resState = ClusterResourceStateUnknown;

		//
		// if the resource is not a SQL Server, then we just skip it
		//
		if ( ! ResUtilResourceTypesEqual( RESTYPE_SQL, hResource ) )
			return ERROR_SUCCESS;

		dwErr = GetClusterResourceControl( hResource, CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES, 
											&pBuf, &dwReturned );
		if ( dwErr != ERROR_SUCCESS )
			return dwErr;

		try
		{
			dwErr = ResUtilFindSzProperty( pBuf, dwReturned, PROPNAME_VIRTUALSERVER, &szVirtualName );
			if ( dwErr != ERROR_SUCCESS )
				throw dwErr;

			dwErr = ResUtilFindSzProperty( pBuf, dwReturned, PROPNAME_INSTANCENAME, &szInstanceName );
			if ( dwErr != ERROR_SUCCESS )
				throw dwErr;

			//
			// Do the instance names match ?
			//
			tstring szTmpInstance = szVirtualName;
			szTmpInstance += TEXT( "\\" );
			szTmpInstance += szInstanceName;

			if ( _tcsicmp( sSqlInstance.c_str(), szTmpInstance.c_str() ) )
				bSkipInstance = TRUE;
		}
		catch (...)
		{
			if ( dwErr == ERROR_SUCCESS )
				dwErr = E_UNEXPECTED;
		}

		LocalFree( pBuf );
		LocalFree( szVirtualName );
		LocalFree( szInstanceName );

		if ( dwErr != ERROR_SUCCESS )
			return dwErr;

		if ( bSkipInstance )
			return ERROR_SUCCESS;

		// 
		// Now get the node for the Sql server
		//
		CLUSTER_RESOURCE_STATE resState = GetClusterResourceState( hResource, szBuf, &cbBuf, NULL, NULL );
		((LPSQL_NODE_CALLBACK_DATA) lpParams)->resState = resState;
		if ( resState == ClusterResourceStateUnknown )
			return GetLastError();

		((LPSQL_NODE_CALLBACK_DATA) lpParams)->sNodeName = szBuf;
	}
	catch (...)
	{
		dwErr = E_UNEXPECTED;
	}

	return dwErr;
}


//---------------------------------------------------------------------------------------
// Clustering Helpers
//
LPBYTE ParseDiskInfo( PBYTE DiskInfo, DWORD DiskInfoSize, DWORD SyntaxValue )
{
    CLUSPROP_BUFFER_HELPER ListEntry; // used to parse the value list

    DWORD  cbOffset    = 0;    // offset to next entry in the value list
    DWORD  cbPosition  = 0;    // tracks the advance through the value list buffer

    LPBYTE returnPtr = NULL;

    ListEntry.pb = DiskInfo;

    while (TRUE) 
	{

        if ( CLUSPROP_SYNTAX_ENDMARK == *ListEntry.pdw ) 
		{
            break;
        }

        cbOffset = ALIGN_CLUSPROP( ListEntry.pValue->cbLength + sizeof(CLUSPROP_VALUE) );

        //
        // Check for specific syntax in the property list.
        //

        if ( SyntaxValue == *ListEntry.pdw ) 
		{

            //
            // Make sure the complete entry fits in the buffer specified.
            //

            if ( cbPosition + cbOffset > DiskInfoSize ) 
			{
                return NULL;
            } 
			else 
			{
                returnPtr = ListEntry.pb;
            }

            break;
        }

        //
        // Verify that the offset to the next entry is
        // within the value list buffer, then advance
        // the CLUSPROP_BUFFER_HELPER pointer.
        //
        cbPosition += cbOffset;
        if ( cbPosition > DiskInfoSize ) break;
        ListEntry.pb += cbOffset;
    }

    return returnPtr;

}   // ParseDiskInfo


BOOL IsInList( LPCTSTR szStrToFind, cStrList *pList, BOOL bIgnoreCase )
{
	if ( IsBadReadPtr( pList, sizeof cStrList ) )
		return FALSE;

	BOOL bFound = FALSE;
	for ( cStrList::size_type i = 0; ( i < pList->size() ) && !bFound ; i++ )
	{
		LPCTSTR szEntry = (*pList)[i].c_str();

		if ( bIgnoreCase )
			bFound = !_tcsicmp( szEntry, szStrToFind );
		else
			bFound = !_tcscmp( szEntry, szStrToFind );
	}

	return bFound;
}


DWORD GetClusterResourceControl( HRESOURCE hResource,
								 DWORD dwControlCode,
								 LPBYTE *pOutBuffer,
								 DWORD *dwBytesReturned )
{
    DWORD dwError;

    DWORD  cbOutBufferSize  = 0;
    DWORD  cbResultSize     = 0;
    LPBYTE tempOutBuffer    = NULL;

    dwError = ClusterResourceControl( hResource,
                                      NULL,
                                      dwControlCode,
                                      NULL,
                                      0,
                                      tempOutBuffer,
                                      cbOutBufferSize,
                                      &cbResultSize );

    //
    // Reallocation routine if buffer is too small
    //

    if ( ERROR_MORE_DATA == dwError || ERROR_SUCCESS == dwError )
    {
        cbOutBufferSize = cbResultSize;
        tempOutBuffer = (LPBYTE) LocalAlloc( LPTR, cbResultSize + 2 );

        dwError = ClusterResourceControl( hResource,
                                          NULL,
                                          dwControlCode,
                                          NULL,
                                          0,
                                          tempOutBuffer,
                                          cbOutBufferSize,
                                          &cbResultSize );
    }

    //
    // On success, give the user the allocated buffer.  The user is responsible
    // for freeing this buffer.  On failure, free the buffer and return a status.
    //

    if ( NO_ERROR == dwError ) 
	{
        *pOutBuffer = tempOutBuffer;
        *dwBytesReturned = cbResultSize;
    } 
	else 
	{
        *pOutBuffer = NULL;
        *dwBytesReturned = 0;
        LocalFree( tempOutBuffer );
    }

    return dwError;

}   // GetClusterResourceControl


//-------------------------------------------------------------------------------------
// Connect to the database instance and get the Schema Version
//
HRESULT	GetDBSchemaVersion( LPCTSTR szInstanceName, LPTSTR szVerBuf, size_t cbVerBuf )
{
	HRESULT hr = S_OK;
	TCHAR	szConnStr[ 256 ];
	LPCTSTR szConnStrMask = TEXT( "Provider=SQLOLEDB.1;Integrated Security=SSPI;Persist Security Info=False;Initial Catalog=uddi;Data Source=%s;Auto Translate=True;Packet Size=4096;Use Encryption for Data=False" );

	if ( IsBadWritePtr(szVerBuf, cbVerBuf * sizeof(TCHAR) ) || !cbVerBuf )
		return E_INVALIDARG;

	if ( IsBadStringPtr( szInstanceName, 128 ) )
		return E_INVALIDARG;

	_tcscpy( szVerBuf, _T("") );

	try
	{
		_stprintf( szConnStr, szConnStrMask, szInstanceName );

		net_config_get configGet;
		configGet.m_connectionString = szConnStr;

		Log( TEXT( "GetDBSchemaVersion: Using connection string: %s." ), szConnStr );

		DBROWCOUNT rowCount;
		hr = configGet.Open();

		if( FAILED(hr) || 0 != configGet.m_RETURN_VALUE )
		{
			try
			{
				HandleOLEDBError( hr );
			}
			catch( ... )
			{
				// leave 'hr' the same.
			}
		}

		bool bStop = false;
		while( SUCCEEDED(hr) && hr != DB_S_NORESULT && !bStop )
		{
			if( NULL != configGet.GetInterface() )
			{
				HRESULT hr2 = configGet.Bind();
				
				if( SUCCEEDED( hr2 ) )
				{
					while( S_OK == configGet.MoveNext() )
					{
						if ( _tcsicmp( configGet.m_configName, PROPNAME_DBSCHEMAVER ) )
							continue;

						_tcsncpy( szVerBuf, configGet.m_configValue, cbVerBuf );
						bStop = true;
						break;
					}
				}
			}

			if ( !bStop )
				hr = configGet.GetNextResult( &rowCount );	
		}
	}
	catch (...)
	{
		Log( TEXT( "GetDBSchemaVersion: caught unexpected exception." ) );

		hr = E_UNEXPECTED;
	}

	Log( TEXT( "GetDBSchemaVersion: Finished with HRESULT %x." ), hr );

	return hr;

}

void HandleOLEDBError( HRESULT hrErr )
{
	CDBErrorInfo ErrorInfo;
	ULONG        cRecords = 0;
	HRESULT      hr;
	ULONG        i;
	CComBSTR     bstrDesc, bstrHelpFile, bstrSource, bstrMsg;
	GUID         guid;
	DWORD        dwHelpContext;
	WCHAR        wszGuid[40];
	USES_CONVERSION;

	// If the user passed in an HRESULT then trace it
	if( hrErr != S_OK )
	{
		TCHAR sz[ 256 ];
		_sntprintf( sz, 256, _T("OLE DB Error Record dump for hr = 0x%x\n"), hrErr );
		sz[ 255 ] = 0x00;
		bstrMsg += sz;
	}

	LCID lcLocale = GetSystemDefaultLCID();

	hr = ErrorInfo.GetErrorRecords(&cRecords);
	if( FAILED(hr) && ( ErrorInfo.m_spErrorInfo == NULL ) )
	{
		TCHAR sz[ 256 ];
		_sntprintf( sz, 256, _T("No OLE DB Error Information found: hr = 0x%x\n"), hr );
		sz[ 255 ] = 0x00;
		bstrMsg += sz;
	}
	else
	{
		for( i = 0; i < cRecords; i++ )
		{
			hr = ErrorInfo.GetAllErrorInfo(i, lcLocale, &bstrDesc, &bstrSource, &guid,
										&dwHelpContext, &bstrHelpFile);
			if( FAILED(hr) )
			{
				TCHAR sz[ 256 ];
				_sntprintf( sz, 256, _T("OLE DB Error Record dump retrieval failed: hr = 0x%x\n"), hr );
				sz[ 255 ] = 0x00;
				bstrMsg += sz;
				break;
			}

			StringFromGUID2( guid, wszGuid, sizeof(wszGuid) / sizeof(WCHAR) );
			TCHAR sz[ 256 ];
			_sntprintf( 
				sz, 256,
				_T("Row #: %4d Source: \"%s\" Description: \"%s\" Help File: \"%s\" Help Context: %4d GUID: %s\n"),
		        i, OLE2T(bstrSource), OLE2T(bstrDesc), OLE2T(bstrHelpFile), dwHelpContext, OLE2T(wszGuid) );

			sz[ 255 ] = 0x00;
			bstrMsg += sz;

			bstrSource.Empty();
			bstrDesc.Empty();
			bstrHelpFile.Empty();
		}

		bstrMsg += _T("OLE DB Error Record dump end\n");
	}

	Log( TEXT( "HandleOLEDBError: %s" ), bstrMsg );
}

//-------------------------------------------------------------------------------------
// Add user to service account in db.
//
HRESULT	AddServiceAccount( LPCTSTR szInstanceName, LPCTSTR szUser )
{
	HRESULT hr = S_OK;
	TCHAR	szConnStr[ 256 ];
	LPCTSTR szConnStrMask = TEXT( "Provider=SQLOLEDB.1;Integrated Security=SSPI;Persist Security Info=False;Initial Catalog=uddi;Data Source=%s;Auto Translate=True;Packet Size=4096;Use Encryption for Data=False" );

	Log( TEXT( "AddServiceAccount: Starting..." ) );

	if ( IsBadStringPtr( szInstanceName, 128 ) )
		return E_INVALIDARG;

	try
	{
		_stprintf( szConnStr, szConnStrMask, szInstanceName );

		Log( TEXT( "AddServiceAccount: Using connection string: %s." ), szConnStr );

		ADM_addServiceAccount addServiceAccount;
		addServiceAccount.m_connectionString = szConnStr;
		_tcsncpy( addServiceAccount.m_accountName, szUser, 129 );
		addServiceAccount.m_accountName[ 128 ] = '\0';

		hr = addServiceAccount.Open();

		if( FAILED(hr) || 0 != addServiceAccount.m_RETURNVALUE )
		{
			try
			{
				HandleOLEDBError( hr );
			}
			catch( ... )
			{
				// leave 'hr' the same.
			}
		}
	}
	catch (...)
	{
		Log( TEXT( "AddServiceAccount: caught unexpected exception." ) );

		hr = E_UNEXPECTED;
	}

	Log( TEXT( "AddServiceAccount: Finished with HRESULT %x." ), hr );

	return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\setup\ocm\uddiocm.cpp ===
//-----------------------------------------------------------------------------------------
// Go to "OCM" alias for assistance on this "technology"
//
//

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
#endif

#ifndef _WIN32_WINNT		// Allow use of features specific to Windows NT 4 or later.
#define _WIN32_WINNT 0x0510		// Change this to the appropriate value to target Windows 98 and Windows 2000 or later.
#endif						

#include <windows.h>
#include <windef.h>
#include <tchar.h>
#include <setupapi.h>
#include <shellapi.h>
#include "ocmanage.h"

#include "uddiocm.h"
#include "uddiinst.h"
#include "ocmcallback.h"
#include "appcompat.h"
#include "..\shared\common.h"
#include "resource.h"

TCHAR *ocmmsg[100] =
{
	TEXT( "OC_PREINITIALIZE" ),
	TEXT( "OC_INIT_COMPONENT" ),
	TEXT( "OC_SET_LANGUAGE" ),
	TEXT( "OC_QUERY_IMAGE" ),
	TEXT( "OC_REQUEST_PAGES" ),
	TEXT( "OC_QUERY_CHANGE_SEL_STATE" ),
	TEXT( "OC_CALC_DISK_SPACE" ),
	TEXT( "OC_QUEUE_FILE_OPS" ),
	TEXT( "OC_NOTIFICATION_FROM_QUEUE" ),
	TEXT( "OC_QUERY_STEP_COUNT" ),
	TEXT( "OC_COMPLETE_INSTALLATION" ),
	TEXT( "OC_CLEANUP" ),
	TEXT( "OC_QUERY_STATE" ),
	TEXT( "OC_NEED_MEDIA" ),
	TEXT( "OC_ABOUT_TO_COMMIT_QUEUE" ),
	TEXT( "OC_QUERY_SKIP_PAGE" ),
	TEXT( "OC_WIZARD_CREATED" ),
	TEXT( "OC_FILE_BUSY" ),
	TEXT( "OC_EXTRA_ROUTINES" ),
	TEXT( "OC_QUERY_IMAGE_EX" )
};

TCHAR *ocmpage[100] =
{
	TEXT("WizPagesWelcome"),
	TEXT("WizPagesMode"),
	TEXT("WizPagesEarly"),
	TEXT("WizPagesPrenet"),
	TEXT("WizPagesPostnet"),
	TEXT("WizPagesLate"),
	TEXT("WizPagesFinal")
};

typedef struct
{
	LPCTSTR szComponentName;
	LPCTSTR szSubcomponentName;
	UINT_PTR Param1;
	PVOID Param2;
} OCM_CALLBACK_ARGS, *POCM_CALLBACK_ARGS;

static DWORD UddiOcmPreinitialize       ( OCM_CALLBACK_ARGS& args );
static DWORD UddiOcmInitComponent       ( OCM_CALLBACK_ARGS& args );
static DWORD UddiOcmChangeSelectionState( OCM_CALLBACK_ARGS& args );
static DWORD UddiOcmInstallUninstall    ( OCM_CALLBACK_ARGS& args );
static DWORD UddiOcmRequestPages        ( OCM_CALLBACK_ARGS& args );
static DWORD UddiOcmQueryState          ( OCM_CALLBACK_ARGS& args );
static DWORD UddiOcmCalcDiskSpace       ( OCM_CALLBACK_ARGS& args );
static DWORD UddiOcmQueueUDDIFiles      ( OCM_CALLBACK_ARGS& args );
static DWORD UddiOcmQueryStepCount      ( OCM_CALLBACK_ARGS& args );

//-----------------------------------------------------------------------------------------

HINSTANCE g_hInstance = NULL;
CUDDIInstall g_uddiComponents;

static TCHAR g_szSetupPath[ MAX_PATH ];
static TCHAR g_szUnattendPath[ MAX_PATH ];
static HINF  g_hComponent;
static bool  g_bUnattendMode = false;
static bool  g_bPerformedCompInstall = false;


//-----------------------------------------------------------------------------------------

BOOL APIENTRY DllMain( HINSTANCE hInstance, 
                       DWORD  ul_reason_for_call, 
                       LPVOID lpReserved
					 )
{
	switch (ul_reason_for_call)
	{
	case DLL_PROCESS_ATTACH:
		g_hInstance = hInstance;
		g_uddiComponents.SetInstance( hInstance );
		ClearLog();
		break;

	case DLL_THREAD_ATTACH:
	case DLL_THREAD_DETACH:
	case DLL_PROCESS_DETACH:
		break;
	}
    return TRUE;
}

//-----------------------------------------------------------------------------------------

DWORD __stdcall OcEntry(
	IN LPCTSTR szComponentName,
	IN LPCTSTR szSubcomponentName,
	IN UINT uMsgID,
	IN UINT_PTR Param1,
	IN OUT PVOID Param2
	)
{
	if( g_bUnattendMode )
		return NO_ERROR;

    DWORD dwOcEntryReturn = 0;

	OCM_CALLBACK_ARGS args;
	args.Param1 = Param1;
	args.Param2 = Param2;
	args.szComponentName = szComponentName;
	args.szSubcomponentName = szSubcomponentName;

	MyOutputDebug( TEXT("--- Component: %15s Subcomponent: %15s Function: %s"), 
		szComponentName,
		NULL == szSubcomponentName ? TEXT( "(NULL) ") : szSubcomponentName,
		ocmmsg[uMsgID]);

    switch(uMsgID)
    {
	case OC_PREINITIALIZE:
        dwOcEntryReturn = UddiOcmPreinitialize( args );
		break;

    case OC_INIT_COMPONENT:
        dwOcEntryReturn = UddiOcmInitComponent( args );
        break;

    case OC_CALC_DISK_SPACE:
		dwOcEntryReturn = UddiOcmCalcDiskSpace( args );
        break;

    case OC_QUERY_STEP_COUNT:
		dwOcEntryReturn = UddiOcmQueryStepCount( args );
        break;

    case OC_QUEUE_FILE_OPS:
		dwOcEntryReturn = UddiOcmQueueUDDIFiles( args );
        break;

    case OC_ABOUT_TO_COMMIT_QUEUE:
        break;

    case OC_COMPLETE_INSTALLATION:
        dwOcEntryReturn = UddiOcmInstallUninstall( args );
        break;

    case OC_WIZARD_CREATED:
        break;

    case OC_QUERY_STATE:
        dwOcEntryReturn = UddiOcmQueryState( args );
        break;

    case OC_REQUEST_PAGES:
        dwOcEntryReturn = UddiOcmRequestPages( args );
        break;

    case OC_QUERY_SKIP_PAGE:
        break;

    case OC_QUERY_CHANGE_SEL_STATE:
        dwOcEntryReturn = UddiOcmChangeSelectionState( args );
        break;

	default:
		break;
	}

    return dwOcEntryReturn;
}

//-----------------------------------------------------------------------------------------

static DWORD UddiOcmPreinitialize( OCM_CALLBACK_ARGS& args )
{
    DWORD dwOcEntryReturn = 0;

#ifdef UNICODE
    dwOcEntryReturn = OCFLAG_UNICODE;
#else
    dwOcEntryReturn = OCFLAG_ANSI;
#endif

    return dwOcEntryReturn;
}

//-----------------------------------------------------------------------------------------

static DWORD UddiOcmInitComponent( OCM_CALLBACK_ARGS& args  )
{
	PSETUP_INIT_COMPONENT pSetupInitComp = (PSETUP_INIT_COMPONENT) args.Param2;
	SETUP_DATA setupData = pSetupInitComp->SetupData;

	//
	// see if we are in unattended mode
	//
	if( SETUPOP_BATCH & setupData.OperationFlags )
	{
		_tcscpy( g_szUnattendPath, pSetupInitComp->SetupData.UnattendFile );
		g_bUnattendMode = true;
		Log( _T("*** UDDI does not install in unattended mode ***") );
		return NO_ERROR;
	}
	
	//
	// grab the handle to the uddi.inf file
	//
	g_hComponent = pSetupInitComp->ComponentInfHandle;

	//
	// save a copy of the source path (to the CDROM drive)
	//
	// MessageBox(NULL, TEXT( "attach debugger" ), TEXT( "debug uddi" ), MB_OK);
	_tcscpy( g_szSetupPath, pSetupInitComp->SetupData.SourcePath );

	//
	// save a copy of the callback pointers into the OCM
	//
	COCMCallback::SetOCMRoutines( &pSetupInitComp->HelperRoutines );

	//
	// if the db is already installed, the db instance name is stored in the registry.
	// get it and set it for use by the web installer (if the user chooses to install the web component).
	//
	if( g_uddiComponents.IsInstalled( UDDI_DB ) )
	{
        CDBInstance dbinstances;
		TCHAR szInstanceName[ 20 ];
		ULONG uLen = 20;
		bool  bIsClustered = false;

		if( dbinstances.GetUDDIDBInstanceName( NULL, szInstanceName, &uLen, &bIsClustered ) )
			g_uddiComponents.SetDBInstanceName( NULL, szInstanceName, UDDI_NOT_INSTALLING_MSDE, bIsClustered );
	}

	//
	// Finally, check the OS flavor (Enterprise, Datacenter etc.)
	//
	g_uddiComponents.DetectOSFlavor();
	Log( _T( "OS Flavor Mask as reported by WMI: %#x" ), g_uddiComponents.GetOSSuiteMask() );

	return NO_ERROR;
}

//-----------------------------------------------------------------------------------------
//
// this function is called for each component and subcomponent
//
static DWORD UddiOcmQueryState( OCM_CALLBACK_ARGS& args )
{
	if( args.szSubcomponentName && args.Param1 == OCSELSTATETYPE_ORIGINAL )
	{
		if ( g_uddiComponents.IsInstalled( (PTCHAR) args.szSubcomponentName ) )
		{
			MyOutputDebug( TEXT( "Reporting that component %s is ON"), args.szSubcomponentName );
			return SubcompOn;
		}
		else
		{
			MyOutputDebug( TEXT( "Reporting that component %s is OFF"), args.szSubcomponentName );
			return SubcompOff;
		}
	}

	return SubcompUseOcManagerDefault;
}

//-----------------------------------------------------------------------------------------
//
// This function is called for each component and subcomponent
// We need to verify that IIS, if installed is not setup for IIS 5 compatability mode.
// If so we will display a message to the user and uncheck the web component portion of the
// install.
//
static DWORD UddiOcmChangeSelectionState( OCM_CALLBACK_ARGS& args )
{
	bool bSelected = false;
	COCMCallback::QuerySelectionState( args.szSubcomponentName, bSelected );
	MyOutputDebug( TEXT( "requested selection state=%08x, flags=%08x, selected=%d" ), args.Param1 , args.Param2, bSelected );

	//
	// ignore if the component name is null
	//
	if( NULL == args.szSubcomponentName )
		return 0;

	//
	// ignore if this is the parent component
	//
	if( 0 == _tcscmp( args.szSubcomponentName, TEXT( "uddiservices" ) ) )
		return 1;

	//
	// if the user has selected the web component to install AND
	// IIS is set to "IIS 5.0 Application Compatibility Mode" then
	// raise an error and don't allow it
	//
	if( 1 == args.Param1 && 
		( 0 == _tcscmp( args.szSubcomponentName, TEXT( "uddiweb" ) ) || 
		( 0 == _tcscmp( args.szSubcomponentName, TEXT( "uddicombo" ) ) ) ) )
	{
		static bool bSkipOnce = false;

		//
		// if the web component was selected from the parent, then suppress one
		// of the two error messages (it gets called twice for some reason)
		//
		if( OCQ_DEPENDENT_SELECTION & ( DWORD_PTR ) args.Param2 )
		{
			bSkipOnce = !bSkipOnce;
			if( bSkipOnce )
				return 0;
		}

		bool bIsIIS5CompatMode;
		TCHAR szMsg[ 500 ];
		TCHAR szTitle[ 50 ];

		LoadString( g_hInstance, IDS_TITLE, szTitle, sizeof( szTitle ) / sizeof( TCHAR ) );

		HRESULT hr = IsIIS5CompatMode( &bIsIIS5CompatMode );
		if( SUCCEEDED( hr ) )
		{
			if( bIsIIS5CompatMode )
			{
				//
				// cannot install web component when IIS is in 5.0 compat mode
				// raise error and do not accept the change
				//
				LoadString( g_hInstance, IDS_IIS_ISOLATION_MODE_ERROR, szMsg, sizeof( szMsg ) / sizeof( TCHAR ) );
				MessageBox( NULL, szMsg, szTitle, MB_OK | MB_ICONWARNING );
				Log( szMsg );
				return 0;
			}
		}
		else
		{
			//
			// error occurred getting the app compat mode setting.
			// tell the user why and tell OCM that we do not accept the change
			//
			// REGDB_E_CLASSNOTREG, CLASS_E_NOAGGREGATION, or E_NOINTERFACE
			//
			if( REGDB_E_CLASSNOTREG == hr )
			{
				Log( TEXT( "IIS is not installed on this machine" ) );
				// This is ok 'cause IIS gets installed if the UDDI web component is selected.
			}
            else if( ERROR_PATH_NOT_FOUND == HRESULT_CODE( hr ) )
            {
                Log( TEXT( "WWW Services not installed on this machine." ) );
				// This is ok 'cause WWW Services installed if the UDDI web component is selected.
            }
			else if( ERROR_SERVICE_DISABLED == HRESULT_CODE( hr ) )
			{
				LoadString( g_hInstance, IDS_IIS_SERVICE_DISABLED, szMsg, sizeof( szMsg ) / sizeof( TCHAR ) );
				MessageBox( NULL, szMsg, szTitle, MB_OK | MB_ICONWARNING );
				Log( szMsg );
				return 0;
			}
			else
			{
				LoadString( g_hInstance, IDS_IIS_UNKNOWN_ERROR, szMsg, sizeof( szMsg ) / sizeof( TCHAR ) );
				MessageBox( NULL, szMsg, szTitle, MB_OK | MB_ICONWARNING );
				Log( szMsg );
				return 0;
			}
		}
	}

	return 1; // indicates that this state change was ACCEPTED
}

//-----------------------------------------------------------------------------------------

static DWORD UddiOcmRequestPages( OCM_CALLBACK_ARGS& args )
{
    DWORD dwOcEntryReturn = NO_ERROR;

	dwOcEntryReturn = AddUDDIWizardPages(
		args.szComponentName,
		(WizardPagesType) args.Param1,
		(PSETUP_REQUEST_PAGES) args.Param2 );

	return dwOcEntryReturn; // return the number of pages that was added
}

//-----------------------------------------------------------------------------------------

static DWORD UddiOcmInstallUninstall( OCM_CALLBACK_ARGS& args  )
{
	DWORD dwRet = ERROR_SUCCESS;

	//
	// for the root component OR if someone is trying
	// to install us unattended, simply return
	//
	if( NULL == args.szSubcomponentName )
		return ERROR_SUCCESS;

	//
	// uddiweb "needs" iis, as commanded in uddi.inf, and the only thing we know
	// for sure about OCM install order is that OCM will install IIS before it
	// installs uddiweb, so let's delay installing all the UDDI components until
	// the OCM calls for the installation of uddiweb, 'cause that way we can be sure
	// that IIS is already installed.  No, that's not a hack.
	//

	//
	// All installation/uninstallation is deferred until this component is referenced
	// This ensures that the IIS dependency is in place prior to installation of any of our
	// components.
	//
	// TODO: Review whether this is necessary anymore. We now declare proper dependencies on netfx (.NET Framework)
	// that should make this synchronization unecessary.
	//
	if( !g_bPerformedCompInstall )
	{
		g_bPerformedCompInstall = true;
		Log( _T("Installing...") );

		//
		// Even though this method name is Install it handles both install and
		// uninstall.
		//
		dwRet = g_uddiComponents.Install();

		//
		// if we need a reboot, tell the OCM
		//
		if( ERROR_SUCCESS_REBOOT_REQUIRED == dwRet )
		{
			COCMCallback::SetReboot();
			
			//
			// mute the error, as it's actualy a "success with info" code
			//
			dwRet = ERROR_SUCCESS;
		}
		else if( ERROR_SUCCESS != dwRet )
		{
			TCHAR szWindowsDirectory[ MAX_PATH + 1 ];
			if( 0 == GetWindowsDirectory( szWindowsDirectory, MAX_PATH + 1 ) )
			{
				return GetLastError();
			}

			tstring cLogFile = szWindowsDirectory;
			cLogFile.append( TEXT( "\\" ) );
			cLogFile.append( UDDI_SETUP_LOG );

			TCHAR szMsg[ 500 ];
			TCHAR szTitle[ 50 ];
			if( !LoadString( g_hInstance, IDS_INSTALL_ERROR, szMsg, sizeof( szMsg ) / sizeof( TCHAR ) ) )
				return GetLastError();

			if( !LoadString( g_hInstance, IDS_TITLE, szTitle, sizeof( szTitle ) / sizeof( TCHAR ) ) )
				return GetLastError();
			
			tstring cMsg = szMsg;
			cMsg.append( cLogFile );
			
			MessageBox( NULL, cMsg.c_str(), szTitle, MB_OK | MB_ICONWARNING | MB_TOPMOST );
		}
		else
		{
			//
			// if we installed the Web components only, show the post-install notes
			//
			if( g_uddiComponents.IsInstalling( UDDI_WEB ) || g_uddiComponents.IsInstalling( UDDI_DB ) )
			{
				HINSTANCE hInstance = ShellExecute(
					GetActiveWindow(), 
					TEXT( "open" ),
					TEXT( "postinstall.htm" ),
					NULL,
					TEXT( "\\inetpub\\uddi" ),
					SW_SHOWNORMAL);
			}
		}
	}

	//
	// on the Standard Server, we want to fail the whole installation if one component fails
	//
	return ERROR_SUCCESS;
}

//-----------------------------------------------------------------------------------------

static DWORD UddiOcmQueryStepCount( OCM_CALLBACK_ARGS& args  )
{
	//
	// if this is the main component, tell it we
	// need four steps on the gauge
	//
	if( NULL == args.szSubcomponentName )
		return 4;

	return 0;
}

//-----------------------------------------------------------------------------------------

static DWORD UddiOcmQueueUDDIFiles( OCM_CALLBACK_ARGS& args )
{
	if( !args.szSubcomponentName )
		return 0;

	HSPFILEQ hFileQueue = ( HSPFILEQ ) args.Param2;
	BOOL bOK = TRUE;
	DWORD dwErrCode = 0;

	if( g_uddiComponents.IsInstalling( args.szSubcomponentName ) )
	{
		TCHAR szSectionName[ 100 ];
		_stprintf( szSectionName, TEXT( "Install.%s" ), args.szSubcomponentName );

		bOK = SetupInstallFilesFromInfSection(
			g_hComponent,	// handle to the UDDI INF file
			NULL,			// optional, layout INF handle
			hFileQueue,		// handle to the file queue
			szSectionName,	// name of the Install section
			NULL,			// optional, root path to source files
			SP_COPY_NEWER | SP_COPY_NOSKIP 	// optional, specifies copy behavior
			);
	}

	UDDI_PACKAGE_ID pkgSubcompID = g_uddiComponents.GetPackageID( args.szSubcomponentName );
	if( pkgSubcompID == UDDI_DB || pkgSubcompID == UDDI_COMBO )
	{
		if( g_uddiComponents.IsInstalling( UDDI_MSDE ) )
		{
			//
			// copy over the msde msi file, it is stored as a different
			// name, and this will rename as it copies (and decomp if needed)
			//
			if( bOK )
			{
				//
				// this will copy over the cab file but NOT decomp the file.
				// the cab file MUST be named sqlrun.cab on the cd, because
				// the SP_COPY_NODECOMP flag foils the renaming scheme built
				// into the setup api's
				//
				bOK = SetupInstallFilesFromInfSection(
					g_hComponent,					// handle to the INF file
					NULL,							// optional, layout INF handle
					hFileQueue,						// handle to the file queue
					TEXT( "Install.MSDE" ),			// name of the Install section
					NULL,							// optional, root path to source files
					SP_COPY_NEWER | SP_COPY_NODECOMP | SP_COPY_NOSKIP // optional, specifies copy behavior
					);
			}
		}
	}

	if( !bOK )
	{
		dwErrCode = GetLastError();
		LogError( TEXT( "Error copying the UDDI files from the Windows CD:" ), dwErrCode );
	}

	return dwErrCode;
}

//-----------------------------------------------------------------------------------------

static DWORD UddiOcmCalcDiskSpace( OCM_CALLBACK_ARGS& args )
{
	BOOL bOK;
	HDSKSPC hDiskSpace = ( HDSKSPC ) args.Param2;
	
	tstring cSection = TEXT( "Install." );
	cSection += args.szSubcomponentName;

    if( args.Param1 )
    {
		//
        // add component
		//
        bOK = SetupAddInstallSectionToDiskSpaceList(
			hDiskSpace,
			g_hComponent,
			NULL,
			cSection.c_str(),
			0, 0);
    }
    else
    {
		//
        // remove component
		//
        bOK = SetupRemoveInstallSectionFromDiskSpaceList(
			hDiskSpace,
			g_hComponent,
			NULL,
			cSection.c_str(),
			0, 0);
	}

	if( !bOK )
	{
		LogError( TEXT( "Error adding disk space requirements" ), GetLastError() ) ;
	}

	return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\setup\ocm\uddiocm.h ===
//-----------------------------------------------------------------------------------------

#pragma once

DWORD AddUDDIWizardPages(
    IN     const TCHAR               *ComponentId,
    IN     const WizardPagesType     WhichOnes,
    IN OUT       SETUP_REQUEST_PAGES *SetupPages );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\setup\ocm\uddiinst.h ===
//-----------------------------------------------------------------------------------------

#pragma once

#include <windows.h>
#include <windef.h>
#include <tchar.h>
#include <setupapi.h>
#include <atlbase.h>
#include <string>
#include <vector>
#include <map>

#include <resapi.h>
#include <clusapi.h>

#include "ocmanage.h"

using namespace std;
#define tstring basic_string <TCHAR>

#include "..\shared\propertybag.h"

#define UDDI_SETUP_LOG				TEXT( "uddisetup.log" )
#define DEFAULT_SQL_INSTANCE_NAME	TEXT( "(default)" )
#define DEFAULT_SQL_INSTANCE_NATIVE	TEXT( "MSSQLSERVER" )

//--------------------------------------------------------------------------

#define PROPKEY_UDDIPROVIDER	TEXT( "UPRV" )
#define	PROPKEY_ADDSERVICES		TEXT( "UDDI_ADDSVC" )
#define PROPKEY_UPDATE_AD		TEXT( "UDDI_UPDATEAD" )

#define PROPKEY_SYSPATH			TEXT( "SFP" )
#define PROPKEY_COREPATH_1		TEXT( "C1P" )
#define PROPKEY_COREPATH_2		TEXT( "C2P" )
#define PROPKEY_JRNLPATH		TEXT( "JRNLP" )
#define PROPKEY_STGPATH			TEXT( "STGP" )
#define PROPKEY_XLOGPATH		TEXT( "XLP" )

#define PROPKEY_CLUSTERNODETYPE TEXT( "CNTYPE" )
#define PROPKEY_ACTIVENODE		TEXT( "A" )
#define PROPKEY_PASSIVENODE		TEXT( "P" )

//-----------------------------------------------------------------------------------------

typedef enum { UDDI_MSDE, UDDI_DB, UDDI_WEB, UDDI_ADMIN, UDDI_COMBO } UDDI_PACKAGE_ID;
typedef enum { UDDI_NOACTION, UDDI_UNINSTALL, UDDI_INSTALL } INSTALL_LEVEL;

#define MAX_PROPERTY_COUNT			10
#define MSI_GUID_LEN				39
#define UDDI_MSDE_INSTANCE_NAME		TEXT( "UDDI" )

const LPCTSTR UDDI_LOCAL_COMPUTER = NULL;
const bool UDDI_INSTALLING_MSDE = true;
const bool UDDI_NOT_INSTALLING_MSDE = false;

//
// SQL Server 2000 SP3
//
#define	MIN_SQLSP_VERSION			TEXT( "8.0.760" )

//
// These types are used by the clustering routines
//
#define DIM(x)	 ( sizeof x )/( sizeof x[0] )

typedef struct _cPhysicalDriveInfo
{
	tstring	sDriveLetter;
	tstring	sResName;
	tstring sOwningNode;
	tstring sGroupName;

	_cPhysicalDriveInfo( LPCTSTR szName, LPCTSTR szNode, LPCTSTR szGroup, LPCTSTR szDriveLetter )
	{
		sResName = szName;
		sOwningNode = szNode;
		sGroupName = szGroup;
		sDriveLetter = szDriveLetter;
	};
}
cPhysicalDriveInfo;


typedef std::map<tstring, cPhysicalDriveInfo>	cDrvMap;
typedef std::pair<tstring, cPhysicalDriveInfo>  cDrvMapPair;
typedef cDrvMap::iterator						cDrvIterator;

typedef std::map<tstring, tstring>		cStrMap;
typedef std::pair<tstring, tstring>		cStrMapPair;
typedef cStrMap::iterator				cStrIterator;

typedef std::vector<tstring>	cStrList;
typedef cStrList::iterator		cStrListIterator;


//
// this struct holds data describing a SQL database instance
//
typedef struct tagDbInstance
{
	bool bIsLocalComputer;
	bool bIsCluster;
	tstring cComputerName;
	tstring cSQLInstanceName;
	tstring cFullName;
	tstring cSPVersion;
	tstring cSQLVersion;

	tagDbInstance() { bIsLocalComputer = true; bIsCluster = false; }

} DB_INSTANCE;

//
// this struct holds all the data needed to install a single UDDI component
//
typedef struct
{
	tstring cOCMName;
	bool bOCMComponent; // true if an actual component on the OCM
	tstring cMSIName;
	tstring cCABName;
	INSTALL_LEVEL iInstallLevel;
	CPropertyBag installProperties;
	TCHAR szMSIPath[ MAX_PATH ];
	TCHAR szUpgradeCode[ MSI_GUID_LEN ];
	TCHAR szProductCode[ MSI_GUID_LEN ];
} SINGLE_UDDI_PACKAGE_DEF;

//
//	We have 4 "real" packages and one "virtual" - UDDI Combo
//
#define UDDI_PACKAGE_COUNT 5 

//
// This structure is used for clustered environment drive letter filtering
//
#define MAX_DRIVE_COUNT		255

typedef struct
{
	int		driveCount;					// -1 means no filtering at all
	tstring drives[ MAX_DRIVE_COUNT ];	// allowed drive letters
} 
CLST_ALLOWED_DRIVES;

//
// container class for the struct defined above
//
class CUDDIInstall
{
public:
	CUDDIInstall();

	void SetInstallLevel( UDDI_PACKAGE_ID id, INSTALL_LEVEL iInstallLevel, BOOL bForceInstall = FALSE );
	void SetInstallLevel( LPCTSTR szOCMName, INSTALL_LEVEL iInstallLevel, BOOL bForceInstall = FALSE );
	void AddProperty( UDDI_PACKAGE_ID id, LPCTSTR szProperty, LPCTSTR szValue );
	void AddProperty( UDDI_PACKAGE_ID id, LPCTSTR szProperty, DWORD dwValue );
	LPCTSTR GetProperty ( UDDI_PACKAGE_ID id, LPCTSTR szProperty, LPTSTR szOutBuf );
	void DeleteProperty( UDDI_PACKAGE_ID id, LPCTSTR szProperty );
	void DeleteProperties( UDDI_PACKAGE_ID id );
	void UpdateAllInstallLevel();
	bool IsInstalled( UDDI_PACKAGE_ID id );
	bool IsInstalled( LPCTSTR szOCMName );
	bool IsInstalling( UDDI_PACKAGE_ID id );
	bool IsUninstalling( UDDI_PACKAGE_ID id );
	bool IsInstalling( LPCTSTR szOCMName );
	LPCTSTR GetInstallStateText( LPCTSTR szOCMName );
	LPCTSTR GetInstallStateText( UDDI_PACKAGE_ID id );
	LPCTSTR GetDefaultDataPath ();
	UDDI_PACKAGE_ID GetPackageID( LPCTSTR szOCMName );
	void SetInstance( HINSTANCE hInstance ) { m_hInstance = hInstance; }
	bool IsAnyInstalling();
	bool IsClusteredDBInstance() { return m_dbinstance.bIsCluster; }
	bool SetDBInstanceName( LPCTSTR szComputerName, LPCTSTR szNewInstanceName, bool bIsInstallingMSDE, bool bIsCluster );
	HRESULT DetectOSFlavor();
	UINT	GetOSSuiteMask()	 { return m_uSuiteMask; }
	bool	IsStdServer()		 { return ( m_uSuiteMask & VER_SUITE_DATACENTER ) || ( m_uSuiteMask & VER_SUITE_DATACENTER ) ? false : true; }
	LPCTSTR GetDBInstanceName();
	LPCTSTR GetFullDBInstanceName();
	LPCTSTR GetDBComputerName();
	UINT Install();

private:
	bool SetMSIPath( UDDI_PACKAGE_ID id );
	UINT InstallPackage( UDDI_PACKAGE_ID id );
	UINT UninstallPackage( UDDI_PACKAGE_ID id );
	UINT PostInstallPackage( UDDI_PACKAGE_ID id );

private:
	HINSTANCE m_hInstance;
	UINT	  m_uSuiteMask;
	tstring m_cDefaultDataDir;
	SINGLE_UDDI_PACKAGE_DEF m_package[ UDDI_PACKAGE_COUNT ];
	DB_INSTANCE m_dbinstance;
};

//-----------------------------------------------------------------------------------------
//
// container class of the list of all db instances on a given (local or remote) machine
//

#define MAX_INSTANCE_COUNT 50

class CDBInstance
{
public:
	CDBInstance( LPCTSTR szRemoteMachine = NULL );

	LONG GetInstalledDBInstanceNames( LPCTSTR szRemoteMachine = NULL );
	bool GetUDDIDBInstanceName( LPCTSTR szRemoteMachine, LPTSTR szInstanceName, PULONG puLen, bool *pbIsClustered = NULL );
	int IsInstanceInstalled( LPCTSTR szInstanceName );
	bool GetInstanceName(int i, PTCHAR szBuffer, UINT uBufLen );
	int GetInstanceCount() { return m_instanceCount; };
	bool GetSqlInstanceVersion( HKEY hParentKey, LPCTSTR szInstanceName, LPTSTR szInstanceVersion, DWORD dwVersionLen, LPTSTR szCDSVersion, DWORD dwCSDVersionLen );
	bool IsClusteredDB( HKEY hParentKey, LPCTSTR szInstanceName, LPTSTR szVirtualMachineName, DWORD dwLen );
	DB_INSTANCE m_dbinstance[ MAX_INSTANCE_COUNT ];

private:
	int m_instanceCount;
};

//-----------------------------------------------------------------------------------------
//
// helper functions
//
DWORD RunMSIEXECCommandLine( tstring &szMSIArgs );
bool IsExistMinDotNetVersion( LPCTSTR szMinDotNetVersion );
bool IsSQLRun08AlreadyUsed( bool *bIsUsed );
bool IsOsWinXP();
DWORD EnableRemoteRegistry();
int CompareVersions( LPCTSTR szVersion1, LPCTSTR szVersion2 );
bool CheckForAdminPrivs();
void RaiseErrorDialog( LPCTSTR szAction, DWORD dwErrorCode );
bool IsTSAppCompat();

HRESULT	GetDBSchemaVersion( LPCTSTR szInstanceName, LPTSTR szVerBuf, size_t cbVerBuf );
HRESULT	AddServiceAccount( LPCTSTR szInstanceName, LPCTSTR szUser );

//*****************************************************************************************
// Cluster helper functions
//
// Enumerates SQL Server dependencies for a given instance. NULL -> enumerates all instances
// The instance name is expected to be in a fully-qualified format: <virtual server>\<instance>
//
DWORD EnumSQLDependencies( HCLUSTER hCls, cStrList *pList, LPCTSTR szInstanceNameOnly = NULL );

//
// Enumerates physical drives and its characteristics, optionaly filtering out only those
// that appear in the Sql Dependencies list.
// Empty list means no filtering. 
// BOTH pointers MUST be valid (no NULLS allowed)
//
DWORD EnumPhysicalDrives( HCLUSTER hCls, cStrList *pSqlDependencies, cDrvMap *pPhysicalDrives );

//
// Retrieves the owning node for the specific SQL instance
// The instance name is expected to be in the fully-qualified format
// i.e. <Virtual Server Name>\<Instance Name>
//
DWORD GetSqlNode( LPCWSTR szInstanceName, LPWSTR szNodeNameBuf, DWORD cbBufSize );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\setup\ocm\wizpage.cpp ===
//--------------------------------------------------------------------------

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
#endif

#ifndef _WIN32_WINNT		// Allow use of features specific to Windows NT 4 or later.
#define _WIN32_WINNT 0x0400		// Change this to the appropriate value to target Windows 98 and Windows 2000 or later.
#endif						

// Windows Header Files:
#include <windows.h>
#include <sddl.h>
#include <setupapi.h>
#include <lmcons.h>

#include "ocmanage.h"

#include "uddiocm.h"
#include "uddiinst.h"
#include "assert.h"
#include "..\shared\common.h"
#include "resource.h"
#include "objectpicker.h"
#include <shlobj.h>
#include <ntsecapi.h>

#include <iiscnfg.h>    // MD_ & IIS_MD_ defines
#ifndef MD_APPPOOL_IDENTITY_TYPE_LOCALSYSTEM
#define MD_APPPOOL_IDENTITY_TYPE_LOCALSYSTEM          0
#define MD_APPPOOL_IDENTITY_TYPE_LOCALSERVICE         1
#define MD_APPPOOL_IDENTITY_TYPE_NETWORKSERVICE       2
#define MD_APPPOOL_IDENTITY_TYPE_SPECIFICUSER         3
#endif

#define NOT_FIRST_OR_LAST_WIZARD_PAGE  false
#define FINAL_WIZARD_PAGE              true
#define WELCOME_WIZARD_PAGE            true

#ifndef STATUS_SUCCESS
#define STATUS_SUCCESS 0
#endif

//--------------------------------------------------------------------------

#define PASSWORD_LEN			PWLEN		// maximum password length
#define USERNAME_LEN			UNLEN		// maximum user name length
#define UDDI_MAXPROVNAME_LEN	255			// maximum UDDI Business Entity name length

#define UDDI_ILLEGALNAMECHARS	TEXT( "\":;/\\?*" )

extern HINSTANCE g_hInstance;
extern CUDDIInstall g_uddiComponents;

static CDBInstance g_dbLocalInstances;
static CDBInstance g_dbRemoteInstances;
static HWND  g_hPropSheet = NULL ;
static HFONT g_hTitleFont = 0;
static TCHAR g_szPwd[ PASSWORD_LEN + 1 ];

//
// "allowed" drive letters for a clustered environment scenario.
// Not used for a "regular" installation
//
static CLST_ALLOWED_DRIVES	gAllowedClusterDrives;

//
// This controls whether the Data Paths page will be shown in "simple" mode by default
//
static BOOL	g_bSimpleDatapathUI = TRUE;
static BOOL g_bResetPathFields	= FALSE;

//
// This controls whether we do clustering data collection. This variable is used
// to coordinate operation between pages
//
static BOOL g_bSkipClusterAnalysis	= FALSE;
static BOOL g_bOnActiveClusterNode	= TRUE;
static BOOL g_bPreserveDatabase		= FALSE;


static int  DisplayUDDIErrorDialog( HWND hDlg, UINT uMsgID, UINT uType = MB_OK | MB_ICONWARNING, DWORD dwError = 0 );
static void ParseUserAccount( PTCHAR szDomainAndUser, UINT uDomainAndUserSize, PTCHAR szUser, UINT uUserSize, PTCHAR szDomain, UINT uDomainSize, bool &bLocalAccount );
static BOOL GetWellKnownAccountName( WELL_KNOWN_SID_TYPE sidWellKnown, TCHAR *pwszName, DWORD *pcbSize );

BOOL ShowBrowseDirDialog( HWND hParent, LPCTSTR szTitle, LPTSTR szOutBuf );
int CALLBACK BrowseCallbackProc( HWND hwnd, UINT uMsg, LPARAM lParam, LPARAM lpData );

static BOOL GrantNetworkLogonRights( LPCTSTR pwszDomainUser );
//--------------------------------------------------------------------------

INT_PTR CALLBACK LocalDBInstanceDlgProc( HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam );
INT_PTR CALLBACK RemoteDBInstanceDlgProc( HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam );
INT_PTR CALLBACK SSLDlgProc( HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam );
INT_PTR CALLBACK ProviderInstanceDlgProc( HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam );
INT_PTR CALLBACK AddSvcDlgProc( HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam );
INT_PTR CALLBACK LoginDlgProc( HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam );
INT_PTR CALLBACK WizardSummaryDlgProc( HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam );
INT_PTR CALLBACK DataPathsDlgProc( HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam );
INT_PTR CALLBACK ExistingDBInstanceProc( HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam );
INT_PTR CALLBACK ClusterDataDlgProc(  HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam );

BOOL CALLBACK ConfirmPasswordDlgProc( HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam );

//--------------------------------------------------------------------------

static int DisplayUDDIErrorDialog( HWND hDlg, UINT uMsgID, UINT uType, DWORD dwError )
{
	TCHAR szMsg[ 1000 ];
	TCHAR szTitle[ 100 ];

	LoadString( g_hInstance, uMsgID, szMsg, sizeof( szMsg ) / sizeof( TCHAR ) );
	LoadString( g_hInstance, IDS_TITLE, szTitle, sizeof( szTitle ) / sizeof( TCHAR ) );
	tstring cMsg = szMsg;

	if( dwError )
	{
		LPVOID lpMsgBuf;
		FormatMessage( 
			FORMAT_MESSAGE_ALLOCATE_BUFFER | 
			FORMAT_MESSAGE_FROM_SYSTEM | 
			FORMAT_MESSAGE_IGNORE_INSERTS,
			NULL,
			dwError,
			MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
			(LPTSTR) &lpMsgBuf,
			0,
			NULL 
		);

		//
		// FIX: 718923: this used to throw an exception if lpMsgBuf was NULL
		//
		if( lpMsgBuf )
		{
			if ( cMsg.length() > 0 )
				cMsg.append( TEXT( " " ) );

			cMsg.append( (LPTSTR) lpMsgBuf );
			LocalFree( lpMsgBuf );
		}
	}

	return MessageBox( hDlg, cMsg.c_str(), szTitle, uType );
}

//--------------------------------------------------------------------------

inline int SkipWizardPage( const HWND hdlg )
{
	SetWindowLongPtr( hdlg, DWLP_MSGRESULT, -1 );
	return 1; //Must return 1 for the page to be skipped
}

//--------------------------------------------------------------------------

static HPROPSHEETPAGE CreatePage( 
	const int nID,
	const DLGPROC pDlgProc,
	const PTCHAR szTitle,
	const PTCHAR szSubTitle,
	bool bFirstOrLast )
{
	PROPSHEETPAGE Page;
	memset( &Page, 0, sizeof( PROPSHEETPAGE ) );

	Page.dwSize = sizeof( PROPSHEETPAGE );
	Page.dwFlags = PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE | PSP_USETITLE;
	// use PSP_USETITLE without specifying szTitle to keep from overwriting the default propery page title

	if ( bFirstOrLast )
	{
		Page.dwFlags |=	PSP_HIDEHEADER;
	}
	Page.hInstance = ( HINSTANCE )g_hInstance;
	Page.pszTemplate = MAKEINTRESOURCE( nID );
	Page.pfnDlgProc = pDlgProc;
	Page.pszHeaderTitle = _tcsdup( szTitle );
	Page.pszHeaderSubTitle = _tcsdup( szSubTitle );

	HPROPSHEETPAGE PageHandle = CreatePropertySheetPage( &Page );

	return PageHandle;
}

//--------------------------------------------------------------------------

DWORD AddUDDIWizardPages( const TCHAR *ComponentId, const WizardPagesType WhichOnes, SETUP_REQUEST_PAGES *SetupPages )
{
	ENTER();

	HPROPSHEETPAGE pPage = NULL;
	DWORD iPageIndex = 0 ;

	TCHAR szTitle[ 256 ];
	TCHAR szSubtitle[ 256 ];
	LoadString( g_hInstance, IDS_TITLE, szTitle, sizeof( szTitle ) / sizeof( TCHAR ) );

	//
	// only add our pages when the OCM asks for the "Late Pages"
	//
	if( WizPagesLate == WhichOnes )
	{
		if( SetupPages->MaxPages < 9 )
			return 9;

		//
		// add the local db instance selection page
		//
		LoadString( g_hInstance, IDS_DB_SUBTITLE, szSubtitle, sizeof( szSubtitle ) / sizeof( TCHAR ) );
		pPage = CreatePage( IDD_DB_INSTANCE, LocalDBInstanceDlgProc, szTitle, szSubtitle, NOT_FIRST_OR_LAST_WIZARD_PAGE );
		if ( NULL == pPage )
		{
			Log( TEXT( "***Unable to add the IDD_DB_INSTANCE Property Page" ) );
			return( (DWORD)( -1 ) );
		}

		SetupPages->Pages[iPageIndex] =	pPage;
		iPageIndex++;

		//
		// add the hidden clustering "data collector" page
		//
		pPage = CreatePage( IDD_CLUSTDATA, ClusterDataDlgProc, TEXT( "" ), TEXT( "" ), NOT_FIRST_OR_LAST_WIZARD_PAGE );
		if ( NULL == pPage )
		{
			Log( TEXT( "***Unable to add the IDD_CLUSTDATA Property Page" ) );
			return( (DWORD)( -1 ) );
		}

		SetupPages->Pages[iPageIndex] =	pPage;
		iPageIndex++;

		//
		// add the "uddi instance found" info page
		//
		LoadString( g_hInstance, IDS_EXISTINGDB_SUBTITLE, szSubtitle, sizeof( szSubtitle ) / sizeof( TCHAR ) );
		pPage = CreatePage( IDD_EXISTING_DBINSTANCE, ExistingDBInstanceProc, szTitle, szSubtitle, NOT_FIRST_OR_LAST_WIZARD_PAGE );
		if ( NULL == pPage )
		{
			Log( TEXT( "***Unable to add the IDD_EXISTING_DBINSTANCE Property Page" ) );
			return( (DWORD)( -1 ) );
		}

		SetupPages->Pages[iPageIndex] =	pPage;
		iPageIndex++;


		//
		// add the SSL page
		//
		LoadString( g_hInstance, IDS_SSL_SUBTITLE, szSubtitle, sizeof( szSubtitle ) / sizeof( TCHAR ) );
		pPage = CreatePage( IDD_SSL, SSLDlgProc, szTitle, szSubtitle, NOT_FIRST_OR_LAST_WIZARD_PAGE );
		if ( NULL == pPage )
		{
			Log( TEXT( "***Unable to add the IDD_SSL Property Page" ) );
			return( (DWORD)( -1 ) );
		}

		SetupPages->Pages[iPageIndex] =	pPage;
		iPageIndex++;

		//
		// add the remote db instance selection page
		//
		LoadString( g_hInstance, IDS_REMOTE_DB_SUBTITLE, szSubtitle, sizeof( szSubtitle ) / sizeof( TCHAR ) );
		pPage = CreatePage( IDD_REMOTE_DB, RemoteDBInstanceDlgProc, szTitle, szSubtitle, NOT_FIRST_OR_LAST_WIZARD_PAGE );
		if ( NULL == pPage )
		{
			Log( TEXT( "***Unable to add the IDD_REMOTE_DB Property Page" ) );
			return( (DWORD)( -1 ) );
		}

		SetupPages->Pages[iPageIndex] =	pPage;
		iPageIndex++;

		//
		// add the data file path(s) selection page
		//
		LoadString( g_hInstance, IDS_FILEPATHS_SUBTITLE, szSubtitle, sizeof( szSubtitle ) / sizeof( TCHAR ) );
		pPage = CreatePage( IDD_DATAPATHS, DataPathsDlgProc, szTitle, szSubtitle, NOT_FIRST_OR_LAST_WIZARD_PAGE );
		if ( NULL == pPage )
		{
			Log( TEXT( "***Unable to add the IDD_DATAPATHS Property Page" ) );
			return( (DWORD)( -1 ) );
		}

		SetupPages->Pages[iPageIndex] =	pPage;
		iPageIndex++;

		//
		// add the authentication page
		//
		LoadString( g_hInstance, IDS_LOGIN_SUBTITLE, szSubtitle, sizeof( szSubtitle ) / sizeof( TCHAR ) );
		pPage = CreatePage( IDD_LOGIN, LoginDlgProc, szTitle, szSubtitle, NOT_FIRST_OR_LAST_WIZARD_PAGE );
		if ( NULL == pPage )
		{
			Log( TEXT( "***Unable to add the IDD_LOGIN Property Page" ) );
			return( (DWORD)( -1 ) );
		}

		SetupPages->Pages[iPageIndex] =	pPage;
		iPageIndex++;


		//
		// add the UDDI Provider Name page
		//
		LoadString( g_hInstance, IDS_UDDIPROV_SUBTITLE, szSubtitle, sizeof( szSubtitle ) / sizeof( TCHAR ) );
		pPage = CreatePage( IDD_SITE_NAME, ProviderInstanceDlgProc, szTitle, szSubtitle, NOT_FIRST_OR_LAST_WIZARD_PAGE );
		if ( NULL == pPage )
		{
			Log( TEXT( "***Unable to add the IDD_SITE_NAME Property Page" ) );
			return( (DWORD)( -1 ) );
		}

		SetupPages->Pages[iPageIndex] =	pPage;
		iPageIndex++;

		//
		// add the UDDI "Add Service / Update AD"
		//
		LoadString( g_hInstance, IDS_UDDIADDSVC_SUBTITLE, szSubtitle, sizeof( szSubtitle ) / sizeof( TCHAR ) );
		pPage = CreatePage( IDD_ADD_SERVICES, AddSvcDlgProc, szTitle, szSubtitle, NOT_FIRST_OR_LAST_WIZARD_PAGE );
		if ( NULL == pPage )
		{
			Log( TEXT( "***Unable to add the IDD_ADD_SERVICES Property Page" ) );
			return( (DWORD)( -1 ) );
		}

		SetupPages->Pages[iPageIndex] =	pPage;
		iPageIndex++;

		//
		// add the wizard summary page
		//
		/*
		LoadString( g_hInstance, IDS_WIZARD_SUMMARY_SUBTITLE, szSubtitle, sizeof( szSubtitle ) / sizeof( TCHAR ) );
		pPage = CreatePage( IDD_WIZARD_SUMMARY, WizardSummaryDlgProc, szTitle, szSubtitle, NOT_FIRST_OR_LAST_WIZARD_PAGE );
		//pPage = CreatePage( IDD_WIZARD_SUMMARY, WizardSummaryDlgProc, szTitle, szSubtitle, FINAL_WIZARD_PAGE );
		if ( NULL == pPage )
		{
			Log( TEXT( "***Unable to add the IDD_LOGIN Property Page" ) );
			return( ( DWORD )( -1 ) );
		}

		SetupPages->Pages[iPageIndex] =	pPage;
		iPageIndex++;
		*/
	}

	return iPageIndex;
}

//--------------------------------------------------------------------------

INT_PTR CALLBACK LocalDBInstanceDlgProc( HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam )
{	
	switch( msg )
	{
		case WM_INITDIALOG:
		{
			//
			// start off with MSDE to not install
			//
			g_uddiComponents.SetInstallLevel( UDDI_MSDE, UDDI_NOACTION );

			//
			// get a handle to the list box
			//
			HWND hwndList =	GetDlgItem( hDlg, IDC_LIST_DB_INSTANCES );

			//
			// Get the list of SQL 2000 ( only ) database instances and, if any are found, populate the list box
			//
			LONG iRet = g_dbLocalInstances.GetInstalledDBInstanceNames();
			if( ERROR_SUCCESS == iRet )
			{
				TCHAR szBuffer[ 50 ];
				for( int i = 0;	i <	g_dbLocalInstances.GetInstanceCount(); i++ )
				{
					if( g_dbLocalInstances.GetInstanceName( i, szBuffer, 50 ) )
					{
						DWORD iIndex = (DWORD) SendMessage( hwndList, CB_ADDSTRING, 0, (LPARAM)szBuffer );
						SendMessage( hwndList, CB_SETITEMDATA, (WPARAM) iIndex, (LPARAM)i );
					}
				}
			}

			//
			// Is SQL on this box?
			//
			if( g_dbLocalInstances.GetInstanceCount() > 0 )
			{
				//
				// select the SQL radio button
				//
				CheckRadioButton( hDlg,
					IDC_RADIO_INSTALL_MSDE,
					IDC_RADIO_USE_EXISTING_INSTANCE,
					IDC_RADIO_USE_EXISTING_INSTANCE );

				//
				// is there an instance named "UDDI" on this machine?
				//
				// If NO, then select the 1st entry in the combo box.
				//
				// If YES, then select the "UDDI" entry from the combo box.  Also, disable
				// the option to select MSDE.
				//
				// FIX: 763442 There was a problem with the test to determine if a SQL Instance named
				// "UDDI" was installed.
				// 
				// BUGBUG:CREEVES This function is named improperly Is...() should return a bool
				//
				if( g_dbLocalInstances.IsInstanceInstalled( UDDI_MSDE_INSTANCE_NAME ) >= 0 )
				{
					//
					// Found a SQL Instance named "UDDI"
					//

					//
					// Disable the MSDE radio, as there is another UDDI instance found
					//
					EnableWindow( GetDlgItem( hDlg, IDC_RADIO_INSTALL_MSDE ), false );
					SendMessage( hwndList, CB_SETCURSEL, 0, 0 );
				}
				else
				{
					//
					// A SQL Instance named "UDDI" was not found
					//
					SendMessage( hwndList, CB_SELECTSTRING, (WPARAM) -1, (LPARAM) UDDI_MSDE_INSTANCE_NAME );
				}
			}
			else
			{
				//
				// there are no sql instances on this machine
				// disable the SQL radio button and list box
				//
				EnableWindow( GetDlgItem( hDlg, IDC_LIST_DB_INSTANCES ), false );
				EnableWindow( GetDlgItem( hDlg, IDC_RADIO_USE_EXISTING_INSTANCE ), false );
				//
				// select the MSDE radio button
				//
				CheckRadioButton( hDlg,
					IDC_RADIO_INSTALL_MSDE,
					IDC_RADIO_USE_EXISTING_INSTANCE,
					IDC_RADIO_INSTALL_MSDE );
			}

			//
			// find out if our instance of MSDE ( SqlRun08.msi ) is already used on this machine
			//
			bool bIsSqlRun08AlreadyUsed = false;
			if( !IsSQLRun08AlreadyUsed( &bIsSqlRun08AlreadyUsed ) )
			{
				Log( TEXT( "IsSQLRun08AlreadyUsed() failed" ) );
				break;
			}

			if( bIsSqlRun08AlreadyUsed )
			{
				//
				// MSDE is already installed, so disable the MSDE radio button
				//
				EnableWindow( GetDlgItem( hDlg, IDC_RADIO_INSTALL_MSDE ), false );
			}
			else
			{
				//
				// MSDE is NOT on this box, but before we select the MSDE radio button
				// we want to see if there is a SQL instance named UDDI, 
				// if so we'll make that the default.
				//
				if( -1 == g_dbLocalInstances.IsInstanceInstalled( UDDI_MSDE_INSTANCE_NAME ) )
				{
					CheckRadioButton( hDlg,
						IDC_RADIO_INSTALL_MSDE,
						IDC_RADIO_USE_EXISTING_INSTANCE,
						IDC_RADIO_INSTALL_MSDE );
				}
			}

			//
			// enable/disable the list box
			//
			EnableWindow( GetDlgItem( hDlg, IDC_LIST_DB_INSTANCES ), IsDlgButtonChecked( hDlg, IDC_RADIO_USE_EXISTING_INSTANCE ) );
		}
		break;

		case WM_COMMAND:

			//
			// someone clicked a radio button:
			//
			if( LOWORD( wParam ) == IDC_RADIO_INSTALL_MSDE || LOWORD( wParam )	== IDC_RADIO_USE_EXISTING_INSTANCE )
			{
				if( HIWORD( wParam ) == BN_CLICKED )
				{
					// disable the list box if its radio button is not clicked
					EnableWindow( GetDlgItem( hDlg, IDC_LIST_DB_INSTANCES ), IsDlgButtonChecked( hDlg, IDC_RADIO_USE_EXISTING_INSTANCE ) );
				}
			}
			break;

		case WM_NOTIFY:
		{
			switch( ( ( NMHDR * )lParam )->code )
			{
				//
				// this is called once when the page is created
				//
				case PSN_SETACTIVE:
				{
					//
					// this page needed only if we are installing the DB
					//
					g_uddiComponents.UpdateAllInstallLevel();

					//
					// Set the flag for ClusterDataProc so that when the user clicks "Next"
					// it won't skip the data collection step
					//
					g_bSkipClusterAnalysis = FALSE;

					if( g_uddiComponents.IsInstalling( UDDI_DB ) )
					{
						PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_NEXT | PSWIZB_BACK );
						SetWindowLongPtr( hDlg, DWLP_MSGRESULT, 0 );
						return 1;
					}
					else
					{
						return SkipWizardPage( hDlg );
					}
				}

				//
				// this message is sent when the user presses the "next" button
				//
				case PSN_WIZNEXT:
				{
					//
					// are we installing MSDE?
					//
					bool bInstallMSDE = ( BST_CHECKED == IsDlgButtonChecked( hDlg, IDC_RADIO_INSTALL_MSDE ) );
					if( bInstallMSDE )
					{
						//
						// check to see if SqlRun08 is already on this box
						//
						bool bIsSqlRun08AlreadyUsed = false;
						IsSQLRun08AlreadyUsed( &bIsSqlRun08AlreadyUsed );
						if( bIsSqlRun08AlreadyUsed )
						{
							DisplayUDDIErrorDialog( hDlg, IDS_MSDE_ALREADY_USED );
							SetWindowLongPtr( hDlg,DWLP_MSGRESULT, 1 );
							return 1; // to keep the focus on this page
						}

						//
						// set the MSDE instance name to "UDDI"
						//
						g_uddiComponents.SetDBInstanceName( UDDI_LOCAL_COMPUTER, UDDI_MSDE_INSTANCE_NAME, UDDI_INSTALLING_MSDE, false );

						//
						// set MSDE to install
						//
						g_uddiComponents.SetInstallLevel( UDDI_MSDE, UDDI_INSTALL, TRUE );

						//
						// exit this property page
						//
						SetWindowLongPtr( hDlg, DWLP_MSGRESULT, 0 );
						return 1; // done
					}
					//
					// we are using an existing instance of SQL
					//
					else
					{
						//
						// get a handle to the combobox
						//
						HWND hwndList =	GetDlgItem( hDlg, IDC_LIST_DB_INSTANCES );

						//
						// get the index of the string that is currently selected in the combobox
						//
						int	nItem =	( int ) SendMessage( hwndList,	CB_GETCURSEL, 0, 0 );
	
						//
						// if no string is selected, raise an error
						//
						if( CB_ERR == nItem )
						{
							DisplayUDDIErrorDialog( hDlg, IDS_NO_INSTANCE_MSG );
							SetWindowLongPtr( hDlg, DWLP_MSGRESULT, 1 );
							return 1; // to keep the focus on this page
						}

						//
						// get the index into the instance array of the selected item
						//
						int nInstanceIndex = ( int ) SendMessage( hwndList, CB_GETITEMDATA, nItem, ( LPARAM ) 0 );

						//
						// Now verify that the selected instance meets our requirements
						//
						if( CompareVersions( g_dbLocalInstances.m_dbinstance[ nInstanceIndex ].cSPVersion.c_str(), 
											 MIN_SQLSP_VERSION ) < 0 )
						{
							DisplayUDDIErrorDialog( hDlg, IDS_SQLSPVERSION_TOO_LOW );
							SetWindowLongPtr( hDlg, DWLP_MSGRESULT, 1 );
							return 1; // to keep the focus on this page
						}

						//
						// set the instance name
						//
						g_uddiComponents.SetDBInstanceName( 
							g_dbLocalInstances.m_dbinstance[ nInstanceIndex ].cComputerName.c_str(),
							g_dbLocalInstances.m_dbinstance[ nInstanceIndex ].cSQLInstanceName.c_str(),
							UDDI_NOT_INSTALLING_MSDE,
							g_dbLocalInstances.m_dbinstance[ nInstanceIndex ].bIsCluster );

						//
						// Set MSDE to NOT INSTALL
						//
						g_uddiComponents.SetInstallLevel( UDDI_MSDE, UDDI_NOACTION );

						//
						// exit this property page
						//
						SetWindowLongPtr( hDlg, DWLP_MSGRESULT, 0 );
						return 1; // done
					}
				}

				case PSN_QUERYCANCEL:
				{
					SetWindowLongPtr( hDlg, DWLP_MSGRESULT, 0 );
					return 1;
				}
			}
		}
	}

	return 0;
}

//--------------------------------------------------------------------------

INT_PTR CALLBACK SSLDlgProc( HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam )
{
	switch( msg )
	{
		case WM_INITDIALOG:
			//
			// turn SSL on by default
			//
			CheckRadioButton( hDlg, IDC_SSL_YES, IDC_SSL_NO, IDC_SSL_YES );
			break;

		case WM_COMMAND:
			break;

		case WM_NOTIFY:
		{
			switch( ( ( NMHDR * )lParam )->code )
			{
				//
				// this is called once when the page is created
				//
				case PSN_SETACTIVE:
				{
					//
					// this page needed only if we are installing the DB
					//
					g_uddiComponents.UpdateAllInstallLevel();
					if( g_uddiComponents.IsInstalling( UDDI_DB ) && g_bOnActiveClusterNode && !g_bPreserveDatabase )
					{
						PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_NEXT | PSWIZB_BACK );
						SetWindowLongPtr( hDlg, DWLP_MSGRESULT, 0 );
						return 1;
					}
					else
					{
						return SkipWizardPage( hDlg );
					}
				}

				case PSN_WIZNEXT:
				{
					//
					// set the SSL mode by adding a property to the DB setup command line
					//
					bool bUseSSL = ( BST_CHECKED == IsDlgButtonChecked( hDlg, IDC_SSL_YES ) );
					g_uddiComponents.AddProperty( UDDI_DB, TEXT( "SSL" ), bUseSSL ? 1 : 0 );

					SetWindowLongPtr( hDlg, DWLP_MSGRESULT, 0 );
					return 1;
				}

				case PSN_QUERYCANCEL:
				{
					SetWindowLongPtr( hDlg, DWLP_MSGRESULT, 0 );
					return 1;
				}
			}
		}
	}

	return 0;
}

//
//--------------------------------------------------------------------------
//
INT_PTR CALLBACK ProviderInstanceDlgProc( HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam )
{
	switch( msg )
	{
		case WM_INITDIALOG:
			//
			// set the maximum edit field length
			//
			SendMessage( GetDlgItem( hDlg, IDC_SITE_NAME  ), EM_LIMITTEXT, ( WPARAM ) UDDI_MAXPROVNAME_LEN, 0 );
			break;

		case WM_COMMAND:
			break;

		case WM_NOTIFY:
		{
			switch( ( ( NMHDR * )lParam )->code )
			{
				//
				// this is called once when the page is created
				//
				case PSN_SETACTIVE:
				{
					//
					// this page needed only if we are installing the DB
					//
					g_uddiComponents.UpdateAllInstallLevel();
					if( g_uddiComponents.IsInstalling( UDDI_DB ) && g_bOnActiveClusterNode  && !g_bPreserveDatabase )
					{
						PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_NEXT | PSWIZB_BACK );
						SetWindowLongPtr( hDlg, DWLP_MSGRESULT, 0 );
						return 1;
					}
					else
					{
						return SkipWizardPage( hDlg );
					}
				}

				case PSN_WIZNEXT:
				{
					//
					// set the Provider Instance Name by adding a property to the DB setup command line
					//
					TCHAR buf[ UDDI_MAXPROVNAME_LEN + 1 ];
					ZeroMemory( buf, sizeof buf );
					
					int iChars = GetWindowText( GetDlgItem( hDlg, IDC_SITE_NAME ), buf, ( sizeof( buf ) / sizeof( buf[0] ) ) -1 );
					if( 0 == iChars )
					{
						DisplayUDDIErrorDialog( hDlg, IDS_ZERO_LEN_PROVIDER_NAME );
						SetFocus( GetDlgItem( hDlg, IDC_SITE_NAME ) );
						SetWindowLongPtr( hDlg, DWLP_MSGRESULT, 1 );
						return 1; // to keep the focus on this page
					}

					//
					// Now verify that the instance name does not contain illegal characters
					//
					TCHAR *pIllegalChar = _tcspbrk( buf, UDDI_ILLEGALNAMECHARS );
					if ( pIllegalChar )
					{
						DisplayUDDIErrorDialog( hDlg, IDS_UDDI_ILLEGALCHARACTERS );
						SetFocus( GetDlgItem( hDlg, IDC_SITE_NAME ) );
						SetWindowLongPtr( hDlg, DWLP_MSGRESULT, 1 );
						return 1; // to keep the focus on this page
					}

					g_uddiComponents.AddProperty( UDDI_DB, PROPKEY_UDDIPROVIDER, buf );

					SetWindowLongPtr( hDlg, DWLP_MSGRESULT, 0 );
					return 1;
				}

				case PSN_QUERYCANCEL:
				{
					SetWindowLongPtr( hDlg, DWLP_MSGRESULT, 0 );
					return 1;
				}
			}
		}
	}

	return 0;
}

//
//-----------------------------------------------------------------------------------
//
void ToggleDatapathUI ( HWND hDlg, BOOL bToSimple )
{
	TCHAR szBuf[ 256 ];

	if ( bToSimple )
	{
		//
		// Hide fields
		//
		ShowWindow( GetDlgItem( hDlg, IDC_COREPATH_1  ), SW_HIDE );
		ShowWindow( GetDlgItem( hDlg, IDC_COREPATH_2  ), SW_HIDE );
		ShowWindow( GetDlgItem( hDlg, IDC_JRNLPATH  ), SW_HIDE );
		ShowWindow( GetDlgItem( hDlg, IDC_STAGINGPATH  ), SW_HIDE );
		ShowWindow( GetDlgItem( hDlg, IDC_XLOGPATH  ), SW_HIDE );

		//
		// Hide buttons
		//
		ShowWindow( GetDlgItem( hDlg, IDC_BROWSECOREPATH1  ), SW_HIDE );
		ShowWindow( GetDlgItem( hDlg, IDC_BROWSECOREPATH2  ), SW_HIDE );
		ShowWindow( GetDlgItem( hDlg, IDC_BROWSEJRNLPATH  ), SW_HIDE );
		ShowWindow( GetDlgItem( hDlg, IDC_BROWSESTAGINGPATH  ), SW_HIDE );
		ShowWindow( GetDlgItem( hDlg, IDC_BROWSEXLOGPATH  ), SW_HIDE );
		ShowWindow( GetDlgItem( hDlg, IDC_LESS_BTN  ), SW_HIDE );
		ShowWindow( GetDlgItem( hDlg, IDC_MORE_BTN  ), SW_SHOW );

		//
		// Hide labels and adjust the text
		//
		ShowWindow( GetDlgItem( hDlg, IDC_STATIC_C1  ), SW_HIDE );
		ShowWindow( GetDlgItem( hDlg, IDC_STATIC_C2  ), SW_HIDE );
		ShowWindow( GetDlgItem( hDlg, IDC_STATIC_JRNL  ), SW_HIDE );
		ShowWindow( GetDlgItem( hDlg, IDC_STATIC_STG  ), SW_HIDE );
		ShowWindow( GetDlgItem( hDlg, IDC_STATIC_XLOG  ), SW_HIDE );
		
		LoadString( g_hInstance, IDS_LABEL_SYSPATHSIMPLE, szBuf, (sizeof szBuf / sizeof szBuf[0]) - 1 );
		SetDlgItemText( hDlg, IDC_STATIC_SYS, szBuf );
	}
	else
	{
		//
		// Show fields
		//
		ShowWindow( GetDlgItem( hDlg, IDC_COREPATH_1  ), SW_SHOW );
		ShowWindow( GetDlgItem( hDlg, IDC_COREPATH_2  ), SW_SHOW );
		ShowWindow( GetDlgItem( hDlg, IDC_JRNLPATH  ), SW_SHOW );
		ShowWindow( GetDlgItem( hDlg, IDC_STAGINGPATH  ), SW_SHOW );
		ShowWindow( GetDlgItem( hDlg, IDC_XLOGPATH  ), SW_SHOW );

		//
		// Show buttons
		//
		ShowWindow( GetDlgItem( hDlg, IDC_MORE_BTN  ), SW_HIDE );
		ShowWindow( GetDlgItem( hDlg, IDC_LESS_BTN  ), SW_SHOW );
		ShowWindow( GetDlgItem( hDlg, IDC_BROWSECOREPATH1  ), SW_SHOW );
		ShowWindow( GetDlgItem( hDlg, IDC_BROWSECOREPATH2  ), SW_SHOW );
		ShowWindow( GetDlgItem( hDlg, IDC_BROWSEJRNLPATH  ), SW_SHOW );
		ShowWindow( GetDlgItem( hDlg, IDC_BROWSESTAGINGPATH  ), SW_SHOW );
		ShowWindow( GetDlgItem( hDlg, IDC_BROWSEXLOGPATH  ), SW_SHOW );
		
		//
		// Show labels and adjust the text
		//
		ShowWindow( GetDlgItem( hDlg, IDC_STATIC_C1  ), SW_SHOW );
		ShowWindow( GetDlgItem( hDlg, IDC_STATIC_C2  ), SW_SHOW );
		ShowWindow( GetDlgItem( hDlg, IDC_STATIC_JRNL  ), SW_SHOW );
		ShowWindow( GetDlgItem( hDlg, IDC_STATIC_STG  ), SW_SHOW );
		ShowWindow( GetDlgItem( hDlg, IDC_STATIC_XLOG  ), SW_SHOW );

		LoadString( g_hInstance, IDS_LABEL_SYSPATH_ADV, szBuf, (sizeof szBuf / sizeof szBuf[0]) - 1 );
		SetDlgItemText( hDlg, IDC_STATIC_SYS, szBuf );
	}
}


void SetAllDatapathFields ( HWND hDlg, LPCTSTR szValue )
{
	SetDlgItemText( hDlg, IDC_SYSPATH, szValue );
	SetDlgItemText( hDlg, IDC_COREPATH_1, szValue );
	SetDlgItemText( hDlg, IDC_COREPATH_2, szValue );
	SetDlgItemText( hDlg, IDC_JRNLPATH, szValue );
	SetDlgItemText( hDlg, IDC_STAGINGPATH, szValue );
	SetDlgItemText( hDlg, IDC_XLOGPATH, szValue );
}


INT_PTR CALLBACK ClusterDataDlgProc(  HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam )
{
	switch( msg )
	{
		case WM_NOTIFY:
		{
			switch( ( ( NMHDR * )lParam )->code )
			{
				//
				// this is called once when the page is created
				//
				case PSN_SETACTIVE:
				{
					bool bSuppressInactiveWarning = false;

					//
					// We ALWAYS skip the page, but if this is a DB installation, then we
					// also need to do some data collection here
					//
					g_uddiComponents.UpdateAllInstallLevel();
					if( !g_bSkipClusterAnalysis )
					{
						//
						// Here we do our cluster environment checks
						//
						gAllowedClusterDrives.driveCount = 0;
						g_bOnActiveClusterNode = TRUE;
						
						//
						// Make sure we keep out installation properties in sync with the
						// cluster configuration
						//
						g_uddiComponents.DeleteProperty( UDDI_DB, PROPKEY_CLUSTERNODETYPE );
						g_uddiComponents.DeleteProperty( UDDI_WEB, PROPKEY_CLUSTERNODETYPE );

						if ( g_uddiComponents.IsClusteredDBInstance() )
						{
							//
							// First, try connecting to the database
							// If the database already exists, then just leave it 
							// intact and skip the drive enumeration process
							//
							TCHAR	szVerBuf[ 256 ] = {0};
							size_t	cbVerBuf = DIM( szVerBuf ) - 1;

							HCURSOR hcrHourglass = LoadCursor( NULL, IDC_WAIT );
							HCURSOR hcrCurr = SetCursor( hcrHourglass );

							HRESULT hr = GetDBSchemaVersion( g_uddiComponents.GetFullDBInstanceName(), 
															 szVerBuf, cbVerBuf );

							SetCursor( hcrCurr );

							if ( SUCCEEDED( hr ) && _tcslen( szVerBuf ) )
							{
								g_bPreserveDatabase = TRUE;
								int iRes = DisplayUDDIErrorDialog( hDlg, IDS_DB_EXISTS, MB_YESNO | MB_ICONQUESTION | MB_DEFBUTTON2 );
								if ( iRes == IDNO )
								{
									// force user to the instance selection page
									SetWindowLongPtr( hDlg, DWLP_MSGRESULT, IDD_DB_INSTANCE );
									return 1;
								}

								bSuppressInactiveWarning = true;
							}
							else
							{
								g_bPreserveDatabase = FALSE;	
							}

							cDrvMap::size_type nDrivesFound = 0;

							HCLUSTER hCls = OpenCluster( NULL );
							if ( !hCls )
							{
								DisplayUDDIErrorDialog( hDlg, IDS_CANTOPENCLUSTER );
								
								// force user to the previous page
								SetWindowLongPtr( hDlg, DWLP_MSGRESULT, IDD_DB_INSTANCE );
								return 1;
							}

							hcrCurr = SetCursor( hcrHourglass );

							//
							// now we will format the instance name and collect the data
							//
							try
							{
								TCHAR	 szComputerName[ 256 ] = {0};
								WCHAR	 szNode[ 256 ] = {0};
								DWORD	 dwErr = ERROR_SUCCESS;
								DWORD	 cbComputerName = DIM( szComputerName );
								DWORD	 cbNode = DIM( szNode );
								cStrList cDependencies;
								cDrvMap	 cPhysicalDrives;

								tstring sServerName = g_uddiComponents.GetDBComputerName();
								tstring sInstance = g_uddiComponents.GetDBInstanceName();

								if ( !_tcsicmp( sInstance.c_str(), DEFAULT_SQL_INSTANCE_NAME ) )
									sInstance = DEFAULT_SQL_INSTANCE_NATIVE;

								sServerName += TEXT( "\\" );
								sServerName += sInstance;

								dwErr = GetSqlNode( sServerName.c_str(), szNode, cbNode );
								if ( dwErr != ERROR_SUCCESS )
									throw dwErr;

								GetComputerName( szComputerName, &cbComputerName );

								//
								// Are we on the same node as the Sql server instance?
								//
								g_bOnActiveClusterNode = ( !_tcsicmp( szComputerName, szNode ) );
								
								gAllowedClusterDrives.driveCount = 0;

								//
								// if we are installing database components,
								// then we will need to go one step further and analyse
								// the drive dependencies etc.
								//
								if ( g_bOnActiveClusterNode )
								{
									if ( g_uddiComponents.IsInstalling( UDDI_DB ) && !g_bPreserveDatabase )
									{
										//
										// We are on an active (owning) node. Let's collect the drive data
										//
										dwErr = EnumSQLDependencies( hCls, &cDependencies, sServerName.c_str() );
										if ( dwErr != ERROR_SUCCESS )
											throw dwErr;
										
										dwErr = EnumPhysicalDrives( hCls, &cDependencies, &cPhysicalDrives );
										if ( dwErr != ERROR_SUCCESS )
											throw dwErr;
					
										int idx = 0;
										nDrivesFound = cPhysicalDrives.size();
										if ( nDrivesFound == 0 )
										{
											DisplayUDDIErrorDialog( hDlg, IDS_NOCLUSTERRESAVAIL );
											
											// force user to the previous page
											SetWindowLongPtr( hDlg, DWLP_MSGRESULT, IDD_DB_INSTANCE );
											return 1;
										}

										//
										// We are in an active node, make sure the user wants to continue
										//
										int iRes = DisplayUDDIErrorDialog( hDlg, IDS_ACTIVENODE_DB, MB_YESNO | MB_ICONQUESTION | MB_DEFBUTTON2 );
										if ( iRes == IDNO )
										{
											// force user to the instance selection page
											SetWindowLongPtr( hDlg, DWLP_MSGRESULT, IDD_DB_INSTANCE );
											return 1;
										}

										for ( cDrvIterator it = cPhysicalDrives.begin(); it != cPhysicalDrives.end(); it++ )
										{
											gAllowedClusterDrives.drives[ idx ] = it->second.sDriveLetter;
											idx++;
										}
										gAllowedClusterDrives.driveCount = idx;
									}

									g_uddiComponents.AddProperty( UDDI_DB, PROPKEY_CLUSTERNODETYPE, PROPKEY_ACTIVENODE );
									g_uddiComponents.AddProperty( UDDI_WEB, PROPKEY_CLUSTERNODETYPE, PROPKEY_ACTIVENODE );
								}
								else
								{
									if ( g_uddiComponents.IsInstalling( UDDI_DB ) &&
										 !bSuppressInactiveWarning )
									{
										//
										// We are on a passive node. Make a note
										//
										int iRes = DisplayUDDIErrorDialog( hDlg, IDS_PASSIVENODE_DB, MB_YESNO | MB_ICONQUESTION | MB_DEFBUTTON2 );
										if ( iRes == IDNO )
										{
											// force user to the instance selection page
											SetWindowLongPtr( hDlg, DWLP_MSGRESULT, IDD_DB_INSTANCE );
											return 1;
										}
									}

									g_uddiComponents.AddProperty( UDDI_DB, PROPKEY_CLUSTERNODETYPE, PROPKEY_PASSIVENODE );
									g_uddiComponents.AddProperty( UDDI_WEB, PROPKEY_CLUSTERNODETYPE, PROPKEY_PASSIVENODE );
								}
							}
							catch (...)
							{
								DisplayUDDIErrorDialog( hDlg, IDS_GENERALCLUSTERR );
								
								// force user to the previous page (SSL)
								SetWindowLongPtr( hDlg, DWLP_MSGRESULT, IDD_SSL );
								return 1;
							}
							
							CloseCluster( hCls );
							SetCursor( hcrCurr );

							//
							// Finally, signal the next page that the data has changed
							//
							g_bResetPathFields = TRUE;
						}
						else
						{
							gAllowedClusterDrives.driveCount = -1;
							g_bPreserveDatabase = FALSE;	
						}

						//
						// Finally, set the flag to indicate that the job is done
						//
						g_bSkipClusterAnalysis = TRUE;
					}

					return SkipWizardPage( hDlg );
				}

				case PSN_QUERYCANCEL:
				{
					SetWindowLongPtr( hDlg, DWLP_MSGRESULT, 0 );
					return 1;
				}
			}
		}
	}

	return 0;
}


INT_PTR CALLBACK DataPathsDlgProc( HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam )
{
	tstring	sTmpString;
	BOOL	bRes = FALSE;
	TCHAR	szTmpPath[ MAX_PATH + 1 ];
	TCHAR	szTmpTitle[ 256 ];

	switch( msg )
	{
		case WM_INITDIALOG:
			//
			// set the maximum edit field length
			//
			SendMessage( GetDlgItem( hDlg, IDC_SYSPATH  ), EM_LIMITTEXT, ( WPARAM ) MAX_PATH, 0 );
			SendMessage( GetDlgItem( hDlg, IDC_COREPATH_1  ), EM_LIMITTEXT, ( WPARAM ) MAX_PATH, 0 );
			SendMessage( GetDlgItem( hDlg, IDC_COREPATH_2  ), EM_LIMITTEXT, ( WPARAM ) MAX_PATH, 0 );
			SendMessage( GetDlgItem( hDlg, IDC_JRNLPATH  ), EM_LIMITTEXT, ( WPARAM ) MAX_PATH, 0 );
			SendMessage( GetDlgItem( hDlg, IDC_STAGINGPATH  ), EM_LIMITTEXT, ( WPARAM ) MAX_PATH, 0 );
			SendMessage( GetDlgItem( hDlg, IDC_XLOGPATH  ), EM_LIMITTEXT, ( WPARAM ) MAX_PATH, 0 );

			// 
			// are we in a clustered environment ?
			//
			if ( g_uddiComponents.IsClusteredDBInstance() )
			{
				if ( gAllowedClusterDrives.driveCount > 0 )
				{
					sTmpString = gAllowedClusterDrives.drives[ 0 ];
					sTmpString += TEXT( "\\uddi\\data" );
				}
				else 
				{
					//
					// falling back on a default data path. This should never happen,
					// this is just a safety net for us
					//
					sTmpString = g_uddiComponents.GetDefaultDataPath();
				}
			}
			else
				sTmpString = g_uddiComponents.GetDefaultDataPath();

			//
			// Set the fields
			//
			SetAllDatapathFields( hDlg, sTmpString.c_str() );

			//
			// now hide the controls and set the dialog into the default mode
			//
			if ( g_bSimpleDatapathUI )
				ToggleDatapathUI( hDlg, TRUE );
			else
				ToggleDatapathUI( hDlg, FALSE );

			break;

		case WM_COMMAND:
			switch( LOWORD( wParam ) )
			{
				case IDC_MORE_BTN:		// toggle to the "advanced mode"
					{
						g_bSimpleDatapathUI = FALSE;
						ToggleDatapathUI( hDlg, FALSE );
					}
					break;

				case IDC_LESS_BTN:		// toggle to the "simple mode"
					{
						g_bSimpleDatapathUI = TRUE;
						ToggleDatapathUI( hDlg, TRUE );
					}
					break;


				case IDC_BROWSESYSPATH:
					{
						LoadString( g_hInstance, IDS_PROMPT_SELSYSDATAPATH, szTmpTitle, sizeof szTmpTitle / sizeof szTmpTitle[0] );
						bRes = ShowBrowseDirDialog( hDlg, szTmpTitle, szTmpPath );
						if ( bRes )
						{
							SetDlgItemText( hDlg, IDC_SYSPATH, szTmpPath );
							if ( g_bSimpleDatapathUI )
								SetAllDatapathFields( hDlg, szTmpPath );
						}

						break;
					}

				case IDC_BROWSECOREPATH1:
					{
						LoadString( g_hInstance, IDS_PROMPT_SELCOREPATH_1, szTmpTitle, sizeof szTmpTitle / sizeof szTmpTitle[0] );
						bRes = ShowBrowseDirDialog( hDlg, szTmpTitle, szTmpPath );
						if ( bRes )
							SetDlgItemText( hDlg, IDC_COREPATH_1, szTmpPath );

						break;
					}

				case IDC_BROWSECOREPATH2:
					{
						LoadString( g_hInstance, IDS_PROMPT_SELCOREPATH_2, szTmpTitle, sizeof szTmpTitle / sizeof szTmpTitle[0] );
						bRes = ShowBrowseDirDialog( hDlg, szTmpTitle, szTmpPath );
						if ( bRes )
							SetDlgItemText( hDlg, IDC_COREPATH_2, szTmpPath );

						break;
					}

				case IDC_BROWSEJRNLPATH:
					{
						LoadString( g_hInstance, IDS_PROMPT_SELJRNLPATH, szTmpTitle, sizeof szTmpTitle / sizeof szTmpTitle[0] );
						bRes = ShowBrowseDirDialog( hDlg, szTmpTitle, szTmpPath );
						if ( bRes )
							SetDlgItemText( hDlg, IDC_JRNLPATH, szTmpPath );

						break;
					}

				case IDC_BROWSESTAGINGPATH:
					{
						LoadString( g_hInstance, IDS_PROMPT_SELSTGPATH, szTmpTitle, sizeof szTmpTitle / sizeof szTmpTitle[0] );
						bRes = ShowBrowseDirDialog( hDlg, szTmpTitle, szTmpPath );
						if ( bRes )
							SetDlgItemText( hDlg, IDC_STAGINGPATH, szTmpPath );

						break;
					}

				case IDC_BROWSEXLOGPATH:
					{
						LoadString( g_hInstance, IDS_PROMPT_SELXLOGPATH, szTmpTitle, sizeof szTmpTitle / sizeof szTmpTitle[0] );
						bRes = ShowBrowseDirDialog( hDlg, szTmpTitle, szTmpPath );
						if ( bRes )
							SetDlgItemText( hDlg, IDC_XLOGPATH, szTmpPath );

						break;
					}

				default:
					break;

			}
			break;

		case WM_NOTIFY:
		{
			switch( ( ( NMHDR * )lParam )->code )
			{
				//
				// this is called once when the page is created
				//
				case PSN_SETACTIVE:
				{
					//
					// this page needed only if we are installing the DB
					//
					g_uddiComponents.UpdateAllInstallLevel();
					if( g_uddiComponents.IsInstalling( UDDI_DB ) && g_bOnActiveClusterNode && !g_bPreserveDatabase )
					{
						PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_NEXT | PSWIZB_BACK );
						SetWindowLongPtr( hDlg, DWLP_MSGRESULT, 0 );

						//
						// Check whether we need to update the data path fileds
						// due to a change in the clustering data
						//
						if ( g_bResetPathFields )
						{
							if ( g_uddiComponents.IsClusteredDBInstance() )
							{
								if ( gAllowedClusterDrives.driveCount > 0 )
								{
									sTmpString = gAllowedClusterDrives.drives[ 0 ];
									sTmpString += TEXT( "\\uddi\\data" );
								}
								else // falling back on a default data path
								{
									sTmpString = g_uddiComponents.GetDefaultDataPath();
								}
							}
							else
								sTmpString = g_uddiComponents.GetDefaultDataPath();

							//
							// Set the fields
							//
							SetAllDatapathFields( hDlg, sTmpString.c_str() );
						}

						g_bResetPathFields = FALSE;

						return 1;
					}
					else
					{
						return SkipWizardPage( hDlg );
					}
				}

				case PSN_WIZNEXT:
				{
					//
					// set the Provider Instance Name by adding a property to the DB setup command line
					//
					TCHAR buf[ MAX_PATH + 1 ];
					ZeroMemory( buf, sizeof buf );
		
					//
					// System Data File path
					//
					GetWindowText( GetDlgItem( hDlg, IDC_SYSPATH ), buf, ( sizeof buf / sizeof buf[0] ) - 1 );
					if ( _tcslen( buf ) && ( buf[ _tcslen( buf ) - 1 ] == TEXT( '\\' ) ) )
						_tcscat( buf, TEXT( "\\" ) );

					g_uddiComponents.AddProperty( UDDI_DB, PROPKEY_SYSPATH, buf );
					ZeroMemory( buf, sizeof buf );

					//
					// Core Data File path #1
					//
					GetWindowText( GetDlgItem( hDlg, IDC_COREPATH_1 ), buf, ( sizeof( buf ) / sizeof( buf[0] ) ) -1 );
					if ( _tcslen( buf ) && ( buf[ _tcslen( buf ) - 1 ] == TEXT( '\\' ) ) )
						_tcscat( buf, TEXT( "\\" ) );

					g_uddiComponents.AddProperty( UDDI_DB, PROPKEY_COREPATH_1, buf );
					ZeroMemory( buf, sizeof buf );

					//
					// Core Data File path #2
					//
					GetWindowText( GetDlgItem( hDlg, IDC_COREPATH_2 ), buf, ( sizeof( buf ) / sizeof( buf[0] ) ) -1 );
					if ( _tcslen( buf ) && ( buf[ _tcslen( buf ) - 1 ] == TEXT( '\\' ) ) )
						_tcscat( buf, TEXT( "\\" ) );

					g_uddiComponents.AddProperty( UDDI_DB, PROPKEY_COREPATH_2, buf );
					ZeroMemory( buf, sizeof buf );

					//
					// Journal Data File path
					//
					GetWindowText( GetDlgItem( hDlg, IDC_JRNLPATH ), buf, ( sizeof( buf ) / sizeof( buf[0] ) ) -1 );
					if ( _tcslen( buf ) && ( buf[ _tcslen( buf ) - 1 ] == TEXT( '\\' ) ) )
						_tcscat( buf, TEXT( "\\" ) );

					g_uddiComponents.AddProperty( UDDI_DB, PROPKEY_JRNLPATH, buf );
					ZeroMemory( buf, sizeof buf );

					//
					// Staging Data File path
					//
					GetWindowText( GetDlgItem( hDlg, IDC_STAGINGPATH ), buf, ( sizeof( buf ) / sizeof( buf[0] ) ) -1 );
					if ( _tcslen( buf ) && ( buf[ _tcslen( buf ) - 1 ] == TEXT( '\\' ) ) )
						_tcscat( buf, TEXT( "\\" ) );

					g_uddiComponents.AddProperty( UDDI_DB, PROPKEY_STGPATH, buf );
					ZeroMemory( buf, sizeof buf );

					//
					// Xact Log File path
					//
					GetWindowText( GetDlgItem( hDlg, IDC_XLOGPATH ), buf, ( sizeof( buf ) / sizeof( buf[0] ) ) -1 );
					if ( _tcslen( buf ) && ( buf[ _tcslen( buf ) - 1 ] == TEXT( '\\' ) ) )
						_tcscat( buf, TEXT( "\\" ) );

					g_uddiComponents.AddProperty( UDDI_DB, PROPKEY_XLOGPATH, buf );
					ZeroMemory( buf, sizeof buf );

					//
					// Finally, we can leave the page
					//
					SetWindowLongPtr( hDlg, DWLP_MSGRESULT, 0 );
					return 1;
				}

				case PSN_QUERYCANCEL:
				{
					SetWindowLongPtr( hDlg, DWLP_MSGRESULT, 0 );
					return 1;
				}
			}
		}
	}

	return 0;
}


//
//--------------------------------------------------------------------------
//
INT_PTR CALLBACK ExistingDBInstanceProc( HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam )
{
	TCHAR	buf[ 1024 ];
	ULONG	cbBuf = ( sizeof buf / sizeof buf[0] );
	bool	bRes = false;

	switch( msg )
	{
		case WM_INITDIALOG:
			//
			// set the database instance name field
			//
			ZeroMemory( buf, sizeof buf );

			bRes = g_dbLocalInstances.GetUDDIDBInstanceName( NULL, buf, &cbBuf );
			if ( bRes )
			{
				if ( !_tcsstr( buf, TEXT( "\\") ) )
				{
					//
					// Add the machine name
					//
					TCHAR szMachineName[ MAX_COMPUTERNAME_LENGTH + 1 ];
					DWORD dwLen = MAX_COMPUTERNAME_LENGTH + 1;

					ZeroMemory (szMachineName, sizeof szMachineName );
					if ( GetComputerName( szMachineName, &dwLen ) )
					{
						TCHAR szTmp[ 1024 ];

						_tcscpy( szTmp, szMachineName );
						_tcscat( szTmp, TEXT( "\\" ) );
						_tcscat( szTmp, buf );
						_tcscpy( buf, szTmp );
					}

				}
				SetDlgItemText( hDlg, IDC_INSTANCENAME, buf );
			}
			break;

		case WM_COMMAND:
			break;

		case WM_NOTIFY:
		{
			switch( ( ( NMHDR * )lParam )->code )
			{
				//
				// this is called once when the page is created
				//
				case PSN_SETACTIVE:
				{
					//
					// this page needed only if we are installing the Web & DB is here
					//
					g_uddiComponents.UpdateAllInstallLevel();
					if( g_uddiComponents.IsInstalled( UDDI_DB ) && 
						!g_uddiComponents.IsUninstalling( UDDI_DB ) &&
						g_uddiComponents.IsInstalling( UDDI_WEB ) ) 
					{
						PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_NEXT | PSWIZB_BACK );
						SetWindowLongPtr( hDlg, DWLP_MSGRESULT, 0 );
						return 1;
					}
					else
					{
						return SkipWizardPage( hDlg );
					}
				}

				case PSN_WIZNEXT:
				{
					SetWindowLongPtr( hDlg, DWLP_MSGRESULT, 0 );
					return 1;
				}

				case PSN_QUERYCANCEL:
				{
					SetWindowLongPtr( hDlg, DWLP_MSGRESULT, 0 );
					return 1;
				}
			}
		}
	}

	return 0;
}


//
//--------------------------------------------------------------------------
//
INT_PTR CALLBACK AddSvcDlgProc( HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam )
{
	switch( msg )
	{
		case WM_INITDIALOG:
			//
			// Check the Publish This Site checkbox
			//
			CheckDlgButton( hDlg, IDC_CHECK_ADDSVC, BST_CHECKED );
			break;

		case WM_COMMAND:
			break;

		case WM_NOTIFY:
		{
			switch( ( ( NMHDR * )lParam )->code )
			{
				//
				// this is called once when the page is created
				//
				case PSN_SETACTIVE:
				{
					//
					// this page needed only if we are installing the DB
					//
					g_uddiComponents.UpdateAllInstallLevel();
					if( g_uddiComponents.IsInstalling( UDDI_WEB ) )
					{
						PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_NEXT | PSWIZB_BACK );
						SetWindowLongPtr( hDlg, DWLP_MSGRESULT, 0 );
						return 1;
					}
					else
					{
						return SkipWizardPage( hDlg );
					}
				}

				case PSN_WIZNEXT:
				{
					//
					//  set the "Add Services" and "Update AD" flags by adding the installation properties
					//
					bool bChecked = ( BST_CHECKED == IsDlgButtonChecked( hDlg, IDC_CHECK_ADDSVC ) );
					g_uddiComponents.AddProperty( UDDI_WEB, PROPKEY_ADDSERVICES, ( bChecked ? 1 : 0 ) );
					g_uddiComponents.AddProperty( UDDI_WEB, PROPKEY_UPDATE_AD, ( bChecked ? 1 : 0 ) );

					SetWindowLongPtr( hDlg, DWLP_MSGRESULT, 0 );
					return 1;
				}

				case PSN_QUERYCANCEL:
				{
					SetWindowLongPtr( hDlg, DWLP_MSGRESULT, 0 );
					return 1;
				}
			}
		}
	}

	return 0;
}


//
//--------------------------------------------------------------------------
//

INT_PTR CALLBACK RemoteDBInstanceDlgProc( HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam )
{
	switch( msg )
	{
		case WM_COMMAND:
			if( LOWORD( wParam ) == IDC_BROWSE_MACHINES )
			{
				//
				// use the object picker to select the remote machine name
				//
				HRESULT hr;
				BOOL	bIsStd = FALSE;
				TCHAR szComputerName[ 256 ] = {0};

				if ( !ObjectPicker( hDlg, OP_COMPUTER, szComputerName, 256 ) )
					break; // user pressed cancel

				hr = IsStandardServer( szComputerName, &bIsStd );
				if ( SUCCEEDED( hr ) && bIsStd )
				{
					DisplayUDDIErrorDialog( hDlg, IDS_CANTCONNTOSTD, MB_OK | MB_ICONWARNING );
					break;
				}

				//
				// write the machine name into the static text box, and them clear the combo box
				//
				SendMessage( GetDlgItem( hDlg, IDC_REMOTE_MACHINE ), WM_SETTEXT, 0, ( LPARAM ) szComputerName );

				//
				// find out if a UDDI database already exists on that remote machine
				//
				TCHAR szInstanceName[ 100 ];
				ULONG uLen = 100;
				if( g_dbRemoteInstances.GetUDDIDBInstanceName( szComputerName, szInstanceName, &uLen ) )
				{
					//
					// write the db instance name into the static text box
					//
					SendMessage( GetDlgItem( hDlg, IDC_REMOTE_INSTANCE ), WM_SETTEXT, 0, ( LPARAM ) szInstanceName );
				}
				else
				{
					//
					// remote machine was not accessable or did not have any instances
					//
					DisplayUDDIErrorDialog( hDlg, IDS_UDDI_DB_NOT_EXIST, MB_OK | MB_ICONWARNING );
				}
			}
			break;

		case WM_NOTIFY:
		{
			switch( ( ( NMHDR * )lParam )->code )
			{
				//
				// this is called once when the page is created
				//
				case PSN_SETACTIVE:
				{
					//
					// needed if user is installing web and NOT the db, or the db is not installed
					//
					g_uddiComponents.UpdateAllInstallLevel();
					if( g_uddiComponents.IsInstalling( UDDI_WEB ) && !g_uddiComponents.IsInstalling( UDDI_DB ) && 
						( !g_uddiComponents.IsInstalled( UDDI_DB ) || g_uddiComponents.IsUninstalling( UDDI_DB ) ) )
					{
						UINT osMask = g_uddiComponents.GetOSSuiteMask();
						BOOL bAdv = ( osMask & VER_SUITE_DATACENTER ) || ( osMask & VER_SUITE_ENTERPRISE );

						EnableWindow( GetDlgItem( hDlg, IDC_BROWSE_MACHINES ), bAdv );

						PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_NEXT | PSWIZB_BACK );
						SetWindowLongPtr( hDlg,DWLP_MSGRESULT,0 );
						return 1;
					}
					else
					{
						return SkipWizardPage( hDlg );
					}
				}

				//
				// this is called when the user presses "next"
				//
				case PSN_WIZNEXT:
				{
					//
					// get the remote machine name from the edit control
					//
					TCHAR szComputerName[ 129 ];
					UINT iChars = ( UINT ) SendMessage( GetDlgItem( hDlg, IDC_REMOTE_MACHINE ), WM_GETTEXT, 129, ( LPARAM ) szComputerName );
					if( 0 == iChars )
					{
						DisplayUDDIErrorDialog( hDlg, IDS_SELECT_REMOTE_COMPUTER );
						SetWindowLongPtr( hDlg, DWLP_MSGRESULT, 1 );
						return 1; // to keep the focus on this page
					}

					//
					// get the index of the database instance selection in the combobox
					//
					TCHAR szRemoteDBInstance[ 100 ];
					iChars = ( UINT ) SendMessage( GetDlgItem( hDlg, IDC_REMOTE_INSTANCE ), WM_GETTEXT, 100, ( LPARAM ) szRemoteDBInstance );
					if( 0 == iChars )
					{
						DisplayUDDIErrorDialog( hDlg, IDS_UDDI_DB_NOT_EXIST );
						SetWindowLongPtr( hDlg, DWLP_MSGRESULT, 1 );
						return 1; // to keep the focus on this page
					}

					//
					// save the computer and instance name. As we are using a remote node here,
					// we don't really care whether it is on cluster or not
					//
					g_uddiComponents.SetDBInstanceName( szComputerName, szRemoteDBInstance, UDDI_NOT_INSTALLING_MSDE, false );

					//
					// the web installer needs the remote machine name to properly add the login
					//
					g_uddiComponents.AddProperty( UDDI_WEB, TEXT( "REMOTE_MACHINE_NAME" ), szComputerName );


					Log( TEXT( "User selected remote computer %s and database instance %s" ), szComputerName, szRemoteDBInstance );

					SetWindowLongPtr( hDlg, DWLP_MSGRESULT, 0 );
					return 1; // done
				}

				case PSN_QUERYCANCEL:
				{
					SetWindowLongPtr( hDlg, DWLP_MSGRESULT, 0 );
					return 1;
				}
			}
		}
	}

	return 0;
}

//--------------------------------------------------------------------------

INT_PTR CALLBACK LoginDlgProc( HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam )
{
	switch( msg )
	{
		case WM_INITDIALOG:
			//
			// set the limit of the length of the password
			//
			SendMessage( GetDlgItem( hDlg, IDC_PASSWORD  ), EM_LIMITTEXT, ( WPARAM ) PASSWORD_LEN, 0 );
			SendMessage( GetDlgItem( hDlg, IDC_USER_NAME ), EM_LIMITTEXT, ( WPARAM ) USERNAME_LEN, 0 );
			break;

		case WM_COMMAND:
			//
			// user clicked a radio button:
			//
			if( LOWORD( wParam ) == IDC_RADIO_NETWORK_SERVICE || LOWORD( wParam ) == IDC_RADIO_DOMAIN_ACCT )
			{
				if( HIWORD( wParam ) == BN_CLICKED )
				{
					EnableWindow( GetDlgItem( hDlg, IDC_USER_NAME        ), IsDlgButtonChecked( hDlg, IDC_RADIO_DOMAIN_ACCT ) );
					EnableWindow( GetDlgItem( hDlg, IDC_USER_NAME_PROMPT ), IsDlgButtonChecked( hDlg, IDC_RADIO_DOMAIN_ACCT ) );
					EnableWindow( GetDlgItem( hDlg, IDC_PASSWORD         ), IsDlgButtonChecked( hDlg, IDC_RADIO_DOMAIN_ACCT ) );
					EnableWindow( GetDlgItem( hDlg, IDC_PASSWORD_PROMPT  ), IsDlgButtonChecked( hDlg, IDC_RADIO_DOMAIN_ACCT ) );
					EnableWindow( GetDlgItem( hDlg, IDC_BROWSE_USERS     ), IsDlgButtonChecked( hDlg, IDC_RADIO_DOMAIN_ACCT ) );
				}
			}
			//
			// if the user clicked the "Browse" button
			//
			else if( LOWORD( wParam ) == IDC_BROWSE_USERS )
			{
				//
				// use the object picker to select the user
				//
				TCHAR szDomainUser[ 256 ];
				if ( !ObjectPicker( hDlg, OP_USER, szDomainUser, 256 ) )
					break;

				//
				// write the machine name into the static text box
				//
				SendMessage( GetDlgItem( hDlg, IDC_USER_NAME ), WM_SETTEXT, 0, ( LPARAM ) szDomainUser );

			}
			break;

		case WM_NOTIFY:
		{
			switch( ( ( NMHDR * )lParam )->code )
			{
				//
				// this is called once when the page is created
				//
				case PSN_SETACTIVE:
				{
					//
					// this page is needed only when the WEB is being installed
					//
					g_uddiComponents.UpdateAllInstallLevel();
					if( g_uddiComponents.IsInstalling( UDDI_WEB ) )
					{
						PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_NEXT | PSWIZB_BACK );
						SetWindowLongPtr( hDlg, DWLP_MSGRESULT, 0 );

						bool bIsClustered = g_uddiComponents.IsClusteredDBInstance();

						if( ( g_uddiComponents.IsInstalling( UDDI_DB ) || 
							  ( g_uddiComponents.IsInstalled( UDDI_DB ) && !g_uddiComponents.IsUninstalling( UDDI_DB ) ) ) &&
							!bIsClustered  )
						{
							CheckRadioButton( hDlg, IDC_RADIO_NETWORK_SERVICE, IDC_RADIO_DOMAIN_ACCT, IDC_RADIO_NETWORK_SERVICE );
						}
						//
						// db is not on the local box, so disable the network service account option
						//
						else
						{
							CheckRadioButton( hDlg, IDC_RADIO_NETWORK_SERVICE, IDC_RADIO_DOMAIN_ACCT, IDC_RADIO_DOMAIN_ACCT );
							EnableWindow( GetDlgItem( hDlg, IDC_RADIO_NETWORK_SERVICE ), FALSE );
							SetFocus( GetDlgItem( hDlg, IDC_USER_NAME ) );
						}

						EnableWindow( GetDlgItem( hDlg, IDC_USER_NAME        ), IsDlgButtonChecked( hDlg, IDC_RADIO_DOMAIN_ACCT ) );
						EnableWindow( GetDlgItem( hDlg, IDC_USER_NAME_PROMPT ), IsDlgButtonChecked( hDlg, IDC_RADIO_DOMAIN_ACCT ) );
						EnableWindow( GetDlgItem( hDlg, IDC_PASSWORD         ), IsDlgButtonChecked( hDlg, IDC_RADIO_DOMAIN_ACCT ) );
						EnableWindow( GetDlgItem( hDlg, IDC_PASSWORD_PROMPT  ), IsDlgButtonChecked( hDlg, IDC_RADIO_DOMAIN_ACCT ) );
						EnableWindow( GetDlgItem( hDlg, IDC_BROWSE_USERS     ), IsDlgButtonChecked( hDlg, IDC_RADIO_DOMAIN_ACCT ) );
					}
					else
					{
						return SkipWizardPage( hDlg );
					}

					return 1;
				}

				//
				// this is called when the user presses "next"
				//
				case PSN_WIZNEXT:
				{
					//
					// Get ready for the SID-to-user name conversions
					//
					TCHAR	szSidStr[ 1024 ];
					TCHAR	szRemote[ 1024 ];
					TCHAR	szRemoteUser[ 1024 ];
					DWORD	cbSidStr = sizeof szSidStr / sizeof szSidStr[0];
					DWORD	cbRemoteUser = sizeof szRemoteUser / sizeof szRemoteUser[0];

					TCHAR szComputerName[ MAX_COMPUTERNAME_LENGTH + 1 ];
					DWORD dwCompNameLen = MAX_COMPUTERNAME_LENGTH + 1;
					GetComputerName( szComputerName, &dwCompNameLen );

					ZeroMemory( szRemote, sizeof szRemote );

					if( NULL == g_uddiComponents.GetProperty( UDDI_WEB, TEXT( "REMOTE_MACHINE_NAME" ), szRemote ) )
					{
						_tcscpy( szRemote, szComputerName );
					}

					//
					// set the property that defines whether we are using "Network Service" or a "User Login"
					//
					bool bUserAcct = ( BST_CHECKED == IsDlgButtonChecked( hDlg, IDC_RADIO_DOMAIN_ACCT ) );

					//
					// set the properties that denotes a domain user
					//
					if( bUserAcct )
					{
						TCHAR szDomainUser[ USERNAME_LEN + 1 ];

						//
						// verify the user name length > 0
						//
						int iChars = GetWindowText( GetDlgItem( hDlg, IDC_USER_NAME ), szDomainUser, sizeof( szDomainUser ) / sizeof( TCHAR ) );
						if( 0 == iChars )
						{
							DisplayUDDIErrorDialog( hDlg, IDS_ZERO_LEN_USER_NAME );
							SetWindowLongPtr( hDlg, DWLP_MSGRESULT, 1 );
							return 1; // to keep the focus on this page
						}

						//
						// make the user retype the password
						//
						GetWindowText( GetDlgItem( hDlg, IDC_PASSWORD ), g_szPwd, sizeof( g_szPwd ) / sizeof( TCHAR ) );

						INT_PTR iRet = DialogBox(
							g_hInstance,
							MAKEINTRESOURCE( IDD_CONFIRM_PW ),
							hDlg,
							ConfirmPasswordDlgProc );

						if( IDCANCEL == iRet )
						{
							//
							// user pressed Cancel to the confirm dialog
							//
							SetWindowLongPtr( hDlg, DWLP_MSGRESULT, 1 );
							return 1; // to keep the focus on this page
						}

						TCHAR szUser[ USERNAME_LEN + 1 ];
						TCHAR szDomain[ 256 ];
						DWORD cbDomain = sizeof( szDomain ) / sizeof( szDomain[0] );
						bool bLocalAccount;

						ZeroMemory( szUser, sizeof( szUser ) );
						ZeroMemory( szDomain, sizeof( szDomain ) );

						ParseUserAccount(
							szDomainUser, sizeof( szDomainUser ) / sizeof ( TCHAR ),
							szUser,   	  sizeof( szUser ) / sizeof ( TCHAR ),
							szDomain,  	  sizeof( szDomain ) / sizeof ( TCHAR ),
							bLocalAccount );

						//
						// try to login as this account
						// if there is no domain name specified
						// then assume local account
						//
						if ( bLocalAccount )
						{
							_tcscpy( szDomain, TEXT( "." ) );

							//
							// are we on a cluster ?
							//
							if ( g_uddiComponents.IsClusteredDBInstance() )
							{
								DisplayUDDIErrorDialog( hDlg, IDS_WRONGLOGONTYPE, MB_OK | MB_ICONWARNING, GetLastError() );
								SetWindowLongPtr( hDlg, DWLP_MSGRESULT, 1 );
								return 1; // to keep the focus on this page
							}
						}

						BOOL fLogonRights = GrantNetworkLogonRights( szDomainUser );
						if( !fLogonRights )
						{
							//
							// FIX: 727877: needed error dialog
							//
							DisplayUDDIErrorDialog( hDlg, IDS_LOGIN_ERROR, MB_OK | MB_ICONWARNING, E_FAIL );
							SetWindowLongPtr( hDlg, DWLP_MSGRESULT, 1 );
							return 1;
						}

						HANDLE hToken = NULL;
						BOOL bIsGoodLogin = LogonUser( 
							szUser, 
							_tcslen( szDomain ) > 0 ? szDomain : NULL,
							g_szPwd,
							LOGON32_LOGON_INTERACTIVE,
							LOGON32_PROVIDER_DEFAULT, 
							&hToken);

						if( bIsGoodLogin )
						{
							HRESULT hr = S_OK;

							Log( _T( "LogonUser succeeded with %s." ), szDomainUser );

							//
							// FIX: 718923: needed to test connectivity with SQL server via impersonation and OLEDB call
							//

							//
							// If we're not installing MSDE, then a database exists for us to check connectivity.
							//
							if( !g_uddiComponents.IsInstalling( UDDI_MSDE ) )
							{
								//
								// Only check this when we're not installing the db components (i.e. off-machine setup)
								//
								if( !g_uddiComponents.IsInstalling( UDDI_DB ) )
								{
									HCURSOR hcrHourglass = LoadCursor( NULL, IDC_WAIT );
									HCURSOR hcrCurr = SetCursor( hcrHourglass );

									//
									// If workgroup account, we need to give AddServiceAccount the workgroup account on the db server.
									// Else, just pass the domain account.
									//
									tstring sServerName;
									if( bLocalAccount )
									{
										sServerName = g_uddiComponents.GetDBComputerName();
										sServerName += _T( "\\" );
										sServerName += szUser;
									}
									else
									{
										sServerName = szDomainUser;
									}

									Log( _T( "Before AddServiceAccount for user %s, instance %s." ), sServerName.c_str(), g_uddiComponents.GetFullDBInstanceName() );

									//
									// Add user to service account on db.
									//
									hr = AddServiceAccount( g_uddiComponents.GetFullDBInstanceName(), sServerName.c_str() );

									if( SUCCEEDED( hr ) )
									{
										if( ImpersonateLoggedOnUser( hToken ) )
										{
											Log( _T( "Successfully impersonated user %s\\%s." ), szDomain, szUser);

											TCHAR	szVerBuf[ 256 ] = {0};
											size_t	cbVerBuf = DIM( szVerBuf ) - 1;

											Log( _T( "Before GetDBSchemaVersion for instance %s." ), g_uddiComponents.GetFullDBInstanceName() );

											//
											// Try connecting to the database with the impersonated user token.
											//
											hr = GetDBSchemaVersion( g_uddiComponents.GetFullDBInstanceName(), szVerBuf, cbVerBuf );

											Log( _T( "GetDBSchemaVersion returned %s, HRESULT %x." ), szVerBuf, hr );

											RevertToSelf();
										}
										else
										{
											//
											// Get error from ImpersonateLoggedOnUser
											//
											hr = GetLastError();
										}
									}
									else
									{
										Log( _T( "AddServiceAccount failed, HRESULT %x." ), hr );
									}

									SetCursor( hcrCurr );
								}
							}

							CloseHandle( hToken );

							if( FAILED( hr ) )
							{
								Log( _T( "Failed to verify connectivity, putting up error dialog, HRESULT %x" ), hr );

								//
								// not a good login, so raise error dialog and keep focus on this property page
								//
								DisplayUDDIErrorDialog( hDlg, IDS_LOGIN_ERROR, MB_OK | MB_ICONWARNING, hr );
								SetWindowLongPtr( hDlg, DWLP_MSGRESULT, 1 );

								Log( _T( "Put up error dialog, returning." ) );

								return 1; // to keep the focus on this page
							}
						}
						else
						{
							Log( _T( "LogonUser failed, %x." ), GetLastError() );

							//
							// not a good login, so raise error dialog and keep focus on this property page
							//
							DisplayUDDIErrorDialog( hDlg, IDS_LOGIN_ERROR, MB_OK | MB_ICONWARNING, GetLastError() );
							SetWindowLongPtr( hDlg, DWLP_MSGRESULT, 1 );
							return 1; // to keep the focus on this page
						}

						//
						// set the property that denotes a domain user login will be used in the iis app pool
						//
						g_uddiComponents.AddProperty( UDDI_WEB, TEXT( "APPPOOL_IDENTITY_TYPE" ), MD_APPPOOL_IDENTITY_TYPE_SPECIFICUSER );


						//
						// the web and installer needs the user name
						//
						g_uddiComponents.AddProperty( UDDI_WEB, TEXT( "WAM_USER_NAME" ), szDomainUser );
						g_uddiComponents.AddProperty( UDDI_WEB, TEXT("WAM_PWD"), g_szPwd );

						//
						// the web installer needs to put the pw into the IIS app pool settings
						//
						_tcscpy( szRemoteUser, szRemote );
						_tcscat( szRemoteUser, TEXT( "\\" ) );
						_tcscat( szRemoteUser, szUser );

						if( bLocalAccount )
							g_uddiComponents.AddProperty( UDDI_WEB, TEXT( "LCL_USER_NAME" ), szRemoteUser );
						else
							g_uddiComponents.AddProperty( UDDI_WEB, TEXT( "LCL_USER_NAME" ), szDomainUser );
					}
					//
					// the user specified the Network Service account
					//
					else
					{
						//
						// set the property that denotes "Network Service"
						//
						g_uddiComponents.AddProperty( UDDI_WEB, TEXT( "APPPOOL_IDENTITY_TYPE" ), MD_APPPOOL_IDENTITY_TYPE_NETWORKSERVICE );

						//
						// the web and db installers need the user name
						//
						TCHAR wszNetworkServiceName[ 512 ];
						DWORD cbSize = 512 * sizeof( TCHAR );
						BOOL b = GetWellKnownAccountName( WinNetworkServiceSid, wszNetworkServiceName, &cbSize );
						if( !b )
						{
							Log( _T( "Call to GetNetworkServiceAccountName failed." ) );
						}
						else
						{
							Log( _T( "Network Service account name on this machine = %s" ), wszNetworkServiceName );
						}
						g_uddiComponents.AddProperty( UDDI_WEB, TEXT( "WAM_USER_NAME" ), wszNetworkServiceName );

						//
						// no need for the pw, so clear out this property
						//
						g_uddiComponents.DeleteProperty( UDDI_WEB, TEXT( "WAM_PWD" ) );

						//
						// Now also save the SID for the WAM_USER
						//
						TCHAR	szUser[ USERNAME_LEN + 1 ];
						TCHAR	szDomain[ 256 ];
						DWORD	cbUser = sizeof szUser / sizeof szUser[0];
						DWORD	cbDomain = sizeof szDomain / sizeof szDomain[0];

						if( !GetLocalSidString( WinNetworkServiceSid, szSidStr, cbSidStr ) )
						{
							DisplayUDDIErrorDialog( hDlg, IDS_GETSID_ERROR, MB_OK | MB_ICONWARNING, GetLastError() );
							SetWindowLongPtr( hDlg, DWLP_MSGRESULT, 1 );
							return 1; // to keep the focus on this page
						}

						if( !GetRemoteAcctName( szRemote, szSidStr, szUser, &cbUser, szDomain, &cbDomain ) )
						{
							DisplayUDDIErrorDialog( hDlg, IDS_GETREMOTEACCT_ERROR, MB_OK | MB_ICONWARNING, GetLastError() );
							SetWindowLongPtr( hDlg, DWLP_MSGRESULT, 1 );
							return 1; // to keep the focus on this page
						}

						_tcscpy( szRemoteUser, szDomain );
						_tcscat( szRemoteUser, TEXT( "\\" ) );
						_tcscat( szRemoteUser, szUser );

						g_uddiComponents.AddProperty( UDDI_WEB, TEXT( "LCL_USER_NAME" ), szRemoteUser );
					}

					SetWindowLongPtr( hDlg, DWLP_MSGRESULT, 0 );
					return 1;
				}

				case PSN_QUERYCANCEL:
				{
					SetWindowLongPtr( hDlg, DWLP_MSGRESULT, 0 );
					return 1;
				}
			}
		}
	}

	return 0;
}

//--------------------------------------------------------------------------

BOOL CALLBACK ConfirmPasswordDlgProc(
	HWND hwndDlg,
	UINT message,
	WPARAM wParam,
	LPARAM lParam)
{
	switch( message ) 
	{
		case WM_INITDIALOG:
		{
			//
			// set the limit of the length of the password
			//
			SendMessage( GetDlgItem( hwndDlg, IDC_CONFIRM_PW ), EM_LIMITTEXT, ( WPARAM ) PASSWORD_LEN, 0 );
		}
		break;

		case WM_COMMAND:
			switch( LOWORD( wParam ) )
			{
				case IDOK:
					TCHAR szPW[ PASSWORD_LEN + 1 ];
					GetDlgItemText( hwndDlg, IDC_CONFIRM_PW, szPW, sizeof( szPW ) / sizeof( TCHAR ) );

					if( 0 != _tcscmp( szPW, g_szPwd ) )
					{
						DisplayUDDIErrorDialog( hwndDlg, IDS_PW_MISMATCH );
						::SetDlgItemText( hwndDlg, IDC_CONFIRM_PW, TEXT( "" ) );
						return TRUE;
					}
					// fall through...

				case IDCANCEL:
					EndDialog( hwndDlg, wParam );
					return TRUE;
			}
	}

	return FALSE;
}

//--------------------------------------------------------------------------

INT_PTR CALLBACK WizardSummaryDlgProc( HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam )
{
	switch( msg )
	{
		case WM_INITDIALOG:
		{
			tstring msg;
			TCHAR szMsg[ 2048 ] = { 0 };
			DWORD dwLen = sizeof( szMsg ) / sizeof( TCHAR ) ;
			int iStrLen = LoadString( g_hInstance, IDS_WIZARD_SUMMARY_GENERAL, szMsg, dwLen );
			assert( iStrLen );

			msg = szMsg;

			if( g_uddiComponents.IsInstalling( UDDI_DB ) )
			{
				iStrLen = LoadString( g_hInstance, IDS_WIZARD_SUMMARY_DB, szMsg, dwLen );
				assert( iStrLen );
				msg += TEXT( "\n\n" );
				msg += szMsg;
			}

			if( g_uddiComponents.IsInstalling( UDDI_WEB ) )
			{
				iStrLen = LoadString( g_hInstance, IDS_WIZARD_SUMMARY_WEB, szMsg, dwLen );
				assert( iStrLen );
				msg += TEXT( "\n\n" );
				msg += szMsg;
			}

			if( g_uddiComponents.IsInstalling( UDDI_ADMIN ) )
			{
				iStrLen = LoadString( g_hInstance, IDS_WIZARD_SUMMARY_ADMIN, szMsg, dwLen );
				assert( iStrLen );
				msg += TEXT( "\n\n" );
				msg += szMsg;
			}

			SetWindowText( GetDlgItem( hDlg, IDC_SUMMARY ), msg.c_str() );

			break;
		}

		case WM_COMMAND:
			break;

		case WM_NOTIFY:
		{
			switch( ( ( NMHDR * )lParam )->code )
			{
				//
				// this is called once when the page is created
				//
				case PSN_SETACTIVE:
				{
					g_uddiComponents.UpdateAllInstallLevel();
					if( g_uddiComponents.IsAnyInstalling() )
					{
						//PropSheet_SetWizButtons( GetParent( hDlg ), 0 );
						PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_NEXT | PSWIZB_BACK );
						SetWindowLongPtr( hDlg, DWLP_MSGRESULT, 0 );
						return 1;
					}
					else
					{
						return SkipWizardPage( hDlg );
					}
				}

                case PSN_KILLACTIVE:
                case PSN_WIZBACK:
                case PSN_WIZFINISH:
                case PSN_QUERYCANCEL:
                case PSN_WIZNEXT:
				{
					SetWindowLongPtr( hDlg, DWLP_MSGRESULT, 0 );
					return 1;
				}
			}
		}
	}

	return 0;
}

//--------------------------------------------------------------------------

static void ParseUserAccount( PTCHAR szDomainAndUser, UINT uDomainAndUserSize, PTCHAR szUser, UINT uUserSize, PTCHAR szDomain, UINT uDomainSize, bool &bLocalAccount )
{
	//
	// see if the user picked a local machine account
	//
	TCHAR szComputerName[ MAX_COMPUTERNAME_LENGTH + 1 ];
	DWORD dwCompNameLen = MAX_COMPUTERNAME_LENGTH + 1;

	szComputerName[ 0 ] = 0x00;
	GetComputerName( szComputerName, &dwCompNameLen );

	bLocalAccount = false;

	//
	// this string is in the format <domain>\<username>,
	// so look for a whack, if found parse out the domain and user name
	//
	_tcsncpy( szDomain, szDomainAndUser, uDomainSize );
	szDomain[ uDomainSize - 1 ] = NULL;

	PTCHAR pWhack = _tcschr( szDomain, '\\' );

	//
	// a whack was not found, so assume it is a user on the local machine
	//
	if( NULL == pWhack )
	{
		//
		// return the user name and a blank domain name
		//
		_tcsncpy( szUser, szDomainAndUser, uUserSize );
		szUser[ uUserSize - 1 ] = NULL;
		
		_tcscpy( szDomain, TEXT( "" ) );

		//
		// if the domain or machine was not specified, then
		// assume the local machine and prepend it
		//
		tstring cDomainAndUser = szComputerName;
		cDomainAndUser.append( TEXT( "\\" ) );
		cDomainAndUser.append( szUser );

		_tcsncpy( szDomainAndUser, cDomainAndUser.c_str(), uDomainAndUserSize );

		bLocalAccount = true;

		return;
	}

	//
	// null the "whack" and step to the next character
	//
	*pWhack = NULL;
	pWhack++;

	_tcsncpy( szUser, pWhack, uUserSize );
	szUser[ uUserSize - 1 ] = NULL;

	//
	// see if the user picked a local machine account.
	// if he did pick a local machine account,
	// null the domain and return only the login
	//
	if( 0 == _tcsicmp( szDomain, szComputerName ) )
	{
		*szDomain = NULL;
		bLocalAccount = true;
	}
}


//---------------------------------------------------------------------------------------
// Shows the shell dialog that allows user to browse for a directory
// Returns FALSE if the dialog was cancelled, or TRUE and the chosen directory
// otherwise. The buffer is expected to be at least MAX_PATH character long
//
BOOL ShowBrowseDirDialog( HWND hParent, LPCTSTR szTitle, LPTSTR szOutBuf )
{
	BOOL	bRes = FALSE;
	TCHAR	szDispName[ MAX_PATH + 1 ];

	if ( IsBadStringPtr( szOutBuf, MAX_PATH ) ) return FALSE;

	HRESULT hr = ::CoInitialize( NULL );
	if ( FAILED( hr ) ) 
		return FALSE;
	
	try
	{
		BROWSEINFO		binfo;
		LPITEMIDLIST	lpItemID = NULL;

		ZeroMemory ( &binfo, sizeof binfo );

		SHGetFolderLocation( NULL, CSIDL_DRIVES, NULL, NULL, &lpItemID );

		binfo.hwndOwner = hParent;
		binfo.ulFlags = BIF_RETURNONLYFSDIRS | BIF_NEWDIALOGSTYLE | BIF_UAHINT | BIF_DONTGOBELOWDOMAIN;
		binfo.lpszTitle = szTitle;
		binfo.pszDisplayName = szDispName;
		binfo.lpfn = BrowseCallbackProc;
		binfo.pidlRoot = lpItemID;

		if ( gAllowedClusterDrives.driveCount >= 0 )
			binfo.lParam = (LPARAM) &gAllowedClusterDrives;
		else
			binfo.lParam = NULL;

		lpItemID = SHBrowseForFolder( &binfo );
		if ( !lpItemID )
			bRes = FALSE;
		else
		{
			bRes = SHGetPathFromIDList( lpItemID, szOutBuf );
		}
	}
	catch (...)
	{
		bRes = FALSE;
	}

	::CoUninitialize();
	return bRes;
}


int CALLBACK BrowseCallbackProc( HWND hwnd, UINT uMsg, LPARAM lParam, LPARAM lpData )
{
	TCHAR	szBuf[ MAX_PATH + 1 ];

	if ( uMsg == BFFM_SELCHANGED )
	{
		TCHAR	szDrive[ _MAX_DRIVE + 2 ];
		LPITEMIDLIST lpItemID = (LPITEMIDLIST) lParam;
		CLST_ALLOWED_DRIVES *lpAllowedDrives = (CLST_ALLOWED_DRIVES *) lpData;
		
		BOOL bEnableOK = FALSE;

		if ( SHGetPathFromIDList( lpItemID, szBuf ) )
		{
			bEnableOK = TRUE;
			try
			{
				_tsplitpath( szBuf, szDrive, NULL, NULL, NULL );
				size_t iDriveLen = _tcslen( szDrive );

				_tcscat( szDrive, TEXT( "\\" ) );

				UINT uiDevType = GetDriveType( szDrive );
				if ( uiDevType != DRIVE_FIXED ) 
				{
					bEnableOK = FALSE;
				}
				else if ( lpAllowedDrives )
				{
					if ( lpAllowedDrives->driveCount > 0 )
					{
						szDrive[ iDriveLen ] = 0;  // drop the slash
						BOOL bFound = FALSE;

						for ( int idx = 0; idx < lpAllowedDrives->driveCount; idx++ )
						{
							if ( !_tcsicmp( lpAllowedDrives->drives[ idx ].c_str(), szDrive ) )
							{
								bFound = TRUE;
								break;
							}
						}

						bEnableOK = bFound;
					}
					else if ( lpAllowedDrives->driveCount == 0 )
					{
						bEnableOK = FALSE;
					}
				}
				
			}
			catch (...)
			{
			}
		}
		
		SendMessage ( hwnd, BFFM_ENABLEOK, 0, bEnableOK );
	}

	return 0;
}

//
// GetWellKnownAccountName
//
// WELL_KNOWN_SID_TYPE is a system enumeration on Win XP & later, and
// Windows Server 2003 & later.  It enumerates the well known SIDs.
//
// Using the functions CreateWellKnownSid, and LookupAccountSid, we
// can retrieve the account name & domain.  These functions are locale
// independent.
//
BOOL
GetWellKnownAccountName( WELL_KNOWN_SID_TYPE idSidWellKnown, TCHAR *pwszName, DWORD *pcbSize )
{
	ENTER();

	//
	// Initialize our output varable.
	//
	memset( pwszName, 0, *pcbSize );

	//
	// These are used for the call to LookupAccountSid.
	//
	TCHAR wszUserName[ 512 ];
	DWORD cbUserName = 512 * sizeof( TCHAR );
	TCHAR wszDomainName[ 512 ];
	DWORD cbDomainName = 512 * sizeof( TCHAR );

	memset( wszUserName, 0, cbUserName );
	memset( wszDomainName, 0, cbDomainName );

	//
	// Try to allocate a buffer for the SID.
	//
	DWORD cbMaxSid = SECURITY_MAX_SID_SIZE;
	PSID psidWellKnown = LocalAlloc( LMEM_FIXED, cbMaxSid );
	if( NULL == psidWellKnown )
	{
		Log( _T( "Call to LocalAlloc failed." ) );
		return FALSE;
	}

	//
	// Create the SID.
	//
	BOOL b = CreateWellKnownSid( idSidWellKnown, NULL, psidWellKnown, &cbMaxSid );
	if( !b )
	{
		Log( _T( "Call to CreateWellKnownSid failed." ) );
		LocalFree( psidWellKnown );
		return FALSE;
	}

	//
	// Use the SID to determine the user name & domain name.
	//
	// For example, for idSidWellKnown = WinNetworkServiceSid,
	// wszDomainName = "NT AUTHORITY"
	// wszUserName = "NETWORK SERVICE"
	//
	SID_NAME_USE snu;
	b = LookupAccountSid( NULL, psidWellKnown, wszUserName, &cbUserName, wszDomainName, &cbDomainName, &snu );
	LocalFree( psidWellKnown );
	if( !b )
	{
		Log( _T( "Call to LookupAccountSid failed." ) );
		return FALSE;
	}
	else
	{
		Log( _T( "LookupAccountSid succeeded!  domain name = %s, account name = %s" ), wszDomainName, wszUserName );
		_tcsncat( pwszName, wszDomainName, *pcbSize );
		_tcsncat( pwszName, _T( "\\" ), *pcbSize );
		_tcsncat( pwszName, wszUserName, *pcbSize );

		*pcbSize = _tcslen( pwszName ) * sizeof( TCHAR );
		return TRUE;
	}
}


BOOL
GrantNetworkLogonRights( LPCTSTR pwszUser )
{
	//
	// 1.  Check our params.
	//
	if( NULL == pwszUser )
	{
		Log( _T( "NULL specified as domain user to function: GrantNetworkLogonRights.  Returning FALSE." ) );
		return FALSE;
	}

	TCHAR wszUser[ 1024 ];
	memset( wszUser, 0, 1024 * sizeof( TCHAR ) );

	//
	// If the user account is a local account, it will be prefixed
	// with ".\"  For example: ".\Administrator".
	//
	// For some reason, LookupAccountName (which we rely on just below) wants
	// local accounts not to be prefixed with ".\".
	//
	if( 0 == _tcsnicmp( _T( ".\\" ), pwszUser, 2 ) )
	{
		_tcsncpy( wszUser, &pwszUser[ 2 ], _tcslen( pwszUser ) - 2 );
	}
	else
	{
		_tcsncpy( wszUser, pwszUser, _tcslen( pwszUser ) );
	}

	Log( _T( "Account we will attempt to grant network logon rights = %s." ), wszUser );


	//
	// 2.  Get the SID of the specified user.
	//
	PSID pUserSID = NULL;
	DWORD cbUserSID = SECURITY_MAX_SID_SIZE;
	TCHAR wszDomain[ 1024 ];
	DWORD cbDomain = 1024 * sizeof( TCHAR );
	SID_NAME_USE pUse;

	pUserSID = LocalAlloc( LMEM_FIXED, cbUserSID );
	if( NULL == pUserSID )
	{
		Log( _T( "Call to LocalAlloc failed." ) );
		return FALSE;
	}
	memset( pUserSID, 0, cbUserSID );

	BOOL fAPISuccess = LookupAccountName( NULL, wszUser, pUserSID, &cbUserSID, wszDomain, &cbDomain, &pUse );

	if( !fAPISuccess )
	{
		Log( _T( "Call to LookupAccountName failed for user: %s." ), wszUser );
		LocalFree( pUserSID );
		return FALSE;
	}
	else
	{
		Log( _T( "Call to LookupAccountName succeeded for user: %s." ), wszUser );
	}

	//
	// 3.  Get a handle to Policy Object.
	//
	LSA_UNICODE_STRING lusMachineName;
	lusMachineName.Length = 0;
	lusMachineName.MaximumLength = 0;
	lusMachineName.Buffer = NULL;

	LSA_OBJECT_ATTRIBUTES loaObjAttrs;
	memset( &loaObjAttrs, 0, sizeof( LSA_OBJECT_ATTRIBUTES ) );

	ACCESS_MASK accessMask = POLICY_LOOKUP_NAMES | POLICY_CREATE_ACCOUNT;

	LSA_HANDLE lhPolicy = NULL;

	NTSTATUS status = LsaOpenPolicy( &lusMachineName, &loaObjAttrs, accessMask, &lhPolicy );
	if( STATUS_SUCCESS != status )
	{
		Log( _T( "Call to LsaOpenPolicy failed." ) );
		LocalFree( pUserSID );
		return FALSE;
	}
	else
	{
		Log( _T( "Call to LsaOpenPolicy succeeded." ) );
	}

	//
	// 4.  Check & see if the user already has the account rights they need.
	//
	PLSA_UNICODE_STRING plusRights = NULL;
	ULONG ulRightsCount = 0;
	BOOL fHasNetworkLogonRights = FALSE;

	status = LsaEnumerateAccountRights( lhPolicy, pUserSID,  &plusRights, &ulRightsCount );
	if( STATUS_SUCCESS == status )
	{
		for( ULONG i = 0; i < ulRightsCount; i++ )
		{
			if( 0 == wcscmp( plusRights[ i ].Buffer, SE_NETWORK_LOGON_NAME ) )
			{
				fHasNetworkLogonRights = TRUE;
				Log( _T( "User account: %s already has network logon rights." ), wszUser );
				break;
			}
		}

		LsaFreeMemory( plusRights );
	}
	else
	{
		fHasNetworkLogonRights = FALSE;
	}

	//
	// 5.  If we need to add account rights, then add them.
	//
	BOOL fRet = FALSE;
	if( !fHasNetworkLogonRights )
	{
		WCHAR wszNetworkLogon[] = L"SeNetworkLogonRight";
		int iLen = wcslen( wszNetworkLogon );

		LSA_UNICODE_STRING lusNetworkLogon;
		lusNetworkLogon.Length = iLen * sizeof( WCHAR );
		lusNetworkLogon.MaximumLength = ( iLen + 1 ) * sizeof( WCHAR );
		lusNetworkLogon.Buffer = wszNetworkLogon;

		status = LsaAddAccountRights( lhPolicy, pUserSID, &lusNetworkLogon, 1 );
		if( STATUS_SUCCESS == status )
		{
			Log( _T( "User account: %s now has network logon rights." ), wszUser );
			fRet = TRUE;
		}
		else
		{
			Log( _T( "Attempt to grant user account: %s logon rights failed." ), wszUser );
			fRet = FALSE;
		}
	}
	else
	{
		fRet = TRUE;
	}

	LocalFree( pUserSID );
	LsaClose( lhPolicy );

	return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\setup\shared\apppool.cpp ===
#ifndef INITGUID
#define INITGUID
#endif

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0500
#endif

#include <windows.h>
#include <tchar.h>
#include <iwamreg.h>    // MD_ & IIS_MD_ defines

#include "apppool.h"
#include "common.h"

//--------------------------------------------------------------------------

HRESULT CUDDIAppPool::Init( void )
{
	ENTER();

	HRESULT hr = CoInitializeEx( NULL, COINIT_MULTITHREADED );

	if( FAILED( hr ) )
	{
		LogError( TEXT( "RecycleApplicationPool(): CoInitializeEx() failed" ), HRESULT_CODE( hr ) );
		return hr;
	}

	hr = CoCreateInstance(
		CLSID_WamAdmin,
		NULL,
		CLSCTX_ALL,
		IID_IWamAdmin,
		(void**)&pIWamAdmin );

	if( FAILED( hr ) )  
	{
		LogError( TEXT( "RecycleApplicationPool(): CoCreateInstance() failed" ), HRESULT_CODE(hr) );
		return hr;
	}

	hr = pIWamAdmin->QueryInterface( IID_IIISApplicationAdmin, (void **) &pIIISApplicationAdmin );

	if( FAILED( hr ) )  
	{
		LogError( TEXT( "RecycleApplicationPool(): QueryInterface() failed" ), HRESULT_CODE(hr) );
		return hr;
	}

	return ERROR_SUCCESS;
}

//--------------------------------------------------------------------------

CUDDIAppPool::~CUDDIAppPool( void )
{
	ENTER();

	if( pIIISApplicationAdmin )
		pIIISApplicationAdmin->Release();

	CoUninitialize();
}

//--------------------------------------------------------------------------
// recycle the UDDI app pool
HRESULT CUDDIAppPool::Recycle( void )
{
	ENTER();

	HRESULT hr = Init();
	if( FAILED( hr ) )  
	{
		Log( TEXT( "Error recycling the UDDI application pool = %d" ), HRESULT_CODE( hr ) );
		return hr;
	}

	hr = pIIISApplicationAdmin->RecycleApplicationPool( APPPOOLNAME );

	if( HRESULT_CODE(hr) == ERROR_OBJECT_NOT_FOUND )
	{
		//
		// the RecycleApplicationPool() method returns an Object Not Found error if you try to 
		// recycle the app pool when the app pool is not running
		//
		Log( TEXT( "The Application Pool %s is NOT running - unable to recycle this pool" ), APPPOOLNAME );
	}
	else if( FAILED( hr ) )  
	{
		Log( TEXT( "Error recycling the UDDI application pool = %d" ), HRESULT_CODE( hr ) );
	}

	return hr;
}

//--------------------------------------------------------------------------
// delete an app pool
HRESULT CUDDIAppPool::Delete( void )
{
	ENTER();

	//
	// init the com interface to the IIS metabase
	//
	HRESULT hr = Init();
	if( FAILED( hr ) )  
	{
		Log( TEXT( "Error stopping UDDI application pool = %d" ), HRESULT_CODE( hr ) );
		return hr;
	}

	//
	// enumerate all the applications in the app pool and delete them
	//
	BSTR bstrBuffer;
	while( ERROR_SUCCESS == pIIISApplicationAdmin->EnumerateApplicationsInPool( APPPOOLNAME, &bstrBuffer ) )
	{
		//
		// returns an empty string when done
		//
		if( 0 == _tcslen( bstrBuffer ) )
			break;

		//
		// unload the application
		//
		if ( pIWamAdmin )
		{
			pIWamAdmin->AppUnLoad( bstrBuffer, true );
		}

		//
		// delete this application
		//
		hr = pIIISApplicationAdmin->DeleteApplication( bstrBuffer, true );

		SysFreeString( bstrBuffer );

		if( FAILED( hr ) )
		{
			Log( TEXT( "Error deleting UDDI application from the app pool, error = %d" ), HRESULT_CODE( hr ) );
			return hr;
		}
	}

	//
	// delete the application pool
	//
	hr = pIIISApplicationAdmin->DeleteApplicationPool( APPPOOLNAME );
	if( FAILED( hr ) )
	{
		Log( TEXT( "Error deleting the UDDI application pool = %d" ), HRESULT_CODE( hr ) );
		return hr;
	}

	return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\setup\shared\apppool.h ===
#pragma once

#ifndef INITGUID
#define INITGUID
#endif

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0500
#endif

#include <windows.h>
#include <iwamreg.h>    // MD_ & IIS_MD_ defines
//#include "webcaum.h"

#define APPPOOLNAME                                     TEXT( "MSUDDIAppPool" )

#define DEFAULTLOADFILE                         TEXT( "default.aspx" )

#define UDDIAPPLICATIONNAME                     TEXT( "uddi" )
#define UDDIAPPLICATIONFRIENDLYNAME     TEXT( "UDDI Services User Interface" )

#define APIAPPLICATIONNAME                      TEXT( "uddipublic" )
#define APIAPPLICATIONFRIENDLYNAME      TEXT( "UDDI Services API" )

#ifndef MD_APPPOOL_IDENTITY_TYPE_LOCALSYSTEM
#define MD_APPPOOL_IDENTITY_TYPE_LOCALSYSTEM          0
#define MD_APPPOOL_IDENTITY_TYPE_LOCALSERVICE         1
#define MD_APPPOOL_IDENTITY_TYPE_NETWORKSERVICE       2
#define MD_APPPOOL_IDENTITY_TYPE_SPECIFICUSER         3
#endif


class CUDDIAppPool
{
private:
        IWamAdmin* pIWamAdmin;
        IIISApplicationAdmin* pIIISApplicationAdmin;
        HRESULT Init( void );

public:
        CUDDIAppPool( void ) { pIIISApplicationAdmin = NULL; }
        ~CUDDIAppPool( void );
        HRESULT Recycle( void );
        HRESULT Delete( void );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\setup\shared\propertybag.h ===
//-----------------------------------------------------------------------------------------

#pragma once

#include <assert.h>
#include <shlwapi.h>
#include "strlist.h"

#define CA_PROPERTY_LEN	100
#define CA_VALUE_LEN	100

//-----------------------------------------------------------------------------------------
// define a list that will hold MSI property/value pairs
//

class CPropertyBag
{
private:
	CStrList	list;

public:

	CPropertyBag( void )
	{
	}

	//---------------------------------------------------------

	void Add( LPCTSTR szProperty, LPCTSTR szValue )
	{
		list.AddValue ( szProperty, szValue );
	}


	//---------------------------------------------------------

	void Add( LPCTSTR szProperty, DWORD dwValue )
	{
		TCHAR szValue[ 100 ];
		_stprintf( szValue, TEXT( "%d" ), dwValue );
		Add( szProperty, szValue );
	}

	//---------------------------------------------------------

	void Delete( LPCTSTR szProperty )
	{
		list.RemoveByKey ( szProperty );
	}

	//---------------------------------------------------------

	LPTSTR ConcatValuePairs (LPCTSTR separator, LPTSTR outBuf)
	{
		if (!outBuf) 
			return NULL;

		list.ConcatKeyValues ( separator, outBuf );	
		return outBuf;
	}


	//---------------------------------------------------------

	void Clear( void ) 
	{
		list.RemoveAll ();
	}

	//---------------------------------------------------------

	LPCTSTR GetString( LPCTSTR szProperty, LPTSTR buf )
	{
		return list.Lookup (szProperty, buf);
	}

	//---------------------------------------------------------

	DWORD GetValue( LPCTSTR szProperty )
	{
		TCHAR buf [256];

		if ( list.Lookup (szProperty, buf) )
		{
			DWORD numRes = _ttoi( buf );
			return numRes;
		}
		else
			return (DWORD)-1;
	}
	
	//---------------------------------------------------------

	bool Parse( LPTSTR szPropertyString, DWORD dwStrLen )
	{
		// property1=value1;property2=value2;
		assert( szPropertyString );
		assert( _tcslen(szPropertyString) > 0 );

		if( NULL == szPropertyString || 0 == _tcslen( szPropertyString ) )
		{
			return false;
		}

		//
		// trim space, commas and semicolons
		//
		StrTrim( szPropertyString, TEXT( " ;," ) );

		//
		// add a semicolon to the end
		//
		if( _tcslen( szPropertyString ) < dwStrLen - 1)
			_tcscat( szPropertyString, TEXT( ";" ) );
		else
		{
			assert( false );
			return false;
		}

		// parse out the pairs
		PTCHAR pProperty = szPropertyString;
		PTCHAR pValue = NULL;

		TCHAR szProperty[ 100 ];
		TCHAR szValue[ 100 ];

		while( *pProperty )
		{
			//
			// the value starts 1 char after the next "="
			//
			pValue = _tcschr(pProperty, TEXT('='));
			if( NULL == pValue )
			{
				assert( false );
				return false;
			}

			//
			// make sure the property value was not blank
			//
			if( pProperty == pValue )
			{
				assert( false );
				return false;
			}

			//
			// put a NULL there to mark the end of the Property
			//
			*pValue = NULL;

			//
			// the value starts after the "="
			//
			pValue++;

			//
			// capture the Property
			//
			_tcsncpy( szProperty, pProperty, sizeof( szProperty ) / sizeof( TCHAR ) );

			//
			// move the property pointer ahead to the next ";"
			//
			//
			pProperty = _tcschr(pValue, TEXT(';'));
			if( NULL == pProperty )
			{
				assert( false );
				return false;
			}

			//
			// null it out to mark the end of the previous value
			//
			*pProperty = NULL;

			//
			// set over the null to the start of the next property (or the end of the string)
			//
			pProperty++;

			//
			// capture the value
			//
			_tcsncpy( szValue, pValue, sizeof( szValue ) / sizeof( TCHAR ) );

			Add( szProperty, szValue );
		}

		return true;
	}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\setup\shared\common.cpp ===
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0510
#endif

#include <windows.h>
#include <tchar.h>

#include <assert.h>
#include <time.h>

#include "common.h"

#define _ATL_CSTRING_EXPLICIT_CONSTRUCTORS	// some CString constructors will be explicit
#include <atlbase.h>

//--------------------------------------------------------------------------

void MyOutputDebug(TCHAR *fmt, ...)
{
#if defined( DBG ) || defined( _DEBUG )
	TCHAR szTime[ 10 ];
	TCHAR szDate[ 10 ];
	::_tstrtime( szTime );
	::_tstrdate( szDate );

	va_list marker;
	TCHAR szBuf[1024];

	size_t cbSize = ( sizeof( szBuf ) / sizeof( TCHAR ) ) - 1; // one byte for null
	_sntprintf( szBuf, cbSize, TEXT( "%s %s: " ), szDate, szTime );
	szBuf[ 1023 ] = '\0';
	cbSize -= _tcslen( szBuf );

	va_start( marker, fmt );

	_vsntprintf( szBuf + _tcslen( szBuf ), cbSize, fmt, marker );
	szBuf[ 1023 ] = '\0';
	cbSize -= _tcslen( szBuf );

	va_end( marker );

	_tcsncat(szBuf, TEXT("\r\n"), cbSize );

	OutputDebugString(szBuf);
#endif
}
//--------------------------------------------------------------------------

void Log( LPCTSTR fmt, ... )
{
	TCHAR szTime[ 10 ];
	TCHAR szDate[ 10 ];
	::_tstrtime( szTime );
	::_tstrdate( szDate );

	va_list marker;
	TCHAR szBuf[1024];

	size_t cbSize = ( sizeof( szBuf ) / sizeof( TCHAR ) ) - 1; // one byte for null
	_sntprintf( szBuf, cbSize, TEXT( "%s %s: " ), szDate, szTime );
	szBuf[ 1023 ] = '\0';
	cbSize -= _tcslen( szBuf );

	va_start( marker, fmt );

	_vsntprintf( szBuf + _tcslen( szBuf ), cbSize, fmt, marker );
	szBuf[ 1023 ] = '\0';
	cbSize -= _tcslen( szBuf );

	va_end( marker );

	_tcsncat(szBuf, TEXT("\r\n"), cbSize );

#if defined( DBG ) || defined( _DEBUG )
	OutputDebugString(szBuf);
#endif

	// write the data out to the log file
	//char szBufA[ 1024 ];
	//WideCharToMultiByte( CP_ACP, 0, szBuf, -1, szBufA, 1024, NULL, NULL );

	TCHAR szLogFile[ MAX_PATH + 1 ];
	if( 0 == GetWindowsDirectory( szLogFile, MAX_PATH + 1 ) )
		return;

	_tcsncat( szLogFile, TEXT( "\\uddisetup.log" ), MAX_PATH - _tcslen( szLogFile ) );
	szLogFile[ MAX_PATH ] = NULL;

	HANDLE hFile = CreateFile(
		szLogFile,                    // file name
		GENERIC_WRITE,                // open for writing 
		0,                            // do not share 
		NULL,                         // no security 
		OPEN_ALWAYS,                  // open and create if not exists
		FILE_ATTRIBUTE_NORMAL,        // normal file 
		NULL);                        // no attr. template 

	if( hFile == INVALID_HANDLE_VALUE )
	{ 
		assert( false );
		return;
	}

	//
	// move the file pointer to the end so that we can append
	//
	SetFilePointer( hFile, 0, NULL, FILE_END );

	DWORD dwNumberOfBytesWritten;
	BOOL bOK = WriteFile(
		hFile,
		szBuf,
		(UINT) _tcslen( szBuf ) * sizeof( TCHAR ),     // number of bytes to write
		&dwNumberOfBytesWritten,                       // number of bytes written
		NULL);                                         // overlapped buffer

	assert( bOK );

	FlushFileBuffers ( hFile );
	CloseHandle( hFile );
}

//-----------------------------------------------------------------------------------------

void ClearLog()
{
	/*
	TCHAR szLogFile[ MAX_PATH ];
	if( 0 == GetWindowsDirectory( szLogFile, MAX_PATH ))
	{
		return;
	}
	_tcscat( szLogFile, TEXT( "\\" ) );
	_tcscat( szLogFile, UDDI_SETUP_LOG );

	::DeleteFile( szLogFile );
	*/
	Log( TEXT( "*******************************************************" ) );
	Log( TEXT( "********** Starting a new log *************************" ) );
	Log( TEXT( "*******************************************************" ) );

	//
	// now get the resource stamp
	//
	TCHAR szVerStamp[ 256 ];
	ZeroMemory( szVerStamp, sizeof szVerStamp );

	int iRet = GetFileVersionStr( szVerStamp, sizeof szVerStamp / sizeof szVerStamp[0] );
	if ( iRet )
	{
		Log( TEXT( "OCM DLL Version is not available" ) );
	}
	else
	{
		Log( TEXT( "OCM DLL Version is '%s'" ), szVerStamp );
	}
}

//-----------------------------------------------------------------------------------------

void LogError( PTCHAR szAction, DWORD dwErrorCode )
{
	LPVOID lpMsgBuf = NULL;

	FormatMessage( 
		FORMAT_MESSAGE_ALLOCATE_BUFFER | 
		FORMAT_MESSAGE_FROM_SYSTEM | 
		FORMAT_MESSAGE_IGNORE_INSERTS,
		NULL,
		dwErrorCode,
		MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
		(LPTSTR) &lpMsgBuf,
		0,
		NULL 
	);

	Log( TEXT( "----------------------------------------------------------" ) );
	Log( TEXT( "An error occurred during installation. Details follow:" ) );
	Log( TEXT( "Action: %s" ), szAction );
	Log( TEXT( "Message: %s" ), lpMsgBuf );
	Log( TEXT( "----------------------------------------------------------" ) );

	LocalFree( lpMsgBuf );
}

//--------------------------------------------------------------------------
/*
void Enter( PTCHAR szMsg )
{
#ifdef _DEBUG
	TCHAR szEnter[ 512 ];
	_stprintf( szEnter, TEXT( "Entering %s..." ), szMsg );
	Log( szEnter );
#endif
}
*/
//--------------------------------------------------------------------------
//
// NOTE: The install path has a trailing backslash
//
bool GetUDDIInstallPath( PTCHAR szInstallPath, DWORD dwLen )
{
	HKEY hKey;

	//
	// get the UDDI installation folder [TARGETDIR] from the registry.  The installer squirrels it away there.
	//
	LONG iRet = RegOpenKeyEx( HKEY_LOCAL_MACHINE, TEXT( "SOFTWARE\\Microsoft\\UDDI" ), NULL, KEY_READ, &hKey );
	if( ERROR_SUCCESS != iRet )
	{
		LogError( TEXT( "Unable to open the UDDI registry key" ), iRet );
		return false;
	}
	
	DWORD dwType = REG_SZ;
	iRet = RegQueryValueEx( hKey, TEXT( "InstallRoot" ), 0, &dwType, (PBYTE) szInstallPath, &dwLen );
	if( ERROR_SUCCESS != iRet )
	{
		LogError( TEXT( "UDDI registry key did not have the InstallRoot value or buffer size was too small" ), iRet );
	}
	
	RegCloseKey( hKey );
	return ERROR_SUCCESS == iRet ? true : false;
}

//---------------------------------------------------------------------------------
// Retrieves the calling module file version string
//
int GetFileVersionStr( LPTSTR outBuf, DWORD dwBufCharSize )
{
	if ( IsBadStringPtr( outBuf, dwBufCharSize ) )
		return E_INVALIDARG;

	TCHAR fname[ MAX_PATH + 1 ];
	UINT cbSize;
	DWORD dwTmp;	
	ZeroMemory (fname, sizeof fname);

	GetModuleFileName( NULL, fname, MAX_PATH );

	DWORD dwSize = GetFileVersionInfoSize( fname, &dwTmp );

	if (dwSize)
	{
		LANGANDCODEPAGE *lpCodePage = NULL;
		LPTSTR lpBlock = NULL;
		TCHAR subBlock[ 256 ];

		LPBYTE pVerBlock = new BYTE[dwSize + 1];
		if ( !pVerBlock )
			return E_OUTOFMEMORY;

		ZeroMemory (pVerBlock, dwSize + 1);

		BOOL bRes = GetFileVersionInfo( fname, dwTmp, dwSize, pVerBlock );
		if (!bRes)  // there is no resource block
		{
			delete[] pVerBlock;
			return GetLastError();
		}

		bRes = VerQueryValue(pVerBlock, TEXT("\\VarFileInfo\\Translation"),
							 (LPVOID*)&lpCodePage,
							 &cbSize);
		if (!bRes)
		{
			delete[] pVerBlock;
			return GetLastError();
		}

		_stprintf( subBlock, TEXT("\\StringFileInfo\\%04x%04x\\FileVersion"),
				   lpCodePage->wLanguage,
                   lpCodePage->wCodePage);
		
		// Retrieve file description for language and code page "i". 
		bRes = VerQueryValue(pVerBlock, subBlock, (LPVOID *)&lpBlock, &cbSize); 
		if (!bRes)
		{
			delete[] pVerBlock;
			return GetLastError();
		}

		_tcsncpy( outBuf, lpBlock, dwBufCharSize );
		delete[] pVerBlock;
		return 0;
	}

	return ERROR_RESOURCE_DATA_NOT_FOUND;
}


//---------------------------------------------------------------------------------------
// Retrieves the SID and converts it to the string representation
//
BOOL GetLocalSidString( WELL_KNOWN_SID_TYPE sidType, LPTSTR szOutBuf, DWORD cbOutBuf )
{
	BYTE	tmpBuf[ 1024 ];
	LPTSTR	szTmpStr = NULL;
	DWORD	cbBuf = sizeof tmpBuf;

	BOOL bRes = CreateWellKnownSid( sidType, NULL, tmpBuf, &cbBuf );
	if( !bRes )
		return FALSE;

	bRes = ConvertSidToStringSid( tmpBuf, &szTmpStr );
	if( !bRes )
		return FALSE;

	_tcsncpy( szOutBuf, szTmpStr, cbOutBuf );
	LocalFree( szTmpStr );
	
	return TRUE;
}


BOOL GetLocalSidString( LPCTSTR szUserName, LPTSTR szOutBuf, DWORD cbOutBuf )
{
	TCHAR	szDomain[ 1024 ];
	LPTSTR	szTmpStr = NULL;
	DWORD	cbDomain = sizeof( szDomain ) / sizeof( szDomain[0] );
	
	SID_NAME_USE pUse;

	//
	// Try to allocate a buffer for the SID.
	//
	DWORD cbMaxSid = SECURITY_MAX_SID_SIZE;
	PSID psidUser = LocalAlloc( LMEM_FIXED, cbMaxSid );
	if( NULL == psidUser )
	{
		Log( _T( "Call to LocalAlloc failed." ) );
		return FALSE;
	}
	memset( psidUser, 0, cbMaxSid );

	BOOL bRes = LookupAccountName( NULL, szUserName, psidUser, &cbMaxSid, szDomain, &cbDomain, &pUse );
	if( !bRes )
	{
		LocalFree( psidUser );
		return FALSE;
	}

	bRes = ConvertSidToStringSid( psidUser, &szTmpStr );
	if( !bRes )
	{
		LocalFree( psidUser );
		return FALSE;
	}

	_tcsncpy( szOutBuf, szTmpStr, cbOutBuf );
	LocalFree( szTmpStr );
	LocalFree( psidUser );

	return TRUE;
}


BOOL GetRemoteAcctName( LPCTSTR szMachineName, LPCTSTR szSidStr, LPTSTR szOutStr, LPDWORD cbOutStr, LPTSTR szDomain, LPDWORD cbDomain )
{
	PSID	pSid = NULL;
	SID_NAME_USE puse;

	BOOL bRes = ConvertStringSidToSid( szSidStr, &pSid );
	if( !bRes )
		return FALSE;

	bRes = LookupAccountSid( szMachineName, pSid, szOutStr, cbOutStr, szDomain, cbDomain, &puse );
	LocalFree( pSid );

	return bRes;
}



HRESULT GetOSProductSuiteMask( LPCTSTR szRemoteServer, UINT *pdwMask )
{
	HRESULT hr = S_OK;
	BSTR bstrWQL = NULL;

	if ( IsBadWritePtr( pdwMask, sizeof UINT ) )
		return E_INVALIDARG;

	hr = CoInitializeEx( 0, COINIT_SPEED_OVER_MEMORY | COINIT_MULTITHREADED );
	if ( FAILED( hr ) )
		return hr;

	try
	{
		DWORD		retCount = 0;
		TCHAR		buf[ 512 ] = {0};
		LPCTSTR		locatorPath = L"//%s/root/cimv2";	
		CComBSTR	objQry = L"SELECT * FROM Win32_OperatingSystem";

		CComPtr<IWbemClassObject>		pWMIOS;
		CComPtr<IWbemServices>			pWMISvc;	
		CComPtr<IWbemLocator>			pWMILocator;
		CComPtr<IEnumWbemClassObject>	pWMIEnum;

		//
		// First, compose the locator string
		//
		if ( szRemoteServer )
		{
			_stprintf( buf, locatorPath, szRemoteServer );
		}
		else
		{
			_stprintf( buf, locatorPath, _T(".") );
		}

		BSTR bstrBuf = ::SysAllocString( buf );
		if( NULL == bstrBuf )
		{
			throw hr;
		}

		//
		// now create the locator and set up the security blanket
		//
		hr = CoInitializeSecurity( NULL, -1, NULL, NULL, 
								RPC_C_AUTHN_LEVEL_DEFAULT, 
								RPC_C_IMP_LEVEL_IMPERSONATE, 
								NULL, EOAC_NONE, NULL);
		if ( FAILED( hr ) && hr != RPC_E_TOO_LATE )
		{
			::SysFreeString( bstrBuf );
			throw hr;
		}

		hr = pWMILocator.CoCreateInstance( CLSID_WbemLocator );
		if( FAILED(hr) )
		{
			::SysFreeString( bstrBuf );
			throw hr;
		}
		
		hr = pWMILocator->ConnectServer( bstrBuf, NULL, NULL, NULL, 
										WBEM_FLAG_CONNECT_USE_MAX_WAIT, 
										NULL, NULL, &pWMISvc );

		::SysFreeString( bstrBuf );
		if( FAILED(hr) )
		{
			throw hr;
		}

		hr = CoSetProxyBlanket( pWMISvc,
								RPC_C_AUTHN_WINNT,
								RPC_C_AUTHZ_NONE,
								NULL,
								RPC_C_AUTHN_LEVEL_CALL,
								RPC_C_IMP_LEVEL_IMPERSONATE,
								NULL,
								EOAC_NONE );
		if( FAILED(hr) )
		{
			throw hr;
		}

		//
		// Now get the Win32_OperatingSystem instances and check the first one found
		//
		bstrWQL = ::SysAllocString( L"WQL" );
		if( NULL == bstrWQL )
		{
			throw hr;
		}

		hr = pWMISvc->ExecQuery( bstrWQL, objQry, 
								 WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_ENSURE_LOCATABLE, 
								 NULL, &pWMIEnum );
		if (FAILED(hr))
			throw hr;
	
		hr = pWMIEnum->Next( 60000, 1, &pWMIOS, &retCount );
		if ( hr == WBEM_S_NO_ERROR )
		{
			VARIANT vt;
			CIMTYPE	cimType;
			long	flavor = 0;

			ZeroMemory( &vt, sizeof vt );
			VariantInit ( &vt );

			hr = pWMIOS->Get( L"SuiteMask", 0, &vt, &cimType, &flavor );
			if ( FAILED( hr ) ) 
				throw hr;

			if ( vt.vt == VT_NULL || vt.vt == VT_EMPTY )
				throw E_FAIL;

			hr = VariantChangeType( &vt, &vt, 0, VT_UINT );
			if ( FAILED( hr ) )
				throw hr;

			*pdwMask = vt.uintVal;
			VariantClear( &vt );
		}
	}
	catch ( HRESULT hrErr )
	{
		hr = hrErr;
		::SysFreeString( bstrWQL );                // it's OK to call SysFreeString with NULL.
	}
	catch (...)
	{
		hr = E_UNEXPECTED;
	}

	CoUninitialize();
	return hr;
}


HRESULT IsStandardServer( LPCTSTR szRemoteServer, BOOL *bResult )
{
	if ( IsBadWritePtr( bResult, sizeof BOOL ) )
		return E_INVALIDARG;

	UINT uMask = 0;
	HRESULT hr = GetOSProductSuiteMask( szRemoteServer, &uMask );
	if ( FAILED( hr ) )
		return hr;

	if ( ( uMask & VER_SUITE_DATACENTER ) || ( uMask & VER_SUITE_ENTERPRISE ) )
		*bResult = FALSE;
	else
		*bResult = TRUE;

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\setup\shared\strlist.cpp ===
#include <windows.h>
#include <tchar.h>
#include <stdlib.h>

#include "strlist.h"

//**********************************************************************************
// Implements the StrList, a double-linked list that maintains a list of value
// entries, each assosiated with a unique key
//

elt* CStrList::FindElement ( LPCTSTR key )
{
	elt*	pelt = NULL;

	if (!count)
		return NULL;
	
	if (!key)
		return NULL;

	if (!_tcslen(key))
		return NULL;

	try
	{
		Lock();

		for ( pelt = head; pelt; pelt = pelt->next )
		{
			if (!_tcscmp(key, pelt->key)) // found it!
			{
				Unlock ();
				return pelt;
			}
		}

		Unlock ();
	}
	catch (...)
	{
		Unlock ();
	}

	return NULL;
}


bool CStrList::AddValue	( LPCTSTR key, LPCTSTR val )
{
	elt *pelt = NULL;

	if (!key || !val)
		return false;

	if (!_tcslen(key))
		return false;

	try
	{
		Lock ();

		pelt = FindElement (key);
		if (pelt)
		{
			free (pelt->val);
			pelt->val = _tcsdup (val);
		}
		else
		{
			pelt = new elt;
			if ( !pelt )
				return false;

			pelt->key = _tcsdup (key);
			pelt->val = _tcsdup (val);
			pelt->next = head;
			pelt->prev = NULL;
			if (head)
				head->prev = pelt;
			head = pelt;
			count++;
		}

		Unlock ();
	}
	catch (...)
	{
		Unlock ();
		return false;
	}

	return true;
}


LPTSTR	CStrList::Lookup ( LPCTSTR key, LPTSTR outBuf )
{
	elt *pelt = FindElement (key);
	if (!pelt)
		return NULL;

	_tcscpy (outBuf, pelt->val);
	return outBuf;
}


void CStrList::RemoveByKey ( LPCTSTR key )
{
	Lock ();

	try
	{
		elt *pelt = FindElement (key);
		if (!pelt)
		{
			Unlock ();
			return;
		}

		if (pelt->prev)
			pelt->prev->next = pelt->next;
		else
			head = pelt->next;

		if (pelt->next)
			pelt->next->prev = pelt->prev;

		count--;
		delete pelt;
	}
	catch (...)
	{
	}

	Unlock ();
}


void CStrList::RemoveAll ()
{
	elt *pelt = NULL;

	Lock ();

	try
	{
		while (head)
		{
			pelt = head;
			head = head->next;
			count--;
			delete pelt;
		}
	}
	catch (...)
	{
	}

	Unlock ();
}


LPTSTR	CStrList::ConcatKeyValues ( LPCTSTR separator, LPTSTR outBuf )
{
	if (!outBuf)
		return NULL;

	if (!separator)
		return NULL;

	Lock ();

	try
	{
		_tcscpy (outBuf, _T(""));
		for (elt *pelt = head; pelt; pelt = pelt->next)
		{
			_tcscat (outBuf, pelt->key);
			_tcscat (outBuf, _T("=\""));
			_tcscat (outBuf, pelt->val);
			_tcscat (outBuf, _T("\""));
			_tcscat (outBuf, separator);
		}
	}
	catch (...)
	{
		Unlock ();
		return NULL;
	}

	Unlock ();
	return outBuf;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\setup\uddimsifiler\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by CreateMSICABMakefile.rc
//
#define IDS_HELLO                       1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\setup\shared\common.h ===
#pragma once

#ifndef _WIN32_WINNT		// Allow use of features specific to Windows NT 4 or later.
#define _WIN32_WINNT 0x0510		// Change this to the appropriate value to target Windows 98 and Windows 2000 or later.
#endif						

#include <windows.h>
#include <sddl.h>
#include <tchar.h>

#include <wbemidl.h>

//
// This struct is used by the version api
//
typedef struct  
{
	WORD wLanguage;
	WORD wCodePage;
} LANGANDCODEPAGE;


void MyOutputDebug(TCHAR *fmt, ...);
void ClearLog();
void Log( LPCTSTR fmt, ... );
void LogError( PTCHAR szAction, DWORD dwErrorCode );
bool GetUDDIInstallPath( PTCHAR szInstallPath, DWORD dwLen );
int  GetFileVersionStr( LPTSTR outBuf, DWORD dwBufCharSize );

HRESULT GetOSProductSuiteMask( LPCTSTR szRemoteServer, UINT *pdwMask );
HRESULT IsStandardServer( LPCTSTR szRemoteServer, BOOL *bResult );

BOOL GetLocalSidString( WELL_KNOWN_SID_TYPE sidType, LPTSTR szOutBuf, DWORD cbOutBuf );
BOOL GetLocalSidString( LPCTSTR szUserName, LPTSTR szOutBuf, DWORD cbOutBuf );
BOOL GetRemoteAcctName( LPCTSTR szMachineName, LPCTSTR szSidStr, LPTSTR szOutStr, LPDWORD cbOutStr, LPTSTR szDomain, LPDWORD cbDomain );


#define ENTER()	CFunctionMarker fa( __FUNCTION__ )

class CFunctionMarker
{
private:
	TCHAR m_szFunctionName[100];

public:
	CFunctionMarker( char *aszFunctionName )
	{
#ifdef _UNICODE
		int iCount = MultiByteToWideChar( 
			CP_ACP, 
			0, 
			aszFunctionName, 
			-1, 
			m_szFunctionName, 
			sizeof( m_szFunctionName ) / sizeof( TCHAR ) );
#else
		strncpy( m_szFunctionName, aszFunctionName, sizeof( m_szFunctionName ) );
#endif
		Log( TEXT( "Entering %s" ), m_szFunctionName );
	}

	~CFunctionMarker()
	{
		Log( TEXT( "Leaving %s" ), m_szFunctionName );
	}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\setup\uddimsifiler\stdafx.cpp ===
#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\setup\uddimsifiler\uddimsifiler.h ===
#pragma once
#include "resource.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\setup\web\ca\makefile.inc ===
foo.cs:
	..\..\..\version\$(O)\version.exe -outfile .\assemblyversioninfo.cs
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\setup\web\ca.unmanaged\apppool.cpp ===
#include "..\..\shared\apppool.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\setup\shared\strlist.h ===
#pragma once

class elt
{
public:
	LPTSTR	key;
	LPTSTR	val;

	elt		*next, 
			*prev;

	elt()
	{
		next = NULL;
		prev = NULL;

		key = NULL;
		val = NULL;
	}

	virtual ~elt()
	{
		if (key)
			free (key);

		if (val)
			free (val);
	}
};


class CStrList
{
protected:
	elt		*head;
	int		count;
	HANDLE	hmtxLock;

	elt		*FindElement ( LPCTSTR key );
	
	void	Lock ()
	{
		if ( hmtxLock )
			WaitForSingleObject ( hmtxLock, INFINITE );
	}

	void	Unlock ()
	{
		if ( hmtxLock )
			ReleaseMutex ( hmtxLock );
	}

public:
	CStrList()
	{
		head = NULL;
		count = 0;
		hmtxLock = CreateMutex ( NULL, FALSE, NULL );
	}

	virtual ~CStrList()
	{
		RemoveAll();
		CloseHandle ( hmtxLock );
	}

	bool	AddValue	( LPCTSTR key, LPCTSTR val );
	LPTSTR	Lookup		( LPCTSTR key, LPTSTR outBuf );
	void	RemoveByKey ( LPCTSTR key );
	void	RemoveAll   ();
	LPTSTR	ConcatKeyValues ( LPCTSTR separator, LPTSTR outBuf );
	
	int		GetCount	() 
	{
		return count;
	}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\setup\web\ca.unmanaged\common.cpp ===
#include "..\..\shared\common.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\setup\uddimsifiler\stdafx.h ===
// stdafx.h : include file for standard system include files,
// or project specific include files that are used frequently, but
// are changed infrequently
//

#pragma once

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>

#ifdef  _WIN32_MSI 
#undef  _WIN32_MSI 
#endif

#define _WIN32_MSI 200

#include <msi.h>
#include <msiquery.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\setup\uddimsifiler\uddimsifiler.cpp ===
//-----------------------------------------------------------------------------

#include "stdafx.h"
#include "uddimsifiler.h"

static PTCHAR GetFileLongName( PTCHAR szFileName );
static PTCHAR GetErrorMsg( UINT iRet );
static bool UpdateFileTable( void );
static bool FileExists( PTCHAR szFileName );
static bool UpdateFile( PTCHAR szFile, PTCHAR szFilePath );
static bool LookupComponentTargetFolder( PTCHAR szComponent, PTCHAR szComponentFolder );
static bool UpdateFileHash( PTCHAR szFile, PTCHAR szFilePath );
static bool UpdateMSIVerFromFile( LPCTSTR szFile );
static void LogError( LPCTSTR fmt, ... );

PMSIHANDLE g_hDatabase;
TCHAR g_MSIFile[ MAX_PATH + 1 ];
TCHAR g_LogFile[ MAX_PATH + 1 ];
TCHAR g_SourceDir[ MAX_PATH + 1 ];
TCHAR g_VerFile[ MAX_PATH + 1 ];

//--------------------------------------------------------------

int __cdecl _tmain( int argc, TCHAR* argv[], TCHAR* envp[] )
{
	UINT iRet = 0;

	bool bDisplayUsage = false;

	ZeroMemory( g_MSIFile, sizeof g_MSIFile );
	ZeroMemory( g_LogFile, sizeof g_LogFile );
	ZeroMemory( g_VerFile, sizeof g_VerFile );
	ZeroMemory( g_SourceDir, sizeof g_SourceDir );

	if ( argc > 1 )
	{
		// loop through all the arguments
		for ( int i=1; i<argc; i++ )
		{
			// -d is the path to the msi file
			if ( _tcscmp( argv[ i ], TEXT( "-d" ) )==0 )
			{
				i++;
				if ( i >= argc )
				{
					bDisplayUsage = true;
					break;
				}

				_tcscpy( g_MSIFile, argv[ i ] );

				continue;
			}

			// -s is the path to the source files
			if( 0 == _tcscmp( argv[ i ], TEXT( "-s" ) ) )
			{
				i++;
				if ( i >= argc )
				{
					bDisplayUsage = true;
					break;
				}

				_tcscpy( g_SourceDir, argv[ i ] );

				continue;
			}

			// -L is the log file
			if( 0 == _tcsicmp( argv[ i ], TEXT( "-L" ) ) )
			{
				i++;
				if ( i >= argc )
				{
					bDisplayUsage = true;
					break;
				}

				_tcscpy( g_LogFile, argv[ i ] );

				continue;
			}

			// -v is a file containing the version stamp
			if( 0 == _tcsicmp( argv[ i ], TEXT( "-v" ) ) )
			{
				i++;
				if ( i >= argc )
				{
					bDisplayUsage = true;
					break;
				}

				_tcscpy( g_VerFile, argv[ i ] );

				continue;
			}

		}
	}

	// usage
	if ( bDisplayUsage || argc == 1 || NULL != _tcsrchr( argv[ 1 ], '?' ) )
	{
		_tprintf( TEXT( "Updates the File Table with files in a folder ( using File.File key names )\n\n" ) );
		_tprintf( TEXT( "Usage: %s -d <MSI database> -s <location of files> [ -L <log file> ] [-v <product version file>]\n\n" ), argv[ 0 ] );
		return 0;
	}

	//
	// open the database
	//
	if( !FileExists( g_MSIFile ) )
	{
		LogError( TEXT( "***ERROR: MSI File does not exist: %s" ), g_MSIFile );
		return 1;
	}

	//
	// open the MSI file
	//
	iRet = MsiOpenDatabase( g_MSIFile, MSIDBOPEN_TRANSACT, &g_hDatabase );
	if( ERROR_SUCCESS != iRet )
	{
		LogError( TEXT( "***ERROR: MsiOpenDatabase Error: %s" ), GetErrorMsg( iRet ) );
		return 1;
	}

	bool bRet = UpdateFileTable();

	//
	// update the ProductVersion property
	//
	UpdateMSIVerFromFile( g_VerFile );

	iRet = MsiDatabaseCommit( g_hDatabase );
	if( ERROR_SUCCESS != iRet )
	{
		LogError( TEXT( "***ERROR: MsiDatabaseCommit Error: %s" ), GetErrorMsg( iRet ) );
		return 0;
	}

	return bRet ? 0 : 1;
}

//--------------------------------------------------------------

static bool UpdateFileTable( void )
{
	UINT iRet;
	PMSIHANDLE hView;
	PMSIHANDLE hRecord = 0;

	//
	// open a view and submit the SQL query
	//
	iRet = MsiDatabaseOpenView( g_hDatabase, TEXT( "select File from File" ), &hView );
	if( ERROR_SUCCESS != iRet )
	{
		LogError( TEXT( "***ERROR: MsiDatabaseOpenView Error: %s" ), GetErrorMsg( iRet ) );
		return false;
	}

	//
	// execute the SQL query
	//
	iRet = MsiViewExecute( hView, hRecord );
	if( ERROR_SUCCESS != iRet )
	{
		LogError( TEXT( "***ERROR: MsiViewExecute Error: %s" ), GetErrorMsg( iRet ) );
		return false;
	}

	//
	// fetch the data
	//
	TCHAR szFile[ 256 ];
	TCHAR szFilePath[ 256 ];
	DWORD cchValueBuf;

	while( ERROR_NO_MORE_ITEMS != MsiViewFetch( hView, &hRecord ) )
	{
		cchValueBuf = 256;
		MsiRecordGetString( hRecord, 1, szFile, &cchValueBuf );

		//
		// create the full path to the file in \binaries folder
		//
		_stprintf( szFilePath, TEXT( "%s\\%s" ), g_SourceDir, szFile );
		//LogError( TEXT( "Updating: %s\n" ), szFilePath );

		//
		// does the file exist?
		//
		if( !FileExists( szFilePath ) )
		{
			LogError( TEXT( "***ERROR: Source File does not exist: %s" ), szFilePath );
			return false;
		}

		//
		// update the size, version, language and hash table
		//
		if( !UpdateFile( szFile, szFilePath ) )
		{
			LogError( TEXT( "***ERROR: Unable to update file %s\n" ), szFile );
			return false;
		}
	}

	return true;
}

//--------------------------------------------------------------

static bool UpdateFile( PTCHAR szFile, PTCHAR szFilePath )
{
	PMSIHANDLE hView;
	PMSIHANDLE hRecord = 0;

	//
	// get the version and language of this file
	//
	TCHAR szVersionBuf[ 100 ];
	DWORD dwVersionBuf = 100;
	TCHAR szLanguageBuf[ 100 ];
	DWORD dwLanguageBuf = 100;
	UINT iRet = MsiGetFileVersion( 
		szFilePath,      // path to the file
		szVersionBuf,     // returned version string
		&dwVersionBuf,   // buffer byte count
		szLanguageBuf,        // returned language string
		&dwLanguageBuf );       // buffer byte count

	if ( ERROR_SUCCESS != iRet )
	{
		_tcscpy( szVersionBuf, TEXT( "" ) );
		_tcscpy( szLanguageBuf, TEXT( "" ) );
		UpdateFileHash( szFile, szFilePath );
	}

	//
	// get the file's size
	//
	HANDLE hFile = CreateFile( szFilePath, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
	if( INVALID_HANDLE_VALUE == hFile )
	{
		return false;
	}

	LARGE_INTEGER liSize;
	if( 0 == GetFileSizeEx( hFile, &liSize ) )
	{
		LogError( TEXT( "***ERROR: Unable to get file size for file %s\n" ), szFilePath );
		CloseHandle( hFile );
		return false;
	}

	CloseHandle( hFile );

	//
	// update the file's version, language and size
	//
	TCHAR szSQLQuery[ 256 ];
	_stprintf( szSQLQuery, TEXT( "UPDATE File SET FileSize = ?, Version = ?, Language = ? where File = ?" ) );

	iRet = MsiDatabaseOpenView( g_hDatabase, szSQLQuery, &hView );

	if ( ERROR_SUCCESS != iRet )
	{
		LogError( 0, TEXT( "***ERROR: MsiDatabaseOpenView Error: %s" ), GetErrorMsg( iRet ) );
		return false;
	}

	// create a temp record to store the replacable values
	hRecord = MsiCreateRecord( 4 );
	if ( NULL == hRecord )
	{
		LogError( 0, TEXT( "***ERROR: MsiCreateRecord failed" ) );
		return false;
	}

	int index = 1;

	// Size goes in #1
	iRet = MsiRecordSetInteger( hRecord, index++, liSize.LowPart );
	if ( ERROR_SUCCESS != iRet )
	{
		LogError( 0, TEXT( "***ERROR: MsiRecordSetString Error: %s" ), GetErrorMsg( iRet ) );
		return false;
	}

	// Version goes in #2
	iRet = MsiRecordSetString( hRecord, index++, szVersionBuf );
	if ( ERROR_SUCCESS != iRet )
	{
		LogError( 0, TEXT( "***ERROR: MsiRecordSetString Error: %s" ), GetErrorMsg( iRet ) );
		return false;
	}

	// Language goes in #3
	iRet = MsiRecordSetString( hRecord, index++, szLanguageBuf );
	if ( ERROR_SUCCESS != iRet )
	{
		LogError( 0, TEXT( "***ERROR: MsiRecordSetString Error: %s" ), GetErrorMsg( iRet ) );
		return false;
	}

	// File goes in #4
	iRet = MsiRecordSetString( hRecord, index++, szFile );
	if ( ERROR_SUCCESS != iRet )
	{
		LogError( 0, TEXT( "***ERROR: MsiRecordSetString Error: %s" ), GetErrorMsg( iRet ) );
		return false;
	}

	// execute the update query
	iRet = MsiViewExecute( hView, hRecord );
	if ( ERROR_SUCCESS != iRet )
	{
		LogError( 0, TEXT( "***ERROR: MsiViewExecute Error: %s" ), GetErrorMsg( iRet ) );
		return false;
	}

	return true;
}


//--------------------------------------------------------------

static bool UpdateMSIVerFromFile( LPCTSTR szFileName )
{
	MSIHANDLE hView;
	TCHAR szVersionBuf[ 256 ];
	TCHAR szLanguageBuf[ 256 ];
	TCHAR szQuery[ 256 ];
	DWORD dwLanguageBuf = 0, dwVersionBuf = 0;

	if ( !szFileName ) 
		return false;

	if ( !FileExists( (LPTSTR)szFileName ) )
		return false;

	dwVersionBuf = sizeof szVersionBuf / sizeof szVersionBuf[0]; 
	dwLanguageBuf = sizeof szLanguageBuf / sizeof szLanguageBuf[0]; 
	UINT iRet = MsiGetFileVersion( szFileName,      // path to the file
								   szVersionBuf,     // returned version string
								   &dwVersionBuf,   // buffer byte count
								   szLanguageBuf,        // returned language string
								   &dwLanguageBuf );       // buffer byte count
	if ( iRet != ERROR_SUCCESS )
	{
		LogError( TEXT( "***ERROR: MsiGetFileVersion Error: %s" ), GetErrorMsg( iRet ) );
		return false;
	}

	_tcscpy( szQuery, TEXT( "UPDATE Property SET Property.Value='" ) );
	_tcscat( szQuery, szVersionBuf );
	_tcscat( szQuery, TEXT("' WHERE Property.Property='ProductVersion'") );

	iRet = MsiDatabaseOpenView( g_hDatabase, szQuery, &hView );
	if ( ERROR_SUCCESS != iRet )
	{
		LogError( TEXT( "***ERROR: MsiDatabaseOpenView Error: %s" ), GetErrorMsg( iRet ) );
		return false;
	}

	// execute the update query
	iRet = MsiViewExecute( hView, NULL );
	if ( ERROR_SUCCESS != iRet )
	{
		LogError( TEXT( "***ERROR: MsiViewExecute Error: %s" ), GetErrorMsg( iRet ) );
		MsiCloseHandle( hView );
		return false;
	}

	MsiCloseHandle( hView );
	return true;
}


//--------------------------------------------------------------

static bool UpdateFileHash( PTCHAR szFile, PTCHAR szFilePath )
{
	PMSIHANDLE hView;
	PMSIHANDLE hRecord = 0;

	//
	// get the file's size
	//
	MSIFILEHASHINFO hashinfo;
	hashinfo.dwFileHashInfoSize = sizeof( MSIFILEHASHINFO );
	UINT iRet = MsiGetFileHash( szFilePath, 0, &hashinfo );
	if ( ERROR_SUCCESS != iRet )
	{
		LogError( 0, TEXT( "***ERROR: MsiGetFileHash Error: %s" ), GetErrorMsg( iRet ) );
		return false;
	}

	//
	// update the file's version, language and size
	//
	TCHAR szSQLQuery[ 256 ];
	_stprintf( szSQLQuery, TEXT( "UPDATE MsiFileHash SET HashPart1 = ?, HashPart2 = ?, HashPart3 = ?, HashPart4 = ? where File_ = ?" ) );

	iRet = MsiDatabaseOpenView( g_hDatabase, szSQLQuery, &hView );
	if ( ERROR_SUCCESS != iRet )
	{
		LogError( 0, TEXT( "***ERROR: MsiDatabaseOpenView Error: %s" ), GetErrorMsg( iRet ) );
		return false;
	}

	// create a temp record to store the replacable values
	hRecord = MsiCreateRecord( 5 );
	if ( NULL == hRecord )
	{
		LogError( 0, TEXT( "***ERROR: MsiCreateRecord failed" ) );
		return false;
	}

	int index = 1;

	for( int i=0; i<4; i++ )
	{
		iRet = MsiRecordSetInteger( hRecord, index++, hashinfo.dwData[ i ] );
		if ( ERROR_SUCCESS != iRet )
		{
			LogError( 0, TEXT( "***ERROR: MsiRecordSetInteger Error: %s" ), GetErrorMsg( iRet ) );
			return false;
		}
	}

	// File goes in #5
	iRet = MsiRecordSetString( hRecord, index++, szFile );
	if ( ERROR_SUCCESS != iRet )
	{
		LogError( 0, TEXT( "***ERROR: MsiRecordSetString Error: %s" ), GetErrorMsg( iRet ) );
		return false;
	}

	// execute the update query
	iRet = MsiViewExecute( hView, hRecord );
	if ( ERROR_SUCCESS != iRet )
	{
		LogError( 0, TEXT( "***ERROR: MsiViewExecute Error: %s" ), GetErrorMsg( iRet ) );
		return false;
	}

	return true;
}

//--------------------------------------------------------------

static bool FileExists( PTCHAR szFileName )
{
	FILE *file = _tfopen( szFileName, TEXT( "rt" ) );
	if( NULL == file )
	{
		return false;
	}

	fclose( file );

	return true;
}

//--------------------------------------------------------------

static PTCHAR GetErrorMsg( UINT iRet )
{
	static TCHAR szErrMsg[ 100 ];

	FormatMessage( 
		FORMAT_MESSAGE_FROM_SYSTEM | 
		FORMAT_MESSAGE_IGNORE_INSERTS,
		NULL,
		iRet,
		MAKELANGID( LANG_NEUTRAL, SUBLANG_DEFAULT ), // Default language
		( LPTSTR ) szErrMsg,
		100,
		NULL );

	return szErrMsg;
}

//--------------------------------------------------------------------------

static void LogError( LPCTSTR fmt, ... )
{
	TCHAR szTime[ 10 ];
	TCHAR szDate[ 10 ];
	::_tstrtime( szTime );
	::_tstrdate( szDate );

	va_list marker;
	TCHAR szBuf[ 1024 ];

	size_t cbSize = ( sizeof( szBuf ) / sizeof( TCHAR ) ) - 1; // one byte for null
	_sntprintf( szBuf, cbSize, TEXT( "%s %s: " ), szDate, szTime );
	szBuf[ 1023 ] = '\0';
	cbSize -= _tcslen( szBuf );

	va_start( marker, fmt );

	_vsntprintf( szBuf + _tcslen( szBuf ), cbSize, fmt, marker );
	szBuf[ 1023 ] = '\0';
	cbSize -= _tcslen( szBuf );

	va_end( marker );

	_tcsncat( szBuf, TEXT( "\r\n" ), cbSize );

	_tprintf( TEXT( "%s" ), szBuf );

	if( 0 == _tcslen( g_LogFile ) )
		return;

	// write the data out to the log file
	char szBufA[ 1024 ];
	WideCharToMultiByte( CP_ACP, 0, szBuf, -1, szBufA, 1024, NULL, NULL );

	HANDLE hFile = CreateFile( 
		g_LogFile,                    // file name
		GENERIC_WRITE,                // open for writing 
		0,                            // do not share 
		NULL,                         // no security 
		OPEN_ALWAYS,                  // open and create if not exists
		FILE_ATTRIBUTE_NORMAL,        // normal file 
		NULL );                        // no attr. template 

	if( hFile == INVALID_HANDLE_VALUE )
	{ 
		return;
	}

	//
	// move the file pointer to the end so that we can append
	//
	SetFilePointer( hFile, 0, NULL, FILE_END );

	DWORD dwNumberOfBytesWritten;
	BOOL bOK = WriteFile( 
		hFile,
		szBufA,
		( UINT ) strlen( szBufA ),     // number of bytes to write
		&dwNumberOfBytesWritten,                       // number of bytes written
		NULL );                                         // overlapped buffer

	FlushFileBuffers ( hFile );
	CloseHandle( hFile );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\setup\web\ca.unmanaged\strlist.cpp ===
#include "..\..\shared\strlist.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\setup\web\ca.unmanaged\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by webcaum.rc
//
#define IDS_UDDI_APPLICATION_FRIENDLY_NAME 101
#define IDS_API_APPLICATION_FRIENDLY_NAME 102

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\setup\web\ca.unmanaged\iis.metabase.cpp ===
#ifndef INITGUID
#define INITGUID
#endif

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0500
#endif


#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include <iadmw.h>      // Interface header
#include <iiscnfg.h>    // MD_ & IIS_MD_ defines

#include <objbase.h>

#include "..\..\shared\common.h"   // needed for GetUDDIInstallPath

#include "webcaum.h"
#include "resource.h"

#include <string>
#include <vector>

using namespace std;
#define tstring basic_string <TCHAR>

typedef std::vector<tstring> cStrList;

#define APPPOOLNAME                     TEXT( "MSUDDIAppPool" )

#define DEFAULTLOADFILE                 TEXT( "default.aspx" )

#define UDDIAPPLICATIONNAME             TEXT( "uddi" )
#define UDDIAPPLICATIONDEPENDENCY		TEXT( "UDDI;ASP.NET v1.1.4322" )
#define UDDINTAUTHPROVIDERS				TEXT( "NTLM" )

#define APIAPPLICATIONNAME              TEXT( "uddipublic" )

#ifndef MD_APPPOOL_IDENTITY_TYPE_LOCALSYSTEM
#define MD_APPPOOL_IDENTITY_TYPE_LOCALSYSTEM          0
#define MD_APPPOOL_IDENTITY_TYPE_LOCALSERVICE         1
#define MD_APPPOOL_IDENTITY_TYPE_NETWORKSERVICE       2
#define MD_APPPOOL_IDENTITY_TYPE_SPECIFICUSER         3
#endif

#define REASONABLE_TIMEOUT 1000

BOOL IsInList( LPCTSTR szStrToFind, cStrList *pList, BOOL bIgnoreCase )
{
	if( IsBadReadPtr( pList, sizeof cStrList ) )
		return FALSE;

	BOOL bFound = FALSE;
	for( cStrList::size_type i = 0; ( i < pList->size() ) && !bFound ; i++ )
	{
		LPCTSTR szEntry = (*pList)[i].c_str();

		if ( bIgnoreCase )
			bFound = !_tcsicmp( szEntry, szStrToFind );
		else
			bFound = !_tcscmp( szEntry, szStrToFind );
	}

	return bFound;
}

BOOL RemoveFromList( LPCTSTR szStrToFind, cStrList *pList, BOOL bIgnoreCase )
{
	if( IsBadReadPtr( pList, sizeof cStrList ) )
		return FALSE;

	BOOL bFound = FALSE;
	for( cStrList::size_type i = 0; ( i < pList->size() ) && !bFound ; i++ )
	{
		LPCTSTR szEntry = (*pList)[i].c_str();

		if ( bIgnoreCase )
			bFound = !_tcsicmp( szEntry, szStrToFind );
		else
			bFound = !_tcscmp( szEntry, szStrToFind );

		if( bFound )
		{
			pList->erase(pList->begin() + i);
		}
	}

	return bFound;
}

//--------------------------------------------------------------------------

class CIISObjectBase
{
protected:
        static IMSAdminBase* pIMSAdminBase;
        METADATA_HANDLE m_hMetabase;
        PTCHAR m_szKeyName;
        PTCHAR m_szRoot;

public:
        CIISObjectBase()        : m_hMetabase( NULL ), m_szKeyName( NULL ), m_szRoot( NULL )
        {
        }

        virtual ~CIISObjectBase()
        {
                Release();
        }

        static void Initialize()
        {
                HRESULT hr = CoCreateInstance(
                        CLSID_MSAdminBase,
                        NULL,
                        CLSCTX_ALL,
                        IID_IMSAdminBase,
                        (void**)&pIMSAdminBase );

                if( FAILED( hr ) )  
                {
                        LogError( TEXT( "CIISObjectBase::Initialize::CoCreateInstance() failed..." ), HRESULT_CODE(hr) );
                        throw hr;
                }
        }

        static void Uninitialize()
        {
                if( pIMSAdminBase ) 
                {
                        pIMSAdminBase->Release();
                        pIMSAdminBase = NULL;
                }
        }

        void SetData( DWORD dwIdentifier, DWORD dwValue, DWORD dwAttributes, DWORD dwUserType )
        {
                HRESULT hr;
                METADATA_RECORD mr;

                mr.dwMDIdentifier = dwIdentifier;
                mr.dwMDAttributes = dwAttributes;
                mr.dwMDUserType   = dwUserType;
                mr.dwMDDataType   = DWORD_METADATA;
                mr.dwMDDataLen    = sizeof( DWORD );
                mr.pbMDData       = reinterpret_cast<unsigned char *>(&dwValue);
                hr = pIMSAdminBase->SetData( m_hMetabase, m_szKeyName, &mr );

                if( FAILED( hr ) )
                {
                        LogError( TEXT( "CIISObjectBase::SetData::pIMSAdminBase->SetData() failed..." ), HRESULT_CODE(hr) );
                        throw hr;
                }
        }

        void SetData( DWORD dwIdentifier, PTCHAR szValue, DWORD dwAttributes, DWORD dwUserType )
        {
                HRESULT hr;
                METADATA_RECORD mr;

                mr.dwMDIdentifier = dwIdentifier;
                mr.dwMDAttributes = dwAttributes;
                mr.dwMDUserType   = dwUserType;
                mr.dwMDDataType   = STRING_METADATA;
                mr.dwMDDataLen    = (DWORD) ( _tcslen( szValue ) + 1) * sizeof( TCHAR );
                mr.pbMDData       = reinterpret_cast<unsigned char *>(szValue);
                hr = pIMSAdminBase->SetData( m_hMetabase, m_szKeyName, &mr );

                if( FAILED( hr ) )
                {
                        LogError( TEXT( "CIISObjectBase::SetData::pIMSAdminBase->SetData() failed..." ), HRESULT_CODE(hr) );
                        throw hr;
                }
        }

        void GetData( DWORD dwIdentifier, PTCHAR szValue, DWORD dwBufferLen, DWORD dwAttributes, DWORD dwUserType )
        {
                HRESULT hr;
                METADATA_RECORD mr;
                DWORD dwMDRequiredDataLen = 0;

                mr.dwMDIdentifier = dwIdentifier;
                mr.dwMDAttributes = dwAttributes;
                mr.dwMDUserType   = dwUserType;
                mr.dwMDDataType   = STRING_METADATA;
                mr.dwMDDataLen    = 0;
                mr.pbMDData       = NULL;
                mr.dwMDDataLen    = dwBufferLen;
                mr.pbMDData       = reinterpret_cast<unsigned char *>(szValue);

				hr = pIMSAdminBase->GetData( m_hMetabase, m_szKeyName, &mr, &dwMDRequiredDataLen );

                if( FAILED( hr ) )
                {
                        Log( TEXT( "CIISObjectBase::GetData::pIMSAdminBase->GetData() failed with HRESULT 0x%x." ), hr );
                        throw hr;
                }
        }

        void GetMultiSzData( DWORD dwIdentifier, cStrList* pList, DWORD dwAttributes, DWORD dwUserType )
        {
                HRESULT hr;
                METADATA_RECORD mr;
                DWORD dwMDRequiredDataLen = 0;
				PTCHAR szValue = NULL;

                mr.dwMDIdentifier = dwIdentifier;
                mr.dwMDAttributes = dwAttributes;
                mr.dwMDUserType   = dwUserType;
                mr.dwMDDataType   = MULTISZ_METADATA;
                mr.dwMDDataLen    = 0;
                mr.pbMDData       = NULL;

				hr = pIMSAdminBase->GetData( m_hMetabase, m_szKeyName, &mr, &dwMDRequiredDataLen );

				DWORD dwMDDataLen = dwMDRequiredDataLen / sizeof(TCHAR);

				// 
				// Let API calculate needed buffer size, then allocate
				//
				if( ERROR_INSUFFICIENT_BUFFER == HRESULT_CODE(hr) )
				{
					szValue = new TCHAR[ dwMDDataLen ];
					if( NULL == szValue )
					{
						hr = E_OUTOFMEMORY;
                        LogError( TEXT( "CIISObjectBase::GetMultiSzData::new TCHAR[] failed..." ), HRESULT_CODE(hr) );
                        throw hr;
					}

					mr.dwMDDataLen    = dwMDRequiredDataLen;				
					mr.pbMDData       = reinterpret_cast<unsigned char *>(szValue);

					hr = pIMSAdminBase->GetData( m_hMetabase, m_szKeyName, &mr, &dwMDRequiredDataLen );
				}
				else
				{
					//
					// Should never get here, should always fail with insufficient buffer
					//
					hr = E_FAIL;

                    LogError( TEXT( "CIISObjectBase::GetMultiSzData::pIMSAdminBase->GetData() failed..." ), HRESULT_CODE(hr) );
                    throw hr;
				}

                if( FAILED( hr ) )
                {
						//
						// Don't forget to free buffer before throwing exception
						//
						if( NULL != szValue )
						{
							delete [] szValue;
						}

                        LogError( TEXT( "CIISObjectBase::GetMultiSzData::pIMSAdminBase->GetData() failed..." ), HRESULT_CODE(hr) );
                        throw hr;
                }

				if( NULL != szValue )
				{
					while( *szValue )
					{
						//
						// Add value at front to cStrList
						//
						pList->push_back( szValue );

						//
						// Walk past null-delimited string
						//
						while( *szValue )
							szValue++;

						//
						// Walk past null character
						//
						szValue++;
					}

					//
					// Free allocated buffer
					//
					delete [] szValue;
				}
        }

        void SetMultiSzData( DWORD dwIdentifier, cStrList* pList, DWORD dwAttributes, DWORD dwUserType )
        {
                HRESULT hr;
                METADATA_RECORD mr;
                DWORD dwMDDataLen = 0;
				tstring szValue;

				//
				// Convert cStrList to multisz string
				//
				for( cStrList::size_type i = 0; ( i < pList->size() ); i++ )
				{
					LPCTSTR szEntry = (*pList)[i].c_str();

					szValue += szEntry;
					szValue += TEXT( '\t' );
				}

				//
				// Add trailing tab (which will become null) character
				//
				szValue += TEXT( '\t' );

				//
				// Calculate string data length
				//
				dwMDDataLen = (DWORD)szValue.length() * sizeof(TCHAR);

				// 
				// Replace /t with /0, to properly create multisz string
				//
				PTCHAR szTemp = (PTCHAR)szValue.c_str();
				while( *szTemp )
				{
					if( TEXT( '\t' ) == *szTemp )
						*szTemp = TEXT( '\0' );

					szTemp++;
				}

                mr.dwMDIdentifier = dwIdentifier;
                mr.dwMDAttributes = dwAttributes;
                mr.dwMDUserType   = dwUserType;
                mr.dwMDDataType   = MULTISZ_METADATA;
				mr.dwMDDataLen    = dwMDDataLen;
                mr.pbMDData       = reinterpret_cast<unsigned char *>( (PTCHAR)szValue.c_str() );

                hr = pIMSAdminBase->SetData( m_hMetabase, m_szKeyName, &mr );

                if( FAILED( hr ) )
                {
                        LogError( TEXT( "CIISObjectBase::SetMultiSzData::pIMSAdminBase->SetData() failed..." ), HRESULT_CODE(hr) );
                        throw hr;
                }
        }

		void Delete()
        {
                HRESULT hr;

                //
                // Attempt to open the virtual dir set on Web server #1 (default server)
                //
                hr = pIMSAdminBase->OpenKey( METADATA_MASTER_ROOT_HANDLE,
                                                        m_szRoot,
                                                        METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
                                                        REASONABLE_TIMEOUT,
                                                        &m_hMetabase );

                if( FAILED( hr )) 
                {
                        LogError( TEXT( "CIISObjectBase::Delete::pIMSAdminBase->OpenKey() failed..." ), HRESULT_CODE(hr) );
                        throw hr;
                }

                //
                // We don't check the return value since the key may already 
                // not exist and we could get an error for that reason.
                //
                pIMSAdminBase->DeleteKey( m_hMetabase, m_szKeyName );
                pIMSAdminBase->CloseKey( m_hMetabase );    
                m_hMetabase = NULL;
        }

        void Release()
        {
                if( m_hMetabase && pIMSAdminBase )
                {
                        pIMSAdminBase->CloseKey( m_hMetabase );    
                        m_hMetabase = NULL;
                }
        }
};

//--------------------------------------------------------------------------

IMSAdminBase* CIISObjectBase::pIMSAdminBase = NULL;

class CIISApplicationPool : public CIISObjectBase
{
public:
        CIISApplicationPool( PTCHAR szName )
        {
                m_szKeyName = szName;
                m_szRoot = TEXT( "/LM/W3SVC/AppPools" );
        }

        void Create()
        {
                HRESULT                 hr;
                METADATA_RECORD mr = {0};
                DWORD                   dwMDRequiredDataLen = 0;
                TCHAR                   achBuffer[ 256 ];

                //
                // Attempt to open the UDDI Application Pool
                //
                hr = pIMSAdminBase->OpenKey( METADATA_MASTER_ROOT_HANDLE,
                                                        m_szRoot,
                                                        METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
                                                        REASONABLE_TIMEOUT,
                                                        &m_hMetabase );

                //
                // Create the key if it does not exist.
                //
                if( FAILED( hr )) 
                {
                        LogError( TEXT( "CIISApplicationPool::pIMSAdminBase->OpenKey() failed..." ), HRESULT_CODE(hr) );
                        throw hr;
                }

                mr.dwMDIdentifier = MD_KEY_TYPE;
                mr.dwMDAttributes = 0;
                mr.dwMDUserType   = IIS_MD_UT_SERVER;
                mr.dwMDDataType   = STRING_METADATA;
                mr.dwMDDataLen    = sizeof(achBuffer);
                mr.pbMDData       = reinterpret_cast<unsigned char *>(achBuffer);

                //
                // See if MD_KEY_TYPE exists
                //
                hr = pIMSAdminBase->GetData( m_hMetabase, m_szKeyName, &mr, &dwMDRequiredDataLen );

                if( FAILED( hr )) 
                {
                        if( MD_ERROR_DATA_NOT_FOUND == hr || ERROR_PATH_NOT_FOUND == HRESULT_CODE(hr) ) 
                        {
                                //
                                // Write both the key and the values if GetData() failed with any of the two errors.
                                //
                                hr = pIMSAdminBase->AddKey( m_hMetabase, m_szKeyName );

                                if( FAILED( hr ) )
                                {
                                        LogError( TEXT( "CIISApplicationPool::pIMSAdminBase->AddKey() failed..." ), HRESULT_CODE(hr) );
                                        throw hr;
                                }
                        }
                        else
                        {
                                LogError( TEXT( "CIISApplicationPool::pIMSAdminBase->GetData() failed..." ), HRESULT_CODE(hr));
                                throw hr;
                        }

                        //
                        // Setup default properties
                        //
                        // TODO: Need to use #define for IIsApplicationPool
                        //
                        SetData( MD_KEY_TYPE, TEXT( "IIsApplicationPool" ), 0, IIS_MD_UT_SERVER );
                }
        }
};

//--------------------------------------------------------------------------

class CIISWebService : public CIISObjectBase
{
public:
        CIISWebService()
        {
                m_szKeyName = TEXT( "/W3SVC" );
                m_szRoot = TEXT( "/LM" );
        }

        void Create()
        {
                HRESULT                 hr;
                METADATA_RECORD mr = {0};
                DWORD                   dwMDRequiredDataLen = 0;
                TCHAR                   achBuffer[ 256 ];

                //
                // Attempt to open the IIS Web Service
                //
                hr = pIMSAdminBase->OpenKey( METADATA_MASTER_ROOT_HANDLE,
                                                        m_szRoot,
                                                        METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
                                                        REASONABLE_TIMEOUT,
                                                        &m_hMetabase );

                //
                // Create the key if it does not exist.
                //
                if( FAILED( hr )) 
                {
                        LogError( TEXT( "CIISWebService::pIMSAdminBase->OpenKey() failed..." ), HRESULT_CODE(hr) );
                        throw hr;
                }

                mr.dwMDIdentifier = MD_KEY_TYPE;
                mr.dwMDAttributes = 0;
                mr.dwMDUserType   = IIS_MD_UT_SERVER;
                mr.dwMDDataType   = STRING_METADATA;
                mr.dwMDDataLen    = sizeof(achBuffer);
                mr.pbMDData       = reinterpret_cast<unsigned char *>(achBuffer);

                //
                // See if MD_KEY_TYPE exists
                //
                hr = pIMSAdminBase->GetData( m_hMetabase, m_szKeyName, &mr, &dwMDRequiredDataLen );

                if( FAILED( hr )) 
                {
						LogError( TEXT( "CIISWebService::pIMSAdminBase->GetData() failed..." ), HRESULT_CODE(hr));
						throw hr;
                }
        }
};

class CIISApplication : public CIISObjectBase
{
private:
        PTCHAR   m_szPath;

public:
        CIISApplication( PTCHAR szVDir, PTCHAR szPath )
        {
                m_szKeyName = szVDir;
                m_szPath = szPath;
                m_szRoot = TEXT( "/LM/W3SVC/1/ROOT" );
        }

        void Create()
        {
                HRESULT                 hr;
                METADATA_RECORD mr;
                DWORD                   dwMDRequiredDataLen = 0;
                TCHAR                   szTempPath[ MAX_PATH ];

                //
                // Attempt to open the virtual dir set on Web server #1 (default server)
                //
                hr = pIMSAdminBase->OpenKey( METADATA_MASTER_ROOT_HANDLE,
                                                        m_szRoot,
                                                        METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
                                                        REASONABLE_TIMEOUT,
                                                        &m_hMetabase );

                //
                // Create the key if it does not exist.
                //
                if( FAILED( hr )) 
                {
                        LogError( TEXT( "CIISApplication::pIMSAdminBase->OpenKey() failed..." ), HRESULT_CODE( hr ) );
                        throw hr;
                }

                mr.dwMDIdentifier = MD_VR_PATH;
                mr.dwMDAttributes = METADATA_INHERIT;
                mr.dwMDUserType   = IIS_MD_UT_FILE;
                mr.dwMDDataType   = STRING_METADATA;
                mr.dwMDDataLen    = sizeof( szTempPath ); 
                mr.pbMDData       = reinterpret_cast<unsigned char *>(szTempPath);

                //
                // See if MD_VR_PATH exists.
                //
                hr = pIMSAdminBase->GetData( m_hMetabase, m_szKeyName, &mr, &dwMDRequiredDataLen );

                if( FAILED( hr )) 
                {
                        if( MD_ERROR_DATA_NOT_FOUND == hr ||
                                ERROR_PATH_NOT_FOUND == HRESULT_CODE(hr) ) 
                        {
                                //
                                // Write both the key and the values if GetData() failed with any of the two errors.
                                //
                                hr = pIMSAdminBase->AddKey( m_hMetabase, m_szKeyName );

                                if( FAILED( hr ) )
                                {
                                        LogError( TEXT( "CIISApplication::pIMSAdminBase->AddKey() failed..." ), HRESULT_CODE(hr) );
                                        throw hr;
                                }
                        }
                        else
                        {
                                LogError( TEXT( "CIISApplication::pIMSAdminBase->GetData() failed..." ), HRESULT_CODE(hr) );
                                throw hr;
                        }
                }

                //
                // Set default property information
                //
                SetData( MD_VR_PATH, m_szPath, METADATA_INHERIT, IIS_MD_UT_FILE );
                SetData( MD_KEY_TYPE, IIS_CLASS_WEB_VDIR_W, 0, IIS_MD_UT_SERVER );

                //
                // Setup the path to the application root
                //
                TCHAR szAppRoot [ MAX_PATH + 1 ];
                _sntprintf( szAppRoot, MAX_PATH, TEXT( "%s/%s" ), m_szRoot, m_szKeyName );
                SetData( MD_APP_ROOT, szAppRoot, METADATA_INHERIT, IIS_MD_UT_FILE );
        }
};

//--------------------------------------------------------------------------

UINT SetupIISUDDIMetabase( int AppPoolIdentityType, LPCTSTR szUserName, LPCTSTR szPwd )
{
        ENTER();

        UINT errCode = ERROR_SUCCESS;

//        ::MessageBox( NULL, TEXT( "Attach Debugger" ), TEXT( "SetupIISUDDIMetabase" ), MB_OK );

        if( FAILED( CoInitializeEx( NULL, COINIT_MULTITHREADED ) ) )
        {
                Log( TEXT( "SetupIISUDDIMetabase() failed: CoInitializeEx() failed" ) );
                return ERROR_INSTALL_FAILURE;
        }

        //
        // Get the root UDDI application path from the registry
        //
        //
        TCHAR szUddiApplicationFilePath[ MAX_PATH ];
        if( !GetUDDIInstallPath( szUddiApplicationFilePath , MAX_PATH ) )
        {
                return ERROR_INSTALL_FAILURE;
        }

        _tcscat( szUddiApplicationFilePath, TEXT( "webroot" ) );

        //
        // Set the api application path to the root UDDI path also
        //
        TCHAR szApiApplicationFilePath[ MAX_PATH ];
        _tcscpy( szApiApplicationFilePath, szUddiApplicationFilePath );

        try
        {
                //
                // Initialize the connection the the IIS metabase
                //
                try
                {
                        CIISObjectBase::Initialize();
                }
                catch( HRESULT hr )
                {
                        LogError( TEXT( "CIISObjectBase::Initialize() failed" ), HRESULT_CODE( hr ) );
                        throw hr;
                }

                //
                // Create the application pool for the SOAP API and the User Interface
                //
                try
                {

                        CIISApplicationPool pool( APPPOOLNAME );
                        pool.Create();

                        //
                        // These values are set by the user on an OCM property page
                        //
                        pool.SetData( MD_APPPOOL_IDENTITY_TYPE, AppPoolIdentityType, METADATA_INHERIT, IIS_MD_UT_SERVER );

                        //
                        // If the user type is "Specific User," then set the user name and password
                        //
                        if( MD_APPPOOL_IDENTITY_TYPE_SPECIFICUSER == AppPoolIdentityType )
                        {
                                pool.SetData( MD_WAM_USER_NAME, ( PTCHAR ) szUserName, METADATA_INHERIT, IIS_MD_UT_FILE );
                                pool.SetData( MD_WAM_PWD, ( PTCHAR ) szPwd, METADATA_INHERIT | METADATA_SECURE, IIS_MD_UT_FILE );
                        }

						pool.SetData( MD_APPPOOL_MAX_PROCESS_COUNT, 1, METADATA_INHERIT, IIS_MD_UT_SERVER );
                        pool.Release();
                }
                catch( HRESULT hr )
                {
                        LogError( TEXT( "Error creating application pool" ), HRESULT_CODE( hr ) );
                        throw hr;
                }

                //
                // Create the uddi application for access to the user interface
                //
                try
                {
						TCHAR wszBuf[ 512 ];
						wszBuf[ 0 ] = 0x00;

						LoadString( g_hinst, IDS_UDDI_APPLICATION_FRIENDLY_NAME, wszBuf, 512 );

                        CIISApplication uddi( UDDIAPPLICATIONNAME, szUddiApplicationFilePath );
                        uddi.Create();
                        uddi.SetData( MD_AUTHORIZATION, MD_AUTH_BASIC | MD_AUTH_NT, METADATA_INHERIT, IIS_MD_UT_FILE );
                        uddi.SetData( MD_ACCESS_PERM, MD_ACCESS_READ | MD_ACCESS_SCRIPT, METADATA_INHERIT, IIS_MD_UT_FILE );
                        uddi.SetData( MD_DEFAULT_LOAD_FILE, DEFAULTLOADFILE, 0, IIS_MD_UT_FILE );
                        uddi.SetData( MD_APP_ISOLATED, 2, 0, IIS_MD_UT_WAM );
                        uddi.SetData( MD_APP_FRIENDLY_NAME, wszBuf, 0, IIS_MD_UT_WAM );
                        uddi.SetData( MD_APP_APPPOOL_ID, APPPOOLNAME, METADATA_INHERIT, IIS_MD_UT_SERVER );
                        uddi.Release();
                }
                catch( HRESULT hr )
                {
                        LogError( TEXT( "Error creating uddi application for access to the user interface" ), HRESULT_CODE( hr ) );
                        throw hr;
                }

                // 
                // Create the api application for access to the SOAP interface
                //
                try
                {
						TCHAR wszBuf[ 512 ];
						wszBuf[ 0 ] = 0x00;
						LoadString( g_hinst, IDS_API_APPLICATION_FRIENDLY_NAME, wszBuf, 512 );

                        CIISApplication api( APIAPPLICATIONNAME, szApiApplicationFilePath );
                        api.Create();
                        api.SetData( MD_AUTHORIZATION, MD_AUTH_ANONYMOUS /* todo remove by Mark Patton | MD_AUTH_NT*/, METADATA_INHERIT, IIS_MD_UT_FILE );
                        api.SetData( MD_ACCESS_PERM, MD_ACCESS_READ | MD_ACCESS_SCRIPT, METADATA_INHERIT, IIS_MD_UT_FILE );
                //      api.SetData( MD_DEFAULT_LOAD_FILE, DEFAULTLOADFILE, 0, IIS_MD_UT_FILE );
                        api.SetData( MD_APP_ISOLATED, 2, 0, IIS_MD_UT_WAM );
                        api.SetData( MD_APP_FRIENDLY_NAME, wszBuf, 0, IIS_MD_UT_WAM );
                        api.SetData( MD_APP_APPPOOL_ID, APPPOOLNAME, METADATA_INHERIT, IIS_MD_UT_SERVER );

//
// Use the default account.
//
#if 0
                        //
                        // Set the anonymous user name and password
                        //
                        if ( MD_APPPOOL_IDENTITY_TYPE_SPECIFICUSER == AppPoolIdentityType )
                        {
                                //
                                // Domain account:
                                //
                                api.SetData( MD_ANONYMOUS_USER_NAME, (PTCHAR) szUserName, METADATA_INHERIT, IIS_MD_UT_FILE );

                                if( szPwd && _tcslen( szPwd ) )
                                {
                                        api.SetData( MD_ANONYMOUS_PWD, (PTCHAR) szPwd, METADATA_INHERIT | METADATA_SECURE, IIS_MD_UT_FILE );
                                }
                        }
                        else
                        {
                                //
                                // Network service account: 
                                //
                                api.SetData( MD_ANONYMOUS_USER_NAME, (PTCHAR) szUserName, METADATA_NO_ATTRIBUTES, IIS_MD_UT_WAM );
                        }
#endif
                        api.Release();
                }
                catch( HRESULT hr )
                {
                        LogError( TEXT( "Error creating the api application for access to the SOAP interface" ), HRESULT_CODE( hr ) );
                        throw hr;
                }

				//
                // Create the UDDI application dependency
                //
                try
                {
						cStrList cAppDep;

                        CIISWebService ws;
                        ws.Create();
						ws.GetMultiSzData( MD_APP_DEPENDENCIES, &cAppDep, 0, IIS_MD_UT_SERVER );

						if( !IsInList( UDDIAPPLICATIONDEPENDENCY, &cAppDep, FALSE ) )
						{
							//
							// Append UDDI app dependency string
							//
							cAppDep.push_back( UDDIAPPLICATIONDEPENDENCY );

							//
							// Set new app dependency string into record
							//
							ws.SetMultiSzData( MD_APP_DEPENDENCIES, &cAppDep, 0, IIS_MD_UT_SERVER );
						}

						TCHAR szAuthProv[ 256 ];

						Log( TEXT( "Attempting to get string value for MD_NTAUTHENTICATION_PROVIDERS." ) );

						try
						{
							ws.GetData( MD_NTAUTHENTICATION_PROVIDERS, szAuthProv, sizeof(szAuthProv), 0, IIS_MD_UT_FILE );
							Log( TEXT( "Found NT Authentication Providers: %s" ), szAuthProv );
						}
						catch( HRESULT hr )
						{
							//
							// Not an error if it doesn't exist already.
							//
							Log( TEXT( "Failed to get MD_NTAUTHENTICATION_PROVIDERS as IIS_MD_UT_FILE, HRESULT 0x%x." ), hr );
						}

						try
						{
							ws.SetData( MD_NTAUTHENTICATION_PROVIDERS, UDDINTAUTHPROVIDERS, METADATA_INHERIT, IIS_MD_UT_FILE );
							Log( TEXT( "Set NT Authentication Providers: %s" ), UDDINTAUTHPROVIDERS );
						}
						catch( HRESULT hr )
						{
							Log( TEXT( "Failed to set MD_NTAUTHENTICATION_PROVIDERS as IIS_MD_UT_FILE, HRESULT 0x%x." ), hr );
							throw hr;
						}

                        ws.Release();
                }
                catch( HRESULT hr )
                {
                        LogError( TEXT( "Error creating application dependency" ), HRESULT_CODE( hr ) );
                        throw hr;
                }
		}
        catch( ... )
        {
                errCode = ERROR_INSTALL_FAILURE;
        }

        CIISObjectBase::Uninitialize();
        CoUninitialize();

        return errCode;
}

//--------------------------------------------------------------------------

UINT RemoveIISUDDIMetabase(void)
{
        ENTER();

        UINT errCode = ERROR_INSTALL_FAILURE;

//        ::MessageBox( NULL, TEXT( "Attach Debugger" ), TEXT( "RemoveIISUDDIMetabase" ), MB_OK );

        //
        // Get the root UDDI application path from the registry
        //
        TCHAR szUddiApplicationFilePath[ MAX_PATH + 1 ];
        if( !GetUDDIInstallPath( szUddiApplicationFilePath , MAX_PATH ) )
        {
                return ERROR_INSTALL_FAILURE;
        }

        if( FAILED( CoInitializeEx( NULL, COINIT_MULTITHREADED ) ) )
        {
                Log( TEXT( "RemoveIISUDDIMetabase() failed: CoInitializeEx() failed" ) );
                return ERROR_INSTALL_FAILURE;
        }

        _tcsncat( szUddiApplicationFilePath, TEXT( "webroot" ), MAX_PATH - _tcslen( szUddiApplicationFilePath ) );
        szUddiApplicationFilePath[ MAX_PATH ] = NULL;

        //
        // Set the api application path to the root UDDI path also
        //
        TCHAR szApiApplicationFilePath[ MAX_PATH+1 ];
        memset( szApiApplicationFilePath, 0, sizeof szApiApplicationFilePath );
        _tcsncpy( szApiApplicationFilePath, szUddiApplicationFilePath, MAX_PATH );

        try
        {
                try
                {
                        CIISObjectBase::Initialize();
                }
                catch( HRESULT hr )
                {
                        LogError( TEXT( "CIISObjectBase::Initialize() failed" ), HRESULT_CODE( hr ) );
                        throw hr;
                }

                // 
                // Delete the api application for access to the SOAP interface
                //
                try
                {
                        CIISApplication api( APIAPPLICATIONNAME, szApiApplicationFilePath );
                        api.Delete();
                        api.Release();
                }
                catch( HRESULT hr )
                {
                        LogError( TEXT( "Error deleting the api application for access to the SOAP interface" ), HRESULT_CODE( hr ) );
                        throw hr;
                }

                //
                // Delete the uddi application for access to the user interface
                //
                try
                {
                        CIISApplication uddi( UDDIAPPLICATIONNAME, szUddiApplicationFilePath );
                        uddi.Delete();
                        uddi.Release();
                }
                catch( HRESULT hr )
                {
                        LogError( TEXT( "Error deleting uddi application for access to the user interface" ), HRESULT_CODE( hr ) );
                        throw hr;
                }

                //
                // Delete the application pool entry
                //
                try
                {
                        CIISApplicationPool pool( APPPOOLNAME );
                        pool.Delete();
                        pool.Release();
                }
                catch( HRESULT hr )
                {
                        LogError( TEXT( "Error deleting application pool" ), HRESULT_CODE( hr ) );
                        throw hr;
                }

                //
                // Remove the UDDI application dependency
                //
                try
                {
						cStrList cAppDep;

                        CIISWebService ws;
                        ws.Create();
						ws.GetMultiSzData( MD_APP_DEPENDENCIES, &cAppDep, 0, IIS_MD_UT_SERVER );

						if( RemoveFromList( UDDIAPPLICATIONDEPENDENCY, &cAppDep, FALSE ) )
						{
							//
							// Set new app dependency string into record
							//
							ws.SetMultiSzData( MD_APP_DEPENDENCIES, &cAppDep, 0, IIS_MD_UT_SERVER );
						}

                        ws.Release();
                }
                catch( HRESULT hr )
                {
                        LogError( TEXT( "Error deleting application dependency" ), HRESULT_CODE( hr ) );
                        throw hr;
                }
		}
        catch( ... )
        {
                errCode = ERROR_INSTALL_FAILURE;
        }

        CIISObjectBase::Uninitialize();
        CoUninitialize();

        return errCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\setup\web\ca\assemblyinfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("webca.dll")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft Corporation")]
[assembly: AssemblyProduct("UDDI Services")]
[assembly: AssemblyCopyright("Copyright (c) 2002 Microsoft Corporation")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]		

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified, the assembly is not signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. KeyFile refers to a file which contains
//       a key.
//   (*) If the KeyFile and the KeyName values are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP, that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the KeyFile is installed into the CSP and used.
//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
//       When specifying the KeyFile, the location of the KeyFile should be
//       relative to the project output directory which is
//       %Project Directory%\obj\<configuration>. For example, if your KeyFile is
//       located in the project directory, you would specify the AssemblyKeyFile 
//       attribute as [assembly: AssemblyKeyFile("..\\..\\mykey.snk")]
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("")]
[assembly: AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\setup\web\ca.unmanaged\setdacl.cpp ===
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0500
#endif

#include <windows.h>
#include <tchar.h>
#include <stdio.h>

#include "webcaum.h"
#include "..\..\shared\common.h"
#include "..\..\shared\apppool.h"


bool AddAccessRights( TCHAR *lpszFileName, TCHAR *szUserName, DWORD dwAccessMask )
{
	//
	// SID variables.
	//
	SID_NAME_USE snuType;
	TCHAR * szDomain = NULL;
	DWORD cbDomain = 0;

	//
	// User name variables.
	//
	LPVOID pUserSID = NULL;
	DWORD cbUserSID = 0;
	DWORD cbUserName = 0;

	//
	// File SD variables.
	//
	PSECURITY_DESCRIPTOR pFileSD = NULL;
	DWORD cbFileSD = 0;

	//
	// New SD variables.
	//
	PSECURITY_DESCRIPTOR pNewSD = NULL;

	//
	// ACL variables.
	//
	PACL pACL = NULL;
	BOOL fDaclPresent;
	BOOL fDaclDefaulted;
	ACL_SIZE_INFORMATION AclInfo;

	//
	// New ACL variables.
	//
	PACL pNewACL = NULL;
	DWORD cbNewACL = 0;

	//
	// Temporary ACE.
	//
	LPVOID pTempAce = NULL;
	UINT CurrentAceIndex;
	bool fResult = false;
	BOOL fAPISuccess;

	// error code
	DWORD	lastErr = 0;

	try
	{
		//
		// Call this API once to get the buffer sizes ( it will return ERROR_INSUFFICIENT_BUFFER )
		//
		fAPISuccess = LookupAccountName( NULL, szUserName, pUserSID, &cbUserSID, szDomain, &cbDomain, &snuType );

		if( fAPISuccess )
		{
			throw E_FAIL; // we throw some fake error to skip through to the exit door
		}
		else if( GetLastError() != ERROR_INSUFFICIENT_BUFFER )
		{
			lastErr = GetLastError();
			LogError( TEXT( "LookupAccountName() failed" ), lastErr );
			throw lastErr;
		}

		//
		// allocate the buffers
		//
		pUserSID = calloc( cbUserSID, 1 );
		if( !pUserSID )
		{
			lastErr = GetLastError();
			LogError( TEXT( "Alloc() for UserSID failed" ), lastErr );
			throw lastErr;
		}

		szDomain = ( TCHAR * ) calloc( cbDomain + sizeof TCHAR, sizeof TCHAR );
		if( !szDomain )
		{
			lastErr = GetLastError();
			LogError( TEXT( "Alloc() for szDomain failed" ), lastErr );
			throw lastErr;
		}

		//
		// The LookupAccountName function accepts the name of a system and an account as input. 
		// It retrieves a security identifier ( SID ) for the account and 
		// the name of the domain on which the account was found
		//
		fAPISuccess = LookupAccountName( NULL /* = local computer */, szUserName, pUserSID, &cbUserSID, szDomain, &cbDomain, &snuType );
		if( !fAPISuccess )
		{
			lastErr = GetLastError();
			LogError( TEXT( "LookupAccountName() failed" ), lastErr );
			throw lastErr;
		}

		//
		// call this API once to get the buffer sizes
		// API should have failed with insufficient buffer.
		//
		fAPISuccess = GetFileSecurity( lpszFileName, DACL_SECURITY_INFORMATION, pFileSD, 0, &cbFileSD );
		if( fAPISuccess )
		{
			throw E_FAIL;
		}
		else if( GetLastError() != ERROR_INSUFFICIENT_BUFFER )
		{
			lastErr = GetLastError();
			LogError( TEXT( "GetFileSecurity() failed" ), lastErr );
			throw lastErr;
		}

		//
		// allocate the buffers
		//
		pFileSD = calloc( cbFileSD, 1 );
		if( !pFileSD )
		{
			lastErr = GetLastError();
			LogError( TEXT( "Alloc() for pFileSD failed" ), lastErr );
			throw lastErr;
		}

		//
		// call the api to get the actual data
		//
		fAPISuccess = GetFileSecurity( lpszFileName, DACL_SECURITY_INFORMATION, pFileSD, cbFileSD, &cbFileSD );
		if( !fAPISuccess )
		{
			lastErr = GetLastError();
			LogError( TEXT( "GetFileSecurity() failed" ), lastErr );
			throw lastErr;
		}

		//
		// Initialize new SD.
		//
		pNewSD = calloc( cbFileSD, 1 ); // Should be same size as FileSD.
		if( !pNewSD )
		{
			lastErr = GetLastError();
			LogError( TEXT( "Alloc() for pNewDS failed" ), GetLastError() );
			throw lastErr;
		}

		if( !InitializeSecurityDescriptor( pNewSD, SECURITY_DESCRIPTOR_REVISION ) )
		{
			lastErr = GetLastError();
			LogError( TEXT( "InitializeSecurityDescriptor() failed" ), lastErr );
			throw lastErr;
		}

		//
		// Get DACL from SD.
		//
		if( !GetSecurityDescriptorDacl( pFileSD, &fDaclPresent, &pACL, &fDaclDefaulted ) )
		{
			lastErr = GetLastError();
			LogError( TEXT( "GetSecurityDescriptorDacl() failed" ), lastErr );
			throw lastErr;
		}

		//
		// Get size information for DACL.
		//
		AclInfo.AceCount = 0; // Assume NULL DACL.
		AclInfo.AclBytesFree = 0;
		AclInfo.AclBytesInUse = sizeof( ACL );      // If not NULL DACL, gather size information from DACL.
		if( fDaclPresent && pACL )
		{
			if( !GetAclInformation( pACL, &AclInfo, sizeof( ACL_SIZE_INFORMATION ), AclSizeInformation ) )
			{
				lastErr = GetLastError();
				LogError( TEXT( "GetAclInformation() failed" ), lastErr );
				throw lastErr;
			}
		}

		//
		// Compute size needed for the new ACL.
		//
		cbNewACL = AclInfo.AclBytesInUse + sizeof( ACCESS_ALLOWED_ACE ) + GetLengthSid( pUserSID );

		//
		// Allocate memory for new ACL.
		//
		pNewACL = ( PACL ) calloc( cbNewACL, 1 );
		if( !pNewACL )
		{
			lastErr = GetLastError();
			LogError( TEXT( "HeapAlloc() failed" ), lastErr );
			throw lastErr;
		}

		//
		// Initialize the new ACL.
		//
		if( !InitializeAcl( pNewACL, cbNewACL, ACL_REVISION2 ) )
		{
			lastErr = GetLastError();
			LogError( TEXT( "InitializeAcl() failed" ), lastErr );
			throw lastErr;
		}

		//
		// Add the access-allowed ACE to the new DACL.
		//
		ACE_HEADER aceheader = {0};
		aceheader.AceFlags = CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE;
		aceheader.AceSize  = sizeof( ACE_HEADER );
		aceheader.AceType = ACCESS_ALLOWED_OBJECT_ACE_TYPE;
		if( !AddAccessAllowedAceEx( pNewACL, ACL_REVISION2, aceheader.AceFlags, dwAccessMask, pUserSID ) )
		{
			lastErr = GetLastError();
			LogError( TEXT( "AddAccessAllowedAce() failed" ),	lastErr );
			throw lastErr;
		}

		//
		// If DACL is present, copy it to a new DACL.
		//
		if( fDaclPresent )
		{
			//
			// Copy the file's ACEs to the new ACL
			//
			if( AclInfo.AceCount )
			{
				for( CurrentAceIndex = 0; CurrentAceIndex < AclInfo.AceCount; CurrentAceIndex++ )
				{
					//
					// Get an ACE.
					//
					if( !GetAce( pACL, CurrentAceIndex, &pTempAce ) )
					{
						lastErr = GetLastError();
						LogError( TEXT( "GetAce() failed" ), lastErr );
						throw lastErr;
					}

					//
					// Add the ACE to the new ACL.
					//
					if( !AddAce( pNewACL, ACL_REVISION, MAXDWORD, pTempAce,	( ( PACE_HEADER ) pTempAce )->AceSize ) )
					{
						lastErr = GetLastError();
						LogError( TEXT( "AddAce() failed" ), lastErr );
						throw lastErr;
					}
				}
			}
		}

		//
		// Set the new DACL to the file SD.
		//
		if( !SetSecurityDescriptorDacl( pNewSD, TRUE, pNewACL, FALSE ) )
		{
			lastErr = GetLastError();
			LogError( TEXT( "SetSecurityDescriptorDacl() failed" ), lastErr );
			lastErr;
		}

		//
		// Set the SD to the File.
		//
		if( !SetFileSecurity( lpszFileName, DACL_SECURITY_INFORMATION, pNewSD ) )
		{
			lastErr = GetLastError();
			LogError( TEXT( "SetFileSecurity() failed" ), lastErr );
			throw lastErr;
		}

		fResult = TRUE;
	}
	catch (...)
	{
		fResult = FALSE;
	}

	//
	// Free allocated memory
	//
	if( pUserSID )
		free( pUserSID );
	if( szDomain )
		free( szDomain );
	if( pFileSD )
		free( pFileSD );
	if( pNewSD )
		free( pNewSD );
	if( pNewACL )
		free( pNewACL );

	return fResult;
}

//----------------------------------------------------------------------------
// give the domain account read access to the webroot folder and subfolders
//
bool SetUDDIFolderDacls( TCHAR *szUserName )
{
	ENTER();

	TCHAR szUDDIInstallPath[ MAX_PATH + 1 ];
	TCHAR szSubfolderPath[ MAX_PATH + 1 ];

	//
	// get UDDI install location ( it already has a backslash )
	//
	if( !GetUDDIInstallPath( szUDDIInstallPath, MAX_PATH ) )
		return false;

	//
	// give read access to the webroot folder
	//
	_sntprintf( szSubfolderPath, MAX_PATH, TEXT( "%s%s" ), szUDDIInstallPath, TEXT( "webroot\\" ) );

	SetFolderAclRecurse( szSubfolderPath, szUserName );

	return true;
}

//-------------------------------------------------------------------*

bool SetFolderAclRecurse( PTCHAR szDirName, PTCHAR szUserName, DWORD dwAccessMask )
{
	//
	// add the ACE for this folder
	//
	Log( TEXT( "Giving %s access to folder %s" ), szUserName, szDirName );

	if( !AddAccessRights( szDirName, szUserName, dwAccessMask ) )
	{
		LogError( TEXT( "Error:" ), GetLastError() );
		return false;
	}

	//
	// search any subdirectories:
	//
	TCHAR tmpFileName[MAX_PATH];
	_tcscpy( tmpFileName, szDirName );
	_tcscat( tmpFileName, TEXT( "*" ) );

	WIN32_FIND_DATA FindData;
	HANDLE hFindFile = FindFirstFileEx( tmpFileName, FindExInfoStandard, &FindData, 
	                            FindExSearchLimitToDirectories, NULL, 0 );

	if( hFindFile == INVALID_HANDLE_VALUE )
	{
		return true;
	}

	do
	{
		// make sure it's really a directory
		if( FILE_ATTRIBUTE_DIRECTORY & FindData.dwFileAttributes && 
			0 != _tcscmp( FindData.cFileName, TEXT( "." ) ) &&
			0 != _tcscmp( FindData.cFileName, TEXT( ".." ) ) )
		{
			_tcscpy( tmpFileName, szDirName );
			_tcscat( tmpFileName, FindData.cFileName );
			_tcscat( tmpFileName, TEXT( "\\" ) );

			// recursively call this routine
			if( !SetFolderAclRecurse( tmpFileName, szUserName ) )
			{
				FindClose( hFindFile );
				return false;
			}
		}
	}
	while( FindNextFile( hFindFile, &FindData ) );

	// clean up
	FindClose( hFindFile );

	return true;
}

//-------------------------------------------------------------------*

bool SetWindowsTempDacls( TCHAR *szUserName )
{
	//
	// Get the windows temp directory.
	//
	TCHAR *systemTemp = GetSystemTemp();

	if( NULL == systemTemp )
	{
		return false;
	}
	
	//
	// Add the rights
	//
	bool rightsAdded = AddAccessRights( systemTemp, szUserName, GENERIC_READ );	

	//
	// Clean up
	//
	delete[] systemTemp;
	systemTemp = NULL;

	return rightsAdded;
}

TCHAR * GetSystemTemp()
{
	TCHAR *TEMP = _T( "\\TEMP\\" );

	//
	// Get the WINDIR environment variable
	//
	DWORD valueSize = GetEnvironmentVariable( L"WINDIR", NULL, NULL );

	if( 0 == valueSize )
	{
		return NULL;
	}

	//
	// Keep in mind that we need to append \\TEMP to our string as well.
	//	
	valueSize += ( DWORD) _tcslen( TEMP );

	TCHAR *valueBuffer = NULL;	
	valueBuffer = new TCHAR[ valueSize ];
	ZeroMemory( valueBuffer, valueSize );

	if( NULL == valueBuffer )
	{
		return NULL;
	}

	DWORD realSize = GetEnvironmentVariable( L"WINDIR", valueBuffer, valueSize );

	if( 0 == realSize || realSize > valueSize )
	{
		delete[] valueBuffer;
		valueBuffer = NULL;

		return NULL;
	}
	
	//
	// Append a \\TEMP to it
	//
	_tcsncat( valueBuffer, TEMP, _tcslen( TEMP ) );

	//
	// Make sure we have null terminated.
	//
	valueBuffer[ valueSize - 1] = 0;

	//
	// Return the value
	//
	return valueBuffer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\setup\web\ca.unmanaged\webcaum.h ===
#pragma once

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0500
#endif

#include <windows.h>
#include <tchar.h>

extern HINSTANCE g_hinst;

UINT SetupIISUDDIMetabase( int AppPoolIdentityType, LPCTSTR szUserName, LPCTSTR szPwd );
bool SetFolderAclRecurse( PTCHAR szDirName, PTCHAR szfileName, DWORD dwAccessMask = GENERIC_READ );
UINT RemoveIISUDDIMetabase( void );
UINT RecycleApplicationPool( void );
bool SetUDDIFolderDacls( TCHAR *szUserName );
bool SetWindowsTempDacls( TCHAR* szUserName );
TCHAR* GetSystemTemp();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\setup\web\ca.unmanaged\webcaum.cpp ===
//#ifndef WIN32_LEAN_AND_MEAN
//#define WIN32_LEAN_AND_MEAN
//#endif

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0500
#endif

#include <windows.h>
#include <tchar.h>

#include <msi.h>
#include <assert.h>
#include <time.h>
#include <msi.h>
#include <msiquery.h>

#include "webcaum.h"
#include "..\..\shared\common.h"
#include "..\..\shared\propertybag.h"
#include "..\..\shared\apppool.h"

HINSTANCE g_hinst;

//--------------------------------------------------------------------------

BOOL APIENTRY DllMain( HANDLE hModule, 
                       DWORD  ul_reason_for_call, 
                       LPVOID lpReserved
					 )
{
	switch (ul_reason_for_call)
	{
	case DLL_PROCESS_ATTACH:
	{
		g_hinst = (HINSTANCE)hModule;
		break;
	}
	case DLL_THREAD_ATTACH:
	case DLL_THREAD_DETACH:
	case DLL_PROCESS_DETACH:
		break;
	}
    return TRUE;
}

//--------------------------------------------------------------------------
//
// This function is exported
//
UINT _stdcall Install(MSIHANDLE hInstall)
{
	//::MessageBox( NULL, TEXT( "attach debugger" ), TEXT( "uddi" ), MB_OK );

	ENTER();

	TCHAR szCustomActionData[ 256 ];
	DWORD dwLen = sizeof( szCustomActionData ) / sizeof( szCustomActionData[0] );

	UINT iRet = MsiGetProperty( hInstall, TEXT( "CustomActionData" ), szCustomActionData, &dwLen);
	if( ERROR_SUCCESS != iRet )
	{
		LogError( TEXT( "Error getting custom action data in Web installer" ), iRet );
		return iRet;
	}

	//::MessageBox( NULL, TEXT( "got CustomActionaData" ), TEXT( "uddi" ), MB_OK );
	
	//
	// get rid of any lefover entries first...
	//
	RemoveIISUDDIMetabase();

	//::MessageBox( NULL, TEXT( "removed metabase" ), TEXT( "uddi" ), MB_OK );

	//
	// put our entries into the IIS metabase
	//
	TCHAR szUserName[CA_VALUE_LEN+1];
	TCHAR szPwd[CA_VALUE_LEN+1];
	TCHAR szTmpBuf[ 1024 ];
	TCHAR szTmpProperty[ 256 ];
	TCHAR szLogPath[ MAX_PATH + 1 ] = {0};
	ATOM at = 0;
	int poolidtype = 0;

	memset (szUserName, 0, sizeof szUserName);
	memset (szPwd, 0, sizeof szPwd);
	memset (szTmpProperty, 0, sizeof szTmpProperty );

	CPropertyBag pb;
	if( !pb.Parse( szCustomActionData, sizeof( szCustomActionData ) / sizeof( TCHAR ) ) )
	{
		return ERROR_INSTALL_FAILURE;
	}

	//::MessageBox( NULL, TEXT( "parsed properties" ), TEXT( "uddi" ), MB_OK );
	poolidtype = pb.GetValue( TEXT( "APPPOOL_IDENTITY_TYPE" ) );
	_tcsncpy( szUserName, pb.GetString( TEXT( "WAM_USER_NAME" ), szTmpBuf ), CA_VALUE_LEN );
	_tcsncpy( szTmpProperty, pb.GetString( TEXT( "C9E18" ), szTmpProperty ), CA_VALUE_LEN );
	_tcsncpy( szLogPath, pb.GetString( TEXT( "LOGDIR" ), szLogPath ), MAX_PATH );

        //::MessageBox( NULL, szTmpProperty, TEXT( "C9E18" ), MB_OK );

	if ( _tcslen( szTmpProperty ) )
	{
		at = (ATOM)_ttoi( szTmpProperty );
		GlobalGetAtomName( at, szPwd, CA_VALUE_LEN );
	}

        //::MessageBox( NULL, szPwd, TEXT( "C9E18 Atom value" ), MB_OK );

	iRet = SetupIISUDDIMetabase( poolidtype, szUserName, szPwd );

	//::MessageBox( NULL, TEXT( "metabase set up ok" ), TEXT( "uddi" ), MB_OK );

	//iRet = SetupIISUDDIMetabase( 3, TEXT( "A-MARKPA11\\Guest" ), TEXT( "" ) );
	if( ERROR_SUCCESS != iRet )
	{
		return iRet;
	}

	//
	// stop and start the app pool
	//
	CUDDIAppPool apppool;
	apppool.Recycle();

	//::MessageBox( NULL, TEXT( "app pool recycled" ), TEXT( "uddi" ), MB_OK );

	//
	// set permissions on the UDDI folders
	//
	if ( !SetUDDIFolderDacls( szUserName ) )
	{
		return ERROR_INSTALL_FAILURE;
	}

	//
	// now set permissions on the log folders
	//
	if ( _tcslen( szLogPath ) )
	{
		if ( !SetFolderAclRecurse( szLogPath, szUserName, GENERIC_READ | GENERIC_WRITE | DELETE ) )
			return ERROR_INSTALL_FAILURE;
	}

	//
	// Set permissions on the Windows TEMP folder; we need access to this directory because our code
	// does CLR serialization.
	if( !SetWindowsTempDacls( szUserName ) ) 
	{
		return ERROR_INSTALL_FAILURE;
	}
	
	//::MessageBox( NULL, TEXT( "finishing this part..." ), TEXT( "uddi" ), MB_OK );

	Log (_T("About to leave Install with retcode %d"), iRet);
	return iRet;
}

//--------------------------------------------------------------------------
//
// This function is exported
//
UINT _stdcall Uninstall(MSIHANDLE hInstall)
{
	ENTER();
	//::MessageBox( NULL, TEXT( "attach debugger" ), TEXT( "uddi" ), MB_OK );

	RemoveIISUDDIMetabase();

	//
	// delete the app pool
	//
	CUDDIAppPool apppool;
	apppool.Delete();

	return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\tools\bootstrap\makefile.inc ===
foo.cs:
	..\..\version\$(O)\version.exe -outfile .\assemblyversioninfo.cs
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\tools\fixdefaulturl\makefile.inc ===
foo.cs:
	..\..\version\$(O)\version.exe .\assemblyversioninfo.cs
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\tools\migrate\makefile.inc ===
foo.cs:
	..\..\version\$(O)\version.exe -outfile .\assemblyversioninfo.cs
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\tools\bootstrap\bootstrap.cs ===
using System;
using System.IO;
using System.Security.Principal;
using System.Xml.Serialization;
using System.Data;
using System.Data.SqlClient;
using System.Resources;

using UDDI.API;
using UDDI.API.Extensions;

namespace UDDI.Tools
{
	class Bootstrap
	{
		static string filename;
		static string username;

		static int Main( string[] args )
		{
			int retCode = 1; // assume error

			// 
			// Check if CurrentUICulture needs to be overridden
			//
			UDDI.Localization.SetConsoleUICulture();

			Console.WriteLine( FormatFromResource( "BOOTSTRAP_COPYRIGHT_1" ) );
			Console.WriteLine( FormatFromResource( "BOOTSTRAP_COPYRIGHT_2" ) );
			Console.WriteLine();

			//
			// parse the command line
			//
			if(!ProcessCommandLine( args ) )
				return 1;

			WindowsPrincipal prin = new WindowsPrincipal( WindowsIdentity.GetCurrent() );

			try
			{
				ConnectionManager.Open( true, true );
			}
			catch
			{
				Console.WriteLine( FormatFromResource( "BOOTSTRAP_DB_CONNECT_FAILED" ) );
				return 1;
			}

			try
			{
				//
				// Setup the UDDI user credentials
				//
				Context.User.SetRole( prin );

				//
				// Verify that the user is a member of the administrators group
				//
				if( !Context.User.IsAdministrator )
				{
					//
					// 735728 - Show an error to the user and exit the program.
					//
					Console.WriteLine( FormatFromResource( "BOOTSTRAP_ACCESS_DENIED" ) );
					Console.WriteLine( FormatFromResource( "BOOTSTRAP_ADMIN_GROUP_ONLY" ) );
					Console.WriteLine( FormatFromResource( "BOOTSTRAP_USER_NOT_ADMIN" , WindowsIdentity.GetCurrent().Name ) );

					return 1;					
				}

				if( null != username && 0 != username.Length )
				{
					//
					// The /u option was specified
					//

					Context.User.SetPublisherRole( username );
					if( !Context.User.IsRegistered )
					{
						//
						// 735728 - Show an error to the user and exit the program.
						//
						Console.WriteLine( FormatFromResource( "BOOTSTRAP_USER_NOT_REGISTERED" , username ) );
						
						return 1;
					}

					//
					// If the current user is not the same as the publisher, set up impersonation
					//

					if ( Context.User.ID != WindowsIdentity.GetCurrent().Name )
						Context.User.ImpersonatorID = WindowsIdentity.GetCurrent().Name;
				}
				else
				{
					//
					// Default is to save data under the default publisher
					//
					Context.User.ID = UDDI.Utility.GetDefaultPublisher();
				}

				//
				// If user is not system publisher, a temporary operator must be added to support pre-assigned key behavior
				//

				string operatorkey = System.Guid.NewGuid().ToString();

				if( Context.User.ID != UDDI.Utility.GetDefaultPublisher() )
					Context.User.SetAllowPreassignedKeys( true );

				XmlSerializer serializer = new XmlSerializer( typeof( UDDI.API.Extensions.Resources ) );

				//
				// Load the XML file.
				//
				Console.WriteLine( FormatFromResource( "BOOTSTRAP_PROCESSING_MSG" , filename, Context.User.ID ) );

				FileStream strm = new FileStream( filename, FileMode.Open, FileAccess.Read );
				Resources.Validate( strm );
				Resources resources = (Resources) serializer.Deserialize( strm );					
				strm.Close();

				//
				// Save the TModel
				//
				Console.WriteLine( FormatFromResource( "BOOTSTRAP_SAVING" ) );
				
				//
				// Determine the number of tModels that we imported.
				//
				int tModelCount = 0;
				if( null != resources.TModelDetail)
				{
					tModelCount += resources.TModelDetail.TModels.Count;
				}

				if( null != resources.CategorizationSchemes )
				{
					foreach( CategorizationScheme scheme in resources.CategorizationSchemes )
					{
						if( null != scheme.TModel )
						{
							tModelCount ++;
						}
					}
				}
				Console.WriteLine( FormatFromResource( "BOOTSTRAP_TMODELS", tModelCount ) );

				if( null != resources.CategorizationSchemes )
					Console.WriteLine( FormatFromResource( "BOOTSTRAP_CATEGORIZATION_SCHEMES", resources.CategorizationSchemes.Count ) );
				else
					Console.WriteLine( FormatFromResource( "BOOTSTRAP_CATEGORIZATION_SCHEMES", 0 ) );

				if( null != resources.BusinessDetail )
					Console.WriteLine( FormatFromResource( "BOOTSTRAP_PROVIDERS", resources.BusinessDetail.BusinessEntities.Count ) );
				else
					Console.WriteLine( FormatFromResource( "BOOTSTRAP_PROVIDERS", 0 ) );

				if( null != resources.ServiceDetail )
					Console.WriteLine( FormatFromResource( "BOOTSTRAP_SERVICES", resources.ServiceDetail.BusinessServices.Count ) );
				else
					Console.WriteLine( FormatFromResource( "BOOTSTRAP_SERVICES", 0 ) );

				if( null != resources.BindingDetail )
					Console.WriteLine( FormatFromResource( "BOOTSTRAP_BINDINGS", resources.BindingDetail.BindingTemplates.Count ) );
				else
					Console.WriteLine( FormatFromResource( "BOOTSTRAP_BINDINGS", 0 ) );
				
				resources.Save();

				Console.WriteLine( FormatFromResource( "BOOTSTRAP_COMPLETE" ) );

				ConnectionManager.Commit();

				retCode = 0; // no error
			}
			catch( Exception e )
			{
				Console.WriteLine();
				Console.WriteLine( FormatFromResource( "BOOTSTRAP_FAILED" , e.Message ) );

				//
				// 735713 - Output an additional message if the user did not have permissions to modify an entity.
				//
				SqlException sqlException = e as SqlException;
				if( null != sqlException )
				{
					if( sqlException.Number - UDDI.Constants.ErrorTypeSQLOffset == ( int ) ErrorType.E_userMismatch )
					{						
						Console.WriteLine( FormatFromResource( "ERROR_USER_MISMATCH" ) );
					}
				}

				ConnectionManager.Abort();
			}
			finally
			{
				ConnectionManager.Close();
			}

			return retCode;
		}

		private static bool ProcessCommandLine( string [] args )
		{
			bool bOK = false;
			for( int i = 0; i < args.Length; i ++ )
			{
				if( '-' == args[i][0] || '/' == args[i][0] )
				{
					string option = args[i].Substring( 1 );

					if( "help" == option.ToLower() || "?" == option )
					{
						break;
					}
					else if( "f" == option.ToLower() )
					{
						i++; // move to the next arg
						if( i >= args.Length )
						{
							break;
						}
							
						filename = args[i];
						bOK = true;
					}
					else if( "u" == option.ToLower() )
					{
						i++; // move to the next arg
						if( i >= args.Length )
						{
							break;
						}

						username = args[i];
					}
					else
					{
						DisplayUsage();
						return false;
					}
				}
			}

			if( !bOK )
			{
				DisplayUsage();
				return false;
			}

			return true;
		}

		static void DisplayUsage()
		{
			Console.WriteLine( FormatFromResource( "BOOTSTRAP_USAGE_1" ) );
			Console.WriteLine();
			Console.WriteLine( FormatFromResource( "BOOTSTRAP_USAGE_2" ) );
			Console.WriteLine();
			Console.WriteLine( FormatFromResource( "BOOTSTRAP_USAGE_3" ) );
			Console.WriteLine( FormatFromResource( "BOOTSTRAP_USAGE_4" ) );
			Console.WriteLine();
		}

		static string FormatFromResource( string resID, params object[] inserts )
		{
			try
			{
				string resourceStr = UDDI.Localization.GetString( resID );
				if( null != resourceStr )
				{
					string resultStr = string.Format( resourceStr, inserts );
					return resultStr;
				}

				return "String not specified in the resources: " + resID;
			}
			catch( Exception e )
			{
				return "FormatFromResource failed to load the resource string for ID: " + resID + " Reason: " + e.Message;
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\tools\bootstrap\assemblyinfo.cs ===
using System.Reflection;
using System.Security.Permissions;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("bootstrap.exe")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft Corporation")]
[assembly: AssemblyProduct("UDDI Services")]
[assembly: AssemblyCopyright("Copyright(c) 2002 Microsoft Corporation")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]
[assembly: PermissionSetAttribute(SecurityAction.RequestMinimum, Name = "FullTrust")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("")]
[assembly: AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\tools\fixdefaulturl\fixdefaulturl.cs ===
using System;
using System.Collections;
using System.IO;
using System.Data;
using System.Data.SqlClient;
using System.Xml;
using System.Xml.Serialization;
using System.Windows.Forms;
using System.Security.Principal;

using Microsoft.Win32;

using UDDI;
using UDDI.API;
using UDDI.API.Business;
using UDDI.Replication;

namespace UDDI.Tools
{
	class FixDefaultURL
	{
		//
		// Enumerated Types
		//
		enum LogType
		{
			ConsoleAndLog,
			ConsoleOnly,
			LogOnly
		}

		//
		// Constants
		//
		const string LogFileName		= "fixdefaulturl.log.txt";
		const string ExceptionFileName  = "fixdefaulturl.exceptions.txt";

		//
		// Globals
		//
		static StreamWriter logFile;
		static StreamWriter exceptionsFile;

		static void FixDefaultURLs()
		{
			//
			// Get a list of business keys that have non-default discovery URLs.
			//
			ArrayList businessEntities = GetBusinessEntities();
			int total		= businessEntities.Count;
			int current		= 1;
			int numberFixed = 0;

			foreach( BusinessEntity businessEntity in businessEntities )
			{				
				//
				// Get values for this business.
				//
				businessEntity.Get();				
				
				//
				// BusinessEntity.Get() may add the default one, we don't want it.
				//
				DiscoveryUrlCollection originalList = new DiscoveryUrlCollection();			
				originalList.Get( businessEntity.BusinessKey );
				businessEntity.DiscoveryUrls = originalList;				

				Log( "*** Processing " + current++ + "/" + total + " *** " );
		
				LogStartBusinessEntity( businessEntity );

				DiscoveryUrlCollection filteredList = GetFilterList( businessEntity );				

				if( filteredList.Count < businessEntity.DiscoveryUrls.Count )
				{
					try
					{
						numberFixed++;

						LogFixStart( filteredList );

						ConnectionManager.BeginTransaction();

						//
						// Remove duplicate discovery URLs
						//
						businessEntity.DiscoveryUrls = filteredList;
					
						//
						// Fix change records
						//
						FixChangeRecords( businessEntity );

						//
						// Fix data.  Saving the BusinessEntity will also create a ChangeRecordNew data in our replication stream.
						// Other operators will consume this change record, which will update their databases.
						//		
						
						FixData( businessEntity );						
#if never						
						ChangeRecordNewData changeRecordNewData = new ChangeRecordNewData( businessEntity );
						ChangeRecord fixData = new ChangeRecord( changeRecordNewData );
						fixData.Process();
#endif																		
						ConnectionManager.Commit();

						LogFixEnd( businessEntity );
					}
					catch( Exception e)
					{										
						WriteException( e );
						ConnectionManager.Abort();
					}
				}				
				LogDoneBusinessEntity( businessEntity );
			}
			Log( "BusinessEntities fixed: " + numberFixed );
		}

		static void FixData( BusinessEntity businessEntity )
		{
			Log( "\t\tSTART Fixing Data" );

			//
			// Save the current user ID
			//
			string currentUserID = Context.User.ID;

			try
			{
				//
				// Set the current user to this user to the PUID for this business entity.
				//			
				Context.User.ID = GetPUIDForBusinessEntity( businessEntity.BusinessKey );
			
				//
				// Save our business
				//
				businessEntity.Save();

				Log( "\t\tDONE Fixing Data" );
			} 
			finally
			{
				//
				// Restore the ID
				//
				Context.User.ID = currentUserID;
			}
		}

		static string GetPUIDForBusinessEntity( string businessKey )
		{
			SqlStoredProcedureAccessor puidSP = new SqlStoredProcedureAccessor();			
			puidSP.ProcedureName = "net_getPUIDForBusinessEntity";			

			puidSP.Parameters.Add( "@businessKey",	SqlDbType.UniqueIdentifier );
			puidSP.Parameters.SetGuidFromString( "@businessKey", businessKey );		
			
			SqlDataReaderAccessor reader = puidSP.ExecuteReader();	
			string puid = "";

			try
			{
				reader.Read();
				puid = reader.GetString( 0 );
			}
			finally
			{
				reader.Close();
			}

			return puid;
		}

		static void FixChangeRecords( BusinessEntity businessEntity )
		{
			//
			// Get all related change records
			//
			ArrayList newDataChangeRecords = GetChangeRecordsForEntity( businessEntity );
			
			//
			// Create and process a correction for each change record.
			//
			Log( "\t\tSTART Processing Corrections" );
			foreach( ChangeRecord changeRecord in newDataChangeRecords )
			{								
				ChangeRecord changeRecordCorrection = CreateCorrection( changeRecord, businessEntity );
				changeRecordCorrection.Process();			

				LogChangeRecordCorrection( changeRecord, changeRecordCorrection );
			}
			Log( "\t\tDONE Processing Corrections" );
		}

		static ChangeRecord CreateCorrection( ChangeRecord originalChangeRecord, BusinessEntity businessEntity )
		{
			ChangeRecordNewData changeRecordNewData = originalChangeRecord.Payload as ChangeRecordNewData;				
			changeRecordNewData.Entity = businessEntity;

			ChangeRecordCorrection changeRecordCorrection = new ChangeRecordCorrection();
			changeRecordCorrection.ChangeRecord			  = originalChangeRecord;
			
			return new ChangeRecord( changeRecordCorrection );
		}

		static ArrayList GetChangeRecordsForEntity( BusinessEntity businessEntity )
		{
			string contextID					= Guid.NewGuid().ToString();
			string operatorKey					= Config.GetString( "OperatorKey" );
			ArrayList changeRecords				= new ArrayList();
			SqlDataReaderAccessor resultsReader = null;

			try
			{
				//
				// Get all the ChangeRecordNewData change records associated with this entity.
				//
				SqlStoredProcedureAccessor findSP = new SqlStoredProcedureAccessor();			
				findSP.ProcedureName = "net_find_changeRecordsByChangeType";			

				findSP.Parameters.Add( "@contextID",	SqlDbType.UniqueIdentifier );
				findSP.Parameters.Add( "@operatorKey",	SqlDbType.UniqueIdentifier );
				findSP.Parameters.Add( "@entityKey",	SqlDbType.UniqueIdentifier );
				findSP.Parameters.Add( "@changeTypeID", SqlDbType.TinyInt );
				findSP.Parameters.Add( "@rows",			SqlDbType.Int, ParameterDirection.Output );

				findSP.Parameters.SetGuidFromString( "@contextID", contextID );
				findSP.Parameters.SetGuidFromString( "@operatorKey", operatorKey );
				findSP.Parameters.SetGuidFromString( "@entityKey",	 businessEntity.BusinessKey );
				findSP.Parameters.SetShort( "@changeTypeID", ( short )ChangeRecordPayloadType.ChangeRecordNewData );

				findSP.ExecuteNonQuery();

				//
				// Retrieve results
				//
				SqlStoredProcedureAccessor resultsSP = new SqlStoredProcedureAccessor();

				resultsSP.ProcedureName = "net_find_changeRecords_commit";

				resultsSP.Parameters.Add( "@contextID", SqlDbType.UniqueIdentifier );			
				resultsSP.Parameters.Add( "@responseLimitCount", SqlDbType.Int );

				resultsSP.Parameters.SetGuidFromString( "@contextID", contextID );
				resultsSP.Parameters.SetInt( "@responseLimitCount", 0 );

				//
				// Read our results and create change records from them.
				//
				resultsReader = resultsSP.ExecuteReader();

				while( resultsReader.Read() )
				{
					ChangeRecord changeRecord = CreateChangeRecord( resultsReader );
					if( null != changeRecord )
					{
						changeRecords.Add( changeRecord );
					}
					else
					{
						throw new Exception( "Could not create change record!" );
					}
				}			
			}
			catch
			{
				//
				// Cleanup on failure.
				//
				SqlStoredProcedureAccessor cleanupSP = new SqlStoredProcedureAccessor();			
						
				cleanupSP.ProcedureName = "net_find_changeRecords_cleanup";
				cleanupSP.Parameters.Add( "@contextID", SqlDbType.UniqueIdentifier );			
				cleanupSP.Parameters.SetGuidFromString( "@contextID", contextID );

				cleanupSP.ExecuteNonQuery();
			}			
			finally
			{
				if( null != resultsReader )
				{
					resultsReader.Close();
				}
			}

			return changeRecords;
		}

		static ChangeRecord CreateChangeRecord( SqlDataReaderAccessor reader )
		{	
			ChangeRecord changeRecord = null;
			
			XmlSerializer serializer = null;

			switch( (ChangeRecordPayloadType)reader.GetShort( "changeTypeID" ) )
			{
				case ChangeRecordPayloadType.ChangeRecordNull:
					serializer = new XmlSerializer( typeof( ChangeRecordNull ) );
					break;

				case ChangeRecordPayloadType.ChangeRecordNewData:
					serializer = new XmlSerializer( typeof( ChangeRecordNewData ) );
					break;

				case ChangeRecordPayloadType.ChangeRecordDelete:
					serializer = new XmlSerializer( typeof( ChangeRecordDelete ) );
					break;

				case ChangeRecordPayloadType.ChangeRecordPublisherAssertion:
					serializer = new XmlSerializer( typeof( ChangeRecordPublisherAssertion ) );
					break;

				case ChangeRecordPayloadType.ChangeRecordHide:
					serializer = new XmlSerializer( typeof( ChangeRecordHide ) );
					break;

				case ChangeRecordPayloadType.ChangeRecordDeleteAssertion:
					serializer = new XmlSerializer( typeof( ChangeRecordDeleteAssertion ) );
					break;

				case ChangeRecordPayloadType.ChangeRecordAcknowledgement:
					serializer = new XmlSerializer( typeof( ChangeRecordAcknowledgement ) );
					break;

				case ChangeRecordPayloadType.ChangeRecordCorrection:
					serializer = new XmlSerializer( typeof( ChangeRecordCorrection ) );
					break;
			}

			StringReader stringReader = new StringReader( reader.GetString( "changeData" ) );
				
			try
			{
				changeRecord = new ChangeRecord();
									
				changeRecord.AcknowledgementRequested = ( reader.GetInt( "flag" ) & (int)ChangeRecordFlags.AcknowledgementRequested ) > 0;
				changeRecord.ChangeID.NodeID		  = reader.GetString( "OperatorKey" );
				changeRecord.ChangeID.OriginatingUSN  = reader.GetLong( "USN" );
				
				ChangeRecordBase changeRecordBase = ( ChangeRecordBase ) serializer.Deserialize( stringReader );
				if( changeRecordBase is ChangeRecordCorrection )
				{
					//
					// The query to find change records will do correction 'fixups'.  That is, the changeData of this
					// change record will be replaced with the changeData from the correction.  The problem with this is 
					// that the original change data will now look like a correction.  To distinguish these types of 
					// change records, we look to see if the OriginatingUSN's match.  If the OriginatingUSN's match,
					// we want they payload of the change record in this correction.  This payload will contain the
					// corrected data that we want.
					//
					ChangeRecordCorrection changeRecordCorrection = ( ChangeRecordCorrection ) changeRecordBase;
					if( changeRecordCorrection.ChangeRecord.ChangeID.OriginatingUSN == changeRecord.ChangeID.OriginatingUSN )
					{
						changeRecordBase = changeRecordCorrection.ChangeRecord.Payload;
					}								
				}
					
				changeRecord.Payload = changeRecordBase;																			
			}
			finally
			{
				stringReader.Close();
			}

			return changeRecord;
		}

		static DiscoveryUrlCollection GetFilterList( BusinessEntity businessEntity )
		{
			DiscoveryUrlCollection filterList  = new DiscoveryUrlCollection();
		
			//
			// Get the default URL
			//
			string defaultDiscoveryUrl= Config.GetString( "DefaultDiscoveryURL" ) + businessEntity.BusinessKey;
			
			foreach( DiscoveryUrl discoveryUrl in businessEntity.DiscoveryUrls )
			{
				//
				// Do a case in-sensitive search
				//
				if( string.Compare( discoveryUrl.Value, defaultDiscoveryUrl, true ) != 0 )
				{
					filterList.Add( discoveryUrl );
				}
			}

			return filterList;
		}

		static ArrayList GetBusinessEntities()
		{			
			ArrayList businessKeyList = new ArrayList();

			SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor();
			sp.ProcedureName = "net_find_businessKeysWithDiscoveryURLs";
		
			SqlDataReaderAccessor reader = sp.ExecuteReader();
			
			ArrayList businessEntities = new ArrayList();
			try
			{
				while( reader.Read() )
				{		
					BusinessEntity businessEntity = new BusinessEntity( reader.GetGuidString( 0 ) );
					businessEntities.Add( businessEntity );
				}
			}
			finally
			{
				reader.Close();
			}
			
			return businessEntities;
		}
				
		[STAThread]
		static void Main(string[] args)
		{
			Log( "Microsoft (R) FixDefaultURL Migrate Utility",					FixDefaultURL.LogType.ConsoleOnly );
			Log( "Copyright (C) Microsoft Corp. 2002. All rights reserved.\n",	FixDefaultURL.LogType.ConsoleOnly );

			try
			{
				//
				// Process command line arguments
				//
				ProcessCommandLineArgs( args );
						
				//
				// Init
				//
				Initialize();

				//
				// Fix our URLs
				//			
				FixDefaultURLs();					
			}
			catch( Exception e )
			{
				WriteException( "Uncaught exception: " + e.ToString() );
			}
			finally
			{
				logFile.Close();
			
				if( null != exceptionsFile )
				{
					exceptionsFile.Close();
				}
			}
		}

		static void ProcessCommandLineArgs( string[] commandLineArgs )
		{
			//
			// No command line args.
			//			
		}

		static bool ValidatePublisher()
		{
			bool validPublisher = Context.User.IsRegistered;
			
			//
			// Make sure the user is a UDDI publisher.
			//
			if( false == validPublisher )
			{
				DialogResult dialogResult = MessageBox.Show( "You are not registered as a publisher on this UDDI Site?  You must register before performing this operation.  Would you like to register now?", 
					"UDDI",
					MessageBoxButtons.YesNo );
				
				if( DialogResult.Yes == dialogResult )
				{
					try
					{
						Context.User.Register();
						validPublisher = Context.User.IsRegistered;
					}
					catch( Exception registrationException )
					{
						MessageBox.Show( "An exception occurred when trying to register:\r\n\r\n" + registrationException.ToString() );
					}
				}
			}

			return validPublisher;
		}

		static void Initialize()
		{
			//
			// Open a connection to our UDDI database.
			//
			ConnectionManager.Open( true, false );

			//
			// Create our log file.
			//
			logFile = new StreamWriter( File.Open( LogFileName, FileMode.Append, FileAccess.Write, FileShare.Read ) );					
			logFile.WriteLine( "--------------------- STARTING NEW LOG (" + DateTime.Now.ToString() + ")--------------------- " );

			//
			// Get UDDI site configuration settings.
			//
			Config.Refresh();

			//
			// Make sure the user is allowed to run this program.
			//
			WindowsIdentity identity   = WindowsIdentity.GetCurrent();
			WindowsPrincipal principal = new WindowsPrincipal( identity );
				
			Context.User.SetRole( principal );
				
			if( !Context.User.IsAdministrator )
			{
				MessageBox.Show( "Access denied.\r\n\r\nThis program must be executed by a member of the '" 
					+ Config.GetString( "GroupName.Administrators" ) + "'\r\ngroup.  The current user '" 
					+ identity.Name + "' is not a member of this group." );					
				return;
			}
		
			//
			// Make sure the user is a valid publisher.
			//
			if( false == ValidatePublisher() )
			{
				Log( "You must be a UDDI publisher in order to run this program", LogType.ConsoleOnly );
				System.Environment.Exit( 1 );
			}							
		}

		static void WriteException( Exception e )
		{
			WriteException( e.ToString() );
		}

		static void WriteException( string msg )
		{		
			if( null == exceptionsFile )
			{
				//
				// Create our exceptions file.
				//
				exceptionsFile = new StreamWriter( File.Open( ExceptionFileName, FileMode.Append, FileAccess.Write, FileShare.Read ) );
				exceptionsFile.WriteLine( "--------------------- STARTING NEW LOG (" + DateTime.Now.ToString() + ")--------------------- " );
			}

			Log( exceptionsFile, msg, LogType.ConsoleAndLog );
		}

		static void Log( string message )
		{
			Log( message, LogType.ConsoleAndLog );
		}

		static void Log( string message, LogType logType )
		{
			Log( logFile, message, logType );
		}

		static void Log( StreamWriter log, string message, LogType logType )
		{
			switch ( logType )
			{
				case LogType.ConsoleAndLog:
				{
					Console.WriteLine( message );
					log.WriteLine( "{0}: {1}", DateTime.Now.ToLongTimeString(), message );
					break;
				}
				case LogType.ConsoleOnly:
				{
					Console.WriteLine( message );
					break;
				}
				default:
				{
					log.WriteLine( "{0}: {1}", DateTime.Now.ToLongTimeString(), message );
					break;
				}
			}
		}

		private static string Serialize( object obj )
		{
			UTF8EncodedStringWriter stringWriter = new UTF8EncodedStringWriter();
			
			try
			{
				XmlSerializer serializer = new XmlSerializer( obj.GetType() );					
				XmlSerializerNamespaces namespaces = new XmlSerializerNamespaces();			
				namespaces.Add( "", "urn:uddi-org:api_v2" );

				serializer.Serialize( stringWriter, obj, namespaces );				
			}
			finally
			{
				stringWriter.Close();
			}

			return stringWriter.ToString();
		}

		static void LogStartBusinessEntity( BusinessEntity businessEntity )
		{
			Log( "START Examining: " + businessEntity.BusinessKey );
			Log( "\tOriginal DiscoveryUrls:" );

			foreach( DiscoveryUrl discoveryUrl in businessEntity.DiscoveryUrls )
			{
				Log( "\t\t" + discoveryUrl.Value );
			}
		}

		static void LogDoneBusinessEntity( BusinessEntity businessEntity )
		{
			Log( "DONE Examining: " + businessEntity.BusinessKey );			
		}

		static void LogFixStart( DiscoveryUrlCollection filteredList )
		{			
			Log( "\tSTART Fixing duplicates; new DiscoveryUrl list will be:" );
			
			if( filteredList.Count == 0 )
			{
				Log( "\t\tNo Discovery Urls besides default." );
			}
			else
			{
				foreach( DiscoveryUrl discoveryUrl in filteredList )
				{
					Log( "\t\t" + discoveryUrl.Value );
				}
			}
		}
		
		static void LogFixEnd( BusinessEntity businessEntity )
		{
			Log( "\tDONE Fixing duplicates" );		
		}

		static void LogChangeRecordCorrection( ChangeRecord changeRecord, ChangeRecord changeRecordCorrection )
		{
			Log( "\t\t\tCorrecting USN: " + changeRecord.ChangeID.OriginatingUSN );
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\tools\monitor\makefile.inc ===
foo.cs:
	..\..\version\$(O)\version.exe -outfile .\assemblyversioninfo.cs
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\tools\fixdefaulturl\assemblyinfo.cs ===
using System.Reflection;
using System.Security.Permissions;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("fixdefaulturl.exe")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft Corporation")]
[assembly: AssemblyProduct("UDDI Services")]
[assembly: AssemblyCopyright("Copyright(c) 2002 Microsoft Corporation")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]
[assembly: PermissionSetAttribute(SecurityAction.RequestMinimum, Name = "FullTrust")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("")]
[assembly: AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\tools\migrate\assemblyinfo.cs ===
using System.Reflection;
using System.Security.Permissions;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("migrate.exe")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft Corporation")]
[assembly: AssemblyProduct("UDDI Services")]
[assembly: AssemblyCopyright("Copyright(c) 2002 Microsoft Corporation")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]
[assembly: PermissionSetAttribute(SecurityAction.RequestMinimum, Name = "FullTrust")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("")]
[assembly: AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\tools\rcf\makefile.inc ===
foo.cs:
	..\..\version\$(O)\version.exe -outfile .\assemblyversioninfo.cs
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\setup\web\ca\webca.cs ===
/// ************************************************************************
///   Microsoft UDDI version 2.0
///   Copyright (c) 2000-2001 Microsoft Corporation
///   All rights reserved
///
///   ** Microsoft Confidential **
/// ------------------------------------------------------------------------
///   <summary>
///   </summary>
/// ************************************************************************
///
using System;
using System.IO;
using System.Net;
using System.Text;
using System.Data;
using Microsoft.Win32;
using System.Diagnostics;
using System.Reflection;
using System.Collections;
using System.Data.SqlClient;
using System.ComponentModel;
using System.ServiceProcess;
using System.DirectoryServices;
using System.Configuration.Install;
using System.Runtime.InteropServices;
using System.Xml.Serialization;
using System.Resources;
using System.Windows.Forms;
using System.Security.Permissions;
using System.Security.Principal;
using System.Globalization;

using UDDI;
using UDDI.Diagnostics;
using UDDI.API;
using UDDI.API.Business;
using UDDI.API.Service;
using UDDI.API.Binding;
using UDDI.API.ServiceType;
using UDDI.ActiveDirectory;


namespace UDDI.WebCA
{
	/// <summary>
	/// Summary description for installer.
	/// </summary>
	[RunInstaller(true)]
	public class Installer : System.Configuration.Install.Installer
	{
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components = null;
		private string serviceAccountPassword = null;
		private string targetDirectory = null;
		private string compileDirectory = null;
		private const int ERROR_USER_NOT_FOUND = -2147463164;
		private const int ERROR_USER_ALREADY_IN_GROUP = -2147023518;

		private const string busEntityKeyName	= "Site.Key";		// we use this name to save the key in the Config
		private const string defaultHelpDir		= "default";

		//
		// These values are set in the MSI
		//
		private const string addServicesKeyName = "UDDI_ADDSVC";	// "Add Services" context flag name
		private const string updateADKeyName	= "UDDI_UPDATEAD";	// "Update Active Dir" context flag name
		private const string sslRequiredKey		= "Security.HTTPS";
		private const string cultureID			= "CultureID";

		private const string clustNodeTypeParam = "CNTYPE";			 // cluster node type
		private const string clustNodeActive	= "A";		// Denotes an "active" node
		private const string clustNodePassive	= "P";		// Denotes a "passive" aka non-owning node

		private const string tmodelWinAuthMode	= "uuid:0C61E2C3-73C5-4743-8163-6647AF5B4B9E";
		private const string tmodelUDDIAuthMode = "uuid:F358808C-E939-4813-A407-8873BFDC3D57";
		private const string tmodelAnonAuthMode = "uuid:E4A56494-4946-4805-ACA5-546B8D08EEFD";

		private const string tmodelUddiOrgPub		= "uuid:64C756D1-3374-4E00-AE83-EE12E38FAE63";
		private const string tmodelUddiOrgPubV2		= "uuid:A2F36B65-2D66-4088-ABC7-914D0E05EB9E";
		private const string tmodelUddiOrgHttp		= "uuid:68DE9E80-AD09-469D-8A37-088422BFBC36";
		private const string tmodelUddiOrgHomepage	= "uuid:4CEC1CEF-1F68-4B23-8CB7-8BAA763AEB89";
		private const string tmodelUddiOrgInquiry	= "uuid:4CD7E4BC-648B-426D-9936-443EAAC8AE23";
		private const string tmodelUddiOrgInquiryV2 = "uuid:AC104DCC-D623-452F-88A7-F8ACD94D9B2B";
		private const string tmodelMSComAddWebRef	= "uuid:CE653789-F6D4-41B7-B7F4-31501831897D";
		private const string tmodelMSComUddiExtV2	= "uuid:B3C0835E-7206-41E0-9311-C8AD8FB19F73";

		//
		// ActiveDirectory Class Names and reserved Keywords
		//
		private const string pubInqClassName	= "UddiInquireUrl";
		private const string pubPubClassName	= "UddiPublishUrl";
		private const string pubWebClassName	= "UddiWebSiteUrl";
		private const string pubDiscoClassName	= "UddiDiscoveryUrl";
		private const string pubAddRefClassName	= "UddiAddWebReferenceUrl";

		private const string kwdWinAuthMode		= "WindowsAuthentication";
		private const string kwdUDDIAuthMode	= "UDDIAuthentication";
		private const string kwdAnonAuthMode	= "AnonymousAuthentication";

		private const string kwdWinAuthModeUuid		= "0C61E2C3-73C5-4743-8163-6647AF5B4B9E";
		private const string kwdUDDIAuthModeUuid	= "F358808C-E939-4813-A407-8873BFDC3D57";
		private const string kwdAnonAuthModeUuid	= "E4A56494-4946-4805-ACA5-546B8D08EEFD";

		private const string kwdDiscoveryUrlID		= "1276768A-1488-4C6F-A8D8-19556C6BE583";
		private const string kwdPublishServiceID	= "64C756D1-3374-4E00-AE83-EE12E38FAE63";
		private const string kwdInquiryServiceID	= "4CD7E4BC-648B-426D-9936-443EAAC8AE23";
		private const string kwdAddWebRefServiceID	= "CE653789-F6D4-41B7-B7F4-31501831897D";
		private const string kwdWebSiteServiceID	= "4CEC1CEF-1F68-4B23-8CB7-8BAA763AEB89";

		private const string kwdDiscoveryUrl	= "Discovery Url";
		private const string kwdPublishService	= "Publish API";
		private const string kwdInquiryService	= "Inquire API";
		private const string kwdAddWebRefService= "Add Web Reference";
		private const string kwdWebSiteService	= "Web Site";

		private const string addXPAccessSQL	    = @"
USE master
IF EXISTS ( SELECT * FROM sysusers where name = '{0}' )
BEGIN
	EXEC sp_revokedbaccess '{0}'
END
EXEC sp_grantdbaccess '{0}'

GRANT EXEC ON xp_recalculate_statistics TO public
GRANT EXEC ON xp_reset_key TO public";

		public Installer()
		{
			Enter();

			//
			// This call is required by the Designer.
			//
			InitializeComponent();

			Leave();
		}

		public override void Install( System.Collections.IDictionary state )
		{
			Enter();
			
			try
			{
				base.Install( state );

				Log( String.Format( "Running under the '{0}' user credentials", WindowsIdentity.GetCurrent().Name ) );

				targetDirectory = (string) Registry.LocalMachine.OpenSubKey( @"SOFTWARE\Microsoft\UDDI" ).GetValue( "InstallRoot" );
				compileDirectory = targetDirectory + @"webroot\compile";

				//foreach( System.Reflection.Assembly a in System.AppDomain.CurrentDomain.GetAssemblies() )
				//{
				//	Log( "Name: " + a.FullName + "\tLocation: " + a.Location );
				//}
			
				//
				// Generate a random password
				//
				serviceAccountPassword = GenerateRandomString();

				//System.Windows.Forms.MessageBox.Show( "UDDI Application Installer Stop", "UDDI.Debug" );

				//
				// obtain installation options
				//
				string szAddServiceFlag = Context.Parameters[ addServicesKeyName ];
				string szUpdateADFlag = Context.Parameters[ updateADKeyName ];
				
				if ( szAddServiceFlag == null )
					throw new InstallException( string.Format( "Required context value is not set: '{0}'", addServicesKeyName ) );

				if ( szUpdateADFlag == null )
					throw new InstallException( string.Format( "Required context value is not set: '{0}'", szUpdateADFlag ) );
                
				bool bAddServices = szAddServiceFlag.Equals( "1" );
				bool bUpdateActiveDir = szUpdateADFlag.Equals( "1" );

				//
				// First, are we on a cluster node ?
				//
				bool bActiveNode = false;
				string sClusterNodeType = Context.Parameters[ clustNodeTypeParam ];

				if ( sClusterNodeType == null || sClusterNodeType == "" )
					bActiveNode = true;  // we are not on a node, assume "active" mode
				else if ( String.Compare( sClusterNodeType, clustNodeActive, true ) == 0 ) 
					bActiveNode = true;
				else
					bActiveNode = false;

				if ( bActiveNode )
				{
					CreateLogin();
				}

				RegisterWebServer();
				ImportCertificate();
				InitializeCounters();
				AddUserToIIS_WPG();
				RenameHelp( targetDirectory, true );

				if ( bActiveNode )
				{
					UpdateDiscoveryUrl( bAddServices );
					if ( bAddServices )
					{
						AddDefaultServices();
					}

					if ( bUpdateActiveDir )
					{
						PublishToActiveDirectory( true );
					}
				}

				try
				{
					StartService( "RemoteRegistry", 30 );
				}
				catch ( Exception e )
				{
					LogException( string.Format( "Exception occured during database install: '{0}'", "RemoteRegistry Start" ) , e );
				}
			}
			catch( Exception e )
			{
				LogException( "Exception thrown in Install()", e );
				throw e;
			}
			finally
			{
				Leave();
			}
		}

		public override void Uninstall( System.Collections.IDictionary state )
		{
			Enter();

			try
			{
				base.Uninstall( state );

				UnRegisterWebServer();
				DeleteCounters();

				//
				// Uninstall is called first during install; make sure our registry is laid down before
				// trying to move files.
				//
				RegistryKey uddiKey = Registry.LocalMachine.OpenSubKey( @"SOFTWARE\Microsoft\UDDI" );
				if( null != uddiKey )
				{
					RenameHelp( ( string ) uddiKey.GetValue( "InstallRoot" ), false );				
				}
			}
			catch
			{
				// do nothing
			}
			finally
			{
				Leave();
			}
		}

		public override void Rollback( System.Collections.IDictionary state )
		{
			Enter();
			base.Rollback( state );
			Uninstall( state );
			Leave();
		}

		public void ImportData()
		{
			//
			// TODO: Import the initial data set
			// we need to get this from ckurt
			//
		}

		public void ImportCertificate()
		{
			//
			// TODO: Get the specified certificate name from the registry
			// and import it into the certificate store using certmgr.exe
			//
		}

		private void AddUserToIIS_WPG()
		{
			Enter();
			string userName = null;

			try
			{
				userName = Context.Parameters[ "WAM_USER_NAME" ];
				if( 0 == userName.Length )
				{
					throw new InstallException( "User name was not specified for the CreateLogin() function" );
				}

				//
				// replace any "\" with "/"
				//
				userName = userName.Replace( '\\', '/' );

				Log( "Attempting to add " + userName + " to the IIS_WPG group..." );
				string rootName = "WinNT://" + SystemInformation.ComputerName;
				DirectoryEntry computer = new DirectoryEntry( rootName );
				DirectoryEntry group = computer.Children.Find( "IIS_WPG", "group" );
				group.Invoke( "Add", new object[] { rootName + "/" + userName } );
				group.CommitChanges(); // actual store of entry
			}
			catch( Exception e )
			{
				//
				// check to see if the exception is because this user
				// is already in the group
				//
				COMException ce = ( COMException ) e.InnerException;
				
				if( ERROR_USER_ALREADY_IN_GROUP == ce.ErrorCode )
				{
					Log( "This user is already in the group" );
				}
				else
				{
					LogError( "Error adding " + userName + " to the IIS_WPG group: " + e.InnerException.Message );
				}
			}
			finally
			{
				Leave();
			}
		}

		private string GenerateRandomString()
		{
			byte[] begin = Guid.NewGuid().ToByteArray();
			byte[] end = Guid.NewGuid().ToByteArray();
			string str = Convert.ToBase64String( begin ) + "29.?" + Convert.ToBase64String( end );
			return str;
		}

		
		protected void AddDefaultServices()
		{
			Enter();

			try
			{
				// 
				// set up the connection and other environment settings
				//
				ConnectionManager.Open( true, true );
				UDDI.Context.User.SetRole( new WindowsPrincipal( WindowsIdentity.GetCurrent() ) );
				UDDI.Context.User.ID = UDDI.Utility.GetDefaultPublisher();

				// 
				// now retrieve the config options (site key etc.)
				//
				string key = UDDI.Config.GetString( busEntityKeyName, "*" );
				if ( key.Equals( "*" ) )	// there is no business entity key in the config
					throw new InstallException( string.Format( "Required configuration parameter is missing: '{0}'", busEntityKeyName ) ); 

				//
				// now as we know the site key, we can populate the Services data
				// First, generate the URL stubs
				//
				IPHostEntry hostInfo = Dns.GetHostByName( Dns.GetHostName() );

				string szUDDIPrivatePath = "http://" + hostInfo.HostName + "/uddi";
				string szUDDIPublicPath = "http://" + hostInfo.HostName + "/uddipublic";
				string szPublishPublicPath;
				string szPublishPrivatePath;

				string szRequireSSL = Config.GetString( sslRequiredKey, "0" ); 
				if ( szRequireSSL.Equals( "1" ) )
				{
					szPublishPrivatePath = "https://" + hostInfo.HostName + "/uddi";
					szPublishPublicPath = "https://" + hostInfo.HostName + "/uddipublic";
				}
				else
				{
					szPublishPrivatePath = "http://" + hostInfo.HostName + "/uddi";
					szPublishPublicPath = "http://" + hostInfo.HostName + "/uddipublic";
				}

				string szServiceName = Localization.GetString( "WEBCA_UDDI_SERVICE_NAME" );
				string szServiceDesc = Localization.GetString( "WEBCA_UDDI_DESC_SERVICE" );
				string szPublishAPIDesc = Localization.GetString( "WEBCA_UDDI_DESC_PUBGENERIC" );
				string szPublishAPIDesc_V1 = Localization.GetString( "WEBCA_UDDI_DESC_PUBVER1" );
				string szPublishAPIDesc_V2 = Localization.GetString( "WEBCA_UDDI_DESC_PUBVER2" );
				string szInquiryAPIDesc = Localization.GetString( "WEBCA_UDDI_DESC_INQUIRYGENERIC" );
				string szInquiryAPIDesc_V1 = Localization.GetString( "WEBCA_UDDI_DESC_INQUIRYV1" );
				string szInquiryAPIDesc_V2 = Localization.GetString( "WEBCA_UDDI_DESC_INQUIRYV2" );				
				string szOrgHttpDesc = Localization.GetString( "WEBCA_UDDI_DESC_HTTP" );
				string szOrgHomepageDesc = Localization.GetString( "WEBCA_UDDI_DESC_HOMEPAGE" );
				string szWinAuthDesc = Localization.GetString( "WEBCA_UDDI_DESC_WINAUTH" );
				string szAnonAuthDesc = Localization.GetString( "WEBCA_UDDI_DESC_ANONAUTH" );
				string szUDDIAuthDesc = Localization.GetString( "WEBCA_UDDI_DESC_UDDIAUTH" );
				string szAddRefDesc = Localization.GetString( "WEBCA_UDDI_DESC_ADDREF" );
				string szExtensionsDesc = Localization.GetString( "WEBCA_UDDI_DESC_MSCOM_EXT" );
				string szExtensionsDesc_V2 = Localization.GetString( "WEBCA_UDDI_DESC_MSCOM_EXTV2" );

				//
				// Now let's update the services
				//
				int itemPos = 0;
				UDDI.API.Service.BusinessService defService = new UDDI.API.Service.BusinessService();
				defService.BusinessKey = key;
				defService.Names.Add( szServiceName );
				defService.Descriptions.Add( szServiceDesc );
 
				//
				// publish API, Windows authentication
				//
				BindingTemplate	bindPublish = new BindingTemplate();
				bindPublish.AccessPoint.Value = szPublishPrivatePath + "/publish.asmx";
				bindPublish.Descriptions.Add( szPublishAPIDesc );

				itemPos = bindPublish.TModelInstanceInfos.Add( tmodelUddiOrgPub, "", "" );
				bindPublish.TModelInstanceInfos[ itemPos ].Descriptions.Add( szPublishAPIDesc_V1 );

				itemPos = bindPublish.TModelInstanceInfos.Add( tmodelUddiOrgPubV2, "", "" );
				bindPublish.TModelInstanceInfos[ itemPos ].Descriptions.Add( szPublishAPIDesc_V2 );

				itemPos = bindPublish.TModelInstanceInfos.Add( tmodelUddiOrgHttp, "", "" );
				bindPublish.TModelInstanceInfos[ itemPos ].Descriptions.Add( szOrgHttpDesc );

				itemPos = bindPublish.TModelInstanceInfos.Add( tmodelWinAuthMode, "", "" );
				bindPublish.TModelInstanceInfos[ itemPos ].Descriptions.Add( szWinAuthDesc );

				defService.BindingTemplates.Add( bindPublish );

				//
				// AddWebRef API, Windows authentication
				//
				BindingTemplate	bindAddWebRef = new BindingTemplate();
				bindAddWebRef.Descriptions.Add( szAddRefDesc );
				bindAddWebRef.AccessPoint.Value = szUDDIPrivatePath + "/addwebreference";
				
				itemPos = bindAddWebRef.TModelInstanceInfos.Add( tmodelUddiOrgHttp, "", "" );
				bindAddWebRef.TModelInstanceInfos[ itemPos ].Descriptions.Add( szOrgHttpDesc );

				itemPos = bindAddWebRef.TModelInstanceInfos.Add( tmodelWinAuthMode, "", "" );
				bindAddWebRef.TModelInstanceInfos[ itemPos ].Descriptions.Add( szWinAuthDesc );

				itemPos = bindAddWebRef.TModelInstanceInfos.Add( tmodelMSComAddWebRef, "", "" );
				bindAddWebRef.TModelInstanceInfos[ itemPos ].Descriptions.Add( szAddRefDesc );

				defService.BindingTemplates.Add( bindAddWebRef );

				//
				// UI public (R/O) API, Anonymous authentication
				//
				BindingTemplate	bindUIRO = new BindingTemplate();
				bindUIRO.AccessPoint.Value = szUDDIPublicPath;
				bindUIRO.Descriptions.Add( szOrgHomepageDesc );

				itemPos = bindUIRO.TModelInstanceInfos.Add( tmodelUddiOrgHttp, "", "" );
				bindUIRO.TModelInstanceInfos[ itemPos ].Descriptions.Add( szOrgHttpDesc );

				itemPos = bindUIRO.TModelInstanceInfos.Add( tmodelUddiOrgHomepage, "", "" );
				bindUIRO.TModelInstanceInfos[ itemPos ].Descriptions.Add( szOrgHomepageDesc );

				itemPos = bindUIRO.TModelInstanceInfos.Add( tmodelAnonAuthMode, "", "" );
				bindUIRO.TModelInstanceInfos[ itemPos ].Descriptions.Add( szAnonAuthDesc );

				defService.BindingTemplates.Add( bindUIRO );

				//
				// UI private API, Windows authentication
				//
				BindingTemplate	bindUI = new BindingTemplate();
				bindUI.AccessPoint.Value = szUDDIPrivatePath;
				bindUI.Descriptions.Add( szOrgHomepageDesc );

				itemPos = bindUI.TModelInstanceInfos.Add( tmodelUddiOrgHttp, "", "" );
				bindUI.TModelInstanceInfos[ itemPos ].Descriptions.Add( szOrgHttpDesc );

				itemPos = bindUI.TModelInstanceInfos.Add( tmodelUddiOrgHomepage, "", "" );
				bindUI.TModelInstanceInfos[ itemPos ].Descriptions.Add( szOrgHomepageDesc );

				itemPos = bindUI.TModelInstanceInfos.Add( tmodelWinAuthMode, "", "" );
				bindUI.TModelInstanceInfos[ itemPos ].Descriptions.Add( szWinAuthDesc );

				defService.BindingTemplates.Add( bindUI );

				//
				// publish API, UDDI authentication
				//
				BindingTemplate	bindPublishUDDI = new BindingTemplate();
				bindPublishUDDI.AccessPoint.Value = szPublishPublicPath + "/publish.asmx";
				bindPublishUDDI.Descriptions.Add( szPublishAPIDesc );

				itemPos = bindPublishUDDI.TModelInstanceInfos.Add( tmodelUddiOrgPub, "", "" );
				bindPublishUDDI.TModelInstanceInfos[ itemPos ].Descriptions.Add( szPublishAPIDesc_V1 );

				itemPos = bindPublishUDDI.TModelInstanceInfos.Add( tmodelUddiOrgPubV2, "", "" );
				bindPublishUDDI.TModelInstanceInfos[ itemPos ].Descriptions.Add( szPublishAPIDesc_V2 );

				itemPos = bindPublishUDDI.TModelInstanceInfos.Add( tmodelUddiOrgHttp, "", "" );
				bindPublishUDDI.TModelInstanceInfos[ itemPos ].Descriptions.Add( szOrgHttpDesc );

				itemPos = bindPublishUDDI.TModelInstanceInfos.Add( tmodelUDDIAuthMode, "", "" );
				bindPublishUDDI.TModelInstanceInfos[ itemPos ].Descriptions.Add( szUDDIAuthDesc );

				defService.BindingTemplates.Add( bindPublishUDDI );

				//
				// inquiry API, Windows authentication
				//
				BindingTemplate	bindInq = new BindingTemplate();
				bindInq.AccessPoint.Value = szUDDIPrivatePath + "/inquire.asmx";
				bindInq.Descriptions.Add( szInquiryAPIDesc );

				itemPos = bindInq.TModelInstanceInfos.Add( tmodelWinAuthMode, "", "" );
				bindInq.TModelInstanceInfos[ itemPos ].Descriptions.Add( szWinAuthDesc );

				itemPos = bindInq.TModelInstanceInfos.Add( tmodelUddiOrgHttp, "", "" );
				bindInq.TModelInstanceInfos[ itemPos ].Descriptions.Add( szOrgHttpDesc );

				itemPos = bindInq.TModelInstanceInfos.Add( tmodelUddiOrgInquiry, "", "" );
				bindInq.TModelInstanceInfos[ itemPos ].Descriptions.Add( szInquiryAPIDesc_V1 );

				itemPos = bindInq.TModelInstanceInfos.Add( tmodelUddiOrgInquiryV2, "", "" );
				bindInq.TModelInstanceInfos[ itemPos ].Descriptions.Add( szInquiryAPIDesc_V2 );

				defService.BindingTemplates.Add( bindInq );

				//
				// inquiry API, Anonymous authentication
				//
				BindingTemplate	bindInqPub = new BindingTemplate();
				bindInqPub.AccessPoint.Value = szUDDIPublicPath + "/inquire.asmx";
				bindInqPub.Descriptions.Add( szInquiryAPIDesc );

				itemPos = bindInqPub.TModelInstanceInfos.Add( tmodelAnonAuthMode, "", "" );
				bindInqPub.TModelInstanceInfos[ itemPos ].Descriptions.Add( szAnonAuthDesc );

				itemPos = bindInqPub.TModelInstanceInfos.Add( tmodelUddiOrgHttp, "", "" );
				bindInqPub.TModelInstanceInfos[ itemPos ].Descriptions.Add( szOrgHttpDesc );

				itemPos = bindInqPub.TModelInstanceInfos.Add( tmodelUddiOrgInquiry, "", "" );
				bindInqPub.TModelInstanceInfos[ itemPos ].Descriptions.Add( szInquiryAPIDesc_V1 );

				itemPos = bindInqPub.TModelInstanceInfos.Add( tmodelUddiOrgInquiryV2, "", "" );
				bindInqPub.TModelInstanceInfos[ itemPos ].Descriptions.Add( szInquiryAPIDesc_V2 );

				defService.BindingTemplates.Add( bindInqPub );

				//
				// categorization API (V2 Ext), UDDI authentication
				//
				BindingTemplate	categoryPub = new BindingTemplate();
				categoryPub.AccessPoint.Value = szUDDIPublicPath + "/extension.asmx"; // #1509 - rename category.asmx to extension.asmx
				categoryPub.Descriptions.Add( szExtensionsDesc );

				itemPos = categoryPub.TModelInstanceInfos.Add( tmodelUddiOrgHttp, "", "" );
				categoryPub.TModelInstanceInfos[ itemPos ].Descriptions.Add( szOrgHttpDesc );

				itemPos = categoryPub.TModelInstanceInfos.Add( tmodelUDDIAuthMode, "", "" );
				categoryPub.TModelInstanceInfos[ itemPos ].Descriptions.Add( szUDDIAuthDesc );

				itemPos = categoryPub.TModelInstanceInfos.Add( tmodelMSComUddiExtV2, "", "" );
				categoryPub.TModelInstanceInfos[ itemPos ].Descriptions.Add( szUDDIAuthDesc );

				defService.BindingTemplates.Add( categoryPub );

				//
				// categorization API (V2 Ext), Windows authentication
				//
				BindingTemplate	categoryWin = new BindingTemplate();
				categoryWin.AccessPoint.Value = szUDDIPrivatePath + "/extension.asmx"; // #1509 - rename category.asmx to extension.asmx
				categoryWin.Descriptions.Add( szExtensionsDesc );

				itemPos = categoryWin.TModelInstanceInfos.Add( tmodelUddiOrgHttp, "", "" );
				categoryWin.TModelInstanceInfos[ itemPos ].Descriptions.Add( szOrgHttpDesc );

				itemPos = categoryWin.TModelInstanceInfos.Add( tmodelWinAuthMode, "", "" );
				categoryWin.TModelInstanceInfos[ itemPos ].Descriptions.Add( szWinAuthDesc );

				itemPos = categoryWin.TModelInstanceInfos.Add( tmodelMSComUddiExtV2, "", "" );
				categoryWin.TModelInstanceInfos[ itemPos ].Descriptions.Add( szExtensionsDesc_V2 );

				defService.BindingTemplates.Add( categoryWin );

				//----------------------------------------
				// now save the service
				//
				defService.Save();

				//
				// Commit pending DB changes
				//
				ConnectionManager.Commit();
			}
			catch ( Exception e )
			{
				ConnectionManager.Abort();
				LogException( "AddDefaultServices", e );
				Log( string.Format( "Failed to create the default service bindings. Reason: {0}", e.Message ) );
				throw e;
			}
			finally
			{
				ConnectionManager.Close();
				Leave();
			}
		}


		protected void PublishToActiveDirectory( bool bOverwrite )
		{
			Enter();
			try
			{
				ConnectionManager.Open( false, false );

				UDDI.Context.User.SetRole( new WindowsPrincipal( WindowsIdentity.GetCurrent() ) );
				UDDI.Context.User.ID = UDDI.Utility.GetDefaultPublisher();

				// 
				// now retrieve the config options (site key etc.)
				//
				string key = UDDI.Config.GetString( busEntityKeyName, "*" );
				if ( key.Equals( "*" ) )	// there is no business entity key in the config
					throw new Exception( "Missing value: " + busEntityKeyName ); 


				// 
				// grab the business entity and all the related parts
				//
				BusinessEntity busEntity = new BusinessEntity( key );
				busEntity.Get();

				//
				// now get the entity name
				//
				string entityName = key;  // in case we can't retrieve the name
				try
				{
					entityName = busEntity.Names[ 0 ].Value;
				}
				catch (Exception)
				{
				}

				// 
				// now load the strings we need to have handy while creating the service
				// entries.
				// Note that we use the "main" resource from uddi.resources rather than
				// the "local" project-level one
				//
				string szInqClassDispName	= Localization.GetString( "WEBCA_ADTAG_UDDI_INQUIRE" );
				string szPubClassDispName	= Localization.GetString( "WEBCA_ADTAG_UDDI_PUBLISH" );
				string szWebClassDispName	= Localization.GetString( "WEBCA_ADTAG_UDDI_WEBSITE" );
				string szDiscoClassDispName	= Localization.GetString( "WEBCA_ADTAG_UDDI_DISCOVERY" );
				string szAddRefClassDispName= Localization.GetString( "WEBCA_ADTAG_UDDI_ADDWEBREF" );

				string szInqClassDesc	= String.Format( Localization.GetString( "WEBCA_ADTAG_UDDI_INQUIREDESC" ), entityName );
				string szPubClassDesc	= String.Format( Localization.GetString( "WEBCA_ADTAG_UDDI_PUBLISHDESC" ), entityName );
				string szWebClassDesc	= String.Format( Localization.GetString( "WEBCA_ADTAG_UDDI_WEBSITEDESC" ), entityName );
				string szDiscoClassDesc	= String.Format( Localization.GetString( "WEBCA_ADTAG_UDDI_DISCOVERYDESC" ), entityName );
				string szAddRefClassDesc= String.Format( Localization.GetString( "WEBCA_ADTAG_UDDI_ADDWEBREFDESC" ), entityName );

				string szWinAuthDescMask	= Localization.GetString( "WEBCA_ADTAG_UDDI_AUTHWIN_DESC" );
				string szUDDIAuthDescMask	= Localization.GetString( "WEBCA_ADTAG_UDDI_AUTHUDDI_DESC" );
				string szAnonAuthDescMask	= Localization.GetString( "WEBCA_ADTAG_UDDI_AUTHANON_DESC" );

				//
				// wipe out the existing entry if needed
				//
				if ( bOverwrite )
					UDDIServiceConnPoint.ResetSiteEntry( key );
				else 
					UDDIServiceConnPoint.CreateSiteEntry( key );
				
				//
				// then take care of the DiscoveryURL's
				//
				foreach ( DiscoveryUrl url in busEntity.DiscoveryUrls )
				{
					string tmpKey = Guid.NewGuid().ToString();
					string tmpUrl = url.Value;

					UDDIServiceConnPoint.CreateEntryPoint( key, tmpKey, tmpUrl,
						pubDiscoClassName, szDiscoClassDispName,
						szDiscoClassDesc, 
						kwdDiscoveryUrl, kwdDiscoveryUrlID );
				}

				//
				// now we can iterate through the list of services
				// and publish them
				//
				BusinessService[] services = busEntity.BusinessServices.ToArray();
				foreach (BusinessService svc in services)
				{
					string svcKey = svc.ServiceKey;
					BindingTemplate[] templates = svc.BindingTemplates.ToArray();
					
					foreach (BindingTemplate busTemplate in templates)
					{
						string	accPoint = busTemplate.AccessPoint.Value;
						string  bindingKey = busTemplate.BindingKey;
						string	svcClass = "";		
						string	svcDispName = "";	
						string	svcDesc	= "";	
						string  svcDescMask = "";

						bool	bWinAuth = false;
						bool	bUDDIAuth = false;
						bool	bAnonAuth = false;
						bool	bInquiry	= false;
						bool	bPublish = false;
						bool	bWebSite = false;
						bool	bAddRef = false;
						ArrayList tmpKwds = new ArrayList();			

						// 
						// now let's go through the TModel list and figure out what
						// service is this
						//
						foreach (TModelInstanceInfo tmdInfo in busTemplate.TModelInstanceInfos)
						{
							string szTemp = tmdInfo.TModelKey;
							
							//
							// checking the authentication mode and service type
							//
							if ( String.Compare( szTemp, tmodelWinAuthMode, true ) == 0 )
							{
								bWinAuth = true;
								tmpKwds.Add( kwdWinAuthMode );
								tmpKwds.Add( kwdWinAuthModeUuid );
								svcDescMask = szWinAuthDescMask;
							}
							else if ( String.Compare( szTemp, tmodelUDDIAuthMode, true ) == 0 )
							{
								bUDDIAuth = true;
								tmpKwds.Add( kwdUDDIAuthMode );
								tmpKwds.Add( kwdUDDIAuthModeUuid );
								svcDescMask = szUDDIAuthDescMask;
							}
							else if ( String.Compare( szTemp, tmodelAnonAuthMode, true ) == 0 )
							{
								bAnonAuth = true;
								tmpKwds.Add( kwdAnonAuthMode );
								tmpKwds.Add( kwdAnonAuthModeUuid );
								svcDescMask = szAnonAuthDescMask;
							}
							else if ( String.Compare( szTemp, tmodelUddiOrgPub, true ) == 0 || 
									  String.Compare( szTemp, tmodelUddiOrgPubV2, true ) == 0    )
							{
								if ( !bPublish )
								{
									bPublish = true;
									tmpKwds.Add( kwdPublishService );
									tmpKwds.Add( kwdPublishServiceID );

									svcClass = pubPubClassName;
									svcDispName = szPubClassDispName;
									svcDesc = szPubClassDesc; 
								}
							}
							else if ( String.Compare( szTemp, tmodelUddiOrgInquiry, true ) == 0 || 
									  String.Compare( szTemp, tmodelUddiOrgInquiryV2, true ) == 0    )
							{
								if ( !bInquiry )
								{
									bInquiry = true;
									tmpKwds.Add( kwdInquiryService );
									tmpKwds.Add( kwdInquiryServiceID );

									svcClass = pubInqClassName;
									svcDispName = szInqClassDispName;
									svcDesc = szInqClassDesc; 
								}
							}
							else if ( String.Compare( szTemp, tmodelMSComAddWebRef, true ) == 0 )
							{
								bAddRef = true;
								tmpKwds.Add( kwdAddWebRefServiceID );
								tmpKwds.Add( kwdAddWebRefService );

								svcClass = pubAddRefClassName;
								svcDispName = szAddRefClassDispName;
								svcDesc = szAddRefClassDesc; 
							}
							else if ( String.Compare( szTemp, tmodelUddiOrgHomepage, true ) == 0 )
							{
								bWebSite = true;
								tmpKwds.Add( kwdWebSiteService );
								tmpKwds.Add( kwdWebSiteServiceID );

								svcClass = pubWebClassName;
								svcDispName = szWebClassDispName;
								svcDesc = szWebClassDesc; 
							}
						}

						//
						// first, a quick sanity check. If more than one authmode is set, or
						// if there is no authmode at all, then we should skip the entry as invalid
						//
						if ( !( bWinAuth | bUDDIAuth | bAnonAuth ) || !( bWinAuth ^ bUDDIAuth ^ bAnonAuth ) )
							continue;

						//
						// now same thing with the service types
						//
						if ( !( bPublish | bInquiry | bAddRef | bWebSite ) || !( bPublish ^ bInquiry ^ bAddRef ^ bWebSite ) )
							continue;
						
						// 
						// now we are ready to create the AD entry
						//
						if ( svcDescMask.Length > 0 )
							svcDesc = String.Format( svcDescMask, svcDesc );

						UDDIServiceConnPoint.CreateEntryPoint( key, bindingKey, accPoint,
															   svcClass, svcDispName,
															   svcDesc, tmpKwds.ToArray() );
					}
				}
			}
			catch (Exception e)
			{
				LogException( string.Format( "Exception occured during web install: {0}", e.Message ), e );
			}
			finally
			{
				ConnectionManager.Close();
				Leave();
			}
		}


		//
		// Here we attempt to format the Discovery URL. If bForceUpdate is set to true
		// then the URL gets updated unconditionally. 
		// Otherwise, we update the URL only and if only we are the first web site
		// installation that connectes to that database (in which case the DiscoveryURL
		// will point to localhost)
		//
		protected void UpdateDiscoveryUrl( bool bForceUpdate )
		{
			Enter(); 

			try
			{
				IPHostEntry hostInfo  = Dns.GetHostByName( Dns.GetHostName() );
				string defaultDiscoveryUrl = "http://" + hostInfo.HostName + "/uddipublic/discovery.ashx?businessKey=";

				ConnectionManager.Open( true, true );
				UDDI.Context.User.SetRole( new WindowsPrincipal( WindowsIdentity.GetCurrent() ) );

				bool bUpdate = bForceUpdate;
				if ( !bUpdate )
				{
					// 
					// now retrieve the Default URL from config options 
					//
					string url = UDDI.Config.GetString( "DefaultDiscoveryURL", "*" );
					if ( url.Equals( "*" ) )	// there is no business entity key in the config
						bUpdate = true;
					else
					{
						if ( url.ToLower().IndexOf( "localhost" ) > 0 )
							bUpdate = true;
					}
				}

				//
				// Now we know whether the Discovery URL should be updated or not
				//
				if ( bUpdate )
				{
					UDDI.Config.SetString( "DefaultDiscoveryURL", defaultDiscoveryUrl );
					UDDI.Config.Refresh();
					ConnectionManager.Commit();
				}
			}
			catch( Exception e )
			{
				//
				// this method will throw if the database has not yet been created,
				// so do not rethrow this error!
				//
				ConnectionManager.Abort();
				LogException( "Error in DefaultDiscoveryURL() in web installer", e );
			}
			finally
			{
				ConnectionManager.Close();
				Leave();
			}
		}



		public void SetStartType( string svcName, ServiceStartMode startType )
		{
			Enter();

			try
			{
				//
				// open the registry entry for the service
				//
				RegistryKey	HKLM = Registry.LocalMachine;
				RegistryKey svcKey = HKLM.OpenSubKey( "SYSTEM\\CurrentControlSet\\Services\\" + svcName, true );

				//
				// now set the start type
				//
				switch( startType )
				{
					case ServiceStartMode.Automatic:
						svcKey.SetValue ( "Start", 2 );
						break;

					case ServiceStartMode.Manual:
						svcKey.SetValue ( "Start", 3 );
						break;

					case ServiceStartMode.Disabled:
						svcKey.SetValue ( "Start", 4 );
						break;
				}

				svcKey.Close();
				HKLM.Close();
			}
			catch( Exception e )
			{
				throw new InstallException( LogException( string.Format( "Unable to set the start type for the service: {0}", svcName ), e ) );
			}
			finally 
			{
				Leave();
			}
		}


		public void StartService ( string svcName, int timeoutSec )
		{
			Enter();
			
			try
			{
				ServiceController		controller;
				ServiceControllerStatus srvStatus;
				TimeSpan				timeout = new TimeSpan ( 0, 0, timeoutSec );  

				//
				// first, connect to the SCM on the local box
				// and attach to the service, then get its status
				//
				controller = new ServiceController ( svcName );
				srvStatus = controller.Status;
				
				//
				// what is the service state?
				//
				switch ( srvStatus)
				{
						//
						// stopped ?
						//
					case ServiceControllerStatus.Stopped:
						controller.Start();
						break;

						//
						// are we trying to start?
						//
					case ServiceControllerStatus.StartPending:
					case ServiceControllerStatus.ContinuePending:
						break;

						//
						// are we trying to stop?
						//
					case ServiceControllerStatus.StopPending:
						controller.WaitForStatus( ServiceControllerStatus.Stopped, timeout );
						controller.Start();
						break;

						//
						// pausing ?
						//
					case ServiceControllerStatus.PausePending:
						controller.WaitForStatus ( ServiceControllerStatus.Paused, timeout );
						controller.Continue();
						break;
					
					default: // the service is already running. Just leave it alone
						break;
				}

				//
				// wait 'till the service wakes up
				//
				controller.WaitForStatus ( ServiceControllerStatus.Running, timeout );
			}
			catch( Exception e )
			{
				Log( e.Source );
				throw new InstallException( LogException( string.Format( "Unable to start the service: {0}", svcName ), e ) );
			}
			finally
			{
				Leave();
			}
		}

		protected void RegisterWebServer()
		{
			//
			// Get the value for Site.WebServers
			//
			string webServerList = Config.GetString( "Site.WebServers" );
			
			//
			// Add ourselves to it
			//				
			if( webServerList.Length > 0)
			{
				webServerList += "%";
			}
			webServerList += System.Environment.MachineName;

			//
			// Store the setting
			//
			Config.SetString( "Site.WebServers", webServerList );
		}

		protected void UnRegisterWebServer()
		{
			//
			// Get the value for Site.WebServers
			//
			string webServerList = Config.GetString( "Site.WebServers" );
			
			//
			// Remove ourselves to it
			//		
			string machineName = System.Environment.MachineName;
			StringBuilder newWebServerList = new StringBuilder();
			string[] webServers = webServerList.Split(new char[]{'%'});
			
			for( int i = 0; i < webServers.Length; i++ )
			{
				if( false == webServers[i].Equals( machineName ) )
				{
					if( i > 0 && i < webServers.Length - 1 )
					{
						newWebServerList.Append( '%' );
					}
					newWebServerList.Append( webServers[i] );
				}
			}
				
			//
			// Store the setting
			//
			Config.SetString( "Site.WebServers", newWebServerList.ToString() );
		}

		protected SqlDataReader ExecuteSql( SqlCommand cmd, bool nonQuery )
		{
			Enter();

			string connectionString = "";
			SqlDataReader reader = null;

			try
			{
				//
				// get the connection string and connect to the db
				//
				connectionString	= ( string ) Registry.LocalMachine.OpenSubKey( "SOFTWARE\\Microsoft\\UDDI\\Database" ).GetValue( "WriterConnectionString" );
				SqlConnection conn	= new SqlConnection( connectionString );
						
				try
				{
					conn.Open();
				}
				catch( Exception e )
				{
					Log( string.Format( "SQL Server raised an exception in {0}. Connection string used: '{1}'", "Createlogin()", connectionString ) );
					LogException( "conn.Open() failed", e );
					throw e;
				}
					
				try	
				{
					if( true == nonQuery )
					{						
						cmd.ExecuteNonQuery();
					}
					else
					{
						reader = cmd.ExecuteReader();
					}
				}
				catch( Exception e )
				{
					Log( string.Format( "SQL Server raised an exception in {0}. Connection string used: '{1}'", "Createlogin()", connectionString ) );
					LogException( cmd.CommandText, e );

					throw new InstallException( LogException( string.Format( "Error while executing the stored procedure '{0}': {1}", cmd.CommandText, e.Message ), e ) );
				}
				finally
				{
					conn.Close();
				}
			}
			catch( Exception e )
			{
				Log( string.Format( "SQL Server raised an exception in {0}. Connection string used: '{1}'", "Createlogin()", connectionString ) );

				throw new InstallException( LogException( string.Format( "Error while executing the stored procedure '{0}': {1}", cmd.CommandText, e.Message ), e ) );
			}
			finally
			{
				Leave();
			}			

			return reader;
		}

		protected void CreateLogin()
		{
			Enter();

			//
			// Create the user login and add the login to the Admin role
			//
			string connectionString = "";

			try
			{
				//
				// get the user name from the properties passed to this Custom Action
				//
				string userName = Context.Parameters[ "LCL_USER_NAME" ];
				if( 0 == userName.Length )
				{
					throw new InstallException(  "User name was not specified for the CreateLogin() function" ) ;
				}

				Log( "Windows Identity      = " + WindowsIdentity.GetCurrent().Name );
				Log( "Thread Identity       =  " + System.Threading.Thread.CurrentPrincipal.Identity.Name );
				Log( "Creating db login for = " + userName );

				//
				// get the connection string and connect to the db
				//
				connectionString = ( string ) Registry.LocalMachine.OpenSubKey( "SOFTWARE\\Microsoft\\UDDI\\Database" ).GetValue( "WriterConnectionString" );
				SqlConnection conn = new SqlConnection( connectionString );
				SqlCommand cmd = new SqlCommand( "ADM_addServiceAccount", conn );
			
				try
				{
					conn.Open();
				}
				catch( Exception e )
				{
					Log( string.Format( "SQL Server raised an exception in {0}. Connection string used: '{1}'", "Createlogin()", connectionString ) );
					LogException( "conn.Open() failed", e );
					throw e;
				}
					
				try	
				{
					cmd.CommandType = CommandType.StoredProcedure;
					cmd.Parameters.Add( new SqlParameter( "@accountName", SqlDbType.NVarChar, 128 ) ).Direction = ParameterDirection.Input;

					Log( "Creating login for username=" + userName );
					cmd.Parameters[ "@accountName" ].Value = userName;
					cmd.ExecuteNonQuery();

					//
					// We need to also give ourselves permission to access the extended stored procedures on the DB. Do this
					// in a separate try-catch so we can preserve the actual exception that is occuring.
					//
					try
					{					
						cmd.CommandType = CommandType.Text;
						cmd.CommandText = string.Format( addXPAccessSQL, userName );
						
						cmd.ExecuteNonQuery();
					}
					catch( Exception innerException )
					{
						Log( string.Format( "SQL Server raised an exception in {0}. Connection string used: '{1}'", "Createlogin()", connectionString ) );
						LogException( "ADM_addServiceAccount", innerException );

						throw new InstallException( LogException( string.Format( "Error while requesting execute permissions on UDDI Services extended stored procedures: {0}", innerException.Message ), innerException ) );
					}
				}
				catch (InstallException installException )
				{
					//
					// If we got an inner exception, just re-throw it.
					//
					throw installException;
				}
				catch( Exception e )
				{
					Log( string.Format( "SQL Server raised an exception in {0}. Connection string used: '{1}'", "Createlogin()", connectionString ) );
					LogException( "ADM_addServiceAccount", e );
					throw new InstallException( LogException( string.Format( "Error while executing the stored procedure '{0}': {1}", "ADM_addServiceAccount", e.Message ), e ) );
				}
				finally
				{
					conn.Close();
				}
			}
			catch( Exception e )
			{
				Log( string.Format( "SQL Server raised an exception in {0}. Connection string used: '{1}'", "Createlogin()", connectionString ) );
				throw new InstallException( LogException( string.Format( "Error while executing the stored procedure '{0}': {1}", "ADM_addServiceAccount", e.Message ), e ) );
			}
			finally
			{
				Leave();
			}
		}



		public void DeleteCounters()
		{
			Enter();

			try
			{
				PerformanceCounterCategory.Delete( "UDDI.API.Times" );
				PerformanceCounterCategory.Delete( "UDDI.API.Counts" );
			}
			catch
			{
				// don't care if it fails
			}
			finally
			{
				Leave();
			}
		}

		public void InitializeCounters()
		{
			Enter();

			try
			{				
				Performance.InitializeCounters();				
			}
			finally
			{
				Leave();
			}
		}

		private void Enter()
		{
			System.Diagnostics.StackTrace trace = new System.Diagnostics.StackTrace( 1, false );
			System.Reflection.MethodBase method = trace.GetFrame( 0 ).GetMethod();

			Log( "Entering " + method.ReflectedType.FullName + "." + method.Name + "..." );
		}

		private void Leave()
		{
			System.Diagnostics.StackTrace trace = new System.Diagnostics.StackTrace( 1, false );
			System.Reflection.MethodBase method = trace.GetFrame( 0 ).GetMethod();

			Log( "Leaving " + method.ReflectedType.FullName + "." + method.Name );
		}

		protected string CheckForSlash( string str )
		{
			if( !str.EndsWith( @"\" ) )
			{
				return ( str + @"\" );
			}

			return str;
		}

		private string LogError( string errmsg )
		{
			System.Diagnostics.StackTrace trace = new System.Diagnostics.StackTrace( 1, false );
			System.Reflection.MethodBase method = trace.GetFrame( 0 ).GetMethod();

			Log( "----------------------------------------------------------" );
			Log( "An error occurred during installation. Details follow:" );
			Log( "Method: " + method.ReflectedType.FullName + "." + method.Name );
			Log( "Message: " + errmsg );
			Log( "----------------------------------------------------------" );

			return errmsg;
		}

		private string LogException( string context, Exception e )
		{
			System.Diagnostics.StackTrace trace = new System.Diagnostics.StackTrace( 1, false );
			System.Reflection.MethodBase method = trace.GetFrame( 0 ).GetMethod();

			Log( "----------------------------------------------------------" );
			Log( "An exception occurred during installation. Details follow:" );
			Log( "Method: " + method.ReflectedType.FullName + "." + method.Name );
			Log( "Context: " + context );
			Log( "Stack Trace: " + e.StackTrace );
			Log( "Source: " + e.Source );
			Log( "Message: " + e.Message );
			Log( "----------------------------------------------------------" );

			return context + ": " + e.Message;
		}

		private void Log( string str )
		{
			try
			{
				System.Diagnostics.Debug.WriteLine( str );

				FileStream f = new FileStream( System.Environment.ExpandEnvironmentVariables( "%systemroot%" ) + @"\uddisetup.log", FileMode.Append, FileAccess.Write );
				StreamWriter s = new StreamWriter( f, System.Text.Encoding.Unicode );
				s.WriteLine( "{0}: {1}", DateTime.Now.ToString(), str );
				s.Close();
				f.Close();
			}
			catch( Exception e )
			{
				System.Diagnostics.Debug.WriteLine( "Error in Log():" + e.Message );
			}
		}
		
		private string GetPathToHelp( string installDir )
		{
			//
			// The value 'default' must match the value in the MSI.
			//
			return string.Format( "{0}webroot/default", installDir );
		}
		
		private void RenameHelp( string installDir, bool install )
		{
			int lcid = 0;
			string cultureIDValue = Context.Parameters[ cultureID ];

			//
			// 'cultureIDValue is expected to contain a neutral culture.  ie,
			// 'en', or 'ko', or 'de'.  All but a few neutral cultures have
			// a default specific culture.  For example, the default specific
			// culture of 'en' is 'en-US'.
			//
			// Traditional & simplified Chinese (zh-CHT and zh-CHS respectively)
			// are examples of neutral cultures which have no default specific
			// culture!
			//
			// So what happens below is this:  First we try to lookup the default
			// specific culture for the neutral culture that we were given.  If that
			// fails (ie, if CreateSpecificCulture throws), we just get the lcid
			// of the neutral culture.
			//
			try
			{
				lcid = CultureInfo.CreateSpecificCulture( cultureIDValue ).LCID;
			}
			catch
			{
				CultureInfo ci = new CultureInfo( cultureIDValue );
				lcid = ci.LCID;
			}


			//
			// Build default paths to the main and add web reference help directories.
			//
			string defaultMainHelpPath = string.Format( @"{0}webroot\help\{1}",			   installDir, defaultHelpDir );
			string defaultAWRHelpPath  = string.Format( @"{0}webroot\addwebreference\{1}", installDir, defaultHelpDir );
			
			//
			// Build lang-specific paths to the main and add web reference help directories.
			//			
			string langMainHelpPath = string.Format( @"{0}webroot\help\{1}",			installDir, lcid );
			string langAWRHelpPath  = string.Format( @"{0}webroot\addwebreference\{1}", installDir, lcid );
			
			if( true == install )
			{
				//
				// If we are installing, then rename the default help directory to one that is language specific.  Delete
				// existing directories if we have to.
				//
				// FIX: UDDI#2443: catch any exceptions, don't pass error back if directories can't be deleted. added
				// LogException call to watch when this ever happens.
				//
				try
				{
					if( true == Directory.Exists( langMainHelpPath ) )
					{
						Directory.Delete( langMainHelpPath, true );
					}

					if( true == Directory.Exists( langAWRHelpPath ) )
					{
						Directory.Delete( langAWRHelpPath, true );
					}
				}
				catch( Exception e )
				{
					LogException( "Caught exception deleting lang-specific help directories.", e );
				}

				try
				{
					Directory.Move( defaultMainHelpPath, langMainHelpPath );
					Directory.Move( defaultAWRHelpPath,  langAWRHelpPath );
				}
				catch( Exception e )
				{
					LogException( "Caught exception moving default help directories to lang-specific directories.", e );
				}
			}
			else
			{
				//
				// If we are uninstalling, then rename the language specific help directory back to the default; this
				// will let MSI clean up these files.  Catch any exceptions, it's not a big deal if this directory can't
				// be moved.
				//
				// FIX: UDDI#2443: added LogException call to watch when this ever happens.
				//
				try
				{
					Directory.Move( langMainHelpPath, defaultMainHelpPath );
					Directory.Move( langAWRHelpPath,  defaultAWRHelpPath );
				}
				catch( Exception e )
				{
					LogException( "Caught exception moving lang-specific help directories to default.", e );
				}
			}
		}

		#region Component Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			components = new System.ComponentModel.Container();
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\tools\monitor\monitor.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using UDDI;
using UDDI.Replication;

namespace UDDI.Tools
{
	public class Monitor
	{
		public static int PollInterval = 5000;
		public static string Program = null;
		
		[STAThread]
		static void Main( string[] args )
		{
			Console.WriteLine( "Microsoft (R) UDDI Monitor Utility" );
			Console.WriteLine( "Copyright (C) Microsoft Corp. 2002. All rights reserved.\r\n" );
			
			try
			{
				ProcessCommandLine( args );

				ArrayList results = new ArrayList();
				
				ConnectionManager.Open( false, false );

				//
				// Get the list of known operatorNodes.
				//
				OperatorNodeCollection operatorNodes = new OperatorNodeCollection();
				operatorNodes.Get();

				//
				// Get the last notification message status for each operator.
				//
				foreach( OperatorNode operatorNode in operatorNodes )
				{
					ReplicationResult result = new ReplicationResult();

					result.GetLast( operatorNode.OperatorNodeID, true );

					results.Add( result );
				}

				//
				// Monitor changes to operator status every 5 seconds.
				//
				while( true )
				{
					Console.WriteLine( "Polling for new notifications: {0}.  Press Ctrl+C to stop.", DateTime.Now );

					for( int i = 0; i < operatorNodes.Count; i ++ )
					{
						ReplicationResult lastResult = (ReplicationResult)results[ i ];
						ReplicationResult result = new ReplicationResult();

						result.GetLast( operatorNodes[ i ].OperatorNodeID, true );
						
						//
						// Check to see if a notification message has been received
						//
						if( result.LastChange > lastResult.LastChange )
						{
							DateTime time = new DateTime( result.LastChange );

							Console.WriteLine( 
								"\r\n\tnotify_changeRecordsAvailable detected\r\n\t\tNode: {0}\r\n\t\tTime: {1}",
								result.OperatorNodeID,
								time );

							//
							// Execute the specified file.
							//
							Console.WriteLine( 
								"\t\tStarting: {0} -o {1}",
								Program,
								result.OperatorNodeID );
							
							Process process = Process.Start( Program, "-o " + result.OperatorNodeID );

							process.WaitForExit();

							Console.WriteLine( 
								"\t\tReturn code: {0}\r\n",
								process.ExitCode );
							
							//
							// Save the current notify result so that we don't
							// reprocess.
							//
							results[ i ] = result;
						}
					}
				
					System.Threading.Thread.Sleep( PollInterval );
				}
			}
			catch( CommandLineException e )
			{
				if( null != e.Message && e.Message.Length > 0 )
				{
					Console.WriteLine( e.Message );
					Console.WriteLine();
				}
				else
				{
					DisplayUsage();
				}
			}
			catch( Exception e )
			{
				Console.WriteLine( "Exception: {0}", e.ToString() );
			}
			finally
			{
				ConnectionManager.Close();
			}
			
			return;
		}

		public static void DisplayUsage()
		{
			Console.WriteLine( "Starts the specified program whenever a notify_changeRecordsAvailable\r\nmessage is received." );
			Console.WriteLine( "\r\nUsage:" );
			Console.WriteLine( "\tmonitor.exe [switches] <program>" );
			Console.WriteLine( "\r\nSwitches:" );
			Console.WriteLine( "\t-i <interval>  Sets the poll interval (in milliseconds).  The" );
			Console.WriteLine( "\t               default is 5000." );
			Console.WriteLine( "\r\nExamples:" );
			Console.WriteLine( "\tmonitor.exe c:\\bin\\retrieve.exe" );
			Console.WriteLine( "\tmonitor.exe -t 10000 c:\\bin\\retrieve.exe" );
		}

		internal static void ProcessCommandLine( string[] args )
		{
			int i = 0;

			if( 0 == args.Length )
				throw new CommandLineException();

			while( i < args.Length )
			{
				if( "-" == args[ i ].Substring( 0, 1 ) || "/" == args[ i ].Substring( 0, 1 ) )
				{
					switch( args[ i ].Substring( 1 ).ToLower() )
					{
						case "i":
							if( i + 1 >= args.Length )
								throw new CommandLineException( "Missing required parameter 'interval'." );

							i ++;

							try
							{
								PollInterval = Convert.ToInt32( args[ i ] );
							}
							catch
							{
								throw new CommandLineException( "Parameter 'interval' must be numeric." );
							}

							break;

						case "?":
							throw new CommandLineException();

						default:
							throw new CommandLineException( "Invalid switch." );
					}
				}
				else
				{
					if( null == Program )
						Program = args[ i ];
					else
						throw new CommandLineException( "Too many command line parameters." );
				}

				i ++;
			}

			if( null == Program )
				throw new CommandLineException( "Missing required parameter 'Program'." );
		}
	}

	/// ****************************************************************
	///   public class CommandLineException
	/// ----------------------------------------------------------------
	///   <summary>
	///     Exception class for errors encountered while parsing the
	///     command-line.
	///   </summary>
	/// ****************************************************************
	/// 
	public class CommandLineException : ApplicationException
	{
		/// ************************************************************
		///   public CommandLineException [constructor]
		/// ------------------------------------------------------------
		///   <summary>
		///     CommandLineException constructor.
		///   </summary>
		/// ************************************************************
		/// 
		public CommandLineException()
			: base( "" )
		{
		}

		/// ************************************************************
		///   public CommandLineException [constructor]
		/// ------------------------------------------------------------
		///   <summary>
		///     CommandLineException constructor.
		///   </summary>
		/// ------------------------------------------------------------
		///   <param name="message">
		///     Exception message.
		///   </param>
		/// ************************************************************
		/// 
		public CommandLineException( string message )
			: base( message )
		{
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\tools\monitor\assemblyinfo.cs ===
using System.Reflection;
using System.Security.Permissions;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("monitor.exe")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft Corporation")]
[assembly: AssemblyProduct("UDDI Services")]
[assembly: AssemblyCopyright("Copyright(c) 2002 Microsoft Corporation")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]
[assembly: PermissionSetAttribute(SecurityAction.RequestMinimum, Name = "FullTrust")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("")]
[assembly: AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\tools\rcf\assemblyinfo.cs ===
using System.Reflection;
using System.Security.Permissions;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("rcf.exe")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft Corporation")]
[assembly: AssemblyProduct("UDDI Services")]
[assembly: AssemblyCopyright("Copyright(c) 2002 Microsoft Corporation")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]
[assembly: PermissionSetAttribute(SecurityAction.RequestMinimum, Name = "FullTrust")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("")]
[assembly: AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\tools\recalcstats\makefile.inc ===
foo.cs:
	..\..\version\$(O)\version.exe -outfile .\assemblyversioninfo.cs
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\tools\migrate\migrate.cs ===
using System;
using System.Diagnostics;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Xml.Serialization;

using Microsoft.Win32;

using UDDI.API;
using UDDI.API.ServiceType;
using UDDI.API.Business;
using UDDI.API.Service;
using UDDI.API.Binding;
using UDDI.API.Extensions;

namespace UDDI.Tools
{
	class Migrate
	{
		enum MigrationStage
		{
			DisplayUsage,
			SetReaderConnection,
			ResetWriter,
			MigratePublishers,
			MigrateBareTModels,
			BootstrapResources,
			MigrateCategorizationSchemes,
			MigrateFullTModels,
			MigrateHiddenTModels,
			MigrateBareBusinessEntities,
			MigrateBusinessEntities,
			MigratePublisherAssertions,
			RestoreReaderConnection
		}

		enum LogType
		{
			ConsoleAndLog,
			ConsoleOnly,
			LogOnly
		}

		//
		// Registry Constants
		//

		private const string DatabaseRoot = @"SOFTWARE\Microsoft\UDDI\Database";
		private const string DatabaseSetupRoot = @"SOFTWARE\Microsoft\UDDI\Setup\DBServer";
		private const string ReaderValueName = "ReaderConnectionString";
		private const string WriterValueName = "WriterConnectionString";
		private const string OldReaderValueName = "OldNewReaderConnectionString";

		//
		// Version Constants
		//

		private const string V2RC0SITESTR = "5.2.3626.0";
		private const string V2RC1SITESTR = "5.2.3663.0";
		private const string V2RC0STR = "2.0.1.0";
		private const string V2RC1STR = "2.0.1.1";
		private const string V2RC2STR = "2.0.1.2";
		private const string V2RTMSTR = "2.0.1.3";

		//
		// Upgrade contstants
		//

		private const string UpgradeRc0ToRc1Script = "uddi.v2.update_rc0_to_rc1.sql";
		private const string UpgradeRc1ToRc2Script = "uddi.v2.update_rc1_to_rc2.sql";

		//
		// Other Constants
		//

		private const string LogFileName = "migrate.log.txt";
		private const string ExceptionFileName = "migrate.exceptions.txt";
		private const string ExceptionDirName = "exceptions";
		private const string EmptyAccessPoint = "undefined"; // String to use when both accessPoint and hostingRedirector are null
		private const string EmptyPersonName = "unspecified"; // String to use when personName does not meet minumum length requriements

		//
		// Command Line Parameters
		//

		static MigrationStage Stage = MigrationStage.DisplayUsage;
		static string NewReaderConnectionString;
		static bool Verbose = false;

		//
		// Global Variables
		//

		static FileStream LogFile = new FileStream( LogFileName, FileMode.Append );
		static StreamWriter Stream = new StreamWriter( LogFile );

		static string ReaderConnectionString;
		static string WriterConnectionString;
		static string Separator="".PadLeft( 80, '-' );
		static int Exceptions = 0;

		static Version V2RC0SITE = new Version( V2RC0SITESTR );
		static Version V2RC1SITE = new Version( V2RC1SITESTR );
		static Version V2RC0 = new Version( V2RC0STR );
		static Version V2RC1 = new Version( V2RC1STR );
		static Version V2RC2 = new Version( V2RC2STR );
		static Version V2RTM = new Version( V2RTMSTR );

		[ StructLayout( LayoutKind.Sequential ) ]
			internal class SECURITY_ATTRIBUTES 
		{ 
			public int		nLength; 
			public object	lpSecurityDescriptor; 
			public bool		bInheritHandle; 
	
			public SECURITY_ATTRIBUTES()
			{
				nLength = Marshal.SizeOf( typeof( SECURITY_ATTRIBUTES ) );
				lpSecurityDescriptor = null;
				bInheritHandle = false;
			}
		} 

		internal enum SystemErrorCodes
		{
			ERROR_SUCCESS		 = 0,
			ERROR_ALREADY_EXISTS = 183
		}

		//
		// TODO add more values as we need them 
		//
		internal enum FileHandleValues
		{
			INVALID_HANDLE_VALUE = -1
		}

		//
		// TODO add more values as we need them 
		//
		internal enum SharedFileProtection : byte
		{
			PAGE_READONLY = 0x02
		}

		internal class SharedMemory
		{
			int				hSharedMemory;
			const	int		INVALID_HANDLE_VALUE = -1;
		
			public bool Create( string name )
			{
				hSharedMemory = -1;
				bool success  = false;

				try
				{
					SECURITY_ATTRIBUTES securityAttributes = new SECURITY_ATTRIBUTES();
	
					hSharedMemory = CreateFileMapping( ( int )FileHandleValues.INVALID_HANDLE_VALUE, 
						securityAttributes, 
						( int )SharedFileProtection.PAGE_READONLY, 
						0, 
						1, 
						name );									

					if( ( int )SystemErrorCodes.ERROR_SUCCESS == GetLastError() )
					{
						success = true;
					}
				}
				catch
				{
					if( -1 != hSharedMemory )
					{
						CloseHandle( hSharedMemory );
					}
				}	
		
				return success;
			}

			public void Release()
			{
				if( -1 != hSharedMemory )
				{
					CloseHandle( hSharedMemory );
				}
			}

			[DllImport( "user32.dll", CharSet=CharSet.Auto )]
			private static extern int MessageBox(int hWnd, String text, String caption, uint type);

			[DllImport( "kernel32.dll", SetLastError=true )]
			private static extern int CreateFileMapping( int						hFile, 
				SECURITY_ATTRIBUTES		lpAttributes,
				int						flProtect,
				int						dwMaximumSizeHigh,
				int						dwMaximumSizeLow,
				string					lpName );

			[DllImport( "kernel32.dll" )]
			private static extern bool CloseHandle( int hObject );

			[DllImport( "kernel32.dll" )]
			private static extern int GetLastError();
		}
			
		static int Main( string[] args )
		{
			int retcode = 0; 

			//
			// Use shared memory to make sure that only 1 instance of this process is running.  sharedMemory.Release() MUST
			// be called when this process exits in order to free up the shared memory.
			//
			SharedMemory sharedMemory = new SharedMemory();

			try
			{

				Log( "Microsoft (R) UDDI Migrate Utility", LogType.ConsoleOnly );
				Log( "Copyright (C) Microsoft Corp. 2002. All rights reserved.\n", LogType.ConsoleOnly );

				if( false == sharedMemory.Create( "UDDI_migration_process" ) )
				{
					Console.WriteLine( "Only 1 instance of this process can be running." );
					System.Environment.Exit( 1 );
				}

				//
				// parse command line
				//
				retcode = ProcessCommandLine( args );

				if( Stage == MigrationStage.DisplayUsage )
				{
					DisplayUsage();
				}
				else
				{

					Log( "Starting execution of migrate.exe", LogType.ConsoleAndLog );
				
					//
					// Get connection strings from registry
					//
					GetSettings();

					//
					// Refresh the config settings
					//
					Config.Refresh();

					switch( Stage )
					{
						case MigrationStage.SetReaderConnection:
							SetReaderConnection();
							break;

						case MigrationStage.ResetWriter:
							CheckDatabaseVersions();
							ResetWriter();
							break;
						
						case MigrationStage.MigratePublishers:
							CheckDatabaseVersions();
							MigratePublishers();
							break;

						case MigrationStage.MigrateBareTModels:
							CheckDatabaseVersions();
							MigrateBareTModels();
							break;

						case MigrationStage.BootstrapResources:
							CheckDatabaseVersions();
							BootstrapResources();
							break;

						case MigrationStage.MigrateCategorizationSchemes:
							CheckDatabaseVersions();
							MigrateCategorizationSchemes();
							break;

						case MigrationStage.MigrateFullTModels:
							CheckDatabaseVersions();
							MigrateFullTModels();
							break;

						case MigrationStage.MigrateHiddenTModels:
							CheckDatabaseVersions();
							MigrateHiddenTModels();
							break;

						case MigrationStage.MigrateBareBusinessEntities:
							CheckDatabaseVersions();
							MigrateBareBusinessEntities();
							break;

						case MigrationStage.MigrateBusinessEntities:
							CheckDatabaseVersions();
							MigrateBusinessEntities();
							break;

						case MigrationStage.MigratePublisherAssertions:
							CheckDatabaseVersions();
							MigratePublisherAssertions();
							break;
						
						case MigrationStage.RestoreReaderConnection:
							RestoreReaderConnection();
							break;
					}
				}
			}
			catch ( Exception e )
			{
				retcode = 1;
				Log( "ERROR: " + e.ToString(), LogType.ConsoleAndLog );
			}
			finally
			{
				sharedMemory.Release();
			}

			if( retcode == 0 )
				Log( "Migrate.exe terminating normally", LogType.ConsoleAndLog );
			else
				Log( "Migrate.exe terminating abnormally", LogType.ConsoleAndLog );

			Stream.Close();
			LogFile.Close();

			return retcode;
		}

		private static int ProcessCommandLine( string [] args )
		{
			int retcode = 0;

			for( int i = 0; i < args.Length; i ++ )
			{
				if( '-' == args[i][0] || '/' == args[i][0] )
				{
					string option = args[i].Substring( 1 );

					if( "help" == option.ToLower() || "?" == option )
					{
						Stage = MigrationStage.DisplayUsage;
						return 0;
					}
					else if( "s" == option.ToLower() )
					{
						i++; // move to the next arg

						try
						{
							Stage = (MigrationStage)Enum.Parse( Stage.GetType(), args[i], true );
						}
						catch( Exception e )
						{
							Log ( "ERROR: Invalid migrationstage value: " + e.ToString(), LogType.ConsoleOnly );
							return 1;
						}

					}
					else if( "c" == option.ToLower() )
					{
						i++; // move to the next arg
						NewReaderConnectionString = args[i];
					}
					else if( "v" == option.ToLower() )
					{
						Verbose = true;
					}
					else if( "i" == option.ToLower() )
					{
						Stream.Close();
						LogFile.Close();
						LogFile = new FileStream( LogFileName, FileMode.Create );					
						Stream = new StreamWriter( LogFile );
					}
					else
					{
						Stage = MigrationStage.DisplayUsage;
						return 1;
					}
				}
			}

			//
			// Check argument dependencies
			//

			switch( Stage )
			{
				case MigrationStage.SetReaderConnection:
					retcode = ( null == NewReaderConnectionString ? 1 : 0 );
					break;

				default:
					retcode = 0;
					break;
			}

			return retcode;
		}

		private static void CheckDatabaseVersions()
		{
			//
			// Process Reader Version
			//

			Version readerversion = GetDbVersion( ReaderConnectionString );
			Version writerversion = GetDbVersion( WriterConnectionString );

			if( !writerversion.Equals( readerversion ) )
			{
				Log( "Different database versions detected.", LogType.ConsoleAndLog );
				Log( "Writer Database Version: " + writerversion.ToString(), LogType.LogOnly );
				
				switch( writerversion.ToString() )
				{
					case V2RC1STR:
						if( readerversion.Equals( V2RC0 ) )
						{
							Log( "Upgrading reader to UDDI Database version " + V2RC1.ToString(), LogType.ConsoleAndLog );
							ExecuteScript( ReaderConnectionString, UpgradeRc0ToRc1Script );
						}
						else
						{
							throw new ApplicationException( "Migrations from a UDDI database version " + readerversion.ToString() + " to a UDDI database version " + writerversion.ToString() + " are not supported by this tool." );
						}

						break;

					case V2RC2STR:
						if( readerversion.Equals( V2RC1 ) )
						{
							Log( "Upgrading reader to UDDI Database version " + V2RC2.ToString(), LogType.ConsoleAndLog );
							ExecuteScript( ReaderConnectionString, UpgradeRc1ToRc2Script );
						}
						else
						{
							throw new ApplicationException( "Migrations from a UDDI database version " + readerversion.ToString() + " to a UDDI database version " + writerversion.ToString() + " are not supported by this tool." );
						}
						
						break;

					case V2RTMSTR:
						throw new ApplicationException( "Migrations from a UDDI database version " + readerversion.ToString() + " to a UDDI database version " + writerversion.ToString() + " are not yet supported by this tool." );

					default:
						throw new ApplicationException( "Unknown UDDI Database version encountered: " + writerversion.ToString() );
				}
			}
		}

		private static void SetReaderConnection()
		{
			Log( Separator, LogType.LogOnly );
			Log( "Executing Stage: SetReaderConnection", LogType.ConsoleAndLog );

			try
			{
				RegistryKey root = Registry.LocalMachine.OpenSubKey( DatabaseRoot, true );

				string oldconnectionstring = root.GetValue( ReaderValueName ).ToString();
				root.SetValue( ReaderValueName, NewReaderConnectionString );
				Log( "Registry setting changed: " + DatabaseRoot + "\\" + ReaderValueName + " = \"" + NewReaderConnectionString + "\"", LogType.LogOnly );
				root.SetValue( OldReaderValueName, oldconnectionstring );
				Log( "Registry setting changed: " + DatabaseRoot + "\\" + OldReaderValueName + " = \"" + oldconnectionstring + "\"", LogType.LogOnly );

				root.Close();
			}
			catch ( Exception e )
			{
				Log( "ERROR: unable to modify registry: " + e.ToString(), LogType.LogOnly );
				throw new ApplicationException( "SetReaderConnection failed." );			
			}
		}

		private static void ResetWriter()
		{
			Log( Separator, LogType.LogOnly );
			Log( "Executing Stage: ResetWriter", LogType.ConsoleAndLog );

			//
			// Setup connection to writer
			//
			SqlConnection connection = new SqlConnection( WriterConnectionString );
			connection.Open();
			SqlTransaction transaction;
			transaction = connection.BeginTransaction();

			try
			{
				//
				// Setup command for delete operation
				//

				string cmdbatch = "";
				cmdbatch += "DELETE [UDC_categoryBag_TM] \n";
				cmdbatch += "DELETE [UDC_identifierBag_TM] \n";
				cmdbatch += "DELETE [UDC_tModelDesc] \n";
				cmdbatch += "DELETE [UDC_tModels] \n";
				cmdbatch += "DELETE [UDC_instanceDesc] \n";
				cmdbatch += "DELETE [UDC_tModelInstances] \n";
				cmdbatch += "DELETE [UDC_bindingDesc] \n";
				cmdbatch += "DELETE [UDC_bindingTemplates] \n";
				cmdbatch += "DELETE [UDC_names_BS] \n";
				cmdbatch += "DELETE [UDC_categoryBag_BS] \n";
				cmdbatch += "DELETE [UDC_serviceDesc] \n";
				cmdbatch += "DELETE [UDC_businessServices] \n";
				cmdbatch += "DELETE [UDC_addressLines] \n";
				cmdbatch += "DELETE [UDC_addresses] \n";
				cmdbatch += "DELETE [UDC_phones] \n";
				cmdbatch += "DELETE [UDC_emails] \n";
				cmdbatch += "DELETE [UDC_contactDesc] \n";
				cmdbatch += "DELETE [UDC_contacts] \n";
				cmdbatch += "DELETE [UDC_businessDesc] \n";
				cmdbatch += "DELETE [UDC_categoryBag_BE] \n";
				cmdbatch += "DELETE [UDC_identifierBag_BE] \n";
				cmdbatch += "DELETE [UDC_discoveryURLs] \n";
				cmdbatch += "DELETE [UDC_names_BE] \n";
				cmdbatch += "DELETE [UDC_assertions_BE] \n";
				cmdbatch += "DELETE [UDC_serviceProjections] \n";
				cmdbatch += "DELETE [UDT_taxonomyValues] \n";
				cmdbatch += "DELETE [UDT_taxonomies] \n";
				cmdbatch += "DELETE [UDO_changeLog] \n";
				cmdbatch += "DELETE [UDO_queryLog] \n";
				cmdbatch += "DELETE [UDO_operatorLog] \n";
				cmdbatch += "DELETE \n";
				cmdbatch += "  [UDO_publishers] \n";
				cmdbatch += "WHERE \n";
				cmdbatch += "  ([PUID] <> '"+ UDDI.Utility.GetDefaultPublisher() + "') \n";
				Log( cmdbatch, LogType.LogOnly );

				SqlCommand command = new SqlCommand( cmdbatch );
				command.Connection = connection;
				command.Transaction = transaction;

				//
				// Execute command
				//

				command.ExecuteNonQuery();
				transaction.Commit();
				Log( "Write database has been reset.", LogType.ConsoleAndLog );
			}
			catch( Exception e )
			{
				transaction.Rollback();
				Log( "ERROR: " + e.ToString(), LogType.ConsoleAndLog );
				throw new ApplicationException( "ResetWriter failed." );			
			}
			finally
			{
				connection.Close();
			}
		}
		
		private static void MigratePublishers()
		{
			int count = 0;

			Log( Separator, LogType.LogOnly );
			Log( "Executing Stage: MigratePublishers", LogType.ConsoleAndLog );

			//
			// Get a list of publishers
			//

			SqlConnection readerconnection = new SqlConnection( ReaderConnectionString );
			readerconnection.Open();

			SqlConnection writerconnection = new SqlConnection( WriterConnectionString );
			writerconnection.Open();

			SqlTransaction transaction;
			transaction = writerconnection.BeginTransaction();

			try
			{
				//
				// Setup writer publisher insert statement
				//

				string writercommandbatch = "";
				writercommandbatch += "INSERT [UDO_publishers] ( \n";
				writercommandbatch += "  [publisherStatusID], \n";
				writercommandbatch += "  [PUID], \n";
				writercommandbatch += "  [email], \n";
				writercommandbatch += "  [name], \n";
				writercommandbatch += "  [phone], \n";
				writercommandbatch += "  [isoLangCode], \n";
				writercommandbatch += "  [tModelLimit], \n";
				writercommandbatch += "  [businessLimit], \n";
				writercommandbatch += "  [serviceLimit], \n";
				writercommandbatch += "  [bindingLimit], \n";
				writercommandbatch += "  [assertionLimit], \n";
				writercommandbatch += "  [companyName], \n";
				writercommandbatch += "  [addressLine1], \n";
				writercommandbatch += "  [addressLine2], \n";
				writercommandbatch += "  [mailstop], \n";
				writercommandbatch += "  [city], \n";
				writercommandbatch += "  [stateProvince], \n";
				writercommandbatch += "  [extraProvince], \n";
				writercommandbatch += "  [country], \n";
				writercommandbatch += "  [postalCode], \n";
				writercommandbatch += "  [companyURL], \n";
				writercommandbatch += "  [companyPhone], \n";
				writercommandbatch += "  [altPhone], \n";
				writercommandbatch += "  [backupContact], \n";
				writercommandbatch += "  [backupEmail], \n";
				writercommandbatch += "  [description], \n";
				writercommandbatch += "  [securityToken], \n";
				writercommandbatch += "  [flag] )\n";
				writercommandbatch += "VALUES ( \n";
				writercommandbatch += "  @publisherStatusID, \n";
				writercommandbatch += "  @PUID, \n";
				writercommandbatch += "  @email, \n";
				writercommandbatch += "  @name, \n";
				writercommandbatch += "  @phone, \n";
				writercommandbatch += "  @isoLangCode, \n";
				writercommandbatch += "  @tModelLimit, \n";
				writercommandbatch += "  @businessLimit, \n";
				writercommandbatch += "  @serviceLimit, \n";
				writercommandbatch += "  @bindingLimit, \n";
				writercommandbatch += "  @assertionLimit, \n";
				writercommandbatch += "  @companyName, \n";
				writercommandbatch += "  @addressLine1, \n";
				writercommandbatch += "  @addressLine2, \n";
				writercommandbatch += "  @mailstop, \n";
				writercommandbatch += "  @city, \n";
				writercommandbatch += "  @stateProvince, \n";
				writercommandbatch += "  @extraProvince, \n";
				writercommandbatch += "  @country, \n";
				writercommandbatch += "  @postalCode, \n";
				writercommandbatch += "  @companyURL, \n";
				writercommandbatch += "  @companyPhone, \n";
				writercommandbatch += "  @altPhone, \n";
				writercommandbatch += "  @backupContact, \n";
				writercommandbatch += "  @backupEmail, \n";
				writercommandbatch += "  @description, \n";
				writercommandbatch += "  @securityToken, \n";
				writercommandbatch += "  @flag )\n";

				SqlCommand writercommand = new SqlCommand( writercommandbatch );
				writercommand.Parameters.Add( "@publisherStatusID", SqlDbType.TinyInt );
				writercommand.Parameters.Add( "@PUID", SqlDbType.NVarChar, 450 );
				writercommand.Parameters.Add( "@email", SqlDbType.NVarChar, 450 );
				writercommand.Parameters.Add( "@name", SqlDbType.NVarChar, 100 );
				writercommand.Parameters.Add( "@phone", SqlDbType.VarChar, 20 );
				writercommand.Parameters.Add( "@isoLangCode", SqlDbType.VarChar, 17 );
				writercommand.Parameters.Add( "@tModelLimit", SqlDbType.Int );
				writercommand.Parameters.Add( "@businessLimit", SqlDbType.Int );
				writercommand.Parameters.Add( "@serviceLimit", SqlDbType.Int );
				writercommand.Parameters.Add( "@bindingLimit", SqlDbType.Int );
				writercommand.Parameters.Add( "@assertionLimit", SqlDbType.Int );
				writercommand.Parameters.Add( "@companyName", SqlDbType.NVarChar, 100 );
				writercommand.Parameters.Add( "@addressLine1", SqlDbType.NVarChar, 4000 );
				writercommand.Parameters.Add( "@addressLine2", SqlDbType.NVarChar, 4000 );
				writercommand.Parameters.Add( "@mailstop", SqlDbType.NVarChar, 20 );
				writercommand.Parameters.Add( "@city", SqlDbType.NVarChar, 100 );
				writercommand.Parameters.Add( "@stateProvince", SqlDbType.NVarChar, 100 );
				writercommand.Parameters.Add( "@extraProvince", SqlDbType.NVarChar, 100 );
				writercommand.Parameters.Add( "@country", SqlDbType.NVarChar, 100 );
				writercommand.Parameters.Add( "@postalCode", SqlDbType.VarChar, 100 );
				writercommand.Parameters.Add( "@companyURL", SqlDbType.NVarChar, 512 );
				writercommand.Parameters.Add( "@companyPhone", SqlDbType.VarChar, 20 );
				writercommand.Parameters.Add( "@altPhone", SqlDbType.VarChar, 20 );
				writercommand.Parameters.Add( "@backupContact", SqlDbType.NVarChar, 100 );
				writercommand.Parameters.Add( "@backupEmail", SqlDbType.NVarChar, 450 );
				writercommand.Parameters.Add( "@description", SqlDbType.NVarChar, 4000 );
				writercommand.Parameters.Add( "@securityToken", SqlDbType.UniqueIdentifier );
				writercommand.Parameters.Add( "@flag", SqlDbType.Int );

				writercommand.Connection = writerconnection;
				writercommand.Transaction = transaction;

				//
				// Execute query against reader and process results
				//
				SqlDataReader reader;
				reader = GetPublisherList( readerconnection );

				while( reader.Read() )
				{
					count++;

					//
					// Set writer insert parameters using reader result values.
					// Note: Assumes reader select and writer insert have identical column lists
					//

					for( int i = 0; i < writercommand.Parameters.Count; i++ )
					{
						writercommand.Parameters[ i ].Value = DBNull.Value;

						if( !reader.IsDBNull( i ) )
							writercommand.Parameters[ i ].Value = reader.GetSqlValue( i );
					}

					//
					// Execute writer insert
					//

					writercommand.ExecuteNonQuery();
				}

				reader.Close();
				transaction.Commit();
			}
			catch ( Exception e )
			{
				transaction.Rollback();
				count = 0;
				Log( "ERROR: database error: " + e.ToString(), LogType.ConsoleAndLog );
				throw new ApplicationException( "MigratePublishers failed." );			
			}
			finally
			{
				readerconnection.Close();
				writerconnection.Close();
				Log( count.ToString() + " publishers migrated.", LogType.ConsoleAndLog );
			}
		}

		private static void MigrateBareTModels()
		{
			int count = 0;

			Log( Separator, LogType.LogOnly );
			Log( "Executing Stage: MigrateBareTModels", LogType.ConsoleAndLog );

			//
			// Open a separate connection to reader 
			//

			SqlConnection connection = new SqlConnection( ReaderConnectionString );
			connection.Open();

			try
			{
				//
				// Get a list of tModels hosted by Microsoft on reader
				//

				SqlDataReader reader = GetCompleteTModelList( connection );

				//
				// Loop through each tModel in the result set
				//
				
				//string operatorkey = "";

				while( reader.Read() )
				{
					TModel tmodel = new TModel();

					//
					// Set identity
					//

					Context.User.ID = reader.IsDBNull( 1 ) ? null : reader.GetString( 1 );
					Context.User.SetPublisherRole( Context.User.ID );

					//
					// Get tModel from reader
					//

					tmodel.TModelKey = "uuid:" + ( reader.IsDBNull( 0 ) ? "" : reader.GetGuid( 0 ).ToString() );
					ConnectionManager.Open( false, false );
					tmodel.Get();
					ConnectionManager.Close();

					//
					// Remove identifier and categoryBags
					//

					if( tmodel.IdentifierBag.Count > 0 )
					{
						tmodel.IdentifierBag.Clear();
						Log( "Cleared identifierBag for tModelKey = " + tmodel.TModelKey, LogType.LogOnly );
					}

					if( tmodel.CategoryBag.Count > 0 )
					{
						tmodel.CategoryBag.Clear();
						Log( "Cleared categoryBag for tModelKey = " + tmodel.TModelKey, LogType.LogOnly );
					}

					//
					// Set authorizedName to null
					//

					tmodel.AuthorizedName = null;

					//
					// Open writer connection
					//

					ConnectionManager.Open( true, true );

					if( Context.User.ID != UDDI.Utility.GetDefaultPublisher() )
						Context.User.SetAllowPreassignedKeys( true );

					//
					// Save the bare tModel to the writer
					//

					Log( "save_tModel: tModelKey = " +  tmodel.TModelKey + "; name = " + tmodel.Name + "; puid = " + Context.User.ID, LogType.LogOnly );
					tmodel.Save();
					count++;
					
					//
					// Note that transaction only spans single save_tModel and operator insert/delete due to connecton manager limitations
					//

					ConnectionManager.Commit();
					ConnectionManager.Close();
				}

				reader.Close();
			}
			catch ( Exception e )
			{
				Log( "ERROR: " + e.ToString(), LogType.ConsoleAndLog );
				throw new ApplicationException( "MigrateBareTModels failed." );			
			}
			finally
			{
				connection.Close();
				ConnectionManager.Close();
				Log( count.ToString() + " bare tModels migrated.", LogType.ConsoleAndLog );
			}
		}

		private static void BootstrapResources()
		{
			int count=0;

			Log( Separator, LogType.LogOnly );
			Log( "Executing Stage: BootstrapResources", LogType.ConsoleAndLog );

			try
			{
				//
				// load all the bootstrap files found in the \uddi\bootstrap folder
				//
				string targetDir = Registry.LocalMachine.OpenSubKey( @"SOFTWARE\Microsoft\UDDI" ).GetValue( "InstallRoot" ).ToString();
				string bootstrapdir = CheckForSlash(targetDir) + "bootstrap";
				string bootstrapexe = CheckForSlash(targetDir) + @"bin\bootstrap.exe";

				Log( "Getting list of bootstrap files from directory '" + bootstrapdir + "'", LogType.LogOnly );

				string[] filepaths = Directory.GetFiles( bootstrapdir, "*.xml" );
				Log( "Writing " + filepaths.Length + " baseline resources to database.", LogType.ConsoleAndLog );
			
				foreach( string filepath in filepaths )
				{
					Log( "Importing bootstrap data from: " + filepath, LogType.ConsoleAndLog );

					ProcessStartInfo startInfo = new ProcessStartInfo( bootstrapexe, "/f \""+ filepath + "\"");

					startInfo.CreateNoWindow = true;
					startInfo.UseShellExecute = false;
					startInfo.RedirectStandardOutput = true;

					Process p = new Process();
					p = Process.Start( startInfo );

					//
					// grab the stdout string
					//
					string bootstrapOutput = p.StandardOutput.ReadToEnd();

					//
					// wait for bootstrap.exe to complete
					//
					p.WaitForExit();

					//
					// write the stdout string to the log
					//
					Log( bootstrapOutput, LogType.LogOnly );

					if( p.ExitCode != 0 )
					{
						throw new ApplicationException( "BootstrapResources failed." );			
					}
					
					count++;
				}
			}
			catch( Exception e )
			{
				DispositionReport.Throw( e );
				Log( "ERROR: " + e.ToString(), LogType.ConsoleAndLog );
				throw new ApplicationException( "BootstrapResources failed." );			
			}
			finally
			{
				Log( count.ToString() + " resource files bootstrapped.", LogType.ConsoleAndLog );
			}
		}

		private static void MigrateCategorizationSchemes()
		{
			int count = 0;

			Log( Separator, LogType.LogOnly );
			Log( "Executing Stage: MigrateCategorizationSchemes", LogType.ConsoleAndLog );

			//
			// Check database version compatibility
			//

			Version writerversion = GetDbVersion( WriterConnectionString );

			if ( writerversion.CompareTo( V2RC2 ) < 0 )
			{
				throw new ApplicationException( "The MigrateCategorizationSchemes migration stage is only supported for UDDI Services database versions " + V2RC2.ToString() + " or later.  Your current database version is: " + writerversion.ToString() );
			}
			
			//
			// Open a separate connection to reader
			//

			SqlConnection connection = new SqlConnection( ReaderConnectionString );
			connection.Open();

			try
			{
				//
				// Get a list of taxonomies
				//

				SqlDataReader reader = GetTaxonomyList( connection );

				//
				// Loop through each taxonomy in the result set
				//
				
				while( reader.Read() )
				{
					//
					// Check to see if taxonomy is a user-defined taxonomy
					// Note: a user-defined taxonomy is any taxonomy that does not exist in a newly bootstrapped uddi database
					//

					if( !CategorizationSchemeExists( reader.IsDBNull( 0 ) ? null : reader.GetGuid( 0 ).ToString() ) )
					{
						CategorizationScheme scheme = new CategorizationScheme();
	
						//
						// Set identity to system since categorization schemes are not publications
						//

						Context.User.ID = UDDI.Utility.GetDefaultPublisher();
						Context.User.SetPublisherRole( Context.User.ID );

						//
						// Get categorization scheme from reader
						//

						scheme.TModelKey = "uuid:" + ( reader.IsDBNull( 0 ) ? "" : reader.GetGuid( 0 ).ToString() );
						ConnectionManager.Open( false, false );
						scheme.Get();
						ConnectionManager.Close();

						//
						// Save the categorization scheme to writer
						//
						ConnectionManager.Open( true, true );
						Log( "CategorizationScheme.Save(): tModelKey = " +  scheme.TModelKey + "; puid = " + Context.User.ID + "; value count = " + scheme.CategoryValues.Count.ToString(), LogType.LogOnly  );
						scheme.Save(); 
						count++;
					
						//
						// Note that transaction only spans single tmodel due to connecton manager limitations
						//

						ConnectionManager.Commit();
						ConnectionManager.Close();

						scheme = new CategorizationScheme();
					}
				}
				
				reader.Close();
			}
			catch ( Exception e )
			{
				Log( "ERROR: " + e.ToString(), LogType.ConsoleAndLog );
				throw new ApplicationException( "MigrateCategorizationSchemes failed." );			
			}
			finally
			{
				connection.Close();
				ConnectionManager.Close();
				Log( count.ToString() + " categorization schemes migrated.", LogType.ConsoleAndLog );
			}
		}

		private static void MigrateFullTModels()
		{
			int count = 0;

			Log( Separator, LogType.LogOnly );
			Log( "Executing Stage: MigrateFullTModels", LogType.ConsoleAndLog );

			//
			// Open a separate connection to reader 
			//

			SqlConnection connection = new SqlConnection( ReaderConnectionString );
			connection.Open();

			try
			{
				//
				// Get a list of tModels hosted by Micrsoft
				//

				SqlDataReader reader = GetCompleteTModelList( connection );

				//
				// Loop through each tModel in the result set
				//
				
				TModel tmodel = new TModel();

				while( reader.Read() )
				{
					count++;

					//
					// Set identity
					//

					Context.User.ID = reader.IsDBNull( 1 ) ? null : reader.GetString( 1 );
					Context.User.SetPublisherRole( Context.User.ID );
					string email = reader.IsDBNull( 2 ) ? null : reader.GetString( 2 );

					//
					// Get tModel from reader
					//

					string tmodelkey = reader.IsDBNull( 0 ) ? null : reader.GetGuid( 0 ).ToString();
					tmodel.TModelKey = "uuid:" + tmodelkey;
					ConnectionManager.Open( false, false );
					tmodel.Get();
					ConnectionManager.Close();

					//
					// Fix 1.0 bugs if any
					//

					FixTModel( tmodel, email );

					//
					// Set authorizedName to null
					//

					tmodel.AuthorizedName = null;

					//
					// Save tModel on writer
					//

					ConnectionManager.Open( true, true );
					Log( "save_tModel: tModelKey = " +  tmodel.TModelKey + "; name = " + tmodel.Name + "; puid = " + Context.User.ID, LogType.LogOnly );
					tmodel.Save();
					
					//
					// Note that transaction only spans single tmodel due to connecton manager limitations
					//

					ConnectionManager.Commit();
					ConnectionManager.Close();

					tmodel = new TModel();
				}
				reader.Close();
			}
			catch ( Exception e )
			{
				Log( "ERROR: " + e.ToString(), LogType.ConsoleAndLog );
				throw new ApplicationException( "MigrateFullTModels failed." );			
			}
			finally
			{
				connection.Close();
				ConnectionManager.Close();
				Log( count.ToString() + " full tModels migrated.", LogType.ConsoleAndLog );
			}
		}

		private static void MigrateHiddenTModels()
		{
			int count = 0;

			Log( Separator, LogType.LogOnly );
			Log( "Executing stage: MigrateHiddenTModels", LogType.ConsoleAndLog );

			//
			// Open a separate connection to reader 
			//

			SqlConnection connection = new SqlConnection( ReaderConnectionString );
			connection.Open();

			//
			// Open writer connection
			//

			ConnectionManager.Open( true, true );

			try
			{
				//
				// Get a list of hidden tModels hosted by Microsoft from reader
				//

				SqlDataReader reader = GetHiddenTModelList( connection );

				//
				// Loop through each tModel in the result set
				//
				
				while( reader.Read() )
				{
					TModel tmodel = new TModel();
					count++;

					//
					// Set identity
					//

					Context.User.ID = reader.IsDBNull( 1 ) ? null : reader.GetString( 1 );
					Context.User.SetPublisherRole( Context.User.ID );

					//
					// Delete the tModel on the writer connection
					//
					tmodel.TModelKey = "uuid:" + ( reader.IsDBNull( 0 ) ? "" : reader.GetGuid( 0 ).ToString() );
					Log( "delete_tModel: tModelKey = " +  tmodel.TModelKey + "; puid = " + Context.User.ID, LogType.LogOnly );
					tmodel.Delete();
				}

				reader.Close();
				ConnectionManager.Commit();
			}
			catch ( Exception e )
			{
				ConnectionManager.Abort();
				count = 0;
				Log( "ERROR: " + e.ToString(), LogType.ConsoleAndLog );
				throw new ApplicationException( "MigrateHiddenTModels failed." );			
			}
			finally
			{
				connection.Close();
				ConnectionManager.Close();
				Log( count.ToString() + " hidden tModels migrated.", LogType.ConsoleAndLog );
			}
		}

		private static void MigrateBareBusinessEntities()
		{
			int count = 0;

			Log( Separator, LogType.LogOnly );
			Log( "Executing stage: MigrateBareBusinessEntities", LogType.ConsoleAndLog );

			//
			// Open a separate connection to reader 
			//

			SqlConnection connection = new SqlConnection( ReaderConnectionString );
			connection.Open();

			try
			{
				//
				// Get a list of businessEntities hosted by Microsoft on reader
				//

				SqlDataReader reader = GetBusinessEntityList( connection );

				//
				// Loop through each businessEntity in the result set
				//
				
				while( reader.Read() )
				{
					BusinessEntity businessentity = new BusinessEntity();
					count++;

					//
					// Set identity
					//

					Context.User.ID = reader.IsDBNull( 1 ) ? null : reader.GetString( 1 );
					Context.User.SetPublisherRole( Context.User.ID );
					string email = reader.IsDBNull( 2 ) ? null : reader.GetString( 2 );

					//
					// Get businessEntity from reader
					//

					businessentity.BusinessKey = reader.IsDBNull( 0 ) ? null : reader.GetGuid( 0 ).ToString();
					ConnectionManager.Open( false, false );
					businessentity.Get();
					ConnectionManager.Close();

					//
					// Remove all keyedReferences from businessEntity
					//

					if( 0 < businessentity.CategoryBag.Count )
					{
						businessentity.CategoryBag.Clear();
						Log( "Cleared categoryBag for businessEntity.  businessKey = " + businessentity.BusinessKey, LogType.LogOnly );
					}

					if( 0 < businessentity.IdentifierBag.Count )
					{
						businessentity.IdentifierBag.Clear();
						Log( "Cleared identifierBag for businessEntity.  businessKey = " + businessentity.BusinessKey, LogType.LogOnly );
					}

					foreach( BusinessService bs in businessentity.BusinessServices )
					{
						//
						// Remove all keyedReferences from businessService
						//

						if( 0 < bs.CategoryBag.Count )
						{
							bs.CategoryBag.Clear();
							Log( "Cleared categoryBag for businessService.  serviceKey = " + bs.ServiceKey, LogType.LogOnly );
						}

						foreach( BindingTemplate bt in bs.BindingTemplates )
						{
							//
							// Clear hostingRedirector from bindingTemplate.  Save key in accessPoint
							//

							if( null != bt.HostingRedirector.BindingKey )
							{
								bt.AccessPoint.Value = bt.HostingRedirector.BindingKey;
								bt.HostingRedirector.BindingKey = null;
								Log( "Cleared hostingRedirector for bindingTemplate.  bindingKey = " + bt.BindingKey, LogType.LogOnly );
							}
						}
					}
					
					//
					// Correct v1.0 bugs if any
					//

					FixBusiness( businessentity, email, false );

					//
					// Set authorizedName to null
					//

					businessentity.AuthorizedName = null;

					//
					// Open writer connection
					//

					ConnectionManager.Open( true, true );

					if( Context.User.ID != UDDI.Utility.GetDefaultPublisher() )
						Context.User.SetAllowPreassignedKeys( true );

					//
					// Save the businessEntity on the writer
					//

					Log( "save_business: businessKey = " + businessentity.BusinessKey + "; name = " + businessentity.Names[ 0 ].Value + "; puid = " + Context.User.ID, LogType.LogOnly );
					businessentity.Save();
					
					//
					// Note that transaction only spans single save_tModel and operator insert/delete due to connecton manager limitations
					//

					ConnectionManager.Commit();
					ConnectionManager.Close();
				}
				reader.Close();
			}
			catch ( Exception e )
			{
				Log( "ERROR: " + e.ToString(), LogType.ConsoleAndLog );
				throw new ApplicationException( "MigrateBareBusinessEntities failed." );			
			}
			finally
			{
				connection.Close();
				ConnectionManager.Close();
				Log( count.ToString() + " bare businessEntities migrated.", LogType.ConsoleAndLog );
			}

		}

		private static void MigrateBusinessEntities()
		{
			int count = 0;

			Log( Separator, LogType.LogOnly );
			Log( "Executing stage: MigrateBusinessEntities", LogType.ConsoleAndLog );

			//
			// Open a separate connection to reader 
			//

			SqlConnection connection = new SqlConnection( ReaderConnectionString );
			connection.Open();

			try
			{
				//
				// Get a list of businessEntities hosted by Microsoft on reader
				//

				SqlDataReader reader = GetBusinessEntityList( connection );

				//
				// Loop through each businessEntity in the result set
				//
				
				while( reader.Read() )
				{
					BusinessEntity businessentity = new BusinessEntity();
					count++;

					//
					// Set identity
					//

					Context.User.ID = reader.IsDBNull( 1 ) ? null : reader.GetString( 1 );
					Context.User.SetPublisherRole( Context.User.ID );
					string email = reader.IsDBNull( 2 ) ? null : reader.GetString( 2 );
					
					//
					// Get businessEntity from reader
					//

					businessentity.BusinessKey = reader.IsDBNull( 0 ) ? null : reader.GetGuid( 0 ).ToString();
					ConnectionManager.Open( false, false );
					businessentity.Get();
					ConnectionManager.Close();

					//
					// Correct v1.0 bugs if any
					//

					FixBusiness( businessentity, email, true );

					//
					// Set authorizedName to null
					//

					businessentity.AuthorizedName = null;

					//
					// Open writer connection
					//

					ConnectionManager.Open( true, true );

					if( Context.User.ID != UDDI.Utility.GetDefaultPublisher() )
						Context.User.SetAllowPreassignedKeys( true );

					//
					// Save the businessEntity on the writer
					//

					Log( "save_business: businessKey = " + businessentity.BusinessKey + "; name = " + businessentity.Names[ 0 ].Value + "; puid = " + Context.User.ID, LogType.LogOnly );
					businessentity.Save();
					
					//
					// Note that transaction only spans single save_tModel and operator insert/delete due to connecton manager limitations
					//

					ConnectionManager.Commit();
					ConnectionManager.Close();
				}
				reader.Close();
			}
			catch ( Exception e )
			{
				Log( "ERROR: " + e.ToString(), LogType.ConsoleAndLog );
				throw new ApplicationException( "MigrateBusinessEntities failed." );			
			}
			finally
			{
				connection.Close();
				ConnectionManager.Close();
				Log( count.ToString() + " businessEntities migrated.", LogType.ConsoleAndLog );
			}

		}

		private static void MigratePublisherAssertions()
		{
			int publishercount = 0;
			int assertioncount = 0;

			Log( Separator, LogType.LogOnly );
			Log( "Executing stage: MigratePublisherAssertions", LogType.ConsoleAndLog );

			//
			// Open a separate connection to reader 
			//

			SqlConnection connection = new SqlConnection( ReaderConnectionString );
			connection.Open();

			try
			{
				//
				// Get a list of publishers on the reader
				//

				SqlDataReader reader = GetPublisherList( connection );

				//
				// Loop through each publisher in the result set
				//
				
				while( reader.Read() )
				{
					PublisherAssertionCollection assertions = new PublisherAssertionCollection();

					//
					// Set identity
					//

					Context.User.ID = reader.IsDBNull( 1 ) ? null : reader.GetString( 1 );
					Context.User.SetPublisherRole( Context.User.ID );

					//
					// Get assertions
					//

					ConnectionManager.Open( false, false );
					assertions.Get();
					ConnectionManager.Close();

					//
					// Open writer connection
					//

					if( 0 < assertions.Count )
					{
						ConnectionManager.Open( true, true );

						//
						// Save the assertions on the writer
						//

						Log( "set_publisherAssertions: puid = " + Context.User.ID + "; count = " + assertions.Count.ToString(), LogType.LogOnly );
						assertions.Save();
					
						publishercount++;
						assertioncount = assertioncount + assertions.Count;

						//
						// Note that transaction only spans single set_publisherAssertions due to connecton manager limitations
						//

						ConnectionManager.Commit();
						ConnectionManager.Close();
					}
				}
				
				reader.Close();
			}
			catch ( Exception e )
			{
				Log( "ERROR: " + e.ToString(), LogType.ConsoleAndLog );
				throw new ApplicationException( "MigratePublisherAssertions failed." );			
			}
			finally
			{
				connection.Close();
				ConnectionManager.Close();
				Log( assertioncount.ToString() + " assertions migrated for " + publishercount.ToString() + " publishers.", LogType.ConsoleAndLog );
			}
		}

		private static void RestoreReaderConnection()
		{
			Log( Separator, LogType.LogOnly );
			Log( "Executing stage: RestoreReaderConnection", LogType.ConsoleAndLog );

			try
			{
				RegistryKey root = Registry.LocalMachine.OpenSubKey( DatabaseRoot, true );
				
				if( null != root.GetValue( OldReaderValueName ) )
				{
					string oldreaderconnectionstring = root.GetValue( OldReaderValueName ).ToString();
					root.SetValue( ReaderValueName, oldreaderconnectionstring );
					Log( "Registry Setting Changed: " + DatabaseRoot + "\\" + ReaderValueName + " = \"" + oldreaderconnectionstring + "\"", LogType.LogOnly );
					root.DeleteValue( OldReaderValueName, true );
					Log( "Deleted Registry Value: " + DatabaseRoot + "\\" + OldReaderValueName, LogType.LogOnly );

					root.Close();
				}
			}
			catch ( Exception e )
			{
				Log( "ERROR:" + e.ToString(), LogType.ConsoleAndLog );
				throw new ApplicationException( "RestoreReaderConnection failed." );			
			}
		}

		private static void GetSettings()
		{

			try
			{
				RegistryKey dbsetuproot = Registry.LocalMachine.OpenSubKey( DatabaseSetupRoot );

				if( null == dbsetuproot )
				{
					throw new ApplicationException( "The UDDI Services Database Components are not installed on this machine." );
				}

				dbsetuproot.Close();

				RegistryKey dbroot = Registry.LocalMachine.OpenSubKey( DatabaseRoot, true );
				
				if( null == dbroot )
				{
					throw new ApplicationException( "Unable to open registry key: " + DatabaseRoot );
				}

				ReaderConnectionString = dbroot.GetValue( ReaderValueName ).ToString();
				WriterConnectionString = dbroot.GetValue( WriterValueName ).ToString();
				dbroot.Close();
			}
			catch ( Exception e )
			{
				Log( "ERROR:" + e.ToString(), LogType.ConsoleAndLog );
				throw new ApplicationException( "GetSettings failed." );
			}

		}

		private static SqlDataReader GetPublisherList( SqlConnection connection )		
		{
			string cmdbatch = "";
			cmdbatch += "SELECT \n";
			cmdbatch += "  [publisherStatusID], \n";
			cmdbatch += "  [PUID], \n";
			cmdbatch += "  [email], \n";
			cmdbatch += "  [name], \n";
			cmdbatch += "  [phone], \n";
			cmdbatch += "  [isoLangCode], \n";
			cmdbatch += "  [tModelLimit], \n";
			cmdbatch += "  [businessLimit], \n";
			cmdbatch += "  [serviceLimit], \n";
			cmdbatch += "  [bindingLimit], \n";
			cmdbatch += "  [assertionLimit], \n";
			cmdbatch += "  [companyName], \n";
			cmdbatch += "  [addressLine1], \n";
			cmdbatch += "  [addressLine2], \n";
			cmdbatch += "  [mailstop], \n";
			cmdbatch += "  [city], \n";
			cmdbatch += "  [stateProvince], \n";
			cmdbatch += "  [extraProvince], \n";
			cmdbatch += "  [country], \n";
			cmdbatch += "  [postalCode], \n";
			cmdbatch += "  [companyURL], \n";
			cmdbatch += "  [companyPhone], \n";
			cmdbatch += "  [altPhone], \n";
			cmdbatch += "  [backupContact], \n";
			cmdbatch += "  [backupEmail], \n";
			cmdbatch += "  [description], \n";
			cmdbatch += "  [securityToken], \n";
			cmdbatch += "  [flag] \n";
			cmdbatch += "FROM \n";
			cmdbatch += "  [UDO_publishers] \n";
			cmdbatch += "WHERE \n";
			cmdbatch += "  ([publisherID] NOT IN (SELECT [publisherID] FROM [UDO_operators])) \n";
			cmdbatch += "ORDER BY \n";
			cmdbatch += "  [publisherID] ASC \n";

			SqlCommand command = new SqlCommand( cmdbatch );
			command.Connection = connection;

			SqlDataReader reader;

			try
			{
				reader = command.ExecuteReader();
			}
			catch ( Exception e )
			{
				Log( "ERROR: " + e.ToString(), LogType.ConsoleAndLog );
				throw new ApplicationException( "GetPublisherList failed." );
			}

			return reader;
		}

		private static SqlDataReader GetCompleteTModelList( SqlConnection connection )
		{
			string cmdbatch = "";
			cmdbatch += "SELECT \n";
			cmdbatch += "  TM.[tModelKey], \n";
			cmdbatch += "  PU.[PUID], \n";
			cmdbatch += "  PU.[email] \n";
			cmdbatch += "FROM \n";
			cmdbatch += "  [UDC_tModels] TM \n";
			cmdbatch += "    JOIN [UDO_publishers] PU ON TM.[publisherID] = PU.[publisherID] \n";
			cmdbatch += "ORDER BY \n";
			cmdbatch += "  [tModelID] ASC \n";

			SqlCommand command = new SqlCommand( cmdbatch );
			command.Connection = connection;

			SqlDataReader reader;
			try
			{
				reader = command.ExecuteReader();
			}
			catch( Exception e )
			{
				Log( "ERROR: " + e.ToString(), LogType.ConsoleAndLog );
				throw new ApplicationException( "GetCompleteTModelList failed." );
			}

			return reader;
		}

		private static SqlDataReader GetHiddenTModelList( SqlConnection connection )
		{
			string cmdbatch = "";
			cmdbatch += "SELECT \n";
			cmdbatch += "  TM.[tModelKey], \n";
			cmdbatch += "  PU.[PUID], \n";
			cmdbatch += "  PU.[email] \n";
			cmdbatch += "FROM \n";
			cmdbatch += "  [UDC_tModels] TM \n";
			cmdbatch += "    JOIN [UDO_publishers] PU ON TM.[publisherID] = PU.[publisherID] \n";
			cmdbatch += "WHERE \n";
			cmdbatch += "  ( TM.[flag] = 1 ) \n";
			cmdbatch += "ORDER BY \n";
			cmdbatch += "  [tModelID] ASC \n";

			SqlCommand command = new SqlCommand( cmdbatch );
			command.Connection = connection;

			SqlDataReader reader;
			try
			{
				reader = command.ExecuteReader();
			}
			catch( Exception e )
			{
				Log( "ERROR: " + e.ToString(), LogType.ConsoleAndLog );
				throw new ApplicationException( "GetCompleteTModelList failed." );
			}

			return reader;
		}

		private static SqlDataReader GetBusinessEntityList( SqlConnection connection )
		{
			string cmdbatch = "";
			cmdbatch += "SELECT \n";
			cmdbatch += "  BE.[businessKey], \n";
			cmdbatch += "  PU.[PUID], \n";
			cmdbatch += "  PU.[email] \n";
			cmdbatch += "FROM \n";
			cmdbatch += "  [UDC_businessEntities] BE \n";
			cmdbatch += "    JOIN [UDO_publishers] PU ON BE.[publisherID] = PU.[publisherID] \n";
			cmdbatch += "ORDER BY \n";
			cmdbatch += "  [businessID] ASC \n";

			SqlCommand command = new SqlCommand( cmdbatch );
			command.Connection = connection;

			SqlDataReader reader;

			try
			{
				reader = command.ExecuteReader();
			}
			catch( Exception e )
			{
				Log( "ERROR: " + e.ToString(), LogType.ConsoleAndLog );
				throw new ApplicationException( "GetBusinessEntityList failed." );
			}

			return reader;
		}

		private static SqlDataReader GetTaxonomyList( SqlConnection connection )
		{
			string cmdbatch = "";
			cmdbatch += "SELECT \n";
			cmdbatch += "  [tModelKey], \n";
			cmdbatch += "  [flag] \n";
			cmdbatch += "FROM \n";
			cmdbatch += "  [UDT_taxonomies] \n";
			cmdbatch += "ORDER BY \n";
			cmdbatch += "  [taxonomyID] ASC \n";

			SqlCommand command = new SqlCommand( cmdbatch );
			command.Connection = connection;

			SqlDataReader reader;
			try
			{
				reader = command.ExecuteReader();
			}
			catch( Exception e )
			{
				Log( "ERROR: " + e.ToString(), LogType.ConsoleAndLog );
				throw new ApplicationException( "GetCompleteTModelList failed." );
			}

			return reader;
		}

		private static bool CategorizationSchemeExists( string tmodelkey )
		{
			bool bExists = false;

			ConnectionManager.Open( true, false );

			SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor( "net_taxonomy_get" );

			sp.Parameters.Add( "@tModelKey", SqlDbType.UniqueIdentifier );
			sp.Parameters.Add( "@flag", SqlDbType.Int, ParameterDirection.InputOutput );

			sp.Parameters.SetGuidFromString( "@tModelKey", tmodelkey );
			sp.Parameters.SetNull( "@flag" );

			try
			{
				sp.ExecuteNonQuery();
				bExists = true;
			}
			catch( System.Data.SqlClient.SqlException se )
			{
				switch ( se.Number - UDDI.Constants.ErrorTypeSQLOffset )
				{
					case (int) ErrorType.E_invalidKeyPassed :
						// E_invalidKey: taxonomy does not exist on writer
						bExists = false;
						break;

					default:
						throw se;
				}		

			}
			catch( Exception e )
			{
				throw e;
			}
			finally
			{
				ConnectionManager.Close();
			}
			
			return bExists;
		}


		private static void FixTModel( TModel tmodel, string email )
		{
			bool changed = false;
			string change = "";

			string oldtmodel = Deserialize( UDDI.EntityType.TModel, tmodel );

			//
			// Fix null tModelKey in identifierBags
			//

			for( int i=0; i < tmodel.IdentifierBag.Count; i++ )
				if( null == tmodel.IdentifierBag[ i ].TModelKey )
				{
					tmodel.IdentifierBag[ i ].TModelKey = Config.GetString( "TModelKey.GeneralKeywords" );
					changed = true;
					change += "tModel/identifierBag/keyedReference/@tModelKey {" + (i + 1).ToString() + "};";
				}

			//
			// Delete invalid references to checked taxonomies in identifierBags
			//

			for( int i=0; i < tmodel.IdentifierBag.Count; i++ )
			{
				ConnectionManager.Open( true, false );

				SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor();

				sp.ProcedureName = "net_identifierBag_validate";

				sp.Parameters.Add( "@keyValue", SqlDbType.NVarChar, UDDI.Constants.Lengths.KeyValue );
				sp.Parameters.Add( "@tModelKey", SqlDbType.UniqueIdentifier );

				sp.Parameters.SetString( "@keyValue", tmodel.IdentifierBag[ i ].KeyValue );
				sp.Parameters.SetGuidFromKey( "@tModelKey", tmodel.IdentifierBag[ i ].TModelKey );

				try
				{
					sp.ExecuteNonQuery();
				}
				catch( System.Data.SqlClient.SqlException se )
				{
					switch ( se.Number )
					{
						case 70200 :
							// E_invalidValue: bad categorization detected, delete keyedReference
							changed = true;
							change += "tModel/identifierBag/keyedReference {" + (i + 1).ToString() + "}; ";
							tmodel.IdentifierBag.Remove( tmodel.IdentifierBag[ i ] );
							
							i--;
							break;

						case 50009 :
							// E_subProcFailure
							break;

						default:
							throw se;
					}		

				}
				catch( Exception e )
				{
					throw e;
				}
				finally
				{
					ConnectionManager.Close();
				}
			}
			 
			if( changed )
				WriteException( email, UDDI.EntityType.TModel, tmodel.TModelKey, oldtmodel, Deserialize( UDDI.EntityType.TModel, tmodel ), change );

			return;
		}

		private static void FixBusiness( BusinessEntity business, string email, bool logExceptions )
		{
			bool changed = false;
			string change = "";

			string oldbusiness = Deserialize( UDDI.EntityType.BusinessEntity, business );

			//
			// Fix businessEntities with no names
			//

			if( 0 == business.Names.Count )
			{
				string name = "unspecified";
				business.Names.Add( "en", name );
				changed = true;
				change += "businessEntity/name {1); ";
			}

			//
			// Fix null tModelKey and / or keyValue in identifierBags
			//

			for( int i=0; i < business.IdentifierBag.Count; i++ )
			{
				if( null == business.IdentifierBag[ i ].TModelKey )
				{
					business.IdentifierBag[ i ].TModelKey = Config.GetString( "TModelKey.GeneralKeywords" );
					changed = true;
				}

				if( null == business.IdentifierBag[ i ].KeyValue )
				{
					business.IdentifierBag[ i ].KeyValue = "";
					changed = true;
				}

				if( changed )
				{
					change += "businessEntity/identifierBag/keyedReference/@tModelKey {" + (i + 1).ToString() + "}; ";
				}
			}

			//
			// Fix personName elements that do not meet minumum length requirements
			//

			for( int i=0; i < business.Contacts.Count; i++ )
			{
				if( StringEmpty2( business.Contacts[ i ].PersonName ) )
				{
					business.Contacts[ i ].PersonName = EmptyPersonName;
					changed = true;
					change += "businessEntity/contact/personName {" + (i + 1).ToString() + "};";
				}
			}

			//
			// Fix bindingTemplates with null accessPoint and hostingRedirector
			//

			for( int i=0; i < business.BusinessServices.Count; i++ )
			{
				for( int j=0; j < business.BusinessServices[ i ].BindingTemplates.Count; j++ )
				{
					if( Utility.StringEmpty( business.BusinessServices[ i ].BindingTemplates[ j ].HostingRedirector.BindingKey ) && Utility.StringEmpty( business.BusinessServices[ i ].BindingTemplates[ j ].AccessPoint.Value ) )
					{
						business.BusinessServices[ i ].BindingTemplates[ j ].AccessPoint.Value = EmptyAccessPoint;
						changed = true;
						change += "businessEntity/businessServices/businessService/bindingTemplates/bindingTemplate/accessPoint {" + (j + 1).ToString() + "};";
					}
				}
			}

			//
			// Delete invalid references to checked taxonomies in categoryBags
			//

			for( int i=0; i < business.CategoryBag.Count; i++ )
			{
				ConnectionManager.Open( true, false );

				SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor();

				sp.ProcedureName = "net_categoryBag_validate";

				sp.Parameters.Add( "@keyValue", SqlDbType.NVarChar, UDDI.Constants.Lengths.KeyValue );
				sp.Parameters.Add( "@tModelKey", SqlDbType.UniqueIdentifier );

				sp.Parameters.SetString( "@keyValue", business.CategoryBag[ i ].KeyValue );
				sp.Parameters.SetGuidFromKey( "@tModelKey", business.CategoryBag[ i ].TModelKey );

				try
				{
					sp.ExecuteNonQuery();
				}
				catch( System.Data.SqlClient.SqlException se )
				{
					switch ( se.Number )
					{
						case 70200 :
							// E_invalidValue: bad categorization detected, delete keyedReference
							changed = true;
							change += "businessEntity/categoryBag/keyedReference {" + (i + 1).ToString() + "}; ";
							business.CategoryBag.Remove( business.CategoryBag[ i ] );
							
							i--;
							break;

						case 50009 :
							// E_subProcFailure
							break;

						default:
							throw se;
					}		

				}
				catch( Exception e )
				{
					throw e;
				}
				finally
				{
					ConnectionManager.Close();
				}
			}

			//
			// Delete invalid references to checked taxonomies in identifierBags
			//

			for( int i=0; i < business.IdentifierBag.Count; i++ )
			{
				ConnectionManager.Open( true, false );

				SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor();

				sp.ProcedureName = "net_identifierBag_validate";

				sp.Parameters.Add( "@keyValue", SqlDbType.NVarChar, UDDI.Constants.Lengths.KeyValue );
				sp.Parameters.Add( "@tModelKey", SqlDbType.UniqueIdentifier );

				sp.Parameters.SetString( "@keyValue", business.IdentifierBag[ i ].KeyValue );
				sp.Parameters.SetGuidFromKey( "@tModelKey", business.IdentifierBag[ i ].TModelKey );

				try
				{
					sp.ExecuteNonQuery();
				}
				catch( System.Data.SqlClient.SqlException se )
				{
					switch ( se.Number )
					{
						case 70200 :
							// E_invalidValue: bad categorization detected, delete keyedReference
							changed = true;
							change += "businessEntity/identifierBag/keyedReference {" + (i + 1).ToString() + "}; ";
							business.IdentifierBag.Remove( business.IdentifierBag[ i ] );
							
							i--;
							break;

						case 50009 :
							// E_subProcFailure
							break;

						default:
							throw se;
					}		

				}
				catch( Exception e )
				{
					throw e;
				}
				finally
				{
					ConnectionManager.Close();
				}
			}

			//
			// Fix dangling @hostingRedirectors
			//

			for( int i=0; i < business.BusinessServices.Count; i++ )
			{
				for( int j=0; j < business.BusinessServices[ i ].BindingTemplates.Count; j++ )
				{
					BindingTemplate binding = business.BusinessServices[ i ].BindingTemplates[ j ];

					if( null != binding.HostingRedirector.BindingKey )
					{
						ConnectionManager.Open( true, false );

						SqlStoredProcedureAccessor sp2 = new SqlStoredProcedureAccessor();

						sp2.ProcedureName = "net_key_validate";

						sp2.Parameters.Add( "@entityTypeID", SqlDbType.TinyInt );
						sp2.Parameters.Add( "@entityKey", SqlDbType.UniqueIdentifier );

						sp2.Parameters.SetShort( "@entityTypeID", (short)EntityType.BindingTemplate );
						sp2.Parameters.SetGuidFromString( "@entityKey", binding.HostingRedirector.BindingKey );

						try
						{
							sp2.ExecuteNonQuery();
						}
						catch( System.Data.SqlClient.SqlException se )
						{
							switch( se.Number - UDDI.Constants.ErrorTypeSQLOffset )
							{
								case (int) ErrorType.E_invalidKeyPassed:
									//
									// Bad hostingRedirector detected
									//
									changed = true;
									change += "businessEntity/businessServices/bindingTemplates/bindingTemplate/hostingRedirector/@bindingKey {" + (i + 1).ToString() + "}; ";
									binding.AccessPoint.Value = "unspecified (previously hostingRedirector/@bindingKey = " + binding.HostingRedirector.BindingKey.ToString() + ")";
									binding.HostingRedirector.BindingKey = null;
									break;

								default:
									throw se;
							}
						}
						catch( Exception e )
						{
							throw e;
						}
						finally
						{
							ConnectionManager.Close();
						}
					}
				}
			}

			if( changed  && logExceptions )
				WriteException( email, UDDI.EntityType.BusinessEntity, business.BusinessKey, oldbusiness, Deserialize( UDDI.EntityType.BusinessEntity, business ) , change );

			return;
		}

		private static Version GetDbVersion( string connectionstring )
		{			
			
			Version siteversion;
			Version dbversion;

			//
			// Get Site.Version config item
			//

			if( connectionstring == WriterConnectionString )
			{
				// Use standard config against writer
				UDDI.Diagnostics.Debug.VerifySetting( "Site.Version" );
				siteversion = new Version( Config.GetString( "Site.Version" ) );
			}
			else // connectionstring == ReaderConnectionString
			{
				// Standard config routines only support writer
				// We need to get the config setting from reader so use a different approach
				siteversion = new Version( GetReaderConfigValue( "Site.Version" ) );
			}

			if( siteversion.CompareTo( V2RC0SITE ) < 0 )
			{
				throw new ApplicationException( "Unsupported UDDI Services Site Version detected: " + siteversion.ToString() );
			}
			
			//
			// Get Database.Version config item
			//

			if( siteversion.CompareTo( V2RC0SITE ) == 0 )
			{
				//
				// Indicates an RC0 (Qwest) build of UDDI Services for Windows Server 2003
				// Note: The Database.Verison config item did not exist in RC0 so we use Site.Version instead
				// Note: This is the earliest version of UDDI Services supported by the migration tool
				//

				dbversion = V2RC0;
			}
			else if( siteversion.CompareTo( V2RC1SITE ) == 0 )
			{
				//
				// Indicates an RC1 build of UDDI Services for Windows Server 2003
				// Note: The Database.Verison config item did not exist in RC1 so we use Site.Version instead
				// Note: This is the earliest version of UDDI Services supported by the migration tool
				//

				dbversion = V2RC1;
			}
			else
			{
				//
				// Indicates a post-RC1 build of UDDI Services for Windows Server 2003
				//

				if( connectionstring == WriterConnectionString )
				{
					// Use standard config against writer
					UDDI.Diagnostics.Debug.VerifySetting( "Database.Version" );
					dbversion = new Version( Config.GetString( "Database.Version" ) );
				}
				else // connectionstring == ReaderConnectionString
				{
					// Standard config routines only support writer
					// We need to get the config setting from reader so use a different approach
					dbversion = new Version( GetReaderConfigValue( "Database.Version" ) );
				}

			}

			//
			// Evalutate database version
			//

			switch( dbversion.ToString() )
			{
				case V2RC0STR:
				case V2RC1STR:
				case V2RC2STR:
					break;

				case V2RTMSTR:
					// 
					// TODO: this will change when we ship RTM
					//
					throw new ApplicationException( "UDDI Services Database Version " + dbversion.ToString() + " is not currently supported by this tool." );

				default:
					throw new ApplicationException( "Unsupported UDDI Services Database Version detected: " + dbversion.ToString() );
			}

			Log( "UDDI Services Database Version detected: " + dbversion.ToString() + "; connection: " + connectionstring, LogType.LogOnly );

			return dbversion;
		}
		
		private static string GetReaderConfigValue( string configname )
		{
			string configvalue = null;
			
			SqlConnection connection = new SqlConnection( ReaderConnectionString );
			connection.Open();

			try
			{

				SqlCommand sp = new SqlCommand( "net_config_get", connection );
				sp.CommandType = CommandType.StoredProcedure;

				SqlDataReader reader = sp.ExecuteReader();	

				while( reader.Read() )
				{
					if( configname.ToUpper() == ( reader.IsDBNull( 0 ) ? null : reader.GetString( 0 ).ToUpper() ) )
					{
						configvalue = reader.IsDBNull( 1 ) ? null : reader.GetString( 1 );
						break;
					}
				}

				reader.Close();
			}
			catch( Exception e )
			{
				throw new ApplicationException( "Execute of net_config_get failed. Error: " + e.ToString() );
			}
			finally
			{
				connection.Close();
			}

			if( null == configvalue )
			{
				throw new ApplicationException( "Unknown configName requested: " + configname );
			}

			return configvalue;
		}

		private static string GetResource( string name )
		{
			try
			{
				Assembly assembly = Assembly.GetExecutingAssembly();

				//
				// Read the resource.
				//
				Log( "Reading resource: " + name, LogType.LogOnly );
				Stream stream = assembly.GetManifestResourceStream( name );
				StreamReader reader = new StreamReader( stream );

				return reader.ReadToEnd();
			}
			catch ( Exception e )
			{
				throw new ApplicationException( "Unable to get resource for: " + name + "; error: " + e.ToString() );
			}
		}

		private static void ExecuteScript( string connectionstring, string scriptname )
		{
			string script = GetResource( scriptname );
				
			Log( "Executing script " + scriptname + " on connection: " + connectionstring, LogType.LogOnly );
			
			//
			// Scripts are comprised of multiple batches separated by "GO".
			// The SQL managed provider does not recognize this convention,
			// so this code must handle batching manually
			//

			string buffer = "";

			for( int i=0; i <= ( script.Length - 1 ); i++ )
			{
				buffer = buffer + script[ i ].ToString();

				//
				// Detect 'G' + 'O' + whitespace at beginning of script
				//
				if( ( 2 == i ) && ( 'G' == Char.ToUpper( script[ i - 2 ] ) ) && ( 'O' == Char.ToUpper( script[ i - 1 ] ) ) && ( Char.IsWhiteSpace( script[ i ] ) ) )
				{
					//
					// This case can be ignored since no commands exist in the batch
					//
					buffer = "";
					continue;
				}

				//
				// Detect whitespace + 'G' + 'O' + whitespace inside script
				// Note: case whitespace + 'G' + 'O' at end of script is handled automatically
				//
				if( ( 2 < i ) && ( Char.IsWhiteSpace( script[ i - 3 ] ) ) && ( 'G' == Char.ToUpper( script[ i - 2 ] ) ) && ( 'O' == Char.ToUpper( script[ i - 1 ] ) ) && ( Char.IsWhiteSpace( script[ i ] ) ) )
				{
					RunBatch( connectionstring, buffer );
					buffer = "";
				}
			}

			if( buffer.Length > 0 )
			{
				RunBatch( connectionstring, buffer );
			}
		}

		private static void RunBatch( string connectionstring, string batch )
		{
			batch = batch.Trim();

			//
			// Strip "GO" off end of batch if it exists
			//
			
			if( ( 3 < batch.Length ) && Char.IsWhiteSpace( batch[ batch.Length - 3 ] ) && ( batch.EndsWith( "GO" ) ) )
			{
				batch = batch.Substring( 0, batch.Length - 2 );
			}

			batch = batch.Trim();

			if( batch.Length == 0 )
				return;

			SqlConnection connection = new SqlConnection( connectionstring );
			connection.Open();
			SqlCommand command = new SqlCommand( batch, connection );

			try
			{
				command.ExecuteNonQuery();
			}
			catch( Exception e )
			{
				throw new ApplicationException( "Attempt to execute batch failed: " + e.ToString() );
			}
			finally
			{
				connection.Close();
			}
		}

		private static void WriteException( string email, EntityType entitytype, string entitykey, string oldxml, string newxml, string change )
		{
			Exceptions++;

			Log( "Logging exception number " + Exceptions.ToString( "0000" ) + " to exceptions file.", LogType.LogOnly );

			if( !Directory.Exists( ExceptionDirName ) )
				Directory.CreateDirectory( ExceptionDirName );

			//
			// Write a new record to exceptions file
			//

			string oldfilename = ExceptionDirName + "\\" + Exceptions.ToString( "0000" ) + "_old_" + entitykey + ".xml";
			oldfilename = oldfilename.Replace( ':', '-' );

			string newfilename = ExceptionDirName + "\\" + Exceptions.ToString( "0000" ) + "_new_" + entitykey + ".xml";
			newfilename = newfilename.Replace( ':', '-' );
			
			string exceptionRecord="";
			exceptionRecord += Exceptions.ToString() + "\t";
			exceptionRecord += email + "\t";
			exceptionRecord += entitytype.ToString() + "\t";
			exceptionRecord += entitykey + "\t";
			exceptionRecord += oldfilename + "\t";
			exceptionRecord += newfilename + "\t";
			exceptionRecord += change;

			FileStream exceptionfile = new FileStream( ExceptionFileName, FileMode.Append );
			StreamWriter stream = new StreamWriter( exceptionfile );
			stream.WriteLine( exceptionRecord );
			stream.Close();
			exceptionfile.Close();

			//
			// Write old and new entities out to exception directory
			//

			Log( "Creating exception file: " + oldfilename, LogType.LogOnly );
			
			FileStream oldfile = new FileStream( oldfilename, FileMode.CreateNew );
			stream = new StreamWriter( oldfile );
			stream.Write( oldxml );
			stream.Close();
			oldfile.Close();

			Log( "Creating exception file: " + newfilename, LogType.LogOnly );

			FileStream newfile = new FileStream( newfilename, FileMode.CreateNew );
			stream = new StreamWriter( newfile );
			stream.Write( newxml );
			stream.Close();
			newfile.Close();

			return;
		}

		private static string CheckForSlash( string str )
		{
			if( !str.EndsWith( @"\" ) )
			{
				return ( str + @"\" );
			}

			return str;
		}

		private static string Deserialize( EntityType entitytype, object entity )
		{
			XmlSerializer serializer;
			string payload;

			switch( entitytype )
			{
				case EntityType.BusinessEntity:
					serializer = new XmlSerializer( typeof( BusinessEntity ) );
					break;
				case EntityType.TModel:
					serializer = new XmlSerializer( typeof( TModel ) );
					break;
				default:
					throw new ApplicationException( "Invalid entitytype in WriteException()." );			
			}
			
			XmlSerializerNamespaces namespaces = new XmlSerializerNamespaces();
			UTF8EncodedStringWriter stringWriter = new UTF8EncodedStringWriter();
			
			try
			{
				namespaces.Add( "", "urn:uddi-org:api_v2" );

				serializer.Serialize( stringWriter, entity, namespaces );
				payload = stringWriter.ToString();
			}
			finally
			{
				stringWriter.Close();
			}


			return payload;
		}

		private static void Log( string message, LogType logType )
		{
			switch ( logType )
			{
				case LogType.ConsoleAndLog:
					Console.WriteLine( message );
					Stream.WriteLine( "{0}: {1}", DateTime.Now.ToLongTimeString(), message );
					break;
				case LogType.ConsoleOnly:
					Console.WriteLine( message );
					break;
				case LogType.LogOnly:
					if( Verbose )
						Console.WriteLine( message );

					Stream.WriteLine( "{0}: {1}", DateTime.Now.ToLongTimeString(), message );
					break;
			}
		}
		
		private static void DisplayUsage()
		{
			Log( "Migrates data from UDDI V1.5 to UDDI V2.0", LogType.ConsoleOnly );
			Log( "Output is logged to " + LogFileName + "\n", LogType.ConsoleOnly );
			Log( "migrate [-?] [-s migrationstage] [-c readerconnectstring] [-v] [-i] \n", LogType.ConsoleOnly );
			Log( "  [?]: Display usage information ", LogType.ConsoleOnly );
			Log( "  [-s migrationstage]: Use one of the following values for migrationstage: ", LogType.ConsoleOnly );
			Log( "     SetReaderConnection: Sets ReaderConnectionString in registry", LogType.ConsoleOnly );
			Log( "        Note: Reference a V2.0 db loaded with V1.5 data", LogType.ConsoleOnly );
			Log( "        Note: Requires -c argument", LogType.ConsoleOnly );
			Log( "     ResetWriter: Resets publishers, tModels and businessEntities on write db", LogType.ConsoleOnly );
			Log( "     MigratePublishers: Migrates publisher accounts from read to write db", LogType.ConsoleOnly );
			Log( "     MigrateBareTModels: Migrates bare TModels from read to write db", LogType.ConsoleOnly );
			Log( "     BootstrapResources: Bootstraps all resources in \\uddi\\bootstrap", LogType.ConsoleOnly );
			Log( "     MigrateCategorizationSchemes: Migrates categorization schemes from read to write db", LogType.ConsoleOnly );
			Log( "     MigrateFullTModels: Migrates full TModels from read to write db", LogType.ConsoleOnly );
			Log( "     MigrateHiddenTModels: Migrates hidden TModels from read to write db", LogType.ConsoleOnly );
			Log( "     MigrateBusinessEntities: Migrates businessEntities from read to write db", LogType.ConsoleOnly );
			Log( "     MigratePublisherAssertions: Migrates publisher assertions from read to write db", LogType.ConsoleOnly );
			Log( "     RestoreReaderConnection: Restores original ReaderConnectionString", LogType.ConsoleOnly );
			Log( "  [-c readerconnectstring]: Used to specify a ReaderConnectionString", LogType.ConsoleOnly );
			Log( "     Note: use only with -s SetReaderConnection", LogType.ConsoleOnly );
			Log( "     Note: must use double-quotes around connection string", LogType.ConsoleOnly );
			Log( "  [-v]: Verbose output to console.", LogType.ConsoleOnly );
			Log( "  [-i]: Initialize log file.\n", LogType.ConsoleOnly );
			Log( "Examples:", LogType.ConsoleOnly );
			Log( "  migrate -?", LogType.ConsoleOnly );
			Log( "  migrate -s SetReaderConnection ", LogType.ConsoleOnly );
			Log( "    -c \"Data Source=SRV;Initial Catalog=DB;Integrated Security=SSPI\" -i", LogType.ConsoleOnly );
			Log( "  migrate -s ResetWriter", LogType.ConsoleOnly );
			Log( "  migrate -s MigratePublishers", LogType.ConsoleOnly );
			Log( "  migrate -s MigrateBareTModels", LogType.ConsoleOnly );
			Log( "  migrate -s BootstrapResources", LogType.ConsoleOnly );
			Log( "  migrate -s MigrateCategorizationSchemes", LogType.ConsoleOnly );
			Log( "  migrate -s MigrateFullTModels", LogType.ConsoleOnly );
			Log( "  migrate -s MigrateHiddenTModels", LogType.ConsoleOnly );
			Log( "  migrate -s MigrateBareBusinessEntities", LogType.ConsoleOnly );
			Log( "  migrate -s MigrateBusinessEntities", LogType.ConsoleOnly );
			Log( "  migrate -s MigratePublisherAssertions", LogType.ConsoleOnly );
			Log( "  migrate -s RestoreReaderConnection", LogType.ConsoleOnly );
		}

		private static bool StringEmpty2( string str )
		{
			if( null == str )
				return true;
			#if never
			if( 0 == str.Trim().Length )
				return true;
			#endif

			return false;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\tools\rcf\rcf.cs ===
using System;
using System.Net;
using System.Collections;
using System.Data;
using System.IO;
using System.Security.Principal;
using System.Security.Cryptography.X509Certificates;
using System.Text;
using System.Threading;
using System.Xml;
using System.Xml.Schema;
using System.Xml.Serialization;
using System.Web.Services;
using System.Web.Services.Description;
using System.Web.Services.Protocols;

using UDDI;
using UDDI.Replication;
using UDDI.Diagnostics;

namespace UDDI.Tools
{
	public class ReplicationConfigurationUtility
	{
		private static string executable = System.AppDomain.CurrentDomain.FriendlyName;
		private static string filename = null;
		private static string operatorKey = null;
		private static string rcfFile = null;

		private static bool overwrite = false;
		
		private enum ModeType
		{
			None						= 0,
			ImportOperatorCertificate	= 1,
			ExportOperatorCertificate	= 2,
			ImportRCF					= 3
		}

		private static ModeType mode = ModeType.None;
		
		/// ****************************************************************
		///   internal ProcessCommandLine [static]
		/// ----------------------------------------------------------------
		///   <summary>
		///     Parse the command-line.
		///   </summary>
		/// ----------------------------------------------------------------
		///   <param name="args">
		///     Command-line arguments.
		///   </param>
		/// ****************************************************************
		internal static void ProcessCommandLine( string[] args )
		{
			int i = 0;
		
			while( i < args.Length )
			{
				if( '-' == args[i][0] || '/' == args[i][0] )
				{
					//
					// Process the switch.
					//
					switch( args[i].Substring( 1 ).ToLower() )
					{
						case "i":
							if( i == args.Length - 1 )
								throw new CommandLineException( "Missing required argument 'certfile'." );
						
							mode = ModeType.ImportOperatorCertificate;
						
							i ++;
							filename = args[i];

							if( !File.Exists( filename ) )
								throw new CommandLineException( "Certificate file '" + filename + "' does not exist." );

							break;

						case "e":
							if( i == args.Length - 1 )
								throw new CommandLineException( "Missing required argument 'certfile'." );
						
							mode = ModeType.ExportOperatorCertificate;
						
							i ++;
							filename = args[i];

							break;

						case "o":
							if( i == args.Length - 1 )
								throw new CommandLineException( "Missing required argument 'operatorkey'." );
						
							i ++;
							operatorKey = args[i];

							//
							// strip {'s and }'s
							//
							operatorKey = operatorKey.Replace("{", string.Empty);
							operatorKey = operatorKey.Replace("}", string.Empty);

							break;
						case "r":
							if( i == args.Length - 1 )
							{
								throw new CommandLineException( "Missing required argument 'path to RCF file'." );
							}
							i ++;
							rcfFile = args[i];
							mode = ModeType.ImportRCF;

							if( !File.Exists( rcfFile ) )
								throw new CommandLineException( "RCF file '" + rcfFile + "' does not exist." );

							break;
						case "y":
							overwrite = true;
							break;

						case "?":
							goto case "help";

						case "help":
							throw new CommandLineException( "" );

						default:
							throw new CommandLineException( "Unknown command-line parameter '" + args[i] + "'." );
					}
				}
		
				i ++;
			}

			//
			// Make sure the appropriate options were set.
			//
			//if()
			//	throw new CommandLineException( "Missing required command-line parameters." );
		}

		public static void ImportOperatorCertificate()
		{
			X509Certificate certificate = X509Certificate.CreateFromCertFile( filename );
			SaveOperatorInfo( operatorKey, certificate );
		}
		
		public static void ImportRCF()
		{		
			FileStream rcfStream = File.Open( rcfFile, FileMode.Open, FileAccess.Read, FileShare.Read );

			try
			{
				//
				// Validate the RCF file.
				//			
				SchemaCollection.Validate( rcfStream );
	
				//	
				//
				// Open our RCF file, it has already been checked to make sure it exists.
				// 					
				XmlTextReader rcfReader = new XmlTextReader( rcfStream );
				
				while( true == rcfReader.Read() && false == rcfReader.EOF )
				{
					if( rcfReader.Name.Equals( "operator" ) && rcfReader.NamespaceURI.Equals( UDDI.Replication.Constants.Namespace ) )
					{							
						//
						// For each operator node, we want the following information.  These are all
						// mandatory elements, so if any were missing we should not have passed schema
						// validation.
						//
						//	operatorNodeID (this is the operatorKey)
						//  operatorStatus
						//  soapReplicationUrl
						//  certificate
						//  operatorCustodyName (operatorName)
						//

						//
						// Note that contacts are currently being ignored.  This is because we are not sending
						// the businessKey for the operator.  Since we store contacts based on businessKey (actually businessID)
						// we do not have a way of storing contacts.  IN 70 says that the operatorNodeID should actually be this
						// businessKey, so once we decide to implement this, we'll process contacts.
						//
						
						X509Certificate certificate		   = null;
						string			operatorKey        = null;
						string			operatorName       = null;
						string			soapReplicationUrl = null;
						int				operatorStatus     = 0;
						string			localOperatorKey   = Config.GetString( "OperatorKey" ).ToLower();

						do
						{
							switch( rcfReader.Name )
							{
								case "operatorNodeID":
								{
									operatorKey = rcfReader.ReadElementString();
									break;
								}
								case "operatorCustodyName":
								{
									operatorName = rcfReader.ReadElementString();
									break;
								}
								case "operatorStatus":
								{
								
									operatorStatus = OperatorStatus2ID( rcfReader.ReadElementString() );
									break;
								}
								case "soapReplicationURL":
								{
									soapReplicationUrl = rcfReader.ReadElementString();
									break;
								}
								case "certificate":
								{
									//
									// Read our data in 1024 byte chunks.  Keep an array list of these
									// chunks.
									//
									int bytesRead = 0;
									int chunkSize = 1024;
									ArrayList chunks = new ArrayList();
									
									do
									{	
										byte[] data = new byte[ chunkSize ];										
										bytesRead = rcfReader.ReadBase64( data, 0, chunkSize );										

										if( bytesRead > 0 )
										{
											chunks.Add( data );
										}
									}while( bytesRead != 0 );
															
									//
									// Allocate a buffer to hold all of our chunks.
									//
									byte[] certificateData = new byte[ chunks.Count * chunkSize ];
								
									//
									// Copy each chunk into our buffer.  This buffer is our certificate.
									//
									int index = 0;									
									foreach( byte[] chunkData in chunks )
									{
										Array.Copy( chunkData, 0, certificateData, index, chunkData.Length );
										index += chunkData.Length;										
									}
							
									//
									// Create a certificate from our byte data.
									//
									certificate = new X509Certificate( certificateData );
									break;
								}								
							}
						}while( true == rcfReader.Read() && false == rcfReader.EOF && false == rcfReader.Name.Equals( "operator" ) );
					
						//
						// Make sure we identify the local operator.
						//
						if( false == operatorKey.ToLower().Equals( localOperatorKey ) )
						{
							//
							// Import this operator
							//						
							SaveOperatorInfo( operatorKey, operatorName, soapReplicationUrl, operatorStatus, certificate );					
							Console.WriteLine( "Successfully imported {0}.", operatorName );																						
						}
						else
						{	
							SaveOperatorInfo( null, operatorName, soapReplicationUrl, operatorStatus, certificate );					
							Console.WriteLine( "Successfully update the local operator." );																						
						}
						
					}
				}
			}
			catch( XmlException xmlException )
			{
				Console.WriteLine( "Exception processing the RCF: " );
				Console.WriteLine( "\t" );
				Console.WriteLine( xmlException.ToString() );
			}
			catch( XmlSchemaException schemaException )
			{
				Console.WriteLine( "The RCF did not pass schema validation: " );
				Console.WriteLine( "\t" );
				Console.WriteLine( schemaException.ToString() );
			}
			finally
			{
				rcfStream.Close();
			}			
		}

		public static void ExportOperatorCertificate()
		{
			if( null == operatorKey )
			{
				operatorKey = Config.GetString( "OperatorKey" );
			}

			if( File.Exists( filename ) && !overwrite )
			{
				Console.Write( "Overwrite '{0}' [y/n]? ", filename );
				int choice = Console.Read();

				if( 'y' != (char)choice && 'Y' != (char)choice )
				{
					Console.WriteLine();
					Console.WriteLine( "Operation aborted." );

					return;
				}
			}
					
			byte[] data = null;
		
			//
			// Retrieve the certificate.
			//
			SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor();

			sp.ProcedureName = "net_operator_get";

			sp.Parameters.Add( "@operatorKey", SqlDbType.UniqueIdentifier );
			sp.Parameters.SetGuidFromString( "@operatorKey", operatorKey );

			SqlDataReaderAccessor reader = sp.ExecuteReader();

			try
			{
				if( reader.Read() )
					data = reader.GetBinary( "certificate" );
			}
			finally
			{
				reader.Close();
			}
		
			FileStream file = File.Open( filename, FileMode.Create, FileAccess.Write, FileShare.None );

			try
			{
				int filesize = (int)data.Length;
			
				file.Write( data, 0, filesize );

				Console.WriteLine( "Wrote {0} byte(s) to certificate file '{1}'.\r\nSource: {{{2}}}",
					filesize,
					filename,
					operatorKey );
			}
			finally
			{
				file.Close();
			}
		}

		private static int OperatorStatus2ID( string status )
		{
			//
			// These values must match the values in UDO_operatorStatus
			//
			int id = 2;
			switch( status )
			{
				case "disable":
				{
					id = 0;
					break;
				}
				case "new":
				{
					id = 1;
					break;
				}
				case "normal":
				{	
					id = 2;
					break;
				}
				case "resigned":
				{
					id = 3;
					break;
				}
			}
		
			return id;
		}

		private static void SaveOperatorInfo( string operatorKey, X509Certificate certificate)
		{
			//
			// Default operator status to 2 (normal)
			//
			SaveOperatorInfo( operatorKey, operatorKey, null, 2, certificate );
		}

		private static void SaveOperatorInfo( string		  operatorKey, 
											  string		  operatorName,
											  string		  soapReplicationUrl,
											  int			  operatorStatus,			
											  X509Certificate certificate)
		{
			byte[] data = certificate.GetRawCertData();

			ConnectionManager.BeginTransaction();

			SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor();
			sp.ProcedureName = "net_operator_save";

			if( null == operatorKey )
			{
				//
				// Import a certificate for the local operator
				//

				operatorKey = Config.GetString( "OperatorKey" );

				sp.Parameters.Add( "@operatorKey",  SqlDbType.UniqueIdentifier );
				sp.Parameters.Add( "@certSerialNo", SqlDbType.NVarChar, UDDI.Constants.Lengths.CertSerialNo );
				sp.Parameters.Add( "@certIssuer",   SqlDbType.NVarChar, UDDI.Constants.Lengths.CertIssuer );
				sp.Parameters.Add( "@certSubject",  SqlDbType.NVarChar, UDDI.Constants.Lengths.CertSubject );
				sp.Parameters.Add( "@certificate",  SqlDbType.Image );

				sp.Parameters.SetGuidFromString( "@operatorKey", operatorKey );
				sp.Parameters.SetString( "@certSerialNo", certificate.GetSerialNumberString() );
				sp.Parameters.SetString( "@certIssuer", certificate.GetIssuerName() );
				sp.Parameters.SetString( "@certSubject", certificate.GetName() );
				sp.Parameters.SetBinary( "@certificate", data );

				sp.ExecuteNonQuery();
			}
			else
			{
				//
				// Create a new operator / publisher and import certificate
				//
				
				//
				// First add a publisher for the new operator
				//

				SqlStoredProcedureAccessor sp2 = new SqlStoredProcedureAccessor();

				sp2.ProcedureName = "UI_savePublisher";

				sp2.Parameters.Add( "@PUID", SqlDbType.NVarChar, UDDI.Constants.Lengths.UserID );
				sp2.Parameters.Add( "@name", SqlDbType.NVarChar, UDDI.Constants.Lengths.Name );
				sp2.Parameters.Add( "@email", SqlDbType.NVarChar, UDDI.Constants.Lengths.Email );
				//
				// TODO: use UDDI.Constants.Lengths.Phone when the UI_savePublisher is fixed
				//
				sp2.Parameters.Add( "@phone", SqlDbType.VarChar, 20 );

				sp2.Parameters.SetString( "@PUID", operatorKey );
				sp2.Parameters.SetString( "@name", operatorKey );
				sp2.Parameters.SetString( "@email", "" );
				sp2.Parameters.SetString( "@phone", "" );

				sp2.ExecuteNonQuery();				

				// 
				// Add the new operator and link it to the new publisher
				//	
				sp.Parameters.Add( "@operatorKey", SqlDbType.UniqueIdentifier );
				sp.Parameters.Add( "@operatorStatusID", SqlDbType.Int );
				sp.Parameters.Add( "@PUID", SqlDbType.NVarChar, UDDI.Constants.Lengths.UserID );
				sp.Parameters.Add( "@name", SqlDbType.NVarChar, UDDI.Constants.Lengths.Name );
				sp.Parameters.Add( "@soapReplicationURL", SqlDbType.NVarChar, UDDI.Constants.Lengths.SoapReplicationURL );
				sp.Parameters.Add( "@certSerialNo", SqlDbType.NVarChar, UDDI.Constants.Lengths.CertSerialNo );
				sp.Parameters.Add( "@certIssuer", SqlDbType.NVarChar, UDDI.Constants.Lengths.CertIssuer );
				sp.Parameters.Add( "@certSubject", SqlDbType.NVarChar, UDDI.Constants.Lengths.CertSubject );
				sp.Parameters.Add( "@certificate", SqlDbType.Image );

				sp.Parameters.SetGuidFromString( "@operatorKey", operatorKey );
				sp.Parameters.SetInt( "@operatorStatusID", operatorStatus );
				sp.Parameters.SetString( "@PUID", operatorKey );
				sp.Parameters.SetString( "@name", operatorName );
				sp.Parameters.SetString( "@soapReplicationURL", soapReplicationUrl );
				sp.Parameters.SetString( "@certSerialNo", certificate.GetSerialNumberString() );
				sp.Parameters.SetString( "@certIssuer", certificate.GetIssuerName() );
				sp.Parameters.SetString( "@certSubject", certificate.GetName() );
				sp.Parameters.SetBinary( "@certificate", data );

				sp.ExecuteNonQuery();						
			}

			ConnectionManager.Commit();		

			Console.WriteLine( "Wrote {0} byte(s) to operator key {{{1}}}.\r\nSource: '{2}'.",
							   data.Length,
							   operatorKey,
				               filename );
		}

		/// ****************************************************************
		///   public Main [static]
		/// ----------------------------------------------------------------	
		///   <summary>
		///     Program entry point.
		///   </summary>
		/// ----------------------------------------------------------------
		///   <param name="args">
		///     Command-line arguments.
		///   </param>
		/// ****************************************************************
		/// 
		public static void Main( string[] args )
		{
			try
			{
				ConnectionManager.Open( true, false );

				Debug.VerifySetting( "OperatorKey" );
			
				Console.WriteLine( "Microsoft (R) UDDI Replication Configuration Utility." );
				Console.WriteLine( "Copyright (C) Microsoft Corp. 2002. All rights reserved." );
				Console.WriteLine();

				WindowsIdentity identity = WindowsIdentity.GetCurrent();
				WindowsPrincipal principal = new WindowsPrincipal( identity );
			
				Context.User.SetRole( principal );
			
				if( !Context.User.IsAdministrator )
				{
					Console.WriteLine( "Access denied.\r\n\r\nThis program must be executed by a member of the '" 
						+ Config.GetString( "GroupName.Administrators" ) + "'\r\ngroup.  The current user '" 
						+ identity.Name + "' is not a member of this group." );
				
					return;
				}
			
				ProcessCommandLine( args );

				switch( mode )
				{
					case ModeType.ImportOperatorCertificate:
						ImportOperatorCertificate();
						break;

					case ModeType.ExportOperatorCertificate:
						ExportOperatorCertificate();
						break;
					case ModeType.ImportRCF:
						ImportRCF();
						break;
					default:
						throw new CommandLineException( "" );
				}
			}
			catch( CommandLineException e )
			{
				//
				// Display command-line help.
				//
				Console.WriteLine( "Syntax:" );
				Console.WriteLine( "    " + executable + " <options> [parameters]" );
				Console.WriteLine();
				Console.WriteLine( "Options:" );
				Console.WriteLine( "    -help             Displays this help message." );
				Console.WriteLine( "    -i <certfile>     Import a certificate. If the -o option is not" );
				Console.WriteLine( "                      used, the certificate is imported for the" );
				Console.WriteLine( "                      local operator." );
				Console.WriteLine( "    -e <certfile>     Export a certificate. If the -o option is not" );
				Console.WriteLine( "                      used, the certificate is exported from the" );
				Console.WriteLine( "                      local operator." );
				Console.WriteLine( "    -o <operatorkey>  The operator key to import/export a certificate" );
				Console.WriteLine( "                      Omit this parameter to import a certificate for the" );
				Console.WriteLine( "                      local operator." );
				Console.WriteLine( "    -y                Supress file overwrite prompt." );
				Console.WriteLine( "    -r <rcf>		  Path to replication configuration file (RCF)." );							
				Console.WriteLine();
				Console.WriteLine( "Examples:" );
				Console.WriteLine( "    " + executable + " -help" );
				Console.WriteLine( "    " + executable + " -o FF735874-28BD-41A0-96F3-02113FFD9D6C -i uddi.cer" );
				Console.WriteLine( "    " + executable + " -i uddi.cer" );
				Console.WriteLine( "    " + executable + " -r operators.xml" );
				Console.WriteLine();
			
				if( 0 != e.Message.Length )
					Console.WriteLine( e.Message );

				return;
			}
			catch( Exception e )
			{
				Console.WriteLine( e.ToString() );

				return;
			}
		}
	}	

	/// ****************************************************************
	///   public class CommandLineException
	/// ----------------------------------------------------------------
	///   <summary>
	///     Exception class for errors encountered while parsing the
	///     command-line.
	///   </summary>
	/// ****************************************************************
	/// 
	public class CommandLineException : ApplicationException
	{
		/// ************************************************************
		///   public CommandLineException [constructor]
		/// ------------------------------------------------------------
		///   <summary>
		///     CommandLineException constructor.
		///   </summary>
		/// ************************************************************
		/// 
		public CommandLineException()
			: base()
		{
		}

		/// ************************************************************
		///   public CommandLineException [constructor]
		/// ------------------------------------------------------------
		///   <summary>
		///     CommandLineException constructor.
		///   </summary>
		/// ------------------------------------------------------------
		///   <param name="message">
		///     Exception message.
		///   </param>
		/// ************************************************************
		/// 
		public CommandLineException( string message )
			: base( message )
		{
		}
	}	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\tools\replicationadmin\makefile.inc ===
foo.cs:
	..\..\version\$(O)\version.exe -outfile .\assemblyversioninfo.cs
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\tools\recalcstats\assemblyinfo.cs ===
using System.Reflection;
using System.Security.Permissions;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("recalcstats.exe")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft Corporation")]
[assembly: AssemblyProduct("UDDI Services")]
[assembly: AssemblyCopyright("Copyright(c) 2002 Microsoft Corporation")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]
[assembly: PermissionSetAttribute(SecurityAction.RequestMinimum, Name = "FullTrust")]


//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("")]
[assembly: AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\tools\recalcstats\recalcstats.cs ===
using System;
using System.Globalization;
using System.Data;
using System.Data.SqlClient;
using Microsoft.Win32;
using System.Resources;

namespace UDDI.Tools
{
	class Recalcstats
	{
		static SqlConnection connection;
		static SqlTransaction transaction;

		static int Main( string[] args )
		{
			int rc = 0; // assume success

			try
			{
				// 
				// Check if CurrentUICulture needs to be overridden
				//
				UDDI.Localization.SetConsoleUICulture();

				DisplayBanner();

				//
				// Parse the command line
				//
				if( !ProcessCommandLine( args ) )
				{
					return 1;
				}

				//
				// Recalculate statistics
				//
				RecalcStats();
			}
			catch( Exception e )
			{
				Console.WriteLine( FormatFromResource( "RECALCSTATS_FAILED" , e.Message ) );
				rc = 1;
			}


			return rc;
		}

		private static bool ProcessCommandLine( string [] args )
		{
			bool bOK = false;

			if ( args.Length > 0 )
			{
				for( int i = 0; i < args.Length; i ++ )
				{
					if( '-' == args[i][0] || '/' == args[i][0] )
					{
						string option = args[i].Substring( 1 );

						if( "help" == option.ToLower() || "?" == option )
						{
							DisplayUsage();
							return false;
						}
					}
				}
			}
			else
				bOK = true;

			if( !bOK )
			{
				DisplayUsage();
				return false;
			}

			return true;
		}
		
		static void DisplayBanner()
		{
			Console.WriteLine( FormatFromResource( "RECALCSTATS_COPYRIGHT_1" ) );
			Console.WriteLine( FormatFromResource( "RECALCSTATS_COPYRIGHT_2" ) );
			Console.WriteLine();
		}

		static void DisplayUsage()
		{
			Console.WriteLine( FormatFromResource( "RECALCSTATS_USAGE_1" ) );
			Console.WriteLine( FormatFromResource( "RECALCSTATS_USAGE_2" ) );
			Console.WriteLine();
		}

		static void RecalcStats()
		{
			OpenConnection();

			try
			{
				//
				// Get entity counts
				//
				Console.Write( FormatFromResource( "RECALCSTATS_GETTINGENTITYCOUNTS" ) );

				SqlCommand cmd = new SqlCommand( "UI_getEntityCounts", connection, transaction );
				cmd.CommandType = CommandType.StoredProcedure;

				cmd.ExecuteNonQuery();

				Console.WriteLine( FormatFromResource( "RECALCSTATS_DONE" ) );

				//
				// Get publisher stats
				//
				Console.Write( FormatFromResource( "RECALCSTATS_GETTINGPUBLISHERSTATS" ) );

				cmd.CommandText = "UI_getPublisherStats";
				cmd.ExecuteNonQuery();

				Console.WriteLine( FormatFromResource( "RECALCSTATS_DONE" ) );

				//
				// Get top publishers
				//
				Console.Write( FormatFromResource( "RECALCSTATS_GETTINGTOPPUBLISHERS" ) );

				cmd.CommandText = "UI_getTopPublishers";
				cmd.ExecuteNonQuery();

				Console.WriteLine( FormatFromResource( "RECALCSTATS_DONE" ) );

				//
				// Get taxonomy stats
				//
				Console.Write( FormatFromResource( "RECALCSTATS_GETTINGTAXONOMYSTATS" ) );

				cmd.CommandText = "UI_getTaxonomyStats";
				cmd.ExecuteNonQuery();

				Console.WriteLine( FormatFromResource( "RECALCSTATS_DONE" ) );

				//
				// All sprocs succeeded
				//
				Console.WriteLine( FormatFromResource( "RECALCSTATS_SUCCEEDED" ) );
			}
			finally
			{
				CloseConnection();
			}

			return;
		}

		static void OpenConnection()
		{
			try
			{
				string connectionString = (string) Registry.LocalMachine.OpenSubKey( @"SOFTWARE\Microsoft\UDDI\Database" ).GetValue( "WriterConnectionString" );
				connection = new SqlConnection( connectionString );
				connection.Open();
				transaction = connection.BeginTransaction( IsolationLevel.ReadCommitted, "recalcstats" );
			}
			catch
			{
				throw new Exception( "Unable to connect to the database" );
			}
		}

		static void CloseConnection()
		{
			transaction.Commit();
			connection.Close();
		}

		static string FormatFromResource( string resID, params object[] inserts )
		{
			try
			{
				string resourceStr = UDDI.Localization.GetString( resID );
				if( null != resourceStr )
				{
					string resultStr = string.Format( resourceStr, inserts );
					return resultStr;
				}

				return "String not specified in the resources: " + resID;
			}
			catch( Exception e )
			{
				return "FormatFromResource failed to load the resource string for ID: " + resID + " Reason: " + e.Message;
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\tools\resetkey\makefile.inc ===
foo.cs:
	..\..\version\$(O)\version.exe -outfile .\assemblyversioninfo.cs
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\tools\replicationadmin\adminframe.cs ===
using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;
using System.Security.Principal;

namespace UDDI.Tools
{
	public interface IAdminObject
	{
		void   Initialize( IAdminFrame parent );
		string GetNodeText();
		void   Show( Control parentDisplay );		
	}

	public interface IAdminFrame
	{
		void UpdateAllViews();	
	}

	public class AdminFrame : Form, IAdminFrame
	{
		private TreeView  nodesTreeView;
		private Splitter  splitter;
		private Panel     viewPanel;
		private MainMenu  mainMenu;		
		private MenuItem  fileMenuItem;
		private MenuItem  viewMenuItem;
		private MenuItem  exitMenuItem;		
		private MenuItem  refreshMenuItem;		
		
		public AdminFrame( ArrayList adminObjects )
		{
			InitializeComponent();							
		
			foreach( IAdminObject adminObject in adminObjects )
			{
				TreeNode adminNode = new TreeNode( adminObject.GetNodeText() );			
				adminNode.Tag = adminObject;
				
				try
				{
					adminObject.Initialize( this );
					nodesTreeView.Nodes.Add( adminNode );
				}
				catch( Exception e )
				{
					MessageBox.Show( string.Format( "There was an exception initializing: {0}\n\n{1}", adminObject.GetNodeText(), e.ToString() ) );
				}				
			}
		}

		public void UpdateAllViews()
		{
			foreach( TreeNode treeNode in nodesTreeView.Nodes )
			{
				IAdminObject adminObject = ( IAdminObject )treeNode.Tag;

				try
				{
					adminObject.Show( viewPanel );
				}
				catch( Exception e )
				{
					MessageBox.Show( string.Format( "There was an exception updating: {0}\n\n{1}", adminObject.GetNodeText(), e.ToString() ) );
				}
			}
		}
				
		private void InitializeComponent()
		{
			nodesTreeView	= new TreeView();
			splitter		= new Splitter();
			viewPanel		= new Panel();
			mainMenu		= new MainMenu();
			fileMenuItem	= new MenuItem();
			viewMenuItem	= new MenuItem();
			exitMenuItem	= new MenuItem();
			refreshMenuItem = new MenuItem();

			SuspendLayout();

			// 
			// nodesTreeView
			// 
			nodesTreeView.BorderStyle		 = BorderStyle.None;
			nodesTreeView.Dock				 = DockStyle.Left;
			nodesTreeView.ImageIndex		 = -1;
			nodesTreeView.Name				 = "nodesTreeView";
			nodesTreeView.SelectedImageIndex = -1;
			nodesTreeView.ShowLines			 = false;
			nodesTreeView.Size				 = new System.Drawing.Size(121, 549);
			nodesTreeView.TabIndex			 = 0;
			nodesTreeView.HotTracking		 = true;
			nodesTreeView.AfterSelect += new TreeViewEventHandler(NodesTreeView_AfterSelect);
			
			// 
			// splitter
			// 
			splitter.Location	= new System.Drawing.Point(121, 0);
			splitter.Name		= "splitter";
			splitter.Size		= new System.Drawing.Size(3, 549);
			splitter.TabIndex	= 1;
			splitter.TabStop	= false;
			
			// 
			// viewPanel
			// 			
			viewPanel.Dock		= DockStyle.Fill;
			viewPanel.Location	= new System.Drawing.Point(124, 0);
			viewPanel.Name		= "viewPanel";
			viewPanel.Size		= new System.Drawing.Size(676, 549);
			viewPanel.TabIndex	= 2;
			
			// 
			// mainMenu
			// 
			mainMenu.MenuItems.AddRange( new MenuItem[] { fileMenuItem, viewMenuItem } );
			
			// 
			// fileMenuItem
			// 
			fileMenuItem.Index = 0;
			fileMenuItem.MenuItems.AddRange(new MenuItem[] { exitMenuItem } );
			fileMenuItem.Text = "File";
			
			// viewMenuItem
			viewMenuItem.Index = 1;
			viewMenuItem.MenuItems.AddRange(new MenuItem[] { refreshMenuItem } );
			viewMenuItem.Text = "View";

			// 
			// exitMenuItem
			// 
			exitMenuItem.Index = 0;
			exitMenuItem.Text = "E&xit";
			exitMenuItem.Click += new System.EventHandler( ExitMenuItem_Click );

			//
			// refreshMenuItem
			//
			refreshMenuItem.Index = 0;
			refreshMenuItem.Text = "Refresh";
			refreshMenuItem.Click += new EventHandler( RefreshMenuItem_Click );

			// 
			// AdminFrame
			// 
			AutoScaleBaseSize = new System.Drawing.Size(5, 13);
			ClientSize = new System.Drawing.Size(705, 680);
			Controls.AddRange(new Control[] { viewPanel, splitter, nodesTreeView});
			
			Menu = mainMenu;
			Name = "AdminFrame";
			Text = "Replication Admin Tool";

			ResumeLayout(false);

			Resize += new EventHandler( AdminFrame_Resize );
		}
		
		private void AdminFrame_Resize( object sender, EventArgs eventArgs )
		{
			UpdateAllViews();
		}

		private void NodesTreeView_AfterSelect( object sender, TreeViewEventArgs treeViewArgs )
		{			
			IAdminObject adminObject = treeViewArgs.Node.Tag as IAdminObject;

			if( null == adminObject )
			{
				MessageBox.Show( "Admin node was incorrectly initialized" );
			}
			else
			{
				viewPanel.Controls.Clear();
				adminObject.Show( viewPanel );
			}
		}

		private void RefreshMenuItem_Click( object sender, EventArgs eventArgs )
		{
			this.UpdateAllViews();
		}

		private void ExitMenuItem_Click( object sender, EventArgs eventArgs )
		{
			System.Windows.Forms.Application.Exit();
		}
		
		[STAThread]
		static void Main() 
		{
			WindowsIdentity identity   = WindowsIdentity.GetCurrent();
			WindowsPrincipal principal = new WindowsPrincipal( identity );
				
			Context.User.SetRole( principal );
				
			if( !Context.User.IsAdministrator )
			{
				MessageBox.Show( "Access denied.\r\n\r\nThis program must be executed by a member of the '" 
								 + Config.GetString( "GroupName.Administrators" ) + "'\r\ngroup.  The current user '" 
								 + identity.Name + "' is not a member of this group." );					
				return;
			}

			UDDI.ConnectionManager.Open( true, false );
					
			ArrayList adminObjects = new ArrayList();

			adminObjects.Add( new CorrectionAdmin() );
			AdminFrame adminFrame = new AdminFrame( adminObjects );

			System.Windows.Forms.Application.Run( adminFrame );
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\tools\send\makefile.inc ===
foo.cs:
	..\..\version\$(O)\version.exe -outfile .\assemblyversioninfo.cs
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\tools\replicationadmin\changelogcontrol.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Drawing;
using System.Data;
using System.Windows.Forms;
using System.Xml.Serialization;

using UDDI;
using UDDI.API;
using UDDI.Replication;

namespace UDDI.Tools
{
	public class ChangeLogControl : UserControl
	{	
		public delegate void ChangeRecordSelectedHandler( bool isLocal, string changeRecordXml );
		public event		 ChangeRecordSelectedHandler ChangeRecordSelect;

		private ListView changeLogListView;
		private Splitter splitter;		
		private TextBox	 rawXmlTextBox;		
		
		public ChangeLogControl()
		{			
			InitializeComponent();
			UpdateView();			
		}
		
		public void UpdateView()
		{
			//
			// Clear our controls out
			//
			changeLogListView.Items.Clear();
			rawXmlTextBox.Text = "";

			//
			// Populate our list view with the change log.
			//			
			GetChangeRecords changeRecords = new GetChangeRecords();
			ChangeRecordDetail detail	   = changeRecords.Get();
						
			foreach( ChangeRecord changeRecord in detail.ChangeRecords )
			{	
				ListViewItem listViewItem = new ListViewItem();	

				listViewItem.Text = Convert.ToString( changeRecord.ChangeID.OriginatingUSN ); 				
				listViewItem.SubItems.Add( changeRecord.ChangeID.NodeID );															
				listViewItem.SubItems.Add( changeRecord.Payload.ChangeRecordPayloadType.ToString() );
				
				ChangeRecordTag changeRecordTag = new ChangeRecordTag();
				
				changeRecordTag.xml = changeRecord.ToString();

				if( Config.GetString( "OperatorKey" ).ToLower().Equals( changeRecord.ChangeID.NodeID.ToLower() ) )
				{
					changeRecordTag.isLocal = true;										

					if( changeRecord.Payload.ChangeRecordPayloadType == ChangeRecordPayloadType.ChangeRecordCorrection )
					{
						listViewItem.ForeColor  = Color.Gray;
					}
					else
					{
						listViewItem.ForeColor  = Color.Green;
					}
				}
				else
				{
					changeRecordTag.isLocal = false;
					listViewItem.ForeColor  = Color.Gray;
				}
				
				listViewItem.Tag = changeRecordTag;

				changeLogListView.Items.Add( listViewItem );							
			}			
		}

		public bool ShowRawXML
		{
			get
			{
				return rawXmlTextBox.Visible;
			}
			set
			{
				rawXmlTextBox.Visible = value;
			}
		}

		public ListView ChangeRecords
		{
			get
			{
				return changeLogListView;
			}
		}

		private void InitializeComponent()
		{
			this.changeLogListView	= new ListView();
			this.rawXmlTextBox		= new TextBox();
			this.splitter			= new Splitter();
			this.SuspendLayout();

			// 
			// changeLogListView
			// 			
			this.changeLogListView.Dock				= DockStyle.Top;
			this.changeLogListView.FullRowSelect	= true;
			this.changeLogListView.Name				= "changeLogListView";
			this.changeLogListView.TabIndex			= 0;
			this.changeLogListView.View				= View.Details;			
			this.changeLogListView.Columns.Add( "Originating USN", -2, HorizontalAlignment.Center );
			this.changeLogListView.Columns.Add( "Node ID", -2, HorizontalAlignment.Center );
			this.changeLogListView.Columns.Add( "Type", -2, HorizontalAlignment.Center );
			this.changeLogListView.SelectedIndexChanged += new System.EventHandler(this.ChangeLogListView_Select);
			
			// 
			// splitter
			// 
			this.splitter.Dock		= DockStyle.Top;			
			this.splitter.Name		= "splitter";			
			this.splitter.TabIndex	= 2;
			this.splitter.TabStop	= false;
			
			// 
			// rawXmlTextBox
			// 
			this.rawXmlTextBox.Dock			= DockStyle.Fill;			
			this.rawXmlTextBox.Multiline	= true;
			this.rawXmlTextBox.Name			= "rawXmlTextBox";
			this.rawXmlTextBox.ReadOnly		= true;
			this.rawXmlTextBox.ScrollBars	= ScrollBars.Both;
			this.rawXmlTextBox.Size			= new System.Drawing.Size(672, 391);
			this.rawXmlTextBox.TabIndex		= 1;
						
			// 
			// ChangeLogControl
			// 
			this.Controls.AddRange( new Control[] { this.splitter,
												    this.rawXmlTextBox,
												    this.changeLogListView } );
			this.Name = "ChangeLogControl";			
			this.ResumeLayout(false);
		}

		private void ChangeLogListView_Select( object sender, EventArgs eventArgs )
		{
			if( changeLogListView.SelectedItems.Count == 1 )
			{
				ListViewItem selectedItem = changeLogListView.SelectedItems[ 0 ];

				ChangeRecordTag changeRecordTag = ( ChangeRecordTag ) selectedItem.Tag;

				rawXmlTextBox.Text = changeRecordTag.xml;

				//
				// Fire our event.
				//
				ChangeRecordSelect( changeRecordTag.isLocal, changeRecordTag.xml );									
			}			
		}		

		private struct ChangeRecordTag
		{			
			public string xml;
			public bool   isLocal;
		}
	}	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\tools\replicationadmin\correctionadmin.cs ===
using System;
using System.Data.SqlClient;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;
using System.Xml;
using System.Xml.Serialization;
using System.IO;

using UDDI;
using UDDI.API;
using UDDI.Replication;
using UDDI.API.Binding;
using UDDI.API.ServiceType;

namespace UDDI.Tools
{
	public class CorrectionAdmin : UserControl, IAdminObject
	{		
		private XmlSerializer    changeRecordSerializer;
		
		private System.Windows.Forms.Label usnLabel;
		private System.Windows.Forms.TextBox usnTextBox;
		private System.Windows.Forms.Button usnButton;
		private System.Windows.Forms.GroupBox findGroupBox;
		private System.Windows.Forms.GroupBox changeRecordGroupBox;
		private System.Windows.Forms.TextBox changeRecordTextBox;
		private System.Windows.Forms.GroupBox correctionGroupBox;
		private System.Windows.Forms.TextBox correctionTextBox;
		private System.Windows.Forms.Button correctionButton;
		private XmlSerializer    correctionSerializer;

		public CorrectionAdmin()
		{
			changeRecordSerializer = new XmlSerializer( typeof( ChangeRecord ) );
			correctionSerializer   = new XmlSerializer( typeof( ChangeRecordCorrection ) );
		}

		public void Initialize( IAdminFrame parent )
		{		
			InitializeComponent();
		}

		public string GetNodeText()
		{
			return "Corrections";
		}		

		public void Show( Control parentDisplay )
		{				
			Parent = parentDisplay;
			Size   = parentDisplay.Size;			
		}		

		private void InitializeComponent()
		{
			this.usnLabel = new System.Windows.Forms.Label();
			this.usnTextBox = new System.Windows.Forms.TextBox();
			this.usnButton = new System.Windows.Forms.Button();
			this.findGroupBox = new System.Windows.Forms.GroupBox();
			this.changeRecordGroupBox = new System.Windows.Forms.GroupBox();
			this.changeRecordTextBox = new System.Windows.Forms.TextBox();
			this.correctionGroupBox = new System.Windows.Forms.GroupBox();
			this.correctionButton = new System.Windows.Forms.Button();
			this.correctionTextBox = new System.Windows.Forms.TextBox();
			this.findGroupBox.SuspendLayout();
			this.changeRecordGroupBox.SuspendLayout();
			this.correctionGroupBox.SuspendLayout();
			this.SuspendLayout();
			// 
			// usnLabel
			// 
			this.usnLabel.Location = new System.Drawing.Point(8, 24);
			this.usnLabel.Name = "usnLabel";
			this.usnLabel.Size = new System.Drawing.Size(48, 16);
			this.usnLabel.TabIndex = 0;
			this.usnLabel.Text = "USN:";
			// 
			// usnTextBox
			// 
			this.usnTextBox.Location = new System.Drawing.Point(56, 22);
			this.usnTextBox.Name = "usnTextBox";
			this.usnTextBox.Size = new System.Drawing.Size(112, 20);
			this.usnTextBox.TabIndex = 1;
			this.usnTextBox.Text = "";
			// 
			// usnButton
			// 
			this.usnButton.Location = new System.Drawing.Point(176, 21);
			this.usnButton.Name = "usnButton";
			this.usnButton.Size = new System.Drawing.Size(120, 23);
			this.usnButton.TabIndex = 2;
			this.usnButton.Text = "Get ChangeRecord";
			this.usnButton.Click += new System.EventHandler(this.usnButton_Click);
			// 
			// findGroupBox
			// 
			this.findGroupBox.Anchor = ((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) 
				| System.Windows.Forms.AnchorStyles.Right);
			this.findGroupBox.Controls.AddRange(new System.Windows.Forms.Control[] {
																					   this.usnLabel,
																					   this.usnButton,
																					   this.usnTextBox});
			this.findGroupBox.Location = new System.Drawing.Point(8, 8);
			this.findGroupBox.Name = "findGroupBox";
			this.findGroupBox.Size = new System.Drawing.Size(568, 56);
			this.findGroupBox.TabIndex = 3;
			this.findGroupBox.TabStop = false;
			this.findGroupBox.Text = "Find Change Record";
			// 
			// changeRecordGroupBox
			// 
			this.changeRecordGroupBox.Anchor = ((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) 
				| System.Windows.Forms.AnchorStyles.Right);
			this.changeRecordGroupBox.Controls.AddRange(new System.Windows.Forms.Control[] {
																							   this.changeRecordTextBox});
			this.changeRecordGroupBox.Location = new System.Drawing.Point(8, 72);
			this.changeRecordGroupBox.Name = "changeRecordGroupBox";
			this.changeRecordGroupBox.Size = new System.Drawing.Size(568, 280);
			this.changeRecordGroupBox.TabIndex = 4;
			this.changeRecordGroupBox.TabStop = false;
			this.changeRecordGroupBox.Text = "Change Record";
			// 
			// changeRecordTextBox
			// 
			this.changeRecordTextBox.Anchor = ((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) 
				| System.Windows.Forms.AnchorStyles.Right);
			this.changeRecordTextBox.Location = new System.Drawing.Point(8, 24);
			this.changeRecordTextBox.Multiline = true;
			this.changeRecordTextBox.Name = "changeRecordTextBox";
			this.changeRecordTextBox.ReadOnly = true;
			this.changeRecordTextBox.ScrollBars = System.Windows.Forms.ScrollBars.Both;
			this.changeRecordTextBox.Size = new System.Drawing.Size(552, 240);
			this.changeRecordTextBox.TabIndex = 0;
			this.changeRecordTextBox.Text = "";
			// 
			// correctionGroupBox
			// 
			this.correctionGroupBox.Anchor = (((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) 
				| System.Windows.Forms.AnchorStyles.Left) 
				| System.Windows.Forms.AnchorStyles.Right);
			this.correctionGroupBox.Controls.AddRange(new System.Windows.Forms.Control[] {
																							 this.correctionButton,
																							 this.correctionTextBox});
			this.correctionGroupBox.Location = new System.Drawing.Point(8, 360);
			this.correctionGroupBox.Name = "correctionGroupBox";
			this.correctionGroupBox.Size = new System.Drawing.Size(568, 304);
			this.correctionGroupBox.TabIndex = 5;
			this.correctionGroupBox.TabStop = false;
			this.correctionGroupBox.Text = "Proposed Correction";
			// 
			// correctionButton
			// 
			this.correctionButton.Anchor = (System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left);
			this.correctionButton.Enabled = false;
			this.correctionButton.Location = new System.Drawing.Point(8, 272);
			this.correctionButton.Name = "correctionButton";
			this.correctionButton.Size = new System.Drawing.Size(112, 23);
			this.correctionButton.TabIndex = 1;
			this.correctionButton.Text = "Issue Correction";
			this.correctionButton.Click += new System.EventHandler(this.correctionButton_Click);
			// 
			// correctionTextBox
			// 
			this.correctionTextBox.Anchor = (((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) 
				| System.Windows.Forms.AnchorStyles.Left) 
				| System.Windows.Forms.AnchorStyles.Right);
			this.correctionTextBox.Location = new System.Drawing.Point(8, 24);
			this.correctionTextBox.Multiline = true;
			this.correctionTextBox.Name = "correctionTextBox";
			this.correctionTextBox.ScrollBars = System.Windows.Forms.ScrollBars.Both;
			this.correctionTextBox.Size = new System.Drawing.Size(552, 240);
			this.correctionTextBox.TabIndex = 0;
			this.correctionTextBox.Text = "";
			// 
			// CorrectionAdmin
			// 
			this.Controls.AddRange(new System.Windows.Forms.Control[] {
																		  this.correctionGroupBox,
																		  this.changeRecordGroupBox,
																		  this.findGroupBox});
			this.Name = "CorrectionAdmin";
			this.Size = new System.Drawing.Size(592, 680);
			this.findGroupBox.ResumeLayout(false);
			this.changeRecordGroupBox.ResumeLayout(false);
			this.correctionGroupBox.ResumeLayout(false);
			this.ResumeLayout(false);

		}

		void usnButton_Click(object sender, System.EventArgs e)
		{
			ShowChangeRecord();			
		}		

		private bool ValidatePublisher()
		{
			bool validPublisher = Context.User.IsRegistered;
			
			//
			// Make sure the user is a UDDI publisher.
			//
			if( false == validPublisher )
			{
				DialogResult dialogResult = MessageBox.Show( "You are not registered as a publisher on this UDDI Site?  You must register before performing this operation.  Would you like to register now?", 
															 "UDDI",
															 MessageBoxButtons.YesNo );
				
				if( DialogResult.Yes == dialogResult )
				{
					try
					{
						Context.User.Register();
						validPublisher = Context.User.IsRegistered;
					}
					catch( Exception registrationException )
					{
						MessageBox.Show( "An exception occurred when trying to register:\r\n\r\n" + registrationException.ToString() );
					}
				}
			}

			return validPublisher;
		}

		private void correctionButton_Click(object sender, System.EventArgs e)
		{	
			if( false == ValidatePublisher() )
			{
				return;
			}

			try
			{
				ConnectionManager.BeginTransaction();

				//
				// Deserialize into a change record object
				//
				StringReader reader = new StringReader( correctionTextBox.Text );			

				ChangeRecordCorrection changeRecordCorrection = ( ChangeRecordCorrection ) correctionSerializer.Deserialize( reader );

				//
				// Validate what we created.
				//
				SchemaCollection.Validate( changeRecordCorrection );

				//
				// Create a new change record to hold the correction.
				//				
				ChangeRecord changeRecord = new ChangeRecord( changeRecordCorrection );														
				changeRecord.Process();						
				ConnectionManager.Commit();
				
				//
				// If we made it this far, we were able to process the correction
				// 
				MessageBox.Show( "Correction processed!" );				

				//
				// Refresh our display.
				//
				ShowChangeRecord();				
			}
			catch( Exception exception )
			{
				ConnectionManager.Abort();

				MessageBox.Show( "An exception occurred when trying to process the correction:\r\n\r\n" + exception.ToString() );
			}
		}

		void ShowChangeRecord()
		{
			try
			{
				//
				// Get the USN the user entered.
				//
				int usn = Convert.ToInt32( usnTextBox.Text );
				SqlDataReaderAccessor reader = null;

				try
				{
					//
					// Try to find the ChangeRecord by USN.  We can only correct local change records, so always
					// use the local operator key.
					//
					FindChangeRecords.SetRange( Config.GetString( "OperatorKey" ), usn, usn );
					
					//
					// Get the results; we should only have 1 result.
					//
					reader = FindChangeRecords.RetrieveResults( 1 );

					//
					// Construct a ChangeRecord from the results.
					//
					ChangeRecord changeRecord = CreateChangeRecord( reader );

					if( null != changeRecord )
					{
						//
						// If we found a change record, show its XML and show the XML for a
						// proposed correction.  The user will be allowed to edit the XML for the
						// proposed correction.
						//
						DisplayChangeRecord( changeRecord );
						DisplayCorrection( changeRecord );

						correctionButton.Enabled = true;
					}
					else
					{
						MessageBox.Show( "No ChangeRecord matching that USN was found." );
					}
				}
				catch( Exception innerException )
				{
					FindChangeRecords.CleanUp();

					throw innerException;
					
				}
				finally
				{
					if( null != reader )
					{
						reader.Close();
					}
				}				
			}
			catch( Exception exception )
			{
				correctionButton.Enabled = false;
				MessageBox.Show( "Change Record for that USN could not be obtained\r\n\r\n:" + exception.ToString() );								
			}				
		}
	
		ChangeRecord CreateChangeRecord( SqlDataReaderAccessor reader )
		{	
			ChangeRecord changeRecord = null;
			try
			{
				while( reader.Read() )
				{
					XmlSerializer serializer = null;

					switch( (ChangeRecordPayloadType)reader.GetShort( "changeTypeID" ) )
					{
						case ChangeRecordPayloadType.ChangeRecordNull:
							serializer = new XmlSerializer( typeof( ChangeRecordNull ) );
							break;

						case ChangeRecordPayloadType.ChangeRecordNewData:
							serializer = new XmlSerializer( typeof( ChangeRecordNewData ) );
							break;

						case ChangeRecordPayloadType.ChangeRecordDelete:
							serializer = new XmlSerializer( typeof( ChangeRecordDelete ) );
							break;

						case ChangeRecordPayloadType.ChangeRecordPublisherAssertion:
							serializer = new XmlSerializer( typeof( ChangeRecordPublisherAssertion ) );
							break;

						case ChangeRecordPayloadType.ChangeRecordHide:
							serializer = new XmlSerializer( typeof( ChangeRecordHide ) );
							break;

						case ChangeRecordPayloadType.ChangeRecordDeleteAssertion:
							serializer = new XmlSerializer( typeof( ChangeRecordDeleteAssertion ) );
							break;

						case ChangeRecordPayloadType.ChangeRecordAcknowledgement:
							serializer = new XmlSerializer( typeof( ChangeRecordAcknowledgement ) );
							break;

						case ChangeRecordPayloadType.ChangeRecordCorrection:
							serializer = new XmlSerializer( typeof( ChangeRecordCorrection ) );
							break;
					}

					StringReader stringReader = new StringReader( reader.GetString( "changeData" ) );
						
					try
					{
						changeRecord = new ChangeRecord();
											
						changeRecord.AcknowledgementRequested = ( reader.GetInt( "flag" ) & (int)ChangeRecordFlags.AcknowledgementRequested ) > 0;
						changeRecord.ChangeID.NodeID		  = reader.GetString( "OperatorKey" );
						changeRecord.ChangeID.OriginatingUSN  = reader.GetLong( "USN" );
						
						ChangeRecordBase changeRecordBase = ( ChangeRecordBase ) serializer.Deserialize( stringReader );
						if( changeRecordBase is ChangeRecordCorrection )
						{
							//
							// The query to find change records will do correction 'fixups'.  That is, the changeData of this
							// change record will be replaced with the changeData from the correction.  The problem with this is 
							// that the original change data will now look like a correction.  To distinguish these types of 
							// change records, we look to see if the OriginatingUSN's match.  If the OriginatingUSN's match,
							// we want they payload of the change record in this correction.  This payload will contain the
							// corrected data that we want.
							//
							ChangeRecordCorrection changeRecordCorrection = ( ChangeRecordCorrection ) changeRecordBase;
							if( changeRecordCorrection.ChangeRecord.ChangeID.OriginatingUSN == changeRecord.ChangeID.OriginatingUSN )
							{
								changeRecordBase = changeRecordCorrection.ChangeRecord.Payload;
							}								
						}
							
						changeRecord.Payload = changeRecordBase;																			
					}
					finally
					{
						stringReader.Close();
					}
				}
			}
			finally
			{
				reader.Close();
			}

			return changeRecord;
		}

		void DisplayChangeRecord( ChangeRecord changeRecord )
		{
			UTF8EncodedStringWriter writer = new UTF8EncodedStringWriter();
			changeRecordSerializer.Serialize( writer, changeRecord );
			writer.Close();		

			changeRecordTextBox.Text = writer.ToString();
		}

		void DisplayCorrection( ChangeRecord changeRecord )
		{
			ChangeRecordCorrection changeRecordCorrection  = new ChangeRecordCorrection();
			changeRecordCorrection.ChangeRecord			   = changeRecord;			

			UTF8EncodedStringWriter writer = new UTF8EncodedStringWriter();
			correctionSerializer.Serialize( writer, changeRecordCorrection );
			writer.Close();
		
			correctionTextBox.Text = writer.ToString();
		}		
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\tools\resetkey\assemblyinfo.cs ===
using System.Reflection;
using System.Security.Permissions;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("resetkey.exe")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft Corporation")]
[assembly: AssemblyProduct("UDDI Services")]
[assembly: AssemblyCopyright("Copyright(c) 2002 Microsoft Corporation")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]
[assembly: PermissionSetAttribute(SecurityAction.RequestMinimum, Name = "FullTrust")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("")]
[assembly: AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\tools\validate\makefile.inc ===
foo.cs:
	..\..\version\$(O)\version.exe -outfile .\assemblyversioninfo.cs
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\tools\replicationadmin\assemblyinfo.cs ===
using System.Reflection;
using System.Security.Permissions;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("replicationadmin.exe")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft Corporation")]
[assembly: AssemblyProduct("UDDI Services")]
[assembly: AssemblyCopyright("Copyright(c) 2002 Microsoft Corporation")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]
[assembly: PermissionSetAttribute(SecurityAction.RequestMinimum, Name = "FullTrust")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("")]
[assembly: AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\tools\send\assemblyinfo.cs ===
using System.Reflection;
using System.Security.Permissions;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("send.exe")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft Corporation")]
[assembly: AssemblyProduct("UDDI Services")]
[assembly: AssemblyCopyright("Copyright(c) 2002 Microsoft Corporation")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]
[assembly: PermissionSetAttribute(SecurityAction.RequestMinimum, Name = "FullTrust")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("")]
[assembly: AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\tools\send\uddisend.cs ===
using System;
using System.Net;
using System.IO;
using System.Security.Cryptography.X509Certificates;
using System.Text;
using System.Xml;

namespace UDDI.Tools
{
	class UDDISend
	{
		public enum AuthenticationType
		{
			Uninitialized					= 0,
			WindowsAuthentication			= 1,
			UDDIAuthentication				= 2,
			ClientCertificateAuthentication = 3
		}

		public const int BlockSize = 4096;

		public static AuthenticationType AuthType = AuthenticationType.Uninitialized;

		public static string Url = null;
		public static string MessageFilename = null;
		public static string CertificateFilename = null;

		public static void Main( string[] args )
		{
			Console.WriteLine( "Microsoft (R) UDDI Send Utility" );
			Console.WriteLine( "Copyright (C) Microsoft Corp. 2002. All rights reserved.\r\n" );
			
			try
			{
				ProcessCommandLine( args );

				//
				// Retrieve the input data from the specified file
				//
				Console.Write( "Loading '" + MessageFilename + "'... ");

				FileStream f = new FileStream( MessageFilename, FileMode.Open, FileAccess.Read );

				System.IO.BinaryReader br = new BinaryReader( f );
				byte[] cbInput =  new byte[ BlockSize ];
				int n = 0;
				int nTotal = 0;
				HttpWebRequest req = (HttpWebRequest) HttpWebRequest.Create( Url );
				req.Timeout = -1;

				if( AuthenticationType.WindowsAuthentication == AuthType )
				{
					req.Credentials = CredentialCache.DefaultCredentials;
					req.PreAuthenticate = true;
				}
				else if( AuthenticationType.ClientCertificateAuthentication == AuthType )
				{
					req.ClientCertificates.Add( X509Certificate.CreateFromCertFile( CertificateFilename ) );
				}

				//
				// Populate the request data from the input file
				//
				req.Method = "POST";
				req.ContentType = "text/xml; charset=\"utf-8\"";
				req.ContentLength = f.Length;
				req.Headers.Add( "SOAPAction", "\"\"" );

				n = br.Read( cbInput, 0, BlockSize );

				while( n > 0 )
				{
					nTotal += n;
					req.GetRequestStream().Write( cbInput, 0, n );
					n = br.Read( cbInput, 0, BlockSize );
				}
				
				Console.WriteLine( "done." );
				Console.Write( "Transmitting... " );

				Stream strmResponse;
				HttpWebResponse result;

				try
				{
					result = (HttpWebResponse) req.GetResponse();
					Console.WriteLine( "done." );
				}
				catch( WebException we )
				{
					Console.WriteLine( "error." );
					
					result = (HttpWebResponse) we.Response;
					Console.WriteLine( "\r\nException: {0}", we.ToString() );
				}

				//
				// Write the results to the standard output
				//
				Console.Write( "\r\nResponse stream received\r\nStatus code: " + result.StatusCode );
				Console.Write( "\r\nStatus Description: " + result.StatusDescription );

				strmResponse = result.GetResponseStream();

				Byte[] cbRead = new Byte[ 512 ];
				BinaryReader br1 = new BinaryReader( strmResponse );
				int nBytesRead = br1.Read( cbRead, 0, 512 );

				Console.WriteLine("\r\n\r\nXML:\r\n");
				
				FileStream file = new FileStream( "output.xml", System.IO.FileMode.Create );
				BinaryWriter strm = new BinaryWriter( file, System.Text.Encoding.UTF8 );

				while( nBytesRead > 0 )
				{
					Console.Write( System.Text.Encoding.UTF8.GetString( cbRead, 0, nBytesRead ) );
					strm.Write( cbRead, 0, nBytesRead );
					
					nBytesRead = br1.Read( cbRead, 0, 512 );
				}

				strm.Close();

				Console.WriteLine("");
			}
			catch( CommandLineException e )
			{
				if( null != e.Message && e.Message.Length > 0 )
				{
					Console.WriteLine( e.Message );
					Console.WriteLine();
				}
				else
				{
					DisplayUsage();
				}
			}
			catch( Exception e )
			{
				Console.WriteLine ("Exception: {0}", e.ToString());
			}
			
			return;
		}

		internal static void ProcessCommandLine( string[] args )
		{
			int i = 0;

			if( 0 == args.Length )
				throw new CommandLineException();

			while( i < args.Length )
			{
				if( "-" == args[ i ].Substring( 0, 1 ) || "/" == args[ i ].Substring( 0, 1 ) )
				{
					switch( args[ i ].Substring( 1 ).ToLower() )
					{
						case "w":
							AuthType = AuthenticationType.WindowsAuthentication;
							Console.WriteLine( "Including Windows Authentication credentials\r\n" );
							
							break;

						case "u":
							AuthType = AuthenticationType.UDDIAuthentication;
							Console.WriteLine( "Using UDDI Authentication -- no credentials included\r\n" );
							
							break;

						case "c":
							if( i + 1 >= args.Length )
								throw new CommandLineException( "Missing required parameter 'CertificateFilename'." );

							i ++;

							if( !File.Exists( args[ i ] ) )
								throw new CommandLineException( "Certificate file '" + args[ i ] + "' does not exist." );
							
							AuthType = AuthenticationType.ClientCertificateAuthentication;
							CertificateFilename = args[ i ];
							
							Console.WriteLine( "Using client certificate '" + CertificateFilename + "' for authentication.\r\n" );

							break;

						case "?":
							throw new CommandLineException();

						default:
							throw new CommandLineException( "Invalid switch." );
					}
				}
				else
				{
					if( null == Url )
						Url = args[ i ];
					else if( null == MessageFilename )
						MessageFilename = args[ i ];
					else
						throw new CommandLineException( "Too many command line parameters." );
				}

				i ++;
			}

			if( null == Url )
				throw new CommandLineException( "Missing required parameter 'URL'." );

			if( null == MessageFilename )
				throw new CommandLineException( "Missing required parameter 'InputFile'." );

			if( AuthenticationType.Uninitialized == AuthType )
			{
				AuthType = AuthenticationType.UDDIAuthentication;
				Console.WriteLine( "Using UDDI Authentication -- no credentials included\r\n" );
			}
		}

		public static void DisplayUsage()
		{
			Console.WriteLine( "Sends a UDDI message to a specific URL." );
			Console.WriteLine( "\r\nUsage:" );
			Console.WriteLine( "\tsend [switches] URL InputFile" );
			Console.WriteLine( "\r\nSwitches:" );
			Console.WriteLine( "\t-w             Windows authentication" );
			Console.WriteLine( "\t-u             UDDI authentication (default)" );
			Console.WriteLine( "\t-c <certfile>  Client certificate authentication" );
			Console.WriteLine( "\r\nExamples:" );
			Console.WriteLine( "\tsend -w http://uddi.microsoft.com/inquire c:\\somefile.xml" );
			Console.WriteLine( "\tsend -u https://test.uddi.microsoft.com/publish c:\\somefile.xml" );
			Console.WriteLine( "\tsend -c uddi.cer https://uddi.microsoft.com/operator c:\\somefile.xml" );
		}

		/// ****************************************************************
		///   public class CommandLineException
		/// ----------------------------------------------------------------
		///   <summary>
		///     Exception class for errors encountered while parsing the
		///     command-line.
		///   </summary>
		/// ****************************************************************
		/// 
		public class CommandLineException : ApplicationException
		{
			/// ************************************************************
			///   public CommandLineException [constructor]
			/// ------------------------------------------------------------
			///   <summary>
			///     CommandLineException constructor.
			///   </summary>
			/// ************************************************************
			/// 
			public CommandLineException()
				: base( "" )
			{
			}

			/// ************************************************************
			///   public CommandLineException [constructor]
			/// ------------------------------------------------------------
			///   <summary>
			///     CommandLineException constructor.
			///   </summary>
			/// ------------------------------------------------------------
			///   <param name="message">
			///     Exception message.
			///   </param>
			/// ************************************************************
			/// 
			public CommandLineException( string message )
				: base( message )
			{
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\tools\resetkey\resetkey.cs ===
using System;
using System.Globalization;
using System.Security.Cryptography;
using System.Data;
using System.Data.SqlClient;
using Microsoft.Win32;
using System.Resources;

namespace UDDI.Tools
{
	class Resetkey
	{
		static bool resetnow = false;
		static string key;
		static string iv;
		static DateTime dt = DateTime.Now;
		static SqlConnection connection;
		static SqlTransaction transaction;
	
		static int Main( string[] args )
		{			
			int rc = 0; // assume success

			try
			{
				// 
				// Check if CurrentUICulture needs to be overridden
				//
				UDDI.Localization.SetConsoleUICulture();

				DisplayBanner();

				//
				// Parse the command line
				//
				if( !ProcessCommandLine( args ) )
				{
					return 1;
				}
				
				//
				// Generate key and initialization vector
				//
				SymmetricAlgorithm sa = SymmetricAlgorithm.Create();

				sa.GenerateKey();
				key = Convert.ToBase64String( sa.Key ); 

				sa.GenerateIV();
				iv = Convert.ToBase64String( sa.IV ); 

				//
				// Save config information
				//
				if( resetnow )
				{
					ResetKeysNow();
				}
				else
				{
					ResetKeysScheduled();
				}
			}
			catch( Exception e )
			{
				Console.WriteLine( FormatFromResource( "RESETKEY_FAILED" , e.Message ) );
				rc = 1;
			}


			return rc;
		}

		private static bool ProcessCommandLine( string [] args )
		{
			bool bOK = false;

			if ( args.Length > 0 )
			{
				for( int i = 0; i < args.Length; i ++ )
				{
					if( '-' == args[i][0] || '/' == args[i][0] )
					{
						string option = args[i].Substring( 1 );

						if( "help" == option.ToLower() || "?" == option )
						{
							DisplayUsage();
							return false;
						}
						if( "now" == option.ToLower() )
						{
							i++; // move to the next arg
							resetnow = true;
							bOK = true;
						}
					}
				}
			}
			else
				bOK = true;

			if( !bOK )
			{
				DisplayUsage();
				return false;
			}

			return true;
		}
		
		static void DisplayBanner()
		{
			Console.WriteLine( FormatFromResource( "RESETKEY_COPYRIGHT_1" ) );
			Console.WriteLine( FormatFromResource( "RESETKEY_COPYRIGHT_2" ) );
			Console.WriteLine();
		}

		static void DisplayUsage()
		{
			Console.WriteLine( FormatFromResource( "RESETKEY_USAGE_1" ) );
			Console.WriteLine( FormatFromResource( "RESETKEY_USAGE_2" ) );
			Console.WriteLine( FormatFromResource( "RESETKEY_USAGE_3" ) );
			Console.WriteLine();
		}

		static void OpenConnection()
		{
			try
			{
				string connectionectionString = (string) Registry.LocalMachine.OpenSubKey( @"SOFTWARE\Microsoft\UDDI\Database" ).GetValue( "WriterConnectionString" );
				connection = new SqlConnection( connectionectionString );
				connection.Open();
				transaction = connection.BeginTransaction( IsolationLevel.ReadCommitted, "resetkey" );
			}
			catch
			{
				throw new Exception( "Unable to connect to the database" );
			}
		}

		static void CloseConnection()
		{
			transaction.Commit();
			connection.Close();
		}

		static void SaveConfig(string configname, string configvalue)
		{
			//
			// Save configuration info
			//

			SqlCommand cmd = new SqlCommand( "net_config_save", connection, transaction );

			cmd.CommandType = CommandType.StoredProcedure;
			cmd.Parameters.Add( new SqlParameter( "@configName", SqlDbType.NVarChar, UDDI.Constants.Lengths.ConfigName ) ).Direction = ParameterDirection.Input;
			cmd.Parameters[ "@configName" ].Value = configname;
			cmd.Parameters.Add( new SqlParameter( "@configValue", SqlDbType.NVarChar, UDDI.Constants.Lengths.ConfigValue ) ).Direction = ParameterDirection.Input;
			cmd.Parameters[ "@configValue" ].Value = configvalue;

			cmd.ExecuteNonQuery();
		}

		static void ResetKeysNow()
		{
			OpenConnection();

			try
			{
				//
				// 739955 - Make sure date is parsed in the same format it was written.
				//
				UDDILastResetDate.Set( dt );

				SaveConfig( "Security.Key", key );
				SaveConfig( "Security.IV", iv );

				Console.WriteLine( FormatFromResource( "RESETKEY_SUCCEEDED" ) );
			}
			finally
			{
				CloseConnection();
			}

			return;
		}

		static void ResetKeysScheduled()
		{
			OpenConnection();

			try
			{
				//
				// Get config values
				//
				SqlCommand cmd = new SqlCommand( "net_config_get", connection, transaction );
				SqlDataReader rdr = cmd.ExecuteReader( CommandBehavior.SingleResult );

				//
				// Iterate through results and populate variables
				//
				string configname;
				string configvalue;
				int timeoutdays = 0;
				DateTime olddt = DateTime.Now;
				int autoreset = 1;

				while( rdr.Read() ) 
				{
					configname = "";
					configvalue = "";

					if( !rdr.IsDBNull( 0 ) )
						configname = rdr.GetString(0);
					if (!rdr.IsDBNull( 1 ))
						configvalue = rdr.GetString(1);

					//
					// TODO: Use ToInt32 here please
					//
					switch( configname )
					{
						case "Security.KeyTimeout":
							timeoutdays = Convert.ToInt16( configvalue );
							break;
						case "Security.KeyLastResetDate":
						{
							//
							// 739955 - Make sure date is parsed in the same format it was written.
							//
							olddt = UDDILastResetDate.Get();

							break;
						}
						case "Security.KeyAutoReset":
							autoreset = Convert.ToInt16 ( configvalue );
							break;
					}
				}
				
				rdr.Close();

				Console.WriteLine( FormatFromResource( "RESETKEY_EXISTING_SETTINGS" ) );
				Console.WriteLine( "Security.KeyAutoReset = " + autoreset.ToString() );
				Console.WriteLine( "Security.KeyTimeout = " + timeoutdays.ToString() );

				//
				// 661537 - Output the date in the correct format for the user.
				//
				Console.WriteLine( "Security.KeyLastResetDate = " + olddt.ToShortDateString() + " " + olddt.ToShortTimeString() + "\n" );

				//
				// Check Security.KeyAutoReset
				//
				if( 1 != autoreset )
				{
					Console.WriteLine( FormatFromResource( "RESETKEY_AUTO_RESET_1" ) );
					Console.WriteLine( FormatFromResource( "RESETKEY_AUTO_RESET_2" ) );
					return;
				}

				//
				// Check dates to determine if key has expired
				//
				DateTime expiration = olddt.AddDays( timeoutdays );

				if( dt <= expiration )
				{
					//
					// 661537 - Output the date in the correct format for the user.
					//
					Console.WriteLine( FormatFromResource( "RESETKEY_KEY_EXPIRE_NOTE_1", expiration.ToShortDateString() + " " + expiration.ToShortTimeString() ) );					
					Console.WriteLine( FormatFromResource( "RESETKEY_KEY_EXPIRE_NOTE_2" ) );
					return;
				}

				//
				// Write config values
				//

				//
				// 739955 - Make sure date is parsed in the same format it was written.
				//
				UDDILastResetDate.Set( dt );

				SaveConfig( "Security.Key", key );
				SaveConfig( "Security.IV", iv );

				Console.WriteLine( FormatFromResource( "RESETKEY_SUCCEEDED" ) );
			}
			finally
			{
				CloseConnection();
			}

			return;
		}

		static string FormatFromResource( string resID, params object[] inserts )
		{
			try
			{
				string resourceStr = UDDI.Localization.GetString( resID );
				if( null != resourceStr )
				{
					string resultStr = string.Format( resourceStr, inserts );
					return resultStr;
				}

				return "String not specified in the resources: " + resID;
			}
			catch( Exception e )
			{
				return "FormatFromResource failed to load the resource string for ID: " + resID + " Reason: " + e.Message;
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\tools\validate\assemblyinfo.cs ===
using System.Reflection;
using System.Security.Permissions;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("validate.exe")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft Corporation")]
[assembly: AssemblyProduct("UDDI Services")]
[assembly: AssemblyCopyright("Copyright(c) 2002 Microsoft Corporation")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]
[assembly: PermissionSetAttribute(SecurityAction.RequestMinimum, Name = "FullTrust")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("")]
[assembly: AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\tools\validate\validate.cs ===
using System;
using System.IO;
using UDDI.Diagnostics;

class UDDIValidate
{
	static void Main(string[] args)
	{
		if( args.Length < 1 )
		{
			usage();
			return;
		}

		try
		{
			Debug.Verify( 
						File.Exists( args[ 0 ] ), 
						"UDDI_ERROR_FATALERROR_TOOLS_VALIDATE_MISSIGFILE",
						UDDI.ErrorType.E_fatalError,
						args[ 0 ] 
			);
			Console.WriteLine( "Validating {0}...", args[0] );
			UDDI.SchemaCollection.ValidateFile( args[0] );
			Console.WriteLine( "{0} successfully validated", args[ 0 ] );
		}
		catch( Exception e )
		{
			Console.WriteLine( "Exception: {0}", e.ToString() );
		}
		
		return;
	}

	public static void usage()
	{
		Console.WriteLine("Attempts to validate an XML file against the UDDI schema");
		Console.WriteLine("\r\nUsage:");
		Console.WriteLine("\r\nvalidate InputFile");
		Console.WriteLine("\r\nExamples:");
		Console.WriteLine("\r\nvalidate c:\\somefile.xml");
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\web\address.cs ===
using System;
using System.Web.UI.WebControls;
using UDDI.API;
using UDDI.API.Business;

namespace UDDI.Web
{
	public class AddressControl : UddiControl
	{
		protected AddressCollection addresses;
		protected BusinessEntity business;
        protected UddiLabel count;

		protected DataGrid grid;

		public void Initialize( AddressCollection addresses )
		{
			this.addresses = addresses;

			grid.Columns[ 1 ].Visible = false;
		}
		
		public void Initialize( AddressCollection addresses, BusinessEntity business )
		{
			this.addresses = addresses;
			this.business = business;
			
			grid.Columns[ 1 ].Visible = true;
		}
		
		protected void Page_Load( object sender, EventArgs e )
		{
			if( !Page.IsPostBack )
				PopulateDataGrid();

			if( grid.EditItemIndex >= 0 )
				SetEditMode();
		}			
		
		void PopulateDataGrid()
		{
			grid.DataSource = addresses;
			grid.DataBind();
		}
		
		protected void DataGrid_Edit( object sender, DataGridCommandEventArgs e )
		{
			int index = e.Item.ItemIndex;
						
			grid.EditItemIndex = index;
			SetEditMode();

			PopulateDataGrid();
		}
		
        protected void OnEnterKeyPressed( object sender, EventArgs e )
        {
            DataGrid_Update( sender, null );
        }

		protected void DataGrid_Update( object sender, DataGridCommandEventArgs e )
		{
			int index = grid.EditItemIndex;
			
			if( index >= addresses.Count )
				addresses.Add( "", "" );
			
			Address address = addresses[ index ];			
			address.AddressLines.Clear();

            DataGridItem item = grid.Items[ index ];
				
			string[] addressLine = new string[ 5 ] 
			{
				((TextBox)item.FindControl( "address0" )).Text,
				((TextBox)item.FindControl( "address1" )).Text,
				((TextBox)item.FindControl( "address2" )).Text,
				((TextBox)item.FindControl( "address3" )).Text,
				((TextBox)item.FindControl( "address4" )).Text 
			};
			
			for( int i = 0; i < 5; i ++ )
			{
				if( !Utility.StringEmpty( addressLine[ i ] ) )
					address.AddressLines.Add( addressLine[ i ] );
			}	
			
			address.UseType = ((TextBox)item.FindControl( "useType" )).Text;
			business.Save();
		
			grid.EditItemIndex = -1;
			CancelEditMode();

			PopulateDataGrid();
		}

		protected void DataGrid_Cancel( object sender, DataGridCommandEventArgs e )
		{
			grid.EditItemIndex = -1;
			CancelEditMode();

			PopulateDataGrid();
		}   

		protected void DataGrid_Delete( object sender, DataGridCommandEventArgs e )
		{
			int index = e.Item.ItemIndex;
			
			addresses.RemoveAt( index );    
			business.Save();
		
			PopulateDataGrid();
		}   

		protected void DataGrid_Add( object sender, EventArgs e )
		{
			grid.EditItemIndex = addresses.Count;
			SetEditMode();

			addresses.Add( "", "" );

			PopulateDataGrid();
		}

        protected void Selector_OnSelect( object sender, string key, string name )
        {
            /*
            UddiLabel otherBusiness = (UddiLabel)GetControl( "otherBusiness", 6 );
            UddiLabel otherBusinessKey = (UddiLabel)GetControl( "otherBusinessKey", 6 );
            UddiLabel leftOtherBusiness = (UddiLabel)GetControl( "leftOtherBusiness", 6 );
            UddiLabel rightOtherBusiness = (UddiLabel)GetControl( "rightOtherBusiness", 6 );
		
            otherBusinessKey.Text = key;
            otherBusiness.Text = name;
            leftOtherBusiness.Text = name;
            rightOtherBusiness.Text = name;

            Panel selectPanel = (Panel)GetControl( "selectPanel", 6 );
            Panel directionPanel = (Panel)GetControl( "directionPanel", 6 );

            UddiButton add = (UddiButton)GetControl( "add", 7 );
		
            add.Enabled = true;
				
            selectPanel.Visible = false;
            directionPanel.Visible = true; */
        }	
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\web\box.cs ===
using System;
using System.Web;
using System.Web.UI;

namespace UDDI.Web
{
	public class Box : Control, INamingContainer
	{
		protected bool downlevel = false;	
		
		public bool Downlevel
		{
			get { return downlevel; }
			set	{ downlevel = value; }
		}

		public Box()
		{
		}

		protected override void OnInit( EventArgs e )
		{
			Downlevel = 
				0 != Page.Request.Browser.Type.IndexOf( "IE" ) ||
				Page.Request.Browser.MajorVersion < 5;				
		}

		protected override void Render( HtmlTextWriter output )
		{
			if( !Downlevel )
			{
				output.AddAttribute( HtmlTextWriterAttribute.Class, "boxed" );
				output.RenderBeginTag( HtmlTextWriterTag.Div );
				
				this.RenderChildren( output );
				
				output.RenderEndTag();
			}
			else
			{
				output.AddAttribute( HtmlTextWriterAttribute.Cellpadding, "10" );
				output.AddAttribute( HtmlTextWriterAttribute.Cellspacing, "0" );
				output.AddAttribute( HtmlTextWriterAttribute.Border, "1" );
				output.AddAttribute( HtmlTextWriterAttribute.Bgcolor, "#f0f8ff" );
				output.AddAttribute( HtmlTextWriterAttribute.Bordercolor, "#639ace" );
				output.AddAttribute( HtmlTextWriterAttribute.Width, "100%" );
				output.RenderBeginTag( HtmlTextWriterTag.Table );

				output.RenderBeginTag( HtmlTextWriterTag.Tr );
				
				output.AddAttribute( HtmlTextWriterAttribute.Width, "100%" );
				output.RenderBeginTag( HtmlTextWriterTag.Td );

				this.RenderChildren( output );

				output.RenderEndTag();
				output.RenderEndTag();
				output.RenderEndTag();
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\version\version.cpp ===
// version.cpp : Defines the entry point for the console application.
//
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <ntverp.h>
#include <tchar.h>

static BOOL WriteToFile( HANDLE hFile, const char *psz );
static void PrintUsage();

int __cdecl
main( int argc, char **argv )
{
	const char *pszOutFile = NULL;

	if( 1 == argc )
	{
		PrintUsage();
		return 1;
	}

	for( int i = 1; i < argc; i++ )
	{
		if( 0 == _stricmp( argv[ i ], "-outFile" ) && ( i + 1 < argc ) )
		{
			pszOutFile = argv[ i + 1 ];
			break;
		}
		else
		{
			PrintUsage();
			return 1;
		}
	}

	const char *pszUsings =   "using System.Reflection;\r\nusing System.Security.Permissions;\r\nusing System.Runtime.CompilerServices;\r\n\r\n";
	const char *pszVersionTemplate = "[assembly: AssemblyVersion(\"%s\")]\r\n";

	char szVersion[ 256 ];
	char szBuf[ 32 ];

	memset( szBuf, 0, 32 * sizeof( char ) );
	memset( szVersion, 0, 256 * sizeof( char ) );

	//
	// VER_PRODUCTVERSION_STR is a preprocessor symbol, defined in ntverp.h.
	// It contains the string-ized Windows version number.
	//
	char *psz = strncpy( szBuf, VER_PRODUCTVERSION_STR, 32 );
	szBuf[ 31 ] = 0x00;

	if( NULL == psz )
	{
		printf( "Preprocessor symbol VER_PRODUCTVERSION_STR is not defined.  Giving up.\n" );
		return -1;
	}

	sprintf( szVersion, pszVersionTemplate, szBuf );

	HANDLE hFile = CreateFileA( pszOutFile,
								GENERIC_WRITE,
								0,
								NULL,
								CREATE_ALWAYS,
								FILE_ATTRIBUTE_NORMAL,
								NULL );
	if( NULL == hFile )
	{
		printf( "Could not create the following file: %s.  Giving up.\n", pszOutFile );
		return -1;
	}

	BOOL fSuccess = FALSE;

	fSuccess = WriteToFile( hFile, pszUsings );
	if( !fSuccess )
	{
		printf( "Error writing to file: %s.  Giving up.\n", pszOutFile );
		CloseHandle( hFile );
		return -1;
	}

	fSuccess = WriteToFile( hFile, szVersion );
	if( !fSuccess )
	{
		printf( "Error writing to file: %s.  Giving up.\n", argv[ 1 ] );
		CloseHandle( hFile );
		return -1;
	}

	CloseHandle( hFile );

	return 0;
}


BOOL
WriteToFile( HANDLE hFile, const char *psz )
{
	if( ( NULL == hFile ) || ( NULL == psz ) )
	{
		return FALSE;
	}

	DWORD dwBytesToWrite = strlen( psz );
	DWORD dwBytesWritten = 0;
	BOOL fSuccess = FALSE;

	fSuccess = WriteFile( hFile,
						  reinterpret_cast<const void *>( psz ),
						  dwBytesToWrite,
						  &dwBytesWritten,
						  NULL );

	if( !fSuccess || ( dwBytesToWrite != dwBytesWritten ) )
	{
		return FALSE;
	}
	else
	{
		return TRUE;
	}
}

void
PrintUsage()
{
	printf( "Usage of version.exe:\r\n\r\n" );
	printf( "version.exe <-outFile <path to output file> >\r\n" );
	printf( "version.exe <-help>\r\n" );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\web\assemblyinfo.cs ===
using System.Reflection;
using System.Security.Permissions;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("uddi.web.dll")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft Corporation")]
[assembly: AssemblyProduct("UDDI Services")]
[assembly: AssemblyCopyright("Copyright(c) 2002 Microsoft Corporation")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]
[assembly: PermissionSetAttribute(SecurityAction.RequestMinimum, Name = "FullTrust")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile( "")]
[assembly: AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\web\businesses.cs ===
using System;
using System.Data;
using System.Web.UI;
using System.Web.UI.WebControls;
using UDDI;
using UDDI.API;
using UDDI.API.Business;
using UDDI.API.ServiceType;
using UDDI.Diagnostics;

namespace UDDI.Web
{
	public class BusinessControl : UddiControl
	{
		protected BusinessInfoCollection businessInfos;
        protected bool frames;

		protected DataGrid grid;

		public void Initialize( BusinessInfoCollection businessInfos, bool allowEdit )
		{
			this.businessInfos = businessInfos;

            grid.Columns[ 0 ].Visible = allowEdit;
            grid.Columns[ 1 ].Visible = allowEdit;
			grid.Columns[ 2 ].Visible = !allowEdit;
		}

		protected void Page_Load( object sender, EventArgs e )
		{
            frames = ( "true" == Request[ "frames" ] );
			PopulateDataGrid();
		}

		void PopulateDataGrid()
		{
			grid.DataSource = businessInfos;
			grid.DataBind();
		}
		
		protected void Business_Edit( object sender, DataGridCommandEventArgs e )
		{
			string key = businessInfos[ e.Item.ItemIndex ].BusinessKey;

            if( frames )
            {
                //
                // Reload explorer and view panes.
                //
                Response.Write(
                    ClientScripts.ReloadExplorerAndViewPanes( "editbusiness.aspx?frames=true&key=" + key, key ) ); 

                Response.End();
            }
            else
            {
                Response.Redirect( "editbusiness.aspx?frames=false&key=" + key ); 
                Response.End();
            }
		}

		protected void Business_Delete( object sender, DataGridCommandEventArgs e )
		{
            string name = businessInfos[ e.Item.ItemIndex ].Names[ 0 ].Value;
            string key = businessInfos[ e.Item.ItemIndex ].BusinessKey;

            //
            // The user has not yet confirmed the delete operation, so display
            // a confirmation dialog.
            //
            string message = String.Format( 
                Localization.GetString( "TEXT_DELETE_CONFIRMATION" ), 
                name );
				
            Page.RegisterStartupScript(
                "Confirm",
                ClientScripts.Confirm(
                message,
                "editbusiness.aspx?frames=" + ( frames ? "true" : "false" ) + "&key=" + key + "&mode=delete&confirm=true&tab=1" ) );
		}

		protected void Business_Add( object sender, EventArgs e )
		{
			Response.Redirect( "editbusiness.aspx?frames=" + ( frames ? "true" : "false" ) + "&mode=add" );
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\web\bindings.cs ===
using System;
using System.Data;
using System.Web.UI;
using System.Web.UI.WebControls;
using UDDI;
using UDDI.API;
using UDDI.API.Business;
using UDDI.API.Service;
using UDDI.API.ServiceType;
using UDDI.API.Binding;
using UDDI.Diagnostics;

namespace UDDI.Web
{
	public class BindingControl : UddiControl
	{
		protected BindingTemplateCollection bindings;
        protected BusinessService parent;
		protected bool frames;

		protected DataGrid grid;

		public void Initialize( BindingTemplateCollection bindings )
		{
			this.bindings = bindings;
            this.parent = null;

            grid.Columns[ 0 ].Visible = false;
            grid.Columns[ 1 ].Visible = false;
            grid.Columns[ 2 ].Visible = true;
        }

        public void Initialize( BindingTemplateCollection bindings, BusinessService parent )
        {
            this.bindings = bindings;
            this.parent = parent;

            grid.Columns[ 0 ].Visible = true;
            grid.Columns[ 1 ].Visible = true;
            grid.Columns[ 2 ].Visible = false;
        }
        
        protected void Page_Load( object sender, EventArgs e )
		{
            frames = ( "true" == Request[ "frames" ] );

            PopulateDataGrid();
		}

		void PopulateDataGrid()
		{
			grid.DataSource = bindings;
			grid.DataBind();
		}
		
		protected void Binding_Edit( object sender, DataGridCommandEventArgs e )
		{
			string key = bindings[ e.Item.ItemIndex ].BindingKey;
			
            if( frames )
            {
                Response.Write(
                    ClientScripts.ReloadExplorerAndViewPanes( "editbinding.aspx?frames=true&key=" + key, key ) );

                Response.End();
            }
            else
            {                    
                Response.Redirect( "editbinding.aspx?frames=false&key=" + key ); 
                Response.End();
            }
		}

		protected void Binding_Delete( object sender, DataGridCommandEventArgs e )
		{
            BindingTemplate binding = bindings[ e.Item.ItemIndex ];            
            string name;

            if( null != binding.AccessPoint )
                name = binding.AccessPoint.Value;
            else
                name = Localization.GetString( "HEADING_BINDING" );
            
            string key = binding.BindingKey;

            //
            // The user has not yet confirmed the delete operation, so display
            // a confirmation dialog.
            //
            string message = String.Format( 
                Localization.GetString( "TEXT_DELETE_CONFIRMATION" ), 
                name );
				
            Page.RegisterStartupScript(
                "Confirm",
                ClientScripts.Confirm(
                message,
                "editbinding.aspx?frames=" + ( frames ? "true" : "false" ) + "&key=" + key + "&mode=delete&confirm=true&tab=1" ) );
		}

		protected void Binding_Add( object sender, EventArgs e )
		{
			Response.Redirect( "editbinding.aspx?frames=" + ( frames ? "true" : "false" ) + "&key=" + parent.ServiceKey + "&mode=add" );
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\web\categorybag.cs ===
using System;
using System.Data;
using System.Web;
using System.Web.UI;
using System.Web.UI.WebControls;
using UDDI.API;
using UDDI.API.Business;
using UDDI.API.ServiceType;
using UDDI;
using UDDI.Diagnostics;

namespace UDDI.Web
{
	public class CategoryBagControl : UddiControl
	{
		protected KeyedReferenceCollection categoryBag = null;
		protected CacheObject cache = null;
		protected EntityBase entity = null;
		protected bool FindMode;		
		protected DataGrid grid;
		protected Label taxonomyID;
		protected Label taxonomyName;
		protected Label tModelKey;
		protected Label keyName;
		protected Label keyValue;
		protected Label path;
		
		public void Initialize( KeyedReferenceCollection categoryBag )
		{
			this.categoryBag = categoryBag;
			
			grid.Columns[ 2 ].Visible = false;
		}

		public void Initialize( KeyedReferenceCollection categoryBag, EntityBase entity )
		{
			this.categoryBag = categoryBag;
			this.entity = entity;
			
			grid.Columns[ 2 ].Visible = true;
		}

		public void Initialize( KeyedReferenceCollection categoryBag, CacheObject cache )
		{
			this.categoryBag = categoryBag;
			this.cache = cache;

			grid.Columns[ 2 ].Visible = true;
		}
				
		public void Initialize( KeyedReferenceCollection categoryBag, CacheObject cache, bool rebind )
		{
			this.categoryBag = categoryBag;
			this.cache = cache;

			grid.Columns[ 2 ].Visible = true;
			
			if( rebind )
				CategoryBag_DataBind( false );

		}
		protected void Page_Load( object sender, EventArgs e )
		{
			if( !Page.IsPostBack )
				CategoryBag_DataBind( false );
		}

		protected Control GetControl( string id, int cell )
		{
			return grid.Items[ grid.EditItemIndex ].Cells[ cell ].FindControl( id );
		}

		protected void CategoryBag_DataBind( bool insertRow )
		{
			DataTable table = new DataTable();
			DataRow row;

			int index = 0;
		        
			table.Columns.Add( new DataColumn( "Index", typeof( int ) ) );
			table.Columns.Add( new DataColumn( "TModelName", typeof( string ) ) );
			table.Columns.Add( new DataColumn( "KeyName", typeof( string ) ) );
			table.Columns.Add( new DataColumn( "KeyValue", typeof( string ) ) );
			table.Columns.Add( new DataColumn( "TModelKey", typeof( string ) ) );

			foreach( KeyedReference keyedReference in categoryBag )
			{
				row = table.NewRow();

				row[0] = index;
				row[1] = HttpUtility.HtmlEncode( Lookup.TModelName( keyedReference.TModelKey ) );
				row[2] = HttpUtility.HtmlEncode( keyedReference.KeyName );
				row[3] = HttpUtility.HtmlEncode( keyedReference.KeyValue );
				row[4] = keyedReference.KeyValue;

				table.Rows.Add( row );
					
				index ++;
			}
		        
			if( insertRow )
			{
				row = table.NewRow();

				row[0] = index;
				row[1] = "";
				row[2] = "";
				row[3] = "";
				row[4] = "";
				table.Rows.Add( row );
					
				index ++;			
			}
		        
			grid.DataSource = table.DefaultView;
			grid.ShowFooter = !FindMode;
			grid.DataBind();
		}

		protected void CategoryBag_OnCommand( object sender, DataGridCommandEventArgs e )
		{
			switch( e.CommandName.ToLower() )
			{
				case "add":
					CategoryBag_OnAdd(sender, e );
					break;
				
				case "select":
					CategoryChooser_OnSelect( sender, e );
					break;
						
				case "cancel":
					CategoryChooser_OnCancel( sender, e );
					break;				
			}
		}
	
		protected void CategoryBag_OnAdd( object sender, DataGridCommandEventArgs e )
		{
			
			
			grid.EditItemIndex = categoryBag.Count;		
			SetEditMode();
		
			CategoryBag_DataBind( true );

		}
		
		protected void CategoryBag_OnDelete( object sender, DataGridCommandEventArgs e )
		{
			int index = e.Item.ItemIndex;
				
			categoryBag.RemoveAt( index );    
				
			if( null != entity )
				entity.Save();
					
			if( null != cache )
				cache.Save();
		    
			CategoryBag_DataBind( false );
		}
			

		protected void CategoryChooser_OnSelect( object sender, DataGridCommandEventArgs e )
		{
			KeyedReference keyedReference = categoryBag[ categoryBag.Add() ];
			
			
			CategoryBrowserControl b = (CategoryBrowserControl)GetControl( "browser", 1 );
			
	
			keyedReference.TModelKey = "uuid:" + b.TModelKey;
			keyedReference.KeyName = HttpUtility.HtmlDecode( b.KeyName );
			keyedReference.KeyValue = b.KeyValue;

			if( null != entity )
				entity.Save();		

			if( null != cache )
				cache.Save();
						
			grid.EditItemIndex = -1;
			CancelEditMode();
				
			CategoryBag_DataBind( false );
		}
			
		protected void CategoryChooser_OnCancel( object sender, DataGridCommandEventArgs e )
		{
			grid.EditItemIndex = -1;
			CancelEditMode();		
			CategoryBag_DataBind( false );
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\web\breadcrumb.cs ===
using System;
using System.Web;
using System.Web.UI;
using System.Web.UI.WebControls;
using UDDI;
using UDDI.API;
using UDDI.API.Business;
using UDDI.API.Service;
using UDDI.API.ServiceType;
using UDDI.API.Binding;

namespace UDDI.Web
{
    public enum BreadCrumbType
    {
        Edit        = 0,
        Details     = 1,
        Search      = 1,
        Administer  = 2
    }

    public class BreadCrumbControl : UserControl
    {
        protected string root = "";
        protected bool frames;

        protected PlaceHolder section;
        protected PlaceHolder navigate;

        protected BreadCrumbType type;

        protected override void OnInit( EventArgs e )
        {
            if( "/" != Request.ApplicationPath )
                root = Request.ApplicationPath;

            frames = ( 0 == String.Compare( "true", Request[ "frames" ], true ) );
        }
	
        public void Initialize( BreadCrumbType type, EntityType entityType, string key )
        {
           Initialize( type,entityType,key,null );
        }
		public void Initialize( BreadCrumbType type, EntityType entityType, string key, string projectionkey )
		{
			this.type = type;

			switch( entityType )
			{
				case EntityType.BusinessEntity:
					AddBusinessBlurb( key, false );
					break;

				case EntityType.BusinessService:
					if( null!=projectionkey )
					{
						AddServiceProjectionBlurb( key,projectionkey, false );
					}
					else
					{
						AddServiceBlurb( key, false );
					}
					break;

				case EntityType.BindingTemplate:
					AddBindingBlurb( key, false );                                      
					break;
                
				case EntityType.TModel:
					AddTModelBlurb( key, false );
					break;

				default:
					break;
			}
		}
        
        public void Initialize( BreadCrumbType type, EntityType entityType, string key, int index )
        {
            this.type = type;

            switch( entityType )
            {
                case EntityType.Contact:
                    AddContactBlurb( key, index, false );
                    break;

                case EntityType.TModelInstanceInfo:
                    AddInstanceInfoBlurb( key, index, false );
                    break;

                default:
                    break;
            }
        }

        public void AddBlurb( string text, string url, string imageFilename, string tooltip, bool crumb )
        {
            if( crumb )
            {
                if( navigate.Controls.Count > 0 )
                    navigate.Controls.Add( new LiteralControl( " | " ) );

                HyperLink link = new HyperLink();

                link.NavigateUrl = url;
                link.Text = HttpUtility.HtmlEncode( text );
                link.CssClass = "breadcrumb";
                link.ToolTip = tooltip;
                
                navigate.Controls.Add( link );
            }
            else
            {
                if( null != imageFilename )
                {
                    Image image = new Image();                
                    image.ImageUrl = root + "/images/" + imageFilename;
                
                    if( frames )
                        image.ImageAlign = ImageAlign.AbsMiddle;
                    else
                        image.ImageAlign = ImageAlign.Bottom;
                    
                    section.Controls.Add( image );
                    section.Controls.Add( new LiteralControl( "&nbsp;" ) );
                }
            
                Label label = new Label();

                label.Text = HttpUtility.HtmlEncode( text );
                label.CssClass = "section";
                label.ToolTip = tooltip;
                
                section.Controls.Add( label );
            }
        }

        public void AddContainerBlurb( bool chained )
        {
            string text;
            string tooltip;
            string url = root;

            if( BreadCrumbType.Edit == type )
            {
                text = Localization.GetString( "HEADING_MY_ENTRIES" );
                tooltip = text;
                url = root + "/edit/edit.aspx?refreshExplorer=&frames=" + frames.ToString().ToLower();
            }
            else
            {
                if( frames )
                    return;

                if( chained )
                {
                    text = Localization.GetString( "HEADING_SEARCH_RESULTS" );
                    url += "/search/results.aspx";
                }
                else
                {
                    text = Localization.GetString( "HEADING_SEARCH_CRITERIA" );
                    url += "/search/search.aspx";
                }

                tooltip = text;
                url += "?search=" + Request[ "search" ] + "&frames=" + frames.ToString().ToLower();
            }
			
            if( chained )                
                AddBlurb( text, url, null, tooltip, true );    
            else
                AddBlurb( text, null, null, tooltip, false );
        }

        public void AddBusinessBlurb( string businessKey, bool chained )
        {
            BusinessInfo businessInfo = new BusinessInfo( businessKey );
            businessInfo.Get( false );
            
            string text = businessInfo.Names[ 0 ].Value;
            string tooltip = Localization.GetString( "HEADING_BUSINESS" );
            string url = root;

            if( BreadCrumbType.Edit == type )
                url += "/edit/editbusiness.aspx?refreshExplorer=&key=";
            else
                url += "/details/businessdetail.aspx?search=" + Request[ "search" ] + "&key=";
 			
            url += businessKey + "&frames=" + frames.ToString().ToLower();

            AddContainerBlurb( true );

            if( chained )
                AddBlurb( text, url, null, tooltip, true );
            else
                AddBlurb( text, null, "business.gif", tooltip, false );
        }

        public void AddServiceBlurb( string serviceKey, bool chained )
        {
            ServiceInfo serviceInfo = new ServiceInfo();
            
            serviceInfo.ServiceKey = serviceKey;
            serviceInfo.Get();

            string text = serviceInfo.Names[ 0 ].Value;
            string tooltip = Localization.GetString( "HEADING_SERVICE" );
            string url = root;

            if( BreadCrumbType.Edit == type )
                url += "/edit/editservice.aspx?refreshExplorer=&key=";
            else
                url += "/details/servicedetail.aspx?search=" + Request[ "search" ] + "&key=";
			
            url += serviceKey + "&frames=" + frames.ToString().ToLower();

            AddBusinessBlurb( serviceInfo.BusinessKey, true );
            
            if( chained )
                AddBlurb( text, url, null, tooltip, true );
            else            
                AddBlurb( text, null, "service.gif", tooltip, false );
        }
		public void AddServiceProjectionBlurb( string serviceKey, string parentKey, bool chained )
		{
			ServiceInfo serviceInfo = new ServiceInfo();
            
			serviceInfo.ServiceKey = serviceKey;
			serviceInfo.Get();

			string text = serviceInfo.Names[ 0 ].Value;
			string tooltip = Localization.GetString( "HEADING_SERVICE" );
			string url = root;

			if( BreadCrumbType.Edit == type )
				url += "/edit/editservice.aspx?refreshExplorer=&key=";
			else
				url += "/details/servicedetail.aspx?search=" + Request[ "search" ] + "&key=";
			
			url += serviceKey + "&frames=" + frames.ToString().ToLower();

			AddBusinessBlurb( parentKey, true );
            
			if( chained )
				AddBlurb( text, url, null, tooltip, true );
			else            
				AddBlurb( text, null, "service_projection.gif", tooltip, false );
		}
        public void AddBindingBlurb( string bindingKey, bool chained )
        {
            BindingTemplate binding = new BindingTemplate( bindingKey );
            binding.Get();
            
            string text = ( null != binding.AccessPoint ? binding.AccessPoint.Value : Localization.GetString( "HEADING_BINDING" ) );
            string tooltip = Localization.GetString( "HEADING_BINDING" );
            string url = root;

            if( BreadCrumbType.Edit == type )
                url += "/edit/editbinding.aspx?refreshExplorer=&key=";
            else
                url += "/details/bindingdetail.aspx?search=" + Request[ "search" ] + "&key=";
			
            url += bindingKey + "&frames=" + frames.ToString().ToLower();

            AddServiceBlurb( binding.ServiceKey, true );

            if( chained )
                AddBlurb( text, url, null, tooltip, true );
            else
                AddBlurb( text, null, "binding.gif", tooltip, false );
        }

        public void AddInstanceInfoBlurb( string bindingKey, int index, bool chained )
        {
            TModelInstanceInfoCollection infos = new TModelInstanceInfoCollection();
            infos.Get( bindingKey );
            
            string text = Lookup.TModelName( infos[ index ].TModelKey );
            string tooltip = Localization.GetString( "HEADING_INSTANCE_INFO" );
            string url = root;

            if( BreadCrumbType.Edit == type )
                url += "/edit/editinstanceinfo.aspx?key=";
            else
                url += "/details/instanceinfodetail.aspx?search=" + Request[ "search" ] + "&key=";
			
            url += bindingKey + "&index=" + index + "&frames=" + frames.ToString().ToLower();
            
            AddBindingBlurb( bindingKey, true );

            if( chained )
                AddBlurb( text, url, null, tooltip, true );
            else
                AddBlurb( text, null, "instance.gif", tooltip, false );
        }

        public void AddContactBlurb( string businessKey, int index, bool chained )
        {
            ContactCollection contacts = new ContactCollection();
            contacts.Get( businessKey );
            
            string text = contacts[ index ].PersonName;
            string tooltip = Localization.GetString( "HEADING_CONTACT" );
            string url = root;

            if( BreadCrumbType.Edit == type )
                url += "/edit/editcontact.aspx?key=";
            else
                url += "/details/contactdetail.aspx?search=" + Request[ "search" ] + "&key=";
			
            url += businessKey + "&index=" + index + "&frames=" + frames.ToString().ToLower();
            
            AddBusinessBlurb( businessKey, true );

            if( chained )
                AddBlurb( text, url, null, tooltip, true );
            else
                AddBlurb( text, null, "contact.gif", tooltip, false );
        }

        public void AddTModelBlurb( string tModelKey, bool chained )
        {
            TModelInfo tModelInfo = new TModelInfo( tModelKey );
            tModelInfo.Get();

            string text = tModelInfo.Name;
            string tooltip = Localization.GetString( "HEADING_TMODEL" );
            string url = root;

            if( BreadCrumbType.Edit == type )
                url += "/edit/editmodel.aspx?key=";
            else
                url += "/details/modeldetail.aspx?search=" + Request[ "search" ] + "&key=";
			
            url += tModelKey + "&frames=" + frames.ToString().ToLower();

            AddContainerBlurb( true );

            if( chained )
                AddBlurb( text, url, null, tooltip, true );
            else
                AddBlurb( text, null, "tmodel.gif", tooltip, false );
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\web\cache.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using System.Text;
using System.Xml;
using System.Xml.Serialization;
using UDDI.API;
using UDDI.API.Business;
using UDDI.API.Service;
using UDDI.API.ServiceType;
using UDDI;
using UDDI.Diagnostics;

namespace UDDI.Web
{
	/// ********************************************************************
	///   public class CacheObject
	/// --------------------------------------------------------------------
	///   <summary>
	///		Encapsulates a session cache object.
	///   </summary>
	/// ********************************************************************
	/// 
	[ XmlRoot( "cacheObject" ) ]
	public class CacheObject
	{
		[XmlElement( "find_business", typeof( FindBusiness ) )]
		public UDDI.API.Business.FindBusiness FindBusiness;
		  
		[XmlElement( "find_service", typeof( FindService ) )]
		public UDDI.API.Service.FindService FindService;

		[XmlElement( "find_tModel", typeof( FindTModel ) )]
		public UDDI.API.ServiceType.FindTModel FindTModel;

		[XmlAttribute( "findType" )]
		public string FindType;
		
		[ XmlIgnore ]
		public string UserID;

		public CacheObject()
		{
		}

		public void Save()
		{
			SessionCache.Save( UserID, this );
		}
	}
	
	public class SessionCache
	{
		/// ****************************************************************
		///   public Get
		/// ----------------------------------------------------------------
		///   <summary>
		///		Retrieves a cache object from the session cache.
		///   </summary>
		/// ----------------------------------------------------------------
		///   <param name="userID">
		///     The user id.
		///   </param>
		/// ----------------------------------------------------------------
		///   <returns>
		///     The cache object.
		///   </returns>
		/// ****************************************************************
		/// 
		public static CacheObject Get( string userID )
		{
			Debug.Enter();

			//
			// Retrieve the cache object from the database.
			//
			string data = "";

			SqlCommand cmd = new SqlCommand( "UI_getSessionCache", ConnectionManager.GetConnection() );
		
			cmd.CommandType = CommandType.StoredProcedure;
			cmd.Transaction = ConnectionManager.GetTransaction();
			
			cmd.Parameters.Add( new SqlParameter( "@PUID", SqlDbType.NVarChar, UDDI.Constants.Lengths.UserID ) ).Direction = ParameterDirection.Input;
			cmd.Parameters.Add( new SqlParameter( "@context", SqlDbType.NVarChar, UDDI.Constants.Lengths.Context ) ).Direction = ParameterDirection.Input;
			
			cmd.Parameters[ "@PUID" ].Value = userID;
			cmd.Parameters[ "@context" ].Value = "WebServer";

			data = (string)cmd.ExecuteScalar();
			
			//
			// Deserialize into a cache object.
			//
			CacheObject cache = null;

			if( !Utility.StringEmpty( data ) )
			{
				XmlSerializer serializer = new XmlSerializer( typeof( CacheObject ) );
				StringReader reader = new StringReader( data );
				
				cache = (CacheObject)serializer.Deserialize( reader );
				cache.UserID = userID;
			}

			Debug.Leave();

			return cache;
		}

		/// ****************************************************************
		///   public Save
		/// ----------------------------------------------------------------
		///   <summary>
		///	    Stores the cache object in the session cache.
		///   </summary>
		/// ----------------------------------------------------------------
		///   <param name="userID">
		///     The user id.
		///   </param>
		///   
		///   <param name="cacheObject">
		///     The cache object.
		///   </param>
		/// ****************************************************************
		/// 
		public static void Save( string userID, CacheObject cache )
		{
			Debug.Enter();

			//
			// Serialize the data into a stream.
			//
			XmlSerializer serializer = new XmlSerializer( typeof( CacheObject ) );
			UTF8EncodedStringWriter writer = new UTF8EncodedStringWriter();
	
			serializer.Serialize( writer, cache );

			//
			// Write the cache object to the database.
			//
			SqlCommand cmd = new SqlCommand( "UI_setSessionCache", ConnectionManager.GetConnection() );
			
			cmd.CommandType = CommandType.StoredProcedure;
			cmd.Transaction = ConnectionManager.GetTransaction();
			
			cmd.Parameters.Add( new SqlParameter( "@PUID", SqlDbType.NVarChar, UDDI.Constants.Lengths.UserID ) ).Direction = ParameterDirection.Input;
			cmd.Parameters.Add( new SqlParameter( "@cacheValue", SqlDbType.NText ) ).Direction = ParameterDirection.Input;
			cmd.Parameters.Add( new SqlParameter( "@context", SqlDbType.NVarChar, UDDI.Constants.Lengths.Context ) ).Direction = ParameterDirection.Input;
			
			cmd.Parameters[ "@PUID" ].Value = userID;
			cmd.Parameters[ "@cacheValue" ].Value = writer.ToString();
			cmd.Parameters[ "@context" ].Value = "WebServer";

			cmd.ExecuteNonQuery();
			
			Debug.Leave();
		}

		/// ****************************************************************
		///   public Discard
		/// ----------------------------------------------------------------
		///   <summary>
		///	    Removes a cache object from the session cache.
		///   </summary>
		/// ----------------------------------------------------------------
		///   <param name="userID">
		///     The user id.
		///   </param>
		/// ****************************************************************
		/// 
		public static void Discard( string userID )
		{
			Debug.Enter();

			SqlCommand cmd = new SqlCommand( "UI_removeSessionCache", ConnectionManager.GetConnection() );
			
			cmd.CommandType = CommandType.StoredProcedure;
			cmd.Transaction = ConnectionManager.GetTransaction();
			
			cmd.Parameters.Add( new SqlParameter( "@PUID", SqlDbType.NVarChar, UDDI.Constants.Lengths.UserID ) ).Direction = ParameterDirection.Input;
			cmd.Parameters.Add( new SqlParameter( "@context", SqlDbType.NVarChar, UDDI.Constants.Lengths.Context ) ).Direction = ParameterDirection.Input;
			
			cmd.Parameters[ "@PUID" ].Value = userID;
			cmd.Parameters[ "@context" ].Value = "WebServer";

			cmd.ExecuteNonQuery();
		
			Debug.Leave();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\web\base.cs ===
using System;
using System.Web;
using System.Web.UI;

namespace UDDI.Web
{
	public class UddiBrowser
	{
		public static bool IsNetscape6
		{
			get
			{
				return 
					HttpContext.Current.Request.Browser.Type.StartsWith( "Netscape" ) && 
					HttpContext.Current.Request.Browser.MajorVersion >= 5;
			}
		}

		public static bool IsIE4
		{
			get
			{
				return 
					HttpContext.Current.Request.Browser.Type.StartsWith( "IE" ) && 
					HttpContext.Current.Request.Browser.MajorVersion >= 4 &&
					HttpContext.Current.Request.Browser.MajorVersion < 5;
			}
		}
		
		public static bool IsIE5
		{
			get
			{
				return 
					HttpContext.Current.Request.Browser.Type.StartsWith( "IE" ) && 
					HttpContext.Current.Request.Browser.MajorVersion >= 5;
			}
		}

		public static bool IsDownlevel
		{
			get { return !IsIE5; }
		}

		public static bool IsFrames
		{	
			get{ return ( "true"==HttpContext.Current.Request[ "frames" ] );}
		}
		public static bool ShouldBeFrames
		{
			get{ return !IsDownlevel; }
		}
    }

	public class UddiPage : System.Web.UI.Page
	{
		
		private System.Web.UI.WebControls.PlaceHolder headerbag;
		public System.Web.UI.WebControls.PlaceHolder HeaderBag
		{
			get{ return headerbag; }
			set{ headerbag=(System.Web.UI.WebControls.PlaceHolder) value; }
		}

		private System.Web.UI.WebControls.PlaceHolder footerbag;
		public System.Web.UI.WebControls.PlaceHolder FooterBag
		{
			get{ return footerbag; }
			set{ footerbag=(System.Web.UI.WebControls.PlaceHolder) value; }
		}

		public bool IsDownlevel
		{
			get { return UddiBrowser.IsDownlevel; }
		}

		public bool EditMode
		{
			get 
			{ 
				if( null == ViewState[ "EditMode" ] )
					return false;

				return (bool)ViewState[ "EditMode" ]; 
			}
		}

		public bool IsNetscape6
		{
            get { return UddiBrowser.IsNetscape6; }
		}

		public bool IsIE4
		{
            get { return UddiBrowser.IsIE4; }
		}
		
		public bool IsIE5
		{
            get { return UddiBrowser.IsIE5; }
		}

		private SytleSheetControlCollection stylesheets;
		public SytleSheetControlCollection StyleSheets
		{
			get
			{ 
				if( null==stylesheets )
					stylesheets = new SytleSheetControlCollection();
				
				return stylesheets; 
			}
			set { stylesheets = (SytleSheetControlCollection)value; }
		}
		private PageStyleControl pagestyle = null;
		public PageStyleControl PageStyle
		{
			get 
			{ 
				if( null==pagestyle )
				{
					pagestyle = PageStyleControl.GetDefault();
				}
				return pagestyle; 
			}
			set { pagestyle = (PageStyleControl)value; }
		}
		private ClientScriptRegisterCollection clientscripts;
		public ClientScriptRegisterCollection ClientScript
		{	
			get
			{
				if( null==clientscripts )
					clientscripts = new ClientScriptRegisterCollection();

				return clientscripts; 
			}
			set{ clientscripts = (ClientScriptRegisterCollection)value; }
		}

		public string Root
		{
			get
			{
				if( "/" == Request.ApplicationPath )
					return "";
				
				return Request.ApplicationPath;
			}
		}

		public void CancelEditMode()
		{
			ViewState[ "EditMode" ] = false;
		}

		public void SetEditMode()
		{
			ViewState[ "EditMode" ] = true;
		}
		
		protected override void OnLoad( EventArgs e )
		{
			base.OnLoad( e );

			if( null!=HeaderBag )
				HeaderBag.Visible = PageStyle.ShowHeader;

			if( null!=FooterBag )
				FooterBag.Visible = PageStyle.ShowFooter;
		}
		
		protected override void Render( HtmlTextWriter output )
		{
			
			//
			// Render Open HTML
			//
			output.RenderBeginTag( HtmlTextWriterTag.Html );
			
			//
			// Render Open Head
			//
			output.Write( "<HEAD>\r\n" );
			
			//
			// Render StyleSheet Links
			//
			foreach( StyleSheetControl stylesheet in this.StyleSheets )
				stylesheet.RenderControl( output );
			
			//
			// Render Client Scripts
			//
			foreach( ClientScriptRegister script in this.ClientScript )
				script.RenderControl( output );
			
			
			if( null != PageStyle )
			{
				
				output.RenderBeginTag( HtmlTextWriterTag.Title );//<title>
				if( 0 == Config.GetInt( "Web.ServiceMode", 0 ) )
				{
					output.Write( UDDI.Localization.GetString( PageStyle.Title ) );
				}
				else
				{
					output.Write( UDDI.Localization.GetString( PageStyle.AltTitle ) );
				}
				output.RenderEndTag();//</title>
			}
			
			
			//
			// Render Close Head
			//
			output.Write( "</HEAD>\r\n" );
			
			//
			// Register the attributes for the body
			//
			if( null!=PageStyle )
				PageStyle.RenderControl( output );
	
			//
			// Render Open Body
			//
			output.RenderBeginTag( HtmlTextWriterTag.Body );
			

				//
				// Render Open Table.  
				// This prevents scrolling problems.
				//
				if( null != PageStyle )
					output.AddAttribute( "border",PageStyle.BorderWidth );
				else
					output.AddAttribute( "border","0" );
				output.AddAttribute( "width","100%" );
				output.AddAttribute( "height","100%" );
				output.AddAttribute( "cellpadding","0" );
				output.AddAttribute( "cellspacing","0" );
				output.RenderBeginTag( HtmlTextWriterTag.Table );
			
				//
				// Render Open TR
				//
				if( UddiBrowser.IsDownlevel || UddiBrowser.IsNetscape6 )
					output.AddAttribute( "height","100%" );
				output.RenderBeginTag( HtmlTextWriterTag.Tr );

				//
				// Render Open TD
				//
				if( UddiBrowser.IsDownlevel || UddiBrowser.IsNetscape6 )
					output.AddAttribute( "height","100%" );
			
				output.AddAttribute( "valign","top" );
				output.RenderBeginTag( HtmlTextWriterTag.Td );
			
			
			//
			// Render Content of ASPX Page
			//
			base.Render( output );//do the base render
			
				//
				// Close All Open Tags
				//
				output.RenderEndTag();//td
				output.RenderEndTag();//tr
				output.RenderEndTag();//table
			
			
			output.RenderEndTag();//body
			output.RenderEndTag();//html
			
		}
		
		protected override void AddParsedSubObject( object obj )
		{
			if( obj is StyleSheetControl )
			{
				this.StyleSheets.Add( (StyleSheetControl)obj );
				return;
			}
			else if( obj is PageStyleControl )
			{
				this.PageStyle = (PageStyleControl)obj;
				return;
			} 
			else if( obj is ClientScriptRegister )
			{
				this.ClientScript.Add( (ClientScriptRegister)obj );
				return;
			}
			
			base.AddParsedSubObject( obj );
		}

		
	}
	public class SytleSheetControlCollection : System.Collections.CollectionBase
	{
		public StyleSheetControl this[ int index ] 
		{
			get{ return (StyleSheetControl)this.List[ index ]; }
			set{ this.List[ index ] = value; }
		}
		public int Add( StyleSheetControl control )
		{
			return this.List.Add( control );
		}
		public void Remove( int index )
		{
			this.RemoveAt( index );
		}
		public void Remove( StyleSheetControl control )
		{
			this.Remove( control );
		}
		public void Insert( int index, StyleSheetControl control )
		{
			this.List.Insert( index, control );
		}
		
	}
	public class StyleSheetControl : UddiControl, INamingContainer
	{
		public StyleSheetControl()
		{
		}
		private string defaultsheet;
		public string Default
		{
			get{ return defaultsheet; }
			set{ defaultsheet = value; }
		}
		private string downlevelsheet;
		public string DownLevel
		{
			get{ return downlevelsheet; }
			set{ downlevelsheet = value; }
		}
		protected override void Render( HtmlTextWriter output )
		{
			if( ( UddiBrowser.IsDownlevel && !UddiBrowser.IsNetscape6 ) && null!=DownLevel )
			{
				output.AddAttribute( HtmlTextWriterAttribute.Href, DownLevel );
			}
			else if( ( !UddiBrowser.IsDownlevel || UddiBrowser.IsNetscape6 ) && null!=Default )
			{
				output.AddAttribute( HtmlTextWriterAttribute.Href, Default );
			}
			else
			{
				return;
			}

			output.AddAttribute( "rel","stylesheet");
			output.AddAttribute( "type", "text/css" );
			output.RenderBeginTag( HtmlTextWriterTag.Link );
			output.RenderEndTag();
		}
	}
	public class PageStyleControl : UddiControl, INamingContainer
	{
		public PageStyleControl()
		{
			//
			// Show footer if Config value is set.
			//
			this.ShowFooter = ( Config.GetInt( "Web.ShowFooter",0 ) > 0 );
			
			//
			// Show header only if DownLevel
			//
			this.ShowHeader = !UddiBrowser.ShouldBeFrames;
			

			//
			// Set Page margin data
			//
			this.MarginHeight = "0";
			this.MarginWidth = "0";
			this.LeftMargin = "0";
			this.RightMargin = "0";
			this.TopMargin = "0";
			this.BottomMargin = "0";

		}
	

		private string title;
		public string Title
		{
			get{ return title; }
			set{ title=value; }
		}
		private string alttitle;
		public string AltTitle
		{
			get{ return alttitle; }
			set{ alttitle=value; }
		}
		
		private string oncontextmenu;
		public string OnClientContextMenu
		{
			get{ return oncontextmenu; }
			set{ oncontextmenu=value; }
		}
		private string leftmargin;
		public string LeftMargin
		{
			get{ return leftmargin; }
			set{ leftmargin=value; }
		}
		private string topmargin;
		public string TopMargin
		{
			get{ return topmargin; }
			set{ topmargin=value; }
		}
		private string bottommargin;
		public string BottomMargin
		{	
			get{ return bottommargin; }
			set{ bottommargin=value; }
		}
		private string rightmargin;
		public string RightMargin
		{	
			get{ return rightmargin; }
			set{ rightmargin=value;}
		}
		private string marginheight;
		public string MarginHeight
		{
			get{ return marginheight; }
			set{ marginheight=value; }
		}
		private string marginwidth;
		public string MarginWidth
		{
			get{ return marginwidth; }
			set{ marginwidth=value; }
		}
		private string onload;
		public string OnClientLoad
		{
			get{ return onload; }
			set{ onload=value; }
		}
		private string bgcolor;
		public string BackgroundColor
		{
			get{ return bgcolor; }
			set{ bgcolor=value; }
		}
		private string linkcolor;
		public string LinkColor
		{	
			get{ return linkcolor; }
			set{ linkcolor=value; }
		}	
		private string alinkcolor;
		public string ALinkColor
		{
			get{ return alinkcolor; }
			set{ alinkcolor=value; }
		}
		private string vlinkcolor;
		public string VLinkColor
		{	
			get{ return vlinkcolor; }
			set{ vlinkcolor=value; }
		}
		private string textcolor;
		public string TextColor 
		{
			get{ return textcolor; }
			set{ textcolor=value; }
		}

		private bool showfooter;
		public bool ShowFooter
		{
			get{ return showfooter; }
			set{ showfooter=value; }
		}

		private bool showheader;
		public bool ShowHeader
		{
			get{ return showheader; }
			set{ showheader=value; }
		}

		private string borderwidth = "0";
		public string BorderWidth
		{
			get{ return borderwidth; }
			set{ borderwidth = value; }
		}

		private string cssclass;
		public string CssClass
		{
			get{ return cssclass; }
			set{ cssclass=value; }
		}
		
		private string onclientactivate;
		public string OnClientActivate
		{
			get{ return onclientactivate; }
			set{ onclientactivate = value; }
		}


		private string onclientafterprint;
		public string OnClientAfterPrint
		{
			get{ return onclientafterprint; }
			set{ onclientafterprint = value; }
		}


		private string onclientbeforeactivate ;
		public string OnClientBeforeActivate
		{
			get{ return onclientbeforeactivate; }
			set{ onclientbeforeactivate = value; }
		}

		private string onclientbeforecut;
		public string OnClientBeforeCut
		{
			get{ return onclientbeforecut; }
			set{ onclientbeforecut = value; }
		}

		private string onclientbeforedeactivate;
		public string OnClientBeforeDeactivate
		{
			get{ return onclientbeforedeactivate; }
			set{ onclientbeforedeactivate = value; }
		}

		private string onclientbeforeeditfocus;
		public string OnClientBeforeEditFocus
		{
			get{ return onclientbeforeeditfocus; }
			set{ onclientbeforeeditfocus = value; }
		}

		private string onclientbeforepaste;
		public string OnClientBeforePaste
		{
			get{ return onclientbeforepaste; }
			set{ onclientbeforepaste = value; }
		}

		private string onclientbeforeprint;
		public string OnClientBeforePrint
		{
			get{ return onclientbeforeprint; }
			set{ onclientbeforeprint = value; }
		}
		
		private string onclientbeforeunload;
		public string OnClientBeforeUnload
		{
			get{ return onclientbeforeunload; }
			set{ onclientbeforeunload = value; }
		}

		private string onclientcontrolselect;
		public string OnClientControlSelect
		{
			get{ return onclientcontrolselect; }
			set{ onclientcontrolselect = value; }
		}

		private string onclientcut;
		public string OnClientCut
		{
			get{ return onclientcut; }
			set{ onclientcut = value; }
		}

		private string onclientdblclick;
		public string OnClientDblClick
		{
			get{ return onclientdblclick; }
			set{ onclientdblclick = value; }
		}

		private string onclientdeactivate;
		public string OnClientDeactivate
		{
			get{ return onclientdeactivate; }
			set{ onclientdeactivate = value; }
		}

		private string onclientdrag;
		public string OnClientDrag
		{
			get{ return onclientdrag; }
			set{ onclientdrag = value; }
		}

		private string onclientdragend;
		public string OnClientDragEnd
		{
			get{ return onclientdragend; }
			set{ onclientdragend = value; }
		}


		private string onclientdragenter;
		public string OnClientDragEnter
		{
			get{ return onclientdragenter; }
			set{ onclientdragenter = value; }
		}

		private string onclientdragleave;
		public string OnClientDragLeave
		{
			get{ return onclientdragleave; }
			set{ onclientdragleave = value; }
		}

		private string onclientdragover;
		public string OnClientDragOver
		{
			get{ return onclientdragover; }
			set{ onclientdragover = value; }
		}

		private string onclientdragstart;
		public string OnClientDragStart
		{
			get{ return onclientdragstart; }
			set{ onclientdragstart = value; }
		}

		private string onclientdrop;
		public string OnClientDrop
		{
			get{ return onclientdrop; }
			set{ onclientdrop = value; }
		}

		private string onclientfilterchange;
		public string OnClientFilterChange
		{
			get{ return onclientfilterchange; }
			set{ onclientfilterchange = value; }
		}

		private string onclientfocusin;
		public string OnClientFocusIn
		{
			get{ return onclientfocusin; }
			set{ onclientfocusin = value; }
		}

		private string onclientfocusout; 
		public string OnClientFocusOut
		{
			get{ return onclientfocusout; }
			set{ onclientfocusout = value; }
		}

		private string onclientkeydown;
		public string OnClientKeyDown
		{
			get{ return onclientkeydown; }
			set{ onclientkeydown = value; }
		}

		private string onclientkeypress;
		public string OnClientKeyPress
		{
			get{ return onclientkeypress; }
			set{ onclientkeypress = value; }
		}

		private string onclientkeyup;
		public string OnClientKeyUp
		{
			get{ return onclientkeyup; }
			set{ onclientkeyup = value; }
		}

		private string onclientlosecapture;
		public string OnClientLoseCapture
		{
			get{ return onclientlosecapture; }
			set{ onclientlosecapture = value; }
		}

		private string onclientmousedown;
		public string OnClientMouseDown
		{
			get{ return onclientmousedown; }
			set{ onclientmousedown = value; }
		}

		private string onclientmouseenter;
		public string OnClientMouseEnter
		{
			get{ return onclientmouseenter; }
			set{ onclientmouseenter = value; }
		}

		private string onclientmouseleave;
		public string OnClientMouseLeave
		{
			get{ return onclientmouseleave; }
			set{ onclientmouseleave = value; }
		}

		private string onclientmousemove;
		public string OnClientMouseMove
		{
			get{ return onclientmousemove; }
			set{ onclientmousemove = value; }
		}

		private string onclientmouseout;
		public string OnClientMouseOut
		{
			get{ return onclientmouseout; }
			set{ onclientmouseout = value; }
		}
		private string onclientmouseover;
		public string OnClientMouseOver
		{
			get{ return onclientmouseover; }
			set{ onclientmouseover = value; }
		}

		private string onclientmouseup;
		public string OnClientMouseUp
		{
			get{ return onclientmouseup; }
			set{ onclientmouseup = value; }
		}

		private string onclientmousewheel;
		public string OnClientMouseWheel
		{
			get{ return onclientmousewheel; }
			set{ onclientmousewheel = value; }
		}

		private string onclientmove;
		public string OnClientMove
		{
			get{ return onclientmove; }
			set{ onclientmove = value; }
		}

		private string onclientmoveend;
		public string OnClientMoveEnd
		{
			get{ return onclientmoveend; }
			set{ onclientmoveend = value; }
		}

		private string onclientmovestart;
		public string OnClientMoveStart
		{
			get{ return onclientmovestart; }
			set{ onclientmovestart = value; }
		}

		private string onclientpaste;
		public string OnClientPaste
		{
			get{ return onclientpaste; }
			set{ onclientpaste = value; }
		}

		private string onclientpropertychange;
		public string OnClientPropertyChange
		{
			get{ return onclientpropertychange; }
			set{ onclientpropertychange = value; }
		}

		private string onclientreadystatechange;
		public string OnClientReadyStateChange
		{
			get{ return onclientreadystatechange; }
			set{ onclientreadystatechange = value; }
		}

		private string onclientresizeend;
		public string OnClientResizeEnd
		{
			get{ return onclientresizeend; }
			set{ onclientresizeend = value; }
		}

		private string onclientresizestart;
		public string OnClientResizeStart
		{
			get{ return onclientresizestart; }
			set{ onclientresizestart = value; }
		}


		private string onclientscroll;
		public string OnClientScroll
		{
			get{ return onclientscroll; }
			set{ onclientscroll = value; }
		}

		private string onclientselect;
		public string OnClientSelect
		{
			get{ return onclientselect; }
			set{ onclientselect = value; }
		}

		private string onclientselectstart;
		public string OnClientSelectStart
		{
			get{ return onclientselectstart; }
			set{ onclientselectstart = value; }
		}

		private string onclientunload;
		public string OnClientUnload
		{
			get{ return onclientunload; }
			set{ onclientunload = value; }
		}

		protected override void Render( HtmlTextWriter output )
		{
			if( null!=ALinkColor )
				output.AddAttribute( "alink",ALinkColor );
			if( null!=LinkColor )
				output.AddAttribute( "link",LinkColor );
			if( null!=VLinkColor )
				output.AddAttribute( "vlink",VLinkColor );
			if( null!=TextColor )
				output.AddAttribute( "text",TextColor );
			
			if( null!=BackgroundColor )
				output.AddAttribute( "bgcolor",BackgroundColor );
			
			if( null!=TopMargin )
				output.AddAttribute( "topmargin",TopMargin );
			if( null!=BottomMargin )
				output.AddAttribute( "bottommargin",BottomMargin );
			if( null!=LeftMargin )
				output.AddAttribute( "leftmargin",LeftMargin );
			if( null!=RightMargin )
				output.AddAttribute( "rightmargin",RightMargin );
			
			if( null!=MarginHeight )
				output.AddAttribute( "marginheight",MarginHeight );
			if( null!=MarginWidth )
				output.AddAttribute( "marginwidth",MarginWidth );

			if( null!=OnClientContextMenu )
				output.AddAttribute( "oncontextmenu",OnClientContextMenu );
			if( null!=OnClientLoad )
				output.AddAttribute( "onload",OnClientLoad );
			if( null!=OnClientActivate )
				output.AddAttribute( "onactive", OnClientActivate );
			if( null!=OnClientAfterPrint )
				output.AddAttribute( "onafterprint" ,OnClientAfterPrint );
			if( null!=OnClientBeforeActivate )
				output.AddAttribute( "onbeforeupdate",OnClientBeforeActivate );
			if( null!=OnClientBeforeCut )
				output.AddAttribute( "onbeforecut",OnClientBeforeCut );
			if( null!=OnClientBeforeDeactivate )
				output.AddAttribute( "onbeforedeactivate", OnClientBeforeDeactivate );
			if( null!=OnClientBeforeEditFocus )
				output.AddAttribute( "onbeforeeditfocus",OnClientBeforeEditFocus );
			if( null!=OnClientBeforePaste )
				output.AddAttribute( "onbeforepaste", OnClientBeforePaste );
			if( null!=OnClientBeforePrint )
				output.AddAttribute( "onbeforeprint", OnClientBeforePrint );
			if( null!=OnClientBeforeUnload )
				output.AddAttribute( "onbeforeunload", OnClientBeforeUnload );
			if( null!=OnClientControlSelect )
				output.AddAttribute( "oncontrolselect", OnClientControlSelect );
			if( null!=OnClientCut )
				output.AddAttribute( "oncut", OnClientCut );
			if( null!=OnClientDblClick )
				output.AddAttribute( "ondblclick", OnClientDblClick );
			if( null!=OnClientDeactivate )
				output.AddAttribute( "ondeactivate", OnClientDeactivate );
			if( null!=OnClientDrag )
				output.AddAttribute( "ondrag", OnClientDrag );
			if( null!=OnClientDragEnd )
				output.AddAttribute( "ondragend", OnClientDragEnd );
			if( null!=OnClientDragEnter )
				output.AddAttribute( "ondragenter", OnClientDragEnter );
			if( null!=OnClientDragLeave )
				output.AddAttribute( "ondragleave", OnClientDragLeave );
			if( null!=OnClientDragOver )
				output.AddAttribute( "ondragover", OnClientDragOver );
			if( null!=OnClientDragStart )
				output.AddAttribute( "ondragstart", OnClientDragStart );
			if( null!=OnClientDrop )
				output.AddAttribute( "ondrop", OnClientDrop );
			if( null!=OnClientFilterChange )
				output.AddAttribute( "onfilterchange", OnClientFilterChange );
			if( null!=OnClientFocusIn )
				output.AddAttribute( "onfocusin", OnClientFocusIn );
			if( null!=OnClientFocusOut )
				output.AddAttribute( "onfocusout", OnClientFocusOut );
			if( null!=OnClientKeyDown )
				output.AddAttribute( "onkeydown", OnClientKeyDown );
			if( null!=OnClientKeyPress )
				output.AddAttribute( "onkeypress", OnClientKeyPress );
			if( null!=OnClientKeyUp )
				output.AddAttribute( "onkeyup", OnClientKeyUp );
			if( null!=OnClientLoseCapture )
				output.AddAttribute( "onlosecapture", OnClientMouseDown );
			if( null!=OnClientMouseDown )
				output.AddAttribute( "onmousedown", OnClientMouseDown );
			if( null!=OnClientMouseEnter )
				output.AddAttribute( "onmouseenter", OnClientMouseEnter );
			if( null!=OnClientMouseLeave )
				output.AddAttribute( "onmouseleave", OnClientMouseLeave );
			if( null!=OnClientMouseMove )
				output.AddAttribute( "onmousemove", OnClientMouseMove );
			if( null!=OnClientMouseOut )
				output.AddAttribute( "onmouseout", OnClientMouseOut );
			if( null!=OnClientMouseOver )
				output.AddAttribute( "onmouseover", OnClientMouseOver );
			if( null!=OnClientMouseUp )
				output.AddAttribute( "onmouseup", OnClientMouseUp );
			if( null!=OnClientMouseWheel )
				output.AddAttribute( "onmousewheel", OnClientMouseWheel );
			if( null!=OnClientMove )
				output.AddAttribute( "onmove", OnClientMove );
			if( null!=OnClientMoveEnd )
				output.AddAttribute( "onmoveend", OnClientMoveEnd );
			if( null!=OnClientMoveStart )
				output.AddAttribute( "onmovestart", OnClientMoveStart );
			if( null!=OnClientPaste )
				output.AddAttribute( "onpaste", OnClientPaste );
			if( null!=OnClientPropertyChange )
				output.AddAttribute( "onpropertychange", OnClientPropertyChange );
			if( null!=OnClientReadyStateChange )
				output.AddAttribute( "onreadystatechange", OnClientReadyStateChange );
			if( null!=OnClientResizeEnd )
				output.AddAttribute( "onresizeend", OnClientResizeEnd );
			if( null!=OnClientResizeStart )
				output.AddAttribute( "onresizestart", OnClientResizeStart );
			if( null!=OnClientScroll )
				output.AddAttribute( "onscroll", OnClientScroll );
			if( null!=OnClientSelect )
				output.AddAttribute( "onselect", OnClientSelect );
			if( null!=OnClientSelectStart )
				output.AddAttribute( "onselectstart", OnClientSelectStart );
			if( null!=OnClientUnload )
				output.AddAttribute( "onunload", OnClientUnload );
		}

		public static PageStyleControl GetDefault()
		{
			PageStyleControl control = new PageStyleControl();
			
			
			 

			//TODO: Build other defaults in.

			return control;
		}

	}
	
	public class UddiControl : System.Web.UI.UserControl
	{
		public bool IsDownlevel
		{
			get { return UddiBrowser.IsDownlevel; }
		}

		public virtual bool EditMode
		{
			get { return ((UddiPage)Page).EditMode; }
		}
		
		public string Root
		{
			get { return ((UddiPage)Page).Root; }
		}
		
		public virtual void CancelEditMode()
		{
			((UddiPage)Page).CancelEditMode();
		}

		public virtual void SetEditMode()
		{
			((UddiPage)Page).SetEditMode();
		}
	}
	
	public class UddiButton : System.Web.UI.WebControls.Button
	{		
		protected bool editModeDisable = false;
        protected bool focus = false;

		public bool EditModeDisable
		{
			get { return editModeDisable; }
			set { editModeDisable = value; }
		}

        public bool Focus
        {
            get { return focus; }
            set { focus = value; }
        }

        public new string Text
		{
			get { return base.Text; }
			set
			{
				//
				// Check to see if the button text needs to be localized.  We
				// use strings of the form [[ID]] to indicate localization is
				// needed.
				//
				if( null != value && value.StartsWith( "[[" ) && value.EndsWith( "]]" ) )
					base.Text = Localization.GetString( value.Substring( 2, value.Length - 4 ) );
				else
					base.Text = value;
			}
		}

		protected override void Render( HtmlTextWriter output )
		{
            bool enabled = Enabled;

            //
			// Check to see if we need to disable this control.  We do
			// this if we are in edit mode and the control is set to
			// autodisable.
			//
			if( EditModeDisable && ((UddiPage)Page).EditMode  )
				Enabled = false;

			//
			// Only render the control if it is enabled, or we're on an IE
			// browser.  Netscape and other browsers do not support the
			// enabled attribute, so we have to prevent the control from
			// rendering on these browsers.
			//
            if( Enabled || UddiBrowser.IsIE5 )
            {
                if( Focus )
                {
                    Page.RegisterStartupScript( 
                        "SetFocus",
                        "<script language='javascript'>SetFocus( '" + UniqueID + "' )</script>" );
                }
			
                base.Render( output );
            }

            Enabled = enabled;
		}
	}

	public class UddiCheckBox : System.Web.UI.WebControls.CheckBox
	{		
		protected bool editModeDisable = false;
        protected bool focus = false;

		public bool EditModeDisable
		{
			get { return editModeDisable; }
			set { editModeDisable = value; }
		}
		
        public bool Focus
        {
            get { return focus; }
            set { focus = value; }
        }
        
        public override string Text
		{
			get { return base.Text; }
			set
			{
				//
				// Check to see if the button text needs to be localized.  We
				// use strings of the form [[ID]] to indicate localization is
				// needed.
				//
				if( null != value && value.StartsWith( "[[" ) && value.EndsWith( "]]" ) )
					base.Text = Localization.GetString( value.Substring( 2, value.Length - 4 ) );
				else
					base.Text = value;
			}
		}

        protected override void Render( HtmlTextWriter output )
        {
            bool enabled = Enabled;

            //
            // Check to see if we need to disable this control.  We do
            // this if we are in edit mode and the control is set to
            // autodisable.
            //
            if( EditModeDisable && ((UddiPage)Page).EditMode )
                Enabled = false;

            //
            // Only render the control if it is enabled, or we're on an IE
            // browser.  Netscape and other browsers do not support the
            // enabled attribute, so we have to prevent the control from
            // rendering on these browsers.
            //
            if( Enabled || UddiBrowser.IsIE5 )
            {
                if( Focus )
                {
                    Page.RegisterStartupScript( 
                        "SetFocus",
                        "<script language='javascript'>SetFocus( '" + UniqueID + "' )</script>" );
                }
			
                base.Render( output );
            }

            Enabled = enabled;
		}
	}

	public class UddiLabel : System.Web.UI.WebControls.Label
	{	
        protected override void Render( HtmlTextWriter output )
		{
            //
			// Check to see if the label text needs to be localized.  We
			// use strings of the form [[ID]] to indicate localization is
			// needed.
			//
            string text = base.Text;

            if( null != text && text.StartsWith( "[[" ) && text.EndsWith( "]]" ) )
			{
				text = Localization.GetString( text.Substring( 2, text.Length - 4 ) );
			}
			else
			{
				text = HttpUtility.HtmlEncode( text );
				
				if( null != text )
					text = text.Replace( "\n", "<br>" ).Replace( "  ", "&nbsp; " );
			}

			base.AddAttributesToRender( output );		
			
			output.RenderBeginTag( HtmlTextWriterTag.Span );
			output.Write( text );
			output.RenderEndTag();
		}
	}
	
	public class UddiTextBox : System.Web.UI.WebControls.TextBox, IPostBackEventHandler
	{
        protected bool editModeDisable = false;
        protected bool selected = false;
		protected bool focus = false;

		public bool Selected
		{
			get { return selected; }
			set { selected = value; }
		}

		public override string Text
		{
			get
			{ 
				//
				// BUG: 759949.  We must strip invalid characters from the strings.
				//
				if( null != base.Text )
					return Utility.XmlEncode( base.Text ); 
				else
					return base.Text;
				
			}
			set
			{ 
				base.Text = value; 
			}
		}

		public bool Focus
		{
			get { return focus; }
			set { focus = value; }
		}

        public bool EditModeDisable
        {
            get { return editModeDisable; }
            set { editModeDisable = value; }
        }
        
        public event EventHandler EnterKeyPressed;

        void IPostBackEventHandler.RaisePostBackEvent( string eventArgument )
        {
            switch( eventArgument )
            {
                case "enterkey":
                    if( null != EnterKeyPressed )
                        EnterKeyPressed( this, new EventArgs() );

                    break;
            }
        }
            
        protected override void Render( HtmlTextWriter output )
		{
            if( EditModeDisable && ((UddiPage)Page).EditMode )
            {
                output.AddAttribute(HtmlTextWriterAttribute.Disabled, null ); 
            }
            else
            {
                if( Selected )
                {
                    Page.RegisterStartupScript( 
                        "Select",
                        "<script language='javascript'>Select( '" + UniqueID + "' )</script>" );
                }
                else if( Focus )
                {
                    Page.RegisterStartupScript( 
                        "SetFocus",
                        "<script language='javascript'>SetFocus( '" + UniqueID + "' )</script>" );
                }

                if( null != EnterKeyPressed )
                    output.AddAttribute( "onkeypress", "if( 13 == event.keyCode ) " + Page.GetPostBackEventReference( this, "enterkey" ) );
            }
            
            base.Render( output );
        }
	}

    public class UddiDataGrid : System.Web.UI.WebControls.DataGrid, IPostBackEventHandler
    {
        void IPostBackEventHandler.RaisePostBackEvent( string eventArgument )
        {
            int page = Convert.ToInt32( eventArgument );
            
            OnPageIndexChanged( 
                new System.Web.UI.WebControls.DataGridPageChangedEventArgs( this, page ) );
        }

        protected override void Render( HtmlTextWriter output )
        {
            bool paging = AllowPaging;

            AllowPaging = false;
            base.Render( output );
            
            if( paging )
            {
                // TODO: Localize!!!
                output.AddAttribute( HtmlTextWriterAttribute.Class, "pagingFooter" );
                output.RenderBeginTag( HtmlTextWriterTag.Span );
                output.Write( String.Format( "Page {0} of {1}: ", CurrentPageIndex + 1, PageCount ) );

                int startPage = ( CurrentPageIndex / PagerStyle.PageButtonCount ) * PagerStyle.PageButtonCount;
                int stopPage = Math.Min( startPage + PagerStyle.PageButtonCount - 1, PageCount - 1 );

                for( int page = startPage; page <= stopPage; page ++ )
                {
                    if( page == CurrentPageIndex )
                    {
                        output.AddAttribute( HtmlTextWriterAttribute.Class, "pageSelected" );
                        output.RenderBeginTag( HtmlTextWriterTag.Span );
                        output.Write( "&nbsp;" + ( page + 1 ) + "&nbsp;" );
                        output.RenderEndTag();
                    }
                    else
                    {
                        output.AddAttribute( HtmlTextWriterAttribute.Class, "page" );
                        output.AddAttribute( HtmlTextWriterAttribute.Href, "javascript:" + Page.GetPostBackEventReference( this, page.ToString() ) );
                        output.RenderBeginTag( HtmlTextWriterTag.A );
                        output.Write( "&nbsp;" + ( page + 1 ) + "&nbsp;" );
                        output.RenderEndTag();
                    }
                }

                output.RenderEndTag();
            }
        }
    }
	public class HyperLinkManager
	{
		
		public static string GetSecureHyperLink( string pagename )
		{
			
			string url = "";
			bool isAbsolute = false;

			int port = Config.GetInt( "Web.HttpsPort",UDDI.Constants.Web.HttpsPort );

            //
			// if 
			// the current context is not secure, and we require HTTPS,
			// - OR - 
			// The Web.HttpsPort is something other than the Default and the current port is not what is configured
			//  
			// we will need to generate an absolute path.
			//
			isAbsolute = ( ( !HttpContext.Current.Request.IsSecureConnection &&
							1==Config.GetInt( "Security.HTTPS", UDDI.Constants.Security.HTTPS ) ) ||
							(  UDDI.Constants.Web.HttpsPort!=port  && HttpContext.Current.Request.Url.Port!=port ) );
			
			
			if( isAbsolute )
			{
				url = GetUrlStart( true );
			}
			
			url+=GetFullFilePath( pagename );
            
			return url;
		}
		public static string GetHyperLink( string pagename )
		{
			return GetHyperLink( pagename, false );
		}
		public static string GetHyperLink( string pagename, bool absolute )
		{
			string url = "";
			if( absolute )
			{
				url = GetUrlStart( HttpContext.Current.Request.IsSecureConnection );
			}
			url += GetFullFilePath( pagename );
			return url;
		}
		public static string GetNonSecureHyperLink( string pagename )
		{
			string url = "";
			
			int port = Config.GetInt( "Web.HttpPort",UDDI.Constants.Web.HttpPort );
			bool isAbsolute = false;

			//
			// if the current context is secure, 
			// - or -
			// the Web.HttpPort is something other than default, and current port is not what is configured
			// we will need to generate an absolute path.
			//
			isAbsolute = HttpContext.Current.Request.IsSecureConnection ||
				( UDDI.Constants.Web.HttpPort!=port && HttpContext.Current.Request.Url.Port!=port );
			
			if( isAbsolute )
			{
				url = GetUrlStart( false );
			}
			
			url += GetFullFilePath( pagename );

			return url;
		}
		private static string GetUrlStart( bool secure )
		{
			string url = "";
			int port = 0;
			if( secure )//build a secure url
			{
				url = "https://" + HttpContext.Current.Request.Url.Host;

				port = Config.GetInt( "Web.HttpsPort",UDDI.Constants.Web.HttpsPort );
				
				if( port!=UDDI.Constants.Web.HttpsPort )
					url += ":" + port.ToString();
			}
			else//build no secure url
			{
				url = "http://" + HttpContext.Current.Request.Url.Host;
				port = Config.GetInt( "Web.HttpPort",UDDI.Constants.Web.HttpPort );
				if( port!=UDDI.Constants.Web.HttpPort )
					url += ":" + port.ToString();
			}

			return url;
		}
		private static string GetFullFilePath( string file )
		{
			string url = ( ( "/"==HttpContext.Current.Request.ApplicationPath) ? "" : HttpContext.Current.Request.ApplicationPath );
			url += file ;
			return url;
		}

	}
	public enum UrlFlags
	{
		Https		= 0x0001,
		Require		= 0x0002,
		Absolute	= 0x0004,
		External	= 0x0008

	}
	public enum UrlOptions
	{
		PreferHttp				= 0x0000,
		PreferHttps				= 0x0001,
		RequireHttp				= 0x0002,
		RequireHttps			= 0x0003,
		PreferHttpAbsolute		= 0x0004,
		PreferHttpsAbsolute		= 0x0005,
		RequireHttpAbsolute		= 0x0006,
		RequireHttpsAbsolute	= 0x0007,
		External				= 0x0008
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\web\categorybrowser.cs ===
using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using System.Web;
using System.Web.UI;
using System.Web.UI.WebControls;
using UDDI;
using UDDI.API;
using UDDI.Diagnostics;

namespace UDDI.Web
{
	/// <summary>
	/// Summary description for categorybrowser.
	/// </summary>
	public class CategoryBrowserControl : UddiControl
	{
		
		protected LinkButton rootLink;
		protected Panel panelTaxonomyList;
		protected Panel panelCategoryChooser;
		protected DataGrid taxonomyList;
		protected DataGrid categoryChooser;
		protected Label  labelCategoryChooser;
		protected Label categoryTree;
		protected TaxonomyTreeControl taxonomyTree;

		private DataView taxonomies;
		
		protected int SelectedTaxonomyItemIndex;
		

		public CategoryBrowserControl()
		{
			
		}


		protected KeyedReferenceCollection categoryBag;
		protected CacheObject cache = null;
 		
		public string ParentKeyValue
		{
			get{ return parentKeyValue; }
		}
		protected string parentKeyValue="";

		public string TaxonomyID
		{
			get{ return taxonomyID; }
		}
		protected string taxonomyID;
 		
 		
		public string TaxonomyName
		{
			get{ return taxonomyName; }	
		}
		protected string taxonomyName;
 		
		
		public string Path
		{
			get{ return path; }
		}
		protected string path="";
 		
		
		public string TModelKey
		{
			get{ return tModelKey; }
		}
		protected string tModelKey;
		
		
		public string KeyName
		{
			get{ return keyName; }
		}
		protected string keyName;
		
		public string KeyValue
		{
			get{ return keyValue; }
		}	
		protected string keyValue;




		public bool ShowNoCategoriesMessage
		{
			get { return showNoCategoriesMessage; }
			set { showNoCategoriesMessage = value; }
		}
		protected bool showNoCategoriesMessage;

		public int TaxonomyCount
		{
			get{ return taxonomies != null ? taxonomies.Count : 0; }
		}

		protected bool showallcategories = false;
		public bool ShowAllCategories
		{
			get{ return showallcategories; }
			set{ showallcategories=value; }
		}

		public void Initialize( KeyedReferenceCollection catbag, CacheObject co )
		{
			showNoCategoriesMessage = true;
			categoryBag = catbag;
			cache = co;	
		}
		
		protected void Page_Init( object sender, EventArgs e )
		{	
		
		}	
		protected void Page_Load( object sender, EventArgs e )
		{
			
			
			
			taxonomyID = Request[ "taxonomyID" ];
			taxonomyName = Request[ "taxonomyName" ];
			tModelKey = Request[ "tModelKey" ];
			keyName = Request[ "keyName" ];
			keyValue = Request[ "keyValue" ];
			
			taxonomyTree.Click += new TaxonomyTreeControlEventHandler( TaxonomyTreeControl_Click );
			if( null!=rootLink )
			{
				rootLink.Text = Localization.GetString( "TAG_AVAILABLE_TAXONOMIES" );
				rootLink.Enabled = (null!=taxonomyID);
				rootLink.Click += new EventHandler( TaxonomyRootLink_Click );
			}	
			Populate();

			
		}
		public void Populate()
		{
			if( null!=taxonomyID && ""!=taxonomyID )
			{
				if( null!=keyValue && ""!=keyValue )
				{
					PopulateTaxonomyTree();
					PopulateCategoryChooser();
				}
			}
			else
			{
				PopulateTaxonomyList( false );
			}
		}
		protected void PopulateTaxonomyList( bool single )
		{
			panelTaxonomyList.Visible = true;
			panelCategoryChooser.Visible = false;
			//DataView taxonomies = null;
			if( !single )
			{
				if( ShowAllCategories )
				{
					//get all taxonomies
					taxonomies = Taxonomy.GetTaxonomies();
				}
				else
				{
					taxonomies = Taxonomy.GetTaxonomiesForBrowsing();
				}
			}
			else
			{
				//get a single taxonomy for the list
				taxonomies = Taxonomy.GetTaxonomiesForBrowsing( "tModelKey = '"+tModelKey+"'","tModelKey" );			
			}
			
			//make sure the visible text is html encoded 
			foreach( DataRowView row in taxonomies )
				row[ "description" ] = HttpUtility.HtmlEncode( (string)row[ "description" ] );
			
			taxonomyList.DataSource = taxonomies;
			taxonomyList.DataBind();
		}
		protected void PopulateTaxonomyTree( )
		{
			panelTaxonomyList.Visible = false;
			panelCategoryChooser.Visible =true ;

			int id=Convert.ToInt32( taxonomyID );
			
			taxonomyTree.TaxonomyID = id;
			taxonomyTree.KeyName = taxonomyName;
			taxonomyTree.KeyValue = "__r00t__";
			
			TaxonomyTreeItemControl item=null;
			
			
			
			if( "__r00t__"!=keyValue && ""!=keyValue )
			{
				string parent = keyValue;
				
				while( null!=parent && ""!=parent )
				{
					if( null==item) item=new TaxonomyTreeItemControl();
					item.KeyValue = parent;
					//replace this with a way to get the keyName with the taxonomyID and the taxonomyValue
					item.KeyName = Taxonomy.GetTaxonomyKeyName( id, parent );
					item.TaxonomyID = id;
					item.Click += new TaxonomyTreeControlEventHandler( TaxonomyTreeControl_Click );
					parent = Taxonomy.GetTaxonomyParent( id, parent );
					if( ""==parent )break;					
					TaxonomyTreeItemControl parentitem = new TaxonomyTreeItemControl();;
					parentitem.SetChild( item );
					item = parentitem;
				
				}
			}
			if( null!=item )
			{
				taxonomyTree.SetChild( item );
				taxonomyTree.SelectItem( item.Count );
			}
			else
				taxonomyTree.SelectItem( 0 );

			
			taxonomyTree.TaxonomyID = id;
			taxonomyTree.KeyName = taxonomyName;
			taxonomyTree.KeyValue = "__r00t__";
			
		}
		protected void PopulateCategoryChooser( )
		{
			panelTaxonomyList.Visible = false;
			panelCategoryChooser.Visible =true ;

			string root = ( "/" == Page.Request.ApplicationPath ) ? "" : Page.Request.ApplicationPath;
			

			int id = Convert.ToInt32( taxonomyID );

			if( Utility.StringEmpty( keyValue ) )
			{
				taxonomies = Taxonomy.GetTaxonomyChildrenRoot( id );				
			}
			else
			{
				taxonomies = Taxonomy.GetTaxonomyChildrenNode( id, keyValue );
			}

			if( 0 == taxonomies.Count )
			{
				categoryChooser.Visible = false;

				if( true == showNoCategoriesMessage )
				{
					labelCategoryChooser.Text = Localization.GetString( "HEADING_NO_CATEGORIES" );
				}
			}
			else
			{
				foreach( DataRowView row in taxonomies )
					row[ "keyName" ] = HttpUtility.HtmlEncode( (string)row[ "keyName" ] );

				categoryChooser.Visible = true;
				
				labelCategoryChooser.Text = Localization.GetString( "TAG_SUBCATEGORIES" );
								
				categoryChooser.DataSource = taxonomies;
				categoryChooser.DataBind();						
			}
			
			
		}
		public void Reset()
		{
			taxonomyID = null;
			taxonomyName = null;
			tModelKey = null;
			keyName = null;
			keyValue = null;
			PopulateTaxonomyList(false);
		}
		protected void CategoryChooser_OnPageChange( object sender, DataGridPageChangedEventArgs e )
		{
			categoryChooser.CurrentPageIndex = e.NewPageIndex;
			PopulateTaxonomyTree();
			PopulateCategoryChooser();
		}
		protected void CategoryChooser_Command( object sender, DataGridCommandEventArgs e )
		{
			switch( e.CommandName )
			{
				case "select":
					
					categoryChooser.CurrentPageIndex = 0;
					taxonomyID = e.Item.Cells[ 0 ].Text;
					parentKeyValue = e.Item.Cells[ 1 ].Text;
					keyName = e.Item.Cells[ 2 ].Text;
					keyValue = e.Item.Cells[ 4 ].Text;
					
					//path = path + "/:/" + keyName ;//+ "|" + keyValue + "|" + taxonomyID;
					PopulateTaxonomyTree();
					PopulateCategoryChooser();
					
					if( null!=cache )
					{
						cache.FindBusiness.CategoryBag.Clear();
						cache.FindBusiness.CategoryBag.Add( keyName, keyValue, "uuid:"+tModelKey );
					
						cache.FindService.CategoryBag.Clear();
						cache.FindService.CategoryBag.Add( keyName, keyValue, "uuid:"+tModelKey );
					
						cache.FindTModel.CategoryBag.Clear();
						cache.FindTModel.CategoryBag.Add( keyName, keyValue, "uuid:"+tModelKey );

						cache.Save();
					}

					if( null!=this.categoryBag )
					{

					}

					break;
			
				default:
					break;
			}
		}
		protected void TaxonomyList_OnCommand( object sender, DataGridCommandEventArgs e )
		{
			switch( e.CommandName )
			{
				case "browse":
					categoryChooser.CurrentPageIndex = 0;
					panelTaxonomyList.Visible = false; 
					panelCategoryChooser.Visible = true;
					categoryChooser.CurrentPageIndex = 0;
					taxonomyID = e.Item.Cells[ 0 ].Text;
					taxonomyName = e.Item.Cells[ 1 ].Text;
					tModelKey = e.Item.Cells[ 3 ].Text;
					
					keyName = "";
					keyValue = "";
					path = "";
								
					PopulateTaxonomyTree();
					PopulateCategoryChooser();
					
					break;
				default:
					break;
			}
			
			
		}

		

		
		private void TaxonomyRootLink_Click( object sender, EventArgs e )
		{
			this.Reset();
		}
		private void TaxonomyTreeControl_Click( object sender, TaxonomyTreeControlEventArgs e )
		{
						
			//reset the page index on the categoryChooser
			this.categoryChooser.CurrentPageIndex = 0;		
			
			//set the relevent info from the selected taxonomy item
			this.taxonomyID = e.Item.TaxonomyID.ToString();
			this.keyName = e.Item.KeyName;
			this.keyValue = ( ( "__r00t__"==e.Item.KeyValue)?"":e.Item.KeyValue);				

			//populate the data
			this.PopulateTaxonomyTree();
			this.PopulateCategoryChooser();
			
		}
		
	}
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\web\contacts.cs ===
using System;
using System.Data;
using System.Web.UI;
using System.Web.UI.WebControls;
using UDDI;
using UDDI.API;
using UDDI.API.Business;
using UDDI.API.ServiceType;
using UDDI.Diagnostics;

namespace UDDI.Web
{
	public class ContactControl : UddiControl
	{
		protected ContactCollection contacts;
        protected BusinessEntity parent;
        protected bool frames;

		protected DataGrid grid;

		public void Initialize( ContactCollection contacts, BusinessEntity parent, bool allowEdit )
		{
			this.contacts = contacts;
            this.parent = parent;

            grid.Columns[ 0 ].Visible = allowEdit;
            grid.Columns[ 1 ].Visible = allowEdit;
            grid.Columns[ 2 ].Visible = !allowEdit;
        }
		
        protected void Page_Load( object sender, EventArgs e )
        {
            frames = ( "true" == Request[ "frames" ] );
            
            PopulateDataGrid();
        }

		void PopulateDataGrid()
		{
			grid.DataSource = contacts;
			grid.DataBind();
		}
		
		protected void Contact_Edit( object sender, DataGridCommandEventArgs e )
		{
			int index = e.Item.ItemIndex;
			
            if( frames )
            {
                Response.Write(
                    ClientScripts.ReloadExplorerAndViewPanes( "editcontact.aspx?frames=true&key=" +  parent.BusinessKey + "&index=" + index, parent.BusinessKey + ":" + index ) );
            
                Response.End();
            }
            else
            {                                      
                Response.Redirect( "editcontact.aspx?frames=false&key=" + parent.BusinessKey + "&index=" + index );
                Response.End();
            }
		}

		protected void Contact_Delete( object sender, DataGridCommandEventArgs e )
		{
            int index = e.Item.ItemIndex;
            
            string name = contacts[ index ].PersonName;
            string key = parent.BusinessKey;

            //
            // The user has not yet confirmed the delete operation, so display
            // a confirmation dialog.
            //
            string message = String.Format( 
                Localization.GetString( "TEXT_DELETE_CONFIRMATION" ), 
                name );
				
            Page.RegisterStartupScript(
                "Confirm",
                ClientScripts.Confirm(
                message,
                "editcontact.aspx?frames=" + ( frames ? "true" : "false" ) + "&key=" + key + "&index=" + index + "&mode=delete&confirm=true&tab=2" ) );
		}

		protected void Contact_Add( object sender, EventArgs e )
		{
			Response.Redirect( "editcontact.aspx?frames=" + ( frames ? "true" : "false" ) + "&key=" +  parent.BusinessKey + "&mode=add" );
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\web\email.cs ===
using System;
using System.Data;
using System.Web.UI;
using System.Web.UI.WebControls;
using UDDI.API;
using UDDI.API.Business;
using UDDI.API.ServiceType;
using UDDI;
using UDDI.Diagnostics;

namespace UDDI.Web
{
	public class EmailControl : UddiControl
	{
		protected EmailCollection emails;
		protected EntityBase entity;

		protected DataGrid grid;
		
		public void Initialize( EmailCollection emails )
		{
			this.emails = emails;
			
			grid.Columns[ 1 ].Visible = false;
		}
			
		public void Initialize( EmailCollection emails, EntityBase entity )
		{
			this.emails = emails;
			this.entity = entity;
			
			grid.Columns[ 1 ].Visible = true;
		}
		
		protected void Page_Init( object sender, EventArgs e )
		{
			grid.Columns[ 0 ].HeaderText = Localization.GetString( "HEADING_EMAIL" );
			grid.Columns[ 1 ].HeaderText = Localization.GetString( "HEADING_ACTIONS" );
		}
		
		protected void Page_Load( object sender, EventArgs e )
		{
			if( !Page.IsPostBack )
				PopulateDataGrid();

			if( grid.EditItemIndex >= 0 )
				SetEditMode();
		}
		
		void PopulateDataGrid()
		{			
			grid.DataSource = emails;
			grid.DataBind();
		}
	    
		protected void DataGrid_Edit( object sender, DataGridCommandEventArgs e )
		{
			int index = e.Item.ItemIndex;
			
			grid.EditItemIndex = index;
			SetEditMode();

			PopulateDataGrid();
		}
	    
        protected void OnEnterKeyPressed( object sender, EventArgs e )
        {
            DataGrid_Update( sender, null );
        }

		protected void DataGrid_Update( object sender, DataGridCommandEventArgs e )
		{
			Page.Validate();
			
			if( Page.IsValid )
			{			
				int index = grid.EditItemIndex;
				
				if( index >= emails.Count )
					emails.Add();
				
				Email email = emails[ index ];
				
                DataGridItem item = grid.Items[ index ];
                
                email.Value = ((TextBox)item.FindControl( "email" )).Text;
				email.UseType = ((TextBox)item.FindControl( "useType" )).Text;
				
				entity.Save();
		    
				grid.EditItemIndex = -1;
				CancelEditMode();

				PopulateDataGrid();
			}
		}

		protected void DataGrid_Cancel( object sender, DataGridCommandEventArgs e )
		{
			grid.EditItemIndex = -1;
			CancelEditMode();
			
			PopulateDataGrid();
		}   

		protected void DataGrid_Delete( object sender, DataGridCommandEventArgs e )
		{
			int index = e.Item.ItemIndex;
			
			emails.RemoveAt( index );    		
			entity.Save();
	    
			PopulateDataGrid();
		}   

		protected void DataGrid_Add( object sender, EventArgs e )
		{
			grid.EditItemIndex = emails.Count;
			SetEditMode();
			
			emails.Add();
			
			PopulateDataGrid();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\web\explorer.cs ===
using System;
using System.Web.UI;
using UDDI;
using UDDI.API;
using UDDI.API.Business;
using UDDI.API.Service;
using UDDI.API.Binding;
using UDDI.API.ServiceType;
using UDDI.Diagnostics;

namespace UDDI.Web
{
	public class ExplorerControl : UserControl
	{
		protected EntityBase entity;
		protected int elementIndex = -1;
		protected string key = "";
		protected bool frames = false;
		
		protected TreeView tree;

		public void Initialize( EntityBase entity )
		{
			this.entity = entity;
		}
		
		public void Initialize( EntityBase entity, int elementIndex )
		{
			this.entity = entity;
			this.elementIndex = elementIndex;
		}	
		
		protected override void OnInit( EventArgs e )
		{
			key = Request[ "key" ];
			frames = ( "true" == Request[ "frames" ] );
		}
		
		protected override void OnPreRender( EventArgs e )
		{
			if( null == entity )
				return;
		
			string root = ( "/" == Request.ApplicationPath ) ? "" : Request.ApplicationPath;

			int contactIndex = 0;
			int instanceIndex = 0;

			EntityBase rootEntity = null;

			if( entity is BusinessEntity )
			{
				rootEntity = entity;
				
				if( -1 != elementIndex )
					key = ((BusinessEntity)entity).BusinessKey + ":" + elementIndex;
				else
					key = ((BusinessEntity)entity).BusinessKey;
			}
			else if( entity is TModel )
			{
				rootEntity = entity;
				key = ((TModel)entity).TModelKey;
			}
			else if( entity is BusinessService )
			{
				BusinessEntity business = new BusinessEntity();
				BusinessService service = (BusinessService)entity;

				key = service.ServiceKey;
				
				business.BusinessKey = service.BusinessKey;
				business.Get();

				rootEntity = business;
			}
			else if( entity is BindingTemplate )
			{
				BusinessEntity business = new BusinessEntity();
				BusinessService service = new BusinessService();
				BindingTemplate binding = (BindingTemplate)entity;

				if( -1 != elementIndex )
					key = binding.BindingKey + ":" + elementIndex;
				else
					key = binding.BindingKey;
				
				service.ServiceKey = binding.ServiceKey;
				service.Get();

				business.BusinessKey = service.BusinessKey;
				business.Get();

				rootEntity = business;
			}

			//
			// Setup explorer information section.
			//
			if( rootEntity is BusinessEntity )
			{
				BusinessEntity business = rootEntity as BusinessEntity;

				//
				// Build explorer tree.
				//
				TreeNode businessNode = tree.Nodes.Add( 
					business.Names[ 0 ].Value,
					business.BusinessKey, 
					"../images/business.gif" );

				businessNode.OnClick = "Entity_OnSelect( [[node]], '../details/businessdetail.aspx?key=" + business.BusinessKey + Iff( frames, "&frames=true", "" ) + "' )";
                businessNode.Tooltip = Localization.GetString( "TOOLTIP_SEARCH_PROVIDER" );

				if( key == business.BusinessKey )
					businessNode.Select();
					
				
				contactIndex = 0;
				
				foreach( Contact contact in business.Contacts )
				{
					TreeNode contactNode = businessNode.Nodes.Add( 
						contact.PersonName, 
						business.BusinessKey + ":" + contactIndex, 
						"../images/contact.gif" );

					contactNode.OnClick = "Entity_OnSelect( [[node]], '../details/contactdetail.aspx?key=" + business.BusinessKey + "&index=" + contactIndex + Iff( frames, "&frames=true", "" ) + "' )";
                    contactNode.Tooltip = Localization.GetString( "TOOLTIP_SEARCH_CONTACT" );

					if( key == business.BusinessKey + ":" + contactIndex )
						contactNode.Select();
					
					contactIndex ++;
				}

				//sort the services
				business.BusinessServices.Sort();

				foreach( BusinessService service in business.BusinessServices )
				{
					if( service.BusinessKey.ToLower() != business.BusinessKey.ToLower() )
					{
						//
						// Added logic to catch errors on this.
						// if the refrenced service doesn't exist, 
						// then we can't get the name, thus we get 
						// an error.
						//
					
						TreeNode nodeService;
					
						//
						// if there are names, then the service projections still exists,
						// use the first name in teh collection.
						// otherwise leave name as the broken projection string.
						//
						if( service.Names.Count>0 )
						{
							nodeService = businessNode.Nodes.Add(
								service.Names[ 0 ].Value,
								service.ServiceKey,
								"../images/service_projection.gif" );
						
							nodeService.OnClick = "Entity_OnSelect( [[node]], '../details/servicedetail.aspx?key=" + service.ServiceKey + Iff( frames, "&frames=true", "" ) + "&projectionKey="+business.BusinessKey+"' )";
							nodeService.Tooltip = Localization.GetString( "TOOLTIP_SEARCH_SERVICEPROJECTION" );
						}
						else
						{
							nodeService = businessNode.Nodes.Add(
								Localization.GetString( "BUTTON_PROJECTIONBROKEN" ),
								service.ServiceKey,
								"../images/x.gif" );
						
							nodeService.OnClick = "javascript:alert('"+Localization.GetString( "TOOLTIP_PROJECTIONBROKEN" )+"');";
							nodeService.Tooltip = Localization.GetString( "TOOLTIP_PROJECTIONBROKEN" );
						}					
						
					}
					else
					{
					
						TreeNode serviceNode = businessNode.Nodes.Add( 
							service.Names[ 0 ].Value, 
							service.ServiceKey, 
							"../images/service.gif" );

						serviceNode.OnClick = "Entity_OnSelect( [[node]], '../details/servicedetail.aspx?key=" + service.ServiceKey + Iff( frames, "&frames=true", "" ) + "' )";
						serviceNode.Tooltip = Localization.GetString( "TOOLTIP_SEARCH_SERVICE" );

						if( key == service.ServiceKey )
							serviceNode.Select();
					
						int bindingCount = 0;
						foreach( BindingTemplate binding in service.BindingTemplates )
						{
							bindingCount ++;
						
							TreeNode bindingNode = serviceNode.Nodes.Add( 
								UDDI.Utility.StringEmpty( binding.AccessPoint.Value ) 
								? Localization.GetString( "HEADING_NONE" ) 
								: binding.AccessPoint.Value, 
								binding.BindingKey, 
								"../images/binding.gif" );
						
							bindingNode.OnClick = "Entity_OnSelect( [[node]], '../details/bindingdetail.aspx?key=" + binding.BindingKey + Iff( frames, "&frames=true", "" ) + "' )";
							bindingNode.Tooltip = Localization.GetString( "TOOLTIP_SEARCH_BINDING" );

							if( key == binding.BindingKey )
								bindingNode.Select();
						
							instanceIndex = 0;
							foreach( TModelInstanceInfo instance in binding.TModelInstanceInfos )
							{
								TreeNode instanceNode = bindingNode.Nodes.Add( 
									UDDI.Utility.StringEmpty( instance.TModelKey ) 
									? Localization.GetString( "HEADING_NONE" ) 
									: Lookup.TModelName( instance.TModelKey ), 
									binding.BindingKey + ":" + instanceIndex, 
									"../images/instance.gif" );							
							
								instanceNode.OnClick = "Entity_OnSelect( [[node]], '../details/instanceinfodetail.aspx?key=" + binding.BindingKey + "&index=" + instanceIndex + Iff( frames, "&frames=true", "" ) + "' )";
								instanceNode.Tooltip = Localization.GetString( "TOOLTIP_SEARCH_INSTANCE_INFO" );

								if( key == binding.BindingKey + ":" + instanceIndex )
									instanceNode.Select();
							
								instanceIndex ++;
							}
						}
					}
				}		
			}
			else if( rootEntity is TModel )
			{
				TModel tModel = rootEntity as TModel;

				//
				// Build explorer tree.
				//
				TreeNode nodeTModel = tree.Nodes.Add( 
					tModel.Name, 
					tModel.TModelKey, 
					"../images/tmodel.gif" );
				
				nodeTModel.OnClick = "Entity_OnSelect( [[node]], '../details/modeldetail.aspx?key=" + Conversions.GuidStringFromKey( tModel.TModelKey ) + Iff( frames, "&frames=true", "" ) + "' )";
                nodeTModel.Tooltip = Localization.GetString( "TOOLTIP_SEARCH_TMODEL" );
				nodeTModel.Select();
			}
			else
			{
				Debug.Assert( false, "Unknown root entity '" + rootEntity.ToString() + "'." );
			}				

			if( null != tree.SelectedNode )
			{		
				tree.SelectedNode.EnsureVisible();
				tree.SelectedNode.Expand();
			}
		}
		
		//
		// TODO: IIF function may not be required, consider using C# tenery operator
		//

		protected string Iff( bool expr, string trueResult, string falseResult )
		{
			if( expr )
				return trueResult;
			else
				return falseResult;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\web\discoveryurl.cs ===
using System;
using System.Data;
using System.Web.UI;
using System.Web.UI.WebControls;
using UDDI.API;
using UDDI.API.Business;
using UDDI.API.ServiceType;
using UDDI;
using UDDI.Diagnostics;

namespace UDDI.Web
{
	public class DiscoveryUrlControl : UddiControl
	{
		protected DiscoveryUrlCollection discoveryUrls;
		
		protected BusinessEntity parentEntity = null;
        protected string BusinessKey = "";
		
		protected DataGrid grid;

		public override void DataBind()
		{
			base.DataBind();
			grid.DataBind();
		}

		public void Initialize( DiscoveryUrlCollection discUrls) 
		{
			this.discoveryUrls =  ShuffleData( discUrls );
			grid.Columns[ 1 ].Visible = false;
		}
		
		public void Initialize( DiscoveryUrlCollection discUrls, BusinessEntity parentEntity ) 
		{
			//set the parenet entity
			this.parentEntity = parentEntity;
			
			//capture the be key
			this.BusinessKey = this.parentEntity.BusinessKey;
			
			//reorganize the discoveryUrls to mantian order. 
			//we need the default to be the first in the collection.
			this.discoveryUrls =  ShuffleData( discUrls );
			
			
			grid.Columns[ 1 ].Visible = true;
		}
		
		protected void Page_Init( object sender, EventArgs e )
		{			
			grid.Columns[ 0 ].HeaderText = Localization.GetString( "HEADING_DISCOVERYURL" );
			grid.Columns[ 1 ].HeaderText = Localization.GetString( "HEADING_ACTIONS" );	
		}
		
		protected void Page_Load( object sender, EventArgs e )
		{
			if( !Page.IsPostBack )
				PopulateDataGrid();
		}
		DiscoveryUrlCollection ShuffleData( DiscoveryUrlCollection discurls )
		{
			foreach( DiscoveryUrl d in discurls )
			{
				// move the default one to the begining of the list to 
				// fix bug: 1229
				if( d.IsDefault( BusinessKey ) )
				{
					discurls.Remove( d );
					discurls.Insert( 0, d );
					break;
				}
			}
			return discurls;

		}
		void PopulateDataGrid()
		{
			
			grid.DataSource = discoveryUrls;
			grid.DataBind();
		}
		
		protected void DiscoveryUrl_Edit( object sender, DataGridCommandEventArgs e )
		{
			int index = e.Item.ItemIndex;
			
			grid.EditItemIndex = index;
			SetEditMode();

			grid.ShowFooter = false;		
			
			PopulateDataGrid();
		}
	    
        protected void OnEnterKeyPressed( object sender, EventArgs e )
        {
            DiscoveryUrl_Update( sender, null );
        }
		public string TruncateUrl( string input )
		{
			if( null!=input && input.Length>80 )
				return input.Substring( 0, 77 ) + "...";
			else
				return input;
		}
		protected void DiscoveryUrl_Update( object sender, DataGridCommandEventArgs e )
		{
			Page.Validate();
			
			if( Page.IsValid )
			{
				int index = grid.EditItemIndex;
				
				if( index == discoveryUrls.Count )
					discoveryUrls.Add();
				
				DiscoveryUrl discoveryUrl = discoveryUrls[ index ];
							
				DataGridItem item = grid.Items[ index ];
                
                discoveryUrl.Value = ((TextBox)item.FindControl( "discoveryUrl" )).Text;
				discoveryUrl.UseType = ((TextBox)item.FindControl( "useType" )).Text;
				

				parentEntity.Save();
		    
				grid.EditItemIndex = -1;
				grid.ShowFooter = true;		

				CancelEditMode();
				
				this.discoveryUrls =  ShuffleData( parentEntity.DiscoveryUrls );

				PopulateDataGrid();
			}
		}

		protected void DiscoveryUrl_Cancel( object sender, DataGridCommandEventArgs e )
		{
			grid.EditItemIndex = -1;
			grid.ShowFooter = true;
		
			CancelEditMode();
			
			PopulateDataGrid();
		}   

		protected void DiscoveryUrl_Delete( object sender, DataGridCommandEventArgs e )
		{
			int index = e.Item.ItemIndex;
		
			discoveryUrls.RemoveAt( index );    
			
			parentEntity.Save();		
			
			grid.EditItemIndex = -1;

			this.discoveryUrls =  ShuffleData( parentEntity.DiscoveryUrls );
			
			PopulateDataGrid();
		}   

		protected void DiscoveryUrl_Add( object sender, EventArgs e )
		{
			grid.EditItemIndex = discoveryUrls.Count;
			grid.ShowFooter = false;	
	
			SetEditMode();

			discoveryUrls.Add();

			PopulateDataGrid();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\web\description.cs ===
using System;
using System.Data;
using System.Web.UI;
using System.Web.UI.WebControls;
using UDDI;
using UDDI.API;
using UDDI.API.Business;
using UDDI.API.ServiceType;
using UDDI.Diagnostics;

namespace UDDI.Web
{
	public class DescriptionControl : UddiControl
	{
		protected DescriptionCollection descriptions;
		protected EntityBase entity;

		protected DataGrid grid;

		public void Initialize( DescriptionCollection descriptions )
		{
			this.descriptions = descriptions;

			grid.Columns[ 1 ].Visible = false;
		}

		public void Initialize( DescriptionCollection descriptions, EntityBase entity )
		{
			this.descriptions = descriptions;
			this.entity = entity;

			grid.Columns[ 1 ].Visible = true;
		}
		
		protected void Page_Load( object sender, EventArgs e )
		{
			if( !Page.IsPostBack )
				PopulateDataGrid();
		}			
		
		void PopulateDataGrid()
		{
			grid.DataSource = descriptions;
			grid.DataBind();
		}
		
		protected DataView GetLanguages()
		{
			DataView view = Lookup.GetLanguages();
			
			int index = 0;
			foreach( Description description in descriptions )
			{
				if( index != grid.EditItemIndex )			
				{
					foreach( DataRowView row in view )				
					{
						if( row[ "isoLangCode" ].ToString() == description.IsoLangCode )
						{
							row.Delete();
							break;
						}
					}
				}
				
				index ++;
			}

			return view;
		}
	    
		protected void Description_OnEdit( object sender, DataGridCommandEventArgs e )
		{
			int index = e.Item.ItemIndex;
			
			grid.EditItemIndex = index;
			SetEditMode();
			
			PopulateDataGrid();

			Description description = descriptions[ index ];

			DropDownList list = (DropDownList)grid.Items[ index ].Cells[ 1 ].FindControl( "language" );
			
			if( null != list )
			{
				ListItem item = list.Items.FindByValue( description.IsoLangCode );
				
				if( null != item )
					item.Selected = true;
				else
				{
					item = new ListItem( description.IsoLangCode, description.IsoLangCode );
					list.Items.Add( item );
					item.Selected = true;
				}
			}
		}
	    
		protected void Description_OnUpdate( object sender, DataGridCommandEventArgs e )
		{
			Page.Validate();
			
			if( Page.IsValid )
			{    
				string text = "";
				
				int index = grid.EditItemIndex;
				
				if( index >= descriptions.Count )
					descriptions.Add( "" );
				
				Description description = descriptions[ index ];
				
				description.IsoLangCode = ((DropDownList)e.Item.FindControl( "language" )).SelectedItem.Value;
				text = ((TextBox)e.Item.FindControl( "description" )).Text.Trim();
				
				description.Value = text;
				entity.Save();
		    
				grid.EditItemIndex = -1;
				CancelEditMode();
				
				PopulateDataGrid();
			}
		}

		protected void Description_OnCancel( object sender, DataGridCommandEventArgs e )
		{
			grid.EditItemIndex = -1;
			CancelEditMode();
			
			PopulateDataGrid();
		}   

		protected void Description_OnDelete( object sender, DataGridCommandEventArgs e )
		{
			int index = e.Item.ItemIndex;
			
			descriptions.RemoveAt( index );    		
			entity.Save();
	    
			PopulateDataGrid();
		}   

		protected void Description_OnAdd( object sender, EventArgs e )
		{
			int index = descriptions.Count;
			
			grid.EditItemIndex = index;
			SetEditMode();

			descriptions.Add( "" );
			PopulateDataGrid();

			DropDownList list = (DropDownList)grid.Items[ index ].Cells[ 1 ].FindControl( "language" );		
			ListItem item = list.Items.FindByValue( Localization.GetCulture().TwoLetterISOLanguageName );
				
			if( null != item )
				item.Selected = true;		
		}   
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\web\format.cs ===
using System;
using System.Data;
using System.Web;
using System.Web.UI.WebControls;
using UDDI;

namespace UDDI.Web
{
	public class DataRowViewAccessor
	{
		public static int GetInt( DataGridItem item, string field )
		{
			DataRowView row = (DataRowView)item.DataItem;

			object data = row[ field ];

			if( null == data )
				return 0;

			return Convert.ToInt32( data );
		}

		public static string GetString( DataGridItem item, string field )
		{
			return GetString( item, field, false );
		}

		public static string GetString( DataGridItem item, string field, bool encode )
		{
			DataRowView row = (DataRowView)item.DataItem;

			object data = row[ field ];

			if( null == data )
				return null;
			else if( encode )
				return HttpUtility.HtmlEncode( data.ToString() );

			return data.ToString();
		}

		public static string GetStringOrNone( DataGridItem item, string field, bool encode )
		{
			string data = GetString( item, field, encode );

			if( Utility.StringEmpty( data ) )
				return Localization.GetString( "HEADING_NONE" );

			return data;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\web\editcontrol.cs ===
using System;
using System.Web;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Collections;
using System.Collections.Specialized;

namespace UDDI.Web
{
	public class EditControl : WebControl, INamingContainer
	{	
		protected ITemplate itemTemplate = null;
		protected ITemplate editItemTemplate = null;
		protected Control activeControl = null;
		
		public event CommandEventHandler EditCommand;
		public event CommandEventHandler CancelCommand;
		public event CommandEventHandler UpdateCommand;
						
		public Control ActiveControl
		{
			get 
			{ 
				EnsureChildControls();
				
				if( EditMode )
					return Controls[ 1 ];
				else
					return Controls[ 0 ];
			}
		}

		public bool EditMode
		{
			get 
			{ 
				if( null == ViewState[ "EditMode" ] )
					return false;

				return (bool)ViewState[ "EditMode" ]; 
			}
		}

		public void CancelEditMode()
		{
			ViewState[ "EditMode" ] = false; 
			
			Controls[ 0 ].Visible = true;
			Controls[ 1 ].Visible = false;

			((UddiPage)Page).CancelEditMode();
		}

		public void SetEditMode()
		{
			ViewState[ "EditMode" ] = true; 			

			Controls[ 0 ].Visible = false;
			Controls[ 1 ].Visible = true;

			((UddiPage)Page).SetEditMode();
		}
		
		protected override bool OnBubbleEvent( object source, EventArgs e ) 
		{
			if( e is CommandEventArgs )
			{
				switch( ((CommandEventArgs)e).CommandName.ToLower() )
				{
					case "edit":
						if( null != EditCommand )
						{	
							EditCommand( this, new CommandEventArgs( "Edit", ActiveControl ) );
							return true;
						}

						break;
					
					case "update":
						if( null != UpdateCommand )
						{
							UpdateCommand( this, new CommandEventArgs( "Update", ActiveControl ) );
							return true;
						}

						break;
					
					case "cancel":
						if( null != CancelCommand )
						{
							CancelCommand( this, new CommandEventArgs( "Cancel", ActiveControl ) );
							return true;
						}
						break;
				}
			}
			
			return false;
		}
		
		[ TemplateContainer( typeof( EditControlItem ) ) ]
		public ITemplate EditItemTemplate
		{
			get { return editItemTemplate; }
			set { editItemTemplate = value; }
		}

		[ TemplateContainer( typeof( EditControlItem ) ) ]
		public ITemplate ItemTemplate
		{
			get { return itemTemplate; }
			set { itemTemplate = value; }
		}

		protected override void CreateChildControls()
		{
			Controls.Clear();

			EditControlItem item = new EditControlItem();

			item.ID = "item";
			ItemTemplate.InstantiateIn( item );
			Controls.Add( item );

			item.DataBind();

			EditControlItem editItem = new EditControlItem();

			EditItemTemplate.InstantiateIn( editItem );
			editItem.ID = "editItem";
			Controls.Add( editItem );

			editItem.DataBind();
				
			Controls[ 0 ].Visible = !EditMode;
			Controls[ 1 ].Visible = EditMode;
		}
	}

	//
	// TODO: Remove unused method and class
	//

	public class EditControlItem : Control, INamingContainer
	{
		public EditControlItem()
		{
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\web\identifierbag.cs ===
using System;
using System.Data;
using System.Web.UI;
using System.Web.UI.WebControls;
using UDDI.API;
using UDDI.API.Business;
using UDDI.API.ServiceType;
using UDDI;
using UDDI.Diagnostics;
using UDDI.Web;

namespace UDDI.Web
{
	public class IdentifierBagControl : UddiControl
	{
		protected KeyedReferenceCollection identifierBag;
		protected CacheObject cache = null;
		protected EntityBase entity = null;
				
		protected DataGrid grid;

		public void Initialize( KeyedReferenceCollection identifierBag )
		{
			this.identifierBag = identifierBag;

			grid.Columns[ 1 ].Visible = false;
		}
		
		public void Initialize( KeyedReferenceCollection identifierBag, EntityBase entity )
		{
			this.identifierBag = identifierBag;
			this.entity = entity;
			
			grid.Columns[ 1 ].Visible = true;
		}
		
		public void Initialize( KeyedReferenceCollection identifierBag, CacheObject cache )
		{
			this.identifierBag = identifierBag;
			this.cache = cache;
			
			grid.Columns[ 1 ].Visible = true;
		}

		protected void Page_Load( object sender, EventArgs e )
		{
			if( !Page.IsPostBack )
				PopulateDataGrid();

			if( grid.EditItemIndex >= 0 )
				SetEditMode();
		}
		
		void PopulateDataGrid()
		{
			grid.DataSource = identifierBag;
			grid.DataBind();
		}

		protected void Identifier_Edit( object sender, DataGridCommandEventArgs e )
		{
			int index = e.Item.ItemIndex;
					    
			grid.EditItemIndex = index;
			SetEditMode();
			
			PopulateDataGrid();

			if( index >= identifierBag.Count )
				identifierBag.Add();
			
			KeyedReference keyedReference = identifierBag[ index ];

			DropDownList list = (DropDownList)grid.Items[ index ].Cells[ 0 ].FindControl( "tModelKey" );
			if( null != list )
			{
				ListItem item = list.Items.FindByValue( keyedReference.TModelKey.Substring( 5 ) );
				
				if( null != item )
					item.Selected = true;
			}
		}
        
        protected void OnEnterKeyPressed( object sender, EventArgs e )
        {
            Identifier_Update( sender, null );
        }
	    
		protected void Identifier_Update( object sender, DataGridCommandEventArgs e )
		{
			Page.Validate();

            if( Page.IsValid )
            {
                int index = grid.EditItemIndex;
    			DataGridItem item = grid.Items[ index ];

                if( index >= identifierBag.Count )
                    identifierBag.Add();
    			
                KeyedReference keyedReference = identifierBag[ index ];
    			
                string tModelKey = ((DropDownList)item.FindControl( "tModelKey" )).SelectedItem.Value;

                keyedReference.TModelKey = "uuid:" + tModelKey;
                keyedReference.KeyName = ((TextBox)item.FindControl( "keyName" )).Text;
                keyedReference.KeyValue = ((TextBox)item.FindControl( "keyValue" )).Text;
    	    
                if( null != entity )
                    entity.Save();
    				
                if( null != cache )
                    cache.Save();
    	    
                grid.EditItemIndex = -1;
                CancelEditMode();

                PopulateDataGrid();
            }
        }

		protected void Identifier_Cancel( object sender, DataGridCommandEventArgs e )
		{
			grid.EditItemIndex = -1;
			CancelEditMode();
			
			PopulateDataGrid();
		}   

		protected void Identifier_Delete( object sender, DataGridCommandEventArgs e )
		{
			int index = e.Item.ItemIndex;
			
			identifierBag.RemoveAt( index );    
			
			if( null != entity )
				entity.Save();
			
			if( null != cache )
				cache.Save();
			
			PopulateDataGrid();
		}   

		protected void Identifier_Add( object sender, EventArgs e )
		{
			grid.EditItemIndex = identifierBag.Count;
			SetEditMode();
			
            identifierBag.Add();

			PopulateDataGrid();
		}   
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\web\header.cs ===
using System;
using System.Globalization;
using System.IO;
using System.Security.Principal;
using System.Web;
using System.Web.UI;
using System.Web.UI.HtmlControls;
using System.Web.UI.WebControls;
using UDDI;

namespace UDDI.Web
{
	public class HeaderControl : UserControl
	{
		
		protected PlaceHolder beta = null;
		protected PlaceHolder test = null;
		protected PlaceHolder edit = null;
		protected PlaceHolder coordinate = null;
		protected UddiLabel user = null;
		protected UddiLabel role = null;
		
		//protected string rootpath;
		protected string root;
		protected string roots;

        protected string isoLangCode;
        protected string[] links;
        protected HtmlSelect quickHelp;
        protected HtmlInputButton go;

		protected bool frames = false;
		
		public bool Frames
		{
			get { return frames; }
			set { frames = value; }
		}
		
		
        protected override void OnInit( EventArgs e )
        {
         	
            Response.Expires = -1;
            Response.AddHeader( "Cache-Control", "no-cache" );
            Response.AddHeader( "Pragma", "no-cache" );
		
			root = HyperLinkManager.GetHyperLink( "" );
			roots = HyperLinkManager.GetSecureHyperLink( "" );

			if( null != beta && 1 == Config.GetInt( "Web.BetaSite", 0 ) )
				beta.Visible = true;

			if( null != test && 1 == Config.GetInt( "Web.TestSite", 0 ) )
				test.Visible = true;
        }
        
        protected override void OnLoad( EventArgs e )
        {
            if( !Page.IsPostBack && null != links )
            {
                for( int i = 0; i < links.Length; i += 2 )
                {
                    string filename = links[ i + 1 ];
                    
                    //
					// 'cultureIDValue is expected to contain a neutral culture.  ie,
					// 'en', or 'ko', or 'de'.  All but a few neutral cultures have
					// a default specific culture.  For example, the default specific
					// culture of 'en' is 'en-US'.
					//
					// Traditional & simplified Chinese (zh-CHT and zh-CHS respectively)
					// are examples of neutral cultures which have no default specific
					// culture!
					//
					// So what happens below is this:  First we try to lookup the default
					// specific culture for the neutral culture that we were given.  If that
					// fails (ie, if CreateSpecificCulture throws), we just get the lcid
					// of the neutral culture.
					//
                    string defaultlang = Config.GetString( "Setup.WebServer.ProductLanguage","en" );
					int defaultlcid = 1033;
                    int userlcid = Localization.GetCulture().LCID;
                    
                    try
					{
						defaultlcid = CultureInfo.CreateSpecificCulture( defaultlang ).LCID;
					}
					catch
					{
						CultureInfo ci = new CultureInfo( defaultlang );
						defaultlcid = ci.LCID;
					}
                    
                    string url = root + "/help/" + userlcid.ToString()+ "/" + filename;
				
					
					
					if( !File.Exists( Server.MapPath( url ) ) )
					{
						//
						// If the language the user wants isn't available user the defualt lang.
						//
						url =  root +"/help/" + defaultlcid.ToString() + "/" + filename;
					}

				
                    ListItem listItem = new ListItem( 
                        Localization.GetString( links[ i ] ),
                        url );

                    quickHelp.Items.Add( listItem );
                }
			
                go.Value = Localization.GetString( "BUTTON_GO" );
                go.Attributes.Add( "onclick", "ShowQuickHelp( '" + quickHelp.UniqueID + "' )" );
			
                quickHelp.Attributes.Add( "onchange", "ShowQuickHelp( '" + quickHelp.UniqueID + "' )" );			
            }
        }

		protected override void Render( HtmlTextWriter output )
		{
			if( null != edit )
				edit.Visible = UDDI.Context.User.IsPublisher;

			if( null != coordinate )
				coordinate.Visible = UDDI.Context.User.IsCoordinator;

			if( null != user )
			{
				if( UDDI.Context.User.IsImpersonated )
					user.Text = String.Format( Localization.GetString( "TAG_IMPERSONATING_USER" ), UDDI.Context.User.ID );
				else
					user.Text = String.Format( Localization.GetString( "TAG_USER" ), UDDI.Context.User.ID );
			}

			if( null != role )
			{
				string roleName;

				if( UDDI.Context.User.IsAdministrator )
					roleName = Localization.GetString( "ROLE_ADMINISTRATOR" );
				else if( UDDI.Context.User.IsCoordinator )
					roleName = Localization.GetString( "ROLE_COORDINATOR" );
				else if( UDDI.Context.User.IsPublisher )
					roleName = Localization.GetString( "ROLE_PUBLISHER" );
				else if( UDDI.Context.User.IsUser )
					roleName = Localization.GetString( "ROLE_USER" );				
				else
					roleName = Localization.GetString( "ROLE_ANONYMOUS" );
					
				role.Text = String.Format( Localization.GetString( "TAG_ROLE" ), roleName );
			}

			base.Render( output );
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\web\helpcontrol.cs ===
using System;
using System.Globalization;
using System.IO;
using System.Web;
using System.Web.UI;
using System.Web.UI.HtmlControls;
using UDDI;

namespace UDDI.Web
{
	public class ContextualHelpControl : UserControl
	{	
		

		private UddiLabel helptext;
		protected UddiLabel HelpText
		{
			get{ return helptext;}
			set{ helptext = (UddiLabel)value; }
		}


		private HelpControl helplink;
		protected HelpControl HelpLink
		{
			get{ return helplink;}
			set{ helplink = (HelpControl)value; }
		}

		private string cssclass;
		public string CssClass
		{
			get{ return cssclass; }
			set{ cssclass=value; }
		}

		private string borderwidth;
		public string BorderWidth
		{
			get{ return borderwidth; }
			set{ borderwidth=value; }
		}
		
		private string horizontalalign;
		public string HorizontalAlign
		{
			get{ return horizontalalign; }
			set{ horizontalalign=value; }
		}
		private string verticalalign;
		public string VertialAlign
		{
			get{ return verticalalign; }
			set{ verticalalign=value; }
		}
		private string width="100%";
		public string Width
		{
			get{ return width; }
			set{ width=value; }
		}

		private string height;
		public string Height
		{
			get{ return height; }
			set{ height=value; }
		}

		private string text;
		public string Text
		{
			get{ return text; }
			set{ text=value; }
		}

		private string helpfile;
		public string HelpFile
		{
			get{ return helpfile; }
			set{ helpfile=value; }
		}


		protected override void OnLoad( EventArgs e )
		{
			
			if( null==HelpText )
			{
				HelpText = new UddiLabel();
				Controls.Add( HelpText );
			}
			if( null==HelpLink )
			{
				HelpLink = new HelpControl();
				Controls.Add( HelpLink );
			}

			HelpText.Text = Text;
			HelpLink.HelpFile = HelpFile;
			base.OnLoad( e );
		}

		protected override void Render( HtmlTextWriter output )
		{
			
			output.Write( 
				"<table " +
					"id='" + this.ClientID + "' " +
					((Height==null) ? "" : "height='" + Height + "' " ) +
					((Width==null) ? "" : "width='" + Width + "' " ) +
					((BorderWidth==null) ? "border='0' " : "border='" + BorderWidth + "' " ) +
					((CssClass==null) ? "" : "class='" + CssClass + "' " ) +
					">\r\n"
			);


			output.Write( 
					"<tr " +
						">\r\n" +
						"<td " +
							((VertialAlign==null) ? "valign='top' " : "valign='" + VertialAlign + "' " )+
							
							">\r\n"
			);
		
		

			HelpText.RenderControl( output );
	

			output.Write(
						"</td>\r\n"+
						"<td " +
							"width='25' "+
							((HorizontalAlign==null) ? "align='right' " : "align='" + HorizontalAlign + "' " )+
							((VertialAlign==null) ? "valign='top' " : "valign='" + VertialAlign + "' " )+
							">\r\n"
			);


			HelpLink.RenderControl( output );

			output.Write( 
						"</td>\r\n"+
					"</tr>\r\n"+
				"</table>\r\n"
			);
			/*
			AddAttribute( output,HtmlTextWriterAttribute.Height, Height, null );
			AddAttribute( output,HtmlTextWriterAttribute.Border, BorderWidth, "0" );
			AddAttribute( output,HtmlTextWriterAttribute.Class, CssClass, null );
			AddAttribute( output,HtmlTextWriterAttribute.Id, ClientID, null );
			AddAttribute( output,HtmlTextWriterAttribute.Width, Width,null );
			output.RenderBeginTag( HtmlTextWriterTag.Table );
			
			output.RenderBeginTag( HtmlTextWriterTag.Tr );

			//Text Row
			AddAttribute( output,HtmlTextWriterAttribute.Align, HorizontalAlign,null );
			AddAttribute( output,HtmlTextWriterAttribute.Valign, VertialAlign,null );
			output.RenderBeginTag( HtmlTextWriterTag.Td );
			
			if( null!=HelpText )
				HelpText.RenderControl( output );

			output.RenderEndTag();//HtmlTextWriterTag.Td

			AddAttribute( output,HtmlTextWriterAttribute.Width, "25",null );
			AddAttribute( output,HtmlTextWriterAttribute.Align, HorizontalAlign,null );
			AddAttribute( output,HtmlTextWriterAttribute.Valign, VertialAlign,null );
			output.RenderBeginTag( HtmlTextWriterTag.Td );
			
			if( null!=HelpLink )
				HelpLink.RenderControl( output );

			output.RenderEndTag();//HtmlTextWriterTag.Td

			output.RenderEndTag();//HtmlTextWriterTag.Tr
			output.RenderEndTag();//HtmlTextWriterTag.Table
			*/

		}
		protected void AddAttribute( HtmlTextWriter output,  HtmlTextWriterAttribute name, string val, string defaultvalue )
		{
			if( null!=val )
			{
				output.AddAttribute( name, val );
			}
			else if( null!=defaultvalue )
			{
				output.AddAttribute( name, val );
			}
		}
		
	}
	
	public class HelpControl : UserControl
	{
		protected string helpFile;
		protected string root;

		public string HelpFile
		{
			get { return helpFile; }
			set	{ helpFile = value; }
		}

		protected override void OnInit( EventArgs e )
		{
			if( "/" == Request.ApplicationPath )
				root = "";
			else
				root = Request.ApplicationPath;
		}
		
		protected override void CreateChildControls()
		{
			CultureInfo culture = UDDI.Localization.GetCulture();

			string isoLangCode = culture.LCID.ToString();
			
			string file = "/help/" + isoLangCode + "/" + HelpFile + ".aspx";
			
			string defaultlang = Config.GetString( "Setup.WebServer.ProductLanguage","en" );
			int lcid = 1033;

			//
			// 'cultureIDValue is expected to contain a neutral culture.  ie,
			// 'en', or 'ko', or 'de'.  All but a few neutral cultures have
			// a default specific culture.  For example, the default specific
			// culture of 'en' is 'en-US'.
			//
			// Traditional & simplified Chinese (zh-CHT and zh-CHS respectively)
			// are examples of neutral cultures which have no default specific
			// culture!
			//
			// So what happens below is this:  First we try to lookup the default
			// specific culture for the neutral culture that we were given.  If that
			// fails (ie, if CreateSpecificCulture throws), we just get the lcid
			// of the neutral culture.
			//
			try
			{
				lcid = CultureInfo.CreateSpecificCulture( defaultlang ).LCID;
			}
			catch
			{
				CultureInfo ci = new CultureInfo( defaultlang );
				lcid = ci.LCID;
			}
		
			if( !File.Exists( Server.MapPath( root + file ) ) )
				file = "/help/" + lcid.ToString() + "/" + HelpFile + ".aspx";


			file = HyperLinkManager.GetNonSecureHyperLink( file );

			HtmlAnchor anchor = new HtmlAnchor();
           
            if( ((UddiPage)Page).IsIE4 || ((UddiPage)Page).IsIE5 || ((UddiPage)Page).IsNetscape6 )
            {
                //
                // Standards recommend pointer, but IE4 used hand.
                //
                if( ((UddiPage)Page).IsIE4 )
                    anchor.Style.Add( "cursor", "hand" );
                else
                    anchor.Style.Add( "cursor", "pointer" );
                
                anchor.Attributes.Add( "onclick", "ShowHelp( '" + file + "' )" );
                anchor.HRef = "";
            }
            else
            {
                anchor.HRef = file;
            }

            anchor.Target = "help";
            anchor.InnerHtml = "<img src='" + root + "/images/help.gif' border='0'>";
			
			Controls.Add( anchor );
		}
	}
	public class ContentController : System.Web.UI.WebControls.PlaceHolder
	{
		private ServiceModeType mode;
		public ServiceModeType Mode
		{
			get{ return mode; }
			set{ mode=(ServiceModeType)value; }
		}

		private RoleType requiredaccesslevel = RoleType.Anonymous;
		public RoleType RequiredAccessLevel
		{
			get{ return requiredaccesslevel; }
			set{ requiredaccesslevel=(RoleType)value; }
		}

		protected internal ServiceModeType currentMode;
		protected override void Render( HtmlTextWriter output )
		{
			if( currentMode==Mode && (int)UDDI.Context.User.Role>=(int)RequiredAccessLevel )
			{
				base.Render( output );
			}
		}
		protected override void OnLoad( EventArgs e )
		{
			currentMode = (ServiceModeType)Config.GetInt( "Web.ServiceMode", (int)ServiceModeType.Private );
			base.OnLoad( e );
		}
	}
	public enum ServiceModeType
	{
		Private		= 0x00,
		Public		= 0x01
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\web\instanceinfos.cs ===
using System;
using System.Data;
using System.Web.UI;
using System.Web.UI.WebControls;
using UDDI;
using UDDI.API;
using UDDI.API.Business;
using UDDI.API.Service;
using UDDI.API.ServiceType;
using UDDI.API.Binding;
using UDDI.Diagnostics;

namespace UDDI.Web
{
	public class InstanceInfoControl : UddiControl
	{
		protected TModelInstanceInfoCollection instanceInfos;
		protected BindingTemplate parent;
        protected bool frames;

		protected DataGrid grid;
		
		public void Initialize( TModelInstanceInfoCollection instanceInfos, BindingTemplate parent, bool allowEdit )
		{
			this.instanceInfos = instanceInfos;
            this.parent = parent;

            grid.Columns[ 0 ].Visible = allowEdit;
            grid.Columns[ 1 ].Visible = allowEdit;
			grid.Columns[ 2 ].Visible = !allowEdit;
		}

		protected void Page_Load( object sender, EventArgs e )
		{
            frames = ( "true" == Request[ "frames" ] );
            
            PopulateDataGrid();
		}

		void PopulateDataGrid()
		{
			grid.DataSource = instanceInfos;
			grid.DataBind();
		}
		
		protected void InstanceInfo_Edit( object sender, DataGridCommandEventArgs e )
		{
			int index = e.Item.ItemIndex;

            if( frames )
            {
                Response.Write(
                    ClientScripts.ReloadExplorerAndViewPanes( "editinstanceinfo.aspx?frames=true&key=" + parent.BindingKey + "&index=" + index, parent.BindingKey + ":" + index ) );
            
                Response.End();
            }
            else
            {                                      
                Response.Redirect( "editinstanceinfo.aspx?frames=false&key=" + parent.BindingKey + "&index=" + index );
                Response.End();
            }
		}

		protected void InstanceInfo_Delete( object sender, DataGridCommandEventArgs e )
		{
            int index = e.Item.ItemIndex;
            
            string name = Lookup.TModelName( instanceInfos[ index ].TModelKey );
            string key = parent.BindingKey;

            //
            // The user has not yet confirmed the delete operation, so display
            // a confirmation dialog.
            //
            string message = String.Format( 
                Localization.GetString( "TEXT_DELETE_CONFIRMATION" ), 
                name );
				
            Page.RegisterStartupScript(
                "Confirm",
                ClientScripts.Confirm(
                message,
                "editinstanceinfo.aspx?frames=" + ( frames ? "true" : "false" ) + "&key=" + key + "&index=" + index + "&mode=delete&confirm=true&tab=1" ) );
		}

		protected void InstanceInfo_Add( object sender, EventArgs e )
		{
			Response.Redirect( "editinstanceinfo.aspx?frames=" + ( frames ? "true" : "false" ) + "&key=" + parent.BindingKey + "&mode=add" );
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\web\localization.cs ===
using System;
using System.Globalization;
using System.Resources;
using System.Threading;
using System.Web;
using System.Web.UI;
using UDDI.Diagnostics;
using UDDI;

namespace UDDI.Web
{
	public class StringResource : UserControl
	{
		protected string name;

		public StringResource()
		{
		}

		public string Name
		{
			get { return name; }
			set { name = value; }
		}

		protected override void Render( HtmlTextWriter output )
		{
			output.Write( Localization.GetString( name ) );
		}
	}

	public class LocalizedLabel : System.Web.UI.WebControls.Label
	{
		protected string name;

		public LocalizedLabel()
		{
		}

		public string Name
		{
			get { return name; }
			set 
			{ 
				name = value;
				base.Text = Localization.GetString( name ); 
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\web\makefile.inc ===
foo.cs:
	..\version\$(O)\version.exe -outfile .\assemblyversioninfo.cs
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\web\lookup.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using System.Globalization;
using UDDI.API;
using UDDI;
using UDDI.Diagnostics;

namespace UDDI.Web
{
	public class Lookup
	{
		public static string TModelName( string tModelKey )
		{
			Debug.Enter();

			SqlCommand cmd = new SqlCommand( "net_tModel_get", ConnectionManager.GetConnection() );
			
			cmd.CommandType = CommandType.StoredProcedure;			
			cmd.Transaction = ConnectionManager.GetTransaction();
			
			cmd.Parameters.Add( new SqlParameter( "@tModelKey", SqlDbType.UniqueIdentifier ) ).Direction = ParameterDirection.Input;
			cmd.Parameters.Add( new SqlParameter( "@operatorName", SqlDbType.NVarChar, UDDI.Constants.Lengths.OperatorName ) ).Direction = ParameterDirection.Output;
			cmd.Parameters.Add( new SqlParameter( "@authorizedName", SqlDbType.NVarChar, UDDI.Constants.Lengths.AuthorizedName ) ).Direction = ParameterDirection.Output;
			cmd.Parameters.Add( new SqlParameter( "@name", SqlDbType.NVarChar, UDDI.Constants.Lengths.Name ) ).Direction = ParameterDirection.Output;
			cmd.Parameters.Add( new SqlParameter( "@overviewURL", SqlDbType.NVarChar, UDDI.Constants.Lengths.OverviewURL ) ).Direction = ParameterDirection.Output;

			SqlParameterAccessor paramacc = new SqlParameterAccessor( cmd.Parameters );
				
			paramacc.SetGuidFromKey( "@tModelKey", tModelKey );

			cmd.ExecuteNonQuery();

			Debug.Leave();

			return paramacc.GetString( "@name" );
		}

		public static string BusinessName( string businessKey )
		{
			string name = null;

			Debug.Enter();

			SqlCommand cmd = new SqlCommand( "net_businessEntity_names_get", ConnectionManager.GetConnection() );
			
			cmd.CommandType = CommandType.StoredProcedure;			
			cmd.Transaction = ConnectionManager.GetTransaction();
			
			cmd.Parameters.Add( new SqlParameter( "@businessKey", SqlDbType.UniqueIdentifier ) ).Direction = ParameterDirection.Input;

			SqlParameterAccessor paramacc = new SqlParameterAccessor( cmd.Parameters );
				
			paramacc.SetGuidFromString( "@businessKey", businessKey );

			SqlDataReaderAccessor reader = new SqlDataReaderAccessor( cmd.ExecuteReader() );
			
			try
			{
				if( reader.Read() )
					name = reader.GetString( "name" );
			}
			finally
			{
				reader.Close();
			}
			
			Debug.Leave();

			return name;
		}

		public static DataView IdentifierTModels( string filter, string sort )
		{
			DataView view = new DataView( GetIdentifierTModelsTable(), filter, sort, DataViewRowState.OriginalRows );
			
			return view;
		}
		public static DataView IdentifierTModels()
		{
			return GetIdentifierTModelsTable().DefaultView;
		}
		
		//
		// This method is a work around to remove the Owning-Business 
		//
		public static DataView IdentifierTModelsFiltered()
		{
			DataTable tModels = GetIdentifierTModelsTable();

			for( int i = 0; i < tModels.Rows.Count; i ++ )
			{
				DataRow row = tModels.Rows[ i ];

				if( (new Guid( "4064C064-6D14-4F35-8953-9652106476A9" ).Equals( (Guid)row[ "tModelKey" ] ) ))

				{
					tModels.Rows.Remove( row );
					break;
				}
			}
			return tModels.DefaultView;

		}
		protected static DataTable GetIdentifierTModelsTable()
		{
			Debug.Enter();

			DataSet tModels = new DataSet();

			SqlCommand cmd = new SqlCommand( "UI_getIdentifierTModels", ConnectionManager.GetConnection() );
			
			cmd.CommandType = CommandType.StoredProcedure;			
			cmd.Transaction = ConnectionManager.GetTransaction();
			
			SqlDataAdapter adapter = new SqlDataAdapter( cmd );

			adapter.Fill( tModels, "tModels" );
			
			//
			// Add the general keywords taxonomy
			//
			//string tModelKey = Config.GetString( "TModelKey.GeneralKeywords" );
			//
			//if( null != tModelKey )
			//{
			//   Guid guidGeneralKeywords = new Guid( Conversions.GuidStringFromKey( tModelKey ) );
			//    
			//    tModels.Tables[ "tModels" ].Rows.Add( 
			//		new object[] { 
			//						 guidGeneralKeywords, 
			//						 Localization.GetString( "TAXONOMY_MISC" ) 
			//					 } );
			//}

			//
			// Remove the operators taxonomy.
			//
			Guid guidOperators = new Guid( Conversions.GuidStringFromKey( Config.GetString( "TModelKey.Operators" ) ) );

			for( int i = 0; i < tModels.Tables[ "tModels" ].Rows.Count; i ++ )
			{
				DataRow row = tModels.Tables[ "tModels" ].Rows[ i ];

				if( guidOperators == (Guid)row[ "tModelKey" ] )
				{
					tModels.Tables[ "tModels" ].Rows.Remove( row );
					break;
				}
			}

			Debug.Leave();

			return tModels.Tables[ "tModels" ];
		}

		public static DataView GetLanguages()
		{
			Debug.Enter();
			
			DataSet languages = new DataSet();
			

			/*
			 *  BUG: 722086
			 * 
			 *	Removed logic to read from the database.  We now use the CultureInfo.GetCultures() method
			 *  to get all available languages.
			 * 
			SqlCommand cmd = new SqlCommand( "UI_getLanguages", ConnectionManager.GetConnection() );
			
			cmd.CommandType = CommandType.StoredProcedure;			
			cmd.Transaction = ConnectionManager.GetTransaction();
			
			SqlDataAdapter adapter = new SqlDataAdapter( cmd );

			adapter.Fill( languages, "languages" );
			*/

			languages.Tables.Add( "languages" );
			languages.Tables[ "languages" ].Columns.Add( "isoLangCode" );
			languages.Tables[ "languages" ].Columns.Add( "language" );

			CultureInfo[] cultures = CultureInfo.GetCultures( CultureTypes.AllCultures );

			foreach( CultureInfo ci in cultures )
			{
				//
				// Check for invariat culture, and add all others.
				//
				if( !Utility.StringEmpty( ci.Name ) )
					languages.Tables[ "languages" ].LoadDataRow( 
						new object[]{ ci.Name.ToLower(),ci.Name },true );
			}
			

			Debug.Leave();

			return languages.Tables[ "languages" ].DefaultView;
		}
		
		public static string GetLanguageName( string isoLangCode )
		{
			Debug.Enter();

			/*
			*  BUG: 722086
			* 
			SqlCommand cmd = new SqlCommand( "UI_getLanguages", ConnectionManager.GetConnection() );
			
			cmd.CommandType = CommandType.StoredProcedure;			
			cmd.Transaction = ConnectionManager.GetTransaction();

			cmd.Parameters.Add( new SqlParameter( "@isoLangCode", SqlDbType.VarChar, UDDI.Constants.Lengths.IsoLangCode ) ).Direction = ParameterDirection.Input;
			cmd.Parameters[ "@isoLangCode" ].Value = isoLangCode;
			
			Debug.Leave();
			
			*/
			try
			{
				CultureInfo ci = new CultureInfo( isoLangCode );

				return ci.Name;
			}
			catch
			{
				return isoLangCode;
			}
			//return (string)cmd.ExecuteScalar();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\web\owner.cs ===
using System;
using System.Data;
using UDDI;

namespace UDDI.Web
{
	public class Owner
	{
        public static void Change( string entityType, string entityKey, string puid )
        {
            SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor();
		
            switch( entityType )
            {
                case "business":
                    sp.ProcedureName = "net_businessEntity_owner_update";
                    sp.Parameters.Add( "@businessKey", SqlDbType.UniqueIdentifier );
                    sp.Parameters.SetGuidFromString( "@businessKey", entityKey );
				
                    break;
				
                case "tmodel":
                    sp.ProcedureName = "net_tModel_owner_update";
                    sp.Parameters.Add( "@tModelKey", SqlDbType.UniqueIdentifier );
                    sp.Parameters.SetGuidFromKey( "@tModelKey", entityKey );
				
                    break;

				default:
				{
#if never
					throw new UDDIException(
						ErrorType.E_fatalError,
						"Unknown entity type '" + entityType + "'" );
#endif
					throw new UDDIException( ErrorType.E_fatalError, "UDDI_ERROR_UKNOWN_ENTITY_TYPE", entityType );						
				}
            }
		
            sp.Parameters.Add( "@PUID", SqlDbType.NVarChar, 450 );
            sp.Parameters.SetString( "@PUID", puid );
		
            sp.ExecuteNonQuery();
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\web\name.cs ===
using System;
using System.Data;
using System.Web.UI;
using System.Web.UI.WebControls;
using UDDI.API;
using UDDI.API.Business;
using UDDI.API.ServiceType;
using UDDI;
using UDDI.Diagnostics;

namespace UDDI.Web
{
	public class NameControl : UddiControl
	{
		protected NameCollection names = null;
		protected EntityBase parentEntity = null;
		protected string parentKey = null;

		protected DataGrid grid;

		public void Initialize( NameCollection names )
		{
			this.names = names;
			
			grid.Columns[ 1 ].Visible = false;
		}

		public void Initialize( NameCollection names, EntityBase parentEntity, string parentKey )
		{
			this.names = names;
			this.parentEntity = parentEntity;
			this.parentKey = parentKey;

			grid.Columns[ 1 ].Visible = true;
		}

		protected void Page_Load( object sender, EventArgs e )
		{
			if( !Page.IsPostBack )
				PopulateDataGrid();
		}			
		
		void PopulateDataGrid()
		{
			grid.DataSource = names;
			grid.DataBind();
		}
		
		
		protected DataView GetLanguages()
		{
			DataView view = Lookup.GetLanguages();
			
			int index = 0;
			foreach( Name name in names )
			{
				if( index != grid.EditItemIndex )			
				{
					foreach( DataRowView row in view )				
					{
						if( row[ "isoLangCode" ].ToString() == name.IsoLangCode )
						{
							row.Delete();
							break;
						}
					}
				}
				
				index ++;
			}

			return view;
		}

		protected void Name_OnEdit( object sender, DataGridCommandEventArgs e )
		{
			int index = e.Item.ItemIndex;
			
			grid.EditItemIndex = index;
			SetEditMode();
			
			PopulateDataGrid();

			Name name = names[ index ];

			DropDownList list = (DropDownList)grid.Items[ index ].Cells[ 0 ].FindControl( "language" );
			
			if( null != list )
			{
				ListItem item = list.Items.FindByValue( name.IsoLangCode );
				
				if( null != item )
				{
					item.Selected = true;
				}
				else
				{
						item = new ListItem( name.IsoLangCode, name.IsoLangCode );
						list.Items.Add( item );
						item.Selected = true;
				}
				
			}
		}
        
        protected void OnEnterKeyPressed( object sender, EventArgs e )
        {
            Name_OnUpdate( sender, null );
        }
	    
		protected void Name_OnUpdate( object sender, DataGridCommandEventArgs e )
		{
			Page.Validate();
			
			if( Page.IsValid )
			{    
				int index = grid.EditItemIndex;
                DataGridItem item = grid.Items[ index ];
				
				if( index >= names.Count )
					names.Add( "" );
				
				Name name = names[ index ];
				
				name.IsoLangCode = ((DropDownList)item.FindControl( "language" )).SelectedItem.Value;
				name.Value = ((TextBox)item.FindControl( "name" )).Text.Trim();
				
				CheckBox checkbox = (CheckBox)item.FindControl( "default" );

				if( index > 0 && null != checkbox && checkbox.Checked )
				{
					for( int i = index; i > 0; i -- )
						names[ i ] = names[ i - 1 ];

					names[ 0 ] = name;
					index = 0;
				}
				
				parentEntity.Save();
		    
				if( 0 == index && !IsDownlevel )
				{
					Page.RegisterStartupScript(
						"Reload",
						ClientScripts.ReloadExplorerPane(
						parentKey ) );
				}
				
				grid.EditItemIndex = -1;
				CancelEditMode();
				
				PopulateDataGrid();
			}
		}

		protected void Name_OnCancel( object sender, DataGridCommandEventArgs e )
		{
			grid.EditItemIndex = -1;
			CancelEditMode();
			
			PopulateDataGrid();
		}   

		protected void Name_OnDelete( object sender, DataGridCommandEventArgs e )
		{
			int index = e.Item.ItemIndex;
			
			names.RemoveAt( index );    		
			parentEntity.Save();

			PopulateDataGrid();

			if( 0 == index && !IsDownlevel )
			{
				Page.RegisterStartupScript(
					"Reload",
					ClientScripts.ReloadExplorerPane(
					parentKey ) );
			}
		}   

		protected void Name_OnAdd( object sender, EventArgs e )
		{
			int index = names.Count;

			grid.EditItemIndex = index;
			SetEditMode();

			names.Add( "" );
			PopulateDataGrid();

			DropDownList list = (DropDownList)grid.Items[ index ].Cells[ 0 ].FindControl( "language" );		
			ListItem item = list.Items.FindByValue( Localization.GetCulture().TwoLetterISOLanguageName );
				
			if( null != item )
				item.Selected = true;		
		}   
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\web\phone.cs ===
using System;
using System.Data;
using System.Web.UI;
using System.Web.UI.WebControls;
using UDDI.API;
using UDDI.API.Business;
using UDDI.API.ServiceType;
using UDDI;
using UDDI.Diagnostics;

namespace UDDI.Web
{
	public class PhoneControl : UddiControl
	{
		protected PhoneCollection phones;
		protected EntityBase entity;

		protected DataGrid grid;
		
		public void Initialize( PhoneCollection phones )
		{
			this.phones = phones;
			
			grid.Columns[ 1 ].Visible = false;
		}
			
		public void Initialize( PhoneCollection phones, EntityBase entity )
		{
			this.phones = phones;
			this.entity = entity;
			
			grid.Columns[ 1 ].Visible = true;
		}
		
		protected void Page_Init( object sender, EventArgs e )
		{
			grid.Columns[ 0 ].HeaderText = Localization.GetString( "HEADING_PHONE" );
			grid.Columns[ 1 ].HeaderText = Localization.GetString( "HEADING_ACTIONS" );
		}
		
		protected void Page_Load( object sender, EventArgs e )
		{
			if( !Page.IsPostBack )
				PopulateDataGrid();

			if( grid.EditItemIndex >= 0 )
				SetEditMode();
		}
		
		void PopulateDataGrid()
		{			
			grid.DataSource = phones;
			grid.DataBind();
		}
	    
		protected void DataGrid_Edit( object sender, DataGridCommandEventArgs e )
		{
			int index = e.Item.ItemIndex;
			
			grid.EditItemIndex = index;
			SetEditMode();

			PopulateDataGrid();
		}
	    
        protected void OnEnterKeyPressed( object sender, EventArgs e )
        {
            DataGrid_Update( sender, null );
        }
        
        protected void DataGrid_Update( object sender, DataGridCommandEventArgs e )
		{
			Page.Validate();
			
			if( Page.IsValid )
			{			
				int index = grid.EditItemIndex;
				
				if( index >= phones.Count )
					phones.Add( "" );
				
				Phone phone = phones[ index ];
				
                DataGridItem item = grid.Items[ index ];
                
                phone.Value = ((TextBox)item.FindControl( "phone" )).Text;
				phone.UseType = ((TextBox)item.FindControl( "useType" )).Text;
				
				entity.Save();
		    
				grid.EditItemIndex = -1;
				CancelEditMode();

				PopulateDataGrid();
			}
		}

		protected void DataGrid_Cancel( object sender, DataGridCommandEventArgs e )
		{
			grid.EditItemIndex = -1;
			CancelEditMode();
			
			PopulateDataGrid();
		}   

		protected void DataGrid_Delete( object sender, DataGridCommandEventArgs e )
		{
			int index = e.Item.ItemIndex;
			
			phones.RemoveAt( index );    		
			entity.Save();
	    
			PopulateDataGrid();
		}   

		protected void DataGrid_Add( object sender, EventArgs e )
		{
			grid.EditItemIndex = phones.Count;
			SetEditMode();
			
			phones.Add( "" );
			
			PopulateDataGrid();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\web\contextmenu.cs ===
using System;
using System.Collections;
using System.Web.UI;

using UDDI;

namespace UDDI.Web
{
	public class ContextMenu : Control
	{
		protected ArrayList menuItems = new ArrayList();
		
		protected static string popupScript = @"
			<script language='javascript'>
				var popup = null;
				var popupArgs = null;
				var popupNode = null;

				function HideAnyPopups()
				{
					if( null != popup )
						HidePopup( popup );

					popup = null;
				}

				function HidePopup( popup )
				{
					var ctrl = document.getElementById( popup );

					ctrl.style.display = ""none"";
				}
			</script>";

		protected static string contextMenuScript = @"
			<script language='javascript'>
				function ShowContextMenu( node, menu, args )
				{
					HideAnyPopups();

					var e = window.event;
					var cm = document.getElementById( menu );

					popupNode = node;
					popupArgs = args;

					cm.style.display = """";
						
					if( cm.clientWidth > document.body.clientWidth )
						cm.style.pixelLeft = 0;
					else if( e.clientX + cm.clientWidth > document.body.clientWidth )
						cm.style.pixelLeft = document.body.clientWidth - cm.clientWidth - 5;
					else
						cm.style.pixelLeft = e.clientX;

					cm.style.pixelLeft += document.body.scrollLeft;

					if( cm.clientHeight > document.body.clientHeight )
						cm.style.pixelTop = 0;
					else if( e.clientY + cm.clientHeight > document.body.clientHeight )
						cm.style.pixelTop = document.body.clientHeight - cm.clientHeight - 5;
					else					
						cm.style.pixelTop = e.clientY;
					
					cm.style.pixelTop += document.body.scrollTop;

					popup = menu;

					e.cancelBubble = true;
					e.returnValue = false;
				}

				function ContextMenu_OnClick( url, target )
				{
					HideAnyPopups();

					if( null != popupArgs )
					{
						if( url.indexOf( '?' ) >= 0 )
							url += ""&"" + popupArg;
						else
							url += ""?"" + popupArgs;
					}

					document.body.style.cursor = 'wait';
					
					if( null == target || ""_self"" == target )
						window.location = url;
					else
						window.parent.frames[ target ].location = url;
				}

				function ContextMenu_OnSeparatorClick()
				{
					var e = window.event;

					e.cancelBubble = true;
					e.returnValue = false;
				}
			</script>";
		
		public ContextMenu()
		{
		}

		protected override void OnInit( EventArgs e )
		{
			if( !Page.IsClientScriptBlockRegistered( "UDDI.Web.Popup" ) )
				Page.RegisterClientScriptBlock( "UDDI.Web.Popup", popupScript );
			
			if( !Page.IsClientScriptBlockRegistered( "UDDI.Web.ContextMenu" ) )
				Page.RegisterClientScriptBlock( "UDDI.Web.ContextMenu", contextMenuScript );
		}

		protected override void AddParsedSubObject( object obj )
		{
			if( obj is MenuItem || obj is MenuSeparator ) 
				menuItems.Add( obj );
		}
		
		protected override void Render( HtmlTextWriter output )
		{
			output.Write( "<div id='" + this.ID + "' class='contextMenu' style='display: none'>" );
			output.Write( "<table cellpadding='0' cellspacing='0' border='0'>" );
			
			foreach( object item in menuItems )
			{
				if( item is MenuItem )
				{
					MenuItem menuItem = (MenuItem)item;

					if( menuItem.Visible && menuItem.AccessAllowed )
					{
						output.Write( "<tr><td class='menuItem' valign='top' onclick='" + menuItem.OnClick + 
							"' oncontextmenu='" + menuItem.OnClick + "' onmouseover='this.className=\"menuItemHover\";" );
						
						if( !Utility.StringEmpty( menuItem.StatusText ) )
							output.Write( " window.status=\"" + Localization.GetString( menuItem.StatusText ) + "\"" );
						
						output.Write( "' onmouseout='this.className=\"menuItem\"; window.status=\"\"'><img src='" + 
							menuItem.ImageUrl + "' border='0' align='absmiddle' class='menuImage'>&nbsp;&nbsp;" );
						
						if( menuItem.Bold )
							output.Write( "<b>" );
						
						output.Write( "<nobr>" + Localization.GetString( menuItem.Text ) + "</nobr>" );
						
						if( menuItem.Bold )
							output.Write( "</b>" );
						
						output.Write( "</td></tr>" );
					}
				}
				else if( item is MenuSeparator )
				{
					MenuSeparator separator = (MenuSeparator)item;

					if( separator.Visible && separator.AccessAllowed )
						output.Write( "<tr><td class='menuSeparator' onclick='ContextMenu_OnSeparatorClick()' oncontextmenu='ContextMenu_OnSeparatorClick()'><hr></td></tr>" );
				}
			}

			output.Write( "</table>" );
			output.Write( "</div>" );
		}
	}

	public class MenuItem : Control
	{
		protected bool bold = false;
		protected string imageUrl = null;
		protected string onClick = null;
		protected string statusText = null;
		protected string text = null;
		protected RoleType requiredRole = RoleType.Anonymous;
		
		public bool Bold		
		{	
			get { return bold; }
			set { bold = value; }
		}

		public string ImageUrl
		{
			get { return imageUrl; }
			set { imageUrl = value; }
		}

		public string OnClick
		{
			get { return onClick; }
			set { onClick = value; }
		}

		public string StatusText
		{
			get { return statusText; }
			set { statusText = value; }
		}

		public string Text
		{
			get { return text; }
			set { text = value; }
		}
	
		public RoleType RequiredRole
		{
			get { return requiredRole; }
			set { requiredRole = value; }
		}

		public bool AccessAllowed
		{
			get
			{
				return
					( RoleType.Anonymous == requiredRole ) ||
					( RoleType.User == requiredRole && UDDI.Context.User.IsUser ) ||
					( RoleType.Publisher == requiredRole && UDDI.Context.User.IsPublisher ) ||
					( RoleType.Coordinator == requiredRole && UDDI.Context.User.IsCoordinator ) ||
					( RoleType.Administrator == requiredRole && UDDI.Context.User.IsAdministrator );
			}
		}

		public MenuItem()
		{
		}
	}

	public class MenuSeparator : Control
	{
		protected RoleType requiredRole = RoleType.Anonymous;
		
		public MenuSeparator()
		{
		}

		public RoleType RequiredRole
		{
			get { return requiredRole; }
			set { requiredRole = value; }
		}

		public bool AccessAllowed
		{
			get
			{
				return
					( RoleType.Anonymous == requiredRole ) ||
					( RoleType.User == requiredRole && UDDI.Context.User.IsUser ) ||
					( RoleType.Publisher == requiredRole && UDDI.Context.User.IsPublisher ) ||
					( RoleType.Coordinator == requiredRole && UDDI.Context.User.IsCoordinator ) ||
					( RoleType.Administrator == requiredRole && UDDI.Context.User.IsAdministrator );
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\web\publisher.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using System.Web;
using UDDI;
using UDDI.Diagnostics;

namespace UDDI.Web
{
	public class Publisher
	{
		public string Puid;
		public string IsoLangCode;
		public string Name;
		public string Email;
		public string Phone;
		public string CompanyName;
		public string AltPhone;
		public string AddressLine1;
		public string AddressLine2;
		public string City;
		public string StateProvince;
		public string PostalCode;
		public string Country;
		public string SecurityToken;
		
		public bool Validated;
		public bool TrackPassport;
		public bool Exists;
		
		public int BusinessLimit;
		public int BusinessCount;
		public int TModelLimit;
		public int TModelCount;
		public int ServiceLimit;
		public int BindingLimit;
		public int AssertionLimit;
		public int AssertionCount;

		public void GetPublisherFromSecurityToken( string securityToken )
		{
			Debug.Enter();

			SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor();

			sp.ProcedureName = "UI_getPublisherFromSecurityToken";
		
			sp.Parameters.Add( "@securityToken", SqlDbType.UniqueIdentifier );
			sp.Parameters.Add( "@PUID", SqlDbType.NVarChar, UDDI.Constants.Lengths.UserID, ParameterDirection.Output );
		
			sp.Parameters.SetGuidFromString( "@securityToken", securityToken );
			sp.ExecuteNonQuery();

			Puid = sp.Parameters.GetString( "@PUID" );

			Debug.Leave();
		}
	
		public void Save()
		{
			Debug.Enter();

			SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor();

			sp.ProcedureName = "UI_savePublisher";
		
			sp.Parameters.Add( "@PUID", SqlDbType.NVarChar, UDDI.Constants.Lengths.UserID );
			sp.Parameters.Add( "@isoLangCode", SqlDbType.VarChar, UDDI.Constants.Lengths.IsoLangCode );
			sp.Parameters.Add( "@name", SqlDbType.NVarChar, UDDI.Constants.Lengths.Name );
			sp.Parameters.Add( "@email", SqlDbType.NVarChar, UDDI.Constants.Lengths.Email );
			sp.Parameters.Add( "@phone", SqlDbType.NVarChar, UDDI.Constants.Lengths.Phone );
			sp.Parameters.Add( "@companyName", SqlDbType.NVarChar, UDDI.Constants.Lengths.CompanyName );
			sp.Parameters.Add( "@altphone", SqlDbType.NVarChar, UDDI.Constants.Lengths.Phone );
			sp.Parameters.Add( "@addressLine1", SqlDbType.NVarChar, UDDI.Constants.Lengths.AddressLine );
			sp.Parameters.Add( "@addressLine2", SqlDbType.NVarChar, UDDI.Constants.Lengths.AddressLine );
			sp.Parameters.Add( "@city", SqlDbType.NVarChar, UDDI.Constants.Lengths.City );
			sp.Parameters.Add( "@stateProvince", SqlDbType.NVarChar, UDDI.Constants.Lengths.StateProvince );
			sp.Parameters.Add( "@postalCode", SqlDbType.NVarChar, UDDI.Constants.Lengths.PostalCode );
			sp.Parameters.Add( "@country", SqlDbType.NVarChar, UDDI.Constants.Lengths.Country );
			sp.Parameters.Add( "@flag", SqlDbType.Int );
			sp.Parameters.Add( "@securityToken", SqlDbType.UniqueIdentifier );
			sp.Parameters.Add( "@tier", SqlDbType.NVarChar, UDDI.Constants.Lengths.Tier );


			sp.Parameters.SetString( "@PUID", Puid );
			sp.Parameters.SetString( "@isoLangCode", IsoLangCode );
			sp.Parameters.SetString( "@name", Name );
			sp.Parameters.SetString( "@email", Email );
			sp.Parameters.SetString( "@phone", Phone );
			sp.Parameters.SetString( "@companyName", CompanyName );
			sp.Parameters.SetString( "@altphone", AltPhone );
			sp.Parameters.SetString( "@addressLine1", AddressLine1 );
			sp.Parameters.SetString( "@addressLine2", AddressLine2 );
			sp.Parameters.SetString( "@city", City );
			sp.Parameters.SetString( "@stateProvince", StateProvince );
			sp.Parameters.SetString( "@postalCode", PostalCode );
			sp.Parameters.SetString( "@country", Country );
			sp.Parameters.SetString( "@tier", Config.GetString( "Publisher.DefaultTier", "2" ) );
		
			int flag = 0;
		
			if( !TrackPassport )
				flag = flag | 0x02;

			if( Validated )
				flag = flag | 0x01;

			sp.Parameters.SetInt( "@flag", flag );
			sp.Parameters.SetGuidFromString( "@securityToken", SecurityToken );

			sp.ExecuteNonQuery();
		
			Debug.Leave();
		}

		public void Get()
		{
			Debug.Enter();

			SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor();

			sp.ProcedureName = "UI_getPublisher";
		
			sp.Parameters.Add( "@PUID", SqlDbType.NVarChar, UDDI.Constants.Lengths.UserID );
			sp.Parameters.SetString( "@PUID", Puid );

			SqlDataReaderAccessor reader = sp.ExecuteReader();
		
			Exists = false;

			try
			{
				if( reader.Read() )
				{
					int flag;

					IsoLangCode		= reader.GetString( 1 );
					Name			= reader.GetString( 2 );
					Email			= reader.GetString( 3 );
					Phone			= reader.GetString( 4 );
					CompanyName		= reader.GetString( 5 );
					AltPhone		= reader.GetString( 6 );
					AddressLine1	= reader.GetString( 7 );
					AddressLine2	= reader.GetString( 8 );
					City			= reader.GetString( 9 );
					StateProvince	= reader.GetString( 10 );
					PostalCode		= reader.GetString( 11 );
					Country			= reader.GetString( 12 );
					flag			= reader.GetInt( 13 );
					SecurityToken	= reader.GetGuidString( 14 );
				
					TrackPassport = ( 0x00 == ( flag & 0x02 ) );
					Validated = ( 0x01 == ( flag & 0x01 ) );
				
					Exists = true;
				}
			}
			finally
			{
				reader.Close();
			}

			Debug.Leave();
		}

		public static int Validate( string userid )
		{
			Debug.Enter();

			SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor();

			sp.ProcedureName = "UI_validatePublisher";

			sp.Parameters.Add( "@PUID", SqlDbType.NVarChar, UDDI.Constants.Lengths.UserID );
			sp.Parameters.Add( "@returnValue", SqlDbType.Int, ParameterDirection.ReturnValue );
	
			sp.Parameters.SetString( "@PUID", userid );
			sp.ExecuteNonQuery();
		
			int returnValue = sp.Parameters.GetInt( "@returnValue" );
		
			Debug.Leave();

			return returnValue;
		}

		public void Login( string userid, string email )
		{
			Debug.Enter();

			SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor();

			sp.ProcedureName = "net_publisher_login";

			sp.Parameters.Add( "@PUID", SqlDbType.NVarChar, UDDI.Constants.Lengths.UserID );
			sp.Parameters.Add( "@email", SqlDbType.NVarChar, UDDI.Constants.Lengths.Email, ParameterDirection.InputOutput );
			
			sp.Parameters.Add( "@name", SqlDbType.NVarChar, UDDI.Constants.Lengths.Name, ParameterDirection.Output );
			sp.Parameters.Add( "@phone", SqlDbType.VarChar, UDDI.Constants.Lengths.Phone, ParameterDirection.Output );
			sp.Parameters.Add( "@companyName", SqlDbType.NVarChar, UDDI.Constants.Lengths.CompanyName, ParameterDirection.Output );
			sp.Parameters.Add( "@altPhone", SqlDbType.VarChar, UDDI.Constants.Lengths.Phone, ParameterDirection.Output );
			sp.Parameters.Add( "@addressLine1", SqlDbType.NVarChar, UDDI.Constants.Lengths.AddressLine, ParameterDirection.Output );
			sp.Parameters.Add( "@addressLine2", SqlDbType.NVarChar, UDDI.Constants.Lengths.AddressLine, ParameterDirection.Output );
			sp.Parameters.Add( "@city", SqlDbType.NVarChar, UDDI.Constants.Lengths.City, ParameterDirection.Output );
			sp.Parameters.Add( "@stateProvince", SqlDbType.NVarChar, UDDI.Constants.Lengths.StateProvince, ParameterDirection.Output );
			sp.Parameters.Add( "@postalCode", SqlDbType.NVarChar, UDDI.Constants.Lengths.PostalCode, ParameterDirection.Output );
			sp.Parameters.Add( "@country", SqlDbType.NVarChar, UDDI.Constants.Lengths.Country, ParameterDirection.Output );
			sp.Parameters.Add( "@isoLangCode", SqlDbType.VarChar, UDDI.Constants.Lengths.IsoLangCode, ParameterDirection.Output );			
			sp.Parameters.Add( "@businessLimit", SqlDbType.Int, ParameterDirection.Output );
			sp.Parameters.Add( "@businessCount", SqlDbType.Int, ParameterDirection.Output );
			sp.Parameters.Add( "@tModelLimit", SqlDbType.Int, ParameterDirection.Output );
			sp.Parameters.Add( "@tModelCount", SqlDbType.Int, ParameterDirection.Output );
			sp.Parameters.Add( "@serviceLimit", SqlDbType.Int, ParameterDirection.Output );
			sp.Parameters.Add( "@bindingLimit", SqlDbType.Int, ParameterDirection.Output );
			sp.Parameters.Add( "@assertionLimit", SqlDbType.Int, ParameterDirection.Output );
			sp.Parameters.Add( "@assertionCount", SqlDbType.Int, ParameterDirection.Output );
		
			sp.Parameters.SetString( "@PUID", userid );
			sp.Parameters.SetString( "@email", email );

			sp.ExecuteNonQuery();
	
			Email = sp.Parameters.GetString( "@email" );
			Name = sp.Parameters.GetString( "@name" );
			Phone = sp.Parameters.GetString( "@phone" );
			CompanyName = sp.Parameters.GetString( "@companyName" );
			AltPhone = sp.Parameters.GetString( "@altPhone" );
			AddressLine1 = sp.Parameters.GetString( "@addressLine1" );
			AddressLine2 = sp.Parameters.GetString( "@addressLine2" );
			City = sp.Parameters.GetString( "@city" );
			StateProvince = sp.Parameters.GetString( "@stateProvince" );
			PostalCode = sp.Parameters.GetString( "@postalCode" );
			Country = sp.Parameters.GetString( "@country" );			
			IsoLangCode = sp.Parameters.GetString( "@isoLangCode" );
			
			BusinessLimit = sp.Parameters.GetInt( "@businessLimit" );
			BusinessCount = sp.Parameters.GetInt( "@businessCount" );
			TModelLimit = sp.Parameters.GetInt( "@tModelLimit" );
			TModelCount = sp.Parameters.GetInt( "@tModelCount" );
			ServiceLimit = sp.Parameters.GetInt( "@serviceLimit" );
			BindingLimit = sp.Parameters.GetInt( "@bindingLimit" );
			AssertionLimit = sp.Parameters.GetInt( "@assertionLimit" );
			AssertionCount = sp.Parameters.GetInt( "@assertionCount" );

			Debug.Leave();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\web\selection.cs ===
using System;
using System.Data;
using System.Web;
using System.Web.UI;
using System.Web.UI.WebControls;
using UDDI;
using UDDI.API.Business;
using UDDI.API.Service;
using UDDI.API.ServiceType;

namespace UDDI.Web
{
	public delegate void SelectEventHandler( object sender, string key, string name );

	public abstract class SelectionControl : UserControl
	{
		public event SelectEventHandler Select;

		protected Panel resultsPanel = null;
		protected TextBox query = null;
		protected DataGrid grid = null; 
		protected Label count = null;
		protected RequiredFieldValidator requiredField = null;
	
		public SelectionControl()
		{
		}

		public void ResetControl()
		{
			resultsPanel.Visible = false;
		
		}
		protected override void OnInit( EventArgs e )
		{
			requiredField.ErrorMessage = Localization.GetString( "ERROR_FIELD_REQUIRED" );
		}

		protected void Grid_OnItemCommand( object sender, DataGridCommandEventArgs e )
		{
			switch( e.CommandName )
			{
				case "select":
					OnSelect( this, e );
				
					break;
			}
		}

		protected void Grid_OnPageIndexChange( object sender, DataGridPageChangedEventArgs e )
		{
            Page.Validate();

            if( Page.IsValid )
            {
                grid.CurrentPageIndex = e.NewPageIndex;		
                OnSearch( this, query.Text );			
            }
		}

		protected void Search_OnClick( object sender, EventArgs e )	
		{
            Page.Validate();

            if( Page.IsValid )
            {
                OnSearch( this, query.Text );
            }
		}
		
		protected virtual void OnSelect( object sender, DataGridCommandEventArgs e )
		{
			switch( e.CommandName )
			{
				case "select":
					string key = ((UddiLabel)e.Item.Cells[ 0 ].FindControl( "key" )).Text;
					string name = ((LinkButton)e.Item.Cells[ 1 ].FindControl( "name" )).Text;
			
					name = HttpUtility.HtmlDecode( name );

                    if( null != Select )
						Select( this, key, name );
			
					break;
			}
		}
		
		protected virtual void OnSearch( object sender, string query )
		{
			resultsPanel.Visible = true;
		}
	}

	public class PublisherSelector : SelectionControl
	{
		public PublisherSelector()
		{
		}

		protected override void OnSearch( object sender, string query )
		{
			base.OnSearch( sender, query );

			if( query.IndexOf( "%" ) < 0 )
				query += "%";

			SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor();
			DataSet ds = new DataSet();

			sp.ProcedureName = "ADM_findPublisher";

			sp.Parameters.Add( "@name", SqlDbType.NVarChar, UDDI.Constants.Lengths.Name );
			sp.Parameters.SetString( "@name", query );

			sp.Fill( ds, "Publishers" );
					
			if( null != ds.Tables[ "Publishers" ] )
			{
				DataView view;

				//
				// To eliminate the system account from the list
				// we should not do it this way. we should change the SP to accept a role
				// and then elimiate the rows before they placed in the DataSet.
				//
			
				//
				// If the user is an Admin, don't filter the data
				//
				if( UDDI.Context.User.IsAdministrator )
				{
					view = ds.Tables[ "Publishers" ].DefaultView;
				}
				else
				{
					view = new DataView( 	ds.Tables[ "Publishers" ],//use the publisher table
								"PUID <> 'System'",					//filter by puid.
								"name",								//name is the sort column
								DataViewRowState.CurrentRows );		// Show all current rows after filtering
				}

				grid.DataSource = view;
				grid.DataBind();

				count.Text = String.Format( 
				    Localization.GetString( "TEXT_QUERY_COUNT" ),
				    view.Count );
			    }
			    else
			    {
				grid.DataSource = null;
				grid.DataBind();

				count.Text = String.Format( 
				    Localization.GetString( "TEXT_QUERY_COUNT" ),
				    0 );
			    }
		}
	}

	public class TModelSelector : SelectionControl
	{
		public TModelSelector()
		{
		}

		protected override void OnSearch( object sender, string query )
		{
			base.OnSearch( sender, query );

			if( query.IndexOf( "%" ) < 0 )
				query += "%";

			FindTModel find = new FindTModel();
			find.Name = query;
			
			TModelList list = find.Find();
			
			grid.DataSource = list.TModelInfos;			
			grid.DataBind();

			count.Text = String.Format( 
				Localization.GetString( "TEXT_QUERY_COUNT" ),
				list.TModelInfos.Count );
		}
	}

	public class BusinessSelector : SelectionControl
	{
		public BusinessSelector()
		{
		}
		
		protected override void OnSearch( object sender, string query )
		{
			if( null == query )
				return;

			query = query.Trim();
			
			if( 0 == query.Length )
				return;

			base.OnSearch( sender, query );
						
			if( query.IndexOf( "%" ) < 0 )
				query +=  "%";

			FindBusiness find = new FindBusiness();
			find.Names.Add( null, query );
			
			BusinessList list = find.Find();
			
			grid.DataSource = list.BusinessInfos;
			grid.DataBind();

			count.Text = String.Format( 
				Localization.GetString( "TEXT_QUERY_COUNT" ),
				list.BusinessInfos.Count );
		}
	}

    public class ServiceSelector : SelectionControl
    {
        public ServiceSelector()
        {
        }

        protected override void OnSearch( object sender, string query )
        {
            if( null == query )
                return;

            query = query.Trim();
			
            if( 0 == query.Length )
                return;

            base.OnSearch( sender, query );
						
            if( query.IndexOf( "%" ) < 0 )
                query +=  "%";

            FindService find = new FindService();
            find.Names.Add( null, query );
			
            ServiceList list = find.Find();
			
            grid.DataSource = list.ServiceInfos;
            grid.DataBind();

            count.Text = String.Format( 
                Localization.GetString( "TEXT_QUERY_COUNT" ),
                list.ServiceInfos.Count );
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\web\sidenav.cs ===
namespace UDDI.Web
{
	using System;
	using System.Web;
	using System.Web.UI;
	using System.Web.UI.WebControls;
	using System.ComponentModel;
	using System.Collections;
	using System.Collections.Specialized;
	using System.Web.Configuration;
	using UDDI;

	
	
	/// ********************************************************************
	///   public class SideNav
	/// --------------------------------------------------------------------
	///   <summary>
	///		Produces the Side navigatio bar.
	///   </summary>
	/// ********************************************************************
	///   
	public class SideNav : System.Web.UI.WebControls.WebControl
	{
		protected string root;
		protected string roots;

		/// ****************************************************************
		///   protected Render
		/// ----------------------------------------------------------------
		///   <summary>
		///		Renders the control.
		///   </summary>
		/// ----------------------------------------------------------------
		///   <param name="output">
		///     The output stream.
		///   </param>
		/// ****************************************************************
		/// 
		protected override void Render( HtmlTextWriter output )
		{
			HttpRequest request = HttpContext.Current.Request;

			root = ( "/" == request.ApplicationPath ) ? "" : request.ApplicationPath; 			

			if( 1 == Config.GetInt( "Security.HTTPS", 0 ) )
				roots = "https://" + request.Url.Host + root;
			else
				roots = "http://" + request.Url.Host + root;

			root = "http://" + request.Url.Host + root;

			output.WriteLine( "<TABLE cellpadding='4' cellspacing='0' border='0' width='100%' height='100%'>" );
			output.WriteLine( "<TR><TD height='4' colspan='2' style='border-right: solid 1px #639ACE;'><IMG src='/images/trans_pixel.gif' width='1' height='1' border='0'></TD></TR>" );
			
			RenderMenuHeader( output, "LINKS" );
			RenderMenuItem( output, "Home", "/default.aspx", "", false );
			RenderMenuItem( output, "News", "http://www.uddi.org/news.html", "", false );
                        
			RenderMenuHeader( output, "TOOLS" );
			RenderMenuItem( output, "Register", "/register.aspx", "/registrationcomplete.aspx", true );
			RenderMenuItem( output, "Publish", "/edit/default.aspx", "", true );
			RenderMenuItem( output, "Search", "/search/default.aspx", "", false );

			RenderMenuHeader( output, "DEVELOPERS" );
			RenderMenuItem( output, "For Developers", "/developer/default.aspx", "/developer/techOverview.aspx;/developer/KnownIssues.aspx", false );
			RenderMenuItem( output, "Solutions", "/solutions.aspx", "", false );
			
			RenderMenuHeader( output, "HELP" );
			RenderMenuItem( output, "Help", "/help/default.aspx", "", false );
			RenderMenuItem( output, "Frequently Asked Questions", "/about/faq.aspx", "/about/faqbasics.aspx;/about/faqcost.aspx;/about/faqoperators.aspx;/about/faqregistration.aspx;/about/faqscope.aspx;/about/faqsearching.aspx;/about/faqsecurity.aspx;/about/faqtech.aspx", false );
			RenderMenuItem( output, "Policies", "/policies/default.aspx", "/policies/privacypolicy.aspx;/policies/termsofuse.aspx", false );
			RenderMenuItem( output, "About UDDI", "/about/default.aspx", "", false );
			RenderMenuItem( output, "Contact Us", "/contact/default.aspx", "", false );
			
			output.WriteLine("<TR>");
			output.WriteLine("<TD COLSPAN='2' HEIGHT='100%' STYLE='border-right : solid 1px #639ACE;'>");
			output.WriteLine("&nbsp;</TD>");
			output.WriteLine("</TR>");
			output.WriteLine( "</TABLE>" );
		}

		/// ****************************************************************
		///   private RenderMenuHeader
		/// ----------------------------------------------------------------
		///   <summary>
		///		Renders a menu header.
		///   </summary>
		/// ----------------------------------------------------------------
		///   <param name="output">
		///     The output stream.
		///   </param>
		///   
		///   <param name="name">
		///     Menu header name.
		///   </param>
		/// ****************************************************************
		/// 
		private void RenderMenuHeader( HtmlTextWriter output, string name )
		{
			output.WriteLine( "			   <TR>" );
			output.WriteLine( "              <TD colspan='2' height='8' style='border-right: solid 1px #639ACE;'><IMG height='1' src='"+root + "/images/trans_pixel.gif" +"' width='1' border='0'></TD>" );
			output.WriteLine( "			   </TR>" );
			output.WriteLine( "			   <TR>" );
			output.WriteLine( "              <TD bgcolor='#F1F1F1' width='10'></TD>" );
			output.WriteLine( "			     <TD class='menu_cell_border'><FONT class='menu_head'>" + name + "</FONT></TD>" );
			output.WriteLine( "			   </TR>" );
		}

		/// ****************************************************************
		///   private RenderMenuItem
		/// ----------------------------------------------------------------
		///   <summary>
		///		Renders a menu item.
		///   </summary>
		/// ----------------------------------------------------------------
		///   <param name="output">
		///     The output stream.
		///   </param>
		///   
		///   <param name="name">
		///     Menu item name.
		///   </param>
		///   
		///   <param name="url">
		///     Menu item url.
		///   </param>
		///   
		///   <param name="alternateURLs">
		///     Alternate URLs that this menu item is associated with.
		///   </param>
		/// ****************************************************************
		/// 
		private void RenderMenuItem( HtmlTextWriter output, string name, string url, string alternateURLs, bool secure )
		{
			string thisPage = HttpContext.Current.Request.ServerVariables["SCRIPT_NAME"].ToLower();
			
			bool currentPage = false;
            
			if( url.ToLower() == thisPage )
				currentPage = true;
			else if( null != alternateURLs )
			{
				alternateURLs = ";" + alternateURLs.ToLower() + ";";

				if( alternateURLs.IndexOf( thisPage ) >= 0 )
					currentPage = true;
			}

			string color = ( currentPage ? "#ffffff" : "#f1f1f1" );
			string border = ( currentPage ? "border-bottom: 1px solid #639ACE; border-top: 1px solid #639ACE; border-left: 1px solid #639ACE;" : " border-right: solid 1px #639ACE;" );

			output.WriteLine( "			   <TR>" );
			output.WriteLine( "              <TD bgcolor='#F1F1F1' width='10'></TD>" );
			output.WriteLine( "				 <TD style='" + border + "' bgcolor='" + color + "' onmouseover='this.style.backgroundColor=\"#CCCCCC\"' onmouseout='this.style.backgroundColor=\"\"' onclick='window.navigate(\"" + url + "\")' style='cursor: hand'><A class='nav' href='" + ( secure ? roots : root ) + url + "'>" + name.Replace( " ", "&nbsp;" ) + "</A></TD>" );
			output.WriteLine( "			   </TR>" );
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\web\menu.cs ===
using System;
using System.Collections;
using System.Data;
using System.IO;
using System.Reflection;
using System.Resources;
using System.Web.UI;
using System.Web.UI.WebControls;
namespace UDDI.Web
{
	public delegate void MenuEventHandler( object sender, MenuEventArgs e );

	[ParseChildren()]
	public class MenuControl : UddiControl, IPostBackEventHandler
	{
		public MenuControl()
		{
			this.SelectedIndexChanged += new MenuEventHandler( this.MenuControl_SelectedIndexChanged );
			MenuItems = new MenuItemControlCollection();
		}
		public event MenuEventHandler SelectedIndexChanged;
		
		protected string Roots
		{
			get
			{ 
				return HyperLinkManager.GetSecureHyperLink( "" );
			}
		}
		protected MenuItemControlCollection MenuItems;
		public string CssClass
		{
			get{ return this.Name; }
		}
		
		private string name;
		public string Name
		{
			get{ return name; }
			set{ name=value; }
		}
		
		private MenuType type;
		public MenuType Type
		{
			get{ return type; }
			set{ type=(MenuType)value; }
		}
		
		private string width = "100%";
		public string Width
		{
			get{ return width; }
			set{ width=value; }
		}
		private string borderwidth = "0";
		public string BorderWidth
		{
			get{ return borderwidth; }
			set{ borderwidth=value; }
		}
		
		
		//private int selectedindex;
		public int SelectedIndex
		{
			
			get
			{ 
				if( null==ViewState[ this.Name + "_Index" ] )
					ViewState[ this.Name + "_Index" ] = 0;
					
				return (int)ViewState[ this.Name + "_Index" ]; 
			}
			set{ ViewState[ this.Name + "_Index" ]=value; }
		}
		
		public MenuItemControl SelectedItem
		{
			get
			{ 
				return (MenuItemControl)this.Controls[ this.SelectedIndex ]; 
			}
		}

		
		private string height = "100%";
		public string Height
		{
			get{ return height; }
			set{ height=value; }
		}
		
		private string topoffset;
		public string TopOffset
		{
			get{ return topoffset; }
			set{ topoffset=value; }
		}
		private string leftoffset;
		public string LeftOffset
		{
			get{ return leftoffset; }
			set{ leftoffset=value; }
		}
		
		private int staticindex=-1;
		public int  StaticIndex
		{
			get{ return staticindex; }
			set{ staticindex=(int)value; }
		}
		
				
		private ArrayList items = new ArrayList();
				
		
		protected override void OnLoad( EventArgs e )
		{
			//
			// This script code is now in client.js
			//
			//if( !Page.IsClientScriptBlockRegistered( "SideNav_ClientScript" ) )
			//{
			//Page.RegisterClientScriptBlock( "SideNav_ClientScript",MenuControl.ClientScript );
			//}

			if( !Page.IsPostBack )
			{								
				if( null!=Request[ this.Name + "_Index" ] )
					this.SelectedIndex = Convert.ToInt32( Request[ this.Name + "_Index" ] );
			}
					
			base.OnLoad( e );
		}
						
		protected override void Render( HtmlTextWriter output )
		{
			
			output.Write( 
				"<table "+
				"width='" + this.Width + "' "+
				"height='" + this.Height + "' " +
				"class='" + this.CssClass + "' "+
				"border='" + this.BorderWidth + "' " +
				"cellpadding='4' "+
				"cellspacing='0' >\r\n" 
				);
			
			
			
			if( MenuType.Horizontal==this.Type )
			{
				output.Write( 
					"<TR >\r\n\t" );
				
				this.RenderChildren( output );
				
				output.Write( 
					"</TR>\r\n" 
					);
				
			}
			else//vertical
			{
				output.Write( 
					"	<TR height='4'>\r\n"+
					"		<TD height='4' colspan='2' class='"+this.Name+"_Item'>&nbsp;</TD>\r\n" +
					"	</TR>\r\n"
					);

				this.RenderChildren( output );
				
				//render the tail of the menu
				output.Write(
					"<TR height='100%'><TD width='100%' colspan='2'  height='100%' class='"+this.Name+"_Item'><br><br></TD></TR>"
					);
			}
			
			
			output.Write(
				"</table>"
				);
			
			
		}
		protected override void RenderChildren( HtmlTextWriter output )
		{
			this.EnsureChildControls();
			
			
			for( int i=0;i<this.MenuItems.Count;i++ )
			{
				MenuItemControl item = this.MenuItems[ i ];	
				if( StaticIndex>=0 )
				{
					if( i==this.StaticIndex  )
						item.Selected=true;
					else
						item.Selected=false;
				}
				else
				{
					if( i==this.SelectedIndex  )
						item.Selected=true;
					else
						item.Selected=false;
				}
				if( null==item.NavigateUrl && MenuItemType.Item==item.Type )
				{
					item.NavigateUrl="javascript:"+Page.GetPostBackEventReference( this, i.ToString() );
				}
			}
			base.RenderChildren( output );
		}
		protected override void AddParsedSubObject( object obj ) 
		{
			if( obj is MenuItemControl )
				this.AddItem( (MenuItemControl)obj );
		  
			base.AddParsedSubObject( obj );
		}
		public int AddItem( MenuItemControl item )
		{
			if( null==item.Name )
				item.Name = this.Name;

			item.MenuType = this.Type;
			item.LeftOffSet = this.LeftOffset;

			return this.MenuItems.Add( item );
		}
		public void RaisePostBackEvent( string eventArgument )
		{
			int newIndex = Convert.ToInt32( eventArgument );

			this.EnsureChildControls();

			this.OnSelectedIndexChanged( new MenuEventArgs( newIndex ) );
		}
		
		protected void OnSelectedIndexChanged( MenuEventArgs e )
		{
			if( null!=SelectedIndexChanged )
				this.SelectedIndexChanged( this,e );
		
		}
		private void MenuControl_SelectedIndexChanged( object sender, MenuEventArgs e )
		{
			this.SelectedIndex = e.Index;
		}


		public const string ClientScript = @"
			<script language='javascript'>
			<!-- 
			function MenuItem_Action( sender, action, name )
			{
				if( null!=sender )
				{
					switch( action.toLowerCase() )
					{
						case ""leave"":
							if( sender.className!=name+""_ItemSelected"" )
							{
								sender.className=name+""_Item"";
							}
							break;
						case ""enter"":
							if( sender.className!=name+""_ItemSelected"" )
							{
								sender.className=name+""_ItemHovor"";
							}
							break;
						default:
							alert( ""Unknown action: "" + action );
							break;

					}
				}
			}
			// -->
			</script>
		";
		
	}
	
	public class MenuEventArgs : EventArgs
	{
		public MenuEventArgs( int newindex )
		{
			this.index = newindex;
		}
		
		private int index;
		public int Index
		{
			get{ return index; }
		}
		
	}
	public class MenuItemControlCollection : CollectionBase
	{
		public MenuItemControl this[ int index ]
		{
			get{ return (MenuItemControl)this.List[ index ]; }
			set{ this.List[ index ] = value; }
		}
		protected internal int Add( MenuItemControl item )
		{
			return this.List.Add( item );
		}
		protected internal void Remove( MenuItemControl item )
		{
			this.List.Remove( item );
		}
		protected internal void Remove( int index )
		{
			this.List.RemoveAt( index );
		}
	}
	[ParseChildren()]
	public class MenuItemControl : UserControl
	{
		
		private ArrayList items = new ArrayList();
		protected string Root
		{
			get{ return ( "/" == Request.ApplicationPath ) ? "" : Request.ApplicationPath; }
		}
		protected string Roots
		{
			get
			{ 
				
				return HyperLinkManager.GetSecureHyperLink( "" ); 
			}
		}
		private bool requirehttps;
		public bool RequireHttps
		{
			get{ return requirehttps; }
			set{ requirehttps=value; }
		}
		private bool requirehttp;
		public bool RequireHttp
		{
			get{ return requirehttp; }
			set{ requirehttp=value; }
		}
		private string cssclass;
		public string CssClass
		{
			get{ return cssclass; }
			set{ cssclass=value; }
		}
		protected string root
		{
			get{ return HyperLinkManager.GetHyperLink( "" ); }
		}
		private bool selected;
		public bool Selected
		{
			get{ return selected; }
			set{ selected=value; }
		}
		
		private string text;
		public string Text
		{
			get
			{ 
				if( null!=text )
				{
					if( text.Length>65 )
						text=text.Substring( 0,65 ) + "...";	
				}
				return text; 
			}
			set{ text=value; }
		}
		
		private string navigateurl;
		public string NavigateUrl
		{
			get{ return navigateurl; }
			set{ navigateurl=value; }
		}
		private string navigatepage;
		public string NavigatePage
		{
			get{ return navigatepage; }
			set{ navigatepage=value; }
		}
		private string navigatetarget;
		public string NavigateTarget
		{
			get{ return navigatetarget; }
			set{ navigatetarget=value; }
		}
		
		private string name;
		public string Name
		{
			get{ return name; }
			set{ name=value; }
		}
		
		private MenuType menutype;
		public MenuType MenuType
		{
			get{ return menutype; }
			set{ menutype=(MenuType)value; }
		}
		
		private MenuItemType type;
		public MenuItemType Type
		{
			get{ return type; }
			set{ type=(MenuItemType)value;}
		}
		
		
		protected internal string LeftOffSet="0";
		

		protected override void Render( HtmlTextWriter output )
		{
			if( MenuType.Vertical==this.MenuType )
			{
				RenderVertical( output );
			
			}
			else
			{
				RenderHorizontal( output );
			}
	
		}
		protected void RenderVertical( HtmlTextWriter output )
		{
			output.Write( 
				"<TR>\r\n\t" 
				);
			
			RenderHorizontal( output );
			
			output.Write( 
				"</TR>\r\n" 
				);
			
			
		}
		protected void RenderHorizontal( HtmlTextWriter output )
		{
			output.Write(
				"<TD ><IMG src='" + Root + "/images/pixel.gif" + "' border='0' width='" + LeftOffSet + "'></TD>"
				
				);
			
			output.Write(
				"<TD "+
				"id='" + this.ID +"' " 
			);
			
			if( MenuItemType.Item==this.Type )
			{
				output.Write(
					"onmouseover='MenuItem_Action( this,\"enter\",\"" + this.Name + "\");' " +
					"onmouseout='MenuItem_Action( this,\"leave\",\"" + this.Name + "\");' " 
					);

				if( Selected )
				{
					output.Write( 
						"class='" + this.Name + "_ItemSelected' " 
						);
				}
				else
				{
					output.Write( 	
						"class='" + this.Name + "_Item' " 
						);
				}
			}
			else
			{
				if( MenuItemType.Separator==this.Type )
				{
					output.Write( 	
						"class='" + this.Name + "_Separator' " 
						);
				}
				else if( MenuItemType.Title==this.Type )
				{
					output.Write( 	
						"class='" + this.Name + "_Title' " 
						);
				}
				else
				{
					output.Write( 	
						"class='" + this.Name + "_Item' " 
						);
				}
			}
			output.Write(	
				">" 
				);

			
			RenderText( output );
			



			output.Write(
				"</TD>\r\n" );
			
		}
		protected void RenderText( HtmlTextWriter output )
		{
			
			switch( this.Type )
			{
				case MenuItemType.Item:			
					HyperLink l = new HyperLink();
					l.Text = this.Text;
					if( null!=this.NavigateTarget && ""!=this.NavigateTarget.Trim() )
						l.Target = this.NavigateTarget;
				
					string classname =  this.Name + "_Text";
				
					if( this.Selected )
					{
						classname += "Selected";
					}
					else
					{
						if( null!=this.NavigatePage )
						{
							if( RequireHttps )
							{
								l.NavigateUrl = HyperLinkManager.GetSecureHyperLink( NavigatePage );
							}
							else if( RequireHttp )
							{
								l.NavigateUrl = HyperLinkManager.GetNonSecureHyperLink( NavigatePage );
							}
							else
							{
								l.NavigateUrl = HyperLinkManager.GetHyperLink( NavigatePage );
							}
						}
						else if( null!=this.NavigateUrl )
						{
							l.NavigateUrl = this.NavigateUrl;
						}
					}
				
							
					l.CssClass=classname;			
					l.Target = this.NavigateTarget;
						
					output.Write( "<nobr>" );
					l.RenderControl( output );
					output.Write( "</nobr>" );
					break;
				case MenuItemType.Separator:
					Image i = new Image();
					i.ImageUrl = Root + "/images/pixel.gif";
					i.Height = new Unit( 1 );	
					i.Width = new Unit( 1 );
					i.BorderWidth = new Unit( 0 );
					i.RenderControl( output );
					break;
				case MenuItemType.Title:
					Label label = new Label();
					label.Text = this.Text;
					output.Write( "<nobr>" );
					label.RenderControl( output );
					output.Write( "</nobr>" );
					break;
			}
			
		}
		
		public void RenderChildrenExt( HtmlTextWriter output )
		{
			EnsureChildControls();
			RenderChildren( output );
		}
	}
	
	public enum MenuType
	{
		Horizontal,
		Vertical

	}
	public enum MenuItemType
	{
		Title,
		Separator,
		Item
	}

	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\web\security.cs ===
using System;
using System.ComponentModel;
using System.Security.Principal;
using System.Web;
using System.Web.Security;
using System.Web.UI;
using UDDI;

namespace UDDI.Web
{
	/// ********************************************************************
	///   public class SignInControl
	/// --------------------------------------------------------------------
	///   <summary>
	///     Web control for producing a sign-in link.
	///   </summary>
	/// ********************************************************************
	/// 
	public class SignInControl : UserControl
	{
		protected string returnUrl = null;
		protected bool forceLogin = true;

		/// ****************************************************************
		///   public ForceLogin [get/set]
		/// ----------------------------------------------------------------
		///   <summary>
		///     Specifies whether the user will be forced to re-enter his
		///     or her password after the time window has expired.
		///   </summary>
		/// ****************************************************************
		/// 
		[ Bindable( true ), Category( "Behavior" ), DefaultValue( true ) ]
		public bool ForceLogin
		{
			get { return forceLogin; }
			set { forceLogin = value; }
		}

		/// ****************************************************************
		///   public ReturnUrl [get/set]
		/// ----------------------------------------------------------------
		///   <summary>
		///     Specifies the URL we should redirect to after a user
		///     has signed in.
		///   </summary>
		/// ****************************************************************
		/// 
		[ Bindable( true ), Category( "Behavior" ), DefaultValue( null ) ]
		public string ReturnUrl
		{
			get { return returnUrl; }
			set { returnUrl = value; }
		}

		/// ****************************************************************
		///   protected Render
		/// ----------------------------------------------------------------
		///   <summary>
		///     Renders the control.
		///   </summary>
		/// ****************************************************************
		/// 
		protected override void Render( HtmlTextWriter output )
		{
			if( ( Config.GetInt( "Security.AuthenticationMode", (int)AuthenticationMode.Windows ) & (int)AuthenticationMode.Passport ) != 0 )
			{
				PassportIdentity passport = (PassportIdentity)Context.User.Identity;
						
				//
				// Display the Passport login image.
				//
				int timeWindow = Config.GetInt( "Passport.TimeWindow", 14400 );
				bool secure = Request.IsSecureConnection;
				
				string thisUrl = ( Request.IsSecureConnection ? "https://" : "http://" ) +
					Request.ServerVariables["SERVER_NAME"] + 
					Request.ServerVariables["SCRIPT_NAME"];

				if( Utility.StringEmpty( ReturnUrl ) )
					ReturnUrl = thisUrl;
				
				//
				// Update this to LogoTag2 when Passport .NET support is updated.				
				//
				string html = passport.LogoTag( ReturnUrl, timeWindow, forceLogin, "", 0, secure, "", 0, false );

				output.WriteLine( 
					"&nbsp;&nbsp;" + 
					html.Replace( "<A ", "<A TARGET='_top' " )+ 
					"&nbsp;&nbsp;" );
			}
		}
	}
	
	public class SecurityControl : UserControl
	{
		protected PassportIdentity passport;
		protected string loginUrl = "/login.aspx";
		protected string registerUrl = "/register.aspx"; 
		protected string returnUrl = null;
		protected bool forceLogin = true;
		protected bool userRequired = false;
		protected bool publisherRequired = false;
		protected bool coordinatorRequired = false;
		protected bool adminRequired = false;
		protected int timeWindow;

		/// ****************************************************************
		///   public UserRequired [get/set]
		/// ----------------------------------------------------------------
		///   <summary>
		///     Specifies the user role is required for the page.
		///   </summary>
		/// ****************************************************************
		/// 
		public bool UserRequired
		{
			get { return userRequired; }
			set { userRequired = value; }
		}

		/// ****************************************************************
		///   public PublisherRequired [get/set]
		/// ----------------------------------------------------------------
		///   <summary>
		///     Specifies the publisher role is required for the page.
		///   </summary>
		/// ****************************************************************
		/// 
		public bool PublisherRequired
		{
			get { return publisherRequired; }
			set { publisherRequired = value; }
		}

		/// ****************************************************************
		///   public CoordinatorRequired [get/set]
		/// ----------------------------------------------------------------
		///   <summary>
		///     Specifies the coordinator role is required for the page.
		///   </summary>
		/// ****************************************************************
		/// 
		public bool CoordinatorRequired
		{
			get { return coordinatorRequired; }
			set { coordinatorRequired = value; }
		}

		/// ****************************************************************
		///   public AdminRequired [get/set]
		/// ----------------------------------------------------------------
		///   <summary>
		///     Specifies the administrator role is required for the page.
		///   </summary>
		/// ****************************************************************
		/// 
		public bool AdminRequired
		{
			get { return adminRequired; }
			set { adminRequired = value; }
		}

		/// ****************************************************************
		///   public ForceLogin [get/set]
		/// ----------------------------------------------------------------
		///   <summary>
		///     Specifies whether the user will be forced to re-enter his
		///     or her password after the time window has expired.
		///   </summary>
		/// ****************************************************************
		/// 
		[ Bindable( true ), Category( "Behavior" ), DefaultValue( true ) ]
		public bool ForceLogin
		{
			get { return forceLogin; }
			set { forceLogin = value; }
		}

		/// ****************************************************************
		///   public LoginUrl [get/set]
		/// ----------------------------------------------------------------
		///   <summary>
		///     Specifies the login page.
		///   </summary>
		/// ****************************************************************
		/// 
		[ Bindable( true ), Category( "Behavior" ), DefaultValue( "/login.aspx" ) ]
		public string LoginUrl
		{
			get { return loginUrl; }
			set { loginUrl = value; }
		}

		/// ****************************************************************
		///   public ReturnUrl [get/set]
		/// ----------------------------------------------------------------
		///   <summary>
		///     Specifies the URL Passport should redirect to after a user
		///     has signed in.
		///   </summary>
		/// ****************************************************************
		/// 
		[ Bindable( true ), Category( "Behavior" ), DefaultValue( null ) ]
		public string ReturnUrl
		{
			get { return returnUrl; }
			set { returnUrl = value; }
		}

		/// ****************************************************************
		///   public IsAuthenticated [get]
		/// ----------------------------------------------------------------
		///   <summary>
		///     Returns true if the user is authenticated.
		///   </summary>
		/// ****************************************************************
		///
		public bool IsAuthenticated
		{
			get { return passport.GetIsAuthenticated( timeWindow, ForceLogin, false ); }
		}

		/// ****************************************************************
		///   protected OnInit
		/// ----------------------------------------------------------------
		///   <summary>
		///		Initializes the security control.
		///   </summary>
		/// ****************************************************************
		///
		protected override void OnInit( EventArgs e )
		{
			//
			// Check to make sure config settings are fresh.
			//
			Config.CheckForUpdate();

			//
			// Check to see if the server has been manually stopped.
			//
			if( 0 == Config.GetInt( "Run", 1 ) )
			{
#if never
				throw new UDDIException(
					ErrorType.E_busy,
					"UDDI Services are currently unavailable." );
#endif
				throw new UDDIException( ErrorType.E_busy, "UDDI_ERROR_SERVICES_NOT_AVAILABLE" );
			}

			int mode = Config.GetInt( "Security.AuthenticationMode", (int)AuthenticationMode.Windows );


			//
			// TODO:  This code should be simplified to simple if statements. 
			//	It is obviously old code that needs to be updated.
			//
			if( ( mode & (int)AuthenticationMode.Passport ) != 0 )
			{
				//
				// SECURITY: Passport.TimeWindow should be the same
				// timeout as API authentication.
				//
				passport = (PassportIdentity)Context.User.Identity;



				timeWindow = Config.GetInt( "Passport.TimeWindow", 14400 );
				
				string thisUrl = ( Request.IsSecureConnection ? "https://" : "http://" ) +
					Request.ServerVariables[ "SERVER_NAME" ] + 
					Request.ServerVariables[ "SCRIPT_NAME" ];

				if( Utility.StringEmpty( ReturnUrl ) )
					ReturnUrl = thisUrl;

				//
				// If the user just logged in, clean up the query string by redirecting
				// to this page.
				//
				if( passport.GetFromNetworkServer )
					Response.Redirect( thisUrl );
				
				//
				// Check to see if the current role is more that a passport user
				// can do.
				//
				if( AdminRequired || CoordinatorRequired )
				{
					//
					//Passport Users are not allowed in these areas.
					//
#if never
					throw new UDDIException(
						ErrorType.E_unknownUser,
						"Access denied." );
#endif
					throw new UDDIException(
						ErrorType.E_unknownUser,
						"UDDI_ERROR_ACCESS_DENIED" );
				}
				
				//
				// Check to see if the user is authenticated.
				//
				if( !passport.GetIsAuthenticated( timeWindow, ForceLogin, false ) )
				{
					//
					// If the user already has a ticket, force them to re-enter 
					// their password.
					//
					if( passport.HasTicket )
					{
						bool secure = Request.IsSecureConnection;
						
						//
						// Update this to AuthUrl2 when Passport .NET support is updated.				
						//
						Response.Redirect( passport.AuthUrl( ReturnUrl, timeWindow, ForceLogin, "", 0, "", 0, secure ) );
					}

					//
					// If login is required, redirect the user to the login page.
					//
					if( PublisherRequired   )
						Response.Redirect( LoginUrl + "?publish=true" );
				}
				else
				{
					string userID = passport.HexPUID;
					
					//
					// Check to ensure that the passport UserID is not ""
					// if it is, force them to retype thier password
					//
				//	if( ""==userID )
				//		Response.Redirect( LoginUrl );
					

					string email = (string)passport.GetProfileObject( "PreferredEmail" );
					
					UDDI.Context.User.SetPublisherRole( userID );
					
					if( PublisherRequired )
					{
						//
						// SECURITY: Is Validate the same as IsRegistered?
						//   lucasm: no, Validate makes sure the registered publisher has validated
						//       the email address they have supplied.  IsRegistered checks to see
						//       if we have added this uses to the publishers table.
						//	
						int valid = Publisher.Validate( userID );
						if( 50013 == valid  )
						{
							//
							// Need to create a page that tells the 
							// user to click the link in the email
							//
							Response.Redirect( LoginUrl );
						}
						else if( 0 != valid )
						{
							Response.Redirect( LoginUrl );
						}

						Publisher publisher = new Publisher();
						publisher.Login( userID, email );

						if( null == email )
							email = publisher.Email;

						//
						// TODO: this REALLY should be merged with the PublisherInfo class
						// in core!!
						//
						UDDI.Context.User.Name = publisher.Name;
						UDDI.Context.User.BindingLimit = publisher.BindingLimit;
						UDDI.Context.User.BusinessCount = publisher.BusinessCount;
						UDDI.Context.User.BusinessLimit = publisher.BusinessLimit;
						UDDI.Context.User.CompanyName = publisher.CompanyName;
						UDDI.Context.User.IsoLangCode = publisher.IsoLangCode;
						UDDI.Context.User.ServiceLimit = publisher.ServiceLimit;
						UDDI.Context.User.TModelCount = publisher.TModelCount;
						UDDI.Context.User.TModelLimit = publisher.TModelLimit;
					}
					

					//
					// Save the credentials for the authenticated user.
					//				
					UDDI.Context.User.ID = userID;
					UDDI.Context.User.Email = email;
				}
			}
			else
			{
				WindowsPrincipal principal = (WindowsPrincipal)HttpContext.Current.User;
				
				UDDI.Context.User.SetRole( principal );
				UDDI.Context.User.Name = principal.Identity.Name;

				if( UserRequired && !UDDI.Context.User.IsUser && ( mode & (int)AuthenticationMode.AuthenticatedRead ) != 0 ||
					PublisherRequired && !UDDI.Context.User.IsPublisher ||
					CoordinatorRequired && !UDDI.Context.User.IsCoordinator ||
					AdminRequired && !UDDI.Context.User.IsAdministrator )
				{
#if never
					throw new UDDIException(
						ErrorType.E_unknownUser,
						"Access denied." );
#endif
					throw new UDDIException( ErrorType.E_unknownUser, "UDDI_ERROR_ACCESS_DENIED" );
				}

				if( PublisherRequired || CoordinatorRequired || AdminRequired )
				{
					if( !UDDI.Context.User.IsRegistered )
					{
						if( 1 == Config.GetInt( "Security.AutoRegister", 0 ) )
						{
							UDDI.Context.User.TrackPassport = false;
							UDDI.Context.User.Verified = true;

							UDDI.Context.User.Register();
						}
						else
						{
#if never
							throw new UDDIException( UDDI.ErrorType.E_unknownUser,
								"User login failed" );
#endif
							throw new UDDIException( UDDI.ErrorType.E_unknownUser, "UDDI_ERROR_USER_LOGIN_FAILED" );
						}
					}

					UDDI.Context.User.Login();
				}
			}

			//
			// SECURITY: put this in the Windows Authentication block... not available
			// for Passport auth.
			//
			// If the user is a coordinator and they have a cookie indicating they are
			// impersonating another user, setup the user info in the current UDDI
			// context.
			//

			//
			// 734292 - Make sure the user is an administrator if they are trying to impersonate the system.
			//
			if( true == ViewAsPublisher.IsValid() )
			{
				UDDI.Context.User.ImpersonatorID = UDDI.Context.User.ID;
				UDDI.Context.User.ID = ViewAsPublisher.GetPublisherID();
			}			
		}
	}

	/// <summary>
	/// This class will handle all of the operations necessary to set and get the impersontation publisher ID value
	/// from HTTP cookies.  The name of this class is obscure by design.
	/// </summary>
	public class ViewAsPublisher
	{
		//
		// This value is used as the name of a cookie sent to the client.
		//
		private static string name = "ViewAsPublisher";

		/// <summary>
		/// This method will clear any current impersonation publisher ID's.
		/// </summary>
		public static void Reset()
		{
			//
			// Remove any current cookies.
			//
			HttpContext.Current.Response.Cookies.Remove( ViewAsPublisher.name );

			//
			// Clear out any current values the client may be holding onto
			//
			HttpCookie viewAsPublisher = new HttpCookie( name, "" );			
			HttpContext.Current.Response.Cookies.Add( viewAsPublisher );				
		}
				
		/// <summary>
		/// This method will set the publisher ID to impersonate.
		/// </summary>
		/// <param name="publisherID"></param>
		/// <returns></returns>
		public static bool Set( string publisherID )
		{			
			bool success = false;

			//
			// Make sure the name we are given is OK
			//
			if( true == ViewAsPublisher.IsValid( publisherID ) )
			{				
				//
				// Remove any current cookies.
				//
				HttpContext.Current.Response.Cookies.Remove( ViewAsPublisher.name );

				//
				// Set the impersonation publisher ID in a cookie.
				//
				HttpCookie viewAsPublisher = new HttpCookie( name, publisherID );			
				HttpContext.Current.Response.Cookies.Add( viewAsPublisher );						

				success = true;
			}
			
			return success;
		}
		
		/// <summary>
		/// This method will return the value of the publisher to impersonate, or null if there isn't one.
		/// </summary>
		/// <returns></returns>
		public static string GetPublisherID()
		{		
			string publisherID = null;

			HttpCookie viewAsPublisher = HttpContext.Current.Request.Cookies[ ViewAsPublisher.name ];
			if( null != viewAsPublisher )
			{
				publisherID = viewAsPublisher.Value as string;
				if( true == Utility.StringEmpty( publisherID ) )
				{
					publisherID = null;
				}
			}

			return publisherID;			
		}

		/// <summary>
		/// This method will return false if the user is not an administrator and they are trying to impersonate system 
		/// </summary>
		/// <returns></returns>
		public static bool IsValid( string publisherID )
		{
			bool isValid = false;

			//
			// The minimum requirement is that the publisherID is not null and that the user is a coordinator.
			//
			if( true == UDDI.Context.User.IsCoordinator && 
				null != publisherID )
			{						
				//
				// At this point, we are in a valid state.
				//
				isValid = true;

				//
				// Check to see if the user is trying to impersonate the system account.
				//
				if( true == publisherID.ToLower().Equals( "system" ) )
				{
					//
					// If the value is System, make sure the user is an administrator
					// 
					isValid = UDDI.Context.User.IsAdministrator;				
				}
			} 

			return isValid;
		}
		
		public static bool IsValid()
		{			
			return ViewAsPublisher.IsValid( ViewAsPublisher.GetPublisherID() );			
		}		
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\web\services.cs ===
using System;
using System.Data;
using System.Web.UI;
using System.Web.UI.WebControls;
using UDDI;
using UDDI.API;
using UDDI.API.Business;
using UDDI.API.Service;
using UDDI.API.ServiceType;
using UDDI.Diagnostics;

namespace UDDI.Web
{
	public class ServiceControl : UddiControl
	{
		protected BusinessServiceCollection services;

		private BusinessServiceCollection bindableServices;
		private BusinessServiceCollection bindableServiceProjections;

        protected BusinessEntity parent;
        protected bool frames;
		protected string parentKey;
		protected DataGrid grid;
		protected DataGrid projectionsGrid;

		public void Initialize( BusinessServiceCollection services, string parentKey )
		{
			this.services = services;
			this.parentKey = parentKey;
            this.parent = null;
			
			InitializeBindableData();
            
			grid.Columns[ 0 ].Visible = false;
            grid.Columns[ 1 ].Visible = false;
			grid.Columns[ 2 ].Visible = true;
			
			grid.ShowFooter = false;

			projectionsGrid.Columns[ 0 ].Visible = false;
			projectionsGrid.Columns[ 1 ].Visible = false;
			projectionsGrid.Columns[ 2 ].Visible = true;
			
		}
        
        public void Initialize( BusinessServiceCollection services, BusinessEntity parent )
        {
            this.services = services;
            this.parent = parent;
			this.parentKey = parent.BusinessKey;
			
			InitializeBindableData();
          
			grid.Columns[ 0 ].Visible = true;
            grid.Columns[ 1 ].Visible = true;
            grid.Columns[ 2 ].Visible = false;

            grid.ShowFooter = true;

			projectionsGrid.Columns[ 0 ].Visible = true;
			projectionsGrid.Columns[ 1 ].Visible = true;
			projectionsGrid.Columns[ 2 ].Visible = false;
			
		}
		private void InitializeBindableData( )
		{
			//
			// Fix to filter out service projections
			//
		
			bindableServices = new BusinessServiceCollection();
			bindableServiceProjections = new BusinessServiceCollection();
			
			foreach( BusinessService s in services )
			{
				
				if( s.BusinessKey!=parentKey )
				{
					bindableServiceProjections.Add( s );	
				}
				else
				{
					bindableServices.Add( s );
				}
			
			}
		}
		protected void Page_Load( object sender, EventArgs e )
		{
			frames = ( "true" == Request[ "frames" ] );
            
            PopulateDataGrid();
		}

		void PopulateDataGrid()
		{
		
			projectionsGrid.DataSource = bindableServiceProjections;
			projectionsGrid.DataBind();

			grid.DataSource = bindableServices;
			// commented for service projection fix.
			//grid.DataSource = services;
			grid.DataBind();
		}
		protected void ServiceProjection_View( object sender, DataGridCommandEventArgs e )
		{
			string key = bindableServiceProjections[ e.Item.ItemIndex ].ServiceKey;
			string root = ((Request.ApplicationPath=="/")?"":Request.ApplicationPath );
			if( frames )
			{
				string explkey = "sp:" + bindableServiceProjections[ e.Item.ItemIndex ].BusinessKey + ":" + key;
				Response.Write(
					ClientScripts.ReloadExplorerAndViewPanes( root+"/details/servicedetail.aspx?projectionContext=edit&frames=true&projectionKey="+parentKey+"&key=" + key, explkey ) );

				Response.End();
			}
			else
			{
				Response.Redirect( "editservice.aspx?frames=false&key=" + key ); 
				Response.End();
			}

		}
		protected void Service_Edit( object sender, DataGridCommandEventArgs e )
		{
			string key = bindableServices[ e.Item.ItemIndex ].ServiceKey;

            if( frames )
            {
                Response.Write(
                    ClientScripts.ReloadExplorerAndViewPanes( "editservice.aspx?frames=true&key=" + key, key ) );

                Response.End();
            }
            else
            {
                Response.Redirect( "editservice.aspx?frames=false&key=" + key ); 
                Response.End();
            }
		}

		protected void Service_Delete( object sender, DataGridCommandEventArgs e )
		{
            string name = bindableServices[ e.Item.ItemIndex ].Names[ 0 ].Value;
            string key = bindableServices[ e.Item.ItemIndex ].ServiceKey;

            //
            // The user has not yet confirmed the delete operation, so display
            // a confirmation dialog.
            //
            string message = String.Format( 
                Localization.GetString( "TEXT_DELETE_CONFIRMATION" ), 
                name );
				
            Page.RegisterStartupScript(
                "Confirm",
                ClientScripts.Confirm(
                message,
                "editservice.aspx?frames=" + ( frames ? "true" : "false" ) + "&key=" + key + "&mode=delete&confirm=true&tab=1" ) );
		}

		protected void Service_Add( object sender, EventArgs e )
		{
			Response.Redirect( "editservice.aspx?frames=" + ( frames ? "true" : "false" ) + "&key=" + parent.BusinessKey + "&mode=add" );
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\web\tab.cs ===
using System;
using System.Collections;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;
using UDDI;

namespace UDDI.Web
{
	public class TabControl : Control, INamingContainer, IPostBackEventHandler
	{
		protected TableStyle style = new TableStyle();
		protected TableItemStyle tabBeginStyle = new TableItemStyle();
		protected TableItemStyle tabBeginSelectedStyle = new TableItemStyle();
		protected TableItemStyle tabStyle = new TableItemStyle();
		protected TableItemStyle tabSelectedStyle = new TableItemStyle();
		protected TableItemStyle tabEndStyle = new TableItemStyle();
		protected TableItemStyle tabEndSelectedStyle = new TableItemStyle();
		protected TableItemStyle tabGapStyle = new TableItemStyle();
		protected TableItemStyle tabPageStyle = new TableItemStyle();
		protected TableStyle tabBodyStyle = new TableStyle();

		protected bool defaultStyle = true;
		protected bool tabSwitch = false;
		
		public delegate void TabChangeEventHandler( object sender, int oldIndex, int newIndex );		
		
		public event TabChangeEventHandler BeforeTabChange;
		public event TabChangeEventHandler TabChange;
		
		public TabControl()
		{
		}

		public int SelectedIndex
		{
			get 
			{
				if( null == ViewState[ "index" ] )
					return 0;

				return (int)ViewState[ "index" ]; 
			}

			set { ViewState[ "index" ] = value; }
		}

		public TableStyle Style
		{
			get { return style; }
		}

		public TableItemStyle TabBeginStyle
		{
			get { return tabBeginStyle; }
		}

		public TableItemStyle TabBeginSelectedStyle
		{
			get { return tabBeginSelectedStyle; }
		}
		
		public TableItemStyle TabStyle
		{
			get { return tabStyle; }
		}

		public TableItemStyle TabSelectedStyle
		{
			get { return tabSelectedStyle; }
		}

		public TableItemStyle TabEndStyle		
		{
			get { return tabEndStyle; }
		}

		public TableItemStyle TabEndSelectedStyle		
		{
			get { return tabEndSelectedStyle; }
		}

		public TableItemStyle TabGapStyle		
		{
			get { return tabGapStyle; }
		}

		public TableItemStyle TabPageStyle		
		{
			get { return tabPageStyle; }
		}
		public TableStyle TabBodyStyle
		{
			get{ return tabBodyStyle; }
		}
		

		public bool DefaultStyle
		{
			get { return defaultStyle; }
			set { defaultStyle = value; }
		}

		protected override void OnInit( EventArgs e )
		{
			if( defaultStyle )
			{
				TabBeginStyle.CssClass = "tabBegin";
				TabStyle.CssClass = "tab";
				TabEndStyle.CssClass = "tabEnd";

				TabBeginSelectedStyle.CssClass = "tabBeginSelected";
				TabSelectedStyle.CssClass = "tabSelected";
				TabEndSelectedStyle.CssClass = "tabEndSelected";

				TabGapStyle.CssClass = "tabGap";
				TabPageStyle.CssClass = "tabPage";
				TabBodyStyle.CssClass = "tabPage";
			}
		}

		protected override void AddParsedSubObject( object obj )
		{
			if( obj is TabPage )
				this.Controls.Add( (Control)obj );
		}
		
		void IPostBackEventHandler.RaisePostBackEvent( string eventArgument )
		{
			tabSwitch = true;

			if( ((UddiPage)Page).EditMode )
				return;

			int oldIndex = SelectedIndex;
			int newIndex = Convert.ToInt32( eventArgument );

			this.EnsureChildControls();

			if( null != BeforeTabChange )
				BeforeTabChange( this, oldIndex, newIndex );
			
			SelectedIndex = newIndex;
			
			if( null != TabChange )
				TabChange( this, oldIndex, newIndex );
		}

		protected override void Render( HtmlTextWriter output )
		{		
			int index = 0;
			int visiblePageCount = 0;
            int capWidth = ( ( UddiBrowser.IsDownlevel && !UddiBrowser.IsNetscape6 ) ? 1 : 4 );
						
			output.AddAttribute( HtmlTextWriterAttribute.Cellpadding, "0" );
			output.AddAttribute( HtmlTextWriterAttribute.Cellspacing, "0" );
			output.AddAttribute( HtmlTextWriterAttribute.Border, "0" );
			
            if( !UddiBrowser.IsDownlevel || UddiBrowser.IsNetscape6 )
                output.AddAttribute( HtmlTextWriterAttribute.Width, "100%" );
			
			Style.AddAttributesToRender( output );
			output.RenderBeginTag( HtmlTextWriterTag.Table );
			
			output.RenderBeginTag( HtmlTextWriterTag.Colgroup );

			foreach( TabPage page in Controls )
			{
				if( page.ShouldDisplay )
				{
					output.Write( "<col width='" + capWidth + "'>" );
					output.Write( "<col>" );
                    output.Write( "<col width='" + capWidth + "'>" );
                }
			}
			
            if( !UddiBrowser.IsDownlevel || UddiBrowser.IsNetscape6  )
                output.Write( "<col width='0*'>" );

			output.RenderEndTag();

			output.RenderBeginTag( HtmlTextWriterTag.Tr );

			foreach( TabPage page in Controls )
			{
				if( page.ShouldDisplay )
				{
					//
					// Create the begin tab cell.
					//
					if( index == SelectedIndex )
						TabBeginSelectedStyle.AddAttributesToRender( output );
					else
						TabBeginStyle.AddAttributesToRender( output );
					
					output.AddAttribute( "width", capWidth.ToString() );
					output.RenderBeginTag( HtmlTextWriterTag.Td );
					output.Write( "<img src='" + ((UddiPage)Page).Root + "/images/trans_pixel.gif' width='" + capWidth + "'>" );
					output.RenderEndTag();

					//
					// Create the link and text for the tab.
					//
					if( index == SelectedIndex )
						TabSelectedStyle.AddAttributesToRender( output );
					else
						TabStyle.AddAttributesToRender( output );
					
                    if( !UddiBrowser.IsDownlevel || UddiBrowser.IsNetscape6  )
                        output.AddAttribute( "width", "100" );
					
                    output.AddAttribute( "align", "center" );
					output.RenderBeginTag( HtmlTextWriterTag.Td );
					
					output.AddAttribute( HtmlTextWriterAttribute.Href, "javascript:" + Page.GetPostBackEventReference( this, Convert.ToString( index ) ) );
					output.Write( "<nobr>&nbsp;&nbsp;" );
					output.RenderBeginTag( HtmlTextWriterTag.A );
					output.Write( Localization.GetString( page.Name ) );
					output.RenderEndTag();
					output.Write( "&nbsp;&nbsp;</nobr>" );
					
					output.RenderEndTag();

					//
					// Create the closing tab cell.
					//
					if( index == SelectedIndex )
						TabEndSelectedStyle.AddAttributesToRender( output );
					else
						TabEndStyle.AddAttributesToRender( output );
					
					output.AddAttribute( "width", capWidth.ToString() );
					output.RenderBeginTag( HtmlTextWriterTag.Td );
					output.Write( "<img src='" + ((UddiPage)Page).Root + "/images/trans_pixel.gif' width='" + capWidth + "'>" );
					output.RenderEndTag();

					visiblePageCount ++;
				}

				index ++;
			}

			//
			// Render the leftover space at the end of the tabs
			//
            if( !UddiBrowser.IsDownlevel || UddiBrowser.IsNetscape6 )
            {
                TabGapStyle.AddAttributesToRender( output );
			
                output.AddAttribute( "width", "100%" );
                output.RenderBeginTag( HtmlTextWriterTag.Td );
                output.Write( "<img src='" + ((UddiPage)Page).Root + "/images/trans_pixel.gif' width='1'>" );
                output.RenderEndTag();
            }

			//
			// Add the completed tab row to the table.
			//
			output.RenderEndTag();

			//  
			// Test to see if we can fix the table spacing problems in IE6
			// Task: Split the table in to tables
			//
			output.RenderEndTag();

			output.AddAttribute( HtmlTextWriterAttribute.Cellpadding, "10" );
			output.AddAttribute( HtmlTextWriterAttribute.Cellspacing, "0" );
			output.AddAttribute( HtmlTextWriterAttribute.Width, "100%" );
			
			

			if( UddiBrowser.IsDownlevel && !UddiBrowser.IsNetscape6 )
			{
				output.AddAttribute( HtmlTextWriterAttribute.Border, "1" );
				output.AddAttribute( HtmlTextWriterAttribute.Bordercolor, "#639ace" );	
			}
			
			output.AddAttribute( HtmlTextWriterAttribute.Bgcolor, "#f0f8ff" );
			TabBodyStyle.AddAttributesToRender( output );
			output.RenderBeginTag( HtmlTextWriterTag.Table );
				
			output.RenderBeginTag( HtmlTextWriterTag.Tr );

			output.AddAttribute( "valign", "top" );
			output.RenderBeginTag( HtmlTextWriterTag.Td );
				
			if( ((UddiPage)Page).EditMode && tabSwitch )
			{
				output.AddAttribute( "color", "red" );
				output.RenderBeginTag( HtmlTextWriterTag.Font );
				output.Write( Localization.GetString( "ERROR_FINISH_EDIT" ) );
				output.RenderEndTag();
				output.Write( "<br><br>" );
			}
				
			this.Controls[ SelectedIndex ].RenderControl( output );
				
			output.RenderEndTag();
			output.RenderEndTag();
			output.RenderEndTag();
			output.Write( "<br>" );
			
			/*
			//
			// Create the tab page content
			//
            //if( UddiBrowser.IsDownlevel )
            //{
                output.RenderEndTag();

                output.AddAttribute( HtmlTextWriterAttribute.Cellpadding, "10" );
                output.AddAttribute( HtmlTextWriterAttribute.Cellspacing, "0" );
                output.AddAttribute( HtmlTextWriterAttribute.Width, "100%" );
                output.AddAttribute( HtmlTextWriterAttribute.Border, "1" );
                output.AddAttribute( HtmlTextWriterAttribute.Bordercolor, "#639ace" );
                output.AddAttribute( HtmlTextWriterAttribute.Bgcolor, "#f0f8ff" );
                output.RenderBeginTag( HtmlTextWriterTag.Table );
				
                output.RenderBeginTag( HtmlTextWriterTag.Tr );
                output.RenderBeginTag( HtmlTextWriterTag.Td );
				
                if( ((UddiPage)Page).EditMode && tabSwitch )
                {
                    output.AddAttribute( "color", "red" );
                    output.RenderBeginTag( HtmlTextWriterTag.Font );
                    output.Write( Localization.GetString( "ERROR_FINISH_EDIT" ) );
                    output.RenderEndTag();
                    output.Write( "<br><br>" );
                }
				
                this.Controls[ SelectedIndex ].RenderControl( output );
				
                output.RenderEndTag();
                output.RenderEndTag();
                output.RenderEndTag();
                output.Write( "<br>" );
			}
			else
			{
			
                output.RenderBeginTag( HtmlTextWriterTag.Tr );
    			
                TabPageStyle.AddAttributesToRender( output );
                output.AddAttribute( HtmlTextWriterAttribute.Valign, "top" );
                output.AddAttribute( HtmlTextWriterAttribute.Colspan, Convert.ToString( visiblePageCount * 3 + 1 ) );
                output.RenderBeginTag( HtmlTextWriterTag.Td );
    			
                if( ((UddiPage)Page).EditMode && tabSwitch )
                {
                    output.AddAttribute( "color", "red" );
                    output.RenderBeginTag( HtmlTextWriterTag.Font );
                    output.Write( Localization.GetString( "ERROR_FINISH_EDIT" ) );
                    output.RenderEndTag();
                    output.Write( "<br><br>" );
                }

                this.Controls[ SelectedIndex ].RenderControl( output );

                output.RenderEndTag();
                output.RenderEndTag();
                output.RenderEndTag();
            }
			*/
		}

	}
	
	public class TabPage : Control, INamingContainer
	{
		protected RoleType requiredRole = RoleType.Anonymous;
		
		protected bool downlevelOnly = false;
		protected string name;
		
		public string Name
		{
			get { return name; }
			set { name = value; }
		}
	
		public RoleType RequiredRole
		{
			get { return requiredRole; }
			set { requiredRole = value; }
		}

		public bool AccessAllowed
		{
			get
			{
				return
					( RoleType.Anonymous == requiredRole ) ||
					( RoleType.User == requiredRole && UDDI.Context.User.IsUser ) ||
					( RoleType.Publisher == requiredRole && UDDI.Context.User.IsPublisher ) ||
					( RoleType.Coordinator == requiredRole && UDDI.Context.User.IsCoordinator ) ||
					( RoleType.Administrator == requiredRole && UDDI.Context.User.IsAdministrator );
			}
		}

		public bool DownlevelOnly
		{
			get { return downlevelOnly; }
			set { downlevelOnly = value; }
		}

		public bool ShouldDisplay
		{
			get
			{
				return 
					AccessAllowed && Visible && 
					( !DownlevelOnly || ( ((UddiPage)Page).IsDownlevel && DownlevelOnly ) );
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\web\taxonomy.cs ===
using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using System.Web;
using UDDI;
using UDDI.API;
using UDDI.API.ServiceType;
using UDDI.Diagnostics;

namespace UDDI.Web
{
	public class Taxonomy
	{
		public static DataView GetTaxonomies()
		{
			Debug.Enter();

			DataTable taxonomies = GetTaxonomiesDataSet();

			Debug.Leave();

			return taxonomies.DefaultView;
		}
		public static DataView GetTaxonomies( string filter, string sort)
		{
			Debug.Enter();

			DataTable taxonomies = GetTaxonomiesDataSet();
			
			DataView view = new DataView( taxonomies, filter, sort,DataViewRowState.OriginalRows );

			Debug.Leave();

			return view;
		}
		protected static DataTable GetTaxonomiesDataSet( )
		{
			Debug.Enter();

			DataSet taxonomies = new DataSet();

			SqlCommand cmd = new SqlCommand( "UI_getTaxonomies", ConnectionManager.GetConnection() );
			cmd.CommandType = CommandType.StoredProcedure;
			
			cmd.Transaction = ConnectionManager.GetTransaction();

			SqlDataAdapter adapter = new SqlDataAdapter( cmd );

			adapter.Fill( taxonomies, "Taxonomies" );

			Debug.Leave();

			return taxonomies.Tables[ "Taxonomies" ];
		}

		public static int GetTaxonomyID( string tModelKey )
		{
			int taxonomyID;

			Debug.Enter();

			SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor();

			sp.ProcedureName = "UI_getTaxonomies";

			sp.Parameters.Add( "@tModelKey", SqlDbType.UniqueIdentifier );
			sp.Parameters.SetGuidFromKey( "@tModelKey", tModelKey );
			
			SqlDataReaderAccessor reader = sp.ExecuteReader();

			try
			{
				if( reader.Read() )
					taxonomyID = reader.GetInt( "taxonomyID" );
				else
					taxonomyID = -1;
			}
			finally
			{
				reader.Close();
			}

			Debug.Leave();
			return taxonomyID;
		}

		public static string GetTaxonomyParent( int taxonomyID, string ID )
		{
			Debug.Enter();

			SqlCommand cmd = new SqlCommand( "UI_getTaxonomyParent", ConnectionManager.GetConnection() );
			cmd.CommandType = CommandType.StoredProcedure;
			
			cmd.Transaction = ConnectionManager.GetTransaction();
			cmd.Parameters.Add( new SqlParameter( "@TaxonomyID", SqlDbType.Int ) ).Direction = ParameterDirection.Input;
			cmd.Parameters.Add( new SqlParameter( "@ID", SqlDbType.NVarChar, 450 ) ).Direction = ParameterDirection.Input;
			
			SqlParameterAccessor paramacc = new SqlParameterAccessor( cmd.Parameters );
				
			paramacc.SetInt( "@TaxonomyID", taxonomyID );
			paramacc.SetString( "@ID", ID );

			string parent = (string)cmd.ExecuteScalar();

			Debug.Leave();

			return parent;
		}
		public static string GetTaxonomyKeyName( int taxonomyID, string keyValue )
		{
			Debug.Enter();

			SqlCommand cmd = new SqlCommand( "UI_getTaxonomyName", ConnectionManager.GetConnection() );
			cmd.CommandType = CommandType.StoredProcedure;
			
			cmd.Transaction = ConnectionManager.GetTransaction();
			cmd.Parameters.Add( new SqlParameter( "@TaxonomyID", SqlDbType.Int ) ).Direction = ParameterDirection.Input;
			cmd.Parameters.Add( new SqlParameter( "@ID", SqlDbType.NVarChar, 450 ) ).Direction = ParameterDirection.Input;
			
			SqlParameterAccessor paramacc = new SqlParameterAccessor( cmd.Parameters );
				
			paramacc.SetInt( "@TaxonomyID", taxonomyID );
			paramacc.SetString( "@ID", keyValue );

			string keyName = (string)cmd.ExecuteScalar();

			
			Debug.Leave();

			return keyName;
		}
		public static DataView GetTaxonomyChildrenNode( int taxonomyID, string node )
		{
			Debug.Enter();

			DataSet categories = new DataSet();

			SqlCommand cmd = new SqlCommand( "UI_getTaxonomyChildrenNode", ConnectionManager.GetConnection() );
			cmd.CommandType = CommandType.StoredProcedure;
			
			cmd.Transaction = ConnectionManager.GetTransaction();
			cmd.Parameters.Add( new SqlParameter( "@rowCount", SqlDbType.Int ) ).Direction = ParameterDirection.ReturnValue;
			cmd.Parameters.Add( new SqlParameter( "@taxonomyID", SqlDbType.Int ) ).Direction = ParameterDirection.Input;
			cmd.Parameters.Add( new SqlParameter( "@node", SqlDbType.NVarChar, 450 ) ).Direction = ParameterDirection.Input;
			
			SqlParameterAccessor paramacc = new SqlParameterAccessor( cmd.Parameters );
				
			paramacc.SetInt( "@taxonomyID", taxonomyID );
			paramacc.SetString( "@node", node );

			SqlDataAdapter adapter = new SqlDataAdapter( cmd );

			adapter.Fill( categories, "categories" );

			Debug.Leave();

			return categories.Tables[ "categories" ].DefaultView;
		}

		public static DataView GetTaxonomyChildrenRoot( int taxonomyID )
		{
			Debug.Enter();

			DataSet categories = new DataSet();

			SqlCommand cmd = new SqlCommand( "UI_getTaxonomyChildrenRoot", ConnectionManager.GetConnection() );
			cmd.CommandType = CommandType.StoredProcedure;
			cmd.Transaction = ConnectionManager.GetTransaction();
			cmd.Parameters.Add( new SqlParameter( "@rowCount", SqlDbType.Int ) ).Direction = ParameterDirection.ReturnValue;
			cmd.Parameters.Add( new SqlParameter( "@taxonomyID", SqlDbType.Int ) ).Direction = ParameterDirection.Input;
			
			SqlParameterAccessor paramacc = new SqlParameterAccessor( cmd.Parameters );
				
			paramacc.SetInt( "@taxonomyID", taxonomyID );

			SqlDataAdapter adapter = new SqlDataAdapter( cmd );

			adapter.Fill( categories, "Categories"  );
			
			Debug.Leave();

			return categories.Tables[ "Categories" ].DefaultView;
		}

		public static bool IsValidForClassification( int taxonomyID, string node )
		{
			Debug.Enter();

			SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor();

			sp.ProcedureName = "UI_isNodeValidForClassification";
			
			sp.Parameters.Add( "@taxonomyID", SqlDbType.Int );
			sp.Parameters.Add( "@node", SqlDbType.NVarChar, 450 );
			
			sp.Parameters.SetInt( "@taxonomyID", taxonomyID );
			sp.Parameters.SetString( "@node", node );

			bool valid = (bool)sp.ExecuteScalar();

			Debug.Leave();

			return valid;
		}
		public static void SetTaxonomyBrowsable( string tModelKey, bool enabled )
		{
			SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor();

			sp.ProcedureName = "UI_setTaxonomyBrowsable";
			
			sp.Parameters.Add( "@tModelKey", SqlDbType.UniqueIdentifier );
			sp.Parameters.Add( "@enabled", SqlDbType.TinyInt );
			
			sp.Parameters.SetGuidFromKey( "@tModelKey", tModelKey );
			sp.Parameters.SetInt( "@enabled", Convert.ToInt32( enabled ) );
			sp.ExecuteNonQuery();
		}
		public static DataTable GetTaxonomiesForBrowsingDataTable()
		{
			Debug.Enter( );
			DataSet taxonomies = new DataSet( );

			SqlCommand cmd = new SqlCommand( "UI_getBrowsableTaxonomies", ConnectionManager.GetConnection() );
			cmd.CommandType = CommandType.StoredProcedure;
			
			cmd.Transaction = ConnectionManager.GetTransaction();

			SqlDataAdapter adapter = new SqlDataAdapter( cmd );

			adapter.Fill( taxonomies, "Taxonomies" );
			Debug.Leave();
			return taxonomies.Tables[ "Taxonomies" ];
		}
		public static DataView GetTaxonomiesForBrowsing( )
		{
			Debug.Enter( );
			
			DataTable taxonomies = GetTaxonomiesForBrowsingDataTable();

			Debug.Leave();

			return taxonomies.DefaultView;

		}
		public static DataView GetTaxonomiesForBrowsing( string filter, string sort )
		{
			Debug.Enter( );
			
			DataTable taxonomies = GetTaxonomiesForBrowsingDataTable();
			DataView view = new DataView( taxonomies, filter, sort, DataViewRowState.OriginalRows );
			
			Debug.Leave();

			return view;

		}

		///********************************************************************************************************
		/// <summary>
		///			Used to determine if the current taxonomy object is valid for use in the User Interface for
		///		browsing purposes.  
		///		
		///			Checks a flag in the database to see if the taxonomy is browsable.
		///			
		///			If flag 0x02 is set, then it is browsable.
		/// </summary>
		///********************************************************************************************************
		/// <param name="tModelKey">tModelKey to get</param>
		///********************************************************************************************************
		/// <returns>
		///		boolean indicating that the taxonomy is valid for browsing in the search via the User Interface
		/// </returns>
		///********************************************************************************************************
		public static bool IsValidForBrowsing( string tModelKey )
		{
			bool r = false;
			SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor();

			sp.ProcedureName = "UI_isTaxonomyBrowsable";
			
			sp.Parameters.Add( "@tModelKey", SqlDbType.UniqueIdentifier );
			sp.Parameters.Add( "@isBrowsable", SqlDbType.TinyInt, ParameterDirection.Output );
			
			sp.Parameters.SetGuidFromKey( "@tModelKey", tModelKey );
			
			sp.ExecuteNonQuery();

			r = sp.Parameters.GetBool( "@isBrowsable" );
			
			sp.Close();

			return r;
		}
		
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\web\tmodelbag.cs ===
using System;
using System.Collections.Specialized;
using System.Data;
using System.Web.UI;
using System.Web.UI.WebControls;
using UDDI.API;
using UDDI.API.Business;
using UDDI.API.ServiceType;
using UDDI;
using UDDI.Diagnostics;

namespace UDDI.Web
{
	public class TModelBagControl : UddiControl
	{
		protected CacheObject cache = null;
		protected StringCollection tModelBag = null;
		
		protected DataGrid grid;

		public void Initialize( StringCollection tModelBag, CacheObject cache )
		{
			this.cache = cache;
			this.tModelBag = tModelBag;
		}	
		
		protected void Page_Load( object sender, EventArgs e )
		{
			if( !Page.IsPostBack )
				PopulateDataGrid( false );
		}

		void PopulateDataGrid( bool createNewRow )
		{
			DataTable table = new DataTable();
			DataRow row;

			int index = 0;
	        
			table.Columns.Add( new DataColumn( "Index", typeof( int ) ) );
			table.Columns.Add( new DataColumn( "TModelName", typeof( string ) ) );
			table.Columns.Add( new DataColumn( "TModelKey", typeof( string ) ) );

			foreach( string tModelKey in tModelBag )
			{
				row = table.NewRow();

				row[0] = index;
				row[1] = Lookup.TModelName( tModelKey );
				row[2] = tModelKey;

				table.Rows.Add( row );
				
				index ++;
			}
	        
			if( createNewRow )
			{
				row = table.NewRow();

				row[0] = index;
				row[1] = "";
				row[2] = "";

				table.Rows.Add( row );
				
				index ++;		
			}
	        
			grid.DataSource = new DataView( table );
			grid.DataBind();
		}	
		
		protected void Grid_OnDelete( object sender, DataGridCommandEventArgs e )
		{
			int index = e.Item.ItemIndex;
			
			tModelBag.RemoveAt( index );    
			
			if( null != cache )
				cache.Save();

			PopulateDataGrid( false );
		}

		protected void Grid_OnCancel( object sender, DataGridCommandEventArgs e )
		{
			grid.EditItemIndex = -1;
			CancelEditMode();

			PopulateDataGrid( false );
		}

		protected void Grid_OnAdd( object sender, EventArgs e )
		{
			grid.EditItemIndex = tModelBag.Count;
			SetEditMode();		
			
			PopulateDataGrid( true );
		}

		protected void Selector_OnSelect( object sender, string key, string name )
		{
			tModelBag.Add( key );
			
			if( null != cache )
				cache.Save();
			
			grid.EditItemIndex = -1;
			CancelEditMode();

			PopulateDataGrid( false );
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\web\tmodels.cs ===
using System;
using System.Data;
using System.Web.UI;
using System.Web.UI.WebControls;
using UDDI;
using UDDI.API;
using UDDI.API.ServiceType;
using UDDI.Diagnostics;

namespace UDDI.Web
{
	public class TModelControl : UddiControl
	{
		protected TModelInfoCollection tModelInfos;
        protected bool frames;

		protected DataGrid grid;

		public void Initialize( TModelInfoCollection tModelInfos, bool allowEdit )
		{
			this.tModelInfos = tModelInfos;

            grid.Columns[ 0 ].Visible = allowEdit;
            grid.Columns[ 1 ].Visible = allowEdit;
			grid.Columns[ 2 ].Visible = !allowEdit;
		}
		
		protected void Page_Load( object sender, EventArgs e )
		{
            frames = ( "true" == Request[ "frames" ] );
			PopulateDataGrid();
		}

		void PopulateDataGrid()
		{
			grid.DataSource = tModelInfos;
			grid.DataBind();
		}
		
		protected void TModel_Edit( object sender, DataGridCommandEventArgs e )
		{
			string key = tModelInfos[ e.Item.ItemIndex ].TModelKey;
			
            if( frames )
            {
                //
                // Reload explorer and view panes.
                //
                Response.Write(
                    ClientScripts.ReloadExplorerAndViewPanes( "editmodel.aspx?frames=true&key=" + key, key ) );
            }
            else
            {
                Response.Redirect( "editmodel.aspx?frames=false&key=" + key ); 
            }
		}

		protected void TModel_Delete( object sender, DataGridCommandEventArgs e )
		{
            string name = tModelInfos[ e.Item.ItemIndex ].Name;
            string key = tModelInfos[ e.Item.ItemIndex ].TModelKey;

            //
            // The user has not yet confirmed the delete operation, so display
            // a confirmation dialog.
            //
            string message = String.Format( 
                Localization.GetString( "TEXT_DELETE_CONFIRMATION" ), 
                name );
				
            Page.RegisterStartupScript(
                "Confirm",
                ClientScripts.Confirm(
                message,
                "editmodel.aspx?frames=" + ( frames ? "true" : "false" ) + "&key=" + key + "&mode=delete&confirm=true&tab=2" ) );
		}

		protected void TModel_Add( object sender, EventArgs e )
		{
			Response.Redirect( "editmodel.aspx?frames=" + ( frames ? "true" : "false" ) + "&mode=add" );
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\web\taxonomytree.cs ===
using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using System.Web;
using System.Web.UI;
using System.Web.UI.WebControls;
using UDDI;
using UDDI.Diagnostics;

namespace UDDI.Web
{
//
//	TODO: Move most of this code into a base class (HyarchicalBreadCrumbsControl) and inherit from that
//	
	public delegate void TaxonomyTreeControlEventHandler( object sender, TaxonomyTreeControlEventArgs e );
	public class TaxonomyTreeControl : TaxonomyTreeItemControl
	{
		public TaxonomyTreeControl() : base()
		{
			//
			// wire up local event handlers
			//
			this.Init += new EventHandler( TaxonomyTreeControl_Init );
			this.Load += new EventHandler( TaxonomyTreeControl_Load );
			
		}

		private static string root = ( ( "/" == HttpContext.Current.Request.ApplicationPath )?"": HttpContext.Current.Request.ApplicationPath );
		public static string SpacerImage
		{
			get{ return root+"/images/blank.gif"; }
		}
		public static string ItemImage
		{
			get{ return root+"/images/bluebox.gif"; }
		}
		public static string SelectedItemImage
		{
			get{ return root+"/images/bluearrow.gif"; }
		}



		private int selectedIndex = 0;
		/// *******************************************************************************************************
		/// <summary>
		///		Gets the Selected Index of the Tree
		/// </summary>
		/// *******************************************************************************************************
		public int SelectedIndex
		{
			get{ return selectedIndex; }
		}

		private string cssClass;
		/// *******************************************************************************************************
		/// <summary>
		///		Gets or Sets the Style Sheet class to use.
		/// </summary>
		/// *******************************************************************************************************
		public string CssClass
		{
			get{ return this.cssClass; }
			set{ this.cssClass = value; }
		}

		/// *******************************************************************************************************
		/// <summary>
		///		Selects and Item in the Tree by the index of the item
		/// </summary>
		/// <param name="index">Index in the tree you want to be selected. Rendering will stop at this node</param>
		/// *******************************************************************************************************
		public void SelectItem( int index )
		{
			TaxonomyTreeItemControl item = this;
			while( item.Index!=index )
			{
				item.isSelected = false;
				item = item.Child;
			}
			item.isSelected = true;
			this.selectedIndex = item.Index;
		}


		/// <summary>
		/// 
		/// </summary>
		/// <param name="output"></param>
		protected override void Render( HtmlTextWriter output )
		{
			//wrap all items in a parent div.
			
			output.Write( "<div class='"+this.CssClass+"'>\r\n" );

			base.Render( output );
			
			output.Write( "</div>\r\n" );
		}


		/// *******************************************************************************************************
		/// <summary>
		/// 
		/// </summary>
		/// <param name="sender">object that triggered the event</param>
		/// <param name="e">EventArguments for this Event.</param>
		/// *******************************************************************************************************
		private void TaxonomyTreeControl_Init( object sender, EventArgs e )
		{


		}

		/// *******************************************************************************************************
		/// <summary>
		/// 
		/// </summary>
		/// <param name="sender">object that triggered the event</param>
		/// <param name="e">EventArguments for this Event.</param>
		/// *******************************************************************************************************
		private void TaxonomyTreeControl_Load( object sender, EventArgs e )
		{


		}

	}



	/// ***********************************************************************************************************
	/// <summary>
	///		TaxonomyTreeItemControl
	///			Holds information about a selected Taxonomy Item.
	/// </summary>
	/// ***********************************************************************************************************
	public class TaxonomyTreeItemControl : UddiControl, IPostBackEventHandler
	{
		public event TaxonomyTreeControlEventHandler ChildClick;
		public event TaxonomyTreeControlEventHandler Click;
		
		public TaxonomyTreeItemControl()
		{
			this.ChildClick += new TaxonomyTreeControlEventHandler( TaxonomyTreeItemControl_ChildClick );
			
			
		}


		protected internal bool isSelected;
		/// *******************************************************************************************************
		/// <summary>
		///		Get if the node is the selected node.
		/// </summary>
		/// *******************************************************************************************************
		public bool IsSelected
		{
			get{ return isSelected; }
		}
		

		private bool bubbleEvents = false;
		/// <summary>
		///		Gets or Sets if the TreeItem should bubble its ClickClick Events up.
		/// </summary>
		public bool BubbleEvents
		{
			get
			{ 
				if( null!=this.ParentTree )
					return this.ParentTree.BubbleEvents;
				return bubbleEvents; 
			}
			set{ bubbleEvents=value; }
		}

		private int indentBase=0;
		/// <summary>
		///		Gets or Sets the base number of pixels to indent each node in the tree.
		///		This number will be multiplied by the index to find the total indent space.
		/// </summary>
		public int IndentBase
		{
			get
			{ 
				if( 0==indentBase )
				{
					if( null!=this.ParentTreeItem )
						indentBase = this.ParentTreeItem.IndentBase;
				}
				
                return indentBase; 
			
			}
			set{ indentBase=value; }
		}

		/// <summary>
		///		Gets the Total Indent space used for this Tree Item
		/// </summary>
		public int TotalIndentSpace
		{
			get{ return ( IndentBase * Index ); }
		}
		
		/// <summary>
		///		Gets the Total count of Children in the hyarchy of the tree including it self
		/// </summary>
		public int Count
		{
			get
			{ 
				int i = 1;
				TaxonomyTreeItemControl item = this;
				while( null!=item.Child )
				{
					item = item.Child;
					i++;
				}
				return i;
			}
		}

		protected string keyValue;
		/// *******************************************************************************************************
		/// <summary>
		///		Gets or Sets the KeyValue associated with the item
		/// </summary>
		/// *******************************************************************************************************
		public string KeyValue
		{
			get{ return keyValue; }
			set{ keyValue = value; }
		}
		
		protected int taxonomyID;
		/// *******************************************************************************************************
		/// <summary>
		///		Gets or Sets the TaxonomyID associated with this item
		/// </summary>
		/// *******************************************************************************************************
		public int TaxonomyID
		{
			get{ return taxonomyID; }
			set{ taxonomyID = value; }
		}

		protected string keyName;
		/// *******************************************************************************************************
		/// <summary>
		///		Gets or Sets the KeyName associated with this item
		/// </summary>
		/// *******************************************************************************************************
		public string KeyName
		{
			get{ return keyName; }
			set{ keyName = value; }
		}
		

		protected TaxonomyTreeItemControl child;
		/// *******************************************************************************************************
		/// <summary>
		///		Gets the Active child of the current Taxonomy Item
		/// </summary>
		/// *******************************************************************************************************
		public TaxonomyTreeItemControl Child
		{
			get{ return child; }
		}
		/// *******************************************************************************************************
		/// <summary>
		///		Gets the Active parent of the current Taxonomy Item
		/// </summary>
		/// *******************************************************************************************************
		public TaxonomyTreeItemControl ParentTreeItem
		{
			get
			{
				if( null!=this.Parent && this.Parent is TaxonomyTreeItemControl )
				{
					return (TaxonomyTreeItemControl)this.Parent;
				}
				else
				{
					return null;
				}
			}
		}
		/// *******************************************************************************************************
		/// <summary>
		///		Gets the Tree that this item belong to
		/// </summary>
		/// *******************************************************************************************************
		public TaxonomyTreeControl ParentTree
		{
			get
			{
				TaxonomyTreeItemControl item = this.ParentTreeItem;
				while( null!=item && !(item is  TaxonomyTreeControl ) )
				{
					item = item.ParentTreeItem;
				}
				return (TaxonomyTreeControl)item;
			}
		}
		/// *******************************************************************************************************
		/// <summary>
		///		Gets the index of this Item in the Tree
		/// </summary>
		/// *******************************************************************************************************
		public int Index
		{
			get
			{
				int i = 0;
				TaxonomyTreeItemControl item = this.ParentTreeItem;
				while( null!=item  )
				{
					item = item.ParentTreeItem;
					i++;
				}
				return i;
			}
		}

		/// *******************************************************************************************************
		/// <summary>
		///		Sets the Active Child to this Taxonomy Item
		/// </summary>
		/// <param name="child">TreeItem you want to be the child</param>
		/// *******************************************************************************************************
		public void SetChild( TaxonomyTreeItemControl child )
		{
			this.Controls.Clear();
			this.Controls.Add( child );
			this.child = child;
			this.Child.IndentBase = this.IndentBase;
			this.Child.BubbleEvents = this.BubbleEvents;
			this.Child.Click += new TaxonomyTreeControlEventHandler( TaxonomyTreeItemControl_ChildClick );
		}
		
		/// *******************************************************************************************************
		/// <summary>
		///		Renders this Tree Item
		/// </summary>
		/// <param name="output">HtmlTextWriter to use to write to the stream</param>
		/// *******************************************************************************************************
		protected override void Render( HtmlTextWriter output )
		{
			//render the begin tag
			output.Write( "<div>" );
			
			Image spacer = new Image();
			Image item = new Image();
			Control text;


			
			if( IsSelected )
			{
				//
				// set the item Image
				//
				item.ImageUrl = TaxonomyTreeControl.SelectedItemImage;
				
				//
				//selected item, not clickable.
				//
				text = (Control)new Label();
				((Label)text).Text= "<nobr>"+HttpUtility.HtmlEncode(	KeyName  )+"</nobr>";
			}
			else
			{
				//
				//item is clickable.
				//
				text = (Control)new HyperLink();
				((HyperLink)text).Text=  "<nobr>"+HttpUtility.HtmlEncode(	KeyName )+"</nobr>";

				//
				//set up the postback event handler
				//
				((HyperLink)text).NavigateUrl = Page.GetPostBackClientHyperlink( this, "" );

				//
				// set the item Image
				//
				item.ImageUrl = TaxonomyTreeControl.ItemImage;
				
			}

			item.ImageAlign = ImageAlign.AbsBottom;

			//
			//	setup the spacer Image
			//
			spacer.Width = new Unit( this.TotalIndentSpace );
			spacer.ImageUrl = TaxonomyTreeControl.SpacerImage;
			spacer.Height = new Unit( 1 );
			spacer.ImageAlign = ImageAlign.AbsBottom;
			
			//render the controls.
			spacer.RenderControl( output );
			item.RenderControl( output );
			
			
			text.RenderControl( output );
			

			//render the end tag
			output.Write( "</div>\r\n" );

			//if this item is selected, don't render any children.
			if( !IsSelected )
				RenderChildren( output );
		}

		protected override void RenderChildren( HtmlTextWriter output )
		{
			if( null!=this.Child )
				this.Child.RenderControl( output );
		}

		/// *******************************************************************************************************
		/// <summary>
		///		Catches the PostBack event from the server
		/// </summary>
		/// <param name="eventArgument">Required by interface, but ignored in this implentation</param>
		/// *******************************************************************************************************
		void IPostBackEventHandler.RaisePostBackEvent( string eventArgument )
		{
			//
			// fire the Click event
			//
			this.OnClick( new TaxonomyTreeControlEventArgs( this ) );
		}

		/// *******************************************************************************************************
		/// <summary>
		///		Code to execute when a ChildClick event is Captured.
		/// </summary>
		/// <param name="sender">object that triggered the event</param>
		/// <param name="e">EventArguments for this Event.</param>
		/// *******************************************************************************************************
		private void TaxonomyTreeItemControl_ChildClick( object sender, TaxonomyTreeControlEventArgs e )
		{
			if( BubbleEvents )
			{
				this.OnClick( e );
			}
		}

		/// *******************************************************************************************************
		/// <summary>
		///		Fires the ChildClick event
		/// </summary>
		/// <param name="e">EventArguments to pass in the Event</param>
		/// *******************************************************************************************************
		protected void OnChildClick( TaxonomyTreeControlEventArgs e )
		{
			if( null!=this.ChildClick )
				this.ChildClick( this, e );
		}
		
		/// *******************************************************************************************************
		/// <summary>
		///		Fires the ChildClick event
		/// </summary>
		/// <param name="e">EventArguments to pass in the Event</param>
		/// *******************************************************************************************************
		protected void OnClick( TaxonomyTreeControlEventArgs e )
		{
			if( null!=this.Click )
				this.Click( this, e );
		}
	}
	/// ***********************************************************************************************************
	/// <summary>
	///		EventArguments Class
	/// </summary>
	/// ***********************************************************************************************************
	public class TaxonomyTreeControlEventArgs : EventArgs
	{
		private TaxonomyTreeItemControl item;
		/// *******************************************************************************************************
		/// <summary>
		///		Gets the TaxonomyTreeItemControl that triggered the event
		/// </summary>
		/// *******************************************************************************************************
		public TaxonomyTreeItemControl Item
		{
			get{ return item; }
		}
		
		public TaxonomyTreeControlEventArgs( TaxonomyTreeItemControl item )
		{
			this.item = item;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\web\statistics.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using System.Web;
using UDDI;
using UDDI.Diagnostics;

namespace UDDI.Web
{
	public enum ReportType
	{
		GetEntityCounts = 0,
		GetPublisherStats = 1,
		GetTopPublishers = 2,
		GetTaxonomyStats = 3
	}

	public enum ReportStatus
	{
		Available = 0,
		Processing = 1
	}

	public class Statistics
	{
		public static DataView GetStatistics( ReportType reporttype, ref DateTime lastchange )
		{
			string reportid = GetReportID( reporttype );

			Debug.Enter();


			//
			// Get Report Header
			//

			SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor();
			sp.ProcedureName = "net_report_get";

			sp.Parameters.Add( "@reportID", SqlDbType.NVarChar, 128 );
			sp.Parameters.Add( "@lastChange", SqlDbType.DateTime, ParameterDirection.Output );

			sp.Parameters.SetString( "@reportID", reportid );			
			sp.ExecuteNonQuery();
			
			lastchange = (DateTime)sp.Parameters.GetDateTime( "@lastChange" );

			//
			// Get Report Detail
			//

			DataSet statistics = new DataSet();

			SqlStoredProcedureAccessor sp2 = new SqlStoredProcedureAccessor();
			sp2.ProcedureName = "net_reportLines_get";

			sp2.Parameters.Add( "@reportID", SqlDbType.NVarChar, 128 );
			sp2.Parameters.SetString( "@reportID", reportid );			

			sp2.Fill( statistics, "Statistics" );

			Debug.Leave();

			return statistics.Tables[ "Statistics" ].DefaultView;
		}

		public static void RecalculateStatistics( )
		{
			Debug.Enter();

			SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor();
			sp.ProcedureName = "net_statistics_recalculate";
			try
			{
				sp.ExecuteNonQuery();
			}			
			catch( Exception e )
			{
				Debug.Write( UDDI.Diagnostics.SeverityType.Info, CategoryType.Website, "Exception during statistic recalculation:\r\n\r\n" + e.ToString() );
#if never
				throw new UDDIException( ErrorType.E_fatalError, "Unable to recalculate statistics:" + e.Message );
#endif
				throw new UDDIException( ErrorType.E_fatalError, "UDDI_ERROR_UNABLE_TO_RECALC_STATS", e.Message );
			}

			Debug.Leave();
		}

		public static ReportStatus GetReportStatus( ReportType reporttype )
		{
			string reportid = GetReportID( reporttype );
			ReportStatus reportstatus;

			Debug.Enter();

			SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor();
			sp.ProcedureName = "net_report_get";

			sp.Parameters.Add( "@reportID", SqlDbType.NVarChar, 128 );
			sp.Parameters.Add( "@reportStatusID", SqlDbType.TinyInt, ParameterDirection.Output );

			sp.Parameters.SetString( "@reportID", reportid );			
			sp.ExecuteNonQuery();
			
			reportstatus = (ReportStatus)sp.Parameters.GetInt( "@reportStatusID" );

			Debug.Leave();

			return reportstatus;
		}

		private static string GetReportID ( ReportType reporttype )
		{
			string reportid = "";

			switch( reporttype )
			{
				case ReportType.GetEntityCounts :
					reportid = "UI_getEntityCounts";
					break;
				case ReportType.GetPublisherStats :
					reportid = "UI_getPublisherStats";
					break;
				case ReportType.GetTopPublishers :
					reportid = "UI_getTopPublishers";
					break;
				case ReportType.GetTaxonomyStats :
					reportid = "UI_getTaxonomyStats";
					break;
			}

			return reportid;
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\xp\uddi.xp.h ===
#include <windows.h>
#include <stdio.h>
#include <tchar.h>

//
// Include ODS headers
//
#include "srv.h"

#include <string>
using namespace std;

#define XP_NOERROR              0
#define XP_ERROR                1
#define MAXCOLNAME				25
#define MAXNAME					50
#define MAXTEXT					255
#define MAXERROR				80
#define	XP_SRVMSG_SEV_ERROR		11

extern "C"
{
	RETCODE xp_reset_key( SRV_PROC *srvproc );
	RETCODE xp_reclaculate_statistics( SRV_PROC *srvproc );
}

void ReportError( SRV_PROC *srvproc, LPCSTR sz, DWORD dwResult = 0 );
string& GetUddiInstallDirectory();
ULONG __GetXpVersion();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\xp\srv.h ===
//------------------------------------------------------------
// Open Data Services header file: srv.h
// Copyright (c) 1989 - 1999 by Microsoft Corp.
//

// Avoid double inclusion
#ifndef _ODS_SRV_H_
#define _ODS_SRV_H_

#include "windows.h"

// ODS uses pack(4) on all CPU types
#pragma pack(4)

#ifdef __cplusplus
extern "C" {
#endif

// define model
#if !defined( FAR )
#define FAR far
#endif

//------------------------------------------------------------
// Formats of data types
#if !defined(DBTYPEDEFS) // Do not conflict with DBLIB definitions
#if !defined(MAXNUMERICLEN) // Do not conflict with ODBC definitions

#define DBTYPEDEFS

typedef unsigned char DBBOOL;
typedef unsigned char DBBYTE;
typedef unsigned char DBTINYINT;
typedef short DBSMALLINT;
typedef unsigned short DBUSMALLINT;
typedef long DBINT;
typedef char DBCHAR;
typedef unsigned char DBBINARY;
typedef unsigned char DBBIT;
typedef double DBFLT8;

typedef struct srv_datetime 
{	// Format for SRVDATETIME
    long dtdays;            // number of days since 1/1/1900
    unsigned long dttime;   // number 300th second since mid
} DBDATETIME;				

typedef struct srv_money 
{		// Format for SRVMONEY
    long mnyhigh;
    unsigned long mnylow;
} DBMONEY;

typedef float DBFLT4;
typedef long DBMONEY4;

typedef struct dbdatetime4 
{	// Format for SRVDATETIM4
    unsigned short numdays; // number of days since 1/1/1900
    unsigned short nummins; // number of minutes sicne midnight
} DBDATETIM4;

#define MAXNUMERICLEN	16
typedef struct dbnumeric	
{	// Format for SRVNUMERIC,SRVNUMERICN,SRVDECIMAL,SRVDECIMALN
	BYTE precision;
	BYTE scale;
	BYTE sign;
	BYTE val[MAXNUMERICLEN];
} DBNUMERIC;
typedef DBNUMERIC DBDECIMAL;

#endif  // #if !defined(MAXNUMERICLEN)
#endif  // #if !defined( DBTYPEDEFS )

//------------------------------------------------------------
// Constants used by APIs

// Type Tokens
#define SRV_TDS_NULL           (BYTE) 0x1f
#define SRV_TDS_TEXT           (BYTE) 0x23
#define SRV_TDS_GUID           (BYTE) 0x24
#define SRV_TDS_VARBINARY      (BYTE) 0x25
#define SRV_TDS_INTN           (BYTE) 0x26
#define SRV_TDS_VARCHAR        (BYTE) 0x27
#define SRV_TDS_BINARY         (BYTE) 0x2d
#define SRV_TDS_IMAGE          (BYTE) 0x22
#define SRV_TDS_CHAR           (BYTE) 0x2f
#define SRV_TDS_INT1           (BYTE) 0x30
#define SRV_TDS_BIT            (BYTE) 0x32
#define SRV_TDS_INT2           (BYTE) 0x34
#define SRV_TDS_DECIMAL        (BYTE) 0x37
#define SRV_TDS_INT4           (BYTE) 0x38
#define SRV_TDS_DATETIM4       (BYTE) 0x3a
#define SRV_TDS_FLT4           (BYTE) 0x3b
#define SRV_TDS_MONEY          (BYTE) 0x3c
#define SRV_TDS_DATETIME       (BYTE) 0x3d
#define SRV_TDS_FLT8           (BYTE) 0x3e
#define SRV_TDS_NUMERIC        (BYTE) 0x3f
#define SRV_TDS_NTEXT		   (BYTE) 0x63
#define SRV_TDS_BITN		   (BYTE) 0x68
#define SRV_TDS_DECIMALN       (BYTE) 0x6a
#define SRV_TDS_NUMERICN       (BYTE) 0x6c
#define SRV_TDS_FLTN           (BYTE) 0x6d
#define SRV_TDS_MONEYN         (BYTE) 0x6e
#define SRV_TDS_DATETIMN       (BYTE) 0x6f
#define SRV_TDS_MONEY4         (BYTE) 0x7a
#define SRV_TDS_BIGVARBINARY   (BYTE) 0xA5
#define SRV_TDS_BIGVARCHAR     (BYTE) 0xA7
#define SRV_TDS_BIGBINARY      (BYTE) 0xAD
#define SRV_TDS_BIGCHAR        (BYTE) 0xAF
#define SRV_TDS_NVARCHAR	   (BYTE) 0xe7
#define SRV_TDS_NCHAR		   (BYTE) 0xef

// Datatypes
// Also: values of symbol parameter to srv_symbol when type = SRV_DATATYPE
#define SRVNULL        SRV_TDS_NULL
#define SRVTEXT        SRV_TDS_TEXT
#define SRVGUID        SRV_TDS_GUID
#define SRVVARBINARY   SRV_TDS_VARBINARY
#define SRVINTN        SRV_TDS_INTN
#define SRVVARCHAR     SRV_TDS_VARCHAR
#define SRVBINARY      SRV_TDS_BINARY
#define SRVIMAGE       SRV_TDS_IMAGE
#define SRVCHAR        SRV_TDS_CHAR
#define SRVINT1        SRV_TDS_INT1
#define SRVBIT         SRV_TDS_BIT
#define SRVINT2        SRV_TDS_INT2
#define SRVDECIMAL	   SRV_TDS_DECIMAL
#define SRVINT4        SRV_TDS_INT4
#define SRVDATETIM4    SRV_TDS_DATETIM4
#define SRVFLT4        SRV_TDS_FLT4    
#define SRVMONEY       SRV_TDS_MONEY
#define SRVDATETIME    SRV_TDS_DATETIME
#define SRVFLT8        SRV_TDS_FLT8
#define SRVNUMERIC	   SRV_TDS_NUMERIC
#define SRVNTEXT	   SRV_TDS_NTEXT
#define SRVBITN		   SRV_TDS_BITN
#define SRVDECIMALN	   SRV_TDS_DECIMALN
#define SRVNUMERICN	   SRV_TDS_NUMERICN
#define SRVFLTN        SRV_TDS_FLTN
#define SRVMONEYN      SRV_TDS_MONEYN
#define SRVDATETIMN    SRV_TDS_DATETIMN
#define SRVMONEY4      SRV_TDS_MONEY4  
#define SRVBIGVARBINARY SRV_TDS_BIGVARBINARY
#define SRVBIGVARCHAR  SRV_TDS_BIGVARCHAR
#define SRVBIGBINARY   SRV_TDS_BIGBINARY
#define SRVBIGCHAR     SRV_TDS_BIGCHAR
#define SRVNVARCHAR	   SRV_TDS_NVARCHAR
#define SRVNCHAR	   SRV_TDS_NCHAR

// values for srv_symbol type parameter
#define SRV_ERROR      0
#define SRV_DONE       1
#define SRV_DATATYPE   2
#define SRV_EVENT      4

// values for srv_symbol symbol parameter, when type = SRV_ERROR
#define SRV_ENO_OS_ERR     0
#define SRV_INFO           1
#define SRV_FATAL_PROCESS  10
#define SRV_FATAL_SERVER   19

// Types of server events
// Also: values for srv_symbol symbol parameter, when type = SRV_EVENT
#define SRV_CONTINUE       0
#define SRV_LANGUAGE       1
#define SRV_CONNECT        2
#define SRV_RPC            3
#define SRV_RESTART        4
#define SRV_DISCONNECT     5
#define SRV_ATTENTION      6
#define SRV_SLEEP          7
#define SRV_START          8
#define SRV_STOP           9
#define SRV_EXIT           10
#define SRV_CANCEL         11
#define SRV_SETUP          12
#define SRV_CLOSE          13
#define SRV_PRACK          14
#define SRV_PRERROR        15
#define SRV_ATTENTION_ACK  16
#define SRV_CONNECT_V7	   16	// TDS type for TDS 7 clients.  Overloaded with SRV_ATTENTION_ACK
#define SRV_SKIP		   17
#define SRV_TRANSMGR	   18
#define SRV_OLEDB	       20
#define SRV_INTERNAL_HANDLER 99
#define SRV_PROGRAMMER_DEFINED  100

// values for srv_config option parameter
#define SRV_CONNECTIONS         1
#define SRV_LOGFILE             2
#define SRV_STACKSIZE           3
#define SRV_REMOTE_ACCESS       7
#define SRV_REMOTE_CONNECTIONS  9
#define SRV_MAX_PACKETS         10
#define SRV_MAXWORKINGTHREADS	11
#define SRV_MINWORKINGTHREADS	12
#define SRV_THREADTIMEOUT		13
#define SRV_MAX_PACKETSIZE		17
#define SRV_THREADPRIORITY		18
#define SRV_ANSI_CODEPAGE		19
#define	SRV_DEFAULT_PACKETSIZE	26
#define SRV_PASSTHROUGH			27

// vlaues for srv_config value parameter when option = SRV_THREADPRIORITY
#define SRV_PRIORITY_LOW      THREAD_PRIORITY_LOWEST
#define SRV_PRIORITY_NORMAL   THREAD_PRIORITY_NORMAL
#define SRV_PRIORITY_HIGH     THREAD_PRIORITY_HIGHEST
#define SRV_PRIORITY_CRITICAL THREAD_PRIORITY_TIME_CRITICAL

// values for srv_sfield field parameter
#define SRV_SERVERNAME          0
#define SRV_VERSION             6

// Length to indicate string is null terminated
#define SRV_NULLTERM   -1

// values of msgtype parameter to srv_sendmsg
#define SRV_MSG_INFO    1
#define SRV_MSG_ERROR   2

// values of status parameter to srv_senddone
// Also: values for symbol parameters to srv_symbol when type = SRV_DONE
#define SRV_DONE_FINAL			(USHORT) 0x0000
#define SRV_DONE_MORE			(USHORT) 0x0001
#define SRV_DONE_ERROR			(USHORT) 0x0002
#define SRV_DONE_COUNT			(USHORT) 0x0010
#define SRV_DONE_RPC_IN_BATCH   (USHORT) 0x0080

// return values of srv_paramstatus
#define SRV_PARAMRETURN		0x0001
#define SRV_PARAMDEFAULT    0x0002

// return values of srv_rpcoptions
#define SRV_RECOMPILE		0x0001
#define SRV_NOMETADATA		0x0002

// values of field parameter to srv_pfield
//#define SRV_LANGUAGE 1   already defined above
//#define SRV_EVENT    4   already defined above
#define SRV_SPID				10
#define SRV_NETSPID				11
#define SRV_TYPE				12
#define SRV_STATUS				13
#define SRV_RMTSERVER			14
#define SRV_HOST				15
#define SRV_USER				16
#define SRV_PWD					17
#define SRV_CPID				18
#define SRV_APPLNAME			19
#define SRV_TDS					20
#define SRV_CLIB				21
#define SRV_LIBVERS				22
#define SRV_ROWSENT				23
#define SRV_BCPFLAG				24
#define SRV_NATLANG				25
#define SRV_PIPEHANDLE			26
#define SRV_NETWORK_MODULE	    27
#define SRV_NETWORK_VERSION		28
#define SRV_NETWORK_CONNECTION	29
#define SRV_LSECURE				30
#define SRV_SAXP				31
#define SRV_UNICODE_USER		33
#define SRV_UNICODE_PWD			35
#define SRV_SPROC_CODEPAGE                    36

// return value of SRV_TDSVERSION macro
#define SRV_TDS_NONE   0
#define SRV_TDS_2_0    1
#define SRV_TDS_3_4    2
#define SRV_TDS_4_2    3
#define SRV_TDS_6_0    4
#define SRV_TDS_7_0    5

// Return values from APIs
typedef int SRVRETCODE;        // SUCCEED or FAIL
#ifndef ODBCVER
typedef int RETCODE;
#endif

#if !defined( SUCCEED )
#define SUCCEED     1   // Successful return value
#endif

#if !defined( FAIL )
#define FAIL        0   // Unsuccessful return value
#endif

#define SRV_DUPLICATE_HANDLER	2	// additional return value for srv_pre/post_handle

//------------------------------------------------
//PreDeclare structures
//
struct srv_server;
typedef struct srv_server SRV_SERVER;

struct srv_config;
typedef struct srv_config SRV_CONFIG;

struct srv_proc;
typedef struct srv_proc SRV_PROC;

//------------------------------------------------
//------------------------------------------------
// ODS MACROs & APIs

// Describing and sending a result set
int srv_describe(SRV_PROC*,int,char*,int,long int,long int,long int,long int,void*);
int srv_setutype(SRV_PROC* srvproc,int column,long int usertype);
int srv_setcoldata(SRV_PROC* srvproc,int column,void* data);
int srv_setcollen( SRV_PROC* srvproc,int column,int len);
int srv_sendrow(SRV_PROC* srvproc );
int srv_senddone(SRV_PROC* srvproc,USHORT status,USHORT curcmd,long int count);

// Dealing with Extended Procedure parameters
int srv_rpcparams(SRV_PROC*);
int srv_paraminfo(SRV_PROC*,int,BYTE*,ULONG*,ULONG*,BYTE*,BOOL*);
int srv_paramsetoutput(SRV_PROC*,int,BYTE*,ULONG,BOOL);

void* srv_paramdata(SRV_PROC*,int);
int srv_paramlen(SRV_PROC*,int);
int srv_parammaxlen(SRV_PROC*,int);
int srv_paramtype(SRV_PROC*,int);
int srv_paramset(SRV_PROC*,int,void*,int);

char* srv_paramname(SRV_PROC*,int,int*);
int srv_paramnumber(SRV_PROC*,char*,int);

//--------------------------------------------------------------
//--------------------------------------------------------------
// The rest of these APIs are still supported, in SQL Server 7.0,
// but may not be supported after SQL Server 7.0

// MACROs
#define SRV_GETCONFIG(a)		srv_getconfig	  ( a )
#define SRV_GETSERVER(a)		srv_getserver	  ( a )
#define SRV_GOT_ATTENTION(a)	srv_got_attention ( a )
#define	SRV_EVENTDATA(a)		srv_eventdata	  ( a )
#define	SRV_IODEAD(a)			srv_iodead		  ( a )
#define	SRV_TDSVERSION(a)		srv_tdsversion	  ( a )

SRV_CONFIG* srv_getconfig( SRV_SERVER * server );
SRV_SERVER* srv_getserver( SRV_PROC   * srvproc );
BOOL srv_got_attention( SRV_PROC * srvproc );
void* srv_eventdata( SRV_PROC * srvproc );

// Memory
void* srv_alloc(long int ulSize);
int srv_bmove(void* from,void* to,long int count);
int srv_bzero( void  * location,long int count);
int srv_free( void * ptr );

int srv_config( SRV_CONFIG * config,long int option,char* value,int valuelen);
SRV_CONFIG * srv_config_alloc( void );


int srv_convert(SRV_PROC*,int,void*,long int,int,void*,long int);

int (*  srv_errhandle(int (* handler)(SRV_SERVER * server,
												  SRV_PROC   * srvproc,
												  int		   srverror,
												  BYTE 	       severity,
												  BYTE 	       state,
												  int		   oserrnum,
												  char     * errtext,
												  int		   errtextlen,
												  char     * oserrtext,
												  int		   oserrtextlen)))
												   ( SRV_SERVER * server,
													 SRV_PROC   * srvproc,
													 int		  srverror,
													 BYTE 	      severity,
													 BYTE 	      state,
													 int		  oserrnum,
													 char     * errtext,
													 int		  errtextlen,
													 char     * oserrtext,
													 int		  oserrtextlen );

int srv_event(SRV_PROC * srvproc,int event,BYTE* data);

void* srv_getuserdata( SRV_PROC * srvproc );

int srv_getbindtoken(SRV_PROC * srvproc,char* token_buf);

int srv_getdtcxact(SRV_PROC * srvproc,void ** ppv);

typedef int (* EventHandler)(void*);
EventHandler srv_handle(SRV_SERVER*,long int,EventHandler);

int srv_impersonate_client( SRV_PROC * srvproc );

SRV_SERVER* srv_init( SRV_CONFIG * config,
					 char	    * connectname,
					 int	      namelen );

BOOL srv_iodead( SRV_PROC * srvproc );

long srv_langcpy(SRV_PROC *	srvproc,long start,long nbytes,char* buffer);
long srv_langlen( SRV_PROC * srvproc );
void* srv_langptr( SRV_PROC *srvproc );

int
     srv_log( SRV_SERVER * server,
					BOOL	     datestamp,
					char     * msg,
					int 	     msglen );

int srv_paramstatus(SRV_PROC*,int);

char* srv_pfield( SRV_PROC * srvproc,int	      field,int	    * len );

int srv_returnval( SRV_PROC * srvproc,
						  char   * valuename,
						  int		 len,
						  BYTE		 status,
						  long int 	 type,
						  long int 	 maxlen,
						  long int 	 datalen,
						  void	   * value );

int srv_revert_to_self( SRV_PROC * srvproc );

char* srv_rpcdb(SRV_PROC* srvproc,int* len );
char* srv_rpcname(SRV_PROC * srvproc,int* len );
int srv_rpcnumber( SRV_PROC * srvproc );
USHORT srv_rpcoptions( SRV_PROC * srvproc );
char* srv_rpcowner( SRV_PROC * srvproc,int	  * len );

int srv_run( SRV_SERVER * server );

int
     srv_sendmsg( SRV_PROC  * srvproc,
						int	        msgtype,
						long int	    msgnum,
						BYTE   msgclass,
						BYTE   state,
						char	  * rpcname,
						int	        rpcnamelen,
						USHORT linenum,
						char	  * message,
						int	        msglen );

int
     srv_ansi_sendmsg( SRV_PROC  * srvproc,
						int	        msgtype,
						long int	    msgnum,
						BYTE   msgclass,
						BYTE   state,
						char	  * rpcname,
						int	        rpcnamelen,
						USHORT linenum,
						char	  * message,
						int	        msglen );

int srv_sendstatus( SRV_PROC * srvproc,long int	  status );


int srv_setuserdata(SRV_PROC* srvproc,void* ptr);


char* srv_sfield( SRV_SERVER * server,int field,int* len);

char* srv_symbol(int	type,int symbol,int* len);

int srv_tdsversion(SRV_PROC* srvproc);

int srv_writebuf(SRV_PROC* srvproc, void* ptr, WORD	count);

BOOL srv_willconvert(int srctype,int desttype );

void srv_ackattention( SRV_PROC * srvproc );

int srv_terminatethread( SRV_PROC * srvproc );

int srv_sendstatistics( SRV_PROC * srvproc );

int srv_clearstatistics( SRV_PROC * srvproc );

int srv_setevent( SRV_SERVER * server, int          event);

int srv_message_handler( SRV_PROC * srvproc, 
								int        errornum, 
								BYTE       severity,
								BYTE       state, 
								int        oserrnum, 
								char     * errtext, 
								int        errtextlen, 
								char     * oserrtext, 
								int        oserrtextlen );

int srv_pre_handle( SRV_SERVER * server,
						    SRV_PROC   * srvproc,
						    long int event,
						    EventHandler handler,
						    BOOL         remove );
int srv_post_handle( SRV_SERVER * server,
							 SRV_PROC   * srvproc,
							 long int        event,
							 EventHandler handler,
							 BOOL         remove );

int srv_post_completion_queue( SRV_PROC * srvproc,
									  char   * inbuf,
									  int	     inbuflen );

int srv_IgnoreAnsiToOem( SRV_PROC * srvproc,BOOL bTF);

#ifdef __cplusplus
}
#endif

#pragma pack()

#define SS_MAJOR_VERSION    7
#define SS_MINOR_VERSION    00
#define SS_LEVEL_VERSION    0000
#define SS_MINIMUM_VERSION  "7.00.00.0000"
#define ODS_VERSION			((SS_MAJOR_VERSION << 24)  | (SS_MINOR_VERSION << 16))

#endif //_ODS_SRV_H_

//////////////////////////////////////////////////////////////////
// Suggested implementation of __GetXpVersion
//
//__declspec(dllexport) ULONG __GetXpVersion() 
//	{
//	return ODS_VERSION;
//	}
//////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\xp\uddi.xp.cpp ===
#include "uddi.xp.h"

BOOL APIENTRY DllMain( HANDLE hModule, 
                       DWORD  ul_reason_for_call, 
                       LPVOID lpReserved
					 )
{
    return TRUE;
}

void GetRegKeyStringValue( HKEY& hKey, const char* regKeyName, string& regKeyValue )
{
	long  nResult = ERROR_SUCCESS;
	DWORD dwType  = REG_SZ;
	DWORD dwCount  = 0;

	nResult = ::RegQueryValueExA( hKey,
								  regKeyName,
								  NULL,
								  &dwType,
								  NULL,
								  &dwCount );

	if( dwCount && ( nResult == ERROR_SUCCESS ) && ( dwType == REG_SZ || dwType == REG_EXPAND_SZ ) )
	{
		char* pszBuf = new char[ dwCount ];
		
		if( NULL != pszBuf )
		{
			__try
			{
				nResult = ::RegQueryValueExA( hKey,
											  regKeyName,
											  NULL,
											  &dwType,
											  ( LPBYTE )pszBuf,
											  &dwCount );
				regKeyValue = pszBuf;
			}
			__finally
			{
				delete [] pszBuf;
				pszBuf = NULL;
			}
		}
	}
}

string g_strUddiInstallDirectory = "";

string& GetUddiInstallDirectory()
{
	HKEY hKey = NULL;

	if( 0 == g_strUddiInstallDirectory.length() )
	{
		if( ::RegOpenKeyEx( HKEY_LOCAL_MACHINE,
				L"Software\\Microsoft\\UDDI",
				0,
				KEY_QUERY_VALUE,
				&hKey ) == ERROR_SUCCESS ) 
		{
			GetRegKeyStringValue( hKey, "InstallRoot",  g_strUddiInstallDirectory );
			if( g_strUddiInstallDirectory.length() != 0 )
			{
				g_strUddiInstallDirectory += "bin";
			}

			::RegCloseKey( hKey );
		}
	}

	return g_strUddiInstallDirectory;
}

void ReportError( SRV_PROC *srvproc, LPCSTR sz, DWORD dwResult )
{
	CHAR szErr[ MAXERROR ];

	_snprintf( szErr, MAXERROR, "%s failed with error code %d while executing the xsp\n", sz, dwResult );
	szErr[ MAXERROR - 1 ] = 0x00;
	
	srv_sendmsg( srvproc, SRV_MSG_ERROR, 0, XP_SRVMSG_SEV_ERROR, (DBTINYINT)0, NULL, 0, 0, szErr, SRV_NULLTERM ); 
}

ULONG __GetXpVersion()
{
   return ODS_VERSION;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\web\validators.cs ===
using System;
using System.Text.RegularExpressions;
using System.Web;
using System.Web.UI;
using System.Web.UI.WebControls;
namespace UDDI.Web
{
	/// <summary>
	/// Summary description for validators.
	/// </summary>
	public class EmailValidator : BaseValidator
	{
		public const string Expression = "(?<user>[^@]+)@{1}(?<host>.+)";
		
		
		
		private const string csName = "ValidateEmail"; 
		private Regex regexp;
		private Control control;
		

		private bool resolvehost;
		public bool ResolveHost
		{
			get{ return resolvehost; }
			set{ resolvehost=value; }
		}


		/// <summary>
		/// 
		/// </summary>
		public EmailValidator()
		{
			//
			// TODO: Add constructor logic here
			//
			regexp = new Regex( Expression );
						
		}

		/// <summary>
		/// 
		/// </summary>
		/// <param name="e"></param>
		protected override void OnInit( EventArgs e )
		{
		
			base.OnInit( e );
		}

		/// <summary>
		///		
		/// </summary>
		/// <param name="e">EventArguments</param>
		protected override void OnLoad( EventArgs e )
		{
			control = FindControl( this.ControlToValidate );
			if( null==control )
			{
				throw new Exception( "The Control Specified can not be found: '" + this.ControlToValidate + "'" );
			}
			
			base.OnLoad( e );
		}

		/// <summary>
		///		
		/// </summary>
		/// <returns>Boolean indicating that the email address is valid</returns>
		protected override bool EvaluateIsValid()
		{
			Match m = regexp.Match( ((TextBox)control).Text );
			try
			{
				if( m.Success )
				{
					if( ResolveHost )
					{
					
						System.Net.IPHostEntry host = System.Net.Dns.Resolve( m.Groups[ "host" ].Value );
					
						if( null!=host )
							return true;
					}
					else
					{	
						return true;
					}
				}
			}
			catch{}//swallow and return false.
		
			return false;
		}
		
		
		


	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\xp\xp_reset_key.cpp ===
#include "uddi.xp.h"

//
// Add your new Extended Stored Procedure from a Visual Studio Data Project, 
// or using the SQL Server Enterprise Manager, or by executing the following 
// SQL command:
//  sp_addextendedproc 'xp_reset_key', 'uddi.xp.dll'
//
// You may drop the extended stored procedure by using the SQL command:
//   sp_dropextendedproc 'xp_reset_key'
// 
// You may release the DLL from the Server (to delete or replace the file), by 
// using the SQL command:
//  DBCC xp_reset_key(FREE)
//
// sp_addextendedproc 'xp_reset_key', 'uddi.xp.dll'
// sp_dropextendedproc 'xp_reset_key'
// exec xp_reset_key
//
// DBCC xp_reset_key(FREE)
//

RETCODE xp_reset_key( SRV_PROC *srvproc )
{
    DBSMALLINT			i = 0;
	DBCHAR				spName[ MAXNAME ];
	DBCHAR				spText[ MAXTEXT ];
	CHAR				bReadBuffer[ 255 ];
	DWORD				cbReadBuffer = 0;
	DBINT               cnt        = 0;
	DBINT               rows       = 0; 
	BOOL                fSuccess   = FALSE;
	STARTUPINFOA        si;
	PROCESS_INFORMATION pi;  
	SECURITY_ATTRIBUTES saPipe;
	HANDLE              hReadPipe  = NULL; 
	HANDLE              hWritePipe = NULL;  
	DWORD               dwExitCode = 0;
	BOOL                fSendRowNotFailed = TRUE;

	//
	// Name of this procedure
	//
	_snprintf( spName, MAXNAME, "xp_reset_key" );
	spName[ MAXNAME - 1 ] = 0x00;

	//
	// Send a text message
	//
	_snprintf( spText, MAXTEXT, "UDDI Services Extended Stored Procedure: %s\n", spName );
	spText[ MAXTEXT - 1 ] = 0x00;

	srv_sendmsg(
		srvproc,
		SRV_MSG_INFO,
		0,
		(DBTINYINT)0,
		(DBTINYINT)0,
		NULL,
		0,
		0,
		spText,
		SRV_NULLTERM );

	string strResetKeyFile = GetUddiInstallDirectory();
	if( 0 == strResetKeyFile.length() )
	{
		ReportError( srvproc, "GetUddiInstallDirectory" );
		return FAIL;     
	}  

	strResetKeyFile += "\\resetkey.exe";

	_snprintf( spText, MAXTEXT, "Resetkey.exe Installed at location: %s\n", strResetKeyFile.c_str() );
	spText[ MAXTEXT - 1 ] = 0x00;

	srv_sendmsg(
		srvproc,
		SRV_MSG_INFO,
		0,
		(DBTINYINT)0,
		(DBTINYINT)0,
		NULL,
		0,
		0,
		spText,
		SRV_NULLTERM );

	//
	// Create child process to execute the command string.  Use an 
	// anonymous pipe to read the output from the command and send 
	// any results to the client.  
	// In order for the child process to be able to write 
	// to the anonymous pipe, the handle must be marked as 
	// inheritable by child processes by setting the 
	// SECURITY_ATTRIBUTES.bInheritHandle flag to TRUE.
	// 
	saPipe.nLength              = sizeof( SECURITY_ATTRIBUTES ); 
	saPipe.lpSecurityDescriptor = NULL;
	saPipe.bInheritHandle       = TRUE; 
	
	fSuccess = CreatePipe( 
		&hReadPipe,      // read handle 
		&hWritePipe,     // write handle 
		&saPipe,         // security descriptor 
		0 );             // use default pipe buffer size 
	
	if( !fSuccess )
	{
		ReportError( srvproc, "CreatePipe", GetLastError() ); 
		return FAIL;     
	}  
	
	//
	// Now we must set standard out and standard error to the 
	// write end of the pipe.  Once standard out and standard 
	// error are set to the pipe handle, we must close the pipe 
	// handle so that when the child process dies, the write end 
	// of the pipe will close, setting an EOF condition on the pipe.
	// 
	memset( &si, 0, sizeof(si) );
	si.cb          = sizeof(si); 
	si.dwFlags     = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES; 
	si.wShowWindow = SW_HIDE;
	si.hStdOutput  = hWritePipe; 
	si.hStdError   = hWritePipe;  

	//
	// Set the fInheritHandles parameter to TRUE so that open 
	// file handles will be inheritied. We can close the child 
	// process and thread handles as we won't be needing them. 
	// The child process will not die until these handles are
	// closed. 
	//
	char params[ 6 ];
	params[ 0 ] = 0x00;
	strncat( params, " /now", 6 );
	params[ 5 ] = 0x00;

	fSuccess = CreateProcessA(
		strResetKeyFile.c_str(),   // filename 
		params,		  // command line for child 
		NULL,         // process security descriptor 
		NULL,         // thread security descriptor 
		TRUE,         // inherit handles? 
		0,            // creation flags 
		NULL,         // inherited environment address 
		NULL,         // startup dir; NULL = start in current 
		&si,          // pointer to startup info (input) 
		&pi );        // pointer to process info (output) 
	
	if (!fSuccess)
	{
		ReportError( srvproc, "CreateProcess", GetLastError() );
		return FAIL;     
	}  
	
	//
	// We need to close our instance of the inherited pipe write 
	// handle now that it's been inherited so that it will actually 
	// close when the child process ends. This will put an EOF 
	// condition on the pipe which we can then detect.     
	// 
	fSuccess = CloseHandle( hWritePipe );
	
	if( !fSuccess )
	{ 
		ReportError( srvproc, "CloseHandle", GetLastError() );  

		CloseHandle( pi.hThread );
		CloseHandle( pi.hProcess );  
		return FAIL;
	}  

	string strOutput = "";

	//
	// Now read from the pipe until EOF condition reached.     
	//
	do
	{ 
		cnt = 0;  
		while(	( cnt < ( sizeof( bReadBuffer ) / sizeof( bReadBuffer[0] ) ) ) &&
				( 0 != (fSuccess = ReadFile( 
								hReadPipe,          // read handle 
								&bReadBuffer[cnt],  // buffer for incoming data 
								1,                  // number of bytes to read 
								&cbReadBuffer,      // number of bytes actually read 
								NULL ) ) ) )
		{ 
			if( !fSuccess )
			{ 
				if( ERROR_BROKEN_PIPE  == GetLastError() )  
				{
					break;
				}

				//
				// Child has died
				//
				ReportError( srvproc, "CloseHandle", GetLastError() );  
				CloseHandle( pi.hThread );
				CloseHandle( pi.hProcess );  

				return FAIL; 
			}          

			if( '\n'  == bReadBuffer[ cnt ] ) 
			{
				break;
			}
			else          
			{
				cnt++;
			}
		}  

		if( fSuccess && cbReadBuffer )
		{             
			if( !cnt )
			{                 
				bReadBuffer[ 0 ] = ' '; 
				cnt = 1; 
			}  

			//
			// Remove carriage return if it exists             
			// 
//			if( 0x0D == bReadBuffer[ cnt-1 ] )                
//			{
//				cnt--;  
//			}
			
			if( cnt >= 0 )
			{
				bReadBuffer[ cnt ] = 0x00;

				//
				// Send program output back as information
				//
				strOutput.append( bReadBuffer, cnt );

				srv_sendmsg(
						srvproc,
						SRV_MSG_INFO,
						0,
						(DBTINYINT)0,
						(DBTINYINT)0,
						NULL,
						0,
						0,
						bReadBuffer,
						cnt );
			}
		}
	} 
	while( fSuccess && cbReadBuffer );  

	OutputDebugStringA( strOutput.c_str() );
	
	//
	// Close the trace file, pipe handles
	// 
	CloseHandle( hReadPipe );  
	
	if( !GetExitCodeProcess( pi.hProcess, &dwExitCode ) || dwExitCode != 0 )
	{
		ReportError( srvproc, "GetExitCodeProcess", dwExitCode );
		return FAIL;
	}
	
	CloseHandle( pi.hThread );
	CloseHandle( pi.hProcess );  

	return XP_NOERROR ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\xp\xp_recalculate_statistics.cpp ===
#include "uddi.xp.h"

//
// Add your new Extended Stored Procedure from a Visual Studio Data Project, 
// or using the SQL Server Enterprise Manager, or by executing the following 
// SQL command:
//  sp_addextendedproc 'xp_recalculate_statistics', 'uddi.xp.dll'
//
// You may drop the extended stored procedure by using the SQL command:
//   sp_dropextendedproc 'xp_recalculate_statistics'
// 
// You may release the DLL from the Server (to delete or replace the file), by 
// using the SQL command:
//  DBCC xp_recalculate_statistics(FREE)
//
// sp_addextendedproc 'xp_recalculate_statistics', 'uddi.xp.dll'
// sp_dropextendedproc 'xp_recalculate_statistics'
// exec xp_recalculate_statistics
//
// DBCC xp_recalculate_statistics(FREE)
//

RETCODE xp_recalculate_statistics( SRV_PROC *srvproc )
{
    DBSMALLINT			i = 0;
	DBCHAR				spName[MAXNAME];
	DBCHAR				spText[MAXTEXT];
	DWORD				cbReadBuffer = 0;
	DBINT               cnt        = 0;
	BOOL                fSuccess   = FALSE;
	STARTUPINFOA        si;
	PROCESS_INFORMATION pi;  

#if defined( _DEBUG ) || defined( DBG )
	CHAR				bReadBuffer[255];
	SECURITY_ATTRIBUTES saPipe;
	HANDLE              hReadPipe  = NULL; 
	HANDLE              hWritePipe = NULL;  
	DWORD               dwExitCode = 0;
	BOOL                fSendRowNotFailed = TRUE;
#endif

	//
	// Name of this procedure
	//
	_snprintf( spName, MAXNAME, "xp_recalculate_statistics" );
	spName[ MAXNAME - 1 ] = 0x00;

	//
	// Send a text message
	//
	_snprintf( spText, MAXTEXT, "UDDI Services Extended Stored Procedure: %s\n", spName );
	spText[ MAXTEXT - 1 ] = 0x00;

	srv_sendmsg(
		srvproc,
		SRV_MSG_INFO,
		0,
		(DBTINYINT)0,
		(DBTINYINT)0,
		NULL,
		0,
		0,
		spText,
		SRV_NULLTERM );

	string strRecalcStatsFile = GetUddiInstallDirectory();
	if( 0 == strRecalcStatsFile.length() )
	{
		ReportError( srvproc, "GetUddiInstallDirectory" );
		return FAIL;     
	}  

	strRecalcStatsFile += "\\recalcstats.exe";

	_snprintf( spText, MAXTEXT, "Recalcstats.exe Installed at location: %s\n", strRecalcStatsFile.c_str() );
	spText[ MAXTEXT - 1 ] = 0x00;

	srv_sendmsg(
		srvproc,
		SRV_MSG_INFO,
		0,
		(DBTINYINT)0,
		(DBTINYINT)0,
		NULL,
		0,
		0,
		spText,
		SRV_NULLTERM );

#if defined( _DEBUG ) || defined( DBG )
	//
	// Create child process to execute the command string.  Use an 
	// anonymous pipe to read the output from the command and send 
	// any results to the client.  
	// In order for the child process to be able to write 
	// to the anonymous pipe, the handle must be marked as 
	// inheritable by child processes by setting the 
	// SECURITY_ATTRIBUTES.bInheritHandle flag to TRUE.
	// 
	saPipe.nLength              = sizeof( SECURITY_ATTRIBUTES ); 
	saPipe.lpSecurityDescriptor = NULL;
	saPipe.bInheritHandle       = TRUE; 
	
	fSuccess = CreatePipe( 
		&hReadPipe,      // read handle 
		&hWritePipe,     // write handle 
		&saPipe,         // security descriptor 
		0 );             // use default pipe buffer size 
	
	if( !fSuccess )
	{
		ReportError( srvproc, "CreatePipe", GetLastError() ); 
		return FAIL;     
	}  
#endif //DBG || _DEBUG

	//
	// Now we must set standard out and standard error to the 
	// write end of the pipe.  Once standard out and standard 
	// error are set to the pipe handle, we must close the pipe 
	// handle so that when the child process dies, the write end 
	// of the pipe will close, setting an EOF condition on the pipe.
	// 
	memset( &si, 0, sizeof(si) );
	si.cb          = sizeof(si); 
	si.dwFlags     = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES; 
	si.wShowWindow = SW_HIDE;

#if defined( _DEBUG ) || defined( DBG )

	si.hStdOutput  = hWritePipe; 
	si.hStdError   = hWritePipe; 
#endif // DBG || _DEBUG

	//
	// Set the fInheritHandles parameter to TRUE so that open 
	// file handles will be inheritied. We can close the child 
	// process and thread handles as we won't be needing them. 
	// The child process will not die until these handles are
	// closed. 
	//
	fSuccess = CreateProcessA(
		strRecalcStatsFile.c_str(),   // filename 
		NULL,		  // command line for child 
		NULL,         // process security descriptor 
		NULL,         // thread security descriptor 
		TRUE,         // inherit handles? 
		0,            // creation flags 
		NULL,         // inherited environment address 
		NULL,         // startup dir; NULL = start in current 
		&si,          // pointer to startup info (input) 
		&pi );        // pointer to process info (output) 
	
	if( !fSuccess )
	{
		ReportError( srvproc, "CreateProcess", GetLastError() );
		return FAIL;     
	}  

#if defined( _DEBUG ) || defined( DBG )


	//
	// We need to close our instance of the inherited pipe write 
	// handle now that it's been inherited so that it will actually 
	// close when the child process ends. This will put an EOF 
	// condition on the pipe which we can then detect.     
	// 
	fSuccess = CloseHandle( hWritePipe );
	
	if( !fSuccess )
	{ 
		ReportError( srvproc, "CloseHandle", GetLastError() );  

		CloseHandle( pi.hThread );
		CloseHandle( pi.hProcess );  
		return FAIL;
	}  

	//
	// Now read from the pipe until EOF condition reached.     
	//
	do
	{ 
		cnt = 0;  
		while(	( cnt < ( sizeof( bReadBuffer ) / sizeof( bReadBuffer[0] ) ) ) &&
				( 0 != (fSuccess = ReadFile( 
								hReadPipe,          // read handle 
								&bReadBuffer[cnt],  // buffer for incoming data 
								1,                  // number of bytes to read 
								&cbReadBuffer,      // number of bytes actually read 
								NULL ) ) ) )
		{ 
			if( !fSuccess )
			{ 
				if( ERROR_BROKEN_PIPE  == GetLastError() )  
				{
					break;
				}

				//
				// Child has died
				//
				ReportError( srvproc, "CloseHandle", GetLastError() );  
				CloseHandle( pi.hThread );
				CloseHandle( pi.hProcess );  

				return FAIL; 
			}          

			if( '\n'  == bReadBuffer[ cnt ] ) 
			{
				break;
			}
			else          
			{
				cnt++;
			}
		}  

		if( fSuccess && cbReadBuffer )
		{             
			if( !cnt )
			{                 
				bReadBuffer[ 0 ] = ' '; 
				cnt = 1; 
			}  

			//
			// Remove carriage return if it exists             
			// 
			if( 0x0D == bReadBuffer[ cnt-1 ] )                
			{
				cnt--;  
			}
			
			if( cnt >= 0 )
			{
				bReadBuffer[ cnt ] = 0;

				//
				// Send program output back as information
				//
				srv_sendmsg(
						srvproc,
						SRV_MSG_INFO,
						0,
						(DBTINYINT)0,
						(DBTINYINT)0,
						NULL,
						0,
						0,
						bReadBuffer,
						cnt );
			}
		}
	} 
	while( fSuccess && cbReadBuffer );  
	
	//
	// Close the trace file, pipe handles
	// 
	CloseHandle( hReadPipe );  
	
	if( !GetExitCodeProcess( pi.hProcess, &dwExitCode ) || dwExitCode != 0 )
	{
		ReportError( srvproc, "GetExitCodeProcess", dwExitCode );
		return FAIL;
	}
#endif // DBG || _DEBUG
	
	CloseHandle( pi.hThread );
	CloseHandle( pi.hProcess );  

	return XP_NOERROR ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\web\tree.cs ===
using System;
using System.Collections;
using System.Web;
using System.Web.UI;
using System.Web.UI.WebControls;
using UDDI.Diagnostics;

namespace UDDI.Web
{
	public class TreeView : UserControl
	{
		protected string binhex = @"!""#$%&'()*+,-012345689@ABCDEFGHIJKLMNPQRSTUVXYZ[`abcdefhijklmpqr";
		protected string clientScript = @"
			<script language='javascript'>
			<!-- 
				var binhex = ""{binhex}"";
		
				function ToggleBranch( id, block, expanderImage, nodeImage, plus, minus, imageUrl, openImageUrl ) 
				{ 
					if( null == block.style ) 
						return; 
					
					if( ""none"" == block.style.display ) 
					{ 
						block.style.display = """"; 
						expanderImage.src = minus;
						nodeImage.src = openImageUrl;
					}  
					else 
					{ 
						block.style.display = ""none""; 
						expanderImage.src = plus;
						nodeImage.src = imageUrl;
					} 

					var node = document.getElementById( ""{id}:state"" );
					var state = node.value;
								
					var index = Math.floor( id / 6 );
					var bit = 1 << ( id % 6 );
								
					while( index >= state.length )
						state += binhex.charAt( 0 );
									
					var digit = binhex.indexOf( state.charAt( index ) ) ^ bit;
					
					node.value = 
						state.substring( 0, index ) + 
						binhex.charAt( digit ) + 
						state.substring( index + 1 );
				} 
				//--> 
				</script>";

		protected string root;
		protected TreeNodeCollection nodes;
		protected TreeNode selectedNode = null;
		protected int count;
		protected string selectedID = null;

		protected override void OnInit( EventArgs e )
		{
			root = ( "/" == Request.ApplicationPath ) ? "" : Request.ApplicationPath;			
			nodes = new TreeNodeCollection( this );

			if( !Page.IsClientScriptBlockRegistered( "UDDI.Web.TreeView" ) )
			{
				clientScript = clientScript.Replace( "{root}", root );
				clientScript = clientScript.Replace( "{id}", this.UniqueID );
				clientScript = clientScript.Replace( "{binhex}", binhex.Replace( "\"", "\\\"" ) );
				
				Page.RegisterClientScriptBlock(
					"UDDI.Web.TreeView",
					clientScript );
			}
		}
	
		public TreeNodeCollection Nodes
		{
			get { return nodes; }
		}
	
		public TreeNode SelectedNode
		{
			get { return selectedNode; }
			set { selectedNode = value; }
		}

		protected void LoadTreeStateForNode( TreeNode node, string viewState )
		{
			int index = count / 6;
			int bit = 1 << ( count % 6 );
			
			bool expanded = false;
			
			if( index < viewState.Length )
				expanded = ( binhex.IndexOf( viewState[ index ] ) & bit ) > 0;

			if( expanded )
				node.Expand();

			count ++;

			foreach( TreeNode child in node.Nodes )
				LoadTreeStateForNode( child, viewState );
		}

		protected void SaveTreeStateForNode( TreeNode node, ref string viewState )
		{
			if( node.IsExpanded )
			{
				int index = count / 6;
				int bit = 1 << ( count % 6 );
			
				while( index >= viewState.Length )
					viewState += binhex[ 0 ];

				viewState =
					viewState.Substring( 0, index ) +
					binhex[ binhex.IndexOf( viewState[ index ] ) | bit ] +
					viewState.Substring( index + 1 );
			}

			count ++;

			foreach( TreeNode child in node.Nodes )
				SaveTreeStateForNode( child, ref viewState );
		}

		protected override void Render( HtmlTextWriter output )
		{	
			string treeState = Request[ this.UniqueID + ":state" ];

			if( null != treeState )
			{
				count = 0;
				foreach( TreeNode child in nodes )
					LoadTreeStateForNode( child, treeState );
			}
			
			if( null != selectedNode )
				selectedNode.EnsureVisible();

			treeState = "";
			
			count = 0;
			foreach( TreeNode child in nodes )
				SaveTreeStateForNode( child, ref treeState );

			count = 0;
			foreach( TreeNode node in Nodes )
				RenderNode( output, node );
			
			output.WriteLine( "<script language='javascript'>" );
			
			if( null != selectedID )
				output.WriteLine( "		var selectedNode = document.getElementById( \"" + selectedID + "\" );" );
			else
				output.WriteLine( "		var selectedNode = null;" );
			
			output.WriteLine( "</script>" );					

			output.WriteLine( "<input type='hidden' name='" + this.UniqueID + ":state' value='" + treeState + "'>" );
		}

		protected void RenderNode( HtmlTextWriter output, TreeNode node )
		{
			string root = ( "/" == Request.ApplicationPath ) ? "" : Request.ApplicationPath;		
			string text = HttpUtility.HtmlEncode( node.Text );
			string image;

			string id = this.UniqueID + ":" + count;
			
			string oncontextmenu = null;
			string onclick = null;

			if( null != node.OnContextMenu )
				oncontextmenu = " oncontextmenu='" + node.OnContextMenu.Replace( "'", "\"" ).Replace( "[[node]]", "document.getElementById( \"" + id + "\" )" ) + "'";

			if( null != node.OnClick )
				onclick = " onclick='" + node.OnClick.Replace( "'", "\"" ).Replace( "[[node]]", "document.getElementById( \"" + id + "\" )" ) + "'";
			
			if( node.IsSelected )
				output.Write( "<a name='#top'>" );

			output.Write( "<nobr>" );

			//
			// Generate ancestor lines.
			//
			string lines = "";
						
			TreeNode ancestor = node.Parent;
			while( null != ancestor )
			{
				image = "line-ns.gif";

				if( null == ancestor.Parent || ancestor.Index >= ancestor.Parent.Nodes.Count - 1 )
					image = "blank.gif";

				lines = "<img src='" + root + "/images/" + image + "' border='0' width='16' height='18' align='absmiddle'>" + lines;

				ancestor = ancestor.Parent;
			}
			
			output.Write( lines );
						
			//
			// Generate expand/collapse image.
			//			
			bool north = false;
			bool south = false;

			if( null == node.Parent )
			{
				if( node.Index > 0 )
					north = true;
				
				if( node.Index < node.TreeView.Nodes.Count - 1 )
					south = true;
			}
			else
			{
				north = true;
				
				if( node.Index < node.Parent.Nodes.Count - 1 )
					south = true;
			}

			//
			// Determine which expander image we should use.
			//
			string dir = ( north ? "n" : "" ) + "e" + ( south ? "s" : "" );
			
			if( node.Nodes.Count > 0 )
			{				
				if( node.IsExpanded )
					image = "minus-";
				else
					image = "plus-";

				output.Write( "<img id='_expander" + count + "' src='" + root + "/images/" + image + dir + ".gif' border='0' width='16' height='18' align='absmiddle' onclick='" );
				output.Write( "ToggleBranch( " + count + ", _branch" + count + ", _expander" + count + ", _nodeImage" + count + ", \"../images/plus-" + dir + ".gif\", \"../images/minus-" + dir + ".gif\", \"" + node.ImageUrl + "\", \"" + ( null == node.OpenImageUrl ? node.ImageUrl : node.OpenImageUrl ) + "\")'>" );
			}
			else
				output.Write( "<img src='" + root + "/images/line-" + dir + ".gif' border='0' width='16' height='18' align='absmiddle'>" );

			//
			// Display the node image (or a blank image if none was specified).
			//
			if( null != node.ImageUrl )
			{
				output.Write( "<img id='_nodeImage" + count + "' src='" );
				
				if( node.IsExpanded && null != node.OpenImageUrl )
					output.Write( node.OpenImageUrl );
				else
					output.Write( node.ImageUrl );

				output.Write( "' border='0' width='16' height='16' align='absmiddle'" );
                output.Write( " title='" + node.Tooltip.Replace( "'", "\'" ) + "'" );
				output.Write( oncontextmenu );
				output.Write( onclick );
				output.Write( ">" );

			}
			else
				output.Write( "<img id='_nodeImage" + count + "' src='" + root + "/images/blank.gif' border='0' width='16' height='16' align='absmiddle'>" );

			//
			// Display the node text.
			//			
			output.Write( "<img src='" + root + "/images/spacer.gif' border='0' width='4' height='16' align='absmiddle'>" );			
			output.Write( "<span id='" + id + "' key='" + node.Key + "'" );
			
			if( node.IsSelected )
			{
				output.Write( " class='selected' " );
				selectedID = id;
			}
			else
				output.Write( " class='node'" );
			
            output.Write( " title='" + node.Tooltip.Replace( "'", "\'" ) + "'" );
            output.Write( oncontextmenu );
			output.Write( onclick );
			output.Write( ">" );			
			output.Write( text + "</span></nobr><br><div id='_branch" + count + "' style='display: " + ( node.IsExpanded ? "\"\"" : "\"none\"" ) + "'>\n" );
		
			count ++;

			//
			// Render this node's children.
			//
			foreach( TreeNode child in node.Nodes )
				RenderNode( output, child );

			output.WriteLine( "</div>" );
		}
		
	}

	/// ********************************************************************
	///   public class TreeNode
	/// --------------------------------------------------------------------
	///   <summary>
	///   </summary>
	/// ********************************************************************
	/// 
	public class TreeNode
	{
		internal protected TreeNode parent;
		internal protected TreeView treeView;	
		internal protected TreeNodeCollection nodes;		
		
		protected bool expanded = false;
	
		public string Text;
		public string Key;
		public string ImageUrl;
		public string OpenImageUrl;
		public string OnClick;
		public string OnContextMenu;
        public string Tooltip;

		public TreeNode()
			: this( null, null, null, null )
		{
		}	

		public TreeNode( string text )
			: this( text, null, null, null )
		{
		}

		public TreeNode( string text, string key )
			: this( text, key, null, null )
		{
		}

		public TreeNode( string text, string key, string imageUrl )
			: this( text, key, null, null )
		{
		}

		public TreeNode( string text, string key, string imageUrl, string openImageUrl )
		{
			this.Text = text;
			this.Key = key;
			this.ImageUrl = imageUrl;
			this.OpenImageUrl = openImageUrl;
		
			this.nodes = new TreeNodeCollection( this );
		}
	
		public string FullPath
		{
			get
			{
				string path = this.Text;
			
				TreeNode node = this;
				while( null != node.Parent )
				{
					node = node.Parent;
					path = path + "\\" + node.Text;
				}
			
				return path;		
			}
		}
	
		public int Index
		{
			get 
			{ 
				if( null == parent )
					return treeView.Nodes.IndexOf( this );

				return parent.Nodes.IndexOf( this );
			}
		}
	
		public bool IsExpanded
		{
			get { return expanded; }
		}
	
		public bool IsSelected
		{
			get 
			{ 
				if( null == treeView )
					return false;

				return treeView.SelectedNode == this; 
			}
		}

		public TreeNodeCollection Nodes
		{
			get { return nodes; }
		}
	
		public TreeNode Parent
		{
			get { return parent; }
		}
	
		public UDDI.Web.TreeView TreeView
		{
			get { return treeView; }
		}
	
		public void Collapse()
		{
			expanded = false;
		}

		public void EnsureVisible()
		{
			TreeNode node = this;
		
			while( null != node.Parent )
			{
				node = node.Parent;
				node.Expand();
			}
		}

		public void Expand()
		{
			expanded = true;
		}
	
		public void Remove()
		{
			if( null != parent )
				parent.Nodes.RemoveAt( Index );
		}

		public void Select()
		{
			treeView.SelectedNode = this;
		}
		
		public void Toggle()
		{
			expanded = !expanded;
		}
	}

	/// ********************************************************************
	///   public class TreeNodeCollection
	/// --------------------------------------------------------------------
	///   <summary>
	///   </summary>
	/// ********************************************************************
	/// 
	public class TreeNodeCollection : CollectionBase
	{
		protected TreeNode parent;
		protected TreeView treeView;

		internal protected TreeNodeCollection( TreeNode parent )
		{
			this.parent = parent;
			this.treeView = parent.TreeView;
		}

		internal protected TreeNodeCollection( TreeView treeView )
		{
			this.parent = null;
			this.treeView = treeView;
		}

		public TreeNode this[ int index ]
		{
			get { return (TreeNode)List[ index ]; }
			set { List[ index ] = value; }
		}

		public TreeNode Add( string text )
		{
			return Add( text, null, null, null );
		}

		public TreeNode Add( string text, string key )
		{
			return Add( text, key, null, null );
		}

		public TreeNode Add( string text, string key, string imageUrl )
		{
			return Add( text, key, imageUrl, null );
		}

		public TreeNode Add( string text, string key, string imageUrl, string openImageUrl )
		{
			TreeNode node = new TreeNode( text, key, imageUrl, openImageUrl );
		
			node.parent = this.parent;
			node.treeView = this.treeView;
			node.Nodes.treeView = this.treeView;
		
			List.Add( node );
				
			return node;
		}

		public int Add( TreeNode node )
		{
			node.parent = this.parent;
			node.treeView = this.treeView;
			node.Nodes.treeView = this.treeView;
		
			return List.Add( node );
		}

		public int IndexOf( TreeNode node )
		{
			return List.IndexOf( node );
		}

		public void Remove( TreeNode node )
		{
			List.Remove( node );
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\actxprxy\dex_as.c ===
#include "rpcproxy.h"
#include "dispex.h"


/* [local] */ HRESULT STDMETHODCALLTYPE IDispatchEx_InvokeEx_Proxy(
    IDispatchEx __RPC_FAR * This,
    /* [in] */ DISPID id,
    /* [in] */ LCID lcid,
    /* [in] */ WORD wFlags,
    /* [in] */ DISPPARAMS __RPC_FAR *pdp,
    /* [unique][out][in] */ VARIANT __RPC_FAR *pvarRes,
    /* [unique][out][in] */ EXCEPINFO __RPC_FAR *pei,
    /* [unique][in] */ IServiceProvider __RPC_FAR *pspCaller)
{
	// CLIENT side code.

	// Clear *pvarRes.
	if (NULL != pvarRes)
		memset(pvarRes, 0, sizeof(*pvarRes));
	// Clear *pei.
	if (NULL != pei)
		memset(pei, 0, sizeof(*pei));

	return IDispatchEx_RemoteInvokeEx_Proxy(This, id, lcid, wFlags, pdp,
		pvarRes, pei, pspCaller);
}


/* [call_as] */ HRESULT STDMETHODCALLTYPE IDispatchEx_InvokeEx_Stub(
    IDispatchEx __RPC_FAR * This,
    /* [in] */ DISPID id,
    /* [in] */ LCID lcid,
    /* [in] */ WORD wFlags,
    /* [in] */ DISPPARAMS __RPC_FAR *pdp,
    /* [unique][out][in] */ VARIANT __RPC_FAR *pvarRes,
    /* [unique][out][in] */ EXCEPINFO __RPC_FAR *pei,
    /* [unique][in] */ IServiceProvider __RPC_FAR *pspCaller)
{
	// SERVER side code.

	// Clear *pvarRes.
	if (NULL != pvarRes)
		memset(pvarRes, 0, sizeof(*pvarRes));
	// Clear *pei.
	if (NULL != pei)
		memset(pei, 0, sizeof(*pei));

	return This->lpVtbl->InvokeEx(This, id, lcid, wFlags, pdp,
		pvarRes, pei, pspCaller);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\actxprxy\makefile.inc ===
clean:
    -del *_p.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\actxprxy\dlldatax.c ===
/*********************************************************
   DllData file -- THIS IS NOT GENERATED BY MIDL, BUT BY HAND

   Instructions: every idl file that wants to be in actxprxy.dll
   must be included under (follow example of htiface.idl)
EXTERN_PROXY_FILE
REFERENCE_PROXY_FILE

*********************************************************/

#define PROXY_DELEGATION

#include <rpcproxy.h>

#ifdef __cplusplus
extern "C"   {
#endif

EXTERN_PROXY_FILE( activscp )
EXTERN_PROXY_FILE( comcat )
EXTERN_PROXY_FILE( docobj )
EXTERN_PROXY_FILE( hlink )
EXTERN_PROXY_FILE( htiface )
EXTERN_PROXY_FILE( htiframe )
EXTERN_PROXY_FILE( htprivwn )
EXTERN_PROXY_FILE( mimeinfo )
EXTERN_PROXY_FILE( mshtml )
EXTERN_PROXY_FILE( objsafe )
EXTERN_PROXY_FILE( servprov )
EXTERN_PROXY_FILE( shldisp )
EXTERN_PROXY_FILE( urlhist )
EXTERN_PROXY_FILE( ocmm )
EXTERN_PROXY_FILE( callback )
EXTERN_PROXY_FILE( webcheck )
EXTERN_PROXY_FILE( shobjidl )
EXTERN_PROXY_FILE( shpriv )
EXTERN_PROXY_FILE( subsmgr )
EXTERN_PROXY_FILE( imapi )


PROXYFILE_LIST_START
/* Start of list */
  REFERENCE_PROXY_FILE( activscp ),
  REFERENCE_PROXY_FILE( comcat ),
  REFERENCE_PROXY_FILE( docobj ),
  REFERENCE_PROXY_FILE( hlink ),
  REFERENCE_PROXY_FILE( htiface ),
  REFERENCE_PROXY_FILE( htiframe ),
  REFERENCE_PROXY_FILE( htprivwn ),
  REFERENCE_PROXY_FILE( mimeinfo ),
  REFERENCE_PROXY_FILE( mshtml ),
  REFERENCE_PROXY_FILE( objsafe ),
  REFERENCE_PROXY_FILE( servprov ),
  REFERENCE_PROXY_FILE( shldisp ),
  REFERENCE_PROXY_FILE( urlhist ),
  REFERENCE_PROXY_FILE( ocmm ),
  REFERENCE_PROXY_FILE( callback ),
  REFERENCE_PROXY_FILE( webcheck ),
  REFERENCE_PROXY_FILE( shobjidl ),
  REFERENCE_PROXY_FILE( shpriv ),
  REFERENCE_PROXY_FILE( subsmgr ),
  REFERENCE_PROXY_FILE( imapi ),
/* End of list */
PROXYFILE_LIST_END


DLLDATA_ROUTINES( aProxyFileList, GET_DLL_CLSID )

#ifdef __cplusplus
}  /*extern "C" */
#endif

/* end of generated dlldata file */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\actxprxy\call_as.c ===
#include "rpcproxy.h"
#include "docobj.h"
#include "servprov.h"
#include "dispex.h"
#include "comcat.h"
#include "activscp.h"


/* [local] */ HRESULT __stdcall IEnumOleDocumentViews_Next_Proxy(
    IEnumOleDocumentViews __RPC_FAR * This,
    /* [in] */ ULONG cViews,
    /* [out] */ IOleDocumentView __RPC_FAR *__RPC_FAR *rgpViews,
    /* [out] */ ULONG __RPC_FAR *pcFetched)
{
    HRESULT hr;
    ULONG cFetched = 0;

    hr = IEnumOleDocumentViews_RemoteNext_Proxy(This, cViews, rgpViews, &cFetched);

    if(pcFetched != 0)
        *pcFetched = cFetched;

    return hr;
}



/* [call_as] */ HRESULT __stdcall IEnumOleDocumentViews_Next_Stub(
    IEnumOleDocumentViews __RPC_FAR * This,
    /* [in] */ ULONG cViews,
    /* [length_is][size_is][out] */ IOleDocumentView __RPC_FAR *__RPC_FAR *rgpView,
    /* [out] */ ULONG __RPC_FAR *pcFetched)

{
    HRESULT hr;

    *pcFetched = 0;
    hr = This->lpVtbl->Next(This, cViews, rgpView, pcFetched);

    return hr;
}




/* [local] */ HRESULT __stdcall IPrint_Print_Proxy(
    IPrint __RPC_FAR * This,
    /* [in] */ DWORD grfFlags,
    /* [out][in] */ DVTARGETDEVICE __RPC_FAR *__RPC_FAR *pptd,
    /* [out][in] */ PAGESET __RPC_FAR *__RPC_FAR *ppPageSet,
    /* [unique][out][in] */ STGMEDIUM __RPC_FAR *pstgmOptions,
    /* [in] */ IContinueCallback __RPC_FAR *pcallback,
    /* [in] */ LONG nFirstPage,
    /* [out] */ LONG __RPC_FAR *pcPagesPrinted,
    /* [out] */ LONG __RPC_FAR *pnLastPage)
{
        return IPrint_RemotePrint_Proxy(This, grfFlags, pptd, ppPageSet,
                                        (RemSTGMEDIUM __RPC_FAR *) pstgmOptions, pcallback,
                                        nFirstPage, pcPagesPrinted, pnLastPage);
}


/* [call_as] */ HRESULT __stdcall IPrint_Print_Stub(
    IPrint __RPC_FAR * This,
    /* [in] */ DWORD grfFlags,
    /* [out][in] */ DVTARGETDEVICE __RPC_FAR *__RPC_FAR *pptd,
    /* [out][in] */ PAGESET __RPC_FAR *__RPC_FAR *ppPageSet,
    /* [unique][out][in] */ RemSTGMEDIUM __RPC_FAR *pstgmOptions,
    /* [in] */ IContinueCallback __RPC_FAR *pcallback,
    /* [in] */ LONG nFirstPage,
    /* [out] */ LONG __RPC_FAR *pcPagesPrinted,
    /* [out] */ LONG __RPC_FAR *pnLastPage)
{
    return This->lpVtbl->Print(This, grfFlags, pptd, ppPageSet,
                                        (STGMEDIUM __RPC_FAR *) pstgmOptions, pcallback,
                                        nFirstPage, pcPagesPrinted, pnLastPage);
}

/* [local] */ HRESULT __stdcall IServiceProvider_QueryService_Proxy(
    IServiceProvider __RPC_FAR * This,
    /* [in] */ REFGUID guidService,
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject)
{
    *ppvObject = NULL;
    return IServiceProvider_RemoteQueryService_Proxy(This, guidService, riid,
                                        (IUnknown**)ppvObject);
}

/* [call_as] */ HRESULT __stdcall IServiceProvider_QueryService_Stub(
    IServiceProvider __RPC_FAR * This,
    /* [in] */ REFGUID guidService,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppvObject)
{
    *ppvObject = NULL;
    return This->lpVtbl->QueryService(This, guidService, riid, ppvObject);
}


/* [local] */ HRESULT STDMETHODCALLTYPE ICatInformation_EnumClassesOfCategories_Proxy( 
    ICatInformation __RPC_FAR * This,
    /* [in] */ ULONG cImplemented,
    /* [size_is][in] */ CATID __RPC_FAR rgcatidImpl[  ],
    /* [in] */ ULONG cRequired,
    /* [size_is][in] */ CATID __RPC_FAR rgcatidReq[  ],
    /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenumClsid)
{
    BOOL fcImpl,fcReq;
    if (cImplemented == (ULONG)-1)
    {
        rgcatidImpl = NULL;
    }

    if (cRequired == (ULONG)-1)
    {
       rgcatidReq = NULL;
    }

    return ICatInformation_RemoteEnumClassesOfCategories_Proxy(This,cImplemented,rgcatidImpl,
        cRequired,rgcatidReq,ppenumClsid);

}


/* [call_as] */ HRESULT STDMETHODCALLTYPE ICatInformation_EnumClassesOfCategories_Stub( 
    ICatInformation __RPC_FAR * This,
    /* [in] */ ULONG cImplemented,
    /* [size_is][in] */ CATID __RPC_FAR rgcatidImpl[  ],
    /* [in] */ ULONG cRequired,
    /* [size_is][in] */ CATID __RPC_FAR rgcatidReq[  ],
    /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenumClsid)
{
    return This->lpVtbl->EnumClassesOfCategories(This,cImplemented,rgcatidImpl,
        cRequired,rgcatidReq,ppenumClsid);
}


/* [local] */ HRESULT STDMETHODCALLTYPE ICatInformation_IsClassOfCategories_Proxy( 
    ICatInformation __RPC_FAR * This,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ ULONG cImplemented,
    /* [size_is][in] */ CATID __RPC_FAR rgcatidImpl[  ],
    /* [in] */ ULONG cRequired,
    /* [size_is][in] */ CATID __RPC_FAR rgcatidReq[  ])
{
    BOOL fcImpl,fcReq;
    if (cImplemented == (ULONG)-1)
    {
        rgcatidImpl = NULL;
    }
    else
        fcImpl = FALSE;

    if (cRequired == (ULONG)-1 )
    {
       rgcatidReq = NULL;
    }
    else
       fcReq = FALSE;

    return ICatInformation_RemoteIsClassOfCategories_Proxy(This,rclsid,cImplemented,rgcatidImpl,
        cRequired,rgcatidReq);
}


/* [call_as] */ HRESULT STDMETHODCALLTYPE ICatInformation_IsClassOfCategories_Stub( 
    ICatInformation __RPC_FAR * This,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ ULONG cImplemented,
    /* [size_is][in] */ CATID __RPC_FAR rgcatidImpl[  ],
    /* [in] */ ULONG cRequired,
    /* [size_is][in] */ CATID __RPC_FAR rgcatidReq[  ])
{
    return This->lpVtbl->IsClassOfCategories(This,rclsid,cImplemented,rgcatidImpl,
        cRequired,rgcatidReq);

}

// IActiveScriptError

/* [local] */ HRESULT __stdcall IActiveScriptError_GetExceptionInfo_Proxy(
    IActiveScriptError __RPC_FAR * This,
	/* [out] */ EXCEPINFO  *pexcepinfo)
{
    return IActiveScriptError_RemoteGetExceptionInfo_Proxy(This, pexcepinfo);
}

/* [call_as] */ HRESULT __stdcall IActiveScriptError_GetExceptionInfo_Stub(
	IActiveScriptError __RPC_FAR * This,
	/* [out] */ EXCEPINFO  *pexcepinfo)
{
	HRESULT hr;

	hr = This->lpVtbl->GetExceptionInfo(This, pexcepinfo);
	if (SUCCEEDED (hr) && pexcepinfo->pfnDeferredFillIn != NULL)
	{
		if (FAILED(pexcepinfo->pfnDeferredFillIn(pexcepinfo)))
			hr = ResultFromScode(pexcepinfo->scode);
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\actxprxy\mshtmlp.c ===
#define HDC_UserSize HWND_UserSize
#define HDC_UserMarshal HWND_UserMarshal
#define HDC_UserUnmarshal HWND_UserUnmarshal
#define HDC_UserFree HWND_UserFree
 
#pragma warning(disable:4028)
#include "mshtml_p.c"
#pragma warning(default:4028)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\advapi32\advapi.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    advapi.h

Abstract:

    This module contains private function prototypes
    and types for the advanced 32-bit windows base APIs.

Author:

    Mark Lucovsky (markl) 18-Sep-1990

Revision History:

--*/

#ifndef _ADVAPI_
#define _ADVAPI_

#undef UNICODE

//
// get thunks right
//

#ifndef _ADVAPI32_
#define _ADVAPI32_
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#ifdef __cplusplus
extern "C" {
#endif
//
// Include Common Definitions.
//

ULONG
BaseSetLastNTError(
    IN NTSTATUS Status
    );


extern RTL_CRITICAL_SECTION Logon32Lock ;

#ifdef __cplusplus
} // extern "C"
#endif

#endif _ADVAPI_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\web\clientscripts.cs ===
using System;

namespace UDDI.Web
{
	public class ClientScripts
	{
        
		
		/// ****************************************************************
        ///	  public ShowHelp [static]
        /// ----------------------------------------------------------------
        ///   <summary>
        ///     Shows the given help url.
        ///   </summary>
        /// ----------------------------------------------------------------  
        ///   <param name="url">
        ///     The URL to load.
        ///   </param>
        /// ----------------------------------------------------------------  
        ///   <returns>
        ///     The client script to show the help.
        ///   </returns>
        /// ****************************************************************
        /// 
        public static string ShowHelp( string url )
        {
            string script = @"
				<script language=""javascript"">
				<!--
					ShowHelp( ""{url}"" );
				//-->
				</script>";

            script = script.Replace( "{url}", url.Replace( "\"", "\\\"" ) );
			
            return script;
        }

        /// ****************************************************************
		///	  public ReloadTop [static]
		/// ----------------------------------------------------------------
		///   <summary>
		///     Reloads the top window with the given url.
		///   </summary>
		/// ----------------------------------------------------------------  
		///   <param name="url">
		///     The URL to load in the top window.
		///   </param>
		/// ----------------------------------------------------------------  
		///   <returns>
		///     The client script to reload the top window.
		///   </returns>
		/// ****************************************************************
		/// 
		public static string ReloadTop( string url )
		{
			string script = @"
				<script language=""javascript"">
				<!--
					window.top.location = ""{url}"";
				//-->
				</script>";

			script = script.Replace( "{url}", url.Replace( "\"", "\\\"" ) );
			
			return script;
		}

		/// ****************************************************************
		///	  public ReloadViewPane [static]
		/// ----------------------------------------------------------------
		///   <summary>
		///     Reloads the view pane with the given url.
		///   </summary>
		/// ----------------------------------------------------------------  
		///   <param name="url">
		///     The URL to load in the view pane.
		///   </param>
		/// ----------------------------------------------------------------  
		///   <returns>
		///     The client script to reload the view pane.
		///   </returns>
		/// ****************************************************************
		/// 
		public static string ReloadViewPane( string url )
		{
			string script = @"
				<script language=""javascript"">
				<!--
					var view = window.parent.frames[ ""view"" ];
					
					view.location = ""{url}"";
				//-->
				</script>";

			script = script.Replace( "{url}", url.Replace( "\"", "\\\"" ) );
			
			return script;
		}

		/// ****************************************************************
		///	  public ReloadExplorerPane [static]
		/// ----------------------------------------------------------------
		///   <summary>
		///     Reloads the explorer pane.
		///   </summary>
		/// ----------------------------------------------------------------  
		///   <returns>
		///     The client script to reload the explorer pane.
		///   </returns>
		/// ****************************************************************
		/// 
		public static string ReloadExplorerPane()
		{
			string script = @"
				<script language=""javascript"">
				<!--
					var explorer = window.parent.frames[ ""explorer"" ];
					
					var form = explorer.document.forms[ 0 ];
					form.submit();
				//-->
				</script>";

			return script;
		}

		/// ****************************************************************
		///	  public ReloadExplorerPane [static]
		/// ----------------------------------------------------------------
		///   <summary>
		///     Reloads the explorer pane.
		///   </summary>
		/// ----------------------------------------------------------------  
		///   <param name="key">
		///     The node key to select.
		///   </param>
		/// ----------------------------------------------------------------  
		///   <returns>
		///     The client script to reload the explorer pane.
		///   </returns>
		/// ****************************************************************
		/// 
		public static string ReloadExplorerPane( string key )
		{
			string script = @"
				<script language=""javascript"">
				<!--
					var explorer = window.parent.frames[ ""explorer"" ];

					var keyField = explorer.document.getElementById( ""key"" );
					keyField.value = ""{key}"";
			
					var form = explorer.document.forms[ 0 ];
					form.submit();
				//-->
				</script>";

			script = script.Replace( "{key}", key.Replace( "\"", "\\\"" ) );
			
			return script;
		}

		/// ****************************************************************
		///	  public ReloadExplorerAndViewPanes [static]
		/// ----------------------------------------------------------------
		///   <summary>
		///     Reloads the explorer and view panes.
		///   </summary>
		/// ----------------------------------------------------------------  
		///   <param name="url">
		///     The URL to load in the view pane.
		///   </param>
		///   
		///   <param name="key">
		///     The node key to select in the explorer pane.
		///   </param>
		/// ----------------------------------------------------------------  
		///   <returns>
		///     The client script to reload the explorer and view panes.
		///   </returns>
		/// ****************************************************************
		/// 
		public static string ReloadExplorerAndViewPanes( string url, string key )
		{
			string script = @"
				<script language=""javascript"">
				<!--
					var explorer = window.parent.frames[ ""explorer"" ];
					var view = window.parent.frames[ ""view"" ];

					var keyField = explorer.document.getElementById( ""key"" );
					keyField.value = ""{key}"";
			
					var form = explorer.document.forms[ 0 ];
					form.submit();
					
					view.location = ""{url}"";
				//-->
				</script>";

			script = script.Replace( "{url}", url.Replace( "\"", "\\\"" ) );			
			script = script.Replace( "{key}", key.Replace( "\"", "\\\"" ) );
			
			return script;
		}

        /// ****************************************************************
        ///	  public Confirm [static]
        /// ----------------------------------------------------------------
        ///   <summary>
        ///     Displays a confirmation dialog and then proceeds to one
        ///     of two URL's depending on the user's choice.
        ///   </summary>
        /// ----------------------------------------------------------------  
        ///   <param name="message">
        ///     The message to display.
        ///   </param>
        ///   
        ///   <param name="urlOk">
        ///     The URL to go to if the user selects OK.
        ///   </param>
        /// ----------------------------------------------------------------  
        ///   <returns>
        ///     The client script to display the confirm dialog.
        ///   </returns>
        /// ****************************************************************
        /// 
        public static string Confirm( string message, string urlOk )
        {
            string script = @"
				<script language=""javascript"">
				<!--
					var result = confirm( ""{message}"" );

					if( result )
						window.location = ""{urlOk}"";
				//-->
				</script>";

            script = script.Replace( "{message}", message.Replace( "\"", "\\\"" ).Replace( "\n", " " ) );
            script = script.Replace( "{urlOk}", urlOk.Replace( "\"", "\\\"" ) );

            return script;
        }

		/// ****************************************************************
		///	  public Confirm [static]
		/// ----------------------------------------------------------------
		///   <summary>
		///     Displays a confirmation dialog and then proceeds to one
		///     of two URL's depending on the user's choice.
		///   </summary>
		/// ----------------------------------------------------------------  
		///   <param name="message">
		///     The message to display.
		///   </param>
		///   
		///   <param name="urlOk">
		///     The URL to go to if the user selects OK.
		///   </param>
		///   
		///   <param name="urlCancel">
		///     The URL to go to if the user selects Cancel.
		///   </param>
		/// ----------------------------------------------------------------  
		///   <returns>
		///     The client script to display the confirm dialog.
		///   </returns>
		/// ****************************************************************
		/// 
		public static string Confirm( string message, string urlOk, string urlCancel )
		{
			string script = @"
				<script language=""javascript"">
				<!--
					var result = confirm( ""{message}"" );

					if( result )
						window.location = ""{urlOk}"";
					else
						window.location = ""{urlCancel}"";
				//-->
				</script>";

			script = script.Replace( "{message}", message.Replace( "\"", "\\\"" ).Replace( "\n", " " ) );
			script = script.Replace( "{urlOk}", urlOk.Replace( "\"", "\\\"" ) );
			script = script.Replace( "{urlCancel}", urlCancel.Replace( "\"", "\\\"" ) );

			return script;
		}


		/// ****************************************************************
		///	  public ShowModalDialog [static]
		/// ----------------------------------------------------------------
		///   <summary>
		///     Displays a modal dialog.
		///   </summary>
		/// ----------------------------------------------------------------  
		///   <param name="url">
		///     The URL of the dialog to display.
		///   </param>
		///   
		///   <param name="width">
		///     The width of the dialog.
		///   </param>
		///   
		///   <param name="height">
		///     The height of the dialog.
		///   </param>
		/// ----------------------------------------------------------------  
		///   <returns>
		///     The client script to display the dialog.
		///   </returns>
		/// ****************************************************************
		/// 
		public static string ShowModalDialog( string url, string width, string height, bool resizable, bool scrollbars, bool status )
		{
			string script = @"
				<script language=""javascript"">
				<!--
					window.open( ""{url}"", ""dialog"", ""directories=no, location=no, menubar=no, toolbar=no, width={width}, height={height}, resizable={resizable}, scrollbars={scrollbars}, status={status}"", true );
				//-->
				</script>";

			script = script.Replace( "{url}", url.Replace( "\"", "\\\"" ) );
			script = script.Replace( "{width}", width );
			script = script.Replace( "{height}", height );
			script = script.Replace( "{resizable}", resizable ? "yes" : "no" );
			script = script.Replace( "{scrollbars}", scrollbars ? "yes" : "no" );
			script = script.Replace( "{status}", status ? "yes" : "no" );

			return script;
		}

		/// ****************************************************************
		///	  public CloseWindow [static]
		/// ----------------------------------------------------------------
		///   <summary>
		///     Closes the window.
		///   </summary>
		/// ----------------------------------------------------------------  
		///   <returns>
		///     The client script to close the window.
		///   </returns>
		/// ****************************************************************
		/// 
		public static string CloseWindow()
		{
			string script = @"
				<script language=""javascript"">
				<!--
					window.close();
				//-->
				</script>";

			return script;
		}	


		
	
	}
	public class ClientScriptRegisterCollection : System.Collections.CollectionBase
	{
		public ClientScriptRegister this[ int index ]
		{
			get{ return (ClientScriptRegister)this.List[ index ] ; }
			set{ this.List[ index ]=value; }
		}
		public int Add( ClientScriptRegister script )
		{
			return this.List.Add( script );
		}
		public void Remove( ClientScriptRegister script )
		{
			this.List.Remove( script );
		}
		public void Remove( int index )
		{
			this.List.RemoveAt( index );
		}

	}
		
	public class ClientScriptRegister : System.Web.UI.WebControls.PlaceHolder
	{
		private string source;
		public string Source
		{
			get{ return source; }
			set{ source=value; }
		}
		
		private string language;
		public string Language
		{
			get{ return language; }
			set{ language=value; }
		}
		protected override void Render( System.Web.UI.HtmlTextWriter output )
		{
			//if source is provided, then render a link
			if( null!=source )
			{
				
				output.Write( 
					"<script " + ((null==Language)?"": "language='"+Language+"' " )+ " src='"+ Source +"'></script>"
				);
			}
			else//else render the control
			{
				//render script tag
				if( null!=Language )
					output.AddAttribute( "language", Language );
				
				output.RenderBeginTag( System.Web.UI.HtmlTextWriterTag.Script );

				base.Render( output );

				//close script tag
				output.RenderEndTag();
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\advapi32\dbgdef.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       dbgdef.h
//
//  Contents:   Defines for debug exports in crypt32 (crypt32d.lib)
//
//  History:    17-Apr-96   kevinr   created
//              05-Sep-1997 pberkman added subsystem id's
//
//--------------------------------------------------------------------------

#ifndef DBGDEF_H
#define DBGDEF_H

#ifdef __cplusplus
    extern "C" 
    {
#endif


#if (DBG)

    //--------------------------------------------------------------------------
    // OSS and heap-checking
    //--------------------------------------------------------------------------
#   include <crtdbg.h>

    // To turn on heap checking (the whole nine yards) (slow):
    // set DEBUG_MASK=0x26
    // To only check for leaks:
    // set DEBUG_MASK=0x20

#   ifndef NO_OSS_DEBUG

#       include <asn1code.h>

        // To turn on OSS tracing (all encodes and decodes):
        // set OSS_DEBUG_MASK=0x02
        //
        // To turn on OSS tracing of only decoder errors
        // set OSS_DEBUG_MASK=0x10
        //
        // To send the OSS tracing output to a file:
        // set OSS_DEBUG_TRACEFILE=<filename>

        extern BOOL WINAPI DbgInitOSS( OssGlobal *pog);

#   endif  // NO_OSS_DEBUG

#endif  // DBG


//
//  05-Sep-1997 pberkman:
//
//      DEBUG_PRINT_MASK settings to turn on sub-system debugs
//
#define DBG_SS_CRYPT32                      0x00000001

#define DBG_SS_TRUSTCOMMON                  0x00010000
#define DBG_SS_TRUST                        0x00020000
#define DBG_SS_TRUSTPROV                    0x00040000
#define DBG_SS_SIP                          0x00080000
#define DBG_SS_CATALOG                      0x00100000
#define DBG_SS_SIGNING                      0x00200000
#define DBG_SS_OFFSIGN                      0x00400000
#define DBG_SS_CATDBSVC                     0x00800000

#define DBG_SS_APP                          0x10000000

typedef struct _DBG_SS_TAG
{
    DWORD       dwSS;
    const char  *pszTag;    // 7 characters!

} DBG_SS_TAG;

#define __DBG_SS_TAGS       { \
                                DBG_SS_CRYPT32,     "CRYPT32",  \
                                DBG_SS_TRUSTCOMMON, "PKITRST",  \
                                DBG_SS_TRUST,       "WINTRST",  \
                                DBG_SS_TRUSTPROV,   "SOFTPUB",  \
                                DBG_SS_CATALOG,     "MSCAT32",  \
                                DBG_SS_SIP,         "MSSIP32",  \
                                DBG_SS_SIGNING,     "MSSGN32",  \
                                DBG_SS_OFFSIGN,     "OFFSIGN",  \
                                DBG_SS_APP,         "CONAPPL",  \
                                DBG_SS_CATDBSVC,    "CATDBSV",  \
                                NULL, NULL                      \
                            }

//--------------------------------------------------------------------------
// DBG_TRACE 
//--------------------------------------------------------------------------
#if DBG 

	void DbgPrintf( DWORD dwSubSysId, LPCSTR lpFmt, ...);


#   define DBG_TRACE_EX(argFmt) DbgPrintf argFmt
#   define DBG_TRACE(argFmt)   DBG_TRACE_EX((DBG_SS_CRYPT32,argFmt))

#   define DBG_PRINTF(args)     DbgPrintf args

#else

#   define DBG_TRACE_EX(argFmt)
#   define DBG_TRACE(argFmt)

#   define DBG_PRINTF(args)

#endif  // DBG


//--------------------------------------------------------------------------
// Error-handling 
//--------------------------------------------------------------------------
#ifndef ERROR_RETURN_LABEL
#define ERROR_RETURN_LABEL ErrorReturn
#endif

#define TRACE_ERROR_EX(id,name)                                         \
name##:                                                                 \
    DBG_TRACE_EX((id,"(" #name ":%s,%d)\n", __FILE__, __LINE__));       \
    goto ERROR_RETURN_LABEL;

#define SET_ERROR_EX(id,name,err)                                       \
name##:                                                                 \
    SetLastError( (DWORD)(err));                                        \
    DBG_TRACE_EX((id, "%s, %d\n         " #name ": SetLastError " #err "\n", __FILE__, __LINE__)); \
    goto ERROR_RETURN_LABEL;

#define SET_ERROR_VAR_EX(id,name,err)                                   \
name##:                                                                 \
    SetLastError( (DWORD)(err));                                        \
    DBG_TRACE_EX((id, "%s, %d\n         " #name ": SetLastError(0x%x)\n", __FILE__, __LINE__, (err))); \
    goto ERROR_RETURN_LABEL;

#define SET_HRESULT_EX(id,name,err)                                     \
name##:                                                                 \
    hr = (HRESULT) (err);                                               \
    DBG_TRACE_EX((id, "%s, %d\n         " #name ": hr = " #err "\n", __FILE__, __LINE__)); \
    goto ERROR_RETURN_LABEL;

#define SET_HRESULT_VAR_EX(id,name,err)                                 \
name##:                                                                 \
    hr = (HRESULT) (err);                                               \
    DBG_TRACE_EX((id, "%s, %d\n         " #name ": hr = 0x%x\n" , __FILE__, __LINE__, (hr))); \
    goto ERROR_RETURN_LABEL;

#define TRACE_HRESULT_EX(id,name)                                       \
name##:                                                                 \
    DBG_TRACE_EX((id, "%s, %d\n         " #name ": hr = 0x%x\n", __FILE__, __LINE__, (hr))); \
    goto ERROR_RETURN_LABEL;

#define SET_DWRESULT_EX(id,name,err)                                     \
name##:                                                                 \
    dwResult = (DWORD) (err);                                               \
    DBG_TRACE_EX((id, "%s, %d\n         " #name ": hr = " #err "\n", __FILE__, __LINE__)); \
    goto ERROR_RETURN_LABEL;

#define TRACE_ERROR(name)               TRACE_ERROR_EX(DBG_SS_CRYPT32,name)
#define SET_ERROR(name,err)             SET_ERROR_EX(DBG_SS_CRYPT32,name,err)
#define SET_ERROR_VAR(name,err)         SET_ERROR_VAR_EX(DBG_SS_CRYPT32,name,err)
#define SET_HRESULT(name,err)           SET_HRESULT_EX(DBG_SS_CRYPT32,name,err)
#define SET_HRESULT_VAR(name,err)       SET_HRESULT_VAR_EX(DBG_SS_CRYPT32,name,err)
#define TRACE_HRESULT(name)             TRACE_HRESULT_EX(DBG_SS_CRYPT32,name)
#define SET_DWRESULT(name,err)          SET_DWRESULT_EX(DBG_SS_CRYPT32,name,err)


#define _JumpCondition(condition, label) \
    if (condition) \
    { \
	goto label; \
    } \
    else { } 

#define _JumpConditionWithExpr(condition, label, expr) \
    if (condition) \
    { \
        expr; \
	goto label; \
    } \
    else { } 

#ifdef __cplusplus
    }       // balance of extern "C"
#endif

#endif // DBGDEF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\advapi32\cryptapi.c ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : cryptapi.c                                             //
//  DESCRIPTION   : Crypto API interface                                   //
//  AUTHOR        :                                                        //
//  HISTORY       :                                                        //
//      Dec  6 1994 larrys  New                                            //
//      Jan 16 1995 larrys  Added key verify                               //
//      Jan 25 1995 larrys  Added thread safe                              //
//      Jan 27 1995 larrys  Added Unicode support                          //
//      Feb 21 1995 larrys  Added Unicode support for CryptAcquireContext  //
//      Feb 21 1995 larrys  Fixed Unicode problem in CryptAcquireContext   //
//      Mar 08 1995 larrys  Removed CryptGetLastError                      //
//      Mar 20 1995 larrys  Removed Certificate APIs                       //
//      Mar 22 1995 larrys  #ifdef in WIN95 code                           //
//      Apr 06 1995 larrys  Increased signature key to 1024 bits           //
//      Apr 07 1995 larrys  Removed CryptConfigure                         //
//      Jun 14 1995 larrys  Removed pointer from RSA key struct            //
//      Jun 29 1995 larrys  Changed AcquireContext                         //
//      Jul 17 1995 larrys  Worked on AcquireContext                       //
//      Aug 01 1995 larrys  Removed CryptTranslate                         //
//                          And CryptDeinstallProvider                     //
//                          Changed CryptInstallProvider to                //
//                          CryptSetProvider                               //
//      Aug 03 1995 larrys  Cleanup                                        //
//      Aug 10 1995 larrys  CryptAcquireContext returns error              //
//                          NTE_BAD_KEYSEY_PARAM now                       //
//      Aug 14 1995 larrys  Removed key exchange stuff                     //
//      Aug 17 1995 larrys  Changed registry entry to decimcal             //
//      Aug 23 1995 larrys  Changed CryptFinishHash to CryptGetHashValue   //
//      Aug 28 1995 larrys  Removed parameter from CryptVerifySignature    //
//      Aug 31 1995 larrys  Remove GenRandom                               //
//      Sep 14 1995 larrys  Code review changes                            //
//      Sep 26 1995 larrys  Added Microsoft's signing key                  //
//      Sep 27 1995 larrys  Updated with more review changes               //
//      Oct 06 1995 larrys  Added more APIs Get/SetHash/ProvParam          //
//      Oct 12 1995 larrys  Remove CryptGetHashValue                       //
//      Oct 20 1995 larrys  Changed test key                               //
//      Oct 24 1995 larrys  Removed return of KeySet name                  //
//      Oct 30 1995 larrys  Removed WIN95                                  //
//      Nov  9 1995 larrys  Disable BUILD1057                              //
//      Nov 10 1995 larrys  Fix a problem in EnterHashCritSec              //
//      May 30 1996 larrys  Added hWnd support                             //
//      Oct 10 1996 jeffspel Reordered SetLastErrors and save error on     //
//                           AcquireContext failure                        //
//      Mar 21 1997 jeffspel Added second tier signatures, new APIs        //
//      Apr 11 1997 jeffspel Replace critical sections with interlocked    //
//                           inc/dec                                       //
//      Oct 02 1997 jeffspel Add caching of CSPs to CryptAcquireContext    //
//      Oct 10 1997 jeffspel Add verification scheme for signature in file //
//                                                                         //
//  Copyright (C) 1993 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////


#include "advapi.h"
#include "stdlib.h"
#include <wincrypt.h>   // Include here, since not included by LEAN_AND_MEAN
#include <cspdk.h>
#include <ntstatus.h>
#include <rsa.h>
#include <md5.h>
#include <rc4.h>
#include <winperf.h>
#include <wtypes.h>
#include <mincrypt.h>

#define IDR_PUBKEY1                     102

typedef struct _VTableStruc {
// ******************** WARNING **********************************************
// Do not place anything before these FARPROCs we init the table assuming
// that the first Function to call is the first thing in the table.
// ***************************************************************************
    FARPROC FuncAcquireContext;
    FARPROC FuncReleaseContext;
    FARPROC FuncGenKey;
    FARPROC FuncDeriveKey;
    FARPROC FuncDestroyKey;
    FARPROC FuncSetKeyParam;
    FARPROC FuncGetKeyParam;
    FARPROC FuncExportKey;
    FARPROC FuncImportKey;
    FARPROC FuncEncrypt;
    FARPROC FuncDecrypt;
    FARPROC FuncCreateHash;
    FARPROC FuncHashData;
    FARPROC FuncHashSessionKey;
    FARPROC FuncDestroyHash;
    FARPROC FuncSignHash;
    FARPROC FuncVerifySignature;
    FARPROC FuncGenRandom;
    FARPROC FuncGetUserKey;
    FARPROC FuncSetProvParam;
    FARPROC FuncGetProvParam;
    FARPROC FuncSetHashParam;
    FARPROC FuncGetHashParam;
    FARPROC FuncNULL;

    FARPROC OptionalFuncDuplicateKey;
    FARPROC OptionalFuncDuplicateHash;
    FARPROC OptionalFuncNULL;

    HANDLE      DllHandle;                     // Handle to open DLL
    HCRYPTPROV  hProv;                         // Handle to provider
    DWORD       Version;
    DWORD       Inuse;
    LONG        RefCnt;
} VTableStruc, *PVTableStruc;

typedef struct _VKeyStruc {
// ******************** WARNING **********************************************
// Do not place anything before these FARPROCs we init the table assuming
// that the first Function to call is the first thing in the table.
// ***************************************************************************
    FARPROC FuncGenKey;
    FARPROC FuncDeriveKey;
    FARPROC FuncDestroyKey;
    FARPROC FuncSetKeyParam;
    FARPROC FuncGetKeyParam;
    FARPROC FuncExportKey;
    FARPROC FuncImportKey;
    FARPROC FuncEncrypt;
    FARPROC FuncDecrypt;

    FARPROC OptionalFuncDuplicateKey;

    HCRYPTPROV  hProv;                         // Handle to provider
    HCRYPTKEY   hKey;                          // Handle to key
    DWORD       Version;
    DWORD       Inuse;
} VKeyStruc, *PVKeyStruc;

typedef struct _VHashStruc {
// ******************** WARNING **********************************************
// Do not place anything before these FARPROCs we init the table assuming
// that the first Function to call is the first thing in the table.
// ***************************************************************************
    FARPROC FuncCreateHash;
    FARPROC FuncHashData;
    FARPROC FuncHashSessionKey;
    FARPROC FuncDestroyHash;
    FARPROC FuncSignHash;
    FARPROC FuncVerifySignature;
    FARPROC FuncSetHashParam;
    FARPROC FuncGetHashParam;

    FARPROC OptionalFuncDuplicateHash;

    HCRYPTPROV  hProv;                         // Handle to provider
    HCRYPTHASH  hHash;                         // Handle to hash
    DWORD       Version;
    DWORD       Inuse;
} VHashStruc, *PVHashStruc;


//
// Crypto providers have to have the following entry points:
//
LPCSTR FunctionNames[] = {
    "CPAcquireContext",
    "CPReleaseContext",
    "CPGenKey",
    "CPDeriveKey",
    "CPDestroyKey",
    "CPSetKeyParam",
    "CPGetKeyParam",
    "CPExportKey",
    "CPImportKey",
    "CPEncrypt",
    "CPDecrypt",
    "CPCreateHash",
    "CPHashData",
    "CPHashSessionKey",
    "CPDestroyHash",
    "CPSignHash",
    "CPVerifySignature",
    "CPGenRandom",
    "CPGetUserKey",
    "CPSetProvParam",
    "CPGetProvParam",
    "CPSetHashParam",
    "CPGetHashParam",
    NULL
    };

LPCSTR OptionalFunctionNames[] = {
    "CPDuplicateKey",
    "CPDuplicateHash",
    NULL
    };

#define CapiExceptionFilter                             \
    (STATUS_ACCESS_VIOLATION == GetExceptionCode() ?    \
     EXCEPTION_EXECUTE_HANDLER :                        \
     EXCEPTION_CONTINUE_SEARCH)

HWND hWnd = NULL;
BYTE *pbContextInfo = NULL;
DWORD cbContextInfo;

#define KEYSIZE512 0x48
#define KEYSIZE1024 0x88

// designatred resource for in file signatures
#define OLD_CRYPT_SIG_RESOURCE_NUMBER   "#666"


typedef struct _SECONDTIER_SIG
{
    DWORD           dwMagic;
    DWORD           cbSig;
    BSAFE_PUB_KEY   Pub;
} SECOND_TIER_SIG, *PSECOND_TIER_SIG;

#ifdef TEST_BUILD_EXPONENT
#pragma message("WARNING: building advapai32.dll with TESTKEY enabled!")
static struct _TESTKEY {
    BSAFE_PUB_KEY    PUB;
    unsigned char pubmodulus[KEYSIZE512];
} TESTKEY = {
    {
    0x66b8443b,
    0x6f5fc900,
    0xa12132fe,
    0xff1b06cf,
    0x2f4826eb,
    },
    {
    0x3e, 0x69, 0x4f, 0x45, 0x31, 0x95, 0x60, 0x6c,
    0x80, 0xa5, 0x41, 0x99, 0x3e, 0xfc, 0x92, 0x2c,
    0x93, 0xf9, 0x86, 0x23, 0x3d, 0x48, 0x35, 0x81,
    0x19, 0xb6, 0x7c, 0x04, 0x43, 0xe6, 0x3e, 0xd4,
    0xd5, 0x43, 0xaf, 0x52, 0xdd, 0x51, 0x20, 0xac,
    0xc3, 0xca, 0xee, 0x21, 0x9b, 0x4a, 0x2d, 0xf7,
    0xd8, 0x5f, 0x32, 0xeb, 0x49, 0x72, 0xb9, 0x8d,
    0x2e, 0x1a, 0x76, 0x7f, 0xde, 0xc6, 0x75, 0xab,
    0xaf, 0x67, 0xe0, 0xf0, 0x8b, 0x30, 0x20, 0x92,
    }
};
#endif


#ifdef MS_INTERNAL_KEY
static struct _mskey {
    BSAFE_PUB_KEY    PUB;
    unsigned char pubmodulus[KEYSIZE1024];
} MSKEY = {
    {
    0x2bad85ae,
    0x883adacc,
    0xb32ebd68,
    0xa7ec8b06,
    0x58dbeb81,
    },
    {
    0x42, 0x34, 0xb7, 0xab, 0x45, 0x0f, 0x60, 0xcd,
    0x8f, 0x77, 0xb5, 0xd1, 0x79, 0x18, 0x34, 0xbe,
    0x66, 0xcb, 0x5c, 0x66, 0x4a, 0x9f, 0x03, 0x18,
    0x13, 0x36, 0x8e, 0x88, 0x21, 0x78, 0xb1, 0x94,
    0xa1, 0xd5, 0x8f, 0x8c, 0xa5, 0xd3, 0x9f, 0x86,
    0x43, 0x89, 0x05, 0xa0, 0xe3, 0xee, 0xe2, 0xd0,
    0xe5, 0x1d, 0x5f, 0xaf, 0xff, 0x85, 0x71, 0x7a,
    0x0a, 0xdb, 0x2e, 0xd8, 0xc3, 0x5f, 0x2f, 0xb1,
    0xf0, 0x53, 0x98, 0x3b, 0x44, 0xee, 0x7f, 0xc9,
    0x54, 0x26, 0xdb, 0xdd, 0xfe, 0x1f, 0xd0, 0xda,
    0x96, 0x89, 0xc8, 0x9e, 0x2b, 0x5d, 0x96, 0xd1,
    0xf7, 0x52, 0x14, 0x04, 0xfb, 0xf8, 0xee, 0x4d,
    0x92, 0xd1, 0xb6, 0x37, 0x6a, 0xe0, 0xaf, 0xde,
    0xc7, 0x41, 0x06, 0x7a, 0xe5, 0x6e, 0xb1, 0x8c,
    0x8f, 0x17, 0xf0, 0x63, 0x8d, 0xaf, 0x63, 0xfd,
    0x22, 0xc5, 0xad, 0x1a, 0xb1, 0xe4, 0x7a, 0x6b,
    0x1e, 0x0e, 0xea, 0x60, 0x56, 0xbd, 0x49, 0xd0,
    }
};
#endif


static struct _key {
    BSAFE_PUB_KEY    PUB;
    unsigned char pubmodulus[KEYSIZE1024];
} KEY = {
    {
    0x3fcbf1a9,
    0x08f597db,
    0xe4aecab4,
    0x75360f90,
    0x9d6c0f00,
    },
    {
    0x85, 0xdd, 0x9b, 0xf4, 0x4d, 0x0b, 0xc4, 0x96,
    0x3e, 0x79, 0x86, 0x30, 0x6d, 0x27, 0x31, 0xee,
    0x4a, 0x85, 0xf5, 0xff, 0xbb, 0xa9, 0xbd, 0x81,
    0x86, 0xf2, 0x4f, 0x87, 0x6c, 0x57, 0x55, 0x19,
    0xe4, 0xf4, 0x49, 0xa3, 0x19, 0x27, 0x08, 0x82,
    0x9e, 0xf9, 0x8a, 0x8e, 0x41, 0xd6, 0x91, 0x71,
    0x47, 0x48, 0xee, 0xd6, 0x24, 0x2d, 0xdd, 0x22,
    0x72, 0x08, 0xc6, 0xa7, 0x34, 0x6f, 0x93, 0xd2,
    0xe7, 0x72, 0x57, 0x78, 0x7a, 0x96, 0xc1, 0xe1,
    0x47, 0x38, 0x78, 0x43, 0x53, 0xea, 0xf3, 0x88,
    0x82, 0x66, 0x41, 0x43, 0xd4, 0x62, 0x44, 0x01,
    0x7d, 0xb2, 0x16, 0xb3, 0x50, 0x89, 0xdb, 0x0a,
    0x93, 0x17, 0x02, 0x02, 0x46, 0x49, 0x79, 0x76,
    0x59, 0xb6, 0xb1, 0x2b, 0xfc, 0xb0, 0x9a, 0x21,
    0xe6, 0xfa, 0x2d, 0x56, 0x07, 0x36, 0xbc, 0x13,
    0x7f, 0x1c, 0xde, 0x55, 0xfb, 0x0d, 0x67, 0x0f,
    0xc2, 0x17, 0x45, 0x8a, 0x14, 0x2b, 0xba, 0x55,
    }
};


static struct _key2 {
    BSAFE_PUB_KEY    PUB;
    unsigned char pubmodulus[KEYSIZE1024];
} KEY2 =  {
    {
    0x685fc690,
    0x97d49b6b,
    0x1dccd9d2,
    0xa5ec9b52,
    0x64fd29d7,
    },
    {
    0x03, 0x8c, 0xa3, 0x9e, 0xfb, 0x93, 0xb6, 0x72,
    0x2a, 0xda, 0x6f, 0xa5, 0xec, 0x26, 0x39, 0x58,
    0x41, 0xcd, 0x3f, 0x49, 0x10, 0x4c, 0xcc, 0x7e,
    0x23, 0x94, 0xf9, 0x5d, 0x9b, 0x2b, 0xa3, 0x6b,
    0xe8, 0xec, 0x52, 0xd9, 0x56, 0x64, 0x74, 0x7c,
    0x44, 0x6f, 0x36, 0xb7, 0x14, 0x9d, 0x02, 0x3c,
    0x0e, 0x32, 0xb6, 0x38, 0x20, 0x25, 0xbd, 0x8c,
    0x9b, 0xd1, 0x46, 0xa7, 0xb3, 0x58, 0x4a, 0xb7,
    0xdd, 0x0e, 0x38, 0xb6, 0x16, 0x44, 0xbf, 0xc1,
    0xca, 0x4d, 0x6a, 0x9f, 0xcb, 0x6f, 0x3c, 0x5f,
    0x03, 0xab, 0x7a, 0xb8, 0x16, 0x70, 0xcf, 0x98,
    0xd0, 0xca, 0x8d, 0x25, 0x57, 0x3a, 0x22, 0x8b,
    0x44, 0x96, 0x37, 0x51, 0x30, 0x00, 0x92, 0x1b,
    0x03, 0xb9, 0xf9, 0x0d, 0xb3, 0x1a, 0xe2, 0xb4,
    0xc5, 0x7b, 0xc9, 0x4b, 0xe2, 0x42, 0x25, 0xfe,
    0x3d, 0x42, 0xfa, 0x45, 0xc6, 0x94, 0xc9, 0x8e,
    0x87, 0x7e, 0xf6, 0x68, 0x90, 0x30, 0x65, 0x10,
    }
};

#define CACHESIZE   32
static HANDLE   gCSPCache[CACHESIZE];

#define TABLEPROV       0x11111111
#define TABLEKEY        0x22222222
#define TABLEHASH       0x33333333

CHAR szreg[] = "SOFTWARE\\Microsoft\\Cryptography\\Providers\\";
CHAR szusertype[] = "SOFTWARE\\Microsoft\\Cryptography\\Providers\\Type ";
CHAR szmachinetype[] = "SOFTWARE\\Microsoft\\Cryptography\\Defaults\\Provider Types\\Type ";
CHAR szprovider[] = "SOFTWARE\\Microsoft\\Cryptography\\Defaults\\Provider\\";
CHAR szenumproviders[] = "SOFTWARE\\Microsoft\\Cryptography\\Defaults\\Provider";
CHAR szprovidertypes[] = "SOFTWARE\\Microsoft\\Cryptography\\Defaults\\Provider Types";

BOOL EnterProviderCritSec(IN PVTableStruc pVTable);
void LeaveProviderCritSec(IN PVTableStruc pVTable);
BOOL EnterKeyCritSec(IN PVKeyStruc pVKey);
void LeaveKeyCritSec(IN PVKeyStruc pVKey);
BOOL EnterHashCritSec(IN PVHashStruc pVHash);
void LeaveHashCritSec(IN PVHashStruc pVHash);

BOOL CheckSignatureInFile(LPCWSTR pszImage);

BOOL CProvVerifyImage(LPCSTR lpszImage,
                      BYTE *pSigData);

BOOL NewVerifyImage(LPCSTR lpszImage,
                    BYTE *pSigData,
                    DWORD cbData,
                    BOOL fUnknownLen);

BOOL BuildVKey(IN PVKeyStruc *ppVKey,
               IN PVTableStruc pVTable);

BOOL BuildVHash(
                IN PVHashStruc *ppVKey,
                IN PVTableStruc pVTable
                );

void CPReturnhWnd(HWND *phWnd);

static void __ltoa(DWORD val, char *buf);

BOOL CSPInCacheCheck(
                     LPSTR pszValue,
                     HANDLE *ph
                     )
{
    HANDLE  h = 0;
    DWORD   i;
    BOOL    fRet = FALSE;

    // check if CSP has been loaded
    if (0 == (h = GetModuleHandle(pszValue)))
        goto Ret;

    // check if the CSP is in the cache designating it as signed
    for (i=0;i<CACHESIZE;i++)
    {
        if (h == gCSPCache[i])
        {
            *ph = h;
            fRet = TRUE;
            break;
        }
    }
Ret:
    return fRet;
}

void AddHandleToCSPCache(
                         HANDLE h
                         )
{
    DWORD   i;

    // check if the CSP is in the cache designating it as signed
    for (i=0;i<CACHESIZE;i++)
    {
        if (0 == gCSPCache[i])
        {
            gCSPCache[i] = h;
            break;
        }
    }
}

/*
 -      CryptAcquireContextW
 -
 *      Purpose:
 *               The CryptAcquireContext function is used to acquire a context
 *               handle to a cryptograghic service provider (CSP).
 *
 *
 *      Parameters:
 *               OUT    phProv      -  Handle to a CSP
 *               IN     pszIdentity -  Pointer to the name of the context's
 *                                     keyset.
 *               IN     pszProvider -  Pointer to the name of the provider.
 *               IN     dwProvType   -  Requested CSP type
 *               IN     dwFlags     -  Flags values
 *
 *      Returns:
 */
WINADVAPI
BOOL
WINAPI CryptAcquireContextW(OUT    HCRYPTPROV *phProv,
                IN     LPCWSTR pszIdentity,
                IN     LPCWSTR pszProvider,
                IN     DWORD dwProvType,
                IN     DWORD dwFlags)
{
    ANSI_STRING         AnsiString1;
    ANSI_STRING         AnsiString2;
    UNICODE_STRING      UnicodeString1;
    UNICODE_STRING      UnicodeString2;
    NTSTATUS            Status = STATUS_SUCCESS;
    BOOL                rt;

    __try
    {
        memset(&AnsiString1, 0, sizeof(AnsiString1));
        memset(&AnsiString2, 0, sizeof(AnsiString2));
        memset(&UnicodeString1, 0, sizeof(UnicodeString1));
        memset(&UnicodeString2, 0, sizeof(UnicodeString2));

        if (NULL != pszIdentity)
        {
            RtlInitUnicodeString(&UnicodeString1, pszIdentity);

            Status = RtlUnicodeStringToAnsiString(&AnsiString1, &UnicodeString1,
                                                  TRUE);
        }

        if (!NT_SUCCESS(Status))
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return(CRYPT_FAILED);
        }

        if (NULL != pszProvider)
        {
            RtlInitUnicodeString(&UnicodeString2, pszProvider);

            Status = RtlUnicodeStringToAnsiString(&AnsiString2, &UnicodeString2,
                                                  TRUE);
        }

        if (!NT_SUCCESS(Status))
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return(CRYPT_FAILED);
        }

        rt = CryptAcquireContextA(phProv, AnsiString1.Buffer,
                      AnsiString2.Buffer,
                      dwProvType, dwFlags);

        RtlFreeAnsiString(&AnsiString1);
        RtlFreeAnsiString(&AnsiString2);

        return(rt);
    }
    __except (CapiExceptionFilter)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Try_Error_Return;
    }

Try_Error_Return:
    return(CRYPT_FAILED);

}

/*
 -      CryptAcquireContextA
 -
 *      Purpose:
 *               The CryptAcquireContext function is used to acquire a context
 *               handle to a cryptograghic service provider (CSP).
 *
 *
 *      Parameters:
 *               OUT    phProv         -  Handle to a CSP
 *               IN OUT pszIdentity    -  Pointer to the name of the context's
 *                                        keyset.
 *               IN OUT pszProvName    -  Pointer to the name of the provider.
 *               IN     dwReqProvider  -  Requested CSP type
 *               IN     dwFlags        -  Flags values
 *
 *      Returns:
 */
WINADVAPI
BOOL
WINAPI CryptAcquireContextA(OUT    HCRYPTPROV *phProv,
                IN     LPCSTR pszIdentity,
                IN     LPCSTR pszProvName,
                IN     DWORD dwReqProvider,
                IN     DWORD dwFlags)
{
    HANDLE          handle = 0;
    DWORD           bufsize;
    ULONG_PTR       *pTable;
    PVTableStruc    pVTable = NULL;
    LPSTR           pszTmpProvName = NULL;
    DWORD           i;
    HKEY            hKey = 0;
    DWORD           cbValue;
    DWORD           cbTemp;
    CHAR            *pszValue = NULL;
    CHAR            *pszDest = NULL;
    BYTE            *SignatureBuf = NULL;
    DWORD           provtype;
    BOOL            rt = CRYPT_FAILED;
    DWORD           dwType;
    LONG            err;
    DWORD           dwErr;
    CHAR            typebuf[9] = {0, 0, 0, 0, 0, 0, 0, 0, 0};
    HCRYPTPROV      hTmpProv = 0;
    VTableProvStruc VTableProv;
    UNICODE_STRING  String ;
    BOOL            SigInFile ;


    __try
    {
        if (dwReqProvider == 0 || dwReqProvider > 999)
        {
            SetLastError((DWORD) NTE_BAD_PROV_TYPE);
            goto Ret;
        }

        if (pszProvName != NULL && pszProvName[0] != 0)
        {
            // Do nothing just check for invalid pointers
            ;
        }

        if (pszProvName != NULL && pszProvName[0] != 0)
        {
            cbValue = strlen(pszProvName);

            if ((pszValue = (CHAR *) LocalAlloc(LMEM_ZEROINIT,
                                                (UINT) cbValue +
                                                strlen(szprovider) + 1)) == NULL)
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                goto Ret;
            }

            if ((pszTmpProvName = (LPSTR)LocalAlloc(LMEM_ZEROINIT,
                                                (UINT) cbValue + 1)) == NULL)
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                goto Ret;
            }

            strcpy(pszTmpProvName, pszProvName);
            strcpy(pszValue, szprovider);
            strcat(pszValue, pszProvName);
        }
        else
        {
            //
            // We no longer look under HKCU for a default csp.  We only look
            // under HKLM.
            //

            if ((pszValue = (CHAR *) LocalAlloc(LMEM_ZEROINIT,
                                                5 + strlen(szmachinetype))) == NULL)
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                goto Ret;
            }

            __ltoa(dwReqProvider, typebuf);
            strcpy(pszValue, szmachinetype);
            strcat(pszValue, &typebuf[5]);

            if ((err = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                    (const char *) pszValue, 0L,
                                    KEY_READ, &hKey)) != ERROR_SUCCESS)
            {
                SetLastError((DWORD) NTE_PROV_TYPE_NOT_DEF);
                goto Ret;
            }

            if ((err = RegQueryValueEx(hKey, "Name", NULL, &dwType,
                                       NULL, &cbValue)) != ERROR_SUCCESS)
            {
                SetLastError((DWORD) NTE_PROV_TYPE_NOT_DEF);
                goto Ret;
            }

            LocalFree(pszValue);
            if ((pszValue = (CHAR *) LocalAlloc(LMEM_ZEROINIT,
                                                cbValue +
                                                strlen(szprovider) + 1)) == NULL)
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                goto Ret;
            }

            if ((pszTmpProvName = (LPSTR)LocalAlloc(LMEM_ZEROINIT,
                                                (UINT) cbValue + 1)) == NULL)
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                goto Ret;
            }

            strcpy(pszValue, szprovider);

            cbTemp = cbValue;

            if ((err = RegQueryValueEx(hKey, "Name", NULL, &dwType,
                                       (LPBYTE)pszTmpProvName,
                                       &cbTemp)) != ERROR_SUCCESS)
            {
                SetLastError((DWORD) NTE_PROV_TYPE_NOT_DEF);
                goto Ret;
            }

            strcat(pszValue, pszTmpProvName);

            RegCloseKey(hKey);
            hKey = 0;
        }

        if ((err = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                (const char *) pszValue,
                                0L, KEY_READ, &hKey)) != ERROR_SUCCESS)
        {
            SetLastError((DWORD) NTE_KEYSET_NOT_DEF);
            goto Ret;
        }

        LocalFree(pszValue);
        pszValue = NULL;

        cbValue = sizeof(DWORD);
        if ((err = RegQueryValueEx(hKey, "Type", NULL, &dwType,
                                   (LPBYTE)&provtype,
                                   &cbValue)) != ERROR_SUCCESS)
        {
            SetLastError((DWORD) NTE_KEYSET_ENTRY_BAD);
            goto Ret;
        }

        // Check that requested provider type is same as registry entry
        if (provtype != dwReqProvider)
        {
            SetLastError((DWORD) NTE_PROV_TYPE_NO_MATCH);
            goto Ret;
        }

        // Determine size of path for provider
        if ((err = RegQueryValueEx(hKey, "Image Path", NULL,
                                   &dwType, NULL, &cbValue)) != ERROR_SUCCESS)
        {
            SetLastError((DWORD) NTE_KEYSET_ENTRY_BAD);
            goto Ret;
        }

        if ((pszValue = (CHAR *) LocalAlloc(LMEM_ZEROINIT,
                                            (UINT) cbValue)) == NULL)
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto Ret;
        }

        // Get value from registry
        if ((err = RegQueryValueEx(hKey, "Image Path", NULL, &dwType,
                                   (LPBYTE)pszValue, &cbValue)) != ERROR_SUCCESS)
        {
            SetLastError((DWORD) NTE_KEYSET_ENTRY_BAD);
            goto Ret;
        }

        pszDest = NULL;
        cbTemp = 0;

        if ((cbTemp = ExpandEnvironmentStrings(pszValue, (CHAR *) &pszDest, cbTemp))  == 0)
        {
            goto Ret;
        }

        if ((pszDest = (CHAR *) LocalAlloc(LMEM_ZEROINIT,
                                           (UINT) cbTemp)) == NULL)
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto Ret;
        }

        if ((cbTemp = ExpandEnvironmentStrings(pszValue, pszDest,
                                               cbTemp))  == 0)
        {
            goto Ret;
        }

        LocalFree(pszValue);
        pszValue = pszDest;
        pszDest = NULL;
        cbValue = cbTemp;

        if (!CSPInCacheCheck(pszValue, &handle))
        {
            if ( RtlCreateUnicodeStringFromAsciiz( &String, pszValue ) )
            {
                // check if the CSP is registered as having the signature in the file

                SigInFile = CheckSignatureInFile( String.Buffer );

                RtlFreeUnicodeString( &String );

                if (! SigInFile )
                {
                    // Determine size of signature
                    if ((err = RegQueryValueEx(hKey, "Signature", NULL,
                                               &dwType, NULL, &cbValue)) != ERROR_SUCCESS)
                    {
                        SetLastError((DWORD) NTE_BAD_SIGNATURE);
                        goto Ret;
                    }

                    if ((SignatureBuf = (LPBYTE)LocalAlloc(LMEM_ZEROINIT,
                                                           (UINT) cbValue)) == NULL)
                    {
                        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                        goto Ret;
                    }


                    // Get Digital signature from registry
                    if ((err = RegQueryValueEx(hKey, "Signature", NULL, &dwType,
                                               SignatureBuf,
                                               &cbValue)) != ERROR_SUCCESS)
                    {
                        SetLastError((DWORD) NTE_BAD_SIGNATURE);
                        goto Ret;
                    }


                    if (RCRYPT_FAILED(NewVerifyImage(pszValue, SignatureBuf, cbValue, FALSE)))
                    {
                        SetLastError((DWORD) NTE_BAD_SIGNATURE);
                        goto Ret;
                    }
                }

            }

            if ((handle = LoadLibrary(pszValue)) == NULL)
            {
                SetLastError((DWORD) NTE_PROVIDER_DLL_FAIL);
                goto Ret;
            }

            AddHandleToCSPCache(handle);
        }

         // DLLs exist allocate VTable struct to hold address of entry points
        bufsize = sizeof(VTableStruc);

        if ((pVTable = (PVTableStruc) LocalAlloc(LMEM_ZEROINIT,
                                                 (UINT) bufsize)) == NULL)
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto Ret;
        }

        pTable = (ULONG_PTR *) pVTable;

        // Build table of pointers to Crypto API for this DLL
        i = 0;
        while (FunctionNames[i] != NULL)
        {
            *pTable = (ULONG_PTR) GetProcAddress(handle, FunctionNames[i]);
            if (*pTable == 0)
            {
                SetLastError((DWORD) NTE_PROVIDER_DLL_FAIL);
                goto Ret;
            }
            pTable++;
            i++;
        }

        // Build the table of optional pointers to Crypto API for this DLL
        i = 0;
        pTable++;
        while (OptionalFunctionNames[i] != NULL)
        {
            *pTable = (ULONG_PTR) GetProcAddress(handle, OptionalFunctionNames[i]);
            pTable++;
            i++;
        }
        pVTable->DllHandle = handle;

        memset(&VTableProv, 0, sizeof(VTableProv));
        VTableProv.Version = 3;
        VTableProv.FuncVerifyImage = (CRYPT_VERIFY_IMAGE_A)CProvVerifyImage;
        VTableProv.FuncReturnhWnd = (CRYPT_RETURN_HWND)CPReturnhWnd;
        VTableProv.dwProvType = dwReqProvider;
        VTableProv.pszProvName = pszTmpProvName;
        VTableProv.pbContextInfo = pbContextInfo;
        VTableProv.cbContextInfo = cbContextInfo;

        *phProv = (HCRYPTPROV) NULL;

        rt = (BOOL)pVTable->FuncAcquireContext(&hTmpProv, pszIdentity, dwFlags,
                                               &VTableProv);

        if (RCRYPT_SUCCEEDED(rt) &&
            ((dwFlags & CRYPT_DELETEKEYSET) != CRYPT_DELETEKEYSET))
        {
            pVTable->hProv = hTmpProv;
            *phProv = (HCRYPTPROV)pVTable;

            pVTable->Version = TABLEPROV;
            pVTable->Inuse = 1;
            pVTable->RefCnt = 1;
        }
    }
    __except (CapiExceptionFilter)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }
Ret:
    dwErr = GetLastError();
    if (pszTmpProvName)
        LocalFree(pszTmpProvName);
    if (pszValue)
        LocalFree(pszValue);
    if (hKey)
        RegCloseKey(hKey);
    if (pszDest)
        LocalFree(pszDest);
    if (SignatureBuf)
        LocalFree(SignatureBuf);
    if ((CRYPT_SUCCEED != rt) || (dwFlags & CRYPT_DELETEKEYSET))
    {
        if (pVTable)
            LocalFree(pVTable);
        SetLastError(dwErr);
    }
    return rt;
}

/*
 -      CryptContextAddRef
 -
 *      Purpose:
 *               Increments the reference counter on the provider handle.
 *
 *      Parameters:
 *               IN  hProv         -  Handle to a CSP
 *               IN  pdwReserved   -  Reserved parameter
 *               IN  dwFlags       -  Flags values
 *
 *      Returns:
 *               BOOL
 *               Use get extended error information use GetLastError
 */
WINADVAPI
BOOL
WINAPI CryptContextAddRef(
                          IN HCRYPTPROV hProv,
                          IN DWORD *pdwReserved,
                          IN DWORD dwFlags
                          )
{
    PVTableStruc    pVTable;
    BOOL            fRet = CRYPT_FAILED;

    __try
    {
        if ((NULL != pdwReserved) || (0 != dwFlags))
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }

        pVTable = (PVTableStruc) hProv;

        if (pVTable->Version != TABLEPROV)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }

        if (InterlockedIncrement(&pVTable->RefCnt) <= 0)
            SetLastError(ERROR_INVALID_PARAMETER);
        else
            fRet = CRYPT_SUCCEED;
    }
    __except ( CapiExceptionFilter )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }

Ret:
    return fRet;
}

/*
 -      CryptReleaseContext
 -
 *      Purpose:
 *               The CryptReleaseContext function is used to release a
 *               context created by CryptAcquireContext.
 *
 *     Parameters:
 *               IN  hProv         -  Handle to a CSP
 *               IN  dwFlags       -  Flags values
 *
 *      Returns:
 *               BOOL
 *               Use get extended error information use GetLastError
 */
WINADVAPI
BOOL
WINAPI CryptReleaseContext(IN HCRYPTPROV hProv,
                           IN DWORD dwFlags)
{
    PVTableStruc    pVTable;
    BOOL            rt;
    BOOL            fRet = CRYPT_FAILED;
    DWORD           dwErr = 0;

    __try
    {
        pVTable = (PVTableStruc) hProv;

        if (pVTable->Version != TABLEPROV)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }

        if (pVTable->RefCnt <= 0)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }

        if (0 == InterlockedDecrement(&pVTable->RefCnt))
        {
            if (0 < InterlockedDecrement((LPLONG)&pVTable->Inuse))
            {
                InterlockedIncrement((LPLONG)&pVTable->Inuse);
                SetLastError(ERROR_BUSY);
                goto Ret;
            }
            InterlockedIncrement((LPLONG)&pVTable->Inuse);

            if (FALSE == (rt = (BOOL)pVTable->FuncReleaseContext(pVTable->hProv, dwFlags)))
            {
                dwErr = GetLastError();
            }
            pVTable->Version = 0;
            LocalFree(pVTable);
            if (!rt)
            {
                SetLastError(dwErr);
                goto Ret;
            }
        }
    }
    __except ( CapiExceptionFilter )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }

    fRet = CRYPT_SUCCEED;
Ret:
    return fRet;
}

/*
 -      CryptGenKey
 -
 *      Purpose:
 *                Generate cryptographic keys
 *
 *
 *      Parameters:
 *               IN      hProv   -  Handle to a CSP
 *               IN      Algid   -  Algorithm identifier
 *               IN      dwFlags -  Flags values
 *               OUT     phKey   -  Handle to a generated key
 *
 *      Returns:
 */
WINADVAPI
BOOL
WINAPI CryptGenKey(IN HCRYPTPROV hProv,
            IN ALG_ID Algid,
            IN DWORD dwFlags,
            OUT HCRYPTKEY * phKey)
{
    PVTableStruc    pVTable = NULL;
    PVKeyStruc      pVKey = NULL;
    BOOL            fProvCritSec = FALSE;
    DWORD           dwErr;
    BOOL            fRet = CRYPT_FAILED;

    __try
    {
        pVTable = (PVTableStruc) hProv;

        if (RCRYPT_FAILED(EnterProviderCritSec(pVTable)))
        {
            goto Ret;
        }
        fProvCritSec = TRUE;

        if (RCRYPT_FAILED(BuildVKey(&pVKey, pVTable)))
        {
            goto Ret;
        }

        if (RCRYPT_FAILED(pVTable->FuncGenKey(pVTable->hProv, Algid, dwFlags,
                            phKey)))
        {
            goto Ret;
        }

        pVKey->hKey = *phKey;

        *phKey = (HCRYPTKEY) pVKey;

        pVKey->Version = TABLEKEY;

        pVKey->hProv = hProv;

        pVKey->Inuse = 1;

    }
    __except ( CapiExceptionFilter )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }

    fRet = CRYPT_SUCCEED;
Ret:
    dwErr = GetLastError();
    if (fProvCritSec)
        LeaveProviderCritSec(pVTable);
    if (CRYPT_SUCCEED != fRet)
    {
        if (pVKey)
            LocalFree(pVKey);
        SetLastError(dwErr);
    }
    return fRet;
}

/*
 -      CryptDuplicateKey
 -
 *      Purpose:
 *                Duplicate a cryptographic key
 *
 *
 *      Parameters:
 *               IN      hKey           -  Handle to the key to be duplicated
 *               IN      pdwReserved    -  Reserved for later use
 *               IN      dwFlags        -  Flags values
 *               OUT     phKey          -  Handle to the new duplicate key
 *
 *      Returns:
 */
WINADVAPI
BOOL
WINAPI CryptDuplicateKey(
                         IN HCRYPTKEY hKey,
                         IN DWORD *pdwReserved,
                         IN DWORD dwFlags,
                         OUT HCRYPTKEY * phKey
                         )
{
    PVTableStruc    pVTable = NULL;
    PVKeyStruc      pVKey;
    PVKeyStruc      pVNewKey = NULL;
    HCRYPTKEY       hNewKey;
    BOOL            fProvCritSecSet = FALSE;
    DWORD           dwErr = 0;
    BOOL            fRet = CRYPT_FAILED;

    __try
    {
        if (IsBadWritePtr(phKey, sizeof(HCRYPTKEY)))
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }
        pVKey = (PVKeyStruc) hKey;

        if (pVKey->Version != TABLEKEY)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }

        if (NULL == pVKey->OptionalFuncDuplicateKey)
        {
            SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
            goto Ret;
        }

        pVTable = (PVTableStruc) pVKey->hProv;

        if (RCRYPT_FAILED(EnterProviderCritSec(pVTable)))
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }
        fProvCritSecSet = TRUE;

        if (RCRYPT_FAILED(BuildVKey(&pVNewKey, pVTable)))
        {
            goto Ret;
        }

        if (RCRYPT_FAILED(pVKey->OptionalFuncDuplicateKey(pVTable->hProv, pVKey->hKey,
                                                          pdwReserved, dwFlags, &hNewKey)))
        {
            goto Ret;
        }

        pVNewKey->hKey = hNewKey;

        pVNewKey->Version = TABLEKEY;

        pVNewKey->hProv = pVKey->hProv;

        pVKey->Inuse = 1;

        *phKey = (HCRYPTKEY) pVNewKey;
    }
    __except ( CapiExceptionFilter )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }

    fRet = CRYPT_SUCCEED;
Ret:
    dwErr = GetLastError();
    if (fProvCritSecSet)
        LeaveProviderCritSec(pVTable);
    if (fRet == CRYPT_FAILED)
    {
        if (NULL != pVNewKey)
            LocalFree(pVNewKey);
        SetLastError(dwErr);
    }

    return fRet;
}

/*
 -      CryptDeriveKey
 -
 *      Purpose:
 *                Derive cryptographic keys from base data
 *
 *
 *      Parameters:
 *               IN      hProv      -  Handle to a CSP
 *               IN      Algid      -  Algorithm identifier
 *               IN      hHash      -  Handle to hash of base data
 *               IN      dwFlags    -  Flags values
 *               IN OUT  phKey      -  Handle to a generated key
 *
 *      Returns:
 */
WINADVAPI
BOOL
WINAPI CryptDeriveKey(IN HCRYPTPROV hProv,
                IN ALG_ID Algid,
                IN HCRYPTHASH hHash,
                IN DWORD dwFlags,
                IN OUT HCRYPTKEY * phKey)
{
    PVTableStruc    pVTable = NULL;
    PVKeyStruc      pVKey = NULL;
    PVHashStruc     pVHash = NULL;
    BOOL            fProvCritSec = FALSE;
    BOOL            fKeyCritSec = FALSE;
    BOOL            fHashCritSec = FALSE;
    BOOL            fUpdate = FALSE;
    DWORD           dwErr = 0;
    BOOL            fRet = CRYPT_FAILED;

    __try
    {
        pVTable = (PVTableStruc) hProv;

        if (RCRYPT_FAILED(EnterProviderCritSec(pVTable)))
        {
            goto Ret;
        }
        fProvCritSec = TRUE;

        pVHash = (PVHashStruc) hHash;

        if (RCRYPT_FAILED(EnterHashCritSec(pVHash)))
        {
            goto Ret;
        }
        fHashCritSec = TRUE;

        if (dwFlags & CRYPT_UPDATE_KEY)
        {
            fUpdate = TRUE;
            pVKey = (PVKeyStruc) phKey;

            if (RCRYPT_FAILED(EnterKeyCritSec(pVKey)))
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                goto Ret;
            }
            fKeyCritSec = TRUE;
        }
        else
        {
            if (RCRYPT_FAILED(BuildVKey(&pVKey, pVTable)))
            {
                goto Ret;
            }
        }

        if (RCRYPT_FAILED(pVTable->FuncDeriveKey(pVTable->hProv, Algid,
                        pVHash->hHash, dwFlags, phKey)))
        {
            goto Ret;
        }

        if ((dwFlags & CRYPT_UPDATE_KEY) != CRYPT_UPDATE_KEY)
        {
            pVKey->hKey = *phKey;

            *phKey = (HCRYPTKEY)pVKey;

            pVKey->hProv = hProv;

            pVKey->Version = TABLEKEY;

            pVKey->Inuse = 1;
        }

    } __except ( CapiExceptionFilter )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }

    fRet = CRYPT_SUCCEED;
Ret:
    if (CRYPT_SUCCEED != fRet)
        dwErr = GetLastError();
    if (fProvCritSec)
        LeaveProviderCritSec(pVTable);
    if (fHashCritSec)
        LeaveHashCritSec(pVHash);
    if (fKeyCritSec)
        LeaveKeyCritSec(pVKey);
    if (CRYPT_SUCCEED != fRet)
    {
        if (pVKey && (!fUpdate))
            LocalFree(pVKey);
        SetLastError(dwErr);
    }
    return fRet;
}


/*
 -      CryptDestroyKey
 -
 *      Purpose:
 *                Destroys the cryptographic key that is being referenced
 *                with the hKey parameter
 *
 *
 *      Parameters:
 *               IN      hKey   -  Handle to a key
 *
 *      Returns:
 */
WINADVAPI
BOOL
WINAPI CryptDestroyKey(IN HCRYPTKEY hKey)
{
    PVTableStruc    pVTable = NULL;
    PVKeyStruc      pVKey;
    BOOL            fProvCritSec = FALSE;
    BOOL            rt;
    DWORD           dwErr = 0;
    BOOL            fRet = CRYPT_FAILED;

    __try
    {
        pVKey = (PVKeyStruc) hKey;

        if (pVKey->Version != TABLEKEY)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }

        if (0 < InterlockedDecrement((LPLONG)&pVKey->Inuse))
        {
            InterlockedIncrement((LPLONG)&pVKey->Inuse);
            SetLastError(ERROR_BUSY);
            goto Ret;
        }
        InterlockedIncrement((LPLONG)&pVKey->Inuse);

        pVTable = (PVTableStruc) pVKey->hProv;

        if (RCRYPT_FAILED(EnterProviderCritSec(pVTable)))
        {
            goto Ret;
        }
        fProvCritSec = TRUE;

        if (FALSE == (rt = (BOOL)pVKey->FuncDestroyKey(pVTable->hProv, pVKey->hKey)))
            dwErr = GetLastError();

        pVKey->Version = 0;
        LocalFree(pVKey);

        if (!rt)
        {
            SetLastError(dwErr);
            goto Ret;
        }
    } __except ( CapiExceptionFilter )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }

    fRet = CRYPT_SUCCEED;
Ret:
    if (CRYPT_SUCCEED != fRet)
        dwErr = GetLastError();
    if (fProvCritSec)
        LeaveProviderCritSec(pVTable);
    if (CRYPT_SUCCEED != fRet)
        SetLastError(dwErr);
    return fRet;
}


/*
 -      CryptSetKeyParam
 -
 *      Purpose:
 *                Allows applications to customize various aspects of the
 *                operations of a key
 *
 *      Parameters:
 *               IN      hKey    -  Handle to a key
 *               IN      dwParam -  Parameter number
 *               IN      pbData  -  Pointer to data
 *               IN      dwFlags -  Flags values
 *
 *      Returns:
 */
WINADVAPI
BOOL
WINAPI CryptSetKeyParam(IN HCRYPTKEY hKey,
                        IN DWORD dwParam,
                        IN CONST BYTE *pbData,
                        IN DWORD dwFlags)
{
    PVTableStruc    pVTable = NULL;
    PVKeyStruc      pVKey;
    BOOL            rt = CRYPT_FAILED;
    BOOL            fCritSec = FALSE;

    __try
    {
        pVKey = (PVKeyStruc) hKey;

        if (pVKey->Version != TABLEKEY)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }

        if (0 < InterlockedDecrement((LPLONG)&pVKey->Inuse))
        {
            InterlockedIncrement((LPLONG)&pVKey->Inuse);
            SetLastError(ERROR_BUSY);
            goto Ret;
        }
        InterlockedIncrement((LPLONG)&pVKey->Inuse);

        pVTable = (PVTableStruc) pVKey->hProv;

        if (RCRYPT_FAILED(EnterProviderCritSec(pVTable)))
        {
            goto Ret;
        }
        fCritSec = TRUE;

        rt = (BOOL)pVKey->FuncSetKeyParam(pVTable->hProv, pVKey->hKey,
                                    dwParam, pbData, dwFlags);
    }
    __except ( CapiExceptionFilter )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }
Ret:
    if (fCritSec)
        LeaveProviderCritSec(pVTable);
    return(rt);

}


/*
 -      CryptGetKeyParam
 -
 *      Purpose:
 *                Allows applications to get various aspects of the
 *                operations of a key
 *
 *      Parameters:
 *               IN      hKey       -  Handle to a key
 *               IN      dwParam    -  Parameter number
 *               IN      pbData     -  Pointer to data
 *               IN      pdwDataLen -  Length of parameter data
 *               IN      dwFlags    -  Flags values
 *
 *      Returns:
 */
WINADVAPI
BOOL
WINAPI CryptGetKeyParam(IN HCRYPTKEY hKey,
                        IN DWORD dwParam,
                        IN BYTE *pbData,
                        IN DWORD *pdwDataLen,
                        IN DWORD dwFlags)
{
    PVTableStruc    pVTable = NULL;
    PVKeyStruc      pVKey = NULL;
    BOOL            rt = CRYPT_FAILED;
    BOOL            fKeyCritSec = FALSE;
    BOOL            fTableCritSec = FALSE;

    __try
    {
        pVKey = (PVKeyStruc) hKey;

        if (RCRYPT_FAILED(EnterKeyCritSec(pVKey)))
        {
            goto Ret;
        }
        fKeyCritSec = TRUE;

        pVTable = (PVTableStruc) pVKey->hProv;

        if (RCRYPT_FAILED(EnterProviderCritSec(pVTable)))
        {
            goto Ret;
        }
        fTableCritSec = TRUE;

        rt = (BOOL)pVKey->FuncGetKeyParam(pVTable->hProv, pVKey->hKey,
                                    dwParam, pbData, pdwDataLen,
                                    dwFlags);

    }
    __except ( CapiExceptionFilter )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }
Ret:
    if (fKeyCritSec)
        LeaveKeyCritSec(pVKey);
    if (fTableCritSec)
        LeaveProviderCritSec(pVTable);
    return(rt);

}


/*
 -      CryptGenRandom
 -
 *      Purpose:
 *                Used to fill a buffer with random bytes
 *
 *
 *      Parameters:
 *               IN  hProv      -  Handle to the user identifcation
 *               IN  dwLen      -  Number of bytes of random data requested
 *               OUT pbBuffer   -  Pointer to the buffer where the random
 *                                 bytes are to be placed
 *
 *      Returns:
 */
WINADVAPI
BOOL
WINAPI CryptGenRandom(IN HCRYPTPROV hProv,
                      IN DWORD dwLen,
                      OUT BYTE *pbBuffer)

{
    PVTableStruc    pVTable = NULL;
    BOOL            fTableCritSec = FALSE;
    BOOL            rt = CRYPT_FAILED;

    __try
    {
        pVTable = (PVTableStruc) hProv;

        if (RCRYPT_FAILED(EnterProviderCritSec(pVTable)))
        {
            goto Ret;
        }
        fTableCritSec = TRUE;

        rt = (BOOL)pVTable->FuncGenRandom(pVTable->hProv, dwLen, pbBuffer);

    } __except ( CapiExceptionFilter )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }
Ret:
    if (fTableCritSec)
        LeaveProviderCritSec(pVTable);
    return(rt);
}

/*
 -      CryptGetUserKey
 -
 *      Purpose:
 *                Gets a handle to a permanent user key
 *
 *
 *      Parameters:
 *               IN  hProv      -  Handle to the user identifcation
 *               IN  dwKeySpec  -  Specification of the key to retrieve
 *               OUT phUserKey  -  Pointer to key handle of retrieved key
 *
 *      Returns:
 */
WINADVAPI
BOOL
WINAPI CryptGetUserKey(IN HCRYPTPROV hProv,
                       IN DWORD dwKeySpec,
                       OUT HCRYPTKEY *phUserKey)
{

    PVTableStruc    pVTable = NULL;
    PVKeyStruc      pVKey = NULL;
    BOOL            fTableCritSec = FALSE;
    BOOL            fRet = CRYPT_FAILED;

    __try
    {
        pVTable = (PVTableStruc) hProv;

        if (RCRYPT_FAILED(EnterProviderCritSec(pVTable)))
        {
            goto Ret;
        }
        fTableCritSec = TRUE;

        if (RCRYPT_FAILED(BuildVKey(&pVKey, pVTable)))
        {
            goto Ret;
        }

        if (RCRYPT_FAILED(pVTable->FuncGetUserKey(pVTable->hProv, dwKeySpec,
                                                  phUserKey)))
        {
            goto Ret;
        }

        pVKey->hKey = *phUserKey;

        pVKey->hProv = hProv;

        *phUserKey = (HCRYPTKEY)pVKey;

        pVKey->Version = TABLEKEY;

        pVKey->Inuse = 1;

    } __except ( CapiExceptionFilter )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }

    fRet = CRYPT_SUCCEED;
Ret:
    if (fTableCritSec)
        LeaveProviderCritSec(pVTable);
    if ((CRYPT_SUCCEED != fRet) && pVKey)
        LocalFree(pVKey);
    return fRet;
}



/*
 -      CryptExportKey
 -
 *      Purpose:
 *                Export cryptographic keys out of a CSP in a secure manner
 *
 *
 *      Parameters:
 *               IN  hKey       - Handle to the key to export
 *               IN  hPubKey    - Handle to the exchange public key value of
 *                                the destination user
 *               IN  dwBlobType - Type of key blob to be exported
 *               IN  dwFlags -    Flags values
 *               OUT pbData -     Key blob data
 *               OUT pdwDataLen - Length of key blob in bytes
 *
 *      Returns:
 */
WINADVAPI
BOOL
WINAPI CryptExportKey(IN HCRYPTKEY hKey,
                IN HCRYPTKEY hPubKey,
                IN DWORD dwBlobType,
                IN DWORD dwFlags,
                OUT BYTE *pbData,
                OUT DWORD *pdwDataLen)
{
    PVTableStruc    pVTable = NULL;
    PVKeyStruc      pVKey = NULL;
    PVKeyStruc      pVPublicKey = NULL;
    BOOL            fKeyCritSec = FALSE;
    BOOL            fPubKeyCritSec = FALSE;
    BOOL            fTableCritSec = FALSE;
    BOOL            rt = CRYPT_FAILED;

    __try
    {
        pVKey = (PVKeyStruc) hKey;

        if (RCRYPT_FAILED(EnterKeyCritSec(pVKey)))
        {
            goto Ret;
        }
        fKeyCritSec = TRUE;

        pVTable = (PVTableStruc) pVKey->hProv;

        if (RCRYPT_FAILED(EnterProviderCritSec(pVTable)))
        {
            goto Ret;
        }
        fTableCritSec = TRUE;

        pVPublicKey = (PVKeyStruc) hPubKey;

        if (pVPublicKey != NULL)
        {
            if (RCRYPT_FAILED(EnterKeyCritSec(pVPublicKey)))
            {
                goto Ret;
            }
            fPubKeyCritSec = TRUE;
        }

        rt = (BOOL)pVKey->FuncExportKey(pVTable->hProv, pVKey->hKey,
                                  (pVPublicKey == NULL ? 0 : pVPublicKey->hKey),
                                  dwBlobType, dwFlags, pbData,
                                  pdwDataLen);

    } __except ( CapiExceptionFilter )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }
Ret:
    if (fKeyCritSec)
        LeaveKeyCritSec(pVKey);
    if (fTableCritSec)
        LeaveProviderCritSec(pVTable);
    if (pVPublicKey != NULL)
    {
        if (fPubKeyCritSec)
            LeaveKeyCritSec(pVPublicKey);
    }
    return(rt);

}


/*
 -      CryptImportKey
 -
 *      Purpose:
 *                Import cryptographic keys
 *
 *
 *      Parameters:
 *               IN  hProv     -  Handle to the CSP user
 *               IN  pbData    -  Key blob data
 *               IN  dwDataLen -  Length of the key blob data
 *               IN  hPubKey   -  Handle to the exchange public key value of
 *                                the destination user
 *               IN  dwFlags   -  Flags values
 *               OUT phKey     -  Pointer to the handle to the key which was
 *                                Imported
 *
 *      Returns:
 */
WINADVAPI
BOOL
WINAPI CryptImportKey(IN HCRYPTPROV hProv,
                    IN CONST BYTE *pbData,
                    IN DWORD dwDataLen,
                    IN HCRYPTKEY hPubKey,
                    IN DWORD dwFlags,
                    OUT HCRYPTKEY *phKey)
{
    PVTableStruc    pVTable = NULL;
    PVKeyStruc      pVKey = NULL;
    PVKeyStruc      pVPublicKey = NULL;
    BOOL            fKeyCritSec = FALSE;
    BOOL            fPubKeyCritSec = FALSE;
    BOOL            fTableCritSec = FALSE;
    BOOL            fBuiltKey = FALSE;
    BOOL            fRet = CRYPT_FAILED;

    __try
    {
        pVTable = (PVTableStruc) hProv;

        if (RCRYPT_FAILED(EnterProviderCritSec(pVTable)))
        {
            goto Ret;
        }
        fTableCritSec = TRUE;

        pVPublicKey = (PVKeyStruc)hPubKey;

        if (pVPublicKey != NULL)
        {
            if (RCRYPT_FAILED(EnterKeyCritSec(pVPublicKey)))
            {
                goto Ret;
            }
            fPubKeyCritSec = TRUE;
        }

        if (dwFlags & CRYPT_UPDATE_KEY)
        {
            pVKey = (PVKeyStruc) phKey;

            if (RCRYPT_FAILED(EnterKeyCritSec(pVKey)))
            {
                goto Ret;
            }
            fKeyCritSec = TRUE;
        }
        else
        {
            if (RCRYPT_FAILED(BuildVKey(&pVKey, pVTable)))
            {
                goto Ret;
            }
            fBuiltKey = TRUE;
        }

        if (RCRYPT_FAILED(pVTable->FuncImportKey(pVTable->hProv, pbData,
                                                 dwDataLen,
                                                 (pVPublicKey == NULL ? 0 : pVPublicKey->hKey),
                                                 dwFlags, phKey)))
        {
            goto Ret;
        }

        if ((dwFlags & CRYPT_UPDATE_KEY) != CRYPT_UPDATE_KEY)
        {
            pVKey->hKey = *phKey;

            *phKey = (HCRYPTKEY) pVKey;

            pVKey->hProv = hProv;

            pVKey->Version = TABLEKEY;
        }
    }
    __except ( CapiExceptionFilter )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }

    fRet = CRYPT_SUCCEED;
Ret:
    if (fTableCritSec)
        LeaveProviderCritSec(pVTable);
    if (pVPublicKey != NULL)
    {
        if (fPubKeyCritSec)
            LeaveKeyCritSec(pVPublicKey);
    }
    if ((dwFlags & CRYPT_UPDATE_KEY) && fKeyCritSec)
    {
        LeaveKeyCritSec(pVKey);
    }
    else if ((CRYPT_SUCCEED != fRet) && fBuiltKey && pVKey)
    {
        LocalFree(pVKey);
    }

    return fRet;
}


/*
 -      CryptEncrypt
 -
 *      Purpose:
 *                Encrypt data
 *
 *
 *      Parameters:
 *               IN  hKey          -  Handle to the key
 *               IN  hHash         -  Optional handle to a hash
 *               IN  Final         -  Boolean indicating if this is the final
 *                                    block of plaintext
 *               IN  dwFlags       -  Flags values
 *               IN OUT pbData     -  Data to be encrypted
 *               IN OUT pdwDataLen -  Pointer to the length of the data to be
 *                                    encrypted
 *               IN dwBufLen       -  Size of Data buffer
 *
 *      Returns:
 */
WINADVAPI
BOOL
WINAPI CryptEncrypt(IN HCRYPTKEY hKey,
            IN HCRYPTHASH hHash,
            IN BOOL Final,
            IN DWORD dwFlags,
            IN OUT BYTE *pbData,
            IN OUT DWORD *pdwDataLen,
            IN DWORD dwBufLen)
{
    PVTableStruc    pVTable = NULL;
    PVKeyStruc      pVKey = NULL;
    PVHashStruc     pVHash = NULL;
    BOOL            fKeyCritSec = FALSE;
    BOOL            fTableCritSec = FALSE;
    BOOL            fHashCritSec = FALSE;
    BOOL            rt = CRYPT_FAILED;

    __try
    {
        pVKey = (PVKeyStruc) hKey;

        if (RCRYPT_FAILED(EnterKeyCritSec(pVKey)))
        {
            goto Ret;
        }
        fKeyCritSec = TRUE;

        pVTable = (PVTableStruc) pVKey->hProv;

        if (RCRYPT_FAILED(EnterProviderCritSec(pVTable)))
        {
            goto Ret;
        }
        fTableCritSec = TRUE;

        pVHash = (PVHashStruc) hHash;

        if (pVHash != NULL)
        {
            if (RCRYPT_FAILED(EnterHashCritSec(pVHash)))
            {
                goto Ret;
            }
            fHashCritSec = TRUE;
        }

        rt = (BOOL)pVKey->FuncEncrypt(pVTable->hProv, pVKey->hKey,
                                (pVHash == NULL ? 0 : pVHash->hHash),
                                Final, dwFlags, pbData,
                                pdwDataLen, dwBufLen);

    }
    __except ( CapiExceptionFilter )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }
Ret:
    if (fTableCritSec)
        LeaveProviderCritSec(pVTable);
    if (fKeyCritSec)
        LeaveKeyCritSec(pVKey);
    if (pVHash != NULL)
    {
        if (fHashCritSec)
            LeaveHashCritSec(pVHash);
    }
    return rt;

}


/*
 -      CryptDecrypt
 -
 *      Purpose:
 *                Decrypt data
 *
 *
 *      Parameters:
 *               IN  hKey          -  Handle to the key
 *               IN  hHash         -  Optional handle to a hash
 *               IN  Final         -  Boolean indicating if this is the final
 *                                    block of ciphertext
 *               IN  dwFlags       -  Flags values
 *               IN OUT pbData     -  Data to be decrypted
 *               IN OUT pdwDataLen -  Pointer to the length of the data to be
 *                                    decrypted
 *
 *      Returns:
 */
WINADVAPI
BOOL
WINAPI CryptDecrypt(IN HCRYPTKEY hKey,
                    IN HCRYPTHASH hHash,
                    IN BOOL Final,
                    IN DWORD dwFlags,
                    IN OUT BYTE *pbData,
                    IN OUT DWORD *pdwDataLen)

{
    PVTableStruc    pVTable = NULL;
    PVKeyStruc      pVKey = NULL;
    PVHashStruc     pVHash = NULL;
    BOOL            fKeyCritSec = FALSE;
    BOOL            fTableCritSec = FALSE;
    BOOL            fHashCritSec = FALSE;
    BOOL            rt = CRYPT_FAILED;

    __try
    {
        pVKey = (PVKeyStruc) hKey;

        if (RCRYPT_FAILED(EnterKeyCritSec(pVKey)))
        {
            goto Ret;
        }
        fKeyCritSec = TRUE;

        pVTable = (PVTableStruc) pVKey->hProv;

        if (RCRYPT_FAILED(EnterProviderCritSec(pVTable)))
        {
            goto Ret;
        }
        fTableCritSec = TRUE;

        pVHash = (PVHashStruc) hHash;

        if (pVHash != NULL)
        {
            if (RCRYPT_FAILED(EnterHashCritSec(pVHash)))
            {
                goto Ret;
            }
            fHashCritSec = TRUE;
        }

        rt = (BOOL)pVKey->FuncDecrypt(pVTable->hProv, pVKey->hKey,
                                (pVHash == NULL ? 0 : pVHash->hHash),
                                Final, dwFlags, pbData, pdwDataLen);
    }
    __except ( CapiExceptionFilter )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }
Ret:
    if (fTableCritSec)
        LeaveProviderCritSec(pVTable);
    if (fKeyCritSec)
        LeaveKeyCritSec(pVKey);
    if (pVHash != NULL)
    {
        if (fHashCritSec)
            LeaveHashCritSec(pVHash);
    }
    return(rt);
}


/*
 -      CryptCreateHash
 -
 *      Purpose:
 *                initate the hashing of a stream of data
 *
 *
 *      Parameters:
 *               IN  hProv   -  Handle to the user identifcation
 *               IN  Algid   -  Algorithm identifier of the hash algorithm
 *                              to be used
 *               IN  hKey    -  Optional key for MAC algorithms
 *               IN  dwFlags -  Flags values
 *               OUT pHash   -  Handle to hash object
 *
 *      Returns:
 */
WINADVAPI
BOOL
WINAPI CryptCreateHash(IN HCRYPTPROV hProv,
                       IN ALG_ID Algid,
                       IN HCRYPTKEY hKey,
                       IN DWORD dwFlags,
                       OUT HCRYPTHASH *phHash)
{
    PVTableStruc    pVTable = NULL;
    DWORD           bufsize;
    PVKeyStruc      pVKey = NULL;
    PVHashStruc     pVHash = NULL;
    BOOL            fTableCritSec = FALSE;
    BOOL            fKeyCritSec = FALSE;
    BOOL            fRet = CRYPT_FAILED;

    __try
    {
        pVTable = (PVTableStruc) hProv;

        if (RCRYPT_FAILED(EnterProviderCritSec(pVTable)))
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }
        fTableCritSec = TRUE;

        pVKey = (PVKeyStruc) hKey;

        if (pVKey != NULL)
        {
            if (RCRYPT_FAILED(EnterKeyCritSec(pVKey)))
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                goto Ret;
            }
            fKeyCritSec = TRUE;
        }

        bufsize = sizeof(VHashStruc);

        if (!BuildVHash(&pVHash, pVTable))
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto Ret;
        }

        if (RCRYPT_FAILED(pVTable->FuncCreateHash(pVTable->hProv, Algid,
                                                  (pVKey == NULL ? 0 : pVKey->hKey),
                                                  dwFlags, phHash)))
        {
            goto Ret;
        }

        pVHash->hHash = *phHash;

        *phHash = (HCRYPTHASH) pVHash;

        pVHash->Version = TABLEHASH;

        pVHash->Inuse = 1;
    }
    __except ( CapiExceptionFilter )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }

    fRet = CRYPT_SUCCEED;
Ret:
    if (fTableCritSec)
        LeaveProviderCritSec(pVTable);
    if (pVKey != NULL)
    {
        if (fKeyCritSec)
            LeaveKeyCritSec(pVKey);
    }
    if ((CRYPT_SUCCEED != fRet) && pVHash)
        LocalFree(pVHash);
    return fRet;
}


/*
 -      CryptDuplicateHash
 -
 *      Purpose:
 *                Duplicate a cryptographic hash
 *
 *
 *      Parameters:
 *               IN      hHash          -  Handle to the hash to be duplicated
 *               IN      pdwReserved    -  Reserved for later use
 *               IN      dwFlags        -  Flags values
 *               OUT     phHash         -  Handle to the new duplicate hash
 *
 *      Returns:
 */
WINADVAPI
BOOL
WINAPI CryptDuplicateHash(
                         IN HCRYPTHASH hHash,
                         IN DWORD *pdwReserved,
                         IN DWORD dwFlags,
                         OUT HCRYPTHASH * phHash
                         )
{
    PVTableStruc    pVTable = NULL;
    PVHashStruc     pVHash;
    PVHashStruc     pVNewHash = NULL;
    HCRYPTHASH      hNewHash;
    BOOL            fProvCritSecSet = FALSE;
    DWORD           dwErr = 0;
    BOOL            fRet = CRYPT_FAILED;

    __try
    {
        if (IsBadWritePtr(phHash, sizeof(HCRYPTHASH)))
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }
        pVHash = (PVHashStruc) hHash;

        if (pVHash->Version != TABLEHASH)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }

        if (NULL == pVHash->OptionalFuncDuplicateHash)
        {
            SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
            goto Ret;
        }

        pVTable = (PVTableStruc) pVHash->hProv;

        if (RCRYPT_FAILED(EnterProviderCritSec(pVTable)))
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }

        fProvCritSecSet = TRUE;


        if (RCRYPT_FAILED(BuildVHash(&pVNewHash, pVTable)))
        {
            goto Ret;
        }

        if (RCRYPT_FAILED(pVHash->OptionalFuncDuplicateHash(pVTable->hProv, pVHash->hHash,
                                                          pdwReserved, dwFlags, &hNewHash)))
        {
            goto Ret;
        }

        pVNewHash->hHash = hNewHash;

        pVNewHash->Version = TABLEHASH;

        pVNewHash->hProv = pVHash->hProv;

        pVHash->Inuse = 1;

        *phHash = (HCRYPTHASH) pVNewHash;
    }
    __except ( CapiExceptionFilter )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }

    fRet = CRYPT_SUCCEED;
Ret:
    if (CRYPT_SUCCEED != fRet)
        dwErr = GetLastError();
    if ((fRet == CRYPT_FAILED) && (NULL != pVNewHash))
        LocalFree(pVNewHash);
    if (fProvCritSecSet)
        LeaveProviderCritSec(pVTable);
    if (CRYPT_SUCCEED != fRet)
        SetLastError(dwErr);

    return fRet;
}

/*
 -      CryptHashData
 -
 *      Purpose:
 *                Compute the cryptograghic hash on a stream of data
 *
 *
 *      Parameters:
 *               IN  hHash     -  Handle to hash object
 *               IN  pbData    -  Pointer to data to be hashed
 *               IN  dwDataLen -  Length of the data to be hashed
 *               IN  dwFlags   -  Flags values
 *
 *
 *      Returns:
 */
WINADVAPI
BOOL
WINAPI CryptHashData(IN HCRYPTHASH hHash,
             IN CONST BYTE *pbData,
             IN DWORD dwDataLen,
             IN DWORD dwFlags)
{
    PVTableStruc    pVTable = NULL;
    PVHashStruc     pVHash = NULL;
    BOOL            fProvCritSec = FALSE;
    BOOL            fHashCritSec = FALSE;
    DWORD           dwErr = 0;
    BOOL            fRet = CRYPT_FAILED;

    __try
    {
        pVHash = (PVHashStruc) hHash;

        if (RCRYPT_FAILED(EnterHashCritSec(pVHash)))
        {
            goto Ret;
        }
        fHashCritSec = TRUE;

        pVTable = (PVTableStruc) pVHash->hProv;

        if (RCRYPT_FAILED(EnterProviderCritSec(pVTable)))
        {
            goto Ret;
        }
        fProvCritSec = TRUE;

        if (!pVHash->FuncHashData(pVTable->hProv,
                                  pVHash->hHash,
                                  pbData, dwDataLen, dwFlags))
            goto Ret;

    } __except ( CapiExceptionFilter )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }

    fRet = CRYPT_SUCCEED;
Ret:
    if (CRYPT_SUCCEED != fRet)
        dwErr = GetLastError();
    if (fHashCritSec)
        LeaveHashCritSec(pVHash);
    if (fProvCritSec)
        LeaveProviderCritSec(pVTable);
    if (CRYPT_SUCCEED != fRet)
        SetLastError(dwErr);

    return fRet;

}

/*
 -      CryptHashSessionKey
 -
 *      Purpose:
 *                Compute the cryptograghic hash on a key object
 *
 *
 *      Parameters:
 *               IN  hHash     -  Handle to hash object
 *               IN  hKey      -  Handle to a key object
 *               IN  dwFlags   -  Flags values
 *
 *      Returns:
 *               CRYPT_FAILED
 *               CRYPT_SUCCEED
 */
WINADVAPI
BOOL
WINAPI CryptHashSessionKey(IN HCRYPTHASH hHash,
                           IN  HCRYPTKEY hKey,
                           IN DWORD dwFlags)
{
    PVTableStruc    pVTable = NULL;
    PVHashStruc     pVHash = NULL;
    PVKeyStruc      pVKey = NULL;
    BOOL            fHashCritSec = FALSE;
    BOOL            fProvCritSec = FALSE;
    BOOL            fKeyCritSec = FALSE;
    BOOL            rt = CRYPT_FAILED;

    __try
    {
        pVHash = (PVHashStruc) hHash;

        if (RCRYPT_FAILED(EnterHashCritSec(pVHash)))
        {
            goto Ret;
        }
        fHashCritSec = TRUE;

        pVTable = (PVTableStruc) pVHash->hProv;

        if (RCRYPT_FAILED(EnterProviderCritSec(pVTable)))
        {
            goto Ret;
        }
        fProvCritSec = TRUE;

        pVKey = (PVKeyStruc) hKey;

        if (pVKey != NULL)
        {
            if (RCRYPT_FAILED(EnterKeyCritSec(pVKey)))
            {
                goto Ret;
            }
            fKeyCritSec = TRUE;
        }

        rt = (BOOL)pVHash->FuncHashSessionKey(pVTable->hProv,
                                        pVHash->hHash,
                                        pVKey->hKey,
                                        dwFlags);

    } __except ( CapiExceptionFilter )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }
Ret:
    if (fHashCritSec)
        LeaveHashCritSec(pVHash);
    if (fProvCritSec)
        LeaveProviderCritSec(pVTable);
    if (pVKey != NULL)
    {
        if (fKeyCritSec)
            LeaveKeyCritSec(pVKey);
    }
    return rt;
}


/*
 -      CryptDestoryHash
 -
 *      Purpose:
 *                Destory the hash object
 *
 *
 *      Parameters:
 *               IN  hHash     -  Handle to hash object
 *
 *      Returns:
 */
WINADVAPI
BOOL
WINAPI CryptDestroyHash(IN HCRYPTHASH hHash)
{
    PVTableStruc    pVTable = NULL;
    PVHashStruc     pVHash;
    BOOL            fProvCritSec = FALSE;
    BOOL            rt = CRYPT_FAILED;

    __try
    {
        pVHash = (PVHashStruc) hHash;

        if (pVHash->Version != TABLEHASH)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }

        if (0 < InterlockedDecrement((LPLONG)&pVHash->Inuse))
        {
            InterlockedIncrement((LPLONG)&pVHash->Inuse);
            SetLastError(ERROR_BUSY);
            goto Ret;
        }
        InterlockedIncrement((LPLONG)&pVHash->Inuse);

        pVTable = (PVTableStruc) pVHash->hProv;

        if (RCRYPT_FAILED(EnterProviderCritSec(pVTable)))
        {
            goto Ret;
        }
        fProvCritSec = TRUE;

        rt = (BOOL)pVHash->FuncDestroyHash(pVTable->hProv, pVHash->hHash);

        pVHash->Version = 0;
        LocalFree(pVHash);
    }
    __except ( CapiExceptionFilter )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }
Ret:
    if (fProvCritSec)
        LeaveProviderCritSec(pVTable);
    return rt;
}

WINADVAPI
BOOL
WINAPI LocalSignHashW(IN  HCRYPTHASH hHash,
                      IN  DWORD dwKeySpec,
                      IN  LPCWSTR sDescription,
                      IN  DWORD dwFlags,
                      OUT BYTE *pbSignature,
                      OUT DWORD *pdwSigLen)
{
    PVTableStruc    pVTable = NULL;
    PVHashStruc     pVHash = NULL;
    BOOL            fHashCritSec = FALSE;
    BOOL            fProvCritSec = FALSE;
    BOOL            rt = CRYPT_FAILED;

    __try
    {
        pVHash = (PVHashStruc) hHash;

        if (RCRYPT_FAILED(EnterHashCritSec(pVHash)))
        {
            goto Ret;
        }
        fHashCritSec = TRUE;

        pVTable = (PVTableStruc) pVHash->hProv;

        if (RCRYPT_FAILED(EnterProviderCritSec(pVTable)))
        {
            goto Ret;
        }
        fProvCritSec = TRUE;

        rt = (BOOL)pVHash->FuncSignHash(pVTable->hProv, pVHash->hHash,
                                  dwKeySpec,
                                  sDescription, dwFlags,
                                  pbSignature, pdwSigLen);
    }
    __except ( CapiExceptionFilter )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }
Ret:
    if (fHashCritSec)
        LeaveHashCritSec(pVHash);
    if (fProvCritSec)
        LeaveProviderCritSec(pVTable);
    return rt;

}


/*
 -      CryptSignHashW
 -
 *      Purpose:
 *                Create a digital signature from a hash
 *
 *
 *      Parameters:
 *               IN  hHash        -  Handle to hash object
 *               IN  dwKeySpec    -  Key pair that is used to sign with
 *                                   algorithm to be used
 *               IN  sDescription -  Description of data to be signed
 *               IN  dwFlags      -  Flags values
 *               OUT pbSignture   -  Pointer to signature data
 *               OUT pdwSigLen    -  Pointer to the len of the signature data
 *
 *      Returns:
 */
WINADVAPI
BOOL
WINAPI CryptSignHashW(IN  HCRYPTHASH hHash,
                      IN  DWORD dwKeySpec,
                      IN  LPCWSTR sDescription,
                      IN  DWORD dwFlags,
                      OUT BYTE *pbSignature,
                      OUT DWORD *pdwSigLen)
{
    return LocalSignHashW(hHash, dwKeySpec, sDescription,
                          dwFlags, pbSignature, pdwSigLen);
}

/*
 -      CryptSignHashA
 -
 *      Purpose:
 *                Create a digital signature from a hash
 *
 *
 *      Parameters:
 *               IN  hHash        -  Handle to hash object
 *               IN  dwKeySpec    -  Key pair that is used to sign with
 *                                   algorithm to be used
 *               IN  sDescription -  Description of data to be signed
 *               IN  dwFlags      -  Flags values
 *               OUT pbSignture   -  Pointer to signature data
 *               OUT pdwSigLen    -  Pointer to the len of the signature data
 *
 *      Returns:
 */
WINADVAPI
BOOL
WINAPI CryptSignHashA(IN  HCRYPTHASH hHash,
                      IN  DWORD dwKeySpec,
                      IN  LPCSTR sDescription,
                      IN  DWORD dwFlags,
                      OUT BYTE *pbSignature,
                      OUT DWORD *pdwSigLen)
{
    ANSI_STRING         AnsiString;
    UNICODE_STRING      UnicodeString;
    NTSTATUS            Status;
    BOOL                rt = CRYPT_FAILED;

    __try
    {
        memset(&AnsiString, 0, sizeof(AnsiString));
        memset(&UnicodeString, 0, sizeof(UnicodeString));

        if (NULL != sDescription)
        {
            RtlInitAnsiString(&AnsiString, sDescription);

            Status = RtlAnsiStringToUnicodeString(&UnicodeString, &AnsiString, TRUE);

            if ( !NT_SUCCESS(Status) )
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                goto Ret;
            }
        }

        rt = LocalSignHashW(hHash, dwKeySpec, UnicodeString.Buffer,
                            dwFlags, pbSignature, pdwSigLen);

        RtlFreeUnicodeString(&UnicodeString);
    } __except ( CapiExceptionFilter )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }
Ret:
    return rt;
}


WINADVAPI
BOOL
WINAPI LocalVerifySignatureW(IN HCRYPTHASH hHash,
                             IN CONST BYTE *pbSignature,
                             IN DWORD dwSigLen,
                             IN HCRYPTKEY hPubKey,
                             IN LPCWSTR sDescription,
                             IN DWORD dwFlags)
{
    PVTableStruc    pVTable = NULL;
    PVHashStruc     pVHash = NULL;
    PVKeyStruc      pVKey = NULL;
    BOOL            fHashCritSec = FALSE;
    BOOL            fProvCritSec = FALSE;
    BOOL            fKeyCritSec = FALSE;
    BOOL            rt = CRYPT_FAILED;

    __try
    {
        pVHash = (PVHashStruc) hHash;

        if (RCRYPT_FAILED(EnterHashCritSec(pVHash)))
        {
            goto Ret;
        }
        fHashCritSec = TRUE;

        pVTable = (PVTableStruc) pVHash->hProv;

        if (RCRYPT_FAILED(EnterProviderCritSec(pVTable)))
        {
            goto Ret;
        }
        fProvCritSec = TRUE;

        pVKey = (PVKeyStruc) hPubKey;

        if (RCRYPT_FAILED(EnterKeyCritSec(pVKey)))
        {
            goto Ret;
        }
        fKeyCritSec = TRUE;

        rt = (BOOL)pVHash->FuncVerifySignature(pVTable->hProv,
                        pVHash->hHash, pbSignature,
                        dwSigLen,
                        (pVKey == NULL ? 0 : pVKey->hKey),
                        sDescription, dwFlags);
    }
    __except ( CapiExceptionFilter )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }
Ret:
    if (fHashCritSec)
        LeaveHashCritSec(pVHash);
    if (fProvCritSec)
        LeaveProviderCritSec(pVTable);
    if (fKeyCritSec)
        LeaveKeyCritSec(pVKey);
    return rt;

}

/*
 -      CryptVerifySignatureW
 -
 *      Purpose:
 *                Used to verify a signature against a hash object
 *
 *
 *      Parameters:
 *               IN  hHash        -  Handle to hash object
 *               IN  pbSignture   -  Pointer to signature data
 *               IN  dwSigLen     -  Length of the signature data
 *               IN  hPubKey      -  Handle to the public key for verifying
 *                                   the signature
 *               IN  sDescription -  String describing the signed data
 *               IN  dwFlags      -  Flags values
 *
 *      Returns:
 */
WINADVAPI
BOOL
WINAPI CryptVerifySignatureW(IN HCRYPTHASH hHash,
                             IN CONST BYTE *pbSignature,
                             IN DWORD dwSigLen,
                             IN HCRYPTKEY hPubKey,
                             IN LPCWSTR sDescription,
                             IN DWORD dwFlags)
{
    return LocalVerifySignatureW(hHash, pbSignature, dwSigLen,
                                 hPubKey, sDescription, dwFlags);
}

/*
 -      CryptVerifySignatureA
 -
 *      Purpose:
 *                Used to verify a signature against a hash object
 *
 *
 *      Parameters:
 *               IN  hHash        -  Handle to hash object
 *               IN  pbSignture   -  Pointer to signature data
 *               IN  dwSigLen     -  Length of the signature data
 *               IN  hPubKey      -  Handle to the public key for verifying
 *                                   the signature
 *               IN  sDescription -  String describing the signed data
 *               IN  dwFlags      -  Flags values
 *
 *      Returns:
 */
WINADVAPI
BOOL
WINAPI CryptVerifySignatureA(IN HCRYPTHASH hHash,
                             IN CONST BYTE *pbSignature,
                             IN DWORD dwSigLen,
                             IN HCRYPTKEY hPubKey,
                             IN LPCSTR sDescription,
                             IN DWORD dwFlags)
{

    ANSI_STRING         AnsiString;
    UNICODE_STRING      UnicodeString;
    NTSTATUS            Status;
    BOOL                rt = CRYPT_FAILED;

    __try
    {
        memset(&AnsiString, 0, sizeof(AnsiString));
        memset(&UnicodeString, 0, sizeof(UnicodeString));

        if (NULL != sDescription)
        {
            RtlInitAnsiString(&AnsiString, sDescription);

            Status = RtlAnsiStringToUnicodeString(&UnicodeString, &AnsiString, TRUE);

            if ( !NT_SUCCESS(Status) )
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                goto Ret;
            }
        }

        rt = LocalVerifySignatureW(hHash, pbSignature, dwSigLen,
                                   hPubKey, UnicodeString.Buffer, dwFlags);

        RtlFreeUnicodeString(&UnicodeString);
    }
    __except ( CapiExceptionFilter )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }
Ret:
    return rt;
}

/*
 -      CryptSetProvParam
 -
 *      Purpose:
 *                Allows applications to customize various aspects of the
 *                operations of a provider
 *
 *      Parameters:
 *               IN      hProv   -  Handle to a provider
 *               IN      dwParam -  Parameter number
 *               IN      pbData  -  Pointer to data
 *               IN      dwFlags -  Flags values
 *
 *      Returns:
 */
WINADVAPI
BOOL
WINAPI CryptSetProvParam(IN HCRYPTPROV hProv,
                         IN DWORD dwParam,
                         IN CONST BYTE *pbData,
                         IN DWORD dwFlags)
{
    PVTableStruc    pVTable;
    BYTE            *pbTmp;
    CRYPT_DATA_BLOB *pBlob;
    BOOL            rt = CRYPT_FAILED;

    __try
    {
        if (dwParam == PP_CLIENT_HWND)
        {
            hWnd = *((HWND *) pbData);
            rt = CRYPT_SUCCEED;
            goto Ret;
        }
        else if (dwParam == PP_CONTEXT_INFO)
        {
            pBlob = (CRYPT_DATA_BLOB*)pbData;

            // allocate space for the new context info
            if (NULL == (pbTmp = (BYTE*)LocalAlloc(LMEM_ZEROINIT, pBlob->cbData)))
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                goto Ret;
            }
            memcpy(pbTmp, pBlob->pbData, pBlob->cbData);

            // free any previously allocated context info
            if (NULL != pbContextInfo)
            {
                LocalFree(pbContextInfo);
            }
            cbContextInfo = pBlob->cbData;
            pbContextInfo = pbTmp;

            rt = CRYPT_SUCCEED;
            goto Ret;
        }

        pVTable = (PVTableStruc) hProv;

        if (pVTable->Version != TABLEPROV)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }

        if (0 < InterlockedDecrement((LPLONG)&pVTable->Inuse))
        {
            InterlockedIncrement((LPLONG)&pVTable->Inuse);
            SetLastError(ERROR_BUSY);
            goto Ret;
        }
        InterlockedIncrement((LPLONG)&pVTable->Inuse);

        rt = (BOOL)pVTable->FuncSetProvParam(pVTable->hProv, dwParam, pbData,
                                       dwFlags);
    }
    __except ( CapiExceptionFilter )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }
Ret:
    return(rt);
}


/*
 -      CryptGetProvParam
 -
 *      Purpose:
 *                Allows applications to get various aspects of the
 *                operations of a provider
 *
 *      Parameters:
 *               IN      hProv      -  Handle to a proivder
 *               IN      dwParam    -  Parameter number
 *               IN      pbData     -  Pointer to data
 *               IN      pdwDataLen -  Length of parameter data
 *               IN      dwFlags    -  Flags values
 *
 *      Returns:
 */
WINADVAPI
BOOL
WINAPI CryptGetProvParam(IN HCRYPTPROV hProv,
                         IN DWORD dwParam,
                         IN BYTE *pbData,
                         IN DWORD *pdwDataLen,
                         IN DWORD dwFlags)
{
    PVTableStruc    pVTable = NULL;
    BOOL            fProvCritSec = FALSE;
    BOOL            rt = CRYPT_FAILED;

    __try
    {
        pVTable = (PVTableStruc) hProv;

        if (RCRYPT_FAILED(EnterProviderCritSec(pVTable)))
        {
            goto Ret;
        }
        fProvCritSec = TRUE;

        rt = (BOOL)pVTable->FuncGetProvParam(pVTable->hProv, dwParam, pbData,
                                       pdwDataLen, dwFlags);
    }
    __except ( CapiExceptionFilter )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }
Ret:
    if (fProvCritSec)
        LeaveProviderCritSec(pVTable);
    return rt;
}


/*
 -      CryptSetHashParam
 -
 *      Purpose:
 *                Allows applications to customize various aspects of the
 *                operations of a hash
 *
 *      Parameters:
 *               IN      hHash   -  Handle to a hash
 *               IN      dwParam -  Parameter number
 *               IN      pbData  -  Pointer to data
 *               IN      dwFlags -  Flags values
 *
 *      Returns:
 */
WINADVAPI
BOOL
WINAPI CryptSetHashParam(IN HCRYPTHASH hHash,
                         IN DWORD dwParam,
                         IN CONST BYTE *pbData,
                         IN DWORD dwFlags)
{
    PVTableStruc    pVTable = NULL;
    PVHashStruc     pVHash;
    BOOL            fProvCritSec = FALSE;
    BOOL            rt = CRYPT_FAILED;

    __try
    {
        pVHash = (PVHashStruc) hHash;

        if (pVHash->Version != TABLEHASH)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }

        if (0 < InterlockedDecrement((LPLONG)&pVHash->Inuse))
        {
            InterlockedIncrement((LPLONG)&pVHash->Inuse);
            SetLastError(ERROR_BUSY);
            goto Ret;
        }
        InterlockedIncrement((LPLONG)&pVHash->Inuse);

        pVTable = (PVTableStruc) pVHash->hProv;

        if (RCRYPT_FAILED(EnterProviderCritSec(pVTable)))
        {
            goto Ret;
        }
        fProvCritSec = TRUE;

        rt = (BOOL)pVHash->FuncSetHashParam(pVTable->hProv, pVHash->hHash,
                                      dwParam, pbData, dwFlags);
    }
    __except ( CapiExceptionFilter )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }
Ret:
    if (fProvCritSec)
        LeaveProviderCritSec(pVTable);
    return rt;
}


/*
 -      CryptGetHashParam
 -
 *      Purpose:
 *                Allows applications to get various aspects of the
 *                operations of a hash
 *
 *      Parameters:
 *               IN      hHash      -  Handle to a hash
 *               IN      dwParam    -  Parameter number
 *               IN      pbData     -  Pointer to data
 *               IN      pdwDataLen -  Length of parameter data
 *               IN      dwFlags    -  Flags values
 *
 *      Returns:
 */
WINADVAPI
BOOL
WINAPI CryptGetHashParam(IN HCRYPTKEY hHash,
                         IN DWORD dwParam,
                         IN BYTE *pbData,
                         IN DWORD *pdwDataLen,
                         IN DWORD dwFlags)
{
    PVTableStruc    pVTable = NULL;
    PVHashStruc     pVHash = NULL;
    BOOL            fHashCritSec = FALSE;
    BOOL            fProvCritSec = FALSE;
    BOOL            rt = CRYPT_FAILED;

    __try
    {
        pVHash = (PVHashStruc) hHash;

        if (RCRYPT_FAILED(EnterHashCritSec(pVHash)))
        {
            goto Ret;
        }
        fHashCritSec = TRUE;

        pVTable = (PVTableStruc) pVHash->hProv;

        if (RCRYPT_FAILED(EnterProviderCritSec(pVTable)))
        {
            goto Ret;
        }
        fProvCritSec = TRUE;

        rt = (BOOL)pVHash->FuncGetHashParam(pVTable->hProv, pVHash->hHash,
                                      dwParam, pbData, pdwDataLen,
                                      dwFlags);
    }
    __except ( CapiExceptionFilter )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }
Ret:
    if (fHashCritSec)
        LeaveHashCritSec(pVHash);
    if (fProvCritSec)
        LeaveProviderCritSec(pVTable);
    return rt;

}

/*
 -      CryptSetProviderW
 -
 *      Purpose:
 *                Set a cryptography provider
 *
 *
 *      Parameters:
 *
 *                IN  pszProvName    - Name of the provider to install
 *                IN  dwProvType     - Type of the provider to install
 *
 *      Returns:
 *               BOOL
 *               Use get extended error information use GetLastError
 */
WINADVAPI
BOOL
WINAPI CryptSetProviderW(IN LPCWSTR pszProvName,
                         IN DWORD dwProvType)

{
    ANSI_STRING         AnsiString;
    UNICODE_STRING      UnicodeString;
    NTSTATUS            Status;
    BOOL                rt = FALSE;

    __try
    {
        RtlInitUnicodeString(&UnicodeString, pszProvName);

        Status = RtlUnicodeStringToAnsiString(&AnsiString, &UnicodeString, TRUE);

        if (!NT_SUCCESS(Status))
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto Ret;
        }

        rt = CryptSetProviderA((LPCSTR) AnsiString.Buffer,
                               dwProvType);

        RtlFreeAnsiString(&AnsiString);
    }
    __except ( CapiExceptionFilter )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }
Ret:
    return(rt);
}

/*
 -      CryptSetProviderA
 -
 *      Purpose:
 *                Set a cryptography provider
 *
 *
 *      Parameters:
 *
 *                IN  pszProvName    - Name of the provider to install
 *                IN  dwProvType     - Type of the provider to install
 *
 *      Returns:
 *               BOOL
 *               Use get extended error information use GetLastError
 */
WINADVAPI
BOOL
WINAPI CryptSetProviderA(IN LPCSTR pszProvName,
                         IN DWORD  dwProvType)
{
    BOOL        fRet = CRYPT_FAILED;
    LPSTR       pszCurrent = NULL;
    DWORD       cbCurrent = 0;

    __try
    {
        if (dwProvType == 0 || dwProvType > 999 || pszProvName == NULL)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }

        //
        // We don't support setting the user default provider any more.  See
        // if the current default provider of the specified type matches the
        // caller's.  If it does, we'll let the call "succeed".
        //

        if (! CryptGetDefaultProvider(
            dwProvType,
            NULL,
            CRYPT_MACHINE_DEFAULT,
            NULL,
            &cbCurrent))
        {
            goto Ret;
        }

        pszCurrent = (LPSTR) HeapAlloc(
            GetProcessHeap(), HEAP_ZERO_MEMORY, cbCurrent);

        if (NULL == pszCurrent)
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto Ret;
        }

        if (! CryptGetDefaultProvider(
            dwProvType,
            NULL,
            CRYPT_MACHINE_DEFAULT,
            pszCurrent,
            &cbCurrent))
        {
            goto Ret;
        }

        if (0 != strcmp(pszProvName, pszCurrent))
        {
            SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
            goto Ret;
        }
    }
    __except ( CapiExceptionFilter )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }

    fRet = CRYPT_SUCCEED;

Ret:

    if (pszCurrent)
        HeapFree(GetProcessHeap(), 0, pszCurrent);

    return fRet;
}

/*
 -      CryptSetProviderExW
 -
 *      Purpose:
 *                Set the cryptographic provider as the default
 *                either for machine or for user.
 *
 *
 *      Parameters:
 *
 *                IN  pszProvName    - Name of the provider to install
 *                IN  dwProvType     - Type of the provider to install
 *                IN  pdwReserved    - Reserved for future use
 *                IN  dwFlags        - Flags parameter (for machine or for user)
 *
 *
 *      Returns:
 *               BOOL
 *               Use get extended error information use GetLastError
 */
WINADVAPI
BOOL
WINAPI CryptSetProviderExW(
                         IN LPCWSTR pszProvName,
                         IN DWORD dwProvType,
                         IN DWORD *pdwReserved,
                         IN DWORD dwFlags
                         )
{
    ANSI_STRING         AnsiString;
    UNICODE_STRING      UnicodeString;
    NTSTATUS            Status;
    BOOL                fRet = CRYPT_FAILED;

    __try
    {
        RtlInitUnicodeString(&UnicodeString, pszProvName);

        Status = RtlUnicodeStringToAnsiString(&AnsiString, &UnicodeString, TRUE);

        if (!NT_SUCCESS(Status))
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto Ret;
        }

        fRet = CryptSetProviderExA((LPCSTR) AnsiString.Buffer,
                                 dwProvType,
                                 pdwReserved,
                                 dwFlags);

        RtlFreeAnsiString(&AnsiString);
    }
    __except ( CapiExceptionFilter )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }

Ret:
    return fRet;
}

/*
 -      CryptSetProviderExA
 -
 *      Purpose:
 *                Set the cryptographic provider as the default
 *                either for machine or for user.
 *
 *
 *      Parameters:
 *
 *                IN  pszProvName    - Name of the provider to install
 *                IN  dwProvType     - Type of the provider to install
 *                IN  pdwReserved    - Reserved for future use
 *                IN  dwFlags        - Flags parameter (for machine or for user)
 *
 *      Returns:
 *               BOOL
 *               Use get extended error information use GetLastError
 */
WINADVAPI
BOOL
WINAPI CryptSetProviderExA(
                           IN LPCSTR pszProvName,
                           IN DWORD dwProvType,
                           IN DWORD *pdwReserved,
                           IN DWORD dwFlags
                           )
{
    HKEY        hCurrUser = 0;
    HKEY        hRegKey = 0;
    LONG        err;
    DWORD       dwDisp;
    DWORD       cbValue;
    CHAR        *pszValue = NULL;
    CHAR        *pszFullName = NULL;
    DWORD       cbFullName;
    CHAR        typebuf[9] = {0, 0, 0, 0, 0, 0, 0, 0, 0};
    DWORD       dwKeyType;
    DWORD       dw;
    DWORD       cbProvType;
    BOOL        fRet = CRYPT_FAILED;

    __try
    {
        if ((dwProvType == 0) || (dwProvType > 999) ||
            (pszProvName == NULL) || (pdwReserved != NULL))
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }

        if ((dwFlags & ~(CRYPT_MACHINE_DEFAULT | CRYPT_USER_DEFAULT | CRYPT_DELETE_DEFAULT)) ||
            ((dwFlags & CRYPT_MACHINE_DEFAULT) && (dwFlags & CRYPT_USER_DEFAULT)))
        {
            SetLastError((DWORD)NTE_BAD_FLAGS);
            goto Ret;
        }

        cbValue = strlen(pszProvName);

        // check if the CSP has been installed
        cbFullName = cbValue + sizeof(szenumproviders) + sizeof(CHAR);

        if (NULL == (pszFullName = (CHAR *) LocalAlloc(LMEM_ZEROINIT, cbFullName)))
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto Ret;
        }

        strcpy(pszFullName, szenumproviders);
        pszFullName[sizeof(szenumproviders) - 1] = '\\';
        strcpy(pszFullName + sizeof(szenumproviders), pszProvName);

        if ((err = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                        (const char *) pszFullName,
                        0L, KEY_READ, &hRegKey)) != ERROR_SUCCESS)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }

        cbProvType = sizeof(dw);
        if (ERROR_SUCCESS != (err = RegQueryValueEx(hRegKey,
                                                    (const char *) "Type",
                                                    NULL, &dwKeyType, (BYTE*)&dw,
                                                    &cbProvType)))
        {
            SetLastError(err);
            goto Ret;
        }
        if (dwProvType != dw)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }

        if (ERROR_SUCCESS != (err = RegCloseKey(hRegKey)))
        {
            SetLastError(err);
            goto Ret;
        }
        hRegKey = NULL;

        if (dwFlags & CRYPT_MACHINE_DEFAULT)
        {
            if ((pszValue = (CHAR *) LocalAlloc(LMEM_ZEROINIT,
                            strlen(szmachinetype) + 5 + 1)) == NULL)
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                goto Ret;
            }

            strcpy(pszValue, szmachinetype);
            __ltoa(dwProvType, typebuf);
            strcat(pszValue, &typebuf[5]);

            if ((err = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                            (const char *) pszValue,
                            0L, NULL, REG_OPTION_NON_VOLATILE,
                            KEY_READ | KEY_WRITE, NULL, &hRegKey, &dwDisp)) != ERROR_SUCCESS)
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                goto Ret;
            }

            // check the delete flag
            if (dwFlags & CRYPT_DELETE_DEFAULT)
            {
                if (ERROR_SUCCESS != (err = RegDeleteValue(hRegKey, "Name")))
                {
                    SetLastError(err);
                    goto Ret;
                }
                fRet = CRYPT_SUCCEED;
                goto Ret;
            }
        }
        else if (dwFlags & CRYPT_USER_DEFAULT)
        {
            if (dwFlags & CRYPT_DELETE_DEFAULT)
            {
                if ((pszValue = (CHAR *) LocalAlloc(LMEM_ZEROINIT,
                                strlen(szusertype) + 5 + 1)) == NULL)
                {
                    SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                    goto Ret;
                }
    
                strcpy(pszValue, szusertype);
                __ltoa(dwProvType, typebuf);
                strcat(pszValue, &typebuf[5]);
    
                if (!NT_SUCCESS(RtlOpenCurrentUser(KEY_READ | KEY_WRITE, &hCurrUser)))
                {
                    SetLastError(ERROR_INVALID_PARAMETER);
                    goto Ret;
                }

                if (ERROR_SUCCESS != (err = RegDeleteKey(hCurrUser, 
                                                         (const char *)pszValue)))
                {
                    NtClose(hCurrUser);
                    SetLastError(err);
                    goto Ret;
                }

                fRet = CRYPT_SUCCEED;
                NtClose(hCurrUser);
                goto Ret;
            }
            else
            {
                // The User flag is set, but Delete is not.  Handle this case
                // in CryptSetProvider.
                fRet = CryptSetProviderA(pszProvName, dwProvType);
                goto Ret;
            }
        }

        if (ERROR_SUCCESS != (err = RegSetValueEx(hRegKey, "Name", 0L, REG_SZ,
                                                  (const LPBYTE) pszProvName, cbValue)))
        {
            SetLastError(err);
            goto Ret;
        }
    }
    __except ( CapiExceptionFilter )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }

    fRet = CRYPT_SUCCEED;
Ret:
    if (pszFullName)
        LocalFree(pszFullName);
    if (pszValue)
        LocalFree(pszValue);
    if (hRegKey)
        RegCloseKey(hRegKey);
    return fRet;
}

/*
 -      CryptGetDefaultProviderW
 -
 *      Purpose:
 *                Get the default cryptographic provider of the specified
 *                type for either the machine or for the user.
 *
 *      Parameters:
 *                IN  dwProvType     - Type of the provider to install
 *                IN  pdwReserved    - Reserved for future use
 *                IN  dwFlags        - Flags parameter (for machine or for user)
 *                OUT pszProvName    - Name of the default provider
 *                IN OUT pcbProvName - Length in bytes of the provider name
 *
 *
 *      Returns:
 *               BOOL
 *               Use get extended error information use GetLastError
 */
WINADVAPI
BOOL
WINAPI CryptGetDefaultProviderW(
                                IN DWORD dwProvType,
                                IN DWORD *pdwReserved,
                                IN DWORD dwFlags,
                                OUT LPWSTR pszProvName,
                                IN OUT DWORD *pcbProvName
                                )
{
    ANSI_STRING         AnsiString;
    UNICODE_STRING      UnicodeString;
    LPSTR               pszName = NULL;
    DWORD               cbName;
    NTSTATUS            Status;
    BOOL                fRet = CRYPT_FAILED;

    memset(&UnicodeString, 0, sizeof(UnicodeString));

    __try
    {
        memset(&AnsiString, 0, sizeof(AnsiString));

        if (!CryptGetDefaultProviderA(dwProvType,
                                      pdwReserved,
                                      dwFlags,
                                      NULL,
                                      &cbName))
            goto Ret;

        if (NULL == (pszName = LocalAlloc(LMEM_ZEROINIT, cbName)))
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto Ret;
        }

        if (!CryptGetDefaultProviderA(dwProvType,
                                      pdwReserved,
                                      dwFlags,
                                      pszName,
                                      &cbName))
            goto Ret;

        RtlInitAnsiString(&AnsiString, pszName);

        Status = RtlAnsiStringToUnicodeString(&UnicodeString, &AnsiString, TRUE);
        if (!NT_SUCCESS(Status))
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto Ret;
        }

        if (NULL == pszProvName)
        {
            *pcbProvName = UnicodeString.Length + sizeof(WCHAR);
            fRet = CRYPT_SUCCEED;
            goto Ret;
        }

        if (*pcbProvName < UnicodeString.Length + sizeof(WCHAR))
        {
            *pcbProvName = UnicodeString.Length + sizeof(WCHAR);
            SetLastError(ERROR_MORE_DATA);
            goto Ret;
        }

        *pcbProvName = UnicodeString.Length + sizeof(WCHAR);
        memset(pszProvName, 0, *pcbProvName);
        memcpy(pszProvName, UnicodeString.Buffer, UnicodeString.Length);
    }
    __except ( CapiExceptionFilter )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }

    fRet = CRYPT_SUCCEED;
Ret:
    if (UnicodeString.Buffer)
        RtlFreeUnicodeString(&UnicodeString);
    if (pszName)
        LocalFree(pszName);
    return fRet;
}

/*
 -      CryptGetDefaultProviderA
 -
 *      Purpose:
 *                Get the default cryptographic provider of the specified
 *                type for either the machine or for the user.
 *
 *
 *      Parameters:
 *                IN  dwProvType     - Type of the provider to install
 *                IN  pdwReserved    - Reserved for future use
 *                IN  dwFlags        - Flags parameter (for machine or for user)
 *                OUT pszProvName    - Name of the default provider
 *                IN OUT pcbProvName - Length in bytes of the provider name
 *                                     including the NULL terminator
 *
 *      Returns:
 *               BOOL
 *               Use get extended error information use GetLastError
 */
WINAPI CryptGetDefaultProviderA(
                                IN DWORD dwProvType,
                                IN DWORD *pdwReserved,
                                IN DWORD dwFlags,
                                OUT LPSTR pszProvName,
                                IN OUT DWORD *pcbProvName
                                )
{
    HKEY        hRegKey = 0;
    LONG        err;
    CHAR        *pszValue = NULL;
    DWORD       dwValType;
    CHAR        typebuf[9] = {0, 0, 0, 0, 0, 0, 0, 0, 0};
    DWORD       cbProvName = 0;
    BOOL        fRet = CRYPT_FAILED;

    __try
    {
        if (dwProvType == 0 || dwProvType > 999 || pdwReserved != NULL)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }

        if ((dwFlags & ~(CRYPT_MACHINE_DEFAULT | CRYPT_USER_DEFAULT)) ||
            ((dwFlags & CRYPT_MACHINE_DEFAULT) && (dwFlags & CRYPT_USER_DEFAULT)))
        {
            SetLastError((DWORD)NTE_BAD_FLAGS);
            goto Ret;
        }

        //
        // We no longer look for a User default, but instead treat the USER_
        // and MACHINE_ flags as identical, and only look in HKLM.
        //
        
        if ((pszValue = (CHAR *) LocalAlloc(LMEM_ZEROINIT,
                        strlen(szmachinetype) + 5 + 1)) == NULL)
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto Ret;
        }

        strcpy(pszValue, szmachinetype);
        __ltoa(dwProvType, typebuf);
        strcat(pszValue, &typebuf[5]);

        if ((err = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                        (const char *) pszValue,
                        0L, KEY_READ, &hRegKey)) != ERROR_SUCCESS)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }

        if ((err = RegQueryValueEx(hRegKey, "Name", 0L, &dwValType,
                        NULL,
                        &cbProvName)) != ERROR_SUCCESS)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }

        if (NULL == pszProvName)
        {
            *pcbProvName = cbProvName;
            fRet = CRYPT_SUCCEED;
            goto Ret;
        }

        if (cbProvName > *pcbProvName)
        {
            *pcbProvName = cbProvName;
            SetLastError(ERROR_MORE_DATA);
            goto Ret;
        }

        if ((err = RegQueryValueEx(hRegKey, "Name", 0L, &dwValType,
                        (BYTE*)pszProvName,
                        &cbProvName)) != ERROR_SUCCESS)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }
        *pcbProvName = cbProvName;
    }
    __except ( CapiExceptionFilter )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }

    fRet = CRYPT_SUCCEED;

Ret:
    if (hRegKey)
        RegCloseKey(hRegKey);
    if (pszValue)
        LocalFree(pszValue);
    return fRet;
}

/*
 -      CryptEnumProviderTypesW
 -
 *      Purpose:
 *                Enumerate the provider types.
 *
 *      Parameters:
 *                IN  dwIndex        - Index to the provider types to enumerate
 *                IN  pdwReserved    - Reserved for future use
 *                IN  dwFlags        - Flags parameter
 *                OUT pdwProvType    - Pointer to the provider type
 *                OUT pszTypeName    - Name of the enumerated provider type
 *                IN OUT pcbTypeName - Length of the enumerated provider type
 *
 *      Returns:
 *               BOOL
 *               Use get extended error information use GetLastError
 */
WINADVAPI
BOOL
WINAPI CryptEnumProviderTypesW(
                               IN DWORD dwIndex,
                               IN DWORD *pdwReserved,
                               IN DWORD dwFlags,
                               OUT DWORD *pdwProvType,
                               OUT LPWSTR pszTypeName,
                               IN OUT DWORD *pcbTypeName
                               )
{
    ANSI_STRING     AnsiString;
    UNICODE_STRING  UnicodeString;
    LPSTR           pszTmpTypeName = NULL;
    DWORD           cbTmpTypeName = 0;
    NTSTATUS        Status;
    BOOL            fRet = CRYPT_FAILED;

    memset(&UnicodeString, 0, sizeof(UnicodeString));

    __try
    {
        memset(&AnsiString, 0, sizeof(AnsiString));

        if (!CryptEnumProviderTypesA(dwIndex,
                                     pdwReserved,
                                     dwFlags,
                                     pdwProvType,
                                     NULL,
                                     &cbTmpTypeName))
            goto Ret;

        if (NULL == (pszTmpTypeName = LocalAlloc(LMEM_ZEROINIT, cbTmpTypeName)))
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto Ret;
        }

        if (!CryptEnumProviderTypesA(dwIndex,
                                     pdwReserved,
                                     dwFlags,
                                     pdwProvType,
                                     pszTmpTypeName,
                                     &cbTmpTypeName))
            goto Ret;

        if (0 != cbTmpTypeName)
        {
            RtlInitAnsiString(&AnsiString, pszTmpTypeName);

            Status = RtlAnsiStringToUnicodeString(&UnicodeString, &AnsiString, TRUE);
            if ( !NT_SUCCESS(Status))
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                goto Ret;
            }

            // check if caller is asking for length, in addition the name of the provider
            // may not be available, in this case a name length of 0 is returned
            if ((NULL == pszTypeName) || (0 == cbTmpTypeName))
            {
                *pcbTypeName = UnicodeString.Length + sizeof(WCHAR);
                fRet = CRYPT_SUCCEED;
                goto Ret;
            }

            if (*pcbTypeName < UnicodeString.Length + sizeof(WCHAR))
            {
                *pcbTypeName = UnicodeString.Length + sizeof(WCHAR);
                SetLastError(ERROR_MORE_DATA);
                goto Ret;
            }

            *pcbTypeName = UnicodeString.Length + sizeof(WCHAR);
            memset(pszTypeName, 0, *pcbTypeName);
            memcpy(pszTypeName, UnicodeString.Buffer, UnicodeString.Length);
        }
    }
    __except ( CapiExceptionFilter )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }

    fRet = CRYPT_SUCCEED;
Ret:
    if (UnicodeString.Buffer)
        RtlFreeUnicodeString(&UnicodeString);
    if (pszTmpTypeName)
        LocalFree(pszTmpTypeName);
    return fRet;
}

/*
 -      CryptEnumProviderTypesA
 -
 *      Purpose:
 *                Enumerate the provider types.
 *
 *      Parameters:
 *                IN  dwIndex        - Index to the provider types to enumerate
 *                IN  pdwReserved    - Reserved for future use
 *                IN  dwFlags        - Flags parameter
 *                OUT pdwProvType    - Pointer to the provider type
 *                OUT pszTypeName    - Name of the enumerated provider type
 *                IN OUT pcbTypeName - Length of the enumerated provider type
 *
 *      Returns:
 *               BOOL
 *               Use get extended error information use GetLastError
 */
WINADVAPI
BOOL
WINAPI CryptEnumProviderTypesA(
                               IN DWORD dwIndex,
                               IN DWORD *pdwReserved,
                               IN DWORD dwFlags,
                               OUT DWORD *pdwProvType,
                               OUT LPSTR pszTypeName,
                               IN OUT DWORD *pcbTypeName
                               )
{
    HKEY        hRegKey = 0;
    HKEY        hTypeKey = 0;
    LONG        err;
    CHAR        *pszRegKeyName = NULL;
    DWORD       cbClass;
    FILETIME    ft;
    CHAR        rgcType[] = {'T', 'y', 'p', 'e', ' '};
    LPSTR       pszValue;
    long        Type;
    DWORD       cSubKeys;
    DWORD       cbMaxKeyName;
    DWORD       cbMaxClass;
    DWORD       cValues;
    DWORD       cbMaxValName;
    DWORD       cbMaxValData;
    DWORD       cbTmpTypeName = 0;
    DWORD       dwValType;
    BOOL        fRet = CRYPT_FAILED;

    __try
    {
        if (NULL != pdwReserved)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }

        if (0 != dwFlags)
        {
            SetLastError((DWORD)NTE_BAD_FLAGS);
            goto Ret;
        }

        if (ERROR_SUCCESS != (err = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                                 (const char *) szprovidertypes,
                                                 0L,
                                                 KEY_READ,
                                                 &hRegKey)))
        {
            SetLastError((DWORD)NTE_FAIL);
            goto Ret;
        }

        if (ERROR_SUCCESS != (err = RegQueryInfoKey(hRegKey,
                                                    NULL,
                                                    NULL,
                                                    NULL,
                                                    &cSubKeys,
                                                    &cbMaxKeyName,
                                                    &cbMaxClass,
                                                    &cValues,
                                                    &cbMaxValName,
                                                    &cbMaxValData,
                                                    NULL,
                                                    &ft)))
        {
            SetLastError((DWORD)NTE_FAIL);
            goto Ret;
        }
        cbMaxKeyName += sizeof(CHAR);

        if (NULL == (pszRegKeyName = LocalAlloc(LMEM_ZEROINIT, cbMaxKeyName)))
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto Ret;
        }

        if (ERROR_SUCCESS != (err = RegEnumKeyEx(hRegKey,
                                                 dwIndex, pszRegKeyName, &cbMaxKeyName, NULL,
                                                 NULL, &cbClass, &ft)))
        {
            if (ERROR_NO_MORE_ITEMS == err)
            {
                SetLastError((DWORD)err);
            }
            else
            {
                SetLastError((DWORD)NTE_FAIL);
            }
            goto Ret;
        }

        if (memcmp(pszRegKeyName, rgcType, sizeof(rgcType)))
        {
            SetLastError((DWORD)NTE_FAIL);
            goto Ret;
        }
        pszValue = pszRegKeyName + sizeof(rgcType);

        if (0 == (Type = atol(pszValue)))
        {
            SetLastError((DWORD)NTE_FAIL);
            goto Ret;
        }
        *pdwProvType = (DWORD)Type;

        // check for the type name
        if (ERROR_SUCCESS != (err = RegOpenKeyEx(hRegKey,
                                                 (const char *)pszRegKeyName,
                                                 0L,
                                                 KEY_READ,
                                                 &hTypeKey)))
        {
            SetLastError((DWORD)NTE_FAIL);
            goto Ret;
        }

        if ((err = RegQueryValueEx(hTypeKey, "TypeName", 0L, &dwValType,
                        NULL, &cbTmpTypeName)) != ERROR_SUCCESS)
        {
            fRet = CRYPT_SUCCEED;
            goto Ret;
        }

        if (NULL == pszTypeName)
        {
            *pcbTypeName = cbTmpTypeName;
            fRet = CRYPT_SUCCEED;
            goto Ret;
        }
        else if (*pcbTypeName < cbTmpTypeName)
        {
            *pcbTypeName = cbTmpTypeName;
            SetLastError(ERROR_MORE_DATA);
            goto Ret;
        }

        if ((err = RegQueryValueEx(hTypeKey, "TypeName", 0L, &dwValType,
                        (BYTE*)pszTypeName, &cbTmpTypeName)) != ERROR_SUCCESS)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }
        *pcbTypeName = cbTmpTypeName;
    }
    __except ( CapiExceptionFilter )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }

    fRet = CRYPT_SUCCEED;
Ret:
    if (hRegKey)
        RegCloseKey(hRegKey);
    if (hTypeKey)
        RegCloseKey(hTypeKey);
    if (pszRegKeyName)
        LocalFree(pszRegKeyName);
    return fRet;
}

/*
 -      CryptEnumProvidersW
 -
 *      Purpose:
 *                Enumerate the providers.
 *
 *      Parameters:
 *                IN  dwIndex        - Index to the providers to enumerate
 *                IN  pdwReserved    - Reserved for future use
 *                IN  dwFlags        - Flags parameter
 *                OUT pdwProvType    - The type of the provider
 *                OUT pszProvName    - Name of the enumerated provider
 *                IN OUT pcbProvName - Length of the enumerated provider
 *
 *      Returns:
 *               BOOL
 *               Use get extended error information use GetLastError
 */
WINADVAPI
BOOL
WINAPI CryptEnumProvidersW(
                           IN DWORD dwIndex,
                           IN DWORD *pdwReserved,
                           IN DWORD dwFlags,
                           OUT DWORD *pdwProvType,
                           OUT LPWSTR pszProvName,
                           IN OUT DWORD *pcbProvName
                           )
{
    ANSI_STRING     AnsiString;
    UNICODE_STRING  UnicodeString;
    LPSTR           pszTmpProvName = NULL;
    DWORD           cbTmpProvName;
    NTSTATUS        Status;
    BOOL            fRet = CRYPT_FAILED;

    memset(&UnicodeString, 0, sizeof(UnicodeString));

    __try
    {
        memset(&AnsiString, 0, sizeof(AnsiString));

        if (!CryptEnumProvidersA(dwIndex,
                                 pdwReserved,
                                 dwFlags,
                                 pdwProvType,
                                 NULL,
                                 &cbTmpProvName))
            goto Ret;

        if (NULL == (pszTmpProvName = LocalAlloc(LMEM_ZEROINIT, cbTmpProvName)))
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto Ret;
        }

        if (!CryptEnumProvidersA(dwIndex,
                                 pdwReserved,
                                 dwFlags,
                                 pdwProvType,
                                 pszTmpProvName,
                                 &cbTmpProvName))
            goto Ret;

        RtlInitAnsiString(&AnsiString, pszTmpProvName);

        Status = RtlAnsiStringToUnicodeString(&UnicodeString, &AnsiString, TRUE);
        if ( !NT_SUCCESS(Status))
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto Ret;
        }

        if (NULL == pszProvName)
        {
            *pcbProvName = UnicodeString.Length + sizeof(WCHAR);
            fRet = CRYPT_SUCCEED;
            goto Ret;
        }

        if (*pcbProvName < UnicodeString.Length + sizeof(WCHAR))
        {
            *pcbProvName = UnicodeString.Length + sizeof(WCHAR);
            SetLastError(ERROR_MORE_DATA);
            goto Ret;
        }

        *pcbProvName = UnicodeString.Length + sizeof(WCHAR);
        memset(pszProvName, 0, *pcbProvName);
        memcpy(pszProvName, UnicodeString.Buffer, UnicodeString.Length);
    }
    __except ( CapiExceptionFilter )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }

    fRet = CRYPT_SUCCEED;
Ret:
    if (UnicodeString.Buffer)
        RtlFreeUnicodeString(&UnicodeString);
    if (pszTmpProvName)
        LocalFree(pszTmpProvName);
    return fRet;
}

/*
 -      CryptEnumProvidersA
 -
 *      Purpose:
 *                Enumerate the providers.
 *
 *      Parameters:
 *                IN  dwIndex        - Index to the providers to enumerate
 *                IN  pdwReserved    - Reserved for future use
 *                IN  dwFlags        - Flags parameter
 *                OUT pdwProvType    - The type of the provider
 *                OUT pszProvName    - Name of the enumerated provider
 *                IN OUT pcbProvName - Length of the enumerated provider
 *
 *      Returns:
 *               BOOL
 *               Use get extended error information use GetLastError
 */
WINADVAPI
BOOL
WINAPI CryptEnumProvidersA(
                           IN DWORD dwIndex,
                           IN DWORD *pdwReserved,
                           IN DWORD dwFlags,
                           OUT DWORD *pdwProvType,
                           OUT LPSTR pszProvName,
                           IN OUT DWORD *pcbProvName
                           )
{
    HKEY        hRegKey = 0;
    HKEY        hProvRegKey = 0;
    LONG        err;
    DWORD       cbClass;
    FILETIME    ft;
    DWORD       dwKeyType;
    DWORD       cbProvType;
    DWORD       dw;
    DWORD       cSubKeys;
    DWORD       cbMaxKeyName;
    DWORD       cbMaxClass;
    DWORD       cValues;
    DWORD       cbMaxValName;
    DWORD       cbMaxValData;
    LPSTR       pszTmpProvName = NULL;
    DWORD       cbTmpProvName;
    BOOL        fRet = CRYPT_FAILED;

    __try
    {
        if (NULL != pdwReserved)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }

        if (0 != dwFlags)
        {
            SetLastError((DWORD)NTE_BAD_FLAGS);
            goto Ret;
        }

        if (ERROR_SUCCESS != (err = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                                 (const char *) szenumproviders,
                                                 0L, KEY_READ, &hRegKey)))
        {
            SetLastError((DWORD)NTE_FAIL);
            goto Ret;
        }

        if (ERROR_SUCCESS != (err = RegQueryInfoKey(hRegKey,
                                                    NULL,
                                                    NULL,
                                                    NULL,
                                                    &cSubKeys,
                                                    &cbMaxKeyName,
                                                    &cbMaxClass,
                                                    &cValues,
                                                    &cbMaxValName,
                                                    &cbMaxValData,
                                                    NULL,
                                                    &ft)))
        {
            SetLastError((DWORD)NTE_FAIL);
            goto Ret;
        }
        cbMaxKeyName += sizeof(CHAR);

        if (NULL == (pszTmpProvName = LocalAlloc(LMEM_ZEROINIT, cbMaxKeyName)))
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto Ret;
        }

        if (ERROR_SUCCESS != (err = RegEnumKeyEx(hRegKey, dwIndex, pszTmpProvName,
                                                 &cbMaxKeyName, NULL,
                                                 NULL, &cbClass, &ft)))
        {
            SetLastError((DWORD)err);
            goto Ret;
        }

        if (ERROR_SUCCESS != (err = RegOpenKeyEx(hRegKey,
                                                 (const char *) pszTmpProvName,
                                                 0L, KEY_READ, &hProvRegKey)))
        {
            SetLastError((DWORD)NTE_FAIL);
            goto Ret;
        }

        cbProvType = sizeof(dw);
        if (ERROR_SUCCESS != (err = RegQueryValueEx(hProvRegKey,
                                                    (const char *) "Type",
                                                    NULL, &dwKeyType, (BYTE*)&dw,
                                                    &cbProvType)))
        {
            SetLastError((DWORD)NTE_FAIL);
            goto Ret;
        }
        *pdwProvType = dw;

        cbTmpProvName = strlen(pszTmpProvName) + sizeof(CHAR);

        if (NULL != pszProvName)
        {
            if (*pcbProvName < cbTmpProvName)
            {
                *pcbProvName = cbTmpProvName;
                SetLastError(ERROR_MORE_DATA);
                goto Ret;
            }
            strcpy(pszProvName, pszTmpProvName);
        }

        *pcbProvName = cbTmpProvName;
    }
    __except ( CapiExceptionFilter )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }

    fRet = CRYPT_SUCCEED;
Ret:
    if (pszTmpProvName)
        LocalFree(pszTmpProvName);
    if (hRegKey)
        RegCloseKey(hRegKey);
    if (hProvRegKey)
        RegCloseKey(hProvRegKey);
    return fRet;
}

BOOL EnterProviderCritSec(IN PVTableStruc pVTable)
{
    __try
    {
        if (pVTable->Version != TABLEPROV)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Try_Error_Return;
        }

        InterlockedIncrement((LPLONG)&pVTable->Inuse);

    }
    __except ( CapiExceptionFilter )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Try_Error_Return;
    }

    return(CRYPT_SUCCEED);
Try_Error_Return:
    return(CRYPT_FAILED);
}


void LeaveProviderCritSec(IN PVTableStruc pVTable)
{
    InterlockedDecrement((LPLONG)&pVTable->Inuse);
}

BOOL EnterKeyCritSec(IN PVKeyStruc pVKey)
{

    __try
    {
        if (pVKey->Version != TABLEKEY)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Try_Error_Return;
        }

        InterlockedIncrement((LPLONG)&pVKey->Inuse);
    }
    __except ( CapiExceptionFilter )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Try_Error_Return;
    }

    return(CRYPT_SUCCEED);
Try_Error_Return:
    return(CRYPT_FAILED);

}


void LeaveKeyCritSec(IN PVKeyStruc pVKey)
{
    InterlockedDecrement((LPLONG)&pVKey->Inuse);
}

BOOL EnterHashCritSec(IN PVHashStruc pVHash)
{

    __try
    {
        if (pVHash->Version != TABLEHASH)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Try_Error_Return;
        }

        InterlockedIncrement((LPLONG)&pVHash->Inuse);
    }
    __except ( CapiExceptionFilter )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Try_Error_Return;
    }

    return(CRYPT_SUCCEED);

Try_Error_Return:
    return(CRYPT_FAILED);

}


void LeaveHashCritSec(IN PVHashStruc pVHash)
{
    InterlockedDecrement((LPLONG)&pVHash->Inuse);
}


BOOL BuildVKey(IN PVKeyStruc *ppVKey,
               IN PVTableStruc pVTable)
{
    DWORD           bufsize;
    PVKeyStruc pVKey;

    bufsize = sizeof(VKeyStruc);

    if ((pVKey = (PVKeyStruc) LocalAlloc(LMEM_ZEROINIT,
                                         (UINT) bufsize)) == NULL)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(CRYPT_FAILED);
    }

    pVKey->FuncGenKey = pVTable->FuncGenKey;
    pVKey->FuncDeriveKey = pVTable->FuncDeriveKey;
    pVKey->FuncDestroyKey = pVTable->FuncDestroyKey;
    pVKey->FuncSetKeyParam = pVTable->FuncSetKeyParam;
    pVKey->FuncGetKeyParam = pVTable->FuncGetKeyParam;
    pVKey->FuncExportKey = pVTable->FuncExportKey;
    pVKey->FuncImportKey = pVTable->FuncImportKey;
    pVKey->FuncEncrypt = pVTable->FuncEncrypt;
    pVKey->FuncDecrypt = pVTable->FuncDecrypt;

    pVKey->OptionalFuncDuplicateKey = pVTable->OptionalFuncDuplicateKey;

    pVKey->hProv = pVTable->hProv;

    *ppVKey = pVKey;

    return(CRYPT_SUCCEED);
}

BOOL BuildVHash(
                IN PVHashStruc *ppVHash,
                IN PVTableStruc pVTable
                )
{
    DWORD           bufsize;
    PVHashStruc     pVHash;


    bufsize = sizeof(VHashStruc);

    if ((pVHash = (PVHashStruc) LocalAlloc(LMEM_ZEROINIT, (UINT) bufsize)) == NULL)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(CRYPT_FAILED);
    }

    pVHash->FuncCreateHash = pVTable->FuncCreateHash;
    pVHash->FuncHashData = pVTable->FuncHashData;
    pVHash->FuncHashSessionKey = pVTable->FuncHashSessionKey;
    pVHash->FuncDestroyHash = pVTable->FuncDestroyHash;
    pVHash->FuncSignHash = pVTable->FuncSignHash;
    pVHash->FuncVerifySignature = pVTable->FuncVerifySignature;
    pVHash->FuncGetHashParam = pVTable->FuncGetHashParam;
    pVHash->FuncSetHashParam = pVTable->FuncSetHashParam;

    pVHash->OptionalFuncDuplicateHash = pVTable->OptionalFuncDuplicateHash;

    pVHash->hProv = (HCRYPTPROV)pVTable;

    *ppVHash = pVHash;

    return(CRYPT_SUCCEED);
}

#define RC4_KEYSIZE 5

void EncryptKey(BYTE *pdata, DWORD size, BYTE val)
{
    RC4_KEYSTRUCT key;
    BYTE          RealKey[RC4_KEYSIZE] = {0xa2, 0x17, 0x9c, 0x98, 0xca};
    DWORD         index;

    for (index = 0; index < RC4_KEYSIZE; index++)
    {
        RealKey[index] ^= val;
    }

    rc4_key(&key, RC4_KEYSIZE, RealKey);

    rc4(&key, size, pdata);

}

void MD5HashData(
                 BYTE *pb,
                 DWORD cb,
                 BYTE *pbHash
                 )
{
    MD5_CTX     HashState;

    MD5Init(&HashState);

    __try
    {
        MD5Update(&HashState, pb, cb);
    } __except ( CapiExceptionFilter )
    {
        SetLastError((DWORD) NTE_SIGNATURE_FILE_BAD);
        return;
    }

    // Finish the hash
    MD5Final(&HashState);

    memcpy(pbHash, HashState.digest, 16);
}

BOOL CheckSignature(
                    BYTE *pbKey,
                    DWORD cbKey,
                    BYTE *pbSig,
                    DWORD cbSig,
                    BYTE *pbHash,
                    BOOL fUnknownLen)
{
    BYTE                rgbResult[KEYSIZE1024];
    BYTE                rgbSig[KEYSIZE1024];
    BYTE                rgbKey[sizeof(BSAFE_PUB_KEY) + KEYSIZE1024];
    BYTE                rgbKeyHash[16];
    BYTE                *pbSecondKey;
    DWORD               cbSecondKey;
    BYTE                *pbKeySig;
    PSECOND_TIER_SIG    pSecondTierSig;
    LPBSAFE_PUB_KEY     pTmp;
    BOOL                fRet = FALSE;

    memset(rgbResult, 0, KEYSIZE1024);
    memset(rgbSig, 0, KEYSIZE1024);

    // just check the straight signature if version is 1
    pTmp = (LPBSAFE_PUB_KEY)pbKey;

    // check if sig length is the same as the key length
    if (fUnknownLen || (cbSig == pTmp->keylen))
    {
        memcpy(rgbSig, pbSig, pTmp->keylen);
        BSafeEncPublic(pTmp, rgbSig, rgbResult);

        if (RtlEqualMemory(pbHash, rgbResult, 16) &&
            rgbResult[cbKey-1] == 0 &&
            rgbResult[cbKey-2] == 1 &&
            rgbResult[16] == 0 &&
            rgbResult[17] == 0xFF)
        {
            fRet = TRUE;
            goto Ret;
        }
    }

    // check the the second tier signature if the magic equals 2
    pSecondTierSig = (PSECOND_TIER_SIG)pbSig;
    if (0x00000002 != pSecondTierSig->dwMagic)
        goto Ret;

    if (0x31415352 != pSecondTierSig->Pub.magic)
        goto Ret;

    if (pSecondTierSig->Pub.keylen > KEYSIZE1024)
        goto Ret;
    
    // assign the pointers
    cbSecondKey = sizeof(BSAFE_PUB_KEY) + pSecondTierSig->Pub.keylen;
    pbSecondKey = pbSig + (sizeof(SECOND_TIER_SIG) - sizeof(BSAFE_PUB_KEY));
    pbKeySig = pbSecondKey + cbSecondKey;

    // hash the second tier key
    MD5HashData(pbSecondKey, cbSecondKey, rgbKeyHash);

    // Decrypt the signature data on the second tier key
    memset(rgbResult, 0, sizeof(rgbResult));
    memset(rgbSig, 0, sizeof(rgbSig));

    if (pSecondTierSig->cbSig > sizeof(rgbSig))
        goto Ret;

    memcpy(rgbSig, pbKeySig, pSecondTierSig->cbSig);
    BSafeEncPublic(pTmp, rgbSig, rgbResult);

    if ((FALSE == RtlEqualMemory(rgbKeyHash, rgbResult, 16)) ||
        rgbResult[cbKey-1] != 0 ||
        rgbResult[cbKey-2] != 1 ||
        rgbResult[16] != 0 ||
        rgbResult[17] != 0)
    {
        goto Ret;
    }

    // Decrypt the signature data on the CSP
    memset(rgbResult, 0, sizeof(rgbResult));
    memset(rgbSig, 0, sizeof(rgbSig));
    memset(rgbKey, 0, sizeof(rgbKey));
    memcpy(rgbSig, pbKeySig + pSecondTierSig->cbSig, pSecondTierSig->cbSig);
    memcpy(rgbKey, pbSecondKey, cbSecondKey);
    pTmp = (LPBSAFE_PUB_KEY)rgbKey;
    BSafeEncPublic(pTmp, rgbSig, rgbResult);

    if (RtlEqualMemory(pbHash, rgbResult, 16) &&
        rgbResult[pTmp->keylen-1] == 0 &&
        rgbResult[pTmp->keylen-2] == 1 &&
        rgbResult[16] == 0)
    {
        fRet = TRUE;
    }
Ret:
    return fRet;
}

// Given hInst, allocs and returns pointers to signature pulled from
// resource
BOOL GetCryptSigResourcePtr(
                            HMODULE hInst,
                            BYTE **ppbRsrcSig,
                            DWORD *pcbRsrcSig
                            )
{
    HRSRC   hRsrc;
    BOOL    fRet = FALSE;

    // Nab resource handle for our signature
    if (NULL == (hRsrc = FindResource(hInst, OLD_CRYPT_SIG_RESOURCE_NUMBER,
                                      RT_RCDATA)))
        goto Ret;

    // get a pointer to the actual signature data
    if (NULL == (*ppbRsrcSig = (PBYTE)LoadResource(hInst, hRsrc)))
        goto Ret;

    // determine the size of the resource
    if (0 == (*pcbRsrcSig = SizeofResource(hInst, hRsrc)))
        goto Ret;

    fRet = TRUE;
Ret:
    return fRet;
}

#define CSP_TO_BE_HASHED_CHUNK  4096

// Given hFile, reads the specified number of bytes (cbToBeHashed) from the file
// and hashes these bytes.  The function does this in chunks.
BOOL HashBytesOfFile(
                     IN HANDLE hFile,
                     IN DWORD cbToBeHashed,
                     IN OUT MD5_CTX *pMD5Hash
                     )
{
    BYTE    rgbChunk[CSP_TO_BE_HASHED_CHUNK];
    DWORD   cbRemaining = cbToBeHashed;
    DWORD   cbToRead;
    DWORD   dwBytesRead;
    BOOL    fRet = FALSE;

    //
    // loop over the file for the specified number of bytes
    // updating the hash as we go.
    //

    while (cbRemaining > 0)
    {
        if (cbRemaining < CSP_TO_BE_HASHED_CHUNK)
            cbToRead = cbRemaining;
        else
            cbToRead = CSP_TO_BE_HASHED_CHUNK;

        if(!ReadFile(hFile, rgbChunk, cbToRead, &dwBytesRead, NULL))
            goto Ret;
        if (dwBytesRead != cbToRead)
            goto Ret;

        MD5Update(pMD5Hash, rgbChunk, dwBytesRead);
        cbRemaining -= cbToRead;
    }

    fRet = TRUE;
Ret:
    return fRet;
}

BOOL HashTheFile(
                 LPCWSTR pszImage,
                 DWORD cbImage,
                 BYTE **ppbSig,
                 DWORD *pcbSig,
                 BYTE *pbHash
                 )
{
    HMODULE                     hInst;
    MEMORY_BASIC_INFORMATION    MemInfo;
    BYTE                        *pbRsrcSig;
    DWORD                       cbRsrcSig;
    BYTE                        *pbStart = NULL;
    BYTE                        *pbZeroSig = NULL;
    MD5_CTX                     MD5Hash;
    BYTE                        *pbPostCRC;   // pointer to just after CRC
    DWORD                       cbCRCToSig;   // number of bytes from CRC to sig
    DWORD                       cbPostSig;    // size - (already hashed + signature size)
    BYTE                        *pbPostSig;
    DWORD                       *pdwSigInFileVer;
    DWORD                       *pdwCRCOffset;
    DWORD                       dwCRCOffset;
    DWORD                       dwZeroCRC = 0;
    HANDLE                      File = INVALID_HANDLE_VALUE ;
    HANDLE                      hMapping = NULL;
    BOOL                        fRet = FALSE;

    memset(&MD5Hash, 0, sizeof(MD5Hash));
    memset(&MemInfo, 0, sizeof(MemInfo));

    // Load the file

    File = CreateFileW(
                pszImage,
                GENERIC_READ,
                FILE_SHARE_READ,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL );

    if ( File == INVALID_HANDLE_VALUE )
    {
        goto Ret ;
    }

    hMapping = CreateFileMapping( File,
                                  NULL,
                                  PAGE_READONLY,
                                  0,
                                  0,
                                  NULL);
    if(hMapping == NULL)
    {
        goto Ret;
    }

    pbStart = MapViewOfFile(hMapping,
                          FILE_MAP_READ,
                          0,
                          0,
                          0);
    if(pbStart == NULL)
    {
        goto Ret;
    }

    // Convert pointer to HMODULE, using the same scheme as
    // LoadLibrary (windows\base\client\module.c).
    hInst = (HMODULE)((ULONG_PTR)pbStart | 0x00000001);

    // the resources signature
    if (!GetCryptSigResourcePtr(hInst, &pbRsrcSig, &cbRsrcSig))
        goto Ret;

    if (cbRsrcSig < (sizeof(DWORD) * 2))
        goto Ret;

    // check the sig in file version and get the CRC offset
    pdwSigInFileVer = (DWORD*)pbRsrcSig;
    pdwCRCOffset = (DWORD*)(pbRsrcSig + sizeof(DWORD));
    dwCRCOffset = *pdwCRCOffset;
    if ((0x00000100 != *pdwSigInFileVer) || (dwCRCOffset > cbImage))
        goto Ret;

    // create a zero byte signature
    if (NULL == (pbZeroSig = (BYTE*)LocalAlloc(LMEM_ZEROINIT, cbRsrcSig)))
        goto Ret;
    memcpy(pbZeroSig, pbRsrcSig, sizeof(DWORD) * 2);

    pbPostCRC = pbStart + *pdwCRCOffset + sizeof(DWORD);
    cbCRCToSig = (DWORD)(pbRsrcSig - pbPostCRC);
    pbPostSig = pbRsrcSig + cbRsrcSig;
    cbPostSig = (cbImage - (DWORD)(pbPostSig - pbStart));

    // allocate the real signature and copy the resource sig into the real sig
    *pcbSig = cbRsrcSig - (sizeof(DWORD) * 2);
    if (NULL == (*ppbSig = (BYTE*)LocalAlloc(LMEM_ZEROINIT, *pcbSig)))
        goto Ret;

    memcpy(*ppbSig, pbRsrcSig + (sizeof(DWORD) * 2), *pcbSig);

    // hash over the relevant data
    MD5Init(&MD5Hash);

    // hash up to the CRC
    if (!HashBytesOfFile(File, dwCRCOffset, &MD5Hash))
        goto Ret;

    // pretend CRC is zeroed
    MD5Update(&MD5Hash, (BYTE*)&dwZeroCRC, sizeof(DWORD));
    if (!SetFilePointer(File, sizeof(DWORD), NULL, FILE_CURRENT))
    {
        goto Ret;
    }

    // hash from CRC to sig resource
    if (!HashBytesOfFile(File, cbCRCToSig, &MD5Hash))
        goto Ret;

    // pretend image has zeroed sig
    MD5Update(&MD5Hash, pbZeroSig, cbRsrcSig);
    if (!SetFilePointer(File, cbRsrcSig, NULL, FILE_CURRENT))
    {
        goto Ret;
    }

    // hash after the sig resource
    if (!HashBytesOfFile(File, cbPostSig, &MD5Hash))
        goto Ret;

    // Finish the hash
    MD5Final(&MD5Hash);

    memcpy(pbHash, MD5Hash.digest, MD5DIGESTLEN);

    fRet = TRUE;
Ret:
    if (pbZeroSig)
        LocalFree(pbZeroSig);
    if(pbStart)
        UnmapViewOfFile(pbStart);
    if(hMapping)
        CloseHandle(hMapping);
    if ( File != INVALID_HANDLE_VALUE )
    {
        CloseHandle( File );
    }

    return fRet;
}


/*
 -      CheckAllSignatures
 -
 *      Purpose:
 *                Check signature against all keys
 *
 *
 *      Returns:
 *                BOOL
 */
BOOL CheckAllSignatures(
                        BYTE *pbSig,
                        DWORD cbSig,
                        BYTE *pbHash,
                        BOOL fUnknownLen
                        )
{
    BYTE        rgbKey[sizeof(BSAFE_PUB_KEY) + KEYSIZE1024];
    BYTE        rgbKey2[sizeof(BSAFE_PUB_KEY) + KEYSIZE1024];
#ifdef MS_INTERNAL_KEY
    BYTE        rgbMSKey[sizeof(BSAFE_PUB_KEY) + KEYSIZE1024];
#endif
#ifdef TEST_BUILD_EXPONENT
    BYTE        rgbTestKey[sizeof(BSAFE_PUB_KEY) + KEYSIZE512];
#endif
    BOOL        fRet = FALSE;

    // decrypt the keys once for each process
    memcpy(rgbKey, (BYTE*)&KEY, sizeof(BSAFE_PUB_KEY) + KEYSIZE1024);
    EncryptKey(rgbKey, sizeof(BSAFE_PUB_KEY) + KEYSIZE1024, 0);

#ifdef MS_INTERNAL_KEY
    memcpy(rgbMSKey, (BYTE*)&MSKEY, sizeof(BSAFE_PUB_KEY) + KEYSIZE1024);
    EncryptKey(rgbMSKey, sizeof(BSAFE_PUB_KEY) + KEYSIZE1024, 1);
#endif
    memcpy(rgbKey2, (BYTE*)&KEY2, sizeof(BSAFE_PUB_KEY) + KEYSIZE1024);
    EncryptKey(rgbKey2, sizeof(BSAFE_PUB_KEY) + KEYSIZE1024, 2);

#ifdef TEST_BUILD_EXPONENT
    memcpy(rgbTestKey, (BYTE*)&TESTKEY, sizeof(BSAFE_PUB_KEY) + KEYSIZE512);
    EncryptKey(rgbTestKey, sizeof(BSAFE_PUB_KEY) + KEYSIZE512, 3);
#endif // TEST_BUILD_EXPONENT

    if (CRYPT_SUCCEED == (fRet = CheckSignature(rgbKey, 128, pbSig,
                                                cbSig, pbHash, fUnknownLen)))
    {
        fRet = TRUE;
        goto Ret;
    }

#ifdef MS_INTERNAL_KEY
    if (CRYPT_SUCCEED == (fRet = CheckSignature(rgbMSKey, 128, pbSig,
                                                cbSig, pbHash, fUnknownLen)))
    {
        fRet = TRUE;
        goto Ret;
    }
#endif

    if (CRYPT_SUCCEED == (fRet = CheckSignature(rgbKey2, 128, pbSig,
                                                cbSig, pbHash, fUnknownLen)))
    {
        fRet = TRUE;
        goto Ret;
    }

#ifdef TEST_BUILD_EXPONENT
    if (CRYPT_SUCCEED == (fRet = CheckSignature(rgbTestKey, 64, pbSig,
                                                cbSig, pbHash, fUnknownLen)))
    {
        fRet = TRUE;
        goto Ret;
    }
#endif // TEST_BUILD_EXPONENT

Ret:
    return fRet;
}

/*
 -      CheckSignatureInFile
 -
 *      Purpose:
 *                Check signature which is in the resource in the file
 *
 *
 *      Parameters:
 *                IN pszImage       - address of file
 *
 *      Returns:
 *                BOOL
 */
BOOL CheckSignatureInFile(
        LPCWSTR pszImage)
{
    DWORD       cbImage;
    BYTE        *pbSig = NULL;
    DWORD       cbSig;
    BYTE        rgbHash[MD5DIGESTLEN];
    BOOL        fRet = FALSE;
    WIN32_FILE_ATTRIBUTE_DATA FileData ;
    WCHAR       FullName[ MAX_PATH ];
    PWSTR       FilePart ;
    SYSTEM_KERNEL_DEBUGGER_INFORMATION KdInfo;
    BYTE        rgbMincryptHash[MINCRYPT_MAX_HASH_LEN];
    DWORD       cbMincryptHash = MINCRYPT_MAX_HASH_LEN;
    CRYPT_HASH_BLOB HashBlob;
    DWORD       dwErr = ERROR_SUCCESS;

    NtQuerySystemInformation(
        SystemKernelDebuggerInformation,
        &KdInfo,
        sizeof(KdInfo),
        NULL);

    // Allow any CSP to load if a Kd is attached 
    // and "responsive"
    if (    TRUE == KdInfo.KernelDebuggerEnabled && 
            FALSE == KdInfo.KernelDebuggerNotPresent)
        return TRUE;

    if ( !SearchPathW(NULL,
                      pszImage,
                      NULL,
                      MAX_PATH,
                      FullName,
                      &FilePart ) )
    {
        goto Ret ;
    }

    // 
    // Try new signature check.  Use "mincrypt" 
    // functionality.
    //
    // Look for valid embedded "signcode" signature
    // in the CSP.
    //
    if (ERROR_SUCCESS == MinCryptVerifySignedFile(
        MINCRYPT_FILE_NAME,
        (PVOID) FullName,
        0, NULL, NULL, NULL))
    {
        // Valid signature was found.
        return TRUE;
    }

    //
    // The new signcode-style signature checks failed,
    // so revert to legacy resource-based signature check.
    //

    if ( !GetFileAttributesExW( FullName,
                               GetFileExInfoStandard,
                               &FileData ) )
    {
        goto Ret ;
    }

    if ( FileData.nFileSizeHigh )
    {
        goto Ret ;
    }

    cbImage = FileData.nFileSizeLow ;

    if (!HashTheFile(FullName, cbImage, &pbSig, &cbSig, rgbHash))
        goto Ret;

    // check signature against all public keys
    if (!CheckAllSignatures(pbSig, cbSig, rgbHash, FALSE))
        goto Ret;

    fRet = TRUE;
Ret:
    if (pbSig)
        LocalFree(pbSig);

    return fRet;
}

/*
 -      NewVerifyImage
 -
 *      Purpose:
 *                Check signature of file
 *
 *
 *      Parameters:
 *                IN lpszImage      - address of file
 *                IN pSigData       - address of signature data
 *                IN cbSig          - length of signature data
 *                IN fUnknownLen    - BOOL to tell if length is not passed in
 *
 *      Returns:
 *                BOOL
 */
BOOL NewVerifyImage(LPCSTR lpszImage,
                    BYTE *pSigData,
                    DWORD cbSig,
                    BOOL fUnknownLen)
{
    HFILE       hFileProv = HFILE_ERROR;
    DWORD       NumBytes;
    DWORD       lpdwFileSizeHigh;
    MD5_CTX     HashState;
    OFSTRUCT    ImageInfoBuf;
    BOOL        fRet = CRYPT_FAILED;

    memset(&HashState, 0, sizeof(HashState));

    if (HFILE_ERROR == (hFileProv = OpenFile(lpszImage, &ImageInfoBuf,
                                             OF_READ)))
    {
        SetLastError((DWORD) NTE_PROV_DLL_NOT_FOUND);
        goto Ret;
    }

    if (0xffffffff == (NumBytes = GetFileSize((HANDLE)IntToPtr(hFileProv),
                                              &lpdwFileSizeHigh)))
    {
        SetLastError((DWORD) NTE_SIGNATURE_FILE_BAD);
        goto Ret;
    }

    MD5Init(&HashState);

    if (!HashBytesOfFile((HANDLE)IntToPtr(hFileProv), NumBytes, &HashState))
    {
        SetLastError((DWORD) NTE_SIGNATURE_FILE_BAD);
        goto Ret;
    }
    MD5Final(&HashState);

    // check the signature against all keys
    if (!CheckAllSignatures(pSigData, cbSig, HashState.digest, fUnknownLen))
    {
        SetLastError((DWORD) NTE_BAD_SIGNATURE);
        goto Ret;
    }
    fRet = TRUE;
Ret:
    if (HFILE_ERROR != hFileProv)
        _lclose(hFileProv);

    return fRet;
}

/*
 -      CProvVerifyImage
 -
 *      Purpose:
 *                Check signature of file
 *
 *
 *      Parameters:
 *                IN lpszImage      - address of file
 *                IN lpSigData      - address of signature data
 *
 *      Returns:
 *                BOOL
 */
BOOL CProvVerifyImage(LPCSTR lpszImage,
                      BYTE *pSigData)
{
    UNICODE_STRING String ;
    BOOL Result ;

    if (NULL == pSigData)
    {
        if ( RtlCreateUnicodeStringFromAsciiz( &String, lpszImage ) )
        {
            Result = CheckSignatureInFile( String.Buffer );

            RtlFreeUnicodeString( &String );
        }
        else
        {
            Result = FALSE ;
        }
    }
    else
    {
        Result = NewVerifyImage(lpszImage, pSigData, 0, TRUE);
    }

    return Result;
}

/*
 -      CPReturnhWnd
 -
 *      Purpose:
 *                Return a window handle back to a CSP
 *
 *
 *      Parameters:
 *                OUT phWnd      - pointer to a hWnd to return
 *
 *      Returns:
 *                void
 */
void CPReturnhWnd(HWND *phWnd)
{
    __try
    {

        *phWnd = hWnd;

    } __except ( CapiExceptionFilter )
    { ; }

    return;
}

static void __ltoa(DWORD val, char *buf)
{
    char *p;            /* pointer to traverse string */
    char *firstdig;     /* pointer to first digit */
    char temp;          /* temp char */
    unsigned digval;    /* value of digit */
    int  i;

    p = buf;

    firstdig = p;       /* save pointer to first digit */

    for (i = 0; i < 8; i++) {
        digval = (unsigned) (val % 10);
        val /= 10;      /* get next digit */

        /* convert to ascii and store */
        *p++ = (char) (digval + '0');    /* a digit */
    }

    /* We now have the digit of the number in the buffer, but in reverse
       order.  Thus we reverse them now. */

    *p-- = '\0';                /* terminate string; p points to last digit */

    do {
        temp = *p;
        *p = *firstdig;
        *firstdig = temp;       /* swap *p and *firstdig */
        --p;
        ++firstdig;             /* advance to next two digits */
    } while (firstdig < p); /* repeat until halfway */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\advapi32\cseclogn.cxx ===
/*+
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1997 - 1998.
 *
 *  Name : cseclogn.cxx
 *  Author:Jeffrey Richter (v-jeffrr)
 *
 * Abstract:
 * This is the client side for Secondary Logon Service
 * implemented as CreateProcessWithLogon API
 * in advapi32.dll
 *
 * Revision History:
 * PraeritG    10/8/97  To integrate this in to services.exe
 *
-*/

#define UNICODE

#define SECURITY_WIN32

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <Windows.h>
#include <wincred.h>
#include <rpc.h>
#include <crypt.h>
#include <strsafe.h>
#include <assert.h>
#include "seclogon.h"
#include "security.h"
#include "dbgdef.h"

//
// must move to winbase.h soon!
#define LOGON_WITH_PROFILE              0x00000001
#define LOGON_NETCREDENTIALS_ONLY       0x00000002

////////////////////////////////////////////////////////////////////////
//
// Function prototypes:
//
////////////////////////////////////////////////////////////////////////

BOOL
CreateProcessWithLogonCommonW(
      HANDLE hToken,
      LPCWSTR lpUsername,
      LPCWSTR lpDomain,
      LPCWSTR lpPassword,
      DWORD dwLogonFlags,
      LPCWSTR lpApplicationName,
      LPWSTR lpCommandLine,
      DWORD dwCreationFlags,
      LPVOID lpEnvironment,
      LPCWSTR lpCurrentDirectory,
      LPSTARTUPINFOW lpStartupInfo,
      LPPROCESS_INFORMATION lpProcessInformation);


DWORD c_SeclCreateProcessWithLogonW(IN   SECL_SLI   *psli,
                                    OUT  SECL_SLRI  *pslri);

DWORD To_SECL_BLOB_A(IN   LPVOID      lpEnvironment,
                     OUT  SECL_BLOB  *psb);

DWORD To_SECL_BLOB_W(IN   LPVOID      lpEnvironment,
                     OUT  SECL_BLOB  *psb);


/////////////////////////////////////////////////////////////////////////
//
// Useful macros:
//
/////////////////////////////////////////////////////////////////////////

#define ARRAYSIZE(array) ((sizeof(array)) / (sizeof(array[0])))

//
// Fill out a string structure to send to the seclogon RPC server.  
// We'll use the convention that the client must allocate an extra byte
// which the server can use to NULL-terminate the input string
//
#define ASSIGN_SECL_STRING(ss, wsz) \
    { \
        ss.pwsz = wsz; \
        if (NULL != wsz) { \
            size_t len; \
            LastError = StringCchLength(wsz, 0xFFFF-1, &len); \
            if (FAILED(LastError)) { \
                __leave; \
            } \
            ss.ccLength = (WORD)len; \
            ss.ccSize = (WORD)len+1; \
         } \
        else { \
            ss.ccLength = ss.ccSize = 0; \
        } \
    }

#define GET_RTL_ENCRYPT_PADDING_LENGTH(dwLen, dwUnits) \
    ((RTL_ENCRYPT_MEMORY_SIZE - (((dwLen)*(dwUnits)) % RTL_ENCRYPT_MEMORY_SIZE)) / (dwUnits))

#define IS_RTL_MEMORY_BLOCK_MULTIPLE(dwLen, dwUnits) \
    ((((dwLen)*(dwUnits)) % RTL_ENCRYPT_MEMORY_SIZE) == 0)

#define GET_RTL_ENCRYPT_BLOCK_LENGTH(dwLen, dwUnits) \
    ((IS_RTL_MEMORY_BLOCK_MULTIPLE((dwLen), (dwUnits))) ? (dwLen) : ((dwLen) + (GET_RTL_ENCRYPT_PADDING_LENGTH((dwLen), (dwUnits)))))
        

////////////////////////////////////////////////////////////////////////
//
// Module implementation:
//
//////////////////////////////////////////////////////////////////////////


extern "C" void *__cdecl _alloca(size_t);


BOOL
WINAPI
CreateProcessWithLogonW(
      LPCWSTR lpUsername,
      LPCWSTR lpDomain,
      LPCWSTR lpPassword,
      DWORD dwLogonFlags,
      LPCWSTR lpApplicationName,
      LPWSTR lpCommandLine,
      DWORD dwCreationFlags,
      LPVOID lpEnvironment,
      LPCWSTR lpCurrentDirectory,
      LPSTARTUPINFOW lpStartupInfo,
      LPPROCESS_INFORMATION lpProcessInformation
      )
{
    return CreateProcessWithLogonCommonW(
                NULL,
                lpUsername,
                lpDomain,
                lpPassword,
                dwLogonFlags,
                lpApplicationName,
                lpCommandLine,
                dwCreationFlags,
                lpEnvironment,
                lpCurrentDirectory,
                lpStartupInfo,
                lpProcessInformation
                );

}

BOOL
WINAPI
CreateProcessWithTokenW(
      HANDLE hToken,
      DWORD dwLogonFlags,
      LPCWSTR lpApplicationName,
      LPWSTR lpCommandLine,
      DWORD dwCreationFlags,
      LPVOID lpEnvironment,
      LPCWSTR lpCurrentDirectory,
      LPSTARTUPINFOW lpStartupInfo,
      LPPROCESS_INFORMATION lpProcessInformation
      )
{
    LPWSTR szEmpty = L"";

    return CreateProcessWithLogonCommonW(
                hToken,
                szEmpty,
                szEmpty,
                szEmpty,
                dwLogonFlags,
                lpApplicationName,
                lpCommandLine,
                dwCreationFlags,
                lpEnvironment,
                lpCurrentDirectory,
                lpStartupInfo,
                lpProcessInformation
                );

}


BOOL
CreateProcessWithLogonCommonW(
      HANDLE hToken,
      LPCWSTR lpUsername,
      LPCWSTR lpDomain,
      LPCWSTR lpPassword, 
      DWORD dwLogonFlags,
      LPCWSTR lpApplicationName,
      LPWSTR lpCommandLine,
      DWORD dwCreationFlags,
      LPVOID lpEnvironment,
      LPCWSTR lpCurrentDirectory,
      LPSTARTUPINFOW lpStartupInfo,
      LPPROCESS_INFORMATION lpProcessInformation)

/*++

Routine Description:

Arguments:

Return Value:

--*/
{

   BOOL                             fOk                        = FALSE;
   BOOL                             fRevertWinsta              = FALSE; 
   DWORD                            ccCmdLine; 
   DWORD                            ccPszApplName; 
   DWORD                            ccEncryptedPassword; 
   DWORD                            LastError                  = ERROR_SUCCESS;
   HANDLE                           hheap                      = GetProcessHeap();
   HDESK                            hDesk                      = NULL; 
   HRESULT                          hr; 
   HWINSTA                          hWinsta                    = NULL; 
   HWINSTA                          hWinstaSave                = NULL; 
   LPWSTR                           pszApplName                = NULL;
   LPWSTR                           pszCmdLine                 = NULL;
   LPWSTR                           pwszEmptyString            = L"";
   NTSTATUS                         ntStatus; 
   SECL_SLI                         sli;
   SECL_SLRI                        slri;
   UNICODE_STRING                   uszEncryptedPassword; 
   WCHAR                            wszDesktopName[2*MAX_PATH + 2];
   WCHAR                            wszEncryptedPassword[GET_RTL_ENCRYPT_BLOCK_LENGTH(CREDUI_MAX_PASSWORD_LENGTH, sizeof(WCHAR)) + 1]; 

   ZeroMemory(&sli,                      sizeof(sli));
   ZeroMemory(&slri,                     sizeof(slri));
   ZeroMemory(&uszEncryptedPassword,     sizeof(uszEncryptedPassword)); 
   ZeroMemory(&wszDesktopName,           sizeof(wszDesktopName));
   ZeroMemory(&wszEncryptedPassword[0],  sizeof(wszEncryptedPassword)); 

   __try {
       sli.hToken = (unsigned __int64)hToken;

       if (NULL != lpPassword && L'\0' != lpPassword[0]) 
       {
	   // BUG 547683: we need to encrypt the password across the LPC boundary to prevent
	   // password theft.  NOTE: we won't actually touch the user's passwd buffer -- 
	   // this behavior would be confusing, and would have minimal gain. 
	   //
	   // The RtlEncryptMemory() routine requires that the
	   // memory buffer's size be a multiple of the encryption block length.  
	   // Copy the password over and pad it with some zeros:
	   // 
	   hr = StringCchCopy(wszEncryptedPassword, ARRAYSIZE(wszEncryptedPassword), lpPassword); 
	   if (FAILED(hr))
	   {
	       LastError = (DWORD)hr; 
	       __leave; 
	   }
	   
	   // Calculate the size of the encrypted password
	   ccEncryptedPassword  = wcslen(wszEncryptedPassword); 
	   ccEncryptedPassword  = GET_RTL_ENCRYPT_BLOCK_LENGTH(ccEncryptedPassword, sizeof(WCHAR)); 
	   assert(ccEncryptedPassword < ARRAYSIZE(wszEncryptedPassword)); 

	   // perform the encryption 
	   ntStatus = RtlEncryptMemory((PVOID)wszEncryptedPassword, sizeof(WCHAR)*ccEncryptedPassword, RTL_ENCRYPT_OPTION_SAME_LOGON); 
	   if (!NT_SUCCESS(ntStatus))
	   {
	       LastError = RtlNtStatusToDosError(ntStatus); 
	       __leave;
	   }
	   
	   // assign the encrypted password to a SECL_STRING. 
	   // NOTE: we can't use ASSIGN_SECL_STRING, as the encrypted password may have 
	   // '\0' characters in the middle
	   sli.ssPassword.ccLength  = (WORD)(ccEncryptedPassword); 
	   sli.ssPassword.ccSize    = (WORD)(ccEncryptedPassword+1); 
	   sli.ssPassword.pwsz      = wszEncryptedPassword; 
       }
       else
       {
	   lpPassword = L"";
	   ASSIGN_SECL_STRING(sli.ssPassword, (LPWSTR)lpPassword); 
       }

      //
      // JMR: Do these flags work: CREATE_SEPARATE_WOW_VDM,
      //       CREATE_SHARED_WOW_VDM
      // Valid flags: CREATE_SUSPENDED, CREATE_UNICODE_ENVIRONMENT,
      //              *_PRIORITY_CLASS
      //
      // The following flags are illegal. Fail the call if any are specified.
      //
      if ((dwCreationFlags & (DEBUG_PROCESS | DEBUG_ONLY_THIS_PROCESS
                              | DETACHED_PROCESS)) != 0) {
         LastError = ERROR_INVALID_PARAMETER;
         __leave;
      }

      if(dwLogonFlags & ~(LOGON_WITH_PROFILE | LOGON_NETCREDENTIALS_ONLY))
      {
         LastError = ERROR_INVALID_PARAMETER;
         __leave;
      }

      //
      // Turn on the flags that MUST be turned on
      //
      // We are overloading CREATE_NEW_CONSOLE to
      // CREATE_WITH_NETWORK_LOGON
      //
      dwCreationFlags |= CREATE_DEFAULT_ERROR_MODE | CREATE_NEW_CONSOLE
                           | CREATE_NEW_PROCESS_GROUP;

      //
      // If no priority class explicitly specified and this process is IDLE, force IDLE (See CreateProcess documentation)
      //
      if ((dwCreationFlags & (NORMAL_PRIORITY_CLASS | IDLE_PRIORITY_CLASS
                              | HIGH_PRIORITY_CLASS
                              | REALTIME_PRIORITY_CLASS)) == 0) {

         if (GetPriorityClass(GetCurrentProcess()) == IDLE_PRIORITY_CLASS)
                  dwCreationFlags |= IDLE_PRIORITY_CLASS;
      }

      ccPszApplName = MAX_PATH; 
      pszApplName = (LPWSTR) HeapAlloc(hheap, 0, sizeof(WCHAR) * ccPszApplName);
      //
      // Lookup the fullpathname of the specified executable
      //
      ccCmdLine = MAX_PATH + lstrlenW(lpCommandLine); 
      pszCmdLine = (LPWSTR) HeapAlloc(hheap, 0, sizeof(WCHAR) * ccCmdLine); 
                                             
      if(pszApplName == NULL || pszCmdLine == NULL)
      {
        LastError = ERROR_INVALID_PARAMETER;
        __leave;
      }


      if(lpApplicationName == NULL)
      {
         if(lpCommandLine != NULL)
         {
            //
            // Commandline contains the name, we should parse it out and get
            // the full path so that correct executable is invoked.
            //

            DWORD   Length;
            DWORD   fileattr;
            WCHAR   TempChar = L'\0';
            LPWSTR  TempApplName = NULL;
            LPWSTR  TempRemainderString = NULL;
            LPWSTR  WhiteScan = NULL;
            BOOL    SearchRetry = TRUE;
	    DWORD   ccApplName = lstrlenW(lpCommandLine)+1; 
            LPWSTR  ApplName = (LPWSTR) HeapAlloc(
                                                hheap, 0,
                                                sizeof(WCHAR) * ccApplName);

	    DWORD   ccNameBuffer = MAX_PATH+1; 
            LPWSTR  NameBuffer = (LPWSTR) HeapAlloc(
                                                hheap, 0,
                                                sizeof(WCHAR) * ccNameBuffer);

	    if (ApplName == NULL || NameBuffer == NULL)
	    {
	        LastError = ERROR_NOT_ENOUGH_MEMORY;
		__leave;
	    }

            hr = StringCchCopy(ApplName, ccApplName, lpCommandLine);
	    if (FAILED(hr)) { 
		LastError = (DWORD)hr; 
		__leave; 
	    }

            WhiteScan = ApplName;

            //
            // if there is a leading quote
            //
            if(*WhiteScan == L'\"')
            {
                // we will NOT retry search, as app name is quoted.

                SearchRetry = FALSE;
                WhiteScan++;
                TempApplName = WhiteScan;
                while(*WhiteScan) {
                    if( *WhiteScan == L'\"')
                    {
                        TempChar = *WhiteScan;
                        *WhiteScan = L'\0';
                        TempRemainderString = WhiteScan;
                        break;
                    }
                    WhiteScan++;
                }
            }
            else
            {
                // skip to the first non-white char
                while(*WhiteScan) {
                    if( *WhiteScan == L' ' || *WhiteScan == L'\t')
                    {
                        WhiteScan++;
                    }
                    else
                        break;
                }
                TempApplName = WhiteScan;

                while(*WhiteScan) {
                    if( *WhiteScan == L' ' || *WhiteScan == L'\t')
                    {
                        TempChar = *WhiteScan;
                        *WhiteScan = L'\0';
                        TempRemainderString = WhiteScan;
                        break;
                    }
                    WhiteScan++;
                }

            }

RetrySearch:
            Length = SearchPathW(
                            NULL,
                            TempApplName,
                            (PWSTR)L".exe",
                            MAX_PATH,
                            NameBuffer,
                            NULL
                            );

            if(!Length || Length > MAX_PATH)
            {
                if(LastError)
                    SetLastError(LastError);
                else
                    LastError = GetLastError();

CoverForDirectoryCase:
                    //
                    // If we still have command line left, then keep going
                    // the point is to march through the command line looking
                    // for whitespace so we can try to find an image name
                    // launches of things like:
                    // c:\word 95\winword.exe /embedding -automation
                    // require this. Our first iteration will
                    // stop at c:\word, our next
                    // will stop at c:\word 95\winword.exe
                    //
                    if(TempRemainderString)
                    {
                        *TempRemainderString = TempChar;
                        WhiteScan++;
                    }
                    if(*WhiteScan & SearchRetry)
                    {
                        // again skip to the first non-white char
                        while(*WhiteScan) {
                            if( *WhiteScan == L' ' || *WhiteScan == L'\t')
                            {
                                WhiteScan++;
                            }
                            else
                                break;
                        }
                        while(*WhiteScan) {
                            if( *WhiteScan == L' ' || *WhiteScan == L'\t')
                            {
                                TempChar = *WhiteScan;
                                *WhiteScan = L'\0';
                                TempRemainderString = WhiteScan;
                                break;
                            }
                            WhiteScan++;
                        }
                        // we'll do one last try of the whole string.
                        if(!WhiteScan) SearchRetry = FALSE;
                        goto RetrySearch;
                    }

                    //
                    // otherwise we have failed.
                    //
                    if(NameBuffer) HeapFree(hheap, 0, NameBuffer);
                    if(ApplName) HeapFree(hheap, 0, ApplName);

                    // we should let CreateProcess do its job.
                    if (pszApplName)
                    {
                        HeapFree(hheap, 0, pszApplName);
                        pszApplName = NULL;
                    }
                    hr = StringCchCopy(pszCmdLine, ccCmdLine, lpCommandLine);
		    if (FAILED(hr)) { 
			LastError = (DWORD)hr; 
			__leave; 
		    }
            }
            else
            {
                // searchpath succeeded.
                // but it can find a directory!
                fileattr = GetFileAttributesW(NameBuffer);
                if ( fileattr != 0xffffffff &&
                        (fileattr & FILE_ATTRIBUTE_DIRECTORY) ) {
                        Length = 0;
                        goto CoverForDirectoryCase;
                }

                //
                // so it is not a directory.. it must be the real thing!
                //
                hr = StringCchCopy(pszApplName, ccPszApplName, NameBuffer);
		if (FAILED(hr)) { 
		    LastError = (DWORD)hr; 
		    __leave; 
		}

		hr = StringCchCopy(pszCmdLine, ccCmdLine, lpCommandLine); 
		if (FAILED(hr)) { 
		    LastError = (DWORD)hr; 
		    __leave; 
		}

                HeapFree(hheap, 0, ApplName);
                HeapFree(hheap, 0, NameBuffer);
            }

         }
         else
         {

            LastError = ERROR_INVALID_PARAMETER;
            __leave;
         }

      }
      else
      {

         //
         // If ApplicationName is not null, we need to handle
         // one case here -- the application name is present in
         // current directory.  All other cases will be handled by
         // CreateProcess in the server side anyway.
         //

         //
         // let us get a FullPath relative to current directory
         // and try to open it.  If it succeeds, then the full path
         // is what we'll give as app name.. otherwise will just
         // pass what we got from caller and let CreateProcess deal with it.

         LPWSTR lpFilePart;

         DWORD  cchFullPath = GetFullPathName(
                                            lpApplicationName,
                                            MAX_PATH,
                                            pszApplName,
                                            &lpFilePart
                                            );

         if(cchFullPath)
         {
             HANDLE hFile;
             //
             // let us try to open it.
             // if it works, pszApplName is already setup correctly.
             // just close the handle.

             hFile = CreateFile(lpApplicationName, GENERIC_READ,
                                FILE_SHARE_READ | FILE_SHARE_WRITE,
                                NULL,
                                OPEN_EXISTING,
                                0,
                                NULL
                                );

             if(hFile == INVALID_HANDLE_VALUE)
             {
                // otherwise, keep what the caller gave us.
		 hr = StringCchCopy(pszApplName, ccPszApplName, lpApplicationName); 
		 if (FAILED(hr)) { 
		     LastError = (DWORD)hr; 
		     __leave;
		 }
             }
             else
                CloseHandle(hFile);

         }
         else { 
	     // lets keep what the caller gave us.
	     hr = StringCchCopy(pszApplName, ccPszApplName, lpApplicationName);
	     if (FAILED(hr)) { 
		 LastError = (DWORD)hr; 
		 __leave;
	     }
	 }

         //
         // Commandline should be kept as is.
         //
         if(lpCommandLine != NULL) { 
	     hr = StringCchCopy(pszCmdLine, ccCmdLine, lpCommandLine);
	     if (FAILED(hr)) { 
		 LastError = (DWORD)hr; 
		 __leave;
	     }
	 }
         else
         {
            HeapFree(hheap, 0, pszCmdLine);
            pszCmdLine = NULL;
         }
      }

#if 0
      if(lpApplicationName != NULL) lstrcpy(pszApplName,lpApplicationName);
      else {
            HeapFree(hheap, 0, pszApplName);
            pszApplName = NULL;
      }
      if(lpCommandLine != NULL) lstrcpy(pszCmdLine, lpCommandLine);
      else {
            HeapFree(hheap, 0, pszCmdLine);
            pszCmdLine = NULL;
      }
#endif

      // Construct a memory block will all the info that needs to go to the server

      sli.lLogonIdHighPart   = 0;
      sli.ulLogonIdLowPart   = 0;
      sli.ulLogonFlags       = dwLogonFlags;
      sli.ulProcessId        = GetCurrentProcessId();
      sli.ulCreationFlags    = dwCreationFlags;
      sli.hWinsta            = 0; // no longer used
      sli.hDesk              = 0; // no longer used

      ASSIGN_SECL_STRING(sli.ssUsername,          (LPWSTR) lpUsername);
      ASSIGN_SECL_STRING(sli.ssDomain,            (LPWSTR) lpDomain);
      ASSIGN_SECL_STRING(sli.ssApplicationName,   pszApplName);
      ASSIGN_SECL_STRING(sli.ssCommandLine,       pszCmdLine);
      ASSIGN_SECL_STRING(sli.ssCurrentDirectory,  (LPWSTR)lpCurrentDirectory);
      ASSIGN_SECL_STRING(sli.ssDesktop,           lpStartupInfo->lpDesktop);
      ASSIGN_SECL_STRING(sli.ssTitle,             lpStartupInfo->lpTitle);

      if (0 != (sli.ulCreationFlags & CREATE_UNICODE_ENVIRONMENT)) {
          LastError = To_SECL_BLOB_W(lpEnvironment, &(sli.sbEnvironment));
      }
      else {
          LastError = To_SECL_BLOB_A(lpEnvironment, &(sli.sbEnvironment));
      }
      if (ERROR_SUCCESS != LastError) { __leave; }

      // If the caller hasn't specified their own desktop, we'll do it for 
      // them  (the seclogon service will take care of granting access
      // to the desktop). 
      if (sli.ssDesktop.pwsz == NULL || sli.ssDesktop.pwsz[0] == L'\0')
      {
          DWORD    Length;
          HWINSTA  Winsta  = GetProcessWindowStation();
          HDESK    Desk    = GetThreadDesktop(GetCurrentThreadId());
          
          // Send seclogon the name of the current windowstation and desktop. 
          // Default to empty string if we can't get the name: 
          ASSIGN_SECL_STRING(sli.ssDesktop, pwszEmptyString);
          
          if (GetUserObjectInformation(Winsta, UOI_NAME, wszDesktopName, (MAX_PATH*sizeof(WCHAR)), &Length))
          {
              Length = (DWORD)wcslen(wszDesktopName); 
              wszDesktopName[Length++] = L'\\'; 
              
              if(GetUserObjectInformation(Desk, UOI_NAME, &wszDesktopName[Length], (MAX_PATH*sizeof(WCHAR)), &Length))
              {
                  // sli.ssDesktop now contains "windowstation\desktop"
                  ASSIGN_SECL_STRING(sli.ssDesktop, wszDesktopName);
              }
          }
      } 
      else
      {
          // The caller specified their own desktop
          sli.ulSeclogonFlags |= SECLOGON_CALLER_SPECIFIED_DESKTOP; 
      }

      // Perform the RPC call to the seclogon service:
      LastError = c_SeclCreateProcessWithLogonW(&sli, &slri);
      if (ERROR_SUCCESS != LastError) __leave;

      fOk = (slri.ulErrorCode == NO_ERROR);  // This function succeeds if the server's function succeeds

      if (!fOk) {
          //
          // If the server function failed, set the server's
          // returned eror code as this thread's error code
          //
          LastError = slri.ulErrorCode;
          SetLastError(slri.ulErrorCode);
      } else {
          //
          // The server function succeeded, return the
          // PROCESS_INFORMATION info
          //
          lpProcessInformation->hProcess     = (HANDLE)slri.hProcess;
          lpProcessInformation->hThread      = (HANDLE)slri.hThread;
          lpProcessInformation->dwProcessId  = slri.ulProcessId;
          lpProcessInformation->dwThreadId   = slri.ulThreadId;
          LastError = ERROR_SUCCESS;
      }
   }
   __finally {
      if (NULL != pszCmdLine)   HeapFree(hheap, 0, pszCmdLine);
      if (NULL != pszApplName)  HeapFree(hheap, 0, pszApplName);
      if (fRevertWinsta)        SetProcessWindowStation(hWinstaSave); 
      if (NULL != hWinsta)      CloseWindowStation(hWinsta); 
      if (NULL != hDesk)        CloseDesktop(hDesk); 
      SetLastError(LastError);
   }

   return(fOk);
}

////////////////////////////////////////////////////////////////////////
//
// RPC Utility methods:
//
////////////////////////////////////////////////////////////////////////

DWORD To_SECL_BLOB_W(IN   LPVOID      lpEnvironment,
                     OUT  SECL_BLOB  *psb) {
    DWORD    cb        = 0;
    DWORD    dwResult  = NULL;
    HANDLE   hHeap     = NULL;
    HRESULT  hr; 
    LPBYTE   pb        = NULL;
    LPWSTR   pwsz      = NULL;
    size_t   totalLen  = 0; 
    size_t   nextLen;

    hHeap = GetProcessHeap();
    _JumpCondition(NULL == hHeap, GetProcessHeapError);

    if (NULL != lpEnvironment) {
        for (pwsz = (LPWSTR)lpEnvironment; pwsz[0] != L'\0'; pwsz += nextLen + 1) { 
	    // 10K chars is the most we allow for the environment block:
	    hr = StringCchLengthW(pwsz, (10*1024)-totalLen, &nextLen); 
	    if (FAILED(hr))
		goto StringCchLengthWError; 
	    totalLen += nextLen + 1; 
	}
        cb = sizeof(WCHAR) * ((DWORD)(1 + totalLen));
        pb = (LPBYTE)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, cb);
        _JumpCondition(NULL == pb, MemoryError);

        CopyMemory(pb, (LPBYTE)lpEnvironment, cb);
    }

    psb->cb  = cb;
    psb->pb  = pb;
    dwResult = ERROR_SUCCESS;
 CommonReturn:
    return dwResult;

 ErrorReturn:
    if (NULL != pb) { HeapFree(hHeap, 0, pb); }
    goto CommonReturn;

SET_DWRESULT(GetProcessHeapError,    GetLastError());
SET_DWRESULT(MemoryError,            ERROR_NOT_ENOUGH_MEMORY);
SET_DWRESULT(StringCchLengthWError,  (DWORD)hr); 
}

DWORD To_SECL_BLOB_A(IN   LPVOID      lpEnvironment,
                     OUT  SECL_BLOB  *psb) {
    DWORD    cb        = 0;
    DWORD    dwResult;
    HANDLE   hHeap     = NULL;
    HRESULT  hr; 
    LPBYTE   pb        = NULL;
    LPSTR    psz       = NULL;
    size_t   totalLen  = 0; 
    size_t   nextLen;

    hHeap = GetProcessHeap();
    _JumpCondition(NULL == hHeap, GetProcessHeapError);

    if (NULL != lpEnvironment) {
        for (psz = (LPSTR)lpEnvironment; psz[0] != '\0'; psz += nextLen + 1) { 
	    // 10K chars is the most we allow for the environment block:
	    hr = StringCchLengthA(psz, (10*1024)-totalLen, &nextLen); 
	    if (FAILED(hr))
		goto StringCchLengthAError; 
	    totalLen += nextLen + 1; 
	}

        cb = (DWORD)(1 + totalLen); 
        pb = (LPBYTE)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, cb);
        _JumpCondition(NULL == pb, MemoryError);

        CopyMemory(pb, (LPBYTE)lpEnvironment, cb);
    }

    psb->cb  = cb;
    psb->pb  = pb;
    dwResult = ERROR_SUCCESS;
 CommonReturn:
    return dwResult;

 ErrorReturn:
    if (NULL != pb) { HeapFree(hHeap, 0, pb); }
    goto CommonReturn;

SET_DWRESULT(GetProcessHeapError,    GetLastError());
SET_DWRESULT(MemoryError,            ERROR_NOT_ENOUGH_MEMORY);
SET_DWRESULT(StringCchLengthAError,  (DWORD)hr); 
}


DWORD StartSeclogonService() {
    BOOL            fResult;
    DWORD           dwInitialCount;
    DWORD           dwResult;
    SC_HANDLE       hSCM              = NULL;
    SC_HANDLE       hService          = NULL;
    SERVICE_STATUS  sSvcStatus;

    hSCM = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
    _JumpCondition(hSCM == NULL, OpenSCManagerError);

    hService = OpenService(hSCM, wszSvcName, SERVICE_START | SERVICE_QUERY_STATUS);
    _JumpCondition(NULL == hService, OpenServiceError);

    fResult = StartService(hService, NULL, NULL);
    _JumpCondition(FALSE == fResult, StartServiceError);

    // Wait until the service has actually started.
    // Set timeout to 20 seconds.
    dwInitialCount = GetTickCount();

    // Keep polling to see if the service has started ...
    for (;;)
    {
        fResult = QueryServiceStatus(hService, &sSvcStatus);
        _JumpCondition(FALSE == fResult, QueryServiceStatusError);

        // The service is running.  We can stop waiting for it.
        if (sSvcStatus.dwCurrentState == SERVICE_RUNNING)
            break;

        // Check to see if we've timed out.  If GetTickCount() rolls over,
        // then at worst we time out early.
        _JumpCondition((GetTickCount() - dwInitialCount) > 20000, ServiceTimeoutError);

        // Don't hose the service.
        SleepEx(100, FALSE);
    }

    // Ok, the service has successfully started.
    dwResult = ERROR_SUCCESS;
 CommonReturn:
    if (NULL != hSCM)     { CloseServiceHandle(hSCM); }
    if (NULL != hService) { CloseServiceHandle(hService); }
    return dwResult;

 ErrorReturn:
    goto CommonReturn;

SET_DWRESULT(OpenSCManagerError,       GetLastError());
SET_DWRESULT(OpenServiceError,         GetLastError());
SET_DWRESULT(QueryServiceStatusError,  GetLastError());
SET_DWRESULT(StartServiceError,        GetLastError());
SET_DWRESULT(ServiceTimeoutError,      ERROR_SERVICE_REQUEST_TIMEOUT);
}

DWORD SetupLocalRPCSecurity(handle_t hRPCBinding)
{
    CHAR                      szDomainName[128]; 
    CHAR                      szName[128]; 
    DWORD                     cbDomainName; 
    DWORD                     cbName; 
    DWORD                     dwResult; 
    PSID                      pSid               = NULL; 
    RPC_SECURITY_QOS          SecurityQOS;
    SID_IDENTIFIER_AUTHORITY  SidAuthority       = SECURITY_NT_AUTHORITY;
    SID_NAME_USE              SidNameUse; 

    // We're doing LRPC -- we need to get the account name of the service to do mutual auth
    if (!AllocateAndInitializeSid(&SidAuthority, 1, SECURITY_LOCAL_SYSTEM_RID, 0, 0, 0, 0, 0, 0, 0, &pSid))
	goto AllocateAndInitializeSidError; 

    cbName = sizeof(szName); 
    cbDomainName = sizeof(szDomainName); 
    if (!LookupAccountSidA(NULL, pSid, szName, &cbName, szDomainName, &cbDomainName, &SidNameUse)) 
	goto LookupAccountSidAError; 
	
    // Specify quality of service parameters.
    SecurityQOS.ImpersonationType = RPC_C_IMP_LEVEL_IMPERSONATE; // the server will need to impersonate us
    SecurityQOS.Version           = RPC_C_SECURITY_QOS_VERSION;
    SecurityQOS.Capabilities      = RPC_C_QOS_CAPABILITIES_MUTUAL_AUTH; // we need mutual auth
    SecurityQOS.IdentityTracking  = RPC_C_QOS_IDENTITY_STATIC; // calls go to the server under the identity that created the binding handle

    dwResult = RpcBindingSetAuthInfoExA(hRPCBinding, (unsigned char *)szName, RPC_C_AUTHN_LEVEL_PKT_PRIVACY, RPC_C_AUTHN_WINNT, NULL, 0, &SecurityQOS); 
    if (RPC_S_OK != dwResult)
	goto RpcBindingSetAuthInfoExAError; 

    dwResult = ERROR_SUCCESS; 
 ErrorReturn:
    if (NULL != pSid) {
	FreeSid(pSid);
    }
    return dwResult; 

SET_DWRESULT(AllocateAndInitializeSidError,  GetLastError()); 
SET_DWRESULT(LookupAccountSidAError,         GetLastError()); 
SET_DWRESULT(RpcBindingSetAuthInfoExAError,  dwResult);
}

DWORD c_SeclCreateProcessWithLogonW
(IN   SECL_SLI  *psli,
 OUT  SECL_SLRI *pslri)
{
    DWORD                dwResult;
    LPWSTR               pwszBinding  = NULL;
    RPC_BINDING_HANDLE   hRPCBinding  = NULL;

    dwResult = RpcStringBindingCompose
          (NULL,
           (USHORT *)L"ncalrpc",
           NULL,
           (USHORT *)wszSeclogonSharedProcEndpointName,
           (USHORT *)L"Security=impersonation static false",
           (USHORT **)&pwszBinding);
    _JumpCondition(RPC_S_OK != dwResult, RpcStringBindingComposeError);

    dwResult = RpcBindingFromStringBinding((USHORT *)pwszBinding, &hRPCBinding);
    _JumpCondition(0 != dwResult, RpcBindingFromStringBindingError);

    dwResult = SetupLocalRPCSecurity(hRPCBinding); 
    _JumpCondition(ERROR_SUCCESS != dwResult, SetupLocalRpcSecurityError); 

    // Perform the RPC call to the seclogon service.  If the call fails because the
    // service was not started, try again.  If the call still fails, give up.
    for (BOOL fFirstTry = TRUE; /*TRUE*/; fFirstTry = FALSE) {
        __try {
            SeclCreateProcessWithLogonW(hRPCBinding, psli, pslri);
            break;
        }
        __except(EXCEPTION_EXECUTE_HANDLER) {
              dwResult = RpcExceptionCode();
              if ((RPC_S_SERVER_UNAVAILABLE == dwResult || RPC_S_UNKNOWN_IF == dwResult) && 
                  (TRUE == fFirstTry)) { 
                  // Ok, the seclogon service is probably just not started.
                  // Attempt to start it up and try again.
                  dwResult = StartSeclogonService();
                  _JumpCondition(ERROR_SUCCESS != dwResult, SeclCreateProcessWithLogonWError);
              }
              else {
                  goto SeclCreateProcessWithLogonWError;
              }
        }
    }

    dwResult = ERROR_SUCCESS;
 CommonReturn:
    if (NULL != pwszBinding) { RpcStringFree((USHORT **)&pwszBinding); }
    if (NULL != hRPCBinding) { RpcBindingFree(&hRPCBinding); }
    return dwResult;

 ErrorReturn:
    goto CommonReturn;

SET_DWRESULT(RpcBindingFromStringBindingError,  dwResult);
SET_DWRESULT(RpcStringBindingComposeError,      dwResult);
SET_DWRESULT(SeclCreateProcessWithLogonWError,  dwResult);
SET_DWRESULT(SetupLocalRpcSecurityError,        dwResult); 
}

void DbgPrintf( DWORD /*dwSubSysId*/, LPCSTR /*pszFormat*/ , ...)
{
}

//////////////////////////////// End Of File /////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\advapi32\isuni.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    isuni.c

Abstract:

    Covering routine for RtlIsUnicode string, since this is declare a BOOL
    API and Rtl is BOOLEAN

Author:

    Steve Wood (stevewo) 16-Dec-1993

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

BOOL
WINAPI
IsTextUnicode(
    CONST VOID* lpv,
    int iSize,
    LPINT lpiResult
    )
{
    if (RtlIsTextUnicode( lpv, iSize, lpiResult )) {
        return TRUE;
        }
    else {
        return FALSE;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\advapi32\init.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    init.c

Abstract:

    AdvApi32.dll initialization

Author:

    Robert Reichel (RobertRe) 8-12-92

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include <marta.h>
#include <winsvcp.h>
#include "advapi.h"
#include "tsappcmp.h"


extern CRITICAL_SECTION FeClientLoadCritical;
extern CRITICAL_SECTION SddlSidLookupCritical;
extern CRITICAL_SECTION MSChapChangePassword;

//
// Local prototypes for functions that seem to have no prototypes.
//

BOOLEAN
RegInitialize (
    IN HANDLE Handle,
    IN DWORD Reason,
    IN PVOID Reserved
    );

BOOLEAN
Sys003Initialize (
    IN HANDLE Handle,
    IN DWORD Reason,
    IN PVOID Reserved
    );

BOOLEAN
AppmgmtInitialize (
    IN HANDLE Handle,
    IN DWORD Reason,
    IN PVOID Reserved
    );

BOOLEAN
WmiDllInitialize (
    IN HANDLE Handle,
    IN DWORD Reason,
    IN PVOID Reserved
    );

BOOLEAN
CodeAuthzInitialize (
    IN HANDLE Handle,
    IN DWORD Reason,
    IN PVOID Reserved
    );

// app server has two modes for app compat
BOOLEAN 
AdvApi_InitializeTermsrvFpns( 
    BOOLEAN *pIsInRelaxedSecurityMode,  
    DWORD *pdwCompatFlags  
    );  

#define ADVAPI_PROCESS_ATTACH   ( 1 << DLL_PROCESS_ATTACH )
#define ADVAPI_PROCESS_DETACH   ( 1 << DLL_PROCESS_DETACH )
#define ADVAPI_THREAD_ATTACH    ( 1 << DLL_THREAD_ATTACH  )
#define ADVAPI_THREAD_DETACH    ( 1 << DLL_THREAD_DETACH  )

typedef struct _ADVAPI_INIT_ROUTINE {
    PDLL_INIT_ROUTINE InitRoutine;
    ULONG Flags;
    ULONG CompletedFlags;
} ADVAPI_INIT_ROUTINE, *PADVAPI_INIT_ROUTINE;

typedef struct _ADVAPI_CRITICAL_SECTION {
    PRTL_CRITICAL_SECTION CriticalSection;
    BOOLEAN bInit;
} ADVAPI_CRITICAL_SECTION, *PADVAPI_CREATE_SECTION;

//
// Place all ADVAPI32 initialization hooks in this
// table.
//

ADVAPI_INIT_ROUTINE AdvapiInitRoutines[] = {

    { (PDLL_INIT_ROUTINE) RegInitialize,
            ADVAPI_PROCESS_ATTACH |
            ADVAPI_PROCESS_DETACH |
            ADVAPI_THREAD_ATTACH  |
            ADVAPI_THREAD_DETACH,
            0 },

    { (PDLL_INIT_ROUTINE) Sys003Initialize,
            ADVAPI_PROCESS_ATTACH |
            ADVAPI_PROCESS_DETACH,
            0 },

    { (PDLL_INIT_ROUTINE) MartaDllInitialize,
            ADVAPI_PROCESS_ATTACH |
            ADVAPI_PROCESS_DETACH,
            0 },

    { (PDLL_INIT_ROUTINE) AppmgmtInitialize,
            ADVAPI_PROCESS_ATTACH |
            ADVAPI_PROCESS_DETACH,
            0 },

    { (PDLL_INIT_ROUTINE) WmiDllInitialize,
            ADVAPI_PROCESS_ATTACH |
            ADVAPI_PROCESS_DETACH,
            0 },

    { (PDLL_INIT_ROUTINE) CodeAuthzInitialize,
            ADVAPI_PROCESS_ATTACH |
            ADVAPI_PROCESS_DETACH,
            0 }
};

//
// Place all critical sections used in advapi32 here:
//

ADVAPI_CRITICAL_SECTION AdvapiCriticalSections[] = {
        { &FeClientLoadCritical, FALSE },
        { &SddlSidLookupCritical, FALSE },
        { &Logon32Lock, FALSE },
        { &MSChapChangePassword, FALSE }
};

NTSTATUS
InitializeAdvapiCriticalSections(
    )
{
    ULONG i;
    NTSTATUS Status = STATUS_SUCCESS;

    for (i = 0; i < sizeof(AdvapiCriticalSections) / sizeof(ADVAPI_CRITICAL_SECTION); i++)
    {
        Status = RtlInitializeCriticalSection(AdvapiCriticalSections[i].CriticalSection);

        if (NT_SUCCESS(Status))
        {
            AdvapiCriticalSections[i].bInit = TRUE;
        } 
        else
        {
#if DBG
            DbgPrint("ADVAPI:  Failed to initialize critical section %p at index %d\n", AdvapiCriticalSections[i], i);
#endif
            break;
        }
    }
    return Status;
}

NTSTATUS
DeleteAdvapiCriticalSections(
    )
{
    ULONG i;
    NTSTATUS Status;
    NTSTATUS ReturnStatus = STATUS_SUCCESS;

    for (i = 0; i < sizeof(AdvapiCriticalSections) / sizeof(ADVAPI_CRITICAL_SECTION); i++)
    {
        if (AdvapiCriticalSections[i].bInit)
        {
            Status = RtlDeleteCriticalSection(AdvapiCriticalSections[i].CriticalSection);
            
            if (!NT_SUCCESS(Status))
            {
#if DBG
                DbgPrint("Failed to delete critical section %p at index %d\n", AdvapiCriticalSections[i], i);
#endif
                //
                // Don't exit if failed to delete.  Keep trying to free all the critsects that
                // we can.  Record the failure status.
                //
                
                ReturnStatus = Status;
            }
        }
    }
    return ReturnStatus;
}

BOOLEAN
DllInitialize(
    IN PVOID hmod,
    IN ULONG Reason,
    IN PCONTEXT Context
    )
{
    NTSTATUS Status;
    BOOLEAN  Result;
    ULONG    ReasonMask;
    LONG     i;

    //
    // First, handle all the critical sections
    //

    if (Reason == DLL_PROCESS_ATTACH) 
    {
        Status = InitializeAdvapiCriticalSections();

        if (!NT_SUCCESS(Status))
        {
            Result = FALSE;

            //
            // If any crit sects failed to init then delete all that 
            // may have succeeded.
            //

            (VOID) DeleteAdvapiCriticalSections();
            goto Return;
        }

        if (IsTerminalServer()) 
        {
            BOOLEAN isInRelaxedSecurityMode = FALSE;       // app server is in standard or relaxed security mode
            DWORD   dwCompatFlags           = 0;

            if(AdvApi_InitializeTermsrvFpns(&isInRelaxedSecurityMode, &dwCompatFlags))
            {
                if (isInRelaxedSecurityMode)
                {
                    //
                    // If TS reg key redirection is enabled, then get our special reg key extention flag for this app
                    // called "gdwRegistryExtensionFlags" which is used in screg\winreg\server\ files.
                    // This flag control HKCR per user virtualization and HKLM\SW\Classes per user virtualization and
                    // also modification to access mask.
                    //
                    // Basically, only non-system, non-ts-aware apps on the app server will have this enabled.
                    // Also, we only provide this feature in the relaxed security mode.
                    //
                    // Future work, add DISABLE mask support on per app basis, so that we can turn off this
                    // reg extenion feature on per app basis (just in case).
                    //
                    
                    GetRegistryExtensionFlags(dwCompatFlags);
                }
            }
        }
    }

    //
    // Now, run the subcomponents initialization routines
    //

    ReasonMask = 1 << Reason;
    Result = TRUE;

    for (i = 0; i < sizeof(AdvapiInitRoutines) / sizeof(ADVAPI_INIT_ROUTINE); i++)
    {
        if (AdvapiInitRoutines[i].Flags & ReasonMask)
        {
            //
            // Only run the routines for *DETACH if the routine successfully 
            // completed for *ATTACH
            //

#define FLAG_ON(dw,f) ((f) == ((dw) & (f)))

            if ((Reason == DLL_PROCESS_DETACH && !FLAG_ON(AdvapiInitRoutines[i].CompletedFlags, ADVAPI_PROCESS_ATTACH)) ||
                (Reason == DLL_THREAD_DETACH  && !FLAG_ON(AdvapiInitRoutines[i].CompletedFlags, ADVAPI_THREAD_ATTACH)))
            {
                continue;
            }
            else
            {
                Result = AdvapiInitRoutines[i].InitRoutine(hmod, Reason, Context);

                if (Result)
                {
                    //
                    // The routine succeeded.  Note for which reason it succeeded.
                    //

                    AdvapiInitRoutines[i].CompletedFlags |= ReasonMask;
                }
                else
                {
#if DBG
                    DbgPrint("ADVAPI:  sub init routine %p failed for reason %d\n", AdvapiInitRoutines[i].InitRoutine, Reason);
#endif
                    break;
                }
            }
        }
    }

    //
    // If an initialization routine failed during DLL_PROCESS_ATTACH then clean up
    // and fail. 
    // If this is DLL_PROCESS_DETACH, clean up all the critical sections
    // after the hooks are run.
    //

    if ((!Result && Reason == DLL_PROCESS_ATTACH) || (Reason == DLL_PROCESS_DETACH))
    {
        (VOID) DeleteAdvapiCriticalSections();
        goto Return;
    }

#if DBG
        SccInit(Reason);
#endif

Return:
    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\advapi32\efs.c ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    efs.c

Abstract:

    EFS (Encrypting File System) API Interfaces

Author:

    Robert Reichel      (RobertRe)
    Robert Gu           (RobertG)

Environment:

Revision History:

--*/

#undef WIN32_LEAN_AND_MEAN

#include "advapi.h"
#include <windows.h>
#include <feclient.h>

#define FE_CLIENT_DLL      L"feclient.dll"


//
// Global Variables
//

LPFE_CLIENT_INFO    FeClientInfo   = NULL;
HMODULE             FeClientModule = NULL;
CRITICAL_SECTION    FeClientLoadCritical;


LPWSTR
GetFeClientDll(
    VOID
    )
/*++

Routine Description:

    This routine obtains the name of the currently installed client
    encryption dll (which is currently hardcoded).

Arguments:

    None.

Return Value:

    Returns the name of the current DLL, or NULL on error.

--*/

{
    return( FE_CLIENT_DLL );
}


BOOL
LoadAndInitFeClient(
    VOID
    )

/*++

Routine Description:

    This routine finds the name of the proper client dll (by some as of
    yet unspecified means) and proceeds to load it and initialize it.

Arguments:

    None.

Return Value:

    TRUE on success, FALSE on failure.  Callers may call GetLastError()
    for more error information.

--*/
{
    LPWSTR FeClientDllName;
    LPFEAPI_CLIENT_INITIALIZE ClientInitRoutine;
    BOOL Inited;

    //
    // GetFeClientDll returns a hard coded name.
    // If we get this name dynamically later, we will
    // need to free FeClientDllName.
    //


    FeClientDllName = GetFeClientDll();

    EnterCriticalSection(&FeClientLoadCritical);
    if (FeClientInfo) {
       LeaveCriticalSection(&FeClientLoadCritical);
       return( TRUE );
    }
    if (FeClientDllName) {
        FeClientModule = LoadLibraryW( FeClientDllName );
        if (FeClientModule == NULL) {
            DbgPrint("Unable to load client dll, error = %d\n",GetLastError());
            LeaveCriticalSection(&FeClientLoadCritical);
            return( FALSE );
        }
    }

    ClientInitRoutine = (LPFEAPI_CLIENT_INITIALIZE) GetProcAddress( FeClientModule, (LPCSTR)"FeClientInitialize");



    if (NULL == ClientInitRoutine) {
        FreeLibrary( FeClientModule );
        DbgPrint("Unable to locate init routine, error = %d\n",GetLastError());
        LeaveCriticalSection(&FeClientLoadCritical);
        return( FALSE );
    }

    Inited = (*ClientInitRoutine)( FE_REVISION_1_0, &FeClientInfo );

    LeaveCriticalSection(&FeClientLoadCritical);
    if (!Inited) {
        FreeLibrary( FeClientModule );
        return( FALSE );
    }

    return( TRUE );
}

BOOL
WINAPI
EncryptFileA (
    LPCSTR lpFileName
    )
/*++

Routine Description:

    ANSI Stub to EncryptFileW

Arguments:

    lpFileName - The name of the file to be encrypted.

Return Value:

    TRUE on success, FALSE on failure.  Callers may call GetLastError()
    for more information.

--*/
{
    UNICODE_STRING Unicode;
    WCHAR UnicodeBuffer[STATIC_UNICODE_BUFFER_LENGTH];
    ANSI_STRING AnsiString;
    NTSTATUS Status;

    Unicode.Length = 0;
    Unicode.MaximumLength = STATIC_UNICODE_BUFFER_LENGTH * sizeof( WCHAR );
    Unicode.Buffer = UnicodeBuffer;

    RtlInitAnsiString(&AnsiString,lpFileName);
    Status = RtlAnsiStringToUnicodeString(&Unicode,&AnsiString,FALSE);

    if ( !NT_SUCCESS(Status) ) {
        if ( Status == STATUS_BUFFER_OVERFLOW ) {
            SetLastError(ERROR_FILENAME_EXCED_RANGE);
        } else {
            BaseSetLastNTError(Status);
        }
        return FALSE;
    }

    return ( EncryptFileW( Unicode.Buffer ));

}


BOOL
WINAPI
EncryptFileW (
    LPCWSTR lpFileName
    )
/*++

Routine Description:

    Win32 EncryptFile API

Arguments:

    lpFileName - Supplies the name of the file to be encrypted.

Return Value:

    TRUE on success, FALSE on failure.  Callers may call GetLastError()
    for more information.

--*/
{
    BOOL rc;
    DWORD Result;

    //
    // See if the module has been loaded, and if not, load it into this
    // process.
    //

    if (FeClientInfo == NULL) {
        rc = LoadAndInitFeClient();
        if (!rc) {
            return(rc);
        }
    }

    Result = FeClientInfo->lpServices->EncryptFile( lpFileName );

    if (ERROR_SUCCESS != Result) {
        SetLastError( Result );
        return( FALSE );
    }

    return( TRUE );
}

BOOL
WINAPI
DecryptFileA (
    IN LPCSTR lpFileName,
    IN DWORD  dwRecovery
    )
/*++

Routine Description:

    ANSI Stub for the DecryptFileW API

Arguments:

    lpFileName - Supplies the name of the file to be decrypted.

    dwRecover - Supplies whether this is a recovery operation or a
        normal decryption operation.

Return Value:

    TRUE on success, FALSE on failure.  Callers may call GetLastError()
    for more information.

--*/
{
    UNICODE_STRING Unicode;
    WCHAR UnicodeBuffer[STATIC_UNICODE_BUFFER_LENGTH];
    ANSI_STRING AnsiString;
    NTSTATUS Status;

    Unicode.Length = 0;
    Unicode.MaximumLength = STATIC_UNICODE_BUFFER_LENGTH * sizeof( WCHAR );
    Unicode.Buffer = UnicodeBuffer;

    RtlInitAnsiString(&AnsiString,lpFileName);
    Status = RtlAnsiStringToUnicodeString(&Unicode,&AnsiString,FALSE);

    if ( !NT_SUCCESS(Status) ) {
        if ( Status == STATUS_BUFFER_OVERFLOW ) {
            SetLastError(ERROR_FILENAME_EXCED_RANGE);
        } else {
            BaseSetLastNTError(Status);
        }
        return FALSE;
    }

    return ( DecryptFileW( Unicode.Buffer, dwRecovery ));
}


BOOL
WINAPI
DecryptFileW (
    IN LPCWSTR lpFileName,
    IN DWORD   dwRecovery
    )
/*++

Routine Description:

    Win32 DecryptFile API

Arguments:

    lpFileName - Supplies the name of the file to be encrypted.

Return Value:

    TRUE on success, FALSE on failure.  Callers may call GetLastError()
    for more information.

--*/
{
    BOOL rc;
    DWORD Result;

    //
    // See if the module has been loaded, and if not, load it into this
    // process.
    //

    if (FeClientInfo == NULL) {
        rc = LoadAndInitFeClient();
        if (!rc) {
            return(rc);
        }
    }

    Result = FeClientInfo->lpServices->DecryptFile( lpFileName, dwRecovery );

    if (ERROR_SUCCESS != Result) {
        SetLastError( Result );
        return( FALSE );
    }

    return( TRUE );

}

BOOL
WINAPI
FileEncryptionStatusA (
    LPCSTR    lpFileName,
    LPDWORD   lpStatus
    )
/*++

Routine Description:

    ANSI Stub to FileEncryptionStatusW

Arguments:

    lpFileName - The name of the file to be checked.
    lpStatus - The status of the file.

Return Value:

    TRUE on success, FALSE on failure. Callers may call GetLastError() for more information.

--*/
{
    ANSI_STRING AnsiString;
    NTSTATUS Status;
    UNICODE_STRING Unicode;
    WCHAR UnicodeBuffer[STATIC_UNICODE_BUFFER_LENGTH];

    Unicode.Length = 0;
    Unicode.MaximumLength = STATIC_UNICODE_BUFFER_LENGTH * sizeof( WCHAR );
    Unicode.Buffer = UnicodeBuffer;

    RtlInitAnsiString(&AnsiString,lpFileName);
    Status = RtlAnsiStringToUnicodeString(&Unicode,&AnsiString,FALSE);

    if ( !NT_SUCCESS(Status) ) {
        if ( Status == STATUS_BUFFER_OVERFLOW ) {
            SetLastError(ERROR_FILENAME_EXCED_RANGE);
        } else {
            BaseSetLastNTError(Status);
        }
        return FALSE;
    }

    return ( FileEncryptionStatusW( Unicode.Buffer, lpStatus ));

}

BOOL
WINAPI
FileEncryptionStatusW (
    LPCWSTR    lpFileName,
    LPDWORD    lpStatus
    )
/*++

Routine Description:

    Win32 FileEncryptionStatus API

Arguments:

    lpFileName - Supplies the name of the file to be encrypted.
    lpStatus - The status of the file.

Return Value:

    TRUE on success, FALSE on failure. Callers may call GetLastError()
    for more information.

--*/
{

    BOOL rc;
    DWORD Result;

    //
    // See if the module has been loaded, and if not, load it into this
    // process.
    //

    if (FeClientInfo == NULL) {
        rc = LoadAndInitFeClient();
        if (!rc) {
            return(rc);
        }
    }

    return (FeClientInfo->lpServices->FileEncryptionStatus( lpFileName, lpStatus ));

}

DWORD
WINAPI
OpenEncryptedFileRawA(
    LPCSTR          lpFileName,
    ULONG           Flags,
    PVOID *         Context
    )
{
    ANSI_STRING AnsiString;
    NTSTATUS Status;
    UNICODE_STRING Unicode;
    WCHAR UnicodeBuffer[STATIC_UNICODE_BUFFER_LENGTH];

    Unicode.Length = 0;
    Unicode.MaximumLength = STATIC_UNICODE_BUFFER_LENGTH * sizeof( WCHAR );
    Unicode.Buffer = UnicodeBuffer;

    RtlInitAnsiString(&AnsiString,lpFileName);
    Status = RtlAnsiStringToUnicodeString(&Unicode,&AnsiString,FALSE);

    if ( !NT_SUCCESS(Status) ) {
        if ( Status == STATUS_BUFFER_OVERFLOW ) {
            SetLastError(ERROR_FILENAME_EXCED_RANGE);
        } else {
            BaseSetLastNTError(Status);
        }
        return FALSE;
    }

    return ( OpenEncryptedFileRawW( Unicode.Buffer, Flags, Context ));
}




DWORD
WINAPI
OpenEncryptedFileRawW(
    LPCWSTR         lpFileName,
    ULONG           Flags,
    PVOID *         Context
    )
{
    BOOL rc;
    DWORD Result;

    //
    // See if the module has been loaded, and if not, load it into this
    // process.
    //

    if (FeClientInfo == NULL) {
        rc = LoadAndInitFeClient();
        if (!rc) {
            return(GetLastError());
        }
    }

    return (FeClientInfo->lpServices->OpenFileRaw( lpFileName, Flags, Context ));
}


DWORD
WINAPI
ReadEncryptedFileRaw(
    PFE_EXPORT_FUNC ExportCallback,
    PVOID           CallbackContext,
    PVOID           Context
    )
{
    //
    // It doesn't make sense to call this before calling OpenRaw, so don't
    // bother checking to see if the module is loaded or not.  We'll fault
    // in the user process if it isn't.
    //

    return (FeClientInfo->lpServices->ReadFileRaw( ExportCallback, CallbackContext, Context ));
}

DWORD
WINAPI
WriteEncryptedFileRaw(
    PFE_IMPORT_FUNC ImportCallback,
    PVOID           CallbackContext,
    PVOID           Context
    )
{
    //
    // It doesn't make sense to call this before calling OpenRaw, so don't
    // bother checking to see if the module is loaded or not.  We'll fault
    // in the user process if it isn't.
    //

    return (FeClientInfo->lpServices->WriteFileRaw( ImportCallback, CallbackContext, Context ));
}

VOID
WINAPI
CloseEncryptedFileRaw(
    PVOID           Context
    )
{
    FeClientInfo->lpServices->CloseFileRaw( Context );

    return;
}


DWORD
QueryUsersOnEncryptedFile(
    IN  LPCWSTR lpFileName,
    OUT PENCRYPTION_CERTIFICATE_HASH_LIST * pUsers
    )
/*++

Routine Description:

    Win32 interface for adding users to an encrypted file.

Arguments:

    lpFileName - Supplies the name of the file to be modified.

    pUsers - Returns a list of users on the file.  This parameter
        must be passed to FreeEncryptionCertificateHashList() when
        no longer needed.

Return Value:

    Win32 error.

--*/

{
    DWORD rc;

    //
    // See if the module has been loaded, and if not, load it into this
    // process.
    //

    if (FeClientInfo == NULL) {
        rc = LoadAndInitFeClient();
        if (!rc) {
            return(rc);
        }
    }

    if ((lpFileName != NULL) && (pUsers != NULL)) {
        return(FeClientInfo->lpServices->QueryUsers( lpFileName, pUsers ));
    } else {
        return( ERROR_INVALID_PARAMETER );
    }
}


VOID
FreeEncryptionCertificateHashList(
    IN PENCRYPTION_CERTIFICATE_HASH_LIST pUsers
    )
/*++

Routine Description:

    Frees a certificate hash list as returned by QueryUsersOnEncryptedFile()
    and QueryRecoveryAgentsOnEncryptedFile().

Arguments:

    Supplies a list of users returned from QueryUsersOnEncryptedFile().

Return Value:

    Win32 error.

--*/
{

    //
    // It is probably safe to assume that feclient.dll is loaded,
    // since we wouldn't have one of these structures to free
    // if it weren't.
    //

    if (pUsers != NULL) {
        FeClientInfo->lpServices->FreeCertificateHashList( pUsers );
    } else {

        //
        // nothing to do
        //
    }

    return;
}


DWORD
QueryRecoveryAgentsOnEncryptedFile(
    IN  LPCWSTR lpFileName,
    OUT PENCRYPTION_CERTIFICATE_HASH_LIST * pRecoveryAgents
    )
/*++

Routine Description:

    This routine returns a list of recovery agents on an encrypted
    file.

Arguments:

    lpFileName - Supplies the name of the file to be examined.

    pRecoveryAgents - Returns a list of recovery agents, represented
        by certificate hashes on the file.  This list should be freed
        by calling FreeEncryptionCertificateHashList().

Return Value:

    return-value - Description of conditions needed to return value. - or -
    None.

--*/
{
    DWORD rc;

    //
    // See if the module has been loaded, and if not, load it into this
    // process.
    //

    if (FeClientInfo == NULL) {
        rc = LoadAndInitFeClient();
        if (!rc) {
            return(rc);
        }
    }

    if ((lpFileName != NULL) && (pRecoveryAgents != NULL)) {
        return(FeClientInfo->lpServices->QueryRecoveryAgents( lpFileName, pRecoveryAgents ));
    } else {
        return( ERROR_INVALID_PARAMETER );
    }
}


DWORD
RemoveUsersFromEncryptedFile(
    IN LPCWSTR lpFileName,
    IN PENCRYPTION_CERTIFICATE_HASH_LIST pHashes
    )
/*++

Routine Description:

    Takes a list of certificate hashes to be removed
    from the passed file.  Any that are found are removed,
    the rest are ignored with no error return.

Arguments:

    lpFileName - Supplies the name of the file to be modified.

    pHashes - Supplies the list of hashes to be removed.

Return Value:

    Win32 Error

--*/
{
    DWORD rc;

    //
    // See if the module has been loaded, and if not, load it into this
    // process.
    //

    if (FeClientInfo == NULL) {
        rc = LoadAndInitFeClient();
        if (!rc) {
            return(rc);
        }
    }

    if ((lpFileName != NULL) && (pHashes != NULL)) {
        return(FeClientInfo->lpServices->RemoveUsers( lpFileName, pHashes ));
    } else {
        return( ERROR_INVALID_PARAMETER );
    }
}

DWORD
AddUsersToEncryptedFile(
    IN LPCWSTR lpFileName,
    IN PENCRYPTION_CERTIFICATE_LIST pEncryptionCertificates
    )
/*++

Routine Description:

    This routine adds user keys to the passed encrypted file.

Arguments:

    lpFileName - Supplies the name of the file to be encrypted.

    pEncryptionCertificates - Supplies the list of certificates for
        new users to be added to the file.

Return Value:

    Win32 Error

--*/
{
    DWORD rc;

    //
    // See if the module has been loaded, and if not, load it into this
    // process.
    //

    if (FeClientInfo == NULL) {
        rc = LoadAndInitFeClient();
        if (!rc) {
            return(rc);
        }
    }

    if ((lpFileName != NULL) && (pEncryptionCertificates != NULL)) {
        return(FeClientInfo->lpServices->AddUsers( lpFileName, pEncryptionCertificates ));
    } else {
        return( ERROR_INVALID_PARAMETER );
    }
}

DWORD
SetUserFileEncryptionKey(
    PENCRYPTION_CERTIFICATE pEncryptionCertificate
    )
/*++

Routine Description:

    This routine will set the user's current EFS key to the one
    contained in the passed certificate.  If no certificate is
    passed, a new key will be generated automatically.

Arguments:

    pEncryptionCertificate - Optionally supplies the certificate
        containing the new public key.

Return Value:

    Win32 error

--*/
{
    DWORD rc;

    //
    // See if the module has been loaded, and if not, load it into this
    // process.
    //

    if (FeClientInfo == NULL) {
        rc = LoadAndInitFeClient();
        if (!rc) {
            return(rc);
        }
    }

    return(FeClientInfo->lpServices->SetKey( pEncryptionCertificate ));

    /*
    if (pEncryptionCertificate != NULL) {
        return(FeClientInfo->lpServices->SetKey( pEncryptionCertificate ));
    } else {
        return( ERROR_INVALID_PARAMETER );
    }*/
}

DWORD
DuplicateEncryptionInfoFile(
     IN LPCWSTR SrcFileName,
     IN LPCWSTR DstFileName, 
     IN DWORD dwCreationDistribution, 
     IN DWORD dwAttributes, 
     IN CONST LPSECURITY_ATTRIBUTES lpSecurityAttributes
     )
/*++

Routine Description:

    This routine duplicates the encryption information from the source file to the
    destination file. Destination file will be created if not existing.

    The destination file is overwritten.

Arguments:

    SrcFileName - Supplies the source of the encryption information.

    DstFileName - Supplies the target file, exclusive open is required on this file.
    
    dwCreationDistribution - Create options. 
                             If dwCreationDistribution != CREATE_NEW, dwCreationDistribution = CREATE_ALWAYS
                             
    dwAttributes - File attributes.
    
    lpSecurityAttributes - Security attributes.
    
    

Return Value:

    Win32 error on failure.

--*/

{
    DWORD rc;

    if (FeClientModule == NULL) {
        rc = LoadAndInitFeClient();
        if (!rc) {
            return(rc);
        }
    }

    if (SrcFileName && DstFileName) {
        return(FeClientInfo->lpServices->DuplicateEncryptionInfo( SrcFileName, 
                                                                  DstFileName, 
                                                                  dwCreationDistribution,
                                                                  dwAttributes,
                                                                  lpSecurityAttributes
                                                                 ));
    } else {
        return( ERROR_INVALID_PARAMETER );
    }
}


BOOL
WINAPI
EncryptionDisable(
    IN LPCWSTR DirPath,
    IN BOOL Disable
    )

/*++

Routine Description:

    This routine disable and enable EFS in the directory DirPath.
        
Arguments:

    DirPath - Directory path.

    Disable - TRUE to disable
    

Return Value:

    TRUE for SUCCESS

--*/
{
    DWORD rc;

    //
    // See if the module has been loaded, and if not, load it into this
    // process.
    //

    if (FeClientInfo == NULL) {
        rc = LoadAndInitFeClient();
        if (!rc) {
            return(rc);
        }
    }

    return(FeClientInfo->lpServices->DisableDir( DirPath, Disable ));

}


WINADVAPI
DWORD
WINAPI
EncryptedFileKeyInfo(
    IN  LPCWSTR lpFileName,
    IN  DWORD   InfoClass,
    OUT PEFS_RPC_BLOB * KeyInfo
    )
/*++

Routine Description:

    Win32 interface for adding users to an encrypted file.

Arguments:

    lpFileName - Supplies the name of the file to be modified.
    
    InfoClass  - Information requested. Only support 1 for now.

    KeyInfo - Returns Key info
    
Return Value:

    Win32 error.

--*/

{
    DWORD rc;

    //
    // See if the module has been loaded, and if not, load it into this
    // process.
    //

    if (FeClientInfo == NULL) {
        rc = LoadAndInitFeClient();
        if (!rc) {
            return(rc);
        }
    }

    if ((lpFileName != NULL) && (KeyInfo != NULL)) {
        return(FeClientInfo->lpServices->GetKeyInfo( lpFileName, InfoClass, KeyInfo ));
    } else {
        return( ERROR_INVALID_PARAMETER );
    }
}



WINADVAPI
VOID
WINAPI
FreeEncryptedFileKeyInfo(
    IN PEFS_RPC_BLOB pKeyInfo
    )
/*++

Routine Description:

    Frees a KeyInfo as returned by EncryptedFileKeyInfo();
    
Arguments:

    pKeyInfo - Supplies a KeyInfo returned from EncryptedFileKeyInfo().

Return Value:

    No.

--*/
{

    //
    // It is probably safe to assume that feclient.dll is loaded,
    // since we wouldn't have one of these structures to free
    // if it weren't.
    //

    if (pKeyInfo != NULL) {
        FeClientInfo->lpServices->FreeKeyInfo( pKeyInfo );
    } else {

        //
        // nothing to do
        //
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\advapi32\eventapi.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    EVENTAPI.C

Abstract:

    This module contains the client ends of the EventLog APIs.

Author:

    Rajen Shah  (rajens)    24-Aug-1991


Revision History:


--*/

#include "advapi.h"

static WCHAR wszDosDevices[] = L"\\DosDevices\\";

ULONG
BaseSetLastNTError(
    IN NTSTATUS Status
    )

/*++

Routine Description:

    This API sets the "last error value" and the "last error string"
    based on the value of Status. For status codes that don't have
    a corresponding error string, the string is set to null.

Arguments:

    Status - Supplies the status value to store as the last error value.

Return Value:

    The corresponding Win32 error code that was stored in the
    "last error value" thread variable.

--*/

{
    ULONG dwErrorCode;

    dwErrorCode = RtlNtStatusToDosError( Status );
    SetLastError( dwErrorCode );
    return( dwErrorCode );
}


BOOL
InitAnsiString(
    OUT PANSI_STRING DestinationString,
    IN PCSZ SourceString OPTIONAL
    )

/*++

Routine Description:

    The RtlInitAnsiString function initializes an NT counted string.
    The DestinationString is initialized to point to the SourceString
    and the Length and MaximumLength fields of DestinationString are
    initialized to the length of the SourceString, which is zero if
    SourceString is not specified.

    This is RtlInitAnsiString with a return status that rejects strings
    that are greater than 64K bytes.

Arguments:

    DestinationString - Pointer to the counted string to initialize

    SourceString - Optional pointer to a null terminated string that
        the counted string is to point to.


Return Value:

    None.

--*/

{
    ULONG Length = 0;
    DestinationString->Length = 0;
    DestinationString->Buffer = (PCHAR)SourceString;
    if (ARGUMENT_PRESENT( SourceString )) {
        while (*SourceString++) {
            Length++;
        }

        //
        // Make sure the length won't overflow a USHORT when converted to
        // UNICODE characters
        //

        if (Length * sizeof(WCHAR) > 0xFFFF) {
            return(FALSE);
        }

        DestinationString->Length = (USHORT) Length;
        DestinationString->MaximumLength = (USHORT) (Length + 1);

    }
    else {
        DestinationString->MaximumLength = 0;
        DestinationString->Length = 0;
    }

    return(TRUE);
}


BOOL
InitUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN PCWSTR SourceString OPTIONAL
    )

/*++

Routine Description:

    The InitUnicodeString function initializes an NT counted
    unicode string.  The DestinationString is initialized to point to
    the SourceString and the Length and MaximumLength fields of
    DestinationString are initialized to the length of the SourceString,
    which is zero if SourceString is not specified.

    This is RtlInitUnicodeString with a return status that rejects strings
    that are greater than 64K bytes.

Arguments:

    DestinationString - Pointer to the counted string to initialize

    SourceString - Optional pointer to a null terminated unicode string that
        the counted string is to point to.


Return Value:

    None.

--*/

{
    ULONG Length = 0;
    DestinationString->Length = 0;
    DestinationString->Buffer = (PWSTR)SourceString;
    if (ARGUMENT_PRESENT( SourceString )) {
        while (*SourceString++) {
            Length += sizeof(*SourceString);
        }

        //
        // Make sure the length won't overflow a USHORT
        //

        if (Length > 0xFFFF) {
            return(FALSE);
        }

        DestinationString->Length = (USHORT) Length;
        DestinationString->MaximumLength =
            (USHORT) Length + (USHORT) sizeof(UNICODE_NULL);
    }
    else {
        DestinationString->MaximumLength = 0;
        DestinationString->Length = 0;
    }

    return(TRUE);
}

//
// Single version API's (no strings)
//

BOOL
CloseEventLog (
    HANDLE hEventLog
    )

/*++

Routine Description:

  This is the client DLL entry point for the WinCloseEventLog API.
  It closes the RPC binding, and frees any memory allocated for the
  handle.

  NOTE that there is no equivalent call for ANSI.

Arguments:

    LogHandle       - Handle returned from a previous "Open" call.


Return Value:

    Returns TRUE if success, FALSE otherwise.


--*/
{
    NTSTATUS Status;
    BOOL ReturnValue;

    Status = ElfCloseEventLog (hEventLog);

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        ReturnValue = FALSE;
    } else {
        ReturnValue = TRUE;
    }
    return ReturnValue;

}



BOOL
DeregisterEventSource (
    HANDLE hEventLog
    )

/*++

Routine Description:

  This is the client DLL entry point for the DeregisterEventSource API.
  It closes the RPC binding, and frees any memory allocated for the
  handle.

  NOTE that there is no equivalent call for ANSI.

Arguments:

    LogHandle       - Handle returned from a previous "Open" call.


Return Value:

    Returns TRUE if success, FALSE otherwise.


--*/
{
    NTSTATUS Status;
    BOOL ReturnValue;

    Status = ElfDeregisterEventSource (hEventLog);

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        ReturnValue = FALSE;
    } else {
        ReturnValue = TRUE;
    }
    return ReturnValue;

}

BOOL
NotifyChangeEventLog(
    HANDLE  hEventLog,
    HANDLE  hEvent
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    NTSTATUS Status;

    Status = ElfChangeNotify(hEventLog,hEvent);

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return(FALSE);
    } else {
        return(TRUE);
    }
}

BOOL
GetNumberOfEventLogRecords (
    HANDLE hEventLog,
    PDWORD NumberOfRecords
    )

/*++

Routine Description:

  This is the client DLL entry point that returns the number of records in
  the eventlog specified by hEventLog.

  NOTE that there is no equivalent call for ANSI.

Arguments:

    LogHandle       - Handle returned from a previous "Open" call.
    NumberOfRecords - Pointer to a DWORD to place the number of records.


Return Value:

    Returns TRUE if success, FALSE otherwise.


--*/
{
    NTSTATUS Status;
    BOOL ReturnValue;

    Status = ElfNumberOfRecords (hEventLog, NumberOfRecords);

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        ReturnValue = FALSE;
    } else {
        ReturnValue = TRUE;
    }
    return ReturnValue;

}



BOOL
GetOldestEventLogRecord (
    HANDLE hEventLog,
    PDWORD OldestRecord
    )

/*++

Routine Description:

  This is the client DLL entry point that returns the record number of the
  oldest record in the eventlog specified by hEventLog.

  NOTE that there is no equivalent call for ANSI.

Arguments:

    LogHandle       - Handle returned from a previous "Open" call.
    OldestRecord    - Pointer to a DWORD to place the record number of the
                      oldest record in the eventlog specified by hEventLog


Return Value:

    Returns TRUE if success, FALSE otherwise.


--*/
{
    NTSTATUS Status;
    BOOL ReturnValue;

    Status = ElfOldestRecord (hEventLog, OldestRecord);

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        ReturnValue = FALSE;
    } else {
        ReturnValue = TRUE;
    }
    return ReturnValue;

}


BOOL
GetEventLogInformation (
    HANDLE    hEventLog,
    DWORD     dwInfoLevel,
    PVOID     lpBuffer,
    DWORD     cbBufSize,
    LPDWORD   pcbBytesNeeded
    )

/*++

Routine Description:

  This is the client DLL entry point that returns information about
  the eventlog specified by hEventLog.

Arguments:

    LogHandle       - Handle returned from a previous "Open" call.
    dwInfoLevel     - Which information to return
    lpBuffer        - Pointer to buffer to hold information
    cbBufSize       - Size of buffer, in bytes
    pcbBytesNeeded  - Number of bytes needed

Return Value:

    Returns TRUE if success, FALSE otherwise.


--*/
{
    NTSTATUS ntStatus;

    ntStatus = ElfGetLogInformation(hEventLog,
                                    dwInfoLevel,
                                    lpBuffer,
                                    cbBufSize,
                                    pcbBytesNeeded);

    if (!NT_SUCCESS(ntStatus)) {
        BaseSetLastNTError(ntStatus);
        return FALSE;
    }

    return TRUE;
}


//
// UNICODE APIs
//

BOOL
ClearEventLogW (
    HANDLE hEventLog,
    LPCWSTR BackupFileName
    )

/*++

Routine Description:

  This is the client DLL entry point for the ClearEventLogFile API.
  The call is passed to the eventlog service on the appropriate server
  identified by LogHandle.


Arguments:

    LogHandle       - Handle returned from a previous "Open" call. This is
                      used to identify the module and the server.

    BackupFileName  - Name of the file to back up the current log file.
                      NULL implies not to back up the file.


Return Value:

    TRUE if success, FALSE otherwise.


--*/
{

    UNICODE_STRING Unicode;
    UNICODE_STRING DLUnicode;   // Downlevel NT filename.
    NTSTATUS Status;
    BOOL ReturnValue;

    //
    // Turn the Dos filename into an NT filename
    //

    if (BackupFileName) {
        ReturnValue = RtlDosPathNameToNtPathName_U(BackupFileName, &Unicode, NULL, NULL);
        if (!BackupFileName || !ReturnValue) {
           SetLastError(ERROR_INVALID_PARAMETER);
           return(FALSE);
        }
    }
    else {
        Unicode.Length = 0;
        Unicode.MaximumLength = 0;
        Unicode.Buffer = NULL;
    }

    Status = ElfClearEventLogFileW (hEventLog, &Unicode);

    //
    // With NT 4.0, NT filenames are preceeded with \?? vs. \DosDevices
    // in 3.51. This retry logic exists for 3.51 machines which don't
    // recognize NT 4.0 filenames. The API should have passed Windows
    // filenames vs NT.
    //

    if (Status == STATUS_OBJECT_PATH_NOT_FOUND && BackupFileName != NULL) {
        DLUnicode.MaximumLength = (wcslen(BackupFileName) * sizeof(WCHAR)) +
                                            sizeof(wszDosDevices);

        DLUnicode.Buffer = RtlAllocateHeap(
                                RtlProcessHeap(), 0,
                                DLUnicode.MaximumLength);

        if (DLUnicode.Buffer != NULL) {
            wcscpy(DLUnicode.Buffer, wszDosDevices);
            wcscat(DLUnicode.Buffer, BackupFileName);
            DLUnicode.Length = DLUnicode.MaximumLength - sizeof(UNICODE_NULL);

            Status = ElfClearEventLogFileW (hEventLog, &DLUnicode);
            RtlFreeHeap(RtlProcessHeap(), 0, DLUnicode.Buffer);
        }
        else {
            Status = STATUS_NO_MEMORY;
        }
    }

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        ReturnValue = FALSE;
    } else {
        ReturnValue = TRUE;
    }

    if (Unicode.MaximumLength) {
        RtlFreeHeap(RtlProcessHeap(), 0, Unicode.Buffer);
    }
    return ReturnValue;

}



BOOL
BackupEventLogW (
    HANDLE hEventLog,
    LPCWSTR BackupFileName
    )

/*++

Routine Description:

  This is the client DLL entry point for the BackupEventLogFile API.
  The call is passed to the eventlog service on the appropriate server
  identified by LogHandle.


Arguments:

    LogHandle       - Handle returned from a previous "Open" call. This is
                      used to identify the module and the server.

    BackupFileName  - Name of the file to back up the current log file.


Return Value:

    TRUE if success, FALSE otherwise.


--*/
{

    UNICODE_STRING Unicode;
    UNICODE_STRING DLUnicode;   // Downlevel NT filename.
    NTSTATUS Status;
    BOOL ReturnValue = TRUE;

    //
    // Turn the Dos filename into an NT filename
    //

    if (BackupFileName) {
        ReturnValue = RtlDosPathNameToNtPathName_U(BackupFileName, &Unicode,
            NULL, NULL);
    }

    if (!BackupFileName || !ReturnValue) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    Status = ElfBackupEventLogFileW (hEventLog, &Unicode);

    //
    // With NT 4.0, NT filenames are preceeded with \?? vs. \DosDevices
    // in 3.51. This retry logic exists for 3.51 machines which don't
    // recognize NT 4.0 filenames. The API should have passed Windows
    // filenames vs NT.
    //

    if (Status == STATUS_OBJECT_PATH_NOT_FOUND && BackupFileName != NULL) {
        DLUnicode.MaximumLength = (wcslen(BackupFileName) * sizeof(WCHAR)) +
                                            sizeof(wszDosDevices);

        DLUnicode.Buffer = RtlAllocateHeap(
                                RtlProcessHeap(), 0,
                                DLUnicode.MaximumLength);

        if (DLUnicode.Buffer != NULL) {
            wcscpy(DLUnicode.Buffer, wszDosDevices);
            wcscat(DLUnicode.Buffer, BackupFileName);
            DLUnicode.Length = DLUnicode.MaximumLength - sizeof(UNICODE_NULL);

            Status = ElfBackupEventLogFileW (hEventLog, &DLUnicode);
            RtlFreeHeap(RtlProcessHeap(), 0, DLUnicode.Buffer);
        }
        else {
            Status = STATUS_NO_MEMORY;
        }
    }

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        ReturnValue = FALSE;
    } else {
        ReturnValue = TRUE;
    }

    if (Unicode.MaximumLength) {
        RtlFreeHeap(RtlProcessHeap(), 0, Unicode.Buffer);
    }
    return ReturnValue;

}


HANDLE
OpenEventLogW (
    LPCWSTR  UNCServerName,
    LPCWSTR  ModuleName
    )

/*++

Routine Description:

    This is the client DLL entry point for the WinOpenEventLog API.

    It creates an RPC binding for the server specified, and stores that
    and additional data away. It returns a handle to the caller that can
    be used to later on access the handle-specific information.

Arguments:

    UNCServerName     - Server with which to bind for subsequent operations.

    ModuleName        - Supplies the name of the module to associate with
                        this handle.


Return Value:

    Returns a handle that can be used for subsequent Win API calls. If
    the handle is NULL, then an error occurred.


--*/
{

    UNICODE_STRING Unicode;
    UNICODE_STRING UnicodeModuleName;
    HANDLE LogHandle;
    NTSTATUS Status;
    HANDLE ReturnHandle;

    RtlInitUnicodeString(&UnicodeModuleName,ModuleName);
    RtlInitUnicodeString(&Unicode, UNCServerName);

    Status = ElfOpenEventLogW (
                        &Unicode,
                        &UnicodeModuleName,
                        &LogHandle
                        );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        ReturnHandle = (HANDLE)NULL;
    } else {
        ReturnHandle = (HANDLE)LogHandle;
    }

    return ReturnHandle;
}


HANDLE
RegisterEventSourceW (
    LPCWSTR  UNCServerName,
    LPCWSTR  ModuleName
    )

/*++

Routine Description:

    This is the client DLL entry point for the RegisterEventSource API.

    It creates an RPC binding for the server specified, and stores that
    and additional data away. It returns a handle to the caller that can
    be used to later on access the handle-specific information.

Arguments:

    UNCServerName     - Server with which to bind for subsequent operations.

    ModuleName        - Supplies the name of the module to associate with
                        this handle.


Return Value:

    Returns a handle that can be used for subsequent Win API calls. If
    the handle is NULL, then an error occurred.


--*/
{

    UNICODE_STRING Unicode;
    UNICODE_STRING UnicodeModuleName;
    HANDLE LogHandle;
    NTSTATUS Status;
    HANDLE ReturnHandle;

    RtlInitUnicodeString(&UnicodeModuleName,ModuleName);
    RtlInitUnicodeString(&Unicode, UNCServerName);

    Status = ElfRegisterEventSourceW (
                        &Unicode,
                        &UnicodeModuleName,
                        &LogHandle
                        );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        ReturnHandle = (HANDLE)NULL;
    } else {
        ReturnHandle = (HANDLE)LogHandle;
    }

    return ReturnHandle;
}


HANDLE
OpenBackupEventLogW (
    LPCWSTR  UNCServerName,
    LPCWSTR  FileName
    )

/*++

Routine Description:

    This is the client DLL entry point for the OpenBackupEventLog API.

    It creates an RPC binding for the server specified, and stores that
    and additional data away. It returns a handle to the caller that can
    be used to later on access the handle-specific information.

Arguments:

    UNCServerName   - Server with which to bind for subsequent operations.

    FileName        - Supplies the filename of the logfile to associate with
                      this handle.


Return Value:

    Returns a handle that can be used for subsequent Win API calls. If
    the handle is NULL, then an error occurred.


--*/
{

    UNICODE_STRING Unicode;
    UNICODE_STRING UnicodeFileName;
    UNICODE_STRING DLUnicode;   // Downlevel NT filename.
    HANDLE LogHandle;
    NTSTATUS Status = STATUS_SUCCESS;
    HANDLE ReturnHandle;

    RtlInitUnicodeString(&Unicode, UNCServerName);
    RtlInitUnicodeString(&UnicodeFileName, NULL);

    //
    // Turn the Dos filename into an NT filename if it was given
    //
    if (FileName)
    {
        if (!RtlDosPathNameToNtPathName_U(FileName, &UnicodeFileName, NULL, NULL))
        {
            Status = STATUS_OBJECT_NAME_INVALID;
        }
    }

    if (NT_SUCCESS(Status))
    {
        Status = ElfOpenBackupEventLogW (
                            &Unicode,
                            &UnicodeFileName,
                            &LogHandle
                            );

        //
        // With NT 4.0, NT filenames are preceeded with \?? vs. \DosDevices
        // in 3.51. This retry logic exists for 3.51 machines which don't
        // recognize NT 4.0 filenames. The API should have passed Windows
        // filenames vs NT.
        //

        if (Status == STATUS_OBJECT_PATH_NOT_FOUND && FileName != NULL)
        {
            DLUnicode.MaximumLength = (wcslen(FileName) * sizeof(WCHAR)) +
                                                sizeof(wszDosDevices);

            DLUnicode.Buffer = RtlAllocateHeap(
                                    RtlProcessHeap(), 0,
                                    DLUnicode.MaximumLength);

            if (DLUnicode.Buffer != NULL)
            {
                wcscpy(DLUnicode.Buffer, wszDosDevices);
                wcscat(DLUnicode.Buffer, FileName);
                DLUnicode.Length = DLUnicode.MaximumLength - sizeof(UNICODE_NULL);

                Status = ElfOpenBackupEventLogW (
                                    &Unicode,
                                    &DLUnicode,
                                    &LogHandle
                                );
                RtlFreeHeap(RtlProcessHeap(), 0, DLUnicode.Buffer);
            }
            else
            {
                Status = STATUS_NO_MEMORY;
            }
        }
    }

    if (!NT_SUCCESS(Status))
    {
        BaseSetLastNTError(Status);
        ReturnHandle = NULL;
    }
    else
    {
        ReturnHandle = LogHandle;
    }

    if (UnicodeFileName.MaximumLength)
    {
        RtlFreeHeap(RtlProcessHeap(), 0, UnicodeFileName.Buffer);
    }

    return ReturnHandle;
}





BOOL
ReadEventLogW (
    HANDLE      hEventLog,
    DWORD       dwReadFlags,
    DWORD       dwRecordOffset,
    LPVOID      lpBuffer,
    DWORD       nNumberOfBytesToRead,
    DWORD       *pnBytesRead,
    DWORD       *pnMinNumberOfBytesNeeded
    )

/*++

Routine Description:

  This is the client DLL entry point for the WinreadEventLog API.

Arguments:



Return Value:

    Returns count of bytes read. Zero of none read.


--*/
{

    NTSTATUS Status;
    BOOL ReturnValue;

    Status = ElfReadEventLogW (
                        hEventLog,
                        dwReadFlags,
                        dwRecordOffset,
                        lpBuffer,
                        nNumberOfBytesToRead,
                        pnBytesRead,
                        pnMinNumberOfBytesNeeded
                        );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        ReturnValue = FALSE;
    } else {
        ReturnValue = TRUE;
    }
    return ReturnValue;

}



BOOL
ReportEventW (
    HANDLE      hEventLog,
    WORD        wType,
    WORD        wCategory       OPTIONAL,
    DWORD       dwEventID,
    PSID        lpUserSid       OPTIONAL,
    WORD        wNumStrings,
    DWORD       dwDataSize,
    LPCWSTR     *lpStrings      OPTIONAL,
    LPVOID      lpRawData       OPTIONAL
    )

/*++

Routine Description:

  This is the client DLL entry point for the ReportEvent API.

Arguments:


Return Value:

    Returns TRUE if success, FALSE otherwise.


--*/
{

    NTSTATUS Status = STATUS_SUCCESS;
    BOOL ReturnValue;
    PUNICODE_STRING  *pUStrings;
    ULONG   i;
    ULONG AllocatedStrings;

    //
    // Convert the array of strings to an array of PUNICODE_STRINGs
    // before calling ElfReportEventW.
    //
    pUStrings = RtlAllocateHeap(
                            RtlProcessHeap(), 0,
                            wNumStrings * sizeof(PUNICODE_STRING)
                            );

    if (pUStrings) {

        //
        // Guard the memory allocation above while we peruse the user's
        // buffer. If not, we'd leak it on an exception.
        //

        try {
            //
            // For each string passed in, allocate a UNICODE_STRING structure
            // and set it to the matching string.
            //
            for (AllocatedStrings = 0; AllocatedStrings < wNumStrings;
              AllocatedStrings++) {
                pUStrings[AllocatedStrings] = RtlAllocateHeap(
                                RtlProcessHeap(), 0,
                                sizeof(UNICODE_STRING)
                                );

                if (pUStrings[AllocatedStrings]) {

                    if (!InitUnicodeString(
                                pUStrings[AllocatedStrings],
                                lpStrings[AllocatedStrings]
                                )) {
                        //
                        // This string was invalid (> 64K bytes) give up
                        // and make sure we only free the ones we've already
                        // allocated (including this last one)
                        //

                        AllocatedStrings++;
                        Status = STATUS_INVALID_PARAMETER;
                        break;
                    }
                }
            }
        }
        except (EXCEPTION_EXECUTE_HANDLER) {
            Status = STATUS_INVALID_PARAMETER;
        }

        if (Status == STATUS_SUCCESS) {
            Status = ElfReportEventW (
                            hEventLog,
                            wType,
                            wCategory,
                            dwEventID,
                            lpUserSid,
                            wNumStrings,
                            dwDataSize,
                            pUStrings,
                            lpRawData,
                            0,            // Flags        -  Paired event
                            NULL,         // RecordNumber  | support.  Not
                            NULL          // TimeWritten  -  in P1
                            );
        }

        //
        // Free the space allocated for the UNICODE strings
        // and then free the space for the array.
        //
        for (i = 0; i < AllocatedStrings; i++) {
            if (pUStrings[i])
                RtlFreeHeap (RtlProcessHeap(), 0, pUStrings[i]);
        }
        RtlFreeHeap (RtlProcessHeap(), 0, pUStrings);

    } else {
        Status = STATUS_NO_MEMORY;
    }

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        ReturnValue = FALSE;
    } else {
        ReturnValue = TRUE;
    }

    return ReturnValue;

}


//
// ANSI APIs
//

BOOL
ClearEventLogA (
    HANDLE  hEventLog,
    LPCSTR  BackupFileName
    )

/*++

Routine Description:

  This is the client DLL entry point for the ClearEventLogFile API.
  The call is passed to the eventlog service on the appropriate server
  identified by LogHandle.


Arguments:

    LogHandle       - Handle returned from a previous "Open" call. This is
                      used to identify the module and the server.

    BackupFileName  - Name of the file to back up the current log file.
                      NULL implies not to back up the file.


Return Value:

    TRUE if success, FALSE otherwise.


--*/
{

    ANSI_STRING AnsiString;
    UNICODE_STRING UnicodeString;
    NTSTATUS Status;
    BOOL ReturnValue;

    //
    // Turn the backup filename into UNICODE
    //

    if (BackupFileName) {
        RtlInitAnsiString(&AnsiString, BackupFileName);
        Status = RtlAnsiStringToUnicodeString(&UnicodeString, &AnsiString,
            TRUE);
        if ( !NT_SUCCESS(Status) ) {
            BaseSetLastNTError(Status);
            return(FALSE);
        }
    }
    else {
        RtlInitUnicodeString(&UnicodeString, NULL);
    }

    ReturnValue = ClearEventLogW (hEventLog, (LPCWSTR)UnicodeString.Buffer);
    RtlFreeUnicodeString(&UnicodeString);
    return(ReturnValue);
}



BOOL
BackupEventLogA (
    HANDLE  hEventLog,
    LPCSTR  BackupFileName
    )

/*++

Routine Description:

  This is the client DLL entry point for the BackupEventLogFile API.
  The call is passed to the eventlog service on the appropriate server
  identified by LogHandle.


Arguments:

    LogHandle       - Handle returned from a previous "Open" call. This is
                      used to identify the module and the server.

    BackupFileName  - Name of the file to back up the current log file.


Return Value:

    TRUE if success, FALSE otherwise.


--*/
{

    ANSI_STRING AnsiString;
    UNICODE_STRING UnicodeString;
    NTSTATUS Status;
    BOOL ReturnValue;

    //
    // Turn the backup filename into UNICODE
    //

    if (BackupFileName) {
        RtlInitAnsiString(&AnsiString, BackupFileName);
        Status = RtlAnsiStringToUnicodeString(&UnicodeString, &AnsiString,
            TRUE);
        if ( !NT_SUCCESS(Status) ) {
            BaseSetLastNTError(Status);
            return(FALSE);
        }
    }
    else {
        RtlInitUnicodeString(&UnicodeString, NULL);
    }

    ReturnValue = BackupEventLogW (hEventLog, (LPCWSTR)UnicodeString.Buffer);
    RtlFreeUnicodeString(&UnicodeString);
    return(ReturnValue);

}


HANDLE
OpenEventLogA (
    LPCSTR   UNCServerName,
    LPCSTR   ModuleName
    )

/*++

Routine Description:

    This is the client DLL entry point for the WinOpenEventLog API.

    It creates an RPC binding for the server specified, and stores that
    and additional data away. It returns a handle to the caller that can
    be used to later on access the handle-specific information.

Arguments:

    UNCServerName     - Server with which to bind for subsequent operations.

    ModuleName        - Supplies the name of the module to associate with
                        this handle.


Return Value:

    Returns a handle that can be used for subsequent Win API calls. If
    the handle is NULL, then an error occurred.


--*/
{

    ANSI_STRING AnsiString;
    ANSI_STRING AnsiModuleName;
    NTSTATUS Status;
    HANDLE LogHandle;
    HANDLE ReturnHandle;

    RtlInitAnsiString(&AnsiModuleName,ModuleName);
    RtlInitAnsiString(&AnsiString, UNCServerName);

    Status = ElfOpenEventLogA (
                        &AnsiString,
                        &AnsiModuleName,
                        &LogHandle
                        );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        ReturnHandle = (HANDLE)NULL;
    } else {
        ReturnHandle = (HANDLE)LogHandle;
    }

    return ReturnHandle;
}


HANDLE
RegisterEventSourceA (
    LPCSTR   UNCServerName,
    LPCSTR   ModuleName
    )

/*++

Routine Description:

    This is the client DLL entry point for the RegisterEventSource API.

    It creates an RPC binding for the server specified, and stores that
    and additional data away. It returns a handle to the caller that can
    be used to later on access the handle-specific information.

Arguments:

    UNCServerName     - Server with which to bind for subsequent operations.

    ModuleName        - Supplies the name of the module to associate with
                        this handle.


Return Value:

    Returns a handle that can be used for subsequent Win API calls. If
    the handle is NULL, then an error occurred.


--*/
{

    ANSI_STRING AnsiString;
    ANSI_STRING AnsiModuleName;
    NTSTATUS Status;
    HANDLE LogHandle;
    HANDLE ReturnHandle;

    RtlInitAnsiString(&AnsiModuleName,ModuleName);
    RtlInitAnsiString(&AnsiString, UNCServerName);

    Status = ElfRegisterEventSourceA (
                        &AnsiString,
                        &AnsiModuleName,
                        &LogHandle
                        );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        ReturnHandle = (HANDLE)NULL;
    } else {
        ReturnHandle = (HANDLE)LogHandle;
    }

    return ReturnHandle;
}


HANDLE
OpenBackupEventLogA (
    LPCSTR   UNCServerName,
    LPCSTR   FileName
    )

/*++

Routine Description:

    This is the client DLL entry point for the OpenBackupEventLog API.

    It creates an RPC binding for the server specified, and stores that
    and additional data away. It returns a handle to the caller that can
    be used to later on access the handle-specific information.

Arguments:

    UNCServerName   - Server with which to bind for subsequent operations.

    FileName        - Supplies the filename of the logfile to associate with
                      this handle.


Return Value:

    Returns a handle that can be used for subsequent Win API calls. If
    the handle is NULL, then an error occurred.


--*/
{

    ANSI_STRING AnsiString;
    UNICODE_STRING UnicodeServerName;
    UNICODE_STRING UnicodeFileName;
    NTSTATUS Status;
    HANDLE ReturnHandle;

    //
    // Turn the servername into UNICODE
    //

    if (UNCServerName) {
        RtlInitAnsiString(&AnsiString, UNCServerName);
        Status = RtlAnsiStringToUnicodeString(&UnicodeServerName, &AnsiString,
            TRUE);
        if ( !NT_SUCCESS(Status) ) {
            BaseSetLastNTError(Status);
            return(NULL);
        }
    }
    else {
        RtlInitUnicodeString(&UnicodeServerName, NULL);
    }

    //
    // Turn the filename into UNICODE
    //

    if (FileName) {
        RtlInitAnsiString(&AnsiString, FileName);
        Status = RtlAnsiStringToUnicodeString(&UnicodeFileName, &AnsiString,
            TRUE);
        if ( !NT_SUCCESS(Status) ) {
            RtlFreeUnicodeString(&UnicodeServerName);
            BaseSetLastNTError(Status);
            return(NULL);
        }
    }
    else {
        RtlInitUnicodeString(&UnicodeFileName, NULL);
    }

    ReturnHandle = OpenBackupEventLogW ((LPCWSTR)UnicodeServerName.Buffer,
        (LPCWSTR)UnicodeFileName.Buffer);
    RtlFreeUnicodeString(&UnicodeServerName);
    RtlFreeUnicodeString(&UnicodeFileName);
    return(ReturnHandle);

}





BOOL
ReadEventLogA (
    HANDLE      hEventLog,
    DWORD       dwReadFlags,
    DWORD       dwRecordOffset,
    LPVOID      lpBuffer,
    DWORD       nNumberOfBytesToRead,
    DWORD       *pnBytesRead,
    DWORD       *pnMinNumberOfBytesNeeded
    )

/*++

Routine Description:

  This is the client DLL entry point for the WinreadEventLog API.

Arguments:



Return Value:

    Returns count of bytes read. Zero of none read.


--*/
{

    NTSTATUS Status;
    BOOL ReturnValue;

    Status = ElfReadEventLogA (
                        hEventLog,
                        dwReadFlags,
                        dwRecordOffset,
                        lpBuffer,
                        nNumberOfBytesToRead,
                        pnBytesRead,
                        pnMinNumberOfBytesNeeded
                        );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        ReturnValue = FALSE;
    } else {
        ReturnValue = TRUE;
    }
    return ReturnValue;

}



BOOL
ReportEventA (
    HANDLE      hEventLog,
    WORD        wType,
    WORD        wCategory       OPTIONAL,
    DWORD       dwEventID,
    PSID        lpUserSid       OPTIONAL,
    WORD        wNumStrings,
    DWORD       dwDataSize,
    LPCSTR      *lpStrings      OPTIONAL,
    LPVOID      lpRawData       OPTIONAL
    )

/*++

Routine Description:

  This is the client DLL entry point for the ReportEvent API.

Arguments:


Return Value:

    Returns TRUE if success, FALSE otherwise.


--*/
{

    NTSTATUS Status = STATUS_SUCCESS;
    BOOL ReturnValue;
    PANSI_STRING *pAStrings;
    ULONG       i;
    ULONG AllocatedStrings;

    //
    // Convert the array of strings to an array of PANSI_STRINGs
    // before calling ElfReportEventW.
    //
    pAStrings = RtlAllocateHeap(
                            RtlProcessHeap(), 0,
                            wNumStrings * sizeof(PANSI_STRING)
                            );

    if (pAStrings) {

        //
        // Guard the memory allocation above while we peruse the user's
        // buffer. If not, we'd leak it on an exception.
        //

        try {
            //
            // For each string passed in, allocate an ANSI_STRING structure
            // and fill it in with the string.
            //
            for (AllocatedStrings = 0; AllocatedStrings < wNumStrings;
              AllocatedStrings++) {
                pAStrings[AllocatedStrings] = RtlAllocateHeap(
                                        RtlProcessHeap(), 0,
                                        sizeof(ANSI_STRING)
                                        );

                if (pAStrings[AllocatedStrings]) {

                    if (!InitAnsiString(
                                pAStrings[AllocatedStrings],
                                lpStrings[AllocatedStrings]
                                )) {
                        //
                        // This string was invalid (> 32K chars) give up
                        // and make sure we only free the ones we've already
                        // allocated (including this last one)
                        //

                        AllocatedStrings++;
                        Status = STATUS_INVALID_PARAMETER;
                        break;
                    }
                }
            }
        }
        except (EXCEPTION_EXECUTE_HANDLER) {
            Status = STATUS_INVALID_PARAMETER;
        }

        if (Status == STATUS_SUCCESS) {
            Status = ElfReportEventA (
                            hEventLog,
                            wType,
                            wCategory,
                            dwEventID,
                            lpUserSid,
                            wNumStrings,
                            dwDataSize,
                            pAStrings,
                            lpRawData,
                            0,            // Flags        -  Paired event
                            NULL,         // RecordNumber  | support.  Not
                            NULL          // TimeWritten  -  in P1
                            );
        }

        //
        // Free all the memory that was allocated
        //
        for (i = 0; i < AllocatedStrings; i++) {
            if (pAStrings[i])
                RtlFreeHeap (RtlProcessHeap(), 0, pAStrings[i]);
        }
        RtlFreeHeap (RtlProcessHeap(), 0, pAStrings);

    } else {
        Status = STATUS_NO_MEMORY;
    }

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        ReturnValue = FALSE;
    } else {
        ReturnValue = TRUE;
    }

    return ReturnValue;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\advapi32\makefile.inc ===
PRIVLIB= $(O)\advapip.lib
$(O)\advapi32.lib : $(PRIVLIB)

$(PRIVLIB) $(PRIVLIB:.lib=.exp): $(O)\advapip.def $(LIBRARY_OBJS)
   -$(LIB_NAME) -out:$(PRIVLIB) @<<
$(LIBRARIAN_FLAGS)
-def:$(O)\advapip.def
$(LIBRARY_OBJS)
<<NOKEEP

$(O)\advapip.def: advapi32.def
    $(C_PREPROCESSOR) $** -DPRIVATE= > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\advapi32\termutil.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include "tsappcmp.h"
#include <regapi.h>

PTERMSRVCREATEREGENTRY gpfnTermsrvCreateRegEntry;

PTERMSRVOPENREGENTRY gpfnTermsrvOpenRegEntry;

PTERMSRVSETVALUEKEY gpfnTermsrvSetValueKey;

PTERMSRVDELETEKEY gpfnTermsrvDeleteKey;

PTERMSRVDELETEVALUE gpfnTermsrvDeleteValue;

PTERMSRVRESTOREKEY gpfnTermsrvRestoreKey;

PTERMSRVSETKEYSECURITY gpfnTermsrvSetKeySecurity;

PTERMSRVOPENUSERCLASSES gpfnTermsrvOpenUserClasses;

PTERMSRVGETPRESETVALUE gpfnTermsrvGetPreSetValue;

DWORD gdwRegistryExtensionFlags=0;

BOOL IsTerminalServerCompatible(VOID)
{

PIMAGE_NT_HEADERS NtHeader = RtlImageNtHeader( NtCurrentPeb()->ImageBaseAddress );

    if ((NtHeader) && (NtHeader->OptionalHeader.DllCharacteristics & IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE)) {
        return TRUE;
    } else {
        return FALSE;
    }
}

BOOL IsSystemLUID(VOID)
{
    HANDLE      TokenHandle;
    UCHAR       TokenInformation[ sizeof( TOKEN_STATISTICS ) ];
    ULONG       ReturnLength;
    LUID        CurrentLUID = { 0, 0 };
    LUID        SystemLUID = SYSTEM_LUID;
    NTSTATUS Status;

    if ( CurrentLUID.LowPart == 0 && CurrentLUID.HighPart == 0 ) {

        Status = NtOpenProcessToken( NtCurrentProcess(),
                                     TOKEN_QUERY,
                                     &TokenHandle );
        if ( !NT_SUCCESS( Status ) )
            return(TRUE);

        NtQueryInformationToken( TokenHandle, TokenStatistics, &TokenInformation,
                                 sizeof(TokenInformation), &ReturnLength );
        NtClose( TokenHandle );

        RtlCopyLuid(&CurrentLUID,
                    &(((PTOKEN_STATISTICS)TokenInformation)->AuthenticationId));
    }

    if (RtlEqualLuid(&CurrentLUID, &SystemLUID)) {
        return(TRUE);
    } else {
        return(FALSE );
    }
}

/**

Params: 
    [out]   Boolean        *RelaxedSecurityMode
                            If TRUE, then we are running app server in relaxed security mode
                            which means that the TsUserSID will be present in user's token, allowing
                            user more access to various reg and file system components.
                            
Retrun:                            
    TRUE    means app server is enabled, and it is in app-compat mode ( the default)
    FALSE   means this is not an app server

**/
BOOL IsTSAppCompatEnabled( BOOLEAN  *RelaxedSecurityMode )
{

   NTSTATUS NtStatus;
   OBJECT_ATTRIBUTES ObjectAttributes;
   UNICODE_STRING UniString;
   HKEY   hKey = 0;
   ULONG  ul, ulcbuf;
   PKEY_VALUE_PARTIAL_INFORMATION pKeyValInfo = NULL;

   BOOL retval = TRUE;


   RtlInitUnicodeString(&UniString,REG_NTAPI_CONTROL_TSERVER);



   // Determine the value info buffer size
   ulcbuf = sizeof(KEY_VALUE_FULL_INFORMATION) + MAX_PATH*sizeof(WCHAR) +
            sizeof(ULONG);

   pKeyValInfo = RtlAllocateHeap(RtlProcessHeap(),
                                 0,
                                 ulcbuf);

   // Did everything initialize OK?
   if (UniString.Buffer && pKeyValInfo) {

       InitializeObjectAttributes(&ObjectAttributes,
                                  &UniString,
                                  OBJ_CASE_INSENSITIVE,
                                  NULL,
                                  NULL
                                 );

       NtStatus = NtOpenKey(&hKey, KEY_READ, &ObjectAttributes);

       if (NT_SUCCESS(NtStatus)) {

           RtlInitUnicodeString(&UniString,
                               L"TSAppCompat");
           NtStatus = NtQueryValueKey(hKey,
                                      &UniString,
                                      KeyValuePartialInformation,
                                      pKeyValInfo,
                                      ulcbuf,
                                      &ul);

           if (NT_SUCCESS(NtStatus) && (REG_DWORD == pKeyValInfo->Type)) {

               if ((*(PULONG)pKeyValInfo->Data) == 0) {
                  retval = FALSE;
               }
           }

           RtlInitUnicodeString(&UniString,
                               L"TSUserEnabled");

           NtStatus = NtQueryValueKey(hKey,
                                      &UniString,
                                      KeyValuePartialInformation,
                                      pKeyValInfo,
                                      ulcbuf,
                                      &ul);

           if (NT_SUCCESS(NtStatus) && (REG_DWORD == pKeyValInfo->Type) ) 
           {
               *RelaxedSecurityMode = (BOOLEAN ) (*(PULONG)pKeyValInfo->Data);
           }
           else     // in case of any problems, assume standard security mode
           {
               *RelaxedSecurityMode = FALSE;
           }

           NtClose(hKey);
       }
   }

   // Free up the buffers we allocated
   // Need to zero out the buffers, because some apps (MS Internet Assistant)
   // won't install if the heap is not zero filled.
   if (pKeyValInfo) {
       memset(pKeyValInfo, 0, ulcbuf);
       RtlFreeHeap( RtlProcessHeap(), 0, pKeyValInfo );
   }

   return(retval);

}


ULONG GetCompatFlags()
{
    ULONG    ulAppFlags = 0;
    PRTL_USER_PROCESS_PARAMETERS pUserParam;
    PWCHAR  pwch, pwchext;
    WCHAR   pwcAppName[MAX_PATH+1];
    NTSTATUS NtStatus;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING UniString;
    HKEY   hKey = 0;
    ULONG  ul, ulcbuf;
    PKEY_VALUE_PARTIAL_INFORMATION pKeyValInfo = NULL;
    LPWSTR UniBuff = NULL;

    ULONG dwCompatFlags = 0;
    UniString.Buffer = NULL;



    // Get the path of the executable name
    pUserParam = NtCurrentPeb()->ProcessParameters;

    // Get the executable name, if there's no \ just use the name as it is
    pwch = wcsrchr(pUserParam->ImagePathName.Buffer, L'\\');
    if (pwch) {
        pwch++;
    } else {
        pwch = pUserParam->ImagePathName.Buffer;
    }
    wcscpy(pwcAppName, pwch);
    pwch = pwcAppName;

    // Remove the extension
    if (pwchext = wcsrchr(pwch, L'.')) {
        *pwchext = '\0';
    }


    UniString.Buffer = NULL;


    ul = sizeof(TERMSRV_COMPAT_APP) + (wcslen(pwch) + 1)*sizeof(WCHAR);

    UniBuff = RtlAllocateHeap(RtlProcessHeap(),
                              0,
                              ul);

    if (UniBuff) {
        wcscpy(UniBuff, TERMSRV_COMPAT_APP);
        wcscat(UniBuff, pwch);

        RtlInitUnicodeString(&UniString, UniBuff);
    }

    // Determine the value info buffer size
    ulcbuf = sizeof(KEY_VALUE_FULL_INFORMATION) + MAX_PATH*sizeof(WCHAR) +
             sizeof(ULONG);

    pKeyValInfo = RtlAllocateHeap(RtlProcessHeap(),
                                  0,
                                  ulcbuf);

    // Did everything initialize OK?
    if (UniString.Buffer && pKeyValInfo) {

        InitializeObjectAttributes(&ObjectAttributes,
                                   &UniString,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL
                                  );

        NtStatus = NtOpenKey(&hKey, KEY_READ, &ObjectAttributes);

        if (NT_SUCCESS(NtStatus)) {

            RtlInitUnicodeString(&UniString,
                                COMPAT_FLAGS);
            NtStatus = NtQueryValueKey(hKey,
                                       &UniString,
                                       KeyValuePartialInformation,
                                       pKeyValInfo,
                                       ulcbuf,
                                       &ul);

            if (NT_SUCCESS(NtStatus) && (REG_DWORD == pKeyValInfo->Type)) {


                dwCompatFlags = *(PULONG)pKeyValInfo->Data;

            }

            NtClose(hKey);
        }
    }

    // Free up the buffers we allocated
    // Need to zero out the buffers, because some apps (MS Internet Assistant)
    // won't install if the heap is not zero filled.
    if (UniBuff) {
        memset(UniBuff, 0, UniString.MaximumLength);
        RtlFreeHeap( RtlProcessHeap(), 0, UniBuff );
    }
    if (pKeyValInfo) {
        memset(pKeyValInfo, 0, ulcbuf);
        RtlFreeHeap( RtlProcessHeap(), 0, pKeyValInfo );
    }

    return(dwCompatFlags);

}

/**

Return code :
    TRUE  means app compat is enabled for this app
    FALSE means app compat is not enabled for this app

**/
BOOLEAN AdvApi_InitializeTermsrvFpns( BOOLEAN   *pIsInRelaxedSecurityMode , DWORD *pdwCompatFlags )
{

    HANDLE          dllHandle;
    ULONG           dwCompatFlags;
    BOOLEAN         rc=FALSE;


    if (IsTerminalServerCompatible() || (!IsTSAppCompatEnabled( pIsInRelaxedSecurityMode ))) {
        return rc;
    }

    *pdwCompatFlags = dwCompatFlags = GetCompatFlags();


    //Don't load app compatibility dll for system components

    if (IsSystemLUID()) {

        if ( (dwCompatFlags & (TERMSRV_COMPAT_SYSREGMAP | TERMSRV_COMPAT_WIN32))
                     != (TERMSRV_COMPAT_SYSREGMAP | TERMSRV_COMPAT_WIN32) ) {

            //
            // Process is running as SYSTEM and we don't have an app
            // compatibility flag telling us to do the regmap stuff.
            //

            return rc;

        }

    } else if ( (dwCompatFlags & (TERMSRV_COMPAT_NOREGMAP | TERMSRV_COMPAT_WIN32))
                     == (TERMSRV_COMPAT_NOREGMAP | TERMSRV_COMPAT_WIN32) ) {
        //
        // We don't want to do registry mapping for this user process
        //
        return rc;

    }

    //
    // Load Terminal Server application compatibility dll
    //
    dllHandle = LoadLibrary("tsappcmp.dll");

    if (dllHandle) {

        gpfnTermsrvCreateRegEntry =
            (PTERMSRVCREATEREGENTRY)GetProcAddress(dllHandle,"TermsrvCreateRegEntry");

        gpfnTermsrvOpenRegEntry =
            (PTERMSRVOPENREGENTRY)GetProcAddress(dllHandle,"TermsrvOpenRegEntry");

        gpfnTermsrvSetValueKey =
            (PTERMSRVSETVALUEKEY)GetProcAddress(dllHandle,"TermsrvSetValueKey");

        gpfnTermsrvDeleteKey =
            (PTERMSRVDELETEKEY)GetProcAddress(dllHandle,"TermsrvDeleteKey");

        gpfnTermsrvDeleteValue =
            (PTERMSRVDELETEVALUE)GetProcAddress(dllHandle,"TermsrvDeleteValue");

         gpfnTermsrvRestoreKey =
            (PTERMSRVRESTOREKEY)GetProcAddress(dllHandle,"TermsrvRestoreKey");

        gpfnTermsrvSetKeySecurity =
            (PTERMSRVSETKEYSECURITY)GetProcAddress(dllHandle,"TermsrvSetKeySecurity");

        gpfnTermsrvOpenUserClasses =
            (PTERMSRVOPENUSERCLASSES)GetProcAddress(dllHandle,"TermsrvOpenUserClasses");

        gpfnTermsrvGetPreSetValue =
            (PTERMSRVGETPRESETVALUE)GetProcAddress(dllHandle,"TermsrvGetPreSetValue");

        rc = TRUE;
    }

    return rc;
}


void
GetRegistryExtensionFlags( DWORD dwCompatFlags )
/*++
GetRegistryExtensionFlags

Routine Description:

    Reads DWORD value of 
    Registry\Machine\Software\Microsoft\Windows NT\CurrentVersion\Terminal Server\RegistryExtensionFlags

Arguments:

    none

Return Value:

    none

--*/
{

    DWORD dwResult=0;
    NTSTATUS Status; 
    HANDLE hKey;
    UNICODE_STRING KeyName;
    PCWSTR wszKeyName=TERMSRV_BASE;
    OBJECT_ATTRIBUTES ObjAttr;
    
    RtlInitUnicodeString(&KeyName,wszKeyName );
    InitializeObjectAttributes(&ObjAttr,&KeyName,OBJ_CASE_INSENSITIVE,NULL,NULL);
    Status = NtOpenKey(&hKey,KEY_QUERY_VALUE,&ObjAttr);

    if(NT_SUCCESS(Status)){

        
        UNICODE_STRING ValueName;
        PKEY_VALUE_PARTIAL_INFORMATION pKeyValInfo = NULL;
        ULONG ulSize = sizeof(KEY_VALUE_PARTIAL_INFORMATION)+sizeof(DWORD);
        
        pKeyValInfo = RtlAllocateHeap(RtlProcessHeap(), 0, ulSize);
        
        if(pKeyValInfo){

            PCWSTR wszValueName=L"RegistryExtensionFlags";

            RtlInitUnicodeString(&ValueName,wszValueName );

            Status=NtQueryValueKey(hKey,&ValueName,KeyValuePartialInformation,
                (PVOID)pKeyValInfo,ulSize,&ulSize);

            if(NT_SUCCESS(Status)){
                gdwRegistryExtensionFlags=*((LPDWORD)(pKeyValInfo->Data));
            }

            RtlFreeHeap( RtlProcessHeap(), 0, pKeyValInfo );

            // the global advapi extension flags might be turned off for this app, so check.
            if ( dwCompatFlags & TERMSRV_COMPAT_NO_PER_USER_CLASSES_REDIRECTION )
            {
                gdwRegistryExtensionFlags &= ~ TERMSRV_ENABLE_PER_USER_CLASSES_REDIRECTION;
            }

            if ( dwCompatFlags & TERMSRV_COMPAT_NO_ENABLE_ACCESS_FLAG_MODIFICATION  )
            {
                gdwRegistryExtensionFlags &= ~TERMSRV_ENABLE_ACCESS_FLAG_MODIFICATION;
            }
        }

        NtClose(hKey);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\advapi32\username.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    USERNAME.C

Abstract:

    This module contains the GetUserName API.

Author:

    Dave Snipp (DaveSn)    27-May-1992


Revision History:


--*/

#include <advapi.h>
#define SECURITY_WIN32
#include <sspi.h>
#include <secext.h>
#include <stdlib.h>
#include <ntlsa.h>


//
// UNICODE APIs
//


BOOL
WINAPI
GetUserNameW (
    LPWSTR pBuffer,
    LPDWORD pcbBuffer
    )

/*++

Routine Description:

  This returns the name of the user currently being impersonated.

Arguments:

    pBuffer - Points to the buffer that is to receive the
        null-terminated character string containing the user name.

    pcbBuffer - Specifies the size (in characters) of the buffer.
                The length of the string is returned in pcbBuffer.

Return Value:

    TRUE on success, FALSE on failure.


--*/
{
    return GetUserNameExW(
                NameSamCompatible | 0x00010000,
                pBuffer,
                pcbBuffer );
}



//
// ANSI APIs
//

BOOL
WINAPI
GetUserNameA (
    LPSTR pBuffer,
    LPDWORD pcbBuffer
    )

/*++

Routine Description:

  This returns the name of the user currently being impersonated.

Arguments:

    pBuffer - Points to the buffer that is to receive the
        null-terminated character string containing the user name.

    pcbBuffer - Specifies the size (in characters) of the buffer.
                The length of the string is returned in pcbBuffer.

Return Value:

    TRUE on success, FALSE on failure.


--*/
{
    return GetUserNameExA(
                NameSamCompatible | 0x00010000,
                pBuffer,
                pcbBuffer );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\advapi32\logon32.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       logon32.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    9-30-94   RichardW   Created
//
//----------------------------------------------------------------------------


#include "advapi.h"
#include <crypt.h>
#include <mpr.h>
#include <ntlsa.h>
#include <ntmsv1_0.h>
#include <wchar.h>
#include <stdlib.h>
#include <lmcons.h>

#define SECURITY_WIN32
#include <security.h>

#include <windows.h>

#include <winbase.h>
#include <winbasep.h>
#include <execsrv.h>
#include <winsta.h>

//
// We dynamically load mpr.dll (no big surprise there), in order to call
// WNetLogonNotify, as defined in private\inc\mpr.h.  This prototype matches
// it -- consult the header file for all the parameters.
//
typedef (* LOGONNOTIFYFN)(LPCWSTR, PLUID, LPCWSTR, LPVOID,
                            LPCWSTR, LPVOID, LPWSTR, LPVOID, LPWSTR *);

//
// The QuotaLimits are global, because the defaults
// are always used for accounts, based on server/wksta, and no one ever
// calls lsasetaccountquota
//

HANDLE      Logon32LsaHandle = NULL;
ULONG       Logon32MsvHandle = 0xFFFFFFFF;
ULONG       Logon32NegoHandle = 0xFFFFFFFF;
WCHAR       Logon32DomainName[DNLEN+1] = L"";

QUOTA_LIMITS    Logon32QuotaLimits;
HINSTANCE       Logon32MprHandle = NULL;
LOGONNOTIFYFN   Logon32LogonNotify = NULL;


RTL_CRITICAL_SECTION    Logon32Lock;

#define LockLogon()     RtlEnterCriticalSection( &Logon32Lock )
#define UnlockLogon()   RtlLeaveCriticalSection( &Logon32Lock )


SID_IDENTIFIER_AUTHORITY L32SystemSidAuthority = SECURITY_NT_AUTHORITY;
SID_IDENTIFIER_AUTHORITY L32LocalSidAuthority = SECURITY_LOCAL_SID_AUTHORITY;



#define COMMON_CREATE_SUSPENDED 0x00000001  // Suspended, do not Resume()
#define COMMON_CREATE_PROCESSSD 0x00000002  // Whack the process SD
#define COMMON_CREATE_THREADSD  0x00000004  // Whack the thread SD


BOOL
WINAPI
LogonUserCommonA(
    LPCSTR          lpszUsername,
    LPCSTR          lpszDomain,
    LPCSTR          lpszPassword,
    DWORD          dwLogonType,
    DWORD          dwLogonProvider,
    BOOL           fExVersion,
    HANDLE *       phToken,
    PSID   *       ppLogonSid,
    PVOID  *       ppProfileBuffer,
    DWORD  *       pdwProfileLength,
    PQUOTA_LIMITS  pQuotaLimits
    );


BOOL
WINAPI
LogonUserCommonW(
    PCWSTR          lpszUsername,
    PCWSTR          lpszDomain,
    PCWSTR          lpszPassword,
    DWORD          dwLogonType,
    DWORD          dwLogonProvider,
    BOOL           fExVersion,
    HANDLE *       phToken,
    PSID   *       ppLogonSid,
    PVOID  *       ppProfileBuffer,
    DWORD  *       pdwProfileLength,
    PQUOTA_LIMITS  pQuotaLimits
    );


//+---------------------------------------------------------------------------
//
//  Function:   Logon32Initialize
//
//  Synopsis:   Initializes the critical section
//
//  Arguments:  [hMod]    --
//              [Reason]  --
//              [Context] --
//
//----------------------------------------------------------------------------
BOOL
Logon32Initialize(
    IN PVOID    hMod,
    IN ULONG    Reason,
    IN PCONTEXT Context)
{
    NTSTATUS    Status;

    if (Reason == DLL_PROCESS_ATTACH)
    {
        Status = RtlInitializeCriticalSection( &Logon32Lock );
        return( Status == STATUS_SUCCESS );
    }

    return( TRUE );
}


/***************************************************************************\
* FindLogonSid
*
* Finds logon sid for a new logon from the access token.
*
\***************************************************************************/
PSID
L32FindLogonSid(
    IN  HANDLE  hToken
    )
{
    PTOKEN_GROUPS   pGroups = NULL;
    DWORD           cbGroups;
    PVOID           FastBuffer[ 512 / sizeof(PVOID) ];
    PTOKEN_GROUPS   pSlowBuffer = NULL;
    UINT            i;
    PSID            Sid = NULL;


    pGroups = (PTOKEN_GROUPS)FastBuffer;
    cbGroups = sizeof(FastBuffer);

    if(!GetTokenInformation(
                hToken,
                TokenGroups,
                pGroups,
                cbGroups,
                &cbGroups
                ))
    {
        if( GetLastError() != ERROR_INSUFFICIENT_BUFFER ) {
            return NULL;
        }

        pSlowBuffer = (PTOKEN_GROUPS)LocalAlloc(LMEM_FIXED, cbGroups);

        if( pSlowBuffer == NULL ) {
            return NULL;
        }

        pGroups = pSlowBuffer;


        if(!GetTokenInformation(
                    hToken,
                    TokenGroups,
                    pGroups,
                    cbGroups,
                    &cbGroups
                    )) {
            goto Cleanup;
        }
    }


    //
    // Get the logon Sid by looping through the Sids in the token
    //

    for(i = 0 ; i < pGroups->GroupCount ; i++) {
        if(pGroups->Groups[i].Attributes & SE_GROUP_LOGON_ID) {
            DWORD dwSidLength;

            //
            // insure we are dealing with a valid Sid
            //

            if(!IsValidSid(pGroups->Groups[i].Sid)) {
                goto Cleanup;
            }

            //
            // get required allocation size to copy the Sid
            //

            dwSidLength = GetLengthSid(pGroups->Groups[i].Sid);

            Sid = (PSID)LocalAlloc( LMEM_FIXED, dwSidLength );
            if( Sid == NULL ) {
                goto Cleanup;
            }

            CopySid(dwSidLength, Sid, pGroups->Groups[i].Sid);

            break;
        }
    }

Cleanup:

    if( pSlowBuffer )
    {
        LocalFree( pSlowBuffer );
    }

    return Sid;
}


/*******************************************************************

    NAME:       GetDefaultDomainName

    SYNOPSIS:   Fills in the given array with the name of the default
                domain to use for logon validation.

    ENTRY:      pszDomainName - Pointer to a buffer that will receive
                    the default domain name.

                cchDomainName - The size (in charactesr) of the domain
                    name buffer.

    RETURNS:    TRUE if successful, FALSE if not.

    HISTORY:
        KeithMo     05-Dec-1994 Created.
        RichardW    10-Jan-95   Liberated from sockets and stuck in base

********************************************************************/
BOOL
L32GetDefaultDomainName(
    PUNICODE_STRING     pDomainName
    )
{
    OBJECT_ATTRIBUTES           ObjectAttributes;
    NTSTATUS                    NtStatus;
    INT                         Result;
    DWORD                       err             = 0;
    LSA_HANDLE                  LsaPolicyHandle = NULL;
    PPOLICY_ACCOUNT_DOMAIN_INFO DomainInfo      = NULL;
    PUNICODE_STRING             pDomain;

    if (Logon32DomainName[0] != L'\0')
    {
        RtlInitUnicodeString(pDomainName, Logon32DomainName);
        return(TRUE);
    }
    //
    //  Open a handle to the local machine's LSA policy object.
    //

    InitializeObjectAttributes( &ObjectAttributes,  // object attributes
                                NULL,               // name
                                0L,                 // attributes
                                NULL,               // root directory
                                NULL );             // security descriptor

    NtStatus = LsaOpenPolicy( NULL,                 // system name
                              &ObjectAttributes,    // object attributes
                              POLICY_EXECUTE,       // access mask
                              &LsaPolicyHandle );   // policy handle

    if( !NT_SUCCESS( NtStatus ) )
    {
        BaseSetLastNTError(NtStatus);
        return(FALSE);
    }

    //
    //  Query the domain information from the policy object.
    //
    NtStatus = LsaQueryInformationPolicy( LsaPolicyHandle,
                                          PolicyAccountDomainInformation,
                                          (PVOID *) &DomainInfo );

    if (!NT_SUCCESS(NtStatus))
    {
        BaseSetLastNTError(NtStatus);
        LsaClose(LsaPolicyHandle);
        return(FALSE);
    }


    (void) LsaClose(LsaPolicyHandle);

    //
    // Copy the domain name into our cache, and
    //

    CopyMemory( Logon32DomainName,
                DomainInfo->DomainName.Buffer,
                DomainInfo->DomainName.Length );

    //
    // Null terminate it appropriately
    //

    Logon32DomainName[DomainInfo->DomainName.Length / sizeof(WCHAR)] = L'\0';

    //
    // Clean up
    //
    LsaFreeMemory( (PVOID)DomainInfo );

    //
    // And init the string
    //
    RtlInitUnicodeString(pDomainName, Logon32DomainName);

    return TRUE;

}   // GetDefaultDomainName

//+---------------------------------------------------------------------------
//
//  Function:   L32pInitLsa
//
//  Synopsis:   Initialize connection with LSA
//
//  Arguments:  (none)
//
//  History:    4-21-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
L32pInitLsa(void)
{
    STRING  PackageName;

    ULONG MsvHandle;
    ULONG NegoHandle;

    NTSTATUS Status;

    //
    // Hookup to the LSA and locate our authentication package.
    //

    Status = LsaConnectUntrusted(
                 &Logon32LsaHandle
                 );

    if (!NT_SUCCESS(Status)) {
        Logon32LsaHandle = NULL;
        goto Cleanup;
    }


    //
    // Connect with the MSV1_0 authentication package
    //
    RtlInitString(&PackageName, "MICROSOFT_AUTHENTICATION_PACKAGE_V1_0");
    Status = LsaLookupAuthenticationPackage (
                Logon32LsaHandle,
                &PackageName,
                &MsvHandle
                );

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    //
    // Connect with the Negotiate authentication package
    //
    RtlInitString(&PackageName, NEGOSSP_NAME_A);
    Status = LsaLookupAuthenticationPackage (
                Logon32LsaHandle,
                &PackageName,
                &NegoHandle
                );

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    //
    // Wait until successful to update the 2 globals.
    //

    Logon32NegoHandle = NegoHandle;
    Logon32MsvHandle = MsvHandle;

Cleanup:


    if( !NT_SUCCESS(Status) ) {

        if( Logon32LsaHandle ) {
            (VOID) LsaDeregisterLogonProcess( Logon32LsaHandle );
            Logon32LsaHandle = NULL;
        }

        BaseSetLastNTError( Status );
        return FALSE;
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   L32pNotifyMpr
//
//  Synopsis:   Loads the MPR DLL and notifies the network providers (like
//              csnw) so they know about this logon session and the credentials
//
//  Arguments:  [NewLogon] -- New logon information
//              [LogonId]  -- Logon ID
//
//  History:    4-24-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
L32pNotifyMpr(
    PMSV1_0_INTERACTIVE_LOGON   NewLogon,
    PLUID                       LogonId
    )
{
    MSV1_0_INTERACTIVE_LOGON    OldLogon;
    LPWSTR                      LogonScripts;
    DWORD                       status;
    LUID                        LocalServiceLuid   = LOCALSERVICE_LUID;
    LUID                        NetworkServiceLuid = NETWORKSERVICE_LUID;

    if (RtlEqualLuid(LogonId, &LocalServiceLuid)
         ||
        RtlEqualLuid(LogonId, &NetworkServiceLuid))
    {
        //
        // Don't notify providers for LocalService/NetworkService logons
        //

        return( TRUE );
    }

    if ( Logon32MprHandle == NULL )
    {
        LockLogon();

        if ( Logon32MprHandle == NULL)
        {
            Logon32MprHandle =  LoadLibrary("mpr.dll");
            if (Logon32MprHandle != NULL) {

                Logon32LogonNotify = (LOGONNOTIFYFN) GetProcAddress(
                                        Logon32MprHandle,
                                        "WNetLogonNotify");

            }
        }

        UnlockLogon();
    }

    if ( Logon32LogonNotify != NULL )
    {


        CopyMemory(&OldLogon, NewLogon, sizeof(OldLogon));

        status = Logon32LogonNotify(
                        L"Windows NT Network Provider",
                        LogonId,
                        L"MSV1_0:Interactive",
                        (LPVOID)NewLogon,
                        L"MSV1_0:Interactive",
                        (LPVOID)&OldLogon,
                        L"SvcCtl",          // StationName
                        NULL,               // StationHandle
                        &LogonScripts);     // LogonScripts

        if (status == NO_ERROR) {
            if (LogonScripts != NULL ) {
                (void) LocalFree(LogonScripts);
            }
        }

        return( TRUE );
    }

    return( FALSE );
}


//+---------------------------------------------------------------------------
//
//  Function:   L32pLogonUser
//
//  Synopsis:   Wraps up the call to LsaLogonUser
//
//  Arguments:  [LsaHandle]             --
//              [AuthenticationPackage] --
//              [LogonType]             --
//              [UserName]              --
//              [Domain]                --
//              [Password]              --
//              [LogonId]               --
//              [LogonToken]            --
//              [Quotas]                --
//              [pProfileBuffer]        --
//              [pProfileBufferLength]  --
//              [pSubStatus]            --
//
//  History:    4-24-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
L32pLogonUser(
    IN HANDLE LsaHandle,
    IN ULONG AuthenticationPackage,
    IN SECURITY_LOGON_TYPE LogonType,
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING Domain,
    IN PUNICODE_STRING Password,
    OUT PLUID LogonId,
    OUT PHANDLE LogonToken,
    OUT PQUOTA_LIMITS Quotas,
    OUT PVOID *pProfileBuffer,
    OUT PULONG pProfileBufferLength,
    OUT PNTSTATUS pSubStatus
    )
{
    NTSTATUS Status;
    STRING OriginName;
    TOKEN_SOURCE SourceContext;
    PMSV1_0_INTERACTIVE_LOGON MsvAuthInfo;
    PMSV1_0_LM20_LOGON MsvNetAuthInfo;
    PVOID AuthInfoBuf;
    ULONG AuthInfoSize;
    WCHAR ComputerName[ MAX_COMPUTERNAME_LENGTH + 1 ];
    DWORD ComputerNameLength;

    //
    // Initialize source context structure
    //

    strncpy(SourceContext.SourceName, "Advapi  ", sizeof(SourceContext.SourceName)); // LATER from res file

    Status = NtAllocateLocallyUniqueId(&SourceContext.SourceIdentifier);

    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    //
    // Set logon origin
    //

    RtlInitString(&OriginName, "LogonUser API");

    //
    // For network logons, do the magic.
    //

    if ( ( LogonType == Network ) )
    {
        ComputerNameLength = MAX_COMPUTERNAME_LENGTH + 1;

        if (!GetComputerNameW( ComputerName, &ComputerNameLength ) )
        {
            return(STATUS_INVALID_PARAMETER);
        }

        AuthInfoSize = sizeof( MSV1_0_LM20_LOGON ) +
                         UserName->Length +
                         Domain->Length +
                         sizeof(WCHAR) * (ComputerNameLength + 1) +
                         Password->Length + // NT password
                         (LM20_PWLEN+1) ;   // LM passsword (worst case)          

        MsvNetAuthInfo = AuthInfoBuf = RtlAllocateHeap( RtlProcessHeap(),
                                                        HEAP_ZERO_MEMORY,
                                                        AuthInfoSize );

        if ( !MsvNetAuthInfo )
        {
            return( STATUS_NO_MEMORY );
        }

        //
        // Start packing in the string
        //

        MsvNetAuthInfo->MessageType = MsV1_0NetworkLogon;

        //
        // Copy the user name into the authentication buffer
        //

        MsvNetAuthInfo->UserName.Length =
                    UserName->Length;
        MsvNetAuthInfo->UserName.MaximumLength =
                    MsvNetAuthInfo->UserName.Length;

        MsvNetAuthInfo->UserName.Buffer = (PWSTR)(MsvNetAuthInfo+1);
        RtlCopyMemory(
            MsvNetAuthInfo->UserName.Buffer,
            UserName->Buffer,
            UserName->Length
            );


        //
        // Copy the domain name into the authentication buffer
        //

        MsvNetAuthInfo->LogonDomainName.Length = Domain->Length;
        MsvNetAuthInfo->LogonDomainName.MaximumLength = Domain->Length ;

        MsvNetAuthInfo->LogonDomainName.Buffer = (PWSTR)
                                     ((PBYTE)(MsvNetAuthInfo->UserName.Buffer) +
                                     MsvNetAuthInfo->UserName.MaximumLength);

        RtlCopyMemory(
            MsvNetAuthInfo->LogonDomainName.Buffer,
            Domain->Buffer,
            Domain->Length);

        //
        // Copy the workstation name into the buffer
        //

        MsvNetAuthInfo->Workstation.Length = (USHORT)
                            (sizeof(WCHAR) * ComputerNameLength);

        MsvNetAuthInfo->Workstation.MaximumLength =
                            MsvNetAuthInfo->Workstation.Length + sizeof(WCHAR);

        MsvNetAuthInfo->Workstation.Buffer = (PWSTR)
                            ((PBYTE) (MsvNetAuthInfo->LogonDomainName.Buffer) +
                            MsvNetAuthInfo->LogonDomainName.MaximumLength );

        wcscpy( MsvNetAuthInfo->Workstation.Buffer, ComputerName );

        //
        // Set up space for Password (Unicode)
        //

        MsvNetAuthInfo->CaseSensitiveChallengeResponse.Buffer = (PUCHAR)
                    ((PBYTE) (MsvNetAuthInfo->Workstation.Buffer) +
                    MsvNetAuthInfo->Workstation.MaximumLength );

        MsvNetAuthInfo->CaseSensitiveChallengeResponse.Length =
        MsvNetAuthInfo->CaseSensitiveChallengeResponse.MaximumLength =
                            Password->Length;

        RtlCopyMemory(
            MsvNetAuthInfo->CaseSensitiveChallengeResponse.Buffer,
            Password->Buffer,
            Password->Length);

        
        //
        // handle passing in the case-insensitive version.
        //

        if( (Password->Length/sizeof(WCHAR)) > LM20_PWLEN )
        {
            Status = STATUS_INVALID_PARAMETER;
        } else {

            MsvNetAuthInfo->CaseInsensitiveChallengeResponse.Buffer = (PUCHAR)
                    ((PBYTE) (MsvNetAuthInfo->CaseSensitiveChallengeResponse.Buffer) +
                    MsvNetAuthInfo->CaseSensitiveChallengeResponse.MaximumLength );

            MsvNetAuthInfo->CaseInsensitiveChallengeResponse.Length = LM20_PWLEN;
            MsvNetAuthInfo->CaseInsensitiveChallengeResponse.MaximumLength = LM20_PWLEN+1;

            Status = RtlUpcaseUnicodeStringToOemString(
                        &MsvNetAuthInfo->CaseInsensitiveChallengeResponse,
                        Password,
                        FALSE
                        );
        }

        if ( !NT_SUCCESS(Status) )
        {
            Status = STATUS_SUCCESS;

            //
            // If we're here, the NT (supplied) password is longer than the
            // limit allowed for LM passwords.  NULL out the field, so that
            // MSV knows not to worry about it.
            //

            RtlZeroMemory( &MsvNetAuthInfo->CaseInsensitiveChallengeResponse,
                           sizeof(MsvNetAuthInfo->CaseInsensitiveChallengeResponse) );
        }

        //
        // to be consistent with Negotiate/Kerberos for _WINNT50 cases,
        // allow machine accounts to be logged on.
        //

        MsvNetAuthInfo->ParameterControl =  MSV1_0_CLEARTEXT_PASSWORD_ALLOWED |
                                            MSV1_0_CLEARTEXT_PASSWORD_SUPPLIED |
                                            MSV1_0_ALLOW_SERVER_TRUST_ACCOUNT |
                                            MSV1_0_ALLOW_WORKSTATION_TRUST_ACCOUNT;

    }
    else
    {
        //
        // Build logon structure for non-network logons - service,
        // batch, interactive, unlock, new credentials, networkcleartext
        //

        AuthInfoSize = sizeof(MSV1_0_INTERACTIVE_LOGON) +
                        UserName->Length +
                        Domain->Length +
                        Password->Length;

        MsvAuthInfo = AuthInfoBuf = RtlAllocateHeap(RtlProcessHeap(),
                                                    HEAP_ZERO_MEMORY,
                                                    AuthInfoSize);

        if (MsvAuthInfo == NULL) {
            return(STATUS_NO_MEMORY);
        }

        //
        // This authentication buffer will be used for a logon attempt
        //

        MsvAuthInfo->MessageType = MsV1_0InteractiveLogon;


        //
        // Copy the user name into the authentication buffer
        //

        MsvAuthInfo->UserName.Length = UserName->Length;
        MsvAuthInfo->UserName.MaximumLength =
                    MsvAuthInfo->UserName.Length;

        MsvAuthInfo->UserName.Buffer = (PWSTR)(MsvAuthInfo+1);
        RtlCopyMemory(
            MsvAuthInfo->UserName.Buffer,
            UserName->Buffer,
            UserName->Length
            );


        //
        // Copy the domain name into the authentication buffer
        //

        MsvAuthInfo->LogonDomainName.Length = Domain->Length;
        MsvAuthInfo->LogonDomainName.MaximumLength =
                     MsvAuthInfo->LogonDomainName.Length;

        MsvAuthInfo->LogonDomainName.Buffer = (PWSTR)
                                     ((PBYTE)(MsvAuthInfo->UserName.Buffer) +
                                     MsvAuthInfo->UserName.MaximumLength);

        RtlCopyMemory(
            MsvAuthInfo->LogonDomainName.Buffer,
            Domain->Buffer,
            Domain->Length
            );

        //
        // Copy the password into the authentication buffer
        // Hide it once we have copied it.  Use the same seed value
        // that we used for the original password in pGlobals.
        //


        MsvAuthInfo->Password.Length = Password->Length;
        MsvAuthInfo->Password.MaximumLength =
                     MsvAuthInfo->Password.Length;

        MsvAuthInfo->Password.Buffer = (PWSTR)
                                     ((PBYTE)(MsvAuthInfo->LogonDomainName.Buffer) +
                                     MsvAuthInfo->LogonDomainName.MaximumLength);

        RtlCopyMemory(
            MsvAuthInfo->Password.Buffer,
            Password->Buffer,
            Password->Length
            );

    }

    //
    // Now try to log this sucker on
    //

    Status = LsaLogonUser (
                LsaHandle,
                &OriginName,
                LogonType,
                AuthenticationPackage,
                AuthInfoBuf,
                AuthInfoSize,
                NULL,
                &SourceContext,
                pProfileBuffer,
                pProfileBufferLength,
                LogonId,
                LogonToken,
                Quotas,
                pSubStatus
                );

    //
    // Notify all the network providers, if this is a NON network logon.  Also
    // skip service logons since the LSA will call WNetLogonNotify for those.
    //

    if ( NT_SUCCESS( Status ) &&
         (LogonType != Network) &&
         (LogonType != Service) )
    {
        L32pNotifyMpr(AuthInfoBuf, LogonId);
    }

    //
    // Discard authentication buffer
    //

    RtlZeroMemory( AuthInfoBuf, AuthInfoSize );

    RtlFreeHeap(RtlProcessHeap(), 0, AuthInfoBuf);

    return(Status);
}


//+---------------------------------------------------------------------------
//
//  Function:   LogonUserCommonA
//
//  Synopsis:   ANSI wrapper for LogonUserCommonW.  See description below
//
//  Arguments:  [lpszUsername]     --
//              [lpszDomain]       --
//              [lpszPassword]     --
//              [dwLogonType]      --
//              [dwLogonProvider]  --
//              [fExVersion]       --
//              [phToken]          --
//              [ppLogonSid]       --
//              [ppProfileBuffer]  --
//              [pdwProfileLength] --
//              [pQuotaLimits]     --
//
//  History:    2-15-2000   JSchwart   Created from RichardW's LogonUserA
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
WINAPI
LogonUserCommonA(
    LPCSTR          lpszUsername,
    LPCSTR          lpszDomain,
    LPCSTR          lpszPassword,
    DWORD          dwLogonType,
    DWORD          dwLogonProvider,
    BOOL           fExVersion,
    HANDLE *       phToken,
    PSID   *       ppLogonSid,
    PVOID  *       ppProfileBuffer,
    DWORD  *       pdwProfileLength,
    PQUOTA_LIMITS  pQuotaLimits
    )
{
    UNICODE_STRING Username;
    UNICODE_STRING Domain;
    UNICODE_STRING Password;
    ANSI_STRING Temp ;
    NTSTATUS Status;
    BOOL    bRet;


    Username.Buffer = NULL;
    Domain.Buffer = NULL;
    Password.Buffer = NULL;

    RtlInitAnsiString( &Temp, lpszUsername );
    Status = RtlAnsiStringToUnicodeString( &Username, &Temp, TRUE );
    if (!NT_SUCCESS( Status ) )
    {
        BaseSetLastNTError(Status);
        bRet = FALSE;
        goto Cleanup;
    }

    RtlInitAnsiString( &Temp, lpszDomain );
    Status = RtlAnsiStringToUnicodeString(&Domain, &Temp, TRUE );
    if (!NT_SUCCESS(Status))
    {
        BaseSetLastNTError(Status);
        bRet = FALSE;
        goto Cleanup;
    }

    RtlInitAnsiString( &Temp, lpszPassword );
    Status = RtlAnsiStringToUnicodeString( &Password, &Temp, TRUE );
    if (!NT_SUCCESS(Status))
    {
        BaseSetLastNTError(Status);
        bRet = FALSE;
        goto Cleanup;
    }

    bRet = LogonUserCommonW( Username.Buffer,
                             Domain.Buffer,
                             Password.Buffer,
                             dwLogonType,
                             dwLogonProvider,
                             fExVersion,
                             phToken,
                             ppLogonSid,
                             ppProfileBuffer,
                             pdwProfileLength,
                             pQuotaLimits );

Cleanup:

    if (Username.Buffer)
    {
        RtlFreeUnicodeString(&Username);
    }

    if (Domain.Buffer)
    {
        RtlFreeUnicodeString(&Domain);
    }

    if (Password.Buffer)
    {
        RtlZeroMemory(Password.Buffer, Password.Length);
        RtlFreeUnicodeString(&Password);
    }

    return(bRet);
}


//+---------------------------------------------------------------------------
//
//  Function:   LogonUserA
//
//  Synopsis:   ANSI wrapper for LogonUserW.  See description below
//
//  Arguments:  [lpszUsername]    --
//              [lpszDomain]      --
//              [lpszPassword]    --
//              [dwLogonType]     --
//              [dwLogonProvider] --
//              [phToken]         --
//
//  History:    4-25-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
WINAPI
LogonUserA(
    LPCSTR       lpszUsername,
    LPCSTR       lpszDomain,
    LPCSTR       lpszPassword,
    DWORD       dwLogonType,
    DWORD       dwLogonProvider,
    HANDLE *    phToken
    )
{
    return LogonUserCommonA(lpszUsername,
                            lpszDomain,
                            lpszPassword,
                            dwLogonType,
                            dwLogonProvider,
                            FALSE,            // LogonUserA
                            phToken,
                            NULL,             // ppLogonSid
                            NULL,             // ppProfileBuffer
                            NULL,             // pdwProfileLength
                            NULL);            // pQuotaLimits
}


//+---------------------------------------------------------------------------
//
//  Function:   LogonUserExA
//
//  Synopsis:   ANSI wrapper for LogonUserExW.  See description below
//
//  Arguments:  [lpszUsername]     --
//              [lpszDomain]       --
//              [lpszPassword]     --
//              [dwLogonType]      --
//              [dwLogonProvider]  --
//              [phToken]          --
//              [ppLogonSid]       --
//              [ppProfileBuffer]  --
//              [pdwProfileLength] --
//              [pQuotaLimits]     --
//
//  History:    2-15-2000   JSchwart   Created from RichardW's LogonUserW
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
WINAPI
LogonUserExA(
    LPCSTR          lpszUsername,
    LPCSTR          lpszDomain,
    LPCSTR          lpszPassword,
    DWORD          dwLogonType,
    DWORD          dwLogonProvider,
    HANDLE *       phToken,
    PSID   *       ppLogonSid,
    PVOID  *       ppProfileBuffer,
    DWORD  *       pdwProfileLength,
    PQUOTA_LIMITS  pQuotaLimits
    )
{
    return LogonUserCommonA(lpszUsername,
                            lpszDomain,
                            lpszPassword,
                            dwLogonType,
                            dwLogonProvider,
                            TRUE,             // LogonUserExA
                            phToken,
                            ppLogonSid,
                            ppProfileBuffer,
                            pdwProfileLength,
                            pQuotaLimits);
}


//+---------------------------------------------------------------------------
//
//  Function:   LogonUserCommonW
//
//  Synopsis:   Common code for LogonUserW and LogonUserExW.  Logs a user on
//              via plaintext password, username and domain name via the LSA.
//
//  Arguments:  [lpszUsername]     -- User name
//              [lpszDomain]       -- Domain name
//              [lpszPassword]     -- Password
//              [dwLogonType]      -- Logon type
//              [dwLogonProvider]  -- Provider
//              [fExVersion]       -- LogonUserExW or LogonUserW
//              [phToken]          -- Returned handle to primary token
//              [ppLogonSid]       -- Returned logon sid
//              [ppProfileBuffer]  -- Returned user profile buffer
//              [pdwProfileLength] -- Returned profile length
//
//  History:    2-15-2000   JSchwart   Created from RichardW's LogonUserW
//
//  Notes:      Requires SeTcbPrivilege, and will enable it if not already
//              present.
//
//----------------------------------------------------------------------------
BOOL
WINAPI
LogonUserCommonW(
    PCWSTR          lpszUsername,
    PCWSTR          lpszDomain,
    PCWSTR          lpszPassword,
    DWORD          dwLogonType,
    DWORD          dwLogonProvider,
    BOOL           fExVersion,
    HANDLE *       phToken,
    PSID   *       ppLogonSid,
    PVOID  *       ppProfileBuffer,
    DWORD  *       pdwProfileLength,
    PQUOTA_LIMITS  pQuotaLimits
    )
{
    NTSTATUS    Status;
    ULONG       PackageId;
    UNICODE_STRING  Username;
    UNICODE_STRING  Domain;
    UNICODE_STRING  Password;
    HANDLE      hTempToken;
    HANDLE    * phTempToken;
    LUID        LogonId;
    PVOID       Profile;
    ULONG       ProfileLength;
    NTSTATUS    SubStatus = STATUS_SUCCESS;
    SECURITY_LOGON_TYPE LogonType;


    //
    // Validate the provider
    //
    if (dwLogonProvider == LOGON32_PROVIDER_DEFAULT)
    {
        dwLogonProvider = LOGON32_PROVIDER_WINNT50;

        //
        // if domain was not supplied, and username is not a UPN, use
        // _WINNT40 to be compatible.
        //

        if((lpszUsername != NULL) &&
           (lpszDomain == NULL || lpszDomain[ 0 ] == L'\0'))
        {
            if( wcschr( lpszUsername, L'@' ) == NULL )
            {
                dwLogonProvider = LOGON32_PROVIDER_WINNT40;
            }
        }
    }

    if (dwLogonProvider > LOGON32_PROVIDER_WINNT50)
    {
        BaseSetLastNTError(STATUS_INVALID_PARAMETER);
        return(FALSE);
    }

    switch (dwLogonType)
    {
        case LOGON32_LOGON_INTERACTIVE:
            LogonType = Interactive;
            break;

        case LOGON32_LOGON_BATCH:
            LogonType = Batch;
            break;

        case LOGON32_LOGON_SERVICE:
            LogonType = Service;
            break;

        case LOGON32_LOGON_NETWORK:
            LogonType = Network;
            break;                 

        case LOGON32_LOGON_UNLOCK:
            LogonType = Unlock ;
            break;

        case LOGON32_LOGON_NETWORK_CLEARTEXT:
            LogonType = NetworkCleartext ;
            break;

        case LOGON32_LOGON_NEW_CREDENTIALS:
            LogonType = NewCredentials;
            break;

        default:
            BaseSetLastNTError(STATUS_INVALID_PARAMETER);
            return(FALSE);
            break;
    }

    //
    // If the MSV handle is -1, grab the lock, and try again:
    //

    if (Logon32MsvHandle == 0xFFFFFFFF || Logon32NegoHandle == 0xFFFFFFFF)
    {
        LockLogon();

        //
        // If the MSV handle is still -1, init our connection to lsa.  We
        // have the lock, so no other threads can't be trying this right now.
        //
        if (Logon32MsvHandle == 0xFFFFFFFF || Logon32NegoHandle == 0xFFFFFFFF)
        {
            if (!L32pInitLsa())
            {
                UnlockLogon();

                return( FALSE );
            }
        }

        UnlockLogon();
    }

    //
    // Validate the parameters.  NULL or empty domain or NULL or empty
    // user name is invalid.
    //

    RtlInitUnicodeString(&Username, lpszUsername);
    if (Username.Length == 0)
    {
        BaseSetLastNTError(STATUS_INVALID_PARAMETER);
        return(FALSE);
    }

    //
    // Initialize/check parameters based on which API we're servicing.
    //
    if (!fExVersion)
    {
        //
        // LogonUserW -- phToken is required.  Initialize the token handle,
        // if the pointer is invalid, then catch the exception now.
        //

        *phToken    = NULL;
        phTempToken = phToken;
    }
    else
    {
        //
        // LogonUserExW -- phToken, ppLogonSid, ppProfileBuffer, and
        // pdwProfileLength are optional.  Initialize as appropriate.
        //

        if (ARGUMENT_PRESENT(phToken))
        {
            *phToken    = NULL;
            phTempToken = phToken;
        }
        else
        {
            //
            // Dummy token handle to use in the LsaLogonUser call
            //
            phTempToken = &hTempToken;
        }

        if (ARGUMENT_PRESENT(ppLogonSid))
        {
            *ppLogonSid = NULL;
        }

        if (!!ppProfileBuffer ^ !!pdwProfileLength)
        {
            //
            // Can't have one without the other...
            //
            BaseSetLastNTError(STATUS_INVALID_PARAMETER);
            return(FALSE);
        }

        if (ARGUMENT_PRESENT(ppProfileBuffer))
        {
            *ppProfileBuffer  = NULL;
            *pdwProfileLength = 0;
        }

        if (ARGUMENT_PRESENT(pQuotaLimits))
        {
            RtlZeroMemory(pQuotaLimits, sizeof(QUOTA_LIMITS));
        }
    }

    //
    // Parse that domain.  Note, if the special token . is passed in for
    // domain, we will use the right value from the LSA, meaning AccountDomain.
    // If the domain is null, the lsa will talk to the local domain, the
    // primary domain, and then on from there...
    //
    if (lpszDomain && *lpszDomain)
    {
        if ((lpszDomain[0] == L'.') &&
            (lpszDomain[1] == L'\0') )
        {
            if (!L32GetDefaultDomainName(&Domain))
            {
                return(FALSE);
            }
        }
        else
        {
            RtlInitUnicodeString(&Domain, lpszDomain);
        }
    }
    else
    {
        RtlInitUnicodeString(&Domain, lpszDomain);
    }

    //
    // Finally, init the password
    //
    RtlInitUnicodeString(&Password, lpszPassword);



    //
    // Attempt the logon
    //

    Status = L32pLogonUser(
                    Logon32LsaHandle,
                    (dwLogonProvider == LOGON32_PROVIDER_WINNT50) ?
                        Logon32NegoHandle : Logon32MsvHandle,
                    LogonType,
                    &Username,
                    &Domain,
                    &Password,
                    &LogonId,
                    phTempToken,
                    pQuotaLimits ? pQuotaLimits : &Logon32QuotaLimits,
                    &Profile,
                    &ProfileLength,
                    &SubStatus);

    //
    // Set output parameters based on which API we're servicing
    //


    // TODO: review cleanup code if something fails mid-stream.
    //

    if (!fExVersion)
    {

        if (!NT_SUCCESS(Status))
        {
            if (Status == STATUS_ACCOUNT_RESTRICTION)
            {
                BaseSetLastNTError(SubStatus);
            }
            else
            {
                BaseSetLastNTError(Status);
            }

            return(FALSE);
        }

        if (Profile != NULL)
        {
            LsaFreeReturnBuffer(Profile);
        }
    }
    else
    {
        //
        // We may need the allocated buffers if all went well, so
        // check the return status first.
        //

        if (!NT_SUCCESS(Status))
        {
            if (Status == STATUS_ACCOUNT_RESTRICTION)
            {
                BaseSetLastNTError(SubStatus);
            }
            else
            {
                BaseSetLastNTError(Status);
            }

            return(FALSE);
        }

        //
        // The logon succeeded -- fill in the requested output parameters.
        //

        if (ARGUMENT_PRESENT(ppLogonSid))
        {
            *ppLogonSid = L32FindLogonSid( *phTempToken );

            if (*ppLogonSid == NULL)
            {
                if (Profile != NULL)
                {
                    LsaFreeReturnBuffer(Profile);
                }

                CloseHandle(*phTempToken);
                *phTempToken = NULL;

                BaseSetLastNTError(STATUS_NO_MEMORY);
                return(FALSE);
            }
        }

        if (ARGUMENT_PRESENT(ppProfileBuffer))
        {
            if (Profile != NULL)
            {
                ASSERT(ProfileLength != 0);

                *ppProfileBuffer = Profile;
                *pdwProfileLength = ProfileLength;
            }
        }
        else
        {
            if (Profile != NULL)
            {
                LsaFreeReturnBuffer(Profile);
            }
        }

        if (!ARGUMENT_PRESENT(phToken))
        {
            //
            // Close the dummy token handle
            //
            CloseHandle(*phTempToken);
        }
    }

    return(TRUE);
}


//+---------------------------------------------------------------------------
//
//  Function:   LogonUserW
//
//  Synopsis:   Logs a user on via plaintext password, username and domain
//              name via the LSA.
//
//  Arguments:  [lpszUsername]    -- User name
//              [lpszDomain]      -- Domain name
//              [lpszPassword]    -- Password
//              [dwLogonType]     -- Logon type
//              [dwLogonProvider] -- Provider
//              [phToken]         -- Returned handle to primary token
//
//  History:    4-25-95   RichardW   Created
//
//  Notes:      Requires SeTcbPrivilege, and will enable it if not already
//              present.
//
//----------------------------------------------------------------------------
BOOL
WINAPI
LogonUserW(
    PCWSTR       lpszUsername,
    PCWSTR       lpszDomain,
    PCWSTR       lpszPassword,
    DWORD       dwLogonType,
    DWORD       dwLogonProvider,
    HANDLE *    phToken
    )
{
    return LogonUserCommonW(lpszUsername,
                            lpszDomain,
                            lpszPassword,
                            dwLogonType,
                            dwLogonProvider,
                            FALSE,            // LogonUserW
                            phToken,
                            NULL,             // ppLogonSid
                            NULL,             // ppProfileBuffer
                            NULL,             // pdwProfileLength
                            NULL);            // pQuotaLimits
}


//+---------------------------------------------------------------------------
//
//  Function:   LogonUserExW
//
//  Synopsis:   Logs a user on via plaintext password, username and domain
//              name via the LSA.
//
//  Arguments:  [lpszUsername]     -- User name
//              [lpszDomain]       -- Domain name
//              [lpszPassword]     -- Password
//              [dwLogonType]      -- Logon type
//              [dwLogonProvider]  -- Provider
//              [phToken]          -- Returned handle to primary token
//              [ppLogonSid]       -- Returned logon sid
//              [ppProfileBuffer]  -- Returned user profile buffer
//              [pdwProfileLength] -- Returned profile length
//              [pQuotaLimits]     -- Returned quota limits
//
//  History:    2-15-2000   JSchwart   Created from RichardW's LogonUserW
//
//  Notes:      Requires SeTcbPrivilege, and will enable it if not already
//              present.
//
//----------------------------------------------------------------------------
BOOL
WINAPI
LogonUserExW(
    PCWSTR          lpszUsername,
    PCWSTR          lpszDomain,
    PCWSTR          lpszPassword,
    DWORD          dwLogonType,
    DWORD          dwLogonProvider,
    HANDLE *       phToken,
    PSID   *       ppLogonSid,
    PVOID  *       ppProfileBuffer,
    DWORD  *       pdwProfileLength,
    PQUOTA_LIMITS  pQuotaLimits
    )
{
    return LogonUserCommonW(lpszUsername,
                            lpszDomain,
                            lpszPassword,
                            dwLogonType,
                            dwLogonProvider,
                            TRUE,             // LogonUserExW
                            phToken,
                            ppLogonSid,
                            ppProfileBuffer,
                            pdwProfileLength,
                            pQuotaLimits);
}


//+---------------------------------------------------------------------------
//
//  Function:   ImpersonateLoggedOnUser
//
//  Synopsis:   Duplicates the token passed in if it is primary, and assigns
//              it to the thread that called.
//
//  Arguments:  [hToken] --
//
//  History:    1-10-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
WINAPI
ImpersonateLoggedOnUser(
    HANDLE  hToken
    )
{
    TOKEN_TYPE                  Type;
    ULONG                       cbType;
    HANDLE                      hImpToken;
    NTSTATUS                    Status;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
    OBJECT_ATTRIBUTES           ObjectAttributes;
    BOOL                        fCloseImp;

    Status = NtQueryInformationToken(
                hToken,
                TokenType,
                &Type,
                sizeof(TOKEN_TYPE),
                &cbType);

    if (!NT_SUCCESS(Status))
    {
        BaseSetLastNTError(Status);
        return(FALSE);
    }

    if (Type == TokenPrimary)
    {
        InitializeObjectAttributes(
                            &ObjectAttributes,
                            NULL,
                            0L,
                            NULL,
                            NULL);

        SecurityQualityOfService.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
        SecurityQualityOfService.ImpersonationLevel = SecurityImpersonation;
        SecurityQualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
        SecurityQualityOfService.EffectiveOnly = FALSE;

        ObjectAttributes.SecurityQualityOfService = &SecurityQualityOfService;


        Status = NtDuplicateToken( hToken,
                                   TOKEN_IMPERSONATE | TOKEN_QUERY,
                                   &ObjectAttributes,
                                   FALSE,
                                   TokenImpersonation,
                                   &hImpToken
                                 );

        if (!NT_SUCCESS(Status))
        {
            BaseSetLastNTError(Status);
            return(FALSE);
        }

        fCloseImp = TRUE;

    }

    else

    {
        hImpToken = hToken;
        fCloseImp = FALSE;
    }

    Status = NtSetInformationThread(
                NtCurrentThread(),
                ThreadImpersonationToken,
                (PVOID) &hImpToken,
                sizeof(hImpToken)
                );

    if (fCloseImp)
    {
        (void) NtClose(hImpToken);
    }

    if (!NT_SUCCESS(Status))
    {
        BaseSetLastNTError(Status);
        return(FALSE);
    }

    return(TRUE);

}


//+---------------------------------------------------------------------------
//
//  Function:   L32SetProcessToken
//
//  Synopsis:   Sets the primary token for the new process.
//
//  Arguments:  [psd]      --
//              [hProcess] --
//              [hThread]  --
//              [hToken]   --
//
//  History:    4-25-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
L32SetProcessToken(
    HANDLE                  hProcess,
    HANDLE                  hThread,
    HANDLE                  hTokenToAssign,
    BOOL                    AlreadyImpersonating
    )
{
    NTSTATUS Status, AdjustStatus;
    PROCESS_ACCESS_TOKEN PrimaryTokenInfo;
    BOOLEAN WasEnabled;
    HANDLE NullHandle;


    //
    // Set the process's primary token.  This is actually much more complex
    // to implement in a single API, but we'll live with it.  This MUST be
    // called when we are not impersonating!  The client generally does *not*
    // have the SeAssignPrimary privilege
    //


    //
    // Enable the required privilege
    //

    if ( !AlreadyImpersonating )
    {
        Status = RtlImpersonateSelf( SecurityImpersonation );
    }
    else
    {
        Status = STATUS_SUCCESS ;
    }

    if ( NT_SUCCESS( Status ) )
    {
        //
        // We now allow restricted tokens to passed in, so we don't
        // fail if the privilege isn't held.  Let the kernel deal with
        // the possibilities.
        //

        Status = RtlAdjustPrivilege(SE_ASSIGNPRIMARYTOKEN_PRIVILEGE, TRUE,
                                    TRUE, &WasEnabled);

        if ( !NT_SUCCESS( Status ) )
        {
            WasEnabled = TRUE ;     // Don't try to restore it.
        }

        PrimaryTokenInfo.Token  = hTokenToAssign;
        PrimaryTokenInfo.Thread = hThread;

        Status = NtSetInformationProcess(
                    hProcess,
                    ProcessAccessToken,
                    (PVOID)&PrimaryTokenInfo,
                    (ULONG)sizeof(PROCESS_ACCESS_TOKEN)
                    );
        //
        // Restore the privilege to its previous state
        //

        if (!WasEnabled)
        {
            AdjustStatus = RtlAdjustPrivilege(SE_ASSIGNPRIMARYTOKEN_PRIVILEGE,
                                          WasEnabled, TRUE, &WasEnabled);
            if (NT_SUCCESS(Status)) {
                Status = AdjustStatus;
            }
        }


        //
        // Revert back to process.
        //

        if ( !AlreadyImpersonating )
        {
            NullHandle = NULL;

            AdjustStatus = NtSetInformationThread(
                                NtCurrentThread(),
                                ThreadImpersonationToken,
                                (PVOID) &NullHandle,
                                sizeof( HANDLE ) );

            if ( NT_SUCCESS( Status ) )
            {
                Status = AdjustStatus;
            }
        }



    } else {

        NOTHING;
    }

    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
    }

    return (NT_SUCCESS(Status));

}


//+---------------------------------------------------------------------------
//
//  Function:   L32SetProcessQuotas
//
//  Synopsis:   Updates the quotas for the process
//
//  Arguments:  [hProcess] --
//
//  History:    4-25-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
L32SetProcessQuotas(
    HANDLE  hProcess,
    BOOL    AlreadyImpersonating )
{
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS AdjustStatus = STATUS_SUCCESS;
    QUOTA_LIMITS RequestedLimits;
    BOOLEAN WasEnabled;
    HANDLE NullHandle;

    RequestedLimits = Logon32QuotaLimits;
    RequestedLimits.MinimumWorkingSetSize = 0;
    RequestedLimits.MaximumWorkingSetSize = 0;

    //
    // Set the process's quota.   This MUST be
    // called when we are not impersonating!  The client generally does *not*
    // have the SeIncreaseQuota privilege.
    //

    if ( !AlreadyImpersonating )
    {
        Status = RtlImpersonateSelf( SecurityImpersonation );
    }

    if ( NT_SUCCESS( Status ) )
    {

        if (RequestedLimits.PagedPoolLimit != 0) {

            Status = RtlAdjustPrivilege(SE_INCREASE_QUOTA_PRIVILEGE, TRUE,
                                        TRUE, &WasEnabled);

            if ( NT_SUCCESS( Status ) )
            {

                Status = NtSetInformationProcess(
                            hProcess,
                            ProcessQuotaLimits,
                            (PVOID)&RequestedLimits,
                            (ULONG)sizeof(QUOTA_LIMITS)
                            );

                if (!WasEnabled)
                {
                    AdjustStatus = RtlAdjustPrivilege(SE_INCREASE_QUOTA_PRIVILEGE,
                                                  WasEnabled, FALSE, &WasEnabled);
                    if (NT_SUCCESS(Status)) {
                        Status = AdjustStatus;
                    }
                }
            }

        }

        if ( !AlreadyImpersonating )
        {
            NullHandle = NULL;

            AdjustStatus = NtSetInformationThread(
                                NtCurrentThread(),
                                ThreadImpersonationToken,
                                (PVOID) &NullHandle,
                                sizeof( HANDLE ) );

            if ( NT_SUCCESS( Status ) )
            {
                Status = AdjustStatus;
            }
        }

    }

    if (!NT_SUCCESS(Status))
    {
        BaseSetLastNTError(Status);
        return(FALSE);
    }

    return(TRUE);
}


BOOL
L32CreateTokenForNewProcess(
    PSECURITY_DESCRIPTOR    psd,
    HANDLE                  hToken,
    PHANDLE                 phTokenToAssign
    )
{
    OBJECT_ATTRIBUTES ObjectAttributes;
    NTSTATUS Status;

    //
    // Check for a NULL token. (No need to do anything)
    // The process will run in the parent process's context and inherit
    // the default ACL from the parent process's token.
    //
    
    if (hToken == NULL)
    {
        *phTokenToAssign = NULL;
        return TRUE;
    }

    //
    // A primary token can only be assigned to one process.
    // Duplicate the logon token so we can assign one to the new
    // process.
    //

    InitializeObjectAttributes(
                 &ObjectAttributes,
                 NULL,
                 0,
                 NULL,
                 psd
                 );

    Status = NtDuplicateToken(
                 hToken,            // Duplicate this token
                 0,                 // Same desired access
                 &ObjectAttributes,
                 FALSE,             // EffectiveOnly
                 TokenPrimary,      // TokenType
                 phTokenToAssign    // Duplicate token handle stored here
                 );


    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        return FALSE;
    }
    return TRUE;
}


HANDLE
L32RevertOpenProcess(
    DWORD dwDesiredAccess,
    BOOL  bInheritHandle,
    DWORD dwProcessId
    )
/*+
    A revert to self wrapper around OpenProcess
-*/
{
    HANDLE   hThreadToken = NULL;
    HANDLE   hRevertToken = NULL;
    HANDLE   hProcess     = NULL;
    BOOL     bImp         = FALSE;
    NTSTATUS Status       = STATUS_SUCCESS;

    //
    // If we are impersonating we must revert.
    // 

    Status = NtOpenThreadToken( 
                 NtCurrentThread(),
                 TOKEN_QUERY | TOKEN_IMPERSONATE,
                 TRUE,
                 &hThreadToken
                 );

    if (NT_SUCCESS(Status))
    {
        bImp = TRUE;

        //
        // Stop impersonating.
        //

        Status = NtSetInformationThread(
                     NtCurrentThread(),
                     ThreadImpersonationToken,
                     &hRevertToken,
                     sizeof(HANDLE)
                     );

        if (!NT_SUCCESS(Status))
        {
            BaseSetLastNTError(Status);
            goto Cleanup;
        }
        else
        {
            bImp = FALSE;
        }
    }
    else if (Status == STATUS_NO_TOKEN)
    {
        hThreadToken = NULL;
        bImp         = FALSE;
    }
    else
    {
        //
        // Why couldn't we open the thread token?
        //

        BaseSetLastNTError(Status);
        ASSERT(NT_SUCCESS(Status));
        goto Cleanup;
    }

    //
    // OpenProcess without impersonating.
    //

    hProcess = OpenProcess(
                   dwDesiredAccess,
                   bInheritHandle,
                   dwProcessId
                   );

    if (hThreadToken)
    {
        //
        // Continue to impersonate.
        //

        Status = NtSetInformationThread(
                     NtCurrentThread(),
                     ThreadImpersonationToken,
                     &hThreadToken,
                     sizeof(HANDLE)
                     );

        if (!NT_SUCCESS(Status))
        {
            BaseSetLastNTError(Status);
            goto Cleanup;
        }
        else
        {
            bImp = TRUE;
        }
    }

Cleanup:

    if (hThreadToken)
    {
        if (!bImp)
        {
            //
            // Continue to impersonate.
            //

            Status = NtSetInformationThread(
                         NtCurrentThread(),
                         ThreadImpersonationToken,
                         &hThreadToken,
                         sizeof(HANDLE)
                         );

            ASSERT(NT_SUCCESS(Status));
        }
        NtClose(hThreadToken);
    }

    return hProcess;
}


BOOL
L32CommonCreate(
    DWORD CreateFlags,
    HANDLE hToken,
    LPPROCESS_INFORMATION lpProcessInfo,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes
    )
/*+
    This will do several tasks.
    
    1 create new security descriptors for the process / thread / token.
    2 create a new token for the new process
    3 assign security to that token
    4 put this new token on the new process
    5 assign security to the process and thread
    6 adjust quotas on the new process
    
-*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    BOOL     b      = TRUE;

    PISECURITY_DESCRIPTOR pProcessSd = NULL;
    PISECURITY_DESCRIPTOR pThreadSd  = NULL;
    PISECURITY_DESCRIPTOR pTokenSd   = NULL;
    
    TOKEN_TYPE Type;
    DWORD      dwLength;
    BOOL       bUsingThreadToken = FALSE;
    BOOL       bUsingImpToken    = FALSE;
    HANDLE     hThreadToken      = NULL;  // the initial thread token, if any
    HANDLE     hNull             = NULL;  // token handle for reverting
    HANDLE     hTokenToAssign    = NULL;  // primary token to place on new process
    HANDLE     hImpToken         = NULL;  // impersonation version of hTokenToAssign

    OBJECT_ATTRIBUTES ObjectAttributes = {0};

    //
    // Please forgive me.
    //

    GENERIC_MAPPING ProcessMapping = {
        STANDARD_RIGHTS_READ |PROCESS_VM_READ | PROCESS_QUERY_INFORMATION,
        STANDARD_RIGHTS_WRITE |PROCESS_CREATE_PROCESS | PROCESS_CREATE_THREAD |PROCESS_VM_OPERATION | 
            PROCESS_VM_WRITE | PROCESS_DUP_HANDLE |PROCESS_TERMINATE | PROCESS_SET_QUOTA |
            PROCESS_SET_INFORMATION | PROCESS_SET_PORT,
        STANDARD_RIGHTS_EXECUTE | SYNCHRONIZE,
        PROCESS_ALL_ACCESS
    };

    GENERIC_MAPPING ThreadMapping = {
        STANDARD_RIGHTS_READ |THREAD_GET_CONTEXT | THREAD_QUERY_INFORMATION,
        STANDARD_RIGHTS_WRITE |THREAD_TERMINATE | THREAD_SUSPEND_RESUME | THREAD_ALERT |THREAD_SET_INFORMATION | THREAD_SET_CONTEXT,
        STANDARD_RIGHTS_EXECUTE |SYNCHRONIZE,
        THREAD_ALL_ACCESS
    };

    GENERIC_MAPPING TokenMapping = { 
        TOKEN_READ,
        TOKEN_WRITE,
        TOKEN_EXECUTE,
        TOKEN_ALL_ACCESS
    };

    //
    // Sanity.
    //

    if (lpProcessInfo->hProcess == NULL)
    {
        b = FALSE;
        BaseSetLastNTError(STATUS_INVALID_HANDLE);
        goto Cleanup;
    }

#ifdef ALLOW_IMPERSONATION_TOKENS
    HANDLE hTempToken = NULL;
#endif

    //
    // Determine type of token, since a non primary token will not work
    // on a process.  Now, we could duplicate it into a primary token,
    // and whack it into the process, but that leaves the process possibly
    // without credentials.
    //

    Status = NtQueryInformationToken(
                 hToken, 
                 TokenType,
                 (PUCHAR) &Type, 
                 sizeof(Type), 
                 &dwLength
                 );

    if (!NT_SUCCESS(Status))
    {
        b = FALSE;
        BaseSetLastNTError(Status);
        goto Cleanup;
    }

    if (Type != TokenPrimary)
    {
#ifdef ALLOW_IMPERSONATION_TOKENS
        //
        // Make this a primary token.
        //

        InitializeObjectAttributes(
                            &ObjectAttributes,
                            NULL,
                            0L,
                            NULL,
                            NULL);

        SecurityQualityOfService.Length              = sizeof(SECURITY_QUALITY_OF_SERVICE);
        SecurityQualityOfService.ImpersonationLevel  = SecurityImpersonation;
        SecurityQualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
        SecurityQualityOfService.EffectiveOnly       = FALSE;

        ObjectAttributes.SecurityQualityOfService = &SecurityQualityOfService;

        Status = NtDuplicateToken( 
                     hToken,
                     TOKEN_IMPERSONATE | TOKEN_QUERY,
                     &ObjectAttributes,
                     FALSE,
                     TokenPrimary,
                     &hTempToken
                     );

        if (!NT_SUCCESS(Status))
        {
            b = FALSE;
            BaseSetLastNTError(Status);
            goto Cleanup;
        }

        hToken = hTempToken;
#else   // !ALLOW_IMPERSONATION_TOKENS
        b = FALSE;
        Status = STATUS_BAD_TOKEN_TYPE;
        BaseSetLastNTError(Status);
        goto Cleanup;
#endif
    }

    //
    // Make our security descriptors grant ownership and permissions to the principal
    // represented by hToken.  We need a SD for the process, thread, and the token
    // that is getting placed on the new process.
    //

    //
    // If we are impersonating we must revert because CreatePrivateObjectSecurityEx will
    // call RtlpGetDefaultsSubjectContext, which will try to open the process token.  
    // The thread token (if it exists) will most likely not have this access.
    // 

    Status = NtOpenThreadToken( 
                 NtCurrentThread(),
                 TOKEN_QUERY | TOKEN_IMPERSONATE,
                 TRUE,
                 &hThreadToken
                 );

    if (NT_SUCCESS(Status))
    {
        //
        // Stop impersonating.
        //

        Status = NtSetInformationThread(
                     NtCurrentThread(),
                     ThreadImpersonationToken,
                     &hNull,
                     sizeof(HANDLE)
                     );

        if (!NT_SUCCESS(Status))
        {
            b = FALSE;
            BaseSetLastNTError(Status);
            goto Cleanup;
        }

        bUsingThreadToken = FALSE;
    }
    else if (Status == STATUS_NO_TOKEN)
    {
        hThreadToken      = NULL;
        bUsingThreadToken = FALSE;
    }
    else
    {
        //
        // Why couldn't we open the thread token?
        //

        ASSERT(NT_SUCCESS(Status));
        b = FALSE;
        BaseSetLastNTError(Status);
        goto Cleanup;
    }

    //
    // We should not be impersonating.
    //

    ASSERT(!bUsingThreadToken && !bUsingImpToken);

    //
    // Ignore the owner check as the owner in the passed SD may not be assignable as an owner
    // given our current security context.
    //
    
    b = CreatePrivateObjectSecurityEx(
            NULL,
            lpProcessAttributes ? lpProcessAttributes->lpSecurityDescriptor : NULL,
            &pProcessSd,
            NULL,
            FALSE,
            SEF_AVOID_OWNER_CHECK,
            hToken,
            &ProcessMapping
            );

    if (!b)
    {
        goto Cleanup;
    }

    b = CreatePrivateObjectSecurityEx(
            NULL,
            lpThreadAttributes ? lpThreadAttributes->lpSecurityDescriptor : NULL,
            &pThreadSd,
            NULL,
            FALSE,
            SEF_AVOID_OWNER_CHECK,
            hToken,
            &ThreadMapping
            );

    if (!b)
    {
        goto Cleanup;
    }

    b = CreatePrivateObjectSecurityEx(
            NULL,
            NULL,
            &pTokenSd,
            NULL,
            FALSE,
            SEF_AVOID_OWNER_CHECK,
            hToken,
            &TokenMapping
            );
    
    if (!b)
    {
        goto Cleanup;
    }

    //
    // We need an impersonation version of hToken so that we can later assign
    // these SDs to the process and threads.  The SDs we created specify hToken
    // as the owner (assuming no passed SDs with owners), so only a thread 
    // impersonating as hToken can assign them to objects successfully 
    // (else we fail with INVALID_OWNER).
    //

    b = DuplicateTokenEx(
            hToken,
            TOKEN_QUERY | TOKEN_IMPERSONATE,
            NULL,
            SecurityImpersonation,
            TokenImpersonation,
            &hImpToken
            );

    if (!b)
    {
        goto Cleanup;
    }

    //
    // Create a new token to put on the process.  Make this a duplicate of
    // the passed hToken.  We are not impersonating here.
    //

    ASSERT(!bUsingThreadToken && !bUsingImpToken);

    b = L32CreateTokenForNewProcess( 
            pTokenSd, 
            hToken, 
            &hTokenToAssign 
            );
    
    if (!b)
    {
        //
        // Try again under impersonation: if the Owner in pTokenSd isn't assignable 
        // when we run as the process, it will work with the new impersonation 
        // version of hToken (since pTokenSd states that the hToken principal is to 
        // be assigned as the Owner of hTokenToAssign).
        //

        Status = NtSetInformationThread(
                     NtCurrentThread(),
                     ThreadImpersonationToken,
                     &hImpToken,
                     sizeof(HANDLE)
                     );

        if (!NT_SUCCESS(Status))
        {
            b = FALSE;
            BaseSetLastNTError(Status);
            goto Cleanup;
        }

        bUsingImpToken = TRUE;

        b = L32CreateTokenForNewProcess( 
                pTokenSd, 
                hToken, 
                &hTokenToAssign 
                );
    
        if (!b)
        {
            goto Cleanup;
        }

        //
        // Revert.
        //

        Status = NtSetInformationThread(
                     NtCurrentThread(),
                     ThreadImpersonationToken,
                     &hNull,
                     sizeof(HANDLE)
                     );

        if (!NT_SUCCESS(Status))
        {
            b = FALSE;
            BaseSetLastNTError(Status);
            goto Cleanup;
        }

        bUsingImpToken = FALSE;
    }
        
    //
    // Now hTokenToAssign exists as a duplicate of hToken and it has proper security 
    // which grants access and ownership to the hToken principal.  Set the primary token 
    // of the new process to be hTokenToAssign. Try this first without impersonating, 
    // since the current process currently owns this new process.
    //

    ASSERT(!bUsingThreadToken && !bUsingImpToken);

    b = L32SetProcessToken(
            lpProcessInfo->hProcess,
            lpProcessInfo->hThread,
            hTokenToAssign,
            FALSE
            );

    if (!b)                       
    {
        if (hThreadToken)
        {
            //
            // Try again as the original thread principal.  We aren't trying as the
            // hToken principal because that would allow anyone to create a process
            // as any user with the correct privileges (assuming that they could get
            // ahold of said user's token).  If the thread token had the assign primary
            // privilege then we will succeed.
            //

            Status = NtSetInformationThread(
                         NtCurrentThread(),
                         ThreadImpersonationToken,
                         &hThreadToken,
                         sizeof(HANDLE)
                         );

            if (!NT_SUCCESS(Status))
            {
                b = FALSE;
                BaseSetLastNTError(Status);
                goto Cleanup;
            }

            bUsingThreadToken = TRUE;

            b = L32SetProcessToken(
                    lpProcessInfo->hProcess,
                    lpProcessInfo->hThread,
                    hTokenToAssign,
                    TRUE
                    );
    
            if (!b)
            {
                goto Cleanup;
            }

            //
            // Revert.
            //

            Status = NtSetInformationThread(
                         NtCurrentThread(),
                         ThreadImpersonationToken,
                         &hNull,
                         sizeof(HANDLE)
                         );

            if (!NT_SUCCESS(Status))
            {
                b = FALSE;
                BaseSetLastNTError(Status);
                goto Cleanup;
            }

            bUsingThreadToken = FALSE;
        }
        else
        {
            //
            // The process doesn't have rights to assign the new process
            // a primary token, and we weren't called with an impersonation
            // context.  We must give up.
            //

            goto Cleanup;
        }
    }

    //
    // Adjust the quota to something reasonable.
    //

    ASSERT(!bUsingThreadToken && !bUsingImpToken);

    b = L32SetProcessQuotas(
            lpProcessInfo->hProcess,
            FALSE 
            );

    if (!b)
    {
        if (hThreadToken)
        {
            //
            // If we failed to adjust quota as the process then try 
            // while impersonating as the original thread token.
            //

            Status = NtSetInformationThread(
                         NtCurrentThread(),
                         ThreadImpersonationToken,
                         &hThreadToken,
                         sizeof(HANDLE)
                         );

            if (!NT_SUCCESS(Status))
            {
                b = FALSE;
                BaseSetLastNTError(Status);
                goto Cleanup;
            }
        
            bUsingThreadToken = TRUE;

            b = L32SetProcessQuotas(
                    lpProcessInfo->hProcess,
                    TRUE
                    );
    
            if (!b)
            {
                goto Cleanup;
            }

            //
            // Revert.
            //

            Status = NtSetInformationThread(
                         NtCurrentThread(),
                         ThreadImpersonationToken,
                         &hNull,
                         sizeof(HANDLE)
                         );

            if (!NT_SUCCESS(Status))
            {
                b = FALSE;
                BaseSetLastNTError(Status);
                goto Cleanup;
            }
        
            bUsingThreadToken = FALSE;
        }
        else
        {
            //
            // We cannot adjust the quota as the process, and we were
            // not called while impersonating.  Fail.
            //

            goto Cleanup;
        }
    }

    //
    // We should not be impersonating here.
    //

    ASSERT(!bUsingThreadToken && !bUsingImpToken);

    //
    // Now put the correct SD on the process / thread.
    //

    b = SetKernelObjectSecurity( 
            lpProcessInfo->hProcess, 
            GROUP_SECURITY_INFORMATION | OWNER_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION,
            pProcessSd
            );
    
    if (!b)
    {
        //
        // If we failed above the cause was most likely because the owner ID in 
        // the SD does not exist as an assignable owner ID in the current process token.  
        // Impersonating as hImpToken will take care of this.
        //

        Status = NtSetInformationThread(
                        NtCurrentThread(),
                        ThreadImpersonationToken,
                        &hImpToken,
                        sizeof(HANDLE)
                        );

        if (!NT_SUCCESS(Status))
        {
            b = FALSE;
            BaseSetLastNTError(Status);
            goto Cleanup;
        }

        bUsingImpToken = TRUE;
        
        //
        // Try again as hImpToken.
        //

        b = SetKernelObjectSecurity( 
                lpProcessInfo->hProcess, 
                GROUP_SECURITY_INFORMATION | OWNER_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION,
                pProcessSd
                );
        
        if (!b)
        {
            goto Cleanup;
        }

        //
        // Revert.
        //

        Status = NtSetInformationThread(
                     NtCurrentThread(),
                     ThreadImpersonationToken,
                     &hNull,
                     sizeof(HANDLE)
                     );

        if (!NT_SUCCESS(Status))
        {
            b = FALSE;
            BaseSetLastNTError(Status);
            goto Cleanup;
        }

        bUsingImpToken = FALSE;
    }

    //
    // Now put it on the thread.
    //

    b = SetKernelObjectSecurity( 
            lpProcessInfo->hThread, 
            GROUP_SECURITY_INFORMATION | OWNER_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION,
            pThreadSd
            );
    
    if (!b)
    {
        //
        // If we failed above the cause was most likely because the owner ID in 
        // the SD does not exist as an assignable owner ID in the current process token.  
        // Impersonating as hImpToken will take care of this.
        //

        Status = NtSetInformationThread(
                        NtCurrentThread(),
                        ThreadImpersonationToken,
                        &hImpToken,
                        sizeof(HANDLE)
                        );

        if (!NT_SUCCESS(Status))
        {
            b = FALSE;
            BaseSetLastNTError(Status);
            goto Cleanup;
        }

        bUsingImpToken = TRUE;
        
        //
        // Try again as hImpToken.
        //

        b = SetKernelObjectSecurity( 
                lpProcessInfo->hThread, 
                GROUP_SECURITY_INFORMATION | OWNER_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION,
                pThreadSd
                );
        
        if (!b)
        {
            goto Cleanup;
        }

        //
        // Revert.
        //

        Status = NtSetInformationThread(
                     NtCurrentThread(),
                     ThreadImpersonationToken,
                     &hNull,
                     sizeof(HANDLE)
                     );

        if (!NT_SUCCESS(Status))
        {
            b = FALSE;
            BaseSetLastNTError(Status);
            goto Cleanup;
        }

        bUsingImpToken = FALSE;
    }

    //
    // If we're not supposed to leave it suspended then resume the
    // thread and let it run.
    //

    if ((CreateFlags & COMMON_CREATE_SUSPENDED) == 0)
    {
        ResumeThread(lpProcessInfo->hThread);
    }

    //
    // That's it! 
    //

    goto Cleanup;

Cleanup:

#ifdef ALLOW_IMPERSONATION_TOKENS
    if (hTempToken)
    {
        NtClose(hTempToken);
    }
#endif
    
    //
    // Free our new security descriptors.
    //

    if (pTokenSd)
    {
        DestroyPrivateObjectSecurity(&pTokenSd);
    }

    if (pProcessSd)
    {
        DestroyPrivateObjectSecurity(&pProcessSd);
    }
    
    if (pThreadSd)
    {
        DestroyPrivateObjectSecurity(&pThreadSd);
    }
    
    if (hTokenToAssign)
    {
        NtClose(hTokenToAssign);
    }

    //
    // If we are using the newly created impersonation token
    // then revert.
    //

    if (hImpToken)
    {
        if (bUsingImpToken)
        {
            Status = NtSetInformationThread(
                         NtCurrentThread(),
                         ThreadImpersonationToken,
                         &hNull,
                         sizeof(HANDLE)
                         );

            //
            // We should only ASSERT here because we don't want to 
            // overwrite our real error codes.
            //

            ASSERT(NT_SUCCESS(Status));
        }
        NtClose(hImpToken);
    }
    
    //
    // Resume original impersonation if that is how we were called.
    //

    if (hThreadToken)
    {
        if (!bUsingThreadToken)
        {
            Status = NtSetInformationThread(
                         NtCurrentThread(),
                         ThreadImpersonationToken,
                         &hThreadToken,
                         sizeof(HANDLE)
                         );

            //
            // We should only ASSERT here because we don't want to 
            // overwrite our real error codes.
            //

            ASSERT(NT_SUCCESS(Status));
        }
        NtClose(hThreadToken);
    }

    if (!b)
    {
        if (lpProcessInfo->hProcess)
        {
            NtTerminateProcess(
                lpProcessInfo->hProcess,
                ERROR_ACCESS_DENIED
                );
            NtClose(lpProcessInfo->hProcess);
        }
        if (lpProcessInfo->hThread)
        {
            NtClose(lpProcessInfo->hThread);
        }
        RtlZeroMemory( 
            lpProcessInfo, 
            sizeof(PROCESS_INFORMATION) 
            );
    }
    return b;
}


//+---------------------------------------------------------------------------
//
//  Function:   SaferiReplaceProcessThreadTokens
//
//  Synopsis:
//      Provides a privately exported function to replace the access token
//      of a process and its primary thread of a new process before its
//      execution has begun.  The process is left in a suspended state
//      after the token modification has been performed.
//
//  Effects:
//
//  Arguments:  [NewTokenHandle]  -- Primary token to use
//              [ProcessHandle]   -- Process handle
//              [ThreadHandle]    -- Handle of process's primary Thread
//
//  History:    8-25-2000   JLawson   Created
//
//  Notes:
//      This is merely a wrapper function that calls L32CommonCreate.
//
//----------------------------------------------------------------------------
BOOL
WINAPI
SaferiReplaceProcessThreadTokens(
        IN HANDLE       NewTokenHandle,
        IN HANDLE       ProcessHandle,
        IN HANDLE       ThreadHandle
        )
{
    PROCESS_INFORMATION TempProcessInfo;

    RtlZeroMemory( &TempProcessInfo, sizeof( PROCESS_INFORMATION ) );
    TempProcessInfo.hProcess = ProcessHandle;
    TempProcessInfo.hThread = ThreadHandle;
    return (L32CommonCreate(
            COMMON_CREATE_PROCESSSD | COMMON_CREATE_THREADSD | COMMON_CREATE_SUSPENDED,
            NewTokenHandle, 
            &TempProcessInfo, 
            NULL, 
            NULL));
}


//+---------------------------------------------------------------------------
//
//   MarshallString
//
//    Marshall in a UNICODE_NULL terminated WCHAR string
//
//  ENTRY:
//    pSource (input)
//      Pointer to source string
//
//    pBase (input)
//      Base buffer pointer for normalizing the string pointer
//
//    MaxSize (input)
//      Maximum buffer size available
//
//    ppPtr (input/output)
//      Pointer to the current context pointer in the marshall buffer.
//      This is updated as data is marshalled into the buffer
//
//    pCount (input/output)
//      Current count of data in the marshall buffer.
//      This is updated as data is marshalled into the buffer
//
//  EXIT:
//    NULL - Error
//    !=NULL "normalized" pointer to the string in reference to pBase
//
//+---------------------------------------------------------------------------
PWCHAR
MarshallString(
    PCWSTR pSource,
    PCHAR  pBase,
    ULONG  MaxSize,
    PCHAR  *ppPtr,
    PULONG pCount
    )
{
    ULONG Len;
    PCHAR ptr;

    Len = wcslen( pSource );
    Len++; // include the NULL;

    Len *= sizeof(WCHAR); // convert to bytes
    if( (*pCount + Len) > MaxSize ) {
        return( NULL );
    }

    RtlMoveMemory( *ppPtr, pSource, Len );

    //
    // the normalized ptr is the current count
    //
        // Sundown note: ptr is a zero-extension of *pCount.
    ptr = (PCHAR)ULongToPtr(*pCount);

    *ppPtr += Len;
    *pCount += Len;

    return((PWCHAR)ptr);
}

#if DBG

void DumpOutLastErrorString()
{
    LPVOID  lpMsgBuf;

    FormatMessage(
            FORMAT_MESSAGE_ALLOCATE_BUFFER |
            FORMAT_MESSAGE_FROM_SYSTEM |
            FORMAT_MESSAGE_IGNORE_INSERTS,
            NULL,
            GetLastError(),
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
            (LPTSTR) &lpMsgBuf,
            0,
            NULL
        );
        //
        // Process any inserts in lpMsgBuf.
        // ...
        // Display the string.
        //
        KdPrint(("%s\n", (LPCTSTR)lpMsgBuf ));

        //
        // Free the buffer.
        //
        LocalFree( lpMsgBuf );
}
#endif

#ifdef DBG
#define    DBG_DumpOutLastError    DumpOutLastErrorString();
#else
#define    DBG_DumpOutLastError
#endif


//+---------------------------------------------------------------------------
//
// This function was originally defined in  \nt\private\ole32\dcomss\olescm\execclt.cxx
//
// CreateRemoteSessionProcessW()
//
//  Create a process on the given Terminal Server Session. This is in UNICODE
//
// ENTRY:
//  SessionId (input)
//    SessionId of Session to create process on
//
//  Param1 (input/output)
//    Comments
//
// Comments
//  The security attribs are not used by the session, they are set to NULL
//  We may consider to extend this feature in the future, assuming there is a
//  need for it.
//
// EXIT:
//  STATUS_SUCCESS - no error
//+---------------------------------------------------------------------------
BOOL
CreateRemoteSessionProcessW(
    ULONG  SessionId,
    BOOL   System,
    HANDLE hToken,
    PCWSTR lpszImageName,
    PCWSTR lpszCommandLine,
    PSECURITY_ATTRIBUTES psaProcess,    // these are ignored on the session side, set to NULL
    PSECURITY_ATTRIBUTES psaThread,     // these are ignored on the session side, set to NULL
    BOOL   fInheritHandles,
    DWORD  fdwCreate,
    LPVOID lpvEnvionment,
    LPCWSTR lpszCurDir,
    LPSTARTUPINFOW pStartInfo,
    LPPROCESS_INFORMATION pProcInfo
    )
{
    BOOL            Result = TRUE;
    HANDLE          hPipe = NULL;
    WCHAR           szPipeName[EXECSRVPIPENAMELEN];
    PCHAR           ptr;
    ULONG           Count, AmountWrote, AmountRead;
    DWORD           MyProcId;
    PEXECSRV_REQUEST pReq;
    EXECSRV_REPLY   Rep;
    CHAR            Buf[EXECSRV_BUFFER_SIZE];
    ULONG           MaxSize = EXECSRV_BUFFER_SIZE;
    DWORD           rc;
    LPVOID          lpMsgBuf;
    ULONG           envSize=0;  // size of the lpEnvironemt, if any
    PWCHAR          lpEnv;
    ULONG           ReturnLen;

#if DBG
    if( lpszImageName )
        KdPrint(("logon32.c: CreateRemoteSessionProcessW: lpszImageName %ws\n",lpszImageName));

    if( lpszCommandLine )
        KdPrint(("logon32.c: CreateRemoteSessionProcessW: lpszCommandLine %ws\n",lpszCommandLine));
#endif

    //
    // Winlogon handles all now. System flag tells it what to do
    //
    Result = WinStationQueryInformation( NULL, SessionId, WinStationExecSrvSystemPipe, szPipeName, sizeof(szPipeName), &ReturnLen );
    if ( !Result ) {
        KdPrint(("logon32.c: WinStationQueryInformation for the EXECSRV pipe name failed\n"));
        return(FALSE);
    }

    while ( TRUE )
    {
        hPipe = CreateFileW(
                    szPipeName,
                    GENERIC_READ|GENERIC_WRITE,
                    0,    // File share mode
                    NULL, // default security
                    OPEN_EXISTING,
                    0,    // Attrs and flags
                    NULL  // template file handle
                    );

        if( hPipe == INVALID_HANDLE_VALUE )
        {
            if (GetLastError() == ERROR_PIPE_BUSY)
            {
                if (!WaitNamedPipeW( szPipeName, 30000 ))
                { // 30 sec
                    KdPrint(("logon32.c: Waited too long for pipe name %ws\n", szPipeName));
                    return(FALSE);
                }
            }
            else
            {
                DBG_DumpOutLastError;
                KdPrint(("logon32.c: Could not create pipe name %ws\n", szPipeName));
                return(FALSE);
            }
        }
        else
        {
            break;
        }
    }


    //
    // Get the handle to the current process
    //
    MyProcId = GetCurrentProcessId();

    //
    // setup the marshalling
    //
    ptr = Buf;
    Count = 0;

    pReq = (PEXECSRV_REQUEST)ptr;
    ptr   += sizeof(EXECSRV_REQUEST);
    Count += sizeof(EXECSRV_REQUEST);

    //
    // set the basic parameters
    //
    pReq->System = System;
    pReq->hToken = hToken;
    pReq->RequestingProcessId = MyProcId;
    pReq->fInheritHandles = fInheritHandles;
    pReq->fdwCreate = fdwCreate;

    //
    // marshall the ImageName string
    //
    if( lpszImageName ) {
        pReq->lpszImageName = MarshallString( lpszImageName, Buf, MaxSize, &ptr, &Count );
        if (! pReq->lpszImageName)
        {
            Result = FALSE;
            goto Cleanup;
        }
    }
    else {
        pReq->lpszImageName = NULL;
    }

    //
    // marshall in the CommandLine string
    //
    if( lpszCommandLine ) {
        pReq->lpszCommandLine = MarshallString( lpszCommandLine, Buf, MaxSize, &ptr, &Count );
        if ( ! pReq->lpszCommandLine )
        {
            Result = FALSE;
            goto Cleanup;
        }
    }
    else {
        pReq->lpszCommandLine = NULL;
    }

    //
    // marshall in the CurDir string
    //
    if( lpszCurDir ) {
        pReq->lpszCurDir = MarshallString( lpszCurDir, Buf, MaxSize, &ptr, &Count );
        if ( ! pReq->lpszCurDir  )
        {
            Result = FALSE;
            goto Cleanup;
        }
    }
    else {
        pReq->lpszCurDir = NULL;
    }

    //
    // marshall in the StartupInfo structure
    //
    RtlMoveMemory( &pReq->StartInfo, pStartInfo, sizeof(STARTUPINFO) );

    //
    // Now marshall the strings in STARTUPINFO
    //
    if( pStartInfo->lpDesktop ) {
        pReq->StartInfo.lpDesktop = MarshallString( pStartInfo->lpDesktop, Buf, MaxSize, &ptr, &Count );
        if (! pReq->StartInfo.lpDesktop )
        {
            Result = FALSE;
            goto Cleanup;
        }
    }
    else {
        pReq->StartInfo.lpDesktop = NULL;
    }

    if( pStartInfo->lpTitle ) {
        pReq->StartInfo.lpTitle = MarshallString( pStartInfo->lpTitle, Buf, MaxSize, &ptr, &Count );
        if ( !pReq->StartInfo.lpTitle  )
        {
            Result = FALSE;
            goto Cleanup;
        }
    }
    else {
        pReq->StartInfo.lpTitle = NULL;
    }

    //
    // WARNING: This version does not pass the following:
    //
    //  Also saProcess and saThread are ignored right now and use
    //  the users default security on the remote WinStation
    //
    // Set things that are always NULL
    //
    pReq->StartInfo.lpReserved = NULL;  // always NULL


    if ( lpvEnvionment)
    {
        for ( lpEnv = (PWCHAR) lpvEnvionment;
            (*lpEnv ) && (envSize + Count < MaxSize ) ;  lpEnv++)
        {
            while( *lpEnv )
            {
                lpEnv++;
                envSize += 2;   // we are dealing with wide chars
                if ( envSize+Count >= MaxSize )
                {
                    // we have too many
                    // vars in the user's profile.
                    KdPrint(("\tEnv length too big = %d \n", envSize));
                    break;
                }
            }
            // this is the null which marked the end of the last env var.
            envSize +=2;

        }
        envSize += 2;    // this is the final NULL


        if ( Count + envSize < MaxSize )
        {
            RtlMoveMemory( (PCHAR)&Buf[Count] ,lpvEnvionment, envSize );
                        // SUNDOWN: Count is zero-extended and store in lpvEnvironment.
            //          This zero-extension is valid. The consuming code [see tsext\notify\execsrv.c]
            //          considers lpvEnvironment as an offset (<2GB).
            pReq->lpvEnvironment = (PCHAR)ULongToPtr(Count);
            ptr += envSize;         // for the next guy
            Count += envSize;       // the count used so far
        }
        else    // no room left to make a complete copy
        {
            pReq->lpvEnvironment = NULL;
        }

    }
    else
    {
        pReq->lpvEnvironment = NULL;
    }

    //
    // now fill in the total count
    //
    pReq->Size = Count;

#if DBG
    KdPrint(("pReq->Size = %d, envSize = %d \n", pReq->Size , envSize ));
#endif

    //
    // Now send the buffer out to the server
    //
    Result = WriteFile(
                 hPipe,
                 Buf,
                 Count,
                 &AmountWrote,
                 NULL
                 );

    if( !Result ) {
        KdPrint(("logon32.c: Error %d sending request\n",GetLastError() ));
        goto Cleanup;
    }

    //
    // Now read the reply
    //
    Result = ReadFile(
                 hPipe,
                 &Rep,
                 sizeof(Rep),
                 &AmountRead,
                 NULL
                 );

    if( !Result ) {
        KdPrint(("logon32.c: Error %d reading reply\n",GetLastError()));
        goto Cleanup;
    }

    //
    // Check the result
    //
    if( !Rep.Result ) {
        KdPrint(("logon32.c: Error %d in reply\n",Rep.LastError));
        //
        // set the error in the current thread to the returned error
        //
        Result = Rep.Result;
        SetLastError( Rep.LastError );
        goto Cleanup;
    }

    //
    // We copy the PROCESS_INFO structure from the reply
    // to the caller.
    //
    // The remote site has duplicated the handles into our
    // process space for hProcess and hThread so that they will
    // behave like CreateProcessW()
    //

     RtlMoveMemory( pProcInfo, &Rep.ProcInfo, sizeof( PROCESS_INFORMATION ) );

Cleanup:
    CloseHandle(hPipe);

   KdPrint(("logon32.c:: Result 0x%x\n", Result));

    return(Result);
}


//+---------------------------------------------------------------------------
//
//  Function:   CreateProcessAsUserW
//
//  Synopsis:   Creates a process running as the user in hToken.
//
//  Arguments:  [hToken]               -- Handle to a Primary Token to use
//              [lpApplicationName]    -- as CreateProcess() q.v.
//              [lpCommandLine]        --
//              [lpProcessAttributes]  --
//              [lpThreadAttributes]   --
//              [bInheritHandles]      --
//              [dwCreationFlags]      --
//              [lpEnvironment]        --
//              [lpCurrentDirectory]   --
//              [lpStartupInfo]        --
//              [lpProcessInformation] --
//
//  Return Values
//          If the function succeeds, the return value is nonzero.
//          If the function fails, the return value is zero. To get extended error information, call GetLastError.
//
//  History:    4-25-95   RichardW   Created
//              1-14-98     AraBern     add changes for Hydra
//  Notes:
//
//
//----------------------------------------------------------------------------
BOOL
WINAPI
CreateProcessAsUserW(
    HANDLE  hToken,
    LPCWSTR lpApplicationName,
    LPWSTR lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL bInheritHandles,
    DWORD dwCreationFlags,
    LPVOID lpEnvironment,
    LPCWSTR lpCurrentDirectory,
    LPSTARTUPINFOW lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
    )
{
    DWORD    CreateFlags;
    DWORD    clientSessionID=0;
    DWORD    currentSessionID=0;
    DWORD    resultLength;
    HANDLE   hTmpToken;
    DWORD    curProcId ;
    NTSTATUS Status ;

    CreateFlags = (dwCreationFlags & CREATE_SUSPENDED ? COMMON_CREATE_SUSPENDED : 0);

    //
    // get the sessionID (if zero then it means that we are on the console).
    //
    currentSessionID = NtCurrentPeb()->SessionId;

    if ( !GetTokenInformation ( hToken, TokenSessionId , &clientSessionID,sizeof( DWORD), &resultLength ) )
    {
    //
    // get the access token for the client of this call
    // get token instead of process since the client might have only
    // impersonated the thread, not the process
    //
        DBG_DumpOutLastError;
        ASSERT( FALSE );
        currentSessionID = 0;

        //
        // We should probably return FALSE here, but at this time we don't want to alter the
        // non-Hydra code-execution-flow at all.
        //
    }

    // KdPrint(("logon32.c: CreateProcessAsUserW(): clientSessionID = %d, currentSessionID = %d \n",
    //    clientSessionID, currentSessionID ));

    if (  clientSessionID != currentSessionID )
    {
        //
        // If the client session ID is not the same as the current session ID, then, we are attempting
        // to create a process on a remote session from the current session.
        // This block of code is used to accomplish such process creation, it is Terminal-Server specific
        //

        BOOL        bHaveImpersonated;
        HANDLE      hCurrentThread;
        HANDLE      hPrevToken = NULL;
        DWORD       rc;
        TOKEN_TYPE  tokenType;

        //
        // We must send the request to the remote session
        // of the requestor
        //
        // NOTE: The current WinStationCreateProcessW() does not use
        //       the supplied security descriptor, but creates the
        //       process under the account of the logged on user.
        //

        //
        // Stop impersonating before doing the WinStationCreateProcess.
        // The remote winstation exec thread will launch the app under
        // the users context. We must not be impersonating because this
        // call only lets SYSTEM request the remote execute.
        //

        //
        // Handle Inheritance is not allowed for cross session process creation
        //
        if (bInheritHandles) {

          SetLastError(ERROR_INVALID_PARAMETER);

          return FALSE;
        }

        hCurrentThread = GetCurrentThread();

        //
        // Init bHaveImpersonated to the FALSE state
        //
        bHaveImpersonated = FALSE;

        //
        // Since the caller of this function (runas-> SecLogon service ) has already
        // impersonated the new (target) user, we do the OpenThreadToken with
        // OpenAsSelf = TRUE
        //
        if ( OpenThreadToken( hCurrentThread, TOKEN_QUERY | TOKEN_IMPERSONATE , TRUE, &hPrevToken ) )
        {

            bHaveImpersonated = TRUE;

            if ( !RevertToSelf() )
            {
                return FALSE;
            }
        }


       //
       // else, we are not impersonating, as reflected by the init value of bHaveImpersonated
       //

        rc = CreateRemoteSessionProcessW(
                clientSessionID,
                FALSE,     // not creating a process for System
                hToken,
                lpApplicationName,
                lpCommandLine,
                lpProcessAttributes,
                lpThreadAttributes,
                bInheritHandles,
                dwCreationFlags,
                lpEnvironment,
                lpCurrentDirectory,
                lpStartupInfo,
                lpProcessInformation) ;

        //
        // Undo the effect of RevertToSelf() if we had impersoanted
        //
        if ( bHaveImpersonated )
        {
            Status = NtSetInformationThread(
                        NtCurrentThread(),
                        ThreadImpersonationToken,
                        &hPrevToken,
                        sizeof( hPrevToken ) );

            ASSERT( NT_SUCCESS(Status ) );

            NtClose( hPrevToken );
        }

        if ( rc )
        {
            return TRUE;
        }
        else
        {
            return FALSE;
        }

    }
    else
    //
    // this is the standard non-Hydra related call block
    //
    {
        HANDLE hRestrictedToken = NULL;
        BOOL b = FALSE;

        if (!CreateProcessInternalW(hToken,
                                    lpApplicationName,
                                    lpCommandLine,
                                    lpProcessAttributes,
                                    lpThreadAttributes,
                                    bInheritHandles,
                                    dwCreationFlags | CREATE_SUSPENDED ,                               
                                    lpEnvironment,
                                    lpCurrentDirectory,
                                    lpStartupInfo,
                                    lpProcessInformation,
                                    &hRestrictedToken))
        {
            //
            // The internal routine might return a token even in the failure case
            // since it uses try-finally. Free the token if needed.
            //

            if (hRestrictedToken != NULL)
            {
                NtClose(hRestrictedToken); 
            } 
            return(FALSE);
        }

        CreateFlags |= (lpProcessAttributes ? 0 : COMMON_CREATE_PROCESSSD);
        CreateFlags |= (lpThreadAttributes ? 0 : COMMON_CREATE_THREADSD);
        
        if(lpProcessInformation->dwProcessId != 0) {
           
           HANDLE VdmWaitHandle = NULL;           

           //
           // Check if it is a shared wow being started
           //
           
           if((ULONG_PTR)lpProcessInformation->hProcess & 0x2) {        

               VdmWaitHandle = lpProcessInformation->hProcess;
               lpProcessInformation->hProcess = OpenProcess(PROCESS_ALL_ACCESS,
                                                            FALSE,
                                                            lpProcessInformation->dwProcessId);

               if (lpProcessInformation->hProcess == NULL)
               {
                   //
                   // Couldn't open it.  Try reverting since the new process gets security
                   // from the process token.
                   //

                   lpProcessInformation->hProcess = L32RevertOpenProcess(PROCESS_ALL_ACCESS,
                                                                         FALSE,
                                                                         lpProcessInformation->dwProcessId);

                   ASSERT(lpProcessInformation->hProcess);
               }
           }
                                                           

           
           //                                                                                   
           // If a restricted token was returned, set it on the process.                        
           // Else use the token provided by the caller.                                        
           //                                                                                   
                                                                                                
           if (hRestrictedToken == NULL)                                                        
           {   
               b = (L32CommonCreate(CreateFlags, hToken, lpProcessInformation, lpProcessAttributes, lpThreadAttributes));                
           }                                                                                    
           else                                                                                 
           {                                                                                    
               b = (L32CommonCreate(CreateFlags, hRestrictedToken, lpProcessInformation, lpProcessAttributes, lpThreadAttributes));      
           }                                                                                    

           //
           // if L32CommonCreate didn't succeed, it closes lpProcessInformation->hProcess and
           // zeros out lpProcessInformation, so we shouldn't be closing it again if it didn't 
           // succeed.           
                                                                                                
           if(b && VdmWaitHandle) {                                                                  
              if(lpProcessInformation->hProcess) {                                                                           
                 NtClose(lpProcessInformation->hProcess);                                       
              }                                                                                 
              lpProcessInformation->hProcess = VdmWaitHandle;                                   
           }                                                                                    

        }
        else {
           b = TRUE;
        }
        
        if (hRestrictedToken) {
           NtClose(hRestrictedToken);
        }

        return b;
    }
}



/***************************************************************************\
* OemToCharW
*
* OemToCharW(pSrc, pDst) - Translates the OEM string at pSrc into
* the Unicode string at pDst.  pSrc == pDst is not legal.
*
* History:
*   This function was copied from NT\windows\Core\ntuser\client\oemxlate.c
*
\***************************************************************************/
BOOL WINAPI ConvertOemToCharW(
    LPCSTR pSrc,
    LPWSTR pDst)
{
    int cch;
    if (pSrc == NULL || pDst == NULL) {
        return FALSE;
    } else if (pSrc == (LPCSTR)pDst) {
        /*
         * MultiByteToWideChar() requires pSrc != pDst: fail this call.
         * LATER: Is this really true?
         */
        return FALSE;
    }

    cch = strlen(pSrc) + 1;

    MultiByteToWideChar(
            CP_OEMCP,                          // Unicode -> OEM
            MB_PRECOMPOSED | MB_USEGLYPHCHARS, // visual map to precomposed
            (LPSTR)pSrc, cch,                  // source & length
            pDst,                              // destination
            cch);                              // max poss. precomposed length

    return TRUE;
}


//----------------------------------------------------------------------------
//
// Function:    OemToCharW_WithAllocation()
//
// Synopsis:    This func will allocated memory for the string ppDst which
//              must be then deallocatd thru a call to LocalFree().
//              If the passed in ansi string is NULL, then no memory
//              is allocated, and a NULL is returned
//
// Arguments:
//              LPCSTR  [in]    ansi string for which we want the wide version
//              *LPWSTR [out]   the wide version of ansi string
// Return:
//      BOOL : TRUE if no errors.
//      BOOL : FALSE if unable to allocated memory.
//
//----------------------------------------------------------------------------
BOOL WINAPI OemToCharW_WithAllocation(  LPCSTR pSrc,
    LPWSTR *ppDst)
{
    DWORD size;

    if (pSrc)
    {
        size = strlen( pSrc );

        *ppDst = ( WCHAR *) LocalAlloc(LMEM_FIXED, ( size + 1 ) * sizeof( WCHAR ) );

        if ( ppDst )
        {
            ConvertOemToCharW( pSrc, *ppDst );
            return TRUE;
        }
        else
            return FALSE;
    }
    else
    {
        *ppDst = NULL;
        return TRUE;
    }

}


//  ANSI wrapper for CreateRemoteSessionProcessW()
//
BOOL
CreateRemoteSessionProcessA(
    ULONG  SessionId,
    BOOL   System,
    HANDLE  hToken,
    LPCSTR lpApplicationName,
    LPSTR lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL bInheritHandles,
    DWORD dwCreationFlags,
    LPVOID lpEnvironment,
    LPCSTR lpCurrentDirectory,
    LPSTARTUPINFOA lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
)
{
    NTSTATUS                st;
    BOOL                    rc,rc2;
    STARTUPINFOW            WCHAR_StartupInfo;
    PWCHAR                  pWCHAR_AppName, pWCHAR_CommandLine, pWCHAR_CurDir, pWCHAR_Title, pWCHAR_Desktop;

    pWCHAR_AppName = pWCHAR_CommandLine =  pWCHAR_CurDir = pWCHAR_Title =  pWCHAR_Desktop = NULL;

    // in case there is a premature return from this function.
    rc2 = FALSE;

    if ( !( rc = OemToCharW_WithAllocation( lpApplicationName , &pWCHAR_AppName ) ))
    {
        goto Cleanup;
    }

    if ( !( rc = OemToCharW_WithAllocation( lpCommandLine , &pWCHAR_CommandLine ) ))
    {
        goto Cleanup;
    }

    if ( !( rc = OemToCharW_WithAllocation( lpCurrentDirectory , &pWCHAR_CurDir ) ))
    {
        goto Cleanup;
    }

    if ( !( rc = OemToCharW_WithAllocation( lpStartupInfo->lpTitle , &pWCHAR_Title ) ))
    {
        goto Cleanup;
    }

    if ( !( rc = OemToCharW_WithAllocation( lpStartupInfo->lpDesktop , &pWCHAR_Desktop ) ))
    {
        goto Cleanup;
    }

    WCHAR_StartupInfo.cb               = lpStartupInfo->cb ;
    WCHAR_StartupInfo.cbReserved2      = lpStartupInfo->cbReserved2;
    WCHAR_StartupInfo.dwFillAttribute  = lpStartupInfo->dwFillAttribute;
    WCHAR_StartupInfo.dwFlags          = lpStartupInfo->dwFlags;
    WCHAR_StartupInfo.dwX              = lpStartupInfo->dwX;
    WCHAR_StartupInfo.dwXCountChars    = lpStartupInfo->dwXCountChars;
    WCHAR_StartupInfo.dwXSize          = lpStartupInfo->dwXSize;
    WCHAR_StartupInfo.dwY              = lpStartupInfo->dwY;
    WCHAR_StartupInfo.dwYCountChars    = lpStartupInfo->dwYCountChars;
    WCHAR_StartupInfo.dwYSize          = lpStartupInfo->dwYSize;
    WCHAR_StartupInfo.hStdError        = lpStartupInfo->hStdError;
    WCHAR_StartupInfo.hStdInput        = lpStartupInfo->hStdInput;
    WCHAR_StartupInfo.hStdOutput       = lpStartupInfo->hStdOutput;
    WCHAR_StartupInfo.lpReserved2      = lpStartupInfo->lpReserved2;
    WCHAR_StartupInfo.wShowWindow      = lpStartupInfo->wShowWindow;
    WCHAR_StartupInfo.lpDesktop        = pWCHAR_Desktop;
    WCHAR_StartupInfo.lpReserved       = NULL;
    WCHAR_StartupInfo.lpTitle          = pWCHAR_Title;

    rc2 =     CreateRemoteSessionProcessW(
        SessionId,
        System,
        hToken,
        pWCHAR_AppName ,
        pWCHAR_CommandLine,
        lpProcessAttributes,
        lpThreadAttributes ,
        bInheritHandles,
        dwCreationFlags,
        lpEnvironment,
        pWCHAR_CurDir,
        &WCHAR_StartupInfo,
        lpProcessInformation
    );

Cleanup:

    if ( !rc )  // rc is set to FALSE if an attempted memory allocation has failed.
    {
        BaseSetLastNTError(STATUS_NO_MEMORY);
    }

    if (pWCHAR_AppName)
    {
        LocalFree( pWCHAR_AppName );
    }

    if (pWCHAR_CommandLine)
    {
        LocalFree( pWCHAR_CommandLine );
    }

    if (pWCHAR_CurDir)
    {
        LocalFree( pWCHAR_CurDir );
    }

    if (pWCHAR_Title)
    {
        LocalFree( pWCHAR_Title );
    }

    if (pWCHAR_Desktop)
    {
        LocalFree( pWCHAR_Desktop );
    }

    return rc2;
}


//+---------------------------------------------------------------------------
//
//  Function:   CreateProcessAsUserA
//
//  Synopsis:   ANSI wrapper for CreateProcessAsUserW
//
//  Arguments:  [hToken]               --
//              [lpApplicationName]    --
//              [lpCommandLine]        --
//              [lpProcessAttributes]  --
//              [lpThreadAttributes]   --
//              [bInheritHandles]      --
//              [dwCreationFlags]      --
//              [lpEnvironment]        --
//              [lpCurrentDirectory]   --
//              [lpStartupInfo]        --
//              [lpProcessInformation] --
//
//  Return Values
//          If the function succeeds, the return value is nonzero.
//          If the function fails, the return value is zero. To get extended error information, call GetLastError.
//
//  History:    4-25-95   RichardW   Created
//              1-14-98  AraBern     add changes for Hydra
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
WINAPI
CreateProcessAsUserA(
    HANDLE  hToken,
    LPCSTR lpApplicationName,
    LPSTR lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL bInheritHandles,
    DWORD dwCreationFlags,
    LPVOID lpEnvironment,
    LPCSTR lpCurrentDirectory,
    LPSTARTUPINFOA lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
    )
{
    DWORD   CreateFlags;
    DWORD   clientSessionID=0;
    DWORD   currentSessionID=0;
    DWORD   resultLength;
    HANDLE  hTmpToken;
    DWORD   curProcId ;
    NTSTATUS Status ;

    CreateFlags = (dwCreationFlags & CREATE_SUSPENDED ? COMMON_CREATE_SUSPENDED : 0);

    //
    // get the session if (zero means console).
    //
    currentSessionID = NtCurrentPeb()->SessionId;

    if ( !GetTokenInformation ( hToken, TokenSessionId , &clientSessionID,sizeof( DWORD), &resultLength ) )
    {
    //
    // get the access token for the client of this call
    // use get token instead of process since the client might have only
    // impersonated the thread, not the process
    //
        DBG_DumpOutLastError;
        ASSERT( FALSE );
        currentSessionID = 0;

        //
        // We should probably return FALSE here, but at this time we don't want to alter the
        // non-Hydra code-execution-flow at all.
        //
    }

    KdPrint(("logon32.c: CreateProcessAsUserA(): clientSessionID = %d, currentSessionID = %d \n",
            clientSessionID, currentSessionID ));

    if ( ( clientSessionID != currentSessionID ))
    {
       //
       // If the client session ID is not the same as the current session ID, then, we are attempting
       // to create a process on a remote session from the current session.
       // This block of code is used to accomplish such process creation, it is Terminal-Server specific
       //

       BOOL        bHaveImpersonated;
       HANDLE      hCurrentThread;
       HANDLE      hPrevToken = NULL;
       DWORD       rc;
       TOKEN_TYPE  tokenType;

       //
       // We must send the request to the remote WinStation
       // of the requestor
       //
       // NOTE: The current WinStationCreateProcessW() does not use
       //       the supplied security descriptor, but creates the
       //       process under the account of the logged on user.
       //

       //
       // Stop impersonating before doing the WinStationCreateProcess.
       // The remote winstation exec thread will launch the app under
       // the users context. We must not be impersonating because this
       // call only lets SYSTEM request the remote execute.
       //
       hCurrentThread = GetCurrentThread();

       //
       // Init bHaveImpersonated to the FALSE state
       //
       bHaveImpersonated = FALSE;


        //
        // Since the caller of this function (runas-> SecLogon service ) has already
        // impersonated the new (target) user, we do the OpenThreadToken with
        // OpenAsSelf = TRUE
        //
        if ( OpenThreadToken( hCurrentThread, TOKEN_QUERY | TOKEN_IMPERSONATE, TRUE, &hPrevToken ) )
        {

            bHaveImpersonated = TRUE;

            if ( !RevertToSelf() )
            {
                return FALSE;
            }
        }

       //
       // else, we are not impersonating, as reflected by the init value of bHaveImpersonated
       //

        rc = CreateRemoteSessionProcessA(
                clientSessionID,
                FALSE,     // not creating a process for System
                hToken,
                lpApplicationName,
                lpCommandLine,
                lpProcessAttributes,
                lpThreadAttributes,
                bInheritHandles,
                dwCreationFlags,
                lpEnvironment,
                lpCurrentDirectory,
                lpStartupInfo,
                lpProcessInformation) ;

        //
        // Undo the effect of RevertToSelf() if we had impersoanted
        //
        if ( bHaveImpersonated )
        {
            Status = NtSetInformationThread(
                NtCurrentThread(),
                ThreadImpersonationToken,
                &hPrevToken,
                sizeof( hPrevToken ) );

            ASSERT( NT_SUCCESS(Status ) );


            NtClose( hPrevToken );
        }

        if ( rc )
        {
            return TRUE;
        }
        else
        {
            return FALSE;
        }

    }
    else
    //
    // this is the standard non-Hydra related call block
    //
    {
        HANDLE hRestrictedToken = NULL;
        BOOL b = FALSE;

        if (!CreateProcessInternalA(hToken,
                                    lpApplicationName,
                                    lpCommandLine,
                                    lpProcessAttributes,
                                    lpThreadAttributes,
                                    bInheritHandles,
                                    dwCreationFlags | CREATE_SUSPENDED,
                                    lpEnvironment,
                                    lpCurrentDirectory,
                                    lpStartupInfo,
                                    lpProcessInformation,
                                    &hRestrictedToken))
        {
            //
            // The internal routine might return a token even in the failure case
            // since it uses try-finally. Free the token if needed.
            //

            if (hRestrictedToken != NULL)
            {
                NtClose(hRestrictedToken); 
            } 
            return(FALSE);
        }

        CreateFlags |= (lpProcessAttributes ? 0 : COMMON_CREATE_PROCESSSD);
        CreateFlags |= (lpThreadAttributes ? 0 : COMMON_CREATE_THREADSD);


        if(lpProcessInformation->dwProcessId != 0) {

           HANDLE VdmWaitHandle = NULL;           

           //
           // Check if it is a shared wow being started
           //
           
           if((ULONG_PTR)lpProcessInformation->hProcess & 0x2) {        
              
               VdmWaitHandle = lpProcessInformation->hProcess;
               lpProcessInformation->hProcess = OpenProcess(PROCESS_ALL_ACCESS,
                                                            FALSE,
                                                            lpProcessInformation->dwProcessId);

               if (lpProcessInformation->hProcess == NULL)
               {
                   //
                   // Couldn't open it.  Try reverting since the new process gets security
                   // from the process token.
                   //

                   lpProcessInformation->hProcess = L32RevertOpenProcess(PROCESS_ALL_ACCESS,
                                                                         FALSE,
                                                                         lpProcessInformation->dwProcessId);

                   ASSERT(lpProcessInformation->hProcess);
               }
           }
                                                           
           //                                                                                   
           // If a restricted token was returned, set it on the process.                        
           // Else use the token provided by the caller.                                        
           //                                                                                   
                                                                                                
           if (hRestrictedToken == NULL)                                                        
           {                                                                                    
               b = (L32CommonCreate(CreateFlags, hToken, lpProcessInformation, lpProcessAttributes, lpThreadAttributes));                
           }                                                                                    
           else                                                                                 
           {                                                                                    
               b = (L32CommonCreate(CreateFlags, hRestrictedToken, lpProcessInformation, lpProcessAttributes, lpThreadAttributes));      
           }                                                                                    

           //
           // if L32CommonCreate didn't succeed, it closes lpProcessInformation->hProcess and
           // zeros out lpProcessInformation, so we shouldn't be closing it again if it didn't 
           // succeed.           
                                                                                                
           if(b && VdmWaitHandle) {                                                                  
              if(lpProcessInformation->hProcess) {                                                                           
                 NtClose(lpProcessInformation->hProcess);                                       
              }                                                                                 
              lpProcessInformation->hProcess = VdmWaitHandle;                                   
           }                                                                                    

        }
        else {
           b = TRUE;
        }
        
        if (hRestrictedToken) {
           NtClose(hRestrictedToken);
        }

        return b;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\advapi32\pnpapi.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    pnpapi.c

Abstract:

    This module contains the user-mode plug-and-play API stubs.

Author:

    Paula Tomlinson (paulat) 9-18-1995

Environment:

    User-mode only.

Revision History:

    18-Sept-1995     paulat

        Creation and initial implementation.

--*/

#ifndef UNICODE
#define UNICODE
#endif

#ifndef _UNICODE
#define _UNICODE
#endif


//
// includes
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <wtypes.h>
#include <regstr.h>
#include <pnpmgr.h>
#include <strsafe.h>

#pragma warning(push, 4)

//
// private prototypes
//
PSTR
UnicodeToMultiByte(
    IN PCWSTR UnicodeString,
    IN UINT   Codepage
    );

PWSTR
MultiByteToUnicode(
    IN PCSTR String,
    IN UINT  Codepage
    );


//
// global data
//
WCHAR pszRegIDConfigDB[] =          REGSTR_PATH_IDCONFIGDB;
WCHAR pszRegKnownDockingStates[] =  REGSTR_KEY_KNOWNDOCKINGSTATES;
WCHAR pszRegCurrentConfig[] =       REGSTR_VAL_CURCONFIG;
WCHAR pszRegHwProfileGuid[] =       L"HwProfileGuid";
WCHAR pszRegFriendlyName[] =        REGSTR_VAL_FRIENDLYNAME;
WCHAR pszRegDockState[] =           REGSTR_VAL_DOCKSTATE;
WCHAR pszRegDockingState[] =        L"DockingState";
WCHAR pszCurrentDockInfo[] =        REGSTR_KEY_CURRENT_DOCK_INFO;



BOOL
GetCurrentHwProfileW (
    OUT LPHW_PROFILE_INFOW  lpHwProfileInfo
    )

/*++

Routine Description:


Arguments:

    lpHwProfileInfo  Points to a HW_PROFILE_INFO structure that will receive
                     the information for the current hardware profile.

Return Value:

    If the function succeeds, the return value is TRUE.  If the function
    fails, the return value is FALSE.  To get extended error information,
    call GetLastError.

--*/

{
   BOOL     Status = TRUE;
   WCHAR    RegStr[MAX_PATH];
   HKEY     hKey = NULL, hCfgKey = NULL;
   HKEY     hCurrentDockInfoKey = NULL;
   ULONG    ulCurrentConfig = 1, ulSize = 0;


   try {
      //
      // validate parameter
      //
      if (!ARGUMENT_PRESENT(lpHwProfileInfo)) {
         SetLastError(ERROR_INVALID_PARAMETER);
         Status = FALSE;
         goto Clean0;
      }

      //
      // open the IDConfigDB key
      //
      if (RegOpenKeyEx(
               HKEY_LOCAL_MACHINE, pszRegIDConfigDB, 0,
               KEY_QUERY_VALUE, &hKey) != ERROR_SUCCESS) {
	
         SetLastError(ERROR_REGISTRY_CORRUPT);
         Status = FALSE;
         goto Clean0;
      }
      
      //
      // retrieve the current config id
      //
      ulSize = sizeof(ULONG);
      if (RegQueryValueEx(hKey, pszRegCurrentConfig, NULL, NULL,
                          (LPBYTE)&ulCurrentConfig, &ulSize) != ERROR_SUCCESS) {          
          SetLastError(ERROR_REGISTRY_CORRUPT);
          Status = FALSE;
          goto Clean0;
      }

      //
      // open the profile key for the current configuration
      //
      if (FAILED(StringCchPrintfW(
                     RegStr,
                     MAX_PATH,
                     L"%s\\%04u",
                     pszRegKnownDockingStates,
                     ulCurrentConfig))) {
          SetLastError(ERROR_REGISTRY_CORRUPT);
          Status = FALSE;
          goto Clean0;
      }

      if (RegOpenKeyEx(hKey, RegStr, 0, KEY_QUERY_VALUE,
                       &hCfgKey) != ERROR_SUCCESS) {
          SetLastError(ERROR_REGISTRY_CORRUPT);
          Status = FALSE;
          goto Clean0;
      }
      
      //
      // retrieve the dock state for the current profile
      //      
      if (RegOpenKeyEx(hKey, pszCurrentDockInfo, 0,  KEY_QUERY_VALUE,
                       &hCurrentDockInfoKey) != ERROR_SUCCESS) {
          //
          // No CurrentDockInfo Key, something's wrong.
          //
          SetLastError(ERROR_REGISTRY_CORRUPT);
          Status = FALSE;
          goto Clean0;
      }      
      
      //
      // Look in CurrentDockInfo for
      // a hardware determined DockingState value.
      //
      ulSize = sizeof(ULONG);                  
      if ((RegQueryValueEx(hCurrentDockInfoKey,
                           pszRegDockingState, 
                           NULL, 
                           NULL,
                           (LPBYTE)&lpHwProfileInfo->dwDockInfo,
                           &ulSize) != ERROR_SUCCESS)
          || (!lpHwProfileInfo->dwDockInfo) 
          || ((lpHwProfileInfo->dwDockInfo & DOCKINFO_UNDOCKED) && 
              (lpHwProfileInfo->dwDockInfo & DOCKINFO_DOCKED))) {          

          //
          // If there's no such value, or the value was set to 0 (unspported),
          // or if the value is "unknown", resort to user supplied docking info.
          // Look under the IDConfigDB profile for a user set DockState value.
          //                    
          if ((RegQueryValueEx(hCfgKey, pszRegDockState, NULL, NULL,
                               (LPBYTE)&lpHwProfileInfo->dwDockInfo,
                               &ulSize) != ERROR_SUCCESS)
              || (!lpHwProfileInfo->dwDockInfo)) {
              
              //
              // If there's no such value, or the value was set to 0,
              // there is no user specified docking state to resort to;
              // return the "user-supplied unknown" docking state.
              //
              lpHwProfileInfo->dwDockInfo =
                  DOCKINFO_USER_SUPPLIED | DOCKINFO_DOCKED | DOCKINFO_UNDOCKED;
          }
      }
      
      //
      // retrieve the profile guid.  if we can't get one, set it to NULL
      //
      ulSize = HW_PROFILE_GUIDLEN * sizeof(WCHAR);
      if (RegQueryValueEx(hCfgKey, pszRegHwProfileGuid, NULL, NULL,
                          (LPBYTE)&lpHwProfileInfo->szHwProfileGuid,
                          &ulSize) != ERROR_SUCCESS) {
          lpHwProfileInfo->szHwProfileGuid[0] = L'\0';
      }
      
      //
      // retrieve the friendly name.  if we can't get one, set it to NULL
      //
      ulSize = MAX_PROFILE_LEN * sizeof(WCHAR);
      if (RegQueryValueEx(hCfgKey, pszRegFriendlyName, NULL, NULL,
                          (LPBYTE)&lpHwProfileInfo->szHwProfileName,
                          &ulSize) != ERROR_SUCCESS) {
          lpHwProfileInfo->szHwProfileName[0] = L'\0';
      }
      
      
   Clean0:
      NOTHING;
      
   } except(EXCEPTION_EXECUTE_HANDLER) {
       SetLastError(ERROR_INVALID_PARAMETER);
       Status = FALSE;
   }
   
   if (hKey != NULL) {
       RegCloseKey(hKey);
   }

   if (hCfgKey != NULL) {
       RegCloseKey(hCfgKey);
   }

   if (hCurrentDockInfoKey != NULL) {
       RegCloseKey(hCurrentDockInfoKey);
   }

   return Status;
   
} // GetCurrentHwProfileW



BOOL
GetCurrentHwProfileA (
    OUT LPHW_PROFILE_INFOA  lpHwProfileInfo
    )

/*++

Routine Description:


Arguments:

    lpHwProfileInfo  Points to a HW_PROFILE_INFO structure that will receive
                     the information for the current hardware profile.

Return Value:

    If the function succeeds, the return value is TRUE.  If the function
    fails, the return value is FALSE.  To get extended error information,
    call GetLastError.

--*/

{
   BOOL              Status = TRUE;
   HW_PROFILE_INFOW  HwProfileInfoW;
   LPSTR             pAnsiString;
   HRESULT           hr;


   try {
      //
      // validate parameter
      //
      if (!ARGUMENT_PRESENT(lpHwProfileInfo)) {
         SetLastError(ERROR_INVALID_PARAMETER);
         Status = FALSE;
         goto Clean0;
      }

      //
      // call the Unicode version
      //
      if (!GetCurrentHwProfileW(&HwProfileInfoW)) {
         Status = FALSE;
         goto Clean0;
      }

      //
      // on successful return, convert unicode form of struct
      // to ANSI and copy struct members to callers struct
      //
      lpHwProfileInfo->dwDockInfo = HwProfileInfoW.dwDockInfo;

      pAnsiString = UnicodeToMultiByte(
               HwProfileInfoW.szHwProfileGuid, CP_ACP);
      if (!pAnsiString) {
          Status = FALSE;
          goto Clean0;
      }

      hr = StringCchCopyA(lpHwProfileInfo->szHwProfileGuid,
                          HW_PROFILE_GUIDLEN,
                          pAnsiString);

      LocalFree(pAnsiString);

      if (FAILED(hr)) {
          SetLastError(ERROR_INTERNAL_ERROR);
          Status = FALSE;
          goto Clean0;
      }

      pAnsiString = UnicodeToMultiByte(
               HwProfileInfoW.szHwProfileName, CP_ACP);
      if (!pAnsiString) {
          Status = FALSE;
          goto Clean0;
      }

      hr = StringCchCopyA(lpHwProfileInfo->szHwProfileName,
                          MAX_PROFILE_LEN,
                          pAnsiString);

      LocalFree(pAnsiString);

      if (FAILED(hr)) {
          SetLastError(ERROR_INTERNAL_ERROR);
          Status = FALSE;
          goto Clean0;
      }

   Clean0:
      NOTHING;

   } except(EXCEPTION_EXECUTE_HANDLER) {
      SetLastError(ERROR_INVALID_PARAMETER);
      Status = FALSE;
   }

   return Status;

} // GetCurrentHwProfileA



PSTR
UnicodeToMultiByte(
    IN PCWSTR UnicodeString,
    IN UINT   Codepage
    )

/*++

Routine Description:

    Convert a string from unicode to ansi.

Arguments:

    UnicodeString - supplies string to be converted.

    Codepage - supplies codepage to be used for the conversion.

Return Value:

    NULL if out of memory or invalid codepage.
    Caller can free buffer with MyFree().

--*/

{
    UINT WideCharCount;
    PSTR String;
    UINT StringBufferSize;
    UINT BytesInString;
    PSTR p;

    WideCharCount = lstrlenW(UnicodeString) + 1;

    //
    // Allocate maximally sized buffer.
    // If every unicode character is a double-byte
    // character, then the buffer needs to be the same size
    // as the unicode string. Otherwise it might be smaller,
    // as some unicode characters will translate to
    // single-byte characters.
    //
    StringBufferSize = WideCharCount * sizeof(WCHAR);
    String = (PSTR)LocalAlloc(LPTR, StringBufferSize);
    if(String == NULL) {
        return(NULL);
    }

    //
    // Perform the conversion.
    //
    BytesInString = WideCharToMultiByte(
                        Codepage,
                        0,                      // default composite char behavior
                        UnicodeString,
                        WideCharCount,
                        String,
                        StringBufferSize,
                        NULL,
                        NULL
                        );

    if(BytesInString == 0) {
        LocalFree(String);
        SetLastError(ERROR_INTERNAL_ERROR);
        return(NULL);
    }

    //
    // Resize the string's buffer to its correct size.
    // If the realloc fails for some reason the original
    // buffer is not freed.
    //
    p = LocalReAlloc(String,BytesInString, LMEM_ZEROINIT | LMEM_MOVEABLE);

    if (p == NULL) {
        LocalFree(String);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(NULL);
    }

    String = p;

    return(String);

} // UnicodeToMultiByte



PWSTR
MultiByteToUnicode(
    IN PCSTR String,
    IN UINT  Codepage
    )

/*++

Routine Description:

    Convert a string to unicode.

Arguments:

    String - supplies string to be converted.

    Codepage - supplies codepage to be used for the conversion.

Return Value:

    NULL if string could not be converted (out of memory or invalid cp)
    Caller can free buffer with MyFree().

--*/

{
    UINT BytesIn8BitString;
    UINT CharsInUnicodeString;
    PWSTR UnicodeString;
    PWSTR p;

    BytesIn8BitString = lstrlenA(String) + 1;

    //
    // Allocate maximally sized buffer.
    // If every character is a single-byte character,
    // then the buffer needs to be twice the size
    // as the 8bit string. Otherwise it might be smaller,
    // as some characters are 2 bytes in their unicode and
    // 8bit representations.
    //
    UnicodeString = (PWSTR)LocalAlloc(LPTR, BytesIn8BitString * sizeof(WCHAR));
    if(UnicodeString == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(NULL);
    }

    //
    // Perform the conversion.
    //
    CharsInUnicodeString = MultiByteToWideChar(
                                Codepage,
                                MB_PRECOMPOSED,
                                String,
                                BytesIn8BitString,
                                UnicodeString,
                                BytesIn8BitString
                                );

    if(CharsInUnicodeString == 0) {
        LocalFree(UnicodeString);
        SetLastError(ERROR_INTERNAL_ERROR);
        return(NULL);
    }

    //
    // Resize the unicode string's buffer to its correct size.
    // If the realloc fails for some reason the original
    // buffer is not freed.
    //
    p = (PWSTR)LocalReAlloc(UnicodeString,CharsInUnicodeString*sizeof(WCHAR),
                            LMEM_ZEROINIT | LMEM_MOVEABLE);

    if (p == NULL) {
        LocalFree(UnicodeString);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(NULL);
    }

    UnicodeString = p;

    return(UnicodeString);

} // MultiByteToUnicode
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\advapi32\win31io.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    win31io.h

Abstract:

    This header file contains the Win 3.1 Group/REG.DAT data
    structure definitions, as well as the 32 bit group definitions.
    Why these aren't in the shell32.dll somewhere I don't know

Author:

    Steve Wood (stevewo) 22-Feb-1993

Revision History:

--*/

#ifndef _WIN31IO_
#define _WIN31IO_

#include "win31evt.h"

typedef struct GROUP_DEF {
    union {
        DWORD   dwMagic;    /* magical bytes 'PMCC' */
        DWORD   dwCurrentSize;  /* During conversion only */
    };
    WORD    wCheckSum;      /* adjust this for zero sum of file */
    WORD    cbGroup;        /* length of group segment (does NOT include tags) */
    RECT    rcNormal;       /* rectangle of normal window */
    POINT   ptMin;          /* point of icon */
    WORD    nCmdShow;       /* min, max, or normal state */
    WORD    pName;          /* name of group */
                            /* these four change interpretation */
    WORD    cxIcon;         /* width of icons */
    WORD    cyIcon;         /* hieght of icons */
    WORD    wIconFormat;    /* planes and BPP in icons */
    WORD    wReserved;      /* This word is no longer used. */
                            /* Used internally to hold total size of group, including tags */
    WORD    cItems;         /* number of items in group */
    WORD    rgiItems[1];    /* array of ITEMDEF offsets */
} GROUP_DEF, *PGROUP_DEF;

#define NSLOTS 16           /* initial number of items entries */

typedef struct ITEM_DEF {
    POINT   pt;             /* location of item icon in group */
    WORD    idIcon;         /* id of item icon */
    WORD    wIconVer;       /* icon version */
    WORD    cbIconRes;      /* size of icon resource */
    WORD    indexIcon;      /* index of item icon */
    WORD    dummy2;         /* - not used anymore */
    WORD    pIconRes;       /* offset of icon resource */
    WORD    dummy3;         /* - not used anymore */
    WORD    pName;          /* offset of name string */
    WORD    pCommand;       /* offset of command string */
    WORD    pIconPath;      /* offset of icon path */
} ITEM_DEF, *PITEM_DEF;


/* the pointers in the above structures are short pointers relative to the
 * beginning of the segments.  This macro converts the short pointer into
 * a long pointer including the proper segment/selector value.        It assumes
 * that its argument is an lvalue somewhere in a group segment, for example,
 * PTR(lpgd->pName) returns a pointer to the group name, but k=lpgd->pName;
 * PTR(k) is obviously wrong as it will use either SS or DS for its segment,
 * depending on the storage class of k.
 */
#define PTR( base, offset ) (LPSTR)((PBYTE)base + offset)

/* this macro is used to retrieve the i-th item in the group segment.  Note
 * that this pointer will NOT be NULL for an unused slot.
 */
#define ITEM( lpgd, i ) ((PITEM_DEF)PTR( lpgd, lpgd->rgiItems[i] ))

#define VER31           0x030A
#define VER30           0x0300
#define VER20           0x0201

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  Tag Stuff                                                               */
/*                                                                          */
/*--------------------------------------------------------------------------*/

typedef struct _TAG_DEF {
    WORD wID;                   // tag identifier
    WORD dummy1;                // need this for alignment!
    int wItem;                  // (unde the covers 32 bit point!)item the tag belongs to
    WORD cb;                    // size of record, including id and count
    WORD dummy2;                // need this for alignment!
    BYTE rgb[1];
} TAG_DEF, *PTAG_DEF;

#define GROUP_MAGIC 0x43434D50L  /* 'PMCC' */
#define PMTAG_MAGIC GROUP_MAGIC

    /* range 8000 - 80FF > global
     * range 8100 - 81FF > per item
     * all others reserved
     */

#define ID_MAINTAIN             0x8000
    /* bit used to indicate a tag that should be kept even if the writer
     * doesn't recognize it.
     */

#define ID_MAGIC                0x8000
    /* data: the string 'TAGS'
     */

#define ID_WRITERVERSION        0x8001
    /* data: string in the form [9]9.99[Z].99
     */

#define ID_APPLICATIONDIR       0x8101
    /* data: ASCIZ string of directory where application may be
     * located.
     * this is defined as application dir rather than default dir
     * since the default dir is explicit in the 3.0 command line and
     * must stay there.  The true "new information" is the application
     * directory.  If not present, search the path.
     */

#define ID_HOTKEY               0x8102
    /* data: WORD hotkey index
     */

#define ID_MINIMIZE             0x8103
    /* data none
     */

#define ID_LASTTAG              0xFFFF
    /* the last tag in the file
     */

    /*
     * Maximium number of items allowed in a group
     */
#define CITEMSMAX   50


    /*
     * Maximium number of groups allowed in PROGMAN
     */

#define CGROUPSMAX  40

/*--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------*/

//
// This is the structure of the .grp files in Windows3.1
//

/* .GRP File format structures -
 */
typedef struct _GROUP_DEF16 {
    DWORD         dwMagic;      /* magical bytes 'PMCC' */
    WORD          wCheckSum;    /* adjust this for zero sum of file */
    WORD          cbGroup;      /* length of group segment (does NOT include tags) */
    WORD          nCmdShow;     /* min, max, or normal state */
    SMALL_RECT    rcNormal;     /* rectangle of normal window */
    POINTS        ptMin;        /* point of icon */
    WORD          pName;        /* name of group */
                                /* these four change interpretation */
    WORD          cxIcon;       /* width of icons */
    WORD          cyIcon;       /* hieght of icons */
    WORD          wIconFormat;  /* planes and BPP in icons */
    WORD          wReserved;    /* This word is no longer used. */
                                /* Used internally to hold total size of group, including tags */

    WORD          cItems;       /* number of items in group */
    WORD          rgiItems[1];  /* array of ITEMDEF offsets */
} GROUP_DEF16, *PGROUP_DEF16;

/* this macro is used to retrieve the i-th item in the group segment.  Note
 * that this pointer will NOT be NULL for an unused slot.
 */
#define ITEM16( lpgd16, i ) ((PITEM_DEF16)PTR( lpgd16, lpgd16->rgiItems[i] ))

//
// These structures are not needed for the conversion but it is useful to
// understand what is going on.
//
typedef struct _ITEM_DEF16 {
    POINTS    pt;               /* location of item icon in group */
    WORD          iIcon;        /* index of item icon */
    WORD          cbHeader;     /* size of icon header */
    WORD          cbANDPlane;   /* size of and part of icon */
    WORD          cbXORPlane;   /* size of xor part of icon */
    WORD          pHeader;      /* file offset of icon header */
    WORD          pANDPlane;    /* file offset of AND plane */
    WORD          pXORPlane;    /* file offset of XOR plane */
    WORD          pName;        /* file offset of name string */
    WORD          pCommand;     /* file offset of command string */
    WORD          pIconPath;    /* file offset of icon path */
} ITEM_DEF16, *PITEM_DEF16;


typedef struct _CURSORSHAPE_16 {
    WORD xHotSpot;
    WORD yHotSpot;
    WORD cx;
    WORD cy;
    WORD cbWidth;  /* Bytes per row, accounting for word alignment. */
    BYTE Planes;
    BYTE BitsPixel;
} CURSORSHAPE_16, *PCURSORSHAPE_16;



typedef struct _TAG_DEF16 {
    WORD wID;			// tag identifier
    WORD wItem; 		// item the tag belongs to
    WORD cb;			// size of record, including id and count
    BYTE rgb[1];
} TAG_DEF16, *PTAG_DEF16;

typedef struct _ICON_HEADER16 {
    WORD xHotSpot;
    WORD yHotSpot;
    WORD cx;
    WORD cy;
    WORD cbWidth;  /* Bytes per row, accounting for word alignment. */
    BYTE Planes;
    BYTE BitsPixel;
} ICON_HEADER16, *PICON_HEADER16;


#pragma pack(2)

typedef struct _REG_KEY16 {     // key nodes
    WORD iNext;                 // next sibling key
    WORD iChild;                // first child key
    WORD iKey;                  // string defining key
    WORD iValue;                // string defining value of key-tuple
} REG_KEY16, *PREG_KEY16;

typedef struct _REG_STRING16 {
    WORD iNext;                 // next string in chain
    WORD cRef;                  // reference count
    WORD cb;                    // length of string
    WORD irgb;                  // offset in string segment
} REG_STRING16, *PREG_STRING16;

typedef union _REG_NODE16 {     // a node may be...
    REG_KEY16 key;              //      a key
    REG_STRING16 str;           //      a string
} REG_NODE16, *PREG_NODE16;

typedef struct _REG_HEADER16 {
    DWORD dwMagic;              // magic number
    DWORD dwVersion;            // version number
    DWORD dwHdrSize;            // size of header
    DWORD dwNodeTable;          // offset of node table
    DWORD dwNTSize;             // size of node table
    DWORD dwStringValue;        // offset of string values
    DWORD dwSVSize;             // size of string values
    WORD nHash;                 // number of initial string table entries
    WORD iFirstFree;            // first free node
} REG_HEADER16, *PREG_HEADER16;

#define MAGIC_NUMBER 0x43434853L        // 'SHCC'
#define VERSION_NUMBER 0x30312E33L      // '3.10'

#pragma pack()

//
// Routines defined in group32.c
//

ULONG
QueryNumberOfPersonalGroupNames(
    HANDLE CurrentUser,
    PHANDLE GroupNamesKey,
    PHANDLE SettingsKey
    );

BOOL
NewPersonalGroupName(
    HANDLE GroupNamesKey,
    PWSTR GroupName,
    ULONG GroupNumber
    );

BOOL
DoesExistGroup(
    HANDLE GroupsKey,
    PWSTR GroupName
    );

PGROUP_DEF
LoadGroup(
    HANDLE GroupsKey,
    PWSTR GroupFileName
    );

BOOL
UnloadGroup(
    PGROUP_DEF Group
    );


BOOL
ExtendGroup(
    PGROUP_DEF Group,
    BOOL AppendToGroup,
    DWORD cb
    );

WORD
AddDataToGroup(
    PGROUP_DEF Group,
    PBYTE Data,
    DWORD cb
    );

BOOL
AddTagToGroup(
    PGROUP_DEF Group,
    WORD wID,
    WORD wItem,
    WORD cb,
    PBYTE rgb
    );

PGROUP_DEF
CreateGroupFromGroup16(
    LPSTR GroupName,
    PGROUP_DEF16 Group16
    );

BOOL
SaveGroup(
    HANDLE GroupsKey,
    PWSTR GroupName,
    PGROUP_DEF Group
    );

BOOL
DeleteGroup(
    HANDLE GroupsKey,
    PWSTR GroupName
    );

#if DBG
BOOL
DumpGroup(
    PWSTR GroupFileName,
    PGROUP_DEF Group
    );
#endif


//
// Routines defined in group16.c
//

PGROUP_DEF16
LoadGroup16(
    PWSTR GroupFileName
    );

BOOL
UnloadGroup16(
    PGROUP_DEF16 Group
    );

#if DBG
BOOL
DumpGroup16(
    PWSTR GroupFileName,
    PGROUP_DEF16 Group
    );
#endif



//
// Routines defined in regdat16.c
//

PREG_HEADER16
LoadRegistry16(
    PWSTR RegistryFileName
    );

BOOL
UnloadRegistry16(
    PREG_HEADER16 Registry
    );

BOOL
CreateRegistryClassesFromRegistry16(
    HANDLE SoftwareRoot,
    PREG_HEADER16 Registry
    );

#if DBG
BOOL
DumpRegistry16(
    PREG_HEADER16 Registry
    );
#endif


#endif // _WIN31IO_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\advapi32\mschapp.c ===
/*++

Copyright (C) Microsoft Corporation, 1999

Module Name:

    mschapp - MS-CHAP Password Change API

Abstract:

    These APIs correspond to the MS-CHAP RFC -2433 sections 9 and 10. In order
    to develop an MS-CHAP RAS server that works with an NT domain, these APIs
    are required.

    The MS-CHAP change password APIs are exposed through a DLL that is obtained
    from PSS. This DLL is not distributed with NT4.0 or Win2000. It is up to
    the ISV to install this with their product. The DLL name is MSCHAPP.DLL.

    Only wide (Unicode) versions of these apis will be available. These are the
    2 callable APIs:

    *   MSChapSrvChangePassword
    *   MsChapSrvChangePassword2

--*/

#define UNICODE
#define _UNICODE
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ntsam.h>
#include <ntsamp.h>
#include <ntlsa.h>
#include <mschapp.h>


//////////////////////////////////////////////////////////////
//                                                          //  
//                                                          //
//         Exported MSChap change password Functions        //
//                                                          //
//                                                          //
//////////////////////////////////////////////////////////////

//critical section for MSChap change password functions                 
CRITICAL_SECTION MSChapChangePassword;

//function pointers for MSChap Functions
HINSTANCE         hSamlib = NULL;

typedef NTSTATUS(* FNSAMCONNECT)(PUNICODE_STRING,
                                   PSAM_HANDLE,
                                   ACCESS_MASK,
                                   POBJECT_ATTRIBUTES);
typedef NTSTATUS(* FNSAMOPENDOMAIN)(SAM_HANDLE,
                                      ACCESS_MASK,
                                      PSID,
                                      PSAM_HANDLE);
typedef NTSTATUS(* FNSAMLOOKUPNAMESINDOMAIN)(SAM_HANDLE,ULONG,PUNICODE_STRING,
                                             PULONG*,PSID_NAME_USE *);
typedef NTSTATUS(* FNSAMOPENUSER)(SAM_HANDLE,ACCESS_MASK,ULONG,PSAM_HANDLE);
typedef NTSTATUS(* FNSAMICHANGEPASSWORDUSER)(SAM_HANDLE,BOOLEAN,PLM_OWF_PASSWORD,PLM_OWF_PASSWORD,
                                             BOOLEAN,PNT_OWF_PASSWORD,PNT_OWF_PASSWORD);
typedef NTSTATUS(* FNSAMICHANGEPASSWORDUSER2)(PUNICODE_STRING,
                                                PUNICODE_STRING,
                                                PSAMPR_ENCRYPTED_USER_PASSWORD,
                                                PENCRYPTED_NT_OWF_PASSWORD,
                                                BOOLEAN,PSAMPR_ENCRYPTED_USER_PASSWORD,
                                                PENCRYPTED_LM_OWF_PASSWORD);
typedef NTSTATUS(* FNSAMCLOSEHANDLE)(SAM_HANDLE);
typedef NTSTATUS(* FNSAMFREEMEMORY)(PVOID);

FNSAMCONNECT              FnSamConnect              = NULL;
FNSAMOPENDOMAIN           FnSamOpenDomain           = NULL;
FNSAMLOOKUPNAMESINDOMAIN  FnSamLookupNamesInDomain  = NULL;
FNSAMOPENUSER             FnSamOpenUser             = NULL;
FNSAMICHANGEPASSWORDUSER  FnSamiChangePasswordUser  = NULL;
FNSAMICHANGEPASSWORDUSER2 FnSamiChangePasswordUser2 = NULL;
FNSAMCLOSEHANDLE          FnSamCloseHandle          = NULL;
FNSAMFREEMEMORY           FnSamFreeMemory           = NULL; 


/*++

MSChapSrvChangePassword:

    Changes the password of a user account.  Password will be set to
    NewPassword only if OldPassword matches the current user password for this
    user and there are no restrictions on using the new password.  This call
    allows users to change their own password if they have access
    USER_CHANGE_PASSWORD.  Password update restrictions apply.

Arguments:

    ServerName - The server to operate on, or NULL for this machine.

    UserName - Name of user whose password is to be changed

    LMOldPresent - TRUE if the LmOldOwfPassword is valid.  This should only be
        FALSE if the old password is too long to be represented by a LM
        password (Complex NT password).  Note the LMNewOwfPassword must always
        be valid.  If the new password is complex, the LMNewOwfPassword should
        be the well-known LM OWF of a NULL password.

    LmOldOwfPassword - One-way-function of the current LM password for the
        user.  Ignored if LmOldPresent == FALSE

    LmNewOwfPassword - One-way-function of the new LM password for the user.

    NtOldOwfPassword - One-way-function of the current NT password for the
        user.

    NtNewOwfPassword - One-way-function of the new NT password for the user.

Return Value:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate access to
        complete the operation.

    STATUS_INVALID_HANDLE - The supplied server or username was not valid.

    STATUS_ILL_FORMED_PASSWORD - The new password is poorly formed, e.g.
        contains characters that can't be entered from the keyboard, etc.

    STATUS_PASSWORD_RESTRICTION - A restriction prevents the password from
        being changed.  This may be for a number of reasons, including time
        restrictions on how often a password may be changed or length
        restrictions on the provided password.  This error might also be
        returned if the new password matched a password in the recent history
        log for the account.  Security administrators indicate how many of the
        most recently used passwords may not be re-used.  These are kept in
        the password recent history log.

    STATUS_WRONG_PASSWORD - OldPassword does not contain the user's current
        password.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the correct
        state (disabled or enabled) to perform the requested operation.  The
        domain server must be enabled for this operation

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the incorrect
        role (primary or backup) to perform the requested operation.

    STATUS_INVALID_PARAMETER_MIX - LmOldPresent or NtPresent or both must be
        TRUE.

--*/     
WINADVAPI DWORD WINAPI
MSChapSrvChangePassword(
   IN LPWSTR ServerName,
   IN LPWSTR UserName,
   IN BOOLEAN LmOldPresent,
   IN PLM_OWF_PASSWORD LmOldOwfPassword,
   IN PLM_OWF_PASSWORD LmNewOwfPassword,
   IN PNT_OWF_PASSWORD NtOldOwfPassword,
   IN PNT_OWF_PASSWORD NtNewOwfPassword)
{
    NTSTATUS Status=STATUS_SUCCESS;
    DWORD    WinErr=ERROR_SUCCESS;
    OBJECT_ATTRIBUTES oa;
    UNICODE_STRING UnicodeName;
    SAM_HANDLE SamHandle = NULL;
    SAM_HANDLE DomainHandle = NULL;
    SAM_HANDLE UserHandle = NULL;
    LSA_HANDLE LsaHandle = NULL;
    PPOLICY_ACCOUNT_DOMAIN_INFO DomainInfo = NULL;
    PULONG RelativeIds = NULL;
    PSID_NAME_USE Use = NULL;

    if (NULL == UserName || NULL == LmOldOwfPassword || NULL == LmNewOwfPassword ||
        NULL == NtOldOwfPassword || NULL == NtNewOwfPassword) {
        WinErr = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }


    //
    // Initialization.
    //

    if ( hSamlib == NULL )
    {
        RtlEnterCriticalSection( &MSChapChangePassword );
    
        if ( hSamlib == NULL )
        {
            hSamlib = LoadLibrary(L"samlib.dll");
            WinErr  = GetLastError();
            if (ERROR_SUCCESS != WinErr) {
                goto Cleanup;
            }
            if (hSamlib != NULL) {
    
                FnSamConnect             = (FNSAMCONNECT)             GetProcAddress(hSamlib,
                                                                         "SamConnect");
                WinErr  = GetLastError();
                if (ERROR_SUCCESS != WinErr) {
                    goto Cleanup;
                }
                FnSamOpenDomain          = (FNSAMOPENDOMAIN)          GetProcAddress(hSamlib,
                                                                         "SamOpenDomain");
                WinErr  = GetLastError();
                if (ERROR_SUCCESS != WinErr) {
                    goto Cleanup;
                }
                FnSamLookupNamesInDomain = (FNSAMLOOKUPNAMESINDOMAIN) GetProcAddress(hSamlib,
                                                                         "SamLookupNamesInDomain");
                WinErr  = GetLastError();
                if (ERROR_SUCCESS != WinErr) {
                    goto Cleanup;
                }
                FnSamOpenUser            = (FNSAMOPENUSER)            GetProcAddress(hSamlib,
                                                                         "SamOpenUser");
                WinErr  = GetLastError();
                if (ERROR_SUCCESS != WinErr) {
                    goto Cleanup;
                }
                FnSamCloseHandle         = (FNSAMCLOSEHANDLE)         GetProcAddress(hSamlib,
                                                                         "SamCloseHandle");
                WinErr  = GetLastError();
                if (ERROR_SUCCESS != WinErr) {
                    goto Cleanup;
                }
                FnSamFreeMemory          = (FNSAMFREEMEMORY)          GetProcAddress(hSamlib,
                                                                         "SamFreeMemory");
                WinErr  = GetLastError();
                if (ERROR_SUCCESS != WinErr) {
                    goto Cleanup;
                }
                FnSamiChangePasswordUser = (FNSAMICHANGEPASSWORDUSER) GetProcAddress(hSamlib,
                                                                         "SamiChangePasswordUser");
                WinErr  = GetLastError();
                if (ERROR_SUCCESS != WinErr) {
                    goto Cleanup;
                }
                FnSamiChangePasswordUser2 = (FNSAMICHANGEPASSWORDUSER2) GetProcAddress(hSamlib,
                                                                         "SamiChangePasswordUser2");
                WinErr  = GetLastError();
                if (ERROR_SUCCESS != WinErr) {
                    goto Cleanup;
                }
            }
        }
    
        RtlLeaveCriticalSection( &MSChapChangePassword );
    
    }

    RtlInitUnicodeString(&UnicodeName, ServerName);
    InitializeObjectAttributes(&oa, NULL, 0, NULL, NULL);


    //
    // Connect to the LSA on the server
    //

    Status = LsaOpenPolicy(
                &UnicodeName,
                &oa,
                POLICY_VIEW_LOCAL_INFORMATION,
                &LsaHandle);
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Status = LsaQueryInformationPolicy(
                LsaHandle,
                PolicyAccountDomainInformation,
                (PVOID *)&DomainInfo);
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Status = FnSamConnect(
                &UnicodeName,
                &SamHandle,
                SAM_SERVER_LOOKUP_DOMAIN,
                &oa);
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Status = FnSamOpenDomain(
                SamHandle,
                DOMAIN_LOOKUP | DOMAIN_READ_PASSWORD_PARAMETERS | DOMAIN_READ_PASSWORD_PARAMETERS,
                DomainInfo->DomainSid,
                &DomainHandle);
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    RtlInitUnicodeString(
        &UnicodeName,
        UserName);

    Status = FnSamLookupNamesInDomain(
                DomainHandle,
                1,
                &UnicodeName,
                &RelativeIds,
                &Use);
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    if (Use[0] != SidTypeUser)
    {
        WinErr = ERROR_INVALID_SID;
        goto Cleanup;
    }

    Status = FnSamOpenUser(
                DomainHandle,
                USER_CHANGE_PASSWORD,
                RelativeIds[0],
                &UserHandle);
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Status = FnSamiChangePasswordUser(
                UserHandle,
                LmOldPresent, // Only false if Old password too complex
                LmOldOwfPassword,
                LmNewOwfPassword,
                TRUE, // NT password present
                NtOldOwfPassword,
                NtNewOwfPassword);
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


Cleanup:
    if (LsaHandle != NULL)
    {
        LsaClose(LsaHandle);
    }
    if (UserHandle != NULL)
    {
        FnSamCloseHandle(UserHandle);
    }
    if (DomainHandle != NULL)
    {
        FnSamCloseHandle(DomainHandle);
    }
    if (SamHandle != NULL)
    {
        FnSamCloseHandle(SamHandle);
    }
    if (DomainInfo != NULL)
    {
        LsaFreeMemory(DomainInfo);
    }
    if (RelativeIds != NULL)
    {
        FnSamFreeMemory(RelativeIds);
    }
    if (Use != NULL)
    {
        FnSamFreeMemory(Use);
    }

    if (ERROR_SUCCESS != WinErr) {
        return WinErr;
    }

    return RtlNtStatusToDosError(Status);
}


/*++

MSChapSrvChangePassword2:

    Changes the password of a user account.  Password will be set to
    NewPassword only if OldPassword matches the current user password for this
    user and there are no restrictions on using the new password.  This call
    allows users to change their own password if they have access
    USER_CHANGE_PASSWORD.  Password update restrictions apply.

Arguments:

    ServerName - The server to operate on, or NULL for this machine.

    UserName - Name of user whose password is to be changed

    NewPasswordEncryptedWithOldNt - The new cleartext password encrypted with
        the old NT OWF password.

    OldNtOwfPasswordEncryptedWithNewNt - The old NT OWF password encrypted
        with the new NT OWF password.

    LmPresent - If TRUE, indicates that the following two last parameter was
        encrypted with the LM OWF password not the NT OWF password.

    NewPasswordEncryptedWithOldLm - The new cleartext password encrypted with
        the old LM OWF password.

    OldLmOwfPasswordEncryptedWithNewLmOrNt - The old LM OWF password encrypted
        with the new LM OWF password.

Return Value:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate access to
        complete the operation.

    STATUS_INVALID_HANDLE - The supplied server or username was not valid.

    STATUS_ILL_FORMED_PASSWORD - The new password is poorly formed, e.g.
        contains characters that can't be entered from the keyboard, etc.

    STATUS_PASSWORD_RESTRICTION - A restriction prevents the password from
        being changed.  This may be for a number of reasons, including time
        restrictions on how often a password may be changed or length
        restrictions on the provided password.  This error might also be
        returned if the new password matched a password in the recent history
        log for the account.  Security administrators indicate how many of the
        most recently used passwords may not be re-used.  These are kept in
        the password recent history log.

    STATUS_WRONG_PASSWORD - OldPassword does not contain the user's current
        password.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the correct
        state (disabled or enabled) to perform the requested operation.  The
        domain server must be enabled for this operation.

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the incorrect
        role (primary or backup) to perform the requested operation.

--*/  
WINADVAPI DWORD WINAPI
MSChapSrvChangePassword2(
    IN LPWSTR ServerName,
    IN LPWSTR UserName,
    IN PSAMPR_ENCRYPTED_USER_PASSWORD NewPasswordEncryptedWithOldNt,
    IN PENCRYPTED_NT_OWF_PASSWORD OldNtOwfPasswordEncryptedWithNewNt,
    IN BOOLEAN LmPresent,
    IN PSAMPR_ENCRYPTED_USER_PASSWORD NewPasswordEncryptedWithOldLm,
    IN PENCRYPTED_LM_OWF_PASSWORD OldLmOwfPasswordEncryptedWithNewLmOrNt)
{
    UNICODE_STRING UnicodeServer;
    UNICODE_STRING UnicodeUser;
    DWORD WinErr = ERROR_SUCCESS;

    if (NULL == UserName || NULL == NewPasswordEncryptedWithOldNt ||
        NULL == NewPasswordEncryptedWithOldLm || NULL ==OldNtOwfPasswordEncryptedWithNewNt ||
        NULL == OldLmOwfPasswordEncryptedWithNewLmOrNt) {
        WinErr = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Initialization.
    //

    if ( hSamlib == NULL )
    {
        RtlEnterCriticalSection( &MSChapChangePassword );
    
        if ( hSamlib == NULL )
        {
            hSamlib = LoadLibrary(L"samlib.dll");
            WinErr  = GetLastError();
            if (ERROR_SUCCESS != WinErr) {
                goto Cleanup;
            }
            if (hSamlib != NULL) {
    
                FnSamConnect             = (FNSAMCONNECT)             GetProcAddress(hSamlib,
                                                                         "SamConnect");
                WinErr  = GetLastError();
                if (ERROR_SUCCESS != WinErr) {
                    goto Cleanup;
                }
                FnSamOpenDomain          = (FNSAMOPENDOMAIN)          GetProcAddress(hSamlib,
                                                                         "SamOpenDomain");
                WinErr  = GetLastError();
                if (ERROR_SUCCESS != WinErr) {
                    goto Cleanup;
                }
                FnSamLookupNamesInDomain = (FNSAMLOOKUPNAMESINDOMAIN) GetProcAddress(hSamlib,
                                                                         "SamLookupNamesInDomain");
                WinErr  = GetLastError();
                if (ERROR_SUCCESS != WinErr) {
                    goto Cleanup;
                }
                FnSamOpenUser            = (FNSAMOPENUSER)            GetProcAddress(hSamlib,
                                                                         "SamOpenUser");
                WinErr  = GetLastError();
                if (ERROR_SUCCESS != WinErr) {
                    goto Cleanup;
                }
                FnSamCloseHandle         = (FNSAMCLOSEHANDLE)         GetProcAddress(hSamlib,
                                                                         "SamCloseHandle");
                WinErr  = GetLastError();
                if (ERROR_SUCCESS != WinErr) {
                    goto Cleanup;
                }
                FnSamFreeMemory          = (FNSAMFREEMEMORY)          GetProcAddress(hSamlib,
                                                                         "SamFreeMemory");
                WinErr  = GetLastError();
                if (ERROR_SUCCESS != WinErr) {
                    goto Cleanup;
                }
                FnSamiChangePasswordUser = (FNSAMICHANGEPASSWORDUSER) GetProcAddress(hSamlib,
                                                                         "SamiChangePasswordUser");
                WinErr  = GetLastError();
                if (ERROR_SUCCESS != WinErr) {
                    goto Cleanup;
                }
                FnSamiChangePasswordUser2 = (FNSAMICHANGEPASSWORDUSER2) GetProcAddress(hSamlib,
                                                                         "SamiChangePasswordUser2");
                WinErr  = GetLastError();
                if (ERROR_SUCCESS != WinErr) {
                    goto Cleanup;
                }
            }
        }
    
    
        RtlLeaveCriticalSection( &MSChapChangePassword );
    
    }                                                                                               


    RtlInitUnicodeString(&UnicodeServer, ServerName);
    RtlInitUnicodeString(&UnicodeUser,   UserName);

    return RtlNtStatusToDosError(FnSamiChangePasswordUser2(&UnicodeServer,
                                                           &UnicodeUser,
                                                           NewPasswordEncryptedWithOldNt,
                                                           OldNtOwfPasswordEncryptedWithNewNt,
                                                           LmPresent,
                                                           NewPasswordEncryptedWithOldLm,
                                                           OldLmOwfPasswordEncryptedWithNewLmOrNt));

    Cleanup:
    return WinErr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\advapi32\security.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    security.c

Abstract:

    This module implements Object Security APIs for Win32

Author:

    Jim Anderson (JimA) 01-Jul-1991
    Robert Reichel (RobertRe) 01-Jan-92

Revision History:

--*/

#include "advapi.h"
#include <ntlsa.h>
#include <rpc.h>
#include <rpcndr.h>
#include <stdio.h>

#define LSADEFINED


/////////////////////////////////////////////////////////////////////////////
//                                                                         //
//               Private Routine Prototypes                                //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////


VOID
SepFormatAccountSid(
    PSID iSid,
    LPWSTR OutputBuffer
    );



/////////////////////////////////////////////////////////////////////////////
//                                                                         //
//               Exported Routines                                         //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////


BOOL
APIENTRY
DuplicateToken(
    HANDLE ExistingTokenHandle,
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,
    PHANDLE DuplicateTokenHandle
    )

/*++

Routine Description:

    Create a new token that is a duplicate of an existing token.  The
    new token will be an impersonation token of the supplied level.

Arguments:

    ExistingTokenHandle - Is a handle to a token already open for
        TOKEN_DUPLICATE access.

    ImpersonationLevel - Supplies the impersonation level of the new
        token.

    DuplicateTokenHandle - Returns the handle to the new token.  The
        handle will have TOKEN_IMPERSONATE and TOKEN_QUERY access to
        the new token.

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.


--*/

{
    return( DuplicateTokenEx( ExistingTokenHandle,
                              TOKEN_IMPERSONATE | TOKEN_QUERY,
                              NULL,
                              ImpersonationLevel,
                              TokenImpersonation,
                              DuplicateTokenHandle
                              ) );

}

BOOL
APIENTRY
DuplicateTokenEx(
    HANDLE hExistingToken,
    DWORD dwDesiredAccess,
    LPSECURITY_ATTRIBUTES lpTokenAttributes,
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,
    TOKEN_TYPE TokenType,
    PHANDLE phNewToken)
/*++

    Routine Description:

    Create a new token that is a duplicate of an existing token.  This API
    more fully exposes NtDuplicateToken .

    Arguments:

        hExistingToken - Is a handle to a token already open for
                                        TOKEN_DUPLICATE access.

        dwDesiredAccess - desired access rights to the new token, e.g.
                                       TOKEN_DUPLICATE, TOKEN_IMPERSONATE, etc.

        lpTokenAttributes - Desired security attributes for the new token.

        ImpersonationLevel - Supplies the impersonation level of the new token.

        TokenType - One of TokenImpersonation or TokenPrimary.

        phNewToken  - Returns the handle to the new token.

    Return Value:

        Returns TRUE for success, FALSE for failure.  Extended error status
        is available using GetLastError.

--*/


{

    OBJECT_ATTRIBUTES ObjA;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
    PSECURITY_DESCRIPTOR SecurityDescriptor;
    NTSTATUS Status;
    ULONG Attributes;

    SecurityQualityOfService.Length = sizeof( SECURITY_QUALITY_OF_SERVICE  );
    SecurityQualityOfService.ImpersonationLevel = ImpersonationLevel;
    SecurityQualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    SecurityQualityOfService.EffectiveOnly = FALSE;

    if (lpTokenAttributes)
    {
        SecurityDescriptor = lpTokenAttributes->lpSecurityDescriptor;
        if (lpTokenAttributes->bInheritHandle)
        {
            Attributes = OBJ_INHERIT;
        }
        else
        {
            Attributes = 0;
        }
    }
    else
    {
        SecurityDescriptor = NULL;
        Attributes = 0;
    }

    InitializeObjectAttributes(
        &ObjA,
        NULL,
        Attributes,
        NULL,
        SecurityDescriptor
        );

    ObjA.SecurityQualityOfService = &SecurityQualityOfService;

    Status = NtDuplicateToken(
                 hExistingToken,
                 dwDesiredAccess,
                 &ObjA,
                 FALSE,
                 TokenType,
                 phNewToken
                 );

    if ( !NT_SUCCESS( Status ) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return( TRUE );

}





BOOL
APIENTRY
AllocateLocallyUniqueId(
    PLUID Luid
    )
/*++

Routine Description:

    Allocates a locally unique ID (LUID).

Arguments:

    Luid - Supplies a pointer used to return the LUID.

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/

{   NTSTATUS Status;

    Status = NtAllocateLocallyUniqueId( Luid );
    if ( !NT_SUCCESS( Status )) {
        BaseSetLastNTError( Status );
        return( FALSE );
    }

    return( TRUE );
}




BOOL
APIENTRY
AccessCheck (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    HANDLE ClientToken,
    DWORD DesiredAccess,
    PGENERIC_MAPPING GenericMapping,
    PPRIVILEGE_SET PrivilegeSet,
    LPDWORD PrivilegeSetLength,
    LPDWORD GrantedAccess,
    LPBOOL AccessStatus
    )
/*++

Routine Description:

    This routine compares the input Security Descriptor against the
    input token and indicates by its return value if access is granted
    or denied.  If access is granted then the desired access mask
    becomes the granted access mask for the object.

    The semantics of the access check routine is described in the DSA
    Security Architecture workbook.  Note that during an access check
    only the discretionary ACL is examined.

Arguments:

    SecurityDescriptor - Supplies the security descriptor protecting the object
        being accessed

    ClientToken - Supplies the handle of the user's token.

    DesiredAccess - Supplies the desired access mask.

    GenericMapping - Supplies the generic mapping associated with this
        object type.

    PrivilegeSet - A pointer to a buffer that upon return will contain
        any privileges that were used to perform the access validation.
        If no privileges were used, the buffer will contain a privilege
        set consisting of zero privileges.

    PrivilegeSetLength - The size of the PrivilegeSet buffer in bytes.

    GrantedAccess - Returns an access mask describing the granted access.

    AccessStatus - Status value that may be returned indicating the
         reason why access was denied.  Routines should avoid hardcoding a
         return value of STATUS_ACCESS_DENIED so that a different value can
         be returned when mandatory access control is implemented.

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;
    NTSTATUS RealStatus;

    Status = NtAccessCheck (
                pSecurityDescriptor,
                ClientToken,
                DesiredAccess,
                GenericMapping,
                PrivilegeSet,
                PrivilegeSetLength,
                GrantedAccess,
                &RealStatus
                );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    if ( !NT_SUCCESS( RealStatus ) ) {
        BaseSetLastNTError( RealStatus );
        *AccessStatus = FALSE;
        return( TRUE );
    }

    *AccessStatus = TRUE;
    return TRUE;
}




BOOL
APIENTRY
AccessCheckByType (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    PSID PrincipalSelfSid,
    HANDLE ClientToken,
    DWORD DesiredAccess,
    POBJECT_TYPE_LIST ObjectTypeList,
    DWORD ObjectTypeListLength,
    PGENERIC_MAPPING GenericMapping,
    PPRIVILEGE_SET PrivilegeSet,
    LPDWORD PrivilegeSetLength,
    LPDWORD GrantedAccess,
    LPBOOL AccessStatus
    )
/*++

Routine Description:

    This routine compares the input Security Descriptor against the
    input token and indicates by its return value if access is granted
    or denied.  If access is granted then the desired access mask
    becomes the granted access mask for the object.

    The semantics of the access check routine is described in the DSA
    Security Architecture workbook.  Note that during an access check
    only the discretionary ACL is examined.

Arguments:

    SecurityDescriptor - Supplies the security descriptor protecting the object
        being accessed

    PrincipalSelfSid - If the object being access checked is an object which
        represents a principal (e.g., a user object), this parameter should
        be the SID of the object.  Any ACE containing the constant
        PRINCIPAL_SELF_SID is replaced by this SID.

        The parameter should be NULL if the object does not represent a principal.

    ClientToken - Supplies the handle of the user's token.

    DesiredAccess - Supplies the desired access mask.

    ObjectTypeList - Supplies a list of GUIDs representing the object (and
        sub-objects) being accessed.  If no list is present, AccessCheckByType
        behaves identically to AccessCheck.

    ObjectTypeListLength - Specifies the number of elements in the ObjectTypeList.

    GenericMapping - Supplies the generic mapping associated with this
        object type.

    PrivilegeSet - A pointer to a buffer that upon return will contain
        any privileges that were used to perform the access validation.
        If no privileges were used, the buffer will contain a privilege
        set consisting of zero privileges.

    PrivilegeSetLength - The size of the PrivilegeSet buffer in bytes.

    GrantedAccess - Returns an access mask describing the granted access.

    AccessStatus - Status value that may be returned indicating the
         reason why access was denied.  Routines should avoid hardcoding a
         return value of STATUS_ACCESS_DENIED so that a different value can
         be returned when mandatory access control is implemented.

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;
    NTSTATUS RealStatus;

    Status = NtAccessCheckByType (
                pSecurityDescriptor,
                PrincipalSelfSid,
                ClientToken,
                DesiredAccess,
                ObjectTypeList,
                ObjectTypeListLength,
                GenericMapping,
                PrivilegeSet,
                PrivilegeSetLength,
                GrantedAccess,
                &RealStatus
                );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    if ( !NT_SUCCESS( RealStatus ) ) {
        BaseSetLastNTError( RealStatus );
        *AccessStatus = FALSE;
        return( TRUE );
    }

    *AccessStatus = TRUE;
    return TRUE;
}




BOOL
APIENTRY
AccessCheckByTypeResultList (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    PSID PrincipalSelfSid,
    HANDLE ClientToken,
    DWORD DesiredAccess,
    POBJECT_TYPE_LIST ObjectTypeList,
    DWORD ObjectTypeListLength,
    PGENERIC_MAPPING GenericMapping,
    PPRIVILEGE_SET PrivilegeSet,
    LPDWORD PrivilegeSetLength,
    LPDWORD GrantedAccessList,
    LPDWORD AccessStatusList
    )
/*++

Routine Description:

    This routine compares the input Security Descriptor against the
    input token and indicates by its return value if access is granted
    or denied.  If access is granted then the desired access mask
    becomes the granted access mask for the object.

    The semantics of the access check routine is described in the DSA
    Security Architecture workbook.  Note that during an access check
    only the discretionary ACL is examined.

Arguments:

    SecurityDescriptor - Supplies the security descriptor protecting the object
        being accessed

    PrincipalSelfSid - If the object being access checked is an object which
        represents a principal (e.g., a user object), this parameter should
        be the SID of the object.  Any ACE containing the constant
        PRINCIPAL_SELF_SID is replaced by this SID.

        The parameter should be NULL if the object does not represent a principal.

    ClientToken - Supplies the handle of the user's token.

    DesiredAccess - Supplies the desired access mask.

    ObjectTypeList - Supplies a list of GUIDs representing the object (and
        sub-objects) being accessed.  If no list is present, AccessCheckByType
        behaves identically to AccessCheck.

    ObjectTypeListLength - Specifies the number of elements in the ObjectTypeList.

    GenericMapping - Supplies the generic mapping associated with this
        object type.

    PrivilegeSet - A pointer to a buffer that upon return will contain
        any privileges that were used to perform the access validation.
        If no privileges were used, the buffer will contain a privilege
        set consisting of zero privileges.

    PrivilegeSetLength - The size of the PrivilegeSet buffer in bytes.

    GrantedAccessList - Returns an access mask describing the granted access.

    AccessStatusList - Status value that may be returned indicating the
         reason why access was denied.  Routines should avoid hardcoding a
         return value of STATUS_ACCESS_DENIED so that a different value can
         be returned when mandatory access control is implemented.

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;
    NTSTATUS RealStatus;
    ULONG i;

    ASSERT (sizeof(NTSTATUS) == sizeof(DWORD) );

    Status = NtAccessCheckByTypeResultList (
                pSecurityDescriptor,
                PrincipalSelfSid,
                ClientToken,
                DesiredAccess,
                ObjectTypeList,
                ObjectTypeListLength,
                GenericMapping,
                PrivilegeSet,
                PrivilegeSetLength,
                GrantedAccessList,
                (PNTSTATUS)AccessStatusList
                );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    //
    // Loop converting the array of NT status codes to WIN status codes.
    //

    for ( i=0; i<ObjectTypeListLength; i++ ) {
        if ( AccessStatusList[i] == STATUS_SUCCESS ) {
            AccessStatusList[i] = NO_ERROR;
        } else {
            AccessStatusList[i] = RtlNtStatusToDosError( AccessStatusList[i] );
        }
    }

    return TRUE;
}




BOOL
APIENTRY
OpenProcessToken (
    HANDLE ProcessHandle,
    DWORD DesiredAccess,
    PHANDLE TokenHandle
    )
/*++

Routine Description:

    Open a token object associated with a process and return a handle
    that may be used to access that token.

Arguments:

    ProcessHandle - Specifies the process whose token is to be
        opened.

    DesiredAccess - Is an access mask indicating which access types
        are desired to the token.  These access types are reconciled
        with the Discretionary Access Control list of the token to
        determine whether the accesses will be granted or denied.

    TokenHandle - Receives the handle of the newly opened token.

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;

    Status = NtOpenProcessToken (
        ProcessHandle,
        DesiredAccess,
        TokenHandle
        );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}




BOOL
APIENTRY
OpenThreadToken (
    HANDLE ThreadHandle,
    DWORD DesiredAccess,
    BOOL OpenAsSelf,
    PHANDLE TokenHandle
    )
/*++


Routine Description:

Open a token object associated with a thread and return a handle that
may be used to access that token.

Arguments:

    ThreadHandle - Specifies the thread whose token is to be opened.

    DesiredAccess - Is an access mask indicating which access types
        are desired to the token.  These access types are reconciled
        with the Discretionary Access Control list of the token to
        determine whether the accesses will be granted or denied.

    OpenAsSelf - Is a boolean value indicating whether the access should
        be m