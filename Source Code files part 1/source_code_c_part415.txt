wIndex-dwPages : dwIndex].pfnDlgProc;

            prgBuildCTLSheet[dwPropCount].lParam=(LPARAM)&CertBuildCTLInfo;

            dwPropCount++;
        }
    }

    //set up the header information
    buildCTLHeader.dwSize=sizeof(buildCTLHeader);
    buildCTLHeader.dwFlags=PSH_PROPSHEETPAGE | PSH_WIZARD | PSH_NOAPPLYNOW;
    buildCTLHeader.hwndParent=hwndParent;
    buildCTLHeader.hInstance=g_hmodThisDll;

    if(pwszWizardTitle)
        buildCTLHeader.pszCaption=pwszWizardTitle;
    else
    {
        if(LoadStringU(g_hmodThisDll, IDS_BUILDCTL_WIZARD_TITLE, wszTitle, sizeof(wszTitle)/sizeof(wszTitle[0])))
            buildCTLHeader.pszCaption=wszTitle;
    }

    buildCTLHeader.nPages=dwPropCount;
    buildCTLHeader.nStartPage=0;
    buildCTLHeader.ppsp=prgBuildCTLSheet;

    //create the wizard
    iReturn = PropertySheetU(&buildCTLHeader);

    if(-1 == iReturn)
        goto Win32Err;

    if(0 == iReturn)
    {
        //user clicks cancel
        fResult=TRUE;
        //no need to say anything if the wizard is cancelled
        ids=0;

        if(ppCTLContext)
            *ppCTLContext=NULL;

        goto CommonReturn;
    }


    //get the resulting nonsigned CTL or signed CTL
    if(dwFlags & CRYPTUI_WIZ_BUILDCTL_SKIP_SIGNING)
    {
        //get the created BLOB of the CTL
        if( (0 == SignBlob.cbBlob) || (NULL==SignBlob.pbBlob) )
        {
            //the error msg should have shown.
            ids=0;
            goto CTLBlobErr;
        }

        //the CTL context from the encoded CTL
        pBldCTL=CertCreateCTLContext(
                    g_dwMsgAndCertEncodingType,
                    SignBlob.pbBlob,
                    SignBlob.cbBlob);
    }
    else
    {
        //get the signing result
        fResult=GetSignInfo.fResult;

        if(!fResult || !(GetSignInfo.pSignContext))
        {
            ids=IDS_SIGN_CTL_FAILED;
            if(0 == GetSignInfo.dwError)
                GetSignInfo.dwError=E_FAIL;

            goto SignErr;
        }

        //the CTL context from the encoded CTL
        pBldCTL=CertCreateCTLContext(
                    g_dwMsgAndCertEncodingType,
                    (GetSignInfo.pSignContext)->pbBlob,
                    (GetSignInfo.pSignContext)->cbBlob);
    }

    if(NULL==pBldCTL)
        goto Win32Err;

    //set the properties
    if(CertBuildCTLInfo.pwszFriendlyName)
    {
        PropertyBlob.cbData=sizeof(WCHAR)*(wcslen(CertBuildCTLInfo.pwszFriendlyName)+1);
        PropertyBlob.pbData=(BYTE *)(CertBuildCTLInfo.pwszFriendlyName);

        CertSetCTLContextProperty(
            pBldCTL,	
            CERT_FRIENDLY_NAME_PROP_ID,	
            0,
            &PropertyBlob);
    }

    if(CertBuildCTLInfo.pwszDescription)
    {
        PropertyBlob.cbData=sizeof(WCHAR)*(wcslen(CertBuildCTLInfo.pwszDescription)+1);
        PropertyBlob.pbData=(BYTE *)(CertBuildCTLInfo.pwszDescription);

        CertSetCTLContextProperty(
            pBldCTL,	
            CERT_DESCRIPTION_PROP_ID,	
            0,
            &PropertyBlob);
    }


    //save to the destination
    if(CertBuildCTLInfo.hDesStore && (TRUE==CertBuildCTLInfo.fSelectedDesStore))
    {
        if(!CertAddCTLContextToStore(CertBuildCTLInfo.hDesStore,
									pBldCTL,
									CERT_STORE_ADD_REPLACE_EXISTING,
									NULL))
        {
            ids=IDS_FAIL_TO_ADD_CTL_TO_STORE;
            goto Win32Err;
        }
    }

    //save to the file
    if(CertBuildCTLInfo.pwszFileName && (TRUE==CertBuildCTLInfo.fSelectedFileName))
    {
        if(S_OK != OpenAndWriteToFile(
                    CertBuildCTLInfo.pwszFileName,
                    pBldCTL->pbCtlEncoded,
                    pBldCTL->cbCtlEncoded))
        {
            ids=IDS_FAIL_TO_ADD_CTL_TO_FILE;
            goto Win32Err;
        }
    }

    if(ppCTLContext)
    {
        *ppCTLContext=pBldCTL;
        pBldCTL=NULL;
    }

    fResult=TRUE;
    ids=IDS_BUILDCTL_SUCCEEDED;

CommonReturn:

    //preserve the last error
    dwError=GetLastError();

    //pop up the confirmation box for failure
    if(ids)
    {
        //set the message of inable to gather enough info for PKCS10
        if(IDS_BUILDCTL_SUCCEEDED == ids)
            I_MessageBox(hwndParent, ids, IDS_BUILDCTL_WIZARD_TITLE,
                        NULL, MB_OK|MB_ICONINFORMATION);
        else
            I_MessageBox(hwndParent, ids, IDS_BUILDCTL_WIZARD_TITLE,
                        NULL, MB_OK|MB_ICONERROR);
    }

    //free the BLOB to be signed.   It is the encoded CTL BLOB without the
    //signature
    if(SignBlob.pbBlob)
         WizardFree(SignBlob.pbBlob);

    //free the signing context
    if(GetSignInfo.pSignContext)
        CryptUIWizFreeDigitalSignContext(GetSignInfo.pSignContext);

    //free the store lsit
    //free my store
    if(hMyStore)
        CertCloseStore(hMyStore, 0);

   /* if(CertStoreList.prgStore)
    {
        for(dwIndex=0; dwIndex<CertStoreList.dwStoreCount; dwIndex++)
            CertCloseStore(CertStoreList.prgStore[dwIndex], 0);

        WizardFree(CertStoreList.prgStore);
    } */

    if(pwPages)
        CryptUIWizFreeDigitalSignPages(pwPages, dwPages);

    if(pBldCTL)
        CertFreeCTLContext(pBldCTL);


    //destroy the hFont object
    DestroyFonts(CertBuildCTLInfo.hBigBold,
                CertBuildCTLInfo.hBold);

    //free the pCertBUILDCTLInfo struct
    if(CertBuildCTLInfo.pwszFileName && (TRUE==CertBuildCTLInfo.fFreeFileName))
        WizardFree(CertBuildCTLInfo.pwszFileName);


    if(CertBuildCTLInfo.hDesStore && (TRUE==CertBuildCTLInfo.fFreeDesStore))
        CertCloseStore(CertBuildCTLInfo.hDesStore, 0);


    //free the friendly name and description
    if(CertBuildCTLInfo.pwszFriendlyName)
        WizardFree(CertBuildCTLInfo.pwszFriendlyName);

    if(CertBuildCTLInfo.pwszDescription)
        WizardFree(CertBuildCTLInfo.pwszDescription);

    //free the listID
    if(CertBuildCTLInfo.pwszListID)
        WizardFree(CertBuildCTLInfo.pwszListID);

    //free the certificates
    FreeCerts(&CertBuildCTLInfo);

   //free the purpose OID
    FreePurposeInfo(CertBuildCTLInfo.prgPurpose,
                   CertBuildCTLInfo.dwPurposeCount);

    if(prgBuildCTLSheet)
        WizardFree(prgBuildCTLSheet);

    //reset the error
    SetLastError(dwError);

    return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;


SET_ERROR(InvalidArgErr, E_INVALIDARG);
TRACE_ERROR(Crypt32Err);
TRACE_ERROR(Win32Err);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
SET_ERROR(SignErr, GetSignInfo.dwError);
TRACE_ERROR(CTLBlobErr);
}

//****************************************************************************
//   Helper functions for BuildCTL wizards
//
//*****************************************************************************
//----------------------------------------------------------------------------
//
//Get the hash of the certificates from the list
//----------------------------------------------------------------------------
BOOL	GetCertHash(CERT_BUILDCTL_INFO  *pCertBuildCTLInfo,
                    BYTE			    ***prgpHash,
                    DWORD			    **prgcbHash,
                    DWORD			    *pdwCount)

{
	BOOL            fResult=FALSE;
	BYTE			*pbData=NULL;
	DWORD			cbData=0;
    DWORD           dwIndex=0;

    //init
    *prgpHash=NULL;
    *prgcbHash=NULL;
    *pdwCount=0;

    if(!pCertBuildCTLInfo->prgCertContext)
       return FALSE;

    //now, we need to enum all the certs in the store
	for(dwIndex=0; dwIndex<pCertBuildCTLInfo->dwCertCount; dwIndex++)
	{

        if(NULL==pCertBuildCTLInfo->prgCertContext[dwIndex])
            continue;

		//get the SHA1 hash of the certificate
		if(!CertGetCertificateContextProperty(
                        pCertBuildCTLInfo->prgCertContext[dwIndex],
                        pCertBuildCTLInfo->dwHashPropID,
                        NULL,&cbData))
            goto CLEANUP;

		pbData=(BYTE *)WizardAlloc(cbData);
		if(!pbData)
            goto CLEANUP;

 		//get the SHA1 hash of the certificate
		if(!CertGetCertificateContextProperty(
                        pCertBuildCTLInfo->prgCertContext[dwIndex],
                        pCertBuildCTLInfo->dwHashPropID,
                        pbData,&cbData))
            goto CLEANUP;


		//add to our global list
		(*pdwCount)++;

		//re-alloc memory
		*prgpHash=(BYTE **)WizardRealloc(*prgpHash, sizeof(BYTE *)*(*pdwCount));
		*prgcbHash=(DWORD *)WizardRealloc(*prgcbHash, sizeof(DWORD)*(*pdwCount));

		if((!(*prgpHash)) || (!(*prgcbHash)))
			goto CLEANUP;

	    (*prgpHash)[*pdwCount-1]=pbData;
		(*prgcbHash)[*pdwCount-1]=cbData;
	}

	fResult=TRUE;

CLEANUP:


    if(!fResult)
    {
      	if(*prgpHash)
	    {
		    for(dwIndex=0; dwIndex<*pdwCount; dwIndex++)
			    WizardFree((*prgpHash)[dwIndex]);

		    WizardFree(*prgpHash);

            *prgpHash=NULL;
	    }

        if(*prgcbHash)
        {
            WizardFree(*prgcbHash);
            *prgcbHash=NULL;
        }
    }


	return fResult;

}
//-----------------------------------------------------------------------
//
// I_BuildCTL
//
//  Build a new CTL or modify an existing CTL.
//------------------------------------------------------------------------
BOOL    I_BuildCTL(CERT_BUILDCTL_INFO   *pCertBuildCTLInfo,
                   UINT                 *pIDS,
                   BYTE                 **ppbEncodedCTL,
                   DWORD                *pcbEncodedCTL)
{
    BOOL                    fResult=FALSE;
   	CMSG_SIGNED_ENCODE_INFO sSignInfo;
    CTL_INFO                CTLInfo;
	DWORD					dwIndex=0;
    DWORD	                cbEncodedCTL=0;
    UINT                    ids=IDS_FAIL_TO_BUILD_CTL;
    GUID                    guid;
    PCCRYPT_OID_INFO        pOIDInfo=NULL;
    ALG_ID                  AlgID=0;
    DWORD                   dwCount=0;

    BYTE			        **rgpHash=NULL;
    DWORD			        *rgcbHash=NULL;
    unsigned char *         pGUID=NULL;
    LPWSTR                  pwszGUID=NULL;

    BYTE		            *pbEncodedCTL=NULL;	
	//init
	memset(&sSignInfo, 0, sizeof(CMSG_SIGNED_ENCODE_INFO));
    sSignInfo.cbSize = sizeof(CMSG_SIGNED_ENCODE_INFO);

	memset(&CTLInfo, 0, sizeof(CTL_INFO));

    if(pbEncodedCTL)
        *pbEncodedCTL=NULL;

	//set up CTL
	CTLInfo.dwVersion=CTL_V1;

    //set up the subject Usage
    for(dwIndex=0; dwIndex<pCertBuildCTLInfo->dwPurposeCount; dwIndex++)
    {
        if(pCertBuildCTLInfo->prgPurpose[dwIndex]->fSelected)
        {
            CTLInfo.SubjectUsage.cUsageIdentifier++;
            CTLInfo.SubjectUsage.rgpszUsageIdentifier=(LPSTR *)WizardRealloc(
                                        CTLInfo.SubjectUsage.rgpszUsageIdentifier,
                                         sizeof(LPSTR) * CTLInfo.SubjectUsage.cUsageIdentifier);

            if(!CTLInfo.SubjectUsage.rgpszUsageIdentifier)
                goto MemoryErr;

            CTLInfo.SubjectUsage.rgpszUsageIdentifier[CTLInfo.SubjectUsage.cUsageIdentifier-1]=
                   pCertBuildCTLInfo->prgPurpose[dwIndex]->pszOID;
        }
    }

    //Set up ListIdentifier
    //copy the listID if user has specified it
    if(NULL==pCertBuildCTLInfo->pwszListID)
    {
        if(RPC_S_OK != UuidCreate(&guid))
            goto TraceErr;

        //make a wchar string out of the guid
        if(RPC_S_OK != UuidToString(&guid, &pGUID))
            goto TraceErr;

        //conver the string to wchar
        pwszGUID=MkWStr((char *)pGUID);

        if(!pwszGUID)
            goto TraceErr;

        CTLInfo.ListIdentifier.cbData=sizeof(WCHAR)*(wcslen(pwszGUID)+1);
        CTLInfo.ListIdentifier.pbData=(BYTE *)WizardAlloc(CTLInfo.ListIdentifier.cbData);

        if(NULL==CTLInfo.ListIdentifier.pbData)
            goto MemoryErr;

        memcpy(CTLInfo.ListIdentifier.pbData,
                pwszGUID,
                CTLInfo.ListIdentifier.cbData);
    }
    else
    {
        CTLInfo.ListIdentifier.cbData=sizeof(WCHAR)*(wcslen(pCertBuildCTLInfo->pwszListID)+1);
        CTLInfo.ListIdentifier.pbData=(BYTE *)WizardAlloc(CTLInfo.ListIdentifier.cbData);

        if(NULL==CTLInfo.ListIdentifier.pbData)
            goto MemoryErr;

        memcpy(CTLInfo.ListIdentifier.pbData,
           pCertBuildCTLInfo->pwszListID,
            CTLInfo.ListIdentifier.cbData);
    }

    //This update field
	GetSystemTimeAsFileTime(&(CTLInfo.ThisUpdate));

    //Next Update field
    //do not specify any value if user did not enter any
    if(pCertBuildCTLInfo->dwValidMonths != 0 || pCertBuildCTLInfo->dwValidDays != 0)
    {
        AddDurationToFileTime(pCertBuildCTLInfo->dwValidMonths,
                            pCertBuildCTLInfo->dwValidDays,
                            &(CTLInfo.ThisUpdate),
                            &(CTLInfo.NextUpdate));
    }

    //subject Algorithm
    if(pCertBuildCTLInfo->dwHashPropID==CERT_MD5_HASH_PROP_ID)
        AlgID=CALG_MD5;
    else
        AlgID=CALG_SHA1;

    pOIDInfo=CryptFindOIDInfo(
            CRYPT_OID_INFO_ALGID_KEY,
            &AlgID,
            CRYPT_HASH_ALG_OID_GROUP_ID);

    if(pOIDInfo)
        CTLInfo.SubjectAlgorithm.pszObjId=(LPSTR)(pOIDInfo->pszOID);
    else
        goto FailErr;

    //set up the list of entries

    //get the array of hash of the certificate
    if(!GetCertHash(pCertBuildCTLInfo,
                    &rgpHash,
                    &rgcbHash,
                    &dwCount))
        goto FailErr;

	CTLInfo.cCTLEntry=dwCount;
	CTLInfo.rgCTLEntry=(CTL_ENTRY *)WizardAlloc(sizeof(CTL_ENTRY)*dwCount);
	if(!(CTLInfo.rgCTLEntry))
        goto MemoryErr;

	//memset
	memset(CTLInfo.rgCTLEntry, 0, sizeof(CTL_ENTRY)*dwCount);

	for(dwIndex=0; dwIndex<dwCount; dwIndex++)
	{
		CTLInfo.rgCTLEntry[dwIndex].SubjectIdentifier.cbData=rgcbHash[dwIndex];
 		CTLInfo.rgCTLEntry[dwIndex].SubjectIdentifier.pbData=rgpHash[dwIndex];
	}

    //include all the certificates in the signer info
    sSignInfo.cCertEncoded=pCertBuildCTLInfo->dwCertCount;
    sSignInfo.rgCertEncoded=(PCERT_BLOB)WizardAlloc(sizeof(CERT_BLOB)*
                                       sSignInfo.cCertEncoded);

    if(NULL==sSignInfo.rgCertEncoded)
        goto MemoryErr;

    for(dwIndex=0; dwIndex<sSignInfo.cCertEncoded; dwIndex++)
    {
        sSignInfo.rgCertEncoded[dwIndex].cbData=pCertBuildCTLInfo->prgCertContext[dwIndex]->cbCertEncoded;
        sSignInfo.rgCertEncoded[dwIndex].pbData=pCertBuildCTLInfo->prgCertContext[dwIndex]->pbCertEncoded;
    }

	//encode and sign the CTL
    if(!CryptMsgEncodeAndSignCTL(g_dwMsgAndCertEncodingType,
                                    &CTLInfo,
                                    &sSignInfo,
                                    0,
                                    NULL,
                                    &cbEncodedCTL))
                goto TraceErr;

	//memory allocation
	pbEncodedCTL=(BYTE *)WizardAlloc(cbEncodedCTL);

	if(!(pbEncodedCTL))
        goto MemoryErr;

    if(!CryptMsgEncodeAndSignCTL(g_dwMsgAndCertEncodingType,
                                    &CTLInfo,
                                    &sSignInfo,
                                    0,
                                    pbEncodedCTL,
                                    &cbEncodedCTL))
        goto TraceErr;


    if(ppbEncodedCTL && pcbEncodedCTL)
    {
        *ppbEncodedCTL=pbEncodedCTL;
        *pcbEncodedCTL=cbEncodedCTL;

        pbEncodedCTL=NULL;
    }

    ids=IDS_BUILDCTL_SUCCEEDED;
    fResult=TRUE;


CommonReturn:


    if(CTLInfo.ListIdentifier.pbData)
        WizardFree(CTLInfo.ListIdentifier.pbData);

    if(CTLInfo.SubjectUsage.rgpszUsageIdentifier)
        WizardFree(CTLInfo.SubjectUsage.rgpszUsageIdentifier);

    if(pGUID)
        RpcStringFree(&pGUID);

    if(pwszGUID)
        FreeWStr(pwszGUID);

    if(CTLInfo.rgCTLEntry)
        WizardFree(CTLInfo.rgCTLEntry);

    if(sSignInfo.rgCertEncoded)
        WizardFree(sSignInfo.rgCertEncoded);

    if(rgpHash)
	{
		for(dwIndex=0; dwIndex<dwCount; dwIndex++)
			WizardFree(rgpHash[dwIndex]);

		WizardFree(rgpHash);
	}

    if(rgcbHash)
        WizardFree(rgcbHash);


    if(pbEncodedCTL)
        WizardFree(pbEncodedCTL);

    if(pIDS)
        *pIDS=ids;


    return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;


SET_ERROR(MemoryErr, E_OUTOFMEMORY);
TRACE_ERROR(TraceErr);
SET_ERROR(FailErr, E_FAIL);
}

//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
BOOL WizardGetOIDInfo(LPWSTR string, DWORD stringSize, LPSTR pszObjId)
{
    PCCRYPT_OID_INFO pOIDInfo;

    pOIDInfo = CryptFindOIDInfo(
                CRYPT_OID_INFO_OID_KEY,
                pszObjId,
                0);

    if (pOIDInfo != NULL)
    {
        if ((DWORD)(wcslen(pOIDInfo->pwszName)+1) <= stringSize)
        {
            wcscpy(string, pOIDInfo->pwszName);
        }
        else
        {
            return FALSE;
        }
    }
    else
    {
        return (MultiByteToWideChar(CP_ACP, 0, pszObjId, -1, string, stringSize) != 0);
    }

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
LPWSTR WizardAllocAndCopyWStr(LPWSTR pwsz)
{
    LPWSTR   pwszReturn;

    if (NULL == (pwszReturn = (LPWSTR) WizardAlloc((wcslen(pwsz)+1) * sizeof(WCHAR))))
    {
        return NULL;
    }
    wcscpy(pwszReturn, pwsz);

    return(pwszReturn);
}



//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
BOOL WizardFormatDateString(LPWSTR *ppString, FILETIME ft, BOOL fIncludeTime)
{
    int                 cch=0;
    int                 cch2=0;
    LPWSTR              psz=NULL;
    SYSTEMTIME          st;
    FILETIME            localTime;
    
    if (!FileTimeToLocalFileTime(&ft, &localTime))
    {
        return FALSE;
    }
    
    if (!FileTimeToSystemTime(&localTime, &st)) 
    {
        //
        // if the conversion to local time failed, then just use the original time
        //
        if (!FileTimeToSystemTime(&ft, &st)) 
        {
            return FALSE;
        }
        
    }

    cch = (GetTimeFormatU(LOCALE_USER_DEFAULT, 0, &st, NULL, NULL, 0) +
           GetDateFormatU(LOCALE_USER_DEFAULT, 0, &st, NULL, NULL, 0) + 5);

    if (NULL == (psz = (LPWSTR) WizardAlloc((cch+5) * sizeof(WCHAR))))
    {
        return FALSE;
    }
    
    cch2 = GetDateFormatU(LOCALE_USER_DEFAULT, 0, &st, NULL, psz, cch);

    if (fIncludeTime)
    {
        psz[cch2-1] = ' ';
        GetTimeFormatU(LOCALE_USER_DEFAULT, 0, &st, NULL, 
                       &psz[cch2], cch-cch2);
    }
    
    *ppString = psz;

    return TRUE;
}


//+-------------------------------------------------------------------------
//  Write a blob to a file
//--------------------------------------------------------------------------
HRESULT OpenAndWriteToFile(
    LPCWSTR  pwszFileName,
    PBYTE   pb,
    DWORD   cb
    )
{
    HRESULT		hr=E_FAIL;
    HANDLE		hFile=NULL;
	DWORD		dwBytesWritten=0;

	if(!pwszFileName || !pb || (cb==0))
	   return E_INVALIDARG;

    hFile = ExpandAndCreateFileU(pwszFileName,
                GENERIC_WRITE,
                0,                      // fdwShareMode
                NULL,                   // lpsa
                CREATE_ALWAYS,
                FILE_ATTRIBUTE_NORMAL,  // fdwAttrsAndFlags
                0);                     // TemplateFile	

    if (INVALID_HANDLE_VALUE == hFile)
	{
		hr=HRESULT_FROM_WIN32(GetLastError());
	}
	else
	{

        if (!WriteFile(
                hFile,
                pb,
                cb,
                &dwBytesWritten,
                NULL            // lpOverlapped
                ))
		{
			hr=HRESULT_FROM_WIN32(GetLastError());
		}
		else
		{

			if(dwBytesWritten != cb)
				hr=E_FAIL;
			else
				hr=S_OK;
		}

        CloseHandle(hFile);
    }

    return hr;
}


//--------------------------------------------------------------------------------
//   See if the DATA blob is a valid wchar string
//--------------------------------------------------------------------------------
BOOL    ValidString(CRYPT_DATA_BLOB *pDataBlob)
{
    LPWSTR  pwsz=NULL;
    DWORD   dwIndex=0;

    if(NULL==pDataBlob)
        return FALSE;

    if(pDataBlob->cbData < sizeof(WCHAR))
        return FALSE;

    //has to be NULL-terminated
    pwsz=(LPWSTR)((DWORD_PTR)(pDataBlob->pbData)+(pDataBlob->cbData)-sizeof(WCHAR));

    if(*pwsz != '\0')
        return FALSE;

    //has to include the exact number of wchars
    if(0 != ((pDataBlob->cbData)%sizeof(WCHAR)))
        return FALSE;

    //each character, with exception of the last NULL terminater,
    //has to be printable (20-7e) range
    for(dwIndex=0; dwIndex<(pDataBlob->cbData)-sizeof(WCHAR); dwIndex=dwIndex+sizeof(WCHAR))
    {
        pwsz=(LPWSTR)((DWORD_PTR)(pDataBlob->pbData)+dwIndex);

        if(0==iswprint(*pwsz))
            return FALSE;
    }

    return TRUE;
}

//--------------------------------------------------------------------------------
//   See if the user input is an 0 in the form of {white spaces}{sign}{0}
//   pwszInput has to be NULL terminated
//--------------------------------------------------------------------------------
BOOL    ValidZero(LPWSTR    pwszInput)
{
    BOOL    fSpace=TRUE;
    BOOL    fSign=TRUE;

    if(NULL==pwszInput)
        return FALSE;

    while(*pwszInput != L'\0')
    {
        if(iswspace(*pwszInput))
        {
            if(fSpace)
                pwszInput++;
            else
                return FALSE;
        }
        else
        {
            if((L'+'==*pwszInput) || (L'-'==*pwszInput))
            {
                if(fSign)
                {
                    fSign=FALSE;
                    fSpace=FALSE;
                    pwszInput++;

                }
                else
                    return FALSE;
            }
            else
            {

                if(L'0'==*pwszInput)
                {
                   fSign=FALSE;
                   fSpace=FALSE;
                   pwszInput++;

                }
                else
                    return FALSE;
            }
        }
    }

    return TRUE;
}

//--------------------------------------------------------------------------------
//  Get the number of days in a particular month of a particular year
//--------------------------------------------------------------------------------
DWORD DaysInMonth(DWORD  dwYear, DWORD dwMonth)
{
    switch (dwMonth)
    {
        case 1:
        case 3:
        case 5:
        case 7:
        case 8:
        case 10:
        case 12:
                return 31;
            break;
        case 4:
        case 6:
        case 9:
        case 11:
                return 30;
            break;
        case 2:
                //leap year
                if((0 == dwYear % 4 && 0!= dwYear % 100) || 0 == dwYear % 400)
                    return 29;
                else
                    return 28;
        default:
            return 0;
    }

    return 0;
}

//--------------------------------------------------------------------------------
//  Substract the next update time from the current time
//--------------------------------------------------------------------------------
void    SubstractDurationFromFileTime(
        FILETIME    *pNextUpdateTime,
        FILETIME    *pCurrentTime,
        DWORD       *pdwValidMonths,
        DWORD       *pdwValidDays)
{
    SYSTEMTIME      SystemNext;
    SYSTEMTIME      SystemCurrent;

    *pdwValidMonths=0;
    *pdwValidDays=0;

    //return if the NextUpdateTime is NULL
    if(0 ==pNextUpdateTime->dwLowDateTime && 0==pNextUpdateTime->dwHighDateTime)
        return;

    //the NextUpateTime has to be more than the current time
    if((*(LONGLONG *)pNextUpdateTime) <= (*(LONGLONG *)pCurrentTime) )
        return;

    //convert to system time
    if(!FileTimeToSystemTime(pNextUpdateTime, &SystemNext) ||
        !FileTimeToSystemTime(pCurrentTime, &SystemCurrent))
        return;

    //compute the difference between the two systemtime
    //in terms of month and days
    if(SystemNext.wDay  >= SystemCurrent.wDay)
        *pdwValidDays=SystemNext.wDay - SystemCurrent.wDay;
    else
    {
        SystemNext.wMonth--;

        //consider the 1st month of the year
        if(0 == SystemNext.wMonth)
        {
            SystemNext.wMonth=12;
            SystemNext.wYear--;
        }

        *pdwValidDays=SystemNext.wDay + DaysInMonth(SystemNext.wYear, SystemNext.wMonth) - SystemCurrent.wDay;

    }

    *pdwValidMonths=(SystemNext.wYear * 12 + SystemNext.wMonth) -
                   (SystemCurrent.wYear * 12 + SystemCurrent.wMonth);

    //if the resolution for day is too small, we just use one day
    if((*pdwValidDays == 0) && (*pdwValidMonths==0))
        *pdwValidDays=1;

}

//--------------------------------------------------------------------------------
//  GetDaysForMonth
//--------------------------------------------------------------------------------
BOOL    GetDaysForMonth(DWORD   dwYear, DWORD   dwMonth, DWORD  *pdwDays)
{
    BOOL    fResult=FALSE;

    if(NULL == pdwDays)
        goto CLEANUP;

    *pdwDays=0;

    switch(dwMonth)
    {
        case 1:
        case 3:
        case 5:
        case 7:
        case 8:
        case 10:
        case 12:
                *pdwDays=31;
            break;
        case 4:
        case 6:
        case 9:
        case 11:
                *pdwDays=30;
            break;
        case 2:   
                
                if((dwYear % 4 == 0 && dwYear % 100 !=0 ) ||
                    (dwYear % 400 ==0))
                    *pdwDays=29;
                else
                    *pdwDays=28;

            break;
        default:
            goto CLEANUP;

    }

    fResult=TRUE;

CLEANUP:

    return fResult;

}

//--------------------------------------------------------------------------------
//  Add the duration to the current fileTime
//--------------------------------------------------------------------------------
void AddDurationToFileTime(DWORD dwValidMonths,
                      DWORD dwValidDays,
                      FILETIME  *pCurrentFileTime,
                      FILETIME  *pNextFileTime)
{
    SYSTEMTIME          SystemCurrent;
    FILETIME            FileAdded;
    LARGE_INTEGER       dwSeconds;
    LARGE_INTEGER       StartTime;
    DWORD               dwActualdDays=0;

    //init
    memset(pNextFileTime, 0, sizeof(FILETIME));

    //conver to the system time
    if(!FileTimeToSystemTime(pCurrentFileTime, &SystemCurrent))
          return;

    //conver the month to year
    while(dwValidMonths >= 12)
    {
        SystemCurrent.wYear++;

        dwValidMonths=dwValidMonths-12;
    }

    SystemCurrent.wMonth = (WORD)(SystemCurrent.wMonth + dwValidMonths);

    if(SystemCurrent.wMonth > 12)
    {
       SystemCurrent.wYear++;
       SystemCurrent.wMonth = SystemCurrent.wMonth -12;
    }
                 
    //make sure the number of days in a month is within the limit
    if(GetDaysForMonth(SystemCurrent.wYear, SystemCurrent.wMonth, &dwActualdDays))
    {
        if(SystemCurrent.wDay > dwActualdDays)
        {
            SystemCurrent.wMonth++;
            SystemCurrent.wDay = SystemCurrent.wDay- (WORD)(dwActualdDays);
        }
    }

    //convert the system file to fileTime
    if(!SystemTimeToFileTime(&SystemCurrent, &FileAdded))
        return;

    //convert the nan-seconds based on the file time
    //// FILETIME is in units of 100 nanoseconds (10**-7)

    dwSeconds.QuadPart=dwValidDays * 24 * 3600;
    dwSeconds.QuadPart=dwSeconds.QuadPart * 10000000;

    StartTime.LowPart=FileAdded.dwLowDateTime;
    StartTime.HighPart=FileAdded.dwHighDateTime;

    StartTime.QuadPart = StartTime.QuadPart + dwSeconds.QuadPart;

    //copy the fileAdded value to *pNextFileTime
    pNextFileTime->dwLowDateTime=StartTime.LowPart;
    pNextFileTime->dwHighDateTime=StartTime.HighPart;

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\ui\wizards\certdsmanager.cpp ===
#include    "wzrdpvk.h"
#include    "CertDSManager.h"

HRESULT CertDSManager::MakeDSManager(OUT CertDSManager **ppDSManager)
{ 
    if (NULL == ppDSManager) 
	return E_INVALIDARG; 
    
    if (NULL == (*ppDSManager = new CachingDSManager))
	return E_OUTOFMEMORY; 

    return (*ppDSManager)->Initialize();
}

//--------------------------------------------------------------------------------
//
// Utility LDAP routines
// 
//--------------------------------------------------------------------------------

HRESULT myRobustLdapBind(OUT LDAP **ppldap)
{
    BOOL      fRediscover     = FALSE; 
    DWORD     dwGetDcFlags    = DS_RETURN_DNS_NAME;
    HRESULT   hr;
    LDAP     *pld             = NULL;
    ULONG     ldaperr;
    ULONG     uVersion        = LDAP_VERSION2; 

    // bind to ds
    for (;;)
    {
	pld = ldap_init(NULL, LDAP_PORT);
	if (NULL == pld)
	{
	    hr = HRESULT_FROM_WIN32(LdapGetLastError()); 
	    if (!fRediscover)
	    {
		fRediscover = TRUE;
		continue;
	    }
	    goto ldap_init_error; 
	}

	if (fRediscover)
	{
	   dwGetDcFlags |= DS_FORCE_REDISCOVERY;
	}

        struct LdapOptions { 
            int    nOption; 
            void  *pvInValue; 
        } rgOptions[] = { 
            { LDAP_OPT_GETDSNAME_FLAGS, &dwGetDcFlags }, 
            { LDAP_OPT_SIGN,            LDAP_OPT_ON }, 
            { LDAP_OPT_VERSION,         &uVersion }
        }; 
        
        for (DWORD dwIndex = 0; dwIndex < (sizeof(rgOptions) / sizeof(rgOptions[0])); dwIndex++) 
        { 
            ldaperr = ldap_set_option(pld, rgOptions[dwIndex].nOption, rgOptions[dwIndex].pvInValue);
            if (LDAP_SUCCESS != ldaperr)
            {
                hr = HRESULT_FROM_WIN32(LdapMapErrorToWin32(ldaperr)); 
                if (!fRediscover)
                {
                    fRediscover = TRUE;
                    goto ContinueBinding;
                }
                goto ldap_set_option_error;
            }
        }

	ldaperr = ldap_bind_s(pld, NULL, NULL, LDAP_AUTH_NEGOTIATE);
	if (LDAP_SUCCESS != ldaperr)
	{
            hr = HRESULT_FROM_WIN32(LdapMapErrorToWin32(ldaperr)); 
	    if (!fRediscover)
	    {
		fRediscover = TRUE;
		goto ContinueBinding;
	    }
	    goto ldap_bind_s_error;
	}

	break;
    ContinueBinding:
	if (NULL != pld)
	{
	    ldap_unbind(pld);
	    pld = NULL; 
	}
    }

    *ppldap = pld;
    pld = NULL;
    hr = S_OK;
    
 ErrorReturn:
    if (NULL != pld)
    {
        ldap_unbind(pld);
    }
    return(hr);

TRACE_ERROR(ldap_bind_s_error); 
TRACE_ERROR(ldap_init_error); 
TRACE_ERROR(ldap_set_option_error); 
}

//--------------------------------------------------------------------------------
//
// CachingDSManager implementation.  
//
//--------------------------------------------------------------------------------

HRESULT CachingDSManager::Initialize() 
{
    HRESULT hr; 

    hr = myRobustLdapBind(&m_ldBindingHandle); 
    _JumpCondition(FAILED(hr), myRobustLdapBindError); 

    hr = DefaultDSManager::Initialize(); 
    _JumpCondition(FAILED(hr), DefaultDSManager__InitializeError); 
    
    hr = S_OK; 
 ErrorReturn:
    return hr; 

TRACE_ERROR(DefaultDSManager__InitializeError); 
TRACE_ERROR(myRobustLdapBindError); 
}

CachingDSManager::~CachingDSManager() 
{
    if (NULL != m_ldBindingHandle) { 
        ldap_unbind(m_ldBindingHandle); 
    }
}

HRESULT CachingDSManager::EnumCertTypesForCA(IN HCAINFO hCAInfo, IN DWORD dwFlags, OUT HCERTTYPE *phCertType)
{
    return ::CAEnumCertTypesForCAEx
        (hCAInfo, 
         (LPCWSTR)m_ldBindingHandle, 
         dwFlags | CT_FLAG_SCOPE_IS_LDAP_HANDLE, 
         phCertType); 
}

HRESULT CachingDSManager::EnumFirstCA(IN LPCWSTR wszScope, IN DWORD dwFlags, OUT HCAINFO *phCAInfo)
{
    HRESULT hr; 

    if (NULL != wszScope) { 
        // We can't muck with the scope parameter.  Just do the default thing.
        hr = DefaultDSManager::EnumFirstCA
            (wszScope, 
             dwFlags, 
             phCAInfo); 
    } else {
        hr = ::CAEnumFirstCA
            ((LPCWSTR)m_ldBindingHandle, 
             dwFlags | CA_FLAG_SCOPE_IS_LDAP_HANDLE, 
             phCAInfo);
    }

    return hr; 
}

HRESULT CachingDSManager::FindCAByName(IN LPCWSTR wszCAName, IN LPCWSTR wszScope, IN DWORD dwFlags,OUT HCAINFO *phCAInfo)
{
    HRESULT hr; 

    if (NULL != wszScope) { 
        // We can't muck with the scope parameter.  Just do the default thing.
        hr = DefaultDSManager::FindCAByName
            (wszCAName, 
             wszScope, 
             dwFlags, 
             phCAInfo);
    } else { 
        hr = ::CAFindByName
            (wszCAName, 
             (LPCWSTR)m_ldBindingHandle, 
             dwFlags | CA_FLAG_SCOPE_IS_LDAP_HANDLE, 
             phCAInfo); 
    }

    return hr; 
}

HRESULT CachingDSManager::FindCertTypeByName(IN LPCWSTR pwszCertType, IN HCAINFO hCAInfo, IN DWORD dwFlags, OUT HCERTTYPE *phCertType)
{
    HRESULT hr; 

    if (NULL != hCAInfo) { 
        // We can't muck with the scope parameter.  Just do the default thing.
        hr = DefaultDSManager::FindCertTypeByName
            (pwszCertType, 
             hCAInfo, 
             dwFlags, 
             phCertType);
    } else { 
        hr = ::CAFindCertTypeByName
            (pwszCertType, 
             m_ldBindingHandle, 
             dwFlags | CT_FLAG_SCOPE_IS_LDAP_HANDLE, 
             phCertType);
    }

    return hr; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\ui\wizards\cautil.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       cautil.cpp
//
//--------------------------------------------------------------------------

#include    "wzrdpvk.h"
#include    "certca.h"
#include    "cautil.h"
#include    "CertRequesterContext.h"
#include    "CertDSManager.h"
#include    "CertRequester.h"

//------------------------------------------------------------
// 
// Utility memory deallocate functions.
//
//------------------------------------------------------------


void CAFreeCertTypeExtensionsArray
(
 IN LPVOID pCertExtensionsArray, 
 int dwArrayLen
 )
{
    for (int i=0; i<dwArrayLen; i++) 
    {
	// Ignore return value. 
	CAFreeCertTypeExtensions(NULL, ((PCERT_EXTENSIONS *)pCertExtensionsArray)[i]); 
    }
}

void WizardFreePDWORDArray
(IN LPVOID pdwArray,
 int dwArrayLen
 )
{
    for (int i=0; i<dwArrayLen; i++) 
    {
	WizardFree(((DWORD **)pdwArray)[i]); 
    }
}
  
void WizardFreeLPWSTRArray
(IN LPVOID pwszArray, 
 int dwArrayLen
 )
{
    for (int i=0; i<dwArrayLen; i++) 
    {
	WizardFree(((LPWSTR *)pwszArray)[i]); 
    }
}

typedef void (* PDEALLOCATOR)(void *, int);

//--------------------------------------------------------------------
//
//  CAUtilGetCADisplayName
//
//--------------------------------------------------------------------
BOOL CAUtilGetCADisplayName(IN  DWORD    dwCAFindFlags,
                            IN  LPWSTR   pwszCAName,
                            OUT LPWSTR  *ppwszCADisplayName)
{
    BOOL            fResult               = FALSE;
    HCAINFO         hCAInfo               = NULL;
    HRESULT         hr                    = E_FAIL;
    LPWSTR         *ppwszDisplayNameProp  = NULL;

    // Input validation: 
    _JumpCondition(NULL == pwszCAName || NULL == ppwszCADisplayName, CLEANUP); 
    
    // Init: 
    *ppwszCADisplayName = NULL;

    hr = CAFindByName
      (pwszCAName, 
       NULL, 
       dwCAFindFlags, 
       &hCAInfo);
    _JumpCondition(NULL == hCAInfo || FAILED(hr), CLEANUP); 
    
    hr=CAGetCAProperty
        (hCAInfo,
         CA_PROP_DISPLAY_NAME,
         &ppwszDisplayNameProp);
    _JumpCondition(NULL == ppwszDisplayNameProp || FAILED(hr), CLEANUP); 
    
    *ppwszCADisplayName = WizardAllocAndCopyWStr(ppwszDisplayNameProp[0]);
    _JumpCondition(NULL == *ppwszCADisplayName, CLEANUP); 
    
    fResult = TRUE;
    
CLEANUP:
    if(NULL != ppwszDisplayNameProp) { CAFreeCAProperty(hCAInfo, ppwszDisplayNameProp); }
    if(NULL != hCAInfo)              { CACloseCA(hCAInfo); }
    
    return fResult;
}

//--------------------------------------------------------------------
//
//   CheckSubjectRequirement
//
//--------------------------------------------------------------------
BOOL    CheckSubjectRequirement(HCERTTYPE hCurCertType, 
                                LPWSTR    pwszInputCertDNName)
{
    DWORD dwFlags;

    //check the subject requirement of the cert type
    if (S_OK != (CAGetCertTypeFlagsEx
		 (hCurCertType,
		  CERTTYPE_SUBJECT_NAME_FLAG, 
		  &dwFlags)))
	return FALSE; 

    // Supported if  
    //   1)  Subject name requirement is not set
    //   2)  Cert DN Name is supplied.
    return 
	(0    == (CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT & dwFlags)) ||
	(NULL != pwszInputCertDNName);
}

//--------------------------------------------------------------------
//
//   Make sure the CSP supported by the cert type is consistent
//   with user's requirement and the local machine's CSP list
//
//--------------------------------------------------------------------
BOOL CheckCertTypeCSP(IN CERT_WIZARD_INFO  *pCertWizardInfo,
                      IN LPWSTR            *ppwszCSPList)
{
    
    DWORD   dwCSPIndex    = 0;
    DWORD   dwGlobalIndex = 0;
    LPWSTR  pwszCSP       = NULL;

    //for UI case, there is no CSP checking
    if(0 == (CRYPTUI_WIZ_NO_UI & (pCertWizardInfo->dwFlags)))
        return TRUE;

    //if the csp list is specfied, we are OK
    if(pCertWizardInfo->pwszProvider)
        return TRUE;

    if(NULL==ppwszCSPList)
        return FALSE;

    for(dwGlobalIndex=0; dwGlobalIndex < pCertWizardInfo->dwCSPCount; dwGlobalIndex++)
    {
        // Loop over the NULL-terminated CSP array...
        for (pwszCSP = ppwszCSPList[dwCSPIndex = 0]; NULL != pwszCSP; pwszCSP = ppwszCSPList[++dwCSPIndex])
        {
            if(0==_wcsicmp(pCertWizardInfo->rgwszProvider[dwGlobalIndex], pwszCSP))
            {
                // A match!  
                return TRUE; 
            }
        }
    }

    // Didn't find a CSP match.
    return FALSE; 
}

//--------------------------------------------------------------------
//
//   CheckCSPRequirement
//
//--------------------------------------------------------------------
BOOL CheckCSPRequirement(IN HCERTTYPE         hCurCertType, 
                         IN CERT_WIZARD_INFO  *pCertWizardInfo)
{
    BOOL     fSupported    = FALSE;
    HRESULT  hr; 
    LPWSTR  *ppwszCSPList  = NULL;

    if (NULL == hCurCertType)
        return FALSE; 

    //get the CSP list from the cert type
    hr = CAGetCertTypeProperty
        (hCurCertType,
         CERTTYPE_PROP_CSP_LIST,
         &ppwszCSPList);
    if (S_OK == hr)
    {
        if (NULL != ppwszCSPList)
	{
	    // The template specifies a CSP list.  See if we can support it.
	    fSupported = CheckCertTypeCSP(pCertWizardInfo, ppwszCSPList);
	}
	else
	{
	    // Any CSP is good.  Just make sure we have one:
	    fSupported = 0 != pCertWizardInfo->dwCSPCount; 
	}
    }
    else
    {
	// Can't get the CSP list.  For UI case, CSP is optional
        if(0 == (CRYPTUI_WIZ_NO_UI & (pCertWizardInfo->dwFlags)))
            fSupported = TRUE;
        else
            //for UILess case, if a CSP is selected, it is also OK
            fSupported = NULL != pCertWizardInfo->pwszProvider; 
    }
    
    //free the properties
    if(NULL != ppwszCSPList) { CAFreeCertTypeProperty(hCurCertType, ppwszCSPList); }

    // All done. 
    return fSupported;
}


//--------------------------------------------------------------------
//
//   Make sure that the CA supports at least one valid cert type
//
//--------------------------------------------------------------------
BOOL IsValidCA(IN CERT_WIZARD_INFO                 *pCertWizardInfo,
               IN PCCRYPTUI_WIZ_CERT_REQUEST_INFO   pCertRequestInfo,
               IN HCAINFO                           hCAInfo)
{
    BOOL            fSupported      = FALSE;
    CertRequester  *pCertRequester  = NULL; 
    CertDSManager  *pDSManager      = NULL; 
    HCERTTYPE       hCurCertType    = NULL;
    HCERTTYPE       hPreCertType    = NULL;
    HRESULT         hr              = E_FAIL;
    
    __try {
        _JumpCondition(NULL == hCAInfo || NULL == pCertWizardInfo || NULL == pCertWizardInfo->hRequester, InvalidArgError);
        pCertRequester        = (CertRequester *)pCertWizardInfo->hRequester; 
        pDSManager            = pCertRequester->GetDSManager(); 
        _JumpCondition(NULL == pDSManager, InvalidArgError);

        if (S_OK != (hr = pDSManager->EnumCertTypesForCA
                     (hCAInfo,
                      (pCertWizardInfo->fMachine ? CT_ENUM_MACHINE_TYPES | CT_FIND_LOCAL_SYSTEM : CT_ENUM_USER_TYPES),
                      &hCurCertType)))
            goto CLEANUP;

        while (NULL != hCurCertType)
        {
            //make sure the principal making this call has access to request
            //this cert type, even if he's requesting on behalf of another.
            fSupported   = CAUtilValidCertTypeNoDS
                (hCurCertType, 
                 pCertRequestInfo->pwszCertDNName, 
                 pCertWizardInfo); 

            // We've found a cert type which we can use for enrollment -- this CA is valid. 
            _JumpCondition(TRUE == fSupported, CLEANUP);
        
            //enum for the next cert types
            hPreCertType = hCurCertType;

            hr = pDSManager->EnumNextCertType
              (hPreCertType,
               &hCurCertType);
            _JumpCondition(S_OK != hr, CLEANUP); 
            
            //free the old cert type
            pDSManager->CloseCertType(hPreCertType);
            hPreCertType = NULL;
        } 

    ErrorReturn:
    CLEANUP:
        if(NULL != hCurCertType) { CACloseCertType(hCurCertType); }
        if(NULL != hPreCertType) { CACloseCertType(hPreCertType); }
        goto CommonReturn;
    
    SET_ERROR(InvalidArgError, E_INVALIDARG);
    
    CommonReturn:;
    
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        SetLastError(GetExceptionCode());
        fSupported = FALSE;
    }

    return fSupported;
}

BOOL CAUtilGetCertTypeNameNoDS(IN  HCERTTYPE  hCertType, 
			       OUT LPWSTR    *ppwszCTName)
{
    BOOL     fResult       = FALSE; 
    HRESULT  hr; 
    LPWSTR  *ppwszNameProp = NULL; 
    
    _JumpCondition(NULL == hCertType || NULL == ppwszCTName, InvalidArgErr); 

    // Init input params: 
    *ppwszCTName = NULL; 

    //get the machine readable form
    hr = CAGetCertTypePropertyEx
	(hCertType,
	 CERTTYPE_PROP_DN,
	 &ppwszNameProp);

    _JumpCondition(S_OK != hr, CertCliErr); 
    _JumpConditionWithExpr(NULL == ppwszNameProp, CertCliErr, S_OK == hr ? hr = E_FAIL : hr);
    _JumpConditionWithExpr(NULL == ppwszNameProp[0], CertCliErr, hr = E_FAIL); 
    
    *ppwszCTName = WizardAllocAndCopyWStr(ppwszNameProp[0]);
    _JumpCondition(NULL==(*ppwszCTName), MemoryErr); 

    fResult = TRUE; 
 CommonReturn:
    if(NULL != ppwszNameProp) { CAFreeCAProperty(hCertType, ppwszNameProp); } 
    return fResult; 

 ErrorReturn:
    if (NULL != ppwszCTName && NULL != *ppwszCTName) { WizardFree(*ppwszCTName); }  
    goto CommonReturn; 

SET_ERROR(MemoryErr, E_OUTOFMEMORY); 
SET_ERROR(InvalidArgErr, E_INVALIDARG); 
SET_ERROR_VAR(CertCliErr, hr);
}

//--------------------------------------------------------------------
//
//From the API's cert type name, get the real machine readable name
//
//---------------------------------------------------------------------
BOOL CAUtilGetCertTypeName(CERT_WIZARD_INFO      *pCertWizardInfo,
                           LPWSTR                pwszAPIName,
                           LPWSTR                *ppwszCTName)
{
    BOOL                        fResult         = FALSE;
    CertDSManager              *pDSManager      = NULL; 
    CertRequester              *pCertRequester  = NULL; 
    DWORD                       dwException     = 0;
    HCERTTYPE                   hCertType       = NULL;
    HRESULT                     hr              = S_OK;
    
    _JumpCondition(NULL == pCertWizardInfo || NULL == pCertWizardInfo->hRequester, InvalidArgError);

    pCertRequester = (CertRequester *)pCertWizardInfo->hRequester; 
    pDSManager     = pCertRequester->GetDSManager(); 
    _JumpCondition(NULL == pDSManager, InvalidArgError);

    __try {
	
	//get the handle based on name
	hr= pDSManager->FindCertTypeByName
	    (pwszAPIName,
	     NULL,
	     (pCertWizardInfo->fMachine?CT_ENUM_MACHINE_TYPES|CT_FIND_LOCAL_SYSTEM:CT_ENUM_USER_TYPES),
	     &hCertType);
	_JumpCondition(S_OK != hr, CertCliErr); 
        _JumpConditionWithExpr(NULL == hCertType, CertCliErr, S_OK == hr ? hr = E_FAIL : hr); 

        fResult = CAUtilGetCertTypeNameNoDS(hCertType, ppwszCTName);
	_JumpConditionWithExpr(FALSE == fResult, CertCliErr, hr = GetLastError()); 
 
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        dwException = GetExceptionCode();
        goto ExceptionErr;
    }

    fResult = TRUE;

CommonReturn:
    //free the memory
    __try{
	if(NULL != hCertType) { pDSManager->CloseCertType(hCertType); } 
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        SetLastError(GetExceptionCode());
    }

    return fResult;

ErrorReturn:
    fResult = FALSE; 
    goto CommonReturn;

SET_ERROR_VAR(CertCliErr, hr);
SET_ERROR_VAR(ExceptionErr, dwException);
SET_ERROR_VAR(InvalidArgError, E_INVALIDARG); 
}


BOOL CAUtilValidCertTypeNoDS(HCERTTYPE         hCertType,
			     LPWSTR            pwszCertDNName, 
			     CERT_WIZARD_INFO *pCertWizardInfo)
{
    BOOL                   fResult               = FALSE; 
    CertRequester         *pCertRequester        = NULL;
    CertRequesterContext  *pCertRequesterContext = NULL;
    
    _JumpCondition(hCertType == NULL || pCertWizardInfo == NULL || NULL == pCertWizardInfo->hRequester, InvalidArgError); 

    pCertRequester        = (CertRequester *)pCertWizardInfo->hRequester; 
    pCertRequesterContext = pCertRequester->GetContext();
    _JumpCondition(NULL == pCertRequesterContext, InvalidArgError);

    //check the subject requirements
    _JumpCondition(FALSE == CheckSubjectRequirement(hCertType, pwszCertDNName), InvalidArgError);

    //check for the permission of the cert type
    _JumpCondition(FALSE == pCertRequesterContext->CheckAccessPermission(hCertType), AccessDeniedError);

    //check for the CSP permission of the cert type
    _JumpCondition(FALSE == CheckCSPRequirement(hCertType, pCertWizardInfo), InvalidArgError); 
    
    fResult = TRUE; 

 CommonReturn: 
    return fResult;

 ErrorReturn: 
    fResult = FALSE;
    goto CommonReturn; 

SET_ERROR_VAR(AccessDeniedError,  E_ACCESSDENIED);
SET_ERROR_VAR(InvalidArgError,    E_INVALIDARG); 
}



//--------------------------------------------------------------------
//
//   Verify that the user has the correct permision to 
//   ask for the requested certificatd types
//
//--------------------------------------------------------------------
BOOL    CAUtilValidCertType(IN PCCRYPTUI_WIZ_CERT_REQUEST_INFO    pCertRequestInfo,
                            IN CERT_WIZARD_INFO                   *pCertWizardInfo)
{
    BOOL                        fResult         = FALSE;
    CertDSManager              *pDSManager      = NULL; 
    CertRequester              *pCertRequester  = NULL; 
    DWORD                       dwException     = 0;
    DWORD                       dwCertTypeIndex = 0;
    HCERTTYPE                   hCertType       = NULL;
    HRESULT                     hr              = S_OK;
    PCCRYPTUI_WIZ_CERT_TYPE     pCertType       = NULL;

    _JumpCondition(NULL == pCertWizardInfo || NULL == pCertWizardInfo->hRequester, InvalidArgError);

    pCertRequester = (CertRequester *)pCertWizardInfo->hRequester; 
    pDSManager     = pCertRequester->GetDSManager(); 
    _JumpCondition(NULL == pDSManager, InvalidArgError); 

    __try {

	//enum all the cert types.  For each of them, 
	//1. Has the correct permission
	//2. Has the correct subject requirement
        if(NULL != pCertRequestInfo)
        {
            if(CRYPTUI_WIZ_CERT_REQUEST_CERT_TYPE == pCertRequestInfo->dwCertChoice)
            {
                pCertType = pCertRequestInfo->pCertType;

                for(dwCertTypeIndex=0; dwCertTypeIndex <pCertType->cCertType; dwCertTypeIndex++)
                {
                    DWORD dwFlags = CT_FIND_BY_OID; 
                    dwFlags |= pCertWizardInfo->fMachine ? CT_ENUM_MACHINE_TYPES | CT_FIND_LOCAL_SYSTEM : CT_ENUM_USER_TYPES; 

                    //get the handle based on OID
                    hr= pDSManager->FindCertTypeByName
                        (pCertType->rgwszCertType[dwCertTypeIndex],
                         NULL,
                         dwFlags, 
                         &hCertType);
                    if (S_OK != hr)
                    {
                        // get the handle based on name: 
                        dwFlags &= ~CT_FIND_BY_OID; 
                        hr = pDSManager->FindCertTypeByName
                            (pCertType->rgwszCertType[dwCertTypeIndex],
                             NULL,
                             dwFlags, 
                             &hCertType);
                    }

                    _JumpCondition(S_OK != hr, CertCliErr); 
                    _JumpConditionWithExpr(NULL == hCertType, CertCliErr, hr == S_OK ? hr = E_FAIL : hr); 

                    if (!CAUtilValidCertTypeNoDS(hCertType, pCertRequestInfo->pwszCertDNName, pCertWizardInfo))
                    {
                        hr = GetLastError(); 
                        goto CertCliErr; 
                    }
                    
                    //free the cert type
                    if(NULL != hCertType)
                    {
                        pDSManager->CloseCertType(hCertType);
                        hCertType = NULL;
                    }
                }
            }
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        dwException = GetExceptionCode();
        goto ExceptionErr;
    }
    
    fResult = TRUE;

CommonReturn:
    return fResult;

ErrorReturn:
    __try {
	if(NULL != hCertType) { pDSManager->CloseCertType(hCertType); } 
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        SetLastError(GetExceptionCode());
    }

    fResult = FALSE; 
    goto CommonReturn;

SET_ERROR_VAR(CertCliErr, hr);
SET_ERROR_VAR(ExceptionErr, dwException)
SET_ERROR_VAR(InvalidArgError, E_INVALIDARG);
}

//--------------------------------------------------------------------
//
//Retrieve a list of CAs that supports at least one valid cert types
//
//---------------------------------------------------------------------
BOOL    CAUtilRetrieveCAFromCertType(
            CERT_WIZARD_INFO                   *pCertWizardInfo,
            PCCRYPTUI_WIZ_CERT_REQUEST_INFO    pCertRequestInfo,
            BOOL                               /*fMultipleCA*/,              //only need one CA
            DWORD                              dwNameFlag,
            DWORD                              *pdwCACount,
            LPWSTR                             **ppwszCALocation,    
            LPWSTR                             **ppwszCAName)
{
    BOOL                        fResult=FALSE;
    CertDSManager              *pDSManager=NULL; 
    CertRequesterContext       *pCertRequesterContext = NULL; 
    DWORD                       dwCACount=0;
    DWORD                       dwValidCACount=0;
    DWORD                       dwCAIndex=0;
    HRESULT                     hr=E_FAIL;

    HCAINFO                     hCurCAInfo=NULL;
    HCAINFO                     hPreCAInfo=NULL;
    LPWSTR                      *ppwszNameProp=NULL;
    LPWSTR                      *ppwszLocationProp=NULL;

    LPWSTR                      pwszDNName=NULL;
    PCCERT_CONTEXT              pCertContext=NULL;
    DWORD                       dwSize=0;
    DWORD                       dwException=0;


    //input param checking
    if(!pdwCACount || !ppwszCALocation || !ppwszCAName) { 
	SetLastError(ERROR_INVALID_PARAMETER); 
	return FALSE;
    }

    //init
    *pdwCACount=0;
    *ppwszCALocation=NULL;
    *ppwszCAName=NULL;

    __try {

    //get a CA from the DS
    if(NULL != pCertWizardInfo)
    {
        CertRequester * pCertRequester = (CertRequester *)pCertWizardInfo->hRequester;
        _JumpCondition(NULL == pCertRequester, InvalidArgErr); 

        pCertRequesterContext = pCertRequester->GetContext(); 
        _JumpCondition(NULL == pCertRequesterContext, InvalidArgErr); 
        
	pDSManager = pCertRequester->GetDSManager(); 
	_JumpCondition(NULL == pDSManager, InvalidArgErr); 

        hr=pDSManager->EnumFirstCA(
            NULL,
            (pCertWizardInfo->fMachine?CA_FIND_LOCAL_SYSTEM:0),
            &hCurCAInfo);
        _JumpCondition(S_OK != hr, CAEnumCAErr);
        _JumpCondition(NULL == hCurCAInfo, CAEnumCAErrNotFound); 

    }
    else
    {
        //this is for SelCA API where pCertWizardInfo is NULL
        hr = CAEnumFirstCA
            (NULL,
             (CRYPTUI_DLG_SELECT_CA_LOCAL_MACHINE_ENUMERATION & dwNameFlag) ? CA_FIND_LOCAL_SYSTEM:0,
             &hCurCAInfo);
        _JumpCondition(S_OK != hr, CAEnumCAErr);
        _JumpCondition(NULL == hCurCAInfo, CAEnumCAErrNotFound); 
        
        if (S_OK != CertRequesterContext::MakeDefaultCertRequesterContext(&pCertRequesterContext))
            goto UnexpectedErr; 
    }

    //get the CA count
    dwCACount = CACountCAs(hCurCAInfo);
    _JumpConditionWithExpr(0 == dwCACount, CertCliErr, hr = E_FAIL); 

    //memory allocation and memset
    *ppwszCALocation=(LPWSTR *)WizardAlloc(sizeof(LPWSTR) * dwCACount);
    _JumpCondition(NULL == *ppwszCALocation, MemoryErr); 
    memset(*ppwszCALocation, 0, sizeof(LPWSTR) * dwCACount);

    *ppwszCAName=(LPWSTR *)WizardAlloc(sizeof(LPWSTR) * dwCACount);
    _JumpCondition(NULL == *ppwszCAName, MemoryErr); 
    memset(*ppwszCAName, 0, sizeof(LPWSTR) * dwCACount);

    dwValidCACount = 0;

    //enum all the CAs available on the DS
    for(dwCAIndex = 0; dwCAIndex < dwCACount; dwCAIndex++)
    {
        //make sure the CA supports all the cert types
        if(NULL != pCertRequestInfo)
        {
            // Skip this CA if it is not valid. 
            _JumpCondition(FALSE == IsValidCA(pCertWizardInfo, pCertRequestInfo, hCurCAInfo), next); 
        }
        
        // Skip this CA if the user does not have access rights to it. 
        _JumpCondition(FALSE == pCertRequesterContext->CheckCAPermission(hCurCAInfo), next); 
        
        //copy the CA name and location
        
        //get the CA's CN or DN based on dwNameFlag
        if(CRYPTUI_DLG_SELECT_CA_USE_DN & dwNameFlag)
        {
            //get the CA's certificate
            hr = CAGetCACertificate(hCurCAInfo, &pCertContext);
            
            _JumpCondition(S_OK != hr, CertCliErr); 
            _JumpConditionWithExpr(NULL==pCertContext, CertCliErr, S_OK == hr ? hr = E_FAIL : hr);

            //get the DN name
            dwSize = CertNameToStrW(pCertContext->dwCertEncodingType,
                                    &(pCertContext->pCertInfo->Subject),
                                    CERT_X500_NAME_STR,
                                    NULL,
                                    0);

            _JumpCondition(0 == dwSize, TraceErr);

            pwszDNName=(LPWSTR)WizardAlloc(dwSize * sizeof(WCHAR));
            _JumpCondition(NULL==pwszDNName, MemoryErr);

            dwSize = CertNameToStrW(pCertContext->dwCertEncodingType,
                                    &(pCertContext->pCertInfo->Subject),
                                    CERT_X500_NAME_STR,
                                    pwszDNName,
                                    dwSize);
            
            _JumpCondition(0==dwSize, TraceErr);

            //copy the name
            (*ppwszCAName)[dwValidCACount]=WizardAllocAndCopyWStr(pwszDNName);
            _JumpCondition(NULL==(*ppwszCAName)[dwValidCACount], TraceErr);

            WizardFree(pwszDNName);
            pwszDNName = NULL;

            CertFreeCertificateContext(pCertContext);
            pCertContext = NULL;
        }
        else
        {
            hr = CAGetCAProperty(
                hCurCAInfo,
                CA_PROP_NAME,
                &ppwszNameProp);

            _JumpCondition(S_OK != hr, CertCliErr); 
            _JumpConditionWithExpr(NULL == ppwszNameProp, CertCliErr, S_OK == hr ? hr = E_FAIL : hr); 

            //copy the name
            (*ppwszCAName)[dwValidCACount] = WizardAllocAndCopyWStr(ppwszNameProp[0]);
            _JumpCondition(NULL == (*ppwszCAName)[dwValidCACount], TraceErr);

            //free the property
            CAFreeCAProperty(hCurCAInfo, ppwszNameProp);
            ppwszNameProp = NULL;
        }

        //get the location
        hr = CAGetCAProperty
            (hCurCAInfo,
             CA_PROP_DNSNAME,
             &ppwszLocationProp);
        
        _JumpCondition(S_OK != hr, CertCliErr); 
        _JumpConditionWithExpr(NULL == ppwszLocationProp, CertCliErr, S_OK == hr ? hr = E_FAIL : hr); 
    
        //copy the name
        (*ppwszCALocation)[dwValidCACount]=WizardAllocAndCopyWStr(ppwszLocationProp[0]);
        _JumpCondition(NULL == (*ppwszCALocation)[dwValidCACount], TraceErr);

        //free the property
        CAFreeCAProperty(hCurCAInfo, ppwszLocationProp);
        ppwszLocationProp = NULL;

        //increment the count
        dwValidCACount++;

    next:
        //enum for the CA
        hPreCAInfo = hCurCAInfo;

        hr = CAEnumNextCA
          (hPreCAInfo,
           &hCurCAInfo);

        //free the old CA Info
        CACloseCA(hPreCAInfo);
        hPreCAInfo=NULL;

        if((S_OK != hr) || (NULL==hCurCAInfo))
            break;
    }

    *pdwCACount = dwValidCACount;
    _JumpConditionWithExpr(0 == (*pdwCACount), CertCliErr, hr = E_FAIL); 

    } __except(EXCEPTION_EXECUTE_HANDLER) {
        dwException = GetExceptionCode();
        goto ExceptionErr;
    }

    fResult = TRUE;

CommonReturn:

    //free memory
    __try {
        if(NULL != ppwszNameProp)     { CAFreeCAProperty(hCurCAInfo, ppwszNameProp); }
        if(NULL != ppwszLocationProp) { CAFreeCAProperty(hCurCAInfo, ppwszLocationProp); }
        if(NULL != hPreCAInfo)        { CACloseCA(hPreCAInfo); }
        if(NULL != hCurCAInfo)        { CACloseCA(hCurCAInfo); }

    } __except(EXCEPTION_EXECUTE_HANDLER) {
        SetLastError(GetExceptionCode());
    }

    if(NULL != pwszDNName)   { WizardFree(pwszDNName); }
    if(NULL != pCertContext) { CertFreeCertificateContext(pCertContext); }

    return fResult;

ErrorReturn:

    //free the memory in failure case
    if(NULL != ppwszCALocation && NULL != *ppwszCALocation)
    {
        for(dwCAIndex=0; dwCAIndex < dwCACount; dwCAIndex++)
        {
            if(NULL != (*ppwszCALocation)[dwCAIndex]) { WizardFree((*ppwszCALocation)[dwCAIndex]); }
        }

        WizardFree(*ppwszCALocation);
        *ppwszCALocation = NULL;
    }

    if(NULL != ppwszCAName && NULL != *ppwszCAName)
    {
        for(dwCAIndex=0; dwCAIndex < dwCACount; dwCAIndex++)
        {
            if(NULL != (*ppwszCAName)[dwCAIndex]) { WizardFree((*ppwszCAName)[dwCAIndex]); }
        }

        WizardFree(*ppwszCAName);
        *ppwszCAName = NULL;
    }

    fResult = FALSE; 
    goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
SET_ERROR_VAR(CertCliErr, hr);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
TRACE_ERROR(TraceErr);
SET_ERROR_VAR(CAEnumCAErr, hr);
SET_ERROR(CAEnumCAErrNotFound, ERROR_DS_OBJ_NOT_FOUND); 
SET_ERROR_VAR(ExceptionErr, dwException)
SET_ERROR(UnexpectedErr, E_UNEXPECTED);
}


//--------------------------------------------------------------------
//
//Based on the CA name and CA location, get a list of certificate type
//and their extensions
//
//  1. Check the permission of the cert types
//  2. Check the subject requirement of the cert types
//---------------------------------------------------------------------

BOOL    CAUtilGetCertTypeNameAndExtensionsNoDS
(
 CERT_WIZARD_INFO                    *pCertWizardInfo,
 LPWSTR                               pwszCertDNName, 
 HCERTTYPE                            hCertType, 
 LPWSTR                              *ppwszCertType,
 LPWSTR                              *ppwszDisplayCertType,
 PCERT_EXTENSIONS                    *pCertExtensions,
 DWORD                               *pdwKeySpec,
 DWORD                               *pdwMinKeySize, 
 DWORD                               *pdwCSPCount,
 DWORD                              **ppdwCSPList,
 DWORD                               *pdwRASignature, 
 DWORD                               *pdwEnrollmentFlags, 
 DWORD                               *pdwSubjectNameFlags,
 DWORD                               *pdwPrivateKeyFlags,
 DWORD                               *pdwGeneralFlags)
{
    BOOL                   fResult                   = FALSE; 
    CertRequester         *pCertRequester            = NULL;
    CertRequesterContext  *pCertRequesterContext     = NULL; 
    DWORD                  dwGlobalIndex             = 0;
    DWORD                  dwLastError               = ERROR_SUCCESS; 
    DWORD                  dwCSPIndex                = 0;
    DWORD                  dwFlags                   = 0;
    DWORD                  dwKeySpec                 = 0;
    DWORD                  dwEnrollmentFlags;
    DWORD                  dwSubjectNameFlags;
    DWORD                  dwPrivateKeyFlags;
    DWORD                  dwGeneralFlags; 
    DWORD                  dwSchemaVersion; 
    HRESULT                hr                        = S_OK; 
    LPWSTR                 pwszCSP                   = NULL;
    LPWSTR                *ppwszCSP                  = NULL; 
    LPWSTR                *ppwszDisplayCertTypeName  = NULL;
    LPWSTR                *ppwszCertTypeName         = NULL;

    // Input validation: 
    if (NULL == pCertWizardInfo    || NULL == pCertWizardInfo->hRequester  ||
        NULL == ppwszCertType      || NULL == ppwszDisplayCertType         || 
	NULL == pCertExtensions    || NULL == pdwKeySpec                   ||
	NULL == pdwMinKeySize      || NULL == pdwCSPCount                  ||
	NULL == ppdwCSPList        || NULL == pdwRASignature               ||
	NULL == pdwEnrollmentFlags || NULL == pdwSubjectNameFlags          ||
	NULL == pdwPrivateKeyFlags || NULL == pdwGeneralFlags)
    {
	SetLastError(ERROR_INVALID_PARAMETER); 
	return FALSE; 
    }
    
    // Init: 
    *ppwszDisplayCertType = NULL;
    *ppwszCertType        = NULL; 
    *pCertExtensions      = NULL;
    *pdwKeySpec           = NULL;
    *pdwMinKeySize        = NULL;
    *pdwCSPCount          = NULL;
    *ppdwCSPList          = NULL;
    *pdwRASignature       = NULL;
    *pdwEnrollmentFlags   = NULL;
    *pdwSubjectNameFlags  = NULL;
    *pdwPrivateKeyFlags   = NULL;
    *pdwGeneralFlags      = NULL; 

    pCertRequester        = (CertRequester *)pCertWizardInfo->hRequester; 
    pCertRequesterContext = pCertRequester->GetContext();
    _JumpCondition(NULL == pCertRequesterContext, InvalidArgError); 

    // check the subject requirement of the cert type
    _JumpCondition(!CheckSubjectRequirement(hCertType,pwszCertDNName), CommonReturn);
	    
    //check for the key specification of the cert type
    //we do not care about the return value.  Since it will be set to 0
    //if the function failed.
    CAGetCertTypeKeySpec(hCertType, &dwKeySpec);
	    
    //check for the CSP requirement of the cert type
    if((S_OK ==(hr=CAGetCertTypeProperty(hCertType, 
					 CERTTYPE_PROP_CSP_LIST,
					 &ppwszCSP)))&&
       (NULL!=ppwszCSP)
       )
    {
	_JumpCondition(!CheckCertTypeCSP(pCertWizardInfo, ppwszCSP), CommonReturn);
    }
	    
    //check for the permission of the cert type
    _JumpCondition(FALSE == pCertRequesterContext->CheckAccessPermission(hCertType), CommonReturn);
	    
    //now, we have found a valid cert type.
    //copy Display name, extension, key spec, dwCertTypeFlag, 
    //the CSP list
	    
    // 
    // First, get all applicable cert type flags: 
    //
    
    // Get enrollment flags:
    if (S_OK != (hr=CAGetCertTypeFlagsEx
		 (hCertType,
		  CERTTYPE_ENROLLMENT_FLAG, 
		  &dwEnrollmentFlags)))
	goto CertCliErr;
	    
    // Get subject name flags: 
    if (S_OK != (hr=CAGetCertTypeFlagsEx
		 (hCertType,
		  CERTTYPE_SUBJECT_NAME_FLAG, 
		  &dwSubjectNameFlags)))
	goto CertCliErr;
	
    // Get private key flags.  
    if(S_OK != (hr = CAGetCertTypeFlagsEx
		(hCertType, 
		 CERTTYPE_PRIVATE_KEY_FLAG, 
		 &dwPrivateKeyFlags)))
	goto CertCliErr;
	    
    // Get general flags:
    if (S_OK != (hr=CAGetCertTypeFlagsEx
		 (hCertType,
		  CERTTYPE_GENERAL_FLAG,
		  &dwGeneralFlags)))
	goto CertCliErr;

    // Filter out CT where subject name or subject alt name must be supplied.  
    if (dwSubjectNameFlags & 
	(CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT           | 
	 CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT_ALT_NAME
	 ))
	goto BadTemplateError; 

    *pdwEnrollmentFlags   = dwEnrollmentFlags; 
    *pdwSubjectNameFlags  = dwSubjectNameFlags;
    *pdwPrivateKeyFlags   = dwPrivateKeyFlags;
    *pdwGeneralFlags      = dwGeneralFlags; 
 
 
    //get the display name of the cert type
    hr = CAGetCertTypeProperty
	(hCertType,
	 CERTTYPE_PROP_FRIENDLY_NAME,
	 &ppwszDisplayCertTypeName);
    
    _JumpCondition(S_OK != hr, CertCliErr); 
    _JumpConditionWithExpr(NULL == ppwszDisplayCertTypeName, CertCliErr, hr = E_FAIL); 

    //copy the name
    *ppwszDisplayCertType = WizardAllocAndCopyWStr(ppwszDisplayCertTypeName[0]);
    _JumpCondition(NULL == *ppwszDisplayCertType, MemoryError);
	    
    //get the machine readable name of the cert type
    hr=CAGetCertTypeProperty
	(hCertType,
	 CERTTYPE_PROP_DN,
	 &ppwszCertTypeName);
	    
    _JumpCondition(S_OK != hr, CertCliErr); 
    _JumpConditionWithExpr(NULL == ppwszCertTypeName, CertCliErr, hr = E_FAIL); 

    //copy the name
    *ppwszCertType = WizardAllocAndCopyWStr(ppwszCertTypeName[0]);
    _JumpCondition(NULL == *ppwszCertType, TraceError);
    
    //copy the dwKeySpec
    *pdwKeySpec = dwKeySpec;
	    
    //
    // Assign V2 Properties.  
    // If the current cert type is a V1 cert type, use default values.
    // Otherwise, get the properties from the CA. 
    // 
    if (S_OK != (hr=CAGetCertTypePropertyEx
		 (hCertType,
		  CERTTYPE_PROP_SCHEMA_VERSION,
		  &dwSchemaVersion)))
	goto CertCliErr; 
	    
    if (dwSchemaVersion == CERTTYPE_SCHEMA_VERSION_1)
    {
	// NULL out the left half-word.  This indicates that the min
	// key size is not specified, and should be defaulted during
	// enrollment.  
	*pdwMinKeySize  = 0; 
	// Set requird number of required RA signatures to 0 (default). 
	*pdwRASignature = 0; 
    }
    else if (dwSchemaVersion == CERTTYPE_SCHEMA_VERSION_2) 
    {
	// Get the minimum key size from the CA
	if (S_OK != (hr=CAGetCertTypePropertyEx
		     (hCertType,
		      CERTTYPE_PROP_MIN_KEY_SIZE, 
		      &dwFlags)))
	    goto CertCliErr; 
	
	// Copy the minimum key size.  The minimum key size is stored in the 
	// top half-word of the type flags.  
	*pdwMinKeySize |= dwFlags; 
		
	// Get the number of required RA signatures from the CA
	if (S_OK != (hr=CAGetCertTypePropertyEx
		     (hCertType,
		      CERTTYPE_PROP_RA_SIGNATURE,
		      pdwRASignature)))
	    goto CertCliErr;
    }

    // Filter out CTs which require RA signatures.  
    if (*pdwRASignature > 0)
    {
        if (0 != (CRYPTUI_WIZ_NO_UI & pCertWizardInfo->dwFlags))
        {
            // In the no-UI case, we assume that the caller knows what they
            // are doing. 
        }
        else
        {
            if ((0 != (CRYPTUI_WIZ_CERT_RENEW                            & pCertWizardInfo->dwPurpose)) && 
                (0 != (CT_FLAG_PREVIOUS_APPROVAL_VALIDATE_REENROLLMENT   & dwEnrollmentFlags)))
            {
                // Special case: we're doing a renew, and the previous approval for this cert
                // validates future re-enrollments.  We don't _really_ need RA sigs. 
            }
            else
	    {
                // This CT requires RA signatures.  Filter it out: 
		goto BadTemplateError;  
            }
        }
    }	    

    // copy the necessary extensions
    if (S_OK != (hr = CAGetCertTypeExtensionsEx
		(hCertType,
                 CT_EXTENSION_TEMPLATE, 
                 NULL,
		 &(*pCertExtensions))))
	goto CertCliErr;

    //set up the CSP list.  It will be a DWORD array index to the 
    //global CSP list
    *ppdwCSPList = (DWORD *)WizardAlloc(sizeof(DWORD) * (pCertWizardInfo->dwCSPCount));
    _JumpCondition(NULL == (*ppdwCSPList), MemoryError); 

    memset((*ppdwCSPList), 0 ,sizeof(DWORD) * (pCertWizardInfo->dwCSPCount)); 
	    
    if (NULL == ppwszCSP || NULL == ppwszCSP[0])
    {
	// no specified CSPs on the templates means that all are allowed:
	for(dwGlobalIndex=0; dwGlobalIndex < pCertWizardInfo->dwCSPCount; dwGlobalIndex++)
	{
	    (*ppdwCSPList)[(*pdwCSPCount)]=dwGlobalIndex;
	    (*pdwCSPCount)++;
	}
    }
    else
    {
	//loop through the CSP list and build the index array
	//we should have at least on item in the index array since
	//we have checked the certtype before
	for (pwszCSP = ppwszCSP[dwCSPIndex = 0]; NULL != pwszCSP; pwszCSP = ppwszCSP[++dwCSPIndex])
        {
	    for(dwGlobalIndex=0; dwGlobalIndex < pCertWizardInfo->dwCSPCount; dwGlobalIndex++)
            {
		if(0==_wcsicmp(pCertWizardInfo->rgwszProvider[dwGlobalIndex], pwszCSP))
                {
		    (*ppdwCSPList)[(*pdwCSPCount)]=dwGlobalIndex;
		    (*pdwCSPCount)++;
		}
	    }
	}       
    }     

    fResult = TRUE; 

 CommonReturn: 
    SetLastError(dwLastError); 

    if (NULL != ppwszCSP)                 { CAFreeCertTypeProperty(hCertType, ppwszCSP); } 
    if (NULL != ppwszDisplayCertTypeName) { CAFreeCertTypeProperty(hCertType, ppwszDisplayCertTypeName); } 
    if (NULL != ppwszCertTypeName)        { CAFreeCertTypeProperty(hCertType, ppwszCertTypeName); }

    return fResult; 

 ErrorReturn: 
    if (NULL != ppwszDisplayCertType && NULL != *ppwszDisplayCertType) { 
	WizardFree(*ppwszDisplayCertType); 
	*ppwszDisplayCertType = NULL;
    }
    if (NULL != ppwszCertType && NULL != *ppwszCertType) { 
	WizardFree(*ppwszCertType); 
	*ppwszCertType = NULL;
    }
    if (NULL != ppdwCSPList && NULL != *ppdwCSPList) { 
	WizardFree(*ppdwCSPList);
	*ppdwCSPList = NULL;
    }
    dwLastError = hr; 
    goto CommonReturn; 

SET_HRESULT(BadTemplateError,  E_INVALIDARG); // approximate error
SET_HRESULT(InvalidArgError,   E_INVALIDARG);
SET_HRESULT(MemoryError,       E_OUTOFMEMORY);
TRACE_ERROR(CertCliErr);
TRACE_ERROR(TraceError);
}



BOOL    CAUtilGetCertTypeNameAndExtensions(
         CERT_WIZARD_INFO                   *pCertWizardInfo,
         PCCRYPTUI_WIZ_CERT_REQUEST_INFO    pCertRequestInfo,
         LPWSTR                             pwszCALocation,
         LPWSTR                             pwszCAName,
         DWORD                              *pdwCertType,
         LPWSTR                             **ppwszCertType,
         LPWSTR                             **ppwszDisplayCertType,
         PCERT_EXTENSIONS                   **ppCertExtensions,
         DWORD                              **ppdwKeySpec,
         DWORD                              **ppdwMinKeySize, 
         DWORD                              **ppdwCSPCount,
         DWORD                              ***ppdwCSPList,
	 DWORD                              **ppdwRASignature, 
	 DWORD                              **ppdwEnrollmentFlags, 
	 DWORD                              **ppdwSubjectNameFlags,
	 DWORD                              **ppdwPrivateKeyFlags,
	 DWORD                              **ppdwGeneralFlags)
{
    BOOL            fResult                   = FALSE;
    CertDSManager  *pDSManager                = NULL;
    CertRequester  *pCertRequester            = NULL;
    DWORD           dwCertTypeCount           = 0;
    DWORD           dwException               = 0;    
    DWORD           dwIndex                   = 0;
    DWORD           dwValidCertType           = 0;
    HCAINFO         hCAInfo                   = NULL;
    HCERTTYPE       hCurCertType              = NULL;
    HCERTTYPE       hPreCertType              = NULL;
    HRESULT         hr                        = S_OK;
    LPWSTR         *ppwszCertTypeName         = NULL;
    LPWSTR         *ppwszDisplayCertTypeName  = NULL;

    // 
    // Construct tables to hold arrays we'll be manipulating.  
    // These tables are used to allocate the arrays, deallocate the arrays, and dealloate
    // the array elements (if necessary).
    // 

    typedef struct _CAUTIL_CERTTYPE_ELEM_ARRAY { 
        LPVOID         *lpvArray;
        DWORD           dwElemSize; 
        PDEALLOCATOR    pElemDeallocator; 
    } CAUTIL_CERTTYPE_ELEM_ARRAY; 

    CAUTIL_CERTTYPE_ELEM_ARRAY certTypeElemArrays[] = { 
	{ (LPVOID *)ppwszDisplayCertType, sizeof (LPWSTR),            WizardFreeLPWSTRArray          },
	{ (LPVOID *)ppwszCertType,        sizeof (LPWSTR),            WizardFreeLPWSTRArray          },
        { (LPVOID *)ppCertExtensions,     sizeof (PCERT_EXTENSIONS),  CAFreeCertTypeExtensionsArray  },
	{ (LPVOID *)ppdwKeySpec,          sizeof (DWORD),             NULL                           },
	{ (LPVOID *)ppdwMinKeySize,       sizeof (DWORD),             NULL                           },
	{ (LPVOID *)ppdwCSPCount,         sizeof (DWORD),             NULL                           },
        { (LPVOID *)ppdwCSPList,          sizeof (DWORD *),           WizardFreePDWORDArray          },
	{ (LPVOID *)ppdwRASignature,      sizeof (DWORD),             NULL                           },
	{ (LPVOID *)ppdwEnrollmentFlags,  sizeof (DWORD),             NULL                           },
	{ (LPVOID *)ppdwSubjectNameFlags, sizeof (DWORD),             NULL                           },
	{ (LPVOID *)ppdwPrivateKeyFlags,  sizeof (DWORD),             NULL                           },
	{ (LPVOID *)ppdwGeneralFlags,     sizeof (DWORD),             NULL                           }
    }; 

    DWORD const dwNumCTElemArrays = sizeof(certTypeElemArrays) / sizeof(certTypeElemArrays[0]); 

    if (NULL == pCertWizardInfo || NULL == pCertRequestInfo || 
	NULL == pwszCALocation  || NULL == pwszCAName       ||
	NULL == pdwCertType)
    {
	SetLastError(ERROR_INVALID_PARAMETER);
	return FALSE;
    }

    pCertRequester = (CertRequester *)pCertWizardInfo->hRequester; 
    if (NULL == pCertRequester) 
    {
	SetLastError(ERROR_INVALID_PARAMETER);
	return FALSE;
    }

    pDSManager = pCertRequester->GetDSManager(); 
    if (NULL == pDSManager) 
    {
	SetLastError(ERROR_INVALID_PARAMETER);
	return FALSE;
    }

    *pdwCertType = 0;

    // Check and initialize the input parameters
    for (dwIndex = 0; dwIndex < dwNumCTElemArrays; dwIndex++)
    {
	if (NULL == certTypeElemArrays[dwIndex].lpvArray)
	{
	    SetLastError(ERROR_INVALID_PARAMETER);
	    return FALSE;
	}
	*(certTypeElemArrays[dwIndex].lpvArray) = NULL;
    }

    __try {

	//get the CA Info handler
        hr= pDSManager->FindCAByName
	    (pwszCAName,
	     NULL,
	     (pCertWizardInfo->fMachine?CA_FIND_LOCAL_SYSTEM:0),
	     &hCAInfo);

	_JumpCondition(S_OK != hr, CertCliErr); 
	_JumpConditionWithExpr(NULL==hCAInfo, CertCliErr, hr = E_FAIL); 

	hr=pDSManager->EnumCertTypesForCA
	    (hCAInfo,
	     (pCertWizardInfo->fMachine?CT_ENUM_MACHINE_TYPES | CT_FIND_LOCAL_SYSTEM:CT_ENUM_USER_TYPES),
	     &hCurCertType);

	//the CA has to support some cert types
	_JumpCondition(S_OK != hr, CertCliErr); 
	_JumpConditionWithExpr(NULL == hCurCertType, CertCliErr, hr = E_FAIL); 
	
	// Get the count of the cert types supported by this CA.
        // We should have at least 1 cert type. 
	dwCertTypeCount = CACountCertTypes(hCurCertType);
	_JumpConditionWithExpr(0 == dwCertTypeCount, CertCliErr, hr = E_FAIL); 

	// Allocate memory for all arrays we'll be manipulating. 
        for (dwIndex = 0; dwIndex < dwNumCTElemArrays; dwIndex++)
        {
            CAUTIL_CERTTYPE_ELEM_ARRAY ctea = certTypeElemArrays[dwIndex];

            *(ctea.lpvArray) = NULL; 
            *(ctea.lpvArray) = WizardAlloc(ctea.dwElemSize * dwCertTypeCount); 
            _JumpCondition(NULL == *(ctea.lpvArray), MemoryErr); 
            memset(*(ctea.lpvArray), 0, ctea.dwElemSize * dwCertTypeCount); 
        }

	dwValidCertType=0;
	for(dwIndex=0; dwIndex < dwCertTypeCount; dwIndex++)
	{
	    if (!CAUtilGetCertTypeNameAndExtensionsNoDS
		(pCertWizardInfo, 
		 pCertRequestInfo->pwszCertDNName, 
		 hCurCertType,
		 &((*ppwszCertType)          [dwValidCertType]), 
		 &((*ppwszDisplayCertType)   [dwValidCertType]), 
		 &((*ppCertExtensions)       [dwValidCertType]), 
		 &((*ppdwKeySpec)            [dwValidCertType]), 
		 &((*ppdwMinKeySize)         [dwValidCertType]), 
		 &((*ppdwCSPCount)           [dwValidCertType]), 
		 &((*ppdwCSPList)            [dwValidCertType]), 
		 &((*ppdwRASignature)        [dwValidCertType]), 
		 &((*ppdwEnrollmentFlags)    [dwValidCertType]), 
		 &((*ppdwSubjectNameFlags)   [dwValidCertType]), 
		 &((*ppdwPrivateKeyFlags)    [dwValidCertType]), 
		 &((*ppdwGeneralFlags)       [dwValidCertType])))
	    {
		// No luck with this template.  Try the next one.  
		goto next; 
	    }
		 
	    dwValidCertType++;
	    
	next: 
	    //enum for the next cert types
	    hPreCertType=hCurCertType;
	    
	    hr = pDSManager->EnumNextCertType(hPreCertType, &hCurCertType);
	    
	    //free the old cert type
	    pDSManager->CloseCertType(hPreCertType);
	    hPreCertType=NULL;
	    
	    if((S_OK != hr) || (NULL==hCurCertType))
		break;
	}
	
	//copy the cert type count
	*pdwCertType=dwValidCertType;
	
	//have to have some valid cert types
	_JumpConditionWithExpr(0 == (*pdwCertType), CertCliErr, hr = E_FAIL); 
	
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        dwException = GetExceptionCode();
        goto ExceptionErr;
    }

    fResult=TRUE;

CommonReturn:
    //free memory
    __try {
	if (NULL != ppwszDisplayCertTypeName) { CAFreeCertTypeProperty(hCurCertType, ppwszDisplayCertTypeName);	}
	if (NULL != ppwszCertTypeName)        { CAFreeCertTypeProperty(hCurCertType, ppwszCertTypeName); }
	if (NULL != hPreCertType)             { pDSManager->CloseCertType(hPreCertType); } 
	if (NULL != hCurCertType)             { pDSManager->CloseCertType(hCurCertType); } 
	if (NULL != hCAInfo)                  { pDSManager->CloseCA(hCAInfo); } 
	
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        SetLastError(GetExceptionCode());
    }

    return fResult;

ErrorReturn:
    //free the memory in failure case
    for (dwIndex = 0; dwIndex < dwNumCTElemArrays; dwIndex++)
    {
        CAUTIL_CERTTYPE_ELEM_ARRAY ctea = certTypeElemArrays[dwIndex];

        if (NULL != ctea.lpvArray && NULL != *(ctea.lpvArray))
        {
            if (NULL != ctea.pElemDeallocator)
            {
                (ctea.pElemDeallocator)(*(ctea.lpvArray), dwCertTypeCount); 
            }
            WizardFree(*(ctea.lpvArray)); 
            *(ctea.lpvArray) = NULL; 
        }
    }

    fResult = FALSE; 
    goto CommonReturn;
    
SET_ERROR_VAR(CertCliErr, hr);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
SET_ERROR_VAR(ExceptionErr, dwException)
}

//--------------------------------------------------------------------
//
//Retrieve the CA information based on a certificate
//
//---------------------------------------------------------------------
BOOL  CAUtilRetrieveCAFromCert(IN  CERT_WIZARD_INFO                 *pCertWizardInfo,
                               IN  PCCRYPTUI_WIZ_CERT_REQUEST_INFO   pCertRequestInfo,
                               OUT LPWSTR                           *pwszCALocation,    
                               OUT LPWSTR                           *pwszCAName)
{
    BOOL            fResult           = FALSE;
    CertDSManager  *pDSManager        = NULL;
    CertRequester  *pCertRequester    = NULL;
    DWORD           dwException       = 0;
    HCAINFO         hCAInfo           = NULL;
    HRESULT         hr                = S_OK;
    LPWSTR         *ppwszCAName       = NULL;
    LPWSTR         *ppwszCALocation   = NULL;
    PCERT_INFO      pCertInfo         = NULL;

    _JumpCondition(NULL==pwszCALocation || NULL==pwszCAName || NULL==pCertRequestInfo, InvalidArgErr);

    //init
    *pwszCALocation = NULL;
    *pwszCAName     = NULL;

    pCertRequester = (CertRequester *)pCertWizardInfo->hRequester; 
    _JumpCondition(NULL == pCertRequester, InvalidArgErr); 
    pDSManager = pCertRequester->GetDSManager(); 
    _JumpCondition(NULL == pDSManager, InvalidArgErr);

    //get the DN name from the certificate
    _JumpCondition(NULL == pCertRequestInfo->pRenewCertContext, InvalidArgErr);

    pCertInfo = pCertRequestInfo->pRenewCertContext->pCertInfo;
    _JumpCondition(NULL==pCertInfo, InvalidArgErr);

    __try {

        //get the certificate CA based on the DN
        hr=CAFindByIssuerDN
            (&(pCertInfo->Issuer),
             NULL,
             (pCertWizardInfo->fMachine?CA_FIND_LOCAL_SYSTEM:0),
             &hCAInfo);  

        //now that we can not get a certificate based on the DN, we 
        //just get any CA on the DN
        if(hr!= S_OK || hCAInfo==NULL)
        {
            hr=pDSManager->EnumFirstCA(NULL,
                                       (pCertWizardInfo->fMachine?CA_FIND_LOCAL_SYSTEM:0),
                                       &hCAInfo);
        }

        _JumpCondition(S_OK != hr || hCAInfo == NULL, CertCliErr);

        //get the CA's name and machine name
        hr = CAGetCAProperty
            (hCAInfo,
             CA_PROP_NAME,
             &ppwszCAName);
        _JumpCondition(S_OK != hr, CertCliErr); 
        _JumpConditionWithExpr(NULL == ppwszCAName, CertCliErr, S_OK == hr ? hr = E_FAIL : hr);

        hr=CAGetCAProperty
            (hCAInfo,
             CA_PROP_DNSNAME,
             &ppwszCALocation);
        _JumpCondition(S_OK != hr, CertCliErr); 
        _JumpConditionWithExpr(NULL == ppwszCALocation, CertCliErr, S_OK == hr ? hr = E_FAIL : hr);

        //copy the result to the output parameter
        *pwszCALocation = WizardAllocAndCopyWStr(ppwszCALocation[0]);
        _JumpCondition(NULL == *pwszCALocation, TraceErr);

        *pwszCAName = WizardAllocAndCopyWStr(ppwszCAName[0]);
        _JumpCondition(NULL == *pwszCAName, TraceErr); 

    } __except(EXCEPTION_EXECUTE_HANDLER) {
        dwException = GetExceptionCode();
        goto ExceptionErr;
    }

    fResult=TRUE;

CommonReturn:

    //free memory

    __try {
        if (NULL != ppwszCAName)     { CAFreeCAProperty(hCAInfo, ppwszCAName); }
        if (NULL != ppwszCALocation) { CAFreeCAProperty(hCAInfo, ppwszCALocation); }
        if (NULL != hCAInfo)         { CACloseCA(hCAInfo); }
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        SetLastError(GetExceptionCode());
    }

    return fResult;

ErrorReturn:

    //free the memory in failure case
    if(NULL != pwszCALocation && NULL != *pwszCALocation)
    {
        WizardFree(*pwszCALocation);
        *pwszCALocation=NULL;
    }

    if(NULL != pwszCAName && NULL != *pwszCAName)
    {
        WizardFree(*pwszCAName);
        *pwszCAName=NULL;
    }

    fResult = FALSE; 
    goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
SET_ERROR_VAR(CertCliErr, hr);
TRACE_ERROR(TraceErr);
SET_ERROR_VAR(ExceptionErr, dwException)
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\ui\wizards\certdsmanager.h ===
#ifndef __CERT_DS_MANAGER_H__
#define __CERT_DS_MANAGER_H__  1

#include <winldap.h>

//--------------------------------------------------------------------------------
//
// CertDSManager interface.  
// 
// The CertDSManager provides a wrapper around the certcli API to allow 
// any DS caching/optimization to be localized within a simple class.
//
//--------------------------------------------------------------------------------
class CertDSManager { 
 public:
    virtual HRESULT CloseCA            (IN HCAINFO hCAInfo)     = 0;
    virtual HRESULT CloseCertType      (IN HCERTTYPE hCertType) = 0; 
    virtual HRESULT CountCAs           (IN HCAINFO hCAInfo) = 0; 
    virtual HRESULT EnumCertTypesForCA (IN HCAINFO hCAInfo, IN DWORD dsFlags, OUT HCERTTYPE *phCertType) = 0; 
    virtual HRESULT EnumFirstCA        (IN LPCWSTR wszScope, IN DWORD fFlags, OUT HCAINFO *phCAInfo) = 0; 
    virtual HRESULT EnumNextCA         (IN HCAINFO hPrevCA, OUT HCAINFO *phCAInfo) = 0; 
    virtual HRESULT EnumNextCertType   (IN HCERTTYPE hPrevCertType, OUT HCERTTYPE *phCertType) = 0; 
    virtual HRESULT FindCertTypeByName (IN LPCWSTR pwszCertType, IN HCAINFO hCAInfo, IN DWORD dwFlags, OUT HCERTTYPE  *phCertType) = 0; 
    virtual HRESULT FindCAByName       (IN LPCWSTR wszCAName,IN LPCWSTR wszScope,IN DWORD dwFlags,OUT HCAINFO *phCAInfo) = 0;
    virtual HRESULT GetCACertificate   (IN HCAINFO hCAInfo, OUT PCCERT_CONTEXT *ppCert) = 0; 


    HRESULT static MakeDSManager(OUT CertDSManager **ppDSManager);

 protected:
    virtual HRESULT Initialize() = 0; 
};


//--------------------------------------------------------------------------------
// 
// DefaultDSManager.
//
// Other DS manager classes should extend this class, and implement only those
// methods which they wish to modify. 
//
//--------------------------------------------------------------------------------
class DefaultDSManager : public CertDSManager { 
 public:
    virtual HRESULT CloseCA(IN HCAINFO hCAInfo) { 
        return ::CACloseCA(hCAInfo); 
    }

    virtual HRESULT CloseCertType(IN HCERTTYPE hCertType) { 
        return ::CACloseCertType(hCertType);
    }

    virtual HRESULT CountCAs(IN HCAINFO hCAInfo) { 
        return ::CACountCAs(hCAInfo);
    }

    virtual HRESULT EnumCertTypesForCA(IN HCAINFO hCAInfo, IN DWORD dwFlags, OUT HCERTTYPE *phCertType) { 
        return ::CAEnumCertTypesForCA(hCAInfo, dwFlags, phCertType); 
    }

    virtual HRESULT EnumFirstCA(IN LPCWSTR wszScope, IN DWORD dwFlags, OUT HCAINFO *phCAInfo) { 
	return ::CAEnumFirstCA(wszScope, dwFlags, phCAInfo);
    }

    virtual HRESULT EnumNextCA(IN HCAINFO hPrevCA, OUT HCAINFO *phCAInfo) {
	return ::CAEnumNextCA(hPrevCA, phCAInfo);
    }

    virtual HRESULT EnumNextCertType(IN HCERTTYPE hPrevCertType, OUT HCERTTYPE *phCertType) { 
        return ::CAEnumNextCertType(hPrevCertType, phCertType);
    }

    virtual HRESULT FindCertTypeByName(IN LPCWSTR pwszCertType, IN HCAINFO hCAInfo, IN DWORD dwFlags, OUT HCERTTYPE *phCertType) { 
	return ::CAFindCertTypeByName(pwszCertType, hCAInfo, dwFlags, phCertType);
    }

    virtual HRESULT FindCAByName(IN LPCWSTR wszCAName, IN LPCWSTR wszScope, IN DWORD dwFlags, OUT HCAINFO *phCAInfo) { 
        return ::CAFindByName(wszCAName, wszScope, dwFlags, phCAInfo); 
    }

    virtual HRESULT GetCACertificate(IN HCAINFO hCAInfo, OUT PCCERT_CONTEXT *ppCert) { 
	return ::CAGetCACertificate(hCAInfo, ppCert); 
    }

 protected: 
    virtual HRESULT Initialize() { return S_OK; }
};

//--------------------------------------------------------------------------------
//
// CachingDSManager
//
// This DS manager caches the LDAP binding handle (where possible) to prevent
// unnecessary binds and unbinds.  It uses an enhanced version of certcli which
// allows you to pass an LDAP binding handle.  
//
//--------------------------------------------------------------------------------

class CachingDSManager : public DefaultDSManager { 
    friend class CertDSManager; 
  
 public:
    virtual ~CachingDSManager(); 

    // Extend those routines which allow you to use a cached binding handle
    HRESULT EnumCertTypesForCA(IN HCAINFO hCAInfo, IN DWORD dwFlags, OUT HCERTTYPE * phCertType);
    HRESULT EnumFirstCA(IN LPCWSTR wszScope, IN DWORD dwFlags, OUT HCAINFO *phCAInfo);
    HRESULT FindCAByName(IN LPCWSTR wszCAName, IN LPCWSTR wszScope, IN DWORD dwFlags,OUT HCAINFO *phCAInfo);
    HRESULT FindCertTypeByName(IN LPCWSTR pwszCertType, IN HCAINFO hCAInfo, IN DWORD dwFlags, OUT HCERTTYPE *phCertType); 

 protected:
    HRESULT Initialize(); 

 private:
    CachingDSManager() : m_ldBindingHandle(NULL) { } 
    LDAP *m_ldBindingHandle; 
};



#endif  // #ifndef __CERT_DS_MANAGER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\ui\wizards\cautil.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       cautil.h
//
//--------------------------------------------------------------------------

//header file for utility functions 

//--------------------------------------------------------------------
//
//   CAUtilGetCADisplayName
//
//		Get the display name of the CA based on its real name
//
//--------------------------------------------------------------------
BOOL    CAUtilGetCADisplayName(DWORD	dwCAFindFlags,
							   LPWSTR	pwszCAName,
							   LPWSTR	*ppwszCADisplayName);



//--------------------------------------------------------------------
//
//   Verify that the user has the correct permision to 
//   ask for the requested certificatd types
//
//--------------------------------------------------------------------
BOOL    CAUtilValidCertType(PCCRYPTUI_WIZ_CERT_REQUEST_INFO    pCertRequestInfo,
                            CERT_WIZARD_INFO                   *pCertWizardInfo);

BOOL CAUtilValidCertTypeNoDS(HCERTTYPE         hCertType,
			     LPWSTR            pwszCertDNName, 
			     CERT_WIZARD_INFO *pCertWizardInfo);


//--------------------------------------------------------------------
//
//Retrieve a list of CAs what supports the required certificate types
//
//  The CA returned will support all the certificate types required.
//  1. Check the permission
//  2. Check for the subject name
//
//  The CA returned will also support the CSP that user specified
//  1. If the CSP type is selected, then use it
//  1.1 If the CSP type is not sepecified and UILess mode, use RSA_FULL
//  1.2 If the CSP type is not sepecified and UI mode, no need to check
//---------------------------------------------------------------------
BOOL    CAUtilRetrieveCAFromCertType(
            CERT_WIZARD_INFO                   *pCertWizardInfo,
            PCCRYPTUI_WIZ_CERT_REQUEST_INFO    pCertRequestInfo,
            BOOL                               fMultipleCA,              //only need one CA
            DWORD                              dwNameFlag,
            DWORD                              *pdwCACount,
            LPWSTR                             **ppwszCALocation,    
            LPWSTR                             **ppwszCAName);

//--------------------------------------------------------------------
//
//Based on the CA name and CA location, get a list of certificate type
//and their extensions
//
//---------------------------------------------------------------------

BOOL    CAUtilGetCertTypeNameAndExtensionsNoDS
(CERT_WIZARD_INFO                    *pCertWizardInfo,
 LPWSTR                               pwszCertDNName, 
 HCERTTYPE                            hCertType, 
 LPWSTR                              *pwszCertType,
 LPWSTR                              *ppwszDisplayCertType,
 PCERT_EXTENSIONS                    *pCertExtensions,
 DWORD                               *pdwKeySpec,
 DWORD                               *pdwMinKeySize, 
 DWORD                               *pdwCSPCount,
 DWORD                              **ppdwCSPList,
 DWORD                               *pdwRASignature, 
 DWORD                               *pdwEnrollmentFlags, 
 DWORD                               *pdwSubjectNameFlags,
 DWORD                               *pdwPrivateKeyFlags,
 DWORD                               *pdwGeneralFlags);

BOOL    CAUtilGetCertTypeNameAndExtensions(
         CERT_WIZARD_INFO                   *pCertWizardInfo,
         PCCRYPTUI_WIZ_CERT_REQUEST_INFO    pCertRequestInfo,
         LPWSTR                             pwszCALocation,
         LPWSTR                             pwszCAName,
         DWORD                              *pdwCertType,
         LPWSTR                             **ppwszCertType,
         LPWSTR                             **ppwszDisplayCertType,
         PCERT_EXTENSIONS                   **ppCertExtensions,
         DWORD                              **ppdwKeySpec,
         DWORD                              **ppdwCertTypeFlag,
         DWORD                              **ppdwCSPCount,
         DWORD                              ***ppdwCSPList,
	 DWORD                              **ppdwRASignature, 
	 DWORD                              **ppdwEnrollmentFlags, 
	 DWORD                              **ppdwSubjectNameFlags,
	 DWORD                              **ppdwPrivateKeyFlags,
	 DWORD                              **ppdwGeneralFlags
	 );

//--------------------------------------------------------------------
//
//Retrieve the CA information based on a certificate
//
//---------------------------------------------------------------------
BOOL    CAUtilRetrieveCAFromCert(
            CERT_WIZARD_INFO                   *pCertWizardInfo,
            PCCRYPTUI_WIZ_CERT_REQUEST_INFO     pCertRequestInfo,
            LPWSTR                              *pwszCALocation,    
            LPWSTR                              *pwszCAName);


//--------------------------------------------------------------------
//
//From the API's cert type name, get the real name with GUID
//
//---------------------------------------------------------------------
BOOL    CAUtilGetCertTypeName(CERT_WIZARD_INFO      *pCertWizardInfo,
                              LPWSTR                pwszAPIName,
                              LPWSTR                *ppwszCTName);

BOOL    CAUtilGetCertTypeNameNoDS(IN  HCERTTYPE  hCertType, 
				  OUT LPWSTR    *ppwszCTName);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\ui\wizards\certrequester.h ===
#ifndef __CERT_REQUESTER_H__
#define __CERT_REQUESTER_H__  1


class CertRequester { 
 public:
    CertDSManager *          GetDSManager() { return m_pDSManager; } 
    CertRequesterContext *   GetContext()   { return m_pContext; } 


    virtual ~CertRequester() 
    {
        if (NULL != m_pDSManager) { delete m_pDSManager; } 
	if (NULL != m_pContext)   { delete m_pContext; } 
    }
    
    static HRESULT MakeCertRequester(IN  LPCWSTR                pwszAccountName, 
				     IN  LPCWSTR                pwszMachineName,
				     IN  DWORD                  dwCertOpenStoreFlags, 
				     IN  DWORD                  dwPurpose,
				     IN  CERT_WIZARD_INFO      *pCertWizardInfo,  
				     OUT CertRequester        **ppCertRequester, 
				     OUT UINT                  *pIDS);

 protected:
    CertRequester(); 
    CertRequester(CERT_WIZARD_INFO * pCertWizardInfo) : m_pCertWizardInfo(pCertWizardInfo), 
	m_pDSManager(NULL), m_pContext(NULL) { 
	if (NULL != pCertWizardInfo) { pCertWizardInfo->hRequester = (HCERTREQUESTER)this; } 
    }
		     

 private:
    // FIXME: does pContext need to be refcounted?
    void SetContext(CertRequesterContext * pContext) { m_pContext = pContext; }
    void SetDSManager(CertDSManager * pDSManager)    { m_pDSManager = pDSManager; }

    CERT_WIZARD_INFO     *m_pCertWizardInfo; 
    CertDSManager        *m_pDSManager; 
    CertRequesterContext *m_pContext; 
};


class EnrollmentCertRequester : public CertRequester {
public:
    EnrollmentCertRequester(CERT_WIZARD_INFO * pCertWizardInfo) : CertRequester(pCertWizardInfo)
	{ } 
};

class RenewalCertRequester : public CertRequester {
public:
    RenewalCertRequester(CERT_WIZARD_INFO * pCertWizardInfo) : CertRequester(pCertWizardInfo)
	{ } 
};


#endif  // #ifndef __CERT_REQUESTER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\ui\wizards\certrequester.cpp ===
#include    "wzrdpvk.h"
#include    "certca.h"
#include    "cautil.h"
#include    "CertRequesterContext.h"
#include    "CertDSManager.h"
#include    "CertRequester.h"

HRESULT CertRequester::MakeCertRequester(IN  LPCWSTR                pwszAccountName, 
					 IN  LPCWSTR                pwszMachineName,
					 IN  DWORD                  dwCertOpenStoreFlag, 
					 IN  DWORD                  dwPurpose,
					 IN  CERT_WIZARD_INFO      *pCertWizardInfo,  
					 OUT CertRequester        **ppCertRequester, 
					 OUT UINT                  *pIDS)
{
    CertDSManager         *pDSManager = NULL; 
    CertRequesterContext  *pContext   = NULL;
    HRESULT                hr         = E_FAIL; 

    if (NULL == ppCertRequester)
	return E_INVALIDARG; 

    // 1) Attempt to construct a CertRequesterContext:
    //
    if (S_OK != (hr = CertRequesterContext::MakeCertRequesterContext
		 (pwszAccountName, 
		  pwszMachineName,
		  dwCertOpenStoreFlag, 
		  pCertWizardInfo, 
		  &pContext, 
		  pIDS)))
	goto MakeCertRequesterContextError; 
	
    if (S_OK != (hr = pContext->Initialize()))
    {
	*pIDS = pContext->GetErrorString(); 
	goto InitializeError; 
    }

    // 2) Attempt to construct a CertDSManager:
    // 

    if (S_OK != (hr = CertDSManager::MakeDSManager(&pDSManager)))
    {
        *pIDS=IDS_NO_AD;
	    goto MakeDSManagerError; 
    }

    // 3) Create the CertRequester itself:
    //
    switch (dwPurpose)
    {
    case CRYPTUI_WIZ_CERT_ENROLL:
	*ppCertRequester = new EnrollmentCertRequester(pCertWizardInfo); 
	break; 
    case CRYPTUI_WIZ_CERT_RENEW:
	*ppCertRequester = new RenewalCertRequester(pCertWizardInfo); 
	break; 
    default:
	goto InvalidArgError; 
    }

    if (NULL == *ppCertRequester)
	goto MemoryError; 

    (*ppCertRequester)->SetContext(pContext); 
    (*ppCertRequester)->SetDSManager(pDSManager); 

    hr = S_OK; 

 CommonReturn: 
    return hr; 

 ErrorReturn:
    if (NULL != pContext) { delete pContext; } 
    goto CommonReturn; 

SET_HRESULT(MakeDSManagerError,            hr);
SET_HRESULT(InitializeError,               hr); 
SET_HRESULT(InvalidArgError,               E_INVALIDARG); 
SET_HRESULT(MakeCertRequesterContextError, hr);
SET_HRESULT(MemoryError,                   E_OUTOFMEMORY);     
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\ui\wizards\dragdrop.h ===
//--------------------------------------------------------------
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       dragdrop.h
//
//  Contents:   The header for dragdrop.c
//
//  History:    Feb-26-98 xiaohs   created
//
//--------------------------------------------------------------
#ifndef DRAGDROP_H
#define DRAGDROP_H



#ifdef __cplusplus
extern "C" {
#endif


//==============================================================================
//    The following are used by Drag-Drop functionalities
//==============================================================================
#undef IToClass
// macro to get from interface pointer to class pointer
#define _IOffset(class, itf)         ((UINT)(ULONG_PTR)&(((class *)0)->itf))
#define IToClass(class, itf, pitf)   ((class  *)(((LPBYTE)pitf)-_IOffset(class, itf)))

#define ARRAYSIZE(a)	(sizeof(a)/sizeof(a[0]))

HRESULT CDataObj_CreateInstance(DWORD           dwCount,
                                LPWSTR          *prgwszFileName,
                                BYTE            **prgBlob,
                                DWORD           *prgdwSize,
                                IDataObject     **ppdtobj);

HRESULT CDropSource_CreateInstance(IDropSource **ppdsrc);



HRESULT CertMgrUIStartDragDrop(LPNMLISTVIEW     pvmn,
                                HWND            hwndControl,
                                DWORD           dwExportFormat,
                                BOOL            fExportChain);


BOOL    GetFileNameAndContent(LPNMLISTVIEW      pvmn,
                                HWND            hwndControl,
                                DWORD           dwExportFormat,
                                BOOL            fExportChain,
                                DWORD           *pdwCount,
                                LPWSTR          **pprgszFileName,
                                BYTE            ***pprgBlob,
                                DWORD           **pprgdwSize);

BOOL    FreeFileNameAndContent( DWORD           dwCount,
                                LPWSTR          *prgwszFileName,
                                BYTE            **prgBlob,
                                DWORD           *prgdwSize);



#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#endif  //DRAGDROP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\ui\wizards\dragdrop.c ===
//-------------------------------------------------------------
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       dragdrop.cpp
//
//  Contents:   The cpp file to implement IDataObject and IDragSource
//
//  History:    March-9th-98 xiaohs   created
//
//--------------------------------------------------------------
#include <windows.h>
#include <shlobj.h>
#include "dragdrop.h"
#include "unicode.h"

//=========================================================================
//
//  The APIs to establish the drag source BLOB and start the drag and drop
//  operations
//
//=========================================================================

HRESULT CertMgrUIStartDragDrop(LPNMLISTVIEW     pvmn,
                                HWND            hwndControl,
                                DWORD           dwExportFormat,
                                BOOL            fExportChain)
{
    HRESULT                 hr=E_FAIL;
	IDropSource             *pdsrc=NULL;
	IDataObject             *pdtobj=NULL;
	DWORD                   dwEffect=0;
    DWORD                   dwCount=0;
    LPWSTR                  *prgwszFileName=NULL;
    BYTE                    **prgBlob=NULL;
    DWORD                   *prgdwSize=NULL;

    if(!pvmn || !hwndControl)
    {
        hr=E_INVALIDARG;
        goto CLEANUP;
    }

    //get the list of file names and their BLOBs
    if(!GetFileNameAndContent(pvmn, hwndControl, dwExportFormat, fExportChain,
                                &dwCount, &prgwszFileName, &prgBlob, &prgdwSize))
    {
        hr=GetLastError();
        goto CLEANUP;
    }

    if(!SUCCEEDED(hr=CDataObj_CreateInstance(dwCount,
                                            prgwszFileName,
                                            prgBlob,
                                            prgdwSize,
                                            &pdtobj)))
        goto CLEANUP;


	if(!SUCCEEDED(hr=CDropSource_CreateInstance(&pdsrc)))
        goto CLEANUP;

    __try {
	    DoDragDrop(pdtobj, pdsrc, DROPEFFECT_COPY, &dwEffect);
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        hr = GetExceptionCode();
        goto CLEANUP;
    }


	pdsrc->lpVtbl->Release(pdsrc);

    pdsrc=NULL;

	pdtobj->lpVtbl->Release(pdtobj);

    pdtobj=NULL;


    hr=S_OK;

CLEANUP:

    FreeFileNameAndContent(dwCount,
                            prgwszFileName,
                            prgBlob,
                            prgdwSize);


    if(pdsrc)
	    pdsrc->lpVtbl->Release(pdsrc);

    if(pdtobj)
	    pdtobj->lpVtbl->Release(pdtobj);

    return hr;

}
//=========================================================================
//
//  IEnumFORMATETC implementation
//
//=========================================================================

typedef struct _StdEnumFmt // idt
{
    IEnumFORMATETC efmt;
    UINT	 cRef;
    UINT	 ifmt;
    UINT	 cfmt;
    FORMATETC	 afmt[1];
} CStdEnumFmt;

extern IEnumFORMATETCVtbl c_CStdEnumFmtVtbl;	// forward

HRESULT CreateStdEnumFmtEtc(UINT cfmt, const FORMATETC afmt[], LPENUMFORMATETC *ppenumFormatEtc)
{
    CStdEnumFmt * this = (CStdEnumFmt*)LocalAlloc( LPTR, sizeof(CStdEnumFmt) + (cfmt - 1) * sizeof(FORMATETC));
    if (this)
    {
	this->efmt.lpVtbl = &c_CStdEnumFmtVtbl;
	this->cRef = 1;
	this->cfmt = cfmt;
	MoveMemory(this->afmt, afmt, cfmt * sizeof(FORMATETC));
        *ppenumFormatEtc = &this->efmt;
	return S_OK;
    }
    else
    {
        *ppenumFormatEtc = NULL;
	return E_OUTOFMEMORY;
    }
}

HRESULT CStdEnumFmt_QueryInterface(LPENUMFORMATETC pefmt, REFIID riid, LPVOID * ppvObj)
{
    CStdEnumFmt *this = IToClass(CStdEnumFmt, efmt, pefmt);

    if (IsEqualIID(riid, &IID_IEnumFORMATETC) || IsEqualIID(riid, &IID_IUnknown))
    {
        *ppvObj = &this->efmt;
        this->cRef++;
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG CStdEnumFmt_AddRef(LPENUMFORMATETC pefmt)
{
    CStdEnumFmt *this = IToClass(CStdEnumFmt, efmt, pefmt);
    return ++this->cRef;
}

ULONG CStdEnumFmt_Release(LPENUMFORMATETC pefmt)
{
    CStdEnumFmt *this = IToClass(CStdEnumFmt, efmt, pefmt);
    this->cRef--;
    if (this->cRef > 0)
        return this->cRef;

    LocalFree((HLOCAL)this);
    return 0;
}

HRESULT CStdEnumFmt_Next(LPENUMFORMATETC pefmt, ULONG celt, FORMATETC *rgelt, ULONG *pceltFethed)
{
    CStdEnumFmt *this = IToClass(CStdEnumFmt, efmt, pefmt);
    UINT cfetch;
    HRESULT hres = S_FALSE;	// assume less numbers

    if (this->ifmt < this->cfmt)
    {
	cfetch = this->cfmt - this->ifmt;
	if (cfetch >= celt)
	{
	    cfetch = celt;
	    hres = S_OK;
	}

	CopyMemory(rgelt, &this->afmt[this->ifmt], cfetch * sizeof(FORMATETC));
	this->ifmt += cfetch;
    }
    else
    {
	cfetch = 0;
    }

    if (pceltFethed)
        *pceltFethed = cfetch;

    return hres;
}

HRESULT CStdEnumFmt_Skip(LPENUMFORMATETC pefmt, ULONG celt)
{
    CStdEnumFmt *this = IToClass(CStdEnumFmt, efmt, pefmt);
    this->ifmt += celt;
    if (this->ifmt > this->cfmt)
    {
	this->ifmt = this->cfmt;
	return S_FALSE;
    }
    return S_OK;
}

HRESULT CStdEnumFmt_Reset(LPENUMFORMATETC pefmt)
{
    CStdEnumFmt *this = IToClass(CStdEnumFmt, efmt, pefmt);
    this->ifmt = 0;
    return S_OK;
}

HRESULT CStdEnumFmt_Clone(LPENUMFORMATETC pefmt, IEnumFORMATETC ** ppenum)
{
    CStdEnumFmt *this = IToClass(CStdEnumFmt, efmt, pefmt);
    return CreateStdEnumFmtEtc(this->cfmt, this->afmt, ppenum);
}

#pragma data_seg(".text", "CODE")
IEnumFORMATETCVtbl c_CStdEnumFmtVtbl = {
    CStdEnumFmt_QueryInterface,
    CStdEnumFmt_AddRef,
    CStdEnumFmt_Release,
    CStdEnumFmt_Next,
    CStdEnumFmt_Skip,
    CStdEnumFmt_Reset,
    CStdEnumFmt_Clone,
};
#pragma data_seg()


//===========================================================================
//
// IDataObject implementation
//
//=========================================================================

typedef struct {
    IDataObject	dtobj;
    UINT        cRef;
    DWORD       dwCount;
    LPWSTR      *prgwszFileName;
    BYTE        **prgBlob;
    DWORD       *prgdwSize;
} CDataObj;

// registered clipboard formats
UINT g_cfFileContents = 0;
UINT g_cfFileGroupDescriptorA = 0;
UINT g_cfFileGroupDescriptorW = 0;


#pragma data_seg(".text", "CODE")
const char c_szFileContents[] = CFSTR_FILECONTENTS;	            // "FileContents"
const char c_szFileGroupDescriptorA[] = CFSTR_FILEDESCRIPTORA;  // "FileGroupDescriptor"
const char c_szFileGroupDescriptorW[] = CFSTR_FILEDESCRIPTORW;  // "FileGroupDescriptorW"
#pragma data_seg()

IDataObjectVtbl c_CDataObjVtbl;		// forward decl

HRESULT CDataObj_CreateInstance(DWORD           dwCount,
                                LPWSTR          *prgwszFileName,
                                BYTE            **prgBlob,
                                DWORD           *prgdwSize,
                                IDataObject     **ppdtobj)
{
    CDataObj *this = (CDataObj *)LocalAlloc(LPTR, sizeof(CDataObj));
    if (this)
    {
        this->dtobj.lpVtbl = &c_CDataObjVtbl;
        this->cRef = 1;
	    this->dwCount = dwCount;
	    this->prgwszFileName = prgwszFileName;
        this->prgBlob = prgBlob;
        this->prgdwSize = prgdwSize;

        *ppdtobj = &this->dtobj;

	    if (g_cfFileContents == 0)
        {
	        g_cfFileContents = RegisterClipboardFormat(c_szFileContents);
            g_cfFileGroupDescriptorW = RegisterClipboardFormat(c_szFileGroupDescriptorW);
	        g_cfFileGroupDescriptorA = RegisterClipboardFormat(c_szFileGroupDescriptorA);
        }

        return S_OK;
    }

    *ppdtobj = NULL;
    return E_OUTOFMEMORY;
}

HRESULT CDataObj_QueryInterface(IDataObject *pdtobj, REFIID riid, LPVOID * ppvObj)
{
    CDataObj *this = IToClass(CDataObj, dtobj, pdtobj);

    if (IsEqualIID(riid, &IID_IDataObject) || IsEqualIID(riid, &IID_IUnknown))
    {
        *ppvObj = this;
        this->cRef++;
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG CDataObj_AddRef(IDataObject *pdtobj)
{
    CDataObj *this = IToClass(CDataObj, dtobj, pdtobj);

    this->cRef++;
    return this->cRef;
}

ULONG CDataObj_Release(IDataObject *pdtobj)
{
    CDataObj *this = IToClass(CDataObj, dtobj, pdtobj);

    this->cRef--;
    if (this->cRef > 0)
	return this->cRef;

    LocalFree((HLOCAL)this);

    return 0;
}

HRESULT CDataObj_GetData(IDataObject *pdtobj, FORMATETC *pformatetcIn, STGMEDIUM *pmedium)
{
    CDataObj *this = IToClass(CDataObj, dtobj, pdtobj);
    HRESULT hres = E_INVALIDARG;
    DWORD   dwIndex=0;
    LPSTR   psz=NULL;


    pmedium->hGlobal = NULL;
    pmedium->pUnkForRelease = NULL;

    if (    ((g_cfFileGroupDescriptorA == pformatetcIn->cfFormat) &&
            (pformatetcIn->tymed & TYMED_HGLOBAL)) ||
            ((g_cfFileGroupDescriptorW == pformatetcIn->cfFormat) &&
            (pformatetcIn->tymed & TYMED_HGLOBAL)) 
       )
    {

        if(g_cfFileGroupDescriptorA == pformatetcIn->cfFormat)
        {
            if(!FIsWinNT())
            {
                //allocate dwCount-1 file descrptors
	            pmedium->hGlobal = GlobalAlloc(GPTR,
                    (sizeof(FILEGROUPDESCRIPTORA)+(this->dwCount -1 )*sizeof(FILEDESCRIPTORA)));

                if(NULL == pmedium->hGlobal)
                    return E_OUTOFMEMORY;

    	        #define pdesc ((FILEGROUPDESCRIPTORA *)pmedium->hGlobal)

                //populate all the file descriptors
                for(dwIndex =0; dwIndex < this->dwCount; dwIndex++)
                {
                    //get the anscii version of the file name
                    if(((this->prgwszFileName)[dwIndex] == NULL) || 
                        (!MkMBStr(NULL, 0, (this->prgwszFileName)[dwIndex], &psz)))
                        return E_OUTOFMEMORY;

    	            lstrcpy(pdesc->fgd[dwIndex].cFileName, psz);
	                // specify the file for our HGLOBAL since GlobalSize() will round up
	                pdesc->fgd[dwIndex].dwFlags = FD_FILESIZE;
	                pdesc->fgd[dwIndex].nFileSizeLow = (this->prgdwSize)[dwIndex];

                    FreeMBStr(NULL,psz);
                    psz=NULL;
                }

                //specify the number of files
    	        pdesc->cItems = this->dwCount;

    	        #undef pdesc
            }
            else
                return E_INVALIDARG;
        }
        else
        {

            //allocate dwCount-1 file descrptors
	        pmedium->hGlobal = GlobalAlloc(GPTR,
                (sizeof(FILEGROUPDESCRIPTORW)+(this->dwCount -1 )*sizeof(FILEDESCRIPTORW)));

            if(NULL == pmedium->hGlobal)
                return E_OUTOFMEMORY;

    	    #define pdesc ((FILEGROUPDESCRIPTORW *)pmedium->hGlobal)

            //populate all the file descriptors
            for(dwIndex =0; dwIndex < this->dwCount; dwIndex++)
            {
    	        wcscpy(pdesc->fgd[dwIndex].cFileName, (this->prgwszFileName)[dwIndex]);
	            // specify the file for our HGLOBAL since GlobalSize() will round up
	            pdesc->fgd[dwIndex].dwFlags = FD_FILESIZE;
	            pdesc->fgd[dwIndex].nFileSizeLow = (this->prgdwSize)[dwIndex];
            }

            //specify the number of files
    	    pdesc->cItems = this->dwCount;

    	    #undef pdesc
        }

        pmedium->tymed = TYMED_HGLOBAL;

	    hres = S_OK;
    }
    else if ((g_cfFileContents == pformatetcIn->cfFormat) &&
             (pformatetcIn->tymed & TYMED_HGLOBAL))
    {
        if((pformatetcIn->lindex) < (int)(this->dwCount))
        {
	        pmedium->hGlobal = GlobalAlloc(GPTR, (this->prgdwSize)[pformatetcIn->lindex]);
    	    if (pmedium->hGlobal)
	        {
	            CopyMemory(pmedium->hGlobal,
                            (this->prgBlob)[pformatetcIn->lindex],
                            (this->prgdwSize)[pformatetcIn->lindex]);

                pmedium->tymed = TYMED_HGLOBAL;
                hres = S_OK;
	        }
            else
                hres=E_OUTOFMEMORY;
        }
	    else
            hres = E_INVALIDARG;
    }

    return hres;
}

HRESULT CDataObj_GetDataHere(IDataObject *pdtobj, FORMATETC *pformatetc, STGMEDIUM *pmedium)
{
    return E_NOTIMPL;
}

HRESULT CDataObj_QueryGetData(IDataObject *pdtobj, LPFORMATETC pformatetcIn)
{
    CDataObj *this = IToClass(CDataObj, dtobj, pdtobj);

    if (((pformatetcIn->cfFormat == g_cfFileContents) &&
        (pformatetcIn->tymed & TYMED_HGLOBAL ))||
        ((pformatetcIn->cfFormat == g_cfFileGroupDescriptorW) &&
        (pformatetcIn->tymed & TYMED_HGLOBAL))
        )
    {
	    return S_OK;
    }
    else
    { 
        //on NT, we do not support A version in order to be
        //unicode compliant.  The shell query the A version first on NT.
        if(!FIsWinNT())
        {
            if((pformatetcIn->cfFormat == g_cfFileGroupDescriptorA) &&
               (pformatetcIn->tymed & TYMED_HGLOBAL))
                return S_OK;
            else
                return S_FALSE;

        }
        else
            return S_FALSE;
    }
}

HRESULT CDataObj_GetCanonicalFormatEtc(IDataObject *pdtobj, FORMATETC *pformatetc, FORMATETC *pformatetcOut)
{
    return DATA_S_SAMEFORMATETC;
}

HRESULT CDataObj_SetData(IDataObject *pdtobj, FORMATETC *pformatetc, STGMEDIUM *pmedium, BOOL fRelease)
{
    return E_NOTIMPL;
}

HRESULT CDataObj_EnumFormatEtc(IDataObject *pdtobj, DWORD dwDirection, LPENUMFORMATETC *ppenumFormatEtc)
{
    CDataObj *this = IToClass(CDataObj, dtobj, pdtobj);

    FORMATETC fmte[3] = {
        {(WORD)g_cfFileContents, 	        NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
        {(WORD)g_cfFileGroupDescriptorA,    NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
        {(WORD)g_cfFileGroupDescriptorW,    NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
    };

    return CreateStdEnumFmtEtc(ARRAYSIZE(fmte), fmte, ppenumFormatEtc);
}

HRESULT CDataObj_Advise(IDataObject *pdtobj, FORMATETC *pFormatetc, DWORD advf, LPADVISESINK pAdvSink, DWORD *pdwConnection)
{
    return OLE_E_ADVISENOTSUPPORTED;
}

HRESULT CDataObj_Unadvise(IDataObject *pdtobj, DWORD dwConnection)
{
    return OLE_E_ADVISENOTSUPPORTED;
}

HRESULT CDataObj_EnumAdvise(IDataObject *pdtobj, LPENUMSTATDATA *ppenumAdvise)
{
    return OLE_E_ADVISENOTSUPPORTED;
}

#pragma data_seg(".text", "CODE")
IDataObjectVtbl c_CDataObjVtbl = {
    CDataObj_QueryInterface,
    CDataObj_AddRef,
    CDataObj_Release,
    CDataObj_GetData,
    CDataObj_GetDataHere,
    CDataObj_QueryGetData,
    CDataObj_GetCanonicalFormatEtc,
    CDataObj_SetData,
    CDataObj_EnumFormatEtc,
    CDataObj_Advise,
    CDataObj_Unadvise,
    CDataObj_EnumAdvise
};
#pragma data_seg()


//=========================================================================
//
//  IDropSource implementation
//
//=========================================================================


typedef struct {
    IDropSource dsrc;
    UINT cRef;
    DWORD grfInitialKeyState;
} CDropSource;

IDropSourceVtbl c_CDropSourceVtbl;	// forward decl

HRESULT CDropSource_CreateInstance(IDropSource **ppdsrc)
{
    CDropSource *this = (CDropSource *)LocalAlloc(LPTR, sizeof(CDropSource));
    if (this)
    {
        this->dsrc.lpVtbl = &c_CDropSourceVtbl;
        this->cRef = 1;
        *ppdsrc = &this->dsrc;

        return S_OK;
    }
    else
    {
	*ppdsrc = NULL;
	return E_OUTOFMEMORY;
    }
}

HRESULT CDropSource_QueryInterface(IDropSource *pdsrc, REFIID riid, LPVOID *ppvObj)
{
    CDropSource *this = IToClass(CDropSource, dsrc, pdsrc);

    if (IsEqualIID(riid, &IID_IDropSource) || IsEqualIID(riid, &IID_IUnknown))
    {
        *ppvObj = this;
        this->cRef++;
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG CDropSource_AddRef(IDropSource *pdsrc)
{
    CDropSource *this = IToClass(CDropSource, dsrc, pdsrc);

    this->cRef++;
    return this->cRef;
}

ULONG CDropSource_Release(IDropSource *pdsrc)
{
    CDropSource *this = IToClass(CDropSource, dsrc, pdsrc);

    this->cRef--;
    if (this->cRef > 0)
	return this->cRef;

    LocalFree((HLOCAL)this);

    return 0;
}

HRESULT CDropSource_QueryContinueDrag(IDropSource *pdsrc, BOOL fEscapePressed, DWORD grfKeyState)
{
    CDropSource *this = IToClass(CDropSource, dsrc, pdsrc);

    if (fEscapePressed)
        return DRAGDROP_S_CANCEL;

    // initialize ourself with the drag begin button
    if (this->grfInitialKeyState == 0)
        this->grfInitialKeyState = (grfKeyState & (MK_LBUTTON | MK_RBUTTON | MK_MBUTTON));


    if (!(grfKeyState & this->grfInitialKeyState))
        return DRAGDROP_S_DROP;	
    else
        return S_OK;
}

HRESULT CDropSource_GiveFeedback(IDropSource *pdsrc, DWORD dwEffect)
{
    CDropSource *this = IToClass(CDropSource, dsrc, pdsrc);
    return DRAGDROP_S_USEDEFAULTCURSORS;
}

#pragma data_seg(".text", "CODE")
IDropSourceVtbl c_CDropSourceVtbl = {
    CDropSource_QueryInterface,
    CDropSource_AddRef,
    CDropSource_Release,
    CDropSource_QueryContinueDrag,
    CDropSource_GiveFeedback
};
#pragma data_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\ui\wizards\certrequestercontext.cpp ===
#include    "wzrdpvk.h"
#include    "certca.h"
#include    "cautil.h"
#include    "CertRequesterContext.h"

//--------------------------------------------------------------------------------
// Machine context and local context now use the same code to build the CSP list: 
HRESULT BuildCSPList(CERT_WIZARD_INFO *m_pCertWizardInfo) 
{
    DWORD     dwIndex          = 0;
    DWORD     dwProviderType   = 0;
    DWORD     cbSize           = 0;
    HRESULT   hr               = E_FAIL; 
    LPWSTR    pwszProviderName = 0;
    
    if (NULL == m_pCertWizardInfo)
	return E_POINTER; 

    //free the old memory
    FreeProviders(m_pCertWizardInfo->dwCSPCount,
		  m_pCertWizardInfo->rgdwProviderType,
		  m_pCertWizardInfo->rgwszProvider);
    
    m_pCertWizardInfo->dwCSPCount        = 0;
    m_pCertWizardInfo->rgdwProviderType  = NULL;
    m_pCertWizardInfo->rgwszProvider     = NULL;

    for (dwIndex = 0; 
	 CryptEnumProvidersU(dwIndex, 0, 0, &dwProviderType, NULL, &cbSize);
	 dwIndex++)
    {	
	pwszProviderName = (LPWSTR)WizardAlloc(cbSize);
	if(NULL == pwszProviderName)
	    goto MemoryErr;
	
	//get the provider name and type
	if(!CryptEnumProvidersU
	   (dwIndex,
	    0,
	    0,
	    &dwProviderType,
	    pwszProviderName,
	    &cbSize))
	    goto CryptEnumProvidersUError; 
	
	m_pCertWizardInfo->dwCSPCount       = dwIndex + 1;
	m_pCertWizardInfo->rgdwProviderType = (DWORD *)WizardRealloc
	    (m_pCertWizardInfo->rgdwProviderType, sizeof(DWORD) * m_pCertWizardInfo->dwCSPCount);

	if(NULL == m_pCertWizardInfo->rgdwProviderType)
	    goto MemoryErr;

	m_pCertWizardInfo->rgwszProvider = (LPWSTR *)WizardRealloc
	    (m_pCertWizardInfo->rgwszProvider, sizeof(LPWSTR) * m_pCertWizardInfo->dwCSPCount);

	if(NULL == m_pCertWizardInfo->rgwszProvider)
	    goto MemoryErr;

	(m_pCertWizardInfo->rgdwProviderType)[dwIndex] = dwProviderType;
	(m_pCertWizardInfo->rgwszProvider)[dwIndex]    = pwszProviderName;

	// Our only reference to this data should now be m_pCertWizardInfo->rgwszProvider. 
	pwszProviderName = NULL; 
    }

    //we should have some CSPs
    if(0 == m_pCertWizardInfo->dwCSPCount)
        goto FailErr;
    
    hr = S_OK;
    
 CommonReturn:
    return hr; 
    
ErrorReturn:
    if (NULL != pwszProviderName) { WizardFree(pwszProviderName); } 

     //free the old memory
    FreeProviders(m_pCertWizardInfo->dwCSPCount,
		  m_pCertWizardInfo->rgdwProviderType,
		  m_pCertWizardInfo->rgwszProvider);

    m_pCertWizardInfo->dwCSPCount       = 0;
    m_pCertWizardInfo->rgdwProviderType = NULL;
    m_pCertWizardInfo->rgwszProvider    = NULL;

    goto CommonReturn;

SET_HRESULT(CryptEnumProvidersUError,  HRESULT_FROM_WIN32(GetLastError()));
SET_HRESULT(MemoryErr,                 E_OUTOFMEMORY);
SET_HRESULT(FailErr,                   E_FAIL);
}

//--------------------------------------------------------------------------------
// Machine context and local context now use the same code to get the default prov
HRESULT GetDefaultCSP(IN CERT_WIZARD_INFO *m_pCertWizardInfo, IN BOOL fMachine, OUT UINT *pIdsText, OUT BOOL *pfAllocateCSP)
{
    DWORD     cbProvName    = 0;
    DWORD     dwFlags       = fMachine ? CRYPT_MACHINE_DEFAULT : CRYPT_USER_DEFAULT; 
    HRESULT   hr            = E_FAIL;
    LPWSTR    pwszProvider  = NULL;

    if (NULL == m_pCertWizardInfo)
	return E_POINTER; 

    if (NULL == pfAllocateCSP)
        return E_INVALIDARG; 

    *pfAllocateCSP = FALSE;

    //no provider has been selected
    if(0 == m_pCertWizardInfo->dwProviderType)
        return S_OK;

    //return if user has selected both the dwProviderType
    //or the provider name
    if(NULL != m_pCertWizardInfo->pwszProvider)
        return S_OK;

    //get the default provider
    if (!CryptGetDefaultProviderW(m_pCertWizardInfo->dwProviderType, NULL, dwFlags, NULL, &cbProvName)) 
	goto CryptGetDefaultProviderWError; 

    pwszProvider = (LPWSTR)LocalAlloc(LPTR, cbProvName); 
    if (NULL == pwszProvider)
	goto MemoryError; 
	
    if (!CryptGetDefaultProviderW(m_pCertWizardInfo->dwProviderType, NULL, dwFlags, pwszProvider, &cbProvName)) 
	goto CryptGetDefaultProviderWError; 


    m_pCertWizardInfo->pwszProvider = pwszProvider; 
    pwszProvider = NULL; 
    *pfAllocateCSP = TRUE;
    hr = S_OK; 
CommonReturn:
    if(NULL != pwszProvider)   { LocalFree(pwszProvider); }
    return hr; 

 ErrorReturn:
    *pIdsText = IDS_INVALID_CSP; 
    goto CommonReturn;

SET_HRESULT(CryptGetDefaultProviderWError,  HRESULT_FROM_WIN32(GetLastError())); 
SET_HRESULT(MemoryError,                    E_OUTOFMEMORY);
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//
// LocalContext Implementation.  
// See CertRequestContext.h for method-level documentation. 
//
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

HRESULT LocalContext::BuildCSPList()
{
    return ::BuildCSPList(m_pCertWizardInfo); 
}

BOOL LocalContext::CheckAccessPermission(IN HCERTTYPE hCertType)
{
    BOOL     fResult       = FALSE; 
    HANDLE   hClientToken  = NULL;
    HRESULT  hr            = E_FAIL; 

    // First attempts to get the thread token.  If this fails, acquires the 
    // process token.  Finally, if that fails, returns NULL. 
    if (0 != (m_pCertWizardInfo->dwFlags & CRYPTUI_WIZ_ALLOW_ALL_TEMPLATES)) { 
        fResult = TRUE; 
    } else { 
        hClientToken = this->GetClientIdentity(); 
        if (NULL == hClientToken)
            goto GetClientIdentityError; 

        __try {
            fResult = S_OK == CACertTypeAccessCheck(hCertType, hClientToken); 
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            goto CACertTypeAccessCheckError; 
        }
    }

 CommonReturn:
    if (NULL != hClientToken) { CloseHandle(hClientToken); } 
    return fResult; 

ErrorReturn:
    fResult = FALSE; 
    goto CommonReturn; 

SET_HRESULT(CACertTypeAccessCheckError, HRESULT_FROM_WIN32(GetLastError()));
SET_HRESULT(GetClientIdentityError,     HRESULT_FROM_WIN32(GetLastError())); 
}

BOOL LocalContext::CheckCAPermission(IN HCAINFO hCAInfo)
{
    BOOL    fResult        = FALSE;
    HANDLE  hClientToken   = NULL; 
    HRESULT hr             = E_FAIL; 

    if (0 != (m_pCertWizardInfo->dwFlags & CRYPTUI_WIZ_ALLOW_ALL_CAS)) { 
        fResult = TRUE; 
    } else { 
        hClientToken = this->GetClientIdentity(); 
        if (NULL == hClientToken)
            goto GetClientIdentityError; 

        __try {
            fResult = S_OK == CAAccessCheck(hCAInfo, hClientToken); 
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            goto CAAccessCheckError; 
        }
    }    

 CommonReturn:
    if (NULL != hClientToken) { CloseHandle(hClientToken); } 
    return fResult; 

ErrorReturn:
    fResult = FALSE; 
    goto CommonReturn; 

SET_HRESULT(CAAccessCheckError,      HRESULT_FROM_WIN32(GetLastError()));
SET_HRESULT(GetClientIdentityError,  HRESULT_FROM_WIN32(GetLastError())); 
}

HRESULT LocalContext::GetDefaultCSP(OUT BOOL  *pfAllocateCSP)
{
    return ::GetDefaultCSP(m_pCertWizardInfo, FALSE /*user*/, &m_idsText, pfAllocateCSP); 
}

HRESULT LocalContext::Enroll(OUT  DWORD   *pdwStatus,
                             OUT  HANDLE  *pResult)
{
    BOOL                  fHasNextCSP           = TRUE;
    BOOL                  fRequestIsCached;
    BOOL                  fCreateRequest; 
    BOOL                  fFreeRequest; 
    BOOL                  fSubmitRequest;
    CERT_BLOB             renewCert; 
    CERT_ENROLL_INFO      RequestInfo;
    CERT_REQUEST_PVK_NEW  CertRequestPvkNew; 
    CERT_REQUEST_PVK_NEW  CertRenewPvk; 
    CRYPTUI_WIZ_CERT_CA   CertCA;            
    DWORD                 dwStatus              = CRYPTUI_WIZ_CERT_REQUEST_STATUS_UNKNOWN; 
    DWORD                 dwCSPIndex;        
    DWORD                 dwSavedGenKeyFlags;
    HANDLE                hRequest              = NULL; 
    HRESULT               hr                    = E_FAIL; 
    LPWSTR                pwszHashAlg           = NULL;

    //init 1st for error jump
    ZeroMemory(&CertRenewPvk, sizeof(CertRenewPvk));

    if (NULL == pResult)        
        return E_INVALIDARG; 
    
    if (NULL == m_pCertWizardInfo)
        return E_POINTER; 

    memset(&CertCA, 0, sizeof(CertCA));
    memset(&RequestInfo, 0, sizeof(RequestInfo)); 

    dwSavedGenKeyFlags = m_pCertWizardInfo->dwGenKeyFlags; 

    fCreateRequest = 0 == (m_pCertWizardInfo->dwFlags & (CRYPTUI_WIZ_SUBMIT_ONLY | CRYPTUI_WIZ_FREE_ONLY)); 
    fFreeRequest   = 0 == (m_pCertWizardInfo->dwFlags & (CRYPTUI_WIZ_CREATE_ONLY | CRYPTUI_WIZ_SUBMIT_ONLY)); 
    fSubmitRequest = 0 == (m_pCertWizardInfo->dwFlags & (CRYPTUI_WIZ_CREATE_ONLY | CRYPTUI_WIZ_FREE_ONLY)); 

    // An invalid combination of flags was specified. 
    if (FALSE == (fCreateRequest || fFreeRequest || fSubmitRequest))
        return E_INVALIDARG; 

    // For FREE_ONLY and SUBMIT_ONLY, copy the request from the IN parameter. 
    if (0 != ((CRYPTUI_WIZ_SUBMIT_ONLY | CRYPTUI_WIZ_FREE_ONLY) & m_pCertWizardInfo->dwFlags))
    {
        if (NULL == *pResult)
            return E_INVALIDARG; 

        hRequest = *pResult;
    }

    // Initialize to false ... we need the marshalled parameters to know whether we can cache the request. 
    fRequestIsCached = FALSE; 

    // Iterate over each CA, performing a create and submit operation for each. 
    // Note that we can cache requests for certs if key archival is not needed. 
    // 
    if (fCreateRequest || fSubmitRequest)
    {
        for (IEnumCA CAEnumerator(m_pCertWizardInfo); ; )
        {
            if (S_OK != (CAEnumerator.Next(&CertCA)))
            {
		if (!FAILED(hr)) 
                    hr=E_FAIL;

		if (E_FAIL == hr)
		    m_pCertWizardInfo->idsText = IDS_NO_CA_FOR_ENROLL_REQUEST_FAILED; 

                goto ErrorReturn; 
            }

            // Create a certificate request only if 
            // 1) This is not a submit-only or a free-only operation. 
            // 2) We don't already have a cached request.  
            //    (We can cache requests which don't require key archival on the CA). 
            // 
            // The request is created by looping over available CSPs until one successfully generates
            // the request. 
            // 
            if (TRUE == fCreateRequest && FALSE == fRequestIsCached)
            {
                fHasNextCSP = TRUE; 
                for (IEnumCSP CSPEnumerator(m_pCertWizardInfo); fHasNextCSP; )
                {
                    _JumpCondition(S_OK != (hr = CSPEnumerator.Next(&dwCSPIndex)),     ErrorReturn); 
                    _JumpCondition(S_OK != (hr = CSPEnumerator.HasNext(&fHasNextCSP)), ErrorReturn);
                
                    // Each call to MarshallRequestParameters can change the dwGenKeyFlags of pCertWizardInfo
                    // if the CSP does not support the min key size contained in this field.  
                    // As a result, we must reset the dwGenKeyFlags field to the desired value
                    // before every call to MarshallRequestParameters. 
                    m_pCertWizardInfo->dwGenKeyFlags = dwSavedGenKeyFlags; 
                    if (S_OK != (hr = ::MarshallRequestParameters
                                 (dwCSPIndex, 
                                  m_pCertWizardInfo,
                                  &renewCert,
                                  &CertRequestPvkNew, 
                                  &CertRenewPvk, 
                                  &pwszHashAlg,
                                  &RequestInfo)))
                        goto NextCSP; 
                
                    if (NULL != hRequest)
                    {
                        ::FreeRequest(hRequest);
                        hRequest = NULL;
                    }

                    hr = ::CreateRequest
                        (m_pCertWizardInfo->dwFlags,
                         m_pCertWizardInfo->dwPurpose,
                         CertCA.pwszCAName,
                         CertCA.pwszCALocation,
                         ((CRYPTUI_WIZ_CERT_RENEW & m_pCertWizardInfo->dwPurpose) ? &renewCert : NULL),
                         ((CRYPTUI_WIZ_CERT_RENEW & m_pCertWizardInfo->dwPurpose) ? &CertRenewPvk : NULL),
                         m_pCertWizardInfo->fNewKey,
                         &CertRequestPvkNew,
                         pwszHashAlg,
                         (LPWSTR)m_pCertWizardInfo->pwszDesStore,
                         m_pCertWizardInfo->dwStoreFlags,
                         &RequestInfo,
                         &hRequest); 

                    // Process the return value:
                    if (S_OK == hr)
                    {
			// Success, get rid of whatever error text we have from past creations:
			m_pCertWizardInfo->idsText = 0; 

                        // We're done if we don't need to submit the request.  
                        _JumpCondition(!fSubmitRequest, CommonReturn); 

                        // Cache the request if we don't need support for key archival. 
                        fRequestIsCached = 0 == (CertRequestPvkNew.dwPrivateKeyFlags & CT_FLAG_ALLOW_PRIVATE_KEY_ARCHIVAL);
                        break;
                    }
                    else if (E_ACCESSDENIED == HRESULT_FROM_WIN32(hr)) 
                    { 
                        // E_ACCESSDENIED could indicate one of several different error conditions.  Map this
                        // to an resource identifier which details the possible causes of failure, and try again...
                        m_pCertWizardInfo->idsText = IDS_NO_ACCESS_TO_ICERTREQUEST2; 
                    } 
                    else if (NTE_BAD_ALGID == HRESULT_FROM_WIN32(hr))
                    {
                        // NTE_BAD_ALGID indicates that the CSP didn't support the algorithm type required
                        // by the template.  Map this to a resource identifier that details the possible causes
                        // of failure, and try again...
                        m_pCertWizardInfo->idsText = IDS_CSP_BAD_ALGTYPE; 
                    }
                    else if (HRESULT_FROM_WIN32(ERROR_CANCELLED) == HRESULT_FROM_WIN32(hr))
                    {
                        // The user cancelled the operation.  Don't try to enroll any longer. 
                        goto ErrorReturn;
                    }
                    else
                    {
                        // It's an error, but we don't need to map it to special text.  Just keep processing...
                    }

                    // We're out of CSPs, and we haven't yet created the request!  
                    if (!fHasNextCSP) 
		    {
			// If the template doesn't require key archival, we're done.  Otherwise, we've got to
			// try the other CAs.  Note that if we had a mechanism for knowing whether it was the
			// key archival step 
			if (0 == (CertRequestPvkNew.dwPrivateKeyFlags & CT_FLAG_ALLOW_PRIVATE_KEY_ARCHIVAL))
			    goto ErrorReturn; 
			else
			{
			    ::FreeRequestParameters(&pwszHashAlg, &CertRenewPvk, &RequestInfo); 
			    goto NextCA; 
			}
		    }

                NextCSP:                
                    ::FreeRequestParameters(&pwszHashAlg, &CertRenewPvk, &RequestInfo); 
                }
            }
        
            // Submit the request only if this is not a create-only or a free-only operation: 
            // 
            if (TRUE == fSubmitRequest)
            {            
                hr = ::SubmitRequest
                    (hRequest,
                     FALSE,
                     m_pCertWizardInfo->dwPurpose,
                     m_pCertWizardInfo->fConfirmation,
                     m_pCertWizardInfo->hwndParent,
                     (LPWSTR)m_pCertWizardInfo->pwszConfirmationTitle,
                     m_pCertWizardInfo->idsConfirmTitle,
                     CertCA.pwszCALocation,
                     CertCA.pwszCAName,
                     NULL,
                     NULL,
                     NULL,
                     &dwStatus,
                     (PCCERT_CONTEXT *)pResult);
		if (S_OK == hr)
		{
		    // Success, get rid of whatever error text we have from past submits:
		    m_pCertWizardInfo->idsText = 0; 

		    // If we've successfully submitted or pended
		    goto CommonReturn;
		}
		else if (E_ACCESSDENIED == HRESULT_FROM_WIN32(hr)) 
		{
		    // E_ACCESSDENIED could indicate one of several different error conditions.  Map this
		    // to an resource identifier which details the possible causes of failure, and try again...
		    m_pCertWizardInfo->idsText = IDS_SUBMIT_NO_ACCESS_TO_ICERTREQUEST2;
		}

                // Some error has occured. 
                // If it's a non-CA related error, give up...
                _JumpCondition(dwStatus != CRYPTUI_WIZ_CERT_REQUEST_STATUS_REQUEST_ERROR     &&
                               dwStatus != CRYPTUI_WIZ_CERT_REQUEST_STATUS_REQUEST_DENIED    &&
                               dwStatus != CRYPTUI_WIZ_CERT_REQUEST_STATUS_CONNECTION_FAILED, 
                               ErrorReturn);
            
                // Otherwise, try another CA...
            }
	NextCA:;
	}
    }
    
 CommonReturn:
    // Write the request to pResult for a create only operation: 
    if (hr == S_OK && 0 != (m_pCertWizardInfo->dwFlags & CRYPTUI_WIZ_CREATE_ONLY))
    {
        *pResult = hRequest; 
    }

    // Write the status code, if requested. 
    if (NULL != pdwStatus) { *pdwStatus = dwStatus; } 

    // Free resources. 
    if (NULL != hRequest && fFreeRequest) { ::FreeRequest(hRequest); } 
    ::FreeRequestParameters(&pwszHashAlg, &CertRenewPvk, &RequestInfo); 

    return hr; 

 ErrorReturn:
    goto CommonReturn;
}


HRESULT LocalContext::QueryRequestStatus(IN HANDLE hRequest, OUT CRYPTUI_WIZ_QUERY_CERT_REQUEST_INFO *pQueryInfo)
{
    HRESULT hr; 

    if (!QueryRequest(hRequest, pQueryInfo))
        goto QueryRequestError; 

    hr = S_OK; 
 ErrorReturn:
    return hr; 

SET_HRESULT(QueryRequestError, GetLastError());
}

HRESULT KeySvcContext::QueryRequestStatus(IN HANDLE hRequest, OUT CRYPTUI_WIZ_QUERY_CERT_REQUEST_INFO *pQueryInfo)
{
    HRESULT                 hr              = E_FAIL; 
    KEYSVCC_HANDLE          hKeyService     = NULL;
    KEYSVC_TYPE             dwServiceType   = KeySvcMachine;
    LPSTR                   pszMachineName  = NULL;

    if (NULL == m_pCertWizardInfo)
        return E_POINTER; 

    if (0 != (hr = ::KeyOpenKeyService(pszMachineName,
				       dwServiceType,
				       (LPWSTR)(m_pCertWizardInfo->pwszAccountName),  // Service name if necessary
				       NULL,     // no authentication string right now
				       NULL,
				       &hKeyService)))
	goto KeyOpenKeyServiceError; 

    if (0 != (hr = ::KeyQueryRequestStatus(hKeyService, hRequest, pQueryInfo)))
        goto KeyQueryRequestStatusError; 

    hr = S_OK; 
 ErrorReturn:
    if (NULL != hKeyService)    { KeyCloseKeyService(hKeyService, NULL); } 
    if (NULL != pszMachineName) { FreeMBStr(NULL,pszMachineName); } 
    return hr; 
 

TRACE_ERROR(KeyOpenKeyServiceError);
TRACE_ERROR(KeyQueryRequestStatusError); 
}
                             
HRESULT LocalContext::Initialize()
{
    return S_OK;
}

HANDLE LocalContext::GetClientIdentity()
{
    HANDLE  hHandle       = NULL;
    HANDLE  hClientToken  = NULL; 
    HANDLE  hProcessToken = NULL; 
    HRESULT hr; 

    // Step 1: attempt to acquire the thread token.  
    hHandle = GetCurrentThread();
    if (NULL == hHandle)
	goto GetThreadTokenError; 
    
    if (!OpenThreadToken(hHandle,
			 TOKEN_QUERY,
			 TRUE,           // open as self
			 &hClientToken))
	goto GetThreadTokenError; 
    
    // We got the thread token:
    goto GetThreadTokenSuccess;
    
    // Step 2:  we've failed to acquire the thread token, 
    //          try to get the process token.  
 GetThreadTokenError:
    if (hHandle != NULL) { CloseHandle(hHandle); } 
    
    // We failed to get the thread token, now try to acquire the process token:
    hHandle = GetCurrentProcess();
    if (NULL == hHandle)
	goto GetProcessHandleError; 
    
    if (!OpenProcessToken(hHandle,
			  TOKEN_DUPLICATE,
			  &hProcessToken))
	goto OpenProcessTokenError; 
    
    if(!DuplicateToken(hProcessToken,
		       SecurityImpersonation,
		       &hClientToken))
	goto DuplicateTokenError;
    
 GetThreadTokenSuccess:
 CommonReturn:
    if (NULL != hHandle)       { CloseHandle(hHandle); } 
    if (NULL != hProcessToken) { CloseHandle(hProcessToken); } 
    
    return hClientToken; 
    
 ErrorReturn:
    goto CommonReturn; 
    
SET_HRESULT(DuplicateTokenError,   HRESULT_FROM_WIN32(GetLastError())); 
SET_HRESULT(GetProcessHandleError, HRESULT_FROM_WIN32(GetLastError())); 
SET_HRESULT(OpenProcessTokenError, HRESULT_FROM_WIN32(GetLastError())); 
}    


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//
// KeySvcContext Implementation.  
// See requesters.h for method-level documentation. 
//
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


HRESULT KeySvcContext::BuildCSPList()
{
    return ::BuildCSPList(m_pCertWizardInfo); 
}

BOOL KeySvcContext::CheckAccessPermission(IN HCERTTYPE hCertType)
{
    LPWSTR   *awszCurrentType = NULL; 
    LPWSTR   *awszTypeName    = NULL; 
    
    if (NULL == m_pCertWizardInfo)
    {
	SetLastError(ERROR_INVALID_DATA);
	return FALSE; 
    }

    if (0 != (m_pCertWizardInfo->dwFlags & CRYPTUI_WIZ_ALLOW_ALL_TEMPLATES)) { 
        return TRUE; 
    } 

    if(NULL != m_pCertWizardInfo->awszAllowedCertTypes)
    {
	if(S_OK == CAGetCertTypeProperty(hCertType, CERTTYPE_PROP_DN, &awszTypeName))
        {
	    if(NULL != awszTypeName)
            {
		if(NULL != awszTypeName[0])
                {
		    awszCurrentType = m_pCertWizardInfo->awszAllowedCertTypes; 

		    while(NULL != *awszCurrentType)
                    {
			if(wcscmp(*awszCurrentType, awszTypeName[0]) == 0)
                        {
                            return TRUE; 
			}
			awszCurrentType++;
		    }
		}
		
		CAFreeCertTypeProperty(hCertType, awszTypeName);
	    }
	}
    }

    return FALSE; 
}


BOOL KeySvcContext::CheckCAPermission(IN HCAINFO hCAInfo)
{
    LPWSTR *wszCAName    = NULL;
    LPWSTR *wszCurrentCA = NULL;
    
    if (NULL == m_pCertWizardInfo)
    {
	SetLastError(ERROR_INVALID_DATA);
	return FALSE; 
    }

    if (0 != (m_pCertWizardInfo->dwFlags & CRYPTUI_WIZ_ALLOW_ALL_CAS)) { 
        return TRUE; 
    } 

    if (NULL != m_pCertWizardInfo->awszValidCA)
    {
	if(S_OK == CAGetCAProperty(hCAInfo, CA_PROP_NAME, &wszCAName))
        {
	    if(NULL != wszCAName)
            {
		if(NULL != wszCAName[0])
                {
		    wszCurrentCA = m_pCertWizardInfo->awszValidCA; 
			
		    while(*wszCurrentCA)
                    {
			if(0 == wcscmp(*wszCurrentCA, wszCAName[0]))
                        {
			    return TRUE; 
			}
			wszCurrentCA++;
		    }
		}
		
		CAFreeCAProperty(hCAInfo, wszCAName);
	    }
	}
    }

    return FALSE; 
}

HRESULT KeySvcContext::GetDefaultCSP(OUT BOOL *pfAllocateCSP)
{
    return ::GetDefaultCSP(m_pCertWizardInfo, TRUE /*machine*/, &m_idsText, pfAllocateCSP); 
}

HRESULT WhistlerMachineContext::Enroll(OUT     DWORD    *pdwStatus,
                                       IN OUT  HANDLE   *pResult)
{
    BOOL                  fRequestIsCached;
    BOOL                  fCreateRequest        = 0 == (m_pCertWizardInfo->dwFlags & (CRYPTUI_WIZ_SUBMIT_ONLY | CRYPTUI_WIZ_FREE_ONLY)); 
    BOOL                  fFreeRequest          = 0 == (m_pCertWizardInfo->dwFlags & (CRYPTUI_WIZ_CREATE_ONLY | CRYPTUI_WIZ_SUBMIT_ONLY)); 
    BOOL                  fSubmitRequest        = 0 == (m_pCertWizardInfo->dwFlags & (CRYPTUI_WIZ_CREATE_ONLY | CRYPTUI_WIZ_FREE_ONLY)); 
    CERT_BLOB             renewCert; 
    CERT_ENROLL_INFO      RequestInfo;
    CERT_REQUEST_PVK_NEW  CertRequestPvkNew; 
    CERT_REQUEST_PVK_NEW  CertRenewPvk; 
    CRYPTUI_WIZ_CERT_CA   CertCA; 
    DWORD                 dwStatus              = CRYPTUI_WIZ_CERT_REQUEST_STATUS_UNKNOWN; 
    DWORD                 dwCSPIndex;        
    DWORD                 dwSavedGenKeyFlags;
    HANDLE                hRequest              = NULL; 
    HRESULT               hr                    = E_FAIL; 
    KEYSVCC_HANDLE        hKeyService           = NULL;
    KEYSVC_TYPE           ktServiceType; 
    LPSTR                 pszMachineName        = NULL; 
    LPWSTR                pwszHashAlg           = NULL;

    //init 1st for error jump
    ZeroMemory(&CertRenewPvk, sizeof(CertRenewPvk));

    if (NULL == pResult)        
        return E_INVALIDARG; 
    
    if (NULL == m_pCertWizardInfo)
        return E_POINTER; 

    memset(&renewCert,  0, sizeof(renewCert)); 
    memset(&CertCA,     0, sizeof(CertCA));
    memset(&RequestInfo, 0, sizeof(RequestInfo)); 

    dwSavedGenKeyFlags = m_pCertWizardInfo->dwGenKeyFlags; 

    // An invalid combination of flags was specified. 
    if (FALSE == (fCreateRequest || fFreeRequest || fSubmitRequest))
        return E_INVALIDARG; 

    // For FREE_ONLY and SUBMIT_ONLY, copy the request from the IN parameter. 
    if (0 != ((CRYPTUI_WIZ_SUBMIT_ONLY | CRYPTUI_WIZ_FREE_ONLY) & m_pCertWizardInfo->dwFlags))
    {
        if (NULL == *pResult)
            return E_INVALIDARG; 

        hRequest = *pResult;
    }

    if(!MkMBStr(NULL, 0, m_pCertWizardInfo->pwszMachineName, &pszMachineName))
        goto MkMBStrError; 

    ktServiceType = NULL != m_pCertWizardInfo->pwszAccountName ? KeySvcService : KeySvcMachine;

    hr = ::KeyOpenKeyService
        (pszMachineName,
         ktServiceType,
         (LPWSTR)(m_pCertWizardInfo->pwszAccountName), 
         NULL,
         NULL,
         &hKeyService); 
    _JumpConditionWithExpr(S_OK != hr, KeyOpenKeyServiceError, m_idsText = IDS_RPC_CALL_FAILED);

    // Initialize to false ... we need the marshalled parameters to know whether we can cache the request. 
    fRequestIsCached = FALSE; 

    // Iterate over each CA, performing a create and submit operation for each. 
    // Note that we can cache requests for certs if key archival is not needed. 
    // 
    if (fCreateRequest || fSubmitRequest)
    {
        for (IEnumCA CAEnumerator(m_pCertWizardInfo); ; )
        {
            if (S_OK != (CAEnumerator.Next(&CertCA)))
            {
		if(!FAILED(hr)) 
		    hr=E_FAIL;

		if (E_FAIL == hr)
		    m_pCertWizardInfo->idsText = IDS_NO_CA_FOR_ENROLL_REQUEST_FAILED; 

                goto ErrorReturn; 
            }

            // Create a certificate request only if 
            // 1) This is not a submit-only or a free-only operation. 
            // 2) We don't already have a cached request.  
            //    (We can cache requests which don't require key archival on the CA). 
            // 
            // The request is created by looping over available CSPs until one successfully generates
            // the request. 
            // 
            
            if (TRUE == fCreateRequest && FALSE == fRequestIsCached)
            {
                BOOL fHasNextCSP = TRUE; 
                for (IEnumCSP CSPEnumerator(m_pCertWizardInfo); fHasNextCSP; )
                {
                    _JumpCondition(S_OK != (hr = CSPEnumerator.Next(&dwCSPIndex)),     ErrorReturn); 
                    _JumpCondition(S_OK != (hr = CSPEnumerator.HasNext(&fHasNextCSP)), ErrorReturn);

                    // Each call to MarshallRequestParameters can change the dwGenKeyFlags of pCertWizardInfo
                    // if the CSP does not support the min key size contained in this field.  
                    // As a result, we must reset the dwGenKeyFlags field to the desired value
                    // before every call to MarshallRequestParameters. 
                    m_pCertWizardInfo->dwGenKeyFlags = dwSavedGenKeyFlags; 
                    if (S_OK != (hr = ::MarshallRequestParameters
                                 (dwCSPIndex, 
                                  m_pCertWizardInfo,
                                  &renewCert,
                                  &CertRequestPvkNew, 
                                  &CertRenewPvk, 
                                  &pwszHashAlg,
                                  &RequestInfo)))
                        goto NextCSP; 

                    if (NULL != hRequest)
                    {
                        this->FreeRequest(hKeyService, pszMachineName, &hRequest); 
                        hRequest = NULL; 
                    }

                    hr = this->CreateRequest
                        (hKeyService,
                         pszMachineName, 
                         CertCA.pwszCALocation,
                         CertCA.pwszCAName,
                         &CertRequestPvkNew, 
                         &renewCert, 
                         &CertRenewPvk, 
                         pwszHashAlg, 
                         &RequestInfo, 
                         &hRequest); 

                    // Process the return value:
                    if (S_OK == hr)
                    {
			// Success, get rid of whatever error text we have from past creations:
			m_pCertWizardInfo->idsText = 0; 

                        // We're done if we don't need to submit the request.  
                        _JumpCondition(!fSubmitRequest, CommonReturn); 

                        // Cache the request if we don't need support for key archival. 
                        fRequestIsCached = 0 == (CertRequestPvkNew.dwPrivateKeyFlags & CT_FLAG_ALLOW_PRIVATE_KEY_ARCHIVAL);
                        break;
                    }
                    else if (E_ACCESSDENIED == HRESULT_FROM_WIN32(hr)) 
                    { 
                        // E_ACCESSDENIED could indicate one of several different error conditions.  Map this
                        // to an resource identifier which details the possible causes of failure, and try again...
                        m_pCertWizardInfo->idsText = IDS_NO_ACCESS_TO_ICERTREQUEST2; 
                    } 
                    else if (NTE_BAD_ALGID == HRESULT_FROM_WIN32(hr))
                    {
                        // NTE_BAD_ALGID indicates that the CSP didn't support the algorithm type required
                        // by the template.  Map this to a resource identifier that details the possible causes
                        // of failure, and try again...
                        m_pCertWizardInfo->idsText = IDS_CSP_BAD_ALGTYPE; 
                    }
                    else if (HRESULT_FROM_WIN32(ERROR_CANCELLED) == HRESULT_FROM_WIN32(hr))
                    {
                        // The user cancelled the operation.  Don't try to enroll any longer. 
                        goto ErrorReturn;
                    }
                    else
                    {
                        // It's an error, but we don't need to map it to special text.  Just keep processing...
                    }
		    
                    // We're out of CSPs, and we haven't yet created the request!  
                    if (!fHasNextCSP) 
		    {
			// If the template doesn't require key archival, we're done.  Otherwise, we've got to
			// try the other CAs.  Note that if we had a mechanism for knowing whether it was the
			// key archival step 
			if (0 == (CertRequestPvkNew.dwPrivateKeyFlags & CT_FLAG_ALLOW_PRIVATE_KEY_ARCHIVAL))
			    goto ErrorReturn; 
			else
			{
			    ::FreeRequestParameters(&pwszHashAlg, &CertRenewPvk, &RequestInfo); 
			    goto NextCA; 
			}
		    }
                
                NextCSP:                
                    ::FreeRequestParameters(&pwszHashAlg, &CertRenewPvk, &RequestInfo); 
                }
            }

            if (TRUE == fSubmitRequest)
            {
                hr = this->SubmitRequest
                    (hKeyService,
                     pszMachineName,
                     CertCA.pwszCALocation,
                     CertCA.pwszCAName, 
                     hRequest, 
                     (PCCERT_CONTEXT *)pResult, 
                     &dwStatus); 
		if (S_OK == hr)
		{
		    // Success, get rid of whatever error text we have from past submits:
		    m_pCertWizardInfo->idsText = 0; 

		    // If we've successfully submitted or pended
		    goto CommonReturn;
		}
		else if (E_ACCESSDENIED == HRESULT_FROM_WIN32(hr)) 
		{
		    // E_ACCESSDENIED could indicate one of several different error conditions.  Map this
		    // to an resource identifier which details the possible causes of failure, and try again...
		    m_pCertWizardInfo->idsText = IDS_SUBMIT_NO_ACCESS_TO_ICERTREQUEST2;
		}
            
                // Some error has occured. 
                // If it's a non-CA related error, give up...
                _JumpCondition(dwStatus != CRYPTUI_WIZ_CERT_REQUEST_STATUS_REQUEST_ERROR     &&
                               dwStatus != CRYPTUI_WIZ_CERT_REQUEST_STATUS_REQUEST_DENIED    &&
                               dwStatus != CRYPTUI_WIZ_CERT_REQUEST_STATUS_CONNECTION_FAILED,
                               ErrorReturn);

                // Otherwise, try another CA...
            }
	NextCA:;
        }
    }    

 CommonReturn:
    // Write the request to pResult for a create only operation: 
    if (hr == S_OK && 0 != (m_pCertWizardInfo->dwFlags & CRYPTUI_WIZ_CREATE_ONLY))
    {
        *pResult = hRequest; 
    }

    // Write the status code, if requested. 
    if (NULL != pdwStatus) { *pdwStatus = dwStatus; } 

    // Free resources. 
    if (NULL != hRequest && TRUE == fFreeRequest)  { this->FreeRequest(hKeyService, pszMachineName, hRequest); }
    if (NULL != hKeyService)                       { ::KeyCloseKeyService(hKeyService, NULL); } 
    if (NULL != pszMachineName)                    { ::FreeMBStr(NULL,pszMachineName); }

    ::FreeRequestParameters(&pwszHashAlg, &CertRenewPvk, &RequestInfo); 

    return hr; 

 ErrorReturn:
    goto CommonReturn;

SET_HRESULT(KeyOpenKeyServiceError,  hr);
SET_HRESULT(MkMBStrError,            HRESULT_FROM_WIN32(GetLastError()));
}

HRESULT WhistlerMachineContext::CreateRequest
(IN  KEYSVCC_HANDLE         hKeyService, 
 IN  LPSTR                  pszMachineName,                   
 IN  LPWSTR                 pwszCALocation,                  
 IN  LPWSTR                 pwszCAName,  
 IN  PCERT_REQUEST_PVK_NEW  pKeyNew,     
 IN  CERT_BLOB             *pCert,       
 IN  PCERT_REQUEST_PVK_NEW  pRenewKey,   
 IN  LPWSTR                 pwszHashAlg,  
 IN  PCERT_ENROLL_INFO      pRequestInfo,
 OUT HANDLE                *phRequest)
{
    DWORD dwFlags = m_pCertWizardInfo->dwFlags;

    dwFlags  &= ~(CRYPTUI_WIZ_SUBMIT_ONLY | CRYPTUI_WIZ_FREE_ONLY);
    dwFlags  |= CRYPTUI_WIZ_CREATE_ONLY; 

    // Create the certificate request...
    return ::KeyEnroll_V2
        (hKeyService,
	 pszMachineName,
         TRUE,
         m_pCertWizardInfo->dwPurpose,
         dwFlags, 
         (LPWSTR)(m_pCertWizardInfo->pwszAccountName),
         NULL, 
         (CRYPTUI_WIZ_CERT_ENROLL & m_pCertWizardInfo->dwPurpose) ? TRUE : FALSE,
         pwszCALocation,
         pwszCAName, 
         m_pCertWizardInfo->fNewKey,
         pKeyNew, 
         pCert, 
         pRenewKey,
         pwszHashAlg,
         (LPWSTR)m_pCertWizardInfo->pwszDesStore,
         m_pCertWizardInfo->dwStoreFlags,
         pRequestInfo,
         (LPWSTR)m_pCertWizardInfo->pwszRequestString, 
         0,
         NULL,
         phRequest, 
         NULL,
         NULL,
         NULL); 
}


HRESULT WhistlerMachineContext::SubmitRequest
(IN  KEYSVCC_HANDLE   hKeyService,
 IN  LPSTR            pszMachineName,                   
 IN  LPWSTR           pwszCALocation,                  
 IN  LPWSTR           pwszCAName,  
 IN  HANDLE           hRequest, 
 OUT PCCERT_CONTEXT  *ppCertContext, 
 OUT DWORD           *pdwStatus) 
{               
    CERT_BLOB HashBlob;
    CERT_BLOB PKCS7Blob; 
    HRESULT   hr         = E_FAIL; 

    memset(&HashBlob,   0, sizeof(HashBlob)); 
    memset(&PKCS7Blob,  0, sizeof(PKCS7Blob)); 
    

    DWORD dwFlags = m_pCertWizardInfo->dwFlags;

    dwFlags  &= ~(CRYPTUI_WIZ_CREATE_ONLY | CRYPTUI_WIZ_FREE_ONLY);
    dwFlags  |= CRYPTUI_WIZ_SUBMIT_ONLY; 

    // Submit the certificate request...
    hr = ::KeyEnroll_V2
        (hKeyService, 
	 pszMachineName,
         TRUE,
         m_pCertWizardInfo->dwPurpose,
         dwFlags, 
         (LPWSTR)(m_pCertWizardInfo->pwszAccountName),
         NULL, 
         (CRYPTUI_WIZ_CERT_ENROLL & m_pCertWizardInfo->dwPurpose) ? TRUE : FALSE,
         pwszCALocation,
         pwszCAName, 
         m_pCertWizardInfo->fNewKey,
         NULL,
         NULL,
         NULL, 
         NULL,
         NULL, 
         0, 
         NULL, 
         NULL, 
         0,
         NULL,
         &hRequest, 
         &PKCS7Blob, 
         &HashBlob, 
         pdwStatus); 
    
    if (S_OK == hr && CRYPTUI_WIZ_CERT_REQUEST_STATUS_SUCCEEDED == *pdwStatus)
    {
        hr = this->ToCertContext
            (&PKCS7Blob, 
             &HashBlob, 
             pdwStatus,
             ppCertContext); 
    }

    if (NULL != HashBlob.pbData)  { ::WizardFree(HashBlob.pbData); }
    if (NULL != PKCS7Blob.pbData) { ::WizardFree(PKCS7Blob.pbData); }

    return hr; 
}

void WhistlerMachineContext::FreeRequest
(IN KEYSVCC_HANDLE  hKeyService, 
 IN LPSTR           pszMachineName, 
 IN HANDLE          hRequest)
{
    DWORD dwFlags = m_pCertWizardInfo->dwFlags;

    dwFlags  &= ~(CRYPTUI_WIZ_CREATE_ONLY | CRYPTUI_WIZ_SUBMIT_ONLY);
    dwFlags  |= CRYPTUI_WIZ_FREE_ONLY; 

    ::KeyEnroll_V2
          (hKeyService, 
	   pszMachineName,
           TRUE,
           0, 
           dwFlags, 
           NULL, 
           NULL, 
           FALSE, 
           NULL, 
           NULL, 
           FALSE, 
           NULL,
           NULL,
           NULL, 
           NULL,
           NULL, 
           0, 
           NULL, 
           NULL, 
           0,
           NULL,
           &hRequest, 
           NULL, 
           NULL, 
           NULL); 
}

HRESULT KeySvcContext::ToCertContext(IN  CERT_BLOB       *pPKCS7Blob, 
                                     IN  CERT_BLOB       *pHashBlob, 
                                     OUT DWORD           *pdwStatus, 
                                     OUT PCCERT_CONTEXT  *ppCertContext)
{
    HCERTSTORE hCertStore = NULL; 
    HRESULT    hr         = E_FAIL; 

    if (NULL == pPKCS7Blob || NULL == pHashBlob || NULL == ppCertContext)
        return E_INVALIDARG; 
    
    //get the certificate store from the PKCS7 for the remote case
    if (!::CryptQueryObject(CERT_QUERY_OBJECT_BLOB,
                            pPKCS7Blob,
                            CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED,
                            CERT_QUERY_FORMAT_FLAG_ALL,
                            0,
                            NULL,
                            NULL,
                            NULL,
                            &hCertStore,
                            NULL,
                            NULL))
    {
        if (NULL != pdwStatus) { *pdwStatus = CRYPTUI_WIZ_CERT_REQUEST_STATUS_INSTALL_FAILED; }
        goto FailError; 
    }

    //find the certificate based on the hash
    if (NULL == (*ppCertContext = ::CertFindCertificateInStore
                 (hCertStore,
                  X509_ASN_ENCODING,
                  0,
                  CERT_FIND_SHA1_HASH,
                  pHashBlob, 
                  NULL)))
    {
        if (NULL != pdwStatus) { *pdwStatus = CRYPTUI_WIZ_CERT_REQUEST_STATUS_INSTALL_FAILED; }
        goto FailError; 
    }

    hr = S_OK; 

 CommonReturn:
    if(NULL != hCertStore) { CertCloseStore(hCertStore, 0); }
    return hr; 

 ErrorReturn:
    if (NULL != pdwStatus && 0 == *pdwStatus) { *pdwStatus = CRYPTUI_WIZ_CERT_REQUEST_STATUS_KEYSVC_FAILED; }
    goto CommonReturn; 

SET_HRESULT(FailError, E_FAIL);
}


HRESULT KeySvcContext::Initialize()
{
    if (NULL == m_pCertWizardInfo)
        return E_POINTER; 

    // We don't need to download the list of allowed templates if we're not going
    // to be performing the access check anyway. 
    if (0 == (m_pCertWizardInfo->dwFlags & CRYPTUI_WIZ_ALLOW_ALL_TEMPLATES)) 
    { 
        //for the remote enrollment, we have to get the allowed cert type
        //list from the key service.  
        if(!::GetCertTypeName(m_pCertWizardInfo))
        {
            m_idsText = IDS_NO_VALID_CERT_TEMPLATE;
            return HRESULT_FROM_WIN32(GetLastError()); 
        }
    }

    // We don't need to download the list of allowed CAs if we're not going
    // to be performing the access check anyway
    if (0 == (m_pCertWizardInfo->dwFlags & CRYPTUI_WIZ_ALLOW_ALL_CAS))
    {
        if(!::GetCAName(m_pCertWizardInfo))
        {
            m_idsText = IDS_NO_CA_FOR_ENROLL;
            return HRESULT_FROM_WIN32(GetLastError()); 
        }
    }    
    return S_OK; 
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//
// CertRequesterContext:  implementation of abstract superclass. 
// See requesters.h for method-level documentation. 
//
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

HRESULT CertRequesterContext::MakeDefaultCertRequesterContext
(OUT  CertRequesterContext **ppRequesterContext)
{
    CERT_WIZARD_INFO  *pCertWizardInfo  = NULL; 
    HRESULT            hr; 
    
    pCertWizardInfo = (CERT_WIZARD_INFO *)WizardAlloc(sizeof(CERT_WIZARD_INFO)); 
    _JumpCondition(NULL == pCertWizardInfo, MemoryError); 

    hr = MakeCertRequesterContext
        (NULL,
         NULL,
         0,
         pCertWizardInfo, 
         ppRequesterContext,
         NULL); 
    _JumpCondition(S_OK != hr, MakeCertRequesterContextError); 

    hr = S_OK; 
 CommonReturn: 
    return hr; 

 ErrorReturn:
    if (NULL != pCertWizardInfo) { WizardFree(pCertWizardInfo); } 
    goto CommonReturn; 

SET_HRESULT(MakeCertRequesterContextError,  hr); 
SET_HRESULT(MemoryError,                    E_OUTOFMEMORY); 
}

HRESULT CertRequesterContext::MakeCertRequesterContext
(IN  LPCWSTR                pwszAccountName, 
 IN  LPCWSTR                pwszMachineName,
 IN  DWORD                  dwCertOpenStoreFlags, 
 IN  CERT_WIZARD_INFO      *pCertWizardInfo,
 OUT CertRequesterContext **ppRequesterContext, 
 OUT UINT                  *pIDSText)
{
    BOOL         fMachine                                    = FALSE; 
    DWORD  const dwLocalUserNameSize                         = UNLEN + 1; 
    DWORD  const dwLocalMachineNameSize                      = MAX_COMPUTERNAME_LENGTH + 1; 
    HRESULT      hr                                          = E_FAIL; 
    UINT         idsText                                     = NULL == pIDSText ? 0 : *pIDSText; 
    WCHAR        wszLocalUserName[dwLocalUserNameSize]       = { 0 }; 
    WCHAR        wszLocalMachineName[dwLocalMachineNameSize] = { 0 }; 

    // Input validation: 
    if (NULL == pCertWizardInfo || NULL == ppRequesterContext)
	return E_INVALIDARG; 
	
    // Should not have assigned values to these fields yet: 
    if (NULL != pCertWizardInfo->pwszAccountName || NULL != pCertWizardInfo->pwszMachineName)
	return E_INVALIDARG; 

    if(!GetUserNameU(wszLocalUserName, (DWORD *)&dwLocalUserNameSize))
    {
	idsText=IDS_FAIL_TO_GET_USER_NAME;
	goto Win32Error;
    }

    if(!GetComputerNameU(wszLocalMachineName, (DWORD *)&dwLocalMachineNameSize))
    {
	idsText=IDS_FAIL_TO_GET_COMPUTER_NAME;
	goto Win32Error;
    }

    // Map all unspecified values to defaults: 
    // 

    // Default #1: NULL pwszAccountName indicates current user _iff_ pwszMachineName is NULL. 
    if (NULL == pwszAccountName && NULL == pwszMachineName)
	{ pwszAccountName = wszLocalUserName; } 

    // Default #2: NULL pwszMachineName indicates local machine. 
    if (NULL == pwszMachineName)                            
	{ pwszMachineName = wszLocalMachineName; } 

    // Default #3: NULL pwszAccountName and non-NULL pwszMachineName indicates machine enrollment. 
    fMachine = (NULL == pwszAccountName                                 || 
                (0 != _wcsicmp(pwszAccountName, wszLocalUserName))      ||
                (0 != _wcsicmp(pwszMachineName, wszLocalMachineName))); 

    // Default #4: dwCertOpenStoreFlags == 0 defaults to CERT_SYSTEM_STORE_LOCAL_MACHINE
    //             for machine enrollment, CERT_SYSTEM_STORE_CURRENT_USER for user enrollment. 
    if (0 == dwCertOpenStoreFlags)
	{ dwCertOpenStoreFlags = fMachine ? CERT_SYSTEM_STORE_LOCAL_MACHINE : CERT_SYSTEM_STORE_CURRENT_USER; }

    // Now that we've mapped unspecified values to defaults, assign the wizard's fields
    // with these values: 
    //
    if (NULL != pwszAccountName)
    {
	pCertWizardInfo->pwszAccountName = (LPWSTR)WizardAlloc(sizeof(WCHAR) * (wcslen(pwszAccountName) + 1));
	_JumpConditionWithExpr(NULL == pCertWizardInfo->pwszAccountName, MemoryError, idsText = IDS_OUT_OF_MEMORY); 
	wcscpy((LPWSTR)pCertWizardInfo->pwszAccountName, pwszAccountName); 
    }

    pCertWizardInfo->pwszMachineName = (LPWSTR)WizardAlloc(sizeof(WCHAR) * (wcslen(pwszMachineName) + 1));
    _JumpConditionWithExpr(NULL == pCertWizardInfo->pwszMachineName, MemoryError, idsText = IDS_OUT_OF_MEMORY); 
    wcscpy((LPWSTR)pCertWizardInfo->pwszMachineName, pwszMachineName); 

    pCertWizardInfo->fMachine        = fMachine; 
    pCertWizardInfo->dwStoreFlags    = dwCertOpenStoreFlags; 

    // We need keysvc if: 
    // 
    // 1) We're doing machine enrollment (we need to run under the local machine's context).
    // 2) An account _other_ than the current user on the local machine is specified.
    //    (we need to run under another user's context). 
    //
    if (TRUE == fMachine)
    {
	KEYSVC_TYPE             ktServiceType;  
        KEYSVC_OPEN_KEYSVC_INFO OpenKeySvcInfo    = { sizeof(KEYSVC_OPEN_KEYSVC_INFO), 0 }; 
        KEYSVCC_HANDLE          hKeyService       = NULL; 
        LPSTR                   pszMachineName    = NULL; 

        ktServiceType = NULL != pwszAccountName ? KeySvcService : KeySvcMachine;
        _JumpConditionWithExpr(!MkMBStr(NULL, 0, pwszMachineName, &pszMachineName), MkMBStrError, idsText = IDS_OUT_OF_MEMORY); 

        // See if we're enrolling for a W2K or a Whistler machine:
        hr = KeyOpenKeyService
            (pszMachineName, 
             ktServiceType, 
             (LPWSTR)pwszAccountName, 
             NULL, 
             NULL, 
             &hKeyService);
        _JumpConditionWithExpr(S_OK != hr, KeyOpenKeyServiceError, idsText = IDS_RPC_CALL_FAILED); 

	*ppRequesterContext = new WhistlerMachineContext(pCertWizardInfo); 
    }
    else
    {
	// We're requesting a cert for ourselves:  we don't need keysvc. 
	*ppRequesterContext = new LocalContext(pCertWizardInfo);
    }
    
    if (NULL == *ppRequesterContext)
	goto MemoryError; 

    hr = S_OK;

 CommonReturn:
    return hr; 

 ErrorReturn:
    if (NULL != pCertWizardInfo->pwszMachineName) { WizardFree((LPVOID)pCertWizardInfo->pwszMachineName); } 
    if (NULL != pCertWizardInfo->pwszAccountName) { WizardFree((LPVOID)pCertWizardInfo->pwszAccountName); } 
    pCertWizardInfo->pwszMachineName = NULL;
    pCertWizardInfo->pwszAccountName = NULL;

    // Assign error text if specified:
    if (NULL != pIDSText) { *pIDSText = idsText; } 
    goto CommonReturn; 

SET_HRESULT(MemoryError,             E_OUTOFMEMORY); 
SET_HRESULT(KeyOpenKeyServiceError,  hr);
SET_HRESULT(MkMBStrError,            HRESULT_FROM_WIN32(GetLastError()));
SET_HRESULT(Win32Error,              HRESULT_FROM_WIN32(GetLastError())); 
}

CertRequesterContext::~CertRequesterContext()
{
    if (NULL != m_pCertWizardInfo)
    {
        if (NULL != m_pCertWizardInfo->pwszMachineName) { WizardFree((LPVOID)m_pCertWizardInfo->pwszMachineName); } 
        if (NULL != m_pCertWizardInfo->pwszAccountName) { WizardFree((LPVOID)m_pCertWizardInfo->pwszAccountName); } 
        m_pCertWizardInfo->pwszMachineName = NULL;
        m_pCertWizardInfo->pwszAccountName = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\ui\wizards\droptrgt.cpp ===
//-------------------------------------------------------------
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       droptrgt.cpp
//
//  Contents:   The cpp file to implement IDropTarget
//
//  History:    March-9th-98 xiaohs   created
//
//--------------------------------------------------------------
#include    "wzrdpvk.h"
#include    "mgrcert.h"

//============================================================================
//
//  the definition of the CCertMgrDropTarget class which supports IDropTarget
//============================================================================

class CCertMgrDropTarget : public IDropTarget
{
private:

    LPDATAOBJECT        m_pDataObj;
    ULONG               m_cRefs;
    DWORD               m_grfKeyStateLast;
    BOOL                m_fHasHDROP;
    DWORD               m_dwEffectLastReturned;
    HWND                m_hwndDlg;
    CERT_MGR_INFO       *m_pCertMgrInfo;


public:
    
    CCertMgrDropTarget(HWND                hwndDlg,
                       CERT_MGR_INFO       *pCertMgrInfo);

    ~CCertMgrDropTarget();

    STDMETHODIMP            QueryInterface      (REFIID riid,LPVOID FAR *ppv);
    STDMETHODIMP_(ULONG)    AddRef              ();
    STDMETHODIMP_(ULONG)    Release             ();
    STDMETHODIMP            DragEnter           (LPDATAOBJECT pDataObj, 
										         DWORD        grfKeyState,
                                                 POINTL       pt, 
                                                 LPDWORD      pdwEffect);
    STDMETHODIMP            DragOver            (DWORD        grfKeyState, 
                                                 POINTL       pt, 
                                                 LPDWORD      pdwEffect);
    STDMETHODIMP            DragLeave           ();
    STDMETHODIMP            Drop                (LPDATAOBJECT pDataObj,
                                                 DWORD        grfKeyState, 
                                                 POINTL       pt, 
                                                 LPDWORD      pdwEffect);
    DWORD                   GetDropEffect       (LPDWORD      pdwEffect);
};       


//============================================================================
//
//  Implementation of CCertMgrDropTarget_CreateInstance
//============================================================================
HRESULT  CCertMgrDropTarget_CreateInstance(HWND                 hwndDlg,
                                           CERT_MGR_INFO        *pCertMgrInfo,
                                           IDropTarget          **ppIDropTarget)
{
    CCertMgrDropTarget  *pCCertMgrDropTarget=NULL;

    *ppIDropTarget=NULL;

    pCCertMgrDropTarget = (CCertMgrDropTarget  *)new CCertMgrDropTarget(hwndDlg, pCertMgrInfo);

    if(pCCertMgrDropTarget)
    {
        *ppIDropTarget=(IDropTarget *)pCCertMgrDropTarget;
        return S_OK;
    }
    
    return E_OUTOFMEMORY;
}

//============================================================================
//
//  Implementation of the CCertMgrDropTarget class
//============================================================================

//
// Constructor
//

CCertMgrDropTarget::CCertMgrDropTarget(HWND                 hwndDlg,
                                       CERT_MGR_INFO        *pCertMgrInfo)

{
    m_cRefs                 = 1;
    m_pDataObj              = NULL;
    m_grfKeyStateLast       = 0;
    m_fHasHDROP             = FALSE;
    m_dwEffectLastReturned  = 0;
    m_hwndDlg               = hwndDlg;
    m_pCertMgrInfo          = pCertMgrInfo;
}

//
// Destructor
//

CCertMgrDropTarget::~CCertMgrDropTarget()
{
}

//
// QueryInterface
//

STDMETHODIMP CCertMgrDropTarget::QueryInterface(REFIID riid, LPVOID *ppv)
{
    HRESULT  hr = E_NOINTERFACE;

    *ppv = NULL;

    // Any interface on this object is the object pointer

    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IDropTarget))
    {
        *ppv = (LPDROPTARGET)this;

        AddRef();

        hr = NOERROR;
    }

    return hr;
}   

//
// AddRef
//

STDMETHODIMP_(ULONG) CCertMgrDropTarget::AddRef()
{
    return ++m_cRefs;
}

//
// Release
//

STDMETHODIMP_(ULONG) CCertMgrDropTarget::Release()
{
    if (--m_cRefs)
    {
        return m_cRefs;
    }

    delete this;

    return 0L;
}

//
// DragEnter
//

STDMETHODIMP CCertMgrDropTarget::DragEnter(LPDATAOBJECT pDataObj, 
                                           DWORD        grfKeyState,
                                           POINTL       pt, 
                                           LPDWORD      pdwEffect)
{
    HRESULT hr = E_INVALIDARG;

    // Release any old data object we might have

    if (m_pDataObj)
    {
        m_pDataObj->Release();
    }

    m_grfKeyStateLast = grfKeyState;
    m_pDataObj        = pDataObj;

    //
    // See if we will be able to get CF_HDROP from this guy
    //

    if (pDataObj)
    {
        pDataObj->AddRef();

        LPENUMFORMATETC penum;
        hr = pDataObj->EnumFormatEtc(DATADIR_GET, &penum);

        if (SUCCEEDED(hr))
        {
            FORMATETC fmte;
            ULONG celt;

            while (S_OK == penum->Next(1, &fmte, &celt))
            {
                if (fmte.cfFormat==CF_HDROP && (fmte.tymed & TYMED_HGLOBAL)) 
                {
                    m_fHasHDROP = TRUE;
                    hr=S_OK;
                    break;
                }
            }
            penum->Release();
        }
    }

    // Save the drop effect

    if (pdwEffect)
    {
        *pdwEffect = m_dwEffectLastReturned = GetDropEffect(pdwEffect);
    }

    return hr;
}

//
// GetDropEffect
//

DWORD CCertMgrDropTarget::GetDropEffect(LPDWORD pdwEffect)
{

    if (m_fHasHDROP)
    {
        return (*pdwEffect) & (DROPEFFECT_COPY);
    }
    else
    {
        return DROPEFFECT_NONE;
    }
}

//
// DragOver
//

STDMETHODIMP CCertMgrDropTarget::DragOver(DWORD grfKeyState, POINTL pt, LPDWORD pdwEffect)
{
    if (m_grfKeyStateLast == grfKeyState)
    {
        // Return the effect we saved at dragenter time

        if (*pdwEffect)
        {
            *pdwEffect = m_dwEffectLastReturned;
        }
    }
    else
    {
        if (*pdwEffect)
        {
            *pdwEffect = m_dwEffectLastReturned = GetDropEffect(pdwEffect);
        }
    }

    m_grfKeyStateLast = grfKeyState;

    return S_OK;
}

//
// DragLeave
//
 
STDMETHODIMP CCertMgrDropTarget::DragLeave()
{
    if (m_pDataObj)
    {
        m_pDataObj->Release();
        m_pDataObj = NULL;
    }

    return S_OK;
}

//
// Drop
//
STDMETHODIMP CCertMgrDropTarget::Drop(LPDATAOBJECT pDataObj,
                                      DWORD        grfKeyState, 
                                      POINTL       pt, 
                                      LPDWORD      pdwEffect)
{
    HRESULT     hr = S_OK;
    FORMATETC   fmte = {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    STGMEDIUM   medium;
    DWORD       dwFileCount=0;    
    BOOL        fOneFileSucceeded=FALSE;
    BOOL        fOneFileFailed=FALSE;
    DWORD       dwIndex=0;
    WCHAR       wszPath[MAX_PATH];
    UINT        idsErrMsg=0;
    CRYPTUI_WIZ_IMPORT_SRC_INFO     ImportSrcInfo;
    DWORD       dwExpectedContentType=CERT_QUERY_CONTENT_FLAG_CTL | CERT_QUERY_CONTENT_FLAG_CERT | CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED;
    DWORD       dwContentType=0;
    DWORD       dwException=0;

    //
    // Take the new data object, since OLE can give us a different one than
    // it did in DragEnter
    //

    if (m_pDataObj)
    {
        m_pDataObj->Release();
    }

    m_pDataObj = pDataObj;

    if (pDataObj)
    {
        pDataObj->AddRef();
    }

    __try {
    //get the file names
    if (SUCCEEDED(pDataObj->GetData(&fmte, &medium)))
    {
        dwFileCount=DragQueryFileU((HDROP)medium.hGlobal, (UINT)-1, NULL, 0);
    }
    else
        return E_INVALIDARG;

    //process the file one at a time
    for(dwIndex=0; dwIndex < dwFileCount; dwIndex++)
    {
        if(DragQueryFileU((HDROP)medium.hGlobal, dwIndex, wszPath, MAX_PATH))
        {

            //make sure the file is either a cert or a PKCS7 file
            if(!CryptQueryObject(
                    CERT_QUERY_OBJECT_FILE,
                    wszPath,
                    dwExpectedContentType,
                    CERT_QUERY_FORMAT_FLAG_ALL,
                    0,
                    NULL,
                    &dwContentType,
                    NULL,
                    NULL,
                    NULL,
                    NULL))
            {

                fOneFileFailed=TRUE;
            }
            else
            {
               //since the CTL itself is a PKCS#7, we need to differentiate them
                if(CERT_QUERY_CONTENT_CTL == dwContentType)
                    fOneFileFailed=TRUE;
                else
                {

                    memset(&ImportSrcInfo, 0, sizeof(ImportSrcInfo));
                    ImportSrcInfo.dwSize=sizeof(CRYPTUI_WIZ_IMPORT_SRC_INFO);
                    ImportSrcInfo.dwSubjectChoice=CRYPTUI_WIZ_IMPORT_SUBJECT_FILE;
                    ImportSrcInfo.pwszFileName=wszPath;

                    //call the import wizard UIless mode
                    CryptUIWizImport(CRYPTUI_WIZ_NO_UI,
                                    m_hwndDlg,
                                    NULL,
                                    &ImportSrcInfo,
                                    NULL);
                    fOneFileSucceeded=TRUE;
                }

            }

        }
    }



    //display messages based on the result
    if(1 == dwFileCount)
    {
        if(fOneFileFailed)
            idsErrMsg=IDS_ALL_INVALID_DROP_FILE;
    } 
    else
    {
        if( 1 < dwFileCount)
        {
            if(fOneFileFailed && fOneFileSucceeded)
                idsErrMsg=IDS_SOME_INVALID_DROP_FILE;
            else
            {
                if(fOneFileFailed && (FALSE==fOneFileSucceeded))
                    idsErrMsg=IDS_ALL_INVALID_DROP_FILE;
            }
        }
    }

    if(idsErrMsg)
        I_MessageBox(m_hwndDlg, 
                idsErrMsg,
                IDS_CERT_MGR_TITLE,
                m_pCertMgrInfo->pCertMgrStruct->pwszTitle,
                MB_ICONEXCLAMATION|MB_OK|MB_APPLMODAL);

    //release the medium
    ReleaseStgMedium(&medium);

    //refresh the listView window
    if(idsErrMsg == 0)
        RefreshCertListView(m_hwndDlg, m_pCertMgrInfo);


    } __except(EXCEPTION_EXECUTE_HANDLER) {
        dwException = GetExceptionCode();
    }


    DragLeave();

    return dwException ? dwException : S_OK;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\ui\wizards\certrequestercontext.h ===
#ifndef __CERT_REQUESTER_CONTEXT_H__
#define __CERT_REQUESTER_CONTEXT_H__ 1


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// CLASS CertRequesterContext.
//
// The CertRequesterContext class is used to encapsulate any details of the certificate enrollment 
// implementation which are dependent upon the context in which the program is running.  
// Currently, there are two supported contexts:
//
// 1) LocalContext.  This is used when the program runs under the current user's context,  
//    on the local machine.  
//
// 2) KeySvcContext.  This is used when some other context must be specified through 
//    keysvc.  
// 
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
class CertRequesterContext { 
public:
    
    //-------------------------------------------------------------------------
    //  Builds a list of the CSPs supported in this context.  
    //  (Different machines may have different CSP lists).  
    //
    //  Requires:
    //    * This CertRequesterContext was created with a valid CERT_WIZARD_INFO pointer. 
    //
    //  Modifies: 
    //    * The following fields of the internal CERT_WIZARD_INFO pointer: 
    //        dwCSPCount         :  contains the number of valid CSPs. 
    //        rgdwProviderType   :  contains a dwCSPCount-element array of the provider types available.  
    //                              This field should be freed with WizardFree(). 
    //        rgwszProvider      :  contains a dwCSPCount-element array of the provider names available.
    //                              This field, and each array element should be freed with WizardFree().
    // 
    //      Use GetWizardInfo() to retrieve a pointer to the updated CERT_WIZARD_INFO. 
    //  
    //  Returns: 
    //    * S_OK if successful, failure code otherwise. 
    // 
    //--------------------------------------------------------------------------
    virtual HRESULT BuildCSPList() = 0;  

    //---------------------------------------------------------------------------
    // Checks if this context has sufficient access to use the specified cert type 
    // in enrollment. 
    // 
    //  Requires:
    //    * This CertRequesterContext was created with a valid CERT_WIZARD_INFO pointer. 
    //
    //  Modifies:
    //      Nothing
    // 
    //  Returns:
    //    * Returns TRUE if this context has the permission to access the specified cert type. 
    //      Returns FALSE if not, or if an error occurs.  
    //
    //--------------------------------------------------------------------------
    virtual BOOL CheckAccessPermission(IN HCERTTYPE hCertType) = 0; 

    //---------------------------------------------------------------------------
    // Checks if this context has sufficient access to use the specified CA in enrollment. 
    //
    //  Requires:
    //    * This CertRequesterContext was created with a valid CERT_WIZARD_INFO pointer. 
    //
    //  Modifies:
    //      Nothing
    // 
    //  Returns:
    //    * Returns TRUE if this context has the permission to access the specified CA. 
    //      Returns FALSE if not, or if an error occurs.  
    //
    //--------------------------------------------------------------------------
    virtual BOOL CheckCAPermission(IN HCAINFO hCAInfo) = 0; 

    //-----------------------------------------------------------------------
    //  Gets the name of the default CSP on the local machine, based on the provider 
    //  type specified by the internal CERT_WIZARD_INFO pointer.  
    //
    //  Requires:
    //    * This CertRequesterContext was created with a valid CERT_WIZARD_INFO pointer. 
    // 
    //  Modifies:
    //    * The following fields of the internal CERT_WIZARD_INFO pointer: 
    //        pwszProvider : contains the name of the default provider, for the specified 
    //                       provider type, on this machine. Use WizardFree to free the memory 
    //                       associated with this field.  HOWEVER, check the out parameter to 
    //                       ensure that memory for this field was actually allocated. 
    // 
    //      Use GetWizardInfo() to retrieve a pointer to the updated CERT_WIZARD_INFO. 
    // 
    //  Returns:
    //    S_OK if successful, an error code otherwise.  
    //    If memory was allocated to store the default CSP's name, returns TRUE into 
    //    the OUT parameter, FALSE otherwise. 
    //   
    //    If the dwProviderType field of the interal wizard pointer is not set, OR
    //    both the dwProviderType and pwszProvider fields are set, then the function 
    //    does not attempt to find a default CSP, and returns successfully without allocating
    //    any memory.  
    // 
    //------------------------------------------------------------------------
    virtual HRESULT GetDefaultCSP(OUT BOOL *pfAllocateCSP) = 0; 

    //----------------------------------------------------------------------
    //
    // Enrolls for a certificate, or renews a certificate, based on the
    // supplied parameters.  
    //  
    // Parameters:
    //   * pdwStatus    : Status of the request.  One of the CRYPTUI_WIZ_CERT_REQUEST_STATUS_* 
    //                    defines in cryptui.h. 
    //   * pResult      : For certificate request creation, returns a pointer to an opaque
    //                    data blob which can be used as a parameter to SubmitRequest(). 
    //                    Otherwise, returns a PCCERT_CONTEXT representing the 
    //                    enrolled/renewed certificate. 
    // 
    // Requires:
    // Modifies:
    // Returns:
    //   S_OK if the operation completed without an error, returns a standard error
    //   code otherwise.  Note that a return value of S_OK does not
    //   guarantee that a certificate was issued:  check that the pdwStatus parameter.
    // 
    //----------------------------------------------------------------------
    virtual HRESULT Enroll(OUT DWORD   *pdwStatus,
			   OUT HANDLE  *pResult) = 0; 
    
    //----------------------------------------------------------------------
    //  Performs context-specific initialization.  This should always be called after
    //  the context is created.  
    //
    //  Requires:
    //    * This CertRequesterContext was created with a valid CERT_WIZARD_INFO pointer. 
    //  
    //  Modifies:
    //    Implementation-specific (see implementation documentation). 
    //
    //  Returns:
    //    S_OK if the initialization succeeded. 
    //
    //----------------------------------------------------------------------
    virtual HRESULT Initialize() = 0; 

    virtual HRESULT QueryRequestStatus(IN HANDLE hRequest, OUT CRYPTUI_WIZ_QUERY_CERT_REQUEST_INFO *pQueryInfo) = 0; 
    
    virtual ~CertRequesterContext(); 

    static HRESULT MakeDefaultCertRequesterContext(OUT CertRequesterContext **ppRequesterContext);

    static HRESULT MakeCertRequesterContext(IN  LPCWSTR                pwszAccountName, 
					    IN  LPCWSTR                pwszMachineName,
					    IN  DWORD                  dwCertOpenStoreFlags, 
					    IN  CERT_WIZARD_INFO      *pCertWizardInfo,
					    OUT CertRequesterContext **ppRequesterContext, 
					    OUT UINT                  *pIDSText);

    UINT               GetErrorString() { return m_idsText; } 
    CERT_WIZARD_INFO * GetWizardInfo()  { return m_pCertWizardInfo; } 
    
    
protected:
    CertRequesterContext(CERT_WIZARD_INFO * pCertWizardInfo) : m_pCertWizardInfo(pCertWizardInfo), m_idsText(0) { }

    CERT_WIZARD_INFO * m_pCertWizardInfo; 
    UINT               m_idsText; 

private:
    CertRequesterContext(); 
};


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// LocalContext. 
//
// This class provides an implementation of the CertRequestContext interface
// which runs under the current user's context on the local machine.  
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

class LocalContext : public CertRequesterContext {
    friend class CertRequesterContext; 

public:
    //----------------------------------------------------------------------
    // See CertRequesterContext::BuildCSPList(). 
    //----------------------------------------------------------------------
    virtual HRESULT BuildCSPList();

    //----------------------------------------------------------------------
    // See CertRequesterContext::CheckAccessPermission(HCERTTYPE). 
    //----------------------------------------------------------------------
    virtual BOOL    CheckAccessPermission(HCERTTYPE hCertType);

    //----------------------------------------------------------------------
    // See CertRequesterContext::BuildCSPList(BOOL *). 
    //----------------------------------------------------------------------
    virtual HRESULT GetDefaultCSP(BOOL *pfAllocateCSP);

    //----------------------------------------------------------------------
    // See CertRequesterContext::BuildCSPList(HCAINFO). 
    //----------------------------------------------------------------------
    virtual BOOL    CheckCAPermission(HCAINFO hCAInfo); 

    virtual HRESULT Enroll(OUT DWORD   *pdwStatus,
			   OUT HANDLE  *pResult); 
    
    virtual HRESULT QueryRequestStatus(IN HANDLE hRequest, OUT CRYPTUI_WIZ_QUERY_CERT_REQUEST_INFO *pQueryInfo); 


    //----------------------------------------------------------------------
    // Always returns S_OK. 
    //----------------------------------------------------------------------
    virtual HRESULT Initialize();

private: 
    HANDLE GetClientIdentity(); 

    LocalContext(); 
    LocalContext(CERT_WIZARD_INFO * pCertWizardInfo) : CertRequesterContext(pCertWizardInfo)
    { 
	if (NULL != m_pCertWizardInfo) { m_pCertWizardInfo->fLocal = TRUE; } 
    }
    
};


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// KeySvcContext. 
//
// This class provides an implementation of the CertRequestContext interface
// using key svc.
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

class KeySvcContext : public CertRequesterContext { 
    friend class CertRequesterContext; 
    
public: 
    //----------------------------------------------------------------------
    // See CertRequesterContext::BuildCSPList(). 
    //----------------------------------------------------------------------
    virtual HRESULT BuildCSPList();

    //----------------------------------------------------------------------
    // See CertRequesterContext::CheckAccessPermission(HCERTTYPE). 
    //----------------------------------------------------------------------
    virtual BOOL    CheckAccessPermission(HCERTTYPE hCertType);

    //----------------------------------------------------------------------
    // See CertRequesterContext::BuildCSPList(BOOL *). 
    //----------------------------------------------------------------------
    virtual HRESULT GetDefaultCSP(BOOL *pfAllocateCSP);

    //----------------------------------------------------------------------
    // See CertRequesterContext::BuildCSPList(HCAINFO). 
    //----------------------------------------------------------------------
    virtual BOOL    CheckCAPermission(HCAINFO hCAInfo); 
    
    virtual HRESULT Enroll(OUT DWORD   *pdwStatus,
			   OUT HANDLE  *pResult) = 0; 

    virtual HRESULT QueryRequestStatus(IN HANDLE hRequest, OUT CRYPTUI_WIZ_QUERY_CERT_REQUEST_INFO *pQueryInfo); 


    //----------------------------------------------------------------------
    // Requires:
    //    * This CertRequesterContext was created with a valid CERT_WIZARD_INFO pointer. 
    //    * This CertRequesterContext has been initialized with a call to Initialize(). 
    //
    // Modifies:
    //    * The following fields of the internal CERT_WIZARD_INFO pointer: 
    //        awszAllowedCertTypes : contains an array of cert types which this context 
    //                               has permission to enroll for.  This field, and each
    //                               array element, must be freed with WizardFree(). 
    //        awszValidCA          : contains an array of CAs which this context has
    //                               permission to enroll from.  This field, and each array
    //                               element, must be freed with WizardFree().
    // Returns:
    //   S_OK if initialization succeeded, an error code otherwise. 
    // 
    //----------------------------------------------------------------------
    virtual HRESULT Initialize();

    virtual ~KeySvcContext() 
    {
	// free the list of allowed CertTypes 
	// These may be allocate by the KeySvcContext's Initialize() method. 
	if(NULL != m_pCertWizardInfo->awszAllowedCertTypes) { WizardFree(m_pCertWizardInfo->awszAllowedCertTypes); } 
	if(NULL != m_pCertWizardInfo->awszValidCA)          { WizardFree(m_pCertWizardInfo->awszValidCA); } 
    }

 protected:
    KeySvcContext(CERT_WIZARD_INFO * pCertWizardInfo) : CertRequesterContext(pCertWizardInfo) 
    { 
	if (NULL != m_pCertWizardInfo)
	{
	    m_pCertWizardInfo->fLocal               = FALSE; 
	    m_pCertWizardInfo->awszAllowedCertTypes = NULL;
	    m_pCertWizardInfo->awszValidCA          = NULL; 
	}
    }

    HRESULT ToCertContext(IN  CERT_BLOB       *pPKCS7Blob, 
                          IN  CERT_BLOB       *pHashBlob, 
                          OUT DWORD           *pdwStatus, 
                          OUT PCCERT_CONTEXT  *ppCertContext);
    

 private:
    KeySvcContext(); 

};

class WhistlerMachineContext : public KeySvcContext { 
    friend class CertRequesterContext; 

    virtual HRESULT Enroll(OUT DWORD  *pdwStatus,
                           OUT HANDLE *ppCertContext);

 private:
    WhistlerMachineContext(CERT_WIZARD_INFO * pCertWizardInfo) : KeySvcContext(pCertWizardInfo) 
        { } 

    HRESULT CreateRequest(IN  KEYSVCC_HANDLE         hKeyService, 
			  IN  LPSTR                  pszMachineName,                   
			  IN  LPWSTR                 pwszCALocation,                  
			  IN  LPWSTR                 pwszCAName,  
			  IN  PCERT_REQUEST_PVK_NEW  pKeyNew,     
			  IN  CERT_BLOB             *pCert,       
			  IN  PCERT_REQUEST_PVK_NEW  pRenewKey,   
			  IN  LPWSTR                 pszHashAlg,  
			  IN  PCERT_ENROLL_INFO      pRequestInfo,
			  OUT HANDLE                *phRequest);

    HRESULT SubmitRequest(IN  KEYSVCC_HANDLE   hKeyService,  
			  IN  LPSTR            pszMachineName,                   
			  IN  LPWSTR           pwszCALocation,                  
			  IN  LPWSTR           pwszCAName,  
			  IN  HANDLE           hRequest, 
			  OUT PCCERT_CONTEXT  *ppCertContext, 
			  OUT DWORD           *pdwStatus);
    
    void FreeRequest(IN KEYSVCC_HANDLE  hKeyService, 
		     IN LPSTR           pszMachineName, 
		     IN HANDLE          hRequest);

};

#endif // #ifndef __CERT_REQUESTER_CONTEXT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\ui\wizards\export.cpp ===
//-------------------------------------------------------------
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       export.cpp
//
//  Contents:   The cpp file to implement the export wizard
//
//  History:    11-19-1997 reidk   created
//
//--------------------------------------------------------------

#include    "wzrdpvk.h"

#define EXPORT_PAGE_NUM 6
#define MAX_PASSWORD    512
#define MAX_STORES      20

//
// these are the defines for the state of a private key
//
#define PRIVATE_KEY_UNKNOWN_STATE   0
#define PRIVATE_KEY_CORRUPT         1
#define PRIVATE_KEY_NOT_EXPORTABLE  2
#define PRIVATE_KEY_EXPORTABLE      3

typedef struct {
    PCCRYPTUI_WIZ_EXPORT_INFO               pExportInfo;
    PCCRYPTUI_WIZ_EXPORT_CERTCONTEXT_INFO   pExportCertInfo;

    LPWSTR                                  pwszExportFileName;
    LPWSTR                                  pwszExportFileNameToCheck;
    DWORD                                   dwExportFormat;
    BOOL                                    fExportChain;
    BOOL                                    fExportPrivateKeys;
	BOOL									fStrongEncryption;
    BOOL                                    fDeletePrivateKey;
    DWORD                                   dwExportablePrivateKeyStatus;
    BOOL                                    fPrivateKeysExist;
    BOOL                                    fDontCheckFileName;
    BOOL                                    fNextPage;
    LPWSTR                                  pwszPassword;

    HFONT                                   hBigBold;
    HFONT                                   hBold;

    // DSIE: Added 04/03/2002 for DCR bug 531006.
    DWORD                                   dwFlags;

    // DSIE: Added 05/06/2002 for bug 613485.
    DWORD                                   dwErrorCode;
} EXPORT_HELPER_STRUCT, *PEXPORT_HELPER_STRUCT;


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static BOOL Validpvoid(PCCRYPTUI_WIZ_EXPORT_INFO pExportInfo, void *pvoid)
{
    // the only type that needs to be validated at this point is for CERT_CONTEXT
    switch (pExportInfo->dwSubjectChoice)
    {
    case CRYPTUI_WIZ_EXPORT_CERT_CONTEXT:
        PCCRYPTUI_WIZ_EXPORT_CERTCONTEXT_INFO pExportCertInfo = (PCCRYPTUI_WIZ_EXPORT_CERTCONTEXT_INFO) pvoid;
        return (pExportCertInfo->dwSize == sizeof(CRYPTUI_WIZ_EXPORT_CERTCONTEXT_INFO));
        break;

    }

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
BOOL AddChainToStore(
					HCERTSTORE			hCertStore,
					PCCERT_CONTEXT		pCertContext,
					DWORD				cStores,
					HCERTSTORE			*rghStores,
					BOOL				fDontAddRootCert,
					CERT_TRUST_STATUS	*pChainTrustStatus)
{
    FILETIME					fileTime;
    DWORD						i;
    CERT_CHAIN_ENGINE_CONFIG	CertChainEngineConfig;
	HCERTCHAINENGINE			hCertChainEngine = NULL;
	PCCERT_CHAIN_CONTEXT		pCertChainContext = NULL;
	CERT_CHAIN_PARA				CertChainPara;
	BOOL						fRet = TRUE;
    PCCERT_CONTEXT              pTempCertContext = NULL;

	//
	// create a new chain engine, then build the chain
	//
	memset(&CertChainEngineConfig, 0, sizeof(CertChainEngineConfig));
	CertChainEngineConfig.cbSize = sizeof(CertChainEngineConfig);
	CertChainEngineConfig.cAdditionalStore = cStores;
	CertChainEngineConfig.rghAdditionalStore = rghStores;

    if (!CertCreateCertificateChainEngine(&CertChainEngineConfig, &hCertChainEngine))
	{
		goto ErrorReturn;
	}

	memset(&CertChainPara, 0, sizeof(CertChainPara));
	CertChainPara.cbSize = sizeof(CertChainPara);

	if (!CertGetCertificateChain(
				hCertChainEngine,
				pCertContext,
				NULL,
				NULL,
				&CertChainPara,
				0,
				NULL,
				&pCertChainContext))
	{
		goto ErrorReturn;
	}

	//
	// make sure there is atleast 1 simple chain
	//
    if (pCertChainContext->cChain != 0)
	{
		i = 0;
		while (i < pCertChainContext->rgpChain[0]->cElement)
		{
			//
			// if we are supposed to skip the root cert,
			// and we are on the root cert, then continue
			//
			if (fDontAddRootCert &&
                (pCertChainContext->rgpChain[0]->rgpElement[i]->TrustStatus.dwInfoStatus & CERT_TRUST_IS_SELF_SIGNED))
			{
                i++;
                continue;
			}

			CertAddCertificateContextToStore(
					hCertStore,
					pCertChainContext->rgpChain[0]->rgpElement[i]->pCertContext,
					CERT_STORE_ADD_REPLACE_EXISTING,
					&pTempCertContext);

            //
            // remove any private key property the certcontext may have on it.
            //
            if (pTempCertContext)
            {
                CertSetCertificateContextProperty(
                            pTempCertContext, 
                            CERT_KEY_PROV_INFO_PROP_ID, 
                            0, 
                            NULL);

                CertFreeCertificateContext(pTempCertContext);
            }

			i++;
		}
	}
	else
	{
		goto ErrorReturn;
	}

	//
	// if the caller wants the status, then set it
	//
	if (pChainTrustStatus != NULL)
	{
		pChainTrustStatus->dwErrorStatus = pCertChainContext->TrustStatus.dwErrorStatus;
		pChainTrustStatus->dwInfoStatus = pCertChainContext->TrustStatus.dwInfoStatus;
	}

	
Ret:
	if (pCertChainContext != NULL)
	{
		CertFreeCertificateChain(pCertChainContext);
	}

	if (hCertChainEngine != NULL)
	{
		CertFreeCertificateChainEngine(hCertChainEngine);
	}

	return fRet;

ErrorReturn:
	fRet = FALSE;
	goto Ret;
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
HRESULT CreateDirectory(LPWSTR pwszExportFileName)
{
    int     index;
    BOOL    ret;
    HRESULT hr;

    index = wcslen(pwszExportFileName) - 1;

    // find the first '\' by parsing backwards
    while ((pwszExportFileName[index] != L'\\') && (index >= 0))
    {
        index--;
    }

    if (index <= 0)
    {
        return TRUE;
    }

    // if there us a ':' to the left of the first '\' then
    // a file name has been entered in the form "c:\filename.ext"
    // which means of course that we need not try to create the
    // directory
    if (pwszExportFileName[index-1] == L':')
    {
        return S_OK;
    }

    pwszExportFileName[index] = 0;
    ret = CreateDirectoryU(pwszExportFileName, NULL);
    pwszExportFileName[index] = L'\\';

    if (ret)
    {
        return S_OK;
    }
    else
    {
        hr = GetLastError();
        if (hr == ERROR_ALREADY_EXISTS)
        {
            return S_OK;
        }
        else
        {
            return hr;
        }
    }
}

//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static HRESULT DoExport(PEXPORT_HELPER_STRUCT pExportHelper)
{
    HCERTSTORE          hTempStore;
    HRESULT             hr = E_FAIL;
    BYTE                *pbBase64 = NULL;
    DWORD               cchBase64 = 0;
    CRYPT_KEY_PROV_INFO	*pCryptKeyProvInfo = NULL;
	DWORD				cbCryptKeyProvInfo = 0;
    HCRYPTPROV			hCryptProv = NULL;

    /*if (S_OK != (hr = CreateDirectory(pExportHelper->pwszExportFileName)))
    {
        return hr;
    }*/

    switch (pExportHelper->pExportInfo->dwSubjectChoice)
    {
    case CRYPTUI_WIZ_EXPORT_CTL_CONTEXT:
        if (S_OK != (hr = OpenAndWriteToFile(
                                pExportHelper->pwszExportFileName,
                                pExportHelper->pExportInfo->pCTLContext->pbCtlEncoded,
                                pExportHelper->pExportInfo->pCTLContext->cbCtlEncoded)))
        {
            return hr;
        }

        break;

    case CRYPTUI_WIZ_EXPORT_CRL_CONTEXT:
        if (S_OK != (hr = OpenAndWriteToFile(
                                pExportHelper->pwszExportFileName,
                                pExportHelper->pExportInfo->pCRLContext->pbCrlEncoded,
                                pExportHelper->pExportInfo->pCRLContext->cbCrlEncoded)))
        {
            return hr;
        }

        break;

    case CRYPTUI_WIZ_EXPORT_CERT_STORE:

        if (!CertSaveStore(
                    pExportHelper->pExportInfo->hCertStore,
                    0,
                    CERT_STORE_SAVE_AS_STORE,
                    CERT_STORE_SAVE_TO_FILENAME_W,
                    (void *) pExportHelper->pwszExportFileName,
                    0))
        {
            return GetLastError();
        }
        else
        {
            hr = S_OK;
        }
        break;

    case CRYPTUI_WIZ_EXPORT_CERT_STORE_CERTIFICATES_ONLY:

        if (!CertSaveStore(
                    pExportHelper->pExportInfo->hCertStore,
                    PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
                    CERT_STORE_SAVE_AS_PKCS7,
                    CERT_STORE_SAVE_TO_FILENAME_W,
                    (void *) pExportHelper->pwszExportFileName,
                    0))
        {
            return GetLastError();
        }
        else
        {
            hr = S_OK;
        }
        break;

    case CRYPTUI_WIZ_EXPORT_CERT_CONTEXT:

        switch (pExportHelper->dwExportFormat)
        {
        case CRYPTUI_WIZ_EXPORT_FORMAT_DER:

            if (S_OK != (hr = OpenAndWriteToFile(
                                    pExportHelper->pwszExportFileName,
                                    pExportHelper->pExportInfo->pCertContext->pbCertEncoded,
                                    pExportHelper->pExportInfo->pCertContext->cbCertEncoded)))
            {
                return hr;
            }

            break;

        case CRYPTUI_WIZ_EXPORT_FORMAT_BASE64:

            if (!CryptBinaryToString(
                pExportHelper->pExportInfo->pCertContext->pbCertEncoded,
                pExportHelper->pExportInfo->pCertContext->cbCertEncoded,
                CRYPT_STRING_BASE64HEADER,
                NULL,
                &cchBase64))
            {
                return HRESULT_FROM_WIN32(GetLastError());
            }

            if (NULL == (pbBase64 = (BYTE *) malloc(cchBase64 * sizeof(TCHAR))))
            {
                return E_OUTOFMEMORY;
            }

            if (!CryptBinaryToString(
                pExportHelper->pExportInfo->pCertContext->pbCertEncoded,
                pExportHelper->pExportInfo->pCertContext->cbCertEncoded,
                CRYPT_STRING_BASE64HEADER,
                (LPSTR) pbBase64,
                &cchBase64))
            {
                free(pbBase64);
                return HRESULT_FROM_WIN32(GetLastError());
            }

            hr = OpenAndWriteToFile(
                    pExportHelper->pwszExportFileName, 
                    pbBase64, 
                    cchBase64);

            free(pbBase64);
            return hr;

            break;

        case CRYPTUI_WIZ_EXPORT_FORMAT_PFX:
            CRYPT_DATA_BLOB pfxBlob;

            pfxBlob.cbData = 0;
            pfxBlob.pbData = NULL;

            //
            // open a temporary memory store that the PFXExport will be done from
            //
            hTempStore = CertOpenStore(
                            CERT_STORE_PROV_MEMORY, 
                            X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, 
                            0, 
                            CERT_STORE_ENUM_ARCHIVED_FLAG, 
                            NULL);
            if (hTempStore == NULL)
            {
                return GetLastError();
            }

            //
            // get all the certs in the chain if we need to
            //
            if (pExportHelper->fExportChain)
            {
                AddChainToStore(
						hTempStore,
						pExportHelper->pExportInfo->pCertContext,
						pExportHelper->pExportInfo->cStores,
						pExportHelper->pExportInfo->rghStores,
						FALSE,
						NULL);
            }
            CertAddCertificateContextToStore(
                    hTempStore,
                    pExportHelper->pExportInfo->pCertContext,
                    CERT_STORE_ADD_REPLACE_EXISTING,
                    NULL);

            //
			// call pfx to export the store to a blob, use the pExportHelper->fStrongEncryption
            // flag to call the appropriate PFX API
            //
            if (pExportHelper->fStrongEncryption)
            {
                if (!PFXExportCertStoreEx(
                            hTempStore,
                            &pfxBlob,
                            pExportHelper->pwszPassword,
                            NULL,
                            (pExportHelper->fExportPrivateKeys ? EXPORT_PRIVATE_KEYS : 0) | REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY))
                {
                    hr = GetLastError();
                    CertCloseStore(hTempStore, 0);
                    return hr;
                }

                if (NULL == (pfxBlob.pbData = (BYTE *) malloc(pfxBlob.cbData)))
                {
                    CertCloseStore(hTempStore, 0);
                    SetLastError(E_OUTOFMEMORY);
                    return E_OUTOFMEMORY;
                }

                if (!PFXExportCertStoreEx(
                            hTempStore,
                            &pfxBlob,
                            pExportHelper->pwszPassword,
                            NULL,
                            (pExportHelper->fExportPrivateKeys ? EXPORT_PRIVATE_KEYS : 0) | REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY))
                {
                    hr = GetLastError();
                    CertCloseStore(hTempStore, 0);
                    free(pfxBlob.pbData);
                    return hr;
                }
            }
            else
            {
                if (!PFXExportCertStore(
                            hTempStore,
                            &pfxBlob,
                            pExportHelper->pwszPassword,
                            (pExportHelper->fExportPrivateKeys ? EXPORT_PRIVATE_KEYS : 0) | REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY))
                {
                    hr = GetLastError();
                    CertCloseStore(hTempStore, 0);
                    return hr;
                }

                if (NULL == (pfxBlob.pbData = (BYTE *) malloc(pfxBlob.cbData)))
                {
                    CertCloseStore(hTempStore, 0);
                    SetLastError(E_OUTOFMEMORY);
                    return E_OUTOFMEMORY;
                }

                if (!PFXExportCertStore(
                            hTempStore,
                            &pfxBlob,
                            pExportHelper->pwszPassword,
                            (pExportHelper->fExportPrivateKeys ? EXPORT_PRIVATE_KEYS : 0) | REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY))
                {
                    hr = GetLastError();
                    CertCloseStore(hTempStore, 0);
                    free(pfxBlob.pbData);
                    return hr;
                }
            }

            CertCloseStore(hTempStore, 0);

            if (S_OK != (hr = OpenAndWriteToFile(
                                    pExportHelper->pwszExportFileName,
                                    pfxBlob.pbData,
                                    pfxBlob.cbData)))
            {
                free(pfxBlob.pbData);
                return hr;
            }

            free(pfxBlob.pbData);

            if (pExportHelper->fDeletePrivateKey)
            {
                if (!CertGetCertificateContextProperty(
				        pExportHelper->pExportInfo->pCertContext,
				        CERT_KEY_PROV_INFO_PROP_ID,
				        NULL,
				        &cbCryptKeyProvInfo)) 
                {
                    return GetLastError();
                }
			
			    if (NULL == (pCryptKeyProvInfo = (CRYPT_KEY_PROV_INFO *) malloc(cbCryptKeyProvInfo))) 
                {
				    return E_OUTOFMEMORY;
			    }
			    
			    if (!CertGetCertificateContextProperty(
					    pExportHelper->pExportInfo->pCertContext,
					    CERT_KEY_PROV_INFO_PROP_ID,
					    pCryptKeyProvInfo,
					    &cbCryptKeyProvInfo)) 
                {
                    free(pCryptKeyProvInfo);
                    return GetLastError();
                }
				    
				// acquire the HCRYPTPROV so we can export the private key in that puppy
				if (!CryptAcquireContextU(
						&hCryptProv,
						pCryptKeyProvInfo->pwszContainerName,
						pCryptKeyProvInfo->pwszProvName,
						pCryptKeyProvInfo->dwProvType,
						pCryptKeyProvInfo->dwFlags | CRYPT_DELETEKEYSET)) 
                {
                    free(pCryptKeyProvInfo);
                    return GetLastError();
                }

                free(pCryptKeyProvInfo);

                CertSetCertificateContextProperty(
                        pExportHelper->pExportInfo->pCertContext,
                        CERT_KEY_PROV_INFO_PROP_ID,
                        0,
                        NULL);
            }

            return S_OK;

            break;

        case CRYPTUI_WIZ_EXPORT_FORMAT_PKCS7:
        case CRYPTUI_WIZ_EXPORT_FORMAT_SERIALIZED_CERT_STORE:

            //
            // open a temporary memory store that the serialized export will be done from
            //
            hTempStore = CertOpenStore(
                            CERT_STORE_PROV_MEMORY, 
                            X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, 
                            0, 
                            CERT_STORE_ENUM_ARCHIVED_FLAG, 
                            NULL);
            if (hTempStore == NULL)
            {
                return GetLastError();
            }

            //
            // get all the certs in the chain if we need to
            //
            if (pExportHelper->fExportChain)
            {
                AddChainToStore(
						hTempStore,
						pExportHelper->pExportInfo->pCertContext,
						pExportHelper->pExportInfo->cStores,
						pExportHelper->pExportInfo->rghStores,
						FALSE,
						NULL);
            }
            CertAddCertificateContextToStore(
                    hTempStore,
                    pExportHelper->pExportInfo->pCertContext,
                    CERT_STORE_ADD_REPLACE_EXISTING,
                    NULL);

            if (!CertSaveStore(
                        hTempStore,
                        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                        (pExportHelper->dwExportFormat == CRYPTUI_WIZ_EXPORT_FORMAT_PKCS7) ? CERT_STORE_SAVE_AS_PKCS7 : CERT_STORE_SAVE_AS_STORE,
                        CERT_STORE_SAVE_TO_FILENAME_W,
                        (void *) pExportHelper->pwszExportFileName,
                        0))
            {
                hr = GetLastError();
                CertCloseStore(hTempStore, 0);
                return hr;
            }

            CertCloseStore(hTempStore, 0);
            return S_OK;

            break;
        }

        break;
    }

    return hr;
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static INT_PTR APIENTRY ExportWelcomePageProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    PEXPORT_HELPER_STRUCT   pExportHelper = NULL;
    PROPSHEETPAGE           *pPropSheet = NULL;

	switch (msg)
	{
	case WM_INITDIALOG:
        //set the wizard information so that it can be shared
        pPropSheet = (PROPSHEETPAGE *) lParam;
        pExportHelper = (PEXPORT_HELPER_STRUCT) (pPropSheet->lParam);
        SetWindowLongPtr(hwndDlg, DWLP_USER, (LONG_PTR)pExportHelper);

        SetControlFont(pExportHelper->hBigBold, hwndDlg,IDC_WELCOME_STATIC);
        SetControlFont(pExportHelper->hBold, hwndDlg, IDC_WHATISCERT_STATIC);
        SetControlFont(pExportHelper->hBold, hwndDlg, IDC_WHATISSTORE_STATIC);

		break;

	case WM_NOTIFY:
        pExportHelper = (PEXPORT_HELPER_STRUCT) GetWindowLongPtr(hwndDlg, DWLP_USER);
    	
        switch (((NMHDR FAR *) lParam)->code)
    	{
            case PSN_QUERYCANCEL:
                SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, FALSE);
                pExportHelper->dwErrorCode = ERROR_CANCELLED;
                return TRUE;

  			case PSN_KILLACTIVE:
                SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
				return TRUE;

			case PSN_RESET:
                SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
				break;

 			case PSN_SETACTIVE:
 				PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_NEXT);
				break;

            case PSN_WIZBACK:
                break;

            case PSN_WIZNEXT:

                //
                // if this isn't a cert, then the only page is the file name
                //
                if (pExportHelper->pExportInfo->dwSubjectChoice != CRYPTUI_WIZ_EXPORT_CERT_CONTEXT)
                {
                    SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_EXPORTWIZARD_FILENAME);
                }

                //
                // if there are no private keys then skip the page that asks if they are to be exported
                //
                else if (!pExportHelper->fPrivateKeysExist)
                {
                    pExportHelper->fExportPrivateKeys = FALSE;
                    SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_EXPORTWIZARD_FORMAT);
                }
                else if (CRYPTUI_WIZ_EXPORT_PRIVATE_KEY & pExportHelper->dwFlags) 
                {
                    //
                    // Skip the page if explictly asked to export the private key.
                    //
                    pExportHelper->fExportPrivateKeys = TRUE;
                    SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_EXPORTWIZARD_FORMAT);
                }

                break;

			default:
				return FALSE;

    	}
		break;

		default:
			return FALSE;
	}

	return TRUE;
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static INT_PTR APIENTRY ExportPrivateKeysPageProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    PEXPORT_HELPER_STRUCT   pExportHelper = NULL;
    PROPSHEETPAGE           *pPropSheet = NULL;
    WCHAR                   szNoteString[MAX_STRING_SIZE];

	switch (msg)
	{
	case WM_INITDIALOG:
        //
        //set the wizard information so that it can be shared
        //
        pPropSheet = (PROPSHEETPAGE *) lParam;
        pExportHelper = (PEXPORT_HELPER_STRUCT) (pPropSheet->lParam);
        SetWindowLongPtr(hwndDlg, DWLP_USER, (LONG_PTR)pExportHelper);

        SetControlFont(pExportHelper->hBold, hwndDlg, IDC_EPKWC_STATIC);

        switch (pExportHelper->dwExportablePrivateKeyStatus)
        {
        case PRIVATE_KEY_UNKNOWN_STATE:
#if (0) // DSIE: Bug 284895
            if (pExportHelper->pExportCertInfo != NULL)
            {
                SendDlgItemMessage(
                        hwndDlg,
                        IDC_YESPKEYS_RADIO,
                        BM_SETCHECK,
                        pExportHelper->pExportCertInfo->fExportPrivateKeys ? 1 : 0,
                        (LPARAM) 0);
            }
            else
            {
                SendDlgItemMessage(hwndDlg, IDC_NOPKEYS_RADIO, BM_SETCHECK, 1, (LPARAM) 0);
            }
#else
            SendDlgItemMessage(hwndDlg, IDC_NOPKEYS_RADIO, BM_SETCHECK, 1, (LPARAM) 0);
#endif

            LoadStringU(g_hmodThisDll, IDS_KEY_STATE_UNKNOWN, szNoteString, ARRAYSIZE(szNoteString));
            SetDlgItemTextU(hwndDlg, IDC_EXPORT_PKEY_NOTE, szNoteString);

            break;

        case PRIVATE_KEY_CORRUPT:
            LoadStringU(g_hmodThisDll, IDS_KEY_CORRUPT, szNoteString, ARRAYSIZE(szNoteString));
            SetDlgItemTextU(hwndDlg, IDC_EXPORT_PKEY_NOTE, szNoteString);
            EnableWindow(GetDlgItem(hwndDlg, IDC_YESPKEYS_RADIO), FALSE);
            SendDlgItemMessage(hwndDlg, IDC_NOPKEYS_RADIO, BM_SETCHECK, 1, (LPARAM) 0);
            break;

        case PRIVATE_KEY_NOT_EXPORTABLE:
            LoadStringU(g_hmodThisDll, IDS_KEY_NOT_EXPORTABLE, szNoteString, ARRAYSIZE(szNoteString));
            SetDlgItemTextU(hwndDlg, IDC_EXPORT_PKEY_NOTE, szNoteString);
            EnableWindow(GetDlgItem(hwndDlg, IDC_YESPKEYS_RADIO), FALSE);
            SendDlgItemMessage(hwndDlg, IDC_NOPKEYS_RADIO, BM_SETCHECK, 1, (LPARAM) 0);
            break;

        case PRIVATE_KEY_EXPORTABLE:
#if (0) // DSIE: Bug 284895
            if (pExportHelper->pExportCertInfo != NULL)
            {
                SendDlgItemMessage(
                        hwndDlg,
                        IDC_YESPKEYS_RADIO,
                        BM_SETCHECK,
                        pExportHelper->pExportCertInfo->fExportPrivateKeys ? 1 : 0,
                        (LPARAM) 0);
            }
            else
            {
                SendDlgItemMessage(hwndDlg, IDC_YESPKEYS_RADIO, BM_SETCHECK, 1, (LPARAM) 0);
            }
#else
            SendDlgItemMessage(hwndDlg, IDC_NOPKEYS_RADIO, BM_SETCHECK, 1, (LPARAM) 0);
#endif
            break;
        }

		break;

	case WM_NOTIFY:
        pExportHelper = (PEXPORT_HELPER_STRUCT) GetWindowLongPtr(hwndDlg, DWLP_USER);

    	switch (((NMHDR FAR *) lParam)->code)
    	{
            case PSN_QUERYCANCEL:
                SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, FALSE);
                pExportHelper->dwErrorCode = ERROR_CANCELLED;
                return TRUE;

  			case PSN_KILLACTIVE:

                pExportHelper->fExportPrivateKeys =
                        (int)SendDlgItemMessage(hwndDlg, IDC_YESPKEYS_RADIO, BM_GETCHECK, 0, (LPARAM) 0);
                SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
                return TRUE;

			case PSN_RESET:
                SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
				break;

 			case PSN_SETACTIVE:
 				PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_NEXT | PSWIZB_BACK);
				break;

            case PSN_WIZBACK:
                break;

            case PSN_WIZNEXT:
                break;

			default:
				return FALSE;

    	}
		break;

		default:
			return FALSE;
	}

	return TRUE;
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static INT_PTR APIENTRY ExportFormatPageProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    PEXPORT_HELPER_STRUCT   pExportHelper = NULL;
    PROPSHEETPAGE           *pPropSheet = NULL;
    WCHAR                   szErrorTitle[MAX_STRING_SIZE];
    WCHAR                   szErrorString[MAX_STRING_SIZE];

	switch (msg)
	{
	case WM_INITDIALOG:
        //set the wizard information so that it can be shared
        pPropSheet = (PROPSHEETPAGE *) lParam;
        pExportHelper = (PEXPORT_HELPER_STRUCT) (pPropSheet->lParam);
        SetWindowLongPtr(hwndDlg, DWLP_USER, (LONG_PTR)pExportHelper);

        SetControlFont(pExportHelper->hBold, hwndDlg, IDC_EFF_STATIC);

        if (pExportHelper->pExportCertInfo != NULL)
        {
            if (pExportHelper->pExportCertInfo->fExportChain)
            {
                SendDlgItemMessageA(hwndDlg, IDC_INCLUDECHAIN_PFX_CHECK, BM_SETCHECK, 1, 0);
                SendDlgItemMessageA(hwndDlg, IDC_INCLUDECHAIN_PKCS7_CHECK, BM_SETCHECK, 1, 0);
            }
            else
            {
                SendDlgItemMessageA(hwndDlg, IDC_INCLUDECHAIN_PFX_CHECK, BM_SETCHECK, 0, 0);
                SendDlgItemMessageA(hwndDlg, IDC_INCLUDECHAIN_PKCS7_CHECK, BM_SETCHECK, 0, 0);
            }

            if (!(pExportHelper->fExportPrivateKeys))
            {
                switch (pExportHelper->pExportCertInfo->dwExportFormat)
                {
                case CRYPTUI_WIZ_EXPORT_FORMAT_DER:
                    SendDlgItemMessageA(hwndDlg, IDC_DER_RADIO, BM_SETCHECK, 1, 0);
                    break;

                case CRYPTUI_WIZ_EXPORT_FORMAT_BASE64:
                    SendDlgItemMessageA(hwndDlg, IDC_BASE64_RADIO, BM_SETCHECK, 1, 0);
                    break;

                case CRYPTUI_WIZ_EXPORT_FORMAT_PKCS7:
                    SendDlgItemMessageA(hwndDlg, IDC_PKCS7_RADIO, BM_SETCHECK, 1, 0);
                    break;

                default:
                    SendDlgItemMessageA(hwndDlg, IDC_DER_RADIO, BM_SETCHECK, 1, 0);
                    break;
                }
            }
        }
        else
        {
            if (!pExportHelper->fExportPrivateKeys)
            {
                SendDlgItemMessageA(hwndDlg, IDC_DER_RADIO, BM_SETCHECK, 1, 0);
            }
        }

		break;

    case WM_COMMAND:
        pExportHelper = (PEXPORT_HELPER_STRUCT) GetWindowLongPtr(hwndDlg, DWLP_USER);

        switch (LOWORD(wParam))
        {

         case IDC_DER_RADIO:
         case IDC_BASE64_RADIO:
            if (HIWORD(wParam) == BN_CLICKED)
            {
                EnableWindow(GetDlgItem(hwndDlg, IDC_INCLUDECHAIN_PFX_CHECK), FALSE);
                EnableWindow(GetDlgItem(hwndDlg, IDC_INCLUDECHAIN_PKCS7_CHECK), FALSE);
                return TRUE;
            }
            break;

         case IDC_PFX_RADIO:
            if (HIWORD(wParam) == BN_CLICKED)
            {
                EnableWindow(GetDlgItem(hwndDlg, IDC_INCLUDECHAIN_PFX_CHECK), TRUE);
                EnableWindow(GetDlgItem(hwndDlg, IDC_INCLUDECHAIN_PKCS7_CHECK), FALSE);
                return TRUE;
            }
            break;

        case IDC_PKCS7_RADIO:
            if (HIWORD(wParam) == BN_CLICKED)
            {
                EnableWindow(GetDlgItem(hwndDlg, IDC_INCLUDECHAIN_PFX_CHECK), FALSE);
                EnableWindow(GetDlgItem(hwndDlg, IDC_INCLUDECHAIN_PKCS7_CHECK), TRUE);
                return TRUE;
            }
            break;
        }

        break;

	case WM_NOTIFY:
        pExportHelper = (PEXPORT_HELPER_STRUCT) GetWindowLongPtr(hwndDlg, DWLP_USER);

    	switch (((NMHDR FAR *) lParam)->code)
    	{
            case PSN_QUERYCANCEL:
                SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, FALSE);
                pExportHelper->dwErrorCode = ERROR_CANCELLED;
                return TRUE;
  			
            case PSN_KILLACTIVE:

                if (SendDlgItemMessageA(hwndDlg, IDC_PKCS7_RADIO, BM_GETCHECK, 0, 0))
                {
                    pExportHelper->dwExportFormat =  CRYPTUI_WIZ_EXPORT_FORMAT_PKCS7;
                    pExportHelper->fExportChain = (int)SendDlgItemMessageA(hwndDlg, IDC_INCLUDECHAIN_PKCS7_CHECK, BM_GETCHECK, 0, 0);
                }
                else if (SendDlgItemMessageA(hwndDlg, IDC_PFX_RADIO, BM_GETCHECK, 0, 0))
                {
                    pExportHelper->dwExportFormat =  CRYPTUI_WIZ_EXPORT_FORMAT_PFX;
                    pExportHelper->fExportChain = (int)SendDlgItemMessageA(hwndDlg, IDC_INCLUDECHAIN_PFX_CHECK, BM_GETCHECK, 0, 0);
					pExportHelper->fStrongEncryption = (int)SendDlgItemMessageA(hwndDlg, IDC_STRONG_ENCRYPTION_CHECK, BM_GETCHECK, 0, 0);
                    pExportHelper->fDeletePrivateKey = (int)SendDlgItemMessageA(hwndDlg, IDC_DELETE_PRIVATE_KEY_CHECK, BM_GETCHECK, 0, 0);
                }
                else if (SendDlgItemMessageA(hwndDlg, IDC_DER_RADIO, BM_GETCHECK, 0, 0))
                {
                    pExportHelper->dwExportFormat =  CRYPTUI_WIZ_EXPORT_FORMAT_DER;
                    pExportHelper->fExportChain = FALSE;
                }
                else if (SendDlgItemMessageA(hwndDlg, IDC_BASE64_RADIO, BM_GETCHECK, 0, 0))
                {
                    pExportHelper->dwExportFormat =  CRYPTUI_WIZ_EXPORT_FORMAT_BASE64;
                    pExportHelper->fExportChain = FALSE;
                }

                SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
                return TRUE;

			case PSN_RESET:
                SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
				break;

 			case PSN_SETACTIVE:
 				PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_NEXT | PSWIZB_BACK);

                if (pExportHelper->fExportPrivateKeys)
                {
                    SendDlgItemMessageA(hwndDlg, IDC_PFX_RADIO, BM_SETCHECK, 1, 0);
                    SendDlgItemMessageA(hwndDlg, IDC_PKCS7_RADIO, BM_SETCHECK, 0, 0);
                    SendDlgItemMessageA(hwndDlg, IDC_DER_RADIO, BM_SETCHECK, 0, 0);
                    SendDlgItemMessageA(hwndDlg, IDC_BASE64_RADIO, BM_SETCHECK, 0, 0);
					SendDlgItemMessageA(hwndDlg,
										IDC_STRONG_ENCRYPTION_CHECK,
										BM_SETCHECK,
										pExportHelper->fStrongEncryption,
										0);
                    SendDlgItemMessageA(hwndDlg,
										IDC_DELETE_PRIVATE_KEY_CHECK,
										BM_SETCHECK,
										pExportHelper->fDeletePrivateKey,
										0);
                    EnableWindow(GetDlgItem(hwndDlg, IDC_PFX_RADIO), TRUE);
                    EnableWindow(GetDlgItem(hwndDlg, IDC_PKCS7_RADIO), FALSE);
                    EnableWindow(GetDlgItem(hwndDlg, IDC_DER_RADIO), FALSE);
                    EnableWindow(GetDlgItem(hwndDlg, IDC_BASE64_RADIO), FALSE);
                    EnableWindow(GetDlgItem(hwndDlg, IDC_INCLUDECHAIN_PFX_CHECK), TRUE);
					EnableWindow(GetDlgItem(hwndDlg, IDC_STRONG_ENCRYPTION_CHECK), TRUE);
                    EnableWindow(GetDlgItem(hwndDlg, IDC_DELETE_PRIVATE_KEY_CHECK),  
                                 CRYPTUI_WIZ_EXPORT_NO_DELETE_PRIVATE_KEY & pExportHelper->dwFlags ? FALSE : TRUE);
                    EnableWindow(GetDlgItem(hwndDlg, IDC_INCLUDECHAIN_PKCS7_CHECK), FALSE);
                }
                else
                {
                    SendDlgItemMessageA(hwndDlg, IDC_PFX_RADIO, BM_SETCHECK, 0, 0);
                    EnableWindow(GetDlgItem(hwndDlg, IDC_PFX_RADIO), FALSE);
                    EnableWindow(GetDlgItem(hwndDlg, IDC_PKCS7_RADIO), TRUE);
                    EnableWindow(GetDlgItem(hwndDlg, IDC_DER_RADIO), TRUE);
                    EnableWindow(GetDlgItem(hwndDlg, IDC_BASE64_RADIO), TRUE);
                    EnableWindow(GetDlgItem(hwndDlg, IDC_INCLUDECHAIN_PFX_CHECK), FALSE);
					EnableWindow(GetDlgItem(hwndDlg, IDC_STRONG_ENCRYPTION_CHECK), FALSE);
                    EnableWindow(GetDlgItem(hwndDlg, IDC_DELETE_PRIVATE_KEY_CHECK), FALSE);

                    if (SendDlgItemMessageA(hwndDlg, IDC_PKCS7_RADIO, BM_GETCHECK, 0, 0))
                    {
                        EnableWindow(GetDlgItem(hwndDlg, IDC_INCLUDECHAIN_PKCS7_CHECK), TRUE);
                    }
                    else
                    {
                        EnableWindow(GetDlgItem(hwndDlg, IDC_INCLUDECHAIN_PKCS7_CHECK), FALSE);
                    }

                    if (!SendDlgItemMessageA(hwndDlg, IDC_DER_RADIO, BM_GETCHECK, 0, 0) &&
                        !SendDlgItemMessageA(hwndDlg, IDC_PKCS7_RADIO, BM_GETCHECK, 0, 0) &&
                        !SendDlgItemMessageA(hwndDlg, IDC_BASE64_RADIO, BM_GETCHECK, 0, 0))
                    {
                        SendDlgItemMessageA(hwndDlg, IDC_DER_RADIO, BM_SETCHECK, 1, 0);
                    }
                }
				break;

            case PSN_WIZBACK:
                if (!pExportHelper->fPrivateKeysExist || 
                    (CRYPTUI_WIZ_EXPORT_PRIVATE_KEY & pExportHelper->dwFlags))
                {
                    SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_EXPORTWIZARD_WELCOME);
                }

                break;

            case PSN_WIZNEXT:
                if (!SendDlgItemMessageA(hwndDlg, IDC_PKCS7_RADIO, BM_GETCHECK, 0, 0)   &&
                    !SendDlgItemMessageA(hwndDlg, IDC_PFX_RADIO, BM_GETCHECK, 0, 0)     &&
                    !SendDlgItemMessageA(hwndDlg, IDC_DER_RADIO, BM_GETCHECK, 0, 0)     &&
                    !SendDlgItemMessageA(hwndDlg, IDC_BASE64_RADIO, BM_GETCHECK, 0, 0))
                {
                    I_MessageBox(hwndDlg, IDS_SELECT_FORMAT, IDS_EXPORT_WIZARD_TITLE, NULL, MB_OK | MB_ICONWARNING);
                    SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, -1);
                    break;
                }

                if (!SendDlgItemMessageA(hwndDlg, IDC_PFX_RADIO, BM_GETCHECK, 0, 0))
                {
                    SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_EXPORTWIZARD_FILENAME);
                    return TRUE;
                }
                break;

			default:
				return FALSE;

    	}
		break;

		default:
			return FALSE;
	}

	return TRUE;
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static INT_PTR APIENTRY ExportPasswordPageProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    PEXPORT_HELPER_STRUCT   pExportHelper = NULL;
    PROPSHEETPAGE           *pPropSheet = NULL;
    LPWSTR                  pwszPassword1;
    LPWSTR                  pwszPassword2;
    DWORD                   cch1, cch2;
    WCHAR                   szErrorTitle[MAX_STRING_SIZE];
    WCHAR                   szErrorString[MAX_STRING_SIZE];

	switch (msg)
	{
	case WM_INITDIALOG:
        //set the wizard information so that it can be shared
        pPropSheet = (PROPSHEETPAGE *) lParam;
        pExportHelper = (PEXPORT_HELPER_STRUCT) (pPropSheet->lParam);
        SetWindowLongPtr(hwndDlg, DWLP_USER, (LONG_PTR)pExportHelper);

        SetControlFont(pExportHelper->hBold, hwndDlg, IDC_PPPK_STATIC);

#if (1) //DSIE: Bug 333621
        SendDlgItemMessage(hwndDlg, IDC_PASSWORD1_EDIT, EM_LIMITTEXT, (WPARAM) 32, (LPARAM) 0);
        SendDlgItemMessage(hwndDlg, IDC_PASSWORD2_EDIT, EM_LIMITTEXT, (WPARAM) 32, (LPARAM) 0);
#endif
        SetDlgItemTextU(hwndDlg, IDC_PASSWORD1_EDIT, L"");
        SetDlgItemTextU(hwndDlg, IDC_PASSWORD2_EDIT, L"");

		break;

    /*case WM_COMMAND:
        pExportHelper = (PEXPORT_HELPER_STRUCT) GetWindowLongPtr(hwndDlg, DWLP_USER);

        switch (LOWORD(wParam))
        {

         case IDC_PASSWORD1_EDIT:
            if (HIWORD(wParam) == EN_SETFOCUS)
            {
                SendDlgItemMessageA(hwndDlg, IDC_PASSWORD1_EDIT, EM_SETSEL, 0, -1);
                return TRUE;
            }
            break;

         case IDC_PASSWORD2_EDIT:
            if (HIWORD(wParam) == EN_SETFOCUS)
            {
                SendDlgItemMessageA(hwndDlg, IDC_PASSWORD2_EDIT, EM_SETSEL, 0, -1);
                return TRUE;
            }
            break;
        }

        break;*/

	case WM_NOTIFY:
        pExportHelper = (PEXPORT_HELPER_STRUCT) GetWindowLongPtr(hwndDlg, DWLP_USER);

    	switch (((NMHDR FAR *) lParam)->code)
    	{
            case PSN_QUERYCANCEL:
                SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, FALSE);
                pExportHelper->dwErrorCode = ERROR_CANCELLED;
                return TRUE;

  			case PSN_KILLACTIVE:

                if (pExportHelper->pwszPassword != NULL)
                {
                    // DSIE: Bug 534689.
                    SecureZeroMemory(pExportHelper->pwszPassword, lstrlenW(pExportHelper->pwszPassword) * sizeof(WCHAR));
                    free(pExportHelper->pwszPassword);
                    pExportHelper->pwszPassword = NULL;
                }

                cch1 = (DWORD)SendDlgItemMessage(hwndDlg, IDC_PASSWORD1_EDIT, WM_GETTEXTLENGTH, 0, 0);
                if (NULL == (pwszPassword1 = (LPWSTR) malloc((cch1+1)*sizeof(WCHAR))))
                {
                    return FALSE;
                }

                cch2 = (DWORD)SendDlgItemMessage(hwndDlg, IDC_PASSWORD2_EDIT, WM_GETTEXTLENGTH, 0, 0);
                if (NULL == (pwszPassword2 = (LPWSTR) malloc((cch2+1)*sizeof(WCHAR))))
                {
                    free(pwszPassword1);
                    return FALSE;
                }
                
                GetDlgItemTextU(hwndDlg, IDC_PASSWORD1_EDIT, pwszPassword1, cch1+1);
                GetDlgItemTextU(hwndDlg, IDC_PASSWORD2_EDIT, pwszPassword2, cch2+1);

                if ((cch1 == 0) && (cch2 == 0))
                {
                    // DSIE: Bug 563670.
                    SecureZeroMemory(pwszPassword1, lstrlenW(pwszPassword1) * sizeof(WCHAR));
                    SecureZeroMemory(pwszPassword2, lstrlenW(pwszPassword2) * sizeof(WCHAR));
                    free(pwszPassword1);
                    free(pwszPassword2);

                    pExportHelper->pwszPassword = NULL;
                }
                else if (wcscmp(pwszPassword1, pwszPassword2) != 0)
                {
                    I_MessageBox(hwndDlg, IDS_MISMATCH_PASSWORDS, IDS_EXPORT_WIZARD_TITLE, NULL, MB_OK | MB_ICONWARNING);

                    SetFocus(GetDlgItem(hwndDlg, IDC_PASSWORD1_EDIT));
                    //SendDlgItemMessageA(hwndDlg, IDC_PASSWORD1_EDIT, EM_SETSEL, 0, -1);
                    SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, -1);
                    
                    SecureZeroMemory(pwszPassword1, lstrlenW(pwszPassword1) * sizeof(WCHAR));
                    SecureZeroMemory(pwszPassword2, lstrlenW(pwszPassword2) * sizeof(WCHAR));
                    free(pwszPassword1);
                    free(pwszPassword2);
                    break;
                }
                else
                {
                    pExportHelper->pwszPassword = pwszPassword1;
                    // DSIE: Bug 534689.
                    SecureZeroMemory(pwszPassword2, lstrlenW(pwszPassword2) * sizeof(WCHAR));
                    free(pwszPassword2);
                }

                SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, FALSE);
                return TRUE;

			case PSN_RESET:
                SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
				break;

 			case PSN_SETACTIVE:
 				PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_NEXT | PSWIZB_BACK);
				break;

            case PSN_WIZBACK:
                break;

            case PSN_WIZNEXT:

                break;

			default:
				return FALSE;

    	}
		break;

		default:
			return FALSE;
	}

	return TRUE;
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static LPWSTR 
BrowseForFileName(
    HWND hwndDlg, 
    PEXPORT_HELPER_STRUCT pExportHelper, 
    LPWSTR pwszInitialDir)
{
    OPENFILENAMEW   openFileName;
    WCHAR           saveFileName[_MAX_PATH];
    WCHAR           filterString[MAX_STRING_SIZE];
    
    memset(&openFileName, 0, sizeof(OPENFILENAMEW));
    openFileName.lStructSize = sizeof(openFileName);
    openFileName.hwndOwner = hwndDlg;
    openFileName.hInstance = NULL;
    switch (pExportHelper->pExportInfo->dwSubjectChoice)
    {
    case CRYPTUI_WIZ_EXPORT_CERT_STORE:
        LoadFilterString(g_hmodThisDll, IDS_SERIALIZED_STORE_SAVE, filterString, ARRAYSIZE(filterString)-1);
        openFileName.lpstrDefExt = L"sst";
        break;

    case CRYPTUI_WIZ_EXPORT_CERT_STORE_CERTIFICATES_ONLY:
        LoadFilterString(g_hmodThisDll, IDS_PKCS7_SAVE, filterString, ARRAYSIZE(filterString)-1);
        openFileName.lpstrDefExt = L"p7b";
        break;

    case CRYPTUI_WIZ_EXPORT_CRL_CONTEXT:
        LoadFilterString(g_hmodThisDll, IDS_CRL_SAVE, filterString, ARRAYSIZE(filterString)-1);
        openFileName.lpstrDefExt = L"crl";
        break;

    case CRYPTUI_WIZ_EXPORT_CTL_CONTEXT:
        LoadFilterString(g_hmodThisDll, IDS_CTL_SAVE, filterString, ARRAYSIZE(filterString)-1);
        openFileName.lpstrDefExt = L"stl";
        break;

    case CRYPTUI_WIZ_EXPORT_CERT_CONTEXT:
        switch (pExportHelper->dwExportFormat)
        {
        case CRYPTUI_WIZ_EXPORT_FORMAT_DER:
            LoadFilterString(g_hmodThisDll, IDS_DER_SAVE, filterString, ARRAYSIZE(filterString)-1);
            openFileName.lpstrDefExt = L"cer";
            break;

        case CRYPTUI_WIZ_EXPORT_FORMAT_BASE64:
            LoadFilterString(g_hmodThisDll, IDS_BASE64_SAVE, filterString, ARRAYSIZE(filterString)-1);
            openFileName.lpstrDefExt = L"cer";
            break;

        case CRYPTUI_WIZ_EXPORT_FORMAT_PFX:
            LoadFilterString(g_hmodThisDll, IDS_PFX_SAVE, filterString, ARRAYSIZE(filterString)-1);
            openFileName.lpstrDefExt = L"pfx";
            break;

        case CRYPTUI_WIZ_EXPORT_FORMAT_PKCS7:
            LoadFilterString(g_hmodThisDll, IDS_PKCS7_SAVE, filterString, ARRAYSIZE(filterString)-1);
            openFileName.lpstrDefExt = L"p7b";
            break;
        }
        break;
    }
    openFileName.lpstrFilter = filterString;
    openFileName.lpstrCustomFilter = NULL;
    openFileName.nMaxCustFilter = 0;
    openFileName.nFilterIndex = 1;
    saveFileName[0] = 0;
    openFileName.lpstrFile = saveFileName;
    openFileName.nMaxFile = ARRAYSIZE(saveFileName);
    openFileName.lpstrFileTitle = NULL;
    openFileName.nMaxFileTitle = 0;
    openFileName.lpstrInitialDir = pwszInitialDir;
    openFileName.lpstrTitle = NULL;
    openFileName.Flags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT | OFN_PATHMUSTEXIST;
    openFileName.nFileOffset = 0;
    openFileName.nFileExtension = 0;
    openFileName.lCustData = NULL;
    openFileName.lpfnHook = NULL;
    openFileName.lpTemplateName = NULL;

    if (!WizGetSaveFileName(&openFileName))
    {
        return NULL;
    }

    return (AllocAndCopyWStr(saveFileName));
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static HRESULT CheckAndAddExtension(PEXPORT_HELPER_STRUCT pExportHelper, LPWSTR pwszExt)
{
    void *pTemp;

    if ((wcslen(pExportHelper->pwszExportFileName) < 4) ||
        (_wcsicmp(pwszExt, &(pExportHelper->pwszExportFileName[wcslen(pExportHelper->pwszExportFileName)-4])) != 0))
    {
        pTemp = realloc(pExportHelper->pwszExportFileName,
                        (wcslen(pExportHelper->pwszExportFileName) + 4 + 1) * sizeof(WCHAR));

        if (pTemp != NULL)
        {
            pExportHelper->pwszExportFileName = (LPWSTR) pTemp;
            wcscat(pExportHelper->pwszExportFileName, pwszExt);
        }
        else
        {
            // pExportHelper->pwszExportFileName will be free'd later
            return E_OUTOFMEMORY;
        }
    }
    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static HRESULT ValidateExtension(PEXPORT_HELPER_STRUCT pExportHelper)
{
    switch (pExportHelper->pExportInfo->dwSubjectChoice)
    {
    case CRYPTUI_WIZ_EXPORT_CTL_CONTEXT:
        return CheckAndAddExtension(pExportHelper, L".stl");
        break;

    case CRYPTUI_WIZ_EXPORT_CRL_CONTEXT:
        return CheckAndAddExtension(pExportHelper, L".crl");
        break;

    case CRYPTUI_WIZ_EXPORT_CERT_STORE_CERTIFICATES_ONLY:
        return CheckAndAddExtension(pExportHelper, L".p7b");
        break;

    case CRYPTUI_WIZ_EXPORT_CERT_STORE:
        return CheckAndAddExtension(pExportHelper, L".sst");
        break;

    case CRYPTUI_WIZ_EXPORT_CERT_CONTEXT:
        switch (pExportHelper->dwExportFormat)
        {
        case CRYPTUI_WIZ_EXPORT_FORMAT_DER:
        case CRYPTUI_WIZ_EXPORT_FORMAT_BASE64:
            return CheckAndAddExtension(pExportHelper, L".cer");
            break;

        case CRYPTUI_WIZ_EXPORT_FORMAT_PFX:
            return CheckAndAddExtension(pExportHelper, L".pfx");
            break;

        case CRYPTUI_WIZ_EXPORT_FORMAT_PKCS7:
            return CheckAndAddExtension(pExportHelper, L".p7b");
            break;

        case CRYPTUI_WIZ_EXPORT_FORMAT_SERIALIZED_CERT_STORE:
            return CheckAndAddExtension(pExportHelper, L".sst");
            break;
        }

        break;
    }

    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static BOOL FileNameOK(HWND hwndDlg, LPWSTR pwszExportFileName)
{
    WCHAR   szErrorTitle[MAX_STRING_SIZE];
    WCHAR   szErrorString[MAX_STRING_SIZE];
    LPWSTR  psz;
    HANDLE  hTestFile;
    int     i;

    hTestFile = ExpandAndCreateFileU(
                    pwszExportFileName,
                    GENERIC_READ,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    0);

    if (hTestFile == INVALID_HANDLE_VALUE)
    {
        hTestFile = ExpandAndCreateFileU(
                    pwszExportFileName,
                    GENERIC_WRITE,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    CREATE_NEW,
                    0,
                    0);

        if (hTestFile == INVALID_HANDLE_VALUE)
        {
            LoadStringU(g_hmodThisDll, IDS_EXPORT_WIZARD_TITLE, szErrorTitle, ARRAYSIZE(szErrorTitle));
            LoadStringU(g_hmodThisDll, IDS_PATH_NOT_FOUND, szErrorString, ARRAYSIZE(szErrorString));
            MessageBoxExW(hwndDlg, szErrorString, szErrorTitle, MB_OK | MB_ICONWARNING, 0);
            return (FALSE);
        }

        CloseHandle(hTestFile);
        DeleteFileU(pwszExportFileName);
        return TRUE;
    }
    else
    {
        CloseHandle(hTestFile);
        LoadStringU(g_hmodThisDll, IDS_EXPORT_WIZARD_TITLE, szErrorTitle, ARRAYSIZE(szErrorTitle));
        LoadStringU(g_hmodThisDll, IDS_OVERWRITE_FILE_NAME, szErrorString, ARRAYSIZE(szErrorString));

        psz = (LPWSTR) malloc((wcslen(szErrorString) + wcslen(pwszExportFileName) + 1) * sizeof(WCHAR));
        if (psz == NULL)
        {
            return FALSE;
        }

        swprintf(psz, szErrorString, pwszExportFileName);
        i = MessageBoxExW(hwndDlg, psz, szErrorTitle, MB_YESNO | MB_ICONWARNING, 0);
        free(psz);
        return (i == IDYES);
    }
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static void AddDefaultPath(PEXPORT_HELPER_STRUCT pExportHelper)
{
    int     i;
    BOOL    fAdd = TRUE;
    DWORD   dwSize = 0;
    LPWSTR  pwszCurrentDir = NULL;

    //
    // check to see if there are any ':' or '\'
    //
    i = 0;
    while (i<wcslen(pExportHelper->pwszExportFileName))
    {
        if ((pExportHelper->pwszExportFileName[i] == ':') ||
            (pExportHelper->pwszExportFileName[i] == '\\'))
        {
            fAdd = FALSE;
        }
        i++;
    }

    if (fAdd)
    {
        dwSize = GetCurrentDirectoryU(0, NULL);

        if (NULL != (pwszCurrentDir = (LPWSTR) malloc((wcslen(pExportHelper->pwszExportFileName) + dwSize + 1) * sizeof(WCHAR))))
        {
            GetCurrentDirectoryU(dwSize, pwszCurrentDir);
            if (pwszCurrentDir[wcslen(pwszCurrentDir)-1] != '\\')
            {
                wcscat(pwszCurrentDir, L"\\");
            }
            wcscat(pwszCurrentDir, pExportHelper->pwszExportFileName);
            free(pExportHelper->pwszExportFileName);
            pExportHelper->pwszExportFileName = pwszCurrentDir;
        }
    }
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static INT_PTR APIENTRY ExportFileNamePageProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    PEXPORT_HELPER_STRUCT   pExportHelper = NULL;
    PROPSHEETPAGE           *pPropSheet = NULL;
    DWORD                   cch;
    LPWSTR                  pwszTempFileName;
    LPWSTR                  pwszInitialDir = NULL;

	switch (msg)
	{
	case WM_INITDIALOG:
        //set the wizard information so that it can be shared
        pPropSheet = (PROPSHEETPAGE *) lParam;
        pExportHelper = (PEXPORT_HELPER_STRUCT) (pPropSheet->lParam);
        SetWindowLongPtr(hwndDlg, DWLP_USER, (LONG_PTR)pExportHelper);

        SetControlFont(pExportHelper->hBold, hwndDlg, IDC_EFN_STATIC);

        if (pExportHelper->pExportInfo->pwszExportFileName != NULL)
        {
            SetDlgItemTextU(hwndDlg, IDC_NAME_EDIT, pExportHelper->pExportInfo->pwszExportFileName);
        }
        else
        {
            SetDlgItemTextU(hwndDlg, IDC_NAME_EDIT, L"");
        }

		break;

    case WM_COMMAND:
        pExportHelper = (PEXPORT_HELPER_STRUCT) GetWindowLongPtr(hwndDlg, DWLP_USER);

        switch (LOWORD(wParam))
        {
            case IDC_NAME_EDIT:
            {
                if (EN_CHANGE == HIWORD(wParam))
                {
                    if (SendDlgItemMessage(hwndDlg, IDC_NAME_EDIT, WM_GETTEXTLENGTH, 0, 0))
                    {
                        PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_NEXT | PSWIZB_BACK);
                    }
                    else
                    {
                        PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK);
                    }

                    return TRUE;
                }

                break;
            }

            case IDC_BROWSE_BUTTON:
            {
                if (HIWORD(wParam) == BN_CLICKED)
                {
                    cch = (DWORD)SendDlgItemMessage(hwndDlg, IDC_NAME_EDIT, WM_GETTEXTLENGTH, 0, 0);
                    if (NULL != (pwszInitialDir = (LPWSTR) malloc((cch+1)*sizeof(WCHAR))))
                    {
                        GetDlgItemTextU(hwndDlg, IDC_NAME_EDIT, pwszInitialDir, cch+1);
                    }
                
                    pwszTempFileName = BrowseForFileName(hwndDlg, pExportHelper, pwszInitialDir);
                    if (pwszTempFileName != NULL)
                    {
                        SetDlgItemTextU(hwndDlg, IDC_NAME_EDIT, pwszTempFileName);
                        free(pwszTempFileName);
                       // SendDlgItemMessageA(hwndDlg, IDC_NAME_EDIT, EM_SETSEL, 0, -1);
                        pExportHelper->fDontCheckFileName = TRUE;
                    }

                    if (pwszInitialDir != NULL)
                    {
                        free(pwszInitialDir);
                        pwszInitialDir = NULL;
                    }
                    return TRUE;
                }
                break;
            }
        }

        break;

    case WM_NOTIFY:
        pExportHelper = (PEXPORT_HELPER_STRUCT) GetWindowLongPtr(hwndDlg, DWLP_USER);

    	switch (((NMHDR FAR *) lParam)->code)
    	{
            case PSN_QUERYCANCEL:
                SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, FALSE);
                pExportHelper->dwErrorCode = ERROR_CANCELLED;
                return TRUE;

  			case PSN_KILLACTIVE:

                if (pExportHelper->pwszExportFileName != NULL)
                {
                    free(pExportHelper->pwszExportFileName);
                    pExportHelper->pwszExportFileName = NULL;
                }

                cch = (DWORD)SendDlgItemMessage(hwndDlg, IDC_NAME_EDIT, WM_GETTEXTLENGTH, 0, 0);
                if (NULL == (pExportHelper->pwszExportFileName = (LPWSTR) malloc((cch+1)*sizeof(WCHAR))))
                {
                    return FALSE;
                }
                GetDlgItemTextU(hwndDlg, IDC_NAME_EDIT, pExportHelper->pwszExportFileName, cch+1);

                if (pExportHelper->fNextPage)
                {
                    if (ValidateExtension(pExportHelper) != S_OK)
                    {
                        return FALSE;
                    }
                }

                if (pExportHelper->fNextPage)
                {
                    AddDefaultPath(pExportHelper);
                }

                if (!(pExportHelper->fDontCheckFileName)                && 
                    pExportHelper->fNextPage                            &&
                    ((pExportHelper->pwszExportFileNameToCheck == NULL)     ||
                        (wcscmp(pExportHelper->pwszExportFileNameToCheck, pExportHelper->pwszExportFileName) != 0)))
                {
                    if (!FileNameOK(hwndDlg, pExportHelper->pwszExportFileName))
                    {
                        SetFocus(GetDlgItem(hwndDlg, IDC_NAME_EDIT));
                        //SendDlgItemMessage(hwndDlg, IDC_NAME_EDIT, EM_SETSEL, 0, -1);
                        SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, -1);
                        break;
                    }
                }

                if ((pExportHelper->pwszExportFileNameToCheck != NULL) &&
                    (pExportHelper->fNextPage == TRUE))
                {
                    free(pExportHelper->pwszExportFileNameToCheck);
                    pExportHelper->pwszExportFileNameToCheck = NULL;
                }

                SetDlgItemTextU(hwndDlg, IDC_NAME_EDIT, pExportHelper->pwszExportFileName);
                
                SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
                return TRUE;

			case PSN_RESET:
                SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
				break;

 			case PSN_SETACTIVE:
                pExportHelper->fDontCheckFileName = FALSE;

                if (pExportHelper->fNextPage == TRUE)
                {
                    cch = (DWORD)SendDlgItemMessage(hwndDlg, IDC_NAME_EDIT, WM_GETTEXTLENGTH, 0, 0);
                    if (NULL == (pExportHelper->pwszExportFileNameToCheck = (LPWSTR) malloc((cch+1)*sizeof(WCHAR))))
                    {
                        pExportHelper->pwszExportFileNameToCheck = NULL;
                    }
                    else
                    {
                        GetDlgItemTextU(hwndDlg, IDC_NAME_EDIT, pExportHelper->pwszExportFileNameToCheck, cch+1);
                    }
                }

                if (SendDlgItemMessage(hwndDlg, IDC_NAME_EDIT, WM_GETTEXTLENGTH, 0, 0))
                {
                    PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_NEXT | PSWIZB_BACK);
                }
                else
                {
                    PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK);
                }

                break;

            case PSN_WIZBACK:
                if (pExportHelper->pExportInfo->dwSubjectChoice != CRYPTUI_WIZ_EXPORT_CERT_CONTEXT)
                {
                    SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_EXPORTWIZARD_WELCOME);
                }
                else if (!(pExportHelper->fExportPrivateKeys))
                {
                    SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_EXPORTWIZARD_FORMAT);
                }
                pExportHelper->fNextPage = FALSE;
                break;

            case PSN_WIZNEXT:
                cch = (DWORD)SendDlgItemMessage(hwndDlg, IDC_NAME_EDIT, WM_GETTEXTLENGTH, 0, 0);

                if (cch == 0)
                {
                    I_MessageBox(hwndDlg, IDS_INPUT_FILENAME, IDS_EXPORT_WIZARD_TITLE, NULL, MB_OK | MB_ICONWARNING);
                    SetFocus(GetDlgItem(hwndDlg, IDC_NAME_EDIT));
                    SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, -1);
                    break;
                }

                pExportHelper->fNextPage = TRUE;
                break;

			default:
				return FALSE;

    	}
		break;

		default:
			return FALSE;
	}

	return TRUE;
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
void DisplayUnknownError(HWND hwndDlg, UINT idsCaption, UINT idsInitialString, DWORD dwError)
{
    WCHAR   wszTitle[256];
    WCHAR   wszInitialString[512];
    LPWSTR  pwszFinalString = NULL;
    LPWSTR  pwszError = NULL;

    GetUnknownErrorString(&pwszError, dwError);

    if (pwszError != NULL)
    {
        LoadStringU(g_hmodThisDll, idsCaption, wszTitle, ARRAYSIZE(wszTitle));
        LoadStringU(g_hmodThisDll, idsInitialString, wszInitialString, ARRAYSIZE(wszInitialString));

        pwszFinalString = (LPWSTR) malloc((wcslen(wszInitialString) + wcslen(pwszError) + 3) * sizeof(WCHAR));
        if (pwszFinalString == NULL)
        {
            free(pwszError);
            return;
        }
        wcscpy(pwszFinalString, wszInitialString);
        wcscat(pwszFinalString, L"\n");
        wcscat(pwszFinalString, pwszError);

        MessageBoxExW(hwndDlg, pwszFinalString, wszTitle, MB_OK | MB_ICONERROR, 0);
        free(pwszError);
        free(pwszFinalString);
    }
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static INT_PTR APIENTRY ExportCompletionPageProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    PEXPORT_HELPER_STRUCT   pExportHelper = NULL;
    PROPSHEETPAGE           *pPropSheet = NULL;
    WCHAR                   szSummaryItem[MAX_STRING_SIZE];
    HDC                     hdc = NULL;
    COLORREF                colorRefBack;
    COLORREF                colorRefText;
    LV_COLUMNW              lvC;
    LV_ITEMW                lvItem;
    HWND                    hWndListView;
    LPNMLISTVIEW            pnmv;
    HRESULT                 hr;

	switch (msg)
	{
	case WM_INITDIALOG:
        //set the wizard information so that it can be shared
        pPropSheet = (PROPSHEETPAGE *) lParam;
        pExportHelper = (PEXPORT_HELPER_STRUCT) (pPropSheet->lParam);
        SetWindowLongPtr(hwndDlg, DWLP_USER, (LONG_PTR)pExportHelper);

        SetControlFont(pExportHelper->hBigBold, hwndDlg, IDC_COMPLETING_STATIC);

        //
        // add two columns to the summary list
        //
        hWndListView = GetDlgItem(hwndDlg, IDC_SUMMARY_LIST);
        memset(&lvC, 0, sizeof(LV_COLUMNW));
        lvC.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
        lvC.fmt = LVCFMT_LEFT;
        lvC.cx = 2;
        lvC.pszText = L"";
        lvC.iSubItem=0;
        if (ListView_InsertColumnU(hWndListView, 0, &lvC) == -1)
        {
            return FALSE;
        }

        lvC.cx = 2;
        lvC.iSubItem= 1;
        if (ListView_InsertColumnU(hWndListView, 1, &lvC) == -1)
        {
            return FALSE;
        }

#if (1) //DSIE: BUg 481641.
        ListView_SetExtendedListViewStyle(hWndListView,
            ListView_GetExtendedListViewStyle(hWndListView) | LVS_EX_FULLROWSELECT);
#endif
        //
        // set the background color of the summary list
        //
        /*if (hdc = GetWindowDC(hwndDlg))
        {
            if ((CLR_INVALID != (colorRefBack = GetBkColor(hdc))) &&
                (CLR_INVALID != (colorRefText = GetTextColor(hdc))))
            {
                ListView_SetBkColor(GetDlgItem(hwndDlg, IDC_SUMMARY_LIST), CLR_NONE);
                ListView_SetTextBkColor(GetDlgItem(hwndDlg, IDC_SUMMARY_LIST), CLR_NONE);
            }
        }*/

        break;

    case WM_NOTIFY:
        pExportHelper = (PEXPORT_HELPER_STRUCT) GetWindowLongPtr(hwndDlg, DWLP_USER);

    	switch (((NMHDR FAR *) lParam)->code)
    	{
            case PSN_QUERYCANCEL:
                SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, FALSE);
                pExportHelper->dwErrorCode = ERROR_CANCELLED;
                return TRUE;

  			case PSN_KILLACTIVE:
                return TRUE;

			case PSN_RESET:
                SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
				break;

 			case PSN_SETACTIVE:
 				PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_FINISH | PSWIZB_BACK);

                hWndListView = GetDlgItem(hwndDlg, IDC_SUMMARY_LIST);
                ListView_DeleteAllItems(hWndListView);

                memset(&lvItem, 0, sizeof(LV_ITEMW));
                lvItem.mask = LVIF_TEXT | LVIF_STATE ;
                lvItem.state = 0;
                lvItem.stateMask = 0;
                lvItem.iItem = 0;
                lvItem.iSubItem = 0;

                //
                // file name
                //
                ListView_InsertItemU_IDS(hWndListView, &lvItem, IDS_FILE_NAME, NULL);
                ListView_SetItemTextU(hWndListView, lvItem.iItem, 1, pExportHelper->pwszExportFileName);

                if (pExportHelper->pExportInfo->dwSubjectChoice == CRYPTUI_WIZ_EXPORT_CERT_CONTEXT)
                {
                    //
                    // export keys
                    //
                    if (pExportHelper->fExportPrivateKeys)
                    {
                        LoadStringU(g_hmodThisDll, IDS_YES, szSummaryItem, ARRAYSIZE(szSummaryItem));
                    }
                    else
                    {
                        LoadStringU(g_hmodThisDll, IDS_NO, szSummaryItem, ARRAYSIZE(szSummaryItem));
                    }
                    lvItem.iItem++;
                    ListView_InsertItemU_IDS(hWndListView, &lvItem, IDS_EXPORT_KEYS, NULL);
                    ListView_SetItemTextU(hWndListView, lvItem.iItem, 1, szSummaryItem);

                    //
                    // export chain
                    //
                    if (pExportHelper->fExportChain)
                    {
                        LoadStringU(g_hmodThisDll, IDS_YES, szSummaryItem, ARRAYSIZE(szSummaryItem));
                    }
                    else
                    {
                        LoadStringU(g_hmodThisDll, IDS_NO, szSummaryItem, ARRAYSIZE(szSummaryItem));
                    }
                    lvItem.iItem++;
                    ListView_InsertItemU_IDS(hWndListView, &lvItem, IDS_EXPORT_CHAIN, NULL);
                    ListView_SetItemTextU(hWndListView, lvItem.iItem, 1, szSummaryItem);
                }

                //
                // file format
                //
                switch (pExportHelper->pExportInfo->dwSubjectChoice)
                {
                case CRYPTUI_WIZ_EXPORT_CERT_STORE:
                    LoadStringU(g_hmodThisDll, IDS_MYSERIALIZED_STORE, szSummaryItem, ARRAYSIZE(szSummaryItem));
                    break;

                case CRYPTUI_WIZ_EXPORT_CERT_STORE_CERTIFICATES_ONLY:
                    LoadStringU(g_hmodThisDll, IDS_PKCS7, szSummaryItem, ARRAYSIZE(szSummaryItem));
                    break;

                case CRYPTUI_WIZ_EXPORT_CRL_CONTEXT:
                    LoadStringU(g_hmodThisDll, IDS_CRL, szSummaryItem, ARRAYSIZE(szSummaryItem));
                    break;

                case CRYPTUI_WIZ_EXPORT_CTL_CONTEXT:
                    LoadStringU(g_hmodThisDll, IDS_CTL, szSummaryItem, ARRAYSIZE(szSummaryItem));
                    break;

                case CRYPTUI_WIZ_EXPORT_CERT_CONTEXT:
                    switch (pExportHelper->dwExportFormat)
                    {
                    case CRYPTUI_WIZ_EXPORT_FORMAT_DER:
                        LoadStringU(g_hmodThisDll, IDS_DER, szSummaryItem, ARRAYSIZE(szSummaryItem));
                        break;

                    case CRYPTUI_WIZ_EXPORT_FORMAT_BASE64:
                        LoadStringU(g_hmodThisDll, IDS_BASE64, szSummaryItem, ARRAYSIZE(szSummaryItem));
                        break;

                    case CRYPTUI_WIZ_EXPORT_FORMAT_PFX:
                        LoadStringU(g_hmodThisDll, IDS_PFX, szSummaryItem, ARRAYSIZE(szSummaryItem));
                        break;

                    case CRYPTUI_WIZ_EXPORT_FORMAT_PKCS7:
                        LoadStringU(g_hmodThisDll, IDS_PKCS7, szSummaryItem, ARRAYSIZE(szSummaryItem));
                        break;
                    }
                    break;
                }

                lvItem.iItem++;
                ListView_InsertItemU_IDS(hWndListView, &lvItem, IDS_FILE_FORMAT, NULL);
                ListView_SetItemTextU(hWndListView, lvItem.iItem, 1, szSummaryItem);

                ListView_SetColumnWidth(hWndListView, 0, LVSCW_AUTOSIZE);
                ListView_SetColumnWidth(hWndListView, 1, LVSCW_AUTOSIZE);

#if (1) //DSIE: Bug 481641.
                ListView_SetItemState(hWndListView, 
                    0, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
#endif
                break;

            case PSN_WIZBACK:
                break;

            case PSN_WIZNEXT:
                break;

            case PSN_WIZFINISH:
                hr = DoExport(pExportHelper);

                if (hr == S_OK)
                {
                    I_MessageBox(hwndDlg, IDS_EXPORT_SUCCESSFULL, IDS_EXPORT_WIZARD_TITLE, NULL, MB_OK);
                }
                else if ((hr == NTE_BAD_KEYSET) || (hr == NTE_BAD_KEY))
                {
                    I_MessageBox(hwndDlg, IDS_EXPORT_BADKEYS, IDS_EXPORT_WIZARD_TITLE, NULL, MB_OK | MB_ICONERROR);
                }
                else if (hr == ERROR_UNSUPPORTED_TYPE)
                {
                    I_MessageBox(hwndDlg, IDS_EXPORT_UNSUPPORTED, IDS_EXPORT_WIZARD_TITLE, NULL, MB_OK | MB_ICONERROR);
                }
                else
                {
                    DisplayUnknownError(hwndDlg, IDS_EXPORT_WIZARD_TITLE, IDS_EXPORT_FAILED, (DWORD)hr);
                }
                break;

#if (0) //DSIE: Bug 481641.
            case LVN_ITEMCHANGING:

                pnmv = (LPNMLISTVIEW) lParam;

                if (pnmv->uNewState & LVIS_SELECTED)
                {
                    SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, TRUE);

                    ListView_SetItemState(pnmv->hdr.hwndFrom, 0, LVIS_FOCUSED, LVIS_FOCUSED);
                }

                return TRUE;
#endif

            default:
				return FALSE;

    	}
		break;

		default:
			return FALSE;
	}

	return TRUE;
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static BOOL CheckPrivateKeysExist(PCCRYPTUI_WIZ_EXPORT_INFO pExportInfo)
{
    DWORD               cbData = 0;

    if (pExportInfo->dwSubjectChoice == CRYPTUI_WIZ_EXPORT_CERT_CONTEXT)
    {
        if (CertGetCertificateContextProperty(pExportInfo->pCertContext, CERT_KEY_PROV_INFO_PROP_ID, NULL, &cbData))
        {
            return TRUE;
        }
    }

    return FALSE;
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static DWORD CheckPrivateKeyStatus(PCCRYPTUI_WIZ_EXPORT_INFO pExportInfo)
{
    HCRYPTPROV  hCryptProv = NULL;
    DWORD       dwKeySpec = 0;
    BOOL        fCallerFreeProv = FALSE;
    BOOL        dwRet = PRIVATE_KEY_UNKNOWN_STATE;
    HCRYPTKEY   hKey = NULL;
    DWORD       dwPermissions = 0;
    DWORD       dwSize = 0;

    if (pExportInfo->dwSubjectChoice == CRYPTUI_WIZ_EXPORT_CERT_CONTEXT)
    {
        //
        // first get the private key context
        //
        if (!CryptAcquireCertificatePrivateKey(
                pExportInfo->pCertContext,
                CRYPT_ACQUIRE_USE_PROV_INFO_FLAG | CRYPT_ACQUIRE_COMPARE_KEY_FLAG,
                NULL,
                &hCryptProv,
                &dwKeySpec,
                &fCallerFreeProv))
        {
            DWORD dw = GetLastError();
            dwRet = PRIVATE_KEY_CORRUPT;
            goto ErrorReturn;
        }

        //
        // get the handle to the key
        //
        if (!CryptGetUserKey(hCryptProv, dwKeySpec, &hKey))
        {
            dwRet = PRIVATE_KEY_CORRUPT;
            goto ErrorReturn;
        }

        //
        // finally, get the permissions on the key and check if it is exportable
        //
        dwSize = sizeof(dwPermissions);
        if (!CryptGetKeyParam(hKey, KP_PERMISSIONS, (PBYTE)&dwPermissions, &dwSize, 0))
        {
            goto ErrorReturn;
        }

        dwRet = (dwPermissions & CRYPT_EXPORT) ? PRIVATE_KEY_EXPORTABLE : PRIVATE_KEY_NOT_EXPORTABLE;
    }

CleanUp:

    if (hKey != NULL)
    {
        CryptDestroyKey(hKey);
    }

    if (fCallerFreeProv)
    {
        CryptReleaseContext(hCryptProv, 0);
    }

    return dwRet;

ErrorReturn:
    goto CleanUp;
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
BOOL
WINAPI
CryptUIWizExport(
     DWORD                                  dwFlags,
     HWND                                   hwndParent,
     LPCWSTR                                pwszWizardTitle,
     PCCRYPTUI_WIZ_EXPORT_INFO              pExportInfo,
     void                                   *pvoid
)
{
    EXPORT_HELPER_STRUCT    ExportHelper;
    PROPSHEETPAGEW          rgPropSheets[EXPORT_PAGE_NUM];
    PROPSHEETHEADERW        PropSheetHeader;
    int                     i;
    WCHAR                   szTitle[MAX_TITLE_LENGTH];
    BOOL                    fRet = FALSE;
    HRESULT                 hr;

    //
    // make sure if UI less option is set, all required information is provided
    //
    if (dwFlags & CRYPTUI_WIZ_NO_UI)
    {
        if (!Validpvoid(pExportInfo, pvoid))
        {
            SetLastError(E_INVALIDARG);
            return FALSE;
        }
    }

    memset(&ExportHelper, 0, sizeof(ExportHelper));
    ExportHelper.pExportInfo = pExportInfo;
    if (pExportInfo->dwSubjectChoice == CRYPTUI_WIZ_EXPORT_CERT_CONTEXT)
    {
        ExportHelper.pExportCertInfo = (PCCRYPTUI_WIZ_EXPORT_CERTCONTEXT_INFO) pvoid;
    }

    //
    // if this is UI less then just copy over the pExportCertInfo and do the export
    //
    if (dwFlags & CRYPTUI_WIZ_NO_UI)
    {
        // BOOL fRet2 = FALSE;

        if (NULL == (ExportHelper.pwszExportFileName = AllocAndCopyWStr(pExportInfo->pwszExportFileName)))
        {
            return FALSE;
        }

        ExportHelper.dwExportFormat = ExportHelper.pExportCertInfo->dwExportFormat;
        ExportHelper.fExportChain = ExportHelper.pExportCertInfo->fExportChain;
        ExportHelper.fExportPrivateKeys = ExportHelper.pExportCertInfo->fExportPrivateKeys;
        if (ExportHelper.fExportPrivateKeys)
        {
            if (ExportHelper.pExportCertInfo->pwszPassword != NULL)
            {
                ExportHelper.pwszPassword = AllocAndCopyWStr(ExportHelper.pExportCertInfo->pwszPassword);
            }
            else
            {
                ExportHelper.pwszPassword = NULL;
            }
        }

        if (offsetof(CRYPTUI_WIZ_EXPORT_CERTCONTEXT_INFO, fStrongEncryption) < ExportHelper.pExportCertInfo->dwSize)
        {
            ExportHelper.fStrongEncryption = ExportHelper.pExportCertInfo->fStrongEncryption;
        }

        hr = DoExport(&ExportHelper);

        free(ExportHelper.pwszExportFileName);
        if (ExportHelper.fExportPrivateKeys)
        {
            if (ExportHelper.pwszPassword != NULL)
            {
                // memset the password to zero so that it is not around in memory
                SecureZeroMemory(ExportHelper.pwszPassword, wcslen(ExportHelper.pwszPassword)*sizeof(WCHAR));
                free(ExportHelper.pwszPassword);
            }
        }

        if (hr != S_OK)
        {
            SetLastError(hr);
            return FALSE;
        }
        else
        {
            return TRUE;
        }
    }

    //
    //set up the fonts
    //
    if(!SetupFonts(g_hmodThisDll, NULL, &(ExportHelper.hBigBold), &(ExportHelper.hBold)))
    {
        return FALSE;
    }

    //
    // init the common controls
    //
    WizardInit(TRUE);

    //
    // check to see if private keys exist, and whether it is exportable (only for exporting cert contexts)
    //
    ExportHelper.fPrivateKeysExist = CheckPrivateKeysExist(pExportInfo);
    if (ExportHelper.fPrivateKeysExist)
    {
        ExportHelper.dwExportablePrivateKeyStatus = CheckPrivateKeyStatus(pExportInfo);
    }

	ExportHelper.fStrongEncryption = TRUE;

#if (1) //DSIE: DCR bug 531006.
    //
    // Check to see if export flag is set?
    //
    if (CRYPTUI_WIZ_EXPORT_PRIVATE_KEY & dwFlags) 
    {
        if (!ExportHelper.fPrivateKeysExist)
        {
            SetLastError(NTE_NO_KEY);
            return FALSE;
        }
             
        if (PRIVATE_KEY_EXPORTABLE != ExportHelper.dwExportablePrivateKeyStatus) 
        {
            SetLastError(NTE_BAD_KEY_STATE);
            return FALSE;
        }

        ExportHelper.fExportPrivateKeys = TRUE;
    }

    //
    // Store flags.
    //
    ExportHelper.dwFlags = dwFlags;
#endif

    //
    // set up the property pages structures
    //
    memset(rgPropSheets, 0, sizeof(rgPropSheets));

    for (i=0; i<EXPORT_PAGE_NUM; i++)
    {
        rgPropSheets[i].dwSize = sizeof(rgPropSheets[0]);
        rgPropSheets[i].hInstance = g_hmodThisDll;
        rgPropSheets[i].lParam = (LPARAM) &ExportHelper;
    }

    rgPropSheets[0].pszTemplate = (LPWSTR) MAKEINTRESOURCE(IDD_EXPORTWIZARD_WELCOME);
    rgPropSheets[0].pfnDlgProc = ExportWelcomePageProc;

    rgPropSheets[1].pszTemplate = (LPWSTR) MAKEINTRESOURCE(IDD_EXPORTWIZARD_PRIVATEKEYS);
    rgPropSheets[1].pfnDlgProc = ExportPrivateKeysPageProc;

    rgPropSheets[2].pszTemplate = (LPWSTR) MAKEINTRESOURCE(IDD_EXPORTWIZARD_FORMAT);
    rgPropSheets[2].pfnDlgProc = ExportFormatPageProc;

    rgPropSheets[3].pszTemplate = (LPWSTR) MAKEINTRESOURCE(IDD_EXPORTWIZARD_PASSWORD);
    rgPropSheets[3].pfnDlgProc = ExportPasswordPageProc;

    rgPropSheets[4].pszTemplate = (LPWSTR) MAKEINTRESOURCE(IDD_EXPORTWIZARD_FILENAME);
    rgPropSheets[4].pfnDlgProc = ExportFileNamePageProc;

    rgPropSheets[5].pszTemplate = (LPWSTR) MAKEINTRESOURCE(IDD_EXPORTWIZARD_COMPLETION);
    rgPropSheets[5].pfnDlgProc = ExportCompletionPageProc;



    //
    // set up the property sheet header
    //
    memset(&PropSheetHeader, 0, sizeof(PropSheetHeader));
    PropSheetHeader.dwSize = sizeof(PropSheetHeader);
    PropSheetHeader.dwFlags = PSH_PROPSHEETPAGE | PSH_WIZARD | PSH_NOAPPLYNOW;
    PropSheetHeader.hwndParent = hwndParent;
    PropSheetHeader.hInstance = g_hmodThisDll;

    if (pwszWizardTitle != NULL)
        PropSheetHeader.pszCaption = pwszWizardTitle;
    else
    {
        if(LoadStringU(g_hmodThisDll, IDS_EXPORT_WIZARD_TITLE, szTitle, sizeof(szTitle)/sizeof(szTitle[0])))
        {
            PropSheetHeader.pszCaption = szTitle;
        }
    }

    PropSheetHeader.nPages = EXPORT_PAGE_NUM;
    PropSheetHeader.nStartPage = 0;
    PropSheetHeader.ppsp = rgPropSheets;

    fRet = (PropertySheetU(&PropSheetHeader) != 0);

#if (1) // DSIE: Bug 664006.
    if (NULL != ExportHelper.pwszPassword) 
    {
        // memset the password to zero so that it is not around in memory
        SecureZeroMemory(ExportHelper.pwszPassword, wcslen(ExportHelper.pwszPassword)*sizeof(WCHAR));
        free(ExportHelper.pwszPassword);
    }
    if (NULL != ExportHelper.pwszExportFileName)
    {
        free(ExportHelper.pwszExportFileName);
    }
#endif

    DestroyFonts(ExportHelper.hBigBold, ExportHelper.hBold);

    if (0 != ExportHelper.dwErrorCode) 
    {
        SetLastError(ExportHelper.dwErrorCode);
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\ui\wizards\import.cpp ===
//-------------------------------------------------------------
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       import.cpp
//
//  Contents:   The cpp file to implement the import wizard
//
//  History:    5-11-1997 xiaohs   created
//
//--------------------------------------------------------------
#include    "wzrdpvk.h"
#include    "import.h" 
#include    "xenroll.h"


extern	HMODULE g_hmodxEnroll;
typedef   IEnroll2 * (WINAPI *PFNPIEnroll2GetNoCOM)();

//-------------------------------------------------------------------------
// DecodeGenericBlob
//-------------------------------------------------------------------------
DWORD DecodeGenericBlob (IN PCERT_EXTENSION pCertExtension,
	                     IN LPCSTR          lpszStructType,
                         IN OUT void     ** ppStructInfo)
{
    DWORD  dwResult     = 0;
	DWORD  cbStructInfo = 0;

    // check parameters.
    if (!pCertExtension || !lpszStructType || !ppStructInfo)
    {
        return E_POINTER;
    }

    //
    // Determine decoded length.
    //
    if(!CryptDecodeObject(X509_ASN_ENCODING,
                          lpszStructType,
                          pCertExtension->Value.pbData, 
                          pCertExtension->Value.cbData,
		                  0,
                          NULL,
                          &cbStructInfo))
    {
        return GetLastError();
    }

    //
    // Allocate memory.
    //
    if (!(*ppStructInfo = malloc(cbStructInfo)))
	{
		return E_OUTOFMEMORY;
	}

    //
    // Decode data.
    //
    if(!CryptDecodeObject(X509_ASN_ENCODING,
                          lpszStructType,
                          pCertExtension->Value.pbData, 
                          pCertExtension->Value.cbData,
		                  0,
                          *ppStructInfo,
                          &cbStructInfo))
    {
        free(*ppStructInfo);
        return GetLastError();
    }

    return S_OK;
}

//-------------------------------------------------------------------------
//  IsCACert
//-------------------------------------------------------------------------
             
BOOL IsCACert(IN PCCERT_CONTEXT pCertContext)
{
    BOOL bResult = FALSE;
    PCERT_BASIC_CONSTRAINTS2_INFO pInfo = NULL;
    PCERT_EXTENSION pBasicConstraints   = NULL;
    
    if (pCertContext)
    {
        //
        // Find the basic constraints extension.
        //
        if (pBasicConstraints = CertFindExtension(szOID_BASIC_CONSTRAINTS2,
                                                  pCertContext->pCertInfo->cExtension,
                                                  pCertContext->pCertInfo->rgExtension))
        {
            //
            // Decode the basic constraints extension.
            //
            if (S_OK == DecodeGenericBlob(pBasicConstraints, 
                                          X509_BASIC_CONSTRAINTS2,
                                          (void **) &pInfo))
            {
                bResult = pInfo->fCA;
                free(pInfo);
            }
        }
        else
        {
            //
            // Extension not found. So, for maximum backward compatibility, we assume CA
            // for V1 cert, and end user for > V1 cert.
            //
            bResult = CERT_V1 == pCertContext->pCertInfo->dwVersion;
        }
    }

    return bResult;
}

//-------------------------------------------------------------------------
// Based on the expected content type, get the file filter
//-------------------------------------------------------------------------
BOOL    FileExist(LPWSTR    pwszFileName)
{
    HANDLE	hFile=NULL;

    if(NULL == pwszFileName)
        return FALSE;

    if ((hFile = ExpandAndCreateFileU(pwszFileName,
                           GENERIC_READ,
                           FILE_SHARE_READ,
                           NULL,                   // lpsa
                           OPEN_EXISTING,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL)) == INVALID_HANDLE_VALUE)
        return FALSE;
    
    CloseHandle(hFile);

    return TRUE;
}


//-------------------------------------------------------------------------
// Based on the expected content type, get the file filter
//-------------------------------------------------------------------------
UINT    GetFileFilerIDS(DWORD   dwFlags)
{
    BOOL    fCert=FALSE;
    BOOL    fCRL=FALSE;
    BOOL    fCTL=FALSE;

    if(CRYPTUI_WIZ_IMPORT_ALLOW_CERT & dwFlags)
        fCert=TRUE;

    if(CRYPTUI_WIZ_IMPORT_ALLOW_CRL & dwFlags)
        fCRL=TRUE;

    if(CRYPTUI_WIZ_IMPORT_ALLOW_CTL & dwFlags)
        fCTL=TRUE;

    if(fCert && fCRL & fCTL)
        return IDS_IMPORT_FILE_FILTER;

    if(fCert && fCRL)
        return IDS_IMPORT_CER_CRL_FILTER;

    if(fCert && fCTL)
        return IDS_IMPORT_CER_CTL_FILTER;

    if(fCRL && fCTL)
        return IDS_IMPORT_CTL_CRL_FILTER;

    if(fCert)
        return IDS_IMPORT_CER_FILTER;

    if(fCRL)
        return IDS_IMPORT_CRL_FILTER;

    if(fCTL)
        return IDS_IMPORT_CTL_FILTER;

    return  IDS_IMPORT_FILE_FILTER;
}

//-------------------------------------------------------------------------
// Check for the content of the store
//-------------------------------------------------------------------------
BOOL    CheckForContent(HCERTSTORE  hSrcStore,  DWORD   dwFlags, BOOL   fFromWizard, UINT   *pIDS)
{
    BOOL            fResult=FALSE;
    UINT            ids=IDS_INVALID_WIZARD_INPUT;
    DWORD           dwExpectedContent=0;
    DWORD           dwActualContent=0;
    PCCERT_CONTEXT  pCertContext=NULL;
    PCCTL_CONTEXT   pCTLContext=NULL;
    PCCRL_CONTEXT   pCRLContext=NULL;
    DWORD           dwCRLFlag=0;


    if(!pIDS)
        return FALSE;

    if(!hSrcStore)
    {
       ids=IDS_INVALID_WIZARD_INPUT;
       goto CLEANUP;

    }

    //get the expected content
    if(dwFlags & CRYPTUI_WIZ_IMPORT_ALLOW_CERT)
        dwExpectedContent |= IMPORT_CONTENT_CERT;

    if(dwFlags & CRYPTUI_WIZ_IMPORT_ALLOW_CRL)
        dwExpectedContent |= IMPORT_CONTENT_CRL;

    if(dwFlags & CRYPTUI_WIZ_IMPORT_ALLOW_CTL)
        dwExpectedContent |= IMPORT_CONTENT_CTL;


    //get the actual content
    if(pCertContext=CertEnumCertificatesInStore(hSrcStore, NULL))
        dwActualContent |= IMPORT_CONTENT_CERT;


    if(pCTLContext=CertEnumCTLsInStore(hSrcStore, NULL))
        dwActualContent |= IMPORT_CONTENT_CTL;

    if(pCRLContext=CertGetCRLFromStore(hSrcStore,
											NULL,
											NULL,
											&dwCRLFlag))
        dwActualContent |= IMPORT_CONTENT_CRL;


    //the actual content should be a subset of expected content
    if(dwActualContent !=(dwExpectedContent & dwActualContent))
    {
        ids=IDS_IMPORT_OBJECT_NOT_EXPECTED;
        goto CLEANUP;
    }

    //make sure the actual content is not empty
    if(0 == dwActualContent)
    {
        if(fFromWizard)
            ids=IDS_IMPORT_OBJECT_EMPTY;
        else
            ids=IDS_IMPORT_PFX_EMPTY;

        goto CLEANUP;
    }

    fResult=TRUE;

CLEANUP:


    if(pCertContext)
		CertFreeCertificateContext(pCertContext);

	if(pCTLContext)
		CertFreeCTLContext(pCTLContext);

	if(pCRLContext)
		CertFreeCRLContext(pCRLContext);


    if(pIDS)
        *pIDS=ids;

    return fResult;
}


//-------------------------------------------------------------------------
//Get the store name(s) based on the store handle
//-------------------------------------------------------------------------
BOOL    GetStoreName(HCERTSTORE hCertStore,
                     LPWSTR     *ppwszStoreName)
{
    DWORD   dwSize=0;

    //init
    *ppwszStoreName=NULL;

    if(NULL==hCertStore)
        return FALSE;

    if(!CertGetStoreProperty(
            hCertStore,
            CERT_STORE_LOCALIZED_NAME_PROP_ID,
            NULL,
            &dwSize) || (0==dwSize))
        return FALSE;

    *ppwszStoreName=(LPWSTR)WizardAlloc(dwSize);

    if(NULL==*ppwszStoreName)
        return FALSE;

    **ppwszStoreName=L'\0';

    if(CertGetStoreProperty(
             hCertStore,
            CERT_STORE_LOCALIZED_NAME_PROP_ID,
            *ppwszStoreName,
            &dwSize))
        return TRUE;

    WizardFree(*ppwszStoreName);

    *ppwszStoreName=NULL;

    return FALSE;
}

//-------------------------------------------------------------------------
//Get the store name(s) for the store selected by the wizard
//-------------------------------------------------------------------------

/*BOOL    GetDefaultStoreName(CERT_IMPORT_INFO    *pCertImportInfo,
                            HCERTSTORE          hSrcStore,
                            LPWSTR              *ppwszStoreName,
                            UINT                *pidsStatus)
{

    HCERTSTORE      hMyStore=NULL;
    HCERTSTORE      hCAStore=NULL;
    HCERTSTORE      hTrustStore=NULL;
    HCERTSTORE      hRootStore=NULL;

	PCCERT_CONTEXT	pCertContext=NULL;
    PCCERT_CONTEXT  pCertPre=NULL;

	PCCRL_CONTEXT	pCRLContext=NULL;

	PCCTL_CONTEXT	pCTLContext=NULL;

    DWORD           dwCRLFlag=0;
    BOOL            fResult=FALSE;

    LPWSTR          pwszStoreName=NULL;
    HCERTSTORE      hCertStore=NULL;
    DWORD           dwData=0;

    DWORD           dwCertOpenStoreFlags;
    
    //init
    *ppwszStoreName=NULL;

    if(NULL==hSrcStore)
        return FALSE;

    if (pCertImportInfo->fPFX && 
        (pCertImportInfo->dwFlag & CRYPTUI_WIZ_IMPORT_TO_LOCALMACHINE))
    {
        dwCertOpenStoreFlags = CERT_SYSTEM_STORE_LOCAL_MACHINE;
    }
    else
    {
        dwCertOpenStoreFlags = CERT_SYSTEM_STORE_CURRENT_USER;
    }

    *ppwszStoreName=(LPWSTR)WizardAlloc(sizeof(WCHAR));
    **ppwszStoreName=L'\0';

    //we need to find a correct store on user's behalf
    //put the CTLs in the trust store
	 if(pCTLContext=CertEnumCTLsInStore(hSrcStore, NULL))
	 {
         //open trust store if necessary
         if(NULL==hTrustStore)
         {
            if(!(hTrustStore=CertOpenStore(CERT_STORE_PROV_SYSTEM_W,
							g_dwMsgAndCertEncodingType,
							NULL,
							dwCertOpenStoreFlags |CERT_STORE_SET_LOCALIZED_NAME_FLAG,
							L"trust")))
            {
                *pidsStatus=IDS_FAIL_OPEN_TRUST;
                goto CLEANUP;
            }

             //get the store name
             if(GetStoreName(hTrustStore, &pwszStoreName))
             {
                *ppwszStoreName=(LPWSTR)WizardRealloc(*ppwszStoreName,
                      sizeof(WCHAR)*(wcslen(*ppwszStoreName)+wcslen(pwszStoreName)+wcslen(L", ") +3));

                if(NULL==*ppwszStoreName)
                {
                    *pidsStatus=IDS_OUT_OF_MEMORY;
                    goto CLEANUP;
                }

                wcscat(*ppwszStoreName, pwszStoreName);
             }
         }

	 }

     //free memory
     if(pwszStoreName)
     {
         WizardFree(pwszStoreName);
         pwszStoreName=NULL;

     }

     //put CRL in the CA store
	 if(pCRLContext=CertGetCRLFromStore(hSrcStore,
											NULL,
											NULL,
											&dwCRLFlag))
	 {

         //open ca store if necessary
         if(NULL==hCAStore)
         {
            if(!(hCAStore=CertOpenStore(CERT_STORE_PROV_SYSTEM_W,
							g_dwMsgAndCertEncodingType,
							NULL,
							dwCertOpenStoreFlags | CERT_STORE_SET_LOCALIZED_NAME_FLAG,
							L"ca")))
            {
                *pidsStatus=IDS_FAIL_OPEN_CA;
                goto CLEANUP;
            }

             //get the store name
             if(GetStoreName(hCAStore, &pwszStoreName))
             {
                *ppwszStoreName=(LPWSTR)WizardRealloc(*ppwszStoreName,
                      sizeof(WCHAR)*(wcslen(*ppwszStoreName)+wcslen(pwszStoreName)+wcslen(L", ") +3));

                if(NULL==*ppwszStoreName)
                {
                    *pidsStatus=IDS_OUT_OF_MEMORY;
                    goto CLEANUP;
                }

                if(wcslen(*ppwszStoreName) !=0 )
                    wcscat(*ppwszStoreName, L", ");

                wcscat(*ppwszStoreName, pwszStoreName);
             }
         }
	 }

     //free memory
     if(pwszStoreName)
     {
         WizardFree(pwszStoreName);
         pwszStoreName=NULL;

     }


     //add the certificate with private key to my store; and the rest
     //to the ca store
	 while(pCertContext=CertEnumCertificatesInStore(hSrcStore, pCertPre))
	 {
        //break if we have opened both MY and CA store and hRootStore
         if(hCAStore && hMyStore && hRootStore)
             break;

         if(TrustIsCertificateSelfSigned(pCertContext,
             pCertContext->dwCertEncodingType,
             0))
         {
             //open the root store if necessary
             if(NULL==hRootStore)
             {
                if(!(hRootStore=CertOpenStore(CERT_STORE_PROV_SYSTEM_W,
							    g_dwMsgAndCertEncodingType,
							    NULL,
							    dwCertOpenStoreFlags | CERT_STORE_SET_LOCALIZED_NAME_FLAG,
							    L"root")) )
                {
                    *pidsStatus=IDS_FAIL_OPEN_ROOT;
                    goto CLEANUP;
                }

                hCertStore=hRootStore;
             }
             else
             {
                pCertPre=pCertContext;

                 continue;
             }

         }
         else
         {
            //check if the certificate has the property on it
            //make sure the private key matches the certificate
            //search for both machine key and user keys
            if(CertGetCertificateContextProperty(
                    pCertContext,
                    CERT_KEY_PROV_INFO_PROP_ID,
                    NULL,
                    &dwData) &&
               CryptFindCertificateKeyProvInfo(
                    pCertContext,
                    0,
                    NULL))
            {
                 //open my store if necessary
                 if(NULL==hMyStore)
                 {
                    if(!(hMyStore=CertOpenStore(CERT_STORE_PROV_SYSTEM_W,
							        g_dwMsgAndCertEncodingType,
							        NULL,
							        dwCertOpenStoreFlags |CERT_STORE_SET_LOCALIZED_NAME_FLAG,
							        L"my")))
                    {
                        *pidsStatus=IDS_FAIL_OPEN_MY;
                        goto CLEANUP;
                    }

                    hCertStore=hMyStore;
                 }
                 else
                 {
                    pCertPre=pCertContext;

                     continue;
                 }
            }
            else
            {
                 //open ca store if necessary
                 if(NULL==hCAStore)
                 {
                    if(!(hCAStore=CertOpenStore(CERT_STORE_PROV_SYSTEM_W,
							        g_dwMsgAndCertEncodingType,
							        NULL,
							        dwCertOpenStoreFlags |CERT_STORE_SET_LOCALIZED_NAME_FLAG,
							        L"ca")) )
                    {
                        *pidsStatus=IDS_FAIL_OPEN_CA;
                        goto CLEANUP;
                    }

                    hCertStore=hCAStore;
                 }
                 else
                 {
                    pCertPre=pCertContext;

                     continue;
                 }
            }
         }

          //get the store name
         if(GetStoreName(hCertStore, &pwszStoreName))
         {
            *ppwszStoreName=(LPWSTR)WizardRealloc(*ppwszStoreName,
                  sizeof(WCHAR)*(wcslen(*ppwszStoreName)+wcslen(pwszStoreName)+wcslen(L", ") +1));

            if(NULL==*ppwszStoreName)
            {
                *pidsStatus=IDS_OUT_OF_MEMORY;
                goto CLEANUP;
            }
            if(wcslen(*ppwszStoreName) !=0 )
                wcscat(*ppwszStoreName, L", ");

            wcscat(*ppwszStoreName, pwszStoreName);
         }

         pCertPre=pCertContext;
	 }

     fResult=TRUE;

CLEANUP:

	if(pCertContext)
		CertFreeCertificateContext(pCertContext);

	if(pCTLContext)
		CertFreeCTLContext(pCTLContext);

	if(pCRLContext)
		CertFreeCRLContext(pCRLContext);

    if(hMyStore)
        CertCloseStore(hMyStore, 0);

    if(hCAStore)
        CertCloseStore(hCAStore, 0);

    if(hTrustStore)
        CertCloseStore(hTrustStore, 0);

    if(hRootStore)
        CertCloseStore(hRootStore, 0);

     //free memory
     if(pwszStoreName)
     {
         WizardFree(pwszStoreName);
         pwszStoreName=NULL;

     }
    return fResult;

}
*/


//-------------------------------------------------------------------------
//Get the store name and insert it to the ListView
//-------------------------------------------------------------------------
void    SetImportStoreName(HWND           hwndControl,
                     HCERTSTORE     hCertStore)
{

    LPWSTR          pwszStoreName=NULL;
    DWORD           dwSize=0;
//    LV_ITEMW        lvItem;
//   LV_COLUMNW      lvC;


     if(!CertGetStoreProperty(
            hCertStore,
            CERT_STORE_LOCALIZED_NAME_PROP_ID,
            NULL,
            &dwSize) || (0==dwSize))
    {

        //Get the  <Unknown> string
        pwszStoreName=(LPWSTR)WizardAlloc(MAX_TITLE_LENGTH * sizeof(WCHAR));

        if(pwszStoreName)
        {
            *pwszStoreName=L'\0';

            LoadStringU(g_hmodThisDll, IDS_UNKNOWN, pwszStoreName, MAX_TITLE_LENGTH);
        }
    }
    else
    {
        pwszStoreName=(LPWSTR)WizardAlloc(dwSize);

        if(pwszStoreName)
        {
            *pwszStoreName=L'\0';

            CertGetStoreProperty(
                 hCertStore,
                CERT_STORE_LOCALIZED_NAME_PROP_ID,
                pwszStoreName,
                &dwSize);
        }
    }

    if(pwszStoreName)
        SetWindowTextU(hwndControl,pwszStoreName);

    if(pwszStoreName)
        WizardFree(pwszStoreName);


    //clear the ListView
    /*ListView_DeleteAllItems(hwndControl);


    //insert one column to the store name ListView
    //set the store name
    //only one column is needed
    memset(&lvC, 0, sizeof(LV_COLUMNW));

    lvC.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
    lvC.fmt = LVCFMT_LEFT;  // Left-align the column.
    lvC.cx = 20;          // Width of the column, in pixels.
    lvC.pszText = L"";   // The text for the column.
    lvC.iSubItem=0;

    if (ListView_InsertColumnU(hwndControl, 0, &lvC) == -1)
    {
        if(pwszStoreName)
            WizardFree(pwszStoreName);

        return;
    }

    //insert the store name
    memset(&lvItem, 0, sizeof(LV_ITEMW));

    // set up the fields in the list view item struct that don't change from item to item
    lvItem.mask = LVIF_TEXT | LVIF_STATE ;
    lvItem.state = 0;
    lvItem.stateMask = 0;
    lvItem.iItem=0;
    lvItem.iSubItem=0;
    lvItem.pszText=pwszStoreName;


    ListView_InsertItemU(hwndControl, &lvItem);

    //autosize the column
    ListView_SetColumnWidth(hwndControl, 0, LVSCW_AUTOSIZE);    */

}

//-------------------------------------------------------------------------
// Check to see if this is an EFS only cert.
//-------------------------------------------------------------------------
BOOL IsEFSOnly(PCCERT_CONTEXT pCertContext)
{
    BOOL               fResult = FALSE;
    PCERT_ENHKEY_USAGE pEKU    = NULL;
    DWORD              cbEKU   = 0;
    DWORD              dwError = 0;

    if (!pCertContext)
    {
        dwError = ERROR_INVALID_PARAMETER;
        goto CLEANUP;
    }

    if (!CertGetEnhancedKeyUsage(pCertContext,
                                 CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG,
                                 NULL,
                                 &cbEKU))
    {
        dwError = GetLastError();
        goto CLEANUP;
    }

    if (!(pEKU = (PCERT_ENHKEY_USAGE) malloc(cbEKU)))
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto CLEANUP;
    }

    if (!CertGetEnhancedKeyUsage(pCertContext,
                                 CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG,
                                 pEKU,
                                 &cbEKU))
    {
        dwError = GetLastError();
        goto CLEANUP;
    }

    if ((1 == pEKU->cUsageIdentifier) && 
        (0 == strcmp(pEKU->rgpszUsageIdentifier[0], szOID_KP_EFS)))
    {
        fResult = TRUE;
    }

CLEANUP:

    if (pEKU)
    {
        free(pEKU);
    }

    SetLastError(dwError);
    return fResult;

}

#if (0) //DSIE: dead code.
//-------------------------------------------------------------------------
//Search for the duplicated elements in the destination store
//-------------------------------------------------------------------------
BOOL    ExistInDes(HCERTSTORE   hSrcStore,
                   HCERTSTORE   hDesStore)
{

	BOOL			fResult=FALSE;
	DWORD			dwCRLFlag=0;

	PCCERT_CONTEXT	pCertContext=NULL;
	PCCERT_CONTEXT	pCertPre=NULL;
	PCCERT_CONTEXT	pFindCert=NULL;

	PCCRL_CONTEXT	pCRLContext=NULL;
	PCCRL_CONTEXT	pCRLPre=NULL;
	PCCRL_CONTEXT	pFindCRL=NULL;


	PCCTL_CONTEXT	pCTLContext=NULL;
	PCCTL_CONTEXT	pCTLPre=NULL;
	PCCTL_CONTEXT	pFindCTL=NULL;

	//add the certs
	 while(pCertContext=CertEnumCertificatesInStore(hSrcStore, pCertPre))
	 {

        if((pFindCert=CertFindCertificateInStore(hDesStore,
                X509_ASN_ENCODING,
                0,
                CERT_FIND_EXISTING,
                pCertContext,
                NULL)))
        {
            fResult=TRUE;
			goto CLEANUP;
        }

		pCertPre=pCertContext;
	 }

	//add the CTLs
	 while(pCTLContext=CertEnumCTLsInStore(hSrcStore, pCTLPre))
	 {

        if((pFindCTL=CertFindCTLInStore(hDesStore,
                g_dwMsgAndCertEncodingType,
                0,
                CTL_FIND_EXISTING,
                pCTLContext,
                NULL)))
        {
            fResult=TRUE;
			goto CLEANUP;
        }

		pCTLPre=pCTLContext;
	 }

	//add the CRLs
	 while(pCRLContext=CertGetCRLFromStore(hSrcStore,
											NULL,
											pCRLPre,
											&dwCRLFlag))
	 {

        if((pFindCRL=CertFindCRLInStore(hDesStore,
                X509_ASN_ENCODING,
                0,
                CRL_FIND_EXISTING,
                pCRLContext,
                NULL)))
        {
            fResult=TRUE;
			goto CLEANUP;
        }

		pCRLPre=pCRLContext;
	 }

     //we can not find a match

CLEANUP:

	if(pCertContext)
		CertFreeCertificateContext(pCertContext);

	if(pFindCert)
		CertFreeCertificateContext(pFindCert);

	if(pCTLContext)
		CertFreeCTLContext(pCTLContext);

	if(pFindCTL)
		CertFreeCTLContext(pFindCTL);

	if(pCRLContext)
		CertFreeCRLContext(pCRLContext);

	if(pFindCRL)
		CertFreeCRLContext(pFindCRL);

	return fResult;

}
#endif

//-------------------------------------------------------------------------
//populate the list box in the order of FileName, FileType, and Store information
//-------------------------------------------------------------------------
void    DisplayImportConfirmation(HWND                hwndControl,
                                CERT_IMPORT_INFO     *pCertImportInfo)
{
    DWORD           dwIndex=0;
    DWORD           dwSize=0;
    UINT            ids=0;


    LPWSTR          pwszStoreName=NULL;
    WCHAR           wszFileType[MAX_STRING_SIZE];
    WCHAR           wszSelectedByWizard[MAX_STRING_SIZE];


    LV_ITEMW         lvItem;
    BOOL             fNewItem=FALSE;


    //delete all the old items in the listView
    ListView_DeleteAllItems(hwndControl);

    //get the ids of the format type
    switch(pCertImportInfo->dwContentType)
    {
        case    CERT_QUERY_CONTENT_CERT:
                ids=IDS_ENCODE_CERT;
            break;
        case    CERT_QUERY_CONTENT_CTL:
                 ids=IDS_ENCODE_CTL;
            break;
        case    CERT_QUERY_CONTENT_CRL:
                 ids=IDS_ENCODE_CRL;
            break;
        case    CERT_QUERY_CONTENT_SERIALIZED_STORE:
                 ids=IDS_SERIALIZED_STORE;
            break;
        case    CERT_QUERY_CONTENT_SERIALIZED_CERT:
                  ids=IDS_SERIALIZED_CERT;
            break;
        case    CERT_QUERY_CONTENT_SERIALIZED_CTL:
                  ids=IDS_SERIALIZED_CTL;
            break;
        case    CERT_QUERY_CONTENT_SERIALIZED_CRL:
                 ids=IDS_SERIALIZED_CRL;
            break;
        case    CERT_QUERY_CONTENT_PKCS7_SIGNED :
                  ids=IDS_PKCS7_SIGNED;
            break;
       case    CERT_QUERY_CONTENT_PFX:
                 ids=IDS_PFX_BLOB;
            break;
        default:
//        case    CERT_QUERY_CONTENT_PKCS7_UNSIGNED
//        case    CERT_QUERY_CONTENT_PKCS7_SIGNED_EMBED
//        case    CERT_QUERY_CONTENT_PKCS10
                ids=IDS_NONE;
            break;
    }

    //get the format type
    LoadStringU(g_hmodThisDll, ids, wszFileType, MAX_STRING_SIZE);

    //get the store name
    if(pCertImportInfo->hDesStore)
    {
        if(!CertGetStoreProperty(
                pCertImportInfo->hDesStore,
                CERT_STORE_LOCALIZED_NAME_PROP_ID,
                NULL,
                &dwSize) || (0==dwSize))
        {

            //Get the  <Unknown> string
            pwszStoreName=(LPWSTR)WizardAlloc(MAX_TITLE_LENGTH);

            if(pwszStoreName)
            {
                *pwszStoreName=L'\0';

                LoadStringU(g_hmodThisDll, IDS_UNKNOWN, pwszStoreName, MAX_TITLE_LENGTH);
            }
        }
        else
        {
            pwszStoreName=(LPWSTR)WizardAlloc(dwSize);

            if(pwszStoreName)
            {
                *pwszStoreName=L'\0';

                CertGetStoreProperty(
                    pCertImportInfo->hDesStore,
                    CERT_STORE_LOCALIZED_NAME_PROP_ID,
                    pwszStoreName,
                    &dwSize);
            }
        }
    }



    //insert row by row
    memset(&lvItem, 0, sizeof(LV_ITEMW));

    // set up the fields in the list view item struct that don't change from item to item
    lvItem.mask = LVIF_TEXT | LVIF_STATE ;
    lvItem.state = 0;
    lvItem.stateMask = 0;
    lvItem.iItem=0;
    lvItem.iSubItem=0;

    //file name
    if(pCertImportInfo->pwszFileName)
    {
        lvItem.iItem=lvItem.iItem ? lvItem.iItem++ : 0;
        lvItem.iSubItem=0;

        ListView_InsertItemU_IDS(hwndControl, &lvItem, IDS_FILE_NAME, NULL);

        //content
        lvItem.iSubItem++;

        ListView_SetItemTextU(hwndControl, lvItem.iItem, lvItem.iSubItem,
            pCertImportInfo->pwszFileName);
    }

    //file type
    if(wszFileType)
    {
        lvItem.iItem=lvItem.iItem ? lvItem.iItem++ : 0;
        lvItem.iSubItem=0;

        ListView_InsertItemU_IDS(hwndControl, &lvItem, IDS_CONTENT_TYPE, NULL);

        //content
        lvItem.iSubItem++;

        ListView_SetItemTextU(hwndControl, lvItem.iItem, lvItem.iSubItem,
            wszFileType);
    }


     //StoreName
    lvItem.iItem=lvItem.iItem ? lvItem.iItem++ : 0;
    lvItem.iSubItem=0;

    if(NULL==pCertImportInfo->hDesStore || (FALSE==pCertImportInfo->fSelectedDesStore))
    {
        ListView_InsertItemU_IDS(hwndControl, &lvItem, IDS_STORE_BY_WIZARD, NULL);

   /*     if(pCertImportInfo->pwszDefaultStoreName)
        {
            lvItem.iSubItem++;

            ListView_SetItemTextU(hwndControl, lvItem.iItem, lvItem.iSubItem,
                pCertImportInfo->pwszDefaultStoreName);
        }
        else */

        //get the format type
        if(LoadStringU(g_hmodThisDll, IDS_SELECTED_BY_WIZARD, wszSelectedByWizard, MAX_STRING_SIZE))
        {

            lvItem.iSubItem++;

            ListView_SetItemTextU(hwndControl, lvItem.iItem, lvItem.iSubItem,
                wszSelectedByWizard);
        }

    }
    else
    {
        ListView_InsertItemU_IDS(hwndControl, &lvItem, IDS_STORE_BY_USER, NULL);

        //content
        if(pwszStoreName)
        {
            lvItem.iSubItem++;

            ListView_SetItemTextU(hwndControl, lvItem.iItem, lvItem.iSubItem,
                pwszStoreName);
        }
    }

    //auto size the columns in the ListView
    ListView_SetColumnWidth(hwndControl, 0, LVSCW_AUTOSIZE);
    ListView_SetColumnWidth(hwndControl, 1, LVSCW_AUTOSIZE);

    if(pwszStoreName)
        WizardFree(pwszStoreName);

    return;
}


//*************************************************************************
//
//   The winproc for import wizards
//************************************************************************
//-----------------------------------------------------------------------
//Import_Welcome
//-----------------------------------------------------------------------
INT_PTR APIENTRY Import_Welcome(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CERT_IMPORT_INFO        *pCertImportInfo=NULL;
    PROPSHEETPAGE           *pPropSheet=NULL;


	switch (msg)
	{
		case WM_INITDIALOG:
            //set the wizard information so that it can be shared
            pPropSheet = (PROPSHEETPAGE *) lParam;
            pCertImportInfo = (CERT_IMPORT_INFO *) (pPropSheet->lParam);
            //make sure pCertImportInfo is a valid pointer
            if(NULL==pCertImportInfo)
               break;
            SetWindowLongPtr(hwndDlg, DWLP_USER, (LONG_PTR)pCertImportInfo);

            SetControlFont(pCertImportInfo->hBigBold, hwndDlg,IDC_WIZARD_STATIC_BIG_BOLD1);
            SetControlFont(pCertImportInfo->hBold, hwndDlg,IDC_WIZARD_STATIC_BOLD1);
            SetControlFont(pCertImportInfo->hBold, hwndDlg,IDC_WIZARD_STATIC_BOLD2);

			break;

		case WM_NOTIFY:
    		    switch (((NMHDR FAR *) lParam)->code)
    		    {

  				    case PSN_KILLACTIVE:
                            SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
					        return TRUE;

                        break;

				    case PSN_RESET:
                            SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
					    break;

 				    case PSN_SETACTIVE:
 					    PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_NEXT);
					    break;

                    case PSN_WIZBACK:
                        break;

                    case PSN_WIZNEXT:

                        break;

				    default:
					    return FALSE;

    	        }
		    break;

		default:
			return FALSE;
	}

	return TRUE;
}

//-----------------------------------------------------------------------
// Import_File
//-----------------------------------------------------------------------
INT_PTR APIENTRY Import_File(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CERT_IMPORT_INFO        *pCertImportInfo=NULL;
    PROPSHEETPAGE           *pPropSheet=NULL;
    OPENFILENAMEW           OpenFileName;
    WCHAR                   szFileName[_MAX_PATH];
    HWND                    hwndControl=NULL;
    DWORD                   dwChar=0;
    LPWSTR                  pwszInitialDir = NULL;

    WCHAR                   szFilter[MAX_STRING_SIZE + MAX_STRING_SIZE];  //"Certificate File (*.cer)\0*.cer\0Certificate File (*.crt)\0*.crt\0All Files\0*.*\0"
    DWORD                   dwSize=0;
    UINT                    ids=0;

	switch (msg)
	{
		case WM_INITDIALOG:
            //set the wizard information so that it can be shared
            pPropSheet = (PROPSHEETPAGE *) lParam;
            pCertImportInfo = (CERT_IMPORT_INFO *) (pPropSheet->lParam);
            //make sure pCertImportInfo is a valid pointer
            if(NULL==pCertImportInfo)
               break;
            SetWindowLongPtr(hwndDlg, DWLP_USER, (LONG_PTR)pCertImportInfo);


            SetControlFont(pCertImportInfo->hBold, hwndDlg,IDC_WIZARD_STATIC_BOLD1);

            //set up the file name if pre-selected
            SetDlgItemTextU(hwndDlg, IDC_WIZARD_EDIT1, pCertImportInfo->pwszFileName);

			break;

		case WM_COMMAND:
                if(HIWORD(wParam) == BN_CLICKED)
                {
                    if(LOWORD(wParam) == IDC_WIZARD_BUTTON1)
                    {

                        if(NULL==(pCertImportInfo=(CERT_IMPORT_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                            break;

                        //the browse button is clicked.  Open the FileOpen dialogue
                        memset(&OpenFileName, 0, sizeof(OpenFileName));

                        *szFileName=L'\0';

                        OpenFileName.lStructSize=sizeof(OpenFileName);
                        OpenFileName.hwndOwner=hwndDlg;
                        OpenFileName.nFilterIndex = 1;

                        //get the file filer ID
                        ids=GetFileFilerIDS(pCertImportInfo->dwFlag);

                        //load the filter string
                        if(LoadFilterString(g_hmodThisDll, ids, szFilter, MAX_STRING_SIZE + MAX_STRING_SIZE))
                        {
                            OpenFileName.lpstrFilter = szFilter;
                        }

                        dwChar = (DWORD)SendDlgItemMessage(hwndDlg, IDC_WIZARD_EDIT1, WM_GETTEXTLENGTH, 0, 0);
                        if (NULL != (pwszInitialDir = (LPWSTR) WizardAlloc((dwChar+1)*sizeof(WCHAR))))
                        {
                            GetDlgItemTextU(hwndDlg, IDC_WIZARD_EDIT1, pwszInitialDir, dwChar+1);
                        }
                        OpenFileName.lpstrInitialDir = pwszInitialDir;

                        OpenFileName.lpstrFile=szFileName;
                        OpenFileName.nMaxFile=_MAX_PATH;
                        OpenFileName.Flags = OFN_HIDEREADONLY | OFN_FILEMUSTEXIST;

                        //user has selected a file name
                        if(WizGetOpenFileName(&OpenFileName))
                        {
                           //set the edit box
                            SetDlgItemTextU(hwndDlg, IDC_WIZARD_EDIT1, szFileName);
                        }

                        if(pwszInitialDir != NULL)
                        {
                            WizardFree(pwszInitialDir);
                            pwszInitialDir = NULL;
                        }   

                    }
                }

			break;	
						
		case WM_NOTIFY:
    		    switch (((NMHDR FAR *) lParam)->code)
    		    {

  				    case PSN_KILLACTIVE:
                            SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
					        return TRUE;

                        break;

				    case PSN_RESET:
                            SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
					    break;

 				    case PSN_SETACTIVE:
 					    PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_NEXT|PSWIZB_BACK);
					    break;

                    case PSN_WIZBACK:
                        break;

                    case PSN_WIZNEXT:
                            if(NULL==(pCertImportInfo=(CERT_IMPORT_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                                break;

                            //make sure a file is selected
                            if(0==(dwChar=(DWORD)SendDlgItemMessage(hwndDlg,
                                                   IDC_WIZARD_EDIT1,
                                                   WM_GETTEXTLENGTH, 0, 0)))
                            {
                                I_MessageBox(hwndDlg, IDS_HAS_TO_SELECT_FILE,
                                        IDS_IMPORT_WIZARD_TITLE,
                                        NULL,
                                        MB_ICONERROR|MB_OK|MB_APPLMODAL);

                                 //make the file page stay
                                SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);

                                 break;
                            }

                            //get the file name
                            if(pCertImportInfo->pwszFileName)
                            {
                                //delete the old file name
                                if(TRUE==pCertImportInfo->fFreeFileName)
                                {
                                    WizardFree(pCertImportInfo->pwszFileName);
                                    pCertImportInfo->pwszFileName=NULL;
                                }
                            }

                            pCertImportInfo->pwszFileName=(LPWSTR)WizardAlloc((dwChar+1)*sizeof(WCHAR));

                            if(NULL!=(pCertImportInfo->pwszFileName))
                            {
                                GetDlgItemTextU(hwndDlg, IDC_WIZARD_EDIT1,
                                                pCertImportInfo->pwszFileName,
                                                dwChar+1);

                                pCertImportInfo->fFreeFileName=TRUE;

                                //make sure the file is valid
                                //delete the old store
                                if(pCertImportInfo->hSrcStore && (TRUE==pCertImportInfo->fFreeSrcStore))
                                {
                                    CertCloseStore(pCertImportInfo->hSrcStore, 0);
                                    pCertImportInfo->hSrcStore=NULL;
                                }

                                //we import anything but PKCS10 or signed document
                                if(!ExpandAndCryptQueryObject(
                                        CERT_QUERY_OBJECT_FILE,
                                        pCertImportInfo->pwszFileName,
                                        dwExpectedContentType,
                                        CERT_QUERY_FORMAT_FLAG_ALL,
                                        0,
                                        NULL,
                                        &(pCertImportInfo->dwContentType),
                                        NULL,
                                        &(pCertImportInfo->hSrcStore),
                                        NULL,
                                        NULL))
                                {
                                    if(FileExist(pCertImportInfo->pwszFileName))
                                        I_MessageBox(hwndDlg, IDS_FAIL_TO_RECOGNIZE_ENTER,
                                                IDS_IMPORT_WIZARD_TITLE,
                                                NULL,
                                                MB_ICONERROR|MB_OK|MB_APPLMODAL);
                                    else
                                        I_MessageBox(hwndDlg, IDS_NON_EXIST_FILE,
                                                IDS_IMPORT_WIZARD_TITLE,
                                                NULL,
                                                MB_ICONERROR|MB_OK|MB_APPLMODAL);

                                     //make the file page stay
                                    SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);

                                     break;

                                }

                                //we re-mark the pPFX
                                pCertImportInfo->fPFX=FALSE;

                                //get the blobs from the pfx file
                                if(CERT_QUERY_CONTENT_PFX==pCertImportInfo->dwContentType)
                                {
									//we can not import PFX Files for remote case
									if(pCertImportInfo->dwFlag & CRYPTUI_WIZ_IMPORT_REMOTE_DEST_STORE)
									{
                                        //output the message
                                        I_MessageBox(hwndDlg, IDS_IMPORT_NO_PFX_FOR_REMOTE,
                                                IDS_IMPORT_WIZARD_TITLE,
                                                NULL,
                                                MB_ICONERROR|MB_OK|MB_APPLMODAL);

                                         //make the file page stay
                                        SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);

                                        break;
									}

                                    if((pCertImportInfo->blobData).pbData)
                                    {
                                        UnmapViewOfFile((pCertImportInfo->blobData).pbData);
                                        (pCertImportInfo->blobData).pbData=NULL;
                                    }

                                    if(S_OK !=RetrieveBLOBFromFile(
                                            pCertImportInfo->pwszFileName,
                                            &((pCertImportInfo->blobData).cbData),
                                            &((pCertImportInfo->blobData).pbData)))
                                    {
                                        //output the message
                                        I_MessageBox(hwndDlg, IDS_FAIL_READ_FILE_ENTER,
                                                IDS_IMPORT_WIZARD_TITLE,
                                                NULL,
                                                MB_ICONERROR|MB_OK|MB_APPLMODAL);

                                         //make the file page stay
                                        SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);

                                        break;
                                    }

                                    //make sure that the soure store's content match with
                                    //the expectation
                                    if(0==((pCertImportInfo->dwFlag) & CRYPTUI_WIZ_IMPORT_ALLOW_CERT))
                                    {
                                        //output the message
                                        I_MessageBox(hwndDlg,
                                                IDS_IMPORT_OBJECT_NOT_EXPECTED,
                                                IDS_IMPORT_WIZARD_TITLE,
                                                NULL,
                                                MB_ICONERROR|MB_OK|MB_APPLMODAL);

                                         //make the file page stay
                                        SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);

                                        break;
                                    }

                                }
                                else
                                {
									//if the content is PKCS7, get the BLOB
									 if(CERT_QUERY_CONTENT_PKCS7_SIGNED==pCertImportInfo->dwContentType)
									 {
										if((pCertImportInfo->blobData).pbData)
										{
											UnmapViewOfFile((pCertImportInfo->blobData).pbData);
											(pCertImportInfo->blobData).pbData=NULL;
										}

										if(S_OK !=RetrieveBLOBFromFile(
												pCertImportInfo->pwszFileName,
												&((pCertImportInfo->blobData).cbData),
												&((pCertImportInfo->blobData).pbData)))
										{
											//output the message
											I_MessageBox(hwndDlg, IDS_FAIL_READ_FILE_ENTER,
													IDS_IMPORT_WIZARD_TITLE,
													NULL,
													MB_ICONERROR|MB_OK|MB_APPLMODAL);

											 //make the file page stay
											SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);

											break;
										}
									 }

                                    //make sure we do have a source store
                                    if(NULL==pCertImportInfo->hSrcStore)
                                    {
                                        //output the message
                                        I_MessageBox(hwndDlg, IDS_FAIL_TO_RECOGNIZE_ENTER,
                                                IDS_IMPORT_WIZARD_TITLE,
                                                NULL,
                                                MB_ICONERROR|MB_OK|MB_APPLMODAL);

                                         //make the file page stay
                                        SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);

                                         break;
                                    }

                                    //remember to free the Src store
                                   pCertImportInfo->fFreeSrcStore=TRUE;


                                   //make sure that the soure store's content match with
                                   //the expectation
                                    ids=0;

                                    if(!CheckForContent(pCertImportInfo->hSrcStore,
                                                        pCertImportInfo->dwFlag,
                                                        TRUE,
                                                        &ids))
                                    {
                                        //output the message
                                        I_MessageBox(hwndDlg,
                                                ids,
                                                IDS_IMPORT_WIZARD_TITLE,
                                                NULL,
                                                MB_ICONERROR|MB_OK|MB_APPLMODAL);

                                         //make the file page stay
                                        SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);

                                        break;
                                    }

                                }
                            }

                            //skip the next page if password is not necessary
                            if(CERT_QUERY_CONTENT_PFX != pCertImportInfo->dwContentType)
                                SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_IMPORT_STORE);

                        break;

				    default:
					    return FALSE;

    	        }
		    break;

		default:
			return FALSE;
	}

	return TRUE;
}


//-----------------------------------------------------------------------
// Import_Password
//-----------------------------------------------------------------------
INT_PTR APIENTRY Import_Password(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CERT_IMPORT_INFO        *pCertImportInfo=NULL;
    PROPSHEETPAGE           *pPropSheet=NULL;
    HWND                    hwndControl=NULL;
    DWORD                   dwChar;
    UINT                    ids=0;


	switch (msg)
	{
		case WM_INITDIALOG:

			HRESULT	hr; 
			HKEY	hKey;
			DWORD	cb;
			DWORD	dwKeyValue;
			DWORD	dwType;

            //set the wizard information so that it can be shared
            pPropSheet = (PROPSHEETPAGE *) lParam;
            pCertImportInfo = (CERT_IMPORT_INFO *) (pPropSheet->lParam);
            //make sure pCertImportInfo is a valid pointer
            if(NULL==pCertImportInfo)
               break;
            SetWindowLongPtr(hwndDlg, DWLP_USER, (LONG_PTR)pCertImportInfo);

            SetControlFont(pCertImportInfo->hBold, hwndDlg,IDC_WIZARD_STATIC_BOLD1);

            //init the passWord 
            SendDlgItemMessage(hwndDlg, IDC_WIZARD_EDIT1, EM_LIMITTEXT, (WPARAM) 64, (LPARAM) 0);
            SetDlgItemTextU(
                hwndDlg, 
                IDC_WIZARD_EDIT1, 
                (pCertImportInfo->pwszPassword != NULL) ? pCertImportInfo->pwszPassword : L"");

#if (1) //DSIE: Bug 333621
            SendDlgItemMessage(hwndDlg, IDC_WIZARD_EDIT1, EM_LIMITTEXT, (WPARAM) 32, (LPARAM) 0);
#endif
            //init the passWord flag
            if(pCertImportInfo->dwPasswordFlags & CRYPT_EXPORTABLE)
               SendMessage(GetDlgItem(hwndDlg, IDC_WIZARD_CHECK_EXPORTKEY), BM_SETCHECK, 1, 0);
            else 
               SendMessage(GetDlgItem(hwndDlg, IDC_WIZARD_CHECK_EXPORTKEY), BM_SETCHECK, 0, 0);

            if(pCertImportInfo->dwPasswordFlags & CRYPT_USER_PROTECTED)
               SendMessage(GetDlgItem(hwndDlg, IDC_WIZARD_CHECK2), BM_SETCHECK, 1, 0);
            else
               SendMessage(GetDlgItem(hwndDlg, IDC_WIZARD_CHECK2), BM_SETCHECK, 0, 0);

			//now, we need to grey out the user protection check box for the local
			//machine import
			if(pCertImportInfo->dwFlag & CRYPTUI_WIZ_IMPORT_TO_LOCALMACHINE)
				EnableWindow(GetDlgItem(hwndDlg, IDC_WIZARD_CHECK2), FALSE);
			else
			{
				//
				// Not Import to Local Machine
				// Open the CRYPTOAPI_PRIVATE_KEY_OPTIONS registry key under HKLM 
				//
				hKey = NULL;
				hr = RegOpenKeyEx(
					HKEY_LOCAL_MACHINE,
					szKEY_CRYPTOAPI_PRIVATE_KEY_OPTIONS,
					0,
					KEY_QUERY_VALUE,
					&hKey);
				if ( S_OK != hr )
					goto error;

				//
				// Query the registry key for FORCE_KEY_PROTECTION value 
				//
				cb = sizeof(dwKeyValue);
				hr = RegQueryValueEx(
					hKey,
					szFORCE_KEY_PROTECTION,
					NULL,
					&dwType,
					(BYTE *) &dwKeyValue,
					&cb);

				if( S_OK == hr && REG_DWORD == dwType && sizeof(dwKeyValue) == cb )
				{
				    switch( dwKeyValue )
				    {
					    case dwFORCE_KEY_PROTECTION_DISABLED:
						    // do not force key protection 
						    break;

					    case dwFORCE_KEY_PROTECTION_USER_SELECT:
						    // allow the user to select key protection UI, default = yes
						    SendMessage(GetDlgItem(hwndDlg, IDC_WIZARD_CHECK2), BM_SETCHECK, 1, 0);
						    break;

					    case dwFORCE_KEY_PROTECTION_HIGH:
						    // set to force key protection and grey out choice so that user cannot change value
						    EnableWindow(GetDlgItem(hwndDlg, IDC_WIZARD_CHECK2), FALSE);
						    SendMessage(GetDlgItem(hwndDlg, IDC_WIZARD_CHECK2), BM_SETCHECK, 1, 0);
						    break;

					    default:
						    // Unknown value in registry
						    break;
				    }
				}

			error:
				if( NULL != hKey ){
					RegCloseKey(hKey);
				}
			}

			break;

		case WM_COMMAND:
			break;	
						
		case WM_NOTIFY:
    		    switch (((NMHDR FAR *) lParam)->code)
    		    {

  				    case PSN_KILLACTIVE:
                            SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
					        return TRUE;

                        break;

				    case PSN_RESET:
                            SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
					    break;

 				    case PSN_SETACTIVE:
 					        PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_NEXT|PSWIZB_BACK);

					    break;

                    case PSN_WIZBACK:
                        break;

                    case PSN_WIZNEXT:
                            if(NULL==(pCertImportInfo=(CERT_IMPORT_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                                break;

                            //free the memory
                            if(pCertImportInfo->pwszPassword)
                            {
                                // DSIE: Bug 534689.
                                SecureZeroMemory(pCertImportInfo->pwszPassword, 
                                                 lstrlenW(pCertImportInfo->pwszPassword) * sizeof(WCHAR));
                                WizardFree(pCertImportInfo->pwszPassword);
                                pCertImportInfo->pwszPassword=NULL;
                            }

                            //get the password
                            if(0!=(dwChar=(DWORD)SendDlgItemMessage(hwndDlg,
                                                   IDC_WIZARD_EDIT1,
                                                   WM_GETTEXTLENGTH, 0, 0)))
                            {
                                pCertImportInfo->pwszPassword=(LPWSTR)WizardAlloc(sizeof(WCHAR)*(dwChar+1));

                                if(NULL!=pCertImportInfo->pwszPassword)
                                {
                                    GetDlgItemTextU(hwndDlg, IDC_WIZARD_EDIT1,
                                                    pCertImportInfo->pwszPassword,
                                                    dwChar+1);

                                }
                                else
                                    break;
                            }
                            else
                                pCertImportInfo->pwszPassword=NULL;


                            //if user request to export the private key
                            if(TRUE==SendMessage(GetDlgItem(hwndDlg, IDC_WIZARD_CHECK_EXPORTKEY), BM_GETCHECK, 0, 0))
                                    pCertImportInfo->dwPasswordFlags |=CRYPT_EXPORTABLE;
                            else
                                    pCertImportInfo->dwPasswordFlags &= (~CRYPT_EXPORTABLE);

                            if(TRUE==SendMessage(GetDlgItem(hwndDlg, IDC_WIZARD_CHECK2), BM_GETCHECK, 0, 0))
                                    pCertImportInfo->dwPasswordFlags |=CRYPT_USER_PROTECTED;
                            else
                                    pCertImportInfo->dwPasswordFlags &= (~CRYPT_USER_PROTECTED);


                            //delete the old certificate store
                            if(pCertImportInfo->hSrcStore && (TRUE==pCertImportInfo->fFreeSrcStore))
                            {
                                CertCloseStore(pCertImportInfo->hSrcStore, 0);
                                pCertImportInfo->hSrcStore=NULL;
                            }

                            //decode the PFX blob
                            if(NULL==(pCertImportInfo->blobData).pbData)
                                break;


                           //convert the PFX BLOB to a certificate store
                            pCertImportInfo->fPFX=PFXVerifyPassword(
                                (CRYPT_DATA_BLOB *)&(pCertImportInfo->blobData),
                                pCertImportInfo->pwszPassword,
                                0);

                           if((FALSE==pCertImportInfo->fPFX) && (NULL == pCertImportInfo->pwszPassword))
                           {
                                //we try to use "" for no password case
                               pCertImportInfo->pwszPassword=(LPWSTR)WizardAlloc(sizeof(WCHAR));

                               if(NULL != pCertImportInfo->pwszPassword)
                               {
                                    *(pCertImportInfo->pwszPassword)=L'\0';

                                    pCertImportInfo->fPFX=PFXVerifyPassword(
                                        (CRYPT_DATA_BLOB *)&(pCertImportInfo->blobData),
                                        pCertImportInfo->pwszPassword,
                                        0);

                                }
                           }

                            if(FALSE==pCertImportInfo->fPFX)
                            {
                                //output the message
                                I_MessageBox(hwndDlg, IDS_INVALID_PASSWORD,
                                        IDS_IMPORT_WIZARD_TITLE,
                                        NULL,
                                        MB_ICONERROR|MB_OK|MB_APPLMODAL);

                                 //make the file page stay
                                SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);

                                break;

                            }

                        break;

				    default:
					    return FALSE;

    	        }
		    break;

		default:
			return FALSE;
	}

	return TRUE;
}


//-----------------------------------------------------------------------
// Import_Store
//-----------------------------------------------------------------------
INT_PTR APIENTRY Import_Store(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CERT_IMPORT_INFO            *pCertImportInfo=NULL;
    PROPSHEETPAGE               *pPropSheet=NULL;
    HWND                        hwndControl=NULL;
    DWORD                       dwSize=0;


    CRYPTUI_SELECTSTORE_STRUCT  CertStoreSelect;
    STORENUMERATION_STRUCT      StoreEnumerationStruct;
    STORESFORSELCTION_STRUCT    StoresForSelectionStruct;
    HCERTSTORE                  hCertStore=NULL;
    HDC                         hdc=NULL;
    COLORREF                    colorRef;
    LV_COLUMNW                  lvC;

    UINT                        idsError=0;


	switch (msg)
	{
		case WM_INITDIALOG:
                //set the wizard information so that it can be shared
                pPropSheet = (PROPSHEETPAGE *) lParam;
                pCertImportInfo = (CERT_IMPORT_INFO *) (pPropSheet->lParam);
                //make sure pCertImportInfo is a valid pointer
                if(NULL==pCertImportInfo)
                   break;
                SetWindowLongPtr(hwndDlg, DWLP_USER, (LONG_PTR)pCertImportInfo);

                SetControlFont(pCertImportInfo->hBold, hwndDlg,IDC_WIZARD_STATIC_BOLD1);

                //getthe background color of the parent window
                //the background of the list view for store name is grayed
                /*
               if(hdc=GetWindowDC(hwndDlg))
               {
                    if(CLR_INVALID!=(colorRef=GetBkColor(hdc)))
                    {
                        ListView_SetBkColor(GetDlgItem(hwndDlg, IDC_WIZARD_LIST1), CLR_NONE);
                        ListView_SetTextBkColor(GetDlgItem(hwndDlg, IDC_WIZARD_LIST1), CLR_NONE);
                    }
               }     */

                //mark the store selection
                if(pCertImportInfo->hDesStore)
                {
                     //disable the 1st radio button
                    SendMessage(GetDlgItem(hwndDlg, IDC_WIZARD_RADIO1), BM_SETCHECK, 0, 0);
                     //select raio2
                    SendMessage(GetDlgItem(hwndDlg, IDC_WIZARD_RADIO2), BM_SETCHECK, 1, 0);

                    //enable the windows for select a certificate store
                    EnableWindow(GetDlgItem(hwndDlg, IDC_WIZARD_STATIC1), TRUE);
                    EnableWindow(GetDlgItem(hwndDlg, IDC_WIZARD_BUTTON1), TRUE);
                    EnableWindow(GetDlgItem(hwndDlg, IDC_WIZARD_LIST1), TRUE);

                    //mark the store name
                    hwndControl=GetDlgItem(hwndDlg, IDC_WIZARD_LIST1);

                    if(hwndControl)
                        SetImportStoreName(hwndControl, pCertImportInfo->hDesStore);

                    //diable the radio buttons if CRYPTUI_WIZ_IMPORT_NO_CHANGE_DEST
                    //is set
                    if(pCertImportInfo->dwFlag & CRYPTUI_WIZ_IMPORT_NO_CHANGE_DEST_STORE)
                    {
                        EnableWindow(GetDlgItem(hwndDlg, IDC_WIZARD_RADIO1),  FALSE);
                        EnableWindow(GetDlgItem(hwndDlg, IDC_WIZARD_BUTTON1), FALSE);
                    }

                }
                else
                {
                    //select the 1st radio button
                    SendMessage(GetDlgItem(hwndDlg, IDC_WIZARD_RADIO1), BM_SETCHECK, 1, 0);
                    SendMessage(GetDlgItem(hwndDlg, IDC_WIZARD_RADIO2), BM_SETCHECK, 0, 0);

                    //disable the windows for select a certificate store
                    EnableWindow(GetDlgItem(hwndDlg, IDC_WIZARD_STATIC1), FALSE);
                    EnableWindow(GetDlgItem(hwndDlg, IDC_WIZARD_BUTTON1), FALSE);
                    EnableWindow(GetDlgItem(hwndDlg, IDC_WIZARD_LIST1), FALSE);

                }

			break;

		case WM_COMMAND:
                if(HIWORD(wParam) == BN_CLICKED)
                {
                    switch (LOWORD(wParam))
                    {
                        case    IDC_WIZARD_RADIO1:
                                 //select the 1st radio button
                                SendMessage(GetDlgItem(hwndDlg, IDC_WIZARD_RADIO1), BM_SETCHECK, 1, 0);
                                 //disable raio2
                                SendMessage(GetDlgItem(hwndDlg, IDC_WIZARD_RADIO2), BM_SETCHECK, 0, 0);

                                //disable the windows for select a certificate store
                                EnableWindow(GetDlgItem(hwndDlg, IDC_WIZARD_STATIC1), FALSE);
                                EnableWindow(GetDlgItem(hwndDlg, IDC_WIZARD_BUTTON1), FALSE);
                                EnableWindow(GetDlgItem(hwndDlg, IDC_WIZARD_LIST1), FALSE);
                            break;
                        case    IDC_WIZARD_RADIO2:
                                 //disable the 1st radio button
                                SendMessage(GetDlgItem(hwndDlg, IDC_WIZARD_RADIO1), BM_SETCHECK, 0, 0);
                                 //select raio2
                                SendMessage(GetDlgItem(hwndDlg, IDC_WIZARD_RADIO2), BM_SETCHECK, 1, 0);

                                //enable the windows for select a certificate store
                                EnableWindow(GetDlgItem(hwndDlg, IDC_WIZARD_STATIC1), TRUE);
                                EnableWindow(GetDlgItem(hwndDlg, IDC_WIZARD_BUTTON1), TRUE);
                                EnableWindow(GetDlgItem(hwndDlg, IDC_WIZARD_LIST1), TRUE);

                                //if no change of the desination is set, we need to diable the browse
                                //button and 1st radio button
                                if(NULL!=(pCertImportInfo=(CERT_IMPORT_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                                {

                                    if(pCertImportInfo->dwFlag & CRYPTUI_WIZ_IMPORT_NO_CHANGE_DEST_STORE)
                                    {
                                        EnableWindow(GetDlgItem(hwndDlg, IDC_WIZARD_RADIO1),  FALSE);
                                        EnableWindow(GetDlgItem(hwndDlg, IDC_WIZARD_BUTTON1), FALSE);
                                    }
                                }

                            break;
                        case    IDC_WIZARD_BUTTON1:
                                if(NULL==(pCertImportInfo=(CERT_IMPORT_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                                {
                                    break;
                                }

                                //get the hwndControl for the list view
                                hwndControl=GetDlgItem(hwndDlg, IDC_WIZARD_LIST1);

                                 //call the store selection dialogue
                                memset(&CertStoreSelect, 0, sizeof(CertStoreSelect));
                                memset(&StoresForSelectionStruct, 0, sizeof(StoresForSelectionStruct));
                                memset(&StoreEnumerationStruct, 0, sizeof(StoreEnumerationStruct));

                                StoreEnumerationStruct.dwFlags=CERT_STORE_MAXIMUM_ALLOWED_FLAG;
                                StoreEnumerationStruct.pvSystemStoreLocationPara=NULL;
                                StoresForSelectionStruct.cEnumerationStructs = 1;
                                StoresForSelectionStruct.rgEnumerationStructs = &StoreEnumerationStruct;
                                
                                // if a pfx import is taking place, then make sure the correct
                                // stores are displayed for selection
                                if ((TRUE == pCertImportInfo->fPFX) && 
                                    (pCertImportInfo->dwFlag & CRYPTUI_WIZ_IMPORT_TO_LOCALMACHINE))
                                {
                                    StoreEnumerationStruct.dwFlags |= CERT_SYSTEM_STORE_LOCAL_MACHINE;      
                                }
                                else
                                {
                                    StoreEnumerationStruct.dwFlags |= CERT_SYSTEM_STORE_CURRENT_USER;      
                                }

                                CertStoreSelect.dwSize=sizeof(CertStoreSelect);
                                CertStoreSelect.hwndParent=hwndDlg;
                                CertStoreSelect.dwFlags=CRYPTUI_VALIDATE_STORES_AS_WRITABLE | CRYPTUI_ALLOW_PHYSICAL_STORE_VIEW | CRYPTUI_DISPLAY_WRITE_ONLY_STORES;
                                CertStoreSelect.pStoresForSelection = &StoresForSelectionStruct;

                                hCertStore=CryptUIDlgSelectStore(&CertStoreSelect);

                                if(hCertStore)
                                {

                                     //delete the old destination certificate store
                                    if(pCertImportInfo->hDesStore && (TRUE==pCertImportInfo->fFreeDesStore))
                                    {
                                        CertCloseStore(pCertImportInfo->hDesStore, 0);
                                        pCertImportInfo->hDesStore=NULL;
                                    }

                                    pCertImportInfo->hDesStore=hCertStore;
                                    pCertImportInfo->fFreeDesStore=TRUE;

                                    //get the store name
                                    if(hwndControl)
                                         SetImportStoreName(hwndControl, pCertImportInfo->hDesStore);
                                }

                            break;
                        default:

                           break;
                    }
                }
			break;	
						
		case WM_NOTIFY:
    		    switch (((NMHDR FAR *) lParam)->code)
    		    {

  				    case PSN_KILLACTIVE:
                            SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
					        return TRUE;

                        break;

				    case PSN_RESET:
                            SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
					    break;

 				    case PSN_SETACTIVE:
 					        PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_NEXT|PSWIZB_BACK);


					    break;

                    case PSN_WIZBACK:
                            if(NULL==(pCertImportInfo=(CERT_IMPORT_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                            {
                                break;
                            }

                            //skip the next page if password is not necessary
                            if(CERT_QUERY_CONTENT_PFX != pCertImportInfo->dwContentType)
                            {
                                //jump to the welcome page if the source is not from a file
                                if((pCertImportInfo->hSrcStore && (NULL==pCertImportInfo->pwszFileName)) ||
								   ((pCertImportInfo->fKnownSrc)&&(pCertImportInfo->pwszFileName)&&(CERT_QUERY_CONTENT_PKCS7_SIGNED == pCertImportInfo->dwContentType))
								  )
                                {
                                    SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_IMPORT_WELCOME);
                                }
                                else
                                {
                                   SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_IMPORT_FILE);
                                }
                            }

                        break;

                    case PSN_WIZNEXT:
                            if(NULL==(pCertImportInfo=(CERT_IMPORT_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                            {
                                break;
                            }

                            //make sure that we have select some store
                            if(TRUE==SendMessage(GetDlgItem(hwndDlg, IDC_WIZARD_RADIO1), BM_GETCHECK, 0, 0))
                            {
                                //mark that the des store is not selected
                                pCertImportInfo->fSelectedDesStore=FALSE;


                                /*if(pCertImportInfo->pwszDefaultStoreName)
                                {
                                    WizardFree(pCertImportInfo->pwszDefaultStoreName);
                                    pCertImportInfo->pwszDefaultStoreName=NULL;
                                }*/

                                //we will not know the default store name
                                //if PFX was selected
                                /*if(pCertImportInfo->hSrcStore)
                                {

                                    if(!GetDefaultStoreName(
                                            pCertImportInfo,
                                            pCertImportInfo->hSrcStore,
                                            &(pCertImportInfo->pwszDefaultStoreName),
                                            &idsError))
                                    {
                                        //output the message
                                        I_MessageBox(hwndDlg, idsError,
                                                IDS_IMPORT_WIZARD_TITLE,
                                                NULL,
                                                MB_ICONERROR|MB_OK|MB_APPLMODAL);

                                         //make the file page stay
                                         SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);

                                         break;

                                    }
                                } */
                            }
                            else
                            {
                                //make sure we have something selected
                                if(NULL==pCertImportInfo->hDesStore)
                                {
                                    //output the message
                                    I_MessageBox(hwndDlg, IDS_HAS_TO_SELECT_STORE,
                                            IDS_IMPORT_WIZARD_TITLE,
                                            NULL,
                                            MB_ICONERROR|MB_OK|MB_APPLMODAL);

                                     //make the file page stay
                                     SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);

                                     break;
                                }
                                else
                                {

                                    pCertImportInfo->fSelectedDesStore=TRUE;
                                }
                            }


                        break;

				    default:
					    return FALSE;

    	        }
		    break;

		default:
			return FALSE;
	}

	return TRUE;
}


//-----------------------------------------------------------------------
// Import_Completion
//-----------------------------------------------------------------------
INT_PTR APIENTRY Import_Completion(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CERT_IMPORT_INFO        *pCertImportInfo=NULL;
    PROPSHEETPAGE           *pPropSheet=NULL;
    HWND                    hwndControl=NULL;
    LV_COLUMNW              lvC;

    HDC                     hdc=NULL;
    COLORREF                colorRef;

	switch (msg)
	{
		case WM_INITDIALOG:
                //set the wizard information so that it can be shared
                pPropSheet = (PROPSHEETPAGE *) lParam;
                pCertImportInfo = (CERT_IMPORT_INFO *) (pPropSheet->lParam);
                //make sure pCertImportInfo is a valid pointer
                if(NULL==pCertImportInfo)
                   break;
                SetWindowLongPtr(hwndDlg, DWLP_USER, (LONG_PTR)pCertImportInfo);

                SetControlFont(pCertImportInfo->hBigBold, hwndDlg,IDC_WIZARD_STATIC_BIG_BOLD1);

               //getthe background color of the parent window
                /*
               if(hdc=GetWindowDC(hwndDlg))
               {
                    if(CLR_INVALID!=(colorRef=GetBkColor(hdc)))
                    {
                        ListView_SetBkColor(GetDlgItem(hwndDlg, IDC_WIZARD_LIST1), CLR_NONE);
                        ListView_SetTextBkColor(GetDlgItem(hwndDlg, IDC_WIZARD_LIST1), CLR_NONE);
                    }
               }  */

               //insert two columns for the confirmation
               if(hwndControl=GetDlgItem(hwndDlg, IDC_WIZARD_LIST1))
               {

                    //1st one is the label for the confirmation
                    memset(&lvC, 0, sizeof(LV_COLUMNW));

                    lvC.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
                    lvC.fmt = LVCFMT_LEFT;  // Left-align the column.
                    lvC.cx = 20;          // Width of the column, in pixels.
                    lvC.pszText = L"";   // The text for the column.
                    lvC.iSubItem=0;

                    ListView_InsertColumnU(hwndControl, 0, &lvC);

                    //2nd column is the content
                    memset(&lvC, 0, sizeof(LV_COLUMNW));

                    lvC.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
                    lvC.fmt = LVCFMT_LEFT;  // Left-align the column.
                    lvC.cx = 20;          // Width of the column, in pixels.
                    lvC.pszText = L"";   // The text for the column.
                    lvC.iSubItem= 1;

                    ListView_InsertColumnU(hwndControl, 1, &lvC);
               }

            break;

		case WM_COMMAND:
			break;	
						
		case WM_NOTIFY:
    		    switch (((NMHDR FAR *) lParam)->code)
    		    {

  				    case PSN_KILLACTIVE:
                            SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
					        return TRUE;

                        break;

				    case PSN_RESET:
                            SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
					    break;

 				    case PSN_SETACTIVE:
 					        PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK|PSWIZB_FINISH);

                            if(NULL==(pCertImportInfo=(CERT_IMPORT_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                            {
                                break;
                            }

                            //populate the list box in the order of
                            //FileName, FileType, and store info
                            if(hwndControl=GetDlgItem(hwndDlg, IDC_WIZARD_LIST1))
                            {
                                DisplayImportConfirmation(hwndControl, pCertImportInfo);
                                ListView_SetItemState(hwndControl, 
                                    0, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
                            }

					    break;

                    case PSN_WIZBACK:

                        break;

                    case PSN_WIZFINISH:
                        break;

				    default:
					    return FALSE;

    	        }
		    break;

		default:

			    return FALSE;
	}

	return TRUE;
}


//--------------------------------------------------------------------------------
//
// Add a specified Cert/CTL/CRL context to specified destination store, and prompt
// user for permission if attempting to replace an older context over a newer 
// context, if UI is allowed.
//
//---------------------------------------------------------------------------------

DWORD AddContextToStore(IN  DWORD        dwContextType,
                        IN  HWND         hwndParent,
                        IN  PVOID        pContext,
                        IN  BOOL         fUIAllowed,
                        IN  HCERTSTORE   hDstStore)
{
    DWORD dwRetCode = 0;

    switch (dwContextType)
    {
        case CRYPTUI_WIZ_IMPORT_SUBJECT_CERT_CONTEXT:
        {
            //
            // Add cert context to store.
            //
		    if (!CertAddCertificateContextToStore(hDstStore,
                                                  (PCCERT_CONTEXT) pContext,
                                                  CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES,
                                                  NULL))
            {
                dwRetCode = GetLastError();
                break;
            }

            break;
        }

        case CRYPTUI_WIZ_IMPORT_SUBJECT_CTL_CONTEXT:
        {
		    if (!CertAddCTLContextToStore(hDstStore,
                                          (PCCTL_CONTEXT) pContext,
                                          CERT_STORE_ADD_NEWER_INHERIT_PROPERTIES,
                                          NULL))
            {
                //
                // If there is a newer copy in the store, then prompt user for permission
                // to replace, if UI is allowed.
                //
                if ((!fUIAllowed) && (CRYPT_E_EXISTS != GetLastError()))
                {
                    dwRetCode = GetLastError();
                    break;
                }

                if (IDYES != I_MessageBox(hwndParent, 
                                          IDS_IMPORT_REPLACE_EXISTING_NEWER_CTL, 
                                          IDS_IMPORT_WIZARD_TITLE,
                                          NULL, 
                                          MB_YESNO | MB_ICONINFORMATION | MB_DEFBUTTON2))
                {
                    dwRetCode = ERROR_CANCELLED;
                    break;
                }

                //
                // Try with REPLACE_EXISTING disposition.
                //
                if (!CertAddCTLContextToStore(hDstStore,
                                              (PCCTL_CONTEXT) pContext,
                                              CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES,
                                              NULL))
                {
                    dwRetCode = GetLastError();
                    break;
                }
            }

            break;
        }

        case CRYPTUI_WIZ_IMPORT_SUBJECT_CRL_CONTEXT:
        {
		    if (!CertAddCRLContextToStore(hDstStore,
			    						  (PCCRL_CONTEXT) pContext,
				    					  CERT_STORE_ADD_NEWER_INHERIT_PROPERTIES,
					    				  NULL))
            {
                //
                // If there is a newer copy in the store, then prompt user for permission
                // to replace, if UI is allowed.
                //
                if ((!fUIAllowed) && (CRYPT_E_EXISTS != GetLastError()))
                {
                    dwRetCode = GetLastError();
                    break;
                }

                if (IDYES != I_MessageBox(hwndParent, 
                                          IDS_IMPORT_REPLACE_EXISTING_NEWER_CRL, 
                                          IDS_IMPORT_WIZARD_TITLE,
                                          NULL, 
                                          MB_YESNO | MB_ICONINFORMATION | MB_DEFBUTTON2))
                {
                    dwRetCode = ERROR_CANCELLED;
                    break;
                }

                //
                // Try with REPLACE_EXISTING disposition.
                //
                if (!CertAddCRLContextToStore(hDstStore,
                                              (PCCRL_CONTEXT) pContext,
                                              CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES,
                                              NULL))
                {
                    dwRetCode = GetLastError();
                    break;
                }
            }

            break;
        }

        default:
        {
            dwRetCode = ERROR_INVALID_PARAMETER;
            break;
        }
    }

    return dwRetCode;
}


//--------------------------------------------------------------------------------
//
// Add CTLs from source store to destination store.
//
//---------------------------------------------------------------------------------

DWORD AddCTLsToStore(HWND         hwndParent, 
                     HCERTSTORE   hSrcStore,
                     HCERTSTORE   hDstStore,
                     BOOL         fUIAllowed,
                     UINT       * pidsStatus)
{
    DWORD         dwError     = 0;
    PCCTL_CONTEXT pCTLPre     = NULL;
    PCCTL_CONTEXT pCTLContext = NULL;
    PCCTL_CONTEXT pFindCTL    = NULL;

    //DSIE: Bug 22633.
    BOOL          bCancelled  = FALSE;

	// Add the CTLs
	while (pCTLContext = CertEnumCTLsInStore(hSrcStore, pCTLPre))
	{
        bCancelled = FALSE;

        if (0 != (dwError = AddContextToStore(CRYPTUI_WIZ_IMPORT_SUBJECT_CTL_CONTEXT,
                                              hwndParent,
                                              (PVOID) pCTLContext,
                                              fUIAllowed,
                                              hDstStore)))
        {
            if (ERROR_CANCELLED == dwError)
            {
                bCancelled = TRUE;
            }
            else
            {
                // Check to see if there is alreay a read-only duplicated copy in the store?
                // If so, ignore the error.
                if (NULL == (pFindCTL = CertFindCTLInStore(hDstStore,
                                                           g_dwMsgAndCertEncodingType,
                                                           0,
                                                           CTL_FIND_EXISTING,
                                                           pCTLContext,
                                                           NULL)))
                {
                    *pidsStatus = IDS_IMPORT_FAIL_MOVE_CONTENT;
                    goto CLEANUP;
                }

                CertFreeCTLContext(pFindCTL);
                pFindCTL = NULL;
            }
         
            dwError = 0;
        }

		pCTLPre = pCTLContext;
    }

    //
    // As the way we have it now, we can only check the last operation!
    //
    if (bCancelled)
    {
        dwError = ERROR_CANCELLED;
        *pidsStatus = IDS_IMPORT_CANCELLED;
    }
    else
    {
        *pidsStatus = IDS_IMPORT_SUCCEEDED;
    }

CLEANUP:

	if (pCTLContext)
    {
		CertFreeCTLContext(pCTLContext);
    }

    return dwError;
}


//--------------------------------------------------------------------------------
//
// Add CRLs from source store to destination store.
//
//---------------------------------------------------------------------------------

DWORD AddCRLsToStore(HWND         hwndParent, 
                     HCERTSTORE   hSrcStore,
                     HCERTSTORE   hDstStore,
                     BOOL         fUIAllowed,
                     UINT       * pidsStatus)
{
    DWORD         dwError     = 0;
	DWORD         dwCRLFlag   = 0;

    PCCRL_CONTEXT pCRLPre     = NULL;
    PCCRL_CONTEXT pCRLContext = NULL;
    PCCRL_CONTEXT pFindCRL    = NULL;

    //DSIE: Bug 22633.
    BOOL          bCancelled  = FALSE;

	// Add the CRLs
	while (pCRLContext = CertGetCRLFromStore(hSrcStore, NULL, pCRLPre, &dwCRLFlag))
	{
        bCancelled = FALSE;

        if (0 != (dwError = AddContextToStore(CRYPTUI_WIZ_IMPORT_SUBJECT_CRL_CONTEXT,
                                              hwndParent,
                                              (PVOID) pCRLContext,
                                              fUIAllowed,
                                              hDstStore)))
        {
            if (ERROR_CANCELLED == dwError)
            {
                bCancelled = TRUE;
            }
            else
            {
                // Check to see if there is alreay a read-only duplicated copy in the store?
                // If so, ignore the error.
                if (NULL == (pFindCRL = CertFindCRLInStore(hDstStore,
                                                           g_dwMsgAndCertEncodingType,
                                                           0,
                                                           CRL_FIND_EXISTING,
                                                           pCRLContext,
                                                           NULL)))
                {
                    *pidsStatus = IDS_IMPORT_FAIL_MOVE_CONTENT;
                    goto CLEANUP;
                }

                CertFreeCRLContext(pFindCRL);
                pFindCRL = NULL;
            }
         
            dwError = 0;
        }

		pCRLPre = pCRLContext;
	}

    //
    // As the way we have it now, we can only check the last operation!
    //
    if (bCancelled)
    {
        dwError = ERROR_CANCELLED;
        *pidsStatus = IDS_IMPORT_CANCELLED;
    }
    else
    {
        *pidsStatus = IDS_IMPORT_SUCCEEDED;
    }

CLEANUP:

	if (pCRLContext)
    {
		CertFreeCRLContext(pCRLContext);
    }

    return dwError;
}


//--------------------------------------------------------------------------------
//
// Add certs from source store to destination store.
//
//---------------------------------------------------------------------------------

DWORD AddCertsToStore(HWND         hwndParent, 
                      HCERTSTORE   hSrcStore,
                      HCERTSTORE   hDstStore,
                      BOOL         fUIAllowed,
                      UINT       * pidsStatus)
{
    DWORD          dwError      = 0;
    PCCERT_CONTEXT pCertPre     = NULL;
    PCCERT_CONTEXT pCertContext = NULL;
    PCCERT_CONTEXT pFindCert    = NULL;

    //DSIE: Bug 22633.
    BOOL           bCancelled   = FALSE;

    // Add the certs
	while (pCertContext = CertEnumCertificatesInStore(hSrcStore, pCertPre))
    {
        bCancelled = FALSE;

        if (0 != (dwError = AddContextToStore(CRYPTUI_WIZ_IMPORT_SUBJECT_CERT_CONTEXT,
                                              hwndParent,
                                              (PVOID) pCertContext,
                                              fUIAllowed,
                                              hDstStore)))
        {
            if (ERROR_CANCELLED == dwError)
            {
                bCancelled = TRUE;
            }
            else            
            {
                // Check to see if there is alreay a read-only duplicated copy in the store?
                // If so, ignore the error.
                if (NULL == (pFindCert = CertFindCertificateInStore(hDstStore,
                                                                    g_dwMsgAndCertEncodingType,
                                                                    0,
                                                                    CERT_FIND_EXISTING,
                                                                    pCertContext,
                                                                    NULL)))
                {
                    *pidsStatus = IDS_IMPORT_FAIL_MOVE_CONTENT;
                    goto CLEANUP;
                }

		        CertFreeCertificateContext(pFindCert);
                pFindCert = NULL;
            }
         
            dwError = 0;
        }

		pCertPre = pCertContext;
    }

    //
    // As the way we have it now, we can only check the last operation!
    //
    if (bCancelled)
    {
        dwError = ERROR_CANCELLED;
        *pidsStatus = IDS_IMPORT_CANCELLED;
    }
    else
    {
        *pidsStatus = IDS_IMPORT_SUCCEEDED;
    }

CLEANUP:

	if (pCertContext)
    {
		CertFreeCertificateContext(pCertContext);
    }

    return dwError;
}


//-------------------------------------------------------------------------
//
//	Move Certs/CRls/CTLs from the source store to the destination
//
//-------------------------------------------------------------------------
DWORD MoveItem(CERT_IMPORT_INFO * pCertImportInfo,
               UINT             * pidsStatus)
{
    DWORD dwError = 0;

	// Add the CTLs.
    if (0 != (dwError = AddCTLsToStore(pCertImportInfo->hwndParent,
                                       pCertImportInfo->hSrcStore,
                                       pCertImportInfo->hDesStore,
                                       pCertImportInfo->dwFlag & CRYPTUI_WIZ_NO_UI ? TRUE : FALSE,
                                       pidsStatus)))
    {
        goto CLEANUP;
    }

	// Add the CRLs.
    if (0 != (dwError = AddCRLsToStore(pCertImportInfo->hwndParent,
                                       pCertImportInfo->hSrcStore,
                                       pCertImportInfo->hDesStore,
                                       pCertImportInfo->dwFlag & CRYPTUI_WIZ_NO_UI ? TRUE : FALSE,
                                       pidsStatus)))
    {
        goto CLEANUP;
    }

    // Add the certs.
    if (0 != (dwError = AddCertsToStore(pCertImportInfo->hwndParent,
                                        pCertImportInfo->hSrcStore,
                                        pCertImportInfo->hDesStore,
                                        pCertImportInfo->dwFlag & CRYPTUI_WIZ_NO_UI ? TRUE : FALSE,
                                        pidsStatus)))
    {
        goto CLEANUP;
    }

CLEANUP:

	return dwError;
}


//**************************************************************************
//
//    The entry point for import wizard
//**************************************************************************
//-----------------------------------------------------------------------
//
// CryptUIWizImport
//
//  The import wizard to import public key related files to a certificate
//  store
//
//  dwFlags can be set to any combination of the following flags:
//  CRYPTUI_WIZ_NO_UI                           No UI will be shown.  Otherwise, User will be
//                                              prompted by a wizard.
//  CRYPTUI_WIZ_IMPORT_ALLOW_CERT               Allow importing certificate
//  CRYPTUI_WIZ_IMPORT_ALLOW_CRL                Allow importing CRL(certificate revocation list)
//  CRYPTUI_WIZ_IMPORT_ALLOW_CTL                Allow importing CTL(certificate trust list)
//  CRYPTUI_WIZ_IMPORT_NO_CHANGE_DEST_STORE     user will not be allowed to change
//                                              the hDesCertStore in the wizard page
//  CRYPTUI_WIZ_IMPORT_TO_LOCALMACHINE          the contents should be imported to local machine
//                                              (currently only applicable for PFX imports)
//  CRYPTUI_WIZ_IMPORT_TO_CURRENTUSER           the contents should be imported to current user
//                                              (currently only applicable for PFX imports)
//
//  Please notice that if neither of following three flags is in dwFlags, default to is
//  allow everything.
//  CRYPTUI_WIZ_IMPORT_ALLOW_CERT
//  CRYPTUI_WIZ_IMPORT_ALLOW_CRL
//  CRYPTUI_WIZ_IMPORT_ALLOW_CTL
//
//  Also, note that the CRYPTUI_WIZ_IMPORT_TO_LOCALMACHINE and CRYPTUI_WIZ_IMPORT_TO_CURRENTUSER
//  flags are used force the content of a pfx blob into either local machine or current user.
//  If neither of these flags are used and hDesCertStore is NULL then:
//  1) The private key in the pfx blob will be forced to be imported into current user.
//  2) If CRYPTUI_WIZ_NO_UI is NOT set, the wizard will prompt the user to select a certificate 
//     store from the current user stores.
//     
//
//
//  If CRYPTUI_WIZ_NO_UI is set in dwFlags:
//      hwndParent:         Ignored
//      pwszWizardTitle:    Ignored
//      pImportSubject:     IN Required:    The subject to import.
//      hDestCertStore:     IN Optional:    The destination certficate store
//
//  If CRYPTUI_WIZ_NO_UI is not set in dwFlags:
//      hwndPrarent:        IN Optional:    The parent window for the wizard
//      pwszWizardTitle:    IN Optional:    The title of the wizard
//                                          If NULL, the default will be IDS_BUILDCTL_WIZARD_TITLE
//      pImportSubject:     IN Optional:    The file name to import.
//                                          If NULL, the wizard will prompt user to enter the file name
//      hDestCertStore:     IN Optional:    The destination certificate store where the file wil be
//                                          imported to.  If NULL, the wizard will prompt user to select
//                                          a certificate store
//------------------------------------------------------------------------
BOOL
WINAPI
CryptUIWizImport(
    DWORD                               dwFlags,
    HWND                                hwndParent,
    LPCWSTR                             pwszWizardTitle,
    PCCRYPTUI_WIZ_IMPORT_SRC_INFO       pImportSubject,
    HCERTSTORE                          hDestCertStore
)
{
    BOOL                    fResult=FALSE;
    HRESULT                 hr=E_FAIL;
    CERT_IMPORT_INFO        CertImportInfo;
    HCERTSTORE              hTempStore=NULL;
    UINT                    ids=IDS_INVALID_WIZARD_INPUT;
    UINT                    idsContent=0;

    PROPSHEETPAGEW           rgImportSheet[IMPORT_PROP_SHEET];
    PROPSHEETHEADERW         importHeader;
    ENROLL_PAGE_INFO        rgImportPageInfo[]=
        {(LPCWSTR)MAKEINTRESOURCE(IDD_IMPORT_WELCOME),           Import_Welcome,
         (LPCWSTR)MAKEINTRESOURCE(IDD_IMPORT_FILE),              Import_File,
         (LPCWSTR)MAKEINTRESOURCE(IDD_IMPORT_PASSWORD),          Import_Password,
         (LPCWSTR)MAKEINTRESOURCE(IDD_IMPORT_STORE),             Import_Store,
         (LPCWSTR)MAKEINTRESOURCE(IDD_IMPORT_COMPLETION),        Import_Completion,
    };

    DWORD                   dwIndex=0;
    DWORD                   dwPropCount=0;
    WCHAR                   wszTitle[MAX_TITLE_LENGTH];
    DWORD                   dwError=0;
    int                     intMsg=0;
    INT_PTR                 iReturn=-1;

    //init
    memset(&CertImportInfo, 0, sizeof(CERT_IMPORT_INFO));
    memset(rgImportSheet, 0, sizeof(PROPSHEETPAGEW)*IMPORT_PROP_SHEET);
    memset(&importHeader, 0, sizeof(PROPSHEETHEADERW));

    //make sure if UIless option is set, all required information
    //is provided
    if(dwFlags &  CRYPTUI_WIZ_NO_UI)
    {
        if(NULL==pImportSubject)
            goto InvalidArgErr;
    }

    if ((dwFlags & CRYPTUI_WIZ_IMPORT_TO_LOCALMACHINE) && 
        (dwFlags & CRYPTUI_WIZ_IMPORT_TO_CURRENTUSER))
    {
        goto InvalidArgErr;
    }

    //make sure that default is to allow everything
    if((0 == (dwFlags & CRYPTUI_WIZ_IMPORT_ALLOW_CERT)) &&
        (0 == (dwFlags & CRYPTUI_WIZ_IMPORT_ALLOW_CRL)) &&
        (0 == (dwFlags & CRYPTUI_WIZ_IMPORT_ALLOW_CTL)))
        dwFlags |= CRYPTUI_WIZ_IMPORT_ALLOW_CERT | CRYPTUI_WIZ_IMPORT_ALLOW_CRL | CRYPTUI_WIZ_IMPORT_ALLOW_CTL;

	//if hDestCertStore is NULL, no need to set the remote flag
	if(NULL == hDestCertStore)
		dwFlags &= (~CRYPTUI_WIZ_IMPORT_REMOTE_DEST_STORE);


    CertImportInfo.hwndParent=hwndParent;
    CertImportInfo.dwFlag=dwFlags;

    //set the subject
    if(pImportSubject)
    {
        if(pImportSubject->dwSize != sizeof(CRYPTUI_WIZ_IMPORT_SRC_INFO))
            goto InvalidArgErr;

        //copy the passWord and flags for PFX BLOBs
        CertImportInfo.dwPasswordFlags=pImportSubject->dwFlags;

        if(pImportSubject->pwszPassword)
            CertImportInfo.pwszPassword=WizardAllocAndCopyWStr((LPWSTR)(pImportSubject->pwszPassword));
        else
            CertImportInfo.pwszPassword=NULL;

        //open a temparory certificate store
        hTempStore=CertOpenStore(CERT_STORE_PROV_MEMORY,
						 g_dwMsgAndCertEncodingType,
						 NULL,
						 0,
						 NULL);

        if(!hTempStore)
            goto CertOpenStoreErr;

        switch(pImportSubject->dwSubjectChoice)
        {
            case    CRYPTUI_WIZ_IMPORT_SUBJECT_FILE:
                        if(NULL==pImportSubject->pwszFileName)
                            goto InvalidArgErr;

                        CertImportInfo.pwszFileName=(LPWSTR)(pImportSubject->pwszFileName);
                        CertImportInfo.fFreeFileName=FALSE;

                        //get the content type of the file
                        //we import anything but PKCS10 or signed document
                        ExpandAndCryptQueryObject(
                                CERT_QUERY_OBJECT_FILE,
                                CertImportInfo.pwszFileName,
                                dwExpectedContentType,
                                CERT_QUERY_FORMAT_FLAG_ALL,
                                0,
                                NULL,
                                &(CertImportInfo.dwContentType),
                                NULL,
                                &(CertImportInfo.hSrcStore),
                                NULL,
                                NULL);

						//if this is a PKCS7 file, get the blob 
						if(CERT_QUERY_CONTENT_PKCS7_SIGNED == CertImportInfo.dwContentType )
						{
							if(S_OK !=(hr=RetrieveBLOBFromFile(
									CertImportInfo.pwszFileName,
									&(CertImportInfo.blobData.cbData),
									&(CertImportInfo.blobData.pbData))))
								goto ReadFromFileErr;
						}
						else
						{
							//get the blobs from the pfx file
							if(CERT_QUERY_CONTENT_PFX==CertImportInfo.dwContentType)
							{

								//we can not import PFX Files for remote case
								if(dwFlags & CRYPTUI_WIZ_IMPORT_REMOTE_DEST_STORE)
								{
									ids=IDS_IMPORT_NO_PFX_FOR_REMOTE;
									goto InvalidArgErr;
								}

								if(S_OK !=(hr=RetrieveBLOBFromFile(
										CertImportInfo.pwszFileName,
										&(CertImportInfo.blobData.cbData),
										&(CertImportInfo.blobData.pbData))))
									goto ReadFromFileErr;

								//convert the PFX BLOB to a certificate store
								CertImportInfo.fPFX=PFXVerifyPassword(
									(CRYPT_DATA_BLOB *)&(CertImportInfo.blobData),
									CertImportInfo.pwszPassword,
									0);

								//PFX blob only contains certificates
								if(0==((CertImportInfo.dwFlag) & CRYPTUI_WIZ_IMPORT_ALLOW_CERT))
								{
									ids=IDS_IMPORT_OBJECT_NOT_EXPECTED;
									goto InvalidArgErr;
								}

							}
						}

                        //make sure we do have a source store
                        if(CertImportInfo.hSrcStore)
                        {
                            //remember to free the Src store
                            CertImportInfo.fFreeSrcStore=TRUE;
                            CertImportInfo.fKnownSrc=TRUE;
                        }

                break;
            case    CRYPTUI_WIZ_IMPORT_SUBJECT_CERT_CONTEXT:
                        if(NULL==pImportSubject->pCertContext)
                                goto InvalidArgErr;

				        //add certificate to the hash
			            if(!CertAddCertificateContextToStore(
                                                    hTempStore,
													pImportSubject->pCertContext,
													CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES,
													NULL))
                                goto AddCertErr;

                        CertImportInfo.hSrcStore=hTempStore;
                        CertImportInfo.fFreeSrcStore=FALSE;
                        CertImportInfo.dwContentType=CERT_QUERY_CONTENT_CERT;
                        CertImportInfo.fKnownSrc=TRUE;

                break;
            case    CRYPTUI_WIZ_IMPORT_SUBJECT_CTL_CONTEXT:
                        if(NULL==pImportSubject->pCTLContext)
                            goto InvalidArgErr;

				        //add CTL to the hash
				        if(!CertAddCTLContextToStore(
                                        hTempStore,
										pImportSubject->pCTLContext,
										CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES,
										NULL))
                                goto Crypt32Err;

                        CertImportInfo.hSrcStore=hTempStore;
                        CertImportInfo.fFreeSrcStore=FALSE;
                        CertImportInfo.dwContentType=CERT_QUERY_CONTENT_CTL;
                        CertImportInfo.fKnownSrc=TRUE;

                break;
            case    CRYPTUI_WIZ_IMPORT_SUBJECT_CRL_CONTEXT:
                        if(NULL==pImportSubject->pCRLContext)
                            goto InvalidArgErr;

				        //add CRL to the hash
					    if(!CertAddCRLContextToStore(
                                        hTempStore,
										pImportSubject->pCRLContext,
										CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES,
										NULL))
                                goto Crypt32Err;

                        CertImportInfo.hSrcStore=hTempStore;
                        CertImportInfo.fFreeSrcStore=FALSE;
                        CertImportInfo.fKnownSrc=TRUE;
                        CertImportInfo.dwContentType=CERT_QUERY_CONTENT_CRL;
                break;
            case    CRYPTUI_WIZ_IMPORT_SUBJECT_CERT_STORE:
                        if(NULL==pImportSubject->hCertStore)
                            goto InvalidArgErr;

                        CertImportInfo.hSrcStore=pImportSubject->hCertStore;
                        CertImportInfo.fFreeSrcStore=FALSE;
                        CertImportInfo.dwContentType=0;
                        CertImportInfo.fKnownSrc=TRUE;
                break;
            default:
                goto InvalidArgErr;
        }

    }
    else
    {
        CertImportInfo.fKnownSrc=FALSE;
    }

    //if user has supplied a source store, it should contain the correct
    //information
    if(NULL != CertImportInfo.hSrcStore)
    {
        //make sure that the destination store has the right content
        if(!CheckForContent(CertImportInfo.hSrcStore, dwFlags, FALSE, &idsContent))
        {
            ids=idsContent;
            goto InvalidArgErr;
        }
    }
    else
    {
        //check for the PFX
        if(TRUE == CertImportInfo.fPFX)
        {
            //PFX blob only contains certificates
            if(0==((CertImportInfo.dwFlag) & CRYPTUI_WIZ_IMPORT_ALLOW_CERT))
            {
                ids=IDS_IMPORT_OBJECT_NOT_EXPECTED;
                goto InvalidArgErr;
            }
        }

    }

    //set the destination store if supplied
    if(hDestCertStore)
    {
        CertImportInfo.hDesStore=hDestCertStore;
        CertImportInfo.fFreeDesStore=FALSE;
        CertImportInfo.fKnownDes=TRUE;
        CertImportInfo.fSelectedDesStore=TRUE;
    }
    else
    {
        CertImportInfo.fKnownDes=FALSE;
        CertImportInfo.fSelectedDesStore=FALSE;
    }

    //supply the UI work
    if((dwFlags &  CRYPTUI_WIZ_NO_UI) == 0)
    {
        //set up the fonts
        if(!SetupFonts(g_hmodThisDll,
                   NULL,
                   &(CertImportInfo.hBigBold),
                   &(CertImportInfo.hBold)))
            goto Win32Err;


        //init the common control
        if(!WizardInit(TRUE) ||
           (sizeof(rgImportPageInfo)/sizeof(rgImportPageInfo[0])!=IMPORT_PROP_SHEET)
          )
            goto InvalidArgErr;

        //set up the property sheet and the property header
        dwPropCount=0;

        for(dwIndex=0; dwIndex<IMPORT_PROP_SHEET; dwIndex++)
        {
            if(pImportSubject)
            {
				//skip the IDD_IMPORT_FILE page if subject is known and it is not
				//a fileName
                if(((1==dwIndex) || (2==dwIndex)) &&
                   (NULL==CertImportInfo.pwszFileName) &&
                   (CertImportInfo.hSrcStore)
                  )
                    continue;

				//or, if this is a PKCS7 file name, we skip the file name
				//page.  This is strictly for UI freeze.
				if(((1==dwIndex) || (2==dwIndex)) && 
					(CertImportInfo.pwszFileName)&&
					(CERT_QUERY_CONTENT_PKCS7_SIGNED == CertImportInfo.dwContentType)
				   )
					continue;
            }

            rgImportSheet[dwPropCount].dwSize=sizeof(rgImportSheet[dwPropCount]);

            if(pwszWizardTitle)
                rgImportSheet[dwPropCount].dwFlags=PSP_USETITLE;
            else
                rgImportSheet[dwPropCount].dwFlags=0;

            rgImportSheet[dwPropCount].hInstance=g_hmodThisDll;
            rgImportSheet[dwPropCount].pszTemplate=rgImportPageInfo[dwIndex].pszTemplate;

            if(pwszWizardTitle)
            {
                rgImportSheet[dwPropCount].pszTitle=pwszWizardTitle;
            }
            else
                rgImportSheet[dwPropCount].pszTitle=NULL;

            rgImportSheet[dwPropCount].pfnDlgProc=rgImportPageInfo[dwIndex].pfnDlgProc;

            rgImportSheet[dwPropCount].lParam=(LPARAM)&CertImportInfo;

            dwPropCount++;
        }

        //set up the header information
        importHeader.dwSize=sizeof(importHeader);
        importHeader.dwFlags=PSH_PROPSHEETPAGE | PSH_WIZARD | PSH_NOAPPLYNOW;
        importHeader.hwndParent=hwndParent;
        importHeader.hInstance=g_hmodThisDll;

        if(pwszWizardTitle)
            importHeader.pszCaption=pwszWizardTitle;
        else
        {
            if(LoadStringU(g_hmodThisDll, IDS_IMPORT_WIZARD_TITLE, wszTitle, sizeof(wszTitle)/sizeof(wszTitle[0])))
                importHeader.pszCaption=wszTitle;
        }

        importHeader.nPages=dwPropCount;
        importHeader.nStartPage=0;
        importHeader.ppsp=rgImportSheet;

        //no need to create the wizard if there are only 2 pages:
        //Welcome and Confirmation
        if(dwPropCount > 2)
        {
            //create the wizard
            iReturn=PropertySheetU(&importHeader);

            if(-1 == iReturn)
                goto Win32Err;

            if(0 == iReturn)
            {
                fResult=TRUE;
                //no need to say anything if the wizard is cancelled
                ids=0;
                goto CommonReturn;
            }
        }
    }

    //Open the destination store for PFX file
    if(TRUE == CertImportInfo.fPFX)
    {
        // if the caller specified local machine then set the appropriate flag
        if (dwFlags & CRYPTUI_WIZ_IMPORT_TO_LOCALMACHINE)
        {
            CertImportInfo.dwPasswordFlags |= CRYPT_MACHINE_KEYSET;
        }
        else if ((dwFlags & CRYPTUI_WIZ_IMPORT_TO_CURRENTUSER) ||
                 (hDestCertStore == NULL))
        {
            CertImportInfo.dwPasswordFlags |= CRYPT_USER_KEYSET;
        }

        CertImportInfo.hSrcStore=
            PFXImportCertStore(
                (CRYPT_DATA_BLOB *)&(CertImportInfo.blobData),
                CertImportInfo.pwszPassword,
                CertImportInfo.dwPasswordFlags);

        if(CertImportInfo.hSrcStore)
        {
            //remember to free the Src store
            CertImportInfo.fFreeSrcStore=TRUE;
            CertImportInfo.fKnownSrc=TRUE;
        }
        else
        {
            DWORD dwLastError = GetLastError();

            if (dwLastError == ERROR_UNSUPPORTED_TYPE)
            {
                ids=IDS_UNSUPPORTED_KEY;
            }
            else if (dwLastError == CRYPT_E_BAD_ENCODE)
            {
                ids=IDS_BAD_ENCODE;
            }
            //DSIE: Bug 22752
            else if (dwLastError == ERROR_CANCELLED)
            {
                ids=IDS_IMPORT_FAIL_MOVE_CONTENT;
            }
            else
            {
                ids=IDS_IMPORT_FAIL_FIND_CONTENT;
            }
            goto InvalidArgErr;
        }

        //make sure the PFX blob is not empty
        if(!CheckForContent(CertImportInfo.hSrcStore, dwFlags, FALSE, &idsContent))
        {
            ids=idsContent;
            goto InvalidArgErr;
        }
    }

    //make sure the source store is a valid value
    if(NULL==(CertImportInfo.hSrcStore))
    {
        ids=IDS_IMPORT_FAIL_FIND_CONTENT;
        goto InvalidArgErr;
    }

    //do the import work.  Return a status
    //we disable the parent window in case the root dialogue will show up
    //this is to prevent  re-entrency
    if(hwndParent)
    {
        EnableWindow(hwndParent,FALSE);
    }

    if(S_OK !=(hr=I_ImportCertificate(&CertImportInfo, &ids)))
    {
        if(hwndParent)
        {
            EnableWindow(hwndParent,TRUE);
        }

        goto I_ImportErr;
    }

    if(hwndParent)
    {
        EnableWindow(hwndParent,TRUE);
    }

    fResult=TRUE;

CommonReturn:

    //preserve the last error
    dwError=GetLastError();

    //pop up the confirmation box for failure
    if(ids && ((dwFlags &  CRYPTUI_WIZ_NO_UI) ==0))
    {
        //set the message of inable to gather enough info for PKCS10
        if(IDS_IMPORT_SUCCEEDED == ids)
            I_MessageBox(hwndParent, ids, IDS_IMPORT_WIZARD_TITLE,
                        NULL, MB_OK|MB_ICONINFORMATION);
        else
        {
            if(IDS_IMPORT_PFX_EMPTY == ids)
                I_MessageBox(hwndParent, ids, IDS_IMPORT_WIZARD_TITLE,
                        NULL, MB_OK|MB_ICONWARNING);
            else
                I_MessageBox(hwndParent, ids, IDS_IMPORT_WIZARD_TITLE,
                        NULL, MB_OK|MB_ICONERROR);
        }

        if(IDS_IMPORT_DUPLICATE == ids)
        {
            //remark the success case
            I_MessageBox(hwndParent, IDS_IMPORT_SUCCEEDED, IDS_IMPORT_WIZARD_TITLE,
                    NULL, MB_OK|MB_ICONINFORMATION);
        }

    }

    //destroy the hFont object
    DestroyFonts(CertImportInfo.hBigBold,
                CertImportInfo.hBold);


    if(CertImportInfo.pwszFileName && (TRUE==CertImportInfo.fFreeFileName))
        WizardFree(CertImportInfo.pwszFileName);

   /* if(CertImportInfo.pwszDefaultStoreName)
        WizardFree(CertImportInfo.pwszDefaultStoreName); */

    if(CertImportInfo.hDesStore && (TRUE==CertImportInfo.fFreeDesStore))
        CertCloseStore(CertImportInfo.hDesStore, 0);

    if(CertImportInfo.hSrcStore && (TRUE==CertImportInfo.fFreeSrcStore))
        CertCloseStore(CertImportInfo.hSrcStore, 0);

    if(CertImportInfo.blobData.pbData)
        UnmapViewOfFile(CertImportInfo.blobData.pbData);

    if(CertImportInfo.pwszPassword)
    {
        SecureZeroMemory(CertImportInfo.pwszPassword, lstrlenW(CertImportInfo.pwszPassword) * sizeof(WCHAR));
        WizardFree(CertImportInfo.pwszPassword);
    }

    if(hTempStore)
        CertCloseStore(hTempStore, 0);

    //reset the error
    SetLastError(dwError);

    return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
TRACE_ERROR(CertOpenStoreErr);
SET_ERROR_VAR(ReadFromFileErr, hr);
TRACE_ERROR(AddCertErr);
TRACE_ERROR(Crypt32Err);
TRACE_ERROR(Win32Err);
SET_ERROR_VAR(I_ImportErr, hr);
}

//****************************************************************************
//   Helper functions for import wizards
//
//*****************************************************************************

BOOL	InstallViaXEnroll(CERT_IMPORT_INFO    *pCertImportInfo)
{
	BOOL					fResult=FALSE;
    IEnroll2				*pIEnroll2=NULL;
    PFNPIEnroll2GetNoCOM    pfnPIEnroll2GetNoCOM=NULL;
	CRYPT_DATA_BLOB			DataBlob;

	PCCERT_CONTEXT			pCert=NULL;

	if(NULL == pCertImportInfo)
		goto CLEANUP;

	DataBlob.cbData=pCertImportInfo->blobData.cbData;
	DataBlob.pbData=pCertImportInfo->blobData.pbData;

	if((0 == DataBlob.cbData) || (NULL == DataBlob.pbData))
	{
		//this is a certificate case.  Get the blob for the cert
		if(NULL==pCertImportInfo->hSrcStore)
			goto CLEANUP;

	    if(!(pCert=CertEnumCertificatesInStore(pCertImportInfo->hSrcStore, NULL)))
			goto CLEANUP;

		DataBlob.cbData=pCert->cbCertEncoded;
		DataBlob.pbData=pCert->pbCertEncoded;
	}

    //load the library "xEnroll.dll".
    if(NULL==g_hmodxEnroll)
    {
        if(NULL==(g_hmodxEnroll=LoadLibrary("xenroll.dll")))
        {
            goto CLEANUP;
        }
    }

	//get the address for PIEnroll2GetNoCOM()
    if(NULL==(pfnPIEnroll2GetNoCOM=(PFNPIEnroll2GetNoCOM)GetProcAddress(g_hmodxEnroll,
                        "PIEnroll2GetNoCOM")))
        goto CLEANUP;

    if(NULL==(pIEnroll2=pfnPIEnroll2GetNoCOM()))
        goto CLEANUP;


	//specify the destiniation store if user has specified one
    if(pCertImportInfo->hDesStore && (TRUE==pCertImportInfo->fSelectedDesStore))
	{	
		if(S_OK != (pIEnroll2->SetHStoreMy(pCertImportInfo->hDesStore)))
			goto CLEANUP;

		if(S_OK != (pIEnroll2->SetHStoreCA(pCertImportInfo->hDesStore)))
			goto CLEANUP;

		if(S_OK != (pIEnroll2->SetHStoreROOT(pCertImportInfo->hDesStore)))
			goto CLEANUP;
	}

	
	if(S_OK != (pIEnroll2->acceptPKCS7Blob(&DataBlob)))
		goto CLEANUP;

	fResult=TRUE;

CLEANUP:
    if(pIEnroll2)
        pIEnroll2->Release();

	if(pCert)
		CertFreeCertificateContext(pCert);

	return fResult;
}

//--------------------------------------------------------------------------------
//
// The import routine that does the work
//
//---------------------------------------------------------------------------------
HRESULT I_ImportCertificate(CERT_IMPORT_INFO * pCertImportInfo,
                            UINT             * pidsStatus)
{
    UINT            idsStatus=0;

    HCERTSTORE      hMyStore=NULL;
    HCERTSTORE      hCAStore=NULL;
    HCERTSTORE      hTrustStore=NULL;
    HCERTSTORE      hRootStore=NULL;
    HCERTSTORE      hAddressBookStore=NULL;
    HCERTSTORE      hTrustedPeopleStore=NULL;
    HCERTSTORE      hCertStore=NULL;

    PCCERT_CONTEXT	pCertContext=NULL;
    PCCERT_CONTEXT	pCertPre=NULL;
    PCCERT_CONTEXT	pFindCert=NULL;

    DWORD           dwData=0;
    DWORD           dwCertOpenStoreFlags;
    
    //DSIE: Bug 22633.
    BOOL bCancelled = FALSE;
    DWORD dwError   = 0;

    if (NULL == pCertImportInfo || NULL == pidsStatus)
        return E_INVALIDARG;

    if (NULL == pCertImportInfo->hSrcStore)
    {
        *pidsStatus = IDS_IMPORT_FAIL_FIND_CONTENT;
        return E_FAIL;
    }

    if (pCertImportInfo->fPFX && (pCertImportInfo->dwFlag & CRYPTUI_WIZ_IMPORT_TO_LOCALMACHINE))
    {
        dwCertOpenStoreFlags = CERT_SYSTEM_STORE_LOCAL_MACHINE;
    }
    else
    {
        dwCertOpenStoreFlags = CERT_SYSTEM_STORE_CURRENT_USER;
    }

 	// If the content type is PKS7 and use pass in or select a file name.
	// We try to use xEnroll to accept it as an enrollment response.
	if ((CERT_QUERY_CONTENT_PKCS7_SIGNED == pCertImportInfo->dwContentType) ||
        (CERT_QUERY_CONTENT_CERT == pCertImportInfo->dwContentType))
	{
		if (InstallViaXEnroll(pCertImportInfo))
		{
            *pidsStatus = IDS_IMPORT_SUCCEEDED;
            return S_OK;
		}
	}
   
	// Do a store copy if hDesStore is selected.
    if (pCertImportInfo->hDesStore && pCertImportInfo->fSelectedDesStore)
    {
        dwError = MoveItem(pCertImportInfo, pidsStatus);
        goto CLEANUP;
    }

    // We need to find a correct store on user's behalf.
    // Put the CTLs in the trust store.
    if (!(hTrustStore = CertOpenStore(CERT_STORE_PROV_SYSTEM_W,
                                      g_dwMsgAndCertEncodingType,
                                      NULL,
                                      dwCertOpenStoreFlags,
                                      L"trust")))
    {
        dwError = GetLastError();
        *pidsStatus = IDS_FAIL_OPEN_TRUST;
        goto CLEANUP;
    }

    if (0 != (dwError = AddCTLsToStore(pCertImportInfo->hwndParent,
                                       pCertImportInfo->hSrcStore,
                                       hTrustStore,
                                       pCertImportInfo->dwFlag & CRYPTUI_WIZ_NO_UI ? TRUE : FALSE,
                                       pidsStatus)))
    {
        goto CLEANUP;
    }

    // Put CRL in the CA store.
    if (!(hCAStore = CertOpenStore(CERT_STORE_PROV_SYSTEM_W,
                                   g_dwMsgAndCertEncodingType,
                                   NULL,
                                   dwCertOpenStoreFlags,
                                   L"ca")))
    {
        dwError = GetLastError();
        *pidsStatus = IDS_FAIL_OPEN_CA;
        goto CLEANUP;
    }

    if (0 != (dwError = AddCRLsToStore(pCertImportInfo->hwndParent,
                                       pCertImportInfo->hSrcStore,
                                       hCAStore,
                                       pCertImportInfo->dwFlag & CRYPTUI_WIZ_NO_UI ? TRUE : FALSE,
                                       pidsStatus)))
    {
        goto CLEANUP;
    }

    // Add the certificate with private key to my store; and the rest
    // to the ca, root, or addressbook store.
    while (pCertContext = CertEnumCertificatesInStore(pCertImportInfo->hSrcStore, pCertPre))
    {
        // Check if the certificate has the property on it.
        // Make sure the private key matches the certificate
        // Search for both machine key and user keys

        if (CertGetCertificateContextProperty(pCertContext,
                                              CERT_KEY_PROV_INFO_PROP_ID,
                                              NULL, &dwData) &&
            CryptFindCertificateKeyProvInfo(pCertContext,
                                            0,
                                            NULL))
        {
            // Open my store if necessary.
            if (!hMyStore)
            {
                if (!(hMyStore = CertOpenStore(CERT_STORE_PROV_SYSTEM_W,
                                               g_dwMsgAndCertEncodingType,
                                               NULL,
                                               dwCertOpenStoreFlags,
                                               L"my")))
                {
                    dwError = GetLastError();
                    *pidsStatus = IDS_FAIL_OPEN_MY;
                    goto CLEANUP;
                }
            }

            hCertStore = hMyStore;
        }
        // See if the certificate is self-signed.
        // If it is selfsigned, goes to the root store
        else if (TrustIsCertificateSelfSigned(pCertContext,
                                              pCertContext->dwCertEncodingType,
                                              0))
        {
            // DSIE: Bug 375649.
            // If EFS only cert, put it in TrustedPeople for self-signed cert,
            // otherwise, go to the root store.
            //
            if (IsEFSOnly(pCertContext))
            {
                // Open the TrustedPeople store if necessary.
                if (!hTrustedPeopleStore)
                {
                    if (!(hTrustedPeopleStore = CertOpenStore(CERT_STORE_PROV_SYSTEM_W,
                                                              g_dwMsgAndCertEncodingType,
                                                              NULL,
                                                              dwCertOpenStoreFlags,
                                                              L"trustedpeople")))
                    {
                        dwError = GetLastError();
                        *pidsStatus = IDS_FAIL_OPEN_TRUSTEDPEOPLE;
                        goto CLEANUP;
                    }
                }

                hCertStore = hTrustedPeopleStore;
            }
            else
            {
                // Open the root store if necessary.
                if (!hRootStore)
                {
                    if (!(hRootStore = CertOpenStore(CERT_STORE_PROV_SYSTEM_W,
                                                     g_dwMsgAndCertEncodingType,
                                                     NULL,
                                                     dwCertOpenStoreFlags,
                                                     L"root")))
                    {
                        dwError = GetLastError();
                        *pidsStatus = IDS_FAIL_OPEN_ROOT;
                        goto CLEANUP;
                    }
                }

                hCertStore = hRootStore;
            }

        }
        // Go to ca store if for ca cert, otherwise go to addressbook (other people) store.
        else if (IsCACert(pCertContext))
        {
            // Open the ca store if necessary.
            if (!hCertStore)
            {
                if (!(hCAStore = CertOpenStore(CERT_STORE_PROV_SYSTEM_W,
                                               g_dwMsgAndCertEncodingType,
                                               NULL,
                                               dwCertOpenStoreFlags,
                                               L"ca")))
                {
                    dwError = GetLastError();
                    *pidsStatus = IDS_FAIL_OPEN_CA;
                    goto CLEANUP;
                }
            }

            hCertStore = hCAStore;
        }
        else
        {
            // Open the other people store if necessary.
            if (!hAddressBookStore)
            {
                if(!(hAddressBookStore = CertOpenStore(CERT_STORE_PROV_SYSTEM_W,
                                                       g_dwMsgAndCertEncodingType,
                                                       NULL,
                                                       dwCertOpenStoreFlags,
                                                       L"addressbook")))
                {
                    dwError = GetLastError();
                    *pidsStatus = IDS_FAIL_OPEN_ADDRESSBOOK;
                    goto CLEANUP;
                }
            }

            hCertStore = hAddressBookStore;
        }
 
        //DSIE: Bug 22633.
        bCancelled = FALSE;
    
        if (0 != (dwError = AddContextToStore(CRYPTUI_WIZ_IMPORT_SUBJECT_CERT_CONTEXT,
                                              pCertImportInfo->hwndParent,
                                              (PVOID) pCertContext,
                                              pCertImportInfo->dwFlag & CRYPTUI_WIZ_NO_UI ? TRUE : FALSE,
                                              hCertStore)))
         {
            if (ERROR_CANCELLED == dwError)
            {
                bCancelled = TRUE;
            }
            else
            {
                // Check to see if there is alreay a read-only duplicated copy in the store?
                // If so, ignore the error.
                if (pFindCert = CertFindCertificateInStore(hCertStore,
                                                           g_dwMsgAndCertEncodingType,
                                                           0,
                                                           CERT_FIND_EXISTING,
                                                           pCertContext,
                                                           NULL))
                {
		            CertFreeCertificateContext(pFindCert);
                    pFindCert = NULL;
                }
                else if (hCertStore == hMyStore)
                {
                    *pidsStatus = IDS_FAIL_ADD_CERT_MY;
			        goto CLEANUP;
                }
                else if (hCertStore == hRootStore)
                {
                    *pidsStatus = IDS_FAIL_ADD_CERT_ROOT;
			        goto CLEANUP;
                }
                else if (hCertStore == hCAStore)
                {
                    *pidsStatus = IDS_FAIL_ADD_CERT_CA;
			        goto CLEANUP;
                }
                else if (hCertStore == hAddressBookStore)
                {
                    *pidsStatus = IDS_FAIL_ADD_CERT_OTHERPEOPLE;
			        goto CLEANUP;
                }
                else if (hCertStore == hTrustedPeopleStore)
                {
                    *pidsStatus = IDS_FAIL_ADD_CERT_TRUSTEDPEOPLE;
			        goto CLEANUP;
                }
            }

            dwError = 0;
        }

        pCertPre = pCertContext;
    }

    if (bCancelled)
    {
        dwError = ERROR_CANCELLED;
        *pidsStatus = IDS_IMPORT_CANCELLED;
    }
    else
    {
        *pidsStatus = IDS_IMPORT_SUCCEEDED;
    }

CLEANUP:

    if(pCertContext)
		CertFreeCertificateContext(pCertContext);

    if(hMyStore)
        CertCloseStore(hMyStore, 0);

    if(hCAStore)
        CertCloseStore(hCAStore, 0);

    if(hTrustStore)
        CertCloseStore(hTrustStore, 0);

    if(hRootStore)
        CertCloseStore(hRootStore, 0);

    if(hAddressBookStore)
        CertCloseStore(hAddressBookStore, 0);

    if(hTrustedPeopleStore)
        CertCloseStore(hTrustedPeopleStore, 0);

    return HRESULT_FROM_WIN32(dwError);
}


//--------------------------------------------------------------------------------
//
//get the bytes from the file name
//
//---------------------------------------------------------------------------------
HRESULT RetrieveBLOBFromFile(LPWSTR	pwszFileName,DWORD *pcb,BYTE **ppb)
{

	HRESULT	hr=E_FAIL;
	HANDLE	hFile=NULL;
    HANDLE  hFileMapping=NULL;

    DWORD   cbData=0;
    BYTE    *pbData=0;
	DWORD	cbHighSize=0;

	if(!pcb || !ppb || !pwszFileName)
		return E_INVALIDARG;

	*ppb=NULL;
	*pcb=0;

    if ((hFile = ExpandAndCreateFileU(pwszFileName,
                           GENERIC_READ,
                           FILE_SHARE_READ,
                           NULL,                   // lpsa
                           OPEN_EXISTING,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL)) == INVALID_HANDLE_VALUE)
    {
            hr=HRESULT_FROM_WIN32(GetLastError());
            goto CLEANUP;
    }

    if((cbData = GetFileSize(hFile, &cbHighSize)) == 0xffffffff)
    {
            hr=HRESULT_FROM_WIN32(GetLastError());
            goto CLEANUP;
    }

	//we do not handle file more than 4G bytes
	if(cbHighSize != 0)
	{
			hr=E_FAIL;
			goto CLEANUP;
	}

    //create a file mapping object
    if(NULL == (hFileMapping=CreateFileMapping(
                hFile,
                NULL,
                PAGE_READONLY,
                0,
                0,
                NULL)))
    {
            hr=HRESULT_FROM_WIN32(GetLastError());
            goto CLEANUP;
    }

    //create a view of the file
	if(NULL == (pbData=(BYTE *)MapViewOfFile(
		hFileMapping,
		FILE_MAP_READ,
		0,
		0,
		cbData)))
    {
            hr=HRESULT_FROM_WIN32(GetLastError());
            goto CLEANUP;
    }

	hr=S_OK;

	*pcb=cbData;
	*ppb=pbData;

CLEANUP:

	if(hFile)
		CloseHandle(hFile);

	if(hFileMapping)
		CloseHandle(hFileMapping);

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\ui\wizards\import.h ===
//--------------------------------------------------------------
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       import.h
//
//  Contents:   The private include file for cryptext.dll.
//
//  History:    5-11-1997 xiaohs   created
//
//--------------------------------------------------------------
#ifndef IMPORT_H
#define IMPORT_H


#ifdef __cplusplus
extern "C" {
#endif


DWORD       dwExpectedContentType= CERT_QUERY_CONTENT_FLAG_CERT |                
                CERT_QUERY_CONTENT_FLAG_CTL  |                 
                CERT_QUERY_CONTENT_FLAG_CRL  |                 
                CERT_QUERY_CONTENT_FLAG_SERIALIZED_STORE |      
                CERT_QUERY_CONTENT_FLAG_SERIALIZED_CERT  |      
                CERT_QUERY_CONTENT_FLAG_SERIALIZED_CTL   |      
                CERT_QUERY_CONTENT_FLAG_SERIALIZED_CRL   |      
                CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED     |      
                CERT_QUERY_CONTENT_FLAG_PFX;



#define     IMPORT_CONTENT_CERT     0x0001
#define     IMPORT_CONTENT_CRL      0x0002
#define     IMPORT_CONTENT_CTL      0x0004

//-----------------------------------------------------------------------
//  CERT_IMPORT_INFO
//
//
//  This struct contains everything you will ever need to the import
//  wizard
//------------------------------------------------------------------------
typedef struct _CERT_IMPORT_INFO
{
    HWND                hwndParent;
    DWORD               dwFlag;
    BOOL                fKnownDes;          //TRUE if we know the destination in advance
    BOOL                fKnownSrc;          
    LPWSTR              pwszFileName;       //used for display
    BOOL                fFreeFileName;
    CERT_BLOB           blobData;           //used only for PFX BLOBs
    DWORD               dwContentType;
    HCERTSTORE          hSrcStore;
    BOOL                fFreeSrcStore;
    HCERTSTORE          hDesStore;
    BOOL                fFreeDesStore;
    BOOL                fSelectedDesStore;
    HFONT               hBigBold;
    HFONT               hBold;
    DWORD               dwPasswordFlags;
    LPWSTR              pwszPassword;  
    BOOL                fPFX;
}CERT_IMPORT_INFO;

HRESULT I_ImportCertificate(CERT_IMPORT_INFO * pCertImportInfo, 
                            UINT             * pidsStatus);

#ifdef __cplusplus
}       // Balance extern "C" above
#endif


#endif  //IMPORT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\ui\wizards\mgrcert.cpp ===
//-------------------------------------------------------------
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       mgrcert.cpp
//
//  Contents:   The cpp file to implement cert mgr dialogue
//
//  History:    Feb-26-98 xiaohs   created
//
//--------------------------------------------------------------
#include    "wzrdpvk.h"
#include    "winuser.h"     //need this file for VK_DELETE
#include    "mgrcert.h"

//context sensitive help for the main dialogue
static const HELPMAP CertMgrMainHelpMap[] = {
    {IDC_CERTMGR_LIST,              IDH_CERTMGR_LIST},
    {IDC_CERTMGR_PURPOSE_COMBO,     IDH_CERTMGR_PURPOSE_COMBO},
    {IDC_CERTMGR_IMPORT,            IDH_CERTMGR_IMPORT},
    {IDC_CERTMGR_EXPORT,            IDH_CERTMGR_EXPORT},
    {IDC_CERTMGR_VIEW,              IDH_CERTMGR_VIEW},
    {IDC_CERTMGR_REMOVE,            IDH_CERTMGR_REMOVE},
    {IDC_CERTMGR_ADVANCE,           IDH_CERTMGR_ADVANCE},
    {IDC_CERTMGR_PURPOSE,           IDH_CERTMGR_FIELD_PURPOSE},
};

//context sensitive help for the main dialogue
static const HELPMAP CertMgrAdvHelpMap[] = {
    {IDC_CERTMGR_ADV_LIST,              IDH_CERTMGR_ADV_LIST},
    {IDC_CERTMGR_EXPORT_COMBO,          IDH_CERTMGR_EXPORT_COMBO},
    {IDC_CERTMGR_EXPORT_CHECK,          IDH_CERTMGR_EXPORT_CHECK},
};

// Primary store associated with each tab. Store to be imported into.
static const LPCWSTR rgpwszTabStoreName[] = {
    L"My",                  // 0
    L"AddressBook",         // 1
    L"Ca",                  // 2
    L"Root",                // 3
    L"TrustedPublisher",    // 4
};
#define TAB_STORE_NAME_CNT (sizeof(rgpwszTabStoreName) / \
                                sizeof(rgpwszTabStoreName[0]))

/*
// The following code is obsolete due to new cert chain building code
//----------------------------------------------------------------------------
// AddCertChainToStore
//----------------------------------------------------------------------------
BOOL    AddCertChainToStore(HCERTSTORE          hStore,
                            PCCERT_CONTEXT      pCertContext)
{
    BOOL            fResult=FALSE;
    HCERTSTORE      rghCertStores[20];
    DWORD           chStores;
    PCCERT_CONTEXT  pChildCert;
    PCCERT_CONTEXT  pParentCert;
    FILETIME        fileTime;
    DWORD           i;

    if(!hStore || !pCertContext)
        goto InvalidArgErr;


    GetSystemTimeAsFileTime(&fileTime);

    if (!TrustOpenStores(NULL, &chStores, rghCertStores, 0))
        goto TraceErr;


    pChildCert = pCertContext;
    while (NULL != (pParentCert = TrustFindIssuerCertificate(
                                        pChildCert,
                                        pChildCert->dwCertEncodingType,
                                        chStores,
                                        rghCertStores,
                                        &fileTime,
                                        NULL,
                                        NULL,
                                        0)))
    {
        CertAddCertificateContextToStore(hStore, pParentCert, CERT_STORE_ADD_NEW, NULL);

        if (pChildCert != pCertContext)
        {
            CertFreeCertificateContext(pChildCert);
        }

        pChildCert = pParentCert;
    }

    if (pChildCert != pCertContext)
    {
        CertFreeCertificateContext(pChildCert);
    }

    for (i=0; i<chStores; i++)
    {
        CertCloseStore(rghCertStores[i], 0);
    }

    fResult=TRUE;

CommonReturn:

    return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
TRACE_ERROR(TraceErr);
}   */



int WINAPI TabCtrl_InsertItemU(
    HWND            hwnd, 	
    int             iItem,
    const LPTCITEMW pitem		
    )
{
    TCITEMA TCItemA;
    int     iRet;
    DWORD   cb = 0;


    if (FIsWinNT())
    {
        return ((int)SendMessage(hwnd, TCM_INSERTITEMW, iItem, (LPARAM) pitem));
    }

    memcpy(&TCItemA, pitem, sizeof(TCITEMA));


    cb = WideCharToMultiByte(
                    0,                      // codepage
                    0,                      // dwFlags
                    pitem->pszText,
                    -1,
                    NULL,
                    0,
                    NULL,
                    NULL);

    
    if ((0 == cb) || (NULL == (TCItemA.pszText = (LPSTR) WizardAlloc(cb)))) 
    {
        return -1;  // this is the unsuccessful return code for this call 
    }

    if( 0 == (WideCharToMultiByte(
            0, 
            0, 
            pitem->pszText, 
            -1, 
            TCItemA.pszText,
            cb,
            NULL,
            NULL)))
    {
        WizardFree(TCItemA.pszText);
        return -1;
    }

    iRet = (int)SendMessage(hwnd, TCM_INSERTITEMA, iItem, (LPARAM) &TCItemA);

    WizardFree(TCItemA.pszText);

    return iRet;
}


//----------------------------------------------------------------------------
// This is the rundll32 entry point for start menu, administartive tools,
// CertMgr.
//----------------------------------------------------------------------------
STDAPI CryptUIStartCertMgr(HINSTANCE hinst, HINSTANCE hPrevInstance, LPSTR lpszCmdLine, int nCmdShow)
{

    CRYPTUI_CERT_MGR_STRUCT          CertMgrStruct;

    memset(&CertMgrStruct, 0, sizeof(CRYPTUI_CERT_MGR_STRUCT));
    CertMgrStruct.dwSize=sizeof(CRYPTUI_CERT_MGR_STRUCT);

    CryptUIDlgCertMgr(&CertMgrStruct);

    return S_OK;

}

//----------------------------------------------------------------------------
// GetFileContentFromCert
//----------------------------------------------------------------------------
BOOL    GetFileContentFromCert(DWORD            dwExportFormat,
                               BOOL             fExportChain,
                               PCCERT_CONTEXT   pCertContext,
                               BYTE             **ppBlob,
                               DWORD            *pdwSize)
{
    BOOL            fResult=FALSE;
    void            *pData=NULL;
    DWORD           dwSize=0;
    HCERTSTORE      hMemoryStore=NULL;
    CRYPT_DATA_BLOB Blob;
    HRESULT         hr=E_INVALIDARG;


    if(!ppBlob || !pdwSize || !pCertContext)
        goto InvalidArgErr;

    *ppBlob=NULL;
    *pdwSize=0;

    switch(dwExportFormat)
    {
        case    CRYPTUI_WIZ_EXPORT_FORMAT_DER:

                dwSize=pCertContext->cbCertEncoded;

                pData=WizardAlloc(dwSize);
                if(!pData)
                    goto MemoryErr;

                memcpy(pData, pCertContext->pbCertEncoded, dwSize);

            break;
        case    CRYPTUI_WIZ_EXPORT_FORMAT_BASE64:
                //base 64 encode the BLOB
                if(!CryptBinaryToStringA(
                        pCertContext->pbCertEncoded,
                        pCertContext->cbCertEncoded,
                        CRYPT_STRING_BASE64,
                        NULL,
                        &dwSize))
                {
                    hr = GetLastError();
                    goto SetErrVar;
                }

                pData=WizardAlloc(dwSize * sizeof(CHAR));
                if(!pData)
                    goto MemoryErr;

                if(!CryptBinaryToStringA(
                        pCertContext->pbCertEncoded,
                        pCertContext->cbCertEncoded,
                        CRYPT_STRING_BASE64,
                        (char *)pData,
                        &dwSize))
                {
                    hr = GetLastError();
                    goto SetErrVar;
                }


            break;
        case    CRYPTUI_WIZ_EXPORT_FORMAT_PKCS7:

                //open a memory store
                hMemoryStore=CertOpenStore(
                    CERT_STORE_PROV_MEMORY,
					g_dwMsgAndCertEncodingType,
					NULL,
					0,
					NULL);

                if(!hMemoryStore)
                    goto TraceErr;

                if(FALSE == fExportChain)
                {
                    if(!CertAddCertificateContextToStore(
                        hMemoryStore,
                        pCertContext,
                        CERT_STORE_ADD_REPLACE_EXISTING,
                        NULL))
                        goto TraceErr;
                }
                else
                {
                    if(!AddChainToStore(
					    hMemoryStore,
					    pCertContext,
					    0,
					    NULL,
					    FALSE,
					    NULL))
                        goto TraceErr;
                }


                //save the store to a PKCS#7
                Blob.cbData=0;
                Blob.pbData=NULL;

                if(!CertSaveStore(hMemoryStore,
                                 g_dwMsgAndCertEncodingType,
                                 CERT_STORE_SAVE_AS_PKCS7,
                                 CERT_STORE_SAVE_TO_MEMORY,
                                 &Blob,
                                 0))
                       goto TraceErr;

                dwSize=Blob.cbData;
                pData=WizardAlloc(dwSize);
                if(!pData)
                    goto MemoryErr;

                Blob.pbData=(BYTE *)pData;

                if(!CertSaveStore(hMemoryStore,
                                 g_dwMsgAndCertEncodingType,
                                 CERT_STORE_SAVE_AS_PKCS7,
                                 CERT_STORE_SAVE_TO_MEMORY,
                                 &Blob,
                                 0))
                       goto TraceErr;

            break;
        default:
                goto InvalidArgErr;
            break;
    }


    //set up the return value
    *pdwSize=dwSize;
    *ppBlob=(BYTE *)pData;
    pData=NULL;

    fResult=TRUE;

CommonReturn:

    if(hMemoryStore)
        CertCloseStore(hMemoryStore, 0);

     return fResult;

ErrorReturn:

    if(pData)
        WizardFree(pData);

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
SET_ERROR_VAR(SetErrVar, hr);
TRACE_ERROR(TraceErr);

}

//----------------------------------------------------------------------------
//  FreeFileNameAndContent
//----------------------------------------------------------------------------
BOOL    FreeFileNameAndContent( DWORD           dwCount,
                                LPWSTR          *prgwszFileName,
                                BYTE            **prgBlob,
                                DWORD           *prgdwSize)
{
    DWORD   dwIndex=0;

    if(prgwszFileName)
    {
        for(dwIndex=0; dwIndex < dwCount; dwIndex++)
        {
            if(prgwszFileName[dwIndex])
                WizardFree(prgwszFileName[dwIndex]);
        }

        WizardFree(prgwszFileName);
    }

    if(prgBlob)
    {
        for(dwIndex=0; dwIndex < dwCount; dwIndex++)
        {
            if(prgBlob[dwIndex])
                WizardFree(prgBlob[dwIndex]);
        }

        WizardFree(prgBlob);
    }

    if(prgdwSize)
        WizardFree(prgdwSize);

    return TRUE;
}


//----------------------------------------------------------------------------
// Get a valid friendly name of the certificate
//----------------------------------------------------------------------------
BOOL    GetValidFriendlyName(PCCERT_CONTEXT  pCertContext,
                        LPWSTR           *ppwszName)
{
    BOOL    fResult=FALSE;
    DWORD   dwChar=0;
    LPWSTR  pwsz=NULL;
    DWORD   dwIndex=0;


    if(!pCertContext || !ppwszName)
        return FALSE;

    //init
    *ppwszName=NULL;

    dwChar=0;

    if(CertGetCertificateContextProperty(
        pCertContext,
        CERT_FRIENDLY_NAME_PROP_ID,
        NULL,
        &dwChar) && (0!=dwChar))
    {
        pwsz=(LPWSTR)WizardAlloc(dwChar * sizeof(WCHAR));

        if(pwsz)
        {
           CertGetCertificateContextProperty(
                pCertContext,
                CERT_FRIENDLY_NAME_PROP_ID,
                pwsz,
                &dwChar);
        }
    }

    if(NULL==pwsz)
        goto CLEANUP;


    //make sure pwsz is a valid name
    if(0 == (dwChar=wcslen(pwsz)))
        goto CLEANUP;

    //the friendly name can not be spaces all the time
    for(dwIndex=0; dwIndex<dwChar; dwIndex++)
    {
        if(L' '!=pwsz[dwIndex])
            break;
    }

    if(dwIndex==dwChar)
        goto CLEANUP;   

    *ppwszName=WizardAllocAndCopyWStr(pwsz);

    if(NULL == (*ppwszName))
        goto CLEANUP;

    fResult=TRUE;

CLEANUP:

    if(pwsz)
        WizardFree(pwsz);

    return fResult;
}

//----------------------------------------------------------------------------
//  InvalidFileNameWch
//----------------------------------------------------------------------------
BOOL	InvalidFileNameWch(WCHAR wChar)
{
	if((wChar == L'\\') || (wChar == L':') || (wChar == L'/') || (wChar == L'*') || (wChar == L'|') || (wChar == L';'))
		return TRUE;

	return FALSE;
}

//----------------------------------------------------------------------------
//  Build the filenames and their content based on the export selection
//----------------------------------------------------------------------------
BOOL    GetFileNameFromCert(DWORD               dwExportFormat,
                            PCCERT_CONTEXT      pCertContext,
                            LPWSTR              pwszFileName)
{
    BOOL            fResult=FALSE;
    WCHAR           wszCertificate[MAX_TITLE_LENGTH];
    WCHAR           wszExt[MAX_TITLE_LENGTH];
    LPWSTR          pwszName=NULL;
    DWORD           dwChar=0;
    UINT            idsExt=0;
    LPWSTR          pwszFirstPart=NULL;
    LPWSTR          pwszFriendlyName=NULL;
	DWORD			dwIndex=0;

    if(!pCertContext || !pwszFileName)
        goto InvalidArgErr;

    //init
    *pwszFileName='\0';


    //get the friendly name for the certificate
    if(!GetValidFriendlyName(pCertContext,&pwszFriendlyName))
    {
        //if failed, we use subject
        //Subject
        dwChar=CertGetNameStringW(
            pCertContext,
            CERT_NAME_SIMPLE_DISPLAY_TYPE,
            0,
            NULL,
            NULL,
            0);

        if ((dwChar > 1) && (NULL != (pwszName = (LPWSTR)WizardAlloc(dwChar * sizeof(WCHAR)))))
        {

            if(!CertGetNameStringW(
                pCertContext,
                CERT_NAME_SIMPLE_DISPLAY_TYPE,
                0,
                NULL,
                pwszName,
                dwChar))
                goto GetNameErr;

            pwszFirstPart=pwszName;
        }
        else
        {
            //load the string for Certificate
            if(!LoadStringU(g_hmodThisDll, IDS_CERTIFICATE, wszCertificate, MAX_TITLE_LENGTH))
                goto LoadStringErr;

            pwszFirstPart=wszCertificate;
        }
    }
    else
        pwszFirstPart=pwszFriendlyName;

    //determine the extension for the file
    switch(dwExportFormat)
    {
        case    CRYPTUI_WIZ_EXPORT_FORMAT_DER:
                idsExt=IDS_CER;
            break;
        case    CRYPTUI_WIZ_EXPORT_FORMAT_BASE64:
                idsExt=IDS_CER;
            break;
        case    CRYPTUI_WIZ_EXPORT_FORMAT_PKCS7:
                idsExt=IDS_P7C;
            break;
        default:
                idsExt=IDS_CER;
            break;
    }

    //load the string for Certificate
    if(!LoadStringU(g_hmodThisDll, idsExt, wszExt, MAX_TITLE_LENGTH))
            goto LoadStringErr;

    //determine the max length of the file name
    dwChar = wcslen(pwszFirstPart) > (CERTMGR_MAX_FILE_NAME - wcslen(wszExt) -1) ?
            (CERTMGR_MAX_FILE_NAME - wcslen(wszExt) -1) : wcslen(pwszFirstPart);

    wcsncpy(pwszFileName, pwszFirstPart, dwChar);

    *(pwszFileName + dwChar)=L'\0';
                              
    wcscat(pwszFileName, wszExt);

	//now, we replace the invalid file characters : ; /  \
	//with space

	dwChar = wcslen(pwszFileName);

	for(dwIndex =0; dwIndex<dwChar; dwIndex++)
	{
		if(InvalidFileNameWch(pwszFileName[dwIndex]))
			pwszFileName[dwIndex]=L'_';
	}

    fResult=TRUE;

CommonReturn:

    if(pwszName)
        WizardFree(pwszName);

    if(pwszFriendlyName)
        WizardFree(pwszFriendlyName);

    return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
TRACE_ERROR(GetNameErr);
TRACE_ERROR(LoadStringErr);
}


//----------------------------------------------------------------------------
//  Build the filenames and their content based on the export selection
//----------------------------------------------------------------------------
BOOL    GetFileNameAndContent(LPNMLISTVIEW      pvmn,
                                HWND            hwndControl,
                                DWORD           dwExportFormat,
                                BOOL            fExportChain,
                                DWORD           *pdwCount,
                                LPWSTR          **pprgwszFileName,
                                BYTE            ***pprgBlob,
                                DWORD           **pprgdwSize)
{

    BOOL            fResult=FALSE;
    DWORD           dwCount=0;
    DWORD           dwIndex=0;
    LVITEM          lvItem;
    int             iIndex=0;
    PCCERT_CONTEXT  pCertContext=NULL;

    if(!pvmn || !hwndControl || !pdwCount || !pprgwszFileName || !pprgBlob || !pprgdwSize)
        goto InvalidArgErr;

    //init
    *pdwCount=0;
    *pprgwszFileName=NULL;
    *pprgBlob=NULL;
    *pprgdwSize=NULL;

    //get the count of selected certificates
    dwCount=ListView_GetSelectedCount(hwndControl);

    if( 0 == dwCount)
        goto InvalidArgErr;

    //allocate memory
    if((*pprgwszFileName)=(LPWSTR *)WizardAlloc(sizeof(LPWSTR) * dwCount))
        memset(*pprgwszFileName, 0,  sizeof(LPWSTR) * dwCount);

    if((*pprgBlob)=(BYTE **)WizardAlloc(sizeof(BYTE *)*  dwCount))
        memset(*pprgBlob, 0,        sizeof(BYTE *)* dwCount);

    if((*pprgdwSize)=(DWORD *)WizardAlloc(sizeof(DWORD) * dwCount))
        memset(*pprgdwSize, 0,      sizeof(DWORD) * dwCount);

    if(!(*pprgwszFileName) || !(*pprgBlob) || !(*pprgdwSize))
        goto MemoryErr;

    //get the selected certificate
    memset(&lvItem, 0, sizeof(LV_ITEM));
    lvItem.mask=LVIF_PARAM;

    iIndex=-1;

    for(dwIndex=0; dwIndex < dwCount; dwIndex++)
    {

        iIndex=ListView_GetNextItem(hwndControl, 		
                                        iIndex, 		
                                        LVNI_SELECTED);

        if(-1 == iIndex)
            break;

        lvItem.iItem=iIndex;

        if(!ListView_GetItem(hwndControl,
                         &lvItem))
            goto ListViewErr;

        pCertContext=(PCCERT_CONTEXT)(lvItem.lParam);

        if(!pCertContext)
            goto InvalidArgErr;

        //get the file name of the ceritificate
        (*pprgwszFileName)[dwIndex]=(LPWSTR)WizardAlloc(sizeof(WCHAR) * CERTMGR_MAX_FILE_NAME);

        if(!((*pprgwszFileName)[dwIndex]))
            goto MemoryErr;

        if(!GetFileNameFromCert(dwExportFormat,
                                pCertContext,
                                (*pprgwszFileName)[dwIndex]))
            goto TraceErr;


        //get the BLOB for the certificate
        if(!GetFileContentFromCert(dwExportFormat, fExportChain, pCertContext,
                                &((*pprgBlob)[dwIndex]),
                                &((*pprgdwSize)[dwIndex])))
            goto TraceErr;

    }

    *pdwCount=dwIndex;

    fResult=TRUE;

CommonReturn:


    return fResult;

ErrorReturn:

    if(pdwCount && pprgwszFileName && pprgBlob && pprgdwSize)
    {
        FreeFileNameAndContent(*pdwCount, *pprgwszFileName, *pprgBlob, *pprgdwSize);
        *pdwCount=0;
        *pprgwszFileName=NULL;
        *pprgBlob=NULL;
        *pprgdwSize=NULL;
    }

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
TRACE_ERROR(ListViewErr);
TRACE_ERROR(TraceErr);
}


//----------------------------------------------------------------------------
//  Get all the selected certificates and do some work vased on dwFlag
//----------------------------------------------------------------------------
BOOL    GetAllSelectedItem(HWND         hWndControl,
                           DWORD        dwFlag,
                           void         *pData)
{
    BOOL            fResult=FALSE;
    BOOL            fCanDelete=TRUE;
    HCERTSTORE      *phCertStore=NULL;
    PCCERT_CONTEXT  pCertContext=NULL;
    int             iIndex=0;
    LVITEM          lvItem;
    DWORD           dwData=0;
    DWORD           dwAccessFlag=0;

    if(!hWndControl)
        goto CLEANUP;

    if((ALL_SELECTED_CAN_DELETE == dwFlag) ||
       (ALL_SELECTED_COPY == dwFlag))
    {
        if(NULL == pData)
            goto CLEANUP;
    }

    //get the selected certificate
    memset(&lvItem, 0, sizeof(LV_ITEM));
    lvItem.mask=LVIF_PARAM;


    iIndex=-1;

    //loop through all the selected items
    while(-1 != (iIndex=ListView_GetNextItem(
                                        hWndControl, 		
                                        iIndex, 		
                                        LVNI_SELECTED		
                                        )))
    {
        lvItem.iItem=iIndex;

        if(!ListView_GetItem(hWndControl,
                         &lvItem))
            goto CLEANUP;

        pCertContext=(PCCERT_CONTEXT)(lvItem.lParam);

        if(!pCertContext)
            goto CLEANUP;

        switch(dwFlag)
        {
            case ALL_SELECTED_CAN_DELETE:
                    dwData=sizeof(dwAccessFlag);

                    //as far as one of the selected items can not be deleted,
                    //the whole selection can not be deleted
                    if( CertGetCertificateContextProperty(
                        pCertContext,
                        CERT_ACCESS_STATE_PROP_ID,
                        &dwAccessFlag,
                        &dwData))
                    {
                        if(0==(CERT_ACCESS_STATE_WRITE_PERSIST_FLAG & dwAccessFlag))
                            fCanDelete=FALSE;
                    }

                break;
            case ALL_SELECTED_DELETE:
                    CertDeleteCertificateFromStore(
                        CertDuplicateCertificateContext(pCertContext));
                break;
            case ALL_SELECTED_COPY:
                    CertAddCertificateContextToStore(
                        *((HCERTSTORE *)pData),
                        pCertContext,
                        CERT_STORE_ADD_ALWAYS,
                        NULL);
                break;
            default:
                    goto CLEANUP;
                break;
        }
    }

    //copy the can delete flag
     if(ALL_SELECTED_CAN_DELETE == dwFlag)
        *((BOOL *)pData)=fCanDelete;


     fResult=TRUE;

CLEANUP:


    return fResult;
}


//----------------------------------------------------------------------------
//  Check to see if <advanced> is selected
//----------------------------------------------------------------------------
BOOL    IsAdvancedSelected(HWND    hwndDlg)
{
    BOOL        fSelected=FALSE;
    int         iIndex=0;
    LPWSTR      pwszOIDName=NULL;
    WCHAR       wszText[MAX_STRING_SIZE];

    if(!hwndDlg)
        goto CLEANUP;

    //get the selected string from the combo box
    iIndex=(int)SendDlgItemMessage(hwndDlg, IDC_CERTMGR_PURPOSE_COMBO,
            CB_GETCURSEL, 0, 0);

    if(CB_ERR==iIndex)
        goto CLEANUP;

    //get the selected purpose name
    if(CB_ERR == SendDlgItemMessageU_GETLBTEXT(hwndDlg,
                IDC_CERTMGR_PURPOSE_COMBO,
              iIndex, &pwszOIDName))
        goto CLEANUP;

    //check to see if <advanced> is selected
    if(!LoadStringU(g_hmodThisDll, IDS_OID_ADVANCED,
                    wszText, MAX_STRING_SIZE))
        goto CLEANUP;

    //check if advanced option is selected
    if(0 == _wcsicmp(pwszOIDName, wszText))
        fSelected=TRUE;

CLEANUP:

    if(pwszOIDName)
        WizardFree(pwszOIDName);

    return fSelected;
}

//----------------------------------------------------------------------------
//  Update the window title based on the tab that user has selected
//----------------------------------------------------------------------------
BOOL    RefreshWindowTitle(HWND                         hwndDlg,
                           PCRYPTUI_CERT_MGR_STRUCT     pCertMgrStruct)
{
    BOOL    fResult=FALSE;
    WCHAR   wszTitle[MAX_TITLE_LENGTH];
    WCHAR   wszText[MAX_TITLE_LENGTH];
    LPWSTR  pwszTitle=NULL;
    LPWSTR  pwszText=NULL;
    UINT    ids=0;
    DWORD   dwTabIndex=0;

    if(!hwndDlg || !pCertMgrStruct)
        goto CLEANUP;

    //get the string ids based on the tab selected
    if (pCertMgrStruct->dwFlags & CRYPTUI_CERT_MGR_SINGLE_TAB_FLAG)
        dwTabIndex = pCertMgrStruct->dwFlags & CRYPTUI_CERT_MGR_TAB_MASK;
    else if(-1 == (dwTabIndex=TabCtrl_GetCurSel(GetDlgItem(hwndDlg, IDC_CERTMGR_TAB))))
        goto CLEANUP;

    //open the correct store based on the tab selected
    switch (dwTabIndex)
    {
        case 0:
                ids=IDS_TAB_PERSONAL;
            break;
        case 1:
                ids=IDS_TAB_OTHER;
            break;
        case 2:
                ids=IDS_TAB_CA;
            break;
        case 3:
                ids=IDS_TAB_ROOT;
            break;
        case 4:
                ids=IDS_TAB_PUBLISHER;
            break;
        default:
                goto CLEANUP;
            break;
    }

    //load the string for tabs
    if(!LoadStringU(g_hmodThisDll, ids, wszText, MAX_TITLE_LENGTH))
        goto CLEANUP;

    //get the window string
    if(pCertMgrStruct->pwszTitle)
        pwszTitle=(LPWSTR)(pCertMgrStruct->pwszTitle);
    else
    {
        if(!LoadStringU(g_hmodThisDll, IDS_CERT_MGR_TITLE, wszTitle, MAX_TITLE_LENGTH))
            goto CLEANUP;

        pwszTitle=wszTitle;
    }

    pwszText=(LPWSTR)WizardAlloc(sizeof(WCHAR) * (
        wcslen(pwszTitle) + wcslen(wszText) + wcslen(L" - ") +1));

    if(!pwszText)
        goto CLEANUP;

    //concatenate the window title as: "Certifiate Manager - Personal"
    *pwszText=L'\0';

    wcscat(pwszText, pwszTitle);

    wcscat(pwszText, L" - ");

    wcscat(pwszText, wszText);

    //set the window text
    SetWindowTextU(hwndDlg, pwszText);

    fResult=TRUE;


CLEANUP:

    if(pwszText)
        WizardFree(pwszText);

    return fResult;
}

//----------------------------------------------------------------------------
//  Check to see if the certificate's key usage is the same as
//  the one selected on the combo box
//
//----------------------------------------------------------------------------
BOOL    IsValidUsage(PCCERT_CONTEXT     pCertContext,
                     HWND               hwndDlg,
                     CERT_MGR_INFO      *pCertMgrInfo)
{
    BOOL        fValidUsage=FALSE;
    int         iIndex=0;
    LPWSTR      pwszOIDName=NULL;
    LPSTR       pszOID=NULL;
    WCHAR       wszText[MAX_STRING_SIZE];
    BOOL        fAdvanced=FALSE;
    DWORD       dwIndex=0;
    DWORD       dwAdvIndex=0;
    int         cNumOID=0;
    LPSTR       *rgOID=NULL;
    DWORD       cbOID=0;

    //input check
    if(!pCertContext || !hwndDlg || !pCertMgrInfo)
        return FALSE;

    //get the selected string from the combo box
    iIndex=(int)SendDlgItemMessage(hwndDlg, IDC_CERTMGR_PURPOSE_COMBO,
            CB_GETCURSEL, 0, 0);

    if(CB_ERR==iIndex)
        goto CLEANUP;

    //get the selected purpose name
    if(CB_ERR == SendDlgItemMessageU_GETLBTEXT(hwndDlg,
                IDC_CERTMGR_PURPOSE_COMBO,
              iIndex, &pwszOIDName))
        goto CLEANUP;

    //check to see if <all> is selected
    if(!LoadStringU(g_hmodThisDll, IDS_OID_ALL,
                    wszText, MAX_STRING_SIZE))
        goto CLEANUP;

    if(0 == _wcsicmp(pwszOIDName, wszText))
    {
        fValidUsage=TRUE;
        goto CLEANUP;
    }

    //check to see if <advanced> is selected
    if(!LoadStringU(g_hmodThisDll, IDS_OID_ADVANCED,
                    wszText, MAX_STRING_SIZE))
        goto CLEANUP;

    //check if advanced option is selected
    if(0 == _wcsicmp(pwszOIDName, wszText))
        fAdvanced=TRUE;


    if(FALSE==fAdvanced)
    {
        //determin the OID for the selected usage name
        for(dwIndex=0; dwIndex<pCertMgrInfo->dwOIDInfo; dwIndex++)
        {
            if(0==_wcsicmp(pwszOIDName,
                (pCertMgrInfo->rgOIDInfo[dwIndex]).pwszName))
               pszOID=(pCertMgrInfo->rgOIDInfo[dwIndex]).pszOID;
        }

        //we are in trouble if we can not find the maching OID based on
        //the name selected
        if(NULL==pszOID)
            goto CLEANUP;
    }

    //get the certificate's list of usage OIDs
    //get the OIDs from the cert
    if(!CertGetValidUsages(
        1,
        &pCertContext,
        &cNumOID,
        NULL,
        &cbOID))
        goto CLEANUP;

    rgOID=(LPSTR *)WizardAlloc(cbOID);

    if(NULL==rgOID)
        goto CLEANUP;

    if(!CertGetValidUsages(
        1,
        &pCertContext,
        &cNumOID,
        rgOID,
        &cbOID))
        goto CLEANUP;

    //-1 means the certiifcate is good for everything
    if(-1==cNumOID)
    {
        fValidUsage=TRUE;
        goto CLEANUP;
    }

    //we need to decide if the certificate include the selected
    //usage
    if(FALSE==fAdvanced)
    {
        for(dwIndex=0; dwIndex<(DWORD)cNumOID; dwIndex++)
        {
            if(0==_stricmp(pszOID,
                           rgOID[dwIndex]))
            {
                fValidUsage=TRUE;
                goto CLEANUP;
            }
        }
    }
    else
    {
        //the certificates have to have advanced OIDs
        for(dwAdvIndex=0; dwAdvIndex<pCertMgrInfo->dwOIDInfo; dwAdvIndex++)
        {
            //only interested in the OIDs with advanced marked
            if(TRUE==(pCertMgrInfo->rgOIDInfo[dwAdvIndex]).fSelected)
            {
                for(dwIndex=0; dwIndex<(DWORD)cNumOID; dwIndex++)
                {
                    if(0==_stricmp((pCertMgrInfo->rgOIDInfo[dwAdvIndex]).pszOID,
                                   rgOID[dwIndex]))
                    {
                        fValidUsage=TRUE;
                        goto CLEANUP;
                    }
                }
            }
        }


    }

    //now, we have examed all the possibilities
    fValidUsage=FALSE;

CLEANUP:

    if(pwszOIDName)
        WizardFree(pwszOIDName);

    if(rgOID)
        WizardFree(rgOID);

    return fValidUsage;

}


//----------------------------------------------------------------------------
//  Check to see if the certificate is an end-entity cert
//
//----------------------------------------------------------------------------
BOOL    IsCertificateEndEntity(PCCERT_CONTEXT   pCertContext)
{
    PCERT_EXTENSION                     pCertExt=NULL;
    BOOL                                fEndEntity=FALSE;
    DWORD                               cbData=0;
    PCERT_BASIC_CONSTRAINTS_INFO        pBasicInfo=NULL;
    PCERT_BASIC_CONSTRAINTS2_INFO       pBasicInfo2=NULL;

    if(!pCertContext)
        return FALSE;

    //get the extension szOID_BASIC_CONSTRAINTS2
    pCertExt=CertFindExtension(
              szOID_BASIC_CONSTRAINTS2,
              pCertContext->pCertInfo->cExtension,
              pCertContext->pCertInfo->rgExtension);


    if(pCertExt)
    {
        //deocde the extension
        cbData=0;

        if(!CryptDecodeObject(
                X509_ASN_ENCODING,
                X509_BASIC_CONSTRAINTS2,
                pCertExt->Value.pbData,
                pCertExt->Value.cbData,
                0,
                NULL,
                &cbData))
            goto CLEANUP;

       pBasicInfo2=(PCERT_BASIC_CONSTRAINTS2_INFO)WizardAlloc(cbData);

       if(NULL==pBasicInfo2)
           goto CLEANUP;

        if(!CryptDecodeObject(
                X509_ASN_ENCODING,
                X509_BASIC_CONSTRAINTS2,
                pCertExt->Value.pbData,
                pCertExt->Value.cbData,
                0,
                pBasicInfo2,
                &cbData))
            goto CLEANUP;

        if(pBasicInfo2->fCA)
            fEndEntity=FALSE;
        else
            fEndEntity=TRUE;
    }
    else
    {
        //get the extension szOID_BASIC_CONSTRAINTS
        pCertExt=CertFindExtension(
                  szOID_BASIC_CONSTRAINTS,
                  pCertContext->pCertInfo->cExtension,
                  pCertContext->pCertInfo->rgExtension);

        if(pCertExt)
        {
            //deocde the extension
            cbData=0;

            if(!CryptDecodeObject(
                    X509_ASN_ENCODING,
                    X509_BASIC_CONSTRAINTS,
                    pCertExt->Value.pbData,
                    pCertExt->Value.cbData,
                    0,
                    NULL,
                    &cbData))
                goto CLEANUP;

           pBasicInfo=(PCERT_BASIC_CONSTRAINTS_INFO)WizardAlloc(cbData);

           if(NULL==pBasicInfo)
               goto CLEANUP;

            if(!CryptDecodeObject(
                    X509_ASN_ENCODING,
                    X509_BASIC_CONSTRAINTS,
                    pCertExt->Value.pbData,
                    pCertExt->Value.cbData,
                    0,
                    pBasicInfo,
                    &cbData))
                goto CLEANUP;

            if(0 == pBasicInfo->SubjectType.cbData)
            {
                fEndEntity=FALSE;
            }
            else
            {

                if(CERT_END_ENTITY_SUBJECT_FLAG & (pBasicInfo->SubjectType.pbData[0]))
                    fEndEntity=TRUE;
                else
                {
                    if(CERT_CA_SUBJECT_FLAG & (pBasicInfo->SubjectType.pbData[0]))
                      fEndEntity=FALSE;
                }
            }
        }
    }


CLEANUP:

    if(pBasicInfo)
        WizardFree(pBasicInfo);

    if(pBasicInfo2)
        WizardFree(pBasicInfo2);

    return fEndEntity;

}

//----------------------------------------------------------------------------
//  Add certificate to the pCertMgrInfo
//
//----------------------------------------------------------------------------
BOOL    AddCertToCertMgrInfo(PCCERT_CONTEXT        pCertContext,
                          CERT_MGR_INFO         *pCertMgrInfo)
{


    pCertMgrInfo->prgCertContext=(PCCERT_CONTEXT *)WizardRealloc(
        pCertMgrInfo->prgCertContext,
        sizeof(PCCERT_CONTEXT *)*(pCertMgrInfo->dwCertCount +1));

    if(NULL==pCertMgrInfo->prgCertContext)
    {
        pCertMgrInfo->dwCertCount=0;
        return FALSE;
    }


    pCertMgrInfo->prgCertContext[pCertMgrInfo->dwCertCount]=pCertContext;

    pCertMgrInfo->dwCertCount++;

    return TRUE;
}


//----------------------------------------------------------------------------
//  Once a certificate is selected, refresh the static windows that display
//  the details of the certificate
//
//----------------------------------------------------------------------------
BOOL    RefreshCertDetails(HWND              hwndDlg,
                           PCCERT_CONTEXT    pCertContext)
{
    BOOL            fResult=FALSE;
    DWORD           dwChar=0;
    WCHAR           wszNone[MAX_TITLE_LENGTH];

    LPWSTR          pwszName=NULL;

    if(!hwndDlg || !pCertContext)
        return FALSE;

    //load the string for NONE
    if(!LoadStringU(g_hmodThisDll, IDS_NONE, wszNone, MAX_TITLE_LENGTH))
        wszNone[0]=L'\0';

    //Subject
   /* dwChar=CertGetNameStringW(
        pCertContext,
        CERT_NAME_SIMPLE_DISPLAY_TYPE,
        0,
        NULL,
        NULL,
        0);

    if ((dwChar != 0) && (NULL != (pwszName = (LPWSTR)WizardAlloc(dwChar * sizeof(WCHAR)))))
    {

        CertGetNameStringW(
            pCertContext,
            CERT_NAME_SIMPLE_DISPLAY_TYPE,
            0,
            NULL,
            pwszName,
            dwChar);

        SetDlgItemTextU(hwndDlg, IDC_CERTMGR_SUBJECT, pwszName);

    }
    else
    {
        SetDlgItemTextU(hwndDlg, IDC_CERTMGR_SUBJECT, wszNone);
    }


    //WizardFree the memory
    if(pwszName)
    {
        WizardFree(pwszName);
        pwszName=NULL;
    }

    //Issuer
    dwChar=CertGetNameStringW(
        pCertContext,
        CERT_NAME_SIMPLE_DISPLAY_TYPE,
        CERT_NAME_ISSUER_FLAG,
        NULL,
        NULL,
        0);

    if ((dwChar != 0) && (NULL != (pwszName = (LPWSTR)WizardAlloc(dwChar * sizeof(WCHAR)))))
    {

        CertGetNameStringW(
            pCertContext,
            CERT_NAME_SIMPLE_DISPLAY_TYPE,
            CERT_NAME_ISSUER_FLAG,
            NULL,
            pwszName,
            dwChar);

        SetDlgItemTextU(hwndDlg, IDC_CERTMGR_ISSUER, pwszName);

    }
    else
        SetDlgItemTextU(hwndDlg, IDC_CERTMGR_ISSUER, wszNone);


    //free the memory
    if(pwszName)
    {
        WizardFree(pwszName);
        pwszName=NULL;
    }



    //Expiration
    if(WizardFormatDateString(&pwszName,pCertContext->pCertInfo->NotAfter, FALSE))
        SetDlgItemTextU(hwndDlg, IDC_CERTMGR_EXPIRE, pwszName);
    else
        SetDlgItemTextU(hwndDlg, IDC_CERTMGR_EXPIRE, wszNone);


    //free the memory
    if(pwszName)
    {
        WizardFree(pwszName);
        pwszName=NULL;
    }   */

    //purpose
    if(MyFormatEnhancedKeyUsageString(&pwszName,pCertContext, FALSE, FALSE))
        
    {
        SetDlgItemTextU(hwndDlg, IDC_CERTMGR_PURPOSE, pwszName);
    }
    


    //free the memory
    if(pwszName)
    {
        WizardFree(pwszName);
        pwszName=NULL;
    }

    //friendly name
  /*  dwChar=0;

    if(CertGetCertificateContextProperty(
        pCertContext,
        CERT_FRIENDLY_NAME_PROP_ID,
        NULL,
        &dwChar) && (0!=dwChar))
    {
        pwszName = (LPWSTR)WizardAlloc(dwChar * sizeof(WCHAR));

        if(pwszName)
        {
           CertGetCertificateContextProperty(
                pCertContext,
                CERT_FRIENDLY_NAME_PROP_ID,
                pwszName,
                &dwChar);

        SetDlgItemTextU(hwndDlg, IDC_CERTMGR_NAME, pwszName);
        }
        else
            SetDlgItemTextU(hwndDlg, IDC_CERTMGR_NAME, wszNone);
    }
    else
        SetDlgItemTextU(hwndDlg, IDC_CERTMGR_NAME, wszNone);


    //free the memory
    if(pwszName)
    {
        WizardFree(pwszName);
        pwszName=NULL;
    }   */


    return TRUE;
}



//----------------------------------------------------------------------------
//  Add certificate to the ListView
//
//----------------------------------------------------------------------------
BOOL    AddCertToListView(HWND              hwndControl,
                      PCCERT_CONTEXT    pCertContext,
                      int               iItem)
{
    BOOL            fResult=FALSE;
    LV_ITEMW        lvItem;
    DWORD           dwChar=0;
    WCHAR           wszNone[MAX_TITLE_LENGTH];

    LPWSTR          pwszName=NULL;

    if(!hwndControl || !pCertContext)
        return FALSE;

     // set up the fields in the list view item struct that don't change from item to item
    lvItem.mask = LVIF_TEXT | LVIF_STATE | LVIF_IMAGE |LVIF_PARAM ;
    lvItem.state = 0;
    lvItem.stateMask = 0;
    lvItem.iItem=iItem;
    lvItem.iSubItem=0;
    lvItem.iImage = 0;
    lvItem.lParam = (LPARAM)pCertContext;


    //load the string for NONE
    if(!LoadStringU(g_hmodThisDll, IDS_NONE, wszNone, MAX_TITLE_LENGTH))
        wszNone[0]=L'\0';

    //Subject
    if (NULL == (pwszName = GetDisplayNameString(pCertContext, 0)))
    {
        lvItem.pszText=wszNone;
        ListView_InsertItemU(hwndControl, &lvItem);
    }
    else
    {
        lvItem.pszText=pwszName;
        ListView_InsertItemU(hwndControl, &lvItem);
        free(pwszName);
        pwszName = NULL;
    }

    //Issuer
    lvItem.iSubItem++;

    if (NULL == (pwszName = GetDisplayNameString(pCertContext, CERT_NAME_ISSUER_FLAG)))
    {
        ListView_SetItemTextU(hwndControl, lvItem.iItem, lvItem.iSubItem, wszNone);
    }
    else
    {
        ListView_SetItemTextU(hwndControl, lvItem.iItem, lvItem.iSubItem, pwszName);
        free(pwszName);
        pwszName = NULL;
    }

    //Expiration
    lvItem.iSubItem++;

    if(WizardFormatDateString(&pwszName,pCertContext->pCertInfo->NotAfter, FALSE))
    {

       ListView_SetItemTextU(hwndControl, lvItem.iItem, lvItem.iSubItem,
                      pwszName);

    }
    else
        ListView_SetItemTextU(hwndControl, lvItem.iItem, lvItem.iSubItem,
                       wszNone);

    //free the memory
    if(pwszName)
    {
        WizardFree(pwszName);
        pwszName=NULL;
    }

    //purpose
    /*lvItem.iSubItem++;

    if(WizardFormatEnhancedKeyUsageString(&pwszName,pCertContext, FALSE, FALSE) &&
        L'\0' != *pwszName)
    {

       ListView_SetItemTextU(hwndControl, lvItem.iItem, lvItem.iSubItem,
                      pwszName);

    }
    else
        ListView_SetItemTextU(hwndControl, lvItem.iItem, lvItem.iSubItem,
                       wszNone);

    //free the memory
    if(pwszName)
    {
        WizardFree(pwszName);
        pwszName=NULL;
    }               */

    //friendly name
    lvItem.iSubItem++;

    dwChar=0;

    if(CertGetCertificateContextProperty(
        pCertContext,
        CERT_FRIENDLY_NAME_PROP_ID,
        NULL,
        &dwChar) && (0!=dwChar))
    {
        pwszName = (LPWSTR)WizardAlloc(dwChar * sizeof(WCHAR));

        if(pwszName)
        {
           CertGetCertificateContextProperty(
                pCertContext,
                CERT_FRIENDLY_NAME_PROP_ID,
                pwszName,
                &dwChar);

            ListView_SetItemTextU(hwndControl, lvItem.iItem, lvItem.iSubItem,
                      pwszName);
        }
        else
            ListView_SetItemTextU(hwndControl, lvItem.iItem, lvItem.iSubItem,
                       wszNone);
    }
    else
    {
        ListView_SetItemTextU(hwndControl, lvItem.iItem, lvItem.iSubItem,
                       wszNone);
    }

    //free the memory
    if(pwszName)
    {
        WizardFree(pwszName);
        pwszName=NULL;
    }


    return TRUE;
}


//-----------------------------------------------------------------------
// Based on the tab(store) and the intended purpose selected,
// find the correct certificates and refresh the list view
// Criteria:
//      Tab 0:  My Store with private key
//      Tab 1:  Ca Store's end-entity cert and the "ADDRESSBOOK" store
//      Tab 2:  Ca Store's CA certs
//      Tab 3:  Root store's self signed certs
//      Tab 4:  Trusted publisher certs
//-----------------------------------------------------------------------
void    RefreshCertListView(HWND            hwndDlg,
                            CERT_MGR_INFO   *pCertMgrInfo)
{
    HWND            hwndControl=NULL;
    DWORD           dwIndex=0;
    DWORD           dwTabIndex=0;
    HCERTSTORE      rghCertStore[]={NULL, NULL};
    DWORD           dwStoreCount=0;
    PCCERT_CONTEXT  pCurCertContext=NULL;
    PCCERT_CONTEXT  pPreCertContext=NULL;
    BOOL            fValidCert=FALSE;
    DWORD           cbData=0;
    DWORD           dwSortParam=0;
    PCCRYPTUI_CERT_MGR_STRUCT pCertMgrStruct = NULL;


    HCURSOR                 hPreCursor=NULL;
    HCURSOR                 hWinPreCursor=NULL;


    if(!hwndDlg || !pCertMgrInfo)
        return;

    pCertMgrStruct = pCertMgrInfo->pCertMgrStruct;
    if(!pCertMgrStruct)
        return;

    //overwrite the cursor for this window class
    hWinPreCursor=(HCURSOR)SetClassLongPtr(hwndDlg, GCLP_HCURSOR, NULL);

    hPreCursor=SetCursor(LoadCursor(NULL, IDC_WAIT));


    //free all the original certificates
    hwndControl=GetDlgItem(hwndDlg, IDC_CERTMGR_LIST);

    if(!hwndControl)
        goto CLEANUP;

    FreeCerts(pCertMgrInfo);

    //deletel all the certs from the listView
    ListView_DeleteAllItems(hwndControl);

    //clear the ceritificate details group box
    SetDlgItemTextU(hwndDlg, IDC_CERTMGR_PURPOSE, L" ");


    //get the tab that is selected
    if (pCertMgrStruct->dwFlags & CRYPTUI_CERT_MGR_SINGLE_TAB_FLAG)
        dwTabIndex = pCertMgrStruct->dwFlags & CRYPTUI_CERT_MGR_TAB_MASK;
    else if(-1 == (dwTabIndex=TabCtrl_GetCurSel(GetDlgItem(hwndDlg, IDC_CERTMGR_TAB))))
        goto CLEANUP;

    //open the correct store based on the tab selected
    switch (dwTabIndex)
    {
        case 0:
                //open my store
                if(rghCertStore[dwStoreCount]=CertOpenStore(
                            CERT_STORE_PROV_SYSTEM_W,
							g_dwMsgAndCertEncodingType,
							NULL,
							CERT_STORE_MAXIMUM_ALLOWED_FLAG |
                            CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG |
                            CERT_SYSTEM_STORE_CURRENT_USER,
                            (LPWSTR)L"my"))
                        dwStoreCount++;
                else
                    goto CLEANUP;
            break;
        case 1:
                //open ca store
                if(rghCertStore[dwStoreCount]=CertOpenStore(
                            CERT_STORE_PROV_SYSTEM_W,
							g_dwMsgAndCertEncodingType,
							NULL,
							CERT_STORE_MAXIMUM_ALLOWED_FLAG |
                            CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG |
                            CERT_SYSTEM_STORE_CURRENT_USER,
                            (LPWSTR)L"ca"))
                        dwStoreCount++;
                else
                    goto CLEANUP;


                //open the "AddressBook" store
                if(rghCertStore[dwStoreCount]=CertOpenStore(
                            CERT_STORE_PROV_SYSTEM_W,
							g_dwMsgAndCertEncodingType,
							NULL,
							CERT_STORE_MAXIMUM_ALLOWED_FLAG |
                            CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG |
                            CERT_SYSTEM_STORE_CURRENT_USER |
                            CERT_STORE_OPEN_EXISTING_FLAG,
                            (LPWSTR)L"ADDRESSBOOK"))
                        dwStoreCount++;
                else
                {
                    //it is OK that user does not have "AddressBook" store
                    rghCertStore[dwStoreCount]=NULL;
                }

            break;
        case 2:
                //open CA store
                if(rghCertStore[dwStoreCount]=CertOpenStore(
                            CERT_STORE_PROV_SYSTEM_W,
							g_dwMsgAndCertEncodingType,
							NULL,
							CERT_STORE_MAXIMUM_ALLOWED_FLAG |
                            CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG |
                            CERT_SYSTEM_STORE_CURRENT_USER,
                            (LPWSTR)L"ca"))
                        dwStoreCount++;
                else
                    goto CLEANUP;

            break;
        case 3:
                //open root store
                if(rghCertStore[dwStoreCount]=CertOpenStore(
                            CERT_STORE_PROV_SYSTEM_W,
							g_dwMsgAndCertEncodingType,
							NULL,
							CERT_STORE_MAXIMUM_ALLOWED_FLAG |
                            CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG |
                            CERT_SYSTEM_STORE_CURRENT_USER,
                            (LPWSTR)L"root"))
                        dwStoreCount++;
                else
                    goto CLEANUP;

            break;
        case 4:
                //open trusted publisher store
                if(rghCertStore[dwStoreCount]=CertOpenStore(
                            CERT_STORE_PROV_SYSTEM_W,
							g_dwMsgAndCertEncodingType,
							NULL,
							CERT_STORE_MAXIMUM_ALLOWED_FLAG |
                            CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG |
                            CERT_SYSTEM_STORE_CURRENT_USER,
                            (LPWSTR)L"TrustedPublisher"))
                        dwStoreCount++;
                else
                    goto CLEANUP;

            break;
        default:
                goto CLEANUP;
            break;
    }



    //gather new certificates from the store opened
    for(dwIndex=0; dwIndex < dwStoreCount; dwIndex++)
    {
        pPreCertContext=NULL;

        while(pCurCertContext=CertEnumCertificatesInStore(
                              rghCertStore[dwIndex],
                              pPreCertContext))
        {

            //make sure the certificate has the correct usage oid
            if(IsValidUsage(pCurCertContext,
                            hwndDlg,
                            pCertMgrInfo))
            {
                switch (dwTabIndex)
                {
                    case 0:
                            //certificate has to have private key associated
                            //with it
                            cbData=0;

                            if(
                                (CertGetCertificateContextProperty(
                                pCurCertContext,	
                                CERT_KEY_PROV_INFO_PROP_ID,	
                                NULL,	
                                &cbData) && (0!=cbData)) ||
                                (CertGetCertificateContextProperty(
                                pCurCertContext,	
                                CERT_PVK_FILE_PROP_ID,	
                                NULL,	
                                &cbData) && (0!=cbData))
                               )
                               fValidCert=TRUE;
                        break;
                    case 1:
                            //the certificate has to be end entity cert for CA cert
                            if(0 == dwIndex)
                            {
                                if(IsCertificateEndEntity(pCurCertContext))
                                    fValidCert=TRUE;
                            }

                            //we display everything in the addressbook store
                            if(1==dwIndex)
                                fValidCert=TRUE;
                        break;
                    case 2:
                            //for certificate in CA store, has to be CA cert
                            if(!IsCertificateEndEntity(pCurCertContext))
                                fValidCert=TRUE;

                        break;
                    case 4:
                        fValidCert=TRUE;
                        break;
                    case 3:
                    default:
                            //the certificate has to be self-signed
                            if(TrustIsCertificateSelfSigned(
                                pCurCertContext,
                                pCurCertContext->dwCertEncodingType, 0))
                                fValidCert=TRUE;

                        break;
                }

                if(fValidCert)
                {
                    AddCertToCertMgrInfo(
                        CertDuplicateCertificateContext(pCurCertContext),
                        pCertMgrInfo);
                }

                fValidCert=FALSE;
            }

            pPreCertContext=pCurCertContext;
            pCurCertContext=NULL;

        }
    }

    //put the certificate in the listView
    for(dwIndex=0; dwIndex<pCertMgrInfo->dwCertCount; dwIndex++)
        AddCertToListView(hwndControl,
                    (pCertMgrInfo->prgCertContext)[dwIndex],
                        dwIndex);

    // if there is no cert selected initially disable the
    // "view cert button", "export" and "remove" button
    if (ListView_GetSelectedCount(hwndControl) == 0)
    {
        EnableWindow(GetDlgItem(hwndDlg, IDC_CERTMGR_VIEW),   FALSE);
        EnableWindow(GetDlgItem(hwndDlg, IDC_CERTMGR_EXPORT), FALSE);
        EnableWindow(GetDlgItem(hwndDlg, IDC_CERTMGR_REMOVE), FALSE);
    }

    //we sort by the 1st column
    dwSortParam=pCertMgrInfo->rgdwSortParam[pCertMgrInfo->iColumn];

    if(0!=dwSortParam)
    {
        //sort the 1st column
        SendDlgItemMessage(hwndDlg,
            IDC_CERTMGR_LIST,
            LVM_SORTITEMS,
            (WPARAM) (LPARAM) dwSortParam,
            (LPARAM) (PFNLVCOMPARE)CompareCertificate);
    }


CLEANUP:

    //close all the certificate stores
    for(dwIndex=0; dwIndex<dwStoreCount; dwIndex++)
        CertCloseStore(rghCertStore[dwIndex], 0);

    //set the cursor back
    SetCursor(hPreCursor);
    SetWindowLongPtr(hwndDlg, GCLP_HCURSOR, (LONG_PTR)hWinPreCursor);

    return;
}


//-----------------------------------------------------------------------
// Check if the input OID is considered to be the advanced OID
//-----------------------------------------------------------------------
BOOL    IsAdvancedOID(CERT_ENHKEY_USAGE     *pKeyUsage,
                      LPCSTR                pszOID)
{
    DWORD   dwIndex=0;

    for(dwIndex=0; dwIndex<pKeyUsage->cUsageIdentifier; dwIndex++)
    {
        if(0 == _stricmp(pKeyUsage->rgpszUsageIdentifier[dwIndex], pszOID))
            return FALSE;
    }

    return TRUE;
}

//-----------------------------------------------------------------------
//The call back function for enum
//-----------------------------------------------------------------------
static BOOL WINAPI EnumOidCallback(
    IN PCCRYPT_OID_INFO pInfo,
    IN void *pvArg
    )
{

    PURPOSE_OID_CALL_BACK       *pCallBackInfo=NULL;
    BOOL                        fResult=FALSE;

    pCallBackInfo=(PURPOSE_OID_CALL_BACK *)pvArg;
    if(NULL==pvArg || NULL==pInfo)
        goto InvalidArgErr;

    //increment the oid list
    (*(pCallBackInfo->pdwOIDCount))++;

    //get more memory for the pointer list
    *(pCallBackInfo->pprgOIDInfo)=(PURPOSE_OID_INFO *)WizardRealloc(*(pCallBackInfo->pprgOIDInfo),
                                      (*(pCallBackInfo->pdwOIDCount)) * sizeof(PURPOSE_OID_INFO));

    if(NULL==*(pCallBackInfo->pprgOIDInfo))
        goto MemoryErr;

    //memset
    memset(&((*(pCallBackInfo->pprgOIDInfo))[*(pCallBackInfo->pdwOIDCount)-1]), 0, sizeof(PURPOSE_OID_INFO));

    (*(pCallBackInfo->pprgOIDInfo))[*(pCallBackInfo->pdwOIDCount)-1].pszOID=WizardAllocAndCopyStr((LPSTR)(pInfo->pszOID));
    (*(pCallBackInfo->pprgOIDInfo))[*(pCallBackInfo->pdwOIDCount)-1].pwszName=WizardAllocAndCopyWStr((LPWSTR)(pInfo->pwszName));
    (*(pCallBackInfo->pprgOIDInfo))[*(pCallBackInfo->pdwOIDCount)-1].fSelected=FALSE;

    if(NULL==(*(pCallBackInfo->pprgOIDInfo))[*(pCallBackInfo->pdwOIDCount)-1].pszOID ||
       NULL==(*(pCallBackInfo->pprgOIDInfo))[*(pCallBackInfo->pdwOIDCount)-1].pwszName)
       goto MemoryErr;

    fResult=TRUE;

CommonReturn:

    return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
}

//----------------------------------------------------------------------------
//  Get the list of supported enhanced key OIDs
//----------------------------------------------------------------------------
BOOL    InitPurposeOID(LPCSTR                 pszInitUsageOID,
                       DWORD                  *pdwOIDInfo,
                       PURPOSE_OID_INFO       **pprgOIDInfo)
{
    BOOL                    fResult=FALSE;
    DWORD                   dwIndex=0;
    PURPOSE_OID_CALL_BACK   OidInfoCallBack;
    DWORD                   dwOIDRequested=0;
    LPWSTR                  pwszName=NULL;

    if(!pdwOIDInfo || !pprgOIDInfo)
        goto InvalidArgErr;

    //init
    *pdwOIDInfo=0;
    *pprgOIDInfo=NULL;

    OidInfoCallBack.pdwOIDCount=pdwOIDInfo;
    OidInfoCallBack.pprgOIDInfo=pprgOIDInfo;

    //enum all the enhanced key usages
    if(!CryptEnumOIDInfo(
               CRYPT_ENHKEY_USAGE_OID_GROUP_ID,
                0,
                &OidInfoCallBack,
                EnumOidCallback))
    {
        FreeUsageOID(*pdwOIDInfo,*pprgOIDInfo);

        *pdwOIDInfo=0;
        *pprgOIDInfo=NULL;

        goto TraceErr;
    }

    fResult=TRUE;

CommonReturn:

    //free the memory

    return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
TRACE_ERROR(TraceErr);
}


//-----------------------------------------------------------------------
//   Initialize the tab control
//-----------------------------------------------------------------------
void    InitTabControl(HWND                         hWndControl,
                       PCCRYPTUI_CERT_MGR_STRUCT    pCertMgrStruct)
{

    DWORD       dwIndex=0;
    DWORD       dwCount=0;
    WCHAR       wszText[MAX_STRING_SIZE];

    UINT        rgIDS[]={IDS_TAB_PERSONAL,
                         IDS_TAB_OTHER,
                         IDS_TAB_CA,
                         IDS_TAB_ROOT,
                         IDS_TAB_PUBLISHER,
                        };

   TCITEMW      tcItem;

    if(!hWndControl)
        return;

    memset(&tcItem, 0, sizeof(TCITEM));

    tcItem.mask=TCIF_TEXT;
    tcItem.pszText=wszText;


    if (pCertMgrStruct->dwFlags & CRYPTUI_CERT_MGR_SINGLE_TAB_FLAG)
    {
        dwIndex = pCertMgrStruct->dwFlags & CRYPTUI_CERT_MGR_TAB_MASK;
        //get the column header
        wszText[0]=L'\0';

        LoadStringU(g_hmodThisDll, rgIDS[dwIndex], wszText, MAX_STRING_SIZE);

        TabCtrl_InsertItemU(hWndControl, 		
                           0, 		
                           &tcItem);		
    } else
    {
        dwCount=sizeof(rgIDS)/sizeof(rgIDS[0]);

        //insert the tabs one at a time
        for(dwIndex=0; dwIndex<dwCount; dwIndex++)
        {
            //get the column header
            wszText[0]=L'\0';

            LoadStringU(g_hmodThisDll, rgIDS[dwIndex], wszText, MAX_STRING_SIZE);

            TabCtrl_InsertItemU(hWndControl, 		
                           dwIndex, 		
                           &tcItem);		
        }
    }

    return;
}


//----------------------------------------------------------------------------
//
//  Free the array of usage OID info
//
//----------------------------------------------------------------------------
BOOL    FreeUsageOID(DWORD              dwOIDInfo,
                     PURPOSE_OID_INFO   *pOIDInfo)
{
    DWORD   dwIndex=0;

    if(pOIDInfo)
    {
        for(dwIndex=0; dwIndex < dwOIDInfo; dwIndex++)
        {
            if(pOIDInfo[dwIndex].pszOID)
                WizardFree(pOIDInfo[dwIndex].pszOID);

            if(pOIDInfo[dwIndex].pwszName)
                WizardFree(pOIDInfo[dwIndex].pwszName);
        }

        WizardFree(pOIDInfo);
    }

    return TRUE;
}


//-----------------------------------------------------------------------
//   Free the Certificates array
//-----------------------------------------------------------------------
void    FreeCerts(CERT_MGR_INFO     *pCertMgrInfo)
{
    DWORD   dwIndex=0;

    if(!pCertMgrInfo)
        return;

    if(pCertMgrInfo->prgCertContext)
    {
        for(dwIndex=0; dwIndex<pCertMgrInfo->dwCertCount; dwIndex++)
        {
            if(pCertMgrInfo->prgCertContext[dwIndex])
                CertFreeCertificateContext(pCertMgrInfo->prgCertContext[dwIndex]);
        }

        WizardFree(pCertMgrInfo->prgCertContext);
    }

    pCertMgrInfo->dwCertCount=0;

    pCertMgrInfo->prgCertContext=NULL;

    return;
}

//--------------------------------------------------------------
// Initialize the Purpose Combo
//--------------------------------------------------------------
void    InitPurposeCombo(HWND               hwndDlg,
                         CERT_MGR_INFO      *pCertMgrInfo)
{
    DWORD                           dwIndex=0;
    DWORD                           dwCount=0;
    WCHAR                           wszText[MAX_STRING_SIZE];

    UINT                            rgIDS[]={IDS_OID_ADVANCED,
                                             IDS_OID_ALL};
    LPWSTR                          pwszInitOIDName=NULL;
    CRYPTUI_CERT_MGR_STRUCT         *pCertMgrStruct=NULL;
    int                             iIndex=0;

    if(!hwndDlg || !pCertMgrInfo)
        return;

    pCertMgrStruct=(CRYPTUI_CERT_MGR_STRUCT *)(pCertMgrInfo->pCertMgrStruct);

    //delete all the entries in the comobox
    SendDlgItemMessage(hwndDlg, IDC_CERTMGR_PURPOSE_COMBO,
        CB_RESETCONTENT, 0, 0);

    //copy all the basic OIDs to the comobox
    for(dwIndex=0; dwIndex<pCertMgrInfo->dwOIDInfo; dwIndex++)
    {

        if(FALSE == (pCertMgrInfo->rgOIDInfo[dwIndex].fSelected))
        {
            SendDlgItemMessageU(hwndDlg, IDC_CERTMGR_PURPOSE_COMBO,
                    CB_ADDSTRING,
                    0, (LPARAM)(pCertMgrInfo->rgOIDInfo[dwIndex].pwszName));


            //looking for the initial OID
            if(pCertMgrStruct->pszInitUsageOID)
            {
                if(0 == _stricmp(pCertMgrStruct->pszInitUsageOID,
                                 pCertMgrInfo->rgOIDInfo[dwIndex].pszOID))
                    pwszInitOIDName=pCertMgrInfo->rgOIDInfo[dwIndex].pwszName;
            }
        }
    }

    //copy <advanced> and <all> to the list
    dwCount=sizeof(rgIDS)/sizeof(rgIDS[0]);

    //insert the column one at a time
    for(dwIndex=0; dwIndex<dwCount; dwIndex++)
    {
        //get the column header
        wszText[0]=L'\0';

        LoadStringU(g_hmodThisDll, rgIDS[dwIndex], wszText, MAX_STRING_SIZE);

        SendDlgItemMessageU(hwndDlg, IDC_CERTMGR_PURPOSE_COMBO,
                    CB_INSERTSTRING,
                    -1, (LPARAM)wszText);
    }


    //initialize the combo box
    //use <advanced> is what user specify is not either
    //client auth or secure e-mail
    if(pCertMgrStruct->pszInitUsageOID)
    {
        if(NULL==pwszInitOIDName)
        {
            wszText[0]=L'\0';

            LoadStringU(g_hmodThisDll, IDS_OID_ADVANCED, wszText, MAX_STRING_SIZE);

            pwszInitOIDName=wszText;
        }

    }

    //use <all> when NULL==pCertMgrStruct->pszInitUsageOID
    if(NULL==pwszInitOIDName)
    {
        //use <all> as the initial case
        wszText[0]=L'\0';

        LoadStringU(g_hmodThisDll, IDS_OID_ALL, wszText, MAX_STRING_SIZE);

        pwszInitOIDName=wszText;
    }

    iIndex=(int)SendDlgItemMessageU(
        hwndDlg,
        IDC_CERTMGR_PURPOSE_COMBO,
        CB_FINDSTRINGEXACT,
        -1,
        (LPARAM)pwszInitOIDName);

    if(CB_ERR == iIndex)
        return;

    //set the selection
    SendDlgItemMessageU(hwndDlg, IDC_CERTMGR_PURPOSE_COMBO, CB_SETCURSEL, iIndex,0);

    return;

}

//--------------------------------------------------------------
// Initialize the Purpose Combo
//--------------------------------------------------------------
void    RepopulatePurposeCombo(HWND                 hwndDlg,
                               CERT_MGR_INFO        *pCertMgrInfo)
{
    LPWSTR          pwszSelectedOIDName=NULL;
    int             iIndex=0;

    if(!hwndDlg || !pCertMgrInfo)
        return;

    //get the selected string from the combo box
    iIndex=(int)SendDlgItemMessage(hwndDlg, IDC_CERTMGR_PURPOSE_COMBO,
            CB_GETCURSEL, 0, 0);

    if(CB_ERR==iIndex)
        return;

    //get the selected purpose
    if(CB_ERR == SendDlgItemMessageU_GETLBTEXT(hwndDlg,
                IDC_CERTMGR_PURPOSE_COMBO,
              iIndex, &pwszSelectedOIDName))
        goto CLEANUP;

    InitPurposeCombo(hwndDlg, pCertMgrInfo);

    iIndex=(int)SendDlgItemMessageU(
            hwndDlg,
            IDC_CERTMGR_PURPOSE_COMBO,
            CB_FINDSTRINGEXACT,
            -1,
            (LPARAM)pwszSelectedOIDName);

    if(CB_ERR == iIndex)
        goto CLEANUP;

    //set the selection
    SendDlgItemMessageU(hwndDlg, IDC_CERTMGR_PURPOSE_COMBO, CB_SETCURSEL, iIndex,0);


CLEANUP:

    if(pwszSelectedOIDName)
        WizardFree(pwszSelectedOIDName);

    return;

}
//--------------------------------------------------------------
// The winProc for the advanced option diagloue for certMgr UI
//--------------------------------------------------------------
INT_PTR APIENTRY CertMgrAdvancedProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CERT_MGR_INFO                   *pCertMgrInfo=NULL;
    PCCRYPTUI_CERT_MGR_STRUCT       pCertMgrStruct=NULL;

    UINT                            rgIDS[]={IDS_CERTMGR_DER,
                                             IDS_CERTMGR_BASE64,
                                             IDS_CERTMGR_PKCS7};

    WCHAR                           wszText[MAX_STRING_SIZE];
    DWORD                           dwCount=0;
    DWORD                           dwIndex=0;
    DWORD                           dwSelectedIndex=0;
    LV_ITEMW                        lvItem;
    LV_COLUMNW                      lvC;
    HWND                            hwndControl=NULL;
    int                             iIndex=0;
    int                             listIndex=0;
    NM_LISTVIEW FAR *               pnmv=NULL;
    HWND                            hwnd=NULL;

    switch ( msg )
    {
        case WM_INITDIALOG:

            pCertMgrInfo = (CERT_MGR_INFO   *) lParam;

            SetWindowLongPtr(hwndDlg, DWLP_USER, (LONG_PTR) pCertMgrInfo);

            pCertMgrStruct=pCertMgrInfo->pCertMgrStruct;

            if(NULL == pCertMgrStruct)
                break;

            //init the export format control
            dwCount=sizeof(rgIDS)/sizeof(rgIDS[0]);

            for(dwIndex=0; dwIndex < dwCount; dwIndex++)
            {
                LoadStringU(g_hmodThisDll,
                            rgIDS[dwIndex],
                            wszText,
                            MAX_STRING_SIZE);

                SendDlgItemMessageU(hwndDlg,
                            IDC_CERTMGR_EXPORT_COMBO,
                            CB_INSERTSTRING,
                            -1,
                            (LPARAM)wszText);
            }

            //select the export format based on the selection
            switch (pCertMgrInfo->dwExportFormat)
            {
                case   CRYPTUI_WIZ_EXPORT_FORMAT_DER:
                        dwSelectedIndex=0;
                    break;
                case   CRYPTUI_WIZ_EXPORT_FORMAT_BASE64:
                        dwSelectedIndex=1;
                    break;
                case   CRYPTUI_WIZ_EXPORT_FORMAT_PKCS7:
                        dwSelectedIndex=2;
                    break;
                default:
                    dwSelectedIndex=0;
            }

            SendDlgItemMessageU(hwndDlg, IDC_CERTMGR_EXPORT_COMBO,
                CB_SETCURSEL, (WPARAM)dwSelectedIndex,0);

            //init the chain check-box
            if(pCertMgrInfo->fExportChain)
                SendDlgItemMessage(hwndDlg, IDC_CERTMGR_EXPORT_CHECK, BM_SETCHECK, 1, 0);
            else
                SendDlgItemMessage(hwndDlg, IDC_CERTMGR_EXPORT_CHECK, BM_SETCHECK, 0, 0);

            if(dwSelectedIndex != 2)
                EnableWindow(GetDlgItem(hwndDlg, IDC_CERTMGR_EXPORT_CHECK), FALSE);
            else
                EnableWindow(GetDlgItem(hwndDlg, IDC_CERTMGR_EXPORT_CHECK), TRUE);

            //init the advanced OID list
            hwndControl = GetDlgItem(hwndDlg, IDC_CERTMGR_ADV_LIST);

            //mark the list is selected by a check box
            ListView_SetExtendedListViewStyle(hwndControl, LVS_EX_CHECKBOXES);

            //insert a column into the list view
            memset(&lvC, 0, sizeof(LV_COLUMNW));

            lvC.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
            lvC.fmt = LVCFMT_LEFT;  // Left-align the column.
            lvC.cx =10;       // (dwMaxSize+2)*7;            // Width of the column, in pixels.
            lvC.pszText = L"";   // The text for the column.
            lvC.iSubItem=0;

            if (ListView_InsertColumnU(hwndControl, 0, &lvC) == -1)
                break;

            //populate the list
            memset(&lvItem, 0, sizeof(LV_ITEMW));
            lvItem.mask=LVIF_TEXT | LVIF_STATE;

            for(dwIndex=0; dwIndex<pCertMgrInfo->dwOIDInfo; dwIndex++)
            {
                lvItem.iItem=dwIndex;

                lvItem.pszText=(pCertMgrInfo->rgOIDInfo[dwIndex]).pwszName;
                lvItem.cchTextMax=sizeof(WCHAR)*(1+wcslen((pCertMgrInfo->rgOIDInfo[dwIndex]).pwszName));
                lvItem.stateMask  = LVIS_STATEIMAGEMASK;
                lvItem.state      = (pCertMgrInfo->rgOIDInfo[dwIndex]).fSelected ? 0x00002000 : 0x00001000;

                // insert and set state
                ListView_SetItemState(hwndControl,
                                    ListView_InsertItemU(hwndControl, &lvItem),
                                    (pCertMgrInfo->rgOIDInfo[dwIndex]).fSelected ? 0x00002000 : 0x00001000,
                                    LVIS_STATEIMAGEMASK);
            }

            //autosize the column
            ListView_SetColumnWidth(hwndControl, 0, LVSCW_AUTOSIZE);

#if (1) // DSIE: bug 282268.
            ListView_SetItemState(hwndControl,
                                  0,
                                  LVIS_FOCUSED | LVIS_SELECTED,
                                  LVIS_FOCUSED | LVIS_SELECTED);
#endif
            break;

        case WM_NOTIFY:
            pCertMgrInfo = (CERT_MGR_INFO *) GetWindowLongPtr(hwndDlg, DWLP_USER);

            if(NULL == pCertMgrInfo)
                break;

            pCertMgrStruct=pCertMgrInfo->pCertMgrStruct;

            if(NULL == pCertMgrStruct)
                break;

            switch (((NMHDR FAR *) lParam)->code)
            {
                case    LVN_ITEMCHANGED:
                        //if the state of the advanced OID check box
                        //has been changed, mark the flag
                        pnmv = (NM_LISTVIEW FAR *) lParam;

                        if(NULL==pnmv)
                            break;

                        //see if the new item is de-selected
                        if(pnmv->uChanged & LVIF_STATE)
                            pCertMgrInfo->fAdvOIDChanged=TRUE;

                    break;
            }

            break;

        case WM_DESTROY:
            break;

        case WM_HELP:
        case WM_CONTEXTMENU:
            if (msg == WM_HELP)
            {
                hwnd = GetDlgItem(hwndDlg, ((LPHELPINFO)lParam)->iCtrlId);
            }
            else
            {
                hwnd = (HWND) wParam;
            }

            if ((hwnd != GetDlgItem(hwndDlg, IDC_CERTMGR_ADV_LIST))         &&
                (hwnd != GetDlgItem(hwndDlg, IDC_CERTMGR_EXPORT_COMBO))     &&
                (hwnd != GetDlgItem(hwndDlg, IDC_CERTMGR_EXPORT_CHECK))     &&
                (hwnd != GetDlgItem(hwndDlg, IDOK))                         &&
                (hwnd != GetDlgItem(hwndDlg, IDCANCEL)))
            {
                SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, TRUE);
                return TRUE;
            }
            else
            {
                return OnContextHelp(hwndDlg, msg, wParam, lParam, CertMgrAdvHelpMap);
            }

            break;

        case WM_COMMAND:
            pCertMgrInfo = (CERT_MGR_INFO *) GetWindowLongPtr(hwndDlg, DWLP_USER);

            if(NULL == pCertMgrInfo)
                break;

            pCertMgrStruct=pCertMgrInfo->pCertMgrStruct;

            if(NULL == pCertMgrStruct)
                break;

            //a control is clicked
            if(HIWORD(wParam) == BN_CLICKED)
            {
                 switch (LOWORD(wParam))
                 {
                     case IDCANCEL:
                         pCertMgrInfo->fAdvOIDChanged=FALSE;

                         EndDialog(hwndDlg, DIALOGUE_CANCEL);
                         break;

                     case IDOK:
                         //the OK button is selected
                         //get the default export format
                         iIndex=(int)SendDlgItemMessage(hwndDlg,
                                 IDC_CERTMGR_EXPORT_COMBO,
                                 CB_GETCURSEL, 0, 0);

                         if(CB_ERR==iIndex)
                             break;

                         switch(iIndex)
                         {
                             case 0:
                                 pCertMgrInfo->dwExportFormat=CRYPTUI_WIZ_EXPORT_FORMAT_DER;

                                 break;

                             case 1:
                                 pCertMgrInfo->dwExportFormat=CRYPTUI_WIZ_EXPORT_FORMAT_BASE64;
                                 break;

                             case 2:
                                 pCertMgrInfo->dwExportFormat=CRYPTUI_WIZ_EXPORT_FORMAT_PKCS7;
                                 break;

                             default:
                                 pCertMgrInfo->dwExportFormat=0;
                                 break;
                         }

                         if(TRUE==SendDlgItemMessage(
                                     hwndDlg,
                                     IDC_CERTMGR_EXPORT_CHECK,
                                     BM_GETCHECK,
                                     0,0))
                             pCertMgrInfo->fExportChain=TRUE;
                         else
                             pCertMgrInfo->fExportChain=FALSE;

                         //get the list of advanded OIDs
                         if(NULL==(hwndControl=GetDlgItem(hwndDlg, IDC_CERTMGR_ADV_LIST)))
                             break;

                         //get the count of selected OIDs and mark them
                         for(dwIndex=0; dwIndex<pCertMgrInfo->dwOIDInfo; dwIndex++)
                         {
                             //mark the selected OIDS.  Keep track of
                             //if the OID selections have been changed
                             if(ListView_GetCheckState(hwndControl, dwIndex))
                             {
                                 ((pCertMgrInfo->rgOIDInfo)[dwIndex]).fSelected=TRUE;
                             }
                             else
                             {
                                 ((pCertMgrInfo->rgOIDInfo)[dwIndex]).fSelected=FALSE;
                             }

                         }


                         //save the advanced options to the registry
                         SaveAdvValueToReg(pCertMgrInfo);

                         EndDialog(hwndDlg, DIALOGUE_OK);

                         break;
                 }
            }

            //a combo box's selection has been changed
            if(HIWORD(wParam) == CBN_SELCHANGE)
            {
                switch(LOWORD(wParam))
                {
                    case IDC_CERTMGR_EXPORT_COMBO:
                        //the export format combo box has been changed
                        //get the selected item index
                        iIndex=(int)SendDlgItemMessage(hwndDlg,
                                IDC_CERTMGR_EXPORT_COMBO,
                                CB_GETCURSEL, 0, 0);

                        if(CB_ERR==iIndex)
                            break;

                        //enable the check box for the chain if
                        //PKCS#7 option is selected
                        if(2 == iIndex)
                            EnableWindow(GetDlgItem(hwndDlg, IDC_CERTMGR_EXPORT_CHECK), TRUE);
                        else
                            EnableWindow(GetDlgItem(hwndDlg, IDC_CERTMGR_EXPORT_CHECK), FALSE);

                        break;
                }
            }

            break;
    }

    return FALSE;
}



//--------------------------------------------------------------
// The winProc for CertMgrDialogProc
//--------------------------------------------------------------
INT_PTR APIENTRY CertMgrDialogProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CERT_MGR_INFO                   *pCertMgrInfo=NULL;
    PCCRYPTUI_CERT_MGR_STRUCT       pCertMgrStruct=NULL;

    HWND                            hWndListView=NULL;
    HWND                            hWndControl=NULL;
    DWORD                           dwIndex=0;
    DWORD                           dwCount=0;
    WCHAR                           wszText[MAX_STRING_SIZE];
    BOOL                            fCanDelete=FALSE;

    UINT                            rgIDS[]={IDS_COLUMN_SUBJECT,
                                             IDS_COLUMN_ISSUER,
                                             IDS_COLUMN_EXPIRE,
                                             IDS_COLUMN_NAME};


    NM_LISTVIEW FAR *               pnmv=NULL;
    LPNMLVKEYDOWN                   pnkd=NULL;
    LV_COLUMNW                      lvC;
    int                             listIndex=0;
    LV_ITEM                         lvItem;
    BOOL                            fPropertyChanged=FALSE;


    HIMAGELIST                      hIml=NULL;
    CRYPTUI_VIEWCERTIFICATE_STRUCT  CertViewStruct;
    CRYPTUI_WIZ_EXPORT_INFO         CryptUIWizExportInfo;
    UINT                            idsDeleteConfirm=0;
    int                             iIndex=0;
    DWORD                           dwSortParam=0;
    HCERTSTORE                      hCertStore=NULL;
    HWND                            hwnd=NULL;

    DWORD                           cbData=0;

    switch ( msg )
    {

        case WM_INITDIALOG:

                pCertMgrInfo = (CERT_MGR_INFO   *) lParam;

                SetWindowLongPtr(hwndDlg, DWLP_USER, (LONG_PTR) pCertMgrInfo);

                pCertMgrStruct=pCertMgrInfo->pCertMgrStruct;

                if(NULL == pCertMgrStruct)
                    break;

                //
                // set the dialog title
                //
                if (pCertMgrStruct->pwszTitle)
                {
                    SetWindowTextU(hwndDlg, pCertMgrStruct->pwszTitle);
                }

                //create the image list

                hIml = ImageList_LoadImage(g_hmodThisDll, MAKEINTRESOURCE(IDB_CERT), 0, 1, RGB(255,0,255), IMAGE_BITMAP, 0);

                //
                // add the colums to the list view
                //
                hWndListView = GetDlgItem(hwndDlg, IDC_CERTMGR_LIST);

                if(NULL==hWndListView)
                    break;

                //set the image list
                if (hIml != NULL)
                {
                    ListView_SetImageList(hWndListView, hIml, LVSIL_SMALL);
                }

                dwCount=sizeof(rgIDS)/sizeof(rgIDS[0]);

                //set up the common info for the column
                memset(&lvC, 0, sizeof(LV_COLUMNW));

                lvC.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
                lvC.fmt = LVCFMT_LEFT;  // Left-align the column.
                lvC.cx = 80;          // Width of the column, in pixels.
                lvC.iSubItem=0;
                lvC.pszText = wszText;   // The text for the column.

                //inser the column one at a time
                for(dwIndex=0; dwIndex<dwCount; dwIndex++)
                {
                    //get the column header
                    wszText[0]=L'\0';

                    //set the column width.  1st and 2nd to 100,
                    //and the expiration to 75, the rest to 80
                    if( dwIndex < 2)
                        lvC.cx=130;
                    else
                    {
                        if( 2 == dwIndex)
                            lvC.cx=70;
                        else
                            lvC.cx=105;
                    }


                    LoadStringU(g_hmodThisDll, rgIDS[dwIndex], wszText, MAX_STRING_SIZE);

                    ListView_InsertColumnU(hWndListView, dwIndex, &lvC);
                }

                // set the style in the list view so that it highlights an entire line
                SendMessageA(hWndListView, LVM_SETEXTENDEDLISTVIEWSTYLE, 0, LVS_EX_FULLROWSELECT);


                //Init tabs to the tab control.
                hWndControl = GetDlgItem(hwndDlg, IDC_CERTMGR_TAB);
                if(NULL==hWndControl)
                    break;

                //add the tabs to the tabl control
                InitTabControl(hWndControl, pCertMgrStruct);

                // If CRYPTUI_CERT_MGR_PUBLISHER_TAB was set, then,
                // select the 5th tab: Trusted Publishers, otherwise,
                // select the 1st tab: Personal Certificate
                TabCtrl_SetCurSel(
                    hWndControl,
                    (CRYPTUI_CERT_MGR_PUBLISHER_TAB ==
                        (pCertMgrStruct->dwFlags &
                            (CRYPTUI_CERT_MGR_TAB_MASK |
                                CRYPTUI_CERT_MGR_SINGLE_TAB_FLAG) )) ?  4 : 0
                    );

                //Init the purpose combo box
                InitPurposeCombo(hwndDlg,pCertMgrInfo);

                //Init the certificates in the list view based on the tab selected
                //and the purpose selected
                RefreshCertListView(hwndDlg, pCertMgrInfo);

                //Set the correct window title based on the tab selection
               // RefreshWindowTitle(hwndDlg, (CRYPTUI_CERT_MGR_STRUCT *)pCertMgrStruct);

                //register the listView window as the drop desitination
                if(S_OK == CCertMgrDropTarget_CreateInstance(
                                           hwndDlg,
                                           pCertMgrInfo,
                                           &(pCertMgrInfo->pIDropTarget)))
                {
                    __try {
                        RegisterDragDrop(hWndListView, pCertMgrInfo->pIDropTarget);
                   } __except(EXCEPTION_EXECUTE_HANDLER) {

                   }
                }
            break;
        case WM_NOTIFY:

                pCertMgrInfo = (CERT_MGR_INFO *) GetWindowLongPtr(hwndDlg, DWLP_USER);

                if(NULL == pCertMgrInfo)
                    break;

                pCertMgrStruct=pCertMgrInfo->pCertMgrStruct;

                if(NULL == pCertMgrStruct)
                    break;


                switch (((NMHDR FAR *) lParam)->code)
                {

                    //the delete key has been pressed
                    case LVN_KEYDOWN:
                            pnkd = (LPNMLVKEYDOWN) lParam;

                            if(VK_DELETE == pnkd->wVKey)
                            {
                                if(NULL==(hWndControl=GetDlgItem(hwndDlg, IDC_CERTMGR_LIST)))
                                    break;
                                
                                GetAllSelectedItem(hWndControl,
                                                      ALL_SELECTED_CAN_DELETE,
                                                      &fCanDelete);

                                if(!fCanDelete)
                                {
                                    I_MessageBox(
                                            hwndDlg,
                                            IDS_CANNOT_DELETE_CERTS,
                                            IDS_CERT_MGR_TITLE,
                                            pCertMgrStruct->pwszTitle,
                                            MB_ICONEXCLAMATION|MB_OK|MB_APPLMODAL);
                                }
                                else
                                {
                                    //same action as user has click on the DELETE button
                                    SendDlgItemMessage(hwndDlg,
                                                        IDC_CERTMGR_REMOVE,
                                                        BM_CLICK,
                                                        0,0);
                                }
                            }

                        break;
                    //drag drop operation has begun
                    case LVN_BEGINDRAG:
                    case LVN_BEGINRDRAG:

                            pnmv = (LPNMLISTVIEW) lParam;

                            if(!pnmv)
                                break;

                            if(NULL==(hWndControl=GetDlgItem(hwndDlg, IDC_CERTMGR_LIST)))
                                                    break;

                            listIndex = ListView_GetNextItem(
                                    hWndControl, 		
                                    -1, 		
                                    LVNI_SELECTED		
                                    );

                            if(listIndex != -1)
                                //start the drag and drop
                                CertMgrUIStartDragDrop(pnmv, hWndControl,
                                pCertMgrInfo->dwExportFormat,
                                pCertMgrInfo->fExportChain);

                        break;
                    //the item has been selected
                    case LVN_ITEMCHANGED:
                            if(NULL==(hWndControl=GetDlgItem(hwndDlg, IDC_CERTMGR_LIST)))
                                                    break;

                            pnmv = (LPNMLISTVIEW) lParam;

                            if(NULL==pnmv)
                                break;

                            if (pnmv->uNewState & LVIS_SELECTED)
                            {

                                //enable the export buttons
                                EnableWindow(GetDlgItem(hwndDlg, IDC_CERTMGR_EXPORT), TRUE);

                                //if more than one certificates are selected, diable the view button
                                if(ListView_GetSelectedCount(hWndControl) > 1)
                                    EnableWindow(GetDlgItem(hwndDlg, IDC_CERTMGR_VIEW), FALSE);
                                else
                                    EnableWindow(GetDlgItem(hwndDlg, IDC_CERTMGR_VIEW), TRUE);

                                //enable the delete window only if the certificate is deletable
                                GetAllSelectedItem(hWndControl,
                                                      ALL_SELECTED_CAN_DELETE,
                                                      &fCanDelete);

                                if(fCanDelete)
                                    EnableWindow(GetDlgItem(hwndDlg, IDC_CERTMGR_REMOVE), TRUE);
                                else
                                    EnableWindow(GetDlgItem(hwndDlg, IDC_CERTMGR_REMOVE), FALSE);


                                //display the details of the certificate if
                                //only 1 cert is selected
                                if(1 == ListView_GetSelectedCount(hWndControl))
                                {
                                    RefreshCertDetails(hwndDlg, (PCCERT_CONTEXT)(pnmv->lParam));
                                }
                                else
                                {
                                    //clear the ceritificate details group box
                                    SetDlgItemTextU(hwndDlg, IDC_CERTMGR_PURPOSE, L" ");
                                }
                            }
                            else
                            {
                                //if the state is deselection
                                if(0 == ListView_GetSelectedCount(hWndControl))
                                {
                                    //we diable the buttons if no certificate is selected
                                    EnableWindow(GetDlgItem(hwndDlg, IDC_CERTMGR_VIEW),     FALSE);
                                    EnableWindow(GetDlgItem(hwndDlg, IDC_CERTMGR_EXPORT),   FALSE);
                                    EnableWindow(GetDlgItem(hwndDlg, IDC_CERTMGR_REMOVE),   FALSE);

                                    //clear the ceritificate details group box
                                    SetDlgItemTextU(hwndDlg, IDC_CERTMGR_PURPOSE, L" ");
                                }
                            }

                        break;
                    //the column has been changed
                    case LVN_COLUMNCLICK:

                            pnmv = (NM_LISTVIEW FAR *) lParam;

                            //get the column number
                            dwSortParam=0;

                            switch(pnmv->iSubItem)
                            {
                                case 0:
                                case 1:
                                case 2:
                                case 3:
                                case 4:
                                        dwSortParam=pCertMgrInfo->rgdwSortParam[pnmv->iSubItem];
                                    break;
                                default:
                                        dwSortParam=0;
                                    break;
                            }

                            if(0!=dwSortParam)
                            {
                                //remember to flip the ascend ording

                                if(dwSortParam & SORT_COLUMN_ASCEND)
                                {
                                    dwSortParam &= 0x0000FFFF;
                                    dwSortParam |= SORT_COLUMN_DESCEND;
                                }
                                else
                                {
                                    if(dwSortParam & SORT_COLUMN_DESCEND)
                                    {
                                        dwSortParam &= 0x0000FFFF;
                                        dwSortParam |= SORT_COLUMN_ASCEND;
                                    }
                                }

                                //sort the column
                                SendDlgItemMessage(hwndDlg,
                                    IDC_CERTMGR_LIST,
                                    LVM_SORTITEMS,
                                    (WPARAM) (LPARAM) dwSortParam,
                                    (LPARAM) (PFNLVCOMPARE)CompareCertificate);

                                pCertMgrInfo->rgdwSortParam[pnmv->iSubItem]=dwSortParam;

                                //remember the column number
                                pCertMgrInfo->iColumn=pnmv->iSubItem;
                            }

                        break;


                    //the tab has been changed
                    case TCN_SELCHANGE:
                            //we need to refresh the column sorting state
                            pCertMgrInfo->rgdwSortParam[0]=SORT_COLUMN_SUBJECT | SORT_COLUMN_ASCEND;
                            pCertMgrInfo->rgdwSortParam[1]=SORT_COLUMN_ISSUER | SORT_COLUMN_DESCEND;
                            pCertMgrInfo->rgdwSortParam[2]=SORT_COLUMN_EXPIRATION | SORT_COLUMN_DESCEND;
                            pCertMgrInfo->rgdwSortParam[3]=SORT_COLUMN_NAME | SORT_COLUMN_DESCEND;
                            pCertMgrInfo->rgdwSortParam[4]=SORT_COLUMN_NAME | SORT_COLUMN_DESCEND;

                            pCertMgrInfo->iColumn=0;

                            //if the tab is changed, we need to
                            //refresh the list view and certificate's
                            //detailed view
                            RefreshCertListView(hwndDlg, pCertMgrInfo);

                            //we also we to update the window title
                            //based on the tabl selection
                            //RefreshWindowTitle(hwndDlg, (CRYPTUI_CERT_MGR_STRUCT *)pCertMgrStruct);
                        break;

                    //double-click on the list view of the certificates
                    case NM_DBLCLK:
                    {
                        switch (((NMHDR FAR *) lParam)->idFrom)
                        {
                            case IDC_CERTMGR_LIST:
                            {
                                //get the window handle of the cert list view
                                if(NULL==(hWndControl=GetDlgItem(hwndDlg, IDC_CERTMGR_LIST)))
                                    break;

                                //get the selected cert
                                listIndex = ListView_GetNextItem(
                                    hWndControl, 		
                                    -1, 		
                                    LVNI_SELECTED		
                                    );

                                if (listIndex != -1)
                                {
                                    //get the selected certificate
                                    memset(&lvItem, 0, sizeof(LV_ITEM));
                                    lvItem.mask=LVIF_PARAM;
                                    lvItem.iItem=listIndex;

                                    if(ListView_GetItem(hWndControl, &lvItem))
                                    {
                                        //view certiificate
                                       if(pCertMgrInfo->dwCertCount > (DWORD)listIndex)
                                       {
                                            memset(&CertViewStruct, 0, sizeof(CRYPTUI_VIEWCERTIFICATE_STRUCT));
                                            CertViewStruct.dwSize=sizeof(CRYPTUI_VIEWCERTIFICATE_STRUCT);
                                            CertViewStruct.pCertContext=(PCCERT_CONTEXT)(lvItem.lParam);
                                            CertViewStruct.hwndParent=hwndDlg;

                                            fPropertyChanged=FALSE;

                                            CryptUIDlgViewCertificate(&CertViewStruct, &fPropertyChanged);

                                            if(fPropertyChanged)
                                            {
                                                RefreshCertListView(hwndDlg, pCertMgrInfo);

                                                //we reselect the one
                                                ListView_SetItemState(
                                                                    hWndControl,
                                                                    listIndex,
                                                                    LVIS_SELECTED,
                                                                    LVIS_SELECTED);
                                            }
                                       }
                                    }
                                }

                                break;
                            }
                        }

                        break;
                    }

#if (1) //DSIE: bug 264568.
                    case NM_SETFOCUS:
                    {
                        //get the window handle of the cert list view
                        if(NULL==(hWndControl=GetDlgItem(hwndDlg, IDC_CERTMGR_LIST)))
                            break;

                        //get the selected cert
                        listIndex = ListView_GetNextItem(
                            hWndControl, 		
                            -1, 		
                            LVNI_FOCUSED		
                            );

                        //select first item to show hilite.
                        if (listIndex == -1)
                            ListView_SetItemState(hWndControl,
                                                  0,
                                                  LVIS_FOCUSED | LVIS_SELECTED,
                                                  LVIS_FOCUSED | LVIS_SELECTED);
                        break;
                    }
#endif
                }

            break;

        case WM_DESTROY:

               __try {
                    //revoke drag drop
                    RevokeDragDrop(GetDlgItem(hwndDlg, IDC_CERTMGR_LIST));
                 } __except(EXCEPTION_EXECUTE_HANDLER) {
                }

                pCertMgrInfo = (CERT_MGR_INFO *) GetWindowLongPtr(hwndDlg, DWLP_USER);

                if(pCertMgrInfo)
                {
                    if(pCertMgrInfo->pIDropTarget)
                        pCertMgrInfo->pIDropTarget->Release();
                }

                // destroy the image list in the list view        //
                hWndListView = GetDlgItem(hwndDlg, IDC_CERTMGR_LIST);

                if(NULL==hWndListView)
                    break;

                //no need to destroy the image list.  Handled by ListView
                //ImageList_Destroy(ListView_GetImageList(hWndListView, LVSIL_SMALL));

            break;
        case WM_HELP:
        case WM_CONTEXTMENU:
                if (msg == WM_HELP)
                {
                    hwnd = GetDlgItem(hwndDlg, ((LPHELPINFO)lParam)->iCtrlId);
                }
                else
                {
                    hwnd = (HWND) wParam;
                }


                if ((hwnd != GetDlgItem(hwndDlg, IDC_CERTMGR_LIST))             &&
                    (hwnd != GetDlgItem(hwndDlg, IDC_CERTMGR_PURPOSE_COMBO))    &&
                    (hwnd != GetDlgItem(hwndDlg, IDC_CERTMGR_IMPORT))           &&
                    (hwnd != GetDlgItem(hwndDlg, IDC_CERTMGR_EXPORT))           &&
                    (hwnd != GetDlgItem(hwndDlg, IDC_CERTMGR_VIEW))             &&
                    (hwnd != GetDlgItem(hwndDlg, IDC_CERTMGR_REMOVE))           &&
                    (hwnd != GetDlgItem(hwndDlg, IDC_CERTMGR_ADVANCE))          &&
                    (hwnd != GetDlgItem(hwndDlg, IDOK))                         &&
                    (hwnd != GetDlgItem(hwndDlg, IDC_CERTMGR_PURPOSE)))
                {
                    SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, TRUE);
                    return TRUE;
                }
                else
                {
                    return OnContextHelp(hwndDlg, msg, wParam, lParam, CertMgrMainHelpMap);
                }

            break;


        case WM_COMMAND:

                pCertMgrInfo = (CERT_MGR_INFO *) GetWindowLongPtr(hwndDlg, DWLP_USER);

                if(NULL == pCertMgrInfo)
                    break;

                pCertMgrStruct=pCertMgrInfo->pCertMgrStruct;

                if(NULL == pCertMgrStruct)
                    break;

                //a control is clicked
               if(HIWORD(wParam) == BN_CLICKED)
               {
                    switch (LOWORD(wParam))
                    {
                        case IDC_CERTMGR_ADVANCE:

                               //lauch the advanced dialogue
                                if(DIALOGUE_OK == DialogBoxParamU(
                                    g_hmodThisDll,
                                    (LPCWSTR)(MAKEINTRESOURCE(IDD_CERTMGR_ADVANCED)),
                                    hwndDlg,
                                    CertMgrAdvancedProc,
                                    (LPARAM) pCertMgrInfo))
                                {
                                    //if the advanced OIDs' list has been changed,
                                    //we need to refresh the list window
                                    if(TRUE == pCertMgrInfo->fAdvOIDChanged)
                                    {
                                        //mark the flag
                                        pCertMgrInfo->fAdvOIDChanged=FALSE;

                                        //repopulate the combo box based on
                                        //the new selection
                                        RepopulatePurposeCombo(hwndDlg,
                                            pCertMgrInfo);

                                        //refresh the list window only if
                                        //<advanced> is selected
                                        if(IsAdvancedSelected(hwndDlg))
                                            RefreshCertListView(hwndDlg, pCertMgrInfo);
                                    }
                                }

                            break;

                        case IDC_CERTMGR_REMOVE:
                                //get the selected certificate
                                if(NULL==(hWndControl=GetDlgItem(hwndDlg, IDC_CERTMGR_LIST)))
                                    break;

                                //get the selected cert
                                listIndex = ListView_GetNextItem(
                                    hWndControl, 		
                                    -1, 		
                                    LVNI_SELECTED		
                                    );

                                if (listIndex != -1)
                                {
                                    //get the selected tab
                                    if (pCertMgrStruct->dwFlags & CRYPTUI_CERT_MGR_SINGLE_TAB_FLAG)
                                        iIndex = pCertMgrStruct->dwFlags & CRYPTUI_CERT_MGR_TAB_MASK;
                                    else
                                        iIndex=TabCtrl_GetCurSel(GetDlgItem(hwndDlg, IDC_CERTMGR_TAB));

                                    if(-1==iIndex)
                                        break;

                                    //delete confirmation
                                    switch(iIndex)
                                    {
                                        case 0:
                                                idsDeleteConfirm=IDS_CERTMGR_PERSONAL_REMOVE;
                                            break;
                                        case 1:
                                                idsDeleteConfirm=IDS_CERTMGR_OTHER_REMOVE;
                                            break;
                                        case 2:
                                                idsDeleteConfirm=IDS_CERTMGR_CA_REMOVE;
                                            break;
                                        case 3:
                                                idsDeleteConfirm=IDS_CERTMGR_ROOT_REMOVE;
                                            break;
                                        case 4:
                                                idsDeleteConfirm=IDS_CERTMGR_PUBLISHER_REMOVE;
                                            break;
                                        default:
                                                idsDeleteConfirm=IDS_CERTMGR_PERSONAL_REMOVE;
                                            break;
                                    }

                                    iIndex=I_MessageBox(hwndDlg,
                                            idsDeleteConfirm,
                                            IDS_CERT_MGR_TITLE,
                                            pCertMgrStruct->pwszTitle,
                                            MB_ICONEXCLAMATION|MB_YESNO|MB_APPLMODAL);

                                    if(IDYES == iIndex)
                                    {
                                        //delete all the selected certificates
                                        GetAllSelectedItem(hWndControl,
                                                      ALL_SELECTED_DELETE,
                                                      NULL);

                                        //refresh the list view since some certificates
                                        //might be deleted
                                        
                                        //send the tab control

                                        SendMessage(hwndDlg, WM_NEXTDLGCTL, (WPARAM) 0, (LPARAM) NULL);

                                        RefreshCertListView(hwndDlg, pCertMgrInfo);
                                    }

                                }
                                else
                                {
                                    //output the message
                                    I_MessageBox(hwndDlg, IDS_HAS_TO_SELECT_CERT,
                                            IDS_CERT_MGR_TITLE,
                                            pCertMgrStruct->pwszTitle,
                                            MB_ICONERROR|MB_OK|MB_APPLMODAL);
                                }

                            break;
                        case IDC_CERTMGR_IMPORT:
                            {
                                DWORD dwTabIndex;
                                HCERTSTORE hTabStore = NULL;

                                // Import into the store associated with the
                                // currently selected tab
                                if (pCertMgrStruct->dwFlags & CRYPTUI_CERT_MGR_SINGLE_TAB_FLAG)
                                    dwTabIndex = pCertMgrStruct->dwFlags & CRYPTUI_CERT_MGR_TAB_MASK;
                                else
                                    dwTabIndex = TabCtrl_GetCurSel(
                                        GetDlgItem(hwndDlg, IDC_CERTMGR_TAB));

                                if (TAB_STORE_NAME_CNT > dwTabIndex) {
                                    hTabStore = CertOpenStore(
                                        CERT_STORE_PROV_SYSTEM_W,
                                        g_dwMsgAndCertEncodingType,
                                        NULL,
                                        CERT_STORE_MAXIMUM_ALLOWED_FLAG |
                                        CERT_STORE_SET_LOCALIZED_NAME_FLAG |
                                        CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG |
                                        CERT_SYSTEM_STORE_CURRENT_USER,
                                        rgpwszTabStoreName[dwTabIndex]
                                        );
                                }

                                //call the certificate import wizard
                                CryptUIWizImport(
                                    0,
                                    hwndDlg,
                                    NULL,
                                    NULL,
                                    hTabStore);

                                if (hTabStore)
                                    CertCloseStore(hTabStore, 0);

                                //refresh the list view since new certificates
                                //might be added
                                RefreshCertListView(hwndDlg, pCertMgrInfo);
                            }

                            break;

                        case IDC_CERTMGR_EXPORT:

                                //get the selected certificate
                                if(NULL==(hWndControl=GetDlgItem(hwndDlg, IDC_CERTMGR_LIST)))
                                    break;

                                //get the selected cert
                                listIndex = ListView_GetNextItem(
                                    hWndControl, 		
                                    -1, 		
                                    LVNI_SELECTED		
                                    );

                                if (listIndex != -1)
                                {

                                    //we call the export wizard differently based
                                    //on single or multiple selection
                                    if(ListView_GetSelectedCount(hWndControl) > 1)
                                    {
                                        //open a memory store
                                        hCertStore=CertOpenStore(
                                            CERT_STORE_PROV_MEMORY,
						                    g_dwMsgAndCertEncodingType,
						                    NULL,
						                    0,
						                    NULL);


                                        if(hCertStore)
                                        {
                                            GetAllSelectedItem(hWndControl,
                                                          ALL_SELECTED_COPY,
                                                          &hCertStore);

                                            //call the export wizard
                                            memset(&CryptUIWizExportInfo, 0, sizeof(CRYPTUI_WIZ_EXPORT_INFO));
                                            CryptUIWizExportInfo.dwSize=sizeof(CRYPTUI_WIZ_EXPORT_INFO);
                                            CryptUIWizExportInfo.dwSubjectChoice=CRYPTUI_WIZ_EXPORT_CERT_STORE_CERTIFICATES_ONLY;
                                            CryptUIWizExportInfo.hCertStore=hCertStore;

                                            CryptUIWizExport(0,
                                                            hwndDlg,
                                                            NULL,
                                                            &CryptUIWizExportInfo,
                                                            NULL);

                                            CertCloseStore(hCertStore, 0);
                                            hCertStore=NULL;
                                        }
                                    }
                                    else
                                    {
                                        memset(&lvItem, 0, sizeof(LV_ITEM));
                                        lvItem.mask=LVIF_PARAM;
                                        lvItem.iItem=listIndex;

                                        if(ListView_GetItem(hWndControl,
                                                         &lvItem))
                                        {
                                           if(pCertMgrInfo->dwCertCount > (DWORD)listIndex)
                                           {
                                                //call the export wizard
                                                memset(&CryptUIWizExportInfo, 0, sizeof(CRYPTUI_WIZ_EXPORT_INFO));
                                                CryptUIWizExportInfo.dwSize=sizeof(CRYPTUI_WIZ_EXPORT_INFO);
                                                CryptUIWizExportInfo.dwSubjectChoice=CRYPTUI_WIZ_EXPORT_CERT_CONTEXT;
                                                CryptUIWizExportInfo.pCertContext=(PCCERT_CONTEXT)(lvItem.lParam);

                                                CryptUIWizExport(0,
                                                                hwndDlg,
                                                                NULL,
                                                                &CryptUIWizExportInfo,
                                                                NULL);
                                           }
                                        }
                                    }
                                }
                                else
                                    //output the message
                                    I_MessageBox(hwndDlg, IDS_HAS_TO_SELECT_CERT,
                                            IDS_CERT_MGR_TITLE,
                                            pCertMgrStruct->pwszTitle,
                                            MB_ICONERROR|MB_OK|MB_APPLMODAL);

                            break;

                        case IDC_CERTMGR_VIEW:

                                //get the selected certificate
                                if(NULL==(hWndControl=GetDlgItem(hwndDlg, IDC_CERTMGR_LIST)))
                                    break;

                                //get the selected cert
                                listIndex = ListView_GetNextItem(
                                    hWndControl, 		
                                    -1, 		
                                    LVNI_SELECTED		
                                    );

                                if (listIndex != -1)
                                {
                                    //view certiificate
                                   if(pCertMgrInfo->dwCertCount > (DWORD)listIndex)
                                   {

                                        memset(&lvItem, 0, sizeof(LV_ITEM));
                                        lvItem.mask=LVIF_PARAM;
                                        lvItem.iItem=listIndex;

                                        if(ListView_GetItem(hWndControl,
                                                         &lvItem))
                                        {
                                            memset(&CertViewStruct, 0, sizeof(CRYPTUI_VIEWCERTIFICATE_STRUCT));
                                            CertViewStruct.dwSize=sizeof(CRYPTUI_VIEWCERTIFICATE_STRUCT);
                                            CertViewStruct.pCertContext=(PCCERT_CONTEXT)(lvItem.lParam);
                                            CertViewStruct.hwndParent=hwndDlg;


                                            fPropertyChanged=FALSE;

                                            CryptUIDlgViewCertificate(&CertViewStruct, &fPropertyChanged);

                                            if(fPropertyChanged)
                                            {
                                                RefreshCertListView(hwndDlg, pCertMgrInfo);

                                                //we reselect the one
                                                ListView_SetItemState(
                                                                    hWndControl,
                                                                    listIndex,
                                                                    LVIS_SELECTED,
                                                                    LVIS_SELECTED);
                                            }
                                        }
                                   }
                                }
                                else
                                    //output the message
                                    I_MessageBox(hwndDlg, IDS_HAS_TO_SELECT_CERT,
                                            IDS_CERT_MGR_TITLE,
                                            pCertMgrStruct->pwszTitle,
                                            MB_ICONERROR|MB_OK|MB_APPLMODAL);

                            break;

                        case IDOK:
                        case IDCANCEL:

                                EndDialog(hwndDlg, NULL);
                            break;

                        default:
                            break;
                    }
               }

                //a combo box's selection has been changed
                if(HIWORD(wParam) == CBN_SELCHANGE)
                {
                    switch(LOWORD(wParam))
                    {
                        case    IDC_CERTMGR_PURPOSE_COMBO:
                                //if the purpose is changed, we need to
                                //refresh the list view and certificate's
                                //detailed view
                                RefreshCertListView(hwndDlg, pCertMgrInfo);

                            break;
                    }

                }
            break;

    }

    return FALSE;
}

//--------------------------------------------------------------
//
// Save the advanced option from the registry
//--------------------------------------------------------------
void    SaveAdvValueToReg(CERT_MGR_INFO      *pCertMgrInfo)
{
    HKEY                hKeyExport=NULL;
    HKEY                hKeyPurpose=NULL;
    DWORD               dwDisposition=0;
    DWORD               dwExportFormat=0;
    DWORD               dwIndex=0;
    LPSTR               pszDefaultOID=NULL;
    LPSTR               pszOID=NULL;


    if(NULL==pCertMgrInfo)
        return;

    //open a registry entry for the export format under HKEY_CURRENT_USER
    if (ERROR_SUCCESS == RegCreateKeyExU(
                            HKEY_CURRENT_USER,
                            WSZCertMgrExportRegLocation,
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS,
                            NULL,
                            &hKeyExport,
                            &dwDisposition))
    {
        //set the value
        switch(pCertMgrInfo->dwExportFormat)
        {
            case CRYPTUI_WIZ_EXPORT_FORMAT_DER:
                    if(pCertMgrInfo->fExportChain)
                        dwExportFormat=4;
                    else
                        dwExportFormat=1;
                break;

            case CRYPTUI_WIZ_EXPORT_FORMAT_BASE64:
                    if(pCertMgrInfo->fExportChain)
                        dwExportFormat=5;
                    else
                        dwExportFormat=2;
                break;

            case CRYPTUI_WIZ_EXPORT_FORMAT_PKCS7:
                    if(pCertMgrInfo->fExportChain)
                        dwExportFormat=6;
                    else
                        dwExportFormat=3;
                break;

            default:
                break;
        }


        if(0 != dwExportFormat)
        {
            //set the value
            RegSetValueExU(
                hKeyExport,
                WSZCertMgrExportName,
                0,          // dwReserved
                REG_DWORD,
                (BYTE *) &dwExportFormat,
                sizeof(dwExportFormat));
        }

    }

    //open the registry entry for the advanced OIDs
    dwDisposition=0;

    if (ERROR_SUCCESS == RegCreateKeyExU(
                            HKEY_CURRENT_USER,
                            WSZCertMgrPurposeRegLocation,
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS,
                            NULL,
                            &hKeyPurpose,
                            &dwDisposition))
    {
        //build a char "," seperated string for simple OID
        pszDefaultOID=(LPSTR)WizardAlloc(sizeof(CHAR));
        if(NULL == pszDefaultOID)
            goto CLEANUP;

        *pszDefaultOID=L'\0';

        for(dwIndex=0; dwIndex<pCertMgrInfo->dwOIDInfo; dwIndex++)
        {
            if(FALSE==(pCertMgrInfo->rgOIDInfo)[dwIndex].fSelected)
            {
                if(strlen(pszDefaultOID)!=0)
                    strcat(pszDefaultOID, ",");

                pszOID=(pCertMgrInfo->rgOIDInfo)[dwIndex].pszOID;

                pszDefaultOID=(LPSTR)WizardRealloc(pszDefaultOID,
                    sizeof(CHAR)*(strlen(pszDefaultOID)+strlen(pszOID)+strlen(",")+1));

                if(NULL==pszDefaultOID)
                    goto CLEANUP;

                strcat(pszDefaultOID,pszOID);
            }
        }

        //set the value
        RegSetValueEx(
            hKeyPurpose,
            SZCertMgrPurposeName,
            0,
            REG_SZ,
            (BYTE *)(pszDefaultOID),
            (strlen(pszDefaultOID) + 1) * sizeof(CHAR));

    }

CLEANUP:

    if(pszDefaultOID)
        WizardFree(pszDefaultOID);

    //close the registry keys
    if(hKeyExport)
        RegCloseKey(hKeyExport);

    if(hKeyPurpose)
        RegCloseKey(hKeyPurpose);

}


//--------------------------------------------------------------
//
// Get init value from the registry
//--------------------------------------------------------------
void    GetInitValueFromReg(CERT_MGR_INFO      *pCertMgrInfo)
{
    HKEY                hKeyExport=NULL;
    HKEY                hKeyPurpose=NULL;
    DWORD               dwType=0;
    DWORD               dwExportFormat=0;
    DWORD               cbExportFormat=0;

    LPSTR               pszDefaultOID=NULL;
    DWORD               cbDefaultOID=0;

    LPSTR               pszTok=NULL;
    DWORD               cTok = 0;
    DWORD               cCount=0;
    CERT_ENHKEY_USAGE   KeyUsage;
    LPSTR               rgBasicOID[]={szOID_PKIX_KP_CLIENT_AUTH,
                                      szOID_PKIX_KP_EMAIL_PROTECTION};
    BOOL                fNoRegData=FALSE;

    if(NULL==pCertMgrInfo)
        return;

    //memset
    memset(&KeyUsage,0,sizeof(CERT_ENHKEY_USAGE));

    //open the registry key if user has saved the advaced options
    if(ERROR_SUCCESS == RegOpenKeyExU(HKEY_CURRENT_USER,
                    WSZCertMgrExportRegLocation,
                    0,
                    KEY_READ,
                    &hKeyExport))
    {
        //get the data
        cbExportFormat=sizeof(dwExportFormat);

        if(ERROR_SUCCESS == RegQueryValueExU(
                        hKeyExport,
                        WSZCertMgrExportName,
                        NULL,
                        &dwType,
                        (BYTE *)&dwExportFormat,
                        &cbExportFormat))
        {
            //      added check for reg_binary because on WIN95 OSR2 when the machine is changed
            //      from mutli-user profiles to single user profile, the registry DWORD values
            //      change to BINARY
            //
	        if ((dwType == REG_DWORD) ||
                (dwType == REG_BINARY))
	        {
                switch(dwExportFormat)
                {
                    case    1:
                            pCertMgrInfo->dwExportFormat=CRYPTUI_WIZ_EXPORT_FORMAT_DER;
                            pCertMgrInfo->fExportChain=FALSE;
                        break;
                    case    2:
                            pCertMgrInfo->dwExportFormat=CRYPTUI_WIZ_EXPORT_FORMAT_BASE64;
                            pCertMgrInfo->fExportChain=FALSE;
                        break;
                    case    3:
                            pCertMgrInfo->dwExportFormat=CRYPTUI_WIZ_EXPORT_FORMAT_PKCS7;
                            pCertMgrInfo->fExportChain=FALSE;
                        break;
                    case    4:
                            pCertMgrInfo->dwExportFormat=CRYPTUI_WIZ_EXPORT_FORMAT_DER;
                            pCertMgrInfo->fExportChain=TRUE;
                        break;
                    case    5:
                            pCertMgrInfo->dwExportFormat=CRYPTUI_WIZ_EXPORT_FORMAT_BASE64;
                            pCertMgrInfo->fExportChain=TRUE;
                        break;
                    case    6:
                            pCertMgrInfo->dwExportFormat=CRYPTUI_WIZ_EXPORT_FORMAT_PKCS7;
                            pCertMgrInfo->fExportChain=TRUE;
                        break;
                    default:
                        break;
                }

            }
        }
    }


    //get the advanced purposed
    if(ERROR_SUCCESS == RegOpenKeyExU(HKEY_CURRENT_USER,
                    WSZCertMgrPurposeRegLocation,
                    0,
                    KEY_READ,
                    &hKeyPurpose))
    {
        dwType=0;
        cbDefaultOID=0;

        if((ERROR_SUCCESS == RegQueryValueEx(
                        hKeyPurpose,
                        SZCertMgrPurposeName,
                        NULL,
                        &dwType,
                        NULL,
                        &cbDefaultOID))&&(cbDefaultOID!=0))
        {
            pszDefaultOID=(LPSTR)WizardAlloc(cbDefaultOID);

            if(NULL==pszDefaultOID)
                goto CLEANUP;

            if(ERROR_SUCCESS != RegQueryValueEx(
                        hKeyPurpose,
                        SZCertMgrPurposeName,
                        NULL,
                        &dwType,
                        (BYTE *)pszDefaultOID,
                        &cbDefaultOID))
                goto CLEANUP;

            //
            // Count the number of OIDs as well as converting from comma delimited
            // to NULL character delimited
            //
            if(0==strlen(pszDefaultOID))
                fNoRegData=TRUE;
            else
            {

                pszTok = strtok(pszDefaultOID, ",");
                while ( pszTok != NULL )
                {
                    cTok++;
                    pszTok = strtok(NULL, ",");
                }

                //
                // Allocate a cert enhanced key usage structure and fill it in with
                // the string tokens
                //

                pszTok = pszDefaultOID;
                KeyUsage.cUsageIdentifier = cTok;
                KeyUsage.rgpszUsageIdentifier = (LPSTR *)WizardAlloc(cTok * sizeof(LPSTR));

                if(NULL==KeyUsage.rgpszUsageIdentifier)
                    goto CLEANUP;

                for ( cCount = 0; cCount < cTok; cCount++ )
                {
                    KeyUsage.rgpszUsageIdentifier[cCount] = pszTok;
                    pszTok = pszTok+strlen(pszTok)+1;
                }

            }
        }
    }

    //set up the default OIDs if the registry is empty
    if(0 == KeyUsage.cUsageIdentifier && TRUE != fNoRegData)
    {
        KeyUsage.cUsageIdentifier=2;
        KeyUsage.rgpszUsageIdentifier=rgBasicOID;
    }


    //mark the OIDs as advanced for basic
    for(cCount=0; cCount<pCertMgrInfo->dwOIDInfo; cCount++)
    {
        if(IsAdvancedOID(&KeyUsage,
                         (pCertMgrInfo->rgOIDInfo)[cCount].pszOID))
            (pCertMgrInfo->rgOIDInfo)[cCount].fSelected=TRUE;
    }


CLEANUP:

   //free memory
    if(pszDefaultOID)
    {
        WizardFree(pszDefaultOID);

        if(KeyUsage.rgpszUsageIdentifier)
            WizardFree(KeyUsage.rgpszUsageIdentifier);
    }

    //close the registry keys
    if(hKeyExport)
        RegCloseKey(hKeyExport);

    if(hKeyPurpose)
        RegCloseKey(hKeyPurpose);

    return;
}
//--------------------------------------------------------------
//
//  Parameters:
//      pCryptUICertMgr       IN  Required
//
//
//--------------------------------------------------------------
BOOL
WINAPI
CryptUIDlgCertMgr(
        IN PCCRYPTUI_CERT_MGR_STRUCT pCryptUICertMgr)
{
    BOOL                fResult=FALSE;
    CERT_MGR_INFO       CertMgrInfo;
    HRESULT             hr=S_OK;
    DWORD               dwException=0;

    //check the input parameter
    if(NULL==pCryptUICertMgr)
        goto InvalidArgErr;

    if(sizeof(CRYPTUI_CERT_MGR_STRUCT) != pCryptUICertMgr->dwSize)
        goto InvalidArgErr;

    if ((pCryptUICertMgr->dwFlags & CRYPTUI_CERT_MGR_TAB_MASK) >
            CRYPTUI_CERT_MGR_PUBLISHER_TAB)
        goto InvalidArgErr;

    if (!WizardInit())
    {
        goto InitOIDErr;
    }

    //init struct
    memset(&CertMgrInfo, 0, sizeof(CertMgrInfo));

    CertMgrInfo.pCertMgrStruct=pCryptUICertMgr;

    //get all the enhanced key usage OIDs
    if(!InitPurposeOID(pCryptUICertMgr->pszInitUsageOID,
                       &(CertMgrInfo.dwOIDInfo),
                       &(CertMgrInfo.rgOIDInfo)))
        goto InitOIDErr;

    //init the column sort
    CertMgrInfo.rgdwSortParam[0]=SORT_COLUMN_SUBJECT | SORT_COLUMN_ASCEND;
    CertMgrInfo.rgdwSortParam[1]=SORT_COLUMN_ISSUER | SORT_COLUMN_DESCEND;
    CertMgrInfo.rgdwSortParam[2]=SORT_COLUMN_EXPIRATION | SORT_COLUMN_DESCEND;
    CertMgrInfo.rgdwSortParam[3]=SORT_COLUMN_NAME | SORT_COLUMN_DESCEND;
    CertMgrInfo.rgdwSortParam[4]=SORT_COLUMN_NAME | SORT_COLUMN_DESCEND;

    //we sort the 1st column
    CertMgrInfo.iColumn=0;


    //init the export format
    CertMgrInfo.dwExportFormat=CRYPTUI_WIZ_EXPORT_FORMAT_DER;
    CertMgrInfo.fExportChain=FALSE;
    CertMgrInfo.fAdvOIDChanged=FALSE;

    //init the OLE library

    __try {
        if(!SUCCEEDED(hr=OleInitialize(NULL)))
            goto OLEInitErr;

        //get the initialization from the registry
        GetInitValueFromReg(&CertMgrInfo);

        //call the dialog box
        if (DialogBoxParamU(
                    g_hmodThisDll,
                    (LPCWSTR)(MAKEINTRESOURCE(IDD_CERTMGR_MAIN)),
                    (pCryptUICertMgr->hwndParent != NULL) ? pCryptUICertMgr->hwndParent : GetDesktopWindow(),
                    CertMgrDialogProc,
                    (LPARAM) &CertMgrInfo) == -1)
        {
            OleUninitialize();
            goto DialogBoxErr;
        }


        OleUninitialize();
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        dwException = GetExceptionCode();
        goto ExceptionErr;
    }

    fResult=TRUE;

CommonReturn:

    //free the cert arrays
    FreeCerts(&CertMgrInfo);

    //free the usage OID array
    FreeUsageOID(CertMgrInfo.dwOIDInfo,
                 CertMgrInfo.rgOIDInfo);


    return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
TRACE_ERROR(DialogBoxErr);
TRACE_ERROR(InitOIDErr);
SET_ERROR_VAR(OLEInitErr, hr);
SET_ERROR_VAR(ExceptionErr, dwException)

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\ui\wizards\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------



//Dialogue and strings
//
#define IDD_COMPLETION                  184
#define IDD_CERTIFICATE_AUTHORITY       185
#define IDD_PURPOSE                     186
#define IDD_CSP_SERVICE_PROVIDER        187
#define IDD_NAME_DESCRIPTION            188
#define IDD_WELCOME                     190
#define IDD_SENDING                     191
#define IDD_FAILED                      192
#define IDD_RECIEVED                    193
#define IDD_RENEW_WELCOME               194
#define IDD_RENEW_COMPLETION            195
#define IDD_RENEW_SERVICE_PROVIDER      196
#define IDD_RENEW_CA                    197
#define IDD_IMPORT_WELCOME              198
#define IDD_IMPORT_FILE                 199
#define IDD_IMPORT_PASSWORD             200
#define IDD_IMPORT_STORE                201
#define IDD_IMPORT_COMPLETION           202
#define IDD_BUILDCTL_WELCOME            203
#define IDD_BUILDCTL_PURPOSE            204
#define IDD_BUILDCTL_CERTS              205
#define IDD_BUILDCTL_DESTINATION        206
#define IDD_BUILDCTL_NAME               207
#define IDD_BUILDCTL_COMPLETION         208
#define IDD_BUILDCTL_USER_PURPOSE       209
#define IDD_EXPORTWIZARD_WELCOME        210
#define IDD_EXPORTWIZARD_PRIVATEKEYS    211
#define IDD_EXPORTWIZARD_PASSWORD       212
#define IDD_EXPORTWIZARD_FORMAT         213
#define IDD_EXPORTWIZARD_FILENAME       214
#define IDD_EXPORTWIZARD_COMPLETION     215
#define IDD_SIGN_WELCOME                216
#define IDD_SIGN_CERT                   217
#define IDD_SIGN_TIMESTAMP              218
#define IDD_SIGN_COMPLETION             219
#define IDD_SIGN_FILE_NAME              220
#define IDD_SIGN_OPTION                 222
#define IDD_SIGN_PVK                    223
#define IDD_SIGN_HASH                   224
#define IDD_SIGN_CHAIN                  225
#define IDD_SIGN_DESCRIPTION            226
#define IDD_RENEW_OPTIONS               227 

//CA selection dialogue
#define IDD_SELECTCA_DIALOG             221

//certmgr dialogue
#define IDD_CERTMGR_MAIN                229
#define IDD_CERTMGR_ADVANCED            230


//controls
#define IDC_WIZARD_BUTTON1              1000
#define IDC_WIZARD_LIST1                1001
#define IDC_WIZARD_CHECK1               1002
#define IDC_WIZARD_EDIT1                1003
#define IDC_WIZARD_EDIT2                1004
#define IDC_WIZARD_BUTTON2              1005
#define IDC_WIZARD_STATIC_BOLD1         1006
#define IDC_WIZARD_STATIC_BOLD2         1007
#define IDC_WIZARD_STATIC_BIG_BOLD1     1008
#define IDC_WIZARD_LIST2                1009
#define IDC_WIZARD_CHECK2               1010
#define IDC_WIZARD_RADIO1               1011
#define IDC_WIZARD_RADIO2               1012
#define IDC_WIZARD_STATIC_BOLD3         1013
#define IDC_WIZARD_STATIC1              1014
#define IDC_WIZARD_BUTTON3              1015
#define IDC_WIZARD_BUTTON4              1016
#define IDC_WIZARD_COMBO1               1017
#define IDC_WIZARD_STATIC_TEXT          1018
#define IDC_WIZARD_CHECK_EXPORTKEY      1019

//BuildCTL wizard
//

//IDD_BUILDCTL_PURPOSE
#define IDC_WIZARD_EDIT_MONTH           1050
#define IDC_WIZARD_EDIT_DAY             1051


//////////////////////////////////////////////////////////////////////////////
//Minimal Signing wizard                        
#define IDC_CERT_LIST                   1060
#define IDC_SIGN_STORE_BUTTON           1061
#define IDC_SIGN_VIEW_BUTTON            1062
#define IDC_SIGN_FILE_BUTTON            1063
#define IDC_PROMPT_STATIC               1064
#define IDC_NOTE_STATIC                 1065


//////////////////////////////////////////////////////////////////////////////
//CA selection dialogue                        
#define IDC_CA_OK                       1066
#define IDC_CA_CANCEL                   1067
#define IDC_CA_NOTE_STATIC              1068
#define IDC_CA_LIST                     1069


//////////////////////////////////////////////////////////////////////////////
//Typical Signing wizard   
//Reserve range 1080-1110                            
#define IDC_PVK_FILE_RADIO                          1080
#define IDC_PVK_FILE_BUTTON                         1081
#define IDC_PVK_FILE_EDIT                           1082
#define IDC_PVK_FILE_CSP_COMBO                      1083
#define IDC_PVK_FILE_TYPE_COMBO                     1084
#define IDC_PVK_CONTAINER_RADIO                     1085
#define IDC_PVK_CONTAINER_CSP_COMBO                 1086
#define IDC_PVK_CONTAINER_TYPE_COMBO                1087
#define IDC_PVK_CONTAINER_NAME_COMBO                1088
#define IDC_PVK_CONTAINER_KEY_TYPE_COMBO            1089
#define IDC_CHAIN_NO_ROOT_RADIO                     1090
#define IDC_CHAIN_ROOT_RADIO                        1091
#define IDC_NO_CHAIN_RADIO                          1092
#define IDC_CHAIN_FILE_RADIO                        1093
#define IDC_CHAIN_STORE_RADIO                       1094
#define IDC_FILE_BUTTON                             1095
#define IDC_STORE_BUTTON                            1096
#define IDC_FILE_EDIT                               1097
#define IDC_STORE_EDIT                              1098
#define IDC_WIZARD_NO_ADD_CERT_RADIO                1099


//////////////////////////////////////////////////////////////////////////////
//CertMgr Dialogue   
//Reserve range 1111-1130                            
#define IDC_CERTMGR_LIST                            1111
#define IDC_CERTMGR_PURPOSE_COMBO                   1112
#define IDC_CERTMGR_TAB                             1113
#define IDC_CERTMGR_IMPORT                          1114
#define IDC_CERTMGR_EXPORT                          1115
#define IDC_CERTMGR_VIEW                            1116
#define IDC_CERTMGR_REMOVE                          1117
#define IDC_CERTMGR_ADVANCE                         1118
//efine IDC_CERTMGR_SUBJECT                         1119
//efine IDC_CERTMGR_ISSUER                          1120
#define IDC_CERTMGR_PURPOSE                         1121
//efine IDC_CERTMGR_EXPIRE                          1122
//efine IDC_CERTMGR_NAME                            1123
#define IDC_CERTMGR_ADV_LIST                        1124
#define IDC_CERTMGR_EXPORT_COMBO                    1125
#define IDC_CERTMGR_EXPORT_CHECK                    1126
//efine IDC_CERTMGR_STATIC_SUBJECT                  1127
//efine IDC_CERTMGR_STATIC_ISSUER                   1128
//efine IDC_CERTMGR_STATIC_EXPIRE                   1129
//efine IDC_CERTMGR_STATIC_PURPOSE                  1130
//efine IDC_CERTMGR_STATIC_NAME                     1131




#define IDC_WIZARD_STATIC               -1


//The strings 
//
#define         IDS_INVALID_INFO_FOR_PKCS10     6135
#define         IDS_INVALID_PVK_FOR_PKCS10      6136
#define         IDS_ENROLL_CONFIRM              6137
#define         IDS_NO_CA                       6138
#define         IDS_RENEW_CONFIRM               6139
#define         IDS_REQUEST_FAIL                6140
#define         IDS_CSP_NOT_SUPPORTED_BY_CA     6141
#define         IDS_FAIL_INIT_DLL               6142
#define         IDS_ENROLL_WIZARD_TITLE         6143
#define         IDS_RENEW_WIZARD_TITLE          6144
#define         IDS_FRIENDLY_NAME               6145
#define         IDS_NONE                        6146
#define         IDS_USER_NAME                   6147
#define         IDS_COMPUTER_NAME               6148
#define         IDS_SERVICE_NAME                6149
#define         IDS_CA                          6150
#define         IDS_CSP                         6151
#define         IDS_NO_CSP_FOR_PURPOSE          6152
#define         IDS_NO_SELECTED_PURPOSE         6153
#define         IDS_INVALID_CSP                 6154
#define         IDS_NO_CA_FOR_CSP               6155
#define         IDS_FAIL_INIT_WIZARD            6156
#define         IDS_LARGEFONTNAME               6157
#define         IDS_LARGEFONTSIZE               6158
#define         IDS_YES                         6160
#define         IDS_NO                          6161
#define         IDS_PUBLISH_DS                  6162
#define         IDS_REQUEST_FAILED              6163
#define         IDS_REQUEST_ERROR               6164
#define         IDS_REQUEST_DENIED              6165
#define         IDS_REQUEST_SUCCEDDED           6166
#define         IDS_ISSUED_SEPERATE             6167
#define         IDS_UNDER_SUBMISSION            6168
#define         IDS_INSTALL_FAILED              6169
#define         IDS_CONNET_CA_FAILED            6170
#define         IDS_INSTAL_CANCELLED            6171
#define         IDS_SMART_CARD                  6172
#define         IDS_ENCODE_CERT                 6173
#define         IDS_ENCODE_CTL                  6174
#define         IDS_ENCODE_CRL                  6175
#define         IDS_SERIALIZED_STORE            6176
#define         IDS_SERIALIZED_CERT             6177
#define         IDS_SERIALIZED_CTL              6178
#define         IDS_SERIALIZED_CRL              6179
#define         IDS_PKCS7_SIGNED                6180
#define         IDS_PFX_BLOB                    6181
#define         IDS_FILE_NAME                   6182
#define         IDS_CONTENT_TYPE                6183
#define         IDS_BEST_FOR_ME                 6184
#define         IDS_STORE_NAME                  6185
#define         IDS_HAS_TO_SELECT_FILE          6186
#define         IDS_IMPORT_WIZARD_TITLE         6187
#define         IDS_INVALID_PASSWORD            6188
#define         IDS_HAS_TO_SELECT_STORE         6189
#define         IDS_INVALID_WIZARD_INPUT        6190
#define         IDS_FAIL_TO_RECOGNIZE           6191
#define         IDS_FAIL_READ_FILE              6192
#define         IDS_FAIL_INIT_IMPORT            6193
#define         IDS_IMPORT_FAIL_FIND_CONTENT    6194
#define         IDS_IMPORT_SUCCEEDED            6195
#define         IDS_IMPORT_FAIL_MOVE_CONTENT    6196
#define         IDS_FAIL_OPEN_TRUST             6197
#define         IDS_FAIL_ADD_CTL_TRUST          6198
#define         IDS_FAIL_OPEN_CA                6199
#define         IDS_FAIL_ADD_CRL_CA             6200
#define         IDS_FAIL_OPEN_MY                6201
#define         IDS_FAIL_ADD_CERT_MY            6202
#define         IDS_FAIL_ADD_CERT_CA            6203 
#define         IDS_FAIL_READ_FILE_ENTER        6204
#define         IDS_FAIL_TO_RECOGNIZE_ENTER     6205
#define         IDS_NOT_SELF_SIGNED             6206
#define         IDS_BUILDCTL_WIZARD_TITLE       6207
#define         IDS_NO_MATCH_USAGE              6208
#define         IDS_CER_FILTER                  6209
#define         IDS_FAIL_TO_READ_FROM_FILE      6210
#define         IDS_INVALID_CERT_FILE           6211
#define         IDS_NO_MATCH_IN_CTL             6212
#define         IDS_NO_MATCH_USAGE_FROM_CTL     6213
#define         IDS_NOT_SELF_SIGNED_FROM_CTL    6214
#define         IDS_WIZARD_ERROR_OID            6215
#define         IDS_PURPOSE                     6216
#define         IDS_EXISTING_OID                6217
#define         IDS_SURE_CERT_GONE              6218
#define         IDS_COLUMN_SUBJECT              6220
#define         IDS_COLUMN_ISSUER               6221
#define         IDS_COLUMN_PURPOSE              6222
#define         IDS_COLUMN_EXPIRE               6223
#define         IDS_FAIL_TO_DELETE              6224
#define         IDS_HAS_TO_SELECT_CERT          6225
#define         IDS_CTL_FILTER                  6226
#define         IDS_INVALID_ALGORITHM_IN_CTL    6229
#define         IDS_FAIL_INIT_BUILDCTL          6230
#define         IDS_FAIL_TO_BUILD_CTL           6231
#define         IDS_FAIL_TO_ADD_CTL_TO_STORE    6232
#define         IDS_FAIL_TO_ADD_CTL_TO_FILE     6233
#define         IDS_BUILDCTL_SUCCEEDED          6234
#define         IDS_ALL_USAGE                   6235
#define         IDS_NO_PVK_FOR_RENEW_CERT       6236
#define         IDS_EXPORT_WIZARD_TITLE         6237
#define         IDS_RPC_CALL_FAILED             6238
#define         IDS_MISMATCH_PASSWORDS          6239
#define         IDS_SELECT_FORMAT               6240
#define         IDS_INPUT_FILENAME              6241
#define         IDS_SERIALIZED_STORE_SAVE       6242
#define         IDS_MYSERIALIZED_STORE          6243
#define         IDS_CRL_SAVE                    6244
#define         IDS_CRL                         6245
#define         IDS_CTL_SAVE                    6246
#define         IDS_CTL                         6247
#define         IDS_DER_SAVE                    6248
#define         IDS_DER                         6249
#define         IDS_PFX_SAVE                    6250
#define         IDS_PFX                         6251
#define         IDS_PKCS7_SAVE                  6252
#define         IDS_PKCS7                       6253
#define         IDS_EXPORT_CHAIN                6254
#define         IDS_EXPORT_KEYS                 6255
#define         IDS_FILE_FORMAT                 6256
#define         IDS_UNKNOWN                     6257
#define         IDS_SURE_REPLACE                6258
#define         IDS_INVALID_DAYS                6259
#define         IDS_INVALID_MONTHS              6260
#define         IDS_INVALID_DURATION            6261
#define         IDS_STORE_BY_USER               6262
#define         IDS_STORE_BY_WIZARD             6263
#define         IDS_OUT_OF_MEMORY               6264
#define         IDS_OVERWRITE_FILE_NAME         6265
#define         IDS_ALL_CER_FILTER              6266
#define         IDS_SOME_NOT_SELF_SIGNED        6267
#define         IDS_SOME_NO_MATCH_USAGE         6268
#define         IDS_SIGN_CONFIRM_TITLE          6269
#define         IDS_SIGN_CERT                   6270
#define         IDS_SIGN_CERT_ISSUE_TO          6271
#define         IDS_SIGN_CERT_ISSUE_BY          6272
#define         IDS_SIGN_CERT_EXPIRATION        6273
#define         IDS_TIEMSTAMP_ADDR              6274
#define         IDS_SIGN_FILE_FILTER            6275
#define         IDS_NO_FILE_NAME_TO_SIGN        6276
#define         IDS_SELECT_SIGNING_CERT         6277
#define         IDS_INVALID_TIMESTAMP_ADDRESS   6278
#define         IDS_NO_TIMESTAMP_ADDRESS        6279
#define         IDS_SIGNING_WIZARD_TITLE        6280
#define         IDS_SIGN_INVALID_ARG            6281
#define         IDS_SIGN_FAILED                 6282
#define         IDS_TIMESTAMP_FAILED            6283
#define         IDS_SIGN_FAIL_INIT              6284
#define         IDS_SIGN_CTL_FAILED             6285
#define         IDS_SIGNING_SUCCEEDED           6286
#define         IDS_COLUMN_CA_NAME              6287
#define         IDS_COLUMN_CA_MACHINE           6288
#define         IDS_HAS_TO_SELECT_CA            6289
#define         IDS_CA_SELECT_TITLE             6290
#define         IDS_BOLDFONTSIZE                6291
#define         IDS_BOLDFONTNAME                6292
#define         IDS_EXPORT_SUCCESSFULL          6293
#define         IDS_EXPORT_FAILED               6294
#define         IDS_BASE64_SAVE                 6295
#define         IDS_BASE64                      6296
#define         IDS_EXPORT_BADKEYS              6297
#define         IDS_SIGN_INVALID_ADDRESS        6298
#define         IDS_SIGN_TS_CERT_INVALID        6299
#define         IDS_PVK_FILE_FILTER             6300
#define         IDS_KEY_EXCHANGE                6301
#define         IDS_KEY_SIGNATURE               6302
#define         IDS_CSP_RSA_FULL                6303
#define         IDS_CSP_RSA_SIG                 6304
#define         IDS_CSP_DSS                     6305
#define         IDS_CSP_FORTEZZA                6306
#define         IDS_CSP_MS_EXCHANGE             6307
#define         IDS_CSP_SSL                     6308
#define         IDS_CSP_RSA_SCHANNEL            6309
#define         IDS_CSP_DSS_DH                  6310
#define         IDS_CSP_EC_ECDSA_SIG            6311
#define         IDS_CSP_EC_ECNRA_SIG            6312
#define         IDS_CSP_EC_ECDSA_FULL           6313
#define         IDS_CSP_EC_ECNRA_FULL           6314
#define         IDS_CSP_DH_SCHANNEL             6315
#define         IDS_CSP_SPYRUS_LYNKS            6316
#define         IDS_SPC_FILE_FILTER             6317
#define         IDS_INVALID_SPC_FILE            6318
#define         IDS_SPC_FILE_NAME               6319
#define         IDS_SIGN_SPC_FILE               6320
#define         IDS_SIGN_PVK_FILE               6321
#define         IDS_SIGN_CSP_NAME               6322
#define         IDS_SIGN_CSP_TYPE               6323
#define         IDS_SIGN_KEY_CONTAINER          6324
#define         IDS_SIGN_KEY_SPEC               6325
#define         IDS_HASH_ALG                    6326
#define         IDS_SIGN_NO_CHAIN               6327
#define         IDS_SIGN_CHAIN_ROOT             6328
#define         IDS_SIGN_CHAIN_NO_ROOT          6329
#define         IDS_SIGN_CERT_CHAIN             6330
#define         IDS_SIGN_NO_ADD                 6331
#define         IDS_SIGN_ADD_FILE               6332
#define         IDS_SIGN_ADD_STORE              6333
#define         IDS_CONTENT_DES                 6334
#define         IDS_CONTENT_URL                 6335
#define         IDS_CERT_SPC_FILE_FILTER        6336
#define         IDS_INVALID_CERT_SPC_FILE       6337
#define         IDS_HAS_TO_SPECIFY_PVK_FILE     6339
#define         IDS_HAS_TO_SPECIFY_CSP          6340
#define         IDS_HAS_TO_SPECIFY_CONTAINER    6341
#define         IDS_HAS_TO_SPECIFY_KEY_TYPE     6342
#define         IDS_HAS_TO_SELECT_HASH          6343
#define         IDS_SELECT_ADD_FILE             6344
#define         IDS_SELECT_ADD_STORE            6345
#define         IDS_FILE_TO_SIGN                6346
#define         IDS_SIGN_SPC_PROMPT             6347
#define         IDS_SIGN_NOMATCH                6348
#define         IDS_SIGN_AUTH                   6349
#define         IDS_SIGN_RESIZE                 6350
#define         IDS_SIGN_NO_PROVIDER            6351
#define         IDS_SIGN_NO_CHAINING            6352
#define         IDS_SIGN_EXPRIED                6353
#define         IDS_IMPORT_FILE_FILTER          6354
#define         IDS_FAIL_OPEN_ROOT              6355
#define         IDS_FAIL_ADD_CERT_ROOT          6356
#define         IDS_EXIT_CERT_IN_CTL            6357
#define         IDS_OID_ADVANCED                6358
#define         IDS_TAB_PERSONAL                6359
#define         IDS_TAB_OTHER                   6360
#define         IDS_TAB_CA                      6361
#define         IDS_TAB_ROOT                    6362
#define         IDS_CERT_MGR_TITLE              6363
#define         IDS_OID_ALL                     6364
#define         IDS_CERTMGR_DER                 6365
#define         IDS_CERTMGR_BASE64              6366
#define         IDS_CERTMGR_PKCS7               6367
#define         IDS_COLUMN_NAME                 6368
#define         IDS_CERTMGR_PERSONAL_REMOVE     6369
#define         IDS_CERTMGR_OTHER_REMOVE        6370
#define         IDS_CERTMGR_CA_REMOVE           6371
#define         IDS_CERTMGR_ROOT_REMOVE         6372
#define         IDS_SIGN_RESPONSE_INVALID       6373
#define         IDS_CERTIFICATE                 6374
#define         IDS_CER                         6375
#define         IDS_P7C                         6376
#define         IDS_ALL_INVALID_DROP_FILE       6377
#define         IDS_SOME_INVALID_DROP_FILE      6378
#define         IDS_PATH_NOT_FOUND              6379
#define         IDS_NO_SELECTED_CTL_PURPOSE     6380
#define         IDS_CTL_DESCRIPTION             6381
#define         IDS_CTL_VALIDITY                6382
#define         IDS_CTL_ID                      6383
#define         IDS_CTL_VALID_MONTH_DAY         6384
#define         IDS_CTL_VALID_MONTH             6385
#define         IDS_CTL_VALID_DAY               6386
#define         IDS_CTL_PURPOSE                 6387
#define         IDS_ENROLL_NO_CERT_TYPE         6388
#define         IDS_NO_CA_FOR_ENROLL            6389
#define         IDS_NO_PERMISSION_FOR_CERTTYPE  6390
#define         IDS_NO_USER_PROTECTED_FOR_REMOTE  6391
#define         IDS_HAS_TO_PROVIDE_CA           6392
#define         IDS_NO_SELECTED_CSP             6393
#define         IDS_NO_CERTIFICATE_FOR_RENEW    6394
#define         IDS_INVALID_CERTIFICATE_TO_RENEW   6395
#define         IDS_FAIL_TO_GET_USER_NAME       6396
#define         IDS_FAIL_TO_GET_COMPUTER_NAME   6397
#define         IDS_FAIL_TO_GET_CSP_LIST        6398
#define         IDS_CSP_NOT_SUPPORTED           6399
#define         IDS_INVALID_CA_FOR_ENROLL       6400
#define         IDS_IMPORT_DUPLICATE            6401
#define         IDS_IMPORT_OBJECT_NOT_EXPECTED  6402
#define         IDS_IMPORT_CER_FILTER           6403
#define         IDS_IMPORT_CTL_FILTER           6404
#define         IDS_IMPORT_CRL_FILTER           6405
#define         IDS_IMPORT_CER_CRL_FILTER       6406
#define         IDS_IMPORT_CER_CTL_FILTER       6407
#define         IDS_IMPORT_CTL_CRL_FILTER       6408
#define         IDS_EXCEED_LIMIT                6409
#define         IDS_SIGN_PROMPT_CUSTOM          6410
#define         IDS_SIGN_PROMPT_TYPICAL         6411
#define         IDS_SELECTED_BY_WIZARD          6412
#define         IDS_KEY_NOT_EXPORTABLE          6413
#define         IDS_KEY_CORRUPT                 6414
#define         IDS_SIGN_FILE_NAME_NOT_SIP      6415
#define         IDS_SIGN_FILE_NAME_NOT_EXIST    6416
#define         IDS_EMPTY_CERT_IN_FILE          6417
#define         IDS_IMPORT_OBJECT_EMPTY         6418
#define         IDS_ENROLL_UI_NO_CERTTYPE       6419
#define         IDS_NON_EXIST_FILE              6420
#define         IDS_REPLACE_FILE                6421
#define         IDS_IMPORT_PFX_EMPTY            6422
#define         IDS_CERT_PVK                    6423
#define         IDS_KEY_PUBLISHER               6424
#define         IDS_NO_VALID_CERT_TEMPLATE      6425
#define         IDS_KEY_STATE_UNKNOWN           6426
#define         IDS_IMPORT_NO_PFX_FOR_REMOTE	6427
#define         IDS_CANNOT_DELETE_CERTS         6428
#define         IDS_EXPORT_UNSUPPORTED          6429
#define         IDS_KEYSIZE_40                  6430
#define         IDS_KEYSIZE_56                  6431
#define         IDS_KEYSIZE_64                  6432
#define         IDS_KEYSIZE_128                 6433
#define         IDS_KEYSIZE_256                 6434
#define         IDS_KEYSIZE_384                 6435
#define         IDS_KEYSIZE_512                 6436
#define         IDS_KEYSIZE_1024                6437
#define         IDS_KEYSIZE_2048                6438
#define         IDS_KEYSIZE_4096                6439
#define         IDS_KEYSIZE_8192                6440
#define         IDS_UNSUPPORTED_KEY             6441
#define         IDS_BAD_ENCODE                  6442

#define         IDS_TAB_PUBLISHER               6443
#define         IDS_CERTMGR_PUBLISHER_REMOVE    6444
#define         IDS_UNKNOWN_WIZARD_ERROR        6445

#define         IDS_FAIL_OPEN_ADDRESSBOOK       6450

#define         IDS_NO_ACCESS_TO_ICERTREQUEST2  6451
#define         IDS_CSP_BAD_ALGTYPE             6452
#define         IDS_IMPORT_REPLACE_EXISTING_NEWER_CRL 6453
#define         IDS_IMPORT_REPLACE_EXISTING_NEWER_CTL 6454
#define         IDS_IMPORT_CANCELLED                  6455
#define         IDS_IMPORT_ACCESS_DENIED              6456
#define         IDS_FAIL_ADD_CERT_OTHERPEOPLE         6457
#define         IDS_FAIL_ADD_CERT_TRUSTEDPEOPLE       6458
#define         IDS_FAIL_OPEN_TRUSTEDPEOPLE           6459
#define         IDS_NO_AD                             6460

#define         IDS_MIN_KEYSIZE                       6461
#define         IDS_KEY_EXPORTABLE                    6462 
#define         IDS_STRONG_PROTECTION                 6463

#define         IDS_SUBMIT_NO_ACCESS_TO_ICERTREQUEST2 6464
#define         IDS_NO_CA_FOR_ENROLL_REQUEST_FAILED   6465

/////////////////////////////////////////////////////////////////
// IDD_EXPORTWIZARD_WELCOME
#define IDC_WELCOME_STATIC              100
#define IDC_CMEW_STATIC                 101
#define IDC_WHATISCERT_STATIC           102
#define IDC_WHATISSTORE_STATIC          103

// IDD_EXPORTWIZARD_PRIVATEKEYS
#define IDC_EPKWC_STATIC                100
#define IDC_YESPKEYS_RADIO              101
#define IDC_NOPKEYS_RADIO               102
#define IDC_EXPORT_PKEY_NOTE            103

// IDD_EXPORTWIZARD_PASSWORD
#define IDC_PPPK_STATIC                 100
#define IDC_PASSWORD1_EDIT              101
#define IDC_PASSWORD2_EDIT              102

// IDD_EXPORTWIZARD_FORMAT
#define IDC_EFF_STATIC                  100
#define IDC_PFX_RADIO                   101
#define IDC_PKCS7_RADIO                 102
#define IDC_DER_RADIO                   103
#define IDC_INCLUDECHAIN_PFX_CHECK      104
#define IDC_INCLUDECHAIN_PKCS7_CHECK    105
#define IDC_BASE64_RADIO                106
#define IDC_STRONG_ENCRYPTION_CHECK		107
#define IDC_DELETE_PRIVATE_KEY_CHECK    108

// IDD_EXPORTWIZARD_FILENAME
#define IDC_EFN_STATIC                  100
#define IDC_NAME_EDIT                   101
#define IDC_BROWSE_BUTTON               102

// IDD_EXPORTWIZARD_COMPLETION
#define IDC_COMPLETING_STATIC           100
#define IDC_CMEW_STATIC                 101
#define IDC_SUMMARY_LIST                102
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\ui\wizards\selca.h ===
//--------------------------------------------------------------
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       selca.h
//
//  Contents:   The private include file for select a CA
//
//  History:    01-12-1997 xiaohs   created
//
//--------------------------------------------------------------
#ifndef SELCA_H
#define SELCA_H


#ifdef __cplusplus
extern "C" {
#endif
   

//**************************************************************************
//
//   The private data used for the CA selection dialogue
//
//**************************************************************************
//-----------------------------------------------------------------------
//  SELECT_CA_INFO
//
//
//  This struct contains everything you will ever need to call
//  the CA selection dialogue.  This struct is private to the dll
//------------------------------------------------------------------------
typedef struct _SELECT_CA_INFO
{
    PCCRYPTUI_SELECT_CA_STRUCT  pCAStruct;
    UINT                        idsMsg;
    BOOL                        fUseInitSelect;
    DWORD                       dwInitSelect;
    DWORD                       dwCACount;
    PCRYPTUI_CA_CONTEXT         *prgCAContext;
    PCRYPTUI_CA_CONTEXT         pSelectedCAContext;
    int                         iOrgCA;
    DWORD                       rgdwSortParam[2];
}SELECT_CA_INFO;



#define SORT_COLUMN_CA_NAME         0x0001
#define SORT_COLUMN_CA_LOCATION     0x0002

#ifdef __cplusplus
}       // Balance extern "C" above
#endif


#endif  //SIGNING_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\ui\wizards\signing.cpp ===
//-------------------------------------------------------------
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       signing.cpp
//
//  Contents:   The cpp file to implement the signing wizard
//
//  History:    5-11-1997 xiaohs   created
//
//--------------------------------------------------------------
#include    "wzrdpvk.h"
#include    "signpvk.h"
#include    "signhlp.h"

//************************************************************************************
//
//Helper functions for the signing wizard pages
//
//*************************************************************************************
//----------------------------------------------------------------------------
//
//  FileExist: Make sure the file exists, and is writable
//----------------------------------------------------------------------------
BOOL    CertPvkMatch(CERT_SIGNING_INFO *pPvkSignInfo, BOOL fTypical)
{
    BOOL                fMatch=FALSE;
    DWORD               dwKeySpec=0;
    LPWSTR              pwszCSP=NULL;
    DWORD               dwCSPType=0;
    LPWSTR              pwszContainer=NULL;
    LPWSTR              pwszPvkFile=NULL;
    BOOL                fAcquire=FALSE;
    WCHAR               wszPublisher[MAX_STRING_SIZE];


    HCRYPTPROV          hProv=NULL;
    LPWSTR              pwszTmpContainer=NULL;
    HCERTSTORE          hCertStore=NULL;
    PCCERT_CONTEXT      pCertContext=NULL;


    if(NULL == pPvkSignInfo)
        goto CLEANUP;

    __try {

    //get the private key information
    if(fTypical)
    {
 		if(!GetCryptProvFromCert(
                            NULL,
							pPvkSignInfo->pSignCert,
							&hProv,
							&dwKeySpec,
							&fAcquire,
							&pwszTmpContainer,
							&pwszCSP,
							&dwCSPType))
            goto CLEANUP;

    }
    else
    {
        if(pPvkSignInfo->fPvkFile)
        {
            pwszCSP=pPvkSignInfo->pwszPvk_CSP;
            dwCSPType=pPvkSignInfo->dwPvk_CSPType;
            pwszPvkFile=pPvkSignInfo->pwszPvk_File;
        }
        else
        {
            pwszCSP=pPvkSignInfo->pwszContainer_CSP;
            dwCSPType=pPvkSignInfo->dwContainer_CSPType;
            dwKeySpec=pPvkSignInfo->dwContainer_KeyType;
            pwszContainer=pPvkSignInfo->pwszContainer_Name;
        }

        if(!LoadStringU(g_hmodThisDll, IDS_KEY_PUBLISHER,
                wszPublisher, MAX_STRING_SIZE-1))
            goto CLEANUP;


        if(S_OK != PvkGetCryptProv(NULL,
						    wszPublisher,
						    pwszCSP,
						    dwCSPType,
						    pwszPvkFile,
						    pwszContainer,
						    &dwKeySpec,
						    &pwszTmpContainer,
						    &hProv))
            goto CLEANUP;
    }

    //check the match
    if(pPvkSignInfo->fSignCert)
    {

       if(NULL == pPvkSignInfo->pSignCert)
           goto CLEANUP;

       if (NULL == (hCertStore = CertOpenStore(
                CERT_STORE_PROV_MEMORY,
                g_dwMsgAndCertEncodingType,      
                NULL,                  
                0,                   
                NULL                  
                )))
            goto CLEANUP;

        //add the signing cert to the store
	    if(!CertAddCertificateContextToStore(hCertStore, 
										pPvkSignInfo->pSignCert,
										CERT_STORE_ADD_USE_EXISTING,
										NULL))
            goto CLEANUP;
    }
    else
    {
        if(NULL == pPvkSignInfo->pwszSPCFileName)
            goto CLEANUP;

        if (NULL == (hCertStore = CertOpenStore(
                                  CERT_STORE_PROV_FILENAME_W,
                                  g_dwMsgAndCertEncodingType,
                                  NULL,
                                  0,
                                  pPvkSignInfo->pwszSPCFileName)))
            goto CLEANUP;
    }

    if(S_OK != SpcGetCertFromKey(
							   g_dwMsgAndCertEncodingType,
                               hCertStore, 
                               hProv,
                               dwKeySpec,
                               &pCertContext))
        goto CLEANUP;

    } __except(EXCEPTION_EXECUTE_HANDLER) {
            SetLastError(GetExceptionCode());
            //if the exception happens, we assume match is true
            //so that the wizard can go on
            fMatch=TRUE;
            goto CLEANUP;
    }


    fMatch=TRUE;

CLEANUP:

    __try {

    if(hProv)
    {
        if(fTypical)
        {
            FreeCryptProvFromCert(fAcquire,
								 hProv,
								 pwszCSP,
								 dwCSPType,
								 pwszTmpContainer);
       }
        else
        {
            PvkFreeCryptProv(hProv,
                            pwszCSP,
                            dwCSPType,
                            pwszTmpContainer); 
        }
    }

    } __except(EXCEPTION_EXECUTE_HANDLER) {
            SetLastError(GetExceptionCode());
    }

 	if(hCertStore)
		CertCloseStore(hCertStore, 0);

    if(pCertContext)
        CertFreeCertificateContext(pCertContext);

    return fMatch;
}



//----------------------------------------------------------------------------
//
//  FileExist: Make sure the file exists, and is writable
//----------------------------------------------------------------------------
BOOL    FileExist(LPWSTR    pwszFileName, UINT  *pIDS)
{
    HANDLE      hFile=NULL;
    GUID        gGuid;


    if(NULL==pwszFileName || NULL==pIDS)
        return FALSE;

    if (INVALID_HANDLE_VALUE==(hFile = ExpandAndCreateFileU(pwszFileName,
                           GENERIC_READ | GENERIC_WRITE,
                           FILE_SHARE_READ,
                           NULL,                   // lpsa
                           OPEN_EXISTING,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL)))
    {
        *pIDS=IDS_SIGN_FILE_NAME_NOT_EXIST;
        return FALSE;
    }


    if(CryptSIPRetrieveSubjectGuid(pwszFileName, hFile, &gGuid))
    {
        if(hFile)
            CloseHandle(hFile);

        return TRUE;
    }


    if(hFile)
        CloseHandle(hFile);

    *pIDS=IDS_SIGN_FILE_NAME_NOT_SIP;

    return FALSE;
}


//----------------------------------------------------------------------------
//
//  SetStoreName
//----------------------------------------------------------------------------
BOOL    SetStoreName(HWND       hwndControl,
                     LPWSTR     pwszStoreName)
{
    LV_COLUMNW              lvC;
    LV_ITEMW                lvItem;


   //clear the ListView
    ListView_DeleteAllItems(hwndControl);

    //set the store name
    //only one column is needed
    memset(&lvC, 0, sizeof(LV_COLUMNW));

    lvC.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
    lvC.fmt = LVCFMT_LEFT;  // Left-align the column.
    lvC.cx =10;    //(wcslen(pwszStoreName)+2)*7;          // Width of the column, in pixels.
    lvC.pszText = L"";   // The text for the column.
    lvC.iSubItem=0;

    if (ListView_InsertColumnU(hwndControl, 0, &lvC) == -1)
        return FALSE;

    //insert the store name
    memset(&lvItem, 0, sizeof(LV_ITEMW));

    // set up the fields in the list view item struct that don't change from item to item
    lvItem.mask = LVIF_TEXT | LVIF_STATE ;
    lvItem.state = 0;
    lvItem.stateMask = 0;
    lvItem.iItem=0;
    lvItem.iSubItem=0;
    lvItem.pszText=pwszStoreName;


    ListView_InsertItemU(hwndControl, &lvItem);

    //automatically resize the column
    ListView_SetColumnWidth(hwndControl, 0, LVSCW_AUTOSIZE);

    return TRUE;
}

//----------------------------------------------------------------------------
//
//  Based on the HRESULT from SignerSign, get the error message ids
//----------------------------------------------------------------------------
UINT    GetErrMsgFromSignHR(HRESULT hr)		
{

    switch(hr)
    {
		case CRYPT_E_NO_MATCH:
				return IDS_SIGN_NOMATCH;
			break;
		case TYPE_E_TYPEMISMATCH:
				return IDS_SIGN_AUTH;
			break;	
		case CRYPT_E_NO_PROVIDER:
				return IDS_SIGN_NO_PROVIDER;
			break;
		case CERT_E_CHAINING:
				return IDS_SIGN_NO_CHAINING;
			break;
		case CERT_E_EXPIRED:
				return IDS_SIGN_EXPRIED;
			break;
		case CRYPT_E_FILERESIZED:
				return IDS_SIGN_RESIZE;
			break;
       default:
                return IDS_SIGN_FAILED;
            break;
    }

    return IDS_SIGN_FAILED;
}
//----------------------------------------------------------------------------
//
//  Based on the HRESULT from SignerTimeStamp, get the error message ids
//----------------------------------------------------------------------------
UINT    GetErrMsgFromTimeStampHR(HRESULT hr)		
{

    switch(hr)
    {
		case HRESULT_FROM_WIN32(ERROR_INVALID_DATA):
				return IDS_SIGN_RESPONSE_INVALID;
			break;
		case HRESULT_FROM_WIN32(ERROR_INVALID_FUNCTION):
				return IDS_SIGN_INVALID_ADDRESS;
			break;
		case TRUST_E_TIME_STAMP:
				return IDS_SIGN_TS_CERT_INVALID;
			break;
        default:
                return IDS_TIMESTAMP_FAILED;
            break;
    }

    return IDS_TIMESTAMP_FAILED;
}


//----------------------------------------------------------------------------
//
//	Compose the private key file structure:
//	"pvkFileName"\0"keysepc"\0"provtype"\0"provname"\0\0
//  This string is used by the CERT_PVK_FILE_PROP_ID property
//
//----------------------------------------------------------------------------
BOOL	ComposePvkString(	CRYPT_KEY_PROV_INFO *pKeyProvInfo,
							LPWSTR				*ppwszPvkString,
							DWORD				*pcwchar)
{

		BOOL        fResult=FALSE;
		DWORD		cwchar=0;
		LPWSTR		pwszAddr=0;
		WCHAR		wszKeySpec[100];
		WCHAR		wszProvType[100];

        if(!pKeyProvInfo || !ppwszPvkString || !pcwchar)
            return FALSE;

		//convert dwKeySpec and dwProvType to wchar
        _itow(pKeyProvInfo->dwKeySpec,  wszKeySpec, 10);
        _itow(pKeyProvInfo->dwProvType, wszProvType, 10);

		//count of the number of characters we need
		cwchar=(pKeyProvInfo->pwszProvName) ?
			(wcslen(pKeyProvInfo->pwszProvName)+1) : 1;

		//add the ContainerName + two DWORDs
		cwchar += wcslen(pKeyProvInfo->pwszContainerName)+1+
				  wcslen(wszKeySpec)+1+wcslen(wszProvType)+1+1;

		*ppwszPvkString=(LPWSTR)WizardAlloc(cwchar * sizeof(WCHAR));
		if(!(*ppwszPvkString))
			return FALSE;

		//copy the private key file name .
		wcscpy((*ppwszPvkString), pKeyProvInfo->pwszContainerName);

		pwszAddr=(*ppwszPvkString)+wcslen(*ppwszPvkString)+1;

		//copy the key spec
		wcscpy(pwszAddr, wszKeySpec);
		pwszAddr=pwszAddr+wcslen(wszKeySpec)+1;

		//copy the provider type
		wcscpy(pwszAddr, wszProvType);
		pwszAddr=pwszAddr+wcslen(wszProvType)+1;

		//copy the provider name
		if(pKeyProvInfo->pwszProvName)
		{
			wcscpy(pwszAddr, pKeyProvInfo->pwszProvName);
			pwszAddr=pwszAddr+wcslen(pKeyProvInfo->pwszProvName)+1;
		}
		else
		{
			*pwszAddr=L'\0';
			pwszAddr++;
		}

		//NULL terminate the string
		*pwszAddr=L'\0';

		*pcwchar=cwchar;

		return TRUE;
}


//------------------------------------------------------------------------------
// Lauch the file open dialogue for the private key file name
//----------------------------------------------------------------------------
BOOL    SelectPvkFileName(HWND  hwndDlg,
                          int   intEditControl)
{
    OPENFILENAMEW       OpenFileName;
    WCHAR               szFileName[_MAX_PATH];
    WCHAR               szFilter[MAX_STRING_SIZE];  //"Certificate File (*.cer)\0*.cer\0Certificate File (*.crt)\0*.crt\0All Files\0*.*\0"
    BOOL                fResult=FALSE;
    DWORD               dwSize=0;


    if(!hwndDlg || !intEditControl)
        goto CLEANUP;

    memset(&OpenFileName, 0, sizeof(OpenFileName));

    *szFileName=L'\0';

    OpenFileName.lStructSize = sizeof(OpenFileName);
    OpenFileName.hwndOwner = hwndDlg;
    OpenFileName.hInstance = NULL;
    //load the fileter string
    if(LoadFilterString(g_hmodThisDll, IDS_PVK_FILE_FILTER, szFilter, MAX_STRING_SIZE))
    {
        OpenFileName.lpstrFilter = szFilter;
    }
    OpenFileName.lpstrCustomFilter = NULL;
    OpenFileName.nMaxCustFilter = 0;
    OpenFileName.nFilterIndex = 1;
    OpenFileName.lpstrFile = szFileName;
    OpenFileName.nMaxFile = _MAX_PATH;
    OpenFileName.lpstrFileTitle = NULL;
    OpenFileName.nMaxFileTitle = 0;
    OpenFileName.lpstrInitialDir = NULL;
    OpenFileName.lpstrTitle = NULL;
    OpenFileName.Flags = OFN_HIDEREADONLY | OFN_FILEMUSTEXIST;
    OpenFileName.nFileOffset = 0;
    OpenFileName.nFileExtension = 0;
    OpenFileName.lpstrDefExt = L"pvk";
    OpenFileName.lCustData = NULL;
    OpenFileName.lpfnHook = NULL;
    OpenFileName.lpTemplateName = NULL;

    if (!WizGetOpenFileName(&OpenFileName))
       goto CLEANUP;

    //copy the file name to the edit box
     SetDlgItemTextU(hwndDlg, intEditControl, szFileName);

    fResult=TRUE;

CLEANUP:

    return fResult;


}


//------------------------------------------------------------------------------
// Select an item in the combo box based on the input string
//----------------------------------------------------------------------------
BOOL    SelectComboName(HWND            hwndDlg,
                        int             idControl,
                        LPWSTR          pwszName)
{
    BOOL    fResult=FALSE;
    int     iIndex=0;

    if(!hwndDlg || !idControl || !pwszName)
        goto CLEANUP;


    //get the index of the string in the comb box
    iIndex=(int)SendDlgItemMessageU(
        hwndDlg,
        idControl,
        CB_FINDSTRINGEXACT,
        -1,
        (LPARAM)pwszName);

    if(CB_ERR == iIndex)
        goto CLEANUP;

    //set the selection
    SendDlgItemMessageU(hwndDlg, idControl, CB_SETCURSEL, iIndex,0);

    fResult=TRUE;

CLEANUP:

    return fResult;
}


//------------------------------------------------------------------------------
//  Based on the CSP name selection, refresh the combo box for the CSP type
//----------------------------------------------------------------------------
BOOL    RefreshCSPType(HWND                     hwndDlg,
                       int                      idsCSPTypeControl,
                       int                      idsCSPNameControl,
                       CERT_SIGNING_INFO        *pPvkSignInfo)
{
    BOOL        fResult=FALSE;
    LPWSTR      pwszCSPName=NULL;
    DWORD       dwCSPType=0;
    DWORD       dwIndex=0;
    int         iIndex=0;
    WCHAR       wszTypeName[CSP_TYPE_NAME];


    if(!hwndDlg || !idsCSPNameControl || !pPvkSignInfo)
        goto CLEANUP;

    //delete all the old CAP type name.  We are rebuilding the container name
    //list
     SendDlgItemMessageU(hwndDlg, idsCSPTypeControl, CB_RESETCONTENT, 0, 0);

    //get the selected CSP index
    iIndex=(int)SendDlgItemMessage(hwndDlg, idsCSPNameControl,
        CB_GETCURSEL, 0, 0);

    if(CB_ERR==iIndex)
        goto CLEANUP;

    //get the selected CSP name
    if(CB_ERR == SendDlgItemMessageU_GETLBTEXT(hwndDlg, idsCSPNameControl,
              iIndex, &pwszCSPName))
        goto CLEANUP;

    //find the CSP type
    for(dwIndex=0; dwIndex < pPvkSignInfo->dwCSPCount; dwIndex++)
    {
        if(0==wcscmp(((pPvkSignInfo->pCSPInfo)[dwIndex].pwszCSPName),
                     pwszCSPName))
        {
            dwCSPType=(pPvkSignInfo->pCSPInfo)[dwIndex].dwCSPType;
            break;
        }

    }

    if(0 == dwCSPType)
        goto CLEANUP;

    //get the CSP name
    if(GetProviderTypeName(dwCSPType,  wszTypeName))
    {
        SendDlgItemMessageU(hwndDlg, idsCSPTypeControl, CB_INSERTSTRING,
            0, (LPARAM)wszTypeName);

        SendDlgItemMessageU(hwndDlg, idsCSPTypeControl, CB_SETCURSEL, 0, 0);
    }

    fResult=TRUE;

CLEANUP:

    if(pwszCSPName)
        WizardFree(pwszCSPName);

    return fResult;

}

//------------------------------------------------------------------------------
//  Select the correct radio button and enable windows for private key file
//----------------------------------------------------------------------------
void    SetSelectPvkFile(HWND   hwndDlg)
{
    SendMessage(GetDlgItem(hwndDlg, IDC_PVK_FILE_RADIO), BM_SETCHECK, 1, 0);
    SendMessage(GetDlgItem(hwndDlg, IDC_PVK_CONTAINER_RADIO), BM_SETCHECK, 0, 0);

    //diable windows
    EnableWindow(GetDlgItem(hwndDlg, IDC_PVK_CONTAINER_CSP_COMBO), FALSE);
    EnableWindow(GetDlgItem(hwndDlg, IDC_PVK_CONTAINER_TYPE_COMBO), FALSE);
    EnableWindow(GetDlgItem(hwndDlg, IDC_PVK_CONTAINER_NAME_COMBO), FALSE);
    EnableWindow(GetDlgItem(hwndDlg, IDC_PVK_CONTAINER_KEY_TYPE_COMBO), FALSE);

    //enable windows
    EnableWindow(GetDlgItem(hwndDlg,  IDC_PVK_FILE_CSP_COMBO), TRUE);
    EnableWindow(GetDlgItem(hwndDlg,  IDC_PVK_FILE_TYPE_COMBO), TRUE);
    EnableWindow(GetDlgItem(hwndDlg,  IDC_PVK_FILE_BUTTON), TRUE);
    EnableWindow(GetDlgItem(hwndDlg,  IDC_PVK_FILE_EDIT), TRUE);
}

//------------------------------------------------------------------------------
//  Select the correct radio button and enable windows for key container
//----------------------------------------------------------------------------
void    SetSelectKeyContainer(HWND   hwndDlg)
{
    SendMessage(GetDlgItem(hwndDlg, IDC_PVK_FILE_RADIO), BM_SETCHECK, 0, 0);
    SendMessage(GetDlgItem(hwndDlg, IDC_PVK_CONTAINER_RADIO), BM_SETCHECK, 1, 0);

    //enable windows
    EnableWindow(GetDlgItem(hwndDlg, IDC_PVK_CONTAINER_CSP_COMBO), TRUE);
    EnableWindow(GetDlgItem(hwndDlg, IDC_PVK_CONTAINER_TYPE_COMBO),TRUE);
    EnableWindow(GetDlgItem(hwndDlg, IDC_PVK_CONTAINER_NAME_COMBO), TRUE);
    EnableWindow(GetDlgItem(hwndDlg, IDC_PVK_CONTAINER_KEY_TYPE_COMBO), TRUE);

    //disable windows
    EnableWindow(GetDlgItem(hwndDlg,  IDC_PVK_FILE_CSP_COMBO), FALSE);
    EnableWindow(GetDlgItem(hwndDlg,  IDC_PVK_FILE_TYPE_COMBO), FALSE);
    EnableWindow(GetDlgItem(hwndDlg,  IDC_PVK_FILE_BUTTON), FALSE);
    EnableWindow(GetDlgItem(hwndDlg,  IDC_PVK_FILE_EDIT), FALSE);
}

//------------------------------------------------------------------------------
//  Initialize private key information based on a PVK file information
//----------------------------------------------------------------------------
BOOL    InitPvkWithPvkInfo(HWND                                     hwndDlg,
                           CRYPTUI_WIZ_DIGITAL_SIGN_PVK_FILE_INFO   *pPvkFileInfo,
                           CERT_SIGNING_INFO                        *pPvkSignInfo)
{
    BOOL    fResult=FALSE;

    if(!hwndDlg || !pPvkFileInfo || !pPvkSignInfo)
        goto CLEANUP;

    if((NULL == pPvkFileInfo->pwszPvkFileName) ||
        (NULL == pPvkFileInfo->pwszProvName))
        goto CLEANUP;

    //set the radio button
    SetSelectPvkFile(hwndDlg);

    //populate the private key file name
    SetDlgItemTextU(hwndDlg, IDC_PVK_FILE_EDIT,pPvkFileInfo->pwszPvkFileName);

    //populate the CSP list
    SelectComboName(hwndDlg, IDC_PVK_FILE_CSP_COMBO, pPvkFileInfo->pwszProvName);

    //refresh the CSP type based on the CSP name
    RefreshCSPType(hwndDlg,  IDC_PVK_FILE_TYPE_COMBO, IDC_PVK_FILE_CSP_COMBO, pPvkSignInfo);

    fResult=TRUE;

CLEANUP:

    return fResult;
}


//------------------------------------------------------------------------------
//  Initialize private key information based on a CRYPT_KEY_PROV_INFO
//----------------------------------------------------------------------------
BOOL    InitPvkWithProvInfo(HWND                 hwndDlg,
                            CRYPT_KEY_PROV_INFO  *pKeyProvInfo,
                            CERT_SIGNING_INFO    *pPvkSignInfo)
{
    BOOL        fResult=FALSE;
    WCHAR       wszKeyTypeName[MAX_KEY_TYPE_NAME];
    int         iIndex=0;

    //init
    if(!hwndDlg || !pKeyProvInfo || !pPvkSignInfo)
        goto CLEANUP;

    //set the radio button
    SetSelectKeyContainer(hwndDlg);

    //CSP name
    if(pKeyProvInfo->pwszProvName)
    {
        if(!SelectComboName(hwndDlg,
                        IDC_PVK_CONTAINER_CSP_COMBO,
                        pKeyProvInfo->pwszProvName))
            goto CLEANUP;
    }

    //refresh the CSP type based on the CSP name
    RefreshCSPType(hwndDlg,  IDC_PVK_CONTAINER_TYPE_COMBO,
        IDC_PVK_CONTAINER_CSP_COMBO, pPvkSignInfo);

    //refresh the key container
    RefreshContainer(hwndDlg,
                     IDC_PVK_CONTAINER_NAME_COMBO,
                     IDC_PVK_CONTAINER_CSP_COMBO,
                     pPvkSignInfo);

    //select the key container
    if(pKeyProvInfo->pwszContainerName)
    {
        if(!SelectComboName(hwndDlg,
                       IDC_PVK_CONTAINER_NAME_COMBO,
                       pKeyProvInfo->pwszContainerName))
        {
            //we add the key container to the list
            //because the key container could be the unique name
            iIndex=(int)SendDlgItemMessageU(hwndDlg, IDC_PVK_CONTAINER_NAME_COMBO,
                CB_ADDSTRING, 0, (LPARAM)(pKeyProvInfo->pwszContainerName));

            //hightlight the selection
            if((CB_ERR!=iIndex) && (CB_ERRSPACE != iIndex) && (iIndex >= 0))
                SendDlgItemMessageU(hwndDlg, IDC_PVK_CONTAINER_NAME_COMBO, CB_SETCURSEL, iIndex,0);

        }
    }

    //refresh the key type
    RefreshKeyType(hwndDlg,
                   IDC_PVK_CONTAINER_KEY_TYPE_COMBO,
                   IDC_PVK_CONTAINER_NAME_COMBO,
                   IDC_PVK_CONTAINER_CSP_COMBO,
                   pPvkSignInfo);

    //select the key type
    if(pKeyProvInfo->dwKeySpec)
    {

        if(AT_KEYEXCHANGE == pKeyProvInfo->dwKeySpec)
        {
            if(LoadStringU(g_hmodThisDll, IDS_KEY_EXCHANGE,
                wszKeyTypeName, MAX_KEY_TYPE_NAME-1))
            {
                if(!SelectComboName(hwndDlg,
                           IDC_PVK_CONTAINER_KEY_TYPE_COMBO,
                           wszKeyTypeName))
                goto CLEANUP;
            }
        }

        if(AT_SIGNATURE == pKeyProvInfo->dwKeySpec)
        {
            if(LoadStringU(g_hmodThisDll, IDS_KEY_SIGNATURE,
                wszKeyTypeName, MAX_KEY_TYPE_NAME-1))
            {
                if(!SelectComboName(hwndDlg,
                           IDC_PVK_CONTAINER_KEY_TYPE_COMBO,
                           wszKeyTypeName))
                goto CLEANUP;
            }
        }


    }


    fResult=TRUE;

CLEANUP:

    return fResult;
}

//------------------------------------------------------------------------------
//  Initialize private key information based on a certificate
//----------------------------------------------------------------------------
BOOL    InitPvkWithCertificate(HWND                 hwndDlg,
                               PCCERT_CONTEXT       pSignCert,
                               CERT_SIGNING_INFO   *pPvkSignInfo)
{
    BOOL                    fResult=FALSE;
    DWORD                   cbData=0;
    CRYPT_KEY_PROV_INFO     *pProvInfo=NULL;

    if(!hwndDlg || !pSignCert || !pPvkSignInfo)
        goto CLEANUP;

    //get the properties on the certificate CERT_KEY_PROV_INFO_PROP_ID
    if(CertGetCertificateContextProperty(
            pSignCert,
            CERT_KEY_PROV_INFO_PROP_ID,
            NULL,
            &cbData) && (0 != cbData))
    {

         pProvInfo=(CRYPT_KEY_PROV_INFO     *)WizardAlloc(cbData);
         if(NULL==pProvInfo)
             goto CLEANUP;

        if(CertGetCertificateContextProperty(
            pSignCert,
            CERT_KEY_PROV_INFO_PROP_ID,
            pProvInfo,
            &cbData))
        {
            if(!InitPvkWithProvInfo(hwndDlg,
                                pProvInfo,
                                pPvkSignInfo))
                goto CLEANUP;

        }
    }


    fResult=TRUE;

CLEANUP:

    if(pProvInfo)
        WizardFree(pProvInfo);

    return fResult;
}

//------------------------------------------------------------------------------
//  Get the key type based on the name
//----------------------------------------------------------------------------
DWORD   GetKeyTypeFromName(LPWSTR   pwszKeyTypeName)
{
    WCHAR       wszKeyTypeName[MAX_KEY_TYPE_NAME];

    if(!pwszKeyTypeName)
        return AT_SIGNATURE;

    if(LoadStringU(g_hmodThisDll, IDS_KEY_SIGNATURE,
                    wszKeyTypeName, MAX_KEY_TYPE_NAME-1))
    {
        if(0==_wcsicmp(wszKeyTypeName, pwszKeyTypeName))
            return AT_SIGNATURE;
    }


    if(LoadStringU(g_hmodThisDll, IDS_KEY_EXCHANGE,
                    wszKeyTypeName, MAX_KEY_TYPE_NAME-1))
    {
        if(0==_wcsicmp(wszKeyTypeName, pwszKeyTypeName))
            return AT_KEYEXCHANGE;
    }

    return  AT_SIGNATURE;
}

//------------------------------------------------------------------------------
//  Check if the key type control is empty
//----------------------------------------------------------------------------
BOOL   IsEmptyKeyType(HWND      hwndDlg,
                      int       idsKeyTypeControl)
{

    if(CB_ERR == SendDlgItemMessage(hwndDlg, idsKeyTypeControl,
        CB_GETCURSEL, 0, 0))
        return TRUE;
    else
        return FALSE;

}

//------------------------------------------------------------------------------
//  Reset the key type combo box based on the CSP user selected
//----------------------------------------------------------------------------
BOOL   RefreshKeyType(HWND                       hwndDlg,
                        int                      idsKeyTypeControl,
                        int                      idsContainerControl,
                        int                      idsCSPNameControl,
                        CERT_SIGNING_INFO        *pPvkSignInfo)
{
    BOOL        fResult=FALSE;
    DWORD       dwIndex=0;
    DWORD       dwCSPType=0;
    int         iIndex=0;
    WCHAR       wszKeyTypeName[MAX_KEY_TYPE_NAME];
    DWORD       dwKeyTypeIndex=0;



    LPWSTR      pwszCSPName=NULL;
    LPWSTR      pwszContainerName=NULL;
    HCRYPTPROV  hProv=NULL;
    HCRYPTKEY   hKey=NULL;


    if(!hwndDlg || !idsKeyTypeControl || !idsContainerControl || !idsCSPNameControl ||
        !pPvkSignInfo)
        goto CLEANUP;

    //delete all the old container name.  We are rebuilding the key type list
     SendDlgItemMessageU(hwndDlg, idsKeyTypeControl, CB_RESETCONTENT, 0, 0);

    //get the selected CSP index
    iIndex=(int)SendDlgItemMessage(hwndDlg, idsCSPNameControl,
        CB_GETCURSEL, 0, 0);

    if(CB_ERR==iIndex)
        goto CLEANUP;

    //get the selected CSP name
    if(CB_ERR == SendDlgItemMessageU_GETLBTEXT(hwndDlg,idsCSPNameControl,
              iIndex, &pwszCSPName))
        goto CLEANUP;


    //find the CSP type
    for(dwIndex=0; dwIndex < pPvkSignInfo->dwCSPCount; dwIndex++)
    {
        if(0==wcscmp(((pPvkSignInfo->pCSPInfo)[dwIndex].pwszCSPName),
                     pwszCSPName))
        {
            dwCSPType=(pPvkSignInfo->pCSPInfo)[dwIndex].dwCSPType;
            break;
        }

    }

    if(0==dwCSPType)
        goto CLEANUP;

    //get the container name
    iIndex=(int)SendDlgItemMessage(hwndDlg, idsContainerControl,
        CB_GETCURSEL, 0, 0);

    if(CB_ERR==iIndex)
        goto CLEANUP;

    //get the selected CSP name
    if(CB_ERR == SendDlgItemMessageU_GETLBTEXT(hwndDlg,idsContainerControl,
              iIndex, &pwszContainerName))
        goto CLEANUP;

    //get the provider handle
    if(!CryptAcquireContextU(&hProv,
                pwszContainerName,
                pwszCSPName,
                dwCSPType,
                0))
        goto CLEANUP;

    //call CryptGetUserKey to check for the key container
    if(CryptGetUserKey(hProv, AT_KEYEXCHANGE, &hKey))
    {

        if(LoadStringU(g_hmodThisDll, IDS_KEY_EXCHANGE,
            wszKeyTypeName, MAX_KEY_TYPE_NAME-1))
        {

            SendDlgItemMessageU(hwndDlg, idsKeyTypeControl,
                CB_INSERTSTRING, dwKeyTypeIndex, (LPARAM)wszKeyTypeName);

            dwKeyTypeIndex++;
        }
    }

    if(hKey)
    {
        CryptDestroyKey(hKey);
        hKey=NULL;
    }

    if(CryptGetUserKey(hProv, AT_SIGNATURE, &hKey))
    {

        if(LoadStringU(g_hmodThisDll, IDS_KEY_SIGNATURE,
            wszKeyTypeName, MAX_KEY_TYPE_NAME-1))
        {

            SendDlgItemMessageU(hwndDlg, idsKeyTypeControl,
                CB_INSERTSTRING, dwKeyTypeIndex, (LPARAM)wszKeyTypeName);

            dwKeyTypeIndex++;
        }
    }

    if(hKey)
    {
        CryptDestroyKey(hKey);
        hKey=NULL;
    }

    //select the 1st one
    if(dwKeyTypeIndex > 0)
        SendDlgItemMessageU(hwndDlg, idsKeyTypeControl, CB_SETCURSEL, 0, 0);

    fResult=TRUE;

CLEANUP:
    if(pwszCSPName)
        WizardFree(pwszCSPName);

    if(pwszContainerName)
        WizardFree(pwszContainerName);

    if(hKey)
        CryptDestroyKey(hKey);


    if(hProv)
        CryptReleaseContext(hProv, 0);

    return fResult;



}

//------------------------------------------------------------------------------
//  Reset the container combo box based on the CSP user selected
//----------------------------------------------------------------------------
BOOL   RefreshContainer(HWND                     hwndDlg,
                        int                      idsContainerControl,
                        int                      idsCSPNameControl,
                        CERT_SIGNING_INFO        *pPvkSignInfo)
{
    BOOL        fResult=FALSE;
    DWORD       dwIndex=0;
    DWORD       dwCSPType=0;
    DWORD       dwFlags=0;
    int         iIndex=0;
    DWORD       dwLength=0;

    LPWSTR      pwszCSPName=NULL;
    HCRYPTPROV  hProv=NULL;
    LPSTR       pszContainer=NULL;


    if(NULL==hwndDlg || NULL==pPvkSignInfo)
        goto CLEANUP;

    //delete all the old container name.  We are rebuilding the container name
    //list
     SendDlgItemMessageU(hwndDlg, idsContainerControl, CB_RESETCONTENT, 0, 0);

    //get the selected CSP index
    iIndex=(int)SendDlgItemMessage(hwndDlg, idsCSPNameControl,
        CB_GETCURSEL, 0, 0);

    if(CB_ERR==iIndex)
        goto CLEANUP;

    //get the selected item
    if(CB_ERR == SendDlgItemMessageU_GETLBTEXT(hwndDlg,idsCSPNameControl,
              iIndex, &pwszCSPName))
        goto CLEANUP;


    //find the CSP type
    for(dwIndex=0; dwIndex < pPvkSignInfo->dwCSPCount; dwIndex++)
    {
        if(0==wcscmp(((pPvkSignInfo->pCSPInfo)[dwIndex].pwszCSPName),
                     pwszCSPName))
        {
            dwCSPType=(pPvkSignInfo->pCSPInfo)[dwIndex].dwCSPType;
            break;
        }

    }

    if(0==dwCSPType)
        goto CLEANUP;

    //get the provider handle
    if(!CryptAcquireContextU(&hProv,
                NULL,
                pwszCSPName,
                dwCSPType,
                CRYPT_VERIFYCONTEXT))
        goto CLEANUP;

    //enum the containers
    dwIndex=0;

    dwFlags=CRYPT_FIRST;

    CryptGetProvParam(hProv,
                    PP_ENUMCONTAINERS,
                    NULL,
                    &dwLength,
                    dwFlags);

    //Since we can not the two way calls here, allocate a
    //big enough buffer
    if(dwLength < MAX_CONTAINER_NAME)
        dwLength = MAX_CONTAINER_NAME;

    //allocate memory.
    pszContainer=(LPSTR)WizardAlloc(dwLength);

    if(NULL==pszContainer)
        goto CLEANUP;

    while(CryptGetProvParam(hProv,
                    PP_ENUMCONTAINERS,
                    (BYTE *)pszContainer,
                    &dwLength,
                    dwFlags))
    {

        //populate the combo box
        SendDlgItemMessage(hwndDlg, idsContainerControl, CB_INSERTSTRING,
            dwIndex, (LPARAM)pszContainer);

        //increase the dwIndex
        dwIndex++;

        dwFlags=0;
    }

    //select the last one
    if(dwIndex > 0)
        SendDlgItemMessageU(hwndDlg, idsContainerControl, CB_SETCURSEL, 0, 0);

    fResult=TRUE;

CLEANUP:

    if(pwszCSPName)
        WizardFree(pwszCSPName);

    if(pszContainer)
        WizardFree(pszContainer);

    if(hProv)
        CryptReleaseContext(hProv, 0);

    return fResult;


}

//------------------------------------------------------------------------------
// Based on the provider type, return the string for the provider type
//----------------------------------------------------------------------------
BOOL    GetProviderTypeName(DWORD   dwCSPType,  LPWSTR  wszName)
{

    UINT    idsCSP=0;

    switch(dwCSPType)
    {

        case    PROV_RSA_FULL:
                idsCSP=IDS_CSP_RSA_FULL;
            break;
        case    PROV_RSA_SIG:
                idsCSP=IDS_CSP_RSA_SIG;
            break;
        case    PROV_DSS:
                idsCSP=IDS_CSP_DSS;
             break;
       case    PROV_FORTEZZA:
                idsCSP=IDS_CSP_FORTEZZA;
            break;
        case    PROV_MS_EXCHANGE:
                idsCSP=IDS_CSP_MS_EXCHANGE;
            break;
        case    PROV_SSL:
                idsCSP=IDS_CSP_SSL;
            break;
        case    PROV_RSA_SCHANNEL:
                idsCSP=IDS_CSP_RSA_SCHANNEL;
            break;
        case    PROV_DSS_DH:
                idsCSP=IDS_CSP_DSS_DH;
            break;
        case    PROV_EC_ECDSA_SIG:
                idsCSP=IDS_CSP_EC_ECDSA_SIG;
            break;
        case    PROV_EC_ECNRA_SIG:
                idsCSP=IDS_CSP_EC_ECNRA_SIG;
            break;
        case    PROV_EC_ECDSA_FULL:
                idsCSP=IDS_CSP_EC_ECDSA_FULL;
            break;
        case    PROV_EC_ECNRA_FULL:
                idsCSP=IDS_CSP_EC_ECNRA_FULL;
            break;
        case    PROV_DH_SCHANNEL:
                idsCSP=IDS_CSP_DH_SCHANNEL;
            break;
        case    PROV_SPYRUS_LYNKS:
                idsCSP=IDS_CSP_SPYRUS_LYNKS;
            break;
        default:
            _itow(dwCSPType, wszName, 10 );
            return TRUE;

    }

    //load the string
    return (0 != LoadStringU(g_hmodThisDll, idsCSP, wszName,
        CSP_TYPE_NAME-1));
}


//------------------------------------------------------------------------------
// Set the default CSP to the RSA_FULL
//----------------------------------------------------------------------------
BOOL    SetDefaultCSP(HWND            hwndDlg)
{
    BOOL            fResult=FALSE;
    DWORD           cbData=0;

    LPWSTR          pwszCSP=NULL;
    HCRYPTPROV      hProv=NULL;
    LPSTR           pszName=NULL;

     //get the default provider
    if(CryptAcquireContext(&hProv,
                            NULL,
                            NULL,
                            PROV_RSA_FULL,
                            CRYPT_VERIFYCONTEXT))
    {

        //get the provider name
        if(CryptGetProvParam(hProv,
                            PP_NAME,
                            NULL,
                            &cbData,
                            0) && (0!=cbData))
        {

            if(pszName=(LPSTR)WizardAlloc(cbData))
            {
                if(CryptGetProvParam(hProv,
                                    PP_NAME,
                                    (BYTE *)pszName,
                                    &cbData,
                                    0))
                {
                    pwszCSP=MkWStr(pszName); 

                    if(pwszCSP)
                    {
                        SelectComboName(hwndDlg, IDC_PVK_FILE_CSP_COMBO, pwszCSP);
                        SelectComboName(hwndDlg, IDC_PVK_CONTAINER_CSP_COMBO, pwszCSP);
                        fResult=TRUE;
                    }
                }

            }
        }
    }




    if(pszName)
        WizardFree(pszName);

    if(pwszCSP)
       FreeWStr(pwszCSP);

    if(hProv)
        CryptReleaseContext(hProv, 0);

    return fResult;
}

//------------------------------------------------------------------------------
//  Initialize the UI with provider name, provider type
//----------------------------------------------------------------------------
BOOL    InitCSP(HWND                     hwndDlg,
                CERT_SIGNING_INFO        *pPvkSignInfo)
{
    BOOL        fResult=FALSE;
    DWORD       dwIndex=0;
    DWORD       cbSize=0;
    WCHAR       wszTypeName[CSP_TYPE_NAME];
    DWORD       dwProviderType=0;

    LPWSTR      pwszCSPName=NULL;

    if(NULL==hwndDlg || NULL==pPvkSignInfo)
        goto CLEANUP;

    pPvkSignInfo->dwCSPCount=0;
    pPvkSignInfo->pCSPInfo=NULL;

    //enum all the providers on the system
   while(CryptEnumProvidersU(
                            dwIndex,
                            0,
                            0,
                            &dwProviderType,
                            NULL,
                            &cbSize))
   {
      pPvkSignInfo->dwCSPCount++;

      pPvkSignInfo->pCSPInfo=(CSP_INFO *)WizardRealloc(
          pPvkSignInfo->pCSPInfo, pPvkSignInfo->dwCSPCount*sizeof(CSP_INFO));

      if(NULL==pPvkSignInfo->pCSPInfo)
          goto CLEANUP;

      (pPvkSignInfo->pCSPInfo)[pPvkSignInfo->dwCSPCount-1].pwszCSPName=(LPWSTR)
            WizardAlloc(cbSize);

      if(NULL==(pPvkSignInfo->pCSPInfo)[pPvkSignInfo->dwCSPCount-1].pwszCSPName)
          goto CLEANUP;

        //get the CSP name and the type
        if(!CryptEnumProvidersU(
                            dwIndex,
                            0,
                            0,
                            &((pPvkSignInfo->pCSPInfo)[pPvkSignInfo->dwCSPCount-1].dwCSPType),
                            (pPvkSignInfo->pCSPInfo)[pPvkSignInfo->dwCSPCount-1].pwszCSPName,
                            &cbSize))
            goto CLEANUP;



      dwIndex++;
   }

    for(dwIndex=0; dwIndex < pPvkSignInfo->dwCSPCount; dwIndex++)
    {
        //add to the combo box
        SendDlgItemMessageU(hwndDlg, IDC_PVK_FILE_CSP_COMBO, CB_INSERTSTRING,
                dwIndex,
                (LPARAM)((pPvkSignInfo->pCSPInfo)[dwIndex].pwszCSPName));

        SendDlgItemMessageU(hwndDlg, IDC_PVK_CONTAINER_CSP_COMBO, CB_INSERTSTRING,
                dwIndex,
                (LPARAM)((pPvkSignInfo->pCSPInfo)[dwIndex].pwszCSPName));
    }

    //select the 1st CSP
    SendDlgItemMessageU(hwndDlg, IDC_PVK_FILE_CSP_COMBO,        CB_SETCURSEL, 0, 0);
    SendDlgItemMessageU(hwndDlg, IDC_PVK_CONTAINER_CSP_COMBO,   CB_SETCURSEL, 0, 0);

    //now, select the CSP that is the default RSA_PROV_FULL
    SetDefaultCSP(hwndDlg);

    //get the selected item
    if(CB_ERR == SendDlgItemMessageU_GETLBTEXT(hwndDlg, IDC_PVK_FILE_CSP_COMBO,
              0, &pwszCSPName))
        goto CLEANUP;


    //populate the CSP type
    for(dwIndex=0; dwIndex < pPvkSignInfo->dwCSPCount; dwIndex++)
    {
        if(0==wcscmp(((pPvkSignInfo->pCSPInfo)[dwIndex].pwszCSPName),
                     pwszCSPName))
        {
            //get the name of the CSP type
            if(GetProviderTypeName((pPvkSignInfo->pCSPInfo)[dwIndex].dwCSPType,
                                wszTypeName))
            {
                SendDlgItemMessageU(hwndDlg, IDC_PVK_FILE_TYPE_COMBO, CB_INSERTSTRING,
                    0, (LPARAM) wszTypeName);

                SendDlgItemMessageU(hwndDlg, IDC_PVK_CONTAINER_TYPE_COMBO, CB_INSERTSTRING,
                    0, (LPARAM) wszTypeName);

                SendDlgItemMessageU(hwndDlg, IDC_PVK_FILE_TYPE_COMBO,        CB_SETCURSEL, 0, 0);
                SendDlgItemMessageU(hwndDlg, IDC_PVK_CONTAINER_TYPE_COMBO,   CB_SETCURSEL, 0, 0);
            }
            break;
        }

    }

    fResult=TRUE;

CLEANUP:

    if(pwszCSPName)
        WizardFree(pwszCSPName);

    return fResult;
}



//------------------------------------------------------------------------------
//  Get the store name
//----------------------------------------------------------------------------
BOOL    SignGetStoreName(HCERTSTORE hCertStore,
                     LPWSTR     *ppwszStoreName)
{
    DWORD   dwSize=0;

    //init
    *ppwszStoreName=NULL;

    if(NULL==hCertStore)
        return FALSE;

    if(CertGetStoreProperty(
            hCertStore,
            CERT_STORE_LOCALIZED_NAME_PROP_ID,
            NULL,
            &dwSize) && (0!=dwSize))
    {

        *ppwszStoreName=(LPWSTR)WizardAlloc(dwSize);

        if(NULL==*ppwszStoreName)
            return FALSE;

        **ppwszStoreName=L'\0';

        CertGetStoreProperty(
                 hCertStore,
                CERT_STORE_LOCALIZED_NAME_PROP_ID,
                *ppwszStoreName,
                &dwSize);
    }
    else
    {

       *ppwszStoreName=(LPWSTR)WizardAlloc(MAX_TITLE_LENGTH * sizeof(WCHAR));

       if(NULL==*ppwszStoreName)
           return FALSE;

       **ppwszStoreName=L'\0';

       LoadStringU(g_hmodThisDll, IDS_UNKNOWN, *ppwszStoreName, MAX_TITLE_LENGTH);

    }

    return TRUE;
}

//+-------------------------------------------------------------------------
//
//	Prompt user for a store name,  copy the cert store to the input param.
//  free the input param it is not NULL.
//--------------------------------------------------------------------------
BOOL    RetrieveStoreName(HWND          hwndDlg,
                         HCERTSTORE     *phCertStore,
                         BOOL           *pfFree)
{
    BOOL                                    fResult=FALSE;
    CRYPTUI_SELECTSTORE_STRUCT              CertStoreSelect;
    STORENUMERATION_STRUCT                  StoreEnumerationStruct;
    STORESFORSELCTION_STRUCT                StoresForSelectionStruct;

    HCERTSTORE                              hCertStore=NULL;
    LPWSTR                                  pwszStoreName=NULL;
    HWND                                    hwndControl=NULL;


    if(NULL==phCertStore || NULL==hwndDlg)
        goto CLEANUP;

    //call the store selection dialogue
    memset(&CertStoreSelect, 0, sizeof(CertStoreSelect));
    memset(&StoresForSelectionStruct, 0, sizeof(StoresForSelectionStruct));
    memset(&StoreEnumerationStruct, 0, sizeof(StoreEnumerationStruct));

    StoreEnumerationStruct.dwFlags=CERT_SYSTEM_STORE_CURRENT_USER;
    StoreEnumerationStruct.pvSystemStoreLocationPara=NULL;
    StoresForSelectionStruct.cEnumerationStructs = 1;
    StoresForSelectionStruct.rgEnumerationStructs = &StoreEnumerationStruct;

    CertStoreSelect.dwSize=sizeof(CertStoreSelect);
    CertStoreSelect.hwndParent=hwndDlg;
    CertStoreSelect.dwFlags=CRYPTUI_ALLOW_PHYSICAL_STORE_VIEW | CRYPTUI_RETURN_READ_ONLY_STORE;
    CertStoreSelect.pStoresForSelection = &StoresForSelectionStruct;

    hCertStore=CryptUIDlgSelectStore(&CertStoreSelect);

    if(hCertStore)
    {
        if(TRUE == (*pfFree))
        {
            if(*phCertStore)
                CertCloseStore(*phCertStore, 0);
        }

        //remember to free the certstore
        *pfFree=TRUE;

        *phCertStore=hCertStore;

        if(SignGetStoreName(hCertStore,
                            &pwszStoreName))
        {
             //get the hwndControl for the list view
            hwndControl=GetDlgItem(hwndDlg, IDC_WIZARD_LIST1);

            if(hwndControl)
                SetWindowTextU(hwndControl,pwszStoreName);
                
                //SetStoreName(hwndControl,pwszStoreName);
        }
    }


    fResult=TRUE;


CLEANUP:

    if(pwszStoreName)
        WizardFree(pwszStoreName);

    return fResult;
}

//+-------------------------------------------------------------------------
//
//	Get the file name from the edit box, copy the cert store to the input param.
//  free the input param it is not NULL.
//--------------------------------------------------------------------------
BOOL    RetrieveFileNameFromEditBox(
                         HWND           hwndDlg,
                         int            idsMsgTitle,
                         LPWSTR         pwszPageTitle,
                         HCERTSTORE     *phCertStore,
                         LPWSTR         *ppwszFileName,
                         int            *pidsMsg)
{
    BOOL                                    fResult=FALSE;
    UINT                                    idsMsg=0;
    DWORD                                   dwChar=0;


    LPWSTR                                  pwszFileName=NULL;
    HCERTSTORE                              hFileCertStore=NULL;

    if(NULL==phCertStore || NULL==hwndDlg || NULL==ppwszFileName || NULL==pidsMsg)
        goto CLEANUP;

    if(0!=(dwChar=(DWORD)SendDlgItemMessage(hwndDlg,
                          IDC_FILE_EDIT,
                          WM_GETTEXTLENGTH, 0, 0)))
    {
        pwszFileName=(LPWSTR)WizardAlloc(sizeof(WCHAR)*(dwChar+1));

        if(NULL!=pwszFileName)
        {
            GetDlgItemTextU(hwndDlg, IDC_FILE_EDIT,
                            pwszFileName,
                            dwChar+1);

        }
        else
            goto CLEANUP;
    }
    else
    {
        idsMsg=IDS_SELECT_ADD_FILE;
        goto CLEANUP;
    }


    //make sure the file name is a valid one
    //the file has to be eitehr a .cer(.crt) or a SPC file
    if(ExpandAndCryptQueryObject(
            CERT_QUERY_OBJECT_FILE,
            pwszFileName,
            CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED,
            CERT_QUERY_FORMAT_FLAG_BINARY,
            0,
            NULL,
            NULL,
            NULL,
            &hFileCertStore,
            NULL,
            NULL) && (NULL != hFileCertStore))
   {

       //close the original store
       if(*phCertStore)
           CertCloseStore(*phCertStore, 0);

        *phCertStore=hFileCertStore;

        //copy the file name
        if(*ppwszFileName)
            WizardFree(*ppwszFileName);

        *ppwszFileName=(LPWSTR)WizardAllocAndCopyWStr(pwszFileName);
   }
   else
   {
        //warn the user that this is not a valid file
       idsMsg=IDS_INVALID_SPC_FILE;

        //free the certificate store
        if(hFileCertStore)
        {
            CertCloseStore(hFileCertStore, 0);
            hFileCertStore=NULL;
        }

        goto CLEANUP;
   }

   fResult=TRUE;


CLEANUP:

   *pidsMsg=idsMsg;

   if(pwszFileName)
      WizardFree(pwszFileName);


    return fResult;
}


//+-------------------------------------------------------------------------
//
//	Prompt user for a file name, verify it is a SPC file, add the name to
//  the edit box (hwndControl), copy the cert store to the input param.
//  free the input param it is not NULL.
//--------------------------------------------------------------------------
BOOL    RetrieveFileName(HWND           hwndDlg,
                         int            idsMsgTitle,
                         LPWSTR         pwszPageTitle,
                         HCERTSTORE     *phCertStore,
                         LPWSTR         *ppwszFileName)
{
    BOOL                                    fResult=FALSE;
    OPENFILENAMEW                           OpenFileName;
    WCHAR                                   szFileName[_MAX_PATH];
    WCHAR                                   szFilter[MAX_STRING_SIZE];  //"Executable File(*.exe)\0*.exe\0Dynamic Link Library (*.dll)\0*.dll\0All Files\0*.*\0"
    DWORD                                   dwSize=0;


    HCERTSTORE                              hFileCertStore=NULL;

    if(NULL==phCertStore || NULL==hwndDlg || NULL==ppwszFileName)
        goto CLEANUP;

    //open a file
    memset(&OpenFileName, 0, sizeof(OpenFileName));

    *szFileName=L'\0';

    OpenFileName.lStructSize = sizeof(OpenFileName);
    OpenFileName.hwndOwner = hwndDlg;
    OpenFileName.hInstance = NULL;

    //load the fileter string
    if(LoadFilterString(g_hmodThisDll, IDS_SPC_FILE_FILTER, szFilter, MAX_STRING_SIZE))
    {
        OpenFileName.lpstrFilter = szFilter;
    }
    OpenFileName.lpstrCustomFilter = NULL;
    OpenFileName.nMaxCustFilter = 0;
    OpenFileName.nFilterIndex = 1;
    OpenFileName.lpstrFile = szFileName;
    OpenFileName.nMaxFile = _MAX_PATH;
    OpenFileName.lpstrFileTitle = NULL;
    OpenFileName.nMaxFileTitle = 0;
    OpenFileName.lpstrInitialDir = NULL;
    OpenFileName.lpstrTitle = NULL;
    OpenFileName.Flags = OFN_HIDEREADONLY | OFN_FILEMUSTEXIST;
    OpenFileName.nFileOffset = 0;
    OpenFileName.nFileExtension = 0;
    OpenFileName.lpstrDefExt = NULL;
    OpenFileName.lCustData = NULL;
    OpenFileName.lpfnHook = NULL;
    OpenFileName.lpTemplateName = NULL;

    if (WizGetOpenFileName(&OpenFileName))
    {

       //make sure the file name is a valid one
       //the file has to be eitehr a .cer(.crt) or a SPC file
       if(ExpandAndCryptQueryObject(
                CERT_QUERY_OBJECT_FILE,
                szFileName,
                CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED,
                CERT_QUERY_FORMAT_FLAG_BINARY,
                0,
                NULL,
                NULL,
                NULL,
                &hFileCertStore,
                NULL,
                NULL) && (NULL != hFileCertStore))
       {
            //Copy the file name to the list
            SetDlgItemTextU(hwndDlg, IDC_FILE_EDIT, szFileName);

           //close the original store
           if(*phCertStore)
               CertCloseStore(*phCertStore, 0);

            *phCertStore=hFileCertStore;

            //copy the file name
            if(*ppwszFileName)
                WizardFree(*ppwszFileName);

            *ppwszFileName=(LPWSTR)WizardAllocAndCopyWStr(szFileName);
       }
       else
       {
            //warn the user that this is not a valid file
              I_MessageBox(hwndDlg, IDS_INVALID_SPC_FILE,
                                idsMsgTitle,
                                pwszPageTitle,
                                MB_ICONERROR|MB_OK|MB_APPLMODAL);

            //the page should stay
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);

            //fee the certificate store
            if(hFileCertStore)
            {
                CertCloseStore(hFileCertStore, 0);
                hFileCertStore=NULL;
            }

            goto CLEANUP;
       }
    }

    fResult=TRUE;


CLEANUP:

    return fResult;
}


//+-------------------------------------------------------------------------
//
//	Verify if the timestamp address is valid
//--------------------------------------------------------------------------
BOOL    ValidTimeStampAddress(LPWSTR    pwszTimeStamp)
{
    if(NULL==pwszTimeStamp)
        return FALSE;

    //the pwszTimeStamp has to start with "http://"
    if(wcslen(pwszTimeStamp)<=7)
        return FALSE;

    if(_wcsnicmp(pwszTimeStamp, L"http://",7) !=0 )
        return FALSE;

    return TRUE;
}


//+-------------------------------------------------------------------------
//
//	Adds a fileName to the ListView
//--------------------------------------------------------------------------
BOOL    AddFileNameToListView(HWND              hwndControl,
                              LPWSTR            pwszFileName)
{
    LV_ITEMW                    lvItem;

    if((NULL==pwszFileName) || (NULL==hwndControl))
        return FALSE;

    //delete all the old items in the listView
    ListView_DeleteAllItems(hwndControl);

    //insert row by row
    memset(&lvItem, 0, sizeof(LV_ITEMW));

    // set up the fields in the list view item struct that don't change from item to item
    lvItem.mask = LVIF_TEXT | LVIF_STATE ;
    lvItem.state = 0;
    lvItem.stateMask = 0;

    //Subject
    lvItem.iItem=0;
    lvItem.iSubItem=0;

    ListView_InsertItemU_IDS(hwndControl, &lvItem, 0, pwszFileName);


    //autosize the column
    ListView_SetColumnWidth(hwndControl, 0, LVSCW_AUTOSIZE);


    return TRUE;
}


//+-------------------------------------------------------------------------
//
//	Adds a certificate information to the ListView
//--------------------------------------------------------------------------
BOOL    AddCertToListView(HWND              hwndControl,
                          PCCERT_CONTEXT    pCertContext)
{
    LV_ITEMW                    lvItem;
    DWORD                       dwChar;
    WCHAR                       wszNone[MAX_TITLE_LENGTH];

    LPWSTR                      pwszName=NULL;

    if((NULL==pCertContext) || (NULL==hwndControl))
        return FALSE;

    //delete all the old items in the listView
    ListView_DeleteAllItems(hwndControl);

    //load the string <None>
    if(!LoadStringU(g_hmodThisDll, IDS_NONE, wszNone, MAX_TITLE_LENGTH))
        wszNone[0]=L'\0';

    //insert row by row
    memset(&lvItem, 0, sizeof(LV_ITEMW));

    // set up the fields in the list view item struct that don't change from item to item
    lvItem.mask = LVIF_TEXT | LVIF_STATE ;
    lvItem.state = 0;
    lvItem.stateMask = 0;

    //Subject
    lvItem.iItem=0;
    lvItem.iSubItem=0;

    ListView_InsertItemU_IDS(hwndControl, &lvItem, IDS_COLUMN_SUBJECT, NULL);

    //content
    lvItem.iSubItem++;

    dwChar=CertGetNameStringW(
        pCertContext,
        CERT_NAME_SIMPLE_DISPLAY_TYPE,
        0,
        NULL,
        NULL,
        0);

    if ((dwChar != 0) && (NULL != (pwszName = (LPWSTR)WizardAlloc(dwChar * sizeof(WCHAR)))))
    {

        CertGetNameStringW(
            pCertContext,
            CERT_NAME_SIMPLE_DISPLAY_TYPE,
            0,
            NULL,
            pwszName,
            dwChar);

        ListView_SetItemTextU(hwndControl, lvItem.iItem, lvItem.iSubItem, pwszName);
    }
    else
        ListView_SetItemTextU(hwndControl, lvItem.iItem, lvItem.iSubItem, wszNone);

    //free memory
    if(pwszName)
    {
        WizardFree(pwszName);
        pwszName=NULL;
    }

    //signing certificate issuer
    lvItem.iItem++;
    lvItem.iSubItem=0;

    ListView_InsertItemU_IDS(hwndControl, &lvItem, IDS_COLUMN_ISSUER, NULL);

    //content
    lvItem.iSubItem++;

    dwChar=CertGetNameStringW(
        pCertContext,
        CERT_NAME_SIMPLE_DISPLAY_TYPE,
        CERT_NAME_ISSUER_FLAG,
        NULL,
        NULL,
        0);

    if ((dwChar != 0) && (NULL != (pwszName = (LPWSTR)WizardAlloc(dwChar * sizeof(WCHAR)))))
    {

        CertGetNameStringW(
            pCertContext,
            CERT_NAME_SIMPLE_DISPLAY_TYPE,
            CERT_NAME_ISSUER_FLAG,
            NULL,
            pwszName,
            dwChar);

        ListView_SetItemTextU(hwndControl, lvItem.iItem, lvItem.iSubItem,
                       pwszName);

    }
    else
        ListView_SetItemTextU(hwndControl, lvItem.iItem, lvItem.iSubItem,
                       wszNone);


    //free the memory
    if(pwszName)
    {
        WizardFree(pwszName);
        pwszName=NULL;
    }

    //signing certificate purpose
    lvItem.iItem++;
    lvItem.iSubItem=0;

    ListView_InsertItemU_IDS(hwndControl, &lvItem, IDS_COLUMN_PURPOSE, NULL);

    //content
    lvItem.iSubItem++;

    if(MyFormatEnhancedKeyUsageString(&pwszName,pCertContext, FALSE, FALSE))
    {

       ListView_SetItemTextU(hwndControl, lvItem.iItem, lvItem.iSubItem,
                      pwszName);

    }
    

    //free the memory
    if(pwszName)
    {
        WizardFree(pwszName);
        pwszName=NULL;
    }



    //signing certificate expiration
    lvItem.iItem++;
    lvItem.iSubItem=0;

    ListView_InsertItemU_IDS(hwndControl, &lvItem, IDS_COLUMN_EXPIRE, NULL);

    //content
    lvItem.iSubItem++;

    if(WizardFormatDateString(&pwszName,pCertContext->pCertInfo->NotAfter, FALSE))
    {
       ListView_SetItemTextU(hwndControl, lvItem.iItem, lvItem.iSubItem,
                      pwszName);

    }
    else
        ListView_SetItemTextU(hwndControl, lvItem.iItem, lvItem.iSubItem,
                       wszNone);

    //free the memory
    if(pwszName)
    {
        WizardFree(pwszName);
        pwszName=NULL;
    }

    //autosize the columns
    ListView_SetColumnWidth(hwndControl, 0, LVSCW_AUTOSIZE);
    ListView_SetColumnWidth(hwndControl, 1, LVSCW_AUTOSIZE);


    return TRUE;
}


//+-------------------------------------------------------------------------
//
//	This function checks for the commercial or individual signing OIDs in the
//  certificate
//--------------------------------------------------------------------------
BOOL    GetCommercial(PCCERT_CONTEXT pSignerCert, BOOL *pfCommercial,
				BOOL *pfIndividual)
{
    BOOL                                fResult=FALSE;
    PCERT_EXTENSION                     pExt=NULL;
    PCERT_KEY_USAGE_RESTRICTION_INFO    pInfo = NULL;
    DWORD                               cbInfo=0;

	if(!pfCommercial || !pfIndividual ||!pSignerCert)
		return FALSE;

	//init
	*pfCommercial=FALSE;
    *pfIndividual=FALSE;


	//first look into the cert extension szOID_KEY_USAGE_RESTRICTION
    pExt = CertFindExtension(szOID_KEY_USAGE_RESTRICTION,
                             pSignerCert->pCertInfo->cExtension,
                             pSignerCert->pCertInfo->rgExtension);

    if(!pExt)
        return FALSE;


    CryptDecodeObject(X509_ASN_ENCODING,
                      X509_KEY_USAGE_RESTRICTION,
                      pExt->Value.pbData,
                      pExt->Value.cbData,
                      0,                      // dwFlags
                      NULL,                   // pInfo
                      &cbInfo);
    if (cbInfo == 0)
        return FALSE;

    pInfo = (PCERT_KEY_USAGE_RESTRICTION_INFO)WizardAlloc(cbInfo);

    if(!pInfo)
        return FALSE;

    if (!CryptDecodeObject(X509_ASN_ENCODING,
                           X509_KEY_USAGE_RESTRICTION,
                           pExt->Value.pbData,
                           pExt->Value.cbData,
                           0,                  // dwFlags
                           pInfo,
                           &cbInfo))
        goto CLEANUP;


    if (pInfo->cCertPolicyId)
	{
        DWORD           cPolicyId=0;
        PCERT_POLICY_ID pPolicyId=NULL;

        cPolicyId = pInfo->cCertPolicyId;
        pPolicyId = pInfo->rgCertPolicyId;

        for ( ; cPolicyId > 0; cPolicyId--, pPolicyId++)
		{
            DWORD cElementId = pPolicyId->cCertPolicyElementId;
            LPSTR *ppszElementId = pPolicyId->rgpszCertPolicyElementId;
            for ( ; cElementId > 0; cElementId--, ppszElementId++)
			{
                if (strcmp(*ppszElementId,
                           SPC_COMMERCIAL_SP_KEY_PURPOSE_OBJID) == 0)
                    *pfCommercial = TRUE;

                if (strcmp(*ppszElementId,
                           SPC_INDIVIDUAL_SP_KEY_PURPOSE_OBJID) == 0)
                    *pfIndividual = TRUE;
            }
        }
    } //end of pInfo->cCertPolicyId

    fResult=TRUE;

CLEANUP:

    if (pInfo)
        WizardFree(pInfo);

    return fResult;
}



//----------------------------------------------------------------------------
//  Check to see if the certificate is a valid signing cert
//  We do so by excluding the certificates that has only non-code signing OIDs
//
//----------------------------------------------------------------------------
BOOL IsValidSigningCert(PCCERT_CONTEXT pCertContext)
{
    BOOL        fResult  = FALSE;
    int         cNumOID  = 0;
    LPSTR       *rgOID   = NULL;
    DWORD       cbOID    = 0;
    DWORD       dwIndex  = 0;
    DWORD       cbData   = 0;
    DWORD       cbInfo   = 0;
    PCERT_EXTENSION pExt = NULL;
    PCERT_KEY_USAGE_RESTRICTION_INFO pInfo = NULL;

    // Sanity check.
    if (!pCertContext)
    {
        goto InvalidArgError;
    }

    // The certificate has to have the CERT_KEY_PROV_INFO_PROP_ID
    if (!CertGetCertificateContextProperty(pCertContext,
                                           CERT_KEY_PROV_INFO_PROP_ID,
                                           NULL,
                                           &cbData))
    {
        goto NoPrivateKeyReturn;
    }

    if (0 == cbData)
    {
        goto NoPrivateKeyReturn;
    }

    // At least, check certificate for time validity.
    if (0 != CertVerifyTimeValidity(NULL, pCertContext->pCertInfo))
    {
        goto NotTimeValidError;
    }

    // Get the OIDs from the cert
    if (!CertGetValidUsages(1,
                            &pCertContext,
                            &cNumOID,
                            NULL,
                            &cbOID))
    {
        goto ValidUsagesError;
    }

    // -1 means the certiifcate is good for everything.
    if (-1 == cNumOID)
    {
        goto SuccessReturn;
    }

    if (NULL == (rgOID = (LPSTR *) WizardAlloc(cbOID)))
    {
        goto MemoryError;
    }

    if (!CertGetValidUsages(1,
                            &pCertContext,
                            &cNumOID,
                            rgOID,
                            &cbOID))
    {
        goto ValidUsagesError;
    }

    // Look for code signing OID.
    for (dwIndex=0; dwIndex < (DWORD) cNumOID; dwIndex++)
    {
        if (0 == strcmp(rgOID[dwIndex], szOID_PKIX_KP_CODE_SIGNING))
        {
		    goto SuccessReturn;
        }
    }

    // We did't find code signing OID, so check for legacy VeriSign OID.
    if (0 == pCertContext->pCertInfo->cExtension)
    {
        goto NoSignerCertExtensions;
    }

    if (NULL == (pExt = CertFindExtension(szOID_KEY_USAGE_RESTRICTION,
                                          pCertContext->pCertInfo->cExtension,
                                          pCertContext->pCertInfo->rgExtension)))
    {
        goto NoSignerKeyUsageExtension;
    }

    if (!CryptDecodeObjectEx(pCertContext->dwCertEncodingType,
                             X509_KEY_USAGE_RESTRICTION,
                             pExt->Value.pbData,
                             pExt->Value.cbData,
                             CRYPT_DECODE_NOCOPY_FLAG | 
                                 CRYPT_DECODE_ALLOC_FLAG |
                                 CRYPT_DECODE_SHARE_OID_STRING_FLAG,
                             NULL,
                             (void *) &pInfo,
                             &cbInfo))
    {
        goto DecodeError;
    }

    if (pInfo->cCertPolicyId) 
    {
        DWORD cPolicyId;
        PCERT_POLICY_ID pPolicyId;

        cPolicyId = pInfo->cCertPolicyId;
        pPolicyId = pInfo->rgCertPolicyId;
        for ( ; cPolicyId > 0; cPolicyId--, pPolicyId++) 
        {
            DWORD cElementId = pPolicyId->cCertPolicyElementId;
            LPSTR *ppszElementId = pPolicyId->rgpszCertPolicyElementId;

            for ( ; cElementId > 0; cElementId--, ppszElementId++) 
            {
                if (0 == strcmp(*ppszElementId, SPC_COMMERCIAL_SP_KEY_PURPOSE_OBJID) ||
                    0 == strcmp(*ppszElementId, SPC_INDIVIDUAL_SP_KEY_PURPOSE_OBJID))
                {
                    goto SuccessReturn;
                }
            }
        }    
    }

    goto NoSignerLegacyPurpose;

SuccessReturn:
    fResult = TRUE;

CommonReturn:
    if (rgOID)
    {
        WizardFree(rgOID);
    }

    if (pInfo)
    {
        LocalFree(pInfo);
    }

    return fResult;

ErrorReturn:
    fResult = FALSE;

    goto CommonReturn;

SET_ERROR(InvalidArgError, E_INVALIDARG)
TRACE_ERROR(NoPrivateKeyReturn)
TRACE_ERROR(NotTimeValidError)
SET_ERROR(MemoryError, E_OUTOFMEMORY)
TRACE_ERROR(ValidUsagesError)
TRACE_ERROR(NoSignerCertExtensions)
TRACE_ERROR(NoSignerKeyUsageExtension)
TRACE_ERROR(DecodeError)
TRACE_ERROR(NoSignerLegacyPurpose)
}

//----------------------------------------------------------------------------
//  CallBack fro cert selection call back
//
//----------------------------------------------------------------------------
static BOOL WINAPI SelectCertCallBack(
        PCCERT_CONTEXT  pCertContext,
        BOOL            *pfInitialSelectedCert,
        void            *pvCallbackData)
{
    if(!pCertContext)
        return FALSE;

    //make sure that this is a valid certificate
    return IsValidSigningCert(pCertContext);
}

//-----------------------------------------------------------------------
//SetControlText
//-----------------------------------------------------------------------
void
SetControlText(
   LPWSTR   pwsz,
   HWND     hwnd,
   INT      nId)
{
	if(pwsz )
    {
    	HWND hwndControl = GetDlgItem(hwnd, nId);

    	if( hwndControl )
        {
        	SetWindowTextU(hwndControl, pwsz);
        }
    }
}



//-----------------------------------------------------------------------
//InitPvkSignInfo
//-----------------------------------------------------------------------
BOOL    InitPvkSignInfo(CERT_SIGNING_INFO **ppPvkSignInfo)
{
    BOOL    fResult=FALSE;

    if(!ppPvkSignInfo)
        goto InvalidArgErr;

    *ppPvkSignInfo=(CERT_SIGNING_INFO *)WizardAlloc(sizeof(CERT_SIGNING_INFO));

    if(NULL==(*ppPvkSignInfo))
        goto MemoryErr;

    //memset
    memset(*ppPvkSignInfo, 0, sizeof(CERT_SIGNING_INFO));

    (*ppPvkSignInfo)->fFree=TRUE;
    (*ppPvkSignInfo)->idsMsgTitle=IDS_SIGN_CONFIRM_TITLE;

    //set up the fonts
    if(!SetupFonts(g_hmodThisDll,
               NULL,
               &((*ppPvkSignInfo)->hBigBold),
               &((*ppPvkSignInfo)->hBold)))
        goto TraceErr;

    fResult=TRUE;

CommonReturn:

    return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
TRACE_ERROR(TraceErr);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
}


//-----------------------------------------------------------------------
//FreePvkCertSigningInfo
//-----------------------------------------------------------------------
void    FreePvkCertSigningInfo(CERT_SIGNING_INFO *pPvkSignInfo)
{
    DWORD       dwIndex=0;

    if(pPvkSignInfo)
    {
        //destroy the hFont object
        DestroyFonts(pPvkSignInfo->hBigBold,
                pPvkSignInfo->hBold);

        if(pPvkSignInfo->pszHashOIDName)
            WizardFree(pPvkSignInfo->pszHashOIDName);

        if(pPvkSignInfo->pCSPInfo)
        {
            for(dwIndex=0; dwIndex < pPvkSignInfo->dwCSPCount; dwIndex++)
            {
                if((pPvkSignInfo->pCSPInfo)[dwIndex].pwszCSPName)
                    WizardFree((pPvkSignInfo->pCSPInfo)[dwIndex].pwszCSPName);
            }

            WizardFree(pPvkSignInfo->pCSPInfo);
        }

        if(pPvkSignInfo->pwszPvk_File)
            WizardFree(pPvkSignInfo->pwszPvk_File);

        if(pPvkSignInfo->pwszPvk_CSP)
            WizardFree(pPvkSignInfo->pwszPvk_CSP);

        if(pPvkSignInfo->pwszContainer_CSP)
            WizardFree(pPvkSignInfo->pwszContainer_CSP);

        if(pPvkSignInfo->pwszContainer_Name)
            WizardFree(pPvkSignInfo->pwszContainer_Name);

         if(pPvkSignInfo->pwszContainer_KeyType)
            WizardFree(pPvkSignInfo->pwszContainer_KeyType);


        if(pPvkSignInfo->hAddFileCertStore)
            CertCloseStore(pPvkSignInfo->hAddFileCertStore, 0);


        if(pPvkSignInfo->hAddStoreCertStore && (TRUE==pPvkSignInfo->fFreeStoreCertStore ))
            CertCloseStore(pPvkSignInfo->hAddStoreCertStore, 0);

        if(pPvkSignInfo->pwszAddFileName)
            WizardFree(pPvkSignInfo->pwszAddFileName);

        if(pPvkSignInfo->pwszDes)
            WizardFree(pPvkSignInfo->pwszDes);

        if(pPvkSignInfo->pwszURL)
            WizardFree(pPvkSignInfo->pwszURL);

        if(pPvkSignInfo->pwszTimeStamp)
            WizardFree(pPvkSignInfo->pwszTimeStamp);

        if(pPvkSignInfo->pwszSPCFileName)
            WizardFree(pPvkSignInfo->pwszSPCFileName);

        if(pPvkSignInfo->pSignCert)
            CertFreeCertificateContext(pPvkSignInfo->pSignCert);

        if(pPvkSignInfo->rghCertStore)
        {
            for(dwIndex=0; dwIndex < pPvkSignInfo->dwCertStore; dwIndex++)
                CertCloseStore(pPvkSignInfo->rghCertStore[dwIndex],0);

          //  WizardFree(pPvkSignInfo->rghCertStore);

        }

        if(pPvkSignInfo->pwszFileName)
            WizardFree(pPvkSignInfo->pwszFileName);

        WizardFree(pPvkSignInfo);
    }


}

//-----------------------------------------------------------------------
//Call the signing procedure when the window is destroyed
//-----------------------------------------------------------------------
void    SignAtDestroy(HWND                             hwndDlg,
                      CRYPTUI_WIZ_GET_SIGN_PAGE_INFO   *pGetSignInfo,
                      DWORD                            dwID)
{
    CERT_SIGNING_INFO                      *pPvkSignInfo=NULL;

    if(NULL==pGetSignInfo)
        return;

    if(NULL==(pPvkSignInfo=(CERT_SIGNING_INFO *)(pGetSignInfo->pvSignReserved)))
        return;

    //make sure user has not click the cancel button
    if(TRUE==pPvkSignInfo->fCancel)
    {
        pGetSignInfo->fResult=FALSE;
        pGetSignInfo->dwError=ERROR_CANCELLED;
        pGetSignInfo->pSignContext=NULL;

        //free the private signing information
        if(pPvkSignInfo->fFree)
        {
            FreePvkCertSigningInfo(pPvkSignInfo);
            pGetSignInfo->pvSignReserved=NULL;
        }
    }
    else
    {
       //make sure the window is the last wizard page

       if(pGetSignInfo->dwReserved==dwID)
       {
            I_SigningWizard(pGetSignInfo);

            //free the private signing information
            if(pPvkSignInfo->fFree)
            {
                FreePvkCertSigningInfo(pPvkSignInfo);
                pGetSignInfo->pvSignReserved=NULL;
            }
       }
    }
    return;

}

 //////////////////////////////////////////////////////////////////////////////////////
//  The call back function for enum system stores for the signing certificate
//////////////////////////////////////////////////////////////////////////////////////
static BOOL WINAPI EnumSysStoreSignPvkCallBack(
    const void* pwszSystemStore,
    DWORD dwFlags,
    PCERT_SYSTEM_STORE_INFO pStoreInfo,
    void *pvReserved,
    void *pvArg
    )
{
    SIGN_CERT_STORE_LIST     *pCertStoreList=NULL;
    HCERTSTORE              hCertStore=NULL;

    if(NULL==pvArg)
        return FALSE;

    pCertStoreList=(SIGN_CERT_STORE_LIST *)pvArg;

    //open the store
    hCertStore=CertOpenStore(CERT_STORE_PROV_SYSTEM_W,
							g_dwMsgAndCertEncodingType,
							NULL,
							CERT_SYSTEM_STORE_CURRENT_USER |CERT_STORE_SET_LOCALIZED_NAME_FLAG,
                            (LPWSTR)pwszSystemStore);

    if(!hCertStore)
       return FALSE;


    pCertStoreList->prgStore=(HCERTSTORE *)WizardRealloc(
        pCertStoreList->prgStore,
        sizeof(HCERTSTORE) *(pCertStoreList->dwStoreCount +1));

    if(NULL==pCertStoreList->prgStore)
    {
        CertCloseStore(hCertStore, 0);
        pCertStoreList->dwStoreCount=0;
    }

    pCertStoreList->prgStore[pCertStoreList->dwStoreCount]=hCertStore;
    pCertStoreList->dwStoreCount++;

    return TRUE;
}
//-----------------------------------------------------------------------
//Select a signing certificate from a store.
//If no store has been opened, enum all the system stores
//-----------------------------------------------------------------------
PCCERT_CONTEXT  SelectCertFromStore(HWND                            hwndDlg,
                                    CRYPTUI_WIZ_GET_SIGN_PAGE_INFO  *pGetSignInfo)
{
    CRYPTUI_SELECTCERTIFICATE_STRUCT        SelCert;
    CERT_SIGNING_INFO                       *pPvkSignInfo=NULL;
    CRYPTUI_WIZ_DIGITAL_SIGN_INFO           *pDigitalSignInfo=NULL;

    PCCERT_CONTEXT                          pCertContext=NULL;
    //SIGN_CERT_STORE_LIST                    CertStoreList;


    if(NULL==pGetSignInfo)
        return NULL;

    if(NULL==(pPvkSignInfo=(CERT_SIGNING_INFO *)(pGetSignInfo->pvSignReserved)))
        return NULL;

    //init
    memset(&SelCert, 0, sizeof(CRYPTUI_SELECTCERTIFICATE_STRUCT));
    //memset(&CertStoreList, 0, sizeof(SIGN_CERT_STORE_LIST));

    //set up the parameter for cert selection dialogue
    SelCert.dwSize=sizeof(CRYPTUI_SELECTCERTIFICATE_STRUCT);
    SelCert.hwndParent=hwndDlg;

    if(pPvkSignInfo->dwCertStore && pPvkSignInfo->rghCertStore)
    {
        SelCert.pFilterCallback=SelectCertCallBack;
        SelCert.pvCallbackData=NULL;
        SelCert.cDisplayStores=pPvkSignInfo->dwCertStore;
        SelCert.rghDisplayStores=pPvkSignInfo->rghCertStore;
    }
    else
    {
        pDigitalSignInfo=(CRYPTUI_WIZ_DIGITAL_SIGN_INFO *)(pGetSignInfo->pDigitalSignInfo);

        if(pDigitalSignInfo)
        {
            if(CRYPTUI_WIZ_DIGITAL_SIGN_STORE == pDigitalSignInfo->dwSigningCertChoice)
            {
                SelCert.pFilterCallback=pDigitalSignInfo->pSigningCertStore->pFilterCallback;
                SelCert.pvCallbackData=pDigitalSignInfo->pSigningCertStore->pvCallbackData;
                SelCert.cDisplayStores=pDigitalSignInfo->pSigningCertStore->cCertStore;
                SelCert.rghDisplayStores=pDigitalSignInfo->pSigningCertStore->rghCertStore;
            }
            else
            {
                /*if (!CertEnumSystemStore(
                        CERT_SYSTEM_STORE_CURRENT_USER,
                        NULL,
                        &CertStoreList,
                        EnumSysStoreSignPvkCallBack))
                    return NULL;*/

                //open the my store
                if(NULL == (pPvkSignInfo->hMyStore=CertOpenStore(CERT_STORE_PROV_SYSTEM_W,
							g_dwMsgAndCertEncodingType,
							NULL,
							CERT_SYSTEM_STORE_CURRENT_USER |CERT_STORE_SET_LOCALIZED_NAME_FLAG,
                            L"my")))
                    return NULL;


                pPvkSignInfo->rghCertStore=&(pPvkSignInfo->hMyStore);         //CertStoreList.prgStore;
                pPvkSignInfo->dwCertStore=1;          //CertStoreList.dwStoreCount;

                SelCert.pFilterCallback=SelectCertCallBack;
                SelCert.pvCallbackData=NULL;
                SelCert.cDisplayStores=pPvkSignInfo->dwCertStore;
                SelCert.rghDisplayStores=pPvkSignInfo->rghCertStore;

            }
        }
        else
        {
            //open all the system stores
            /*if (!CertEnumSystemStore(
                    CERT_SYSTEM_STORE_CURRENT_USER,
                    NULL,
                    &CertStoreList,
                    EnumSysStoreSignPvkCallBack))
                return NULL; */

            //open the my store
            if(NULL == (pPvkSignInfo->hMyStore=CertOpenStore(CERT_STORE_PROV_SYSTEM_W,
						g_dwMsgAndCertEncodingType,
						NULL,
						CERT_SYSTEM_STORE_CURRENT_USER |CERT_STORE_SET_LOCALIZED_NAME_FLAG,
                        L"my")))
                return NULL;

            pPvkSignInfo->rghCertStore=&(pPvkSignInfo->hMyStore);     //CertStoreList.prgStore;
            pPvkSignInfo->dwCertStore=1;              //CertStoreList.dwStoreCount;

            SelCert.pFilterCallback=SelectCertCallBack;
            SelCert.pvCallbackData=NULL;
            SelCert.cDisplayStores=pPvkSignInfo->dwCertStore;
            SelCert.rghDisplayStores=pPvkSignInfo->rghCertStore;
        }
    }

    pCertContext=CryptUIDlgSelectCertificate(&SelCert);

    return pCertContext;
}

//-------------------------------------------------------------------------
//DisplayConfirmation
//-------------------------------------------------------------------------
void    DisplayConfirmation(HWND                                hwndControl,
                            CRYPTUI_WIZ_GET_SIGN_PAGE_INFO      *pGetSignInfo)
{
    LV_ITEMW                    lvItem;
    DWORD                       dwChar;
    WCHAR                       wszNone[MAX_TITLE_LENGTH];
    CERT_SIGNING_INFO           *pPvkSignInfo=NULL;
    WCHAR                       wszTypeName[CSP_TYPE_NAME];
    WCHAR                       wszText[MAX_STRING_SIZE];
    UINT                        idsText=0;

    LPWSTR                      pwszName=NULL;
    LPWSTR                      pwszStoreName=NULL;

    if(NULL==pGetSignInfo)
        return;

    if(NULL==(pPvkSignInfo=(CERT_SIGNING_INFO *)(pGetSignInfo->pvSignReserved)))
        return;

    //delete all the old items in the listView
    ListView_DeleteAllItems(hwndControl);

    //load the string <None>
    if(!LoadStringU(g_hmodThisDll, IDS_NONE, wszNone, MAX_TITLE_LENGTH))
        wszNone[0]=L'\0';

    //insert row by row
    memset(&lvItem, 0, sizeof(LV_ITEMW));

    // set up the fields in the list view item struct that don't change from item to item
    lvItem.mask = LVIF_TEXT | LVIF_STATE ;
    lvItem.state = 0;
    lvItem.stateMask = 0;

    //Signing Certificate
    lvItem.iItem=0;
    lvItem.iSubItem=0;


    if(pPvkSignInfo->pwszFileName)
    {
        lvItem.iSubItem=0;

        ListView_InsertItemU_IDS(hwndControl, &lvItem, IDS_FILE_TO_SIGN, NULL);

        //content
        lvItem.iSubItem++;

        ListView_SetItemTextU(hwndControl, lvItem.iItem, lvItem.iSubItem,pPvkSignInfo->pwszFileName);
        lvItem.iItem++;
    }



    //Signing certificate subject
    if(pPvkSignInfo->fSignCert && pPvkSignInfo->pSignCert)
    {
        ListView_InsertItemU_IDS(hwndControl, &lvItem, IDS_SIGN_CERT, NULL);

        lvItem.iSubItem=0;

        ListView_InsertItemU_IDS(hwndControl, &lvItem, IDS_SIGN_CERT_ISSUE_TO, NULL);

        //content
        lvItem.iSubItem++;

        dwChar=CertGetNameStringW(
            pPvkSignInfo->pSignCert,
            CERT_NAME_SIMPLE_DISPLAY_TYPE,
            0,
            NULL,
            NULL,
            0);

        if ((dwChar != 0) && (NULL != (pwszName = (LPWSTR)WizardAlloc(dwChar * sizeof(WCHAR)))))
        {

            CertGetNameStringW(
                pPvkSignInfo->pSignCert,
                CERT_NAME_SIMPLE_DISPLAY_TYPE,
                0,
                NULL,
                pwszName,
                dwChar);

            ListView_SetItemTextU(hwndControl, lvItem.iItem, lvItem.iSubItem, pwszName);
        }
        else
            ListView_SetItemTextU(hwndControl, lvItem.iItem, lvItem.iSubItem, wszNone);

        //free memory
        if(pwszName)
        {
            WizardFree(pwszName);
            pwszName=NULL;
        }

        lvItem.iItem++;

        //signing certificate issuer
        lvItem.iSubItem=0;

        ListView_InsertItemU_IDS(hwndControl, &lvItem, IDS_SIGN_CERT_ISSUE_BY, NULL);

        //content
        lvItem.iSubItem++;

        dwChar=CertGetNameStringW(
            pPvkSignInfo->pSignCert,
            CERT_NAME_SIMPLE_DISPLAY_TYPE,
            CERT_NAME_ISSUER_FLAG,
            NULL,
            NULL,
            0);

        if ((dwChar != 0) && (NULL != (pwszName = (LPWSTR)WizardAlloc(dwChar * sizeof(WCHAR)))))
        {

            CertGetNameStringW(
                pPvkSignInfo->pSignCert,
                CERT_NAME_SIMPLE_DISPLAY_TYPE,
                CERT_NAME_ISSUER_FLAG,
                NULL,
                pwszName,
                dwChar);

            ListView_SetItemTextU(hwndControl, lvItem.iItem, lvItem.iSubItem,
                           pwszName);

        }
        else
            ListView_SetItemTextU(hwndControl, lvItem.iItem, lvItem.iSubItem,
                           wszNone);


        //free the memory
        if(pwszName)
        {
            WizardFree(pwszName);
            pwszName=NULL;
        }

        lvItem.iItem++;

         //signing certificate expiration
        lvItem.iSubItem=0;

        ListView_InsertItemU_IDS(hwndControl, &lvItem, IDS_SIGN_CERT_EXPIRATION, NULL);

        //content
        lvItem.iSubItem++;

        if(WizardFormatDateString(&pwszName,pPvkSignInfo->pSignCert->pCertInfo->NotAfter, FALSE))
        {
           ListView_SetItemTextU(hwndControl, lvItem.iItem, lvItem.iSubItem,
                          pwszName);

        }
        else
            ListView_SetItemTextU(hwndControl, lvItem.iItem, lvItem.iSubItem,
                           wszNone);

        //free the memory
        if(pwszName)
        {
            WizardFree(pwszName);
            pwszName=NULL;
        }

        lvItem.iItem++;
    }

    //CPS file
    if((FALSE == pPvkSignInfo->fSignCert) && (pPvkSignInfo->pwszSPCFileName))
    {
        lvItem.iSubItem=0;

        ListView_InsertItemU_IDS(hwndControl, &lvItem, IDS_SIGN_SPC_FILE, NULL);

        //content
        lvItem.iSubItem++;

        if(pPvkSignInfo->pwszSPCFileName)
            ListView_SetItemTextU(hwndControl, lvItem.iItem, lvItem.iSubItem,pPvkSignInfo->pwszSPCFileName);

        lvItem.iItem++;

    }

    //private key file information
    if(pPvkSignInfo->fUsePvkPage && pPvkSignInfo->fPvkFile)
    {
        //PVK file name
        lvItem.iSubItem=0;

        ListView_InsertItemU_IDS(hwndControl, &lvItem, IDS_SIGN_PVK_FILE, NULL);

        //content
        lvItem.iSubItem++;

        if(pPvkSignInfo->pwszPvk_File)
            ListView_SetItemTextU(hwndControl, lvItem.iItem, lvItem.iSubItem,pPvkSignInfo->pwszPvk_File);

        lvItem.iItem++;

        //csp name
        lvItem.iSubItem=0;

        ListView_InsertItemU_IDS(hwndControl, &lvItem, IDS_SIGN_CSP_NAME, NULL);

        //content
        lvItem.iSubItem++;

        if(pPvkSignInfo->pwszPvk_CSP)
            ListView_SetItemTextU(hwndControl, lvItem.iItem, lvItem.iSubItem,pPvkSignInfo->pwszPvk_CSP);

        lvItem.iItem++;

        //csp type
        lvItem.iSubItem=0;

        ListView_InsertItemU_IDS(hwndControl, &lvItem, IDS_SIGN_CSP_TYPE, NULL);

        //content
        lvItem.iSubItem++;

        if(GetProviderTypeName(pPvkSignInfo->dwPvk_CSPType,
                               wszTypeName))
            ListView_SetItemTextU(hwndControl, lvItem.iItem, lvItem.iSubItem,
                        wszTypeName);

        lvItem.iItem++;
    }

    //private key container information
    if(pPvkSignInfo->fUsePvkPage && (FALSE ==pPvkSignInfo->fPvkFile))
    {
        //csp name
        lvItem.iSubItem=0;

        ListView_InsertItemU_IDS(hwndControl, &lvItem, IDS_SIGN_CSP_NAME, NULL);

        //content
        lvItem.iSubItem++;

        if(pPvkSignInfo->pwszContainer_CSP)
            ListView_SetItemTextU(hwndControl, lvItem.iItem, lvItem.iSubItem,pPvkSignInfo->pwszContainer_CSP);

        lvItem.iItem++;

        //csp type
        lvItem.iSubItem=0;

        ListView_InsertItemU_IDS(hwndControl, &lvItem, IDS_SIGN_CSP_TYPE, NULL);

        //content
        lvItem.iSubItem++;

        if(GetProviderTypeName(pPvkSignInfo->dwContainer_CSPType,
                               wszTypeName))
            ListView_SetItemTextU(hwndControl, lvItem.iItem, lvItem.iSubItem,
                        wszTypeName);

        lvItem.iItem++;

        //key container
        lvItem.iSubItem=0;

        ListView_InsertItemU_IDS(hwndControl, &lvItem, IDS_SIGN_KEY_CONTAINER, NULL);

        //content
        lvItem.iSubItem++;

        if(pPvkSignInfo->pwszContainer_Name)
            ListView_SetItemTextU(hwndControl, lvItem.iItem, lvItem.iSubItem,pPvkSignInfo->pwszContainer_Name);

        lvItem.iItem++;

        //key spec
        lvItem.iSubItem=0;

        ListView_InsertItemU_IDS(hwndControl, &lvItem, IDS_SIGN_KEY_SPEC, NULL);

        //content
        lvItem.iSubItem++;

        if(pPvkSignInfo->pwszContainer_KeyType)
            ListView_SetItemTextU(hwndControl, lvItem.iItem, lvItem.iSubItem,pPvkSignInfo->pwszContainer_KeyType);

        lvItem.iItem++;
    }

    //Hash OID
    if(pPvkSignInfo->pszHashOIDName)
    {
        lvItem.iSubItem=0;

        ListView_InsertItemU_IDS(hwndControl, &lvItem, IDS_HASH_ALG, NULL);

        //content
        lvItem.iSubItem++;

        ListView_SetItemText(hwndControl, lvItem.iItem, lvItem.iSubItem,pPvkSignInfo->pszHashOIDName);
        lvItem.iItem++;
    }

    //chain options
    if(pPvkSignInfo->fUsageChain)
    {
        switch(pPvkSignInfo->dwChainOption)
        {
            case  SIGN_PVK_NO_CHAIN:
                    idsText=IDS_SIGN_NO_CHAIN;
                break;
            case      SIGN_PVK_CHAIN_ROOT:
                    idsText=IDS_SIGN_CHAIN_ROOT;
                break;
            case       SIGN_PVK_CHAIN_NO_ROOT:
                    idsText=IDS_SIGN_CHAIN_NO_ROOT;
                break;
            default:
                idsText=0;
        }

        if(idsText)
        {
            lvItem.iSubItem=0;

            ListView_InsertItemU_IDS(hwndControl, &lvItem, IDS_SIGN_CERT_CHAIN, NULL);

            //content
            lvItem.iSubItem++;

            //load the stirng
            if(!LoadStringU(g_hmodThisDll, idsText, wszText, MAX_STRING_SIZE))
                wszText[0]=L'\0';

            ListView_SetItemTextU(hwndControl, lvItem.iItem, lvItem.iSubItem,wszText);
            lvItem.iItem++;
        }
    }

    //additional certificate
    if(pPvkSignInfo->fUsageChain)
    {
        switch(pPvkSignInfo->dwAddOption)
        {
            case  SIGN_PVK_NO_ADD:
                        lvItem.iSubItem=0;

                        ListView_InsertItemU_IDS(hwndControl, &lvItem, IDS_SIGN_NO_ADD, NULL);

                        lvItem.iItem++;

                break;
            case    SIGN_PVK_ADD_FILE:
                        lvItem.iSubItem=0;

                        ListView_InsertItemU_IDS(hwndControl, &lvItem, IDS_SIGN_ADD_FILE, NULL);

                        lvItem.iSubItem++;

                        if(pPvkSignInfo->pwszAddFileName)
                            ListView_SetItemTextU(hwndControl, lvItem.iItem, lvItem.iSubItem,pPvkSignInfo->pwszAddFileName);

                        lvItem.iItem++;
                break;
            case       SIGN_PVK_ADD_STORE:
                        lvItem.iSubItem=0;

                        ListView_InsertItemU_IDS(hwndControl, &lvItem, IDS_SIGN_ADD_STORE, NULL);

                        lvItem.iSubItem++;


                        //get the store name
                        if(SignGetStoreName(pPvkSignInfo->hAddStoreCertStore, &pwszStoreName))
                            ListView_SetItemTextU(hwndControl, lvItem.iItem, lvItem.iSubItem,pwszStoreName);

                        if(pwszStoreName)
                        {
                            WizardFree(pwszStoreName);
                            pwszStoreName=NULL;
                        }

                        lvItem.iItem++;
                break;
            default:
                idsText=0;
        }

    }

    //content description
    if(pPvkSignInfo->fUseDescription  && pPvkSignInfo->pwszDes)
    {
        lvItem.iSubItem=0;

        ListView_InsertItemU_IDS(hwndControl, &lvItem, IDS_CONTENT_DES, NULL);

        //content
        lvItem.iSubItem++;

        ListView_SetItemTextU(hwndControl, lvItem.iItem, lvItem.iSubItem,pPvkSignInfo->pwszDes);
        lvItem.iItem++;
    }


    //content URL
    if(pPvkSignInfo->fUseDescription  && pPvkSignInfo->pwszURL)
    {
        lvItem.iSubItem=0;

        ListView_InsertItemU_IDS(hwndControl, &lvItem, IDS_CONTENT_URL, NULL);

        //content
        lvItem.iSubItem++;

        ListView_SetItemTextU(hwndControl, lvItem.iItem, lvItem.iSubItem,pPvkSignInfo->pwszURL);
        lvItem.iItem++;
    }


    //TimeStamp Address
    if(pPvkSignInfo->fUsageTimeStamp)
    {
        lvItem.iSubItem=0;

        ListView_InsertItemU_IDS(hwndControl, &lvItem, IDS_TIEMSTAMP_ADDR, NULL);

        //content
        lvItem.iSubItem++;

        if(pPvkSignInfo->pwszTimeStamp)
        {
            ListView_SetItemTextU(hwndControl, lvItem.iItem, lvItem.iSubItem,pPvkSignInfo->pwszTimeStamp);
        }
        else
        {
            ListView_SetItemTextU(hwndControl, lvItem.iItem, lvItem.iSubItem,wszNone);
        }

        lvItem.iItem++;

    }


    //autosize the columns
    ListView_SetColumnWidth(hwndControl, 0, LVSCW_AUTOSIZE);
    ListView_SetColumnWidth(hwndControl, 1, LVSCW_AUTOSIZE);


    return;
}

//************************************************************************************
//
//The winProc for each of the signing wizard page
//
//*************************************************************************************
//-----------------------------------------------------------------------
//Welcome
//-----------------------------------------------------------------------
INT_PTR APIENTRY Sign_Welcome(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CRYPTUI_WIZ_GET_SIGN_PAGE_INFO         *pGetSignInfo=NULL;
    CERT_SIGNING_INFO                      *pPvkSignInfo=NULL;
    PROPSHEETPAGE                          *pPropSheet=NULL;


	switch (msg)
	{
		case WM_INITDIALOG:

                //set the wizard information so that it can be shared
                pPropSheet = (PROPSHEETPAGE *) lParam;
                pGetSignInfo = (CRYPTUI_WIZ_GET_SIGN_PAGE_INFO *) (pPropSheet->lParam);

                if(NULL==pGetSignInfo)
                    break;

                SetWindowLongPtr(hwndDlg, DWLP_USER, (LONG_PTR)pGetSignInfo);

                //init the pPvkSignInfo if not present
                if(NULL==(pGetSignInfo->pvSignReserved))
                {
                    if(!InitPvkSignInfo((CERT_SIGNING_INFO **)(&(pGetSignInfo->pvSignReserved))))
                        break;
                }

                pPvkSignInfo=(CERT_SIGNING_INFO *)(pGetSignInfo->pvSignReserved);

                if(NULL==pPvkSignInfo)
                    break;

                //set up the control
                SetControlFont(pPvkSignInfo->hBigBold, hwndDlg,IDC_WIZARD_STATIC_BIG_BOLD1);
                SetControlFont(pPvkSignInfo->hBold,    hwndDlg,IDC_WIZARD_STATIC_BOLD1);

			break;

        case WM_DESTROY:
                if(NULL==(pGetSignInfo=(CRYPTUI_WIZ_GET_SIGN_PAGE_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                    break;

                //try to sign the document
                SignAtDestroy(hwndDlg, pGetSignInfo, IDD_SIGN_WELCOME);

            break;

		case WM_NOTIFY:
    		    switch (((NMHDR FAR *) lParam)->code)
    		    {

  				    case PSN_KILLACTIVE:
                            SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
					        return TRUE;

                        break;

				    case PSN_RESET:
                            if(NULL==(pGetSignInfo=(CRYPTUI_WIZ_GET_SIGN_PAGE_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                                break;

                            if(NULL==(pPvkSignInfo=(CERT_SIGNING_INFO *)(pGetSignInfo->pvSignReserved)))
                                break;

                            //mark that the cancel bottun is clicked
                            pPvkSignInfo->fCancel=TRUE;

                            SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
					    break;

 				    case PSN_SETACTIVE:
 					        PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_NEXT);
					    break;

                    case PSN_WIZBACK:
                        break;

                    case PSN_WIZNEXT:

                        break;

				    default:
					    return FALSE;

    	        }
		    break;

		default:
			return FALSE;
	}

	return TRUE;
}


//-----------------------------------------------------------------------
//Sign_Option
//-----------------------------------------------------------------------
INT_PTR APIENTRY Sign_Option(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CRYPTUI_WIZ_GET_SIGN_PAGE_INFO         *pGetSignInfo=NULL;
    CERT_SIGNING_INFO                      *pPvkSignInfo=NULL;
    PROPSHEETPAGE                          *pPropSheet=NULL;

	switch (msg)
	{
		case WM_INITDIALOG:
                //set the wizard information so that it can be shared
                pPropSheet = (PROPSHEETPAGE *) lParam;
                pGetSignInfo = (CRYPTUI_WIZ_GET_SIGN_PAGE_INFO *) (pPropSheet->lParam);

                if(NULL==pGetSignInfo)
                    break;

                SetWindowLongPtr(hwndDlg, DWLP_USER, (LONG_PTR)pGetSignInfo);

                //init the pPvkSignInfo if not present
                if(NULL==(pGetSignInfo->pvSignReserved))
                {
                    if(!InitPvkSignInfo((CERT_SIGNING_INFO **)(&(pGetSignInfo->pvSignReserved))))
                        break;
                }

                pPvkSignInfo=(CERT_SIGNING_INFO *)(pGetSignInfo->pvSignReserved);

                if(NULL==pPvkSignInfo)
                    break;

                SetControlFont(pPvkSignInfo->hBold, hwndDlg,IDC_WIZARD_STATIC_BOLD1);

                //initialize the signing options to be typical
                SendMessage(GetDlgItem(hwndDlg, IDC_WIZARD_RADIO1), BM_SETCHECK, 1, 0);
                SendMessage(GetDlgItem(hwndDlg, IDC_WIZARD_RADIO2), BM_SETCHECK, 0, 0);

			break;

        case WM_DESTROY:
                if(NULL==(pGetSignInfo=(CRYPTUI_WIZ_GET_SIGN_PAGE_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                    break;

                //try to sign the document
                SignAtDestroy(hwndDlg, pGetSignInfo,IDD_SIGN_OPTION);

            break;

		case WM_COMMAND:
                if(HIWORD(wParam) == BN_CLICKED)
                {
                    switch (LOWORD(wParam))
                    {
                        case    IDC_WIZARD_RADIO1:
                                SendMessage(GetDlgItem(hwndDlg, IDC_WIZARD_RADIO1), BM_SETCHECK, 1, 0);
                                SendMessage(GetDlgItem(hwndDlg, IDC_WIZARD_RADIO2), BM_SETCHECK, 0, 0);
                            break;

                        case    IDC_WIZARD_RADIO2:
                                SendMessage(GetDlgItem(hwndDlg, IDC_WIZARD_RADIO1), BM_SETCHECK, 0, 0);
                                SendMessage(GetDlgItem(hwndDlg, IDC_WIZARD_RADIO2), BM_SETCHECK, 1, 0);
                            break;

                        default:
                            break;

                    }
                }

			break;				
						
		case WM_NOTIFY:
    		    switch (((NMHDR FAR *) lParam)->code)
    		    {

  				    case PSN_KILLACTIVE:
                            SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
					        return TRUE;

                        break;

				    case PSN_RESET:
                            if(NULL==(pGetSignInfo=(CRYPTUI_WIZ_GET_SIGN_PAGE_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                                break;

                            if(NULL==(pPvkSignInfo=(CERT_SIGNING_INFO *)(pGetSignInfo->pvSignReserved)))
                                break;

                            //mark that the cancel bottun is clicked
                            pPvkSignInfo->fCancel=TRUE;

                            SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
					    break;

 				    case PSN_SETACTIVE:
 					    PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_NEXT|PSWIZB_BACK);
					    break;

                    case PSN_WIZBACK:
                        break;

                    case PSN_WIZNEXT:

                                if(NULL==(pGetSignInfo=(CRYPTUI_WIZ_GET_SIGN_PAGE_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                                    break;

                                if(NULL==(pPvkSignInfo=(CERT_SIGNING_INFO *)(pGetSignInfo->pvSignReserved)))
                                    break;

                                //mark that the option is selected
                                pPvkSignInfo->fUseOption=TRUE;

                                if(TRUE==SendMessage(GetDlgItem(hwndDlg, IDC_WIZARD_RADIO2), BM_GETCHECK, 0, 0))
                                    pPvkSignInfo->fCustom=TRUE;
                                else
                                    pPvkSignInfo->fCustom=FALSE;

                        break;

				    default:
					    return FALSE;

    	        }
		    break;

		default:
			return FALSE;
	}

	return TRUE;
}

//-----------------------------------------------------------------------
//Sign_FileName
//-----------------------------------------------------------------------
INT_PTR APIENTRY Sign_FileName(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CRYPTUI_WIZ_GET_SIGN_PAGE_INFO         *pGetSignInfo=NULL;
    CERT_SIGNING_INFO                      *pPvkSignInfo=NULL;
    PROPSHEETPAGE                          *pPropSheet=NULL;

    DWORD                                   dwChar=0;
    DWORD                                   dwSize=0;
    CRYPTUI_WIZ_DIGITAL_SIGN_INFO           *pDigitalSignInfo=NULL;
    UINT                                    ids=0;

    OPENFILENAMEW                           OpenFileName;
    WCHAR                                   szFileName[_MAX_PATH];
    WCHAR                                   szFilter[MAX_STRING_SIZE];  //"Executable File(*.exe)\0*.exe\0Dynamic Link Library (*.dll)\0*.dll\0All Files\0*.*\0"

	switch (msg)
	{
		case WM_INITDIALOG:
                //set the wizard information so that it can be shared
                pPropSheet = (PROPSHEETPAGE *) lParam;
                pGetSignInfo = (CRYPTUI_WIZ_GET_SIGN_PAGE_INFO *) (pPropSheet->lParam);

                if(NULL==pGetSignInfo)
                    break;

                SetWindowLongPtr(hwndDlg, DWLP_USER, (LONG_PTR)pGetSignInfo);

                //init the pPvkSignInfo if not present
                if(NULL==(pGetSignInfo->pvSignReserved))
                {
                    if(!InitPvkSignInfo((CERT_SIGNING_INFO **)(&(pGetSignInfo->pvSignReserved))))
                        break;
                }

                pPvkSignInfo=(CERT_SIGNING_INFO *)(pGetSignInfo->pvSignReserved);

                if(NULL==pPvkSignInfo)
                    break;

                SetControlFont(pPvkSignInfo->hBold, hwndDlg,IDC_WIZARD_STATIC_BOLD1);

                //initialize the file name to be signed
                pDigitalSignInfo=(CRYPTUI_WIZ_DIGITAL_SIGN_INFO *)(pGetSignInfo->pDigitalSignInfo);

                if(pDigitalSignInfo)
                {
                    if(CRYPTUI_WIZ_DIGITAL_SIGN_SUBJECT_FILE == pDigitalSignInfo->dwSubjectChoice)
                        SetDlgItemTextU(hwndDlg, IDC_WIZARD_EDIT1,pDigitalSignInfo->pwszFileName);
                }

			break;

        case WM_DESTROY:
                if(NULL==(pGetSignInfo=(CRYPTUI_WIZ_GET_SIGN_PAGE_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                    break;

                //try to sign the document
                SignAtDestroy(hwndDlg, pGetSignInfo,IDD_SIGN_FILE_NAME);

            break;

		case WM_COMMAND:
                if(HIWORD(wParam) == BN_CLICKED)
                {
                    switch (LOWORD(wParam))
                    {
                        //select a file to sign
                        case    IDC_WIZARD_BUTTON1:
                                if(NULL==(pGetSignInfo=(CRYPTUI_WIZ_GET_SIGN_PAGE_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                                    break;

                                if(NULL==(pPvkSignInfo=(CERT_SIGNING_INFO *)(pGetSignInfo->pvSignReserved)))
                                    break;

                                memset(&OpenFileName, 0, sizeof(OpenFileName));

                                *szFileName=L'\0';

                                OpenFileName.lStructSize = sizeof(OpenFileName);
                                OpenFileName.hwndOwner = hwndDlg;
                                OpenFileName.hInstance = NULL;
                                //load the fileter string
                                if(LoadFilterString(g_hmodThisDll, IDS_SIGN_FILE_FILTER, szFilter, MAX_STRING_SIZE))
                                {
                                    OpenFileName.lpstrFilter = szFilter;
                                }
                                OpenFileName.lpstrCustomFilter = NULL;
                                OpenFileName.nMaxCustFilter = 0;
                                OpenFileName.nFilterIndex = 1;
                                OpenFileName.lpstrFile = szFileName;
                                OpenFileName.nMaxFile = _MAX_PATH;
                                OpenFileName.lpstrFileTitle = NULL;
                                OpenFileName.nMaxFileTitle = 0;
                                OpenFileName.lpstrInitialDir = NULL;
                                OpenFileName.lpstrTitle = NULL;
                                OpenFileName.Flags = OFN_HIDEREADONLY | OFN_FILEMUSTEXIST;
                                OpenFileName.nFileOffset = 0;
                                OpenFileName.nFileExtension = 0;
                                OpenFileName.lpstrDefExt = NULL;
                                OpenFileName.lCustData = NULL;
                                OpenFileName.lpfnHook = NULL;
                                OpenFileName.lpTemplateName = NULL;

                                if (WizGetOpenFileName(&OpenFileName))
                                {
                                    //set the edit box
                                    SetDlgItemTextU(hwndDlg, IDC_WIZARD_EDIT1, szFileName);
                                }

                            break;

                        default:
                            break;
                    }
                }

			break;				
						
		case WM_NOTIFY:
    		    switch (((NMHDR FAR *) lParam)->code)
    		    {

  				    case PSN_KILLACTIVE:
                            SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
					        return TRUE;

                        break;

				    case PSN_RESET:
                            if(NULL==(pGetSignInfo=(CRYPTUI_WIZ_GET_SIGN_PAGE_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                                break;

                            if(NULL==(pPvkSignInfo=(CERT_SIGNING_INFO *)(pGetSignInfo->pvSignReserved)))
                                break;

                            //mark that the cancel bottun is clicked
                            pPvkSignInfo->fCancel=TRUE;

                            SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
					    break;

 				    case PSN_SETACTIVE:
 					    PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_NEXT|PSWIZB_BACK);
					    break;

                    case PSN_WIZBACK:
                        break;

                    case PSN_WIZNEXT:

                                if(NULL==(pGetSignInfo=(CRYPTUI_WIZ_GET_SIGN_PAGE_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                                    break;

                                if(NULL==(pPvkSignInfo=(CERT_SIGNING_INFO *)(pGetSignInfo->pvSignReserved)))
                                    break;

                                //free the original filename
                                if(pPvkSignInfo->pwszFileName)
                                {
                                    WizardFree(pPvkSignInfo->pwszFileName);
                                    pPvkSignInfo->pwszFileName=NULL;
                                }

                                //get the file name
                                if(0!=(dwChar=(DWORD)SendDlgItemMessage(hwndDlg,
                                                      IDC_WIZARD_EDIT1,
                                                      WM_GETTEXTLENGTH, 0, 0)))
                                {
                                    pPvkSignInfo->pwszFileName=(LPWSTR)WizardAlloc(sizeof(WCHAR)*(dwChar+1));

                                    if(NULL!=(pPvkSignInfo->pwszFileName))
                                    {
                                        GetDlgItemTextU(hwndDlg, IDC_WIZARD_EDIT1,
                                                        pPvkSignInfo->pwszFileName,
                                                        dwChar+1);

                                    }


                                    //make sure the file exist
                                    ids=IDS_SIGN_FILE_NAME_NOT_EXIST;

                                    if(!FileExist(pPvkSignInfo->pwszFileName,&ids))
                                    {
                                        I_MessageBox(hwndDlg, ids,
                                                        pPvkSignInfo->idsMsgTitle,
                                                        pGetSignInfo->pwszPageTitle,
                                                        MB_ICONERROR|MB_OK|MB_APPLMODAL);

                                        //make the page stay
                                        SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);

                                        break;
                                    }

                                }
                                else
                                {
                                    //ask for the file name
                                    I_MessageBox(hwndDlg, IDS_NO_FILE_NAME_TO_SIGN,
                                                    pPvkSignInfo->idsMsgTitle,
                                                    pGetSignInfo->pwszPageTitle,
                                                    MB_ICONERROR|MB_OK|MB_APPLMODAL);

                                    //make the purpose page stay
                                    SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);

                                    break;
                                }

                        break;

				    default:
					    return FALSE;

    	        }
		    break;

		default:
			return FALSE;
	}

	return TRUE;
}
//-----------------------------------------------------------------------
//Sign_Cert
//
//This is the page that specify the signing certificate.  It is used by
//both the typical (minimal) and custom signing pages
//-----------------------------------------------------------------------
INT_PTR APIENTRY Sign_Cert(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CRYPTUI_WIZ_GET_SIGN_PAGE_INFO          *pGetSignInfo=NULL;
    CERT_SIGNING_INFO                       *pPvkSignInfo=NULL;
    PROPSHEETPAGE                           *pPropSheet=NULL;
    CRYPTUI_WIZ_DIGITAL_SIGN_INFO           *pDigitalSignInfo=NULL;
    CRYPTUI_WIZ_DIGITAL_SIGN_CERT_PVK_INFO  *pCertPvkInfo=NULL;
    DWORD                                   dwSize=0;

    HCERTSTORE                          hFileCertStore=NULL;
    PCCERT_CONTEXT                      pFileCertContext=NULL;
    HWND                                hwndControl=NULL;
    CRYPTUI_VIEWCERTIFICATE_STRUCT      CertViewStruct;
    PCCERT_CONTEXT                      pCertContext=NULL;
    
    OPENFILENAMEW                       OpenFileName;
    WCHAR                               szFileName[_MAX_PATH];
    WCHAR                               szFilter[MAX_STRING_SIZE];  //"Executable File(*.exe)\0*.exe\0Dynamic Link Library (*.dll)\0*.dll\0All Files\0*.*\0"
    WCHAR                               wszPrompt[MAX_STRING_SIZE];
    BOOL                                fPrompt=FALSE;
    UINT                                idsPrompt=IDS_SIGN_PROMPT_TYPICAL;

    LV_COLUMNW                          lvC;


	switch (msg)
	{
		case WM_INITDIALOG:

                //set the wizard information so that it can be shared
                pPropSheet = (PROPSHEETPAGE *) lParam;
                pGetSignInfo = (CRYPTUI_WIZ_GET_SIGN_PAGE_INFO *) (pPropSheet->lParam);

                if(NULL==pGetSignInfo)
                    break;

                SetWindowLongPtr(hwndDlg, DWLP_USER, (LONG_PTR)pGetSignInfo);

                //init the pPvkSignInfo if not present
                if(NULL==(pGetSignInfo->pvSignReserved))
                {
                    if(!InitPvkSignInfo((CERT_SIGNING_INFO **)(&(pGetSignInfo->pvSignReserved))))
                        break;
                }

                pPvkSignInfo=(CERT_SIGNING_INFO *)(pGetSignInfo->pvSignReserved);

                if(NULL==pPvkSignInfo)
                    break;

                //set up the special font
                SetControlFont(pPvkSignInfo->hBold, hwndDlg,IDC_WIZARD_STATIC_BOLD1);

                //get the window handle of the cert list view
                if(NULL==(hwndControl=GetDlgItem(hwndDlg, IDC_CERT_LIST)))
                    break;

                // set the style in the list view so that it highlights an entire line
                SendMessageA(hwndControl, LVM_SETEXTENDEDLISTVIEWSTYLE, 0, LVS_EX_FULLROWSELECT);

                //insert two columns in the listView
                memset(&lvC, 0, sizeof(LV_COLUMNW));

                lvC.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
                lvC.fmt = LVCFMT_LEFT;  // Left-align the column.
                lvC.cx = 40;            // Width of the column, in pixels.
                lvC.iSubItem=0;
                lvC.pszText = L"";      // The text for the column.

                //inser the column one at a time
                if (ListView_InsertColumnU(hwndControl, 0, &lvC) == -1)
                    break;

                //2nd column
                memset(&lvC, 0, sizeof(LV_COLUMNW));

                lvC.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
                lvC.fmt = LVCFMT_LEFT;      // Left-align the column.
                lvC.cx = 40;                // Width of the column, in pixels.
                lvC.pszText = L"";          // The text for the column.
                lvC.iSubItem= 1;

                if (ListView_InsertColumnU(hwndControl, 1, &lvC) == -1)
                    break;

                //delete all the items in the listView
                ListView_DeleteAllItems(hwndControl);

                //set up the prompt text if supplied
                if(pGetSignInfo->pDigitalSignInfo)
                {
                    if(pGetSignInfo->pDigitalSignInfo->pSignExtInfo)
                    {
                       if(pGetSignInfo->pDigitalSignInfo->pSignExtInfo->pwszSigningCertDisplayString)
                           SetControlText((LPWSTR)(pGetSignInfo->pDigitalSignInfo->pSignExtInfo->pwszSigningCertDisplayString),
                                          hwndDlg,
                                          IDC_PROMPT_STATIC);
                    }
                }

                //diable the View ceritifcate button
                EnableWindow(GetDlgItem(hwndDlg, IDC_SIGN_VIEW_BUTTON), FALSE);

                //init the signing certificate
                pDigitalSignInfo=(CRYPTUI_WIZ_DIGITAL_SIGN_INFO *)(pGetSignInfo->pDigitalSignInfo);

                if(pDigitalSignInfo)
                {
                    if(CRYPTUI_WIZ_DIGITAL_SIGN_CERT==pDigitalSignInfo->dwSigningCertChoice)
                    {
                        pPvkSignInfo->pSignCert=CertDuplicateCertificateContext(pDigitalSignInfo->pSigningCertContext);

                        //add the certificate to the listView and enable the ViewButton
                        if(AddCertToListView(hwndControl, pPvkSignInfo->pSignCert))
                            EnableWindow(GetDlgItem(hwndDlg, IDC_SIGN_VIEW_BUTTON), TRUE);

                        pPvkSignInfo->fSignCert=TRUE;
                    }

                    if(CRYPTUI_WIZ_DIGITAL_SIGN_PVK == pDigitalSignInfo->dwSigningCertChoice)
                    {

                       pCertPvkInfo=(CRYPTUI_WIZ_DIGITAL_SIGN_CERT_PVK_INFO *)pDigitalSignInfo->pSigningCertPvkInfo;

                       if(pCertPvkInfo->pwszSigningCertFileName)
                       {
                           //the file has to be eitehr a .cer(.crt) or a SPC file
                           if(ExpandAndCryptQueryObject(
                                    CERT_QUERY_OBJECT_FILE,
                                    pCertPvkInfo->pwszSigningCertFileName,
                                    CERT_QUERY_CONTENT_FLAG_CERT | CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED,
                                    CERT_QUERY_FORMAT_FLAG_BINARY,
                                    0,
                                    NULL,
                                    NULL,
                                    NULL,
                                    &hFileCertStore,
                                    NULL,
                                    (const void **)&pFileCertContext))
                           {
                                //check if it is a Cert context
                               if(pFileCertContext)
                               {
                                    pPvkSignInfo->pSignCert=CertDuplicateCertificateContext(pFileCertContext);

                                    //add the certificate to the listView and enable the ViewButton
                                    if(AddCertToListView(hwndControl, pPvkSignInfo->pSignCert))
                                        EnableWindow(GetDlgItem(hwndDlg, IDC_SIGN_VIEW_BUTTON), TRUE);

                                    pPvkSignInfo->fSignCert=TRUE;
                               }
                               else
                               {
                                   if(hFileCertStore)
                                   {
                                        //this is a SPC file.  Copy the file name to the list
                                        pPvkSignInfo->pwszSPCFileName=(LPWSTR)WizardAllocAndCopyWStr(pCertPvkInfo->pwszSigningCertFileName);

                                        AddFileNameToListView(hwndControl,
                                                                pPvkSignInfo->pwszSPCFileName);

                                        pPvkSignInfo->fSignCert=FALSE;
                                   }
                               }
                           }

                           //free the certificate context and store handle
                           if(pFileCertContext)
                           {
                               CertFreeCertificateContext(pFileCertContext);
                               pFileCertContext=NULL;
                           }

                           if(hFileCertStore)
                           {
                                CertCloseStore(hFileCertStore, 0);
                                hFileCertStore=NULL;
                           }
                       }
                    }
                }

            break;

        case WM_DESTROY:
                if(NULL==(pGetSignInfo=(CRYPTUI_WIZ_GET_SIGN_PAGE_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                    break;

                //try to sign the document
                SignAtDestroy(hwndDlg, pGetSignInfo,IDD_SIGN_CERT);

            break;

		case WM_COMMAND:
                if(HIWORD(wParam) == BN_CLICKED)
                {
                    switch (LOWORD(wParam))
                    {
                        //select a certificate from a store
                        case    IDC_SIGN_STORE_BUTTON:
                                if(NULL==(pGetSignInfo=(CRYPTUI_WIZ_GET_SIGN_PAGE_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                                    break;

                                if(NULL==(pPvkSignInfo=(CERT_SIGNING_INFO *)(pGetSignInfo->pvSignReserved)))
                                    break;

                                //get the window handle of the cert list view
                                if(NULL==(hwndControl=GetDlgItem(hwndDlg, IDC_CERT_LIST)))
                                    break;

                                //get the certificate from the stores
                                if(pCertContext=SelectCertFromStore(hwndDlg,pGetSignInfo))
                                {
                                    if(AddCertToListView(hwndControl, pCertContext))
                                    {
                                        if(pPvkSignInfo->pSignCert)
                                        {
                                            CertFreeCertificateContext(pPvkSignInfo->pSignCert);
                                            pPvkSignInfo->pSignCert=NULL;
                                        }

                                        pPvkSignInfo->pSignCert=pCertContext;

                                        EnableWindow(GetDlgItem(hwndDlg, IDC_SIGN_VIEW_BUTTON), TRUE);

                                        //mark that user has selected a certificate
                                        pPvkSignInfo->fSignCert=TRUE;

                                    }
                                    else
                                    {
                                        CertFreeCertificateContext(pCertContext);
                                        pCertContext=NULL;
                                    }
                                }

                            break;

                        //select a signing file name
                        case    IDC_SIGN_FILE_BUTTON:

                                if(NULL==(pGetSignInfo=(CRYPTUI_WIZ_GET_SIGN_PAGE_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                                    break;

                                if(NULL==(pPvkSignInfo=(CERT_SIGNING_INFO *)(pGetSignInfo->pvSignReserved)))
                                    break;

                                //get the window handle of the cert list view
                                if(NULL==(hwndControl=GetDlgItem(hwndDlg, IDC_CERT_LIST)))
                                    break;

                                memset(&OpenFileName, 0, sizeof(OpenFileName));

                                *szFileName=L'\0';

                                OpenFileName.lStructSize = sizeof(OpenFileName);
                                OpenFileName.hwndOwner = hwndDlg;
                                OpenFileName.hInstance = NULL;

                                //load the fileter string
                                if(LoadFilterString(g_hmodThisDll, IDS_CERT_SPC_FILE_FILTER, szFilter, MAX_STRING_SIZE))
                                {
                                    OpenFileName.lpstrFilter = szFilter;
                                }
                                OpenFileName.lpstrCustomFilter = NULL;
                                OpenFileName.nMaxCustFilter = 0;
                                OpenFileName.nFilterIndex = 1;
                                OpenFileName.lpstrFile = szFileName;
                                OpenFileName.nMaxFile = _MAX_PATH;
                                OpenFileName.lpstrFileTitle = NULL;
                                OpenFileName.nMaxFileTitle = 0;
                                OpenFileName.lpstrInitialDir = NULL;
                                OpenFileName.lpstrTitle = NULL;
                                OpenFileName.Flags = OFN_HIDEREADONLY | OFN_FILEMUSTEXIST;
                                OpenFileName.nFileOffset = 0;
                                OpenFileName.nFileExtension = 0;
                                OpenFileName.lpstrDefExt = NULL;
                                OpenFileName.lCustData = NULL;
                                OpenFileName.lpfnHook = NULL;
                                OpenFileName.lpTemplateName = NULL;

                                if (WizGetOpenFileName(&OpenFileName))
                                {
                                    //make sure the file name is a valid one
                                   //the file has to be eitehr a .cer(.crt) or a SPC file
                                   if(ExpandAndCryptQueryObject(
                                            CERT_QUERY_OBJECT_FILE,
                                            szFileName,
                                            CERT_QUERY_CONTENT_FLAG_CERT | CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED,
                                            CERT_QUERY_FORMAT_FLAG_ALL,
                                            0,
                                            NULL,
                                            NULL,
                                            NULL,
                                            &hFileCertStore,
                                            NULL,
                                            (const void **)&pFileCertContext))
                                   {
                                        //check if it is a Cert context
                                       if(pFileCertContext)
                                       {
                                            if(pPvkSignInfo->pSignCert)
                                            {
                                                CertFreeCertificateContext(pPvkSignInfo->pSignCert);
                                                pPvkSignInfo->pSignCert=NULL;
                                            }

                                            pPvkSignInfo->pSignCert=CertDuplicateCertificateContext(pFileCertContext);

                                            //add the certificate to the listView and enable the ViewButton
                                            if(AddCertToListView(hwndControl, pPvkSignInfo->pSignCert))
                                                EnableWindow(GetDlgItem(hwndDlg, IDC_SIGN_VIEW_BUTTON), TRUE);

                                            pPvkSignInfo->fSignCert=TRUE;

                                       }
                                       else
                                       {
                                           if(hFileCertStore)
                                           {
                                                //this is a SPC file.  Copy the file name to the list
                                                if(pPvkSignInfo->pwszSPCFileName)
                                                {
                                                    WizardFree(pPvkSignInfo->pwszSPCFileName);
                                                    pPvkSignInfo->pwszSPCFileName=NULL;
                                                }

                                                pPvkSignInfo->pwszSPCFileName=WizardAllocAndCopyWStr(szFileName);

                                                //get the window handle of the cert list view
                                                if(NULL==(hwndControl=GetDlgItem(hwndDlg, IDC_CERT_LIST)))
                                                    break;

                                                if(AddFileNameToListView(hwndControl,
                                                                      pPvkSignInfo->pwszSPCFileName))
                                                    EnableWindow(GetDlgItem(hwndDlg, IDC_SIGN_VIEW_BUTTON), FALSE);

                                                pPvkSignInfo->fSignCert=FALSE;
                                           }
                                       }
                                   }
                                   else
                                   {
                                        //warn the user that this is not a valid file
                                          I_MessageBox(hwndDlg, IDS_INVALID_CERT_SPC_FILE,
                                                            pPvkSignInfo->idsMsgTitle,
                                                            pGetSignInfo->pwszPageTitle,
                                                            MB_ICONERROR|MB_OK|MB_APPLMODAL);

                                        //the page should stay
                                        SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);

                                        break;
                                   }

                                   //free the certificate context and store handle
                                   if(pFileCertContext)
                                   {
                                       CertFreeCertificateContext(pFileCertContext);
                                       pFileCertContext=NULL;
                                   }

                                   if(hFileCertStore)
                                   {
                                        CertCloseStore(hFileCertStore, 0);
                                        hFileCertStore=NULL;
                                   }                                                                       
                                }

                            break;
                            //view a certificate
                        case    IDC_SIGN_VIEW_BUTTON:
                                if(NULL==(pGetSignInfo=(CRYPTUI_WIZ_GET_SIGN_PAGE_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                                    break;

                                if(NULL==(pPvkSignInfo=(CERT_SIGNING_INFO *)(pGetSignInfo->pvSignReserved)))
                                    break;

                                if (pPvkSignInfo->pSignCert)
                                {
                                    //view certiificate
                                    memset(&CertViewStruct, 0, sizeof(CRYPTUI_VIEWCERTIFICATE_STRUCT));
                                    CertViewStruct.dwSize=sizeof(CRYPTUI_VIEWCERTIFICATE_STRUCT);
                                    CertViewStruct.pCertContext=pPvkSignInfo->pSignCert;
                                    CertViewStruct.hwndParent=hwndDlg;
                                    CertViewStruct.dwFlags=CRYPTUI_DISABLE_EDITPROPERTIES;

                                    CryptUIDlgViewCertificate(&CertViewStruct, NULL);
                                }
                                else
                                    //output the message
                                    I_MessageBox(hwndDlg, IDS_SELECT_SIGNING_CERT,
                                                        pPvkSignInfo->idsMsgTitle,
                                                        pGetSignInfo->pwszPageTitle,
                                                        MB_ICONERROR|MB_OK|MB_APPLMODAL);

                            break;
                        default:
                            break;
                    }
                }

			break;	
						
		case WM_NOTIFY:
    		    switch (((NMHDR FAR *) lParam)->code)
    		    {

  				    case PSN_KILLACTIVE:
                            SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
					        return TRUE;

                        break;

				    case PSN_RESET:
                            if(NULL==(pGetSignInfo=(CRYPTUI_WIZ_GET_SIGN_PAGE_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                                break;

                            if(NULL==(pPvkSignInfo=(CERT_SIGNING_INFO *)(pGetSignInfo->pvSignReserved)))
                                break;

                            //mark that the cancel bottun is clicked
                            pPvkSignInfo->fCancel=TRUE;

                            SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
					    break;

 				    case PSN_SETACTIVE:
 					        PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_NEXT|PSWIZB_BACK);

                            if(NULL==(pGetSignInfo=(CRYPTUI_WIZ_GET_SIGN_PAGE_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                                    break;

                            if(NULL==(pPvkSignInfo=(CERT_SIGNING_INFO *)(pGetSignInfo->pvSignReserved)))
                                break;

                            //disable botton for selection from a file
                            //this option is only for custom signing only
                            if((pGetSignInfo->dwPageChoice & CRYPTUI_WIZ_DIGITAL_SIGN_TYPICAL_SIGNING_OPTION_PAGES) ||
                               (pGetSignInfo->dwPageChoice & CRYPTUI_WIZ_DIGITAL_SIGN_MINIMAL_SIGNING_OPTION_PAGES) ||
                               (TRUE == pPvkSignInfo->fUseOption  && FALSE ==pPvkSignInfo->fCustom  )
                              )
                            {
                                EnableWindow(GetDlgItem(hwndDlg, IDC_SIGN_FILE_BUTTON), FALSE);

                                //NULL the note about the SPC file
                                SetControlText(L" ",
                                               hwndDlg,
                                               IDC_NOTE_STATIC);

                                idsPrompt=IDS_SIGN_PROMPT_TYPICAL;
                            }
                            else
                            {
                                EnableWindow(GetDlgItem(hwndDlg, IDC_SIGN_FILE_BUTTON), TRUE);

                                if(LoadStringU(g_hmodThisDll, IDS_SIGN_SPC_PROMPT, wszPrompt, sizeof(wszPrompt)/sizeof(wszPrompt[0])))
                                {
                                    //NULL the note about the SPC file
                                    SetControlText(wszPrompt,
                                                   hwndDlg,
                                                   IDC_NOTE_STATIC);
                                }

                                idsPrompt=IDS_SIGN_PROMPT_CUSTOM;
                            }

                            //change the prompt static note
                            fPrompt=FALSE;

                            if(pGetSignInfo->pDigitalSignInfo)
                            {
                                if(pGetSignInfo->pDigitalSignInfo->pSignExtInfo)
                                {
                                   if(pGetSignInfo->pDigitalSignInfo->pSignExtInfo->pwszSigningCertDisplayString)
                                       fPrompt=TRUE;
                                }
                            }

                            if(FALSE == fPrompt)
                            {
                                if(LoadStringU(g_hmodThisDll, idsPrompt, wszPrompt, sizeof(wszPrompt)/sizeof(wszPrompt[0])))
                                {
                                    //prompt for certificate file only
                                    SetControlText(wszPrompt,
                                                   hwndDlg,
                                                   IDC_PROMPT_STATIC);
                                }
                            }

					    break;

                    case PSN_WIZBACK:

                        break;

                    case PSN_WIZNEXT:

                            if(NULL==(pGetSignInfo=(CRYPTUI_WIZ_GET_SIGN_PAGE_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                                break;

                            if(NULL==(pPvkSignInfo=(CERT_SIGNING_INFO *)(pGetSignInfo->pvSignReserved)))
                                break;

                            //mark the user has visited in page
                            pPvkSignInfo->fUseSignCert=TRUE;

                            //user has to either specify a signing cert or
                            //a SPC file
                            if( ((TRUE==pPvkSignInfo->fSignCert) && (NULL==pPvkSignInfo->pSignCert )) ||
                                ((FALSE==pPvkSignInfo->fSignCert) && (NULL==pPvkSignInfo->pwszSPCFileName))
                              )
                            {
                                I_MessageBox(hwndDlg, IDS_SELECT_SIGNING_CERT,
                                                    pPvkSignInfo->idsMsgTitle,
                                                    pGetSignInfo->pwszPageTitle,
                                                    MB_ICONERROR|MB_OK|MB_APPLMODAL);

                                //the page should stay
                                SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);

                                break;
                            }

                            //remember to refresh the private key based on the siging cert's selection
                            if(pPvkSignInfo->fSignCert)
                                pPvkSignInfo->fRefreshPvkOnCert=TRUE;

                            //we want to make sure that we check for the private key
                            //if the custom page is not going to be shown up
                            if((CRYPTUI_WIZ_DIGITAL_SIGN_TYPICAL_SIGNING_OPTION_PAGES & (pGetSignInfo->dwPageChoice)) ||
                               (CRYPTUI_WIZ_DIGITAL_SIGN_MINIMAL_SIGNING_OPTION_PAGES & (pGetSignInfo->dwPageChoice)) ||
                               ( (TRUE == pPvkSignInfo->fUseOption) && (FALSE == pPvkSignInfo->fCustom))
                              )
                            {
                                //make sure the certificate selected has a private key
                                if(!CertPvkMatch(pPvkSignInfo, TRUE))
                                {
                                    //ask for the CSP name
                                    I_MessageBox(hwndDlg, IDS_CERT_PVK,
                                                            pPvkSignInfo->idsMsgTitle,
                                                            pGetSignInfo->pwszPageTitle,
                                                            MB_ICONERROR|MB_OK|MB_APPLMODAL);
                                     //make the file page stay
                                     SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);

                                     break;

                                }
                            }

                            //if use has chosen the typical signing, we need to skip pages
                            if(TRUE == pPvkSignInfo->fUseOption)
                            {
                                if(FALSE == pPvkSignInfo->fCustom)
                                {
                                    //jump to the description page
                                    SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_SIGN_DESCRIPTION);
                                }
                            }

                        break;

#if (1) //DSIE: Bug 484852.
                    case LVN_INSERTITEM:
                        NM_LISTVIEW FAR * pnmv;

                        pnmv = (LPNMLISTVIEW) lParam;

                        if (pnmv->iItem == 0)
                        {
                            ListView_SetItemState(pnmv->hdr.hwndFrom, 
                                0, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
                        }

                        break;
#endif

				    default:
					    return FALSE;

    	        }
		    break;

		default:
			return FALSE;
	}

	return TRUE;
}



//-----------------------------------------------------------------------
// Sign_PVK
//-----------------------------------------------------------------------
INT_PTR APIENTRY Sign_PVK(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CRYPTUI_WIZ_GET_SIGN_PAGE_INFO         *pGetSignInfo=NULL;
    CERT_SIGNING_INFO                      *pPvkSignInfo=NULL;
    PROPSHEETPAGE                          *pPropSheet=NULL;
    CRYPTUI_WIZ_DIGITAL_SIGN_INFO          *pDigitalSignInfo=NULL;

    HWND                                    hwndControl=NULL;
    CRYPTUI_WIZ_DIGITAL_SIGN_CERT_PVK_INFO  *pKeyInfo=NULL;
    DWORD                                   dwChar=0;
    int                                     iIndex=0;
    DWORD                                   dwIndex=0;

	switch (msg)
	{
		case WM_INITDIALOG:
                //set the wizard information so that it can be shared
                pPropSheet = (PROPSHEETPAGE *) lParam;
                pGetSignInfo = (CRYPTUI_WIZ_GET_SIGN_PAGE_INFO *) (pPropSheet->lParam);

                if(NULL==pGetSignInfo)
                    break;

                SetWindowLongPtr(hwndDlg, DWLP_USER, (LONG_PTR)pGetSignInfo);

                //init the pPvkSignInfo if not present
                if(NULL==(pGetSignInfo->pvSignReserved))
                {
                    if(!InitPvkSignInfo((CERT_SIGNING_INFO **)(&(pGetSignInfo->pvSignReserved))))
                        break;
                }

                pPvkSignInfo=(CERT_SIGNING_INFO *)(pGetSignInfo->pvSignReserved);

                if(NULL==pPvkSignInfo)
                    break;

                SetControlFont(pPvkSignInfo->hBold, hwndDlg,IDC_WIZARD_STATIC_BOLD1);

                //enum combo boxes for the CSP and CSP type
                InitCSP(hwndDlg, pPvkSignInfo);

                //set the selection of the combo box for the key container
                RefreshContainer(hwndDlg, IDC_PVK_CONTAINER_NAME_COMBO,
                    IDC_PVK_CONTAINER_CSP_COMBO, pPvkSignInfo);

                //set the selection of the key type for the key container case
                RefreshKeyType(hwndDlg,
                        IDC_PVK_CONTAINER_KEY_TYPE_COMBO,
                        IDC_PVK_CONTAINER_NAME_COMBO,
                        IDC_PVK_CONTAINER_CSP_COMBO,
                        pPvkSignInfo);

                //init the default behavior: use the private key from the file
                SetSelectPvkFile(hwndDlg);

                //we init the private key based on user's selection
                //init the radio and combo boxes based on user's selection
                if(pPvkSignInfo->fRefreshPvkOnCert && pPvkSignInfo->fSignCert && pPvkSignInfo->pSignCert)
                {
                    InitPvkWithCertificate(hwndDlg, pPvkSignInfo->pSignCert, pPvkSignInfo);
                    pPvkSignInfo->fRefreshPvkOnCert=FALSE;
                }
                else
                {
                    if((FALSE == pPvkSignInfo->fSignCert) && pPvkSignInfo->pwszSPCFileName)
                    {
                        //init the signing certificate
                        pDigitalSignInfo=(CRYPTUI_WIZ_DIGITAL_SIGN_INFO *)(pGetSignInfo->pDigitalSignInfo);

                        if(pDigitalSignInfo)
                        {

                            if(CRYPTUI_WIZ_DIGITAL_SIGN_PVK == pDigitalSignInfo->dwSigningCertChoice)
                            {
                                pKeyInfo=(CRYPTUI_WIZ_DIGITAL_SIGN_CERT_PVK_INFO *)(pDigitalSignInfo->pSigningCertPvkInfo);

                                if(pKeyInfo)
                                {
                                    if(0 == _wcsicmp(pKeyInfo->pwszSigningCertFileName,
                                                pPvkSignInfo->pwszSPCFileName))
                                    {
                                        switch(pKeyInfo->dwPvkChoice)
                                        {
                                            case CRYPTUI_WIZ_DIGITAL_SIGN_PVK_FILE:
                                                   InitPvkWithPvkInfo(hwndDlg, (CRYPTUI_WIZ_DIGITAL_SIGN_PVK_FILE_INFO   *)(pKeyInfo->pPvkFileInfo), pPvkSignInfo);
                                                break;
                                            case CRYPTUI_WIZ_DIGITAL_SIGN_PVK_PROV:
                                                   InitPvkWithProvInfo(hwndDlg, pKeyInfo->pPvkProvInfo, pPvkSignInfo);
                                                break;

                                            default:
                                                break;
                                        }

                                    }

                                }

                            }
                        }
                    }
                }
			break;


        case WM_DESTROY:
                if(NULL==(pGetSignInfo=(CRYPTUI_WIZ_GET_SIGN_PAGE_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                    break;

                //try to sign the document
                SignAtDestroy(hwndDlg, pGetSignInfo,IDD_SIGN_PVK);

            break;

		case WM_COMMAND:

                if(NULL==(pGetSignInfo=(CRYPTUI_WIZ_GET_SIGN_PAGE_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                    break;

                if(NULL==(pPvkSignInfo=(CERT_SIGNING_INFO *)(pGetSignInfo->pvSignReserved)))
                    break;


                if(HIWORD(wParam) == BN_CLICKED)
                {
                    switch (LOWORD(wParam))
                    {
                        case    IDC_PVK_FILE_RADIO:
                                SetSelectPvkFile(hwndDlg);
                            break;

                        case    IDC_PVK_CONTAINER_RADIO:
                                SetSelectKeyContainer(hwndDlg);
                            break;

                        case    IDC_PVK_FILE_BUTTON:
                                //get the private key file name
                                SelectPvkFileName(hwndDlg, IDC_PVK_FILE_EDIT);
                        default:
                            break;

                    }
                }

                //if the key spec combo box is clicked
              /*  if(HIWORD(wParam) == CBN_DROPDOWN)
                {
                    switch(LOWORD(wParam))
                    {
                        case    IDC_PVK_CONTAINER_KEY_TYPE_COMBO:

                               //refresh the combo box if it is empty
                               if(IsEmptyKeyType(hwndDlg,IDC_PVK_CONTAINER_KEY_TYPE_COMBO))
                               {
                                   RefreshKeyType(hwndDlg,
                                            IDC_PVK_CONTAINER_KEY_TYPE_COMBO,
                                            IDC_PVK_CONTAINER_NAME_COMBO,
                                            IDC_PVK_CONTAINER_CSP_COMBO,
                                            pPvkSignInfo);
                               }

                            break;
                        default:
                            break;

                    }
                }  */

                //if the key container or CSP selection has been changed
                if(HIWORD(wParam) == CBN_SELCHANGE)
                {
                    switch(LOWORD(wParam))
                    {
                        case    IDC_PVK_CONTAINER_NAME_COMBO:

                               //refresh the combo box if it is not empty
                          //     if(!IsEmptyKeyType(hwndDlg,IDC_PVK_CONTAINER_KEY_TYPE_COMBO))
                           //    {
                                   RefreshKeyType(hwndDlg,
                                            IDC_PVK_CONTAINER_KEY_TYPE_COMBO,
                                            IDC_PVK_CONTAINER_NAME_COMBO,
                                            IDC_PVK_CONTAINER_CSP_COMBO,
                                            pPvkSignInfo);
                            //   }

                            break;
                        case    IDC_PVK_CONTAINER_CSP_COMBO:

                                //refresh the CSP type based on the CSP name
                                RefreshCSPType(hwndDlg,  IDC_PVK_CONTAINER_TYPE_COMBO,
                                    IDC_PVK_CONTAINER_CSP_COMBO, pPvkSignInfo);

                                //refresh the key container
                                RefreshContainer(hwndDlg,
                                                 IDC_PVK_CONTAINER_NAME_COMBO,
                                                 IDC_PVK_CONTAINER_CSP_COMBO,
                                                 pPvkSignInfo);

                               //refresh the key type if it is not empty
                             //  if(!IsEmptyKeyType(hwndDlg,IDC_PVK_CONTAINER_KEY_TYPE_COMBO))
                             //  {
                                   RefreshKeyType(hwndDlg,
                                            IDC_PVK_CONTAINER_KEY_TYPE_COMBO,
                                            IDC_PVK_CONTAINER_NAME_COMBO,
                                            IDC_PVK_CONTAINER_CSP_COMBO,
                                            pPvkSignInfo);
                              // }

                            break;
                        case    IDC_PVK_FILE_CSP_COMBO:

                                //refresh the CSP type based on the CSP name
                                RefreshCSPType(hwndDlg,  IDC_PVK_FILE_TYPE_COMBO,
                                    IDC_PVK_FILE_CSP_COMBO, pPvkSignInfo);
                            break;

                        default:
                            break;

                    }
                }

			break;	
						
		case WM_NOTIFY:
    		    switch (((NMHDR FAR *) lParam)->code)
    		    {

  				    case PSN_KILLACTIVE:
                            SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
					        return TRUE;

                        break;

				    case PSN_RESET:
                            if(NULL==(pGetSignInfo=(CRYPTUI_WIZ_GET_SIGN_PAGE_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                                break;

                            if(NULL==(pPvkSignInfo=(CERT_SIGNING_INFO *)(pGetSignInfo->pvSignReserved)))
                                break;

                            //mark that the cancel bottun is clicked
                            pPvkSignInfo->fCancel=TRUE;

                            SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
					    break;

 				    case PSN_SETACTIVE:

    					    PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_NEXT|PSWIZB_BACK);

                            if(NULL==(pGetSignInfo=(CRYPTUI_WIZ_GET_SIGN_PAGE_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                                break;

                            if(NULL==(pPvkSignInfo=(CERT_SIGNING_INFO *)(pGetSignInfo->pvSignReserved)))
                                break;

                            //init the radio and combo boxes based on user's selection
                            if(pPvkSignInfo->fRefreshPvkOnCert && pPvkSignInfo->fSignCert && pPvkSignInfo->pSignCert)
                            {
                                InitPvkWithCertificate(hwndDlg, pPvkSignInfo->pSignCert, pPvkSignInfo);
                                pPvkSignInfo->fRefreshPvkOnCert=FALSE;
                            }
                            /*else
                            {
                                if((FALSE == pPvkSignInfo->fSignCert) && pPvkSignInfo->pwszSPCFileName)
                                {
                                    //init the signing certificate
                                    pDigitalSignInfo=(CRYPTUI_WIZ_DIGITAL_SIGN_INFO *)(pGetSignInfo->pDigitalSignInfo);

                                    if(pDigitalSignInfo)
                                    {

                                        if(CRYPTUI_WIZ_DIGITAL_SIGN_PVK == pDigitalSignInfo->dwSigningCertChoice)
                                        {
                                            pKeyInfo=(CRYPTUI_WIZ_DIGITAL_SIGN_CERT_PVK_INFO *)(pDigitalSignInfo->pSigningCertPvkInfo);

                                            if(pKeyInfo)
                                            {
                                                if(0 == _wcsicmp(pKeyInfo->pwszSigningCertFileName,
                                                            pPvkSignInfo->pwszSPCFileName))
                                                {
                                                    switch(pKeyInfo->dwPvkChoice)
                                                    {
                                                        case CRYPTUI_WIZ_DIGITAL_SIGN_PVK_FILE:
                                                               InitPvkWithPvkInfo(hwndDlg, (CRYPTUI_WIZ_DIGITAL_SIGN_PVK_FILE_INFO   *)(pKeyInfo->pPvkFileInfo), pPvkSignInfo);
                                                            break;
                                                        case CRYPTUI_WIZ_DIGITAL_SIGN_PVK_PROV:
                                                               InitPvkWithProvInfo(hwndDlg, pKeyInfo->pPvkProvInfo, pPvkSignInfo);
                                                            break;

                                                        default:
                                                            break;
                                                    }

                                                }

                                            }

                                        }
                                    }
                                }
                            } */


					    break;

                    case PSN_WIZBACK:

                        break;

                    case PSN_WIZNEXT:

                            if(NULL==(pGetSignInfo=(CRYPTUI_WIZ_GET_SIGN_PAGE_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                                break;

                            if(NULL==(pPvkSignInfo=(CERT_SIGNING_INFO *)(pGetSignInfo->pvSignReserved)))
                                break;

                            //gather the infomation for user's select
                            pPvkSignInfo->fUsePvkPage=TRUE;

                            //check the radio button
                            if(TRUE==SendMessage(GetDlgItem(hwndDlg, IDC_PVK_FILE_RADIO), BM_GETCHECK, 0, 0))
                            {
                                pPvkSignInfo->fPvkFile=TRUE;

                                //get the PvkFile
                                if(0==(dwChar=(DWORD)SendDlgItemMessage(hwndDlg,
                                                      IDC_PVK_FILE_EDIT,
                                                      WM_GETTEXTLENGTH, 0, 0)))
                                {
                                    //ask for the file name
                                    I_MessageBox(hwndDlg, IDS_HAS_TO_SPECIFY_PVK_FILE,
                                                            pPvkSignInfo->idsMsgTitle,
                                                            pGetSignInfo->pwszPageTitle,
                                                            MB_ICONERROR|MB_OK|MB_APPLMODAL);
                                     //make the file page stay
                                     SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);

                                     break;
                                }

                                if(pPvkSignInfo->pwszPvk_File)
                                {
                                    WizardFree(pPvkSignInfo->pwszPvk_File);
                                    pPvkSignInfo->pwszPvk_File=NULL;
                                }

                                pPvkSignInfo->pwszPvk_File=(LPWSTR)WizardAlloc((dwChar+1)*sizeof(WCHAR));

                                if(NULL==pPvkSignInfo->pwszPvk_File)
                                    break;

                                GetDlgItemTextU(hwndDlg, IDC_PVK_FILE_EDIT,
                                                pPvkSignInfo->pwszPvk_File,
                                                dwChar+1);

                                //get the CSP
                                iIndex=(int)SendDlgItemMessage(hwndDlg, IDC_PVK_FILE_CSP_COMBO,
                                    CB_GETCURSEL, 0, 0);

                                if(CB_ERR==iIndex)
                                {
                                    //ask for the CSP name
                                    I_MessageBox(hwndDlg, IDS_HAS_TO_SPECIFY_CSP,
                                                            pPvkSignInfo->idsMsgTitle,
                                                            pGetSignInfo->pwszPageTitle,
                                                            MB_ICONERROR|MB_OK|MB_APPLMODAL);
                                     //make the file page stay
                                     SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);

                                     break;
                                }

                                //get the selected CSP name
                                if(pPvkSignInfo->pwszPvk_CSP)
                                {
                                    WizardFree(pPvkSignInfo->pwszPvk_CSP);
                                    pPvkSignInfo->pwszPvk_CSP=NULL;
                                }

                                if(CB_ERR==SendDlgItemMessageU_GETLBTEXT(hwndDlg, IDC_PVK_FILE_CSP_COMBO,
                                          iIndex, &(pPvkSignInfo->pwszPvk_CSP)))
                                    break;

                                //find the CSP type
                                for(dwIndex=0; dwIndex < pPvkSignInfo->dwCSPCount; dwIndex++)
                                {
                                    if(0==wcscmp(((pPvkSignInfo->pCSPInfo)[dwIndex].pwszCSPName),
                                                 pPvkSignInfo->pwszPvk_CSP))
                                    {
                                        pPvkSignInfo->dwPvk_CSPType=(pPvkSignInfo->pCSPInfo)[dwIndex].dwCSPType;
                                        break;
                                    }

                                }

                            }
                            else
                            {

                                pPvkSignInfo->fPvkFile=FALSE;

                                //get the CSP
                                iIndex=(int)SendDlgItemMessage(hwndDlg, IDC_PVK_CONTAINER_CSP_COMBO,
                                    CB_GETCURSEL, 0, 0);

                                if(CB_ERR==iIndex)
                                {
                                    //ask for the CSP name
                                    I_MessageBox(hwndDlg, IDS_HAS_TO_SPECIFY_CSP,
                                                            pPvkSignInfo->idsMsgTitle,
                                                            pGetSignInfo->pwszPageTitle,
                                                            MB_ICONERROR|MB_OK|MB_APPLMODAL);
                                     //make the file page stay
                                     SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);

                                     break;
                                }

                                //get the selected CSP name
                                if(pPvkSignInfo->pwszContainer_CSP)
                                {
                                    WizardFree(pPvkSignInfo->pwszContainer_CSP);
                                    pPvkSignInfo->pwszContainer_CSP=NULL;
                                }

                                if(CB_ERR==SendDlgItemMessageU_GETLBTEXT(hwndDlg, IDC_PVK_CONTAINER_CSP_COMBO,
                                          iIndex, &(pPvkSignInfo->pwszContainer_CSP)))
                                    break;

                                //find the CSP type
                                for(dwIndex=0; dwIndex < pPvkSignInfo->dwCSPCount; dwIndex++)
                                {
                                    if(0==wcscmp(((pPvkSignInfo->pCSPInfo)[dwIndex].pwszCSPName),
                                                 pPvkSignInfo->pwszContainer_CSP))
                                    {
                                        pPvkSignInfo->dwContainer_CSPType=(pPvkSignInfo->pCSPInfo)[dwIndex].dwCSPType;
                                        break;
                                    }

                                }

                                //get the key container name
                                iIndex=(int)SendDlgItemMessage(hwndDlg, IDC_PVK_CONTAINER_NAME_COMBO,
                                    CB_GETCURSEL, 0, 0);

                                if(CB_ERR==iIndex)
                                {
                                    //ask for the CSP name
                                    I_MessageBox(hwndDlg, IDS_HAS_TO_SPECIFY_CONTAINER,
                                                            pPvkSignInfo->idsMsgTitle,
                                                            pGetSignInfo->pwszPageTitle,
                                                            MB_ICONERROR|MB_OK|MB_APPLMODAL);
                                     //make the file page stay
                                     SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);

                                     break;
                                }

                                //get the selected CSP name
                                if(pPvkSignInfo->pwszContainer_Name)
                                {
                                    WizardFree(pPvkSignInfo->pwszContainer_Name);
                                    pPvkSignInfo->pwszContainer_Name=NULL;
                                }

                                if(CB_ERR==SendDlgItemMessageU_GETLBTEXT(hwndDlg, IDC_PVK_CONTAINER_NAME_COMBO,
                                          iIndex, &(pPvkSignInfo->pwszContainer_Name)))
                                    break;

                                //get the KeyType
                                iIndex=(int)SendDlgItemMessage(hwndDlg, IDC_PVK_CONTAINER_KEY_TYPE_COMBO,
                                    CB_GETCURSEL, 0, 0);

                                if(CB_ERR==iIndex)
                                {
                                    //ask for the CSP name
                                    I_MessageBox(hwndDlg, IDS_HAS_TO_SPECIFY_KEY_TYPE,
                                                            pPvkSignInfo->idsMsgTitle,
                                                            pGetSignInfo->pwszPageTitle,
                                                            MB_ICONERROR|MB_OK|MB_APPLMODAL);
                                     //make the file page stay
                                     SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);

                                     break;
                                }

                                if(pPvkSignInfo->pwszContainer_KeyType)
                                {
                                    WizardFree(pPvkSignInfo->pwszContainer_KeyType);
                                    pPvkSignInfo->pwszContainer_KeyType=NULL;
                                }


                                //get the selected CSP name
                                if(CB_ERR==SendDlgItemMessageU_GETLBTEXT(hwndDlg, IDC_PVK_CONTAINER_KEY_TYPE_COMBO,
                                          iIndex, &(pPvkSignInfo->pwszContainer_KeyType)))
                                    break;

                                pPvkSignInfo->dwContainer_KeyType=GetKeyTypeFromName(pPvkSignInfo->pwszContainer_KeyType);


                            }

                            //make sure the selected public key and private key match
                            if(!CertPvkMatch(pPvkSignInfo, FALSE))
                            {
                                //ask for the CSP name
                                I_MessageBox(hwndDlg, IDS_SIGN_NOMATCH,
                                                        pPvkSignInfo->idsMsgTitle,
                                                        pGetSignInfo->pwszPageTitle,
                                                        MB_ICONERROR|MB_OK|MB_APPLMODAL);
                                 //make the file page stay
                                 SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);

                                 break;
                            }


                        break;

				    default:
					    return FALSE;

    	        }
		    break;

		default:
			return FALSE;
	}

	return TRUE;
}


//-----------------------------------------------------------------------
// Sign_Hash
//-----------------------------------------------------------------------
INT_PTR APIENTRY Sign_Hash(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CRYPTUI_WIZ_GET_SIGN_PAGE_INFO         *pGetSignInfo=NULL;
    CERT_SIGNING_INFO                      *pPvkSignInfo=NULL;
    PROPSHEETPAGE                          *pPropSheet=NULL;

    DWORD                                   dwIndex=0;
    int                                     iIndex=0;
    int                                     iLength=0;
    HWND                                    hwndControl=NULL;
    CRYPTUI_WIZ_DIGITAL_SIGN_INFO           *pDigitalSignInfo=NULL;
    CRYPTUI_WIZ_DIGITAL_SIGN_EXTENDED_INFO  *pExtInfo=NULL;
    ALG_ID                                  rgAlgID[HASH_ALG_COUNT]={CALG_MD5,
                                                        CALG_SHA1};
    PCCRYPT_OID_INFO                        pOIDInfo=NULL;
    LPSTR                                   pszOIDName=NULL;
    LPSTR                                   pszUserOIDName=NULL;

	switch (msg)
	{
		case WM_INITDIALOG:
                //set the wizard information so that it can be shared
                pPropSheet = (PROPSHEETPAGE *) lParam;
                pGetSignInfo = (CRYPTUI_WIZ_GET_SIGN_PAGE_INFO *) (pPropSheet->lParam);

                if(NULL==pGetSignInfo)
                    break;

                SetWindowLongPtr(hwndDlg, DWLP_USER, (LONG_PTR)pGetSignInfo);

                //init the pPvkSignInfo if not present
                if(NULL==(pGetSignInfo->pvSignReserved))
                {
                    if(!InitPvkSignInfo((CERT_SIGNING_INFO **)(&(pGetSignInfo->pvSignReserved))))
                        break;
                }

                pPvkSignInfo=(CERT_SIGNING_INFO *)(pGetSignInfo->pvSignReserved);

                if(NULL==pPvkSignInfo)
                    break;

                SetControlFont(pPvkSignInfo->hBold, hwndDlg,IDC_WIZARD_STATIC_BOLD1);

                //initialize hashing table
                if(NULL==(hwndControl=GetDlgItem(hwndDlg, IDC_WIZARD_LIST1)))
                    break;

                //add the hash algorithm required by the user
                pDigitalSignInfo=(CRYPTUI_WIZ_DIGITAL_SIGN_INFO *)(pGetSignInfo->pDigitalSignInfo);

                if(pDigitalSignInfo)
                {
                    pExtInfo=(CRYPTUI_WIZ_DIGITAL_SIGN_EXTENDED_INFO  *)pDigitalSignInfo->pSignExtInfo;

                    if(pExtInfo)
                    {
                        if(pExtInfo->pszHashAlg)
                        {
                            //get the name of the HashAlg.
                            pOIDInfo=CryptFindOIDInfo(
                                    CRYPT_OID_INFO_OID_KEY,
                                    (void *)(pExtInfo->pszHashAlg),
                                    CRYPT_HASH_ALG_OID_GROUP_ID);

                            if(pOIDInfo)
                            {
                               MkMBStr(NULL, 0, pOIDInfo->pwszName,
                                        &pszUserOIDName);

                                if(pszUserOIDName)
                                {
                                   SendMessage(hwndControl, LB_ADDSTRING, 0, (LPARAM)pszUserOIDName);
                                   //set the cursor selection
                                   SendMessage(hwndControl, LB_SETCURSEL, 0, 0);
                                }
                            }

                        }

                    }
                }

                //populate the table with string with pre-defined hash algorithms
                for(dwIndex=0; dwIndex < HASH_ALG_COUNT; dwIndex++)
                {
                    pOIDInfo=CryptFindOIDInfo(CRYPT_OID_INFO_ALGID_KEY,
                                    &rgAlgID[dwIndex],
                                    CRYPT_HASH_ALG_OID_GROUP_ID);

                    if(NULL != pOIDInfo)
                    {
                       MkMBStr(NULL, 0, pOIDInfo->pwszName,
                                &pszOIDName);

                        if(pszOIDName)
                        {
                           //make sure the OID has not been populated yet
                           if(pszUserOIDName)
                           {
                               if(0 != strcmp(pszUserOIDName, pszOIDName))
                                    SendMessage(hwndControl, LB_ADDSTRING, 0, (LPARAM)pszOIDName);
                           }
                           else
                                SendMessage(hwndControl, LB_ADDSTRING, 0, (LPARAM)pszOIDName);

                           FreeMBStr(NULL, pszOIDName);
                           pszOIDName=NULL;
                        }
                    }
                }

                //set the cursor selection if nothing has been selected
                //select SHA1 hashing
                if(LB_ERR==SendMessage(hwndControl, LB_GETCURSEL, 0, 0))
                    SendMessage(hwndControl, LB_SETCURSEL, 1, 0);

                //free the user OID name
                if(pszUserOIDName)
                {
                    FreeMBStr(NULL, pszUserOIDName);
                    pszUserOIDName=NULL;
                }

			break;

        case WM_DESTROY:
                if(NULL==(pGetSignInfo=(CRYPTUI_WIZ_GET_SIGN_PAGE_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                    break;

                //try to sign the document
                SignAtDestroy(hwndDlg, pGetSignInfo,IDD_SIGN_HASH);

            break;

		case WM_COMMAND:
			break;	
						
		case WM_NOTIFY:
    		    switch (((NMHDR FAR *) lParam)->code)
    		    {

  				    case PSN_KILLACTIVE:
                            SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
					        return TRUE;

                        break;

				    case PSN_RESET:
                            if(NULL==(pGetSignInfo=(CRYPTUI_WIZ_GET_SIGN_PAGE_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                                break;

                            if(NULL==(pPvkSignInfo=(CERT_SIGNING_INFO *)(pGetSignInfo->pvSignReserved)))
                                break;

                            //mark that the cancel bottun is clicked
                            pPvkSignInfo->fCancel=TRUE;

                            SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
					    break;

 				    case PSN_SETACTIVE:
 					    PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_NEXT|PSWIZB_BACK);
					    break;

                    case PSN_WIZBACK:

                        break;

                    case PSN_WIZNEXT:

                            if(NULL==(pGetSignInfo=(CRYPTUI_WIZ_GET_SIGN_PAGE_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                                break;

                            if(NULL==(pPvkSignInfo=(CERT_SIGNING_INFO *)(pGetSignInfo->pvSignReserved)))
                                break;

                            if(NULL==(hwndControl=GetDlgItem(hwndDlg, IDC_WIZARD_LIST1)))
                                break;

                            //get the selected index
                            iIndex=(int)SendMessage(hwndControl, LB_GETCURSEL, 0, 0);

                            if(LB_ERR == iIndex)
                            {
                                //warn the user has to select a hash algorithm
                                I_MessageBox(hwndDlg, IDS_HAS_TO_SELECT_HASH,
                                                            pPvkSignInfo->idsMsgTitle,
                                                            pGetSignInfo->pwszPageTitle,
                                                            MB_ICONERROR|MB_OK|MB_APPLMODAL);

                                //make the purpose page stay
                                SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);

                                break;
                            }


                            //free the original OID name
                            if(pPvkSignInfo->pszHashOIDName)
                            {
                                WizardFree(pPvkSignInfo->pszHashOIDName);
                                pPvkSignInfo->pszHashOIDName=NULL;
                            }


                            //get the OID name
                            if(0 != (iLength=(int)SendMessage(hwndControl, LB_GETTEXTLEN,iIndex,0)))
                            {
                                pPvkSignInfo->pszHashOIDName=(LPSTR)WizardAlloc(sizeof(CHAR)*(iLength+1));

                                if(NULL!=(pPvkSignInfo->pszHashOIDName))
                                    SendMessage(hwndControl, LB_GETTEXT, iIndex, (LPARAM)(pPvkSignInfo->pszHashOIDName));
                            }


                        break;

				    default:
					    return FALSE;

    	        }
		    break;

		default:
			return FALSE;
	}

	return TRUE;
}


//-----------------------------------------------------------------------
// Sign_Chain
//-----------------------------------------------------------------------
INT_PTR APIENTRY Sign_Chain(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CRYPTUI_WIZ_GET_SIGN_PAGE_INFO         *pGetSignInfo=NULL;
    CERT_SIGNING_INFO                      *pPvkSignInfo=NULL;
    PROPSHEETPAGE                          *pPropSheet=NULL;
    HDC                                     hdc=NULL;
    COLORREF                                colorRef;

    HWND                                    hwndControl=NULL;
    CRYPTUI_WIZ_DIGITAL_SIGN_INFO           *pDigitalSignInfo=NULL;
    CRYPTUI_WIZ_DIGITAL_SIGN_EXTENDED_INFO  *pSignExtInfo=NULL;
    LPWSTR                                  pwszCertStoreName=NULL;
    WCHAR                                   wszUnknownStoreName[MAX_TITLE_LENGTH];
    int                                     idsMsg=0;
    CRYPTUI_SELECTSTORE_STRUCT              CertStoreSelect;


	switch (msg)
	{
		case WM_INITDIALOG:
                //set the wizard information so that it can be shared
                pPropSheet = (PROPSHEETPAGE *) lParam;
                pGetSignInfo = (CRYPTUI_WIZ_GET_SIGN_PAGE_INFO *) (pPropSheet->lParam);

                if(NULL==pGetSignInfo)
                    break;

                SetWindowLongPtr(hwndDlg, DWLP_USER, (LONG_PTR)pGetSignInfo);

                //init the pPvkSignInfo if not present
                if(NULL==(pGetSignInfo->pvSignReserved))
                {
                    if(!InitPvkSignInfo((CERT_SIGNING_INFO **)(&(pGetSignInfo->pvSignReserved))))
                        break;
                }

                pPvkSignInfo=(CERT_SIGNING_INFO *)(pGetSignInfo->pvSignReserved);

                if(NULL==pPvkSignInfo)
                    break;

                SetControlFont(pPvkSignInfo->hBold, hwndDlg,IDC_WIZARD_STATIC_BOLD1);


                //initialize the chain options
                pDigitalSignInfo=(CRYPTUI_WIZ_DIGITAL_SIGN_INFO *)(pGetSignInfo->pDigitalSignInfo);

                if(pDigitalSignInfo)
                {
                    switch(pDigitalSignInfo->dwAdditionalCertChoice)
                    {
                        case    CRYPTUI_WIZ_DIGITAL_SIGN_ADD_CHAIN:
                                SendMessage(GetDlgItem(hwndDlg, IDC_CHAIN_ROOT_RADIO), BM_SETCHECK, 1, 0);
                            break;
                        case    CRYPTUI_WIZ_DIGITAL_SIGN_ADD_CHAIN_NO_ROOT:
                                SendMessage(GetDlgItem(hwndDlg, IDC_CHAIN_NO_ROOT_RADIO), BM_SETCHECK, 1, 0);
                            break;
                        default:
                                SendMessage(GetDlgItem(hwndDlg, IDC_CHAIN_ROOT_RADIO), BM_SETCHECK, 1, 0);
                            break;

                    }
                }
                else
                {
                    //we add the whole chain without root
                    SendMessage(GetDlgItem(hwndDlg, IDC_CHAIN_ROOT_RADIO), BM_SETCHECK, 1, 0);
                }

                //initialize the additional cert store
                //disable browse button and the file name button
                EnableWindow(GetDlgItem(hwndDlg, IDC_FILE_BUTTON), FALSE);
                EnableWindow(GetDlgItem(hwndDlg, IDC_STORE_BUTTON), FALSE);
                EnableWindow(GetDlgItem(hwndDlg, IDC_FILE_EDIT), FALSE);


                if(pDigitalSignInfo)
                {

                    pSignExtInfo=(CRYPTUI_WIZ_DIGITAL_SIGN_EXTENDED_INFO  *)pDigitalSignInfo->pSignExtInfo;

                    if(pSignExtInfo)
                    {
                        if(pSignExtInfo->hAdditionalCertStore)
                        {
                            //check the radio button
                            SendMessage(GetDlgItem(hwndDlg, IDC_CHAIN_STORE_RADIO), BM_SETCHECK, 1, 0);

                            //enable the browse button
                            EnableWindow(GetDlgItem(hwndDlg, IDC_STORE_BUTTON), TRUE);

                            //get the name of the certificate store
                            if(SignGetStoreName(pSignExtInfo->hAdditionalCertStore,
                                            &pwszCertStoreName))
                            {
                                 //get the hwndControl for the list view
                                hwndControl=GetDlgItem(hwndDlg, IDC_WIZARD_LIST1);

                                if(hwndControl)
                                    SetWindowTextU(hwndControl,pwszCertStoreName);
                            }

                            //copy the certificate store
                            pPvkSignInfo->hAddStoreCertStore=pSignExtInfo->hAdditionalCertStore;
                            pPvkSignInfo->fFreeStoreCertStore=FALSE;

                            if(pwszCertStoreName)
                                WizardFree(pwszCertStoreName);

                            pwszCertStoreName=NULL;
                        }

                    }
                }

                //set the default addtional cert options
                if(TRUE != (GetDlgItem(hwndDlg, IDC_CHAIN_STORE_RADIO), BM_GETCHECK, 0, 0))
                    SendMessage(GetDlgItem(hwndDlg, IDC_WIZARD_NO_ADD_CERT_RADIO), BM_SETCHECK, 1, 0);

			break;

        case WM_DESTROY:
                if(NULL==(pGetSignInfo=(CRYPTUI_WIZ_GET_SIGN_PAGE_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                    break;

                //try to sign the document
                SignAtDestroy(hwndDlg, pGetSignInfo,IDD_SIGN_CHAIN);

            break;

		case WM_COMMAND:
                if(HIWORD(wParam) == BN_CLICKED)
                {
                    switch (LOWORD(wParam))
                    {

                        case    IDC_FILE_BUTTON:
                                if(NULL==(pGetSignInfo=(CRYPTUI_WIZ_GET_SIGN_PAGE_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                                    break;

                                if(NULL==(pPvkSignInfo=(CERT_SIGNING_INFO *)(pGetSignInfo->pvSignReserved)))
                                    break;


                                if(!RetrieveFileName(hwndDlg,
                                                pPvkSignInfo->idsMsgTitle,
                                                pGetSignInfo->pwszPageTitle,
                                                &(pPvkSignInfo->hAddFileCertStore),
                                                &(pPvkSignInfo->pwszAddFileName)))
                                    break;

                            break;

                        case    IDC_STORE_BUTTON:
                                if(NULL==(pGetSignInfo=(CRYPTUI_WIZ_GET_SIGN_PAGE_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                                    break;

                                if(NULL==(pPvkSignInfo=(CERT_SIGNING_INFO *)(pGetSignInfo->pvSignReserved)))
                                    break;

                                if(!RetrieveStoreName(hwndDlg,
                                                &(pPvkSignInfo->hAddStoreCertStore),
                                                &(pPvkSignInfo->fFreeStoreCertStore)))
                                    break;



                            break;

                        case    IDC_WIZARD_NO_ADD_CERT_RADIO:
                                //disable browse button
                                EnableWindow(GetDlgItem(hwndDlg, IDC_FILE_BUTTON), FALSE);
                                EnableWindow(GetDlgItem(hwndDlg, IDC_STORE_BUTTON), FALSE);
                                EnableWindow(GetDlgItem(hwndDlg, IDC_FILE_EDIT), FALSE);
                               
                            break;
                        case    IDC_CHAIN_STORE_RADIO:
                                EnableWindow(GetDlgItem(hwndDlg, IDC_FILE_BUTTON), FALSE);
                                EnableWindow(GetDlgItem(hwndDlg, IDC_STORE_BUTTON), TRUE);
                                EnableWindow(GetDlgItem(hwndDlg, IDC_FILE_EDIT), FALSE);
                            break;

                        case    IDC_CHAIN_FILE_RADIO:
                                EnableWindow(GetDlgItem(hwndDlg, IDC_FILE_BUTTON), TRUE);
                                EnableWindow(GetDlgItem(hwndDlg, IDC_STORE_BUTTON), FALSE);
                                EnableWindow(GetDlgItem(hwndDlg, IDC_FILE_EDIT), TRUE);
                            break;

                        default:
                            break;

                    }
                }
			break;	
						
		case WM_NOTIFY:
    		    switch (((NMHDR FAR *) lParam)->code)
    		    {

  				    case PSN_KILLACTIVE:
                            SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
					        return TRUE;

                        break;

				    case PSN_RESET:
                            if(NULL==(pGetSignInfo=(CRYPTUI_WIZ_GET_SIGN_PAGE_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                                break;

                            if(NULL==(pPvkSignInfo=(CERT_SIGNING_INFO *)(pGetSignInfo->pvSignReserved)))
                                break;

                            //mark that the cancel bottun is clicked
                            pPvkSignInfo->fCancel=TRUE;

                            SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
					    break;

 				    case PSN_SETACTIVE:
 					    PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_NEXT|PSWIZB_BACK);
					    break;

                    case PSN_WIZBACK:
                        break;

                    case PSN_WIZNEXT:

                            if(NULL==(pGetSignInfo=(CRYPTUI_WIZ_GET_SIGN_PAGE_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                                break;

                            if(NULL==(pPvkSignInfo=(CERT_SIGNING_INFO *)(pGetSignInfo->pvSignReserved)))
                                break;

                            //mark the we have obtained the information from the chain page
                            pPvkSignInfo->fUsageChain=TRUE;

                            //check to see which chain is selected
                            if(TRUE==SendMessage(GetDlgItem(hwndDlg, IDC_CHAIN_NO_ROOT_RADIO), BM_GETCHECK, 0, 0))
                                pPvkSignInfo->dwChainOption=SIGN_PVK_CHAIN_NO_ROOT;
                            else
                            {
                                if(TRUE==SendMessage(GetDlgItem(hwndDlg, IDC_CHAIN_ROOT_RADIO), BM_GETCHECK, 0, 0))
                                    pPvkSignInfo->dwChainOption=SIGN_PVK_CHAIN_ROOT;
                                else
                                {
                                    if(TRUE==SendMessage(GetDlgItem(hwndDlg, IDC_NO_CHAIN_RADIO), BM_GETCHECK, 0, 0))
                                        pPvkSignInfo->dwChainOption=SIGN_PVK_NO_CHAIN;
                                }
                            }

                            idsMsg=0;

                            //check to see if the fileName or the cert store is specified
                            if(TRUE==SendMessage(GetDlgItem(hwndDlg, IDC_CHAIN_FILE_RADIO), BM_GETCHECK, 0, 0))
                            {
                                pPvkSignInfo->dwAddOption=SIGN_PVK_ADD_FILE;

                                //user could have just enter the file name in the edit box
                                //without clicking on the browse button
                                RetrieveFileNameFromEditBox(hwndDlg,
                                            pPvkSignInfo->idsMsgTitle,
                                            pGetSignInfo->pwszPageTitle,
                                            &(pPvkSignInfo->hAddFileCertStore),
                                            &(pPvkSignInfo->pwszAddFileName),
                                            &idsMsg);
                            }
                            else
                            {
                                if(TRUE==SendMessage(GetDlgItem(hwndDlg, IDC_CHAIN_STORE_RADIO), BM_GETCHECK, 0, 0))
                                {
                                    pPvkSignInfo->dwAddOption=SIGN_PVK_ADD_STORE;

                                    if(!(pPvkSignInfo->hAddStoreCertStore))
                                        idsMsg=IDS_SELECT_ADD_STORE;
                                }
                                else
                                {
                                    if(TRUE==SendMessage(GetDlgItem(hwndDlg, IDC_WIZARD_NO_ADD_CERT_RADIO), BM_GETCHECK, 0, 0))
                                        pPvkSignInfo->dwAddOption=SIGN_PVK_NO_ADD;
                                }
                            }

                            if(idsMsg)
                            {

                                //warn the user has to select a select a file or store
                                I_MessageBox(hwndDlg, idsMsg,
                                            pPvkSignInfo->idsMsgTitle,
                                            pGetSignInfo->pwszPageTitle,
                                            MB_ICONERROR|MB_OK|MB_APPLMODAL);

                                //make the purpose page stay
                                SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);

                                break;
                            }

                        break;

				    default:
					    return FALSE;

    	        }
		    break;

		default:
			return FALSE;
	}

	return TRUE;
}


//-----------------------------------------------------------------------
// Sign_Description
//-----------------------------------------------------------------------
INT_PTR APIENTRY Sign_Description(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CRYPTUI_WIZ_GET_SIGN_PAGE_INFO         *pGetSignInfo=NULL;
    CERT_SIGNING_INFO                      *pPvkSignInfo=NULL;
    PROPSHEETPAGE                          *pPropSheet=NULL;

    DWORD                                   dwChar=0;
    CRYPTUI_WIZ_DIGITAL_SIGN_INFO           *pDigitalSignInfo=NULL;
    CRYPTUI_WIZ_DIGITAL_SIGN_EXTENDED_INFO  *pExtInfo=NULL;

	switch (msg)
	{
		case WM_INITDIALOG:
                //set the wizard information so that it can be shared
                pPropSheet = (PROPSHEETPAGE *) lParam;
                pGetSignInfo = (CRYPTUI_WIZ_GET_SIGN_PAGE_INFO *) (pPropSheet->lParam);

                if(NULL==pGetSignInfo)
                    break;

                SetWindowLongPtr(hwndDlg, DWLP_USER, (LONG_PTR)pGetSignInfo);

                //init the pPvkSignInfo if not present
                if(NULL==(pGetSignInfo->pvSignReserved))
                {
                    if(!InitPvkSignInfo((CERT_SIGNING_INFO **)(&(pGetSignInfo->pvSignReserved))))
                        break;
                }

                pPvkSignInfo=(CERT_SIGNING_INFO *)(pGetSignInfo->pvSignReserved);

                if(NULL==pPvkSignInfo)
                    break;

                SetControlFont(pPvkSignInfo->hBold, hwndDlg,IDC_WIZARD_STATIC_BOLD1);

                //initialize the Description and URL
                //use the default if user did not supply one

                pDigitalSignInfo=(CRYPTUI_WIZ_DIGITAL_SIGN_INFO *)(pGetSignInfo->pDigitalSignInfo);

                if(pDigitalSignInfo)
                {
                    pExtInfo=(CRYPTUI_WIZ_DIGITAL_SIGN_EXTENDED_INFO  *)pDigitalSignInfo->pSignExtInfo;

                    if(pExtInfo)
                    {
                        //description
                        if(pExtInfo->pwszDescription)
                            SetDlgItemTextU(hwndDlg, IDC_WIZARD_EDIT1,pExtInfo->pwszDescription);

                        //URL
                        if(pExtInfo->pwszMoreInfoLocation)
                            SetDlgItemTextU(hwndDlg, IDC_WIZARD_EDIT2,pExtInfo->pwszMoreInfoLocation);
                    }
                }


			break;

        case WM_DESTROY:
                if(NULL==(pGetSignInfo=(CRYPTUI_WIZ_GET_SIGN_PAGE_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                    break;

                //try to sign the document
                SignAtDestroy(hwndDlg, pGetSignInfo,IDD_SIGN_DESCRIPTION);

            break;

		case WM_COMMAND:
			break;	
						
		case WM_NOTIFY:
    		    switch (((NMHDR FAR *) lParam)->code)
    		    {

  				    case PSN_KILLACTIVE:
                            SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
					        return TRUE;

                        break;

				    case PSN_RESET:
                            if(NULL==(pGetSignInfo=(CRYPTUI_WIZ_GET_SIGN_PAGE_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                                break;

                            if(NULL==(pPvkSignInfo=(CERT_SIGNING_INFO *)(pGetSignInfo->pvSignReserved)))
                                break;

                            //mark that the cancel bottun is clicked
                            pPvkSignInfo->fCancel=TRUE;

                            SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
					    break;

 				    case PSN_SETACTIVE:
 					    PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_NEXT|PSWIZB_BACK);
					    break;

                    case PSN_WIZBACK:
                            //if we are doing the all signing options, skip the pages
                            //in typical case
                            if(NULL==(pGetSignInfo=(CRYPTUI_WIZ_GET_SIGN_PAGE_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                                break;

                            if(NULL==(pPvkSignInfo=(CERT_SIGNING_INFO *)(pGetSignInfo->pvSignReserved)))
                                break;

                            if(TRUE == pPvkSignInfo->fUseOption)
                            {
                                if(FALSE == pPvkSignInfo->fCustom)
                                {
                                    //skip to the sign cert page
                                    SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_SIGN_CERT);
                                }
                            }

                        break;

                    case PSN_WIZNEXT:

                            if(NULL==(pGetSignInfo=(CRYPTUI_WIZ_GET_SIGN_PAGE_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                                break;

                            if(NULL==(pPvkSignInfo=(CERT_SIGNING_INFO *)(pGetSignInfo->pvSignReserved)))
                                break;

                            //free the original content and URL address
                            if(pPvkSignInfo->pwszDes)
                            {
                                WizardFree(pPvkSignInfo->pwszDes);
                                pPvkSignInfo->pwszDes=NULL;
                            }

                            if(pPvkSignInfo->pwszURL)
                            {
                                WizardFree(pPvkSignInfo->pwszURL);
                                pPvkSignInfo->pwszURL=NULL;
                            }


                            //we have obtained the description information from the user
                            pPvkSignInfo->fUseDescription=TRUE;

                            //get the content
                            if(0!=(dwChar=(DWORD)SendDlgItemMessage(hwndDlg,
                                                  IDC_WIZARD_EDIT1,
                                                  WM_GETTEXTLENGTH, 0, 0)))
                            {
                                pPvkSignInfo->pwszDes=(LPWSTR)WizardAlloc(sizeof(WCHAR)*(dwChar+1));

                                if(NULL!=(pPvkSignInfo->pwszDes))
                                {
                                    GetDlgItemTextU(hwndDlg, IDC_WIZARD_EDIT1,
                                                    pPvkSignInfo->pwszDes,
                                                    dwChar+1);
                                }
                            }

                            //get the URL
                            if(0!=(dwChar=(DWORD)SendDlgItemMessage(hwndDlg,
                                                  IDC_WIZARD_EDIT2,
                                                  WM_GETTEXTLENGTH, 0, 0)))
                            {
                                pPvkSignInfo->pwszURL=(LPWSTR)WizardAlloc(sizeof(WCHAR)*(dwChar+1));

                                if(NULL!=(pPvkSignInfo->pwszURL))
                                {
                                    GetDlgItemTextU(hwndDlg, IDC_WIZARD_EDIT2,
                                                    pPvkSignInfo->pwszURL,
                                                    dwChar+1);
                                }
                            }

                        break;

				    default:
					    return FALSE;

    	        }
		    break;

		default:
			return FALSE;
	}

	return TRUE;
}

//-----------------------------------------------------------------------
// TimeStamp
//-----------------------------------------------------------------------
INT_PTR APIENTRY Sign_TimeStamp(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CRYPTUI_WIZ_GET_SIGN_PAGE_INFO         *pGetSignInfo=NULL;
    CERT_SIGNING_INFO                      *pPvkSignInfo=NULL;
    PROPSHEETPAGE                          *pPropSheet=NULL;

    DWORD                                   dwChar=0;
    HWND                                    hwndControl=NULL;
    CRYPTUI_WIZ_DIGITAL_SIGN_INFO           *pDigitalSignInfo=NULL;

	switch (msg)
	{
		case WM_INITDIALOG:
                //set the wizard information so that it can be shared
                pPropSheet = (PROPSHEETPAGE *) lParam;
                pGetSignInfo = (CRYPTUI_WIZ_GET_SIGN_PAGE_INFO *) (pPropSheet->lParam);

                if(NULL==pGetSignInfo)
                    break;

                SetWindowLongPtr(hwndDlg, DWLP_USER, (LONG_PTR)pGetSignInfo);

                //init the pPvkSignInfo if not present
                if(NULL==(pGetSignInfo->pvSignReserved))
                {
                    if(!InitPvkSignInfo((CERT_SIGNING_INFO **)(&(pGetSignInfo->pvSignReserved))))
                        break;
                }

                pPvkSignInfo=(CERT_SIGNING_INFO *)(pGetSignInfo->pvSignReserved);

                if(NULL==pPvkSignInfo)
                    break;

                SetControlFont(pPvkSignInfo->hBold, hwndDlg,IDC_WIZARD_STATIC_BOLD1);

                //initialize the Timestamp address
                //use the default if user did not supply one

                pDigitalSignInfo=(CRYPTUI_WIZ_DIGITAL_SIGN_INFO *)(pGetSignInfo->pDigitalSignInfo);

                if(pDigitalSignInfo)
                {
                    if(pDigitalSignInfo->pwszTimestampURL)
                    {
                        //set the check box for the timestamp address
                        if(hwndControl=GetDlgItem(hwndDlg, IDC_WIZARD_CHECK1))
                            SendMessage(hwndControl, BM_SETCHECK, 1, 0);

                        SetDlgItemTextU(hwndDlg, IDC_WIZARD_EDIT1,pDigitalSignInfo->pwszTimestampURL);
                    }
                 //   else
                 //       SetDlgItemTextU(hwndDlg, IDC_WIZARD_EDIT1,g_wszTimeStamp);
                }
              /*  else
                    SetDlgItemTextU(hwndDlg, IDC_WIZARD_EDIT1,g_wszTimeStamp);
                */


                if(NULL==(hwndControl=GetDlgItem(hwndDlg, IDC_WIZARD_CHECK1)))
                    break;


                //diable the window if the timestamp check is not checked
                if(TRUE==SendMessage(hwndControl, BM_GETCHECK, 0, 0))
                    EnableWindow(GetDlgItem(hwndDlg, IDC_WIZARD_EDIT1), TRUE);
                else
                    EnableWindow(GetDlgItem(hwndDlg, IDC_WIZARD_EDIT1), FALSE);
			break;

        case WM_DESTROY:
                if(NULL==(pGetSignInfo=(CRYPTUI_WIZ_GET_SIGN_PAGE_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                    break;

                //try to sign the document
                SignAtDestroy(hwndDlg, pGetSignInfo,IDD_SIGN_TIMESTAMP);

            break;

		case WM_COMMAND:
                if(HIWORD(wParam) == BN_CLICKED)
                {
                    switch (LOWORD(wParam))
                    {
                        case    IDC_WIZARD_CHECK1:
                                if(NULL==(hwndControl=GetDlgItem(hwndDlg, IDC_WIZARD_CHECK1)))
                                    break;

                                //diable the window if the timestamp check is not checked
                                if(TRUE==SendMessage(hwndControl, BM_GETCHECK, 0, 0))
                                    EnableWindow(GetDlgItem(hwndDlg, IDC_WIZARD_EDIT1), TRUE);
                                else
                                    EnableWindow(GetDlgItem(hwndDlg, IDC_WIZARD_EDIT1), FALSE);

                            break;

                        default:
                            break;

                    }
                }

			break;	
						
		case WM_NOTIFY:
    		    switch (((NMHDR FAR *) lParam)->code)
    		    {

  				    case PSN_KILLACTIVE:
                            SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
					        return TRUE;

                        break;

				    case PSN_RESET:
                            if(NULL==(pGetSignInfo=(CRYPTUI_WIZ_GET_SIGN_PAGE_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                                break;

                            if(NULL==(pPvkSignInfo=(CERT_SIGNING_INFO *)(pGetSignInfo->pvSignReserved)))
                                break;

                            //mark that the cancel bottun is clicked
                            pPvkSignInfo->fCancel=TRUE;

                            SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
					    break;

 				    case PSN_SETACTIVE:
 					    PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_NEXT|PSWIZB_BACK);
					    break;

                    case PSN_WIZBACK:
                        break;

                    case PSN_WIZNEXT:

                            if(NULL==(pGetSignInfo=(CRYPTUI_WIZ_GET_SIGN_PAGE_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                                break;

                            if(NULL==(pPvkSignInfo=(CERT_SIGNING_INFO *)(pGetSignInfo->pvSignReserved)))
                                break;

                            //free the original timestamp address
                            if(pPvkSignInfo->pwszTimeStamp)
                            {
                                WizardFree(pPvkSignInfo->pwszTimeStamp);
                                pPvkSignInfo->pwszTimeStamp=NULL;
                            }

                            //we have obtained the timestamp information from the user
                            pPvkSignInfo->fUsageTimeStamp=TRUE;

                            //get the timestamp adddress
                            if(NULL==(hwndControl=GetDlgItem(hwndDlg, IDC_WIZARD_CHECK1)))
                                break;

                            if(TRUE==SendMessage(hwndControl, BM_GETCHECK, 0, 0))
                            {
                                if(0!=(dwChar=(DWORD)SendDlgItemMessage(hwndDlg,
                                                      IDC_WIZARD_EDIT1,
                                                      WM_GETTEXTLENGTH, 0, 0)))
                                {
                                    pPvkSignInfo->pwszTimeStamp=(LPWSTR)WizardAlloc(sizeof(WCHAR)*(dwChar+1));

                                    if(NULL!=(pPvkSignInfo->pwszTimeStamp))
                                    {
                                        GetDlgItemTextU(hwndDlg, IDC_WIZARD_EDIT1,
                                                        pPvkSignInfo->pwszTimeStamp,
                                                        dwChar+1);

                                        //make sure the timestamp address is correct
                                        if(!ValidTimeStampAddress(pPvkSignInfo->pwszTimeStamp))
                                        {
                                            //ask for the timestamp address
                                            I_MessageBox(hwndDlg, IDS_INVALID_TIMESTAMP_ADDRESS,
                                                            pPvkSignInfo->idsMsgTitle,
                                                            pGetSignInfo->pwszPageTitle,
                                                            MB_ICONERROR|MB_OK|MB_APPLMODAL);

                                            //make the purpose page stay
                                            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);

                                            break;
                                        }

                                    }
                                }
                                else
                                {
                                    //ask for the timestamp address
                                    I_MessageBox(hwndDlg, IDS_NO_TIMESTAMP_ADDRESS,
                                                    pPvkSignInfo->idsMsgTitle,
                                                    pGetSignInfo->pwszPageTitle,
                                                    MB_ICONERROR|MB_OK|MB_APPLMODAL);

                                    //make the purpose page stay
                                    SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);

                                    break;
                                }
                            }

                        break;

				    default:
					    return FALSE;

    	        }
		    break;

		default:
			return FALSE;
	}

	return TRUE;
}
//-----------------------------------------------------------------------
//Completion
//-----------------------------------------------------------------------
INT_PTR APIENTRY Sign_Completion(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CRYPTUI_WIZ_GET_SIGN_PAGE_INFO         *pGetSignInfo=NULL;
    CERT_SIGNING_INFO                      *pPvkSignInfo=NULL;
    PROPSHEETPAGE                          *pPropSheet=NULL;

    HWND                    hwndControl=NULL;
    LV_COLUMNW              lvC;
    HDC                     hdc=NULL;
    COLORREF                colorRef;

	switch (msg)
	{
		case WM_INITDIALOG:

                //set the wizard information so that it can be shared
                pPropSheet = (PROPSHEETPAGE *) lParam;
                pGetSignInfo = (CRYPTUI_WIZ_GET_SIGN_PAGE_INFO *) (pPropSheet->lParam);

                if(NULL==pGetSignInfo)
                    break;

                SetWindowLongPtr(hwndDlg, DWLP_USER, (LONG_PTR)pGetSignInfo);

                //init the pPvkSignInfo if not present
                if(NULL==(pGetSignInfo->pvSignReserved))
                {
                    if(!InitPvkSignInfo((CERT_SIGNING_INFO **)(&(pGetSignInfo->pvSignReserved))))
                        break;
                }

                pPvkSignInfo=(CERT_SIGNING_INFO *)(pGetSignInfo->pvSignReserved);

                if(NULL==pPvkSignInfo)
                    break;

                SetControlFont(pPvkSignInfo->hBigBold, hwndDlg,IDC_WIZARD_STATIC_BIG_BOLD1);

                //getthe background color of the parent window
                /*
                if(hdc=GetWindowDC(hwndDlg))
                {
                    if(CLR_INVALID!=(colorRef=GetBkColor(hdc)))
                    {
                        ListView_SetBkColor(GetDlgItem(hwndDlg, IDC_WIZARD_LIST1), CLR_NONE);
                        ListView_SetTextBkColor(GetDlgItem(hwndDlg, IDC_WIZARD_LIST1), CLR_NONE);
                    }
                }    */

                //insert two columns
                hwndControl=GetDlgItem(hwndDlg, IDC_WIZARD_LIST1);

                memset(&lvC, 0, sizeof(LV_COLUMNW));

                lvC.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
                lvC.fmt = LVCFMT_LEFT;  // Left-align the column.
                lvC.cx = 20;          // Width of the column, in pixels.
                lvC.pszText = L"";   // The text for the column.
                lvC.iSubItem=0;

                if (ListView_InsertColumnU(hwndControl, 0, &lvC) == -1)
                    break;

                //2nd column is the content
                memset(&lvC, 0, sizeof(LV_COLUMNW));

                lvC.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
                lvC.fmt = LVCFMT_LEFT;  // Left-align the column.
                lvC.cx = 10; //(dwMaxSize+2)*7;          // Width of the column, in pixels.
                lvC.pszText = L"";   // The text for the column.
                lvC.iSubItem= 1;

                if (ListView_InsertColumnU(hwndControl, 1, &lvC) == -1)
                    break;

           break;
        case WM_DESTROY:
                if(NULL==(pGetSignInfo=(CRYPTUI_WIZ_GET_SIGN_PAGE_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                    break;

                //try to sign the document
                SignAtDestroy(hwndDlg, pGetSignInfo,IDD_SIGN_COMPLETION);

            break;

		case WM_COMMAND:
			break;	
						
		case WM_NOTIFY:
    		    switch (((NMHDR FAR *) lParam)->code)
    		    {

  				    case PSN_KILLACTIVE:
                            SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
					        return TRUE;

                        break;

				    case PSN_RESET:
                            if(NULL==(pGetSignInfo=(CRYPTUI_WIZ_GET_SIGN_PAGE_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                                break;

                            if(NULL==(pPvkSignInfo=(CERT_SIGNING_INFO *)(pGetSignInfo->pvSignReserved)))
                                break;

                            //mark that the cancel bottun is clicked
                            pPvkSignInfo->fCancel=TRUE;

                            SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
					    break;

 				    case PSN_SETACTIVE:
 					        PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK|PSWIZB_FINISH);

                            if(NULL==(pGetSignInfo=(CRYPTUI_WIZ_GET_SIGN_PAGE_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                                break;

                            //populate the list box in the order of friendly name,
                            //UserName, CA, Purpose, and CSP
                            //Get the window handle for the CSP list
                            if(hwndControl=GetDlgItem(hwndDlg, IDC_WIZARD_LIST1))
                                DisplayConfirmation(hwndControl, pGetSignInfo);

					    break;

                    case PSN_WIZBACK:
                        break;

                    case PSN_WIZFINISH:
                            if(NULL==(pGetSignInfo=(CRYPTUI_WIZ_GET_SIGN_PAGE_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                                break;

                            if(NULL==(pPvkSignInfo=(CERT_SIGNING_INFO *)(pGetSignInfo->pvSignReserved)))
                                break;

                            //mark that the cancel bottun is NOT clicked
                            pPvkSignInfo->fCancel=FALSE;
                        break;

				    default:
					    return FALSE;

    	        }
		    break;

		default:

			    return FALSE;
	}

	return TRUE;
}

//***************************************************************************************
//
//   The APIs for the signing wizard
//
//**************************************************************************************
//-----------------------------------------------------------------------
//  CheckDigitalSignInfo
//
//-----------------------------------------------------------------------
BOOL    CheckDigitalSignInfo(CRYPTUI_WIZ_DIGITAL_SIGN_INFO *pDigitalSignInfo)
{
    if(!pDigitalSignInfo)
        return FALSE;

    if(pDigitalSignInfo->dwSize != sizeof(CRYPTUI_WIZ_DIGITAL_SIGN_INFO))
        return FALSE;

    switch(pDigitalSignInfo->dwSubjectChoice)
    {
        case CRYPTUI_WIZ_DIGITAL_SIGN_SUBJECT_FILE:
                if(NULL == pDigitalSignInfo->pwszFileName)
                    return FALSE;
            break;

        case CRYPTUI_WIZ_DIGITAL_SIGN_SUBJECT_BLOB:
                if(NULL== pDigitalSignInfo->pSignBlobInfo)
                    return FALSE;

                if(pDigitalSignInfo->pSignBlobInfo->dwSize != sizeof(CRYPTUI_WIZ_DIGITAL_SIGN_BLOB_INFO))
                    return FALSE;
            break;
        case 0:
            break;
        default:
                    return FALSE;
            break;
    }

    switch(pDigitalSignInfo->dwSigningCertChoice)
    {
        case    CRYPTUI_WIZ_DIGITAL_SIGN_CERT:
                if(NULL==pDigitalSignInfo->pSigningCertContext)
                    return FALSE;
            break;

        case    CRYPTUI_WIZ_DIGITAL_SIGN_STORE:
                if(NULL==pDigitalSignInfo->pSigningCertStore)
                    return FALSE;
            break;
        case    CRYPTUI_WIZ_DIGITAL_SIGN_PVK:
                if(NULL==pDigitalSignInfo->pSigningCertPvkInfo)
                    return FALSE;
            break;

        case 0:
            break;
        default:
                    return FALSE;
            break;
    }

    return TRUE;

}

//-----------------------------------------------------------------------
//  The call back functions for the GetPages
//
//-----------------------------------------------------------------------
UINT
CALLBACK
GetSignPageCallback(
                HWND                hWnd,
                UINT                uMsg,
                LPPROPSHEETPAGEW    ppsp)
{
    PCRYPTUI_WIZ_GET_SIGN_PAGE_INFO  pGetSignInfo = (PCRYPTUI_WIZ_GET_SIGN_PAGE_INFO)(ppsp->lParam);

    if (pGetSignInfo->pPropPageCallback != NULL)
    {
        (*(pGetSignInfo->pPropPageCallback))(hWnd, uMsg, pGetSignInfo->pvCallbackData);
    }


    return TRUE;
}
//-----------------------------------------------------------------------
//
// CryptUIWizDigitalSign
//
//  The wizard to digitally sign a document or a BLOB.
//
//  If CRYPTUI_WIZ_NO_UI is set in dwFlags, no UI will be shown.  Otherwise,
//  User will be prompted for input through a wizard.
//
//  dwFlags:            IN  Required:
//  hwndParnet:         IN  Optional:   The parent window handle
//  pwszWizardTitle:    IN  Optional:   The title of the wizard
//                                      If NULL, the default will be IDS_DIGITAL_SIGN_WIZARD_TITLE
//  pDigitalSignInfo:   IN  Required:   The information about the signing process
//  ppSignContext       OUT Optional:   The context pointer points to the signed BLOB
//------------------------------------------------------------------------
BOOL
WINAPI
CryptUIWizDigitalSign(
     IN                 DWORD                               dwFlags,
     IN     OPTIONAL    HWND                                hwndParent,
     IN     OPTIONAL    LPCWSTR                             pwszWizardTitle,
     IN                 PCCRYPTUI_WIZ_DIGITAL_SIGN_INFO     pDigitalSignInfo,
     OUT    OPTIONAL    PCCRYPTUI_WIZ_DIGITAL_SIGN_CONTEXT  *ppSignContext)
{
    BOOL                            fResult=FALSE;
    UINT                            idsText=IDS_SIGN_FAIL_INIT;
    CRYPTUI_WIZ_GET_SIGN_PAGE_INFO  GetPageInfo;
    DWORD                           dwPages=0;
    PROPSHEETHEADERW                signHeader;
    WCHAR                           wszTitle[MAX_TITLE_LENGTH];
    BOOL                            fFreePvkSigningInfo=TRUE;

    PROPSHEETPAGEW                  *pwPages=NULL;
    CERT_SIGNING_INFO               *pPvkSigningInfo=NULL;
    INT_PTR                         iReturn=-1;

    //memset
    memset(&GetPageInfo,        0, sizeof(CRYPTUI_WIZ_GET_SIGN_PAGE_INFO));
    memset(&signHeader,         0, sizeof(PROPSHEETHEADERW));

    //check the input parameters
    if(!pDigitalSignInfo)
        goto InvalidArgErr;

    if(!CheckDigitalSignInfo((CRYPTUI_WIZ_DIGITAL_SIGN_INFO *)pDigitalSignInfo))
        goto InvalidArgErr;

    if(ppSignContext)
        *ppSignContext=NULL;

    //allocation memory for private information
    pPvkSigningInfo=(CERT_SIGNING_INFO *)WizardAlloc(sizeof(CERT_SIGNING_INFO));

    if(NULL==pPvkSigningInfo)
        goto MemoryErr;

    //memset
    memset(pPvkSigningInfo, 0, sizeof(CERT_SIGNING_INFO));

    //set up the get page information
    GetPageInfo.dwSize=sizeof(CRYPTUI_WIZ_GET_SIGN_PAGE_INFO);

    GetPageInfo.dwPageChoice=CRYPTUI_WIZ_DIGITAL_SIGN_ALL_SIGNING_OPTION_PAGES |
                             CRYPTUI_WIZ_DIGITAL_SIGN_WELCOME_PAGE |
                             CRYPTUI_WIZ_DIGITAL_SIGN_CONFIRMATION_PAGE;

    //include the fileName to sign if user does not want to sign a BLOB
    if(pDigitalSignInfo->dwSubjectChoice != CRYPTUI_WIZ_DIGITAL_SIGN_SUBJECT_BLOB)
       GetPageInfo.dwPageChoice |= CRYPTUI_WIZ_DIGITAL_SIGN_FILE_NAME_PAGE;

    GetPageInfo.hwndParent=hwndParent;
    GetPageInfo.pwszPageTitle=(LPWSTR)pwszWizardTitle;
    GetPageInfo.pDigitalSignInfo=pDigitalSignInfo;
    GetPageInfo.pvSignReserved=pPvkSigningInfo;

    //set up the private signing information
    pPvkSigningInfo->dwFlags=dwFlags;
    pPvkSigningInfo->fFree=FALSE;
    pPvkSigningInfo->idsMsgTitle=IDS_SIGN_CONFIRM_TITLE;

    //set up the fonts
    if(!SetupFonts(g_hmodThisDll,
               NULL,
               &(pPvkSigningInfo->hBigBold),
               &(pPvkSigningInfo->hBold)))
        goto TraceErr;

    //check if we need to do the UI
    if(0==(dwFlags & CRYPTUI_WIZ_NO_UI))
    {
        //init the wizard
        if(!WizardInit())
            goto TraceErr;

        //get the signing pages and get the common  private information
        if(!CryptUIWizGetDigitalSignPages(
                &GetPageInfo,
                &pwPages,
                &dwPages))
            goto TraceErr;


        //set up the header information
        signHeader.dwSize=sizeof(signHeader);
        signHeader.dwFlags=PSH_PROPSHEETPAGE | PSH_WIZARD | PSH_NOAPPLYNOW;
        signHeader.hwndParent=hwndParent;
        signHeader.hInstance=g_hmodThisDll;


        if(pwszWizardTitle)
            signHeader.pszCaption=pwszWizardTitle;
        else
        {
            if(LoadStringU(g_hmodThisDll, IDS_SIGNING_WIZARD_TITLE, wszTitle, sizeof(wszTitle)/sizeof(wszTitle[0])))
                signHeader.pszCaption=wszTitle;
        }

        signHeader.nPages=dwPages;
        signHeader.nStartPage=0;
        signHeader.ppsp=pwPages;

        //create the wizard
        iReturn=PropertySheetU(&signHeader);

        if(-1 == iReturn)
            goto TraceErr;

        if(0 == iReturn)
        {
            //mark that we do not free the pPvkSigningInfo any more
            fFreePvkSigningInfo=FALSE;

            //the wizard is cancelled
            fResult=TRUE;
            idsText=0;
            goto CommonReturn;
        }
    }
    else
    {
        I_SigningWizard(&GetPageInfo);
    }

    //mark that we do not free the pPvkSigningInfo any more
    fFreePvkSigningInfo=FALSE;

    //get the signing result
    fResult=GetPageInfo.fResult;
    idsText=((CERT_SIGNING_INFO *)(GetPageInfo.pvSignReserved))->idsText;

    if(!fResult)
        goto WizardErr;

    idsText=IDS_SIGNING_SUCCEEDED;

    fResult=TRUE;

CommonReturn:

    //free the memory
    if(GetPageInfo.pSignContext)
    {
        if(ppSignContext)
            *ppSignContext=GetPageInfo.pSignContext;
        else
            CryptUIWizFreeDigitalSignContext(GetPageInfo.pSignContext);
    }

    if(pwPages)
        CryptUIWizFreeDigitalSignPages(pwPages, dwPages);

    //pop up the confirmation box for failure if UI is required
    if(idsText && (((dwFlags & CRYPTUI_WIZ_NO_UI) == 0)) )
    {
         if(idsText == IDS_SIGNING_SUCCEEDED)
         {
             //set the message of inable to gather enough info for PKCS10
             I_MessageBox(hwndParent, idsText, IDS_SIGN_CONFIRM_TITLE,
                            pwszWizardTitle, MB_OK|MB_ICONINFORMATION);
         }
         else
             I_MessageBox(hwndParent, idsText, IDS_SIGN_CONFIRM_TITLE,
                            pwszWizardTitle, MB_OK|MB_ICONERROR);

    }

    if(pPvkSigningInfo)
        FreePvkCertSigningInfo(pPvkSigningInfo);


    return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
TRACE_ERROR(TraceErr);
SET_ERROR(WizardErr,GetPageInfo.dwError);
SET_ERROR(MemoryErr,    E_OUTOFMEMORY);
}


//-----------------------------------------------------------------------
//
//   CryptUIWizFreeDigitalSignContext
//-----------------------------------------------------------------------
BOOL
WINAPI
CryptUIWizFreeDigitalSignContext(
     IN  PCCRYPTUI_WIZ_DIGITAL_SIGN_CONTEXT   pSignContext)
{
    BOOL    fResult=TRUE;

    __try {
        SignerFreeSignerContext((SIGNER_CONTEXT *)pSignContext);
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        SetLastError(GetExceptionCode());
        fResult=FALSE;
    }
    return fResult;
}

//-----------------------------------------------------------------------
//
// CryptUIWizGetDigitalSignPages
//
//  Get specific wizard pages from the CryptUIWizDigitalSign wizard.
//  Application can include the pages to other wizards.  The pages will
//  gather user inputs throught the new "Parent" wizard.
//  After user clicks the finish buttion, signing process will start the signing
//  and return the result in fResult and dwError field of CRYPTUI_WIZ_SIGN_GET_PAGE_INFO
//  struct.  If not enough information can be gathered through the wizard pages,
//  user should supply addtional information in pSignGetPageInfo.
//
//
// pSignGetPageInfo    IN   Required:   The struct that user allocate.   It can be used
//                                      to supply additinal information which is not gathered
//                                      from the selected wizard pages
// prghPropPages,      OUT  Required:   The wizard pages returned.  Please
//                                      notice the pszTitle of the struct is set to NULL
// pcPropPages         OUT  Required:   The number of wizard pages returned
//------------------------------------------------------------------------
BOOL
WINAPI
CryptUIWizGetDigitalSignPages(
     IN     PCRYPTUI_WIZ_GET_SIGN_PAGE_INFO     pSignGetPageInfo,
     OUT    PROPSHEETPAGEW                      **prghPropPages,
     OUT    DWORD                               *pcPropPages)
{

    BOOL                        fResult=FALSE;
    DWORD                       dwPageCount=0;
    DWORD                       dwIndex=0;
    DWORD                       dwLastSignID=0;


    PROPSHEETPAGEW              *pwPages=NULL;

    //check the input parameters
    if(!pSignGetPageInfo || !prghPropPages || !pcPropPages)
        goto InvalidArgErr;

    if(pSignGetPageInfo->dwSize != sizeof(CRYPTUI_WIZ_GET_SIGN_PAGE_INFO))
        goto InvalidArgErr;

    if(pSignGetPageInfo->pDigitalSignInfo)
    {
        if(!CheckDigitalSignInfo((CRYPTUI_WIZ_DIGITAL_SIGN_INFO *)(pSignGetPageInfo->pDigitalSignInfo)))
            goto InvalidArgErr;
    }


    //init
    *prghPropPages=NULL;
    *pcPropPages=0;

    //allocate memory for enough pages
    pwPages=(PROPSHEETPAGEW *)WizardAlloc(sizeof(PROPSHEETPAGEW) * SIGN_PROP_SHEET);

    if(NULL==pwPages)
        goto MemoryErr;

    //memset
    memset(pwPages, 0, sizeof(PROPSHEETPAGEW) * SIGN_PROP_SHEET);

    //setup the basic common elements
    for(dwIndex=0; dwIndex <SIGN_PROP_SHEET; dwIndex++)
    {
        pwPages[dwIndex].dwSize=sizeof(pwPages[dwIndex]);
        pwPages[dwIndex].dwFlags=PSP_USECALLBACK;

        if(pSignGetPageInfo->pwszPageTitle)
            pwPages[dwIndex].dwFlags |=PSP_USETITLE;

        pwPages[dwIndex].hInstance=g_hmodThisDll;
        pwPages[dwIndex].pszTitle=pSignGetPageInfo->pwszPageTitle;
        pwPages[dwIndex].lParam=(LPARAM)pSignGetPageInfo;
        pwPages[dwIndex].pfnCallback=GetSignPageCallback;
    }

    //get the pages based on requirement
    //make sure  one, and only one of the signing option pages are selected
    dwIndex=0;

    if(CRYPTUI_WIZ_DIGITAL_SIGN_MINIMAL_SIGNING_OPTION_PAGES & (pSignGetPageInfo->dwPageChoice))
       dwIndex++;

    if(CRYPTUI_WIZ_DIGITAL_SIGN_TYPICAL_SIGNING_OPTION_PAGES & (pSignGetPageInfo->dwPageChoice))
       dwIndex++;

    if(CRYPTUI_WIZ_DIGITAL_SIGN_CUSTOM_SIGNING_OPTION_PAGES & (pSignGetPageInfo->dwPageChoice))
       dwIndex++;

    if(CRYPTUI_WIZ_DIGITAL_SIGN_ALL_SIGNING_OPTION_PAGES & (pSignGetPageInfo->dwPageChoice))
       dwIndex++;

    if(dwIndex != 1)
        goto InvalidArgErr;

    //welcome pages
    if(CRYPTUI_WIZ_DIGITAL_SIGN_WELCOME_PAGE & (pSignGetPageInfo->dwPageChoice))
    {
        pwPages[dwPageCount].pszTemplate=(LPCWSTR)MAKEINTRESOURCE(IDD_SIGN_WELCOME);
        pwPages[dwPageCount].pfnDlgProc=Sign_Welcome;
        dwPageCount++;


        dwLastSignID=IDD_SIGN_WELCOME;

    }

    //file page
    if(CRYPTUI_WIZ_DIGITAL_SIGN_FILE_NAME_PAGE & (pSignGetPageInfo->dwPageChoice))
    {
        //dwPageCount can not be more than the max
        if(dwPageCount >= SIGN_PROP_SHEET)
            goto InvalidArgErr;
        //file name page
        pwPages[dwPageCount].pszTemplate=(LPCWSTR)MAKEINTRESOURCE(IDD_SIGN_FILE_NAME);
        pwPages[dwPageCount].pfnDlgProc=Sign_FileName;
        dwPageCount++;


        dwLastSignID=IDD_SIGN_FILE_NAME;

    }


    //Minimal Signing
    if(CRYPTUI_WIZ_DIGITAL_SIGN_MINIMAL_SIGNING_OPTION_PAGES & (pSignGetPageInfo->dwPageChoice))
    {
        //dwPageCount can not be more than the max
        if(dwPageCount >= SIGN_PROP_SHEET)
            goto InvalidArgErr;
        //signing cert page
        pwPages[dwPageCount].pszTemplate=(LPCWSTR)MAKEINTRESOURCE(IDD_SIGN_CERT);
        pwPages[dwPageCount].pfnDlgProc=Sign_Cert;
        dwPageCount++;


        //dwPageCount can not be more than the max
        if(dwPageCount >= SIGN_PROP_SHEET)
            goto InvalidArgErr;
        //timestamp page
        pwPages[dwPageCount].pszTemplate=(LPCWSTR)MAKEINTRESOURCE(IDD_SIGN_TIMESTAMP);
        pwPages[dwPageCount].pfnDlgProc=Sign_TimeStamp;
        dwPageCount++;


        dwLastSignID=IDD_SIGN_TIMESTAMP;

    }

    //typical signing
    if(CRYPTUI_WIZ_DIGITAL_SIGN_TYPICAL_SIGNING_OPTION_PAGES & (pSignGetPageInfo->dwPageChoice))
    {
        //dwPageCount can not be more than the max
        if(dwPageCount >= SIGN_PROP_SHEET)
            goto InvalidArgErr;
        //signing cert page
        pwPages[dwPageCount].pszTemplate=(LPCWSTR)MAKEINTRESOURCE(IDD_SIGN_CERT);
        pwPages[dwPageCount].pfnDlgProc=Sign_Cert;
        dwPageCount++;



        //dwPageCount can not be more than the max
        if(dwPageCount >= SIGN_PROP_SHEET)
            goto InvalidArgErr;
        //description page
        pwPages[dwPageCount].pszTemplate=(LPCWSTR)MAKEINTRESOURCE(IDD_SIGN_DESCRIPTION);
        pwPages[dwPageCount].pfnDlgProc=Sign_Description;
        dwPageCount++;



        //dwPageCount can not be more than the max
        if(dwPageCount >= SIGN_PROP_SHEET)
            goto InvalidArgErr;
        //timestamp page
        pwPages[dwPageCount].pszTemplate=(LPCWSTR)MAKEINTRESOURCE(IDD_SIGN_TIMESTAMP);
        pwPages[dwPageCount].pfnDlgProc=Sign_TimeStamp;
        dwPageCount++;


        dwLastSignID=IDD_SIGN_TIMESTAMP;

    }


    //custom signing
    if(CRYPTUI_WIZ_DIGITAL_SIGN_CUSTOM_SIGNING_OPTION_PAGES & (pSignGetPageInfo->dwPageChoice))
    {
        //dwPageCount can not be more than the max
        if(dwPageCount >= SIGN_PROP_SHEET)
            goto InvalidArgErr;
        //signing cert page
        pwPages[dwPageCount].pszTemplate=(LPCWSTR)MAKEINTRESOURCE(IDD_SIGN_CERT);
        pwPages[dwPageCount].pfnDlgProc=Sign_Cert;
        dwPageCount++;



        //dwPageCount can not be more than the max
        if(dwPageCount >= SIGN_PROP_SHEET)
            goto InvalidArgErr;
        //private key page
        pwPages[dwPageCount].pszTemplate=(LPCWSTR)MAKEINTRESOURCE(IDD_SIGN_PVK);
        pwPages[dwPageCount].pfnDlgProc=Sign_PVK;
        dwPageCount++;



        //dwPageCount can not be more than the max
        if(dwPageCount >= SIGN_PROP_SHEET)
            goto InvalidArgErr;
        //hash algorithm page
        pwPages[dwPageCount].pszTemplate=(LPCWSTR)MAKEINTRESOURCE(IDD_SIGN_HASH);
        pwPages[dwPageCount].pfnDlgProc=Sign_Hash;
        dwPageCount++;




        //dwPageCount can not be more than the max
        if(dwPageCount >= SIGN_PROP_SHEET)
            goto InvalidArgErr;
        //cert chain page
        pwPages[dwPageCount].pszTemplate=(LPCWSTR)MAKEINTRESOURCE(IDD_SIGN_CHAIN);
        pwPages[dwPageCount].pfnDlgProc=Sign_Chain;
        dwPageCount++;




        //dwPageCount can not be more than the max
        if(dwPageCount >= SIGN_PROP_SHEET)
            goto InvalidArgErr;
        //description page
        pwPages[dwPageCount].pszTemplate=(LPCWSTR)MAKEINTRESOURCE(IDD_SIGN_DESCRIPTION);
        pwPages[dwPageCount].pfnDlgProc=Sign_Description;
        dwPageCount++;




        //dwPageCount can not be more than the max
        if(dwPageCount >= SIGN_PROP_SHEET)
            goto InvalidArgErr;
        //timestamp page
        pwPages[dwPageCount].pszTemplate=(LPCWSTR)MAKEINTRESOURCE(IDD_SIGN_TIMESTAMP);
        pwPages[dwPageCount].pfnDlgProc=Sign_TimeStamp;
        dwPageCount++;



        dwLastSignID=IDD_SIGN_TIMESTAMP;

    }


    //all signing
    //all signing option is the same with custom signing, except for the option page
    if(CRYPTUI_WIZ_DIGITAL_SIGN_ALL_SIGNING_OPTION_PAGES & (pSignGetPageInfo->dwPageChoice))
    {
        //dwPageCount can not be more than the max
        if(dwPageCount >= SIGN_PROP_SHEET)
            goto InvalidArgErr;
        //signing cert page
        pwPages[dwPageCount].pszTemplate=(LPCWSTR)MAKEINTRESOURCE(IDD_SIGN_OPTION);
        pwPages[dwPageCount].pfnDlgProc=Sign_Option;
        dwPageCount++;




        //dwPageCount can not be more than the max
        if(dwPageCount >= SIGN_PROP_SHEET)
            goto InvalidArgErr;
        //signing cert page
        pwPages[dwPageCount].pszTemplate=(LPCWSTR)MAKEINTRESOURCE(IDD_SIGN_CERT);
        pwPages[dwPageCount].pfnDlgProc=Sign_Cert;
        dwPageCount++;



        //dwPageCount can not be more than the max
        if(dwPageCount >= SIGN_PROP_SHEET)
            goto InvalidArgErr;
        //private key page
        pwPages[dwPageCount].pszTemplate=(LPCWSTR)MAKEINTRESOURCE(IDD_SIGN_PVK);
        pwPages[dwPageCount].pfnDlgProc=Sign_PVK;
        dwPageCount++;



        //dwPageCount can not be more than the max
        if(dwPageCount >= SIGN_PROP_SHEET)
            goto InvalidArgErr;
        //hash algorithm page
        pwPages[dwPageCount].pszTemplate=(LPCWSTR)MAKEINTRESOURCE(IDD_SIGN_HASH);
        pwPages[dwPageCount].pfnDlgProc=Sign_Hash;
        dwPageCount++;




        //dwPageCount can not be more than the max
        if(dwPageCount >= SIGN_PROP_SHEET)
            goto InvalidArgErr;
        //cert chain page
        pwPages[dwPageCount].pszTemplate=(LPCWSTR)MAKEINTRESOURCE(IDD_SIGN_CHAIN);
        pwPages[dwPageCount].pfnDlgProc=Sign_Chain;
        dwPageCount++;




        //dwPageCount can not be more than the max
        if(dwPageCount >= SIGN_PROP_SHEET)
            goto InvalidArgErr;
        //description page
        pwPages[dwPageCount].pszTemplate=(LPCWSTR)MAKEINTRESOURCE(IDD_SIGN_DESCRIPTION);
        pwPages[dwPageCount].pfnDlgProc=Sign_Description;
        dwPageCount++;




        //dwPageCount can not be more than the max
        if(dwPageCount >= SIGN_PROP_SHEET)
            goto InvalidArgErr;
        //timestamp page
        pwPages[dwPageCount].pszTemplate=(LPCWSTR)MAKEINTRESOURCE(IDD_SIGN_TIMESTAMP);
        pwPages[dwPageCount].pfnDlgProc=Sign_TimeStamp;
        dwPageCount++;



        dwLastSignID=IDD_SIGN_TIMESTAMP;
    }



    //completion page
    if(CRYPTUI_WIZ_DIGITAL_SIGN_CONFIRMATION_PAGE & (pSignGetPageInfo->dwPageChoice))
    {

        //dwPageCount can not be more than the max
        if(dwPageCount >= SIGN_PROP_SHEET)
            goto InvalidArgErr;

        //timestamp page
        pwPages[dwPageCount].pszTemplate=(LPCWSTR)MAKEINTRESOURCE(IDD_SIGN_COMPLETION);
        pwPages[dwPageCount].pfnDlgProc=Sign_Completion;

        dwLastSignID=IDD_SIGN_COMPLETION;

        dwPageCount++;
    }


    //set up the private information
    pSignGetPageInfo->dwReserved=dwLastSignID;

    fResult=TRUE;

CommonReturn:

    //return the pages
    if(TRUE==fResult)
    {
        *pcPropPages=(dwPageCount);

        *prghPropPages=pwPages;
    }
    else
    {
       CryptUIWizFreeDigitalSignPages(pwPages, dwPageCount+1);
    }

    return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
SET_ERROR(MemoryErr,     E_OUTOFMEMORY);
}



//-----------------------------------------------------------------------
//
//   CryptUIWizFreeDigitalSignPages
//-----------------------------------------------------------------------
BOOL
WINAPI
CryptUIWizFreeDigitalSignPages(
            IN PROPSHEETPAGEW    *rghPropPages,
            IN DWORD             cPropPages)
{
    WizardFree(rghPropPages);

    return TRUE;
}


//-----------------------------------------------------------------------
//
//  I_SigningWizard
//-----------------------------------------------------------------------
BOOL    I_SigningWizard(PCRYPTUI_WIZ_GET_SIGN_PAGE_INFO     pSignGetPageInfo)
{
    BOOL                                fResult=FALSE;
    HRESULT                             hr=E_FAIL;
    UINT                                idsText=IDS_SIGN_INVALID_ARG;
    CRYPTUI_WIZ_DIGITAL_SIGN_INFO       *pDigitalSignInfo=NULL;
    CRYPTUI_WIZ_DIGITAL_SIGN_EXTENDED_INFO  *pExtInfo=NULL;
    CERT_SIGNING_INFO                   *pPvkSignInfo=NULL;
    LPWSTR                              pwszTimeStamp=NULL;
    DWORD                               dwSignerIndex=0;
    BOOL                                fFreeSignerBlob=FALSE;
    PCCRYPT_OID_INFO                     pOIDInfo=NULL;
    CRYPTUI_WIZ_DIGITAL_SIGN_PVK_FILE_INFO  *pPvkFileInfo=NULL;
    PCRYPT_KEY_PROV_INFO                pProvInfo=NULL;
    CRYPT_KEY_PROV_INFO                 KeyProvInfo;
    DWORD                               cbSize=0;
	CRYPT_DATA_BLOB			            dataBlob;
    DWORD                               dwCertPolicy=0;
    HCERTSTORE                          hAddCertStore=0;
    DWORD                               dwException=0;


    SIGNER_SUBJECT_INFO                 SignerSubjectInfo;
    SIGNER_FILE_INFO                    SignerFileInfo;
    SIGNER_BLOB_INFO                    SignerBlobInfo;
    SIGNER_CERT                         SignerCert;
    SIGNER_PROVIDER_INFO                SignerProviderInfo;
    SIGNER_CERT_STORE_INFO              SignerCertStoreInfo;
    SIGNER_SPC_CHAIN_INFO               SignerSpcChainInfo;
    SIGNER_SIGNATURE_INFO               SignerSignatureInfo;
    SIGNER_ATTR_AUTHCODE                SignerAttrAuthcode;



    SIGNER_CONTEXT                  *pSignerContext=NULL;
    PCRYPT_KEY_PROV_INFO            pOldProvInfo=NULL;
    LPWSTR                          pwszPvkFileProperty=NULL;
    BYTE                            *pOldPvkFileProperty=NULL;
    LPWSTR                          pwszOIDName=NULL;

    //check the input parameters
    if(!pSignGetPageInfo)
        goto InvalidArgErr;

    if(pSignGetPageInfo->dwSize != sizeof(CRYPTUI_WIZ_GET_SIGN_PAGE_INFO))
        goto InvalidArgErr;

    pPvkSignInfo=(CERT_SIGNING_INFO *)(pSignGetPageInfo->pvSignReserved);

    if(NULL==pPvkSignInfo)
        goto InvalidArgErr;

    //pDigitalSignInfo can be NULL
    pDigitalSignInfo=(CRYPTUI_WIZ_DIGITAL_SIGN_INFO *)(pSignGetPageInfo->pDigitalSignInfo);

    if(pDigitalSignInfo)
        pExtInfo=(CRYPTUI_WIZ_DIGITAL_SIGN_EXTENDED_INFO *)(pDigitalSignInfo->pSignExtInfo);

    //memset
    memset(&dataBlob, 0, sizeof(CRYPT_DATA_BLOB));

    memset(&SignerSubjectInfo, 0, sizeof(SIGNER_SUBJECT_INFO));
    SignerSubjectInfo.cbSize=sizeof(SIGNER_SUBJECT_INFO);

    memset(&SignerFileInfo, 0, sizeof(SIGNER_FILE_INFO));
    SignerFileInfo.cbSize=sizeof(SIGNER_FILE_INFO);

    memset(&SignerBlobInfo, 0, sizeof(SIGNER_BLOB_INFO));
    SignerBlobInfo.cbSize=sizeof(SIGNER_BLOB_INFO);

    memset(&SignerCert, 0, sizeof(SIGNER_CERT));
    SignerCert.cbSize=sizeof(SIGNER_CERT);

    memset(&SignerProviderInfo, 0, sizeof(SIGNER_PROVIDER_INFO));
    SignerProviderInfo.cbSize=sizeof(SIGNER_PROVIDER_INFO);

    memset(&SignerCertStoreInfo, 0,sizeof(SIGNER_CERT_STORE_INFO));
    SignerCertStoreInfo.cbSize=sizeof(SIGNER_CERT_STORE_INFO);

    memset(&SignerSpcChainInfo, 0, sizeof(SIGNER_SPC_CHAIN_INFO));
    SignerSpcChainInfo.cbSize=sizeof(SIGNER_SPC_CHAIN_INFO);

    memset(&SignerSignatureInfo, 0,sizeof(SIGNER_SIGNATURE_INFO));
    SignerSignatureInfo.cbSize=sizeof(SIGNER_SIGNATURE_INFO);

    memset(&SignerAttrAuthcode, 0, sizeof(SIGNER_ATTR_AUTHCODE));
    SignerAttrAuthcode.cbSize=sizeof(SIGNER_ATTR_AUTHCODE);

    //do the signing.  Notice pDigitalSignInfo can be NULL

    //set up SignerSubjectInfo struct
    if(pPvkSignInfo->pwszFileName)
    {
        SignerSubjectInfo.pdwIndex=&dwSignerIndex;
        SignerSubjectInfo.dwSubjectChoice=SIGNER_SUBJECT_FILE;
        SignerSubjectInfo.pSignerFileInfo=&SignerFileInfo;

        SignerFileInfo.pwszFileName=pPvkSignInfo->pwszFileName;
    }
    else
    {
        if(NULL == pDigitalSignInfo)
            goto InvalidArgErr;

        switch(pDigitalSignInfo->dwSubjectChoice)
        {
            case CRYPTUI_WIZ_DIGITAL_SIGN_SUBJECT_FILE:
                    SignerSubjectInfo.pdwIndex=&dwSignerIndex;
                    SignerSubjectInfo.dwSubjectChoice=SIGNER_SUBJECT_FILE;
                    SignerSubjectInfo.pSignerFileInfo=&SignerFileInfo;

                    SignerFileInfo.pwszFileName=pDigitalSignInfo->pwszFileName;
                break;

            case CRYPTUI_WIZ_DIGITAL_SIGN_SUBJECT_BLOB:
                    SignerSubjectInfo.pdwIndex=&dwSignerIndex;
                    SignerSubjectInfo.dwSubjectChoice=SIGNER_SUBJECT_BLOB;
                    SignerSubjectInfo.pSignerBlobInfo=&SignerBlobInfo;

                    SignerBlobInfo.pGuidSubject=pDigitalSignInfo->pSignBlobInfo->pGuidSubject;
                    SignerBlobInfo.cbBlob=pDigitalSignInfo->pSignBlobInfo->cbBlob;
                    SignerBlobInfo.pbBlob=pDigitalSignInfo->pSignBlobInfo->pbBlob;
                    SignerBlobInfo.pwszDisplayName=pDigitalSignInfo->pSignBlobInfo->pwszDisplayName;

                break;
            default:
                    goto InvalidArgErr;
                break;
        }

    }

    //set up the dwCertPolicy and hCertStore for the certificate chain
    //in SignerCertStoreInfo  and SignerSpcChainInfo
    if(pPvkSignInfo->fUsageChain)
    {

        switch(pPvkSignInfo->dwChainOption)
        {
            case    SIGN_PVK_CHAIN_ROOT:
                    dwCertPolicy=SIGNER_CERT_POLICY_CHAIN;
                break;
            case    SIGN_PVK_CHAIN_NO_ROOT:
                    dwCertPolicy=SIGNER_CERT_POLICY_CHAIN_NO_ROOT;
                break;
            case    SIGN_PVK_NO_CHAIN:
            default:
                break;
        }


        switch(pPvkSignInfo->dwAddOption)
        {

            case    SIGN_PVK_ADD_FILE:
                        dwCertPolicy |= SIGNER_CERT_POLICY_STORE;
                        hAddCertStore=pPvkSignInfo->hAddFileCertStore;
                break;
            case    SIGN_PVK_ADD_STORE:
                        dwCertPolicy |= SIGNER_CERT_POLICY_STORE;
                        hAddCertStore=pPvkSignInfo->hAddStoreCertStore;
                break;
            case    SIGN_PVK_NO_ADD:
            default:
                break;
        }



    }
    //UILess mode  or typical and minimal signing pages are used
    else
    {
        if(pDigitalSignInfo)
        {
            if(pPvkSignInfo->fUseOption && (!pPvkSignInfo->fCustom))
                //we include the whole chain in the case of typical or minimal signing base
                dwCertPolicy=SIGNER_CERT_POLICY_CHAIN;
            else
            {
               //UIless mode
                switch(pDigitalSignInfo->dwAdditionalCertChoice)
                {
                    case CRYPTUI_WIZ_DIGITAL_SIGN_ADD_CHAIN:
                            dwCertPolicy=SIGNER_CERT_POLICY_CHAIN;
                        break;

                    case CRYPTUI_WIZ_DIGITAL_SIGN_ADD_CHAIN_NO_ROOT:
                            dwCertPolicy=SIGNER_CERT_POLICY_CHAIN_NO_ROOT;
                        break;

                    default:
                        break;
                }

                if(pExtInfo)
                {
                    if(pExtInfo->hAdditionalCertStore)
                    {
                        dwCertPolicy |= SIGNER_CERT_POLICY_STORE;
                        hAddCertStore=pExtInfo->hAdditionalCertStore;
                    }

                }
            }

        }
        else
        {
            //we include the whole chain in the case of typical or minimal signing base
            dwCertPolicy=SIGNER_CERT_POLICY_CHAIN;
        }
    }


    //set up SignerCert and SignerCertStoreInfo, SignerProviderInfo, SignerSpcChainInfo
    if(pPvkSignInfo->fUseSignCert)
    {
        //if the signing cert page is shown, we have only two possibilies:
        // 1. The typical(minimal) signing with the signing cert, no private key information
        // 2. The custom signing with both the signing cert and private key information
        if(FALSE == pPvkSignInfo->fUsePvkPage)
        {
            SignerCert.dwCertChoice=SIGNER_CERT_STORE;
            SignerCert.pCertStoreInfo=&SignerCertStoreInfo;
            SignerCert.hwnd= pSignGetPageInfo->hwndParent;

            //set up SignerCertStoreInfo
            if(pPvkSignInfo->pSignCert)
                SignerCertStoreInfo.pSigningCert=pPvkSignInfo->pSignCert;
            else
                goto InvalidArgErr;

            SignerCertStoreInfo.dwCertPolicy=dwCertPolicy;
            SignerCertStoreInfo.hCertStore=hAddCertStore;
        }
        else
        {
            //now, we have both the SPC file, signing cert, and private key information
            if(pPvkSignInfo->fSignCert)
            {
                //signing certificate with private key information
                //we need to set the private key on the signing certificate
                //and save the old private key properties
                SignerCert.dwCertChoice=SIGNER_CERT_STORE;
                SignerCert.pCertStoreInfo=&SignerCertStoreInfo;
                SignerCert.hwnd= pSignGetPageInfo->hwndParent;

                //set up SignerCertStoreInfo
                if(NULL == pPvkSignInfo->pSignCert)
                    goto InvalidArgErr;

                SignerCertStoreInfo.pSigningCert=pPvkSignInfo->pSignCert;
                SignerCertStoreInfo.dwCertPolicy=dwCertPolicy;
                SignerCertStoreInfo.hCertStore=hAddCertStore;

                //set the correct private key information
                //if we are signing with private key file
                if(pPvkSignInfo->fPvkFile)
                {
                    //save the old CERT_PVK_FILE_PROP_ID property
                    cbSize=0;

	                if(CertGetCertificateContextProperty(
                                            SignerCertStoreInfo.pSigningCert,
							                CERT_PVK_FILE_PROP_ID,
							                NULL,
							                &cbSize) && (0!=cbSize))
                    {

	                    pOldPvkFileProperty=(BYTE *)WizardAlloc(cbSize);

                        if(NULL==pOldPvkFileProperty)
                            goto MemoryErr;

	                    if(!CertGetCertificateContextProperty(
                                                SignerCertStoreInfo.pSigningCert,
							                    CERT_PVK_FILE_PROP_ID,
							                    pOldPvkFileProperty,
							                    &cbSize))
		                    goto TraceErr;
                    }

                    //set the new CERT_PVK_FILE_PROP_ID property
                    memset(&KeyProvInfo, 0, sizeof(CRYPT_KEY_PROV_INFO));

                    KeyProvInfo.pwszProvName=pPvkSignInfo->pwszPvk_CSP;
                    KeyProvInfo.dwProvType=pPvkSignInfo->dwPvk_CSPType;
                    KeyProvInfo.pwszContainerName=pPvkSignInfo->pwszPvk_File;

                    //compose the string
                    cbSize=0;

                    if(!ComposePvkString(&KeyProvInfo,
							            &pwszPvkFileProperty,
							            &cbSize))
                        goto MemoryErr;

                    dataBlob.cbData=cbSize*sizeof(WCHAR);
			        dataBlob.pbData=(BYTE *)pwszPvkFileProperty;

			        if(!CertSetCertificateContextProperty(
					        SignerCertStoreInfo.pSigningCert,
					        CERT_PVK_FILE_PROP_ID,
					        0,
					        &dataBlob))
				        goto TraceErr;
                }
                else
                {
                    //we are signing with the key container

                    //get the CERT_KEY_PROV_INFO_PROP_ID property
                    cbSize=0;

                    if(CertGetCertificateContextProperty(
                            SignerCertStoreInfo.pSigningCert,
                            CERT_KEY_PROV_INFO_PROP_ID,
                            NULL,
                            &cbSize) && (0!=cbSize))
                    {

                        pOldProvInfo=(PCRYPT_KEY_PROV_INFO)WizardAlloc(cbSize);

                        if(NULL==pOldProvInfo)
                            goto MemoryErr;

                        if(!CertGetCertificateContextProperty(
                                SignerCertStoreInfo.pSigningCert,
                                CERT_KEY_PROV_INFO_PROP_ID,
                                pOldProvInfo,
                                &cbSize))
                            goto TraceErr;
                    }

                    //set the new property
                    memset(&KeyProvInfo, 0, sizeof(CRYPT_KEY_PROV_INFO));

                    KeyProvInfo.pwszProvName=pPvkSignInfo->pwszContainer_CSP;
                    KeyProvInfo.dwProvType=pPvkSignInfo->dwContainer_CSPType;
                    KeyProvInfo.dwKeySpec=pPvkSignInfo->dwContainer_KeyType;
                    KeyProvInfo.pwszContainerName=pPvkSignInfo->pwszContainer_Name;

                    //set the property
                    if(!CertSetCertificateContextProperty(
                            SignerCertStoreInfo.pSigningCert,
                            CERT_KEY_PROV_INFO_PROP_ID,
                            0,
                            &KeyProvInfo))
                      goto TraceErr;
                }
            }
            else
            {
               //SPC file with private key information
                if(NULL==pPvkSignInfo->pwszSPCFileName)
                    goto InvalidArgErr;

                SignerCert.dwCertChoice=SIGNER_CERT_SPC_CHAIN;
                SignerCert.pSpcChainInfo=&SignerSpcChainInfo;
                SignerCert.hwnd= pSignGetPageInfo->hwndParent;

                //set up SignerSpcChainInfo
                SignerSpcChainInfo.pwszSpcFile=pPvkSignInfo->pwszSPCFileName;
                SignerSpcChainInfo.dwCertPolicy=dwCertPolicy;
                SignerSpcChainInfo.hCertStore=hAddCertStore;


                //if we are signing with private key file
                if(pPvkSignInfo->fPvkFile)
                {
                    //update SignerProviderInfo
                    SignerProviderInfo.pwszProviderName=pPvkSignInfo->pwszPvk_CSP;
                    SignerProviderInfo.dwProviderType=pPvkSignInfo->dwPvk_CSPType;
                    SignerProviderInfo.dwPvkChoice=PVK_TYPE_FILE_NAME;
                    SignerProviderInfo.pwszPvkFileName=pPvkSignInfo->pwszPvk_File;

                }
                else
                {
                    //update SignerProviderInfo
                    SignerProviderInfo.pwszProviderName=pPvkSignInfo->pwszContainer_CSP;
                    SignerProviderInfo.dwProviderType=pPvkSignInfo->dwContainer_CSPType;
                    SignerProviderInfo.dwKeySpec=pPvkSignInfo->dwContainer_KeyType;
                    SignerProviderInfo.dwPvkChoice=PVK_TYPE_KEYCONTAINER;
                    SignerProviderInfo.pwszKeyContainer=pPvkSignInfo->pwszContainer_Name;
                }
            }

        }
    }
    //UIless case
    else
    {
        if(NULL == pDigitalSignInfo)
            goto InvalidArgErr;

        switch(pDigitalSignInfo->dwSigningCertChoice)
        {
            case    CRYPTUI_WIZ_DIGITAL_SIGN_CERT:
                        SignerCert.dwCertChoice=SIGNER_CERT_STORE;
                        SignerCert.pCertStoreInfo=&SignerCertStoreInfo;
                        SignerCert.hwnd= pSignGetPageInfo->hwndParent;

                        SignerCertStoreInfo.pSigningCert=pDigitalSignInfo->pSigningCertContext;
                        SignerCertStoreInfo.dwCertPolicy=dwCertPolicy;
                        SignerCertStoreInfo.hCertStore=hAddCertStore;
                break;

            case    CRYPTUI_WIZ_DIGITAL_SIGN_STORE:
                        //this is only valid in UI case, which will set a valid value in
                        //pPvkSignInfo->pSignCert
                        goto InvalidArgErr;
                break;
            case    CRYPTUI_WIZ_DIGITAL_SIGN_PVK:
                        if(NULL==pDigitalSignInfo->pSigningCertPvkInfo)
                            goto InvalidArgErr;

                        SignerCert.dwCertChoice=SIGNER_CERT_SPC_CHAIN;
                        SignerCert.pSpcChainInfo=&SignerSpcChainInfo;
                        SignerCert.hwnd= pSignGetPageInfo->hwndParent;

                        //set up SignerSpcChainInfo
                        SignerSpcChainInfo.pwszSpcFile=pDigitalSignInfo->pSigningCertPvkInfo->pwszSigningCertFileName;
                        SignerSpcChainInfo.dwCertPolicy=dwCertPolicy;
                        SignerSpcChainInfo.hCertStore=hAddCertStore;

                        if(CRYPTUI_WIZ_DIGITAL_SIGN_PVK_FILE == pDigitalSignInfo->pSigningCertPvkInfo->dwPvkChoice)
                        {
                            pPvkFileInfo=(CRYPTUI_WIZ_DIGITAL_SIGN_PVK_FILE_INFO  *)pDigitalSignInfo->pSigningCertPvkInfo->pPvkFileInfo;

                            if(NULL==pPvkFileInfo)
                                goto InvalidArgErr;

                            //update SignerProviderInfo
                            SignerProviderInfo.pwszProviderName=pPvkFileInfo->pwszProvName;
                            SignerProviderInfo.dwProviderType=pPvkFileInfo->dwProvType;
                            SignerProviderInfo.dwPvkChoice=PVK_TYPE_FILE_NAME;
                            SignerProviderInfo.pwszPvkFileName=pPvkFileInfo->pwszPvkFileName;

                        }
                        else
                        {
                            if(CRYPTUI_WIZ_DIGITAL_SIGN_PVK_PROV== pDigitalSignInfo->pSigningCertPvkInfo->dwPvkChoice)
                            {
                                pProvInfo=pDigitalSignInfo->pSigningCertPvkInfo->pPvkProvInfo;

                                if(NULL == pProvInfo)
                                    goto InvalidArgErr;

                                //update SignerProviderInfo
                                SignerProviderInfo.pwszProviderName=pProvInfo->pwszProvName;
                                SignerProviderInfo.dwProviderType=pProvInfo->dwProvType;
                                SignerProviderInfo.dwKeySpec=pProvInfo->dwKeySpec;
                                SignerProviderInfo.dwPvkChoice=PVK_TYPE_KEYCONTAINER;
                                SignerProviderInfo.pwszKeyContainer=pProvInfo->pwszContainerName;
                            }
                            else
                                goto InvalidArgErr;
                        }


                break;
            default:
                        goto InvalidArgErr;
                break;
        }
    }

    //set up SignerSignatureInfo
    //set up the hashing algorithm in SignerSignatureInfo
    if(pPvkSignInfo->pszHashOIDName)
    {
        //get the wchar name of the HashOIDName
        pwszOIDName=MkWStr(pPvkSignInfo->pszHashOIDName);

        if(pwszOIDName)
        {
            //get the ALG_ID of the HashAlg based on name.
            pOIDInfo=CryptFindOIDInfo(
                    CRYPT_OID_INFO_NAME_KEY,
                    pwszOIDName,
                    CRYPT_HASH_ALG_OID_GROUP_ID);
        }

    }
    else
    {
        if(pExtInfo)
        {
            //get the ALG_ID of the HashAlg based on OID.
            pOIDInfo=CryptFindOIDInfo(
                    CRYPT_OID_INFO_OID_KEY,
                    (void *)pExtInfo->pszHashAlg,
                    CRYPT_HASH_ALG_OID_GROUP_ID);
        }
    }

    if(pOIDInfo)
    {
        if(CRYPT_HASH_ALG_OID_GROUP_ID == pOIDInfo->dwGroupId)
            SignerSignatureInfo.algidHash=pOIDInfo->Algid;
        else
                //default for signing is SHA1
            SignerSignatureInfo.algidHash=CALG_SHA1;

    }
    else
    {
        //default for signing is SHA1
        SignerSignatureInfo.algidHash=CALG_SHA1;
    }


    SignerSignatureInfo.dwAttrChoice=SIGNER_AUTHCODE_ATTR;
    SignerSignatureInfo.pAttrAuthcode=&SignerAttrAuthcode;

    //addtional attributes for the SignerAttrAuthcode
    if(pDigitalSignInfo)
    {
        if(pDigitalSignInfo->pSignExtInfo)
        {
             SignerSignatureInfo.psAuthenticated=pDigitalSignInfo->pSignExtInfo->psAuthenticated;
             SignerSignatureInfo.psUnauthenticated=pDigitalSignInfo->pSignExtInfo->psUnauthenticated;
        }

    }

    //setup commercial or individual in SignerAttrAuthcode
    if(pExtInfo)
    {
        if(pExtInfo->dwAttrFlags & CRYPTUI_WIZ_DIGITAL_SIGN_COMMERCIAL)
            SignerAttrAuthcode.fCommercial=TRUE;
        else
        {
            if(pExtInfo->dwAttrFlags & CRYPTUI_WIZ_DIGITAL_SIGN_INDIVIDUAL)
                SignerAttrAuthcode.fIndividual=TRUE;
        }

    }

    //set up URL and description in SignerAttrAuthcode
    if(pPvkSignInfo->fUseDescription)
    {
        SignerAttrAuthcode.pwszName=pPvkSignInfo->pwszDes;
        SignerAttrAuthcode.pwszInfo=pPvkSignInfo->pwszURL;

    }
    else
    {
        if(pExtInfo)
        {
            SignerAttrAuthcode.pwszName=pExtInfo->pwszDescription;
            SignerAttrAuthcode.pwszInfo=pExtInfo->pwszMoreInfoLocation;
        }

    }

    //sign the document

    __try {
    if(S_OK !=(hr=SignerSignEx(
                            0,
                            &SignerSubjectInfo,
                            &SignerCert,
                            &SignerSignatureInfo,
                            SignerProviderInfo.dwPvkChoice ? &SignerProviderInfo : NULL,
                            NULL,
                            NULL,
                            NULL,
                            &pSignerContext)))
    {
        idsText=GetErrMsgFromSignHR(hr);
        goto SignerSignErr;
    }

    //timestamp the document if required
    if(pPvkSignInfo->fUsageTimeStamp)
        pwszTimeStamp=pPvkSignInfo->pwszTimeStamp;
    else
        pwszTimeStamp=pDigitalSignInfo ? (LPWSTR)(pDigitalSignInfo->pwszTimestampURL): NULL;

    if(pwszTimeStamp)
    {
        //we need to reset the subject if we are doing the BLOB
        if(SIGNER_SUBJECT_BLOB == SignerSubjectInfo.dwSubjectChoice)
        {
            SignerBlobInfo.cbBlob=pSignerContext->cbBlob;
            SignerBlobInfo.pbBlob=(BYTE *)WizardAlloc(pSignerContext->cbBlob);
            if(NULL==SignerBlobInfo.pbBlob)
                goto MemoryErr;

            //copy the new signer context.  It is the BLOB to timestamp with.
            memcpy(SignerBlobInfo.pbBlob, pSignerContext->pbBlob,pSignerContext->cbBlob);
            fFreeSignerBlob=TRUE;
        }

        //free the original timeStamp context
        SignerFreeSignerContext(pSignerContext);
        pSignerContext=NULL;

        if(S_OK != (hr=SignerTimeStampEx(0,
                                        &SignerSubjectInfo,
                                        pwszTimeStamp,
                                        NULL,
                                        NULL,
                                        &pSignerContext)))
        {
            idsText=GetErrMsgFromTimeStampHR(hr);
            goto SignerTimeStampErr;

        }

    }

    } __except(EXCEPTION_EXECUTE_HANDLER) {
        dwException = GetExceptionCode();
        goto ExceptionErr;
    }


    fResult=TRUE;

CommonReturn:

    //reset the property
    if(pOldProvInfo)
    {
        if(pPvkSignInfo && pPvkSignInfo->pSignCert)
        {
            CertSetCertificateContextProperty(
                pPvkSignInfo->pSignCert,
                CERT_KEY_PROV_INFO_PROP_ID,
                0,
                pOldProvInfo);
        }

          WizardFree(pOldProvInfo);
    }

    if(pOldPvkFileProperty)
    {

        if(pPvkSignInfo->pSignCert)
        {
            CertSetCertificateContextProperty(
                pPvkSignInfo->pSignCert,
                CERT_PVK_FILE_PROP_ID,
                0,
                pOldPvkFileProperty);
        }



        WizardFree(pOldPvkFileProperty);

    }

    if(pwszPvkFileProperty)
        WizardFree(pwszPvkFileProperty);


    //free memory
    if(fFreeSignerBlob)
    {
        if(SignerBlobInfo.pbBlob)
            WizardFree(SignerBlobInfo.pbBlob);
    }


    //set up the return value
    pSignGetPageInfo->fResult=fResult;

    if(fResult)
        pSignGetPageInfo->dwError=0;
    else
        pSignGetPageInfo->dwError=GetLastError();

    if(pSignerContext)
    {
        if(fResult)
            pSignGetPageInfo->pSignContext=(CRYPTUI_WIZ_DIGITAL_SIGN_CONTEXT *)pSignerContext;
        else
        {
            pSignGetPageInfo->pSignContext=NULL;

            __try {
                SignerFreeSignerContext(pSignerContext);
            } __except(EXCEPTION_EXECUTE_HANDLER) {
                SetLastError(GetExceptionCode());
            }

        }
    }

    if(pwszOIDName)
        FreeWStr(pwszOIDName);

    //set up the idsText
    ((CERT_SIGNING_INFO *)(pSignGetPageInfo->pvSignReserved))->idsText=idsText;

    return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
SET_ERROR_VAR(SignerSignErr, hr);
SET_ERROR_VAR(SignerTimeStampErr, hr);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
TRACE_ERROR(TraceErr);
SET_ERROR_VAR(ExceptionErr, dwException)
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\ui\wizards\signpvk.h ===
//--------------------------------------------------------------
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       signpvk.h
//
//  Contents:   The private include file for signing.cpp.
//
//  History:    01-12-1997 xiaohs   created
//
//--------------------------------------------------------------
#ifndef SIGNPVK_H
#define SIGNPVK_H


#ifdef __cplusplus
extern "C" {
#endif

#define     HASH_ALG_COUNT     2

#define     SIGN_PVK_NO_CHAIN               1
#define     SIGN_PVK_CHAIN_ROOT             2
#define     SIGN_PVK_CHAIN_NO_ROOT          3


#define     SIGN_PVK_NO_ADD                 1
#define     SIGN_PVK_ADD_FILE               2
#define     SIGN_PVK_ADD_STORE              3

#define     CSP_TYPE_NAME                   200
#define     MAX_CONTAINER_NAME              1000
#define     MAX_ALG_NAME                    1000
#define     MAX_KEY_TYPE_NAME               100

typedef struct _CSP_INFO
{
    DWORD   dwCSPType;
    LPWSTR  pwszCSPName;
}CSP_INFO;


//-----------------------------------------------------------------------
//  The struct to define the list of all stores
//
//-----------------------------------------------------------------------
typedef struct _SIGN_CERT_STORE_LIST
{
    DWORD               dwStoreCount;
    HCERTSTORE          *prgStore;
}SIGN_CERT_STORE_LIST;


//-----------------------------------------------------------------------
//  CERT_SIGNING_INFO
//
//
//  This struct contains everything you will ever need to signing
//  a file.  This struct is private to the dll
//------------------------------------------------------------------------
typedef struct _CERT_SIGNING_INFO
{
    UINT                idsText;               //output parameter
    DWORD               dwFlags;               //dwFlags from the API
    UINT                idsMsgTitle;           //the IDS for the message box title
    HFONT               hBigBold;
    HFONT               hBold;
    BOOL                fFree;                 //Whether to free the struct
    BOOL                fCancel;               //Whether user has cliked on the cancel button
    BOOL                fUseOption;               //Whether user has requested the all signing option
    BOOL                fCustom;               //if fOption is true, whether or not use has chosen the custon option
    LPSTR               pszHashOIDName;        //the hash OID name that user has selected
    DWORD               dwCSPCount;            //the count of CSPs from the numeration
    CSP_INFO            *pCSPInfo;             //the array of CSPs from the numeration
    BOOL                fUsePvkPage;           //whether the user has enter information in the PVK page
    BOOL                fPvkFile;              //whether to use the PVK file
    LPWSTR              pwszPvk_File;          //the pvk file name
    LPWSTR              pwszPvk_CSP;           //the csp name 
    DWORD               dwPvk_CSPType;         //the csp type
    LPWSTR              pwszContainer_CSP;     //the csp name 
    DWORD               dwContainer_CSPType;   //the csp type
    LPWSTR              pwszContainer_Name;    //container name
    DWORD               dwContainer_KeyType;   //key spec
    LPWSTR              pwszContainer_KeyType; //key spec name
    BOOL                fUsageChain;           //whether we have obtained user input from the page
    DWORD               dwChainOption;         //the chain options
    DWORD               dwAddOption;           //the add certificate options
    HCERTSTORE          hAddStoreCertStore;    //The additional certificate (from store) to add in the signature
    BOOL                fFreeStoreCertStore;   //whether to free the hAddStoreCertStore
    HCERTSTORE          hAddFileCertStore;     //The additional certificate (from file) to add in the signature
    LPWSTR              pwszAddFileName;       //The file name of the additional certificate file
    BOOL                fUseDescription;       //Whether we have obtained the descrition information from the user
    LPWSTR              pwszDes;               //the content description
    LPWSTR              pwszURL;               //the content URL
    BOOL                fUsageTimeStamp;       //Whether we have obtained the timestamp information from the user
    LPWSTR              pwszTimeStamp;         //The timestamp address
    BOOL                fUseSignCert;          //whether user has entered the information through  the signing cert page
    BOOL                fSignCert;             //whether user has selected the signing cert, or the SPC file
    LPWSTR              pwszSPCFileName;       //The SPC file name that inclues the signing cert
    PCCERT_CONTEXT      pSignCert;             //The signing certificate
    DWORD               dwCertStore;           //the count the certificate store for the signing cert
    HCERTSTORE          *rghCertStore;          //The certificate store from which the siging cert is selected
    LPWSTR              pwszFileName;          //The file name to be signed
    HCERTSTORE          hMyStore;               //the signing certificate store
    BOOL                fRefreshPvkOnCert;      //whether to refill the private key information when SIGN_PVK page is shown
}CERT_SIGNING_INFO;


BOOL    I_SigningWizard(PCRYPTUI_WIZ_GET_SIGN_PAGE_INFO     pSignGetPageInfo);

BOOL    GetProviderTypeName(DWORD   dwCSPType,  LPWSTR  wszName);

BOOL    SelectComboName(HWND            hwndDlg, 
                        int             idControl,
                        LPWSTR          pwszName);

BOOL    RefreshCSPType(HWND                     hwndDlg,
                       int                      idsCSPTypeControl,
                       int                      idsCSPNameControl,
                       CERT_SIGNING_INFO        *pPvkSignInfo);

void    SetSelectPvkFile(HWND   hwndDlg);


void    SetSelectKeyContainer(HWND   hwndDlg);

BOOL    InitPvkWithPvkInfo(HWND                                     hwndDlg, 
                           CRYPTUI_WIZ_DIGITAL_SIGN_PVK_FILE_INFO   *pPvkFileInfo, 
                           CERT_SIGNING_INFO                        *pPvkSignInfo);

BOOL   RefreshContainer(HWND                     hwndDlg,
                        int                      idsContainerControl,
                        int                      idsCSPNameControl,
                        CERT_SIGNING_INFO        *pPvkSignInfo);


DWORD   GetKeyTypeFromName(LPWSTR   pwszKeyTypeName);

BOOL   RefreshKeyType(HWND                       hwndDlg,
                        int                      idsKeyTypeControl,
                        int                      idsContainerControl,
                        int                      idsCSPNameControl,
                        CERT_SIGNING_INFO        *pPvkSignInfo);



#ifdef __cplusplus
}       // Balance extern "C" above
#endif


#endif  //SIGNPVK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\ui\wizards\mgrcert.h ===
//--------------------------------------------------------------
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       mgrcert.h
//
//  Contents:   The private include file for the dialogue of managing 
//              certificates
//
//  History:    Feb-26-98 xiaohs   created
//
//--------------------------------------------------------------
#ifndef MGRCERT_H
#define MGRCERT_H

#include "dragdrop.h"

//used for the context sensitive help
#include "secauth.h"


#ifdef __cplusplus
extern "C" {
#endif
   

//**************************************************************************
//
//   The private data used for the cert management dialogue
//
//**************************************************************************

//constatns

#define     DIALOGUE_OK         1    
#define     DIALOGUE_CANCEL     0

#define     ALL_SELECTED_CAN_DELETE     1
#define     ALL_SELECTED_DELETE         2
#define     ALL_SELECTED_COPY           3

 
#define     CERTMGR_MAX_FILE_NAME       88

//the registry keys to persist the advanced options
#define     WSZCertMgrExportRegLocation     L"Software\\Microsoft\\Cryptography\\UI\\Certmgr\\ExportFormat"
#define     WSZCertMgrPurposeRegLocation    L"Software\\Microsoft\\Cryptography\\UI\\Certmgr\\Purpose"

#define     WSZCertMgrExportName            L"Export"
#define     SZCertMgrPurposeName            "Purpose"

//-----------------------------------------------------------------------
//  PURPOSE_OID_INFO
//
//------------------------------------------------------------------------
typedef struct _PURPOSE_OID_INFO
{
    LPWSTR      pwszName;
    BOOL        fSelected; 
    LPSTR       pszOID;
}PURPOSE_OID_INFO;


//-----------------------------------------------------------------------
//  PURPOSE_OID_CALL_BACK
//
//------------------------------------------------------------------------
typedef struct _PURPOSE_OID_CALL_BACK
{
    DWORD                   *pdwOIDCount;
    PURPOSE_OID_INFO         **pprgOIDInfo; 
}PURPOSE_OID_CALL_BACK;


//-----------------------------------------------------------------------
//  CERT_MGR_INFO
//
//
//  This struct contains everything you will ever need to call
//  the cert mgr dialogue.  This struct is private to the dll
//------------------------------------------------------------------------
typedef struct _CERT_MGR_INFO
{
    PCCRYPTUI_CERT_MGR_STRUCT       pCertMgrStruct;
    DWORD                           dwCertCount;
    PCCERT_CONTEXT                  *prgCertContext;
    DWORD                           dwOIDInfo;
    PURPOSE_OID_INFO                *rgOIDInfo;
    DWORD                           dwExportFormat;
    BOOL                            fExportChain;
    BOOL                            fAdvOIDChanged;
    DWORD                           rgdwSortParam[5];
    int                             iColumn;
    IDropTarget                     *pIDropTarget;
}CERT_MGR_INFO;



//function prototypes
BOOL    FreeUsageOID(DWORD              dwOIDInfo,
                     PURPOSE_OID_INFO   *pOIDInfo);

void    FreeCerts(CERT_MGR_INFO     *pCertMgrInfo);

HRESULT  CCertMgrDropTarget_CreateInstance(HWND                 hwndDlg,
                                           CERT_MGR_INFO        *pCertMgrInfo,
                                           IDropTarget          **ppIDropTarget);

void    RefreshCertListView(HWND            hwndDlg, 
                            CERT_MGR_INFO   *pCertMgrInfo);


void    SaveAdvValueToReg(CERT_MGR_INFO      *pCertMgrInfo);


#ifdef __cplusplus
}       // Balance extern "C" above
#endif


#endif  //MGRCERT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\ui\wizards\selca.cpp ===
//-------------------------------------------------------------
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       selcal.cpp
//
//  Contents:   The cpp file to implement CA selection dialogue
//
//  History:    Jan-2-1998 xiaohs   created
//
//--------------------------------------------------------------
#include    "wzrdpvk.h"
#include	"certca.h"
#include    "cautil.h"
#include    "selca.h"

//context sensitive help for the main dialogue
static const HELPMAP SelCaMainHelpMap[] = {
    {IDC_CA_LIST,       IDH_SELCA_LIST},
};

//-----------------------------------------------------------------------------
//  the call back function to compare the certificate
//
//-----------------------------------------------------------------------------
int CALLBACK CompareCA(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
    PCRYPTUI_CA_CONTEXT         pCAOne=NULL;
    PCRYPTUI_CA_CONTEXT         pCATwo=NULL;
    DWORD                       dwColumn=0;
    int                         iCompare=0;
    LPWSTR                      pwszOne=NULL;
    LPWSTR                      pwszTwo=NULL;



    pCAOne=(PCRYPTUI_CA_CONTEXT)lParam1;
    pCATwo=(PCRYPTUI_CA_CONTEXT)lParam2;
    dwColumn=(DWORD)lParamSort;

    if((NULL==pCAOne) || (NULL==pCATwo))
        goto CLEANUP;

    switch(dwColumn & 0x0000FFFF)
    {
       case SORT_COLUMN_CA_NAME:
                pwszOne=(LPWSTR)(pCAOne->pwszCAName);
                pwszTwo=(LPWSTR)(pCATwo->pwszCAName);

            break;
       case SORT_COLUMN_CA_LOCATION:
                pwszOne=(LPWSTR)(pCAOne->pwszCAMachineName);
                pwszTwo=(LPWSTR)(pCATwo->pwszCAMachineName);
            break;

    }

    if((NULL==pwszOne) || (NULL==pwszTwo))
        goto CLEANUP;

    iCompare=_wcsicmp(pwszOne, pwszTwo);

    if(dwColumn & SORT_COLUMN_DESCEND)
        iCompare = 0-iCompare;

CLEANUP:
    return iCompare;
}


//--------------------------------------------------------------
// AddCAToList
//--------------------------------------------------------------
BOOL    AddCAToList(HWND                hwndControl,
                    SELECT_CA_INFO      *pSelectCAInfo)
{
    BOOL            fResult=FALSE;
    DWORD           dwIndex=0;
    LV_ITEMW        lvItem;

    if(!hwndControl || !pSelectCAInfo)
        goto InvalidArgErr;

     // set up the fields in the list view item struct that don't change from item to item
    memset(&lvItem, 0, sizeof(LV_ITEMW));

    lvItem.mask = LVIF_TEXT | LVIF_STATE | LVIF_IMAGE|LVIF_PARAM ;
    lvItem.state = 0;
    lvItem.stateMask = 0;
    lvItem.iSubItem=0;
    lvItem.iImage = 0;

    //add all the CAs
    for(dwIndex=0; dwIndex<pSelectCAInfo->dwCACount; dwIndex++)
    {
        if((pSelectCAInfo->prgCAContext)[dwIndex])
        {
            lvItem.iItem=dwIndex;
            lvItem.iSubItem=0;
            lvItem.lParam = (LPARAM)((pSelectCAInfo->prgCAContext)[dwIndex]);
            lvItem.pszText=(LPWSTR)((pSelectCAInfo->prgCAContext)[dwIndex]->pwszCAName);

            //CA common name
            ListView_InsertItemU(hwndControl, &lvItem);

            lvItem.iSubItem++;

            //CA machine name
            ListView_SetItemTextU(hwndControl, lvItem.iItem, lvItem.iSubItem,
                     (pSelectCAInfo->prgCAContext)[dwIndex]->pwszCAMachineName);

            //set the item to be selected
            if(pSelectCAInfo->fUseInitSelect)
            { 
                if(dwIndex == pSelectCAInfo->dwInitSelect)
                ListView_SetItemState(hwndControl, dwIndex, LVIS_SELECTED, LVIS_SELECTED);
            } 

        }
        else
            goto InvalidArgErr;

    }

    if (!pSelectCAInfo->fUseInitSelect) { 
        ListView_SetItemState(hwndControl, 0, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
    }

    fResult=TRUE;

CommonReturn:

    return fResult;

ErrorReturn:

	fResult=FALSE;

	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
}

//--------------------------------------------------------------
// CopyCAContext
//--------------------------------------------------------------
BOOL    CopyCAContext(PCRYPTUI_CA_CONTEXT   pSrcCAContext,
                      PCRYPTUI_CA_CONTEXT   *ppDestCAContext)
{
    BOOL    fResult=FALSE;

    if((!pSrcCAContext) || (!ppDestCAContext))
        goto InvalidArgErr;

    *ppDestCAContext=NULL;

    *ppDestCAContext=(PCRYPTUI_CA_CONTEXT)WizardAlloc(sizeof(CRYPTUI_CA_CONTEXT));

    if(NULL==(*ppDestCAContext))
        goto MemoryErr;

    //memset
    memset(*ppDestCAContext, 0, sizeof(CRYPTUI_CA_CONTEXT));

    (*ppDestCAContext)->dwSize=sizeof(CRYPTUI_CA_CONTEXT);

    (*ppDestCAContext)->pwszCAName=(LPCWSTR)WizardAllocAndCopyWStr(
                                  (LPWSTR)(pSrcCAContext->pwszCAName));

    (*ppDestCAContext)->pwszCAMachineName=(LPCWSTR)WizardAllocAndCopyWStr(
                                  (LPWSTR)(pSrcCAContext->pwszCAMachineName));

    //make sure we have the correct informatiom
    if((NULL==(*ppDestCAContext)->pwszCAName) ||
       (NULL==(*ppDestCAContext)->pwszCAMachineName)
       )
    {
        CryptUIDlgFreeCAContext(*ppDestCAContext);
        *ppDestCAContext=NULL;
        goto TraceErr;
    }


    fResult=TRUE;

CommonReturn:

    return fResult;

ErrorReturn:

	fResult=FALSE;

	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
TRACE_ERROR(TraceErr);
}

//--------------------------------------------------------------
// The wineProc for SelectCADialogProc
//--------------------------------------------------------------
INT_PTR APIENTRY SelectCADialogProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    SELECT_CA_INFO                  *pSelectCAInfo=NULL;
    PCCRYPTUI_SELECT_CA_STRUCT      pCAStruct=NULL;

    HWND                            hWndListView=NULL;
    DWORD                           dwIndex=0;
    DWORD                           dwCount=0;
    WCHAR                           wszText[MAX_STRING_SIZE];
    UINT                            rgIDS[]={IDS_COLUMN_CA_NAME,
                                            IDS_COLUMN_CA_MACHINE};
    NM_LISTVIEW FAR *               pnmv=NULL;
    LV_COLUMNW                      lvC;
    int                             listIndex=0;
    LV_ITEM                         lvItem;

    HIMAGELIST                      hIml=NULL;
    HWND                            hwnd=NULL;
    DWORD                           dwSortParam=0;



    switch ( msg ) {

    case WM_INITDIALOG:

        pSelectCAInfo = (SELECT_CA_INFO   *) lParam;

        SetWindowLongPtr(hwndDlg, DWLP_USER, (LONG_PTR) pSelectCAInfo);

        pCAStruct=pSelectCAInfo->pCAStruct;

        if(NULL == pCAStruct)
            break;
        //
        // set the dialog title and the display string
        //
        if (pCAStruct->wszTitle)
        {
            SetWindowTextU(hwndDlg, pCAStruct->wszTitle);
        }

        if (pCAStruct->wszDisplayString != NULL)
        {
            SetDlgItemTextU(hwndDlg, IDC_CA_NOTE_STATIC, pCAStruct->wszDisplayString);
        }

        //create the image list

        hIml = ImageList_LoadImage(g_hmodThisDll, MAKEINTRESOURCE(IDB_CA), 0, 1, RGB(255,0,255), IMAGE_BITMAP, 0);

        //
        // add the colums to the list view
        //
        hWndListView = GetDlgItem(hwndDlg, IDC_CA_LIST);

        if(NULL==hWndListView)
            break;

        //set the image list
        if (hIml != NULL)
        {
            ListView_SetImageList(hWndListView, hIml, LVSIL_SMALL);
        }

        dwCount=sizeof(rgIDS)/sizeof(rgIDS[0]);

        //set up the common info for the column
        memset(&lvC, 0, sizeof(LV_COLUMNW));

        lvC.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
        lvC.fmt = LVCFMT_LEFT;  // Left-align the column.
        lvC.cx = 200;          // Width of the column, in pixels.
        lvC.iSubItem=0;
        lvC.pszText = wszText;   // The text for the column.

        //inser the column one at a time
        for(dwIndex=0; dwIndex<dwCount; dwIndex++)
        {
            //get the column header
            wszText[0]=L'\0';

            LoadStringU(g_hmodThisDll, rgIDS[dwIndex], wszText, MAX_STRING_SIZE);

            ListView_InsertColumnU(hWndListView, dwIndex, &lvC);
        }


        //Add the CAs to the List View.  Go to the DS for more information
        AddCAToList(hWndListView, pSelectCAInfo);


        //Select first item
        ListView_SetItemState(hWndListView, 0, LVIS_SELECTED, LVIS_SELECTED);

        // if there is no cert selected initially disable the "view cert button"
        if (ListView_GetSelectedCount(hWndListView) == 0)
        {
            //diable the OK button.
            EnableWindow(GetDlgItem(hwndDlg, IDOK), FALSE);
        }

        //
        // set the style in the list view so that it highlights an entire line
        //
        SendMessageA(hWndListView, LVM_SETEXTENDEDLISTVIEWSTYLE, 0, LVS_EX_FULLROWSELECT);


        //we sort by the 1st column
        dwSortParam=pSelectCAInfo->rgdwSortParam[0];

        if(0!=dwSortParam)
        {
            //sort the 1st column
            SendDlgItemMessage(hwndDlg,
                IDC_CA_LIST,
                LVM_SORTITEMS,
                (WPARAM) (LPARAM) dwSortParam,
                (LPARAM) (PFNLVCOMPARE)CompareCA);
        }


        break;
    case WM_NOTIFY:
        switch (((NMHDR FAR *) lParam)->code)
        {
            //the column has been changed
            case LVN_COLUMNCLICK:

                    pSelectCAInfo = (SELECT_CA_INFO *) GetWindowLongPtr(hwndDlg, DWLP_USER);

                    if(NULL == pSelectCAInfo)
                        break;

                    pnmv = (NM_LISTVIEW FAR *) lParam;

                    //get the column number
                    dwSortParam=0;

                    switch(pnmv->iSubItem)
                    {
                        case 0:
                        case 1:
                                dwSortParam=pSelectCAInfo->rgdwSortParam[pnmv->iSubItem];
                            break;
                        default:
                                dwSortParam=0;
                            break;
                    }

                    if(0!=dwSortParam)
                    {
                        //remember to flip the ascend ording

                        if(dwSortParam & SORT_COLUMN_ASCEND)
                        {
                            dwSortParam &= 0x0000FFFF;
                            dwSortParam |= SORT_COLUMN_DESCEND;
                        }
                        else
                        {
                            if(dwSortParam & SORT_COLUMN_DESCEND)
                            {
                                dwSortParam &= 0x0000FFFF;
                                dwSortParam |= SORT_COLUMN_ASCEND;
                            }
                        }

                        //sort the column
                        SendDlgItemMessage(hwndDlg,
                            IDC_CA_LIST,
                            LVM_SORTITEMS,
                            (WPARAM) (LPARAM) dwSortParam,
                            (LPARAM) (PFNLVCOMPARE)CompareCA);

                        pSelectCAInfo->rgdwSortParam[pnmv->iSubItem]=dwSortParam;
                    }

                break;

                //the item has been selected
                case LVN_ITEMCHANGED:

                        //get the window handle of the purpose list view
                        if(NULL==(hWndListView=GetDlgItem(hwndDlg, IDC_CA_LIST)))
                            break;

                        pSelectCAInfo = (SELECT_CA_INFO *) GetWindowLongPtr(hwndDlg, DWLP_USER);

                        if(NULL == pSelectCAInfo)
                            break;

                        pnmv = (LPNMLISTVIEW) lParam;

                        if(NULL==pnmv)
                            break;

                        //we try not to let user de-select cert template
                        if((pnmv->uOldState & LVIS_SELECTED) && (0 == (pnmv->uNewState & LVIS_SELECTED)))
                        {
                             //we should have something selected
                             if(-1 == ListView_GetNextItem(
                                    hWndListView, 		
                                    -1, 		
                                    LVNI_SELECTED		
                                ))
                             {
                                //we should re-select the original item
                                ListView_SetItemState(
                                                    hWndListView,
                                                    pnmv->iItem,
                                                    LVIS_SELECTED,
                                                    LVIS_SELECTED);

                                pSelectCAInfo->iOrgCA=pnmv->iItem;
                             }
                        }

                        //if something is selected, we disable all other selection
                        if(pnmv->uNewState & LVIS_SELECTED)
                        {
                            if(pnmv->iItem != pSelectCAInfo->iOrgCA && -1 != pSelectCAInfo->iOrgCA)
                            {
                                //we should de-select the original item

                                ListView_SetItemState(
                                                    hWndListView,
                                                    pSelectCAInfo->iOrgCA,
                                                    0,
                                                    LVIS_SELECTED);

                                pSelectCAInfo->iOrgCA=-1;
                            }
                        }

                break;
            case LVN_ITEMCHANGING:

                    pnmv = (NM_LISTVIEW FAR *) lParam;

                    if (pnmv->uNewState & LVIS_SELECTED)
                    {
                        EnableWindow(GetDlgItem(hwndDlg, IDOK), TRUE);
                    }

                break;

            case NM_DBLCLK:
                    switch (((NMHDR FAR *) lParam)->idFrom)
                    {
                        case IDC_CA_LIST:

                            pSelectCAInfo = (SELECT_CA_INFO *) GetWindowLongPtr(hwndDlg, DWLP_USER);

                            if(NULL == pSelectCAInfo)
                                break;

                            pCAStruct=pSelectCAInfo->pCAStruct;

                            if(NULL == pCAStruct)
                                break;

                            hWndListView = GetDlgItem(hwndDlg, IDC_CA_LIST);

                            //get the selected CA name and machine name
                            listIndex = ListView_GetNextItem(
                                                hWndListView, 		
                                                -1, 		
                                                LVNI_SELECTED		
                                                );	

                            if (listIndex != -1)
                            {

                              //get the selected certificate
                                memset(&lvItem, 0, sizeof(LV_ITEM));
                                lvItem.mask=LVIF_PARAM;
                                lvItem.iItem=listIndex;

                                if(ListView_GetItem(hWndListView, &lvItem))
                                {
                                    //copy the CA context to the result
                                    if((listIndex < (int)(pSelectCAInfo->dwCACount)) && (listIndex >=0) )
                                    {
                                        if(!CopyCAContext((PCRYPTUI_CA_CONTEXT)(lvItem.lParam),
                                             &(pSelectCAInfo->pSelectedCAContext)))
										{
											I_MessageBox(hwndDlg, IDS_HAS_TO_SELECT_CA,
												pSelectCAInfo->idsMsg,
												pCAStruct->wszTitle,
												MB_ICONEXCLAMATION|MB_OK|MB_APPLMODAL);

											SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);
											return TRUE;
										}
                                    }
                                }
                            }
                            else
                            {
                                I_MessageBox(hwndDlg, IDS_HAS_TO_SELECT_CA,
                                    pSelectCAInfo->idsMsg,
                                    pCAStruct->wszTitle,
                                    MB_ICONEXCLAMATION|MB_OK|MB_APPLMODAL);

                                SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);
                                return TRUE;
                            }

                            //double click will end the dialogue
                            EndDialog(hwndDlg, NULL);
                        break;
                    }

                break;
        }

        break;

    case WM_HELP:
    case WM_CONTEXTMENU:
                if (msg == WM_HELP)
                {
                    hwnd = GetDlgItem(hwndDlg, ((LPHELPINFO)lParam)->iCtrlId);
                }
                else
                {
                    hwnd = (HWND) wParam;
                }

                if ((hwnd != GetDlgItem(hwndDlg, IDOK))         &&
                    (hwnd != GetDlgItem(hwndDlg, IDCANCEL))     &&
                    (hwnd != GetDlgItem(hwndDlg, IDC_CA_LIST)))
                {
                    SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, TRUE);
                    return TRUE;
                }
                else
                {
                    return OnContextHelp(hwndDlg, msg, wParam, lParam, SelCaMainHelpMap);
                }
            break;
    case WM_DESTROY:

        //
        // get all the items in the list view         //
        hWndListView = GetDlgItem(hwndDlg, IDC_CA_LIST);

        if(NULL==hWndListView)
            break;

       //no need to destroy the image list.  Handled by ListView
       // ImageList_Destroy(ListView_GetImageList(hWndListView, LVSIL_SMALL));

        break;
    case WM_COMMAND:
        pSelectCAInfo = (SELECT_CA_INFO *) GetWindowLongPtr(hwndDlg, DWLP_USER);

        if(NULL == pSelectCAInfo)
            break;

        pCAStruct=pSelectCAInfo->pCAStruct;

        if(NULL == pCAStruct)
            break;


        hWndListView = GetDlgItem(hwndDlg, IDC_CA_LIST);

        switch (LOWORD(wParam))
        {
        case IDOK:

            //get the selected CA name and machine name
            listIndex = ListView_GetNextItem(
                                hWndListView, 		
                                -1, 		
                                LVNI_SELECTED		
                                );	

            if (listIndex != -1)
            {

              //get the selected certificate
                memset(&lvItem, 0, sizeof(LV_ITEM));
                lvItem.mask=LVIF_PARAM;
                lvItem.iItem=listIndex;

                if(ListView_GetItem(hWndListView, &lvItem))
                {
                    //copy the CA context to the result
                    if((listIndex < (int)(pSelectCAInfo->dwCACount)) && (listIndex >=0) )
                    {
                        if(!CopyCAContext((PCRYPTUI_CA_CONTEXT)(lvItem.lParam),
                             &(pSelectCAInfo->pSelectedCAContext)))
						{
							I_MessageBox(hwndDlg, IDS_HAS_TO_SELECT_CA,
								pSelectCAInfo->idsMsg,
								pCAStruct->wszTitle,
								MB_ICONEXCLAMATION|MB_OK|MB_APPLMODAL);

							SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);
							return TRUE;
						}
                    }
                }
            }
            else
            {
                I_MessageBox(hwndDlg, IDS_HAS_TO_SELECT_CA,
                    pSelectCAInfo->idsMsg,
                    pCAStruct->wszTitle,
                    MB_ICONEXCLAMATION|MB_OK|MB_APPLMODAL);

                SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);
                return TRUE;
            }

            EndDialog(hwndDlg, NULL);
            break;

        case IDCANCEL:
            EndDialog(hwndDlg, NULL);
            break;
        }

        break;

    }

    return FALSE;
}


//--------------------------------------------------------------
//
//  Parameters:
//      pCryptUISelectCA       IN  Required
//
//  the PCCRYPTUI_CA_CONTEXT that is returned must be released by calling
//  CryptUIDlgFreeCAContext
//  if NULL is returned and GetLastError() == 0 then the user dismissed the dialog by hitting the
//  "cancel" button, otherwise GetLastError() will contain the last error.
//
//
//--------------------------------------------------------------
PCCRYPTUI_CA_CONTEXT
WINAPI
CryptUIDlgSelectCA(
        IN PCCRYPTUI_SELECT_CA_STRUCT pCryptUISelectCA
             )
{
    BOOL                    fResult=FALSE;
    DWORD                   dwIndex=0;
    SELECT_CA_INFO          SelectCAInfo;
    DWORD                   dwNTCACount=0;
    BOOL                    fInitSelected=FALSE;
    DWORD                   dwSearchIndex=0;
    BOOL                    fFound=FALSE;

    CRYPTUI_CA_CONTEXT      CAContext;

    LPWSTR                  *pwszCAName=NULL;
    LPWSTR                  *pwszCALocation=NULL;
	LPWSTR					*pwszCADisplayName=NULL;

    //init
    memset(&SelectCAInfo, 0, sizeof(SELECT_CA_INFO));
    memset(&CAContext, 0, sizeof(CRYPTUI_CA_CONTEXT));

    //check the input parameter
    if(NULL==pCryptUISelectCA)
        goto InvalidArgErr;

    if(sizeof(CRYPTUI_SELECT_CA_STRUCT) != pCryptUISelectCA->dwSize)
        goto InvalidArgErr;

    if (!WizardInit())
    {
        goto TraceErr;
    }

    //either user supply known CAs or request us to retrieve info from the network
    if( (0== (pCryptUISelectCA->dwFlags & (CRYPTUI_DLG_SELECT_CA_FROM_NETWORK))) &&
        (0 == pCryptUISelectCA->cCAContext) )
        goto InvalidArgErr;

    //set up the private data
    SelectCAInfo.pCAStruct=pCryptUISelectCA;
    SelectCAInfo.idsMsg=IDS_CA_SELECT_TITLE;
    SelectCAInfo.fUseInitSelect=FALSE;
    SelectCAInfo.dwInitSelect=0;
    SelectCAInfo.pSelectedCAContext=NULL;
    SelectCAInfo.iOrgCA=-1;
    SelectCAInfo.rgdwSortParam[0]=SORT_COLUMN_CA_NAME | SORT_COLUMN_ASCEND;
    SelectCAInfo.rgdwSortParam[1]=SORT_COLUMN_CA_LOCATION | SORT_COLUMN_DESCEND;

    //get all the CA available from the DS if requested
    if(CRYPTUI_DLG_SELECT_CA_FROM_NETWORK & (pCryptUISelectCA->dwFlags))
    {
        //get all the availabe CAs from the network
        if((!CAUtilRetrieveCAFromCertType(
                NULL,
                NULL,
                FALSE,
                pCryptUISelectCA->dwFlags,
                &dwNTCACount,
                &pwszCALocation,
                &pwszCAName)) && (0==pCryptUISelectCA->cCAContext))
            goto TraceErr;

		//build up the CA's display name list based on the CA name
		pwszCADisplayName = (LPWSTR *)WizardAlloc(sizeof(LPWSTR) * dwNTCACount);

		if(NULL == pwszCADisplayName)
			goto MemoryErr;

		memset(pwszCADisplayName, 0,  sizeof(LPWSTR) * dwNTCACount);

		for(dwIndex=0; dwIndex < dwNTCACount; dwIndex++)
		{
			if(CRYPTUI_DLG_SELECT_CA_USE_DN & pCryptUISelectCA->dwFlags)
			{
				//use the CA name
				pwszCADisplayName[dwIndex]=WizardAllocAndCopyWStr(pwszCAName[dwIndex]);

				if(NULL == pwszCADisplayName[dwIndex])
					goto MemoryErr;
				
			}
			else
			{
				if(!CAUtilGetCADisplayName(
					(CRYPTUI_DLG_SELECT_CA_LOCAL_MACHINE_ENUMERATION & pCryptUISelectCA->dwFlags) ? CA_FIND_LOCAL_SYSTEM:0,
					pwszCAName[dwIndex],
					&(pwszCADisplayName[dwIndex])))
				{
					//use the CA name if there is no display name
					pwszCADisplayName[dwIndex]=WizardAllocAndCopyWStr(pwszCAName[dwIndex]);

					if(NULL == pwszCADisplayName[dwIndex])
						goto MemoryErr;
				}
			}
		}


        //add all the CAs
        SelectCAInfo.prgCAContext=(PCRYPTUI_CA_CONTEXT *)WizardAlloc(
                    sizeof(PCRYPTUI_CA_CONTEXT) * dwNTCACount);

        if(NULL == SelectCAInfo.prgCAContext)
            goto MemoryErr;

        //memset
        memset(SelectCAInfo.prgCAContext, 0, sizeof(PCRYPTUI_CA_CONTEXT) * dwNTCACount);

        //add the count
        SelectCAInfo.dwCACount = 0;

        for(dwIndex=0; dwIndex <dwNTCACount; dwIndex++)
        {
            //query user for whether to add the CA to the list
            CAContext.dwSize=sizeof(CRYPTUI_CA_CONTEXT);

            CAContext.pwszCAName=pwszCAName[dwIndex];
            CAContext.pwszCAMachineName=pwszCALocation[dwIndex];

            fInitSelected=FALSE;

            if(pCryptUISelectCA->pSelectCACallback)
            {
                if(!((pCryptUISelectCA->pSelectCACallback)(
                                                &CAContext,
                                                &fInitSelected,
                                                pCryptUISelectCA->pvCallbackData)))
                    continue;
            }

           SelectCAInfo.prgCAContext[SelectCAInfo.dwCACount]=(PCRYPTUI_CA_CONTEXT)WizardAlloc(
                                    sizeof(CRYPTUI_CA_CONTEXT));

           if(NULL==SelectCAInfo.prgCAContext[SelectCAInfo.dwCACount])
               goto MemoryErr;

           //memset
           memset(SelectCAInfo.prgCAContext[SelectCAInfo.dwCACount], 0, sizeof(CRYPTUI_CA_CONTEXT));

           SelectCAInfo.prgCAContext[SelectCAInfo.dwCACount]->dwSize=sizeof(CRYPTUI_CA_CONTEXT);

           SelectCAInfo.prgCAContext[SelectCAInfo.dwCACount]->pwszCAName=(LPCWSTR)WizardAllocAndCopyWStr(
                                          pwszCADisplayName[dwIndex]);

           SelectCAInfo.prgCAContext[SelectCAInfo.dwCACount]->pwszCAMachineName=(LPCWSTR)WizardAllocAndCopyWStr(
                                          pwszCALocation[dwIndex]);

            //make sure we have the correct information
            if((NULL==SelectCAInfo.prgCAContext[SelectCAInfo.dwCACount]->pwszCAName) ||
               (NULL==SelectCAInfo.prgCAContext[SelectCAInfo.dwCACount]->pwszCAMachineName)
               )
               goto TraceErr;

            //mark the initial selected CA
            if(fInitSelected)
            {
                SelectCAInfo.fUseInitSelect=TRUE;
                SelectCAInfo.dwInitSelect=SelectCAInfo.dwCACount;
            }

            //add the count of the CA
            (SelectCAInfo.dwCACount)++;
         }

    }

    //add the additional CA contexts
    if(pCryptUISelectCA->cCAContext)
    {
        SelectCAInfo.prgCAContext=(PCRYPTUI_CA_CONTEXT *)WizardRealloc(
             SelectCAInfo.prgCAContext,
             sizeof(PCRYPTUI_CA_CONTEXT) * (dwNTCACount + pCryptUISelectCA->cCAContext));

        if(NULL == SelectCAInfo.prgCAContext)
            goto MemoryErr;

        //memset
        memset(SelectCAInfo.prgCAContext + dwNTCACount,
                0,
                sizeof(PCRYPTUI_CA_CONTEXT) * (pCryptUISelectCA->cCAContext));

        //copy the CA contexts
        for(dwIndex=0; dwIndex <pCryptUISelectCA->cCAContext; dwIndex++)
        {

            //query user for whether to add the CA to the list
            CAContext.dwSize=sizeof(CRYPTUI_CA_CONTEXT);

            CAContext.pwszCAName=(pCryptUISelectCA->rgCAContext)[dwIndex]->pwszCAName;
            CAContext.pwszCAMachineName=(pCryptUISelectCA->rgCAContext)[dwIndex]->pwszCAMachineName;

            fInitSelected=FALSE;

            if(pCryptUISelectCA->pSelectCACallback)
            {
                if(!((pCryptUISelectCA->pSelectCACallback)(
                                                &CAContext,
                                                &fInitSelected,
                                                pCryptUISelectCA->pvCallbackData)))
                    continue;
            }

            //make sure the CA is not already in the list
            fFound=FALSE;

            for(dwSearchIndex=0; dwSearchIndex < SelectCAInfo.dwCACount; dwSearchIndex++)
            {
                if((0==_wcsicmp(CAContext.pwszCAName, (SelectCAInfo.prgCAContext)[dwSearchIndex]->pwszCAName)) &&
                    (0==_wcsicmp(CAContext.pwszCAMachineName, (SelectCAInfo.prgCAContext)[dwSearchIndex]->pwszCAMachineName))
                    )
                {
                    fFound=TRUE;
                    break;
                }
            }

            //do not need to include the CA since it is already in the list
            if(TRUE==fFound)
                continue;

           if(!CopyCAContext((PCRYPTUI_CA_CONTEXT)(pCryptUISelectCA->rgCAContext[dwIndex]),
               &(SelectCAInfo.prgCAContext[SelectCAInfo.dwCACount])))
               goto TraceErr;

            //mark the initial selected CA
            if(fInitSelected)
            {
                SelectCAInfo.fUseInitSelect=TRUE;
                SelectCAInfo.dwInitSelect=SelectCAInfo.dwCACount;
            }

            //increase the count
           (SelectCAInfo.dwCACount)++;
        }
    }

    //call the dialog box
    if (DialogBoxParamU(
                g_hmodThisDll,
                (LPCWSTR)MAKEINTRESOURCE(IDD_SELECTCA_DIALOG),
                (pCryptUISelectCA->hwndParent != NULL) ? pCryptUISelectCA->hwndParent : GetDesktopWindow(),
                SelectCADialogProc,
                (LPARAM) &SelectCAInfo) != -1)
    {
        SetLastError(0);
    }
	 
	//map the CA's display name to its real name
    if(CRYPTUI_DLG_SELECT_CA_FROM_NETWORK & (pCryptUISelectCA->dwFlags))
	{
		if(SelectCAInfo.pSelectedCAContext)
		{
			//if the selection match with what the caller has supplied,
			//we leave it alone
			for(dwIndex=0; dwIndex <pCryptUISelectCA->cCAContext; dwIndex++)
			{
				if(0 == wcscmp((SelectCAInfo.pSelectedCAContext)->pwszCAName, 
						(pCryptUISelectCA->rgCAContext)[dwIndex]->pwszCAName))
				{
					if(0==wcscmp((SelectCAInfo.pSelectedCAContext)->pwszCAMachineName,
						(pCryptUISelectCA->rgCAContext)[dwIndex]->pwszCAMachineName))
						break;
				}

			}
	  		
			//now that we did not find a match
			if(dwIndex == pCryptUISelectCA->cCAContext)
			{
				for(dwIndex=0; dwIndex <dwNTCACount; dwIndex++)
				{
					if(0 == wcscmp((SelectCAInfo.pSelectedCAContext)->pwszCAMachineName, 
							pwszCALocation[dwIndex]))
					{
						if(0==wcscmp((SelectCAInfo.pSelectedCAContext)->pwszCAName,
							pwszCADisplayName[dwIndex]))
						{
							WizardFree((LPWSTR)((SelectCAInfo.pSelectedCAContext)->pwszCAName));
							(SelectCAInfo.pSelectedCAContext)->pwszCAName = NULL;

							
							(SelectCAInfo.pSelectedCAContext)->pwszCAName = WizardAllocAndCopyWStr(
																			pwszCAName[dwIndex]);

							if(NULL == (SelectCAInfo.pSelectedCAContext)->pwszCAName)
								goto MemoryErr;

							//we find a match
							break;

						}
					}
				}
			}
		}
	}

    fResult=TRUE;

CommonReturn:

    //free the CA list
    if(SelectCAInfo.prgCAContext)
    {
        for(dwIndex=0; dwIndex<SelectCAInfo.dwCACount; dwIndex++)
        {
            if(SelectCAInfo.prgCAContext[dwIndex])
              CryptUIDlgFreeCAContext(SelectCAInfo.prgCAContext[dwIndex]);
        }

        WizardFree(SelectCAInfo.prgCAContext);
    }

    //free the CA names array
    if(pwszCAName)
    {
        for(dwIndex=0; dwIndex<dwNTCACount; dwIndex++)
        {
            if(pwszCAName[dwIndex])
              WizardFree(pwszCAName[dwIndex]);
        }

        WizardFree(pwszCAName);

    }

    //free the CA location array
    if(pwszCADisplayName)
    {
        for(dwIndex=0; dwIndex<dwNTCACount; dwIndex++)
        {
            if(pwszCADisplayName[dwIndex])
              WizardFree(pwszCADisplayName[dwIndex]);
        }

        WizardFree(pwszCADisplayName);

    }

    //free the CA Display name array
    if(pwszCALocation)
    {
        for(dwIndex=0; dwIndex<dwNTCACount; dwIndex++)
        {
            if(pwszCALocation[dwIndex])
              WizardFree(pwszCALocation[dwIndex]);
        }

        WizardFree(pwszCALocation);

    }

    return (SelectCAInfo.pSelectedCAContext);

ErrorReturn:

	if(SelectCAInfo.pSelectedCAContext)
	{
		CryptUIDlgFreeCAContext(SelectCAInfo.pSelectedCAContext);
		SelectCAInfo.pSelectedCAContext=NULL;
	}

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
TRACE_ERROR(TraceErr);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
}

//--------------------------------------------------------------
// CryptUIDlgFreeCAContext
//--------------------------------------------------------------
BOOL
WINAPI
CryptUIDlgFreeCAContext(
        IN PCCRYPTUI_CA_CONTEXT       pCAContext
            )
{
    if(pCAContext)
    {
        if(pCAContext->pwszCAName)
            WizardFree((LPWSTR)(pCAContext->pwszCAName));

        if(pCAContext->pwszCAMachineName)
            WizardFree((LPWSTR)(pCAContext->pwszCAMachineName));

        WizardFree((PCRYPTUI_CA_CONTEXT)pCAContext);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\ui\wizards\wizards.cpp ===
//depot/Lab03_N/ds/security/cryptoapi/ui/wizards/wizards.cpp#21 - edit change 8790 (text)
//-------------------------------------------------------------
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       wizards.cpp
//
//  Contents:   The cpp file to implement the wizards
//
//  History:    16-10-1997 xiaohs   created
//
//--------------------------------------------------------------
#include    "wzrdpvk.h"
#include    "certca.h"
#include    "cautil.h"
#include    "CertRequesterContext.h"
#include    "CertDSManager.h"
#include    "CertRequester.h"

// Used to provide singleton instances of useful COM objects in a demand-driven fashion.
// See wzrdpvk.h. 
EnrollmentCOMObjectFactory  *g_pEnrollFactory = NULL; 

HINSTANCE                    g_hmodThisDll = NULL;	// Handle to this DLL itself.
HMODULE                      g_hmodRichEdit = NULL;
HMODULE                      g_hmodxEnroll=NULL;     // Handle to the xEnroll dll


typedef struct _CREATE_REQUEST_WIZARD_STATE { 
    HANDLE hRequest; 
    DWORD  dwPurpose; 
    LPWSTR pwszMachineName; 
    DWORD  dwStoreFlags; 
} CREATE_REQUEST_WIZARD_STATE, *PCREATE_REQUEST_WIZARD_STATE; 

/////////////////////////////////////////////////////////////////////////////
// library Entry Point
extern "C"
BOOL WINAPI Wizard_DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
        g_hmodThisDll=hInstance;

    if (dwReason == DLL_PROCESS_DETACH)
    {
        //  If the rich edit dll was loaded, then unload it now
        if (g_hmodRichEdit != NULL)
        {
            FreeLibrary(g_hmodRichEdit);
        }

        //if xEnroll.dll was loaded, unload it now
        if(NULL != g_hmodxEnroll)
        {
            FreeLibrary(g_hmodxEnroll);
        }
    }

	return TRUE;    // ok
}


DWORD CryptUIStatusToIDSText(HRESULT hr, DWORD dwStatus)
{
    switch(dwStatus)
    {
        case CRYPTUI_WIZ_CERT_REQUEST_STATUS_UNKNOWN:           return IDS_UNKNOWN_WIZARD_ERROR;   
        case CRYPTUI_WIZ_CERT_REQUEST_STATUS_REQUEST_ERROR:     return IDS_REQUEST_ERROR;    
        case CRYPTUI_WIZ_CERT_REQUEST_STATUS_REQUEST_DENIED:    return IDS_REQUEST_DENIED;   
        case CRYPTUI_WIZ_CERT_REQUEST_STATUS_SUCCEEDED:         return S_OK == hr ? IDS_REQUEST_SUCCEDDED : IDS_REQUEST_FAILED;  
        case CRYPTUI_WIZ_CERT_REQUEST_STATUS_ISSUED_SEPARATELY: return IDS_ISSUED_SEPERATE;  
        case CRYPTUI_WIZ_CERT_REQUEST_STATUS_UNDER_SUBMISSION:  return IDS_UNDER_SUBMISSION; 
        case CRYPTUI_WIZ_CERT_REQUEST_STATUS_INSTALL_FAILED:    return IDS_INSTALL_FAILED;   
        case CRYPTUI_WIZ_CERT_REQUEST_STATUS_CONNECTION_FAILED: return IDS_CONNET_CA_FAILED; 
        case CRYPTUI_WIZ_CERT_REQUEST_STATUS_INSTALL_CANCELLED: return IDS_INSTAL_CANCELLED; 
        case CRYPTUI_WIZ_CERT_REQUEST_STATUS_KEYSVC_FAILED:     return IDS_RPC_CALL_FAILED;  
        default:
            return IDS_UNKNOWN_WIZARD_ERROR; 
    }
}

//--------------------------------------------------------------------------
//
//	  I_EnrollMessageBox
//
//
//
//--------------------------------------------------------------------------
int I_EnrollMessageBox(
            HWND        hWnd,
            UINT        idsText,
            HRESULT     hr,
            UINT        idsCaption,
            LPCWSTR     pwszCaption,
            UINT        uType)
{
    //we print out the error message (hr) for denied and error case
    WCHAR    wszText[MAX_STRING_SIZE];
    WCHAR    wszCaption[MAX_STRING_SIZE];
    UINT     intReturn=0;

    LPWSTR   wszErrorMsg=NULL;
    LPWSTR   wszTextErr=NULL;

    //init
    wszText[0]=L'\0';
    wszCaption[0]=L'\0';

    if((IDS_REQUEST_ERROR != idsText) && (IDS_REQUEST_DENIED != idsText) &&
       (IDS_REQUEST_FAILED != idsText) && (IDS_UNKNOWN_WIZARD_ERROR != idsText) && 
       (IDS_INSTALL_FAILED != idsText))
        return I_MessageBox(hWnd, idsText, idsCaption, pwszCaption, uType);


    //get the caption string
    if(NULL == pwszCaption)
    {
        if(!LoadStringU(g_hmodThisDll, idsCaption, wszCaption, ARRAYSIZE(wszCaption)))
             return 0;
    }

    //get the text string
    if(!LoadStringU(g_hmodThisDll, idsText, wszText, ARRAYSIZE(wszText)))
    {
        return 0;
    }

    //cancatenate the error string with the error string. 
    //using W version because this is a NT5 only function call
    if( FAILED(hr) && FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                        FORMAT_MESSAGE_FROM_SYSTEM |
                        FORMAT_MESSAGE_IGNORE_INSERTS,
                        NULL,
                        hr,
                        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                        (LPWSTR) &wszErrorMsg,
                        0,
                        NULL))
    {

        wszTextErr=(LPWSTR)WizardAlloc(sizeof(WCHAR) *(wcslen(wszText) + wcslen(wszErrorMsg) + wcslen(L".  ")+2));

        if(!wszTextErr)
        {
            if(wszErrorMsg)
                LocalFree(wszErrorMsg);

            return 0;
        }

        wcscpy(wszTextErr, wszText);

        wcscat(wszTextErr, wszErrorMsg);

    }
    else
    {
        wszTextErr=(LPWSTR)WizardAlloc((wcslen(wszText) + 2) * sizeof(WCHAR));

        if(!wszTextErr)
        {
            if(wszErrorMsg)
                LocalFree(wszErrorMsg);

            return 0;
        }

        wcscpy(wszTextErr, wszText);
    }

    //message box
    if(pwszCaption)
    {
        intReturn=MessageBoxExW(hWnd, wszTextErr, pwszCaption, uType, 0);
    }
    else
        intReturn=MessageBoxExW(hWnd, wszTextErr, wszCaption, uType, 0);

    if(wszErrorMsg)
        LocalFree(wszErrorMsg);

    if(wszTextErr)
        WizardFree(wszTextErr);

    return intReturn;

}


//--------------------------------------------------------------------------
//	WizardCopyAndFreeWStr
//
//		Alloc and copy the new string and free the old string.  If failed to
//	alloc the memory, use the old string
//
//--------------------------------------------------------------------------
LPWSTR WizardCopyAndFreeWStr(LPWSTR	pwszNew, LPWSTR pwszOld)
{
	LPWSTR	pwsz=NULL;

	pwsz=WizardAllocAndCopyWStr(pwszNew);

	if(pwsz)
	{
		WizardFree(pwszOld);	
	}
	else
	{
		pwsz=pwszOld;
	}

	return pwsz;
}


//--------------------------------------------------------------------------
//
//	  GetCAContext
//
//      Call the CA selection dialogue, get the selected CA name and update
//		internal data. (pCertWizardInfo->pwszCALocation, pCertWizardInfo->
//		pwszCAName, and pCertWizardInfo->dwCAindex).
//
//--------------------------------------------------------------------------
PCRYPTUI_CA_CONTEXT GetCAContext(HWND                hwndControl,
                                 CERT_WIZARD_INFO    *pCertWizardInfo)
{
    DWORD                       dwCACount=0;
    PCRYPTUI_WIZ_CERT_CA_INFO   pCertCAInfo=NULL;
    DWORD                       dwIndex=0;
    BOOL                        fResult=FALSE;
    CRYPTUI_SELECT_CA_STRUCT    SelectCAStruct;
    PCRYPTUI_CA_CONTEXT         pCAContext=NULL;
	BOOL						fFoundCA=FALSE;
	LPWSTR						pwszOldName=NULL;
	LPWSTR						pwszOldLocation=NULL;

    PCRYPTUI_CA_CONTEXT         *prgCAContext=NULL;
	LPWSTR						pwszCADisplayName=NULL;


    //init
    memset(&SelectCAStruct, 0, sizeof(CRYPTUI_SELECT_CA_STRUCT));

    if(NULL == pCertWizardInfo)
        return NULL;

    pCertCAInfo=pCertWizardInfo->pCertCAInfo;

    if(NULL==pCertCAInfo)
        return NULL;

    if( (0==pCertCAInfo->dwCA) || (NULL == pCertCAInfo->rgCA))
        return NULL;


    //add all the CAs
    prgCAContext=(PCRYPTUI_CA_CONTEXT *)WizardAlloc(
                sizeof(PCRYPTUI_CA_CONTEXT) * (pCertCAInfo->dwCA));

    if(NULL == prgCAContext)
        goto MemoryErr;

    //memset
    memset(prgCAContext, 0, sizeof(PCRYPTUI_CA_CONTEXT) * (pCertCAInfo->dwCA));

    //add the count
    dwCACount = 0;

    for(dwIndex=1; dwIndex <(pCertCAInfo->dwCA); dwIndex++)
    {
        //skip the 1st CA.  it contains generic information
        if((pCertCAInfo->rgCA)[dwIndex].pwszCAName && (pCertCAInfo->rgCA)[dwIndex].pwszCALocation)
        {

            //the CA has to support the selected CT
            if(CASupportSpecifiedCertType(&((pCertCAInfo->rgCA)[dwIndex])))
            {

               prgCAContext[dwCACount]=(PCRYPTUI_CA_CONTEXT)WizardAlloc(
                                        sizeof(CRYPTUI_CA_CONTEXT));

               if(NULL==prgCAContext[dwCACount])
                   goto MemoryErr;

               //memset
               memset(prgCAContext[dwCACount], 0, sizeof(CRYPTUI_CA_CONTEXT));

               prgCAContext[dwCACount]->dwSize=sizeof(CRYPTUI_CA_CONTEXT);

			   if(!CAUtilGetCADisplayName(
				   (pCertWizardInfo->fMachine) ? CA_FIND_LOCAL_SYSTEM:0,
				   (pCertCAInfo->rgCA)[dwIndex].pwszCAName,
				   (LPWSTR *)&(prgCAContext[dwCACount]->pwszCAName)))
			   {
				   prgCAContext[dwCACount]->pwszCAName=(LPCWSTR)WizardAllocAndCopyWStr(
												  (pCertCAInfo->rgCA)[dwIndex].pwszCAName);
			   }

               prgCAContext[dwCACount]->pwszCAMachineName=(LPCWSTR)WizardAllocAndCopyWStr(
                                              (pCertCAInfo->rgCA)[dwIndex].pwszCALocation);

                //make sure we have the correct information
                if((NULL==prgCAContext[dwCACount]->pwszCAName) ||
                   (NULL==prgCAContext[dwCACount]->pwszCAMachineName)
                   )
                   goto TraceErr;

                //add the count of the CA
                dwCACount++;
            }
        }
     }

    if(0 == dwCACount)
        goto InvalidArgErr;

    //call the CA selection dialogue
    SelectCAStruct.dwSize=sizeof(CRYPTUI_SELECT_CA_STRUCT);
    SelectCAStruct.hwndParent=hwndControl;
    SelectCAStruct.cCAContext=dwCACount;
    SelectCAStruct.rgCAContext=(PCCRYPTUI_CA_CONTEXT *)prgCAContext;
    SelectCAStruct.pSelectCACallback=NULL;
    SelectCAStruct.wszDisplayString=NULL;

    pCAContext=(PCRYPTUI_CA_CONTEXT)CryptUIDlgSelectCA(&SelectCAStruct);

	if(pCAContext)
	{
		if((NULL == (pCAContext->pwszCAName)) || (NULL == (pCAContext->pwszCAMachineName)))
			goto MemoryErr;

		//user has selected a CA. Find it in our list
		fFoundCA=FALSE;

		for(dwIndex=1; dwIndex <(pCertCAInfo->dwCA); dwIndex++)
		{
			//skip the 1st CA.  it contains generic information
			if((pCertCAInfo->rgCA)[dwIndex].pwszCAName && (pCertCAInfo->rgCA)[dwIndex].pwszCALocation)
			{
				//the CA has to support the selected CT
				if(CASupportSpecifiedCertType(&((pCertCAInfo->rgCA)[dwIndex])))
				{
					if(0 == wcscmp((pCertCAInfo->rgCA)[dwIndex].pwszCALocation,
									pCAContext->pwszCAMachineName))
					{
						
					   if(CAUtilGetCADisplayName(
						   (pCertWizardInfo->fMachine) ? CA_FIND_LOCAL_SYSTEM:0,
						   (pCertCAInfo->rgCA)[dwIndex].pwszCAName,
						   &pwszCADisplayName))
					   {
							if(0==wcscmp(pwszCADisplayName,
										 pCAContext->pwszCAName))
								fFoundCA=TRUE;
					   }
					   else
					   {
							if(0==wcscmp((pCertCAInfo->rgCA)[dwIndex].pwszCAName,
										 pCAContext->pwszCAName))
								fFoundCA=TRUE;
					   }
						
					   //free the memory
					   if(pwszCADisplayName)
					   {
							WizardFree(pwszCADisplayName);
							pwszCADisplayName=NULL;
					   }

					   if(fFoundCA)
					   {
						    pwszOldName = pCertWizardInfo->pwszCAName;
							pwszOldLocation = pCertWizardInfo->pwszCALocation;

							pCertWizardInfo->pwszCALocation=
								WizardCopyAndFreeWStr((pCertCAInfo->rgCA)[dwIndex].pwszCALocation,
													pwszOldLocation);
							
							pCertWizardInfo->pwszCAName=
								WizardCopyAndFreeWStr((pCertCAInfo->rgCA)[dwIndex].pwszCAName,
													pwszOldName);

							//copy the new data
							pCertWizardInfo->dwCAIndex=dwIndex;

							break;
					   }
					}
				}
			}
		}

		//we should find the selected the CA in our cached CA list
		if(FALSE == fFoundCA)
			goto TraceErr;
	}


    fResult=TRUE;

CommonReturn:

	if(pwszCADisplayName)
	{
		WizardFree(pwszCADisplayName);
		pwszCADisplayName=NULL;
	}
	
    //free the CA list
    if(prgCAContext)
    {
        for(dwIndex=0; dwIndex<dwCACount; dwIndex++)
        {
            if(prgCAContext[dwIndex])
              CryptUIDlgFreeCAContext(prgCAContext[dwIndex]);
        }

        WizardFree(prgCAContext);
    }

    return pCAContext;

ErrorReturn:

	if(pCAContext)
	{
		CryptUIDlgFreeCAContext(pCAContext);
		pCAContext=NULL;
	}

	fResult=FALSE;
	goto CommonReturn;

TRACE_ERROR(TraceErr);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
SET_ERROR(InvalidArgErr, E_INVALIDARG);
}

//--------------------------------------------------------------------------
//
//	  FormatMessageStr
//
//--------------------------------------------------------------------------
int ListView_InsertItemU_IDS(HWND       hwndList,
                         LV_ITEMW       *plvItem,
                         UINT           idsString,
                         LPWSTR         pwszText)
{
    WCHAR   wszText[MAX_STRING_SIZE];


    if(pwszText)
        plvItem->pszText=pwszText;
    else
    {
        if(!LoadStringU(g_hmodThisDll, idsString, wszText, MAX_STRING_SIZE))
		    return -1;

        plvItem->pszText=wszText;
    }

    return ListView_InsertItemU(hwndList, plvItem);
}


//*******************************************************************************
//  WinProc for the enrollment wizard
//
//*******************************************************************************


//--------------------------------------------------------------------------------
//
// Inserts an entry into our confirmation dialog's list view.
//
//--------------------------------------------------------------------------------
void ConfirmationListView_InsertItem(HWND hwndControl, LV_ITEMW *plvItem, UINT idsText, LPCWSTR pwszText)
{
    plvItem->iSubItem=0; 
    
    if (0 == idsText)
    {
        plvItem->pszText = L""; 
        ListView_InsertItemU(hwndControl, plvItem);
    }
    else
        ListView_InsertItemU_IDS(hwndControl, plvItem, idsText, NULL); 

    plvItem->iSubItem++; 
    ListView_SetItemTextU(hwndControl, plvItem->iItem, plvItem->iSubItem, pwszText);
    plvItem->iItem++; 
}

//-------------------------------------------------------------------------
//populate the list box in the order of friendly name,
//UserName, CA, Purpose, and CSP
//-------------------------------------------------------------------------
void    DisplayConfirmation(HWND                hwndControl,
                            CERT_WIZARD_INFO   *pCertWizardInfo)
{
    WCHAR   wszBuffer[MAX_TITLE_LENGTH];
    WCHAR   wszBuffer2[MAX_TITLE_LENGTH]; 
    DWORD   dwIndex=0;
    UINT    ids=0;
    
    LPWSTR  pwszCADisplayName = NULL;

    LV_ITEMW         lvItem;
    CRYPTUI_WIZ_CERT_CA *pCertCA=NULL;

    //delete all the old items in the listView
    ListView_DeleteAllItems(hwndControl);

    //insert row by row
    memset(wszBuffer, 0, sizeof(wszBuffer)); 
    memset(&lvItem,    0, sizeof(LV_ITEMW));

    // set up the fields in the list view item struct that don't change from item to item
    lvItem.mask = LVIF_TEXT | LVIF_STATE ;
    lvItem.state = 0;
    lvItem.stateMask = 0;
    lvItem.iItem = 0; 

    // Friendly Name (only shown for enroll)
    if (0 == (CRYPTUI_WIZ_CERT_RENEW & pCertWizardInfo->dwPurpose))
    {
        LPWSTR pwszFriendlyName = L""; 
        if(pCertWizardInfo->pwszFriendlyName)
        {
            pwszFriendlyName = pCertWizardInfo->pwszFriendlyName; 
        }
        else
        {
            if (LoadStringU(g_hmodThisDll, IDS_NONE, wszBuffer, ARRAYSIZE(wszBuffer)))
                pwszFriendlyName = &wszBuffer[0]; 
        }
        ConfirmationListView_InsertItem(hwndControl, &lvItem, IDS_FRIENDLY_NAME, pwszFriendlyName); 
    }

    //Machine Name/SerivceName/ UserName
    if(pCertWizardInfo->pwszAccountName)
    {
        ConfirmationListView_InsertItem(hwndControl, &lvItem, IDS_USER_NAME, pCertWizardInfo->pwszAccountName); 
    }

    //machine name
    if(pCertWizardInfo->pwszMachineName)
    {
        ConfirmationListView_InsertItem(hwndControl, &lvItem, IDS_COMPUTER_NAME, pCertWizardInfo->pwszMachineName); 
    }

    //CA
    //check if we know exactly which CA to send the request;
    //or we are going through the loop
    if ((TRUE == pCertWizardInfo->fUIAdv) || (TRUE == pCertWizardInfo->fCAInput))
    {
        if(pCertWizardInfo->pwszCAName)
        {
            LPWSTR pwszCAName = NULL; 

            if(pCertWizardInfo->pwszCADisplayName)
                pwszCAName = pCertWizardInfo->pwszCADisplayName; 
            else if (CAUtilGetCADisplayName((pCertWizardInfo->fMachine) ? CA_FIND_LOCAL_SYSTEM:0, pCertWizardInfo->pwszCAName, &pwszCADisplayName))
                pwszCAName = pwszCADisplayName; 
            else
                pwszCAName = pCertWizardInfo->pwszCAName;
         
            ConfirmationListView_InsertItem(hwndControl, &lvItem, IDS_CA, pwszCAName);
        }
    }
    
    //populate the OID name and certtype name (only shown for enroll)
    if (0 == (CRYPTUI_WIZ_CERT_RENEW & pCertWizardInfo->dwPurpose))
    {
        ids = IDS_PURPOSE;
        pCertCA=&(pCertWizardInfo->pCertCAInfo->rgCA[pCertWizardInfo->dwCAIndex]);
        for(dwIndex=0; dwIndex<pCertCA->dwOIDInfo; dwIndex++)
        {
            if(TRUE==((pCertCA->rgOIDInfo[dwIndex]).fSelected))
            {
                ConfirmationListView_InsertItem(hwndControl, &lvItem, ids, (pCertCA->rgOIDInfo[dwIndex]).pwszName); 
                ids = 0; 
            }
        }

        for(dwIndex=0; dwIndex<pCertCA->dwCertTypeInfo; dwIndex++)
        {
            if(TRUE==((pCertCA->rgCertTypeInfo[dwIndex]).fSelected))
            {
                ConfirmationListView_InsertItem(hwndControl, &lvItem, ids, (pCertCA->rgCertTypeInfo[dwIndex]).pwszCertTypeName);
                ids = 0; 
            }
        }
    }

    if(pCertWizardInfo->pwszProvider)
    {
        ConfirmationListView_InsertItem(hwndControl, &lvItem, IDS_CSP, pCertWizardInfo->pwszProvider); 
    }

    // Advanced options: 
    if (TRUE == pCertWizardInfo->fUIAdv)
    {
        // Key creation options:
        if (pCertWizardInfo->fNewKey)
        {
            // Minimum key size: 
            if (pCertWizardInfo->dwMinKeySize)
            {
                WCHAR * const rgParams[1] = { (WCHAR *)(ULONG_PTR) pCertWizardInfo->dwMinKeySize };

                if (FormatMessageU(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY, 
                                   L"%1!d!%0", 0, 0, wszBuffer, ARRAYSIZE(wszBuffer), (va_list *)rgParams))
                {
                    ConfirmationListView_InsertItem(hwndControl, &lvItem, IDS_MIN_KEYSIZE, wszBuffer); 
                }
            }            

            // Is key exportable?
            ids = (0 != (CRYPT_EXPORTABLE & pCertWizardInfo->dwGenKeyFlags)) ? IDS_YES : IDS_NO; 
            if (LoadStringU(g_hmodThisDll, ids, wszBuffer2, ARRAYSIZE(wszBuffer2)))
            {    
                ConfirmationListView_InsertItem(hwndControl, &lvItem, IDS_KEY_EXPORTABLE, wszBuffer2); 
            }
        
            // Is strong key protection enabled?
            ids = (0 != (CRYPT_USER_PROTECTED & pCertWizardInfo->dwGenKeyFlags)) ? IDS_YES : IDS_NO; 
            if (LoadStringU(g_hmodThisDll, ids, wszBuffer, ARRAYSIZE(wszBuffer)))
            {    
                ConfirmationListView_InsertItem(hwndControl, &lvItem, IDS_STRONG_PROTECTION, wszBuffer); 
            }
        }
    }
    
    ListView_SetItemState(hwndControl, 0, LVIS_SELECTED, LVIS_SELECTED);

    //autosize the columns
    ListView_SetColumnWidth(hwndControl, 0, LVSCW_AUTOSIZE);
    ListView_SetColumnWidth(hwndControl, 1, LVSCW_AUTOSIZE);


    // CommonReturn:
    if (NULL != pwszCADisplayName)                     
        WizardFree(pwszCADisplayName);

    return;
}

BOOL GetSelectedCertTypeInfo(IN  CERT_WIZARD_INFO        *pCertWizardInfo, 
			     OUT ENROLL_CERT_TYPE_INFO  **ppCertTypeInfo)
{
    DWORD                 dwIndex; 
    PCRYPTUI_WIZ_CERT_CA  pCertCA; 

    if (pCertWizardInfo == NULL)
	return FALSE; 

    pCertCA=&(pCertWizardInfo->pCertCAInfo->rgCA[pCertWizardInfo->dwCAIndex]);
    for(dwIndex=0; dwIndex<pCertCA->dwCertTypeInfo; dwIndex++)
    {
	if((pCertCA->rgCertTypeInfo)[dwIndex].fSelected)
	{
	    *ppCertTypeInfo = &((pCertCA->rgCertTypeInfo)[dwIndex]); 
	    return TRUE; 
	 }  
    }

    return FALSE; 
}

//-----------------------------------------------------------------------
//Initialize the CSP list
//-----------------------------------------------------------------------
BOOL    InitCSPList(HWND                   hwndList,
                    CERT_WIZARD_INFO       *pCertWizardInfo)
{
    DWORD                       dwMinSize;
    DWORD                       dwMaxSize;
    DWORD                       dwInc;
    LV_ITEMW                    lvItem;
    CRYPTUI_WIZ_CERT_CA         *pCertCA=NULL;
    ENROLL_CERT_TYPE_INFO       *pCertTypeInfo=NULL;
    int                         iInsertedIndex=0;

    if(!hwndList || !pCertWizardInfo)
        return FALSE;

    if(!(pCertWizardInfo->pCertCAInfo) || !(pCertWizardInfo->pwszCALocation) ||
        !(pCertWizardInfo->pwszCAName))
        return FALSE;

    //delete all the old items in the listView
    ListView_DeleteAllItems(hwndList);

    //populate the list
    memset(&lvItem, 0, sizeof(LV_ITEMW));
    lvItem.mask=LVIF_TEXT | LVIF_STATE | LVIF_PARAM;

    pCertCA=&(pCertWizardInfo->pCertCAInfo->rgCA[pCertWizardInfo->dwCAIndex]);
    pCertTypeInfo = NULL; 
    GetSelectedCertTypeInfo(pCertWizardInfo, &pCertTypeInfo); 

    // Populate the CSP list with the intersection of: 
    //       1) The available CSPs on the local machine 
    //   and 2) The CSPs specified on the template.  
    //
    // If no template information is available, or the template does not specify
    // a CSP, enumerate all CSPs.
    //
    for(DWORD dwLocalCSPIndex = 0; dwLocalCSPIndex < pCertWizardInfo->dwCSPCount; dwLocalCSPIndex++)
    {
        BOOL fUseCSP = FALSE; 

        if (NULL == pCertTypeInfo) 
        {
            fUseCSP = TRUE; 
        }
        else 
        {
            for (DWORD dwTemplateCSPIndex = 0; dwTemplateCSPIndex < pCertTypeInfo->dwCSPCount; dwTemplateCSPIndex++) 
            {
                if(dwLocalCSPIndex == pCertTypeInfo->rgdwCSP[dwTemplateCSPIndex])
                {
                    // The CSP is specified in the template, so we can use it,
                    // if it supports an algorithm / key size that matches
                    // the template information. 
                    if (GetValidKeySizes
                        ((pCertWizardInfo->rgwszProvider)[dwLocalCSPIndex],
                         (pCertWizardInfo->rgdwProviderType)[dwLocalCSPIndex], 
                         pCertTypeInfo->dwKeySpec, 
                         &dwMinSize,
                         &dwMaxSize, 
                         &dwInc))
                    {
                        fUseCSP = dwMaxSize >= pCertTypeInfo->dwMinKeySize;
                    }

                    break; 
                }
            }
        }

        if (fUseCSP)
        {
            lvItem.iItem        = dwLocalCSPIndex;
            lvItem.pszText      = (pCertWizardInfo->rgwszProvider)[dwLocalCSPIndex];
            lvItem.cchTextMax   = sizeof(WCHAR)*(1+wcslen((pCertWizardInfo->rgwszProvider)[dwLocalCSPIndex]));
            lvItem.lParam       = (LPARAM)dwLocalCSPIndex;
            
            //insert the item,
            iInsertedIndex = ListView_InsertItemU(hwndList, &lvItem);
        
            // Highlight a CSP if it is already specified through the advanced
            // options.  If not, highlight the first CSP on the template. 
            // 
            BOOL fHighlightCSP = FALSE; 
        
            if (pCertWizardInfo->pwszProvider)
            {
                fHighlightCSP = 0 == _wcsicmp(pCertWizardInfo->pwszProvider, lvItem.pszText); 
            }
            else
            {
                if (NULL != pCertTypeInfo && pCertTypeInfo->dwCSPCount > 0)
                {
                    //we highlight the 1st one of the intersection if there is any
                    fHighlightCSP = dwLocalCSPIndex == pCertTypeInfo->rgdwCSP[0];
                }
                else
                {
                    // We don't highlight a CSP in this case.  
                }
            }

            if (fHighlightCSP)
            {
                ListView_SetItemState
                    (hwndList, 
                     iInsertedIndex,
                     LVIS_SELECTED,
                     LVIS_SELECTED);
                
                ListView_EnsureVisible
                    (hwndList,
                     iInsertedIndex, 
                     FALSE);
            }
        }
    }    
        
    //make the column autosize
    ListView_SetColumnWidth(hwndList, 0, LVSCW_AUTOSIZE);

    return TRUE;
}


BOOL CSPListIndexToCertWizardInfoIndex(IN  HWND   hwnd, 
				       IN  int   nCSPIndex,
				       OUT DWORD *pdwWizardIndex)
{
    LVITEM lvItem; 
    
    if (hwnd == NULL || nCSPIndex < 0)
	return FALSE; 

    memset(&lvItem, 0, sizeof(LV_ITEM));
    lvItem.mask  = LVIF_PARAM;
    lvItem.iItem = nCSPIndex;

    if(!ListView_GetItem(hwnd, &lvItem))
	return FALSE; 

    *pdwWizardIndex = (DWORD)lvItem.lParam; 
    return TRUE;
}

BOOL InitKeySizesList(IN HWND    hWnd,           // Required:  The combo box to initialize.
                      IN DWORD   dwCTMinKeySize, // Required:  The min key size specified on the template
		      IN LPWSTR  lpwszProvider,  // Required:  The CSP.
		      IN DWORD   dwProvType,     // Required:  The provider type.
		      IN DWORD   dwKeySpec       // Required:  Either AT_SIGNATURE or AT_KEYEXCHANGE. 
		      )
{
    static const DWORD dwSmallValidKeySizes[] = { 40, 56, 64, 128, 256, 384 }; 
    static const DWORD dwLargeValidKeySizes[] = { 512, 1024, 2048, 4096, 8192, 16384 }; 
    static const DWORD dwAllValidKeySizes[]   = { 40, 56, 64, 128, 256, 384, 512, 1024, 2048, 4096, 8192, 16384 }; 

    static const DWORD dwSmLen  = sizeof(dwSmallValidKeySizes) / sizeof(DWORD); 
    static const DWORD dwLgLen  = sizeof(dwLargeValidKeySizes) / sizeof(DWORD); 
    static const DWORD dwAllLen = sizeof(dwAllValidKeySizes) / sizeof(DWORD); 

    static const DWORD MAX_KEYSIZE_STRING_SIZE = sizeof(WCHAR) * 8; 
    static       WCHAR ppwszStrings[dwAllLen][MAX_KEYSIZE_STRING_SIZE]; 
    
    BOOL          fIsLargeKey = FALSE; 
    BOOL          fIsSmallKey = FALSE; 
    BOOL          fResult     = FALSE; 
    DWORD         dwMinSize;
    DWORD         dwMaxSize;
    DWORD         dwInc; 
    const DWORD  *pdwValidKeySizes; 
    DWORD         dwValidKeySizesLen; 

    // Temporaries: 
    DWORD   dwCurrent; 
    DWORD   dwIndex; 


    // Validate inputs: 
    if (hWnd == NULL || lpwszProvider == NULL)
    {
	SetLastError(ERROR_INVALID_PARAMETER);
	goto Error;
    }

    // First, delete all items present in the list view. 
    // (This always succeeds). 
    SendMessage(hWnd, CB_RESETCONTENT, (WPARAM)0, (LPARAM)0); 

    if (!GetValidKeySizes
	(lpwszProvider, 
	 dwProvType,
	 dwKeySpec,
	 &dwMinSize,
	 &dwMaxSize,
	 &dwInc))
	goto Error; 

    if (dwCTMinKeySize > dwMinSize) { 
        dwMinSize = dwCTMinKeySize;
    }

    fIsLargeKey = dwMinSize >= 512;
    fIsSmallKey = dwMaxSize <  512; 

    if (fIsLargeKey)
    {
	pdwValidKeySizes   = &dwLargeValidKeySizes[0]; 
	dwValidKeySizesLen = dwLgLen;
    }
    else if (fIsSmallKey)

    {
	pdwValidKeySizes   = &dwSmallValidKeySizes[0];
	dwValidKeySizesLen = dwSmLen;
    }
    else 
    {
	pdwValidKeySizes   = &dwAllValidKeySizes[0]; 
	dwValidKeySizesLen = dwAllLen;
    }

    for (dwCurrent = 0, dwIndex = 0; dwCurrent < dwValidKeySizesLen; dwCurrent++)
    {
	if (pdwValidKeySizes[dwCurrent] > dwMaxSize)
	    break;

	if (pdwValidKeySizes[dwCurrent] < dwMinSize)
	    continue; 

	if ((dwInc == 0) || (0 == (pdwValidKeySizes[dwCurrent] % dwInc)))
	{
	    if (CB_ERR == SendMessageW
		(hWnd, 
		 CB_ADDSTRING, 
		 0, 
		 (LPARAM)_ltow(pdwValidKeySizes[dwCurrent], &ppwszStrings[dwIndex][0], 10)))
		goto Error; 

	    if (CB_ERR == SendMessage
		(hWnd, 
		 CB_SETITEMDATA, 
		 (WPARAM)dwIndex, 
		 (LPARAM)pdwValidKeySizes[dwCurrent]))
		goto Error; 

	    // Default to 1024-bit keys if we can. 
	    if (dwIndex == 0 || pdwValidKeySizes[dwCurrent] == 1024)
		SendMessage(hWnd, CB_SETCURSEL, dwIndex, (LPARAM)0); 

	    dwIndex++; 
	}
    }

    fResult = TRUE; 

 CommonReturn: 
    return fResult; 

 Error: 
    fResult = FALSE;
    goto CommonReturn; 
}

//-----------------------------------------------------------------------
//ExistInListView:
//  
//  Check to see if the cert type is alreayd in the list view
//  based on its display name
//-----------------------------------------------------------------------
BOOL    ExistInListView(HWND    hwndList, LPWSTR   pwszDisplayName)
{
    BOOL            fExist=FALSE;
    LVFINDINFOW     lvfi;


    if((NULL == hwndList) || (NULL == pwszDisplayName))
        return FALSE;

    memset(&lvfi, 0, sizeof(LVFINDINFOW));

    lvfi.flags=LVFI_STRING;
    lvfi.psz=pwszDisplayName;

    if(-1 == SendMessageW(hwndList, 
                        LVM_FINDITEMW,
                        (WPARAM)-1,
                        (LPARAM)(&lvfi)))
        fExist=FALSE;
    else
        fExist=TRUE;

    return fExist;
}

//--------------------------------------------------------------------------------
// IsKeyProtected() 
// 
// Determines whether or not a key has strong key protection enabled. 
// Should be used only with user keysets.
// 
//--------------------------------------------------------------------------------
HRESULT IsKeyProtected(IN   LPWSTR   pwszContainerName,
		       IN   LPWSTR   pwszProviderName, 
		       IN   DWORD    dwProvType, 
		       OUT  BOOL    *pfIsProtected)
{
    DWORD       cbData; 
    DWORD       dwImpType; 
    HCRYPTPROV  hCryptProv  = NULL; 
    HRESULT     hr; 

    if (NULL == pwszContainerName || NULL == pwszProviderName || NULL == pfIsProtected)
	goto InvalidArgError;

    *pfIsProtected = FALSE; 

    // Get the provider context with no key access.
    if (!CryptAcquireContextW(&hCryptProv, NULL, pwszProviderName, dwProvType, CRYPT_VERIFYCONTEXT))
	goto CryptAcquireContextError;

    cbData = sizeof(dwImpType);
    if (!CryptGetProvParam(hCryptProv, PP_IMPTYPE, (PBYTE) &dwImpType, &cbData, 0))
	goto CryptGetProvParamError;
 
    // Assume hardware key is protected.
    if (dwImpType & CRYPT_IMPL_HARDWARE) { 
	*pfIsProtected = TRUE; 
    } else { 

	// Reacquire context with silent flag.
	CryptReleaseContext(hCryptProv, 0);
	hCryptProv = NULL;
 
	if (!CryptAcquireContextW(&hCryptProv, pwszContainerName, pwszProviderName, dwProvType, CRYPT_SILENT)) { 
	    // CryptAcquireContextW with silent flag, assume user protected
	    *pfIsProtected = TRUE; 
        }
    }

    hr = S_OK; 
 ErrorReturn: 
    if (hCryptProv)
        CryptReleaseContext(hCryptProv, 0);
    return hr;

SET_HRESULT(CryptAcquireContextError, HRESULT_FROM_WIN32(GetLastError())); 
SET_HRESULT(CryptGetProvParamError,   HRESULT_FROM_WIN32(GetLastError())); 
SET_HRESULT(InvalidArgError,          E_INVALIDARG); 
}


//-----------------------------------------------------------------------
//Initialize the usage OID/CertType list
//-----------------------------------------------------------------------
BOOL    InitCertTypeList(HWND                   hwndList,
                         CERT_WIZARD_INFO       *pCertWizardInfo)
{
    BOOL                        fIsKeyProtected; 
    DWORD                       dwCAIndex=0;
    DWORD                       dwCTIndex=0;
    HRESULT                     hr; 
    LV_ITEMW                    lvItem;
    BOOL                        fSelected=FALSE;
    int                         iInsertedIndex=0;
    DWORD                       dwValidCTCount=0;
    ENROLL_CERT_TYPE_INFO       *pCertTypeInfo=NULL;

    if(!hwndList || !pCertWizardInfo)
        return FALSE;

    if(!(pCertWizardInfo->pCertCAInfo) || !(pCertWizardInfo->pwszCALocation) ||
        !(pCertWizardInfo->pwszCAName))
        return FALSE;

    //delete all the old items in the listView
    ListView_DeleteAllItems(hwndList);

    //populate the list
    memset(&lvItem, 0, sizeof(LV_ITEMW));
    lvItem.mask=LVIF_TEXT | LVIF_STATE | LVIF_PARAM;

    // if we're doing an enroll with same key, see whether it has strong key protection:
    if (!pCertWizardInfo->fNewKey) { 
	hr = IsKeyProtected((LPWSTR)pCertWizardInfo->pwszKeyContainer, 
			    (LPWSTR)pCertWizardInfo->pwszProvider,
			    pCertWizardInfo->dwProviderType, 
			    &fIsKeyProtected); 
	if (FAILED(hr)) { 
	    // assume no key protection
	    fIsKeyProtected = FALSE;
	}
    }

    //populate the certType name
    //we search for each CA 

    dwValidCTCount=0;

    //we start from the 1st CA
    for(dwCAIndex=1; dwCAIndex<pCertWizardInfo->pCertCAInfo->dwCA; dwCAIndex++)
    {  
        for(dwCTIndex=0; dwCTIndex <(pCertWizardInfo->pCertCAInfo->rgCA)[dwCAIndex].dwCertTypeInfo; dwCTIndex++)
        {
            pCertTypeInfo=&((pCertWizardInfo->pCertCAInfo->rgCA)[dwCAIndex].rgCertTypeInfo[dwCTIndex]);

            // if the template specifies strong key protection but our key doesn't have it, filter the template out
            if (!pCertWizardInfo->fNewKey && !fIsKeyProtected && (CT_FLAG_STRONG_KEY_PROTECTION_REQUIRED & pCertTypeInfo->dwPrivateKeyFlags))
                continue; 
	    
            //make sure that we do not have duplicated entries
            if(!ExistInListView(hwndList, pCertTypeInfo->pwszCertTypeName))
            {
                lvItem.iItem=dwValidCTCount;

                lvItem.pszText=pCertTypeInfo->pwszCertTypeName;
                lvItem.cchTextMax=sizeof(WCHAR)* (1+wcslen(pCertTypeInfo->pwszCertTypeName));

                lvItem.lParam=(LPARAM)pCertTypeInfo->pwszDNName;

                //insert the item,
                iInsertedIndex=ListView_InsertItemU(hwndList, &lvItem);

                //set the item to be selected
                if(pCertTypeInfo->fSelected)
                {
                    ListView_SetItemState(
                                    hwndList,
                                    iInsertedIndex,
                                    LVIS_SELECTED,
                                    LVIS_SELECTED);
                   fSelected=TRUE;
                }

                dwValidCTCount++;
            }
        }
    }

    //select the 1st item is nothing has been selected
    if(FALSE == fSelected)
        ListView_SetItemState(
                            hwndList,
                            0,
                            LVIS_SELECTED,
                            LVIS_SELECTED);

    //make the column autosize
    ListView_SetColumnWidth(hwndList, 0, LVSCW_AUTOSIZE);

    return TRUE;
}

//-----------------------------------------------------------------------
//  MarkSelectedCertType:
//
//      Based on the user's certificate type selection, we mark the selected
//  certType.   Also, check to see based on the selected certificate type, if we 
//  have to show the CSP page.  That is, use did not specify a CSP
//  via the API, and the certificate type has no default CSP list.

//-----------------------------------------------------------------------
void    MarkSelectedCertType(CERT_WIZARD_INFO       *pCertWizardInfo,
                             LPWSTR pwszDNName)
{
    DWORD                       dwCAIndex=0;
    DWORD                       dwCTIndex=0;
    PCRYPTUI_WIZ_CERT_CA        pCertCA=NULL;
    PCRYPTUI_WIZ_CERT_CA_INFO   pCertCAInfo=NULL;


    pCertCAInfo=pCertWizardInfo->pCertCAInfo;

    if(NULL == pCertCAInfo)
        return;

    //we start from the 1st CA
    for(dwCAIndex=1; dwCAIndex<pCertCAInfo->dwCA; dwCAIndex++)
    {
        pCertCA=&(pCertCAInfo->rgCA[dwCAIndex]);
       
        for(dwCTIndex=0; dwCTIndex < pCertCA->dwCertTypeInfo; dwCTIndex++)
        {
            if(0 == wcscmp(pwszDNName, pCertCA->rgCertTypeInfo[dwCTIndex].pwszDNName))
            {
                pCertCA->rgCertTypeInfo[dwCTIndex].fSelected=TRUE;

                if((NULL == pCertWizardInfo->pwszProvider)&&
                   (0==pCertCA->rgCertTypeInfo[dwCTIndex].dwCSPCount)
                   )
                    pCertWizardInfo->fUICSP=TRUE;
                
                if (0 != (CT_FLAG_EXPORTABLE_KEY & pCertCA->rgCertTypeInfo[dwCTIndex].dwPrivateKeyFlags))
                {
                    pCertWizardInfo->dwGenKeyFlags |= CRYPT_EXPORTABLE; 
                } 
                else
                {
                    pCertWizardInfo->dwGenKeyFlags &= ~CRYPT_EXPORTABLE; 
                }

		if (0 != (CT_FLAG_STRONG_KEY_PROTECTION_REQUIRED & pCertCA->rgCertTypeInfo[dwCTIndex].dwPrivateKeyFlags))
		{
                    pCertWizardInfo->dwGenKeyFlags |= CRYPT_USER_PROTECTED; 
		}
		else
		{
                    pCertWizardInfo->dwGenKeyFlags &= ~CRYPT_USER_PROTECTED; 
		}

            }
            else
                pCertCA->rgCertTypeInfo[dwCTIndex].fSelected=FALSE;
        }
     }
}

//-----------------------------------------------------------------------
//  ResetDefaultCA:
//  
//      Based on the selected certificate type, we reset the default
//  value for the Ceritification Authority
//-----------------------------------------------------------------------
void    ResetDefaultCA(CERT_WIZARD_INFO       *pCertWizardInfo)
{
    LPWSTR                      pwszOldCALocation=NULL;
    LPWSTR                      pwszOldCAName=NULL;

    DWORD                       dwCAIndex=0;
    PCRYPTUI_WIZ_CERT_CA        pCertCA=NULL;
    PCRYPTUI_WIZ_CERT_CA_INFO   pCertCAInfo=NULL;
    BOOL                        fFound=FALSE;


    pCertCAInfo=pCertWizardInfo->pCertCAInfo;

    if(NULL == pCertCAInfo)
        return;

    //if user has specified a CA, then this CA has priority other the rest
    if(pCertWizardInfo->fCAInput)
    {

        dwCAIndex=pCertWizardInfo->dwOrgCA;
        
        pCertCA=&(pCertCAInfo->rgCA[dwCAIndex]);
       
        fFound=CASupportSpecifiedCertType(pCertCA);

    }

    //we do a generic search if the priority CA does not satisfy the requirements
    if(FALSE == fFound)
    {
        //we start from the 1st CA
        for(dwCAIndex=1; dwCAIndex<pCertCAInfo->dwCA; dwCAIndex++)
        {
            pCertCA=&(pCertCAInfo->rgCA[dwCAIndex]);
       
            if(TRUE == (fFound=CASupportSpecifiedCertType(pCertCA)))
                break;
         }
    }

     if(FALSE == fFound)
         return;

     //copy the old data
     pwszOldCALocation=pCertWizardInfo->pwszCALocation;
     pwszOldCAName=pCertWizardInfo->pwszCAName;


     pCertWizardInfo->pwszCALocation=WizardAllocAndCopyWStr(pCertCAInfo->rgCA[dwCAIndex].pwszCALocation);
     pCertWizardInfo->pwszCAName=WizardAllocAndCopyWStr(pCertCAInfo->rgCA[dwCAIndex].pwszCAName);

     if(NULL == pCertWizardInfo->pwszCALocation ||
        NULL == pCertWizardInfo->pwszCAName)
     {
        //free the memory
         if(pCertWizardInfo->pwszCALocation)
             WizardFree(pCertWizardInfo->pwszCALocation);

         if(pCertWizardInfo->pwszCAName)
             WizardFree(pCertWizardInfo->pwszCAName);

         pCertWizardInfo->pwszCALocation=pwszOldCALocation;
         pCertWizardInfo->pwszCAName=pwszOldCAName;

         return;
     }

     pCertWizardInfo->dwCAIndex=dwCAIndex;

     if(pwszOldCALocation)
         WizardFree(pwszOldCALocation);

     if(pwszOldCAName)
         WizardFree(pwszOldCAName);
}


//-----------------------------------------------------------------------
//enable the window if small card if selected
//-----------------------------------------------------------------------
void    EnableIfSmartCard(HWND  hwndControl, HWND hwndChkBox)
{
    LPWSTR                  pwszText=NULL;

    WCHAR                   wszCSPName[MAX_STRING_SIZE];
    DWORD                   dwChar=0;
    int                     iItem=0;

    //get the length of the selected item
    iItem=(int)SendMessage(hwndControl, LB_GETCURSEL, 0, 0);

    dwChar=(DWORD)SendMessage(hwndControl,
                       LB_GETTEXTLEN,
                       iItem,
                       0);

    //allocate memory
    if(NULL==(pwszText=(LPWSTR)WizardAlloc(sizeof(WCHAR)*(1+dwChar))))
        return;

    //get the selected CSP name
    if(LB_ERR==Send_LB_GETTEXT(hwndControl,
                    iItem,
                    (LPARAM)pwszText))
        goto CLEANUP;

    //get the smart card name
    if(!LoadStringU(g_hmodThisDll, IDS_SMART_CARD, wszCSPName, MAX_STRING_SIZE))
        goto CLEANUP;

    if(0==wcscmp(wszCSPName, pwszText))
         //enable the box
        EnableWindow(hwndChkBox, TRUE);
    else
        //gray out the box
        EnableWindow(hwndChkBox, FALSE);

CLEANUP:
    if(pwszText)
        WizardFree(pwszText);
}



//-----------------------------------------------------------------------
//
//The winProc for each of the enrollment wizard page
//
//-----------------------------------------------------------------------


//-----------------------------------------------------------------------
//Welcome
//-----------------------------------------------------------------------
INT_PTR APIENTRY Enroll_Welcome(HWND hwndDlg, UINT msg, WPARAM /*wParam*/, LPARAM lParam)
{
    CERT_WIZARD_INFO        *pCertWizardInfo=NULL;
    PROPSHEETPAGE           *pPropSheet=NULL;


	switch (msg)
	{
		case WM_INITDIALOG:
            //set the wizard information so that it can be shared
            pPropSheet = (PROPSHEETPAGE *) lParam;
            pCertWizardInfo = (CERT_WIZARD_INFO *) (pPropSheet->lParam);
            SetWindowLongPtr(hwndDlg, DWLP_USER, (LONG_PTR)pCertWizardInfo);

            SetControlFont(pCertWizardInfo->hBigBold, hwndDlg,IDC_WIZARD_STATIC_BIG_BOLD1);
           // SetControlFont(pCertWizardInfo->hBold, hwndDlg,IDC_WIZARD_STATIC_BOLD1);
           //  SetControlFont(pCertWizardInfo->hBold, hwndDlg,IDC_WIZARD_STATIC_BOLD2);
			break;

		case WM_NOTIFY:
    		    switch (((NMHDR FAR *) lParam)->code)
    		    {

  				    case PSN_KILLACTIVE:
                            SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
					        return TRUE;

                        break;

				    case PSN_RESET:
                            SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
					    break;

 				    case PSN_SETACTIVE:
 					    PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_NEXT);
					    break;

                    case PSN_WIZBACK:
                        break;

                    case PSN_WIZNEXT:

                        break;

				    default:
					    return FALSE;

    	        }
		    break;

		default:
			return FALSE;
	}

	return TRUE;
}


//-----------------------------------------------------------------------
//Purpose
//-----------------------------------------------------------------------
INT_PTR APIENTRY Enroll_Purpose(HWND hwndDlg, UINT msg, WPARAM /*wParam*/, LPARAM lParam)
{
    CERT_WIZARD_INFO        *pCertWizardInfo=NULL;
    PROPSHEETPAGE           *pPropSheet=NULL;
    HWND                    hwndControl=NULL;
    DWORD                   dwIndex=0;

    LV_COLUMNW                  lvC;
    LV_ITEM                     lvItem;

    NM_LISTVIEW FAR *           pnmv=NULL;

	switch (msg)
	{
		case WM_INITDIALOG:
            //set the wizard information so that it can be shared
            pPropSheet = (PROPSHEETPAGE *) lParam;
            pCertWizardInfo = (CERT_WIZARD_INFO *) (pPropSheet->lParam);

            //make sure pCertWizardInfo is a valid pointer
            if(NULL==pCertWizardInfo)
                break;

            SetWindowLongPtr(hwndDlg, DWLP_USER, (LONG_PTR)pCertWizardInfo);

            SetControlFont(pCertWizardInfo->hBold, hwndDlg,IDC_WIZARD_STATIC_BOLD1);

            //by default, we do not use the advanced options
            SendMessage(GetDlgItem(hwndDlg, IDC_WIZARD_CHECK1), BM_SETCHECK, 0, 0);  


            if(NULL!=(hwndControl=GetDlgItem(hwndDlg, IDC_WIZARD_LIST1)))
            {
                //insert a column into the list view
                memset(&lvC, 0, sizeof(LV_COLUMNW));

                lvC.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
                lvC.fmt = LVCFMT_LEFT;  // Left-align the column.
                lvC.cx = 20; //(dwMaxSize+2)*7;            // Width of the column, in pixels.
                lvC.pszText = L"";   // The text for the column.
                lvC.iSubItem=0;

                if (ListView_InsertColumnU(hwndControl, 0, &lvC) == -1)
                    break;

                //initizialize the cert type
                InitCertTypeList(GetDlgItem(hwndDlg, IDC_WIZARD_LIST1),
                    pCertWizardInfo);

            }

			break;

		case WM_COMMAND:
			break;	
						
		case WM_NOTIFY:
    		    switch (((NMHDR FAR *) lParam)->code)
    		    {
                    //the item has been selected
                    case LVN_ITEMCHANGED:

                            //get the window handle of the purpose list view
                            if(NULL==(hwndControl=GetDlgItem(hwndDlg, IDC_WIZARD_LIST1)))
                                break;

                            if(NULL==(pCertWizardInfo=(CERT_WIZARD_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                                break;

                            pnmv = (LPNMLISTVIEW) lParam;

                            if(NULL==pnmv)
                                break;

                            //we try not to let user de-select cert template
                            if((pnmv->uOldState & LVIS_SELECTED) && (0 == (pnmv->uNewState & LVIS_SELECTED)))
                            {
                                 //we should have something selected
                                 if(-1 == ListView_GetNextItem(
                                        hwndControl, 		
                                        -1, 		
                                        LVNI_SELECTED		
                                    ))
                                 {
                                    //we should re-select the original item
                                    ListView_SetItemState(
                                                        hwndControl,
                                                        pnmv->iItem,
                                                        LVIS_SELECTED,
                                                        LVIS_SELECTED);

                                    pCertWizardInfo->iOrgCertType=pnmv->iItem;
                                 }
                            }

                            //if something is selected, we disable all other selection
                            if(pnmv->uNewState & LVIS_SELECTED)
                            {
                                if(pnmv->iItem != pCertWizardInfo->iOrgCertType && -1 != pCertWizardInfo->iOrgCertType)
                                {
                                    //we should de-select the original item

                                    ListView_SetItemState(
                                                        hwndControl,
                                                        pCertWizardInfo->iOrgCertType,
                                                        0,
                                                        LVIS_SELECTED);

                                    pCertWizardInfo->iOrgCertType=-1;
                                }
                            }

                        break;
  				    case PSN_KILLACTIVE:
                            SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
					        return TRUE;

                        break;

				    case PSN_RESET:
                            SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
					    break;

 				    case PSN_SETACTIVE:
 					        PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_NEXT|PSWIZB_BACK);

                            if(NULL==(pCertWizardInfo=(CERT_WIZARD_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                                break;

                            //if the adv selection is made, it has to stay selected
                            if(pCertWizardInfo->fUIAdv)
                                EnableWindow(GetDlgItem(hwndDlg, IDC_WIZARD_CHECK1), FALSE);

					    break;

                    case PSN_WIZBACK:

                        break;

                    case PSN_WIZNEXT:

                            if(NULL==(pCertWizardInfo=(CERT_WIZARD_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                                break;

                            //get the window handle of the purpose list view
                            if(NULL==(hwndControl=GetDlgItem(hwndDlg, IDC_WIZARD_LIST1)))
                                break;

                             //now, mark the one that is selected
                             if(-1 != (dwIndex= ListView_GetNextItem(
                                    hwndControl, 		
                                    -1, 		
                                    LVNI_SELECTED		
                                )))	
                             {

                                //get the selected certificate
                                memset(&lvItem, 0, sizeof(LV_ITEM));
                                lvItem.mask=LVIF_PARAM;
                                lvItem.iItem=(int)dwIndex;

                                if(ListView_GetItem(hwndControl,
                                                 &lvItem))
                                {

                                    pCertWizardInfo->fCertTypeChanged=FALSE;

                                    if(NULL == pCertWizardInfo->pwszSelectedCertTypeDN)
                                         pCertWizardInfo->fCertTypeChanged=TRUE;
                                    else
                                    {
                                        if(0 != wcscmp(pCertWizardInfo->pwszSelectedCertTypeDN,
                                                       (LPWSTR)lvItem.lParam))
                                           pCertWizardInfo->fCertTypeChanged=TRUE;
                                    }

                                    if(pCertWizardInfo->fCertTypeChanged)
                                    {
                                        pCertWizardInfo->pwszSelectedCertTypeDN=(LPWSTR)(lvItem.lParam);

                                        //we need to reset the CSP
                                        if(FALSE == pCertWizardInfo->fKnownCSP)
                                        {
                                            pCertWizardInfo->pwszProvider=NULL;
                                            pCertWizardInfo->dwProviderType=0;
                                        }
                                        else
                                        {
                                            //we convert to the original selected CSP information
                                           pCertWizardInfo->dwProviderType=pCertWizardInfo->dwOrgCSPType;
                                           pCertWizardInfo->pwszProvider=pCertWizardInfo->pwszOrgCSPName;
                                        }

                                        pCertWizardInfo->fUICSP=FALSE;

                                        //mark the selected cert type and mark the rest as un-selected  
                                        MarkSelectedCertType(pCertWizardInfo,
                                                            (LPWSTR)lvItem.lParam);

                                        //we need to reset the default CA information based on the new CertType
                                        ResetDefaultCA(pCertWizardInfo);
                                    }
                                }
                                else
                                {
                                    I_MessageBox(hwndDlg, IDS_NO_SELECTED_PURPOSE,
                                                    pCertWizardInfo->idsConfirmTitle,
                                                    pCertWizardInfo->pwszConfirmationTitle,
                                                    MB_ICONEXCLAMATION|MB_OK|MB_APPLMODAL);

                                    //make the purpose page stay
                                    SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);

                                break;
                                }
                             }
                            else
                            {
                                I_MessageBox(hwndDlg, IDS_NO_SELECTED_PURPOSE,
                                                pCertWizardInfo->idsConfirmTitle,
                                                pCertWizardInfo->pwszConfirmationTitle,
                                                MB_ICONEXCLAMATION|MB_OK|MB_APPLMODAL);

                                //make the purpose page stay
                                SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);

                                break;

                            }

                            //check for the advanced options
                            if(TRUE==SendDlgItemMessage(hwndDlg,IDC_WIZARD_CHECK1, BM_GETCHECK, 0, 0))
                                pCertWizardInfo->fUIAdv=TRUE;
                            else
                                pCertWizardInfo->fUIAdv=FALSE;

                            //skip to the correct page based on the advanced options and CSP requirement
                            if(FALSE == pCertWizardInfo->fUIAdv)
                            {
                                if(TRUE == pCertWizardInfo->fUICSP)
                                    SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_CSP_SERVICE_PROVIDER);
                                else
                                    SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_NAME_DESCRIPTION);
                            }
                            else
                            {
                                if(FALSE == pCertWizardInfo->fNewKey)
                                    SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_CERTIFICATE_AUTHORITY);
                            }


                        break;

				    default:
					    return FALSE;

    	        }
		    break;

		default:
			return FALSE;
	}

	return TRUE;
}

//-----------------------------------------------------------------------
//CSP
//-----------------------------------------------------------------------
INT_PTR APIENTRY Enroll_CSP(HWND hwndDlg, UINT msg, WPARAM /*wParam*/, LPARAM lParam)
{
    CERT_WIZARD_INFO        *pCertWizardInfo=NULL;
    ENROLL_CERT_TYPE_INFO   *pCertTypeInfo=NULL; 
    PROPSHEETPAGE           *pPropSheet=NULL;

    DWORD                   dwMinKeySize=0; 
    DWORD                   dwIndex=0;
    int                     nSelected=0; 
    DWORD                   dwSelected=0;
    HWND                    hwndControl=NULL;

    LV_COLUMNW                  lvC;
    LV_ITEM                     lvItem;

    NM_LISTVIEW FAR *           pnmv=NULL;

    switch (msg)
    {
    case WM_INITDIALOG:
        //set the wizard information so that it can be shared
        pPropSheet = (PROPSHEETPAGE *) lParam;
        pCertWizardInfo = (CERT_WIZARD_INFO *) (pPropSheet->lParam);

        //make sure pCertWizardInfo is a valid pointer
        if(NULL==pCertWizardInfo)
            break;

        // Get the selected cert type info
        pCertTypeInfo = NULL; 
        GetSelectedCertTypeInfo(pCertWizardInfo, &pCertTypeInfo); 

        SetWindowLongPtr(hwndDlg, DWLP_USER, (LONG_PTR)pCertWizardInfo);

        SetControlFont(pCertWizardInfo->hBold, hwndDlg,IDC_WIZARD_STATIC_BOLD1);

        //set the check box for the exportable key option
        if(NULL==(hwndControl=GetDlgItem(hwndDlg, IDC_WIZARD_CHECK_EXPORTKEY)))
            break;

        // determine whether the exportable checkbox should be set
        // The checkbox is set if:
        //     1) The CT_FLAG_EXPORTABLE_KEY flag is set on the template AND
        //     2) The user has not unchecked this checkbox
        if (pCertWizardInfo->fNewKey && (0 != (CRYPT_EXPORTABLE & pCertWizardInfo->dwGenKeyFlags)))
            SendMessage(hwndControl, BM_SETCHECK, BST_CHECKED, 0);
        else
            SendMessage(hwndControl, BM_SETCHECK, BST_UNCHECKED, 0);

        if (NULL != pCertTypeInfo)
            EnableWindow(hwndControl, 0 != (CT_FLAG_EXPORTABLE_KEY & pCertTypeInfo->dwPrivateKeyFlags));

        //set the check box for the user protection option
        if(NULL==(hwndControl=GetDlgItem(hwndDlg, IDC_WIZARD_CHECK2)))
            break;

	// determine whether the strong key protection checkbox should be set
	if (0 != (CRYPT_USER_PROTECTED & pCertWizardInfo->dwGenKeyFlags)) { 
	    // if this bit is set in the INITDIALOG handler, it's either
	    // from the template or the previous key.  Enforce the setting
	    // by disabling the checkbox
	    SendMessage(hwndControl, BM_SETCHECK, BST_CHECKED, 0);
            EnableWindow(hwndControl, FALSE);
	} else { 
	    SendMessage(hwndControl, BM_SETCHECK, BST_UNCHECKED, 0);
	}

        //gray out the user protection check box if we are not
        //generating a new key or doing remote
        if((FALSE == pCertWizardInfo->fNewKey) || (FALSE == pCertWizardInfo->fLocal) )
        {
            EnableWindow(hwndControl, FALSE);
        }

        //populate the CSP list with the following logic:
        if(NULL!=(hwndControl=GetDlgItem(hwndDlg, IDC_WIZARD_LIST1)))
        {
            //insert a column into the list view
            memset(&lvC, 0, sizeof(LV_COLUMNW));

            lvC.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
            lvC.fmt = LVCFMT_LEFT;  // Left-align the column.
            lvC.cx = 20; //(dwMaxSize+2)*7;            // Width of the column, in pixels.
            lvC.pszText = L"";   // The text for the column.
            lvC.iSubItem=0;

            if (ListView_InsertColumnU(hwndControl, 0, &lvC) == -1)
                break;

            InitCSPList(hwndControl, pCertWizardInfo);

            // Determine which CSP is selected. 
            if(-1 != (nSelected= ListView_GetNextItem
                      (hwndControl, 		
                       -1, 		
                       LVNI_SELECTED		
                       )))	
            {
                
                // Done with CSP list.  Populate the key sizes list. 
                if (CSPListIndexToCertWizardInfoIndex(hwndControl, nSelected, &dwIndex))
                {
                    if (NULL!=(hwndControl=GetDlgItem(hwndDlg, IDC_WIZARD_COMBO1)))
                    {
                        // Determine the selected cert type's min key size:
                        pCertTypeInfo = NULL; 
                        if (GetSelectedCertTypeInfo(pCertWizardInfo, &pCertTypeInfo))
                        {
                            dwMinKeySize = NULL != pCertTypeInfo ? pCertTypeInfo->dwMinKeySize : 0; 
                            InitKeySizesList(hwndControl, 
                                             dwMinKeySize, 
                                             (pCertWizardInfo->rgwszProvider)[dwIndex], 
                                             (pCertWizardInfo->rgdwProviderType)[dwIndex], 
                                             pCertTypeInfo->dwKeySpec); 
                        }
                    }
                }
		    
            }
        }
        break;

    case WM_COMMAND:
        break;	
						
    case WM_NOTIFY:
        switch (((NMHDR FAR *) lParam)->code)
        {
            //the item has been selected
        case LVN_ITEMCHANGED:

            //get the window handle of the purpose list view
            if(NULL==(hwndControl=GetDlgItem(hwndDlg, IDC_WIZARD_LIST1)))
                break;

            if(NULL==(pCertWizardInfo=(CERT_WIZARD_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                break;

            pnmv = (LPNMLISTVIEW) lParam;

            if(NULL==pnmv)
                break;

                            //we try not to let user de-select cert template
            if((pnmv->uOldState & LVIS_SELECTED) && (0 == (pnmv->uNewState & LVIS_SELECTED)))
            {
                //we should have something selected
                if(-1 == ListView_GetNextItem(
                                              hwndControl, 		
                                              -1, 		
                                              LVNI_SELECTED		
                                              ))
                {
                                //we should re-select the original item
                    ListView_SetItemState(
                                          hwndControl,
                                          pnmv->iItem,
                                          LVIS_SELECTED,
                                          LVIS_SELECTED);
                    
                    pCertWizardInfo->iOrgCSP=pnmv->iItem;
                }
            }
            
            //if something is selected, we disable all other selection
            if(pnmv->uNewState & LVIS_SELECTED)
            {
                if(pnmv->iItem != pCertWizardInfo->iOrgCSP && -1 != pCertWizardInfo->iOrgCSP)
                {
                    //we should de-select the original item
                    
                    ListView_SetItemState(
                                          hwndControl,
                                          pCertWizardInfo->iOrgCSP,
                                          0,
                                          LVIS_SELECTED);
                    
                    pCertWizardInfo->iOrgCSP=-1;
                            }
            }

            // Determine which CSP is selected. 
            if(-1 != (nSelected= ListView_GetNextItem
                      (hwndControl, 		
                       -1, 		
                       LVNI_SELECTED		
                       )))	
            {
                
                // Done with CSP list.  Populate the key sizes list. 
                if (CSPListIndexToCertWizardInfoIndex(hwndControl, nSelected, &dwIndex))
                {
                    if (NULL!=(hwndControl=GetDlgItem(hwndDlg, IDC_WIZARD_COMBO1)))
                    {
                        // Determine the selected cert type's min key size:
                        pCertTypeInfo = NULL; 
                        if (GetSelectedCertTypeInfo(pCertWizardInfo, &pCertTypeInfo))
                        {
                            dwMinKeySize = NULL != pCertTypeInfo ? pCertTypeInfo->dwMinKeySize : 0; 
                            InitKeySizesList(hwndControl, 
                                             dwMinKeySize, 
                                             (pCertWizardInfo->rgwszProvider)[dwIndex], 
                                             (pCertWizardInfo->rgdwProviderType)[dwIndex], 
                                             pCertTypeInfo->dwKeySpec); 
                        }
                    }
                }
                
            }
            break;

        case PSN_KILLACTIVE:
            SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
            return TRUE;

            break;
                        
        case PSN_RESET:
            SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
            break;

        case PSN_SETACTIVE:
            PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_NEXT|PSWIZB_BACK);

                //reset the CSP list if CA selection has been changed
            if(NULL==(pCertWizardInfo=(CERT_WIZARD_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                break;

            if(TRUE==pCertWizardInfo->fCertTypeChanged)
            {
                // Get the selected cert type info
                pCertTypeInfo = NULL; 
                GetSelectedCertTypeInfo(pCertWizardInfo, &pCertTypeInfo); 
                
                //set the check box for the exportable key option
                if(NULL==(hwndControl=GetDlgItem(hwndDlg, IDC_WIZARD_CHECK_EXPORTKEY)))
                    break; 

                // determine whether the exportable checkbox should be set
                // The checkbox is set if:
                //     1) The CT_FLAG_EXPORTABLE_KEY flag is set on the template AND
                //     2) The user has not unchecked this checkbox
                if (pCertWizardInfo->fNewKey && (0 != (CRYPT_EXPORTABLE & pCertWizardInfo->dwGenKeyFlags)))
                    SendMessage(hwndControl, BM_SETCHECK, BST_CHECKED, 0);
                else
                    SendMessage(hwndControl, BM_SETCHECK, BST_UNCHECKED, 0);
                                
                if (NULL != pCertTypeInfo)
                    EnableWindow(hwndControl, 0 != (CT_FLAG_EXPORTABLE_KEY & pCertTypeInfo->dwPrivateKeyFlags));
		
		
		//set the check box for the user protection option
		if(NULL==(hwndControl=GetDlgItem(hwndDlg, IDC_WIZARD_CHECK2)))
		    break;

		// determine whether the strong key protection checkbox should be set
		if (pCertWizardInfo->fNewKey && (0 != (CRYPT_USER_PROTECTED & pCertWizardInfo->dwGenKeyFlags))) { 
		    SendMessage(hwndControl, BM_SETCHECK, BST_CHECKED, 0);
		    EnableWindow(hwndControl, FALSE);
		} else { 
		    SendMessage(hwndControl, BM_SETCHECK, BST_UNCHECKED, 0);
		}

		if (pCertWizardInfo->fLocal) { 
		    if (NULL != pCertTypeInfo) { 
			EnableWindow(hwndControl, 0 == (CT_FLAG_STRONG_KEY_PROTECTION_REQUIRED & pCertTypeInfo->dwPrivateKeyFlags)); 
		    } 
		} else { 
		    EnableWindow(hwndControl, FALSE);
		}

                InitCSPList(hwndControl=GetDlgItem(hwndDlg, IDC_WIZARD_LIST1), pCertWizardInfo);

                // Determine the selected cert type's min key size:
                dwMinKeySize = NULL != pCertTypeInfo ? pCertTypeInfo->dwMinKeySize : 0; 
            }

            // Determine which CSP is selected. 
            if(-1 != (nSelected=ListView_GetNextItem
                      (hwndControl=GetDlgItem(hwndDlg, IDC_WIZARD_LIST1),
                       -1, 		
                       LVNI_SELECTED		
                       )))	
            {
                
                // Done with CSP list.  Populate the key sizes list. 
                if (CSPListIndexToCertWizardInfoIndex(hwndControl, nSelected, &dwIndex))
                {
                    if (NULL!=(hwndControl=GetDlgItem(hwndDlg, IDC_WIZARD_COMBO1)))
                    {
                        if (GetSelectedCertTypeInfo(pCertWizardInfo, &pCertTypeInfo))
                        {
                            dwMinKeySize = NULL != pCertTypeInfo ? pCertTypeInfo->dwMinKeySize : 0; 
                            InitKeySizesList(hwndControl, 
                                             dwMinKeySize, 
                                             (pCertWizardInfo->rgwszProvider)[dwIndex], 
                                             (pCertWizardInfo->rgdwProviderType)[dwIndex], 
                                             pCertTypeInfo->dwKeySpec); 
                        }
                    }
                }
                
            }
            else 
            {
                // Check whether we have any CSPs available...
                if(-1 == (nSelected=ListView_GetNextItem
                          (hwndControl=GetDlgItem(hwndDlg, IDC_WIZARD_LIST1),
                           -1, 		
                           LVNI_ALL		
                           )))	
                {
                    // No CSPs!  We can't enroll for this template. 
                    I_MessageBox(hwndDlg, 
                                 IDS_NO_CSP_FOR_PURPOSE, 
                                 pCertWizardInfo->idsConfirmTitle,
                                 pCertWizardInfo->pwszConfirmationTitle,
                                 MB_ICONEXCLAMATION|MB_OK|MB_APPLMODAL);
                    SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_PURPOSE);
                }
            }

            break;


                        
        case PSN_WIZBACK:
            break;

        case PSN_WIZNEXT:
            if(NULL==(pCertWizardInfo=(CERT_WIZARD_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                break;

                            //get the window handle of the export key
            if(NULL==(hwndControl=GetDlgItem(hwndDlg, IDC_WIZARD_CHECK_EXPORTKEY)))
                break;

                            //mark the pose the cert to the CSP
            if(TRUE==SendMessage(hwndControl, BM_GETCHECK, 0, 0))
                pCertWizardInfo->dwGenKeyFlags |= CRYPT_EXPORTABLE;
            else
                pCertWizardInfo->dwGenKeyFlags &= ~CRYPT_EXPORTABLE;



                            //get the window handle of the user protection
            if(NULL==(hwndControl=GetDlgItem(hwndDlg, IDC_WIZARD_CHECK2)))
                break;

                            //mark the pose the cert to the CSP
            if(TRUE==SendMessage(hwndControl, BM_GETCHECK, 0, 0))
                pCertWizardInfo->dwGenKeyFlags |= CRYPT_USER_PROTECTED;
            else
                pCertWizardInfo->dwGenKeyFlags &= ~CRYPT_USER_PROTECTED;

			    // Set the key size based on the user's suggestion: 
			    //
            if (NULL==(hwndControl=GetDlgItem(hwndDlg, IDC_WIZARD_COMBO1)))
                break;

            if (CB_ERR != (dwSelected = (DWORD)SendMessage(hwndControl, CB_GETCURSEL, 0, 0)))
            {
                pCertWizardInfo->dwMinKeySize = (DWORD)SendMessage(hwndControl, CB_GETITEMDATA, dwSelected, 0); 
            }
            else
            {
                pCertWizardInfo->dwMinKeySize = 0; 
            }

            //get the window handle for the CSP list
            if(NULL==(hwndControl=GetDlgItem(hwndDlg, IDC_WIZARD_LIST1)))
                break;

            //now, mark the ones that are selected
            if(-1 != (dwIndex= ListView_GetNextItem(
                                                    hwndControl, 		
                                                    -1, 		
                                                    LVNI_SELECTED		
                                                    )))	
            {
                
                                //get the selected certificate
                memset(&lvItem, 0, sizeof(LV_ITEM));
                lvItem.mask=LVIF_PARAM;
                lvItem.iItem=(int)dwIndex;

                if(ListView_GetItem(hwndControl,
                                    &lvItem))
                {
                    pCertWizardInfo->dwProviderType=pCertWizardInfo->rgdwProviderType[(DWORD)(lvItem.lParam)];
                    pCertWizardInfo->pwszProvider=pCertWizardInfo->rgwszProvider[(DWORD)(lvItem.lParam)];
                }
                else
                {
                    I_MessageBox(hwndDlg, IDS_NO_SELECTED_CSP,
                                 pCertWizardInfo->idsConfirmTitle,
                                 pCertWizardInfo->pwszConfirmationTitle,
                                 MB_ICONERROR|MB_OK|MB_APPLMODAL);

                                //make the purpose page stay

                    SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);

                    break;
                }
            }
            else
            {
                I_MessageBox(hwndDlg, IDS_NO_SELECTED_CSP,
                             pCertWizardInfo->idsConfirmTitle,
                             pCertWizardInfo->pwszConfirmationTitle,
                             MB_ICONERROR|MB_OK|MB_APPLMODAL);

                                //make the purpose page stay

                SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);

                break;

            }

            //skip to the correct page based on the advanced options and CSP requirement
            if(FALSE == pCertWizardInfo->fUIAdv)
                SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_NAME_DESCRIPTION);

            break;

        default:
            return FALSE;

        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

//-----------------------------------------------------------------------
//CA
//-----------------------------------------------------------------------
INT_PTR APIENTRY Enroll_CA(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CERT_WIZARD_INFO        *pCertWizardInfo=NULL;
    PROPSHEETPAGE           *pPropSheet=NULL;
    DWORD                   dwChar=0;

    PCRYPTUI_CA_CONTEXT     pCAContext=NULL;
    LPWSTR 		    pwszCADisplayName = NULL;

    HCURSOR                 hPreCursor=NULL;
    HCURSOR                 hWinPreCursor=NULL;

	switch (msg)
	{
		case WM_INITDIALOG:
            //set the wizard information so that it can be shared
            pPropSheet = (PROPSHEETPAGE *) lParam;
            pCertWizardInfo = (CERT_WIZARD_INFO *) (pPropSheet->lParam);

            SetControlFont(pCertWizardInfo->hBold, hwndDlg,IDC_WIZARD_STATIC_BOLD1);

            //make sure pCertWizardInfo is a valid pointer
            if(NULL==pCertWizardInfo)
               break;

            SetWindowLongPtr(hwndDlg, DWLP_USER, (LONG_PTR)pCertWizardInfo);

            //init the CA name and CA location
            if(pCertWizardInfo->pwszCALocation)
                SetDlgItemTextU(hwndDlg, IDC_WIZARD_EDIT2,pCertWizardInfo->pwszCALocation);

            if(pCertWizardInfo->pwszCAName)
			{
                //overwrite the cursor for this window class
                hWinPreCursor=(HCURSOR)SetClassLongPtr(hwndDlg, GCLP_HCURSOR, (LONG_PTR)NULL);
                hPreCursor=SetCursor(LoadCursor(NULL, IDC_WAIT));

             	if(CAUtilGetCADisplayName((pCertWizardInfo->fMachine) ? CA_FIND_LOCAL_SYSTEM:0,
							   pCertWizardInfo->pwszCAName,
							   &pwszCADisplayName))
				{
					SetDlgItemTextU(hwndDlg, IDC_WIZARD_EDIT1,pwszCADisplayName);
					WizardFree(pwszCADisplayName);
					pwszCADisplayName=NULL;
				}
				else
					SetDlgItemTextU(hwndDlg, IDC_WIZARD_EDIT1,pCertWizardInfo->pwszCAName);

				//set the cursor back
                SetCursor(hPreCursor);
                SetWindowLongPtr(hwndDlg, GCLP_HCURSOR, (LONG_PTR)hWinPreCursor);
			}

			break;

		case WM_COMMAND:
                if(HIWORD(wParam) == BN_CLICKED)
                {
                    switch (LOWORD(wParam))
                    {
                        case    IDC_WIZARD_BUTTON1:

                                if(NULL==(pCertWizardInfo=(CERT_WIZARD_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                                    break;

								//overwrite the cursor for this window class
								hWinPreCursor=(HCURSOR)SetClassLongPtr(hwndDlg, GCLP_HCURSOR, (LONG_PTR)NULL);
								hPreCursor=SetCursor(LoadCursor(NULL, IDC_WAIT));

                                //call the CA selection dialogue
                                pCAContext=GetCAContext(hwndDlg, pCertWizardInfo);

								//set the cursor back
								SetCursor(hPreCursor);
								SetWindowLongPtr(hwndDlg, GCLP_HCURSOR, (LONG_PTR)hWinPreCursor);

                                if(pCAContext)
                                {
                                    //update the edit box
                                    if(pCAContext->pwszCAMachineName)
                                        SetDlgItemTextU(hwndDlg, IDC_WIZARD_EDIT2,pCAContext->pwszCAMachineName);

                                    if(pCAContext->pwszCAName)
                                        SetDlgItemTextU(hwndDlg, IDC_WIZARD_EDIT1,pCAContext->pwszCAName);

                                    //free the CA context
                                    CryptUIDlgFreeCAContext(pCAContext);

                                    pCAContext=NULL;

                                }


                            break;
                        default:
                            break;
                    }
                }

			break;	
						
		case WM_NOTIFY:
    		    switch (((NMHDR FAR *) lParam)->code)
    		    {

  				    case PSN_KILLACTIVE:
                            SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
					        return TRUE;

                        break;

				    case PSN_RESET:
                            SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
					    break;

 				    case PSN_SETACTIVE:
 					    PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_NEXT|PSWIZB_BACK);

                        //reset the CSP list if CA selection has been changed
                        if(NULL==(pCertWizardInfo=(CERT_WIZARD_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                            break;

                        if(TRUE==pCertWizardInfo->fCertTypeChanged)
                        {   
                            //reset the CA name and CA location
                            if(pCertWizardInfo->pwszCALocation)
                                SetDlgItemTextU(hwndDlg, IDC_WIZARD_EDIT2,pCertWizardInfo->pwszCALocation);

							if(pCertWizardInfo->pwszCAName)
							{

								//overwrite the cursor for this window class
								hWinPreCursor=(HCURSOR)SetClassLongPtr(hwndDlg, GCLP_HCURSOR, (LONG_PTR)NULL);
								hPreCursor=SetCursor(LoadCursor(NULL, IDC_WAIT));

             					if(CAUtilGetCADisplayName((pCertWizardInfo->fMachine) ? CA_FIND_LOCAL_SYSTEM:0,
											   pCertWizardInfo->pwszCAName,
											   &pwszCADisplayName))
								{
									SetDlgItemTextU(hwndDlg, IDC_WIZARD_EDIT1,pwszCADisplayName);
									WizardFree(pwszCADisplayName);
									pwszCADisplayName=NULL;
								}
								else
									SetDlgItemTextU(hwndDlg, IDC_WIZARD_EDIT1,pCertWizardInfo->pwszCAName);

								//set the cursor back
								SetCursor(hPreCursor);
								SetWindowLongPtr(hwndDlg, GCLP_HCURSOR, (LONG_PTR)hWinPreCursor);
							}
                        }

						//reset the certtype change flag to FALSE.
						pCertWizardInfo->fCertTypeChanged = FALSE;

					    break;

                    case PSN_WIZBACK:
                            if(NULL==(pCertWizardInfo=(CERT_WIZARD_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                                break;

                            //skip to the correct page based on the advanced options and CSP requirement
                            if(FALSE == pCertWizardInfo->fNewKey)
                                SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_PURPOSE);
                        break;

                    case PSN_WIZNEXT:
                            if(NULL==(pCertWizardInfo=(CERT_WIZARD_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                                break;		   

								//cach the display name of the CA
								if(0!=(dwChar=(DWORD)SendDlgItemMessage(hwndDlg,
													   IDC_WIZARD_EDIT1,
													   WM_GETTEXTLENGTH, 0, 0)))
								{
									if(pCertWizardInfo->pwszCADisplayName)
									{
										WizardFree(pCertWizardInfo->pwszCADisplayName);
										pCertWizardInfo->pwszCADisplayName = NULL;
									}

									pCertWizardInfo->pwszCADisplayName=(LPWSTR)WizardAlloc(sizeof(WCHAR)*(dwChar+1));

									if(NULL!=(pCertWizardInfo->pwszCADisplayName))
									{
										GetDlgItemTextU(hwndDlg, IDC_WIZARD_EDIT1,
														pCertWizardInfo->pwszCADisplayName,
														dwChar+1);

									}
								}

                        break;

				    default:
					    return FALSE;

    	        }
		    break;

		default:
			return FALSE;
	}

	return TRUE;
}

//-----------------------------------------------------------------------
//FriendlyName
//-----------------------------------------------------------------------
INT_PTR APIENTRY Enroll_Name(HWND hwndDlg, UINT msg, WPARAM /*wParam*/, LPARAM lParam)
{
    CERT_WIZARD_INFO        *pCertWizardInfo=NULL;
    PROPSHEETPAGE           *pPropSheet=NULL;
    DWORD                   dwChar=0;


	switch (msg)
	{
		case WM_INITDIALOG:
            //set the wizard information so that it can be shared
            pPropSheet = (PROPSHEETPAGE *) lParam;
            pCertWizardInfo = (CERT_WIZARD_INFO *) (pPropSheet->lParam);
            //make sure pCertWizardInfo is a valid pointer
            if(NULL==pCertWizardInfo)
                break;

            SetWindowLongPtr(hwndDlg, DWLP_USER, (LONG_PTR)pCertWizardInfo);

            SetControlFont(pCertWizardInfo->hBold, hwndDlg,IDC_WIZARD_STATIC_BOLD1);

            //initialize the friendlyname and description
            if(pCertWizardInfo->pwszFriendlyName)
                SetDlgItemTextU(hwndDlg, IDC_WIZARD_EDIT1,pCertWizardInfo->pwszFriendlyName);

            if(pCertWizardInfo->pwszDescription)
                 SetDlgItemTextU(hwndDlg, IDC_WIZARD_EDIT2,pCertWizardInfo->pwszDescription);

			break;

		case WM_COMMAND:
			break;	
						
		case WM_NOTIFY:
    		    switch (((NMHDR FAR *) lParam)->code)
    		    {

  				    case PSN_KILLACTIVE:
                            SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
					        return TRUE;

                        break;

				    case PSN_RESET:
                            SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
					    break;

 				    case PSN_SETACTIVE:
 					    PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_NEXT|PSWIZB_BACK);
					    break;

                    case PSN_WIZBACK:
                            if(NULL==(pCertWizardInfo=(CERT_WIZARD_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                                break;

                            //skip to the correct page based on the advanced options and CSP requirement
                            if(FALSE == pCertWizardInfo->fUIAdv)
                            {
                                if(TRUE == pCertWizardInfo->fUICSP)
                                    SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_CSP_SERVICE_PROVIDER);
                                else
                                    SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_PURPOSE);
                            }
                        
                        break;

                    case PSN_WIZNEXT:

                            if(NULL==(pCertWizardInfo=(CERT_WIZARD_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                                break;

                            //free the original messages
                            if(pCertWizardInfo->pwszFriendlyName)
                            {
                                WizardFree(pCertWizardInfo->pwszFriendlyName);
                                pCertWizardInfo->pwszFriendlyName=NULL;
                            }

                            if(pCertWizardInfo->pwszDescription)
                            {
                                WizardFree(pCertWizardInfo->pwszDescription);
                                pCertWizardInfo->pwszDescription=NULL;
                            }

                            //get the friendlyName
                            if(0!=(dwChar=(DWORD)SendDlgItemMessage(hwndDlg,
                                                   IDC_WIZARD_EDIT1,
                                                   WM_GETTEXTLENGTH, 0, 0)))
                            {
                                pCertWizardInfo->pwszFriendlyName=(LPWSTR)WizardAlloc(sizeof(WCHAR)*(dwChar+1));

                                if(NULL!=(pCertWizardInfo->pwszFriendlyName))
                                {
                                    GetDlgItemTextU(hwndDlg, IDC_WIZARD_EDIT1,
                                                    pCertWizardInfo->pwszFriendlyName,
                                                    dwChar+1);

                                }
                            }

                            //get the description
                            if(0!=(dwChar=(DWORD)SendDlgItemMessage(hwndDlg,
                                                   IDC_WIZARD_EDIT2,
                                                   WM_GETTEXTLENGTH, 0, 0)))
                            {
                                pCertWizardInfo->pwszDescription=(LPWSTR)WizardAlloc(sizeof(WCHAR)*(dwChar+1));

                                if(NULL!=(pCertWizardInfo->pwszDescription))
                                {
                                    GetDlgItemTextU(hwndDlg, IDC_WIZARD_EDIT2,
                                                    pCertWizardInfo->pwszDescription,
                                                    dwChar+1);
                                }
                            }

                        break;

				    default:
					    return FALSE;

    	        }
		    break;

		default:
			return FALSE;
	}

	return TRUE;
}

//-----------------------------------------------------------------------
//Completion
//-----------------------------------------------------------------------
INT_PTR APIENTRY Enroll_Completion(HWND hwndDlg, UINT msg, WPARAM /*wParam*/, LPARAM lParam)
{
    CERT_WIZARD_INFO        *pCertWizardInfo=NULL;
    PROPSHEETPAGE           *pPropSheet=NULL;
    HWND                    hwndControl=NULL;
    LV_COLUMNW              lvC;
    HCURSOR                 hPreCursor=NULL;
    HCURSOR                 hWinPreCursor=NULL;

	switch (msg)
	{
		case WM_INITDIALOG:
            //set the wizard information so that it can be shared
            pPropSheet = (PROPSHEETPAGE *) lParam;
            pCertWizardInfo = (CERT_WIZARD_INFO *) (pPropSheet->lParam);
            //make sure pCertWizardInfo is a valid pointer
            if(NULL==pCertWizardInfo)
                break;
                
            SetWindowLongPtr(hwndDlg, DWLP_USER, (LONG_PTR)pCertWizardInfo);

            SetControlFont(pCertWizardInfo->hBigBold, hwndDlg,IDC_WIZARD_STATIC_BIG_BOLD1);

            //insert two columns
            hwndControl=GetDlgItem(hwndDlg, IDC_WIZARD_LIST1);

            memset(&lvC, 0, sizeof(LV_COLUMNW));

            lvC.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
            lvC.fmt = LVCFMT_LEFT;  // Left-align the column.
            lvC.cx = 20;          // Width of the column, in pixels.
            lvC.pszText = L"";   // The text for the column.
            lvC.iSubItem=0;

            if (ListView_InsertColumnU(hwndControl, 0, &lvC) == -1)
                break;

            //2nd column is the content
            memset(&lvC, 0, sizeof(LV_COLUMNW));

            lvC.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
            lvC.fmt = LVCFMT_LEFT;  // Left-align the column.
            lvC.cx = 10; //(dwMaxSize+2)*7;          // Width of the column, in pixels.
            lvC.pszText = L"";   // The text for the column.
            lvC.iSubItem= 1;

            if (ListView_InsertColumnU(hwndControl, 1, &lvC) == -1)
                break;


           break;
		case WM_COMMAND:
			break;	
						
		case WM_NOTIFY:
    		    switch (((NMHDR FAR *) lParam)->code)
    		    {

  				    case PSN_KILLACTIVE:
                            SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
					        return TRUE;

                        break;

				    case PSN_RESET:
                            SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
					    break;

 				    case PSN_SETACTIVE:
 					        PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK|PSWIZB_FINISH);

                            if(NULL==(pCertWizardInfo=(CERT_WIZARD_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                                break;

                            //populate the list box in the order of friendly name,
                            //overwrite the cursor for this window class
                            hWinPreCursor=(HCURSOR)SetClassLongPtr(hwndDlg, GCLP_HCURSOR, (LONG_PTR)NULL);
                            hPreCursor=SetCursor(LoadCursor(NULL, IDC_WAIT));

                            //UserName, CA, Purpose, and CSP
                            //Get the window handle for the CSP list
                            if(hwndControl=GetDlgItem(hwndDlg, IDC_WIZARD_LIST1))
                                DisplayConfirmation(hwndControl, pCertWizardInfo);

                            //set the cursor back
                            SetCursor(hPreCursor);
                            SetWindowLongPtr(hwndDlg, GCLP_HCURSOR, (LONG_PTR)hWinPreCursor);

					    break;

                    case PSN_WIZBACK:
                        break;

                    case PSN_WIZFINISH:
			{
			    CertRequester        *pCertRequester        = NULL; 
			    CertRequesterContext *pCertRequesterContext = NULL; 

                            if(NULL==(pCertWizardInfo=(CERT_WIZARD_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                                break;

                            //overwrite the cursor for this window class
                            hWinPreCursor=(HCURSOR)SetClassLongPtr(hwndDlg, GCLP_HCURSOR, (LONG_PTR)NULL);
                            hPreCursor=SetCursor(LoadCursor(NULL, IDC_WAIT));

                            //set the parent window to the hwndDlg so that
                            //confirmat to install dlg use hwndDlg as the
                            //parent window
                            pCertWizardInfo->hwndParent=hwndDlg;

			    if (NULL == (pCertRequester = (CertRequester *) pCertWizardInfo->hRequester))
                                break; 
			    if (NULL == (pCertRequesterContext = pCertRequester->GetContext()))
                                break; 
			    

                            //call the enrollment wizard
			    pCertWizardInfo->hr = pCertRequesterContext->Enroll(&(pCertWizardInfo->dwStatus), (HANDLE *)&(pCertWizardInfo->pNewCertContext));
                            if (0 == pCertWizardInfo->idsText) { 
                                pCertWizardInfo->idsText = CryptUIStatusToIDSText(pCertWizardInfo->hr, pCertWizardInfo->dwStatus); 
                            }
			    
			    if(S_OK != pCertWizardInfo->hr)
                                break; 
				    
                            //set the cursor back
                            SetCursor(hPreCursor);
                            SetWindowLongPtr(hwndDlg, GCLP_HCURSOR, (LONG_PTR)hWinPreCursor);
			}
                        break;

		    default:
			return FALSE;

		    }
		    break;

	default:

	    return FALSE;
	}

	return TRUE;
}

//*******************************************************************************
//  WinProc for the enrollment wizard
//
//*******************************************************************************

//-----------------------------------------------------------------------
//Renew_Welcome
//-----------------------------------------------------------------------
INT_PTR APIENTRY Renew_Welcome(HWND hwndDlg, UINT msg, WPARAM /*wParam*/, LPARAM lParam)
{
    CERT_WIZARD_INFO        *pCertWizardInfo=NULL;
    PROPSHEETPAGE           *pPropSheet=NULL;

    PCRYPTUI_WIZ_CERT_CA    pCertCA=NULL;
    DWORD                   dwIndex=0;

	switch (msg)
	{
		case WM_INITDIALOG:
            //set the wizard information so that it can be shared
            pPropSheet = (PROPSHEETPAGE *) lParam;
            pCertWizardInfo = (CERT_WIZARD_INFO *) (pPropSheet->lParam);
            SetWindowLongPtr(hwndDlg, DWLP_USER, (LONG_PTR)pCertWizardInfo);

            SetControlFont(pCertWizardInfo->hBigBold, hwndDlg,IDC_WIZARD_STATIC_BIG_BOLD1);
         //   SetControlFont(pCertWizardInfo->hBold, hwndDlg,IDC_WIZARD_STATIC_BOLD1);

			break;

		case WM_NOTIFY:
    		    switch (((NMHDR FAR *) lParam)->code)
    		    {

  				    case PSN_KILLACTIVE:
                            SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
					        return TRUE;

                        break;

				    case PSN_RESET:
                            SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
					    break;

 				    case PSN_SETACTIVE:
 					    PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_NEXT);
					    break;

                    case PSN_WIZBACK:
                        break;

                    case PSN_WIZNEXT:
                            if(NULL==(pCertWizardInfo=(CERT_WIZARD_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                                break;  

                             //decide the default CA to use since the CertType will not
                             //be changed
                            ResetDefaultCA(pCertWizardInfo);

                             //decide if we need to show the CSP page 
                            pCertCA=&(pCertWizardInfo->pCertCAInfo->rgCA[pCertWizardInfo->dwCAIndex]);

                            for(dwIndex=0; dwIndex<pCertCA->dwCertTypeInfo; dwIndex++)
                            {
                                if(pCertCA->rgCertTypeInfo[dwIndex].fSelected)
                                {
                                    if(NULL == pCertWizardInfo->pwszProvider)
                                    {
                                        if(0 == pCertCA->rgCertTypeInfo[dwIndex].dwCSPCount)
                                            pCertWizardInfo->fUICSP=TRUE;
                                    }

                                    //copy the selected CertTypeName
                                    pCertWizardInfo->pwszSelectedCertTypeDN=pCertCA->rgCertTypeInfo[dwIndex].pwszDNName;

                                    break;

                                }
                            }
                       break;

				    default:
					    return FALSE;

    	        }
		    break;

		default:
			return FALSE;
	}

	return TRUE;
}
//-----------------------------------------------------------------------
//Renew_Options
//-----------------------------------------------------------------------
INT_PTR APIENTRY Renew_Options(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CERT_WIZARD_INFO        *pCertWizardInfo=NULL;
    PROPSHEETPAGE           *pPropSheet=NULL;


    switch (msg)
	{
		case WM_INITDIALOG:
            //set the wizard information so that it can be shared
            pPropSheet = (PROPSHEETPAGE *) lParam;
            pCertWizardInfo = (CERT_WIZARD_INFO *) (pPropSheet->lParam);

            SetControlFont(pCertWizardInfo->hBold, hwndDlg,IDC_WIZARD_STATIC_BOLD1);

            //make sure pCertWizardInfo is a valid pointer
            if(NULL==pCertWizardInfo)
               break;

            SetWindowLongPtr(hwndDlg, DWLP_USER, (LONG_PTR)pCertWizardInfo);

            //set the initial selection as using the default selections
            SendMessage(GetDlgItem(hwndDlg, IDC_WIZARD_RADIO1), BM_SETCHECK, 1, 0);
            SendMessage(GetDlgItem(hwndDlg, IDC_WIZARD_RADIO2), BM_SETCHECK, 0, 0);

			break;

		case WM_COMMAND:
                if(HIWORD(wParam) == BN_CLICKED)
                {
                    switch (LOWORD(wParam))
                    {
                        case    IDC_WIZARD_RADIO1:
                                SendMessage(GetDlgItem(hwndDlg, IDC_WIZARD_RADIO1), BM_SETCHECK, 1, 0);
                                SendMessage(GetDlgItem(hwndDlg, IDC_WIZARD_RADIO2), BM_SETCHECK, 0, 0);
                            break;

                        case    IDC_WIZARD_RADIO2:
                                SendMessage(GetDlgItem(hwndDlg, IDC_WIZARD_RADIO1), BM_SETCHECK, 0, 0);
                                SendMessage(GetDlgItem(hwndDlg, IDC_WIZARD_RADIO2), BM_SETCHECK, 1, 0);
                            break;

                        default:
                            break;

                    }
                }

			break;	
						
		case WM_NOTIFY:
    		    switch (((NMHDR FAR *) lParam)->code)
    		    {

  				    case PSN_KILLACTIVE:
                            SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
					        return TRUE;

                        break;

				    case PSN_RESET:
                            SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
					    break;

 				    case PSN_SETACTIVE:
 					        PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_NEXT|PSWIZB_BACK);
                            
                            if(NULL==(pCertWizardInfo=(CERT_WIZARD_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                                break;

                            //if the adv selection is made, it has to stay selected
                            if(pCertWizardInfo->fUIAdv)
                                EnableWindow(GetDlgItem(hwndDlg, IDC_WIZARD_RADIO1), FALSE);
                        
                        break;

                    case PSN_WIZBACK:
                        break;

                    case PSN_WIZNEXT:
                            if(NULL==(pCertWizardInfo=(CERT_WIZARD_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                                break;

                            //check for the advanced options
                            if(TRUE==SendMessage(GetDlgItem(hwndDlg, IDC_WIZARD_RADIO1), BM_GETCHECK, 0, 0))
                                pCertWizardInfo->fUIAdv=FALSE;
                            else
                                pCertWizardInfo->fUIAdv=TRUE;


                            //skip to the correct page based on the advanced options and CSP requirement
                            if(FALSE == pCertWizardInfo->fUIAdv)
                            {
                                if(TRUE == pCertWizardInfo->fUICSP)
                                    SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_RENEW_SERVICE_PROVIDER);
                                else
                                    SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_RENEW_COMPLETION);
                            }
                            else
                            {
                                if(FALSE == pCertWizardInfo->fNewKey)
                                    SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_RENEW_CA);
                            }

                        break;

				    default:
					    return FALSE;

    	        }
		    break;

		default:
			return FALSE;
	}

	return TRUE;
}


//-----------------------------------------------------------------------
// Renew_CSP
//-----------------------------------------------------------------------
INT_PTR APIENTRY Renew_CSP(HWND hwndDlg, UINT msg, WPARAM /*wParam*/, LPARAM lParam)
{
    CERT_WIZARD_INFO        *pCertWizardInfo=NULL;
    PROPSHEETPAGE           *pPropSheet=NULL;
    ENROLL_CERT_TYPE_INFO   *pCertTypeInfo=NULL; 

    DWORD                   dwMinKeySize=0;
    DWORD                   dwIndex=0;
    DWORD                   dwSelected=0; 
    int                     nSelected=0;
    HWND                    hwndControl=NULL;

    LV_COLUMNW                  lvC;
    LV_ITEM                     lvItem;

    NM_LISTVIEW FAR *           pnmv=NULL;

    switch (msg)
	{
		case WM_INITDIALOG:


            //set the wizard information so that it can be shared
            pPropSheet = (PROPSHEETPAGE *) lParam;
            pCertWizardInfo = (CERT_WIZARD_INFO *) (pPropSheet->lParam);

            //make sure pCertWizardInfo is a valid pointer
            if(NULL==pCertWizardInfo)
                break;

            // Get the selected cert type info
            pCertTypeInfo = NULL; 
            GetSelectedCertTypeInfo(pCertWizardInfo, &pCertTypeInfo); 
            if (NULL != pCertTypeInfo)
                MarkSelectedCertType(pCertWizardInfo, pCertTypeInfo->pwszDNName);

            SetWindowLongPtr(hwndDlg, DWLP_USER, (LONG_PTR)pCertWizardInfo);

            SetControlFont(pCertWizardInfo->hBold, hwndDlg,IDC_WIZARD_STATIC_BOLD1);

            //set the check box for the exportable key option
            if(NULL==(hwndControl=GetDlgItem(hwndDlg, IDC_WIZARD_CHECK_EXPORTKEY)))
                break;

            // determine whether the exportable checkbox should be set
            // The checkbox is set if:
            //     1) The CT_FLAG_EXPORTABLE_KEY flag is set on the template AND
            //     2) The user has not unchecked this checkbox
            if (pCertWizardInfo->fNewKey && (0 != (CRYPT_EXPORTABLE & pCertWizardInfo->dwGenKeyFlags)))
                SendMessage(hwndControl, BM_SETCHECK, BST_CHECKED, 0);
            else
                SendMessage(hwndControl, BM_SETCHECK, BST_UNCHECKED, 0);

            if (NULL != pCertTypeInfo)
                EnableWindow(hwndControl, 0 != (CT_FLAG_EXPORTABLE_KEY & pCertTypeInfo->dwPrivateKeyFlags));

            //set the check box for the user protection option
            if(NULL==(hwndControl=GetDlgItem(hwndDlg, IDC_WIZARD_CHECK2)))
                break;

	    //set the check box for the user protection option
	    if(NULL==(hwndControl=GetDlgItem(hwndDlg, IDC_WIZARD_CHECK2)))
		break;

	    // determine whether the strong key protection checkbox should be set
	    if (0 != (CRYPT_USER_PROTECTED & pCertWizardInfo->dwGenKeyFlags)) { 
		// if this bit is set in the INITDIALOG handler, it's either
		// from the template or the previous key.  Enforce the setting
		// by disabling the checkbox
		SendMessage(hwndControl, BM_SETCHECK, BST_CHECKED, 0);
		EnableWindow(hwndControl, FALSE);
	    } else { 
		SendMessage(hwndControl, BM_SETCHECK, BST_UNCHECKED, 0);
	    }

	    //gray out the user protection check box if we are not
	    //generating a new key or doing remote
	    if((FALSE == pCertWizardInfo->fNewKey) || (FALSE == pCertWizardInfo->fLocal) )
	    {
		EnableWindow(hwndControl, FALSE);
	    }

            //populate the CSP list with the following logic:

            if(NULL!=(hwndControl=GetDlgItem(hwndDlg, IDC_WIZARD_LIST1)))
            {
                //insert a column into the list view
                memset(&lvC, 0, sizeof(LV_COLUMNW));

                lvC.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
                lvC.fmt = LVCFMT_LEFT;  // Left-align the column.
                lvC.cx = 20; //(dwMaxSize+2)*7;            // Width of the column, in pixels.
                lvC.pszText = L"";   // The text for the column.
                lvC.iSubItem=0;

                if (ListView_InsertColumnU(hwndControl, 0, &lvC) == -1)
                    break;

                InitCSPList(hwndControl, pCertWizardInfo);

		if(-1 != (nSelected= ListView_GetNextItem
			  (hwndControl, 		
			   -1, 		
			   LVNI_SELECTED		
			   )))	
		{

		    // Done with CSP list.  Populate the key sizes list. 
		    if (CSPListIndexToCertWizardInfoIndex(hwndControl, nSelected, &dwIndex))
		    {
			if (NULL!=(hwndControl=GetDlgItem(hwndDlg, IDC_WIZARD_COMBO1)))
			{
                            // Determine the selected cert type's min key size:
                            pCertTypeInfo = NULL; 
			    if (GetSelectedCertTypeInfo(pCertWizardInfo, &pCertTypeInfo))
			    {
                                dwMinKeySize = NULL != pCertTypeInfo ? pCertTypeInfo->dwMinKeySize : 0; 
				InitKeySizesList(hwndControl, 
						 dwMinKeySize, 
                                                 (pCertWizardInfo->rgwszProvider)[dwIndex], 
						 (pCertWizardInfo->rgdwProviderType)[dwIndex], 
						 pCertTypeInfo->dwKeySpec); 
			    }
			}
		    }
		    
		}

            }

			break;

		case WM_COMMAND:
			break;	
						
		case WM_NOTIFY:
    		    switch (((NMHDR FAR *) lParam)->code)
    		    {
                    //the item has been selected
                    case LVN_ITEMCHANGED:

                            //get the window handle of the purpose list view
                            if(NULL==(hwndControl=GetDlgItem(hwndDlg, IDC_WIZARD_LIST1)))
                                break;

                            if(NULL==(pCertWizardInfo=(CERT_WIZARD_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                                break;

                            pnmv = (LPNMLISTVIEW) lParam;

                            if(NULL==pnmv)
                                break;

                            //we try not to let user de-select cert template
                            if((pnmv->uOldState & LVIS_SELECTED) && (0 == (pnmv->uNewState & LVIS_SELECTED)))
                            {
                                 //we should have something selected
                                 if(-1 == ListView_GetNextItem(
                                        hwndControl, 		
                                        -1, 		
                                        LVNI_SELECTED		
                                    ))
                                 {
                                    //we should re-select the original item
                                    ListView_SetItemState(
                                                        hwndControl,
                                                        pnmv->iItem,
                                                        LVIS_SELECTED,
                                                        LVIS_SELECTED);

                                    pCertWizardInfo->iOrgCSP=pnmv->iItem;
                                 }
                            }

                            //if something is selected, we disable all other selection
                            if(pnmv->uNewState & LVIS_SELECTED)
                            {
                                if(pnmv->iItem != pCertWizardInfo->iOrgCSP && -1 != pCertWizardInfo->iOrgCSP)
                                {
                                    //we should de-select the original item

                                    ListView_SetItemState(
                                                        hwndControl,
                                                        pCertWizardInfo->iOrgCSP,
                                                        0,
                                                        LVIS_SELECTED);

                                    pCertWizardInfo->iOrgCSP=-1;
                                }
                            }
		    		// Determine which CSP is selected. 
			    if(-1 != (nSelected= ListView_GetNextItem
				      (hwndControl, 		
				       -1, 		
				       LVNI_SELECTED		
				       )))	
			    {
				    
                                // Done with CSP list.  Populate the key sizes list. 
                                if (CSPListIndexToCertWizardInfoIndex(hwndControl, nSelected, &dwIndex))
                                {
                                    if (NULL!=(hwndControl=GetDlgItem(hwndDlg, IDC_WIZARD_COMBO1)))
                                    {
                                        pCertTypeInfo = NULL; 
                                        if (GetSelectedCertTypeInfo(pCertWizardInfo, &pCertTypeInfo))
                                        {
                                            dwMinKeySize = NULL != pCertTypeInfo ? pCertTypeInfo->dwMinKeySize : 0; 
                                            InitKeySizesList(hwndControl, 
                                                             dwMinKeySize, 
                                                             (pCertWizardInfo->rgwszProvider)[dwIndex], 
                                                             (pCertWizardInfo->rgdwProviderType)[dwIndex], 
                                                             pCertTypeInfo->dwKeySpec); 
                                        }
                                    }
                                }
				    
                            }

                        break;
                    case PSN_KILLACTIVE:
                        SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
                        return TRUE;

                        break;

                    case PSN_RESET:
                        SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
                        break;

                    case PSN_SETACTIVE:
                        PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_NEXT|PSWIZB_BACK);

                        //reset the CSP list if CA selection has been changed
                        if(NULL==(pCertWizardInfo=(CERT_WIZARD_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                            break;

                        if(TRUE==pCertWizardInfo->fCertTypeChanged)
                        {
                            pCertTypeInfo = NULL; 
                            GetSelectedCertTypeInfo(pCertWizardInfo, &pCertTypeInfo); 
                                
                            //set the check box for the exportable key option
                            if(NULL==(hwndControl=GetDlgItem(hwndDlg, IDC_WIZARD_CHECK_EXPORTKEY)))
                                break; 
                            
                            // determine whether the exportable checkbox should be set
                            // The checkbox is set if:
                            //     1) The CT_FLAG_EXPORTABLE_KEY flag is set on the template AND
                            //     2) The user has not unchecked this checkbox
                            if (pCertWizardInfo->fNewKey && (0 != (CRYPT_EXPORTABLE & pCertWizardInfo->dwGenKeyFlags)))
                                SendMessage(hwndControl, BM_SETCHECK, BST_CHECKED, 0);
                            else
                                SendMessage(hwndControl, BM_SETCHECK, BST_UNCHECKED, 0);
                            
                            if (NULL != pCertTypeInfo)
                                EnableWindow(hwndControl, 0 != (CT_FLAG_EXPORTABLE_KEY & pCertTypeInfo->dwPrivateKeyFlags));

                            InitCSPList(hwndControl=GetDlgItem(hwndDlg, IDC_WIZARD_LIST1), pCertWizardInfo);
                        }

                        // Determine which CSP is selected. 
                        if(-1 != (nSelected=ListView_GetNextItem
                                  (hwndControl=GetDlgItem(hwndDlg, IDC_WIZARD_LIST1), 
                                   -1, 		
                                   LVNI_SELECTED		
                                   )))	
                        {
                            
                            // Done with CSP list.  Populate the key sizes list. 
                            if (CSPListIndexToCertWizardInfoIndex(hwndControl, nSelected, &dwIndex))
                            {
                                if (NULL!=(hwndControl=GetDlgItem(hwndDlg, IDC_WIZARD_COMBO1)))
                                {
                                    pCertTypeInfo = NULL; 
                                    if (GetSelectedCertTypeInfo(pCertWizardInfo, &pCertTypeInfo))
                                    {
                                        // Determine the selected cert type's min key size:
                                        dwMinKeySize = NULL != pCertTypeInfo ? pCertTypeInfo->dwMinKeySize : 0; 
                                        InitKeySizesList(hwndControl, 
                                                         dwMinKeySize, 
                                                         (pCertWizardInfo->rgwszProvider)[dwIndex], 
                                                         (pCertWizardInfo->rgdwProviderType)[dwIndex], 
                                                         pCertTypeInfo->dwKeySpec); 
                                    }
                                }
                            }
                            
                        }
                        else
                        {
                            if(-1 == (nSelected=ListView_GetNextItem
                                      (hwndControl=GetDlgItem(hwndDlg, IDC_WIZARD_LIST1), 
                                       -1, 		
                                       LVNI_ALL		
                                   )))
                            {
                                // No CSPs!  We can't enroll for this template. 
                                I_MessageBox(hwndDlg, 
                                             IDS_NO_CSP_FOR_PURPOSE, 
                                             pCertWizardInfo->idsConfirmTitle,
                                             pCertWizardInfo->pwszConfirmationTitle,
                                             MB_ICONEXCLAMATION|MB_OK|MB_APPLMODAL);
                                SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_RENEW_OPTIONS);
                            }
                        }
                        
                        break;

                    case PSN_WIZBACK:
                        break;

                    case PSN_WIZNEXT:
                            if(NULL==(pCertWizardInfo=(CERT_WIZARD_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                                break;

                            //get the window handle of the exportkey
                            if(NULL==(hwndControl=GetDlgItem(hwndDlg, IDC_WIZARD_CHECK_EXPORTKEY)))
                                break;

                            //mark the pose the cert to the CSP
                            if(TRUE==SendMessage(hwndControl, BM_GETCHECK, 0, 0))
                                pCertWizardInfo->dwGenKeyFlags |= CRYPT_EXPORTABLE;
                            else
                                pCertWizardInfo->dwGenKeyFlags &= ~CRYPT_EXPORTABLE;



                            //get the window handle of the user protection
                            if(NULL==(hwndControl=GetDlgItem(hwndDlg, IDC_WIZARD_CHECK2)))
                                break;

                            //mark the pose the cert to the CSP
                            if(TRUE==SendMessage(hwndControl, BM_GETCHECK, 0, 0))
                                pCertWizardInfo->dwGenKeyFlags |= CRYPT_USER_PROTECTED;
                            else
                                pCertWizardInfo->dwGenKeyFlags &= ~CRYPT_USER_PROTECTED;

			    // Set the key size based on the user's suggestion: 
			    //
			    if (NULL==(hwndControl=GetDlgItem(hwndDlg, IDC_WIZARD_COMBO1)))
				break;

			    if (CB_ERR != (dwSelected = (DWORD)SendMessage(hwndControl, CB_GETCURSEL, 0, 0)))
			    {
				pCertWizardInfo->dwMinKeySize = (DWORD)SendMessage(hwndControl, CB_GETITEMDATA, dwSelected, 0); 
			    }
			    else
			    {
				pCertWizardInfo->dwMinKeySize = 0; 
			    }


                            //get the window handle for the CSP list
                            if(NULL==(hwndControl=GetDlgItem(hwndDlg, IDC_WIZARD_LIST1)))
                                break;

                             //now, mark the ones that are selected
                             if(-1 != (dwIndex= ListView_GetNextItem(
                                    hwndControl, 		
                                    -1, 		
                                    LVNI_SELECTED		
                                )))	
                             {

                                //get the selected certificate
                                memset(&lvItem, 0, sizeof(LV_ITEM));
                                lvItem.mask=LVIF_PARAM;
                                lvItem.iItem=(int)dwIndex;

                                if(ListView_GetItem(hwndControl,
                                                 &lvItem))
                                {
                                    pCertWizardInfo->dwProviderType=pCertWizardInfo->rgdwProviderType[(DWORD)(lvItem.lParam)];
                                    pCertWizardInfo->pwszProvider=pCertWizardInfo->rgwszProvider[(DWORD)(lvItem.lParam)];
                                }
                                else
                                {
                                    I_MessageBox(hwndDlg, IDS_NO_SELECTED_CSP,
                                                    pCertWizardInfo->idsConfirmTitle,
                                                    pCertWizardInfo->pwszConfirmationTitle,
                                                    MB_ICONERROR|MB_OK|MB_APPLMODAL);

                                    //make the purpose page stay

                                    SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);

                                break;
                                }
                             }
                            else
                            {
                                I_MessageBox(hwndDlg, IDS_NO_SELECTED_CSP,
                                                pCertWizardInfo->idsConfirmTitle,
                                                pCertWizardInfo->pwszConfirmationTitle,
                                                MB_ICONERROR|MB_OK|MB_APPLMODAL);

                                //make the purpose page stay
                                SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);

                                break;

                            }

                            //skip to the correct page based on the advanced options and CSP requirement
                            if(FALSE == pCertWizardInfo->fUIAdv)
                                SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_RENEW_COMPLETION);

                        break;

				    default:
					    return FALSE;

    	        }
		    break;

		default:
			return FALSE;
	}

	return TRUE;
}

//-----------------------------------------------------------------------
//Renew_CA
//-----------------------------------------------------------------------
INT_PTR APIENTRY Renew_CA(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CERT_WIZARD_INFO        *pCertWizardInfo=NULL;
    PROPSHEETPAGE           *pPropSheet=NULL;
    DWORD                   dwChar=0;

    PCRYPTUI_CA_CONTEXT     pCAContext=NULL;
	LPWSTR					pwszCADisplayName=NULL;

    HCURSOR                 hPreCursor=NULL;
    HCURSOR                 hWinPreCursor=NULL;


    switch (msg)
	{
		case WM_INITDIALOG:
            //set the wizard information so that it can be shared
            pPropSheet = (PROPSHEETPAGE *) lParam;
            pCertWizardInfo = (CERT_WIZARD_INFO *) (pPropSheet->lParam);

            SetControlFont(pCertWizardInfo->hBold, hwndDlg,IDC_WIZARD_STATIC_BOLD1);

            //make sure pCertWizardInfo is a valid pointer
            if(NULL==pCertWizardInfo)
               break;

            SetWindowLongPtr(hwndDlg, DWLP_USER, (LONG_PTR)pCertWizardInfo);

            //init the CA name and CA location
            if(pCertWizardInfo->pwszCALocation)
                SetDlgItemTextU(hwndDlg, IDC_WIZARD_EDIT2,pCertWizardInfo->pwszCALocation);

            if(pCertWizardInfo->pwszCAName)
			{
                //overwrite the cursor for this window class
                hWinPreCursor=(HCURSOR)SetClassLongPtr(hwndDlg, GCLP_HCURSOR, (LONG_PTR)NULL);
                hPreCursor=SetCursor(LoadCursor(NULL, IDC_WAIT));


             	if(CAUtilGetCADisplayName((pCertWizardInfo->fMachine) ? CA_FIND_LOCAL_SYSTEM:0,
							   pCertWizardInfo->pwszCAName,
							   &pwszCADisplayName))
				{
					SetDlgItemTextU(hwndDlg, IDC_WIZARD_EDIT1,pwszCADisplayName);
					WizardFree(pwszCADisplayName);
					pwszCADisplayName=NULL;
				}
				else
					SetDlgItemTextU(hwndDlg, IDC_WIZARD_EDIT1,pCertWizardInfo->pwszCAName);

				//set the cursor back
				SetCursor(hPreCursor);
				SetWindowLongPtr(hwndDlg, GCLP_HCURSOR, (LONG_PTR)hWinPreCursor);
			}

			break;

		case WM_COMMAND:
                if(HIWORD(wParam) == BN_CLICKED)
                {
                    switch (LOWORD(wParam))
                    {
                        case    IDC_WIZARD_BUTTON1:

                                if(NULL==(pCertWizardInfo=(CERT_WIZARD_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                                    break;

								//overwrite the cursor for this window class
								hWinPreCursor=(HCURSOR)SetClassLongPtr(hwndDlg, GCLP_HCURSOR, (LONG_PTR)NULL);
								hPreCursor=SetCursor(LoadCursor(NULL, IDC_WAIT));

                                //call the CA selection dialogue
                                pCAContext=GetCAContext(hwndDlg, pCertWizardInfo);

								//set the cursor back
								SetCursor(hPreCursor);
								SetWindowLongPtr(hwndDlg, GCLP_HCURSOR, (LONG_PTR)hWinPreCursor);

                                if(pCAContext)
                                {
                                    //update the edit box
                                    if(pCAContext->pwszCAMachineName)
                                        SetDlgItemTextU(hwndDlg, IDC_WIZARD_EDIT2,pCAContext->pwszCAMachineName);

                                    if(pCAContext->pwszCAName)
                                        SetDlgItemTextU(hwndDlg, IDC_WIZARD_EDIT1,pCAContext->pwszCAName);

                                    //free the CA context
                                    CryptUIDlgFreeCAContext(pCAContext);

                                    pCAContext=NULL;

                                }

                            break;
                        default:
                            break;
                    }
                }

			break;	
						
		case WM_NOTIFY:
    		    switch (((NMHDR FAR *) lParam)->code)
    		    {

  				    case PSN_KILLACTIVE:
                            SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
					        return TRUE;

                        break;

				    case PSN_RESET:
                            SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
					    break;

 				    case PSN_SETACTIVE:
 					        PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_NEXT|PSWIZB_BACK);
					    break;

                    case PSN_WIZBACK:
                            if(NULL==(pCertWizardInfo=(CERT_WIZARD_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                                break;

                            //skip to the correct page based on the advanced options and CSP requirement
                            if(FALSE == pCertWizardInfo->fNewKey)
                                SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_RENEW_OPTIONS);
                        break;

                    case PSN_WIZNEXT:

                            if(NULL==(pCertWizardInfo=(CERT_WIZARD_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                                break;		   

							//cach the display name of the CA
							if(0!=(dwChar=(DWORD)SendDlgItemMessage(hwndDlg,
												   IDC_WIZARD_EDIT1,
												   WM_GETTEXTLENGTH, 0, 0)))
							{
								if(pCertWizardInfo->pwszCADisplayName)
								{
									WizardFree(pCertWizardInfo->pwszCADisplayName);
									pCertWizardInfo->pwszCADisplayName = NULL;
								}

								pCertWizardInfo->pwszCADisplayName=(LPWSTR)WizardAlloc(sizeof(WCHAR)*(dwChar+1));

								if(NULL!=(pCertWizardInfo->pwszCADisplayName))
								{
									GetDlgItemTextU(hwndDlg, IDC_WIZARD_EDIT1,
													pCertWizardInfo->pwszCADisplayName,
													dwChar+1);

								}
							}
                        break;

				    default:
					    return FALSE;

    	        }
		    break;

		default:
			return FALSE;
	}

	return TRUE;
}



//-----------------------------------------------------------------------
// Renew_Completion
//-----------------------------------------------------------------------
INT_PTR APIENTRY Renew_Completion(HWND hwndDlg, UINT msg, WPARAM /*wParam*/, LPARAM lParam)
{
    CERT_WIZARD_INFO        *pCertWizardInfo=NULL;
    PROPSHEETPAGE           *pPropSheet=NULL;
    HWND                    hwndControl=NULL;
    LV_COLUMNW              lvC;

    HCURSOR                 hPreCursor=NULL;
    HCURSOR                 hWinPreCursor=NULL;

	switch (msg)
	{
		case WM_INITDIALOG:
            //set the wizard information so that it can be shared
            pPropSheet = (PROPSHEETPAGE *) lParam;
            pCertWizardInfo = (CERT_WIZARD_INFO *) (pPropSheet->lParam);
            //make sure pCertWizardInfo is a valid pointer
            if(NULL==pCertWizardInfo)
                break;

            SetWindowLongPtr(hwndDlg, DWLP_USER, (LONG_PTR)pCertWizardInfo);

            SetControlFont(pCertWizardInfo->hBigBold, hwndDlg,IDC_WIZARD_STATIC_BIG_BOLD1);

            //insert two columns
            hwndControl=GetDlgItem(hwndDlg, IDC_WIZARD_LIST1);

            memset(&lvC, 0, sizeof(LV_COLUMNW));

            lvC.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
            lvC.fmt = LVCFMT_LEFT;  // Left-align the column.
            lvC.cx = 20;          // Width of the column, in pixels.
            lvC.pszText = L"";   // The text for the column.
            lvC.iSubItem=0;

            if (ListView_InsertColumnU(hwndControl, 0, &lvC) == -1)
                break;

            //2nd column is the content
            memset(&lvC, 0, sizeof(LV_COLUMNW));

            lvC.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
            lvC.fmt = LVCFMT_LEFT;  // Left-align the column.
            lvC.cx = 10; //(dwMaxSize+2)*7;          // Width of the column, in pixels.
            lvC.pszText = L"";   // The text for the column.
            lvC.iSubItem= 1;

            if (ListView_InsertColumnU(hwndControl, 1, &lvC) == -1)
                break;

            break;
		case WM_COMMAND:
			break;	
						
		case WM_NOTIFY:
    		    switch (((NMHDR FAR *) lParam)->code)
    		    {

  				    case PSN_KILLACTIVE:
                            SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
					        return TRUE;

                        break;

				    case PSN_RESET:
                            SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
					    break;

 				    case PSN_SETACTIVE:
 					        PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK|PSWIZB_FINISH);

                            if(NULL==(pCertWizardInfo=(CERT_WIZARD_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                                break;

                            //overwrite the cursor for this window class
                            hWinPreCursor=(HCURSOR)SetClassLongPtr(hwndDlg, GCLP_HCURSOR, (LONG_PTR)NULL);
                            hPreCursor=SetCursor(LoadCursor(NULL, IDC_WAIT));

                            //populate the list box in the order of
                            //UserName, CSP, and Publish to the DS
                            //Get the window handle for the CSP list
                            if(hwndControl=GetDlgItem(hwndDlg, IDC_WIZARD_LIST1))
                                DisplayConfirmation(hwndControl, pCertWizardInfo);

                            //set the cursor back
                            SetCursor(hPreCursor);
                            SetWindowLongPtr(hwndDlg, GCLP_HCURSOR, (LONG_PTR)hWinPreCursor);

						break;

                    case PSN_WIZBACK:
                            if(NULL==(pCertWizardInfo=(CERT_WIZARD_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                                break;

                            //skip to the correct page based on the advanced options and CSP requirement
                            if(FALSE == pCertWizardInfo->fUIAdv)
                            {
                                if(TRUE == pCertWizardInfo->fUICSP)
                                    SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_RENEW_SERVICE_PROVIDER);
                                else
                                    SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_RENEW_OPTIONS);
                            }

                        break;

                    case PSN_WIZFINISH:
                        {
                            CertRequester        *pCertRequester        = NULL; 
                            CertRequesterContext *pCertRequesterContext = NULL;
                            
                            if(NULL==(pCertWizardInfo=(CERT_WIZARD_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                                break;

                            //overwrite the cursor for this window class
                            hWinPreCursor=(HCURSOR)SetClassLongPtr(hwndDlg, GCLP_HCURSOR, (LONG_PTR)NULL);

                            hPreCursor=SetCursor(LoadCursor(NULL, IDC_WAIT));

                            //set the parent window to the hwndDlg so that
                            //confirmat to install dlg use hwndDlg as the
                            //parent window
                            pCertWizardInfo->hwndParent=hwndDlg;

			    if (NULL == (pCertRequester = (CertRequester *) pCertWizardInfo->hRequester))
                                break;
                            if (NULL == (pCertRequesterContext = pCertRequester->GetContext()))
                                break; 

                            //call the enrollment wizard
			    pCertWizardInfo->hr = pCertRequesterContext->Enroll(&(pCertWizardInfo->dwStatus), (HANDLE *)&(pCertWizardInfo->pNewCertContext));
			    if (0 == pCertWizardInfo->idsText) { 
                                pCertWizardInfo->idsText = CryptUIStatusToIDSText(pCertWizardInfo->hr, pCertWizardInfo->dwStatus); 
                            }
			    
			    if(S_OK != pCertWizardInfo->hr)
				break; 

                            //set the cursor back
                            SetCursor(hPreCursor);
                            SetWindowLongPtr(hwndDlg, GCLP_HCURSOR, (LONG_PTR)hWinPreCursor);
                        }

                        break;

				    default:
					    return FALSE;

    	        }
		    break;

		default:

			    return FALSE;
	}

	return TRUE;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Two-stage no-DS entry point for certificate enrollment and renewal.  
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
BOOL
WINAPI
CryptUIWizCreateCertRequestNoDS
(IN  DWORD                                   dwFlags, 
 IN  HWND                                    hwndParent, 
 IN  PCCRYPTUI_WIZ_CREATE_CERT_REQUEST_INFO  pCreateCertRequestInfo, 
 OUT HANDLE                                 *phRequest)
{

    BOOL                   fAllocateCSP          = FALSE; 
    BOOL                   fResult               = FALSE; 
    CertRequester         *pCertRequester        = NULL; 
    CertRequesterContext  *pCertRequesterContext = NULL; 
    CERT_WIZARD_INFO       CertWizardInfo; 
    CRYPT_KEY_PROV_INFO   *pKeyProvInfo          = NULL;
    LPWSTR                 pwszAllocatedCSP      = NULL;
    LPWSTR                 pwszMachineName       = NULL; 
    UINT                   idsText               = IDS_INVALID_INFO_FOR_PKCS10;
    
    // STATIC INITIALIZATION:  initialize our object factory.
#if DBG
    assert(NULL == g_pEnrollFactory);
#endif

    // Initialization: 
    memset(&CertWizardInfo, 0, sizeof(CertWizardInfo)); 
    *phRequest = NULL; 


    g_pEnrollFactory = new EnrollmentCOMObjectFactory; 
    if (NULL == g_pEnrollFactory)
	goto MemoryErr; 

    // Input validation: 
    if (NULL == pCreateCertRequestInfo || NULL == phRequest)
	goto InvalidArgErr; 

    if (pCreateCertRequestInfo->dwSize != sizeof(CRYPTUI_WIZ_CREATE_CERT_REQUEST_INFO))
	goto InvalidArgErr; 

    if ((pCreateCertRequestInfo->dwPurpose != CRYPTUI_WIZ_CERT_ENROLL) &&
	(pCreateCertRequestInfo->dwPurpose != CRYPTUI_WIZ_CERT_RENEW))
	goto InvalidArgErr; 

    if (0 == (CRYPTUI_WIZ_NO_UI & dwFlags))
	goto InvalidArgErr; 

    
    if (pCreateCertRequestInfo->fMachineContext)
    {	
        dwFlags |= CRYPTUI_WIZ_NO_INSTALL_ROOT; 

        pwszMachineName = (LPWSTR)WizardAlloc(sizeof(WCHAR) * (MAX_COMPUTERNAME_LENGTH+1)); 
        if (NULL == pwszMachineName) 
            goto MemoryErr; 

        DWORD dwSize = MAX_COMPUTERNAME_LENGTH+1; 
        if (!GetComputerNameU(pwszMachineName, &dwSize))
        {
            idsText = IDS_FAIL_TO_GET_COMPUTER_NAME;
            goto GetComputerNameUError; 
        }
    }

    // Copy the dwFlags. 
    CertWizardInfo.dwFlags = dwFlags; 
   
    if (S_OK != (CertRequester::MakeCertRequester
		 (NULL, 
		  pwszMachineName, 
		  pCreateCertRequestInfo->dwCertOpenStoreFlag, 
		  pCreateCertRequestInfo->dwPurpose, 
		  &CertWizardInfo, 
		  &pCertRequester, 
		  &idsText)))
	goto InvalidArgErr; 

    pCertRequesterContext = pCertRequester->GetContext(); 

    // We can pass in a parent hwnd -- however, this is used only 
    // as the parent of CSP ui:
    if (NULL != hwndParent)
    {
        if ((0 == (CRYPTUI_WIZ_NO_UI & dwFlags)) || 
            (0 != (CRYPTUI_WIZ_IGNORE_NO_UI_FLAG_FOR_CSPS & dwFlags)))
        {
            if (!CryptSetProvParam(0 /*all CSPs*/, PP_CLIENT_HWND, (LPBYTE)&hwndParent, sizeof(hwndParent)))
            {
                goto CryptSetProvParamError; 
            }
        }
    }
    
    // We're not using the wizard UI, so we don't need to change the cursor. 
    CertWizardInfo.fCursorChanged = FALSE; 

    // Enroll or renew
    CertWizardInfo.dwPurpose      = pCreateCertRequestInfo->dwPurpose;
    
    // The CA name and location must be provided:
    CertWizardInfo.fCAInput       = TRUE; 
    if(NULL == pCreateCertRequestInfo->pwszCALocation || NULL == pCreateCertRequestInfo->pwszCAName) 
        goto InvalidArgErr;

    CertWizardInfo.pwszCALocation = (LPWSTR)pCreateCertRequestInfo->pwszCALocation;
    CertWizardInfo.pwszCAName = (LPWSTR)pCreateCertRequestInfo->pwszCAName;

    // We always enroll for certs in our current context: 
    CertWizardInfo.fLocal         = TRUE; 
    
    if (!CheckPVKInfoNoDS
	(dwFlags, 
	 pCreateCertRequestInfo->dwPvkChoice, 
	 pCreateCertRequestInfo->pPvkCert,
	 pCreateCertRequestInfo->pPvkNew,
	 pCreateCertRequestInfo->pPvkExisting,
	 CRYPTUI_WIZ_CERT_REQUEST_CERT_TYPE,
	 &CertWizardInfo, 
	 &pKeyProvInfo))
	goto InvalidArgErr; 

    //make sure the CSP selected is supported by the local machine
    //populate the pwszProvider in CertWizardInfo if it is NULL
    if (S_OK != pCertRequesterContext->GetDefaultCSP(&fAllocateCSP))
    {
        idsText = pCertRequesterContext->GetErrorString();
        goto InvalidArgErr; 
    }

    if (fAllocateCSP)
	pwszAllocatedCSP = CertWizardInfo.pwszProvider; 

    if (S_OK != pCertRequesterContext->BuildCSPList())
    {
	idsText = IDS_FAIL_TO_GET_CSP_LIST; 
	goto TraceErr; 
    }

    if (0 != CertWizardInfo.dwProviderType || NULL != CertWizardInfo.pwszProvider)
    {
	if (!CSPSupported(&CertWizardInfo))
	{
	    idsText = IDS_CSP_NOT_SUPPORTED;
	    goto InvalidArgErr;
	}
    }

  //set it see if the provider is known
   if(NULL != CertWizardInfo.pwszProvider)
   {
       CertWizardInfo.fKnownCSP      = TRUE;
       CertWizardInfo.dwOrgCSPType   = CertWizardInfo.dwProviderType;
       CertWizardInfo.pwszOrgCSPName = CertWizardInfo.pwszProvider;
   }
   else
   {
       CertWizardInfo.fKnownCSP=FALSE; 
   }
   
   //check the dwCertChoice for the enroll case
   if(CRYPTUI_WIZ_CERT_ENROLL & (pCreateCertRequestInfo->dwPurpose))
   {
       // We're enrolling based on cert type. 
       // Check that we have a valid cert type:

       if(!CAUtilValidCertTypeNoDS(pCreateCertRequestInfo->hCertType,  // The cert type we'll use to enroll.
				   NULL,                               // The DN Name of the cert type.  We don't know it. 
				   &CertWizardInfo                     // Our wizard info.  
				   ))
       {
	   idsText=IDS_NO_PERMISSION_FOR_CERTTYPE;
	   goto CheckCertTypeErr;
       }
   }

   if (pCreateCertRequestInfo->dwPurpose & CRYPTUI_WIZ_CERT_RENEW)
   {
       DWORD dwSize;

       CertWizardInfo.pCertContext = pCreateCertRequestInfo->pRenewCertContext; 
       
        //the certificate has to have the property
        if(!CertGetCertificateContextProperty
	   (CertWizardInfo.pCertContext,
	    CERT_KEY_PROV_INFO_PROP_ID,
	    NULL,
	    &dwSize) || (0==dwSize))
	{
            idsText=IDS_NO_PVK_FOR_RENEW_CERT;
            goto InvalidArgErr;
        }
   }

   //reset the initial ids valud
   idsText=IDS_INVALID_INFO_FOR_PKCS10;

   fResult = CreateCertRequestNoSearchCANoDS
     (&CertWizardInfo,
      dwFlags,
      pCreateCertRequestInfo->hCertType, 
      phRequest);

   if(FALSE==fResult)
       goto CertRequestErr;
   
   // Save the machine name with the request handle: 
   ((PCREATE_REQUEST_WIZARD_STATE)*phRequest)->pwszMachineName = pwszMachineName;
   ((PCREATE_REQUEST_WIZARD_STATE)*phRequest)->dwStoreFlags    = CertWizardInfo.dwStoreFlags; 
   pwszMachineName = NULL; 
   fResult=TRUE;

 CommonReturn:
   if (NULL != pKeyProvInfo)                         { WizardFree(pKeyProvInfo); } 
   if (fAllocateCSP && NULL != pwszAllocatedCSP)     { WizardFree(pwszAllocatedCSP); }
   if (NULL != pwszMachineName)                      { WizardFree(pwszMachineName); } 
   if (NULL != pCertRequester)                       { delete(pCertRequester); } 
   
   if (NULL != g_pEnrollFactory)                     
   {
       delete g_pEnrollFactory;
       g_pEnrollFactory = NULL;
   }
   
   FreeProviders(CertWizardInfo.dwCSPCount, 
		 CertWizardInfo.rgdwProviderType, 
		 CertWizardInfo.rgwszProvider); 

   return fResult; 

 ErrorReturn: 
   fResult = FALSE; 
   goto CommonReturn; 
   
SET_ERROR(InvalidArgErr, ERROR_INVALID_PARAMETER); 
SET_ERROR(MemoryErr, ERROR_NOT_ENOUGH_MEMORY);
TRACE_ERROR(CryptSetProvParamError); 
TRACE_ERROR(CertRequestErr); 
TRACE_ERROR(CheckCertTypeErr); 
TRACE_ERROR(GetComputerNameUError); 
TRACE_ERROR(TraceErr); 
}

BOOL
WINAPI
CryptUIWizSubmitCertRequestNoDS
(IN HANDLE           hRequest, 
 IN  HWND            hwndParent, 
 IN LPCWSTR          pwszCAName, 
 IN LPCWSTR          pwszCALocation, 
 OUT DWORD          *pdwStatus, 
 OUT PCCERT_CONTEXT *ppCertContext  // Optional
)
{
    BOOL    fResult; 

    // STATIC INITIALIZATION:  initialize our object factory
#if DBG
    assert(NULL == g_pEnrollFactory);
#endif
    g_pEnrollFactory = new EnrollmentCOMObjectFactory; 
    if (NULL == g_pEnrollFactory)
	goto MemoryErr; 

    // We can pass in a parent hwnd -- however, this is used only 
    // as the parent of CSP ui:
    if (NULL != hwndParent)
    {
        if (!CryptSetProvParam(0 /*all CSPs*/, PP_CLIENT_HWND, (LPBYTE)&hwndParent, sizeof(hwndParent)))
        {
            goto CryptSetProvParamError; 
        }
    }

    fResult = SubmitCertRequestNoSearchCANoDS
	(hRequest, 
	 pwszCAName, 
	 pwszCALocation, 
	 pdwStatus, 
	 ppCertContext);

 CommonReturn:
    if (NULL != g_pEnrollFactory) 
    { 
        delete g_pEnrollFactory; 
        g_pEnrollFactory = NULL; 
    } 

    return fResult; 

 ErrorReturn:
    fResult = FALSE; 
    goto CommonReturn; 

TRACE_ERROR(CryptSetProvParamError); 
SET_ERROR(MemoryErr, ERROR_NOT_ENOUGH_MEMORY);
}

void
WINAPI
CryptUIWizFreeCertRequestNoDS
(IN HANDLE hRequest)
{
    // STATIC INITIALIZATION:  initialize our object factory
#if DBG
    assert(NULL == g_pEnrollFactory);
#endif
    g_pEnrollFactory = new EnrollmentCOMObjectFactory; 
    if (NULL == g_pEnrollFactory)
	return; // Not much we can do about this ... 
    
    FreeCertRequestNoSearchCANoDS(hRequest);

    if (NULL != g_pEnrollFactory) 
    { 
        delete g_pEnrollFactory; 
        g_pEnrollFactory = NULL; 
    } 
}

BOOL 
WINAPI
CryptUIWizQueryCertRequestNoDS
(IN HANDLE hRequest, OUT CRYPTUI_WIZ_QUERY_CERT_REQUEST_INFO *pQueryInfo)
{
    BOOL                          fResult; 
    CERT_WIZARD_INFO              CertWizardInfo; 
    CertRequester                *pCertRequester; 
    HRESULT                       hr; 
    PCREATE_REQUEST_WIZARD_STATE  pState; 
    UINT                          idsText; 

    if (NULL == hRequest || NULL == pQueryInfo) 
        goto InvalidArgErr; 

    memset(&CertWizardInfo,  0,  sizeof(CertWizardInfo)); 
    // Specify this set of flags to indicate that cryptui doesn't need to prepare 
    // access check information.  Doing so could cause lots of extraneous logoff/logon events. 
    CertWizardInfo.dwFlags = CRYPTUI_WIZ_ALLOW_ALL_TEMPLATES | CRYPTUI_WIZ_ALLOW_ALL_CAS; 

    pState = (PCREATE_REQUEST_WIZARD_STATE)hRequest; 

    if (S_OK != (hr = CertRequester::MakeCertRequester
		 (NULL, 
		  pState->pwszMachineName, 
		  pState->dwStoreFlags, 
                  pState->dwPurpose, 
		  &CertWizardInfo, 
		  &pCertRequester, 
		  &idsText 
                  )))
	goto MakeCertRequesterErr; 

    if (S_OK != (hr = pCertRequester->GetContext()->QueryRequestStatus(pState->hRequest, pQueryInfo)))
        goto QueryRequestStatusErr; 

    fResult = TRUE; 
 CommonReturn:
    return fResult;

 ErrorReturn:
    fResult = FALSE;
    goto CommonReturn; 

SET_ERROR(InvalidArgErr,          E_INVALIDARG); 
SET_ERROR(MakeCertRequesterErr,   hr);
SET_ERROR(QueryRequestStatusErr,  hr); 
}


HRESULT getTemplateName(PCCERT_CONTEXT pCertContext, LPWSTR *ppwszName)   { 
    CERT_NAME_VALUE   *pCertTemplateNameValue   = NULL;
    DWORD              cbCertTemplateNameValue; 
    DWORD              cbRequired; 
    HRESULT            hr                       = S_OK; 
    PCERT_EXTENSION    pCertTemplateExtension   = NULL; 

    if (NULL == (pCertTemplateExtension = CertFindExtension
                 (szOID_ENROLL_CERTTYPE_EXTENSION,
                  pCertContext->pCertInfo->cExtension,
                  pCertContext->pCertInfo->rgExtension)))
        goto CertFindExtensionError; 

    if (!CryptDecodeObject
        (pCertContext->dwCertEncodingType,
         X509_UNICODE_ANY_STRING,
         pCertTemplateExtension->Value.pbData,
         pCertTemplateExtension->Value.cbData,
         0,
         NULL, 
         &cbCertTemplateNameValue) || (cbCertTemplateNameValue == 0))
        goto CryptDecodeObjectError; 
		
    pCertTemplateNameValue = (CERT_NAME_VALUE *)WizardAlloc(cbCertTemplateNameValue); 
    if (NULL == pCertTemplateNameValue)
        goto MemoryErr; 

    if (!CryptDecodeObject
        (pCertContext->dwCertEncodingType,
         X509_UNICODE_ANY_STRING,
         pCertTemplateExtension->Value.pbData,
         pCertTemplateExtension->Value.cbData,
         0,
         (void *)(pCertTemplateNameValue), 
         &cbCertTemplateNameValue))
        goto CryptDecodeObjectError; 

    cbRequired = sizeof(WCHAR) * (wcslen((LPWSTR)(pCertTemplateNameValue->Value.pbData)) + 1);
    *ppwszName = (LPWSTR)WizardAlloc(cbRequired); 
    if (NULL == *ppwszName)
        goto MemoryErr; 

    // Assign the OUT parameter:
    wcscpy(*ppwszName, (LPWSTR)(pCertTemplateNameValue->Value.pbData)); 
    hr = S_OK;
 ErrorReturn:
    if (NULL != pCertTemplateNameValue) { WizardFree(pCertTemplateNameValue); }
    return hr; 

SET_HRESULT(CertFindExtensionError,  HRESULT_FROM_WIN32(GetLastError()));
SET_HRESULT(CryptDecodeObjectError,  HRESULT_FROM_WIN32(GetLastError()));
SET_HRESULT(MemoryErr,               E_OUTOFMEMORY); 
}

HRESULT decodeTemplateOID(PCERT_EXTENSION pCertExtension, LPSTR *ppszOID, DWORD dwEncodingType) {
    CERT_TEMPLATE_EXT  *pCertTemplateExt    = NULL; 
    DWORD               cbCertTemplateExt   = 0; 
    DWORD               cbRequired; 
    HRESULT             hr;
            
    if (FALSE == CryptDecodeObject
        (dwEncodingType,
         X509_CERTIFICATE_TEMPLATE, 
         pCertExtension->Value.pbData,
         pCertExtension->Value.cbData,
         0,
         NULL, 
         &cbCertTemplateExt) || (cbCertTemplateExt == 0))
        goto CryptDecodeObjectError; 
            
    pCertTemplateExt = (CERT_TEMPLATE_EXT *)WizardAlloc(cbCertTemplateExt); 
    if (NULL == pCertTemplateExt)
        goto MemoryErr; 

    if (FALSE == CryptDecodeObject
        (dwEncodingType,
         X509_CERTIFICATE_TEMPLATE, 
         pCertExtension->Value.pbData,
         pCertExtension->Value.cbData,
         0,
         (void *)(pCertTemplateExt), 
         &cbCertTemplateExt))
        goto CryptDecodeObjectError;

    cbRequired = strlen(pCertTemplateExt->pszObjId) + sizeof(CHAR); 
    *ppszOID = (LPSTR)WizardAlloc(cbRequired); 
    if (NULL == *ppszOID)
        goto MemoryErr; 

    strcpy(*ppszOID, pCertTemplateExt->pszObjId); 
    hr = S_OK; 
 ErrorReturn:
    if (NULL != pCertTemplateExt) { LocalFree(pCertTemplateExt); } 
    return hr; 

SET_HRESULT(CryptDecodeObjectError,  HRESULT_FROM_WIN32(GetLastError()));
SET_HRESULT(MemoryErr,               E_OUTOFMEMORY); 
} 

HRESULT getTemplateOID(PCCERT_CONTEXT pCertContext, LPSTR *ppszOID)    { 
    HRESULT             hr;
    PCERT_EXTENSION     pCertExtension      = NULL; 
            
    if (NULL == (pCertExtension = CertFindExtension
                 (szOID_CERTIFICATE_TEMPLATE, 
                  pCertContext->pCertInfo->cExtension,
                  pCertContext->pCertInfo->rgExtension)))
        goto CertFindExtensionError; 

    hr = decodeTemplateOID(pCertExtension, ppszOID, pCertContext->dwCertEncodingType); 
ErrorReturn:
    return hr; 

SET_HRESULT(CertFindExtensionError,  HRESULT_FROM_WIN32(GetLastError()));
} 

BOOL ContainsCertTemplateOid(PCERT_EXTENSIONS pCertExtensions, LPWSTR pwszTemplateOid)
{
    BOOL             fResult         = FALSE; 
    LPSTR            pszOid          = NULL;  
    LPWSTR           pwszOid         = NULL;  
    PCERT_EXTENSION  pCertExtension  = NULL; 

    if (NULL == (pCertExtension = CertFindExtension(szOID_CERTIFICATE_TEMPLATE, pCertExtensions->cExtension, pCertExtensions->rgExtension)))
        goto CertFindExtensionError; 

    if (S_OK != decodeTemplateOID(pCertExtension, &pszOid, X509_ASN_ENCODING | PKCS_7_ASN_ENCODING))
        goto decodeTemplateOIDError; 

    if (S_OK != WizardSZToWSZ(pszOid, &pwszOid))
        goto MemoryError; 

    fResult = 0 == wcscmp(pwszOid, pwszTemplateOid); 
 ErrorReturn:
    if (NULL != pszOid)  { WizardFree(pszOid); } 
    if (NULL != pwszOid) { WizardFree(pwszOid); } 

    return fResult; 

TRACE_ERROR(CertFindExtensionError);
TRACE_ERROR(decodeTemplateOIDError);
TRACE_ERROR(MemoryError);
}


//********************************************************************************
//  Enrollment and renew
//
//  UI or ULless dll entry points
//
//
//********************************************************************************

//-----------------------------------------------------------------------
//
//  CryptUIWizCertRequest
//
//      Request a certificate via a wizard.
//
//  dwFlags:  IN Required
//      If CRYPTUI_WIZ_NO_UI is set in dwFlags, no UI will be shown.
//
//  hwndParent:  IN Optional
//      The parent window for the UI.  Ignored if CRYPTUI_WIZ_NO_UI is set in dwFlags
//
//  pwszWizardTitle: IN Optional
//      The title of the wizard.   Ignored if CRYPTUI_WIZ_NO_UI is set in dwFlags
//
//  pCertRequestInfo: IN Required
//      A pointer to CRYPTUI_WIZ_CERT_REQUEST_INFO struct
//
//  ppCertContext: Out Optional
//      The enrolled certificate.  The certificate is in a memory store.
//
//  pdwStatus: Out Optional.
//      The return status of the certificate cerver.  The dwStatus can be one of
///     the following:
//         CRYPTUI_WIZ_CERT_REQUEST_STATUS_SUCCEEDED
//         CRYPTUI_WIZ_CERT_REQUEST_STATUS_REQUEST_ERROR
//         CRYPTUI_WIZ_CERT_REQUEST_STATUS_REQUEST_DENIED
//         CRYPTUI_WIZ_CERT_REQUEST_STATUS_ISSUED_SEPERATELY
//         CRYPTUI_WIZ_CERT_REQUEST_STATUS_UNDER_SUBMISSION
//------------------------------------------------------------------------
BOOL
WINAPI
CryptUIWizCertRequest(
 IN             DWORD                           dwFlags,
 IN OPTIONAL    HWND                            hwndParent,         //IN  Optional: The parent window handle
 IN OPTIONAL    LPCWSTR                         pwszWizardTitle,    //IN  Optional: The title of the wizard
 IN             PCCRYPTUI_WIZ_CERT_REQUEST_INFO pRequestInfo,
 OUT OPTIONAL   PCCERT_CONTEXT                  *ppCertContext,     //OUT Optional: The enrolled certificate.  The certificate is in a
 OUT OPTIONAL   DWORD                           *pdwStatus          //OUT Optional: The status of the certificate request
)
{
    BOOL                    fResult=FALSE;
    DWORD                   dwLastError=ERROR_SUCCESS; 
    UINT                    idsText=IDS_INVALID_INFO_FOR_PKCS10;
    CERT_WIZARD_INFO        CertWizardInfo;
    CertRequester          *pCertRequester = NULL; 
    CertRequesterContext   *pCertRequesterContext = NULL; 
    BOOL                    fAllocateCSP=FALSE;
    LPWSTR                  pwszAllocatedCSP=NULL;
    PCERT_ENHKEY_USAGE      pEKUsage=NULL;
    HRESULT                 hr; 

    UINT                    uMsgType=MB_OK|MB_ICONINFORMATION;

    CRYPT_KEY_PROV_INFO     *pKeyProvInfo=NULL;


    DWORD                   dwCertChoice=0;
    void                    *pData=NULL;
    CRYPTUI_WIZ_CERT_TYPE   CertType;
    CERT_NAME_VALUE         *pCertType=NULL;
    BOOL                    fResetCertType=FALSE;

    LPWSTR                  pwszCTName=NULL;
    CRYPTUI_WIZ_CERT_TYPE   CertTypeInfo;

    CRYPTUI_WIZ_CERT_REQUEST_INFO   CertRequestInfoStruct;
    PCCRYPTUI_WIZ_CERT_REQUEST_INFO pCertRequestInfo=NULL;


    //memset
    memset(&CertWizardInfo, 0, sizeof(CertWizardInfo));
    memset(&CertTypeInfo, 0, sizeof(CertTypeInfo));
    memset(&CertRequestInfoStruct, 0, sizeof(CRYPTUI_WIZ_CERT_REQUEST_INFO));
    memset(&CertType, 0, sizeof(CertType)); 

    // STATIC INITIALIZATION:  initialize our object factory
#if DBG
    assert(NULL == g_pEnrollFactory);
#endif
    g_pEnrollFactory = new EnrollmentCOMObjectFactory; 
    if (NULL == g_pEnrollFactory)
        goto MemoryErr; 

   //we need to make our own copy of the input data because we will have to change
    //the struct for:
    //1. Renew case
    //2. Map the input cert type name to the REAL GUID- defined cert type name

    pCertRequestInfo=&CertRequestInfoStruct;
    memcpy((void *)pCertRequestInfo, pRequestInfo,sizeof(CRYPTUI_WIZ_CERT_REQUEST_INFO));

    //init the output parameter
    if(ppCertContext)
        *ppCertContext=NULL;

    if(pdwStatus)
        *pdwStatus=CRYPTUI_WIZ_CERT_REQUEST_STATUS_UNKNOWN;


    //check in the input parameters
    if(NULL==pCertRequestInfo)
        goto InvalidArgErr;

    //make sure the dwSize is correct
    if(pCertRequestInfo->dwSize != sizeof(CRYPTUI_WIZ_CERT_REQUEST_INFO))
        goto InvalidArgErr;

    //check the purpose
    if((pCertRequestInfo->dwPurpose != CRYPTUI_WIZ_CERT_ENROLL) &&
       (pCertRequestInfo->dwPurpose != CRYPTUI_WIZ_CERT_RENEW))
       goto InvalidArgErr;

    //copy the dwFlags
    CertWizardInfo.dwFlags=dwFlags;

    if (S_OK != (CertRequester::MakeCertRequester
		 (pCertRequestInfo->pwszAccountName, 
		  pCertRequestInfo->pwszMachineName,
		  pCertRequestInfo->dwCertOpenStoreFlag, 
		  pCertRequestInfo->dwPurpose, 
		  &CertWizardInfo, 
		  &pCertRequester, 
		  &idsText)))
	goto InvalidArgErr; 

    pCertRequesterContext = pCertRequester->GetContext(); 

    //if UILess is required, set the flags so that the root cert
    //will be put into the CA store
    if(CRYPTUI_WIZ_NO_UI & dwFlags)
        dwFlags |= CRYPTUI_WIZ_NO_INSTALL_ROOT;


    //if UI is required, we change the cursor shape to the hour glass
    CertWizardInfo.fCursorChanged=FALSE;
    if(NULL != hwndParent)
    {
        if (0 == (CRYPTUI_WIZ_NO_UI & dwFlags))
        {
            //overwrite the cursor for this window class
            CertWizardInfo.hWinPrevCursor=(HCURSOR)SetClassLongPtr(hwndParent, GCLP_HCURSOR, (LONG_PTR)NULL);

            CertWizardInfo.hPrevCursor=SetCursor(LoadCursor(NULL, IDC_WAIT));

            CertWizardInfo.fCursorChanged=TRUE;

            // BUGBUG:  spec says to use sizeof(DWORD) -- is this correct for 64-bit?
            if (!CryptSetProvParam(0 /*all CSPs*/, PP_CLIENT_HWND, (LPBYTE)&hwndParent, sizeof(hwndParent)))
            {
                goto CryptSetProvParamError; 
            }
        }
        else
        {
            // We've passed a window handle, but have specified no ui. 
            // We may want this window handle to be the parent window for
            // CSP UI:
            if (0 != (CRYPTUI_WIZ_IGNORE_NO_UI_FLAG_FOR_CSPS & dwFlags))
            {
                // BUGBUG:  spec says to use sizeof(DWORD) -- is this correct for 64-bit?
                if (!CryptSetProvParam(0 /*all CSPs*/, PP_CLIENT_HWND, (LPBYTE)&hwndParent, sizeof(hwndParent)))
                {
                    goto CryptSetProvParamError; 
                }
            }
        }
    }

    //check the CA information
    //pwszCALocation and pwszCAName have to be set at the same time
    CertWizardInfo.fCAInput=FALSE;

    if(pCertRequestInfo->pwszCALocation)
    {
        if(NULL==(pCertRequestInfo->pwszCAName))
            goto InvalidArgErr;

        //mark that we known the CA in advance
        CertWizardInfo.fCAInput=TRUE;
    }
    else
    {
        if(pCertRequestInfo->pwszCAName)
            goto InvalidArgErr;
    }

    CertWizardInfo.dwPurpose=pCertRequestInfo->dwPurpose;    

    //make sure NO root UI will pop up in remote enrollment
    if(FALSE == CertWizardInfo.fLocal)
        dwFlags |= CRYPTUI_WIZ_NO_INSTALL_ROOT;

    //check for the private key information
    if(!CheckPVKInfo(dwFlags,
                    pCertRequestInfo,
                    &CertWizardInfo,
                    &pKeyProvInfo))
    {
        idsText=IDS_INVALID_PVK_FOR_PKCS10;

        goto InvalidArgErr;

    }

    //for non-enterprise enrollment, we default the CSP to RSA_FULL
    if(CRYPTUI_WIZ_CERT_REQUEST_KEY_USAGE == pCertRequestInfo->dwCertChoice)
    {
        if(0 == CertWizardInfo.dwProviderType)
            CertWizardInfo.dwProviderType=PROV_RSA_FULL;
    }

    //make sure the CSP selected is supported by the local machine
    //populate the pwszProvider in CertWizardInfo if it is NULL
    if(S_OK != pCertRequesterContext->GetDefaultCSP(&fAllocateCSP))
    {
        idsText = pCertRequesterContext->GetErrorString(); 
	goto InvalidArgErr;
    }

   //copy the allocated string
   if(fAllocateCSP)
      pwszAllocatedCSP=CertWizardInfo.pwszProvider;

   //build the list of local machine's CSP
   if (S_OK != pCertRequesterContext->BuildCSPList())
   {
       idsText = IDS_FAIL_TO_GET_CSP_LIST;
       goto TraceErr;
   }

   //make sure the selected on is in the list
   if(0 != CertWizardInfo.dwProviderType ||
       NULL != CertWizardInfo.pwszProvider)
   {
        if(!CSPSupported(&CertWizardInfo))
        {
            idsText=IDS_CSP_NOT_SUPPORTED;
            goto InvalidArgErr;
        }
   }


   //set it see if the provider is know
   if(CertWizardInfo.pwszProvider)
   {
       CertWizardInfo.fKnownCSP      = TRUE;
       CertWizardInfo.dwOrgCSPType   = CertWizardInfo.dwProviderType;
       CertWizardInfo.pwszOrgCSPName = CertWizardInfo.pwszProvider;
   }
   else
       CertWizardInfo.fKnownCSP=FALSE; 
   
    //check for the renew case.
    //1. The certificate has to be valid
    //2. The certificate has to has a valid cert type extension

    if(CRYPTUI_WIZ_CERT_RENEW == pCertRequestInfo->dwPurpose)
    {
        LPSTR  pszTemplateOid = NULL; 
        LPWSTR pwszTemplateName = NULL; 

        //for renew, the pRenewCertContext has to be set
        if(NULL==pCertRequestInfo->pRenewCertContext)
        {
            idsText=IDS_NO_CERTIFICATE_FOR_RENEW;
            goto InvalidArgErr;
        }

        
        // First, try the CERTIFICATE_TEMPLATE extension.  This will work
        // only for V2 templates: 
        if (S_OK == getTemplateOID(pCertRequestInfo->pRenewCertContext, &pszTemplateOid))
        {        
            // Convert the template oid to a WCHAR * and store it. 
            hr = WizardSZToWSZ(pszTemplateOid, &pwszTemplateName);
            WizardFree(pszTemplateOid); 
            if (S_OK != hr)
                goto WizardSZToWSZError; 

        }
        else
        {
            // We probably have a V1 template, try to get the template name:
            if (S_OK != getTemplateName(pCertRequestInfo->pRenewCertContext, &pwszTemplateName))
            {      
                // No v1 or v2 extension that tells which certtype we've enrolled for.  This is
                // not a valid certificate for renew:
                idsText = IDS_INVALID_CERTIFICATE_TO_RENEW; 
                goto TraceErr; 
            }

            // We successfully acquired the cert type name. 
        }
            
        CertType.dwSize        = sizeof(CertType);
        CertType.cCertType     = 1;
        CertType.rgwszCertType = &pwszTemplateName; 

        ((CRYPTUI_WIZ_CERT_REQUEST_INFO *)pCertRequestInfo)->dwCertChoice=CRYPTUI_WIZ_CERT_REQUEST_CERT_TYPE;
        ((CRYPTUI_WIZ_CERT_REQUEST_INFO *)pCertRequestInfo)->pCertType=&CertType;

        //remember to set the old value back
        fResetCertType = TRUE; 

        //make sure the user has the permission to ask for those
        //request
        if(!CAUtilValidCertType(pCertRequestInfo, &CertWizardInfo))
        {
            idsText=IDS_NO_PERMISSION_FOR_CERTTYPE;
            goto CheckCertTypeErr;
        }
    }

    //check the dwCertChoice for the enroll case
    if(CRYPTUI_WIZ_CERT_ENROLL & (pCertRequestInfo->dwPurpose))
    {
        switch(pCertRequestInfo->dwCertChoice)
        {
        case CRYPTUI_WIZ_CERT_REQUEST_KEY_USAGE:

            if(NULL==(pCertRequestInfo->pKeyUsage))
                goto InvalidArgErr;

            //has to specify some use oid
            if(0==(pCertRequestInfo->pKeyUsage)->cUsageIdentifier)
                goto InvalidArgErr;

            break;

        case CRYPTUI_WIZ_CERT_REQUEST_CERT_TYPE:

            if(NULL==(pCertRequestInfo->pCertType))
                goto InvalidArgErr;

            if(pCertRequestInfo->pCertType->dwSize != sizeof(CRYPTUI_WIZ_CERT_TYPE))
                goto InvalidArgErr;

            //we only allow one cert type for now
            if(1 !=pCertRequestInfo->pCertType->cCertType)
                goto InvalidArgErr;


            //make sure the user has the permission to ask for those
            //request
            if(!CAUtilValidCertType(pCertRequestInfo, &CertWizardInfo))
                {
                    idsText=IDS_NO_PERMISSION_FOR_CERTTYPE;
                    goto CheckCertTypeErr;
                }

            break;

            //dwCertChoice is optional only for the UI case
        case 0:
            if(dwFlags & CRYPTUI_WIZ_NO_UI)
                goto InvalidArgErr;
            break;

        default:
            goto InvalidArgErr;

        }
    }


    //for UI mode, we only do certificate type enrollment/renewal
    if(0 == (dwFlags & CRYPTUI_WIZ_NO_UI))
    {
        if(CRYPTUI_WIZ_CERT_REQUEST_KEY_USAGE == (pCertRequestInfo->dwCertChoice))
        {
            idsText=IDS_INVALID_CERTIFICATE_TO_RENEW;
            goto InvalidArgErr;
        }
    }
    else
    {
        //for UILess mode, if user enroll for EKUs, they
        //have to specify a CA name
        if(CRYPTUI_WIZ_CERT_REQUEST_KEY_USAGE == (pCertRequestInfo->dwCertChoice))
        {
            //user has to supply the CA information
            if((NULL==pCertRequestInfo->pwszCAName) ||
                (NULL==pCertRequestInfo->pwszCALocation)
              )
            {
                idsText=IDS_HAS_TO_PROVIDE_CA;
                goto InvalidArgErr;
            }
        }
    }

   //reset the initial ids valud
    idsText=IDS_INVALID_INFO_FOR_PKCS10;

    fResult=CertRequestSearchCA(
                        &CertWizardInfo,
                        dwFlags,
                        hwndParent,
                        pwszWizardTitle,
                        pCertRequestInfo,
                        ppCertContext,
                        pdwStatus,
                        &idsText);


    if(FALSE==fResult)
        goto CertRequestErr;

    fResult=TRUE;

CommonReturn:
    if(TRUE == fResetCertType)
    {
        ((CRYPTUI_WIZ_CERT_REQUEST_INFO *)pCertRequestInfo)->dwCertChoice=dwCertChoice;
        ((CRYPTUI_WIZ_CERT_REQUEST_INFO *)pCertRequestInfo)->pCertType=(PCCRYPTUI_WIZ_CERT_TYPE)pData;
    }

    //free the memory
    if(pwszCTName)
        WizardFree(pwszCTName);

    if(pCertType)
        WizardFree(pCertType);

    if(pEKUsage)
        WizardFree(pEKUsage);

    if(pKeyProvInfo)
        WizardFree(pKeyProvInfo);

    //free pwszProvider
    if(fAllocateCSP)
    {
        if(pwszAllocatedCSP)
            WizardFree(pwszAllocatedCSP);
    }

    //free the CSP list: rgdwProviderType and rgwszProvider;
    FreeProviders(CertWizardInfo.dwCSPCount,
                    CertWizardInfo.rgdwProviderType,
                    CertWizardInfo.rgwszProvider);

    if (NULL != g_pEnrollFactory) 
    {
        delete g_pEnrollFactory;
        g_pEnrollFactory = NULL; 
    }

    //reset the cursor shape
    if(TRUE == CertWizardInfo.fCursorChanged)
    {
        SetCursor(CertWizardInfo.hPrevCursor);
        SetWindowLongPtr(hwndParent, GCLP_HCURSOR, (LONG_PTR)(CertWizardInfo.hWinPrevCursor));
    }


    //pop up the confirmation box for failure if UI is required
    if(idsText && (((dwFlags & CRYPTUI_WIZ_NO_UI) == 0)) )
    {
         //set the message of inable to gather enough info for PKCS10
        if(IDS_REQUEST_SUCCEDDED == idsText ||
            IDS_ISSUED_SEPERATE  == idsText ||
            IDS_UNDER_SUBMISSION == idsText)
             uMsgType=MB_OK|MB_ICONINFORMATION;
        else
             uMsgType=MB_OK|MB_ICONERROR;


        if(idsText != IDS_INSTAL_CANCELLED)
        {
            I_EnrollMessageBox(hwndParent, idsText, CertWizardInfo.hr,
                 (CRYPTUI_WIZ_CERT_RENEW == pCertRequestInfo->dwPurpose) ? IDS_RENEW_CONFIRM : IDS_ENROLL_CONFIRM,
                            pwszWizardTitle,
                            uMsgType);
        }

    }

    if (!fResult)
        SetLastError(dwLastError); 
    return fResult;

ErrorReturn:
    dwLastError = GetLastError(); 
	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
SET_ERROR(WizardSZToWSZError, hr); 
TRACE_ERROR(CertRequestErr);
TRACE_ERROR(CheckCertTypeErr);
TRACE_ERROR(CryptSetProvParamError); 
TRACE_ERROR(TraceErr);
}

//-----------------------------------------------------------------------
//The call back function for enum
//-----------------------------------------------------------------------
static BOOL WINAPI EnumOidCallback(
    IN PCCRYPT_OID_INFO pInfo,
    IN void *pvArg
    )
{

    OID_INFO_CALL_BACK          *pCallBackInfo=NULL;
    BOOL                        fResult=FALSE;

    pCallBackInfo=(OID_INFO_CALL_BACK *)pvArg;
    if(NULL==pvArg || NULL==pInfo)
        goto InvalidArgErr;

    //increment the oid list
    (*(pCallBackInfo->pdwOIDCount))++;

    //get more memory for the pointer list
    *(pCallBackInfo->pprgOIDInfo)=(ENROLL_OID_INFO *)WizardRealloc(*(pCallBackInfo->pprgOIDInfo),
                                      (*(pCallBackInfo->pdwOIDCount)) * sizeof(ENROLL_OID_INFO));

    if(NULL==*(pCallBackInfo->pprgOIDInfo))
        goto MemoryErr;

    //memset
    memset(&((*(pCallBackInfo->pprgOIDInfo))[*(pCallBackInfo->pdwOIDCount)-1]), 0, sizeof(ENROLL_OID_INFO));

    (*(pCallBackInfo->pprgOIDInfo))[*(pCallBackInfo->pdwOIDCount)-1].pszOID=WizardAllocAndCopyStr((LPSTR)(pInfo->pszOID));
    (*(pCallBackInfo->pprgOIDInfo))[*(pCallBackInfo->pdwOIDCount)-1].pwszName=WizardAllocAndCopyWStr((LPWSTR)(pInfo->pwszName));
    (*(pCallBackInfo->pprgOIDInfo))[*(pCallBackInfo->pdwOIDCount)-1].fSelected=FALSE;

    if(NULL==(*(pCallBackInfo->pprgOIDInfo))[*(pCallBackInfo->pdwOIDCount)-1].pszOID ||
       NULL==(*(pCallBackInfo->pprgOIDInfo))[*(pCallBackInfo->pdwOIDCount)-1].pwszName)
       goto MemoryErr;

    fResult=TRUE;

CommonReturn:

    return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
}


//----------------------------------------------------------------------------
//
//  Get the list of supported OIDs and mark the one that caller has requested
//
//
//----------------------------------------------------------------------------
BOOL    InitCertCAOID(PCCRYPTUI_WIZ_CERT_REQUEST_INFO   pCertRequestInfo,
                      DWORD                             *pdwOIDInfo,
                      ENROLL_OID_INFO                   **pprgOIDInfo)
{
    BOOL    fResult=FALSE;
    DWORD   dwIndex=0;
    OID_INFO_CALL_BACK  OidInfoCallBack;
    DWORD   dwOIDRequested=0;
    BOOL    fFound=FALSE;
    LPWSTR  pwszName=NULL;


    if(!pCertRequestInfo || !pdwOIDInfo || !pprgOIDInfo)
        goto InvalidArgErr;

    //init
    *pdwOIDInfo=0;
    *pprgOIDInfo=NULL;

    OidInfoCallBack.pdwOIDCount=pdwOIDInfo;
    OidInfoCallBack.pprgOIDInfo=pprgOIDInfo;

    //no need for renew
   /*if(0==(CRYPTUI_WIZ_CERT_ENROLL & (pCertRequestInfo->dwPurpose)))
    {
        fResult=TRUE;
        goto CommonReturn;
    } */

    //no need for the request for cert types
    if(CRYPTUI_WIZ_CERT_REQUEST_CERT_TYPE == pCertRequestInfo->dwCertChoice)
    {
        fResult=TRUE;
        goto CommonReturn;
    }

    //enum all the enhanced key usages
    if(!CryptEnumOIDInfo(
               CRYPT_ENHKEY_USAGE_OID_GROUP_ID,
                0,
                &OidInfoCallBack,
                EnumOidCallback))
        goto TraceErr;

    //mark those requested by the user as selected
    if(CRYPTUI_WIZ_CERT_REQUEST_KEY_USAGE == pCertRequestInfo->dwCertChoice)
    {
       for(dwOIDRequested=0; dwOIDRequested<pCertRequestInfo->pKeyUsage->cUsageIdentifier; dwOIDRequested++)
       {
           fFound=FALSE;

           for(dwIndex=0; dwIndex<*pdwOIDInfo; dwIndex++)
           {
                if(0==strcmp(pCertRequestInfo->pKeyUsage->rgpszUsageIdentifier[dwOIDRequested],
                             (*pprgOIDInfo)[dwIndex].pszOID))
                {
                    fFound=TRUE;
                    (*pprgOIDInfo)[dwIndex].fSelected=TRUE;
                    break;
                }
           }

           //add the requested oid to the list if not in the numerated enhanced key usage
           if(FALSE==fFound)
           {
                (*pdwOIDInfo)++;

                //get more memory for the pointer list
                *pprgOIDInfo=(ENROLL_OID_INFO *)WizardRealloc(*pprgOIDInfo,
                                                  (*pdwOIDInfo) * sizeof(ENROLL_OID_INFO));

                if(NULL==(*pprgOIDInfo))
                    goto MemoryErr;

                //memset
                memset(&((*pprgOIDInfo)[*pdwOIDInfo-1]), 0, sizeof(ENROLL_OID_INFO));

                (*pprgOIDInfo)[(*pdwOIDInfo)-1].pszOID=
                        WizardAllocAndCopyStr(pCertRequestInfo->pKeyUsage->rgpszUsageIdentifier[dwOIDRequested]);
		if (NULL == (*pprgOIDInfo)[(*pdwOIDInfo)-1].pszOID)
		    goto MemoryErr; 

                pwszName=MkWStr((*pprgOIDInfo)[(*pdwOIDInfo)-1].pszOID);

                if(NULL==pwszName)
                    goto MemoryErr;

                (*pprgOIDInfo)[(*pdwOIDInfo)-1].pwszName=WizardAllocAndCopyWStr(pwszName);
                (*pprgOIDInfo)[(*pdwOIDInfo)-1].fSelected=TRUE;

                if(NULL==(*pprgOIDInfo)[(*pdwOIDInfo)-1].pszOID ||
                   NULL==(*pprgOIDInfo)[(*pdwOIDInfo)-1].pwszName)
                   goto MemoryErr;

           }

           if(pwszName)
           {
                FreeWStr(pwszName);
                pwszName=NULL;
           }
       }

    }

    fResult=TRUE;

CommonReturn:

    //free the memory
    if(pwszName)
        FreeWStr(pwszName);

    return fResult;

ErrorReturn:

    if(pCertRequestInfo && pdwOIDInfo && pprgOIDInfo)
    {
        FreeCertCAOID(*pdwOIDInfo,
                    *pprgOIDInfo);

        *pdwOIDInfo=0;
        *pprgOIDInfo=NULL;
    }

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
TRACE_ERROR(TraceErr);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
}


//----------------------------------------------------------------------------
//
//  Free the array of enroll OID info
//
//
//----------------------------------------------------------------------------
BOOL    FreeCertCAOID(DWORD             dwOIDInfo,
                      ENROLL_OID_INFO   *pOIDInfo)
{
    DWORD   dwIndex=0;

    if(pOIDInfo)
    {
        for(dwIndex=0; dwIndex < dwOIDInfo; dwIndex++)
        {
            if(pOIDInfo[dwIndex].pszOID)
                WizardFree(pOIDInfo[dwIndex].pszOID);

            if(pOIDInfo[dwIndex].pwszName)
                WizardFree(pOIDInfo[dwIndex].pwszName);
        }

        WizardFree(pOIDInfo);
    }

    return TRUE;

}

//----------------------------------------------------------------------------
//
//  Init a CERT_CA struct
//
//
//----------------------------------------------------------------------------
BOOL    InitCertCA(CERT_WIZARD_INFO         *pCertWizardInfo,
                   PCRYPTUI_WIZ_CERT_CA     pCertCA,
                   LPWSTR                   pwszCALocation,
                   LPWSTR                   pwszCAName,
                   BOOL                     fCASelected,
                   PCCRYPTUI_WIZ_CERT_REQUEST_INFO  pCertRequestInfo,
                   DWORD                    dwOIDInfo,
                   ENROLL_OID_INFO          *pOIDInfo,
                   BOOL                     fSearchForCertType)
{
    BOOL                fResult=FALSE;
    LPWSTR              *ppwszDisplayCertType=NULL;
    LPWSTR              *ppwszCertType=NULL;
    DWORD               *pdwKeySpec=NULL;
    DWORD               *pdwMinKeySize=NULL;
    DWORD               *pdwCSPCount=NULL;
    DWORD               **ppdwCSPList=NULL;
    DWORD               *pdwRASignature=NULL;
    DWORD               *pdwEnrollmentFlags;
    DWORD               *pdwSubjectNameFlags;
    DWORD               *pdwPrivateKeyFlags;
    DWORD               *pdwGeneralFlags; 
    DWORD               dwCertType=0;
    PCERT_EXTENSIONS    *ppCertExtensions=NULL;
    DWORD               dwIndex=0;
    DWORD               dwCertTypeRequested=0;
    BOOL                fFound=FALSE;
    LPWSTR              pwszCertTypeName=NULL;
    DWORD               dwFoundCertType=0;

    if (!pCertCA || !pCertRequestInfo)
        goto InvalidArgErr;

    //memset
    memset(pCertCA, 0, sizeof(CRYPTUI_WIZ_CERT_CA));

    pCertCA->dwSize=sizeof(CRYPTUI_WIZ_CERT_CA);
    pCertCA->pwszCALocation=pwszCALocation;
    pCertCA->pwszCAName=pwszCAName;
    pCertCA->fSelected=fCASelected;

    //set up the OID information if requested
    switch (pCertRequestInfo->dwCertChoice)
    {
        case CRYPTUI_WIZ_CERT_REQUEST_KEY_USAGE:

                if(dwOIDInfo==0 || NULL==pOIDInfo)
                    goto InvalidArgErr;

                pCertCA->dwOIDInfo=dwOIDInfo;
                pCertCA->rgOIDInfo=pOIDInfo;

            break;

        case CRYPTUI_WIZ_CERT_REQUEST_CERT_TYPE:
                //if we are required to search the CertType. get all the certTypes
                //from the CA.  Otherwize, just use the CertType provided
                if(fSearchForCertType && pwszCALocation && pwszCAName)
                {

                    //get the list of cert type names and extensions supported by the CA
                    if(!CAUtilGetCertTypeNameAndExtensions(
                                                pCertWizardInfo,
                                                pCertRequestInfo,
                                                pwszCALocation,
                                                pwszCAName,
                                                &dwCertType,
                                                &ppwszCertType,
                                                &ppwszDisplayCertType,
                                                &ppCertExtensions,
                                                &pdwKeySpec,
                                                &pdwMinKeySize,
                                                &pdwCSPCount,
                                                &ppdwCSPList,
						&pdwRASignature,
						&pdwEnrollmentFlags,
						&pdwSubjectNameFlags,
						&pdwPrivateKeyFlags,
						&pdwGeneralFlags))
                        goto TraceErr;

                    //add the certType name and extenisions to the struct
                    for(dwIndex=0; dwIndex < dwCertType; dwIndex++)
                    {
                        fFound=FALSE;


                        //search for the certTypes that requested by the user
                        //we are guaranteed that the certificat type user requested
                        //is supported by the CA
                        for(dwCertTypeRequested=0; dwCertTypeRequested < pCertRequestInfo->pCertType->cCertType;
                            dwCertTypeRequested++)
                        {

                            fFound  = 0 == wcscmp(ppwszCertType[dwIndex], pCertRequestInfo->pCertType->rgwszCertType[dwCertTypeRequested]); 
                            fFound |= ContainsCertTemplateOid(ppCertExtensions[dwIndex], pCertRequestInfo->pCertType->rgwszCertType[dwCertTypeRequested]);

                            if (fFound)
                            {
                                dwFoundCertType++;
                                break;
                            }

                        }

                        if(!AddCertTypeToCertCA(&(pCertCA->dwCertTypeInfo),
						&(pCertCA->rgCertTypeInfo),
						ppwszCertType[dwIndex],
						ppwszDisplayCertType[dwIndex],
						ppCertExtensions[dwIndex],
						fFound,
						pdwKeySpec[dwIndex],
						pdwMinKeySize[dwIndex],
						pdwCSPCount[dwIndex],
						ppdwCSPList[dwIndex],
						pdwRASignature[dwIndex], 
						pdwEnrollmentFlags[dwIndex],
						pdwSubjectNameFlags[dwIndex],
						pdwPrivateKeyFlags[dwIndex],
						pdwGeneralFlags[dwIndex]
						))
                            goto TraceErr;
                    }

                    //make sure all the requested cert types are supported
                    //Only do so if the CA information is input through
                    //the API
                   // if(dwFoundCertType < pCertRequestInfo->pCertType->cCertType)
                   //     goto InvalidArgErr;
                }
                else
                {
                    for(dwCertTypeRequested=0; dwCertTypeRequested < pCertRequestInfo->pCertType->cCertType;
                        dwCertTypeRequested++)
                    {

                        //get the cert type name
                        pwszCertTypeName=WizardAllocAndCopyWStr(pCertRequestInfo->pCertType->rgwszCertType[dwCertTypeRequested]);

                        if(!pwszCertTypeName)
                            goto MemoryErr;

                        if(!AddCertTypeToCertCA(&(pCertCA->dwCertTypeInfo),
						&(pCertCA->rgCertTypeInfo),
						NULL,
						pwszCertTypeName,
						NULL,
						TRUE,
						0,
						0,
						0,
						NULL,
						0, 
						0, 
						0, 
						0, 
						0
						))   //select it
                            goto TraceErr;

                        //no need to free pwszCertTyptName.  It is included
                        //in pCertCA->rgCertTypeInfo
                   }
                }
            break;

        //dwCertChoice is optional
        case 0:
                //if we are required to search the CertType. get all the certTypes
                //from the CA.  Otherwize, use the OID
                if(fSearchForCertType && pwszCALocation && pwszCAName)
                {
                    //get the list of cert type names and extensions supported by the CA
                    if(!CAUtilGetCertTypeNameAndExtensions(
                                                pCertWizardInfo,
                                                pCertRequestInfo,
                                                pwszCALocation,
                                                pwszCAName,
                                                &dwCertType,
                                                &ppwszCertType,
                                                &ppwszDisplayCertType,
                                                &ppCertExtensions,
                                                &pdwKeySpec,
                                                &pdwMinKeySize,
                                                &pdwCSPCount,
                                                &ppdwCSPList,
						&pdwRASignature,
						&pdwEnrollmentFlags,
						&pdwSubjectNameFlags,
						&pdwPrivateKeyFlags,
						&pdwGeneralFlags))
                        goto TraceErr;

                    //add the certType name and extenisions to the struct
                    for(dwIndex=0; dwIndex < dwCertType; dwIndex++)
		    {
			if(!AddCertTypeToCertCA(&(pCertCA->dwCertTypeInfo),
						&(pCertCA->rgCertTypeInfo),
						ppwszCertType[dwIndex],
						ppwszDisplayCertType[dwIndex],
						ppCertExtensions[dwIndex],
						FALSE,
						pdwKeySpec[dwIndex],
						pdwMinKeySize[dwIndex],
						pdwCSPCount[dwIndex],
						ppdwCSPList[dwIndex],
						pdwRASignature[dwIndex],
						pdwEnrollmentFlags[dwIndex],
						pdwSubjectNameFlags[dwIndex],
						pdwPrivateKeyFlags[dwIndex],
						pdwGeneralFlags[dwIndex]
						))
			    goto TraceErr;
		    }
                }
                else
                {
                    if(dwOIDInfo==0 || NULL==pOIDInfo)
                        goto InvalidArgErr;

                    pCertCA->dwOIDInfo=dwOIDInfo;
                    pCertCA->rgOIDInfo=pOIDInfo;

                }

            break;

        default:
            goto InvalidArgErr;

    }

    fResult=TRUE;

CommonReturn:

    //free the memory
    if(ppwszCertType)
        WizardFree(ppwszCertType);

    if(ppwszDisplayCertType)
        WizardFree(ppwszDisplayCertType);

    if(ppCertExtensions)
        WizardFree(ppCertExtensions);

    if(pdwKeySpec)
        WizardFree(pdwKeySpec);

    if(pdwMinKeySize)
        WizardFree(pdwMinKeySize);

    if(pdwCSPCount)
        WizardFree(pdwCSPCount);

    if(ppdwCSPList)
        WizardFree(ppdwCSPList);

    return fResult;

ErrorReturn:

    //free the individual elements
    if(ppdwCSPList)
    {
        for(dwIndex=0; dwIndex < dwCertType; dwIndex++)
        {
            if(ppdwCSPList[dwIndex])
                WizardFree(ppdwCSPList[dwIndex]);
        }
    }

    if(ppwszCertType)
    {
        for(dwIndex=0; dwIndex <dwCertType; dwIndex++)
        {
            if(ppwszCertType[dwIndex])
                WizardFree(ppwszCertType[dwIndex]);
        }
    }
    
    if(ppwszDisplayCertType)
    {
        for(dwIndex=0; dwIndex <dwCertType; dwIndex++)
        {
            if(ppwszDisplayCertType[dwIndex])
                WizardFree(ppwszDisplayCertType[dwIndex]);
        }
    }

    if(ppCertExtensions)
    {
        for(dwIndex=0; dwIndex <dwCertType; dwIndex++)
        {
            if(ppCertExtensions[dwIndex])
                CAFreeCertTypeExtensions(NULL, ppCertExtensions[dwIndex]);
        }
    }

    if(pCertCA)
    {
        if(pCertCA->rgCertTypeInfo)
            WizardFree(pCertCA->rgCertTypeInfo);

        memset(pCertCA, 0, sizeof(CRYPTUI_WIZ_CERT_CA));
    }

    if(pwszCertTypeName)
        WizardFree(pwszCertTypeName);

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
TRACE_ERROR(TraceErr);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
}

//----------------------------------------------------------------------------
//
//  Free an array of ENROLL_CERT_TYPE_INFO struct
//
//
//----------------------------------------------------------------------------
BOOL    FreeCertCACertType(DWORD                    dwCertTypeInfo,
                           ENROLL_CERT_TYPE_INFO    *rgCertTypeInfo)
{
    DWORD   dwIndex=0;

    if(rgCertTypeInfo)
    {
        for(dwIndex=0; dwIndex <dwCertTypeInfo; dwIndex++)
        {
            if(rgCertTypeInfo[dwIndex].pwszDNName)
                WizardFree(rgCertTypeInfo[dwIndex].pwszDNName);

            if(rgCertTypeInfo[dwIndex].pwszCertTypeName)
                WizardFree(rgCertTypeInfo[dwIndex].pwszCertTypeName);

            if(rgCertTypeInfo[dwIndex].pCertTypeExtensions)
                CAFreeCertTypeExtensions(NULL, rgCertTypeInfo[dwIndex].pCertTypeExtensions);

            if(rgCertTypeInfo[dwIndex].rgdwCSP)
                WizardFree(rgCertTypeInfo[dwIndex].rgdwCSP);
        }

        WizardFree(rgCertTypeInfo);

    }

    return TRUE;
}


//----------------------------------------------------------------------------
//
// Add a certType to the ENROLL_CERT_TYPE_INFO struct
//
//
//----------------------------------------------------------------------------
BOOL    AddCertTypeToCertCA(DWORD                   *pdwCertTypeInfo,
                            ENROLL_CERT_TYPE_INFO   **ppCertTypeInfo,
                            LPWSTR                  pwszDNName,
                            LPWSTR                  pwszCertType,
                            PCERT_EXTENSIONS        pCertExtensions,
                            BOOL                    fSelected,
                            DWORD                   dwKeySpec,
                            DWORD                   dwMinKeySize,
                            DWORD                   dwCSPCount,
                            DWORD                   *pdwCSPList,
			    DWORD                   dwRASignature,
			    DWORD                   dwEnrollmentFlags,
			    DWORD                   dwSubjectNameFlags,
			    DWORD                   dwPrivateKeyFlags,
			    DWORD                   dwGeneralFlags
			    )
{
    BOOL    fResult=FALSE;

    if(!pdwCertTypeInfo || !ppCertTypeInfo)
        goto InvalidArgErr;

    *ppCertTypeInfo=(ENROLL_CERT_TYPE_INFO   *)WizardRealloc(*ppCertTypeInfo,
                    (*pdwCertTypeInfo+1) * sizeof(ENROLL_CERT_TYPE_INFO));

    if(NULL==*ppCertTypeInfo)
        goto MemoryErr;

    (*pdwCertTypeInfo)++;


    ((*ppCertTypeInfo)[*pdwCertTypeInfo-1]).fSelected=fSelected;
    ((*ppCertTypeInfo)[*pdwCertTypeInfo-1]).pwszDNName=pwszDNName;
    ((*ppCertTypeInfo)[*pdwCertTypeInfo-1]).pwszCertTypeName=pwszCertType;
    ((*ppCertTypeInfo)[*pdwCertTypeInfo-1]).pCertTypeExtensions=pCertExtensions;
    ((*ppCertTypeInfo)[*pdwCertTypeInfo-1]).dwKeySpec=dwKeySpec;
    ((*ppCertTypeInfo)[*pdwCertTypeInfo-1]).dwMinKeySize=dwMinKeySize; 
    ((*ppCertTypeInfo)[*pdwCertTypeInfo-1]).dwCSPCount=dwCSPCount;
    ((*ppCertTypeInfo)[*pdwCertTypeInfo-1]).rgdwCSP=pdwCSPList;
    ((*ppCertTypeInfo)[*pdwCertTypeInfo-1]).dwRASignature=dwRASignature;
    ((*ppCertTypeInfo)[*pdwCertTypeInfo-1]).dwEnrollmentFlags=dwEnrollmentFlags;
    ((*ppCertTypeInfo)[*pdwCertTypeInfo-1]).dwSubjectNameFlags=dwSubjectNameFlags;
    ((*ppCertTypeInfo)[*pdwCertTypeInfo-1]).dwPrivateKeyFlags=dwPrivateKeyFlags;
    ((*ppCertTypeInfo)[*pdwCertTypeInfo-1]).dwGeneralFlags=dwGeneralFlags; 

    fResult=TRUE;

CommonReturn:

    return fResult;

ErrorReturn:


	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
}

BOOL
WINAPI
CreateCertRequestNoSearchCANoDS
(
 IN  CERT_WIZARD_INFO  *pCertWizardInfo,
 IN  DWORD             /*dwFlags*/,
 IN  HCERTTYPE         hCertType, 
 OUT HANDLE            *pResult
 )
{
    BOOL                            fResult      = FALSE;
    CRYPTUI_WIZ_CERT_CA_INFO        CertCAInfo;
    CRYPTUI_WIZ_CERT_CA             rgCertCA[2];
    HRESULT                         hr; 

    // Declare cert type properties / flags / extensions: 
    LPWSTR             pwszCertType;
    LPWSTR             pwszDisplayCertType; 
    PCERT_EXTENSIONS   pCertExtensions;
    DWORD              dwKeySpec;
    DWORD              dwMinKeySize;
    DWORD              dwCSPCount;
    DWORD             *pdwCSPList;
    DWORD              dwRASignature;
    DWORD              dwEnrollmentFlags;
    DWORD              dwSubjectNameFlags;
    DWORD              dwPrivateKeyFlags;
    DWORD              dwGeneralFlags;
    CertRequester        *pCertRequester        = NULL; 
    CertRequesterContext *pCertRequesterContext = NULL; 

    // Invalid validation
    if (NULL == pCertWizardInfo || NULL == pCertWizardInfo->hRequester || NULL == hCertType || NULL == pResult)
	return FALSE; 
    
    // Init: 
    *pResult = NULL; 

    //memset
    memset(&CertCAInfo, 0, sizeof(CertCAInfo));
    memset(rgCertCA,    0, sizeof(rgCertCA));

    //set up the CA info
    CertCAInfo.dwSize = sizeof(CertCAInfo);
    CertCAInfo.dwCA   = 2;  // 1 dummy CA + 1 real CA
    CertCAInfo.rgCA   = rgCertCA;

    CertCAInfo.rgCA[1].dwSize         = sizeof(CertCAInfo.rgCA[1]);     
    CertCAInfo.rgCA[1].pwszCAName     = pCertWizardInfo->pwszCAName;
    CertCAInfo.rgCA[1].pwszCALocation = pCertWizardInfo->pwszCALocation;
    CertCAInfo.rgCA[1].fSelected      = TRUE; 
    pCertWizardInfo->dwCAIndex        = 1;  // We're using the first CA.

    // NOTE:  No need to set up the OID info:  we're requesting based on cert type. 

    //get the list of cert type names and extensions supported by the CA
    if(!CAUtilGetCertTypeNameAndExtensionsNoDS
       (pCertWizardInfo,
	NULL, 
	hCertType, 
	&pwszCertType,
	&pwszDisplayCertType,
	&pCertExtensions,
	&dwKeySpec,
	&dwMinKeySize,
	&dwCSPCount,
	&pdwCSPList,
	&dwRASignature,
	&dwEnrollmentFlags,
	&dwSubjectNameFlags,
	&dwPrivateKeyFlags,
	&dwGeneralFlags))
    {
	if (GetLastError() == ERROR_SUCCESS)
	{
	    // No code error occured, we just can't use this cert template.  
	    // Since this code path relies on being able to use this particular
	    // cert template, bubble this up as an invalid arg err. 
	    goto InvalidArgErr; 
	}
	else
	{
	    // An error occured. 
	    goto CAUtilGetCertTypeNameAndExtensionsNoDSErr; 
	}
    }

    
    if(!AddCertTypeToCertCA(&(CertCAInfo.rgCA[1].dwCertTypeInfo),
			    &(CertCAInfo.rgCA[1].rgCertTypeInfo),
			    pwszCertType,
			    pwszDisplayCertType,
			    pCertExtensions,
			    TRUE, 
			    dwKeySpec,
			    dwMinKeySize,
			    dwCSPCount,
			    pdwCSPList,
			    dwRASignature, 
			    dwEnrollmentFlags,
			    dwSubjectNameFlags,
			    dwPrivateKeyFlags,
			    dwGeneralFlags))
	goto AddCertTypeToCertCAErr;


    // We're only _creating_ a request, not submitting it. 
    pCertWizardInfo->dwFlags     |= CRYPTUI_WIZ_CREATE_ONLY; 
    pCertWizardInfo->pCertCAInfo  = &CertCAInfo;
 
    if (NULL == (pCertRequester = (CertRequester *)pCertWizardInfo->hRequester))
        goto UnexpectedErr; 
    if (NULL == (pCertRequesterContext = pCertRequester->GetContext()))
        goto UnexpectedErr;

    if (S_OK != (hr = pCertRequesterContext->Enroll(NULL, pResult)))
	goto EnrollErr; 

    // Bundle state we need to carry across the create/submit boundary: 
    {
	PCREATE_REQUEST_WIZARD_STATE pState = (PCREATE_REQUEST_WIZARD_STATE)WizardAlloc(sizeof(CREATE_REQUEST_WIZARD_STATE)); 
	if (NULL == pState)
	    goto MemoryErr; 

	pState->hRequest        = *pResult; 
	pState->dwPurpose       = pCertWizardInfo->dwPurpose; 

	*pResult = (HANDLE)pState; 
    }

    fResult=TRUE;

 CommonReturn:
    FreeCertCACertType(CertCAInfo.rgCA[0].dwCertTypeInfo, CertCAInfo.rgCA[0].rgCertTypeInfo);
    return fResult;

ErrorReturn:
    fResult=FALSE;
    goto CommonReturn;

TRACE_ERROR(AddCertTypeToCertCAErr); 
TRACE_ERROR(CAUtilGetCertTypeNameAndExtensionsNoDSErr); 
SET_ERROR(EnrollErr,     hr); 
SET_ERROR(InvalidArgErr, E_INVALIDARG); 
SET_ERROR(MemoryErr,     E_OUTOFMEMORY); 
SET_ERROR(UnexpectedErr, E_UNEXPECTED); 
}

BOOL
WINAPI
SubmitCertRequestNoSearchCANoDS
(IN            HANDLE            hRequest,
 IN            LPCWSTR           pwszCAName,
 IN            LPCWSTR           pwszCALocation, 
 OUT           DWORD            *pdwStatus, 
 OUT OPTIONAL  PCCERT_CONTEXT   *ppCertContext 
)
{
    BOOL                           fResult                = FALSE;
    CertRequester                 *pCertRequester         = NULL; 
    CertRequesterContext          *pCertRequesterContext  = NULL; 
    CERT_WIZARD_INFO               CertWizardInfo; 
    DWORD                          dwPurpose; 
    HANDLE                         hCertRequest           = NULL; 
    HRESULT                        hr; 
    PCREATE_REQUEST_WIZARD_STATE   pState                 = NULL; 
    UINT                           idsText;  // Not used

    // Invalid validation  
    if (NULL == hRequest  || NULL == pwszCAName || NULL == pwszCALocation || NULL == pdwStatus)
	return FALSE; 
    
    memset(&CertWizardInfo,  0,  sizeof(CertWizardInfo)); 
    // Specify this set of flags to indicate that cryptui doesn't need to prepare 
    // access check information.  Doing so could cause lots of extraneous logoff/logon events. 
    CertWizardInfo.dwFlags = CRYPTUI_WIZ_ALLOW_ALL_TEMPLATES | CRYPTUI_WIZ_ALLOW_ALL_CAS; 

    pState        = (PCREATE_REQUEST_WIZARD_STATE)hRequest; 
    hCertRequest  = pState->hRequest;  
    dwPurpose     = pState->dwPurpose; 

    if (S_OK != (CertRequester::MakeCertRequester
		 (NULL, 
		  pState->pwszMachineName, 
                  pState->dwStoreFlags, 
                  dwPurpose, 
		  &CertWizardInfo, 
		  &pCertRequester, 
		  &idsText 
                  )))
	goto InvalidArgErr; 

    pCertRequesterContext             = pCertRequester->GetContext(); 

    // Set up the wizard information necessary for a submit operation: 
    CertWizardInfo.dwFlags         &= ~(CRYPTUI_WIZ_CREATE_ONLY | CRYPTUI_WIZ_FREE_ONLY); 
    CertWizardInfo.dwFlags         |= CRYPTUI_WIZ_SUBMIT_ONLY; 
    CertWizardInfo.dwPurpose        = dwPurpose; 
    CertWizardInfo.pwszCAName       = (LPWSTR)pwszCAName;
    CertWizardInfo.pwszCALocation   = (LPWSTR)pwszCALocation; 
    CertWizardInfo.fCAInput         = TRUE; 

    if (S_OK != (hr = pCertRequesterContext->Enroll(pdwStatus, &hCertRequest)))
        goto EnrollErr; 

    if (NULL != ppCertContext)
        *ppCertContext = (PCCERT_CONTEXT)hCertRequest; 

    // Success
    fResult = TRUE;
 CommonReturn:
    if (NULL != pCertRequester) { delete pCertRequester; } 
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(EnrollErr,      hr);     
SET_ERROR(InvalidArgErr,  ERROR_INVALID_PARAMETER);
}

void 
WINAPI
FreeCertRequestNoSearchCANoDS
(IN HANDLE hRequest)
{
    CERT_WIZARD_INFO               CertWizardInfo; 
    CertRequester                 *pCertRequester         = NULL; 
    CertRequesterContext          *pCertRequesterContext  = NULL; 
    DWORD                          dwPurpose; 
    HANDLE                         hCertRequest; 
    HRESULT                        hr; 
    PCREATE_REQUEST_WIZARD_STATE   pState; 
    UINT                           idsText; 

    if (NULL == hRequest) 
        return; 

    memset(&CertWizardInfo,  0,  sizeof(CertWizardInfo)); 
    // Specify this set of flags to indicate that cryptui doesn't need to prepare 
    // access check information.  Doing so could cause lots of extraneous logoff/logon events. 
    CertWizardInfo.dwFlags = CRYPTUI_WIZ_ALLOW_ALL_TEMPLATES | CRYPTUI_WIZ_ALLOW_ALL_CAS; 

    pState        = (PCREATE_REQUEST_WIZARD_STATE)hRequest; 
    hCertRequest  = pState->hRequest;  
    dwPurpose     = pState->dwPurpose; 

    if (S_OK != (CertRequester::MakeCertRequester
		 (NULL, 
		  pState->pwszMachineName, 
		  pState->dwStoreFlags, 
                  dwPurpose, 
		  &CertWizardInfo, 
		  &pCertRequester, 
		  &idsText 
                  )))
	goto InvalidArgErr; 

    pCertRequesterContext      = pCertRequester->GetContext(); 
    CertWizardInfo.dwFlags    &= ~(CRYPTUI_WIZ_CREATE_ONLY | CRYPTUI_WIZ_SUBMIT_ONLY); 
    CertWizardInfo.dwFlags    |= CRYPTUI_WIZ_FREE_ONLY; 
    CertWizardInfo.dwPurpose   = dwPurpose; 

    if (S_OK != (hr = pCertRequesterContext->Enroll(NULL, &hCertRequest)))
        goto EnrollErr; 

    if (NULL != pState->pwszMachineName) { WizardFree(pState->pwszMachineName); } 
    WizardFree(pState); 

 ErrorReturn:
    return;

TRACE_ERROR(EnrollErr);
TRACE_ERROR(InvalidArgErr); 
}

//----------------------------------------------------------------------------
//
//  This is the layer of CertRequest wizard builds up the CA information
//  without searching for it on the network.
//
//  It pass the information throught to the  CryptUIWizCertRequestWithCAInfo API
//----------------------------------------------------------------------------
BOOL
WINAPI
CertRequestNoSearchCA(
            BOOL                            fSearchCertType,
            CERT_WIZARD_INFO                *pCertWizardInfo,
            DWORD                           dwFlags,
            HWND                            hwndParent,
            LPCWSTR                         pwszWizardTitle,
            PCCRYPTUI_WIZ_CERT_REQUEST_INFO pCertRequestInfo,
            PCCERT_CONTEXT                  *ppCertContext,
            DWORD                           *pCAdwStatus,
            UINT                            *pIds
)
{
    BOOL                            fResult=FALSE;
    DWORD                           dwError=0;
    DWORD                           dwIndex=0;

    DWORD                           dwOIDInfo=0;
    ENROLL_OID_INFO                 *pOIDInfo=NULL;

    CRYPTUI_WIZ_CERT_CA_INFO        CertCAInfo;
    CRYPTUI_WIZ_CERT_CA             rgCertCA[2];

    //memset
    memset(&CertCAInfo, 0, sizeof(CRYPTUI_WIZ_CERT_CA_INFO));
    memset(rgCertCA,    0,  2*sizeof(CRYPTUI_WIZ_CERT_CA));

    //set up the CA info
    CertCAInfo.dwSize=sizeof(CertCAInfo);
    CertCAInfo.dwCA=2;
    CertCAInfo.rgCA=rgCertCA;


    //user has to supply the CA information
    if((NULL==pCertRequestInfo->pwszCAName) ||
        (NULL==pCertRequestInfo->pwszCALocation)
      )
    {
        *pIds=IDS_HAS_TO_PROVIDE_CA;
        goto InvalidArgErr;
    }


    //set up the OID info
   if(!InitCertCAOID(pCertRequestInfo,
                     &dwOIDInfo,
                     &pOIDInfo))
        goto TraceErr;


    //set up the CA array
    //the 1st one is the default one without CA information
    if(!InitCertCA(pCertWizardInfo, &rgCertCA[0], NULL, NULL, FALSE, pCertRequestInfo,
                    dwOIDInfo, pOIDInfo, fSearchCertType))
    {
        *pIds=IDS_ENROLL_NO_CERT_TYPE;
        goto TraceErr;
    }

   //the second one indicate the information for the real CA
    CertCAInfo.dwCA=2;

    if(!InitCertCA(pCertWizardInfo, &rgCertCA[1], (LPWSTR)(pCertRequestInfo->pwszCALocation),
        (LPWSTR)(pCertRequestInfo->pwszCAName), TRUE, pCertRequestInfo,
                dwOIDInfo, pOIDInfo, fSearchCertType))
    {
        *pIds=IDS_ENROLL_NO_CERT_TYPE;
        goto TraceErr;
    }


    fResult=CryptUIWizCertRequestWithCAInfo(
             pCertWizardInfo,
             dwFlags,
             hwndParent,
             pwszWizardTitle,
             pCertRequestInfo,
             &CertCAInfo,
             ppCertContext,
             pCAdwStatus,
             pIds);

    if(FALSE==fResult)
        goto TraceErr;


    fResult=TRUE;

CommonReturn:
    //preserve the last error
    dwError=GetLastError();

    //free memory
    for(dwIndex=0; dwIndex< CertCAInfo.dwCA; dwIndex++)
        FreeCertCACertType(CertCAInfo.rgCA[dwIndex].dwCertTypeInfo,
                            CertCAInfo.rgCA[dwIndex].rgCertTypeInfo);

    FreeCertCAOID(dwOIDInfo, pOIDInfo);

    //reset the error
    SetLastError(dwError);

    return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
TRACE_ERROR(TraceErr);
}



//----------------------------------------------------------------------------
//
//  This is the layer of CertRequest wizard builds up the CA information
//  by searching for it on the network.
//
//  It pass the information throught to the  CryptUIWizCertRequestWithCAInfo API
//----------------------------------------------------------------------------
BOOL
WINAPI
CertRequestSearchCA(
            CERT_WIZARD_INFO                *pCertWizardInfo,
            DWORD                           dwFlags,
            HWND                            hwndParent,
            LPCWSTR                         pwszWizardTitle,
            PCCRYPTUI_WIZ_CERT_REQUEST_INFO pCertRequestInfo,
            PCCERT_CONTEXT                  *ppCertContext,
            DWORD                           *pCAdwStatus,
            UINT                            *pIds
)
{
    BOOL                            fResult=FALSE;
    DWORD                           dwError=0;
    DWORD                           dwIndex=0;
    DWORD                           dwCACount=0;
    BOOL                            fFound=FALSE;

    LPWSTR                          *ppwszCAName=0;
    LPWSTR                          *ppwszCALocation=0;

    CRYPTUI_WIZ_CERT_CA_INFO        CertCAInfo;
    CRYPTUI_WIZ_CERT_CA             *rgCertCA=NULL;

    DWORD                           dwOIDInfo=0;
    ENROLL_OID_INFO                 *pOIDInfo=NULL;

    CRYPTUI_WIZ_CERT_REQUEST_INFO   CertRequestInfo;
    DWORD                           dwValidCA=0;

    //memset
    memset(&CertCAInfo, 0, sizeof(CRYPTUI_WIZ_CERT_CA_INFO));
    memset(&CertRequestInfo, 0, sizeof(CRYPTUI_WIZ_CERT_REQUEST_INFO));

    //set up the CA info
    CertCAInfo.dwSize=sizeof(CertCAInfo);

    //see if CA information is provided
    if(pCertRequestInfo->pwszCALocation &&
       pCertRequestInfo->pwszCAName)
    {
        //no need to do anything if UILess
       if(dwFlags & CRYPTUI_WIZ_NO_UI)
       {
            if(!CertRequestNoSearchCA(    TRUE,             //search for certype
                                          pCertWizardInfo,
                                          dwFlags,
                                          hwndParent,
                                          pwszWizardTitle,
                                          pCertRequestInfo,
                                          ppCertContext,
                                          pCAdwStatus,
                                          pIds))
                goto TraceErr;
       }
       else
       {
           //UI version of the enrollment with known CA informatin
           //get a CA which can issue the required certificate type
           //or the OIDs.  The ca has to support some certificate type
           //unless user specifically asked for OID
            if(!CAUtilRetrieveCAFromCertType(
                        pCertWizardInfo,
                        pCertRequestInfo,
                        TRUE,              //need multiple CAs
                        0,                 //ask for the CN
                        &dwCACount,
                        &ppwszCALocation,
                        &ppwszCAName) )
            {
                *pIds=IDS_NO_CA_FOR_ENROLL;
                goto TraceErr;
            }

            //set up the OID info
           if(!InitCertCAOID(pCertRequestInfo,
                             &dwOIDInfo,
                             &pOIDInfo))
                goto TraceErr;

           //allocation the memory
           rgCertCA=(CRYPTUI_WIZ_CERT_CA *)WizardAlloc((dwCACount + 2) *
                    sizeof(CRYPTUI_WIZ_CERT_CA));

           if(NULL==rgCertCA)
               goto OutOfMemoryErr;

           //memset
           memset(rgCertCA, 0, (dwCACount + 2) * sizeof(CRYPTUI_WIZ_CERT_CA));

            //the 1st one is the default one without CA information
           if(!InitCertCA(pCertWizardInfo, &rgCertCA[0], NULL, NULL, FALSE, pCertRequestInfo,
                            dwOIDInfo, pOIDInfo, TRUE) )
            {
                *pIds=IDS_ENROLL_NO_CERT_TYPE;
                goto TraceErr;
            }

           dwValidCA=0;

           //the rest is the CA information
           for(dwIndex=0; dwIndex<dwCACount; dwIndex++)
           {

                if(0==_wcsicmp(ppwszCALocation[dwIndex], pCertRequestInfo->pwszCALocation) &&
                    0==_wcsicmp(ppwszCAName[dwIndex], pCertRequestInfo->pwszCAName)
                  )
                {
                    fFound=TRUE;

                    //mark CA as selected
                    if(!InitCertCA(pCertWizardInfo, &rgCertCA[dwValidCA+1], ppwszCALocation[dwIndex],
                                ppwszCAName[dwIndex],  TRUE,
                                pCertRequestInfo, dwOIDInfo, pOIDInfo, TRUE))
                        //we contine to the next CA
                        continue;

                    dwValidCA++;
                }
                else
                {
                    if(!InitCertCA(pCertWizardInfo, &rgCertCA[dwValidCA+1], ppwszCALocation[dwIndex],
                                ppwszCAName[dwIndex], FALSE,
                                pCertRequestInfo, dwOIDInfo, pOIDInfo, TRUE))
                        continue;

                    dwValidCA++;
                }
           }

           if(0==dwValidCA)
           {
                *pIds=IDS_ENROLL_NO_CERT_TYPE;
                goto TraceErr;
           }

           //we need the add the CA to the list
           if(!fFound)
           {
               //we require the CA has to be on DS
                *pIds=IDS_INVALID_CA_FOR_ENROLL;
                goto TraceErr;
           }

          // CertCAInfo.dwCA=(fFound) ? (dwCACount + 1) : (dwCACount+2);
           CertCAInfo.dwCA=dwValidCA + 1;
           CertCAInfo.rgCA=rgCertCA;

           fResult=CryptUIWizCertRequestWithCAInfo(
                                        pCertWizardInfo,
                                        dwFlags,
                                        hwndParent,
                                        pwszWizardTitle,
                                        pCertRequestInfo,
                                        &CertCAInfo,
                                        ppCertContext,
                                        pCAdwStatus,
                                        pIds);
           if(!fResult)
               goto TraceErr;
       }

    }
    //the CA Information is not provided
    else
    {
       //get a list of CAs which can issue the required certificate type
       //or the OIDs
        if(!CAUtilRetrieveCAFromCertType(
                    pCertWizardInfo,
                    pCertRequestInfo,
                    TRUE,              //need multiple CAs
                    0,                 //ask for the CN
                    &dwCACount,
                    &ppwszCALocation,
                    &ppwszCAName))
        {
            *pIds=IDS_NO_CA_FOR_ENROLL;
            goto TraceErr;
        }

        //init the OID
        //set up the OID info
       if(!InitCertCAOID(pCertRequestInfo,
                         &dwOIDInfo,
                         &pOIDInfo))
            goto TraceErr;

       //allocation the memory
       rgCertCA=(CRYPTUI_WIZ_CERT_CA *)WizardAlloc((dwCACount + 1) *
                sizeof(CRYPTUI_WIZ_CERT_CA));

       if(NULL==rgCertCA)
           goto OutOfMemoryErr;

       //memset
       memset(rgCertCA, 0, (dwCACount + 1) * sizeof(CRYPTUI_WIZ_CERT_CA));

        //the 1st one is the default one without CA information
       if(!InitCertCA(pCertWizardInfo, &rgCertCA[0], NULL, NULL, FALSE, pCertRequestInfo,
                        dwOIDInfo, pOIDInfo, TRUE))
        {
            *pIds=IDS_ENROLL_NO_CERT_TYPE;
            goto TraceErr;
        }

       dwValidCA=0;

       //the rest is the CA information
       for(dwIndex=0; dwIndex<dwCACount; dwIndex++)
       {
            //mark the 1st CA as selected
            if(!InitCertCA(pCertWizardInfo, &rgCertCA[dwValidCA+1], ppwszCALocation[dwIndex],
                        ppwszCAName[dwIndex], (dwValidCA == 0) ? TRUE : FALSE,
                        pCertRequestInfo, dwOIDInfo, pOIDInfo, TRUE) )
                continue;

            dwValidCA++;

       }

       if(0==dwValidCA)
       {
            *pIds=IDS_ENROLL_NO_CERT_TYPE;
            goto TraceErr;
       }


       CertCAInfo.dwCA=dwValidCA + 1;
       CertCAInfo.rgCA=rgCertCA;

       
       

       fResult=CryptUIWizCertRequestWithCAInfo(
                                    pCertWizardInfo,
                                    dwFlags,
                                    hwndParent,
                                    pwszWizardTitle,
                                    pCertRequestInfo,
                                    &CertCAInfo,
                                    ppCertContext,
                                    pCAdwStatus,
                                    pIds);

       if(!fResult)
               goto TraceErr;
    }

    fResult=TRUE;

CommonReturn:
    //preserve the last error
    dwError=GetLastError();

    //free memory

    //free the OID information
    FreeCertCAOID(dwOIDInfo, pOIDInfo);

    if(CertCAInfo.rgCA)
    {
        for(dwIndex=0; dwIndex<CertCAInfo.dwCA; dwIndex++)
        {
            FreeCertCACertType(CertCAInfo.rgCA[dwIndex].dwCertTypeInfo,
                               CertCAInfo.rgCA[dwIndex].rgCertTypeInfo);
        }

        WizardFree(CertCAInfo.rgCA);
    }


    if(ppwszCAName)
    {
        for(dwIndex=0; dwIndex < dwCACount; dwIndex++)
        {
            if(ppwszCAName[dwIndex])
                WizardFree(ppwszCAName[dwIndex]);
        }

        WizardFree(ppwszCAName);
    }

    if(ppwszCALocation)
    {
        for(dwIndex=0; dwIndex < dwCACount; dwIndex++)
        {
            if(ppwszCALocation[dwIndex])
                WizardFree(ppwszCALocation[dwIndex]);
        }

        WizardFree(ppwszCALocation);
    }
    //reset the error
    SetLastError(dwError);

    return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(OutOfMemoryErr, E_OUTOFMEMORY);
TRACE_ERROR(TraceErr);

}


//----------------------------------------------------------------------------
//
// We make sure that the if the CA info is specified via the API, it
// support the specified cert type
//----------------------------------------------------------------------------
BOOL    CASupportSpecifiedCertType(CRYPTUI_WIZ_CERT_CA     *pCertCA)
{
    DWORD       dwIndex=0;

    if(NULL == pCertCA)
        return FALSE;

    for(dwIndex=0; dwIndex<pCertCA->dwCertTypeInfo; dwIndex++)
    {
        if(TRUE==(pCertCA->rgCertTypeInfo)[dwIndex].fSelected)
            return TRUE;
    }

    return FALSE;
}

//----------------------------------------------------------------------------
//
//  This is the layer of CertRequest wizard that is independent of CA object on the DS.
//
//----------------------------------------------------------------------------
BOOL
WINAPI
CryptUIWizCertRequestWithCAInfo(
            CERT_WIZARD_INFO                *pCertWizardInfo,
            DWORD                           dwFlags,
            HWND                            hwndParent,
            LPCWSTR                         pwszWizardTitle,
            PCCRYPTUI_WIZ_CERT_REQUEST_INFO pCertRequestInfo,
            PCCRYPTUI_WIZ_CERT_CA_INFO      pCertRequestCAInfo,
            PCCERT_CONTEXT                  *ppCertContext,
            DWORD                           *pdwStatus,
            UINT                            *pIds)
{

    PROPSHEETPAGEW           rgEnrollSheet[ENROLL_PROP_SHEET];
    PROPSHEETHEADERW         enrollHeader;
    DWORD                   dwIndex=0;
    DWORD                   dwSize=0;
    ENROLL_PAGE_INFO        rgEnrollPageInfo[]=
        {(LPCWSTR)MAKEINTRESOURCE(IDD_WELCOME),                 Enroll_Welcome,
         (LPCWSTR)MAKEINTRESOURCE(IDD_PURPOSE),                 Enroll_Purpose,
         (LPCWSTR)MAKEINTRESOURCE(IDD_CSP_SERVICE_PROVIDER),    Enroll_CSP,
         (LPCWSTR)MAKEINTRESOURCE(IDD_CERTIFICATE_AUTHORITY),   Enroll_CA,
         (LPCWSTR)MAKEINTRESOURCE(IDD_NAME_DESCRIPTION),        Enroll_Name,
         (LPCWSTR)MAKEINTRESOURCE(IDD_COMPLETION),              Enroll_Completion,
    };

    PROPSHEETPAGEW           rgRenewSheet[RENEW_PROP_SHEET];
    PROPSHEETHEADERW         renewHeader;
    ENROLL_PAGE_INFO        rgRenewPageInfo[]=
        {(LPCWSTR)MAKEINTRESOURCE(IDD_RENEW_WELCOME),            Renew_Welcome,
         (LPCWSTR)MAKEINTRESOURCE(IDD_RENEW_OPTIONS),            Renew_Options,
         (LPCWSTR)MAKEINTRESOURCE(IDD_RENEW_SERVICE_PROVIDER),   Renew_CSP,
         (LPCWSTR)MAKEINTRESOURCE(IDD_RENEW_CA),                 Renew_CA,
         (LPCWSTR)MAKEINTRESOURCE(IDD_RENEW_COMPLETION),         Renew_Completion,
    };


    WCHAR                   wszTitle[MAX_TITLE_LENGTH];
    HRESULT                 hr=E_FAIL;
    BOOL                    fResult=FALSE;
    DWORD                   dwError=0;
    UINT                    idsText=IDS_INVALID_INFO_FOR_PKCS10;
    DWORD                   dwStatus=CRYPTUI_WIZ_CERT_REQUEST_STATUS_UNKNOWN;


    //memset
    memset(rgEnrollSheet,   0, sizeof(PROPSHEETPAGEW)*ENROLL_PROP_SHEET);
    memset(&enrollHeader,   0, sizeof(PROPSHEETHEADERW));

    memset(rgRenewSheet,    0, sizeof(PROPSHEETPAGEW)*RENEW_PROP_SHEET);
    memset(&renewHeader,    0, sizeof(PROPSHEETHEADERW));


    //error checking
    if(NULL== pCertRequestInfo ||
      NULL == pCertRequestCAInfo)
      goto InvalidArgErr;

    //the CA name is a must
    if(1>=(pCertRequestCAInfo->dwCA))
    {
        idsText=IDS_NO_CA_FOR_CSP;
        goto InvalidArgErr;
    }


    //for each ca information, we can not have both OID and certType information
    for(dwIndex=0; dwIndex <pCertRequestCAInfo->dwCA; dwIndex++)
    {
        if((0==pCertRequestCAInfo->rgCA[dwIndex].dwOIDInfo) &&
           (0==pCertRequestCAInfo->rgCA[dwIndex].dwCertTypeInfo))
        {
            //we are in trouble
            goto InvalidArgErr;
        }

        if((0!=pCertRequestCAInfo->rgCA[dwIndex].dwOIDInfo) &&
           (0!=pCertRequestCAInfo->rgCA[dwIndex].dwCertTypeInfo))
           goto InvalidArgErr;
    }

    //make sure the genKey flag does not include CRYPT_USER_PROTECTED
    //if we are doing a remote enrollment/renew
    if(FALSE == pCertWizardInfo->fLocal)
    {
        if(CRYPT_USER_PROTECTED & pCertWizardInfo->dwGenKeyFlags)
        {
            idsText=IDS_NO_USER_PROTECTED_FOR_REMOTE;
            goto InvalidArgErr;
        }
    }


    //for UI enrollment
    //get a list of CAs, based on the CSP user selected
    //and the availability of CAs on the DS
    if(pCertRequestInfo->dwPurpose & CRYPTUI_WIZ_CERT_RENEW)
    {

        pCertWizardInfo->pCertContext=pCertRequestInfo->pRenewCertContext;

        //the certificate has to be the property
        if(!CertGetCertificateContextProperty(
                pCertWizardInfo->pCertContext,
                CERT_KEY_PROV_INFO_PROP_ID,
                NULL,
                &dwSize) || (0==dwSize))
        {
            idsText=IDS_NO_PVK_FOR_RENEW_CERT;
            goto InvalidArgErr;
        }
    }

    //set up the information
    pCertWizardInfo->dwFlags=dwFlags;
    pCertWizardInfo->dwPurpose=pCertRequestInfo->dwPurpose;
    pCertWizardInfo->hwndParent=hwndParent;
    pCertWizardInfo->pCertCAInfo=(CRYPTUI_WIZ_CERT_CA_INFO *)pCertRequestCAInfo;
    pCertWizardInfo->iOrgCertType=-1;      //the original cert type selection is -1
    pCertWizardInfo->iOrgCSP=-1;           //the original CSP selection is -1
    pCertWizardInfo->pwszCADisplayName=NULL;

    //get the CA name and CA location
    for(dwIndex=0; dwIndex < pCertRequestCAInfo->dwCA; dwIndex++)
    {
        if(TRUE==pCertRequestCAInfo->rgCA[dwIndex].fSelected)
        {
            if(NULL==pCertRequestCAInfo->rgCA[dwIndex].pwszCALocation ||
               NULL==pCertRequestCAInfo->rgCA[dwIndex].pwszCAName)
               goto InvalidArgErr;

            //copy the CA name and location
            pCertWizardInfo->pwszCALocation=WizardAllocAndCopyWStr(pCertRequestCAInfo->rgCA[dwIndex].pwszCALocation);
            pCertWizardInfo->pwszCAName=WizardAllocAndCopyWStr(pCertRequestCAInfo->rgCA[dwIndex].pwszCAName);

            //memory check
            if(NULL== pCertWizardInfo->pwszCALocation ||
               NULL== pCertWizardInfo->pwszCAName)
               goto MemoryErr;

            pCertWizardInfo->dwCAIndex=dwIndex;
            pCertWizardInfo->dwOrgCA=dwIndex;
        }
    }

    //make sure that have CA information
   if(NULL== pCertWizardInfo->pwszCALocation ||
      NULL== pCertWizardInfo->pwszCAName ||
      0 == pCertWizardInfo->dwCAIndex ||
      0 == pCertWizardInfo->dwOrgCA)
   {
        idsText=IDS_NO_CA_FOR_ENROLL;
        goto FailErr;
   }

   //if user has selected a CA and CertType, we want to
   //make sure that the CA specified do support the
   //CertType
   if(TRUE == pCertWizardInfo->fCAInput)
   {
        //make sure that the CA has a selected cert type in it
        if(!(CASupportSpecifiedCertType(&(pCertWizardInfo->pCertCAInfo->rgCA[pCertWizardInfo->dwCAIndex]))))
        {
            idsText=IDS_ENROLL_NO_CERT_TYPE;
            goto FailErr;
        }
   } 
   else 
   { 
        // Ensure that we default to a CA that supports
        ResetDefaultCA(pCertWizardInfo); 
   }


   pCertWizardInfo->fConfirmation          = !(dwFlags & CRYPTUI_WIZ_NO_UI); 
   pCertWizardInfo->pwszConfirmationTitle  = pwszWizardTitle;

    if(pCertRequestInfo->dwPurpose & CRYPTUI_WIZ_CERT_ENROLL)
        pCertWizardInfo->idsConfirmTitle=IDS_ENROLL_CONFIRM;
    else
        pCertWizardInfo->idsConfirmTitle=IDS_RENEW_CONFIRM;

    pCertWizardInfo->pAuthentication=pCertRequestInfo->pAuthentication;
    pCertWizardInfo->pwszRequestString=pCertRequestInfo->pCertRequestString;
    pCertWizardInfo->pwszDesStore=pCertRequestInfo->pwszDesStore;
    pCertWizardInfo->pwszCertDNName=pCertRequestInfo->pwszCertDNName;
    pCertWizardInfo->pszHashAlg=pCertRequestInfo->pszHashAlg;
    pCertWizardInfo->dwPostOption=pCertRequestInfo->dwPostOption;

    if(pCertRequestInfo->pwszFriendlyName)
        pCertWizardInfo->pwszFriendlyName=WizardAllocAndCopyWStr((LPWSTR)(pCertRequestInfo->pwszFriendlyName));
    if(pCertRequestInfo->pwszDescription)
        pCertWizardInfo->pwszDescription=WizardAllocAndCopyWStr((LPWSTR)(pCertRequestInfo->pwszDescription));

    pCertWizardInfo->pCertRequestExtensions=pCertRequestInfo->pCertRequestExtensions;

    //set up the fonts for the UI case
    if( 0 == (dwFlags & CRYPTUI_WIZ_NO_UI) )
    {
        if(!SetupFonts(g_hmodThisDll,
                   NULL,
                   &(pCertWizardInfo->hBigBold),
                   &(pCertWizardInfo->hBold)))
        {
            idsText=IDS_FAIL_INIT_DLL;
            goto Win32Err;
        }

        //we change the cursor shape from the hour glass to its original shape
        if((hwndParent) && (TRUE == pCertWizardInfo->fCursorChanged))
        {
            //set the cursor back
            SetCursor(pCertWizardInfo->hPrevCursor);
            SetWindowLongPtr(hwndParent, GCLP_HCURSOR, (LONG_PTR)(pCertWizardInfo->hWinPrevCursor));
            pCertWizardInfo->fCursorChanged = FALSE;
        }
    }

    //init the common control for the UI enrollmnet
    if((pCertRequestInfo->dwPurpose & CRYPTUI_WIZ_CERT_ENROLL)  &&
        ((dwFlags & CRYPTUI_WIZ_NO_UI) == 0)
      )
    {

        if(!WizardInit() ||
           (sizeof(rgEnrollPageInfo)/sizeof(rgEnrollPageInfo[0])!=ENROLL_PROP_SHEET)
          )
        {
            idsText=IDS_FAIL_INIT_DLL;
            goto InvalidArgErr;
        }

        //set up the property sheet and the property header
        for(dwIndex=0; dwIndex<ENROLL_PROP_SHEET; dwIndex++)
        {
            rgEnrollSheet[dwIndex].dwSize=sizeof(rgEnrollSheet[dwIndex]);

            if(pwszWizardTitle)
                rgEnrollSheet[dwIndex].dwFlags=PSP_USETITLE;
            else
                rgEnrollSheet[dwIndex].dwFlags=0;

            rgEnrollSheet[dwIndex].hInstance=g_hmodThisDll;
            rgEnrollSheet[dwIndex].pszTemplate=rgEnrollPageInfo[dwIndex].pszTemplate;

            if(pwszWizardTitle)
            {
                rgEnrollSheet[dwIndex].pszTitle=pwszWizardTitle;
            }
            else
                rgEnrollSheet[dwIndex].pszTitle=NULL;

            rgEnrollSheet[dwIndex].pfnDlgProc=rgEnrollPageInfo[dwIndex].pfnDlgProc;

            rgEnrollSheet[dwIndex].lParam=(LPARAM)pCertWizardInfo;
        }

        //set up the header information
        enrollHeader.dwSize=sizeof(enrollHeader);
        enrollHeader.dwFlags=PSH_PROPSHEETPAGE | PSH_WIZARD | PSH_NOAPPLYNOW;
        enrollHeader.hwndParent=hwndParent;
        enrollHeader.hInstance=g_hmodThisDll;

        if(pwszWizardTitle)
            enrollHeader.pszCaption=pwszWizardTitle;
        else
        {
            if(LoadStringU(g_hmodThisDll, IDS_ENROLL_WIZARD_TITLE, wszTitle, sizeof(wszTitle)/sizeof(wszTitle[0])))
                enrollHeader.pszCaption=wszTitle;
        }

        enrollHeader.nPages=ENROLL_PROP_SHEET;
        enrollHeader.nStartPage=0;
        enrollHeader.ppsp=rgEnrollSheet;

        //create the wizard
        if(!PropertySheetU(&enrollHeader))
        {
            //cancel button is pushed
            fResult=TRUE;
            idsText=0;
            goto CommonReturn;
        }
        else
        {
            //finish button is pushed
            //get the result of the enrollment wizard
            idsText=pCertWizardInfo->idsText;
            dwStatus=pCertWizardInfo->dwStatus;

            if(S_OK != (hr=pCertWizardInfo->hr))
                goto I_EnrollErr;
        }

    }
    else
    {
        //call the UI  renew
        if((pCertRequestInfo->dwPurpose & CRYPTUI_WIZ_CERT_RENEW)  &&
            ((dwFlags & CRYPTUI_WIZ_NO_UI) == 0)
        )
        {
            //init the common control
            if(!WizardInit() ||
               (sizeof(rgRenewPageInfo)/sizeof(rgRenewPageInfo[0])!=RENEW_PROP_SHEET)
               )
            {
                idsText=IDS_FAIL_INIT_DLL;
                goto InvalidArgErr;
            }

            //set up the property pages and the property header
            for(dwIndex=0; dwIndex<RENEW_PROP_SHEET; dwIndex++)
            {
                rgRenewSheet[dwIndex].dwSize=sizeof(rgRenewSheet[dwIndex]);

                if(pwszWizardTitle)
                    rgRenewSheet[dwIndex].dwFlags=PSP_USETITLE;
                else
                    rgRenewSheet[dwIndex].dwFlags=0;

                rgRenewSheet[dwIndex].hInstance=g_hmodThisDll;
                rgRenewSheet[dwIndex].pszTemplate=rgRenewPageInfo[dwIndex].pszTemplate;

                if(pwszWizardTitle)
                {
                    rgRenewSheet[dwIndex].pszTitle=pwszWizardTitle;
                }
                else
                    rgRenewSheet[dwIndex].pszTitle=NULL;

                rgRenewSheet[dwIndex].pfnDlgProc=rgRenewPageInfo[dwIndex].pfnDlgProc;

                rgRenewSheet[dwIndex].lParam=(LPARAM)pCertWizardInfo;
            }

            //set up the header information
            renewHeader.dwSize=sizeof(renewHeader);
            renewHeader.dwFlags=PSH_PROPSHEETPAGE | PSH_WIZARD | PSH_NOAPPLYNOW;
            renewHeader.hwndParent=hwndParent;
            renewHeader.hInstance=g_hmodThisDll;

            if(pwszWizardTitle)
                renewHeader.pszCaption=pwszWizardTitle;
            else
            {
                if(LoadStringU(g_hmodThisDll, IDS_RENEW_WIZARD_TITLE, wszTitle, sizeof(wszTitle)/sizeof(wszTitle[0])))
                    renewHeader.pszCaption=wszTitle;
            }

            renewHeader.nPages=RENEW_PROP_SHEET;
            renewHeader.nStartPage=0;
            renewHeader.ppsp=rgRenewSheet;

            //create the wizard
            if(!PropertySheetU(&renewHeader))
            {
                //cancel button is pushed
                fResult=TRUE;
                idsText=0;
                goto CommonReturn;
            }
            else
            {
                //finish button is pushed
                //get the result of the enrollment wizard
               idsText=pCertWizardInfo->idsText;
               dwStatus=pCertWizardInfo->dwStatus;
                
               if(S_OK != (hr=pCertWizardInfo->hr))
                    goto I_EnrollErr;
            }

        }
        //UIless enroll or renew
        else
        {
            CertRequester         *pCertRequester        = NULL; 
            CertRequesterContext  *pCertRequesterContext = NULL;
            
            if (NULL == (pCertRequester = (CertRequester *) pCertWizardInfo->hRequester))
            { 
                hr = E_UNEXPECTED; 
                goto I_EnrollErr; 
            }
            if (NULL == (pCertRequesterContext = pCertRequester->GetContext()))
            {
                hr = E_UNEXPECTED; 
                goto I_EnrollErr; 
            }

	    hr = pCertRequesterContext->Enroll(&dwStatus, (HANDLE *)&(pCertWizardInfo->pNewCertContext));
	    if (0 == pCertWizardInfo->idsText) { 
                idsText = CryptUIStatusToIDSText(hr, dwStatus); 
            }

            if(S_OK != hr)
                goto I_EnrollErr;
       }
    }

    if(S_OK !=hr)
        goto I_EnrollErr;

    fResult=TRUE;

CommonReturn:

    //preserve the last error
    dwError=GetLastError();

    if(pIds)
        *pIds=idsText;


    //we have to free the friendlyName and description field
    if(pCertWizardInfo->pwszFriendlyName)
         WizardFree(pCertWizardInfo->pwszFriendlyName);

    if(pCertWizardInfo->pwszDescription)
            WizardFree(pCertWizardInfo->pwszDescription);

    //free the CA name and CA location
    if(pCertWizardInfo->pwszCALocation)
            WizardFree(pCertWizardInfo->pwszCALocation);

    if(pCertWizardInfo->pwszCAName)
            WizardFree(pCertWizardInfo->pwszCAName);

	if(pCertWizardInfo->pwszCADisplayName)
			WizardFree(pCertWizardInfo->pwszCADisplayName);

    //destroy the hFont object
    DestroyFonts(pCertWizardInfo->hBigBold,
                pCertWizardInfo->hBold);

    //return the value
    if(pdwStatus)
    {
        //remember it is the CA status
        switch (dwStatus)
        {
            case    CRYPTUI_WIZ_CERT_REQUEST_STATUS_INSTALL_FAILED:
            case    CRYPTUI_WIZ_CERT_REQUEST_STATUS_INSTALL_CANCELLED:
                        dwStatus=CRYPTUI_WIZ_CERT_REQUEST_STATUS_CERT_ISSUED;
                break;
            case    CRYPTUI_WIZ_CERT_REQUEST_STATUS_KEYSVC_FAILED:
                        dwStatus=CRYPTUI_WIZ_CERT_REQUEST_STATUS_UNKNOWN;
                break;
        }
       *pdwStatus=dwStatus;
    }

    if(ppCertContext)
        *ppCertContext=pCertWizardInfo->pNewCertContext;
    else
    {
        //free the certificate context
        if(pCertWizardInfo->pNewCertContext)
            CertFreeCertificateContext(pCertWizardInfo->pNewCertContext);
    }

    //reset the error
    SetLastError(dwError);

    return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
TRACE_ERROR(Win32Err);
SET_ERROR_VAR(I_EnrollErr, hr);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
SET_ERROR(FailErr, E_FAIL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\ui\wizards\wzrdhlp.cpp ===
//--------------------------------------------------------------
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       wizards.cpp
//
//  Contents:   The cpp file to implement the wizards
//
//  History:    16-10-1997 xiaohs   created
//
//--------------------------------------------------------------
#include    "wzrdpvk.h"
#include    "certca.h"
#include    "cautil.h"

#include    "CertRequesterContext.h"
#include    "CertDSManager.h"
#include    "CertRequester.h"

//need the CLSID and IID for xEnroll

#include    <ole2.h>
#include    <oleauto.h>
#include    "xenroll.h"
#include    "xenroll_i.c"
#include    <certrpc.h>


#define _SET_XENROLL_PROPERTY_IF(condition, property, arg)         \
    {                                                              \
        if ( condition ) {                                         \
            if (S_OK != (hr = pIEnroll->put_ ## property ( arg ))) \
                goto xEnrollErr;                                   \
        }                                                          \
    }

// Used to provide singleton instances of useful COM objects in a demand-driven fashion.
// See wzrdpvk.h. 
extern EnrollmentCOMObjectFactory *g_pEnrollFactory; 

extern HMODULE                     g_hmodRichEdit;
extern HMODULE                     g_hmodxEnroll;

typedef struct _CERT_ACCEPT_INFO
{
        PCCERT_CONTEXT     pCertContext;
        PCRYPT_DATA_BLOB   pPKCS7Blob;
        LPWSTR             pwszTitle;
}CERT_ACCEPT_INFO;
#define USE_NP

typedef struct  _CREATE_REQUEST_WIZARD_STATE { 
    BOOL             fMustFreeRequestBlob; 
    CRYPT_DATA_BLOB  RequestBlob; 
    CRYPT_DATA_BLOB  HashBlob; 
    DWORD            dwMyStoreFlags;
    DWORD            dwRootStoreFlags;
    LPWSTR           pwszMyStoreName; 
    LPWSTR           pwszRootStoreName; 
    LONG             lRequestFlags;
    BOOL             fReusedPrivateKey; 
    BOOL             fNewKey; 
} CREATE_REQUEST_WIZARD_STATE, *PCREATE_REQUEST_WIZARD_STATE; 

typedef   IEnroll4 * (WINAPI *PFNPIEnroll4GetNoCOM)();

BOOL CertAllocAndGetCertificateContextProperty
(IN  PCCERT_CONTEXT    pCertContext,
 IN  DWORD             dwPropID,
 OUT void            **ppvData, 
 OUT DWORD            *pcbData)
{
    if (NULL == ppvData || NULL == pcbData)
        return FALSE;

    *ppvData = 0; 
    *pcbData = 0; 

    if(!CertGetCertificateContextProperty
       (pCertContext,
        dwPropID, 
        NULL,	
        pcbData) || (0==*pcbData))
        return FALSE;
    
    *ppvData = WizardAlloc(*pcbData);
    if(NULL == *ppvData)
        return FALSE;

    if(!CertGetCertificateContextProperty
       (pCertContext,
        dwPropID,
        *ppvData, 
        pcbData))
        return FALSE;

    return TRUE;
}

/*typedef HRESULT (WINAPI *pfDllGetClassObject)(REFCLSID    rclsid,
                                    REFIID      riid,
                                    LPVOID      *ppvOut);  */
//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////

//------------------------------------------------------------------------------
// WizGetOpenFileName
//----------------------------------------------------------------------------
BOOL    WizGetOpenFileName(LPOPENFILENAMEW pOpenFileName)
{

    BOOL    fResult=FALSE;

    __try {

        fResult=GetOpenFileNameU(pOpenFileName);

    } __except(EXCEPTION_EXECUTE_HANDLER) {
        SetLastError(GetExceptionCode());
        fResult=FALSE;
    }


    return fResult;
}

//------------------------------------------------------------------------------
// WizGetSaveFileName
//----------------------------------------------------------------------------
BOOL    WizGetSaveFileName(LPOPENFILENAMEW pOpenFileName)
{

    BOOL    fResult=FALSE;

    __try {

        fResult=GetSaveFileNameU(pOpenFileName);

    } __except(EXCEPTION_EXECUTE_HANDLER) {
        SetLastError(GetExceptionCode());
        fResult=FALSE;
    }

    return fResult;
}

void    FreeProviders(  DWORD               dwCSPCount,
                        DWORD               *rgdwProviderType,
                        LPWSTR              *rgwszProvider)
{
    //free the  rgdwProviderType and rgwszProvider;
    if(NULL != rgdwProviderType) { WizardFree(rgdwProviderType); } 

    if(NULL != rgwszProvider)
    {
        for(DWORD dwIndex=0; dwIndex<dwCSPCount; dwIndex++)
        {
	    if (NULL != rgwszProvider[dwIndex]) { WizardFree(rgwszProvider[dwIndex]); } 
	}
        WizardFree(rgwszProvider);
    }
}

//------------------------------------------------------------------------------
// Unicode version of CB_GETLBTEXT
//----------------------------------------------------------------------------
LRESULT
WINAPI
SendDlgItemMessageU_GETLBTEXT
(   HWND        hwndDlg,
    int         nIDDlgItem,
    int         iIndex,
    LPWSTR      *ppwsz
    )
{
    LPSTR   sz = NULL;
    LPWSTR  pwsz=NULL;
    LRESULT lRet;
    int     iLength=0;

    iLength=(int)SendDlgItemMessage(hwndDlg, nIDDlgItem,
                    CB_GETLBTEXTLEN, iIndex, 0);

    if(iLength == CB_ERR)
        return CB_ERR;


    if(FIsWinNT())
    {
        *ppwsz=(LPWSTR)WizardAlloc(sizeof(WCHAR) * (iLength + 1));

        if(NULL == (*ppwsz))
            return CB_ERR;


        lRet = SendDlgItemMessageW(
                    hwndDlg,
                    nIDDlgItem,
                    CB_GETLBTEXT,
                    iIndex,
                    (LPARAM) (*ppwsz)
                    );


        if(CB_ERR == lRet)
        {
            WizardFree(*ppwsz);
            *ppwsz=NULL;
        }

        return lRet;
    }

    sz=(LPSTR)WizardAlloc(sizeof(CHAR) * (iLength + 1));

    if(NULL == sz)
        return CB_ERR;


    lRet = SendDlgItemMessageA(
                hwndDlg,
                nIDDlgItem,
                CB_GETLBTEXT,
                iIndex,
                (LPARAM)sz
                );


    if(CB_ERR == lRet)
        goto CLEANUP;

    if(NULL == (pwsz=MkWStr(sz)))
    {
        lRet=CB_ERR;
        goto CLEANUP;
    }

    *ppwsz=WizardAllocAndCopyWStr(pwsz);

    if(NULL == (*ppwsz))
    {
        lRet=CB_ERR;
        goto CLEANUP;
    }


CLEANUP:

    if(sz)
        WizardFree(sz);

    if(pwsz)
        FreeWStr(pwsz);

    return (lRet);
}

//
// A mapping from cert type flags to gen key flags.  
// 
BOOL CertTypeFlagsToGenKeyFlags(IN OPTIONAL DWORD dwEnrollmentFlags,
				IN OPTIONAL DWORD dwSubjectNameFlags,
				IN OPTIONAL DWORD dwPrivateKeyFlags,
				IN OPTIONAL DWORD dwGeneralFlags, 
				OUT DWORD *pdwGenKeyFlags)
{
    // Define a locally scoped helper function.  This allows us to gain the benefits of procedural
    // abstraction without corrupting the global namespace.  
    // 
    LocalScope(CertTypeMap): 
	// Maps cert type flags of one category (enrollment flags, private key flags, etc...)
	// to their corresponding gen key flags.  This function always returns successfully.  
	// 
	DWORD mapOneCertTypeCategory(IN DWORD dwOption, IN DWORD dwCertTypeFlags) 
	{ 
	    static DWORD const rgdwEnrollmentFlags[][2] = { 
		{ 0, 0 } // No enrollment flags mapped. 
	    }; 
	    static DWORD const rgdwSubjectNameFlags[][2] = { 
		{ 0, 0 } // No subject name flags mapped. 
	    }; 
	    static DWORD const rgdwPrivateKeyFlags[][2]   = { 
	      { CT_FLAG_EXPORTABLE_KEY,                  CRYPT_EXPORTABLE }, 
	      { CT_FLAG_STRONG_KEY_PROTECTION_REQUIRED,  CRYPT_USER_PROTECTED }
	    }; 
	    static DWORD const rgdwGeneralFlags[][2] = { 
		{ 0, 0 } // No general flags mapped. 
	    }; 
	    
	    static DWORD const dwEnrollmentLen  = sizeof(rgdwEnrollmentFlags)  / sizeof(DWORD[2]); 
	    static DWORD const dwSubjectNameLen = sizeof(rgdwSubjectNameFlags) / sizeof(DWORD[2]); 
	    static DWORD const dwPrivateKeyLen  = sizeof(rgdwPrivateKeyFlags)  / sizeof(DWORD[2]); 
	    static DWORD const dwGeneralLen     = sizeof(rgdwGeneralFlags)     / sizeof(DWORD[2]); 
	    
	    static DWORD const CERT_TYPE_INDEX  = 0; 
	    static DWORD const GEN_KEY_INDEX    = 1;

	    DWORD const  *pdwFlags; 
	    DWORD         dwLen, dwIndex, dwResult = 0; 

	    switch (dwOption)
	    {

	    case CERTTYPE_ENROLLMENT_FLAG:    
		pdwFlags = &rgdwEnrollmentFlags[0][0]; 
		dwLen    = dwEnrollmentLen; 
		break;
	    case CERTTYPE_SUBJECT_NAME_FLAG:  
		pdwFlags = &rgdwSubjectNameFlags[0][0]; 
		dwLen    = dwSubjectNameLen; 
		break;
	    case CERTTYPE_PRIVATE_KEY_FLAG:   
		pdwFlags = &rgdwPrivateKeyFlags[0][0]; 
		dwLen    = dwPrivateKeyLen;
		break;
	    case CERTTYPE_GENERAL_FLAG:       
		pdwFlags = &rgdwGeneralFlags[0][0]; 
		dwLen    = dwGeneralLen;
		break;
	    }
	    
	    for (dwIndex = 0; dwIndex < dwLen; dwIndex++)
	    {
		if (0 != (pdwFlags[CERT_TYPE_INDEX] & dwCertTypeFlags))
		{
		    dwResult |= pdwFlags[GEN_KEY_INDEX]; 
		}
		pdwFlags += 2; 
	    }
	    
	    return dwResult; 
	}
    EndLocalScope; 

    //
    // Begin procedure body: 
    //

    BOOL   fResult; 
    DWORD  dwResult = 0; 
    DWORD  dwErr    = ERROR_SUCCESS; 
	
    // Input parameter validation: 
    _JumpConditionWithExpr(pdwGenKeyFlags == NULL, Error, dwErr = ERROR_INVALID_PARAMETER); 

    // Compute the gen key flags using the locally scope function.  
    dwResult |= local.mapOneCertTypeCategory(CERTTYPE_ENROLLMENT_FLAG, dwEnrollmentFlags);
    dwResult |= local.mapOneCertTypeCategory(CERTTYPE_SUBJECT_NAME_FLAG, dwSubjectNameFlags);
    dwResult |= local.mapOneCertTypeCategory(CERTTYPE_PRIVATE_KEY_FLAG, dwPrivateKeyFlags);
    dwResult |= local.mapOneCertTypeCategory(CERTTYPE_GENERAL_FLAG, dwGeneralFlags); 

    // Assign the out parameter: 
    *pdwGenKeyFlags = dwResult; 

    fResult = TRUE; 

 CommonReturn: 
    return fResult;

 Error: 
    fResult = FALSE; 
    SetLastError(dwErr); 
    goto CommonReturn; 
}



HRESULT GetCAExchangeCertificate(IN  BSTR             bstrCAQualifiedName, 
				 OUT PCCERT_CONTEXT  *ppCert) 
{
    HRESULT                      hr                      = S_OK; 

    // BUGBUG:  need to use global enrollment factory. 
    EnrollmentCOMObjectFactory  *pEnrollFactory          = NULL; 
    ICertRequest2               *pCertRequest            = NULL; 
    VARIANT                      varExchangeCertificate; 

    // We're using a COM component in this method.  It's absolutely necessary that we
    // uninitialize COM before we return, because we're running in an RPC thread, 
    // and failing to uninitialize COM will cause us to step on RPC's toes.  
    // 
    // See BUG 404778. 
    __try { 
	// Input validation: 
	if (NULL == bstrCAQualifiedName || NULL == ppCert)
	    return E_INVALIDARG; 

	// Init: 
	*ppCert                        = NULL; 
	VariantInit(&varExchangeCertificate);

	pEnrollFactory = new EnrollmentCOMObjectFactory; 
	if (NULL == pEnrollFactory)
	{
	    hr = E_OUTOFMEMORY; 
	    goto Error; 
	}

	if (S_OK != (hr = pEnrollFactory->getICertRequest2(&pCertRequest)))
	    goto Error; 

	if (S_OK != (hr = pCertRequest->GetCAProperty
		     (bstrCAQualifiedName,     // CA Name/CA Location
		      CR_PROP_CAXCHGCERT,      // Get the exchange certificate from the CA. 
		      0,                       // Unused
		      PROPTYPE_BINARY,         // 
		      CR_OUT_BINARY,           // 
		      &varExchangeCertificate  // Variant type representing the certificate. 
		      )))
	    goto Error;
 
	if (VT_BSTR != varExchangeCertificate.vt || NULL == varExchangeCertificate.bstrVal)
	{
	    hr = E_UNEXPECTED; 
	    goto Error; 
	}

	*ppCert = CertCreateCertificateContext
	    (X509_ASN_ENCODING, 
	     (LPBYTE)varExchangeCertificate.bstrVal, 
	     SysStringByteLen(varExchangeCertificate.bstrVal)); 
	if (*ppCert == NULL)
	{
	    hr = CodeToHR(GetLastError()); 
	    goto Error;
	}
    } __except (EXCEPTION_EXECUTE_HANDLER) { 
	hr = GetExceptionCode();
	goto Error; 
    }

 CommonReturn: 
    if (NULL != pCertRequest)                    { pCertRequest->Release(); }
    if (NULL != pEnrollFactory)                  { delete pEnrollFactory; } 
    VariantClear(&varExchangeCertificate); 
    return hr; 
   
 Error:
    if (ppCert != NULL && *ppCert != NULL)
    {
	CertFreeCertificateContext(*ppCert);
	*ppCert = NULL;
    }
    
    goto CommonReturn; 
}


HRESULT
WizardSZToWSZ
(IN LPCSTR   psz,
 OUT LPWSTR *ppwsz)
{
    HRESULT hr = S_OK;
    LONG    cc = 0;

    if (NULL == ppwsz)
	return E_INVALIDARG; 

    //init
    *ppwsz = NULL;

    cc = MultiByteToWideChar(GetACP(), 0, psz, -1, NULL, 0); 
    if (0 == cc) 
	goto Win32Err; 

    *ppwsz = (LPWSTR)WizardAlloc(sizeof (WCHAR) * cc); 
    if (NULL == *ppwsz)
	goto MemoryErr; 

    cc = MultiByteToWideChar(GetACP(), 0, psz, -1, *ppwsz, cc);
    if (0 == cc)
	goto Win32Err; 

 CommonReturn: 
    return hr; 

 ErrorReturn:
    if (NULL != ppwsz && NULL != *ppwsz) 
    {
	WizardFree(*ppwsz); 
	*ppwsz = NULL;
    }

    goto CommonReturn; 

SET_HRESULT(Win32Err, GetLastError()); 
SET_HRESULT(MemoryErr, E_OUTOFMEMORY); 
}

//--------------------------------------------------------------------------
//
//	WizardAllocAndCopyStr
//
//--------------------------------------------------------------------------
LPSTR WizardAllocAndCopyStr(LPSTR psz)
{
    LPSTR   pszReturn;

    if (NULL == (pszReturn = (LPSTR) WizardAlloc((strlen(psz)+1) * sizeof(CHAR))))
    {
        return NULL;
    }
    strcpy(pszReturn, psz);

    return(pszReturn);
}

//--------------------------------------------------------------------------
//
//	WizardAllocAndConcatStrU
//
//--------------------------------------------------------------------------
LPWSTR WizardAllocAndConcatStrsU(LPWSTR * rgStrings, DWORD dwStringsLen)
{
    DWORD  cbReturn   = 0;
    LPWSTR pwszReturn = NULL;

    if (NULL == rgStrings) 
	return NULL; 

    for (DWORD dwIndex = 0; dwIndex < dwStringsLen; dwIndex++)
	cbReturn += wcslen(rgStrings[dwIndex]);

    // Add space for NULL character. 
    cbReturn = (cbReturn + 1) * sizeof(WCHAR);  

    if (NULL == (pwszReturn = (LPWSTR)WizardAlloc(cbReturn)))
	return NULL;

    for (DWORD dwIndex = 0; dwIndex < dwStringsLen; dwIndex++)
	wcscat(pwszReturn, rgStrings[dwIndex]);

    return (pwszReturn); 
}

//--------------------------------------------------------------------------
//
//	InitUnicodeString
//
//--------------------------------------------------------------------------
void WizardInitUnicodeString(PKEYSVC_UNICODE_STRING pUnicodeString,
                       LPCWSTR pszString
                       )
{
    pUnicodeString->Length = (USHORT)(wcslen(pszString) * sizeof(WCHAR));
    pUnicodeString->MaximumLength = pUnicodeString->Length + sizeof(WCHAR);
    pUnicodeString->Buffer = (USHORT*)pszString;
}

//--------------------------------------------------------------------------
//
//	 SetControlFont
//
//--------------------------------------------------------------------------
void
SetControlFont(
    IN HFONT    hFont,
    IN HWND     hwnd,
    IN INT      nId
    )
{
	if( hFont )
    {
    	HWND hwndControl = GetDlgItem(hwnd, nId);

    	if( hwndControl )
        {
        	SetWindowFont(hwndControl, hFont, TRUE);
        }
    }
}


//--------------------------------------------------------------------------
//
//	  SetupFonts
//
//--------------------------------------------------------------------------
BOOL
SetupFonts(
    IN HINSTANCE    hInstance,
    IN HWND         hwnd,
    IN HFONT        *pBigBoldFont,
    IN HFONT        *pBoldFont
    )
{
    //
	// Create the fonts we need based on the dialog font
    //
	NONCLIENTMETRICS ncm = {0};
	ncm.cbSize = sizeof(ncm);
	if (!SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &ncm, 0))
	    return FALSE; 

	LOGFONT BigBoldLogFont  = ncm.lfMessageFont;
	LOGFONT BoldLogFont     = ncm.lfMessageFont;

    //
	// Create Big Bold Font and Bold Font
    //
    BigBoldLogFont.lfWeight   = FW_BOLD;
	BoldLogFont.lfWeight      = FW_BOLD;

    CHAR FontSizeString[24];
    INT BigBoldFontSize;
    INT BoldFontSize;

    //
    // Load size and name from resources, since these may change
    // from locale to locale based on the size of the system font, etc.
    //
 /*  
	//no longer needs to do it.  We are loading the default font
   if(!LoadStringA(hInstance,IDS_LARGEFONTNAME,BigBoldLogFont.lfFaceName,LF_FACESIZE))
    {
        lstrcpy(BigBoldLogFont.lfFaceName,TEXT("MS Shell Dlg"));
    }

    if(!LoadStringA(hInstance,IDS_BOLDFONTNAME,BoldLogFont.lfFaceName,LF_FACESIZE))
    {
        lstrcpy(BoldLogFont.lfFaceName,TEXT("MS Sans Serif"));
    }	
*/
    if(LoadStringA(hInstance,IDS_LARGEFONTSIZE,FontSizeString,sizeof(FontSizeString)))
    {
        BigBoldFontSize = strtoul( FontSizeString, NULL, 10 );
    }
    else
    {
        BigBoldFontSize = 12;
    }

    if(LoadStringA(hInstance,IDS_BOLDFONTSIZE,FontSizeString,sizeof(FontSizeString)))
    {
        BoldFontSize = strtoul( FontSizeString, NULL, 10 );
    }
    else
    {
        BoldFontSize = 8;
    }

	HDC hdc = GetDC( hwnd );

    if( hdc )
    {
        BigBoldLogFont.lfHeight = 0 - (GetDeviceCaps(hdc,LOGPIXELSY) * BigBoldFontSize / 72);
        BoldLogFont.lfHeight = 0 - (GetDeviceCaps(hdc,LOGPIXELSY) * BoldFontSize / 72);

        *pBigBoldFont = CreateFontIndirect(&BigBoldLogFont);
		*pBoldFont    = CreateFontIndirect(&BoldLogFont);

        ReleaseDC(hwnd,hdc);

        if(*pBigBoldFont && *pBoldFont)
            return TRUE;
        else
        {
            if( *pBigBoldFont )
            {
                DeleteObject(*pBigBoldFont);
            }

            if( *pBoldFont )
            {
                DeleteObject(*pBoldFont);
            }
            return FALSE;
        }
    }

    return FALSE;
}


//--------------------------------------------------------------------------
//
//	  DestroyFonts
//
//--------------------------------------------------------------------------
void
DestroyFonts(
    IN HFONT        hBigBoldFont,
    IN HFONT        hBoldFont
    )
{
    if( hBigBoldFont )
    {
        DeleteObject( hBigBoldFont );
    }

    if( hBoldFont )
    {
        DeleteObject( hBoldFont );
    }
}


//-------------------------------------------------------------------------
//
//  Unicode version of SendMessage
//
//-------------------------------------------------------------------------
LRESULT Send_LB_GETTEXT(
            HWND hwnd,
            WPARAM wParam,
            LPARAM lParam
)
{
    int         iLength=0;
    LPSTR       psz=0;
    LRESULT     lResult;
    BOOL        fResult=FALSE;

    if(FIsWinNT())
    {
        return SendMessageW(hwnd, LB_GETTEXT, wParam, lParam);

    }

    //get the length of the buffer
    iLength=(int)SendMessageA(hwnd, LB_GETTEXTLEN, wParam, 0);

    psz=(LPSTR)WizardAlloc(iLength+1);

    if(NULL==psz)
        return LB_ERR;

    lResult=SendMessageA(hwnd, LB_GETTEXT, wParam, (LPARAM)psz);

    if(LB_ERR==lResult)
    {
        WizardFree(psz);
        return LB_ERR;
    }

    fResult=MultiByteToWideChar(
                    0,
                    0,
                    psz,
                    -1,
                    (LPWSTR)lParam,
                    iLength+1);

    WizardFree(psz);

    if(TRUE==fResult)
        return lResult;
    else
        return LB_ERR;
}

//-------------------------------------------------------------------------
//
//  Unicode version of SendMessage
//
//-------------------------------------------------------------------------
LRESULT Send_LB_ADDSTRING(
            HWND hwnd,
            WPARAM wParam,
            LPARAM lParam
)
{
    LPSTR   psz=NULL;
    LRESULT lResult;

    if(FIsWinNT())
    {
        return SendMessageW(hwnd, LB_ADDSTRING, wParam, lParam);

    }

    psz=(LPSTR)WizardAlloc(wcslen((LPWSTR)lParam)+1);

    if(NULL==psz)
        return LB_ERRSPACE;

    if(0==WideCharToMultiByte(0, 0, (LPWSTR)lParam, -1, psz, wcslen((LPWSTR)lParam)+1, NULL, NULL))
    {
        WizardFree(psz);
        return LB_ERR;
    }

    lResult=SendMessageA(hwnd, LB_ADDSTRING, wParam, (LPARAM)psz);

    WizardFree(psz);

    return lResult;
}

//-----------------------------------------------------------------------
//  Get the default CSP name based on the provider type
//
//------------------------------------------------------------------------
BOOL    CSPSupported(CERT_WIZARD_INFO *pCertWizardInfo)
{
    BOOL                    fResult=FALSE;
    DWORD                   dwIndex=0;

    if(!pCertWizardInfo)
        goto InvalidArgErr;

    if(!(pCertWizardInfo->dwProviderType) || !(pCertWizardInfo->pwszProvider))
        goto InvalidArgErr;


    for(dwIndex=0; dwIndex < pCertWizardInfo->dwCSPCount; dwIndex++)
    {
        if((pCertWizardInfo->dwProviderType == pCertWizardInfo->rgdwProviderType[dwIndex] ) &&
            (0==_wcsicmp(pCertWizardInfo->pwszProvider, pCertWizardInfo->rgwszProvider[dwIndex]))
          )
        {
          fResult=TRUE;
          break;
        }
    }


CommonReturn:

    return fResult;

ErrorReturn:
    
	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
}

//-----------------------------------------------------------------------
//  Get a list of allowed CAs
//
//------------------------------------------------------------------------
BOOL    GetCAName(CERT_WIZARD_INFO *pCertWizardInfo)
{
    DWORD                   dwErr=0;
    KEYSVC_TYPE             dwServiceType=KeySvcMachine;
    KEYSVCC_HANDLE          hKeyService=NULL;
    PKEYSVC_UNICODE_STRING  pCA = NULL;
    DWORD                   cCA=0;
    LPSTR                   pszMachineName=NULL;
    DWORD                   cbArray = 0;
    DWORD                   i=0;
    LPWSTR                  wszCurrentCA=NULL;
    BOOL                    fResult=FALSE;
        
    // We're not doing a local enrollment, so we must enroll via keysvc.  Get the
    // list of acceptable cert types.
    if(pCertWizardInfo->pwszAccountName)
        dwServiceType=KeySvcService;
    else
        dwServiceType=KeySvcMachine;

    if(!MkMBStr(NULL, 0, pCertWizardInfo->pwszMachineName, &pszMachineName))
        goto TraceErr;
       
    dwErr = KeyOpenKeyService(pszMachineName,
                              dwServiceType,
                              (LPWSTR)(pCertWizardInfo->pwszAccountName), 
                              NULL,     // no authentication string right now
                              NULL,
                              &hKeyService);
    
    if(dwErr != ERROR_SUCCESS)
    {
        SetLastError(dwErr);
        goto TraceErr;
    }

    dwErr = KeyEnumerateCAs(hKeyService,
                              NULL, 
							  CA_FIND_LOCAL_SYSTEM,
                              &cCA,
                              &pCA);
    if(dwErr != ERROR_SUCCESS)
    {
        SetLastError(dwErr);
        goto TraceErr;
    }

    cbArray = (cCA+1)*sizeof(LPWSTR);

    // Convert into a simple array
    for(i=0; i < cCA; i++)
    {
       cbArray += pCA[i].Length;
    }

    pCertWizardInfo->awszValidCA = (LPWSTR *)WizardAlloc(cbArray);


    if(pCertWizardInfo->awszValidCA == NULL)
           goto MemoryErr;


    memset(pCertWizardInfo->awszValidCA, 0, cbArray);

    wszCurrentCA = (LPWSTR)(&((pCertWizardInfo->awszValidCA)[cCA + 1]));
    
    for(i=0; i < cCA; i++)
    {
       (pCertWizardInfo->awszValidCA)[i] = wszCurrentCA;

       wcscpy(wszCurrentCA, pCA[i].Buffer);

       wszCurrentCA += wcslen(wszCurrentCA)+1;
    }

    fResult=TRUE;

CommonReturn:

    if(pCA)
        WizardFree(pCA);


    if(hKeyService)
        KeyCloseKeyService(hKeyService, NULL);


    if(pszMachineName)
        FreeMBStr(NULL,pszMachineName);

    return fResult;


ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

TRACE_ERROR(TraceErr);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
}

//-----------------------------------------------------------------------
//  Get a list of allowed cert types
//
//------------------------------------------------------------------------
BOOL    GetCertTypeName(CERT_WIZARD_INFO *pCertWizardInfo)
{
    DWORD                   dwErr=0;
    KEYSVC_TYPE             dwServiceType=KeySvcMachine;
    KEYSVCC_HANDLE          hKeyService=NULL;
    PKEYSVC_UNICODE_STRING  pCertTypes = NULL;
    DWORD                   cTypes=0;
    LPSTR                   pszMachineName=NULL;
    DWORD                   cbArray = 0;
    DWORD                   i=0;
    LPWSTR                  wszCurrentType;
    BOOL                    fResult=FALSE;
        
    // We're not doing a local enrollment, so we must enroll via keysvc.  Get the
    // list of acceptable cert types.
    if(pCertWizardInfo->pwszAccountName)
        dwServiceType=KeySvcService;
    else
        dwServiceType=KeySvcMachine;

    if(!MkMBStr(NULL, 0, pCertWizardInfo->pwszMachineName, &pszMachineName))
        goto TraceErr;
       
    dwErr = KeyOpenKeyService(pszMachineName,
                                    dwServiceType,
                                    (LPWSTR)(pCertWizardInfo->pwszAccountName), 
                                    NULL,     // no authentication string right now
                                    NULL,
                                    &hKeyService);

    if(dwErr != ERROR_SUCCESS)
    {
        SetLastError(dwErr);
        goto TraceErr;
    }

    dwErr = KeyEnumerateAvailableCertTypes(hKeyService,
                                          NULL, 
                                          &cTypes,
                                          &pCertTypes);
    if(dwErr != ERROR_SUCCESS)
    {
        SetLastError(dwErr);
        goto TraceErr;
    }

    cbArray = (cTypes+1)*sizeof(LPWSTR);

    // Convert into a simple array
    for(i=0; i < cTypes; i++)
    {
       cbArray += pCertTypes[i].Length;
    }

    pCertWizardInfo->awszAllowedCertTypes = (LPWSTR *)WizardAlloc(cbArray);


    if(pCertWizardInfo->awszAllowedCertTypes == NULL)
           goto MemoryErr;


    memset(pCertWizardInfo->awszAllowedCertTypes, 0, cbArray);

    wszCurrentType = (LPWSTR)(&((pCertWizardInfo->awszAllowedCertTypes)[cTypes + 1]));
    
    for(i=0; i < cTypes; i++)
    {
       (pCertWizardInfo->awszAllowedCertTypes)[i] = wszCurrentType;

       wcscpy(wszCurrentType, pCertTypes[i].Buffer);

       wszCurrentType += wcslen(wszCurrentType)+1;
    }

    fResult=TRUE;

CommonReturn:

    if(pCertTypes)
        WizardFree(pCertTypes);


    if(hKeyService)
        KeyCloseKeyService(hKeyService, NULL);


    if(pszMachineName)
        FreeMBStr(NULL,pszMachineName);

    return fResult;


ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

TRACE_ERROR(TraceErr);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
}

//-----------------------------------------------------------------------
//     WizardInit
//------------------------------------------------------------------------
BOOL    WizardInit(BOOL fLoadRichEdit)
{
    if ((fLoadRichEdit) && (g_hmodRichEdit == NULL))
    {
        g_hmodRichEdit = LoadLibraryA("RichEd32.dll");
        if (g_hmodRichEdit == NULL) {
            return FALSE;
        }
    }

    INITCOMMONCONTROLSEX        initcomm = {
        sizeof(initcomm), ICC_NATIVEFNTCTL_CLASS | ICC_LISTVIEW_CLASSES
    };

    InitCommonControlsEx(&initcomm);

    return TRUE;
}


//-----------------------------------------------------------------------
//check for the private key information
//-----------------------------------------------------------------------
BOOL  CheckPVKInfoNoDS(DWORD                                     /*dwFlags*/, 
		       DWORD                                     dwPvkChoice, 
		       PCCRYPTUI_WIZ_CERT_REQUEST_PVK_CERT       pCertRequestPvkContext,
		       PCCRYPTUI_WIZ_CERT_REQUEST_PVK_NEW        pCertRequestPvkNew,
		       PCCRYPTUI_WIZ_CERT_REQUEST_PVK_EXISTING   pCertRequestPvkExisting,
		       DWORD                                     dwCertChoice,
		       CERT_WIZARD_INFO                         *pCertWizardInfo,
		       CRYPT_KEY_PROV_INFO                     **ppKeyProvInfo)
{
    DWORD  cbData  = 0;
    BOOL   fResult = FALSE;

    pCertWizardInfo->fIgnore=FALSE;

    //check if we need to generate a new private key
    switch(dwPvkChoice)
    {
    case CRYPTUI_WIZ_CERT_REQUEST_PVK_CHOICE_CERT:

	if (sizeof(CRYPTUI_WIZ_CERT_REQUEST_PVK_CERT) != pCertRequestPvkContext->dwSize)
	    return FALSE;

	if(NULL==pCertRequestPvkContext->pCertContext)
	    return FALSE;

	//pCertContext should have a property of CRYPT_KEY_PROV_INFO
	if(!CertAllocAndGetCertificateContextProperty
	   (pCertRequestPvkContext->pCertContext,
	    CERT_KEY_PROV_INFO_PROP_ID,
	    (LPVOID *)ppKeyProvInfo,
	    &cbData))
	    goto CLEANUP; 

	pCertWizardInfo->fNewKey           = FALSE;
	pCertWizardInfo->dwProviderType    = (*ppKeyProvInfo)->dwProvType;
	pCertWizardInfo->pwszProvider      = (*ppKeyProvInfo)->pwszProvName;
	pCertWizardInfo->dwProviderFlags   = (*ppKeyProvInfo)->dwFlags;
	pCertWizardInfo->pwszKeyContainer  = (*ppKeyProvInfo)->pwszContainerName;
	pCertWizardInfo->dwKeySpec         = (*ppKeyProvInfo)->dwKeySpec;
	
	break;

    case CRYPTUI_WIZ_CERT_REQUEST_PVK_CHOICE_NEW:

	//check the size of the struct
	if(pCertRequestPvkNew->dwSize!=sizeof(CRYPTUI_WIZ_CERT_REQUEST_PVK_NEW))
	    goto CLEANUP;
	
	pCertWizardInfo->fNewKey=TRUE;
	
	//we only copy the information if:
	//1. Cert type is required
	//2. The CSP is specified
	if((CRYPTUI_WIZ_CERT_REQUEST_CERT_TYPE == dwCertChoice) || (0 == dwCertChoice))
	{
	    if(pCertRequestPvkNew->pKeyProvInfo)
	    {
		if( (0 == pCertRequestPvkNew->pKeyProvInfo->dwProvType) &&
		    (NULL == (LPWSTR)(pCertRequestPvkNew->pKeyProvInfo->pwszProvName))
		 )
		    pCertWizardInfo->fIgnore=TRUE;
	    }
	    else
		pCertWizardInfo->fIgnore=TRUE;
	}

	//see if pKeyProvInfo is not NULL
	if(pCertRequestPvkNew->pKeyProvInfo)
	{
	    if(TRUE == pCertWizardInfo->fIgnore)
	    {
		pCertWizardInfo->pwszKeyContainer   =pCertRequestPvkNew->pKeyProvInfo->pwszContainerName;
		pCertWizardInfo->dwProviderFlags    =pCertRequestPvkNew->pKeyProvInfo->dwFlags;
	    }
	    else
	    {
		pCertWizardInfo->dwProviderType     =pCertRequestPvkNew->pKeyProvInfo->dwProvType;
		pCertWizardInfo->pwszProvider       =(LPWSTR)(pCertRequestPvkNew->pKeyProvInfo->pwszProvName);
		pCertWizardInfo->dwProviderFlags    =pCertRequestPvkNew->pKeyProvInfo->dwFlags;
		pCertWizardInfo->pwszKeyContainer   =pCertRequestPvkNew->pKeyProvInfo->pwszContainerName;
		pCertWizardInfo->dwKeySpec          =pCertRequestPvkNew->pKeyProvInfo->dwKeySpec;
	    }
	}

	if(TRUE == pCertWizardInfo->fIgnore)
	    //we should ignore the exportable flag
	    pCertWizardInfo->dwGenKeyFlags=(pCertRequestPvkNew->dwGenKeyFlags & (~CRYPT_EXPORTABLE));
	else
	    pCertWizardInfo->dwGenKeyFlags=pCertRequestPvkNew->dwGenKeyFlags;
	
	
	break;
    case CRYPTUI_WIZ_CERT_REQUEST_PVK_CHOICE_EXISTING:
	//check the size of the struct
	if(pCertRequestPvkExisting->dwSize!=sizeof(CRYPTUI_WIZ_CERT_REQUEST_PVK_EXISTING))
	    goto CLEANUP;

	pCertWizardInfo->fNewKey=FALSE;

	//make sure pKeyProvInfo is not NULL
	if(NULL==pCertRequestPvkExisting->pKeyProvInfo)
	    goto CLEANUP;
	
	pCertWizardInfo->dwProviderType     =pCertRequestPvkExisting->pKeyProvInfo->dwProvType;
	pCertWizardInfo->pwszProvider       =(LPWSTR)(pCertRequestPvkExisting->pKeyProvInfo->pwszProvName);
	pCertWizardInfo->dwProviderFlags    =pCertRequestPvkExisting->pKeyProvInfo->dwFlags;
	pCertWizardInfo->pwszKeyContainer   =pCertRequestPvkExisting->pKeyProvInfo->pwszContainerName;
	pCertWizardInfo->dwKeySpec          =pCertRequestPvkExisting->pKeyProvInfo->dwKeySpec;
	break; 
	
    default:
	goto CLEANUP;
	break;
    }

    //for existing keys, keyContainer and providerType has to set
    if(FALSE==pCertWizardInfo->fNewKey)
    {
	if(NULL==pCertWizardInfo->pwszKeyContainer)
	    goto CLEANUP;

	if(0==pCertWizardInfo->dwProviderType)
	    goto CLEANUP;
   }

   //if the provider name is set, the provider type has to be set
   if(0 == pCertWizardInfo->dwProviderType)
   {
        if(pCertWizardInfo->pwszProvider)
            goto CLEANUP;
   }

   fResult=TRUE;

CLEANUP:

   if(FALSE==fResult)
   {
       if(*ppKeyProvInfo)
       {
           WizardFree(*ppKeyProvInfo);
           *ppKeyProvInfo=NULL;
       }
   }

   return fResult;

			 
}			 
			 
BOOL    CheckPVKInfo(   DWORD                       dwFlags,
                        PCCRYPTUI_WIZ_CERT_REQUEST_INFO  pCertRequestInfo,
                          CERT_WIZARD_INFO          *pCertWizardInfo,
                          CRYPT_KEY_PROV_INFO       **ppKeyProvInfo)
{
    if(NULL == pCertRequestInfo)
        return FALSE;

    return CheckPVKInfoNoDS
	(dwFlags, 
	 pCertRequestInfo->dwPvkChoice,
	 pCertRequestInfo->pPvkCert, 
	 pCertRequestInfo->pPvkNew, 
	 pCertRequestInfo->pPvkExisting, 
	 pCertRequestInfo->dwCertChoice,
	 pCertWizardInfo,
	 ppKeyProvInfo);
}



//-----------------------------------------------------------------------
// Reset properties on the old certiifcate to the new certificat context
//------------------------------------------------------------------------
void    ResetProperties(PCCERT_CONTEXT  pOldCertContext, PCCERT_CONTEXT pNewCertContext)
{

    DWORD   rgProperties[2]={CERT_FRIENDLY_NAME_PROP_ID,
                             CERT_DESCRIPTION_PROP_ID};

    DWORD   cbData=0;
    BYTE    *pbData=NULL;
    DWORD   dwCount=sizeof(rgProperties)/sizeof(rgProperties[0]);
    DWORD   dwIndex=0;

    if(NULL==pOldCertContext || NULL==pNewCertContext)
        return;

    //set the properies one at a time
    for(dwIndex=0; dwIndex<dwCount; dwIndex++)
    {
        if (CertAllocAndGetCertificateContextProperty
	    (pOldCertContext,
	     rgProperties[dwIndex],
	     (LPVOID *)&pbData, 
	     &cbData))
        {
	    CertSetCertificateContextProperty
		(pNewCertContext,	
		 rgProperties[dwIndex],	
		 0,
		 pbData);	
	}
	
	WizardFree(pbData);
	pbData=NULL;
    }

    if(pbData)
        WizardFree(pbData);

    return;

}

//-----------------------------------------------------------------------
// Private implementation of the message box
//------------------------------------------------------------------------
int I_MessageBox(
    HWND        hWnd,
    UINT        idsText,
    UINT        idsCaption,
    LPCWSTR     pwszCaption,
    UINT        uType
)
{

    WCHAR   wszText[MAX_STRING_SIZE];
    WCHAR   wszCaption[MAX_STRING_SIZE];
    UINT    intReturn=0;

    //get the caption string
    if(NULL == pwszCaption)
    {
        if(!LoadStringU(g_hmodThisDll, idsCaption, wszCaption, ARRAYSIZE(wszCaption)))
             return 0;

        pwszCaption = wszCaption;
    }

    //get the text string
    if(!LoadStringU(g_hmodThisDll, idsText, wszText, ARRAYSIZE(wszText)))
    {
        return 0;
    }

    intReturn=MessageBoxExW(hWnd, wszText, pwszCaption, uType, 0);

    return intReturn;

}
//-----------------------------------------------------------------------
//
// CodeToHR
//
//------------------------------------------------------------------------
HRESULT CodeToHR(HRESULT hr)
{
    if (S_OK != (DWORD) hr && S_FALSE != (DWORD) hr &&
	    (!FAILED(hr) || 0 == HRESULT_FACILITY(hr)))
    {
        hr = HRESULT_FROM_WIN32(hr);
	    if (0 == HRESULT_CODE(hr))
	    {
	        // A call failed without properly setting an error condition!
	        hr = E_UNEXPECTED;
	    }
    }
    return(hr);
}

//-----------------------------------------------------------------------
//
// CAUtilAddSMIME
//
//------------------------------------------------------------------------
BOOL CAUtilAddSMIME(DWORD              dwExtensions, 
                    PCERT_EXTENSIONS  *prgExtensions)
{
    BOOL               fSMIME   = FALSE;
    DWORD              dwIndex  = 0;
    DWORD              dwExt    = 0;
    PCERT_EXTENSION    pExt     = NULL;
    DWORD              cb       = 0;
    DWORD              dwUsage  = 0;
    
    CERT_ENHKEY_USAGE *pUsage   = NULL;
    
	for(dwIndex=0; dwIndex < dwExtensions; dwIndex++)
	{
		for(dwExt=0; dwExt < prgExtensions[dwIndex]->cExtension; dwExt++)
		{
			pExt=&(prgExtensions[dwIndex]->rgExtension[dwExt]);

			if(0==_stricmp(szOID_ENHANCED_KEY_USAGE, pExt->pszObjId))
			{
				if(!CryptDecodeObject(X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
									 X509_ENHANCED_KEY_USAGE,
									 pExt->Value.pbData,
									 pExt->Value.cbData,
									 0,
									 NULL,
									 &cb))
					goto CLEANUP;

				 pUsage=(CERT_ENHKEY_USAGE *)WizardAlloc(cb);
				 if(NULL==pUsage)
					 goto CLEANUP;

				if(!CryptDecodeObject(X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
									 X509_ENHANCED_KEY_USAGE,
									 pExt->Value.pbData,
									 pExt->Value.cbData,
									 0,
									 pUsage,
									 &cb))
					goto CLEANUP;

				for(dwUsage=0; dwUsage<pUsage->cUsageIdentifier; dwUsage++)
				{
					if(0==_stricmp(szOID_PKIX_KP_EMAIL_PROTECTION,
								pUsage->rgpszUsageIdentifier[dwUsage]))
					{
						fSMIME=TRUE;
						goto CLEANUP;
					}
				}

				if(pUsage)
				{
					WizardFree(pUsage);
					pUsage=NULL;
				}

			}
		}
	}

CLEANUP:

	if(pUsage)
		WizardFree(pUsage);

	return fSMIME;
}
//-----------------------------------------------------------------------
//
// The following are memory routines for certdg_c.c
//------------------------------------------------------------------------
void*
MIDL_user_allocate(size_t cb)
{
    return(WizardAlloc(cb));
}

void
MIDL_user_free(void *pb)
{
    WizardFree(pb);
}

//-----------------------------------------------------------------------
//
//	CanUse1024BitKey
//
//------------------------------------------------------------------------
BOOL	CanUse1024BitKey(DWORD		dwProvType,
						 LPCWSTR	pwszProvider,
						 DWORD		dwUserKeySpec)
{
	DWORD				dwKeySpec=0;
	DWORD				dwCSPCount=0;
	DWORD				dwIndex=0;
	LPWSTR				rgwszCSP[]={MS_DEF_PROV_W, 
									MS_ENHANCED_PROV_W, 
									MS_STRONG_PROV_W,
									MS_DEF_RSA_SCHANNEL_PROV_W,
									MS_DEF_DSS_PROV_W, 
									MS_DEF_DSS_DH_PROV_W,
									MS_ENH_DSS_DH_PROV_W, 
									MS_DEF_DH_SCHANNEL_PROV_W};
	DWORD				dwFlags=0;
	DWORD				cbSize=0;
    PROV_ENUMALGS_EX	paramData;
	DWORD				dwMin=0;
	DWORD				dwMax=0;

	HCRYPTPROV			hProv = NULL;

	//if dwProvType is 0, we are using the base provider, which supports
	//1024 bit in all key spec
	if(0 == dwProvType)
		return TRUE;

	if(pwszProvider)
	{
		dwCSPCount=sizeof(rgwszCSP)/sizeof(rgwszCSP[0]);

		for(dwIndex=0; dwIndex < dwCSPCount; dwIndex++)
		{
			if(0 == _wcsicmp(pwszProvider, rgwszCSP[dwIndex]))
				break;
		}

		if(dwIndex != dwCSPCount)
			return TRUE;
	}

	dwKeySpec=dwUserKeySpec;

	//xenroll uses AT_SIGNATURE as the default
	if(0 == dwKeySpec)
		dwKeySpec=AT_SIGNATURE;

	if(!CryptAcquireContextU(&hProv,
            NULL,
            pwszProvider,
            dwProvType,
            CRYPT_VERIFYCONTEXT))
		return FALSE;

	//get the max/min of key length for both signature and encryption
	dwFlags=CRYPT_FIRST;
	cbSize=sizeof(paramData);
	memset(&paramData, 0, sizeof(PROV_ENUMALGS_EX));

	while(CryptGetProvParam(
            hProv,
            PP_ENUMALGS_EX,
            (BYTE *) &paramData,
            &cbSize,
            dwFlags))
    {
		if(AT_SIGNATURE == dwKeySpec)
		{
			if (ALG_CLASS_SIGNATURE == GET_ALG_CLASS(paramData.aiAlgid))
			{
				dwMax = paramData.dwMaxLen;
				dwMin = paramData.dwMinLen;

				break;
			}
		}
		else
		{
			if(AT_KEYEXCHANGE == dwKeySpec)
			{
				if (ALG_CLASS_KEY_EXCHANGE == GET_ALG_CLASS(paramData.aiAlgid))
				{
					dwMax = paramData.dwMaxLen;
					dwMin = paramData.dwMinLen;

					break;
				}
			}
		}

		dwFlags=0;
		cbSize=sizeof(paramData);
		memset(&paramData, 0, sizeof(PROV_ENUMALGS_EX));
	}

	if(hProv)
		CryptReleaseContext(hProv, 0);

	if((1024 >= dwMin) && (1024 <= dwMax))
		return TRUE;

	return FALSE;

}

BOOL GetValidKeySizes  
    (IN  LPCWSTR  pwszProvider,
     IN  DWORD    dwProvType,
     IN  DWORD    dwUserKeySpec, 
     OUT DWORD *  pdwMinLen,
     OUT DWORD *  pdwMaxLen,
     OUT DWORD *  pdwInc)
{
    BOOL              fDone              =  FALSE; 
    BOOL              fFoundAlgorithm    =  FALSE; 
    BOOL              fResult            =  FALSE;
    DWORD             cbSize             =  0;
    DWORD             dwFlags            =  0;
    DWORD             dwParam            =  0; 
    HCRYPTPROV	      hProv              =  NULL;
    PROV_ENUMALGS_EX  paramData;


    if((NULL==pwszProvider) || (0 == dwProvType))
        goto InvalidArgError;

    if (!CryptAcquireContextU
	(&hProv,
	 NULL,
	 pwszProvider, 
	 dwProvType, 
	 CRYPT_VERIFYCONTEXT))
	goto CryptAcquireContextUError; 

    dwFlags = CRYPT_FIRST;
    cbSize  = sizeof(paramData);
    
    while((!fDone) && (!fFoundAlgorithm))
    {
	memset(&paramData, 0, sizeof(PROV_ENUMALGS_EX));
    
	// We're done searching if CryptGetProvParam fails. 
	fDone = !CryptGetProvParam
	    (hProv,
	     PP_ENUMALGS_EX,
	     (BYTE *) &paramData,
	     &cbSize,
	     dwFlags); 

	// We know we've found the algorithm we want if our key spec matches
	// the algorithmic class of the algorithm. 
	fFoundAlgorithm  = 
	    (ALG_CLASS_SIGNATURE == GET_ALG_CLASS(paramData.aiAlgid)) &&
	    (AT_SIGNATURE        == dwUserKeySpec);  

	fFoundAlgorithm |= 
	    (ALG_CLASS_KEY_EXCHANGE == GET_ALG_CLASS(paramData.aiAlgid)) &&
	    (AT_KEYEXCHANGE         == dwUserKeySpec); 

	// Don't want to keep enumerating the first element.  
	dwFlags &= ~CRYPT_FIRST; 
    }

    // Couldn't find an algorithm based on the keyspec
    if (fDone)
    { 
	goto ErrorReturn; 
    }

    // Ok, we've found the algorithm we're looking for, assign two of 
    // our out parameters. 
    *pdwMaxLen = paramData.dwMaxLen;
    *pdwMinLen = paramData.dwMinLen;

    // Now, find the increment.  
    dwParam = (AT_SIGNATURE == dwUserKeySpec) ? 
	PP_SIG_KEYSIZE_INC : PP_KEYX_KEYSIZE_INC; 
    cbSize  = sizeof(DWORD); 
    
    if (!CryptGetProvParam
	(hProv, 
	 dwParam, 
	 (BYTE *)pdwInc,         // Assigns final the out parameter
	 &cbSize, 
	 0))
	goto CryptGetProvParamError;

    fResult = TRUE; 
 ErrorReturn:
    if (NULL != hProv) { CryptReleaseContext(hProv, 0); }
    return fResult;

TRACE_ERROR(CryptAcquireContextUError);
TRACE_ERROR(CryptGetProvParamError);
SET_ERROR(InvalidArgError, E_INVALIDARG);
}


HRESULT WINAPI CreateRequest(DWORD                 dwFlags,         //IN  Required
			     DWORD                 dwPurpose,       //IN  Required: Whether it is enrollment or renew
			     LPWSTR                pwszCAName,      //IN  Required: 
			     LPWSTR                pwszCALocation,  //IN  Required: 
			     CERT_BLOB             *pCertBlob,      //IN  Required: The renewed certifcate
			     CERT_REQUEST_PVK_NEW  *pRenewKey,      //IN  Required: The private key on the certificate
			     BOOL                  fNewKey,         //IN  Required: Set the TRUE if new private key is needed
			     CERT_REQUEST_PVK_NEW  *pKeyNew,        //IN  Required: The private key information
			     LPWSTR                pwszHashAlg,     //IN  Optional: The hash algorithm
			     LPWSTR                pwszDesStore,    //IN  Optional: The destination store
			     DWORD                 dwStoreFlags,    //IN  Optional: The store flags
			     CERT_ENROLL_INFO     *pRequestInfo,    //IN  Required: The information about the cert request
			     HANDLE               *hRequest         //OUT Required: A handle to the PKCS10 request created
			     )
{

    BSTR                         bstrCA                 = NULL; 
    CRYPT_DATA_BLOB              descriptionBlob; 
    CRYPT_DATA_BLOB              friendlyNameBlob; 
    CRYPT_DATA_BLOB              hashBlob; 
    CRYPT_DATA_BLOB              RequestBlob;
    CRYPT_KEY_PROV_INFO          KeyProvInfo;
    DWORD                        dwIndex                = 0;
    DWORD                        dwCAAndRootStoreFlags; 
    HRESULT                      hr                     = E_FAIL;
    IEnroll4                    *pIEnroll               = NULL;
    LONG                         lRequestFlags          = 0; 
    LPWSTR                       pwszCA                 = NULL; 
    PCCERT_CONTEXT               pRenewCertContext      = NULL;
    PCCERT_CONTEXT               pArchivalCert          = NULL; 
    PCREATE_REQUEST_WIZARD_STATE pState                 = NULL; 
    PFNPIEnroll4GetNoCOM         pfnPIEnroll4GetNoCOM   = NULL;
    BOOL                         fV2TemplateRequest     = FALSE;


    //input param checking
    if(NULL == pKeyNew  || NULL == pRequestInfo || NULL == hRequest)
        return E_INVALIDARG;
    
    // Check for versioning errors: 
    if(pKeyNew->dwSize != sizeof(CERT_REQUEST_PVK_NEW) || pRequestInfo->dwSize != sizeof(CERT_ENROLL_INFO))
	return E_INVALIDARG;

    // Init: 
    memset(&descriptionBlob,     0,  sizeof(descriptionBlob)); 
    memset(&friendlyNameBlob,    0,  sizeof(friendlyNameBlob)); 
    memset(&RequestBlob,         0,  sizeof(RequestBlob)); 
    memset(&hashBlob,            0,  sizeof(hashBlob)); 

    //////////////////////////////////////////////////////////////
    // 
    // Acquire an IEnroll4 object.
    //
    //
    // 1) load the library "xEnroll.dll".
    //
    if(NULL==g_hmodxEnroll)
    {
        if(NULL==(g_hmodxEnroll=LoadLibrary("xenroll.dll")))
	    goto Win32Err; 
    }
    
    //
    // 2) Get a pointer to the function that returns an IEnroll 4 object
    //    without using COM. 
    //
    if(NULL==(pfnPIEnroll4GetNoCOM=(PFNPIEnroll4GetNoCOM)GetProcAddress(g_hmodxEnroll,
									"PIEnroll4GetNoCOM")))
        goto Win32Err; 
    
    //
    // 3) Get the IEnroll4 object: 
    //
    if(NULL==(pIEnroll=pfnPIEnroll4GetNoCOM()))
        goto GeneralErr; 

    //
    //////////////////////////////////////////////////////////////

    // Set the key size to the default, if it is not specified: 
    if(fNewKey)
    {
	//we set the default to 1024 is not specified by user
	if(0 == (0xFFFF0000 & pKeyNew->dwGenKeyFlags))
	{
	    if(CanUse1024BitKey(pKeyNew->dwProvType,
				pKeyNew->pwszProvider,
				pKeyNew->dwKeySpec))
	    {
		pKeyNew->dwGenKeyFlags=pKeyNew->dwGenKeyFlags | (1024 << 16); 
	    }
	}
    }	

    if(dwStoreFlags)
    {
        //we either open CA and Root on the local machine or the current user
        if(CERT_SYSTEM_STORE_CURRENT_USER != dwStoreFlags)
	    dwCAAndRootStoreFlags = CERT_SYSTEM_STORE_LOCAL_MACHINE;
	else
	    dwCAAndRootStoreFlags = dwStoreFlags; 
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //
    // Set XENROLL properties.   
    // The property corresponding to "Property Name" is set to "Property Value", IF "Condition" evaluates to TRUE: 
    //
    //                       Condition                  Property Name             Property Value
    //  -----------------------------------------------------------------------------------------------------------------------------------
    //

    _SET_XENROLL_PROPERTY_IF(dwStoreFlags,              CAStoreFlags,             dwCAAndRootStoreFlags);
    _SET_XENROLL_PROPERTY_IF(pKeyNew->pwszKeyContainer, ContainerNameWStr,        (LPWSTR)(pKeyNew->pwszKeyContainer)); 
    _SET_XENROLL_PROPERTY_IF(TRUE,                      EnableSMIMECapabilities,  pKeyNew->dwEnrollmentFlags & CT_FLAG_INCLUDE_SYMMETRIC_ALGORITHMS); 
    _SET_XENROLL_PROPERTY_IF(pwszHashAlg,               HashAlgorithmWStr,        pwszHashAlg); 
    _SET_XENROLL_PROPERTY_IF(TRUE, 	                GenKeyFlags,              pKeyNew->dwGenKeyFlags); 
    _SET_XENROLL_PROPERTY_IF(pKeyNew->dwKeySpec,        KeySpec,                  pKeyNew->dwKeySpec); 
    _SET_XENROLL_PROPERTY_IF(dwStoreFlags,              MyStoreFlags,             dwStoreFlags);
    _SET_XENROLL_PROPERTY_IF(pwszDesStore,              MyStoreNameWStr,          pwszDesStore); 
    _SET_XENROLL_PROPERTY_IF(pKeyNew->dwProviderFlags,  ProviderFlags,            pKeyNew->dwProviderFlags); 
    _SET_XENROLL_PROPERTY_IF(pKeyNew->dwProvType,       ProviderType,             pKeyNew->dwProvType);
    _SET_XENROLL_PROPERTY_IF(dwStoreFlags,              RootStoreFlags,           dwCAAndRootStoreFlags); 
    _SET_XENROLL_PROPERTY_IF(TRUE,                      UseExistingKeySet,        !fNewKey); 
    _SET_XENROLL_PROPERTY_IF(TRUE,                      WriteCertToUserDS,        pRequestInfo->dwPostOption & CRYPTUI_WIZ_CERT_REQUEST_POST_ON_DS); 

    _SET_XENROLL_PROPERTY_IF(pKeyNew->dwProvType && pKeyNew->pwszProvider,  ProviderNameWStr,                  (LPWSTR)(pKeyNew->pwszProvider));
    _SET_XENROLL_PROPERTY_IF(CRYPTUI_WIZ_NO_INSTALL_ROOT & dwFlags,         RootStoreNameWStr,                 L"CA"); 
    _SET_XENROLL_PROPERTY_IF(TRUE,                                          ReuseHardwareKeyIfUnableToGenNew,  0 == (dwFlags & CRYPTUI_WIZ_CERT_REQUEST_REQUIRE_NEW_KEY)); 

    //
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    //////////////////////////////////////////////////////////////
    // 
    // Perform remaining XENROLL configuration: 
    //
    // 1) Add the extensions to the certificate request
    //
    for(dwIndex=0; dwIndex < pRequestInfo->dwExtensions; dwIndex++)
    {
        if(NULL != pRequestInfo->prgExtensions[dwIndex])
        {
	        PCERT_EXTENSIONS prgExtensions = pRequestInfo->prgExtensions[dwIndex]; 
	    
	        for (DWORD dwIndex2 = 0; dwIndex2 < prgExtensions->cExtension; dwIndex2++)
	        {
		        CERT_EXTENSION certExtension = prgExtensions->rgExtension[dwIndex2]; 
		        LPWSTR         pwszName      = NULL;

                if(FALSE == fV2TemplateRequest)
                {
                    if(0 == _stricmp(szOID_CERTIFICATE_TEMPLATE, certExtension.pszObjId))
                        fV2TemplateRequest = TRUE;
                }

		        if (S_OK != (hr = WizardSZToWSZ(certExtension.pszObjId, &pwszName)))
		            goto ErrorReturn; 

		        hr = pIEnroll->addExtensionToRequestWStr
		            (certExtension.fCritical,
		             pwszName, 
		             &(certExtension.Value));

		        // Make sure we always free pwszName.  
		        if (NULL != pwszName) { WizardFree(pwszName); } 

		        if (S_OK != hr) 
		            goto xEnrollErr; 
	        }
	    }
    }

    //
    // 2) Set the key archival certificate, if requested by the cert template.
    //
    if (pKeyNew->dwPrivateKeyFlags & CT_FLAG_ALLOW_PRIVATE_KEY_ARCHIVAL)
    {
	if (NULL == pwszCAName || NULL == pwszCALocation)
	    goto InvalidArgErr; 

	LPWSTR rgwszStrsToConcat[] = { pwszCALocation, L"\\", pwszCAName } ; 

	pwszCA = WizardAllocAndConcatStrsU(rgwszStrsToConcat, 3); 
	if (NULL == pwszCA)
	    goto MemoryErr; 

	bstrCA = SysAllocString(pwszCA); 
    	if (NULL == bstrCA)
	    goto MemoryErr; 

	// Cert type specifies key archival.  
	if (S_OK != (hr = GetCAExchangeCertificate(bstrCA, &pArchivalCert)))
	    goto xEnrollErr; 
	
	if (S_OK != (hr = pIEnroll->SetPrivateKeyArchiveCertificate(pArchivalCert)))
	    goto xEnrollErr; 
    }
    
    //
    // 3) If renewing, do the requisite extra work...
    //
    if(CRYPTUI_WIZ_CERT_RENEW & dwPurpose)
    {
        if(NULL == pCertBlob || NULL == pRenewKey)
            goto InvalidArgErr;  

        //create a certificate context
        pRenewCertContext=CertCreateCertificateContext(
            X509_ASN_ENCODING,
            pCertBlob->pbData,
            pCertBlob->cbData);
        if(NULL == pRenewCertContext)
            goto CertCliErr; 

        //set the property for keyProvInfo
        memset(&KeyProvInfo, 0, sizeof(CRYPT_KEY_PROV_INFO));

        KeyProvInfo.dwProvType=pRenewKey->dwProvType;
        KeyProvInfo.pwszProvName=(LPWSTR)(pRenewKey->pwszProvider);
        KeyProvInfo.dwFlags=pRenewKey->dwProviderFlags;
        KeyProvInfo.pwszContainerName=(LPWSTR)(pRenewKey->pwszKeyContainer);
        KeyProvInfo.dwKeySpec=pRenewKey->dwKeySpec;

        CertSetCertificateContextProperty(
            pRenewCertContext,	
            CERT_KEY_PROV_INFO_PROP_ID,	
            0,	
            &KeyProvInfo);

        //set the RenewCertContext
        if (0 == (dwFlags & CRYPTUI_WIZ_NO_ARCHIVE_RENEW_CERT))
        {
            if (S_OK !=(hr=pIEnroll->put_RenewalCertificate(pRenewCertContext)))
                goto xEnrollErr; 
        }
        else
        {
            // we add the signing certificate
            if(S_OK != (hr = pIEnroll->SetSignerCertificate(pRenewCertContext)))
                goto xEnrollErr; 
        }
   }

    // Add certificate context properties to the request: 

    // 1) Add the friendly name property
    if (NULL != pRequestInfo->pwszFriendlyName) 
    {
        friendlyNameBlob.cbData = sizeof(WCHAR) * (wcslen(pRequestInfo->pwszFriendlyName) + 1); 
        friendlyNameBlob.pbData = (LPBYTE)WizardAllocAndCopyWStr((LPWSTR)pRequestInfo->pwszFriendlyName); 
        if (NULL == friendlyNameBlob.pbData)
            goto MemoryErr; 

        if (S_OK != (hr = pIEnroll-> addBlobPropertyToCertificateWStr
                     (CERT_FRIENDLY_NAME_PROP_ID, 
                      0,
                      &friendlyNameBlob)))
            goto xEnrollErr;
    }

    // 2) Add the description property
    if (NULL != pRequestInfo->pwszDescription)
    {
        descriptionBlob.cbData = sizeof(WCHAR) * (wcslen(pRequestInfo->pwszDescription) + 1); 
        descriptionBlob.pbData = (LPBYTE)WizardAllocAndCopyWStr((LPWSTR)pRequestInfo->pwszDescription); 
        if (NULL == descriptionBlob.pbData)
            goto MemoryErr; 

        if (S_OK != (hr = pIEnroll-> addBlobPropertyToCertificateWStr
                     (CERT_DESCRIPTION_PROP_ID, 
                      0,
                      &descriptionBlob)))
            goto xEnrollErr;
    }
      
    //////////////////////////////////////////////////////////////////////////////////
    //
    // At last, generate the request, and assign the out parameters:
    //
    
    //
    // 1) Create the request.  For V2 template, use CMC.  
    //    For V1 template, use a PKCS7 for renewal, and PKCS10 for enrollment.  
    //
    
    { 
        if(TRUE == fV2TemplateRequest)
        {
            lRequestFlags = XECR_CMC;
        }
        else
        {
            if (CRYPTUI_WIZ_CERT_RENEW & dwPurpose)
            {
                // We're renewing:  use PKCS7.
                lRequestFlags = XECR_PKCS7; 
            }
            else
            {
                // Enrolling with no PVK archival support:  use PKCS10. 
                lRequestFlags = XECR_PKCS10_V2_0; 
            }
        }
	
        if (FAILED(hr=pIEnroll->createRequestWStr
                   (lRequestFlags, 
                    pRequestInfo->pwszCertDNName, //L"CN=Test Certificate",
                    pRequestInfo->pwszUsageOID,   //pwszUsage
                    &RequestBlob)))
            goto xEnrollErr; 
    }
    //
    // 2) Get the HASH of the request so we can supply it to xenroll when we submit:
    //
    { 
	pState = (PCREATE_REQUEST_WIZARD_STATE)WizardAlloc(sizeof(CREATE_REQUEST_WIZARD_STATE));
	if (pState == NULL)
	    goto MemoryErr; 

	if (S_OK != (hr = pIEnroll->get_ThumbPrintWStr(&hashBlob)))
	    goto xEnrollErr; 
	    
	hashBlob.pbData = (LPBYTE)WizardAlloc(hashBlob.cbData); 
	if (NULL == hashBlob.pbData)
	    goto MemoryErr; 

	if (S_OK != (hr = pIEnroll->get_ThumbPrintWStr(&hashBlob)))
	    goto xEnrollErr;

	// 
	// 3) Create a blob to assign our OUT parameter to. 
	//    This blob preserves state from the call of CreateRequest() to the call 
	//    of SubmitRequest()
	//

        pState->fMustFreeRequestBlob = TRUE; 
	pState->RequestBlob          = RequestBlob; 
	pState->HashBlob             = hashBlob; 

	// Persist certificate store information: 
	pState->dwMyStoreFlags    = dwStoreFlags; 
	pState->dwRootStoreFlags  = dwCAAndRootStoreFlags; 

	pState->pwszMyStoreName   = NULL == pwszDesStore ? NULL : WizardAllocAndCopyWStr(pwszDesStore); 
	_JumpCondition(NULL != pwszDesStore && NULL == pState->pwszMyStoreName, MemoryErr); 

	pState->pwszRootStoreName = CRYPTUI_WIZ_NO_INSTALL_ROOT & dwFlags ? L"CA" : NULL; 

	// Persist the request type: 
	pState->lRequestFlags     = lRequestFlags; 

        // Persist status information:  did we need to reuse the private key?
        hr = pIEnroll->get_UseExistingKeySet(&pState->fReusedPrivateKey); 
        if (FAILED(hr))
            goto xEnrollErr; 

	pState->fNewKey = fNewKey; 

	//
	// 4) Assign cast the request to a handle and return it:
	//
	*hRequest = (HANDLE)pState; 
    }
	
    //
    //////////////////////////////////////////////////////////////////////////////////

    // We're done!
    hr = S_OK;
 CommonReturn: 
    if (NULL != bstrCA)                   { SysFreeString(bstrCA); } 
    if (NULL != pArchivalCert)            { CertFreeCertificateContext(pArchivalCert); } 
    if (NULL != pIEnroll)                 { pIEnroll->Release(); } 
    if (NULL != pRenewCertContext)        { CertFreeCertificateContext(pRenewCertContext); } 
    if (NULL != pwszCA)                   { WizardFree(pwszCA); } 
    if (NULL != descriptionBlob.pbData)   { WizardFree(descriptionBlob.pbData); }
    if (NULL != friendlyNameBlob.pbData)  { WizardFree(friendlyNameBlob.pbData); }

    //return values
    return hr;

 ErrorReturn:
    if(NULL != RequestBlob.pbData) 
    {
        // NOTE: pIEnroll can not be NULL because it is used to allocate RequestBlob
        pIEnroll->freeRequestInfoBlob(RequestBlob); 
        // This memory is from xenroll:  must use LocalFree(). 
        LocalFree(RequestBlob.pbData);
    } 

    if (NULL != pState)
    {
	WizardFree(pState); 
    }

    if (NULL != hashBlob.pbData)
    {
	WizardFree(hashBlob.pbData); 
    }
    goto CommonReturn; 


SET_HRESULT(CertCliErr,    CodeToHR(GetLastError()));
SET_HRESULT(GeneralErr,    E_FAIL);
SET_HRESULT(InvalidArgErr, E_INVALIDARG); 
SET_HRESULT(MemoryErr,     E_OUTOFMEMORY); 
SET_HRESULT(xEnrollErr,    hr);
SET_HRESULT(Win32Err,      CodeToHR(GetLastError())); 
}


BSTR
GetClientAttribs()
{
    HRESULT hr;
    DOMAIN_CONTROLLER_INFO *pDomainInfo = NULL;
    BSTR strAttr = NULL;
    WCHAR const *pwszDC = NULL;
    DWORD cwc;
    DWORD cwcDNS;

    hr = DsGetDcName(
		NULL,
		NULL,
		NULL,
		NULL,
		DS_RETURN_DNS_NAME,
		&pDomainInfo);
    if (S_OK == hr)
    {
	pwszDC = pDomainInfo->DomainControllerName;
	while (L'\\' == *pwszDC)
	{
	    pwszDC++;
	}
    }

    cwcDNS = 0;
    if (!GetComputerNameExW(ComputerNameDnsFullyQualified, NULL, &cwcDNS))
    {
	hr = GetLastError();
	if ((HRESULT) ERROR_MORE_DATA != hr)
	{
	    cwcDNS = 0;
	}
    }
    else
    {
	cwcDNS++;
    }

    cwc = 0;
    if (NULL != pwszDC)
    {
	cwc += wcslen(wszPROPCLIENTDCDNS) + 1 + wcslen(pwszDC);
    }
    if (0 != cwcDNS)
    {
	if (NULL != pwszDC)
	{
	    cwc++;
	}

	// cwcDNS includes the trailing NULL WCHAR, cwc should not.

	cwc += wcslen(wszPROPREQUESTMACHINEDNS) + 1 + cwcDNS - 1;
    }
    if (0 == cwc)
    {
	goto error;
    }
    strAttr = SysAllocStringLen(NULL, cwc);
    if (NULL == strAttr)
    {
	hr = E_OUTOFMEMORY;
	goto error;
    }
    strAttr[0] = L'\0';
    if (NULL != pwszDC)
    {
	wcscat(strAttr, wszPROPCLIENTDCDNS L":");
	wcscat(strAttr, pwszDC);
    }
    if (0 != cwcDNS)
    {
	WCHAR *pwszTruncate = &strAttr[wcslen(strAttr)];
	WCHAR *pwsz;
	
	if (NULL != pwszDC)
	{
	    wcscat(strAttr, L"\n");
	}
	wcscat(strAttr, wszPROPREQUESTMACHINEDNS L":");
	pwsz = &strAttr[wcslen(strAttr)];
	if (!GetComputerNameExW(ComputerNameDnsFullyQualified, pwsz, &cwcDNS))
	{
	    hr = GetLastError();
	}
	else
	{
	    pwszTruncate = &pwsz[cwcDNS];
	}
	assert(pwszTruncate <= &strAttr[cwc]);
	*pwszTruncate = L'\0';
    }
    assert(wcslen(strAttr) == cwc);
    assert(SysStringLen(strAttr) == cwc);
    hr = S_OK;

error:
    if (NULL != pDomainInfo)
    {
        NetApiBufferFree(pDomainInfo);
    }
    return(strAttr);
}


HRESULT WINAPI SubmitRequest(IN   HANDLE                hRequest, 
			     IN   BOOL                  fKeyService,     //IN Required: Whether the function is called remotely
			     IN   DWORD                 /*dwPurpose*/,               //IN deprecated: we don't use purpose during submit anymore
			     IN   BOOL                  /*fConfirmation*/,           //IN deprecated: we no longer have a confirmation dialog
			     IN   HWND                  /*hwndParent*/,              //IN deprecated: we no longer have a confirmation dialog
			     IN   LPWSTR                /*pwszConfirmationTitle*/,   //IN deprecated: we no longer have a confirmation dialog
			     IN   UINT                  /*idsConfirmTitle*/,         //IN deprecated: we no longer have a confirmation dialog
			     IN   LPWSTR                pwszCALocation,  //IN Required: The ca machine name
			     IN   LPWSTR                pwszCAName,      //IN Required: The ca name
			     IN   LPWSTR                pwszCADisplayName, // IN Optional:  The display name of the CA.  
			     OUT  CERT_BLOB            *pPKCS7Blob,      //OUT Optional: The PKCS7 from the CA
			     OUT  CERT_BLOB            *pHashBlob,       //OUT Optioanl: The SHA1 hash of the enrolled/renewed certificate
			     OUT  DWORD                *pdwDisposition,  //OUT Optional: The status of the enrollment/renewal
			     OUT  PCCERT_CONTEXT       *ppCertContext    //OUT Optional: The enrolled certificate
			     )
{
    BOOL                         fNewKey; 
    BSTR                         bstrAttribs           = NULL;    // Always NULL. 
    BSTR                         bstrCA                = NULL;    // "CA Location\CA Name"
    BSTR                         bstrCMC               = NULL;    // BSTR representation of the CMC certificate. 
    BSTR                         bstrPKCS7             = NULL;    // BSTR representation of the PKCS7 certificate. 
    BSTR                         bstrReq               = NULL;    // BSTR representation of the PKCS10 request. 
    CRYPT_DATA_BLOB              CMCBlob;                         // CMC encoded issued certificate. 
    CRYPT_DATA_BLOB              HashBlob; 
    CRYPT_DATA_BLOB              PKCS7Blob;                       // PKCS7 encoded issued certificate. 
    CRYPT_DATA_BLOB              PropertyBlob;                    // Temporary variable. 
    CRYPT_DATA_BLOB              RequestBlob; 
    DWORD                        dwRequestID;                     // The request ID of the submitted request. 
    DWORD                        dwDisposition;                   // The disposition of the submitted request. 
    DWORD                        dwMyStoreFlags        = 0; 
    DWORD                        dwRootStoreFlags      = 0;

    // BUGBUG:  need to use global enrollment factory. 
    EnrollmentCOMObjectFactory  *pEnrollFactory        = NULL; 
    HRESULT                      hr                    = E_FAIL;  // Return code. 
    ICertRequest2               *pICertRequest         = NULL;    // Used to submit request to CA. 
    IEnroll4                    *pIEnroll              = NULL;    // Used to install issued certificate.  
    LONG                         lRequestFlags         = 0; 
    LPWSTR                       pwszCA                = NULL;    // "CA Location\CA Name" 
    LPWSTR                       pwszMyStoreName       = NULL;
    LPWSTR                       pwszRootStoreName     = NULL; 
    PCCERT_CONTEXT               pCertContext          = NULL;    // The (hopefully) issued certificate. 
    PCREATE_REQUEST_WIZARD_STATE pState                = NULL; 
    PFNPIEnroll4GetNoCOM         pfnPIEnroll4GetNoCOM  = NULL;    // Function that acquires an IEnroll4 object without using COM. 
    VARIANT                      varCMC; 

    LocalScope(SubmitRequestHelper): 
	DWORD ICEnrollDispositionToCryptUIStatus(DWORD dwDisposition)
	{
	    switch (dwDisposition) 
	    { 
	    case CR_DISP_INCOMPLETE:          return CRYPTUI_WIZ_CERT_REQUEST_STATUS_REQUEST_ERROR;
	    case CR_DISP_ERROR:               return CRYPTUI_WIZ_CERT_REQUEST_STATUS_REQUEST_ERROR; 
	    case CR_DISP_DENIED:              return CRYPTUI_WIZ_CERT_REQUEST_STATUS_REQUEST_DENIED;
	    case CR_DISP_ISSUED_OUT_OF_BAND:  return CRYPTUI_WIZ_CERT_REQUEST_STATUS_ISSUED_SEPARATELY;
	    case CR_DISP_UNDER_SUBMISSION:    return CRYPTUI_WIZ_CERT_REQUEST_STATUS_UNDER_SUBMISSION; 
	    case CR_DISP_ISSUED:              return CRYPTUI_WIZ_CERT_REQUEST_STATUS_SUCCEEDED;
	    default: 
		// Something's wrong. 
		return CRYPTUI_WIZ_CERT_REQUEST_STATUS_REQUEST_ERROR; 
	    }
	}
    EndLocalScope; 

    // Input Validation: 
    if (NULL == pwszCALocation || NULL == pwszCAName || NULL == hRequest)
	return E_INVALIDARG;

    // Initialization: 
    if (NULL != pPKCS7Blob)
        memset(pPKCS7Blob, 0, sizeof(CERT_BLOB));

    if (NULL != pHashBlob)
        memset(pHashBlob, 0, sizeof(CERT_BLOB));

    if (NULL != ppCertContext)
        *ppCertContext=NULL;

    memset(&CMCBlob, 0, sizeof(CRYPT_DATA_BLOB));
    memset(&PKCS7Blob, 0, sizeof(CRYPT_DATA_BLOB));
    memset(&PropertyBlob, 0, sizeof(CRYPT_DATA_BLOB));
    VariantInit(&varCMC); 

    dwDisposition  = CRYPTUI_WIZ_CERT_REQUEST_STATUS_UNKNOWN; 

    // We're using a COM component in this method.  It's absolutely necessary that we
    // uninitialize COM before we return, because we're running in an RPC thread, 
    // and failing to uninitialize COM will cause us to step on RPC's toes.  
    // 
    // See BUG 404778. 
    pEnrollFactory = new EnrollmentCOMObjectFactory; 
    if (NULL == pEnrollFactory)
	goto MemoryErr;
    
    __try { 
	//////////////////////////////////////////////////////////////    
	// 
	// Extract the data we need from the IN handle. 
	//
    
	pState             = (PCREATE_REQUEST_WIZARD_STATE)hRequest; 
	RequestBlob        = pState->RequestBlob; 
	HashBlob           = pState->HashBlob; 
	dwMyStoreFlags     = pState->dwMyStoreFlags;
	dwRootStoreFlags   = pState->dwRootStoreFlags;
	pwszMyStoreName    = pState->pwszMyStoreName; 
	pwszRootStoreName  = pState->pwszRootStoreName; 
	fNewKey            = pState->fNewKey; 

	lRequestFlags = CR_IN_BINARY; 
	switch (pState->lRequestFlags)
	{
	    case XECR_PKCS10_V2_0:   lRequestFlags |= CR_IN_PKCS10; break;
	    case XECR_PKCS7:         lRequestFlags |= CR_IN_PKCS7;  break;
	    case XECR_CMC:           lRequestFlags |= CR_IN_CMC;    break; 
	    default:
		goto InvalidArgErr; 
	}

	//////////////////////////////////////////////////////////////
	// 
	// Acquire an IEnroll4 object.
	//
	//
	// 1) load the library "xEnroll.dll".
	//
	if(NULL==g_hmodxEnroll)
	{
	    if(NULL==(g_hmodxEnroll=LoadLibrary("xenroll.dll")))
		goto Win32Err; 
	}
	
	//
	// 2) Get a pointer to the function that returns an IEnroll 4 object
	//    without using COM. 
	//
	if(NULL==(pfnPIEnroll4GetNoCOM=(PFNPIEnroll4GetNoCOM)GetProcAddress(g_hmodxEnroll,
									    "PIEnroll4GetNoCOM")))
	    goto Win32Err; 
    
	//
	// 3) Get the IEnroll4 object: 
	//
	if(NULL==(pIEnroll=pfnPIEnroll4GetNoCOM()))
	    goto GeneralErr; 

	//
	// 4) Set the pending request to use: 
	//
	if (S_OK != (hr = pIEnroll->put_ThumbPrintWStr(HashBlob)))
	    goto xEnrollErr; 
	
	// 5) Restore the old certificate store information: 
	_SET_XENROLL_PROPERTY_IF(dwMyStoreFlags,     MyStoreFlags,       dwMyStoreFlags);
	_SET_XENROLL_PROPERTY_IF(pwszMyStoreName,    MyStoreNameWStr,    pwszMyStoreName); 
	_SET_XENROLL_PROPERTY_IF(dwRootStoreFlags,   RootStoreFlags,     dwRootStoreFlags);
	_SET_XENROLL_PROPERTY_IF(pwszRootStoreName,  RootStoreNameWStr,  pwszRootStoreName); 
	_SET_XENROLL_PROPERTY_IF(TRUE,               UseExistingKeySet,  !fNewKey); 

	//
	//////////////////////////////////////////////////////////////
	
	// Convert request blob to a BSTR: 
	bstrReq = SysAllocStringByteLen((LPCSTR)RequestBlob.pbData, RequestBlob.cbData);
	if (NULL == bstrReq)
	    goto MemoryErr; 

	bstrAttribs = GetClientAttribs();

	// Acquire and use an ICertRequest2 object to submit the request to the CA: 
	if (pICertRequest == NULL)
	{
	    if (S_OK != (hr = pEnrollFactory->getICertRequest2(&pICertRequest)))
		goto ErrorReturn; 
	}

	// bstrCA <-- pwszCALocation\pwszCAName
	{ 
	    LPWSTR rgwszStrsToConcat[] = { pwszCALocation, L"\\", pwszCAName } ; 
	    pwszCA = WizardAllocAndConcatStrsU(rgwszStrsToConcat, 3); 
	    if (NULL == pwszCA)
		goto MemoryErr; 
	}
	
	bstrCA = SysAllocString(pwszCA); 
	if (NULL == bstrCA)
	    goto MemoryErr; 

	hr = pICertRequest->Submit
	    (lRequestFlags, 
	     bstrReq, 
	     bstrAttribs, 
	     bstrCA, 
	     (long *)&dwDisposition); 

	dwDisposition = local.ICEnrollDispositionToCryptUIStatus(dwDisposition);     
	_JumpCondition(S_OK != hr, ErrorReturn); 

	// Deal with the possible status codes we could've encountered: 
	switch (dwDisposition)
	{
	    case CRYPTUI_WIZ_CERT_REQUEST_STATUS_CONNECTION_FAILED:
	    case CRYPTUI_WIZ_CERT_REQUEST_STATUS_REQUEST_ERROR: 
	    case CRYPTUI_WIZ_CERT_REQUEST_STATUS_REQUEST_DENIED:
	    case CRYPTUI_WIZ_CERT_REQUEST_STATUS_ISSUED_SEPARATELY:
		if (S_OK == hr) 
		{
		    pICertRequest->GetLastStatus((LONG *)&hr);
		    if(!FAILED(hr))
			hr=E_FAIL;
		}
		
		goto ErrorReturn; 

	    case CRYPTUI_WIZ_CERT_REQUEST_STATUS_UNDER_SUBMISSION:
		// The certificate request has pended.  Set the pending request info.

		if (S_OK != (hr = pICertRequest->GetRequestId((long *)&dwRequestID)))
		    goto ErrorReturn; 

		if (S_OK != (hr = pIEnroll->setPendingRequestInfoWStr
			     (dwRequestID, 
			      pwszCALocation, 
			      pwszCAName, 
			      NULL)))
		    goto setPendingRequestInfoWStrError; 

		// The request has pended, we don't need to delete it from the request store... 
		pState->fMustFreeRequestBlob = FALSE;

		goto CommonReturn; 
	    case CRYPTUI_WIZ_CERT_REQUEST_STATUS_SUCCEEDED:
		// 4) Success!  Continue processing... 
		break; 
	default: 
	    // 5) Invalid error code: 
	    goto UnexpectedErr;
	}


	if (S_OK != (hr = pICertRequest->GetFullResponseProperty(FR_PROP_FULLRESPONSE, 0, PROPTYPE_BINARY, CR_OUT_BINARY, &varCMC)))
	    goto ErrorReturn; 
	
	// Check to make sure we've gotten a BSTR back: 
	if (VT_BSTR != varCMC.vt) 
	{
	    dwDisposition = CRYPTUI_WIZ_CERT_REQUEST_STATUS_INSTALL_FAILED; 
	    hr = HRESULT_FROM_WIN32(ERROR_BAD_FORMAT);
	    goto ErrorReturn; 
	}
	bstrCMC = varCMC.bstrVal; 
	
	// Marshal the cert into a CRYPT_DATA_BLOB:
	CMCBlob.pbData = (LPBYTE)bstrCMC; 
	CMCBlob.cbData = SysStringByteLen(bstrCMC); 
     
	if (S_OK != (hr = pIEnroll->getCertContextFromResponseBlob(&CMCBlob, &pCertContext)))
	{
	    dwDisposition = CRYPTUI_WIZ_CERT_REQUEST_STATUS_INSTALL_FAILED; 
	    goto ErrorReturn; 
	}
	
	// Install the certificate, and delete the request from the request store. 
	if(S_OK !=(hr=pIEnroll->acceptResponseBlob(&CMCBlob)))
	{
	    dwDisposition = CRYPTUI_WIZ_CERT_REQUEST_STATUS_INSTALL_FAILED; 
	    goto xEnrollErr; 
	}
	
	// acceptPKCS7Blob cleans up the request store for us ... we don't need to 
	// do this explicitly anyone. 
	pState->fMustFreeRequestBlob = FALSE; 
    

	////////////////////////////////////////////////////////////////////////////////
	//
	// Assign the OUT parameters: 
	//
	//
	// 1) Assign the PKCS7 Blob to the OUT PKCS7 blob: 
	// 
	
	if(NULL != pPKCS7Blob)
	{
	    // Get a PKCS7 Blob to return to the client: 
	    if (S_OK != (hr = pICertRequest->GetCertificate(CR_OUT_BINARY | CR_OUT_CHAIN, &bstrPKCS7)))
		goto ErrorReturn; 
	    
	    // Marshal the cert into a CRYPT_DATA_BLOB:
	    PKCS7Blob.pbData = (LPBYTE)bstrPKCS7; 
	    PKCS7Blob.cbData = SysStringByteLen(bstrPKCS7); 
		
	    pPKCS7Blob->pbData=(BYTE *)WizardAlloc(PKCS7Blob.cbData);
	    
	    if(NULL==(pPKCS7Blob->pbData))
	    {
		dwDisposition = CRYPTUI_WIZ_CERT_REQUEST_STATUS_INSTALL_FAILED;
		goto MemoryErr; 
	    }
	    
	    memcpy(pPKCS7Blob->pbData, PKCS7Blob.pbData,PKCS7Blob.cbData);
	    pPKCS7Blob->cbData=PKCS7Blob.cbData;
	}
	
	//
	// 2) Assign the SHA1 hash blob of the cert to the OUT hashblob. 
	//

	if(NULL != pHashBlob)
	{
	    if(!CertAllocAndGetCertificateContextProperty(
							  pCertContext,	
							  CERT_SHA1_HASH_PROP_ID,	
							  (LPVOID *)&(pHashBlob->pbData),	
							  &(pHashBlob->cbData)))
	    {
		dwDisposition = CRYPTUI_WIZ_CERT_REQUEST_STATUS_INSTALL_FAILED; 
		goto CertCliErr; 
	    }
	}
	
	// 
	// 3) Return the certificate context on the local case
	// 

	if((NULL != ppCertContext) && !fKeyService)
	{
	    *ppCertContext = CertDuplicateCertificateContext(pCertContext);
	}
	
	//
	////////////////////////////////////////////////////////////////////////////////

    } __except (EXCEPTION_EXECUTE_HANDLER) { 
	hr = GetExceptionCode();
	goto ErrorReturn; 
    }

    dwDisposition = CRYPTUI_WIZ_CERT_REQUEST_STATUS_SUCCEEDED; 
    hr=S_OK;

 CommonReturn: 
    if (NULL != bstrCA)             { SysFreeString(bstrCA); } 
    if (NULL != bstrAttribs)        { SysFreeString(bstrAttribs); } 
    if (NULL != bstrReq)            { SysFreeString(bstrReq); } 
    if (NULL != pICertRequest)      { pICertRequest->Release(); } 
    if (NULL != bstrCMC)            { SysFreeString(bstrCMC); }
    if (NULL != bstrPKCS7)          { SysFreeString(bstrPKCS7); }
    if (NULL != pEnrollFactory)     { delete pEnrollFactory; }
    if (NULL != pIEnroll)           { pIEnroll->Release(); } 
    if (NULL != pwszCA)             { WizardFree(pwszCA); }
    if (NULL != pCertContext)       { CertFreeCertificateContext(pCertContext); } 

    // PKCS7Blob.pbData is aliased to bstrCertificate.  Just NULL it out: 
    PKCS7Blob.pbData = NULL; 

    // Always return a status code:
    if (NULL != pdwDisposition) { *pdwDisposition = dwDisposition; } 

    return hr;

 ErrorReturn: 
    //free the output parameter
    if (NULL != pPKCS7Blob && NULL != pPKCS7Blob->pbData)
    {
	WizardFree(pPKCS7Blob->pbData);
	memset(pPKCS7Blob, 0, sizeof(CERT_BLOB));
    }
    
    //free the output parameter
    if (NULL != pHashBlob  && NULL != pHashBlob->pbData)
    {
	WizardFree(pHashBlob->pbData);
	memset(pHashBlob, 0, sizeof(CERT_BLOB));
    }

    if (NULL != ppCertContext && NULL != *ppCertContext) { CertFreeCertificateContext(*ppCertContext); } 
    
    goto CommonReturn; 

SET_HRESULT(CertCliErr,                      CodeToHR(GetLastError()));
SET_HRESULT(GeneralErr,                      E_FAIL);
SET_HRESULT(InvalidArgErr,                   E_INVALIDARG);
SET_HRESULT(MemoryErr,                       E_OUTOFMEMORY); 
SET_HRESULT(setPendingRequestInfoWStrError,  hr); 
SET_HRESULT(UnexpectedErr,                   E_UNEXPECTED);
SET_HRESULT(xEnrollErr,                      hr);
SET_HRESULT(Win32Err,                        CodeToHR(GetLastError())); 
}

BOOL WINAPI QueryRequest(IN HANDLE hRequest, OUT CRYPTUI_WIZ_QUERY_CERT_REQUEST_INFO *pQueryInfo)
{
    BOOL                                  fResult; 
    CREATE_REQUEST_WIZARD_STATE          *pState;
    CRYPTUI_WIZ_QUERY_CERT_REQUEST_INFO   QueryInfo; 

    memset(&QueryInfo, 0, sizeof(QueryInfo)); 

    pState = (CREATE_REQUEST_WIZARD_STATE *)hRequest; 
    QueryInfo.dwSize    = sizeof(QueryInfo); 
    QueryInfo.dwStatus  = (pState->fReusedPrivateKey) ? CRYPTUI_WIZ_QUERY_CERT_REQUEST_STATUS_CREATE_REUSED_PRIVATE_KEY : 0; 

    *pQueryInfo = QueryInfo; 
    fResult = TRUE;
    //  CommonReturn:
    return fResult; 
}

void WINAPI FreeRequest(IN HANDLE hRequest)
{
    IEnroll4                      *pIEnroll              = NULL;    
    PCREATE_REQUEST_WIZARD_STATE   pState                = NULL;
    PFNPIEnroll4GetNoCOM           pfnPIEnroll4GetNoCOM  = NULL;

    if (NULL == hRequest)
	return;  // Nothing to free!

    pState = (PCREATE_REQUEST_WIZARD_STATE)hRequest; 

    // Make our best effort to get an IEnroll4 pointer: 
    if (NULL == g_hmodxEnroll)
    {
        g_hmodxEnroll = LoadLibrary("xenroll.dll");  
    }
    
    // We couldn't load xenroll -- not much we can do about it.  In this case,
    // it's likely we ever allocated memory with it anyway, however, so we're
    // probably not leaking. 
    _JumpCondition(NULL == g_hmodxEnroll, xEnrollDone); 

    pfnPIEnroll4GetNoCOM = (PFNPIEnroll4GetNoCOM)GetProcAddress(g_hmodxEnroll, "PIEnroll4GetNoCOM"); 
    _JumpCondition(NULL == pfnPIEnroll4GetNoCOM, xEnrollDone);

    pIEnroll = pfnPIEnroll4GetNoCOM(); 
    _JumpCondition(NULL == pIEnroll, xEnrollDone); 

    // Free the request created by xenroll.  
    // NOTE: freeRequestInfoBlob does not actually free the memory associated with the request.
    //       Rather, it deletes the request from the request store, leaving the caller responsible
    //       for the memory free.  

    if (pState->fMustFreeRequestBlob) 
    {
        if (NULL != pState->RequestBlob.pbData) 
        { 
            if (NULL != pIEnroll)
            {
                pIEnroll->put_MyStoreFlags(pState->dwMyStoreFlags);
		if (NULL != pState->HashBlob.pbData) 
		{
		    pIEnroll->put_ThumbPrintWStr(pState->HashBlob); 
		}
		pIEnroll->freeRequestInfoBlob(pState->RequestBlob);
             }
            LocalFree(pState->RequestBlob.pbData); 
        } 
    }

 xEnrollDone:
    // We've finished attempting to free data created by xenroll.  Now
    // free data allocated in CreateRequest(): 

    if (NULL != pState->HashBlob.pbData)    { WizardFree(pState->HashBlob.pbData); }
    WizardFree(pState);

    // We're done with the IEnroll4 pointer:
    if (NULL != pIEnroll)                   { pIEnroll->Release(); } 
}

HRESULT WINAPI LocalEnrollNoDS(  DWORD                 dwFlags,         //IN Required
				 LPCWSTR               /*pRequestString*/,  // Reserved:  must be NULL. 
                      void                  *pReserved,      //IN Optional
                      BOOL                  fKeyService,     //IN Required: Whether the function is called remotely
                      DWORD                 dwPurpose,       //IN Required: Whether it is enrollment or renew
                      BOOL                  fConfirmation,   //IN Required: Set the TRUE if confirmation dialogue is needed
                      HWND                  hwndParent,      //IN Optional: The parent window
                      LPWSTR                pwszConfirmationTitle,   //IN Optional: The title for confirmation dialogue
                      UINT                  idsConfirmTitle, //IN Optional: The resource ID for the title of the confirmation dialogue
                      LPWSTR                pwszCALocation,  //IN Required: The ca machine name
                      LPWSTR                pwszCAName,      //IN Required: The ca name
                      CERT_BLOB             *pCertBlob,      //IN Required: The renewed certifcate
                      CERT_REQUEST_PVK_NEW  *pRenewKey,      //IN Required: The private key on the certificate
                      BOOL                  fNewKey,         //IN Required: Set the TRUE if new private key is needed
                      CERT_REQUEST_PVK_NEW  *pKeyNew,        //IN Required: The private key information
                      LPWSTR                pwszHashAlg,     //IN Optional: The hash algorithm
                      LPWSTR                pwszDesStore,    //IN Optional: The destination store
                      DWORD                 dwStoreFlags,    //IN Optional: The store flags
                      CERT_ENROLL_INFO      *pRequestInfo,   //IN Required: The information about the cert request
                      CERT_BLOB             *pPKCS7Blob,     //OUT Optional: The PKCS7 from the CA
                      CERT_BLOB             *pHashBlob,      //OUT Optioanl: The SHA1 hash of the enrolled/renewed certificate
                      DWORD                 *pdwStatus,      //OUT Optional: The status of the enrollment/renewal
		      HANDLE                *pResult         //IN OUT Optional: The enrolled certificate
                   )

{
    // When no flags are specified, we still create, submit, and free.
    BOOL    fCreateRequest  = 0 == (dwFlags & (CRYPTUI_WIZ_NODS_MASK & ~CRYPTUI_WIZ_CREATE_ONLY));
    BOOL    fSubmitRequest  = 0 == (dwFlags & (CRYPTUI_WIZ_NODS_MASK & ~CRYPTUI_WIZ_SUBMIT_ONLY));
    BOOL    fFreeRequest    = 0 == (dwFlags & (CRYPTUI_WIZ_NODS_MASK & ~CRYPTUI_WIZ_FREE_ONLY));

    // Query the request only when specifically queried. 
    BOOL    fQueryRequest   = 0 != (dwFlags & CRYPTUI_WIZ_QUERY_ONLY); 
    HANDLE  hRequest        = NULL; 
    HRESULT hr              = E_FAIL; 

    if (fQueryRequest) { 
        // Querying the request takes precedence over other operations. 
        if (!QueryRequest(*pResult, (CRYPTUI_WIZ_QUERY_CERT_REQUEST_INFO *)pReserved))
            goto QueryRequestErr; 

        return S_OK; 
    }

    if (NULL != pdwStatus)
        *pdwStatus = CRYPTUI_WIZ_CERT_REQUEST_STATUS_REQUEST_ERROR; 

    if (FALSE == (fCreateRequest || fSubmitRequest || fFreeRequest))
	return E_INVALIDARG; 
    
    if (TRUE == fCreateRequest)
    {
	if (S_OK != (hr = CreateRequest(dwFlags, 
                                        dwPurpose,
                                        pwszCAName, 
                                        pwszCALocation, 
                                        pCertBlob, 
                                        pRenewKey, 
                                        fNewKey, 
                                        pKeyNew, 
                                        pwszHashAlg, 
                                        pwszDesStore, 
                                        dwStoreFlags, 
                                        pRequestInfo, 
                                        &hRequest)))
            goto ErrorReturn; 

	_JumpCondition(NULL == hRequest, UnexpectedErr);

        // Successfully created the request:
        if (NULL != pdwStatus) { *pdwStatus = CRYPTUI_WIZ_CERT_REQUEST_STATUS_REQUEST_CREATED; }
        if (NULL != pResult)   { *pResult = hRequest; } 
    }
    else 
    {
        // The created request is passed in through "pResult".  
	hRequest = *pResult;
    }

    if (TRUE == fSubmitRequest)
    {
	if (S_OK != (hr = SubmitRequest
                     (hRequest, 
                      fKeyService, 
                      dwPurpose, 
                      fConfirmation, 
                      hwndParent, 
                      pwszConfirmationTitle, 
                      idsConfirmTitle, 
                      pwszCALocation,
                      pwszCAName,
                      NULL, // pwszCADisplayName,
                      pPKCS7Blob, 
                      pHashBlob, 
                      pdwStatus, 
                      (PCCERT_CONTEXT *)pResult)))
        {
            // Assign the created request to the OUT parameter on error. 
            if (NULL != pResult) { *pResult = hRequest; } 
            goto ErrorReturn; 
        }
                
    }

    if (TRUE == fFreeRequest)
    {
        FreeRequest(hRequest);
        hr = S_OK; 
    }

    
 CommonReturn: 
    return hr; 

 ErrorReturn:
    goto CommonReturn; 

SET_HRESULT(QueryRequestErr, GetLastError()); 
SET_HRESULT(UnexpectedErr,   E_UNEXPECTED); 
}


HRESULT WINAPI LocalEnroll(  DWORD                 dwFlags,         //IN Required
		      LPCWSTR               pRequestString,  // Reserved:  must be NULL. 
                      void                  *pReserved,      //IN Optional
                      BOOL                  fKeyService,     //IN Required: Whether the function is called remotely
                      DWORD                 dwPurpose,       //IN Required: Whether it is enrollment or renew
                      BOOL                  fConfirmation,   //IN Required: Set the TRUE if confirmation dialogue is needed
                      HWND                  hwndParent,      //IN Optional: The parent window
                      LPWSTR                pwszConfirmationTitle,   //IN Optional: The title for confirmation dialogue
                      UINT                  idsConfirmTitle, //IN Optional: The resource ID for the title of the confirmation dialogue
                      LPWSTR                pwszCALocation,  //IN Required: The ca machine name
                      LPWSTR                pwszCAName,      //IN Required: The ca name
                      CERT_BLOB             *pCertBlob,      //IN Required: The renewed certifcate
                      CERT_REQUEST_PVK_NEW  *pRenewKey,      //IN Required: The private key on the certificate
                      BOOL                  fNewKey,         //IN Required: Set the TRUE if new private key is needed
                      CERT_REQUEST_PVK_NEW  *pKeyNew,        //IN Required: The private key information
                      LPWSTR                pwszHashAlg,     //IN Optional: The hash algorithm
                      LPWSTR                pwszDesStore,    //IN Optional: The destination store
                      DWORD                 dwStoreFlags,    //IN Optional: The store flags
                      CERT_ENROLL_INFO      *pRequestInfo,   //IN Required: The information about the cert request
                      CERT_BLOB             *pPKCS7Blob,     //OUT Optional: The PKCS7 from the CA
                      CERT_BLOB             *pHashBlob,      //OUT Optioanl: The SHA1 hash of the enrolled/renewed certificate
                      DWORD                 *pdwStatus,      //OUT Optional: The status of the enrollment/renewal
		      PCERT_CONTEXT         *ppCertContext   //OUT Optional: The enrolled certificate
                   )
{
    return LocalEnrollNoDS
        ( dwFlags,         //IN Required
	  pRequestString,  // Reserved:  must be NULL. 
	  pReserved,      //IN Optional
	  fKeyService,     //IN Required: Whether the function is called remotely
	  dwPurpose,       //IN Required: Whether it is enrollment or renew
	  fConfirmation,   //IN Required: Set the TRUE if confirmation dialogue is needed
	  hwndParent,      //IN Optional: The parent window
	  pwszConfirmationTitle,   //IN Optional: The title for confirmation dialogue
	  idsConfirmTitle, //IN Optional: The resource ID for the title of the confirmation dialogue
	  pwszCALocation,  //IN Required: The ca machine name
	  pwszCAName,      //IN Required: The ca name
	  pCertBlob,      //IN Required: The renewed certifcate
	  pRenewKey,      //IN Required: The private key on the certificate
	  fNewKey,         //IN Required: Set the TRUE if new private key is needed
	  pKeyNew,        //IN Required: The private key information
	  pwszHashAlg,     //IN Optional: The hash algorithm
	  pwszDesStore,    //IN Optional: The destination store
	  dwStoreFlags,    //IN Optional: The store flags
	  pRequestInfo,   //IN Required: The information about the cert request
	  pPKCS7Blob,     //OUT Optional: The PKCS7 from the CA
	  pHashBlob,      //OUT Optioanl: The SHA1 hash of the enrolled/renewed certificate
	  pdwStatus,      //OUT Optional: The status of the enrollment/renewal
	  (HANDLE *)ppCertContext);   //OUT Optional: The enrolled certificate
}

//note pCertRenewPvk internal pointers has to be freed by callers
HRESULT  MarshallRequestParameters(IN      DWORD                  dwCSPIndex,
                                   IN      CERT_WIZARD_INFO      *pCertWizardInfo,
                                   IN OUT  CERT_BLOB             *pCertBlob, 
                                   IN OUT  CERT_REQUEST_PVK_NEW  *pCertRequestPvkNew,
                                   IN OUT  CERT_REQUEST_PVK_NEW  *pCertRenewPvk, 
                                   IN OUT  LPWSTR                *ppwszHashAlg, 
                                   IN OUT  CERT_ENROLL_INFO      *pRequestInfo)
                                   
{
    BOOL                    fCopyPropertiesFromRequestInfo  = FALSE; 
    BOOL                    fRevertWizardProvider           = FALSE; 
    BOOL                    fSetUpRenewPvk                  = FALSE; 
    CertRequester          *pCertRequester                  = NULL;
    CertRequesterContext   *pCertRequesterContext           = NULL; 
    CRYPT_KEY_PROV_INFO    *pKeyProvInfo                    = NULL;
    CRYPTUI_WIZ_CERT_CA    *pCertCA                         = NULL;
    DWORD                   dwExtensions                    = 0;
    DWORD                   dwIndex                         = 0;
    DWORD                   dwGenKeyFlags                   = 0; 
    DWORD                   dwSize                          = 0;
    HRESULT                 hr                              = E_FAIL;
    LPWSTR                  pwszOID                         = NULL;
    LPWSTR                  pwszUsageOID                    = NULL; 
    PCERT_EXTENSIONS       *pExtensions                     = NULL;
    UINT                    idsText                         = 0;
    DWORD                   dwMinKey                        = 0;
    DWORD                   dwMaxKey                        = 0;
    DWORD                   dwInc                           = 0;
    DWORD                   dwTempGenKeyFlags               = 0;

    // Input validation: 
    _JumpConditionWithExpr
	(NULL == pCertWizardInfo    || NULL == pCertWizardInfo->hRequester || NULL == pCertBlob    || 
	 NULL == pCertRequestPvkNew || NULL == pCertRenewPvk               || NULL == ppwszHashAlg || 
	 NULL == pRequestInfo, 
	 InvalidArgError, 
	 idsText = IDS_REQUEST_FAIL); 

    // Initialization: 
    memset(pCertBlob,          0, sizeof(*pCertBlob)); 
    memset(pCertRequestPvkNew, 0, sizeof(*pCertRequestPvkNew));
    memset(pCertRenewPvk,      0, sizeof(*pCertRenewPvk));
    memset(ppwszHashAlg,       0, sizeof(*ppwszHashAlg)); 
    memset(pRequestInfo,       0, sizeof(*pRequestInfo)); 

    pCertRequester        = (CertRequester *)pCertWizardInfo->hRequester;
    pCertRequesterContext = pCertRequester->GetContext();
    _JumpCondition(NULL == pCertRequesterContext, InvalidArgError); 

    //set up the hash algorithm.  Convert to the wchar version
    if(pCertWizardInfo->pszHashAlg)
        (*ppwszHashAlg) = MkWStr((LPSTR)(pCertWizardInfo->pszHashAlg));

    // Build a comma seperated OID usage for enrollment only.
    // The CA index must not exceed the number of CAs:
    _JumpCondition(pCertWizardInfo->dwCAIndex >= pCertWizardInfo->pCertCAInfo->dwCA, UnexpectedError); 

    pCertCA=&(pCertWizardInfo->pCertCAInfo->rgCA[pCertWizardInfo->dwCAIndex]);

    //decide if we need to build the list
    if(pCertCA->dwOIDInfo)
    {
        pwszUsageOID=(LPWSTR)WizardAlloc(sizeof(WCHAR));
        _JumpCondition(NULL == pwszUsageOID, MemoryError); 
        
        *pwszUsageOID=L'\0';
        
        //we are guaranteed that at least one OID should be selected
        for(dwIndex=0; dwIndex<pCertCA->dwOIDInfo; dwIndex++)
        {
            if(TRUE==(pCertCA->rgOIDInfo)[dwIndex].fSelected)
            {
                if(wcslen(pwszUsageOID)!=0)
                    wcscat(pwszUsageOID, L",");
                
                pwszOID=MkWStr((pCertCA->rgOIDInfo)[dwIndex].pszOID);
                _JumpCondition(NULL == pwszOID, MemoryError); 

                pwszUsageOID=(LPWSTR)WizardRealloc(pwszUsageOID,
                                                   sizeof(WCHAR)*(wcslen(pwszUsageOID)+wcslen(pwszOID)+wcslen(L",")+1));

                _JumpCondition(NULL==pwszUsageOID, MemoryError); 

                wcscat(pwszUsageOID,pwszOID);

                FreeWStr(pwszOID);
                pwszOID=NULL;
            }
        }

    }
    else
    {
        //we need to build the extension list for the certificate types

        dwExtensions=0;
        
        for(dwIndex=0; dwIndex<pCertCA->dwCertTypeInfo; dwIndex++)
        {
            if(TRUE==(pCertCA->rgCertTypeInfo)[dwIndex].fSelected)
            {
                //add the extensions
                if(NULL !=(pCertCA->rgCertTypeInfo)[dwIndex].pCertTypeExtensions)
                {
                    dwExtensions++;
                    pExtensions=(PCERT_EXTENSIONS *)WizardRealloc(pExtensions,
                                                                  dwExtensions * sizeof(PCERT_EXTENSIONS));
                    _JumpCondition(NULL == pExtensions, MemoryError); 
                    
                    pExtensions[dwExtensions-1]=(pCertCA->rgCertTypeInfo)[dwIndex].pCertTypeExtensions;
                }
		    
                pCertWizardInfo->dwEnrollmentFlags  = (pCertCA->rgCertTypeInfo)[dwIndex].dwEnrollmentFlags; 
                pCertWizardInfo->dwSubjectNameFlags = (pCertCA->rgCertTypeInfo)[dwIndex].dwSubjectNameFlags; 
                pCertWizardInfo->dwPrivateKeyFlags  = (pCertCA->rgCertTypeInfo)[dwIndex].dwPrivateKeyFlags; 
                pCertWizardInfo->dwGeneralFlags     = (pCertCA->rgCertTypeInfo)[dwIndex].dwGeneralFlags; 
                
                //copy the dwKeySpec and genKeyFlags from the
                //cert type to the request information
                //if rgdwCSP is not NULL for the cert type, then we know
                //we need to copy the information since the memory is always
                //allocated
                if((pCertCA->rgCertTypeInfo)[dwIndex].rgdwCSP)
                {
                    //if ignored the user's input, we use the one from the certificate
                    //template
                    if(TRUE == pCertWizardInfo->fIgnore)
                    {
                        pCertWizardInfo->dwKeySpec=(pCertCA->rgCertTypeInfo)[dwIndex].dwKeySpec;
                        if (!CertTypeFlagsToGenKeyFlags
                            (pCertWizardInfo->dwEnrollmentFlags,
                             pCertWizardInfo->dwSubjectNameFlags,
                             pCertWizardInfo->dwPrivateKeyFlags,
                             pCertWizardInfo->dwGeneralFlags,
                             &dwGenKeyFlags))
                            goto CertTypeFlagsToGenKeyFlagsError;
			    
                        // Add these flags to whatever flags have already been specified by the user.  
                        pCertWizardInfo->dwGenKeyFlags |= dwGenKeyFlags; 
                        pCertWizardInfo->dwGenKeyFlags |= ((pCertCA->rgCertTypeInfo)[dwIndex].dwMinKeySize << 16); 
                    }
                    else
                    {
                        //we only copy information we need to
                        if(0 == pCertWizardInfo->dwKeySpec)
                            pCertWizardInfo->dwKeySpec=(pCertCA->rgCertTypeInfo)[dwIndex].dwKeySpec;
                    }
                }
                
                // The user has specified a minimum key size through the advanced options.  
                // Use it to override whatever key size is specified in the cert template. 
                if (pCertWizardInfo->dwMinKeySize != 0)
                {
                    pCertWizardInfo->dwGenKeyFlags &= 0x0000FFFF; 
                    pCertWizardInfo->dwGenKeyFlags |= (pCertWizardInfo->dwMinKeySize) << 16; 
                }
                
                //deside the CSP to use:
                if(NULL == pCertWizardInfo->pwszProvider)
                { 
                    if((pCertCA->rgCertTypeInfo)[dwIndex].dwCSPCount && (pCertCA->rgCertTypeInfo)[dwIndex].rgdwCSP)
                    {
                        //Use the 1st one on the cert type's CSP list
                        pCertWizardInfo->pwszProvider=pCertWizardInfo->rgwszProvider[dwCSPIndex];
                        pCertWizardInfo->dwProviderType=pCertWizardInfo->rgdwProviderType[dwCSPIndex];
                        fRevertWizardProvider = TRUE; 
                    }
                }

                //the increase the min key size to the minimal of CSP selected
                if(GetValidKeySizes(
                            pCertWizardInfo->pwszProvider,
		                    pCertWizardInfo->dwProviderType,
		                    pCertWizardInfo->dwKeySpec, 
		                    &dwMinKey,
		                    &dwMaxKey,
		                    &dwInc))
                {
                    dwTempGenKeyFlags = pCertWizardInfo->dwGenKeyFlags;

                    dwTempGenKeyFlags &= 0xFFFF0000;

                    dwTempGenKeyFlags = (dwTempGenKeyFlags >> 16);

                    //we use 0 for default key size for V1 template
                    if(0 != dwTempGenKeyFlags)
                    {
                        if(dwTempGenKeyFlags < dwMinKey)
                        {
                            pCertWizardInfo->dwGenKeyFlags &= 0x0000FFFF; 
                            pCertWizardInfo->dwGenKeyFlags |= ((dwMinKey) << 16); 
                        }
                    }
                }
            }
        }
    }

    //user has to set up the CSP:
    //1. in the UI case.  The CSP is always selected
    //2. In the UILess case, the CSP can be:
    //  2.1 User specified in the API.
    //  2.2 We have selected for their dehalf for the CSP list on the cert template
    //  2.3 We default to RSA_FULL for non-cert template case
    if((NULL == pCertWizardInfo->pwszProvider) || (0 == pCertWizardInfo->dwProviderType))
    {
        idsText=IDS_ENROLL_NO_CERT_TYPE;
        hr=E_INVALIDARG;
    }

    //consider the user input extensions
    if(pCertWizardInfo->pCertRequestExtensions)
    {
        dwExtensions++;
        pExtensions=(PCERT_EXTENSIONS *)WizardRealloc(pExtensions,
            dwExtensions * sizeof(PCERT_EXTENSIONS));
        _JumpCondition(NULL == pExtensions, MemoryError); 

        pExtensions[dwExtensions-1]=pCertWizardInfo->pCertRequestExtensions;
    }


    //set up the private key information
    pCertRequestPvkNew->dwSize=sizeof(CERT_REQUEST_PVK_NEW);
    pCertRequestPvkNew->dwProvType=pCertWizardInfo->dwProviderType;
    pCertRequestPvkNew->pwszProvider=pCertWizardInfo->pwszProvider;
    pCertRequestPvkNew->dwProviderFlags=pCertWizardInfo->dwProviderFlags;

    //we mark the provider flag SILENT for remote or UIless enrollment
    if (((0 != (pCertWizardInfo->dwFlags & CRYPTUI_WIZ_NO_UI)) && 
         (0 == (pCertWizardInfo->dwFlags & CRYPTUI_WIZ_IGNORE_NO_UI_FLAG_FOR_CSPS))) || 
        (FALSE == pCertWizardInfo->fLocal))
    {
        pCertRequestPvkNew->dwProviderFlags |= CRYPT_SILENT;
    }

    pCertRequestPvkNew->pwszKeyContainer    = pCertWizardInfo->pwszKeyContainer;
    pCertRequestPvkNew->dwKeySpec           = pCertWizardInfo->dwKeySpec;
    pCertRequestPvkNew->dwGenKeyFlags       = pCertWizardInfo->dwGenKeyFlags;

    pCertRequestPvkNew->dwEnrollmentFlags   = pCertWizardInfo->dwEnrollmentFlags; 
    pCertRequestPvkNew->dwSubjectNameFlags  = pCertWizardInfo->dwSubjectNameFlags; 
    pCertRequestPvkNew->dwPrivateKeyFlags   = pCertWizardInfo->dwPrivateKeyFlags; 
    pCertRequestPvkNew->dwGeneralFlags      = pCertWizardInfo->dwGeneralFlags; 

    //set up the enrollment information
    pRequestInfo->dwSize=sizeof(CERT_ENROLL_INFO);
    pRequestInfo->pwszUsageOID=pwszUsageOID;

    pRequestInfo->pwszCertDNName=pCertWizardInfo->pwszCertDNName;

    pRequestInfo->dwPostOption=pCertWizardInfo->dwPostOption;

    pRequestInfo->dwExtensions=dwExtensions;
    pRequestInfo->prgExtensions=pExtensions;

    // We want to copy the friendlyname and description from the request info if
    // a) if we're enrolling OR
    // b) if we're enrolling with a signing cert
    fCopyPropertiesFromRequestInfo = 
        (0 != (CRYPTUI_WIZ_CERT_ENROLL           & pCertWizardInfo->dwPurpose)) ||
        (0 != (CRYPTUI_WIZ_NO_ARCHIVE_RENEW_CERT & pCertWizardInfo->dwFlags)); 
    
    //set up the friendlyName and pwszDescription separately
    if (fCopyPropertiesFromRequestInfo)
    {
        if (NULL == pCertWizardInfo->pwszFriendlyName) { pRequestInfo->pwszFriendlyName = NULL; } 
        else
        {
            pRequestInfo->pwszFriendlyName = WizardAllocAndCopyWStr(pCertWizardInfo->pwszFriendlyName);
            _JumpCondition(NULL == pRequestInfo->pwszFriendlyName, MemoryError);
        }

        if (NULL == pCertWizardInfo->pwszDescription) { pRequestInfo->pwszDescription = NULL; } 
        else 
        {
            pRequestInfo->pwszDescription  = WizardAllocAndCopyWStr(pCertWizardInfo->pwszDescription);
            _JumpCondition(NULL == pRequestInfo->pwszDescription, MemoryError);
        }
    }
    else // copy properties from renew cert context
    {
        //get the friendlyName and description of the cerititificate
        //get the friendly info from the certificate
        CertAllocAndGetCertificateContextProperty
            (pCertWizardInfo->pCertContext,
             CERT_FRIENDLY_NAME_PROP_ID,
             (LPVOID *)&(pRequestInfo->pwszFriendlyName), 
             &dwSize);

        //get the description
        CertAllocAndGetCertificateContextProperty
            (pCertWizardInfo->pCertContext,
             CERT_DESCRIPTION_PROP_ID,
             (LPVOID *)&(pRequestInfo->pwszDescription), 
             &dwSize);
    }

    // We want to set up renew pvk info if
    // a) We're renewing 
    // b) We're enrolling with a signing cert
    fSetUpRenewPvk = 
        (0 == (CRYPTUI_WIZ_CERT_ENROLL           & pCertWizardInfo->dwPurpose)) ||
        (0 != (CRYPTUI_WIZ_NO_ARCHIVE_RENEW_CERT & pCertWizardInfo->dwFlags)); 

    if (fSetUpRenewPvk)
    {
        //Set up the private key information and the certBLOBs
        _JumpCondition(NULL == pCertWizardInfo->pCertContext, InvalidArgError);

        pCertBlob->cbData=pCertWizardInfo->pCertContext->cbCertEncoded;
        pCertBlob->pbData=pCertWizardInfo->pCertContext->pbCertEncoded;

        //get the private key info from the certificate
        if(!CertAllocAndGetCertificateContextProperty
           (pCertWizardInfo->pCertContext,
            CERT_KEY_PROV_INFO_PROP_ID,
            (LPVOID *)&pKeyProvInfo, 
            &dwSize))
            goto CertAllocAndGetCertificateContextPropertyError;

         //set up the private key information
        pCertRenewPvk->dwSize          = sizeof(CERT_REQUEST_PVK_NEW);
        pCertRenewPvk->dwProvType      = pKeyProvInfo->dwProvType;
        pCertRenewPvk->dwProviderFlags = pKeyProvInfo->dwFlags;

        //we mark the provider flag SILENT for remote or UIless enrollment
        if (((0 != (pCertWizardInfo->dwFlags & CRYPTUI_WIZ_NO_UI)) && 
             (0 == (pCertWizardInfo->dwFlags & CRYPTUI_WIZ_IGNORE_NO_UI_FLAG_FOR_CSPS))) || 
            (FALSE == pCertWizardInfo->fLocal))
        {
            pCertRenewPvk->dwProviderFlags |= CRYPT_SILENT;
        }

        pCertRenewPvk->dwKeySpec           = pKeyProvInfo->dwKeySpec;
	pCertRenewPvk->dwEnrollmentFlags   = pCertWizardInfo->dwEnrollmentFlags; 
	pCertRenewPvk->dwSubjectNameFlags  = pCertWizardInfo->dwSubjectNameFlags; 
	pCertRenewPvk->dwPrivateKeyFlags   = pCertWizardInfo->dwPrivateKeyFlags; 
	pCertRenewPvk->dwGeneralFlags      = pCertWizardInfo->dwGeneralFlags; 

        pCertRenewPvk->pwszKeyContainer = WizardAllocAndCopyWStr(
                                        pKeyProvInfo->pwszContainerName);
        _JumpCondition(NULL == pCertRenewPvk->pwszKeyContainer, MemoryError);

        pCertRenewPvk->pwszProvider = WizardAllocAndCopyWStr(
                                        pKeyProvInfo->pwszProvName);
        _JumpCondition(NULL == pCertRenewPvk->pwszProvider, MemoryError);
    }

    hr = S_OK; 

CLEANUP:
    if (fRevertWizardProvider) { pCertWizardInfo->pwszProvider = NULL; } 

    if (S_OK != hr) 
    {
        pCertWizardInfo->idsText  = idsText; 
        pCertWizardInfo->dwStatus = CRYPTUI_WIZ_CERT_REQUEST_STATUS_REQUEST_ERROR;
    }

    if (NULL != pwszOID)      { FreeWStr(pwszOID); }
    if (NULL != pKeyProvInfo) { WizardFree((LPVOID)pKeyProvInfo); }

    return hr;

 ErrorReturn:
    goto CLEANUP; 

SET_HRESULT(CertAllocAndGetCertificateContextPropertyError,   CodeToHR(GetLastError()));
SET_HRESULT(CertTypeFlagsToGenKeyFlagsError,                  CodeToHR(GetLastError()));
SET_HRESULT(InvalidArgError,                                  E_INVALIDARG);
SET_HRESULT(MemoryError,                                      E_OUTOFMEMORY);
SET_HRESULT(UnexpectedError,                                  E_UNEXPECTED);
}

void FreeRequestParameters(IN LPWSTR                *ppwszHashAlg, 
			   IN CERT_REQUEST_PVK_NEW  *pCertRenewPvk,
			   IN CERT_ENROLL_INFO      *pRequestInfo)

{
    if (NULL != pRequestInfo)
    {
        if (NULL != pRequestInfo->pwszUsageOID)     { WizardFree((LPVOID)pRequestInfo->pwszUsageOID); }
        if (NULL != pRequestInfo->prgExtensions)    { WizardFree((LPVOID)pRequestInfo->prgExtensions); } 
        if (NULL != pRequestInfo->pwszFriendlyName) { WizardFree((LPVOID)pRequestInfo->pwszFriendlyName); }
        if (NULL != pRequestInfo->pwszDescription)  { WizardFree((LPVOID)pRequestInfo->pwszDescription); }

        pRequestInfo->pwszUsageOID     = NULL;
        pRequestInfo->prgExtensions    = NULL;
        pRequestInfo->pwszFriendlyName = NULL;
        pRequestInfo->pwszDescription  = NULL; 
    }

    if (NULL != pCertRenewPvk) 
    {
	if (NULL != pCertRenewPvk->pwszKeyContainer)
	{
	    WizardFree((LPVOID)pCertRenewPvk->pwszKeyContainer);
	    pCertRenewPvk->pwszKeyContainer = NULL;
	}

	if (NULL != pCertRenewPvk->pwszProvider) 
	{
	    WizardFree((LPVOID)pCertRenewPvk->pwszProvider);
	    pCertRenewPvk->pwszProvider = NULL; 
	}
    }

    if (NULL != ppwszHashAlg && NULL != *ppwszHashAlg) 
    { 
        FreeWStr(*ppwszHashAlg);
        *ppwszHashAlg = NULL; 
    }
}
                                   


//-----------------------------------------------------------------------------
//  Memory routines
//
//#define malloc(cb)          ((void*)LocalAlloc(LPTR, cb))
//#define free(pv)            (LocalFree((HLOCAL)pv))
//#define realloc(pv, cb)     ((void*)LocalReAlloc((HLOCAL)pv, cb, LMEM_MOVEABLE))
//
//
//-----------------------------------------------------------------------------
LPVOID  WizardAlloc (ULONG cbSize)
{
    return ((void*)LocalAlloc(LPTR, cbSize));
}


LPVOID  WizardRealloc (
        LPVOID pv,
        ULONG cbSize)
{
    LPVOID  pvTemp=NULL;

    if(NULL==pv)
        return WizardAlloc(cbSize);

    pvTemp=((void*)LocalReAlloc((HLOCAL)pv, cbSize, LMEM_MOVEABLE));

    if(NULL==pvTemp)
    {
        //we are running out memory
        WizardFree(pv);
    }

    return pvTemp;
}

VOID    MyWizardFree (LPVOID pv)
{
    if (pv)
        LocalFree((HLOCAL)pv);
}

VOID    WizardFree (LPVOID pv)
{
    if (pv)
        LocalFree((HLOCAL)pv);
}



//-----------------------------------------------------------------------------
//  the call back function to compare the certificate
//
//-----------------------------------------------------------------------------
int CALLBACK CompareCertificate(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
    PCCERT_CONTEXT      pCertOne=NULL;
    PCCERT_CONTEXT      pCertTwo=NULL;
    DWORD               dwColumn=0;
    int                 iCompare=0;
    LPWSTR              pwszOne=NULL;
    LPWSTR              pwszTwo=NULL;



    pCertOne=(PCCERT_CONTEXT)lParam1;
    pCertTwo=(PCCERT_CONTEXT)lParam2;
    dwColumn=(DWORD)lParamSort;

    if((NULL==pCertOne) || (NULL==pCertTwo))
        goto CLEANUP;

    switch(dwColumn & 0x0000FFFF)
    {
       case SORT_COLUMN_SUBJECT:
	   GetCertSubject(pCertOne, &pwszOne);
	   GetCertSubject(pCertTwo, &pwszTwo);
            break;
       case SORT_COLUMN_ISSUER:
	   GetCertIssuer(pCertOne, &pwszOne);
	   GetCertIssuer(pCertTwo, &pwszTwo);
            break;

        case SORT_COLUMN_PURPOSE:
	    GetCertPurpose(pCertOne, &pwszOne);
	    GetCertPurpose(pCertTwo, &pwszTwo);
            break;

        case SORT_COLUMN_NAME:
	    GetCertFriendlyName(pCertOne, &pwszOne);
	    GetCertFriendlyName(pCertTwo, &pwszTwo);
            break;

        case SORT_COLUMN_LOCATION:
	    if (!GetCertLocation(pCertOne, &pwszOne)) 
	    {
		pwszOne = NULL; 
		goto CLEANUP; 
	    }
	    if (!GetCertLocation(pCertTwo, &pwszTwo)) 
	    {
		pwszTwo = NULL; 
		goto CLEANUP; 
	    }
            break;
                
    }

    if(SORT_COLUMN_EXPIRATION == (dwColumn & 0x0000FFFF))
    {
        iCompare=CompareFileTime(&(pCertOne->pCertInfo->NotAfter),
                                &(pCertTwo->pCertInfo->NotAfter));

    }
    else
    {
        if((NULL==pwszOne) || (NULL==pwszTwo))
            goto CLEANUP;

		//we should use wcsicoll instead of wcsicmp since wcsicoll use the
		//lexicographic order of current code page.
		iCompare=CompareStringU(LOCALE_USER_DEFAULT,
							NORM_IGNORECASE,
							pwszOne,
							-1,
							pwszTwo,
							-1);

		//map to the C run time convention
		iCompare = iCompare -2;
    }

    if(dwColumn & SORT_COLUMN_DESCEND)
        iCompare = 0-iCompare;

CLEANUP:

    if(pwszOne)
        WizardFree(pwszOne);

    if(pwszTwo)
        WizardFree(pwszTwo);

    return iCompare;
}


//-----------------------------------------------------------------------------
//  GetCertIssuer
//
//-----------------------------------------------------------------------------
BOOL    GetCertIssuer(PCCERT_CONTEXT    pCertContext, LPWSTR    *ppwsz)
{
    BOOL            fResult=FALSE;
    DWORD           dwChar=0;
    WCHAR           wszNone[MAX_TITLE_LENGTH];


    if(!pCertContext || !ppwsz)
        goto CLEANUP;

    *ppwsz=NULL;


    dwChar=CertGetNameStringW(
        pCertContext,
        CERT_NAME_SIMPLE_DISPLAY_TYPE,
        CERT_NAME_ISSUER_FLAG,
        NULL,
        NULL,
        0);

    if ((dwChar != 0) && (NULL != (*ppwsz = (LPWSTR)WizardAlloc(dwChar * sizeof(WCHAR)))))
    {

        CertGetNameStringW(
            pCertContext,
            CERT_NAME_SIMPLE_DISPLAY_TYPE,
            CERT_NAME_ISSUER_FLAG,
            NULL,
            *ppwsz,
            dwChar);

    }
    else
    {
        if(!LoadStringU(g_hmodThisDll, IDS_NONE, wszNone, MAX_TITLE_LENGTH))
            wszNone[0]=L'\0';

        if(!(*ppwsz=WizardAllocAndCopyWStr(wszNone)))
            goto CLEANUP;
    }

    fResult=TRUE;

CLEANUP:

    if(FALSE == fResult)
    {
        if(*ppwsz)
            WizardFree(*ppwsz);

        *ppwsz=NULL;
    }

    return fResult;

}


//-----------------------------------------------------------------------------
//  GetCertSubject
//
//-----------------------------------------------------------------------------
BOOL    GetCertSubject(PCCERT_CONTEXT    pCertContext, LPWSTR    *ppwsz)
{
    BOOL            fResult=FALSE;
    DWORD           dwChar=0;
    WCHAR           wszNone[MAX_TITLE_LENGTH];


    if(!pCertContext || !ppwsz)
        goto CLEANUP;

    *ppwsz=NULL;


    dwChar=CertGetNameStringW(
        pCertContext,
        CERT_NAME_SIMPLE_DISPLAY_TYPE,
        0,
        NULL,
        NULL,
        0);

    if ((dwChar != 0) && (NULL != (*ppwsz = (LPWSTR)WizardAlloc(dwChar * sizeof(WCHAR)))))
    {

        CertGetNameStringW(
            pCertContext,
            CERT_NAME_SIMPLE_DISPLAY_TYPE,
            0,
            NULL,
            *ppwsz,
            dwChar);

    }
    else
    {
        if(!LoadStringU(g_hmodThisDll, IDS_NONE, wszNone, MAX_TITLE_LENGTH))
            wszNone[0]=L'\0';

        if(!(*ppwsz=WizardAllocAndCopyWStr(wszNone)))
            goto CLEANUP;
    }

    fResult=TRUE;

CLEANUP:

    if(FALSE == fResult)
    {
        if(*ppwsz)
            WizardFree(*ppwsz);

        *ppwsz=NULL;
    }

    return fResult;

}

//-----------------------------------------------------------------------------
//  MyFormatEnhancedKeyUsageString 
//
//  This functions is here because the FormatEnhancedKeyUsageString function
//  uses malloc and all the wizards use LocalAlloc and LocalFree.
//
//-----------------------------------------------------------------------------
BOOL MyFormatEnhancedKeyUsageString(LPWSTR *ppString, 
                                    PCCERT_CONTEXT pCertContext, 
                                    BOOL fPropertiesOnly, 
                                    BOOL fMultiline)
{
    LPWSTR pwszTemp = NULL;

    if(!FormatEnhancedKeyUsageString(&pwszTemp, pCertContext, fPropertiesOnly, fMultiline))
        return FALSE;
    
    *ppString = WizardAllocAndCopyWStr(pwszTemp);

    free(pwszTemp);

    if (*ppString != NULL)
        return TRUE;
    else
        return FALSE;
    
    
}
//-----------------------------------------------------------------------------
//  GetCertPurpose
//
//-----------------------------------------------------------------------------
BOOL    GetCertPurpose(PCCERT_CONTEXT    pCertContext, LPWSTR    *ppwsz)
{
    if(!pCertContext || !ppwsz)
        return FALSE;

    *ppwsz=NULL;

    if(MyFormatEnhancedKeyUsageString(ppwsz,pCertContext, FALSE, FALSE))
        return TRUE;

    return FALSE;
}


//-----------------------------------------------------------------------------
//  GetCertFriendlyName
//
//-----------------------------------------------------------------------------
BOOL    GetCertFriendlyName(PCCERT_CONTEXT    pCertContext, LPWSTR    *ppwsz)
{
    DWORD           dwChar=0;
    WCHAR           wszNone[MAX_TITLE_LENGTH];


    if(!pCertContext || !ppwsz)
        return FALSE;

    *ppwsz=NULL;

    dwChar=0;

    if(CertAllocAndGetCertificateContextProperty(
        pCertContext,
        CERT_FRIENDLY_NAME_PROP_ID,
        (LPVOID *)ppwsz, 
        &dwChar))
    {
        return TRUE;
    }

    if(!LoadStringU(g_hmodThisDll, IDS_NONE, wszNone, MAX_TITLE_LENGTH))
        wszNone[0]=L'\0';

    if((*ppwsz=WizardAllocAndCopyWStr(wszNone)))
        return TRUE;

    return FALSE;
}

//-----------------------------------------------------------------------------
//  GetCertLocation
//
//-----------------------------------------------------------------------------
BOOL GetCertLocation (PCCERT_CONTEXT  pCertContext, LPWSTR *ppwsz)
{
    DWORD    cbName = 0;
    WCHAR    wszNotAvailable[MAX_TITLE_LENGTH];
    
    if (CertGetStoreProperty(
                pCertContext->hCertStore,
                CERT_STORE_LOCALIZED_NAME_PROP_ID,
                NULL,
                &cbName))
    {
        if (NULL == (*ppwsz = (LPWSTR) WizardAlloc(cbName)))
        {
            return FALSE;
        }

        if (!CertGetStoreProperty(
                    pCertContext->hCertStore,
                    CERT_STORE_LOCALIZED_NAME_PROP_ID,
                    *ppwsz,
                    &cbName))
        {
            WizardFree(*ppwsz);
            return FALSE;
        }
    }
    else
    {
        if (!LoadStringU(g_hmodThisDll, IDS_NOTAVAILABLE, wszNotAvailable, MAX_TITLE_LENGTH))
        {
            wszNotAvailable[0]=L'\0';
        }

        if (NULL == (*ppwsz = WizardAllocAndCopyWStr(wszNotAvailable)))
        {
            return FALSE;
        }
    }

    return TRUE;
}

//-----------------------------------------------------------------------------
//  LoadFilterString
//
//-----------------------------------------------------------------------------
int LoadFilterString(
            HINSTANCE hInstance,	
            UINT uID,	
            LPWSTR lpBuffer,	
            int nBufferMax)
{
    int size;

    if(size = LoadStringU(hInstance, uID, lpBuffer, nBufferMax-1))
    {
        lpBuffer[size]= L'\0';
        lpBuffer[size+1]= L'\0';
        return size+1;
    }
    else
    {
        return 0;
    }
}

//-----------------------------------------------------------------------------
//  ExpandAndAllocString
//
//-----------------------------------------------------------------------------
LPWSTR ExpandAndAllocString(LPCWSTR pwsz)
{
    LPWSTR  pwszExpandedFileName = NULL;
    DWORD   dwExpanded = 0;

    dwExpanded = ExpandEnvironmentStringsU(pwsz, NULL, 0);
    
    pwszExpandedFileName = (LPWSTR) WizardAlloc(dwExpanded * sizeof(WCHAR));
    if (pwszExpandedFileName == NULL)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return (NULL);
    }

    if (0 == ExpandEnvironmentStringsU(pwsz, pwszExpandedFileName, dwExpanded))
    {
        WizardFree(pwszExpandedFileName);
        return (NULL);
    }

    return (pwszExpandedFileName);
}

//-----------------------------------------------------------------------------
//  ExpandAndCreateFileU
//
//-----------------------------------------------------------------------------
HANDLE WINAPI ExpandAndCreateFileU (
    LPCWSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile
    )
{
    HANDLE  hRet = INVALID_HANDLE_VALUE;
    LPWSTR  pwszExpandedFileName = NULL;
    
    pwszExpandedFileName = ExpandAndAllocString(lpFileName);

    if (NULL != pwszExpandedFileName)
    {
        hRet = CreateFileU (
                pwszExpandedFileName,
                dwDesiredAccess,
                dwShareMode,
                lpSecurityAttributes,
                dwCreationDisposition,
                dwFlagsAndAttributes,
                hTemplateFile);
        
        WizardFree(pwszExpandedFileName);
    }

    return (hRet);
}

WINCRYPT32API
BOOL
WINAPI
ExpandAndCryptQueryObject(
    DWORD            dwObjectType,
    const void       *pvObject,
    DWORD            dwExpectedContentTypeFlags,
    DWORD            dwExpectedFormatTypeFlags,
    DWORD            dwFlags,
    DWORD            *pdwMsgAndCertEncodingType,
    DWORD            *pdwContentType,
    DWORD            *pdwFormatType,
    HCERTSTORE       *phCertStore,
    HCRYPTMSG        *phMsg,
    const void       **ppvContext
    )
{
    LPWSTR  pwszExpandedFileName = NULL;
    BOOL    fRet = FALSE;
    
    if (dwObjectType == CERT_QUERY_OBJECT_FILE)
    {
        pwszExpandedFileName = ExpandAndAllocString((LPWSTR)pvObject);

        if (NULL != pwszExpandedFileName)
        {
            fRet = CryptQueryObject(
                        dwObjectType,
                        pwszExpandedFileName,
                        dwExpectedContentTypeFlags,
                        dwExpectedFormatTypeFlags,
                        dwFlags,
                        pdwMsgAndCertEncodingType,
                        pdwContentType,
                        pdwFormatType,
                        phCertStore,
                        phMsg,
                        ppvContext
                        );
        
            WizardFree(pwszExpandedFileName);
        }
        else
        {
            fRet = FALSE;
        }
    }
    else
    {
        fRet = CryptQueryObject(
                    dwObjectType,
                    pvObject,
                    dwExpectedContentTypeFlags,
                    dwExpectedFormatTypeFlags,
                    dwFlags,
                    pdwMsgAndCertEncodingType,
                    pdwContentType,
                    pdwFormatType,
                    phCertStore,
                    phMsg,
                    ppvContext
                    );
    }
    
    return (fRet);
}

HRESULT EnrollmentCOMObjectFactory_getInstance
(EnrollmentCOMObjectFactoryContext  *pContext, 
 REFCLSID                            rclsid, 
 REFIID                              riid, 
 LPUNKNOWN                          *pUnknown,
 LPVOID                             *ppInstance)
{
    HRESULT hr = S_OK; 
    
    // Input validation.  
    // Only ppInstance can be an invalid argument, as the other arguments are supplied
    // directly by other class members. 
    if (ppInstance == NULL) { return E_INVALIDARG; } 
    
    // Ensure that COM is initialized. 
    if (!pContext->fIsCOMInitialized) 
    { 
        hr = CoInitialize(NULL);
	if (FAILED(hr))
            goto Error;
	pContext->fIsCOMInitialized = TRUE;
    }
	
    if (*pUnknown == NULL)
    {
	// We've not yet created an instance of this type, do so now: 
	if (S_OK != (hr = CoCreateInstance(rclsid, 
					   NULL,
					   CLSCTX_INPROC_SERVER,
					   riid, 
					   (LPVOID *)pUnknown)))
	    goto Error;
    }
    
    // Increment the reference count and assign the out param: 
    (*pUnknown)->AddRef();
    *ppInstance = *pUnknown; 

 CommonReturn:
    return hr; 

 Error: 
    // Some error occured which did not prevent the creation of the COM object.  
    // Release the object: 
    if (*pUnknown != NULL)
    {
	(*pUnknown)->Release();
	*pUnknown = NULL;
    }

    goto CommonReturn; 
}

//-----------------------------------------------------------------------
//
// RetrivePKCS7FromCA
//
//  The routine that calls xEnroll and CA to request a certificate
//  This routine also provide confirmation dialogue
//------------------------------------------------------------------------

extern "C" HRESULT WINAPI RetrievePKCS7FromCA(DWORD               dwPurpose,
                                              LPWSTR              pwszCALocation,
                                              LPWSTR              pwszCAName,
                                              LPWSTR              pwszRequestString,
                                              CRYPT_DATA_BLOB     *pPKCS10Blob,
                                              CRYPT_DATA_BLOB     *pPKCS7Blob,
                                              DWORD               *pdwStatus)
{
    HRESULT                 hr=E_FAIL;
	DWORD					dwException=0;
    DWORD                   dwStatus=0;
    DWORD                   dwDisposition=0;
    DWORD                   dwFlags=0;

	CERTSERVERENROLL		*pCertServerEnroll=NULL;

    //input checking
    if(!pPKCS10Blob  || !pPKCS7Blob)
        return E_INVALIDARG;

    //determine the format flag
    if(dwPurpose & CRYPTUI_WIZ_CERT_RENEW )
        dwFlags = CR_IN_BINARY | CR_IN_PKCS7;
    else
        dwFlags = CR_IN_BINARY | CR_IN_PKCS10;


    //submit the request
    __try
    {
	    hr= CertServerSubmitRequest(
                dwFlags,
				pPKCS10Blob->pbData,
				pPKCS10Blob->cbData,
				pwszRequestString,
				pwszCALocation,
				pwszCAName,
				&pCertServerEnroll);
	}
    __except(dwException = GetExceptionCode(), EXCEPTION_EXECUTE_HANDLER)
    {
		hr=HRESULT_FROM_WIN32(dwException);

		if(S_OK == hr)
			hr=E_UNEXPECTED;
    }


	//process the error 
	//first, filter out the PRC error
    if(hr == HRESULT_FROM_WIN32(RPC_S_UNKNOWN_AUTHN_SERVICE) ||
       hr == HRESULT_FROM_WIN32(RPC_S_SERVER_UNAVAILABLE) ||
       hr == HRESULT_FROM_WIN32(RPC_S_SERVER_TOO_BUSY))
    {
        dwStatus=CRYPTUI_WIZ_CERT_REQUEST_STATUS_CONNECTION_FAILED;
        goto CLEANUP;
    }

	//if hr is S_OK, we have retrieve valid return from the CA
    if(hr==S_OK)
    {
		if(!pCertServerEnroll)
		{
			hr=E_INVALIDARG;
			dwDisposition=CR_DISP_ERROR;
		}
		else
		{
			hr = pCertServerEnroll->hrLastStatus;
			dwDisposition = pCertServerEnroll->Disposition;
		}
    }
    else
    {
        dwDisposition=CR_DISP_ERROR;
    }


    //map the dwDisposition	to dwStatus
    switch(dwDisposition)
    {
        case    CR_DISP_DENIED:
                    dwStatus=CRYPTUI_WIZ_CERT_REQUEST_STATUS_REQUEST_DENIED;

                    if(!FAILED(hr))
                        hr=E_FAIL;

                break;

        case    CR_DISP_ISSUED:
                    dwStatus=CRYPTUI_WIZ_CERT_REQUEST_STATUS_CERT_ISSUED;
                break;

        case    CR_DISP_ISSUED_OUT_OF_BAND:
                    dwStatus=CRYPTUI_WIZ_CERT_REQUEST_STATUS_ISSUED_SEPARATELY;
                break;

        case    CR_DISP_UNDER_SUBMISSION:
                    dwStatus=CRYPTUI_WIZ_CERT_REQUEST_STATUS_UNDER_SUBMISSION;
                break;

        //we should never get CR_DISP_INCOMPLETE or CR_DISP_REVOKED
        //case    CR_DISP_INCOMPLETE:
        //case    CR_DISP_REVOKED:
        case    CR_DISP_ERROR:
        default:
                    dwStatus=CRYPTUI_WIZ_CERT_REQUEST_STATUS_REQUEST_ERROR;

                    if(!FAILED(hr))
                        hr=E_FAIL;
                break;
    }

	//no need to retrieve the enrolled certificate if failed
    if(hr != S_OK)
        goto CLEANUP;

    //copy the PKCS7 blob
    pPKCS7Blob->cbData=pCertServerEnroll->cbCertChain;

    pPKCS7Blob->pbData=(BYTE *)WizardAlloc(pCertServerEnroll->cbCertChain);

    if(NULL==pPKCS7Blob->pbData)
    {
        hr=E_OUTOFMEMORY;
        dwStatus=CRYPTUI_WIZ_CERT_REQUEST_STATUS_INSTALL_FAILED;
        goto CLEANUP;
    }

    memcpy(pPKCS7Blob->pbData,pCertServerEnroll->pbCertChain,pCertServerEnroll->cbCertChain);

    hr=S_OK;


CLEANUP:

	if(pCertServerEnroll)
		CertServerFreeMemory(pCertServerEnroll);

    if(pdwStatus)
        *pdwStatus=dwStatus;
	
    return hr;
}


IEnumCSP::IEnumCSP(CERT_WIZARD_INFO * pCertWizardInfo)
{
    if (NULL == pCertWizardInfo)
    {
        m_hr = E_POINTER; 
        return; // We're not initialized. 
    }

    m_fIsInitialized = FALSE; 
    m_cCSPs  = pCertWizardInfo->dwCSPCount;
    m_pfCSPs = (BOOL *)WizardAlloc(sizeof(BOOL) * m_cCSPs); 
    if (NULL == m_pfCSPs)
    {
        m_hr = E_OUTOFMEMORY; 
        return; // We're not initialized. 
    }
    
    if (NULL != pCertWizardInfo->pwszProvider)
    {
        for (DWORD dwIndex = 0; dwIndex < pCertWizardInfo->dwCSPCount; dwIndex++) 
        {
            if (0 == _wcsicmp(pCertWizardInfo->pwszProvider, pCertWizardInfo->rgwszProvider[dwIndex]))
            {
                // Enable only the CSP we've specified. 
                m_pfCSPs[dwIndex] = TRUE; 
            }
        }
    }
    else
    {
        for (DWORD dwCAIndex = 1; dwCAIndex < pCertWizardInfo->pCertCAInfo->dwCA; dwCAIndex++ )
        {
            CRYPTUI_WIZ_CERT_CA  *pCertCA = &(pCertWizardInfo->pCertCAInfo->rgCA[dwCAIndex]);

            // Any cert types available for this CA?
            if(pCertCA->dwCertTypeInfo > 0)
            {
                for(DWORD dwCertTypeIndex = 0; dwCertTypeIndex < pCertCA->dwCertTypeInfo; dwCertTypeIndex++)
                {
                    if (TRUE == (pCertCA->rgCertTypeInfo)[dwCertTypeIndex].fSelected)
                    {
                        if ((pCertCA->rgCertTypeInfo)[dwCertTypeIndex].dwCSPCount && (pCertCA->rgCertTypeInfo)[dwCertTypeIndex].rgdwCSP)
                        {
                            for (DWORD dwCSPIndex = 0; dwCSPIndex < (pCertCA->rgCertTypeInfo)[dwCertTypeIndex].dwCSPCount; dwCSPIndex++)
                            {
                                // Turn on this CSP. 
                                m_pfCSPs[((pCertCA->rgCertTypeInfo)[dwCertTypeIndex].rgdwCSP)[dwCSPIndex]] = TRUE; 
                            }
                        }
                    }
                }
            }
        }
    }

    m_dwCSPIndex     = 0; 
    m_fIsInitialized = TRUE; 
}

HRESULT IEnumCSP::HasNext(BOOL *pfResult)
{
    if (FALSE == m_fIsInitialized)
        return m_hr; 

    for (; m_dwCSPIndex < m_cCSPs; m_dwCSPIndex++)
    {
        if (m_pfCSPs[m_dwCSPIndex])
        {
            *pfResult = TRUE; 
            return S_OK; 
        }
    }
    
    *pfResult = FALSE;
    return S_OK; 
}

HRESULT IEnumCSP::Next(DWORD *pdwCSP)
{
    if (FALSE == m_fIsInitialized)
        return m_hr; 

    if (NULL == pdwCSP)
        return E_INVALIDARG; 
    
    for (; m_dwCSPIndex < m_cCSPs; m_dwCSPIndex++)
    {
        if (m_pfCSPs[m_dwCSPIndex])
        {
            *pdwCSP = m_dwCSPIndex++; 
            return S_OK;
        }
    }
    
    return HRESULT_FROM_WIN32(CRYPT_E_NOT_FOUND); 
}

HRESULT IEnumCA::HasNext(BOOL *pfResult)
{
    BOOL fDontKnowCA; 

    if (NULL == pfResult)
        return E_INVALIDARG; 

    // We don't know the CA if it wasn't supplied through the API, 
    // and if the user did not specify it through advanced options. 
    fDontKnowCA  = FALSE == m_pCertWizardInfo->fCAInput; 
    fDontKnowCA &= FALSE == m_pCertWizardInfo->fUIAdv; 

    if (FALSE == fDontKnowCA)
    {
        *pfResult = m_dwCAIndex == 1;  
        return S_OK; 
    }
    else
    {
        for (; m_dwCAIndex < m_pCertWizardInfo->pCertCAInfo->dwCA; m_dwCAIndex++)
        {
            if (CASupportSpecifiedCertType(&(m_pCertWizardInfo->pCertCAInfo->rgCA[m_dwCAIndex])))
            {
                *pfResult = TRUE;
                return S_OK; 
            }
        }
    }

    *pfResult = FALSE;
    return S_OK; 
}

HRESULT IEnumCA::Next(PCRYPTUI_WIZ_CERT_CA pCertCA)
{
    BOOL fDontKnowCA; 

    if (NULL == pCertCA)
        return E_INVALIDARG; 

    // We don't know the CA if it wasn't supplied through the API, 
    // and if the user did not specify it through advanced options. 
    fDontKnowCA  = FALSE == m_pCertWizardInfo->fCAInput; 
    fDontKnowCA &= FALSE == m_pCertWizardInfo->fUIAdv; 

    if (FALSE == fDontKnowCA)
    {
        if (1 == m_dwCAIndex) 
        {
            CRYPTUI_WIZ_CERT_CA CertCA; 
        
            m_dwCAIndex++; 
            CertCA.pwszCALocation = m_pCertWizardInfo->pwszCALocation; 
            CertCA.pwszCAName     = m_pCertWizardInfo->pwszCAName; 
            *pCertCA = CertCA; 
            return S_OK; 
        }
    }
    else
    {
        for (; m_dwCAIndex < m_pCertWizardInfo->pCertCAInfo->dwCA; m_dwCAIndex++)
        {
            if (CASupportSpecifiedCertType(&(m_pCertWizardInfo->pCertCAInfo->rgCA[m_dwCAIndex])))
            {
                *pCertCA = m_pCertWizardInfo->pCertCAInfo->rgCA[m_dwCAIndex++];
                return S_OK; 
            }
        }
    }

    return HRESULT_FROM_WIN32(CRYPT_E_NOT_FOUND); 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\scardlib\buffers.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1995 - 1999

Module Name:

    buffers

Abstract:

    This module provides the run time code to support the CBuffer object.

Author:

    Doug Barlow (dbarlow) 11/7/1995

Environment:

    Win32, C++ w/ Exceptions

Notes:

    None

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include "SCardLib.h"


/*++

CBuffer:

    This constructor is a special case for use explicitly with the operator+
    routine.  It builds a CBuffer out of the other two with only a single
    allocation.

Arguments:

    bfSourceOne supplies the first part of the new buffer
    bfSourceTwo supplies the second part of the new buffer.

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 11/7/1995

--*/

CBuffer::CBuffer(           //  Object assignment constructor.
    IN const CBuffer &bfSourceOne,
    IN const CBuffer &bfSourceTwo)
{
    Initialize();
    Presize(bfSourceOne.m_cbDataLength + bfSourceTwo.m_cbDataLength);
    Set(bfSourceOne.m_pbBuffer, bfSourceOne.m_cbDataLength);
    Append(bfSourceTwo.m_pbBuffer, bfSourceTwo.m_cbDataLength);
}


/*++

Clear:

    This routine resets a CBuffer to it's initial state, freeing any allocated
    memory.

Arguments:

    None

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

void
CBuffer::Clear(
    void)
{
    if (NULL != m_pbBuffer)
        delete[] m_pbBuffer;
    Initialize();
}


/*++

Reset:

    This routine logically empties the CBuffer without actually deallocating
    memory.  It's data lengh goes to zero.

Arguments:

    None

Return Value:

    The address of the buffer.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

LPBYTE
CBuffer::Reset(
    void)
{
    m_cbDataLength = 0;
    return m_pbBuffer;
}


/*++

Presize:

    This is the primary workhorse of the CBuffer class.  It ensures that the
    size of the buffer is of the proper size.  Data in the buffer may optionally
    be preserved, in which case the data length doesn't change.  If the buffer
    is not preserved, then the data length is reset to zero.

Arguments:

    cbLength supplies the desired length of the buffer.

    fPreserve supplies a flag indicating whether or not to preserve the current
        contents of the buffer.

Return Value:

    The address of the properly sized buffer.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

LPBYTE
CBuffer::Presize(
    IN DWORD cbLength,
    IN BOOL fPreserve)
{
    LPBYTE pbNewBuf = NULL;
    if (fPreserve && (0 < m_cbDataLength))
    {

        //
        // Increase the buffer length, and preserve the existing data.
        //

        if (m_cbBufferLength < cbLength)
        {
            pbNewBuf = new BYTE[cbLength];
            if (NULL == pbNewBuf)
                throw (DWORD)ERROR_OUTOFMEMORY;
            memcpy(pbNewBuf, m_pbBuffer, m_cbDataLength);
            delete[] m_pbBuffer;
            m_pbBuffer = pbNewBuf;
            m_cbBufferLength = cbLength;
        }
    }
    else
    {

        //
        // Increase the buffer length, but lose any existing data.
        //

        if (m_cbBufferLength < cbLength)
        {
            pbNewBuf = new BYTE[cbLength];
            if (NULL == pbNewBuf)
                throw (DWORD)ERROR_OUTOFMEMORY;
            if (NULL != m_pbBuffer)
                delete[] m_pbBuffer;
            m_pbBuffer = pbNewBuf;
            m_cbBufferLength = cbLength;
        }
        m_cbDataLength = 0;
    }
    return m_pbBuffer;
}


/*++

Resize:

    This method sets the length of the data to the given size.  If the buffer
    isn't big enough to support that data length, it is enlarged.

Arguments:

    cbLength supplies the new length of the data.

    fPreserve supplies a flag indicating whether or not to preserve existing
        data.

Return Value:

    The address of the buffer.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

LPBYTE
CBuffer::Resize(
    DWORD cbLength,
    BOOL fPreserve)
{
    LPBYTE pb = Presize(cbLength, fPreserve);
    m_cbDataLength = cbLength;
    return pb;
}


/*++

Set:

    This method sets the contents of the data to the given value.  If the buffer
    isn't big enough to hold the given data, it is enlarged.

Arguments:

    pbSource supplies the data to place in the data buffer.

    cbLength supplies the length of that data, in bytes.

Return Value:

    The address of the buffer.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

LPBYTE
CBuffer::Set(
    IN const BYTE * const pbSource,
    IN DWORD cbLength)
{
    LPBYTE pb = Presize(cbLength, FALSE);
    if (0 < cbLength)
        memcpy(pb, pbSource, cbLength);
    m_cbDataLength = cbLength;
    return pb;
}


/*++

CBuffer::Append:

    This method appends the supplied data onto the end of the existing data,
    enlarging the buffer if necessary.

Arguments:

    pbSource supplies the data to be appended.

    cbLength supplies the length of the data to be appended, in bytes.

Return Value:

    The address of the buffer.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

LPBYTE
CBuffer::Append(
    IN const BYTE * const pbSource,
    IN DWORD cbLength)
{
    LPBYTE pb = m_pbBuffer;
    if (0 < cbLength)
    {
        pb = Presize(m_cbDataLength + cbLength, TRUE);
        memcpy(&pb[m_cbDataLength], pbSource, cbLength);
        m_cbDataLength += cbLength;
    }
    return pb;
}


/*++

CBuffer::Compare:

    This method compares the contents of another CBuffer to this one, and
    returns a value indicating a comparative value.

Arguments:

    bfSource supplies the other buffer.

Return Value:

    < 0 - The other buffer is less than this one.
    = 0 - The other buffer is identical to this one.
    > 0 - The other buffer is greater than this one.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

int
CBuffer::Compare(
    const CBuffer &bfSource)
const
{
    if (m_cbDataLength < bfSource.m_cbDataLength)
        return -1;
    else if (m_cbDataLength > bfSource.m_cbDataLength)
        return 1;
    else if (0 < m_cbDataLength)
        return memcmp(m_pbBuffer, bfSource.m_pbBuffer, m_cbDataLength);
    else
        return 0;
}


/*++

operator+:

    This routine is a special operator that allows addition of two CBuffers to
    produce a third, a la bfThree = bfOne + bfTwo.  It calls the special
    protected constructor of CBuffer.

Arguments:

    bfSourceOne supplies the first buffer
    bfSourceTwo supplies the second buffer

Return Value:

    A reference to a temporary CBuffer that is the concatenation of the two
    provided buffers.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

#pragma warning(push)
#pragma warning (disable : 4172)
CBuffer &
operator+(
    IN const CBuffer &bfSourceOne,
    IN const CBuffer &bfSourceTwo)
{
    return CBuffer(bfSourceOne, bfSourceTwo);
}
#pragma warning (pop)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\scardlib\handles.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    handles

Abstract:

    This header file describes the handle management service.

Author:

    Doug Barlow (dbarlow) 5/9/1996

Environment:

    Win32, C++ w/ Exceptions

Notes:

    ?Notes?

--*/

#ifndef _HANDLES_H_
#define _HANDLES_H_

#ifndef HANDLE_TYPE
#define HANDLE_TYPE DWORD_PTR
#endif

#if defined(_WIN64) || defined(WIN64)
static const DWORD_PTR
    HANDLE_INDEX_MASK   = 0x000000007fffffff,
    HANDLE_COUNT_MASK   = 0x00ffffff00000000,
    HANDLE_ID_MASK      = 0xff00000000000000;
static const DWORD
    HANDLE_INDEX_OFFSET = 0,
    HANDLE_COUNT_OFFSET = 32,
    HANDLE_ID_OFFSET    = 56;
#elif defined(_WIN32) || defined(WIN32)
static const DWORD_PTR
    HANDLE_INDEX_MASK   = 0x0000ffff,
    HANDLE_COUNT_MASK   = 0x00ff0000,
    HANDLE_ID_MASK      = 0xff000000;
static const DWORD
    HANDLE_INDEX_OFFSET = 0,
    HANDLE_COUNT_OFFSET = 16,
    HANDLE_ID_OFFSET    = 24;
#else
#error "Unsupported handle type length"
#endif

class CHandleList;


//
//==============================================================================
//
//  CCritSect
//

class CCritSect
{
public:
    CCritSect(LPCRITICAL_SECTION pCritSect)
    {
        m_pCritSect = pCritSect;
        EnterCriticalSection(m_pCritSect);
    };

    ~CCritSect()
    {
        LeaveCriticalSection(m_pCritSect);
    };

protected:
    LPCRITICAL_SECTION m_pCritSect;
};


//
//==============================================================================
//
//  CHandle
//

class CHandle
{
protected:
    //  Constructors & Destructor

    CHandle()
    {
        m_dwCount = 0;
        m_dwIndex = (DWORD)(HANDLE_INDEX_MASK >> HANDLE_INDEX_OFFSET);
    };

    virtual ~CHandle() { /* Mandatory Base Class Destructor */ };


    //  Properties

    DWORD m_dwCount;
    DWORD m_dwIndex;


    //  Methods

    friend class CHandleList;
};


//
//==============================================================================
//
//  CHandleList
//

class CHandleList
{
public:

    //  Constructors & Destructor

    CHandleList(DWORD dwHandleId)
    {
        m_dwId = dwHandleId;
        m_Max = m_Mac = 0;
        m_phList = NULL;
        InitializeCriticalSection(&m_critSect);
    };

    virtual ~CHandleList()
    {
        Clear();
        DeleteCriticalSection(&m_critSect);
    };


    //  Properties
    //  Methods

    DWORD Count(void)
    {
        CCritSect csLock(&m_critSect);
        return m_Mac;
    };

    void
    Clear(void)
    {
        CCritSect csLock(&m_critSect);
        if (NULL != m_phList)
        {
            for (DWORD index = 0; index < m_Mac; index += 1)
                if (NULL != m_phList[index].phObject)
                    delete m_phList[index].phObject;
            delete[] m_phList;
            m_phList = NULL;
            m_Max = 0;
            m_Mac = 0;
        }
    };

    CHandle *
    Close(
        IN HANDLE_TYPE hItem);

    HANDLE_TYPE
    Add(
        IN CHandle *phItem);

    CHandle * const
    GetQuietly(
        IN HANDLE_TYPE hItem);

    CHandle * const
    Get(
        IN HANDLE_TYPE hItem);

    HANDLE_TYPE
    IndexHandle(
        DWORD nItem);


    //  Operators

    CHandle * const
    operator[](HANDLE_TYPE hItem)
    { return Get(hItem); };

protected:

    struct HandlePtr
    {
        CHandle *phObject;
        DWORD dwCount;
    };

    //  Properties


    DWORD
        m_dwId;          // Id number of handle list.
    DWORD
        m_Max,          // Number of element slots available.
        m_Mac;          // Number of element slots used.
    HandlePtr *
        m_phList;       // The elements.
    CRITICAL_SECTION
        m_critSect;     // Handle list access control.

    //  Methods

    HandlePtr *
    GetHandlePtr(
        IN HANDLE_TYPE hItem)
    const;
};


/*++

Close:

    This routine closes an item in the handle array.

Arguments:

    hItem - Supplies the handle to the object to be closed.

Throws:

    ERROR_INVALID_HANDLE - The supplied handle value is invalid.


Return Value:

    The referenced object.

Author:

    Doug Barlow (dbarlow) 7/13/1995

--*/

inline CHandle *
CHandleList::Close(
    IN HANDLE_TYPE hItem)
{
    CHandle *phItem;
    CCritSect csLock(&m_critSect);
    HandlePtr *pHandlePtr = GetHandlePtr(hItem);
    if (NULL == pHandlePtr)
        throw (DWORD)ERROR_INVALID_HANDLE;

    phItem = pHandlePtr->phObject;
    if (NULL == phItem)
        throw (DWORD)ERROR_INVALID_HANDLE;
    pHandlePtr->phObject = NULL;
    pHandlePtr->dwCount += 1;
    return phItem;
}


/*++

Add:

    This method adds an item to the Handle list.

Arguments:

    pvItem - Supplies the value to be added to the list.

Return Value:

    The resultant handle of the Add operation.

Author:

    Doug Barlow (dbarlow) 10/10/1995

--*/

inline HANDLE_TYPE
CHandleList::Add(
    IN CHandle *phItem)
{
    DWORD index;
    HandlePtr * pHndl = NULL;


    //
    // Look for a vacant handle slot.  We look through m_Max instead of m_Mac,
    // so that if all the official ones are used, we fall into unused territory.
    //

    CCritSect csLock(&m_critSect);
    for (index = 0; index < m_Max; index += 1)
    {
        pHndl = &m_phList[index];
        if (NULL == pHndl->phObject)
            break;
        pHndl = NULL;
    }


    //
    // Make sure the array was big enough.
    //

    if (NULL == pHndl)
    {
        DWORD newSize = (0 == m_Max ? 4 : m_Max * 2);
        if ((HANDLE_INDEX_MASK >> HANDLE_INDEX_OFFSET) < newSize)
            throw (DWORD)ERROR_OUTOFMEMORY;
        pHndl = new HandlePtr[newSize];
        if (NULL == pHndl)
            throw (DWORD)ERROR_OUTOFMEMORY;
        if (NULL != m_phList)
        {
            CopyMemory(pHndl, m_phList, sizeof(HandlePtr) * m_Mac);
            delete[] m_phList;
        }
        ZeroMemory(&pHndl[m_Mac], sizeof(HandlePtr) * (newSize - m_Mac));
        m_phList = pHndl;
        m_Max = (DWORD)newSize;
        index = m_Mac++;
        pHndl = &m_phList[index];
    }
    else
    {
        if (m_Mac <= index)
            m_Mac = index + 1;
    }


    //
    // Cross index the list element and the object.
    //

    ASSERT(NULL == pHndl->phObject);
    pHndl->phObject = phItem;
    if (0 == pHndl->dwCount)
        pHndl->dwCount = 1;
    phItem->m_dwCount = (DWORD)(pHndl->dwCount
                                & (HANDLE_COUNT_MASK >> HANDLE_COUNT_OFFSET));
    phItem->m_dwIndex = index;
    return (HANDLE_TYPE)(
                  ((((HANDLE_TYPE)m_dwId)          << HANDLE_ID_OFFSET)   & HANDLE_ID_MASK)
                | ((((HANDLE_TYPE)pHndl->dwCount) << HANDLE_COUNT_OFFSET) & HANDLE_COUNT_MASK)
                | ((((HANDLE_TYPE)index)          << HANDLE_INDEX_OFFSET) & HANDLE_INDEX_MASK));
}


/*++

GetQuietly:

    This method returns the element at the given handle.  If the handle is
    invalid, it returns NULL.  It does not expand the array.

Arguments:

    hItem - Supplies the index into the list.

Return Value:

    The value stored at that handle in the list, or NULL if the handle is
    invalid.

Author:

    Doug Barlow (dbarlow) 7/13/1995

--*/

inline CHandle * const
CHandleList::GetQuietly(
    HANDLE_TYPE hItem)
{
    CCritSect csLock(&m_critSect);
    HandlePtr *pHandlePtr = GetHandlePtr(hItem);
    if (NULL == pHandlePtr)
        return NULL;
    return pHandlePtr->phObject;
}


/*++

Get:

    This method returns the element at the given handle.  If the handle is
    invalid, it throws an error.  It does not expand the array.

Arguments:

    hItem - Supplies the index into the list.

Return Value:

    The value stored at that handle in the list.

Throws:

    ERROR_INVALID_HANDLE - Invalid handle value.

Author:

    Doug Barlow (dbarlow) 7/13/1995

--*/

inline CHandle * const
CHandleList::Get(
    HANDLE_TYPE hItem)
{
    CCritSect csLock(&m_critSect);
    HandlePtr *pHandlePtr = GetHandlePtr(hItem);
    if (NULL == pHandlePtr)
        throw (DWORD)ERROR_INVALID_HANDLE;
    return pHandlePtr->phObject;
}


/*++

GetHandlePtr:

    This routine finds the HandlePtr structure corresponding to a given handle.

Arguments:

    hItem supplies the handle to look up.

Return Value:

    The address of the HandlePtr structure corresponding to the handle, or NULL
    if none exists.

Author:

    Doug Barlow (dbarlow) 5/9/1996

--*/

inline CHandleList::HandlePtr *
CHandleList::GetHandlePtr(
    HANDLE_TYPE hItem)
    const
{
    try
    {
        HandlePtr *pHandlePtr;
        DWORD_PTR dwItem  = (DWORD_PTR)hItem;
        DWORD dwId    = (DWORD)((dwItem & HANDLE_ID_MASK)    >> HANDLE_ID_OFFSET);
        DWORD dwCount = (DWORD)((dwItem & HANDLE_COUNT_MASK) >> HANDLE_COUNT_OFFSET);
        DWORD dwIndex = (DWORD)((dwItem & HANDLE_INDEX_MASK) >> HANDLE_INDEX_OFFSET);

        if (dwId != (m_dwId & (HANDLE_ID_MASK >> HANDLE_ID_OFFSET))
                || (m_Mac <= dwIndex))
            return NULL;

        pHandlePtr = &m_phList[dwIndex];
        if (dwCount
                != (pHandlePtr->dwCount
                    & (HANDLE_ID_MASK >> HANDLE_ID_OFFSET)))
            return NULL;

        return pHandlePtr;
    }
    catch (...)
    {
        // Swallow the error.
    }
    return NULL;
}


/*++

IndexHandle:

    This method converts an index into a handle.  The handle is NULL if there is
    no element stored at that index.

Arguments:

    nItem supplies the index of the object to reference.

Return Value:

    The handle of the object, or NULL if there is no object at that index.

Throws:

    None

Author:

    Doug Barlow (dbarlow) 1/3/1997

--*/

inline HANDLE_TYPE
CHandleList::IndexHandle(
    DWORD nItem)
{
    HANDLE_TYPE hItem = NULL;
    HandlePtr * pHndl;

    CCritSect csLock(&m_critSect);
    if (m_Mac > nItem)
    {
        pHndl = &m_phList[nItem];
        if (NULL != pHndl->phObject)
        {
            hItem =
                  ((((HANDLE_TYPE)m_dwId)         << HANDLE_ID_OFFSET) & HANDLE_ID_MASK)
                | ((((HANDLE_TYPE)pHndl->dwCount) << HANDLE_COUNT_OFFSET) & HANDLE_COUNT_MASK)
                | ((((HANDLE_TYPE)nItem)          << HANDLE_INDEX_OFFSET) & HANDLE_INDEX_MASK);
        }
    }
    return hItem;
}

#endif // _HANDLES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\scardlib\misc.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    misc

Abstract:

    This module contains an interesting collection of routines that are
    generally useful in the Calais context, but don't seem to fit anywhere else.

Author:

    Doug Barlow (dbarlow) 11/14/1996

Environment:

    Win32, C++ w/ Exceptions

Notes:

    ?Notes?

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <Windows.h>
#include "SCardLib.h"
#include <stdio.h>
#include <stdarg.h>
#include <tchar.h>


/*++

MemCompare:

    This routine compares memory sections.

Arguments:

    pbOne supplies the address of the first block of memory

    pbTwo supplies the address of the second block of memory

    cbLength supplies the length of the two memory segments.

Return Value:

    the difference between the first two differing bytes, or zero if they're the
    identical.

Throws:

    None

Author:

    Doug Barlow (dbarlow) 11/26/1996

--*/

int
MemCompare(
    IN LPCBYTE pbOne,
    IN LPCBYTE pbTwo,
    IN DWORD cbLength)
{
    for (DWORD index = 0; index < cbLength; index += 1)
    {
        if (*pbOne++ != *pbTwo++)
            return (int)*(--pbOne) - (int)*(--pbTwo);
    }
    return 0;
}


/*++

MStrAdd:

    This method adds a string to the end of a multistring contained in a
    CBuffer.  The CBuffer may be empty, in which case its value becomes a
    multistring with the single string element.

Arguments:

    bfMsz supplies the multistring to be modified.

    szAdd supplies the string to append.

Return Value:

    the number of strings in the resulting multistring.

Throws:

    None

Author:

    Doug Barlow (dbarlow) 1/29/1997

--*/

DWORD
MStrAdd(
    IN OUT CBuffer &bfMsz,
    IN LPCSTR szAdd)
{
    DWORD dwLen, dwAddLen;
    CBuffer bfTmp;

    dwLen = bfMsz.Length();
    if (0 < dwLen)
    {
        ASSERT(2 * sizeof(TCHAR) <= dwLen);
        ASSERT(0 == *(LPCTSTR)(bfMsz.Access(dwLen - sizeof(TCHAR))));
        ASSERT(0 == *(LPCTSTR)(bfMsz.Access(dwLen - 2 * sizeof(TCHAR))));
        dwLen -= sizeof(TCHAR);
    }

    dwAddLen = MoveString(bfTmp, szAdd);
    bfMsz.Presize((dwLen + dwAddLen + 1) * sizeof(TCHAR), TRUE);
    bfMsz.Resize(dwLen, TRUE);  // Trim one trailing NULL, if any.
    bfMsz.Append(bfTmp.Access(), dwAddLen * sizeof(TCHAR));
    bfMsz.Append((LPBYTE)TEXT("\000"), sizeof(TCHAR));
    return MStrLen(bfMsz);
}

DWORD
MStrAdd(
    IN OUT CBuffer &bfMsz,
    IN LPCWSTR szAdd)
{
    DWORD dwLen, dwAddLen;
    CBuffer bfTmp;

    dwLen = bfMsz.Length();
    if (0 < dwLen)
    {
        ASSERT(2 * sizeof(TCHAR) <= dwLen);
        ASSERT(0 == *(LPCTSTR)(bfMsz.Access(dwLen - sizeof(TCHAR))));
        ASSERT(0 == *(LPCTSTR)(bfMsz.Access(dwLen - 2 * sizeof(TCHAR))));
        dwLen -= sizeof(TCHAR);
    }

    dwAddLen = MoveString(bfTmp, szAdd);
    bfMsz.Presize((dwLen + dwAddLen + 2) * sizeof(TCHAR), TRUE);
    bfMsz.Resize(dwLen, TRUE);  // Trim one trailing NULL, if any.
    bfMsz.Append(bfTmp.Access(), dwAddLen * sizeof(TCHAR));
    bfMsz.Append((LPBYTE)TEXT("\000"), sizeof(TCHAR));
    return MStrLen(bfMsz);
}


/*++

MStrLen:

    This routine determines the length of a Multi-string, in characters.

Arguments:

    mszString supplies the string to compute the length of.

Return Value:

    The length of the string, in characters, including trailing zeroes.

Author:

    Doug Barlow (dbarlow) 11/14/1996

--*/

DWORD
MStrLen(
    LPCSTR mszString)
{
    DWORD dwLen, dwTotLen = 0;

    for (;;)
    {
        dwLen = lstrlenA(&mszString[dwTotLen]);
        dwTotLen += dwLen + 1;
        if (0 == dwLen)
            break;
    }
    if (2 > dwTotLen)
        dwTotLen = 2;  // Include the second trailing null character.
    return dwTotLen;
}

DWORD
MStrLen(
    LPCWSTR mszString)
{
    DWORD dwLen, dwTotLen = 0;

    for (;;)
    {
        dwLen = lstrlenW(&mszString[dwTotLen]);
        dwTotLen += dwLen + 1;
        if (0 == dwLen)
            break;
    }
    if (2 > dwTotLen)
        dwTotLen = 2;  // Include the second trailing null character.
    return dwTotLen;
}


/*++

FirstString:

    This routine returns a pointer to the first string in a multistring, or NULL
    if there aren't any.

Arguments:

    szMultiString - This supplies the address of the current position within a
         Multi-string structure.

Return Value:

    The address of the first null-terminated string in the structure, or NULL if
    there are no strings.

Author:

    Doug Barlow (dbarlow) 11/25/1996

--*/

LPCTSTR
FirstString(
    IN LPCTSTR szMultiString)
{
    LPCTSTR szFirst = NULL;

    try
    {
        if (0 != *szMultiString)
            szFirst = szMultiString;
    }
    catch (...) {}

    return szFirst;
}



/*++

NextString:

    In some cases, the Smartcard API returns multiple strings, separated by Null
    characters, and terminated by two null characters in a row.  This routine
    simplifies access to such structures.  Given the current string in a
    multi-string structure, it returns the next string, or NULL if no other
    strings follow the current string.

Arguments:

    szMultiString - This supplies the address of the current position within a
         Multi-string structure.

Return Value:

    The address of the next Null-terminated string in the structure, or NULL if
    no more strings follow.

Author:

    Doug Barlow (dbarlow) 8/12/1996

--*/

LPCTSTR
NextString(
    IN LPCTSTR szMultiString)
{
    LPCTSTR szNext;

    try
    {
        DWORD cchLen = lstrlen(szMultiString);
        if (0 == cchLen)
            szNext = NULL;
        else
        {
            szNext = szMultiString + cchLen + 1;
            if (0 == *szNext)
                szNext = NULL;
        }
    }

    catch (...)
    {
        szNext = NULL;
    }

    return szNext;
}


/*++

StringIndex:

    In some cases, the Smartcard API returns multiple strings, separated by Null
    characters, and terminated by two null characters in a row.  This routine
    simplifies access to such structures.  Given the starting address of a
    multi-string structure, it returns the nth string in the structure, where n
    is a zero-based index.  If the supplied value for n exceeds the number of
    strings in the structure, NULL is returned.

Arguments:

    szMultiString - This supplies the address of the Multi-string structure.

    dwIndex - This supplies the index value into the structure.

Return Value:

    The address of the specified Null-terminated string in the structure, or
    NULL if dwIndex indexes beyond the end of the structure.

Author:

    Doug Barlow (dbarlow) 8/12/1996

--*/

LPCTSTR
StringIndex(
    IN LPCTSTR szMultiString,
    IN DWORD dwIndex)
{
    LPCTSTR szCurrent = szMultiString;

    try
    {
        DWORD index;
        for (index = 0; (index < dwIndex) && (NULL != szCurrent); index += 1)
            szCurrent = NextString(szCurrent);
    }

    catch (...)
    {
        szCurrent = NULL;
    }

    return szCurrent;
}


/*++

MStringCount:

    This routine returns the count of the number of strings in a multistring

Arguments:

    mszInString supplies the input string to be sorted.

Return Value:

    The count of strings

Throws:

    None

Author:

    Ross Garmoe (v-rossg) 12/05/1996

--*/

DWORD
MStringCount(
    LPCTSTR mszInString)
{
    LPCTSTR szCurrent;
        DWORD   cStr = 0;

    //
    // Count the strings
    //

    for (szCurrent = FirstString(mszInString);
         NULL != szCurrent;
         szCurrent = NextString(szCurrent))
        cStr++;

        return (cStr);
}


/*++

MStringSort:

    This routine rearranges a multistring so that the elements are sorted and
    duplicates are eliminated.

Arguments:

    mszInString supplies the input string to be sorted.

    bfOutString receives the sorted string.

Return Value:

    Count of strings in the multistring

Throws:

    None

Author:

    Doug Barlow (dbarlow) 11/25/1996

--*/

DWORD
MStringSort(
    LPCTSTR mszInString,
    CBuffer &bfOutString)
{
    LPCTSTR szCurrent;
    LPCTSTR szTmp;
    CDynamicArray<const TCHAR> rgszElements;
    DWORD ix, jx, kx, nMax;
    int nDiff;


    //
    // Set up for the sort.
    //

    for (szCurrent = FirstString(mszInString);
         NULL != szCurrent;
         szCurrent = NextString(szCurrent))
        rgszElements.Add(szCurrent);


    //
    // Do a simple bubble sort, eliminating duplicates.  (We don't use qsort
    // here, to ensure that the Run-time library doesn't get pulled in.)
    //

    nMax = rgszElements.Count();
    if (0 == nMax)
    {
        bfOutString.Set((LPCBYTE)TEXT("\000"), 2 * sizeof(TCHAR));
        return (nMax);     // No elements implies nothing to do.
    }
    for (ix = 0; ix < nMax; ix += 1)
    {
        for (jx = nMax - 1; ix < jx; jx -= 1)
        {
            nDiff = lstrcmpi(rgszElements[jx - 1], rgszElements[jx]);
            if (0 < nDiff)
            {
                szTmp = rgszElements.Get(jx - 1);
                rgszElements.Set(jx - 1, rgszElements.Get(jx));
                rgszElements.Set(jx, szTmp);
            }
            else if (0 == nDiff)
            {
                for (kx = jx; kx < nMax - 1; kx += 1)
                    rgszElements.Set(kx, rgszElements.Get(kx + 1));
                rgszElements.Set(nMax -1, NULL);
                nMax -= 1;
            }
            // else 0 > nDiff, which is what we want.
        }
    }


    //
    // Write the sorted strings to the output buffer.
    //

    jx = 0;
    for (ix = 0; ix < nMax; ix += 1)
        jx += lstrlen(rgszElements[ix]) + 1;
    bfOutString.Presize((jx + 2) * sizeof(TCHAR));
    bfOutString.Reset();

    for (ix = 0; ix < nMax; ix += 1)
    {
        szTmp = rgszElements[ix];
        bfOutString.Append(
                (LPCBYTE)szTmp,
                (lstrlen(szTmp) + 1) * sizeof(TCHAR));
    }
    bfOutString.Append((LPCBYTE)TEXT("\000"), sizeof(TCHAR));
    return (nMax);
}


/*++

MStringMerge:

    This routine merges two Multistrings into a single multistring without
    duplicate entries.

Arguments:

    mszOne supplies the first multistring.

    mszTwo supplies the secong multistring.

    bfOutString receives the combined strings.

Return Value:

    Count of strings in the multistring

Throws:

    None

Author:

    Doug Barlow (dbarlow) 11/25/1996

--*/

DWORD
MStringMerge(
    LPCTSTR mszOne,
    LPCTSTR mszTwo,
    CBuffer &bfOutString)
{
    DWORD dwLenOne = (MStrLen(mszOne) - 1) * sizeof(TCHAR);
    DWORD dwLenTwo = MStrLen(mszTwo) * sizeof(TCHAR);
    CBuffer bfTmp;

    bfTmp.Presize((dwLenOne + dwLenTwo) * sizeof(TCHAR));
    bfTmp.Set((LPCBYTE)mszOne, dwLenOne);
    bfTmp.Append((LPCBYTE)mszTwo, dwLenTwo);

    return MStringSort((LPCTSTR)bfTmp.Access(), bfOutString);
}


/*++

MStringCommon:

    This routine finds strings which are common to both supplied multistrings,
    and returns the list of commonalities.

Arguments:

    mszOne supplies the first multistring.

    mszTwo supplies the secong multistring.

    bfOutString receives the intersection of the strings.

Return Value:

    Count of strings in the multistring

Throws:

    None

Author:

    Doug Barlow (dbarlow) 11/25/1996

--*/

DWORD
MStringCommon(
    LPCTSTR mszOne,
    LPCTSTR mszTwo,
    CBuffer &bfOutString)
{
    CBuffer bfOne, bfTwo;
    LPCTSTR szOne, szTwo;
    DWORD dwStrings = 0;
    int nDiff;

    bfOutString.Reset();
    MStringSort(mszOne, bfOne);
    MStringSort(mszTwo, bfTwo);
    szOne = FirstString(bfOne);
    szTwo = FirstString(bfTwo);

    while ((NULL != szOne) && (NULL != szTwo))
    {
        nDiff = lstrcmpi(szOne, szTwo);
        if (0 > nDiff)
            szOne = NextString(szOne);
        else if (0 < nDiff)
            szTwo = NextString(szTwo);
        else    // a match!
        {
            bfOutString.Append(
                (LPCBYTE)szOne,
                (lstrlen(szOne) + 1) * sizeof(TCHAR));
            szOne = NextString(szOne);
            szTwo = NextString(szTwo);
            dwStrings += 1;
        }
    }
    if (0 == dwStrings)
        bfOutString.Append((LPCBYTE)TEXT("\000"), 2 * sizeof(TCHAR));
    else
        bfOutString.Append((LPCBYTE)TEXT("\000"), sizeof(TCHAR));
    return dwStrings;
}


/*++

MStringRemove:

    This routine scans the first supplied multistring, removing any entries that
    exist in the second string.

Arguments:

    mszOne supplies the first multistring.

    mszTwo supplies the secong multistring.

    bfOutString receives the value of the first string without the second
        string.

Return Value:

    Number of strings in output buffer

Throws:

    None

Author:

    Doug Barlow (dbarlow) 11/25/1996

--*/

DWORD
MStringRemove(
    LPCTSTR mszOne,
    LPCTSTR mszTwo,
    CBuffer &bfOutString)
{
    CBuffer bfOne, bfTwo;
    LPCTSTR szOne, szTwo;
    int nDiff;
        DWORD   cStr = 0;

    bfOutString.Reset();
    MStringSort(mszOne, bfOne);
    MStringSort(mszTwo, bfTwo);
    szOne = FirstString(bfOne);
    szTwo = FirstString(bfTwo);

    while ((NULL != szOne) && (NULL != szTwo))
    {
        nDiff = lstrcmpi(szOne, szTwo);
        if (0 > nDiff)
        {
            bfOutString.Append(
                (LPCBYTE)szOne,
                (lstrlen(szOne) + 1) * sizeof(TCHAR));
            szOne = NextString(szOne);
                        cStr++;
        }
        else if (0 < nDiff)
        {
            szTwo = NextString(szTwo);
        }
        else    // a match!
        {
            szOne = NextString(szOne);
            szTwo = NextString(szTwo);
        }
    }
    while (NULL != szOne)
    {
                bfOutString.Append(
                        (LPCBYTE)szOne,
                        (lstrlen(szOne) + 1) * sizeof(TCHAR));
                        szOne = NextString(szOne);
                cStr++;
    }
    bfOutString.Append(
        (LPCBYTE)TEXT("\000"),
        (DWORD)(0 == cStr ? 2 * sizeof(TCHAR) :sizeof(TCHAR)));
    return cStr;
}


/*++

ParseAtr:

    This routine parses an ATR string.

Arguments:

    pbAtr supplies the ATR string.

    pdwAtrLen receives the length of the ATR string.  This is an optional
        parameter, and may be NULL.

    pdwHistOffset receives the offset into the ATR string at which the history
        string starts; i.e., the history string is at pbAtr[*pdwOffset].

    pcbHisory receives the length of the history string, in bytes.

    cbMaxLen supplies the maximum length of this ATR string.  Typically this is
        33, but you can restrict it to less by setting this parameter.

Return Value:

    TRUE - Valid ATR
    FALSE - Invalid ATR

Author:

    Doug Barlow (dbarlow) 11/14/1996

--*/

BOOL
ParseAtr(
    LPCBYTE pbAtr,
    LPDWORD pdwAtrLen,
    LPDWORD pdwHistOffset,
    LPDWORD pcbHistory,
    DWORD cbMaxLen)
{
    static const BYTE rgbYMap[] = {
        0,      // 0000
        1,      // 0001
        1,      // 0010
        2,      // 0011
        1,      // 0100
        2,      // 0101
        2,      // 0110
        3,      // 0111
        1,      // 1000
        2,      // 1001
        2,      // 1010
        3,      // 1011
        2,      // 1100
        3,      // 1101
        3,      // 1110
        4 };    // 1111
    DWORD dwHistLen, dwHistOffset, dwTDLen, dwIndex, dwAtrLen;
    BOOL fTck = FALSE;


    ASSERT(33 >= cbMaxLen);
    try
    {


        //
        // Get the ATR string, if any.
        //

        if ((0x3b != pbAtr[0]) && (0x3f != pbAtr[0]))
            throw (DWORD)ERROR_NOT_SUPPORTED;
        dwHistLen = pbAtr[1] & 0x0f;
        dwIndex = 1;
        dwTDLen = 0;
        for (;;)
        {
            dwIndex += dwTDLen;
            dwTDLen = rgbYMap[(pbAtr[dwIndex] >> 4) & 0x0f];
            if (cbMaxLen < dwIndex + dwTDLen + dwHistLen)
                throw (DWORD)ERROR_INVALID_DATA;
            if (0 == dwTDLen)
                break;
            if (0 != (pbAtr[dwIndex] & 0x80))
            {
                if (0 != (pbAtr[dwIndex + dwTDLen] & 0x0f))
                    fTck = TRUE;
            }
            else
                break;
        }
        dwIndex += dwTDLen + 1;
        dwHistOffset = dwIndex;
        dwAtrLen = dwIndex + dwHistLen + (fTck ? 1 : 0);
        if (cbMaxLen < dwAtrLen)
            throw (DWORD)ERROR_INVALID_DATA;
        if (fTck)
        {
            BYTE bXor = 0;
            for (dwIndex = 1; dwIndex < dwAtrLen; dwIndex += 1)
                bXor ^= pbAtr[dwIndex];
            if (0 != bXor)
                throw (DWORD)ERROR_INVALID_DATA;
        }
    }

    catch (...)
    {
        return FALSE;
    }


    //
    // Let the caller in on what we know.
    //

    if (NULL != pdwAtrLen)
        *pdwAtrLen = dwAtrLen;
    if (NULL != pdwHistOffset)
        *pdwHistOffset = dwHistOffset;
    if (NULL != pcbHistory)
        *pcbHistory = dwHistLen;
    return TRUE;
}


/*++

AtrCompare:

    This routine compares two ATRs for equality, given an optional ATR mask.  If
    the mask is supplied, ATR1 XORed against the mask must match ATR2.

Arguments:

    pbAtr1 supplies the first ATR.

    pbAtr2 supplies the second ATR,

    pbMask supplies the ATR mask associated with the 2nd ATR.  If this
        parameter is NULL, no mask is used.

    cbAtr2 supplies the length of ATR2 and it's mask.  This value may be zero
        if the length should be derived from ATR2.

Return Value:

    TRUE - They are identical
    FALSE - They differ.

Author:

    Doug Barlow (dbarlow) 11/25/1996

--*/

BOOL
AtrCompare(
    LPCBYTE pbAtr1,
    LPCBYTE pbAtr2,
    LPCBYTE pbMask,
    DWORD cbAtr2)
{
    DWORD dwAtr1Len = 0;
    DWORD dwAtr2Len = 0;


    //
    // Trivial checks.
    //

    if (!ParseAtr(pbAtr1, &dwAtr1Len))
        return FALSE;   // Invalid ATR.
    if ((NULL == pbMask) || (0 == cbAtr2))
    {
        if (!ParseAtr(pbAtr2, &dwAtr2Len))
            return FALSE;   // Invalid ATR.
        if ((0 != cbAtr2) && (dwAtr2Len != cbAtr2))
            return FALSE;   // Lengths don't match.
        if (dwAtr1Len != dwAtr2Len)
            return FALSE;   // Different lengths.
    }
    else
    {
        dwAtr2Len = cbAtr2;
        if (dwAtr1Len != dwAtr2Len)
            return FALSE;   // Different lengths.
    }


    //
    // Apply the mask, if any.
    //

    if (NULL != pbMask)
    {
        for (DWORD index = 0; index < dwAtr2Len; index += 1)
        {
            if ((pbAtr1[index] & pbMask[index]) != pbAtr2[index])
                return FALSE;   // Byte mismatch.
        }
    }
    else
    {
        for (DWORD index = 0; index < dwAtr2Len; index += 1)
        {
            if (pbAtr1[index] != pbAtr2[index])
                return FALSE;   // Byte mismatch.
        }
    }


    //
    // If we get here, they match.
    //

    return TRUE;
}


/*++

GetPlatform:

    This routine determines, to the best of its ability, the underlying
    operating system.

Arguments:

    None

Return Value:

    A DWORD, formatted as follows:

        +-------------------------------------------------------------------+
        |             OpSys Id            | Major  Version | Minor  Version |
        +-------------------------------------------------------------------+
    Bit  31                             16 15             8 7              0

    Predefined values are:

        PLATFORM_UNKNOWN - The platform cannot be determined
        PLATFORM_WIN95   - The platform is Windows 95
        PLATFORM_WIN97   - The platform is Windows 97
        PLATFORM_WINNT40 - The platform is Windows NT V4.0
        PLATFORM_WINNT50 - The platform is Windows NT V5.0

Throws:

    None

Author:

    Doug Barlow (dbarlow) 1/16/1997
        Taken from a collection of common routines with no authorship
        information.

--*/

DWORD
GetPlatform(
    void)
{
    static DWORD dwPlatform = PLATFORM_UNKNOWN;

    if (PLATFORM_UNKNOWN == dwPlatform)
    {
        OSVERSIONINFO osVer;

        memset(&osVer, 0, sizeof(OSVERSIONINFO));
        osVer.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        if (GetVersionEx(&osVer))
            dwPlatform =
                (osVer.dwPlatformId << 16)
                + (osVer.dwMajorVersion << 8)
                + osVer.dwMinorVersion;
    }
    return dwPlatform;
}


/*++

MoveString:

    This routine moves an ASCII or UNICODE string into a buffer, converting to
    the character set in use.

Arguments:

    bfDst receives the string, converted to TCHARs, and NULL terminated.

    szSrc supplies the original string.

    dwLength supplies the length of the string, with or without trailing
        nulls, in characters.  A -1 value implies the length should be
        computed based on a trailing null.

Return Value:

    The actual number of characters in the resultant string, including the
    trailing null.

Throws:

    Errors encountered, as DWORDS.

Author:

    Doug Barlow (dbarlow) 2/12/1997

--*/

DWORD
MoveString(
    CBuffer &bfDst,
    LPCSTR szSrc,
    DWORD dwLength)
{
    if ((DWORD)(-1) == dwLength)
        dwLength = lstrlenA(szSrc);
    else
    {
        while ((0 < dwLength) && (0 == szSrc[dwLength - 1]))
            dwLength -= 1;
    }

#ifdef UNICODE
    DWORD dwResultLength;

    dwResultLength =
        MultiByteToWideChar(
            GetACP(),
            MB_PRECOMPOSED | MB_USEGLYPHCHARS,
            szSrc,
            dwLength,
            NULL,
            0);
    if (0 == dwLength)
        throw GetLastError();
    bfDst.Presize((dwResultLength + 1) * sizeof(TCHAR));
    dwResultLength =
        MultiByteToWideChar(
            GetACP(),
            MB_PRECOMPOSED | MB_USEGLYPHCHARS,
            szSrc,
            dwLength,
            (LPTSTR)bfDst.Access(),
            bfDst.Space()/sizeof(TCHAR) - 1);
    if (0 == dwLength)
        throw GetLastError();
    bfDst.Resize(dwResultLength * sizeof(TCHAR), TRUE);
    dwLength = dwResultLength;
#else
    bfDst.Presize((dwLength + 1) * sizeof(TCHAR));
    bfDst.Set((LPCBYTE)szSrc, dwLength * sizeof(TCHAR));
#endif
    bfDst.Append((LPCBYTE)(TEXT("\000")), sizeof(TCHAR));
    dwLength += 1;
    return dwLength;
}

DWORD
MoveString(
    CBuffer &bfDst,
    LPCWSTR szSrc,
    DWORD dwLength)
{
    if ((DWORD)(-1) == dwLength)
        dwLength = lstrlenW(szSrc);
    else
    {
        while ((0 < dwLength) && (0 == szSrc[dwLength - 1]))
            dwLength -= 1;
    }

#ifndef UNICODE
    DWORD dwResultLength =
        WideCharToMultiByte(
            GetACP(),
            WC_COMPOSITECHECK,
            szSrc,
            dwLength,
            NULL,
            0,
            NULL,
            NULL);
    if (0 == dwResultLength)
        throw GetLastError();
    bfDst.Presize((dwResultLength + 1) * sizeof(TCHAR));
    dwResultLength =
        WideCharToMultiByte(
            GetACP(),
            WC_COMPOSITECHECK,
            szSrc,
            dwLength,
            (LPSTR)bfDst.Access(),
            bfDst.Space()/sizeof(TCHAR) - 1,
            NULL,
            NULL);
    if (0 == dwResultLength)
        throw GetLastError();
    bfDst.Resize(dwResultLength * sizeof(TCHAR), TRUE);
    dwLength = dwResultLength;
#else
    bfDst.Presize((dwLength + 1) * sizeof(TCHAR));
    bfDst.Set((LPCBYTE)szSrc, dwLength * sizeof(TCHAR));
#endif
    bfDst.Append((LPCBYTE)(TEXT("\000")), sizeof(TCHAR));
    dwLength += 1;
    return dwLength;
}


/*++

MoveToAnsiString:

    This routine moves the internal string representation to an ANSI output
    buffer.

Arguments:

    szDst receives the output string.  It must be sufficiently large enough to
        handle the string.  If this parameter is NULL, then the number of
        characters required to hold the result is returned.

    szSrc supplies the input string.

    cchLength supplies the length of the input string, with or without trailing
        nulls.  A -1 value implies the length should be computed based on a
        trailing null.

Return Value:

    The length of the resultant string, in characters, including the trailing
    null.

Throws:

    Errors as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 2/14/1997

--*/

DWORD
MoveToAnsiString(
    LPSTR szDst,
    LPCTSTR szSrc,
    DWORD cchLength)
{
    if ((DWORD)(-1) == cchLength)
        cchLength = lstrlen(szSrc);
    else
    {
        while ((0 < cchLength) && (0 == szSrc[cchLength - 1]))
            cchLength -= 1;
    }

#ifdef UNICODE
    if (0 == *szSrc)
        cchLength = 1;
    else if (NULL == szDst)
    {
        cchLength =
            WideCharToMultiByte(
            GetACP(),
            WC_COMPOSITECHECK,
            szSrc,
            cchLength,
            NULL,
            0,
            NULL,
            NULL);
        if (0 == cchLength)
            throw GetLastError();
        cchLength += 1;
    }
    else
    {
        cchLength =
            WideCharToMultiByte(
            GetACP(),
            WC_COMPOSITECHECK,
            szSrc,
            cchLength,
            szDst,
            cchLength,
            NULL,
            NULL);
        if (0 == cchLength)
            throw GetLastError();
        szDst[cchLength++] = 0;
    }
#else
    if (0 < cchLength)
    {
        cchLength += 1;
        if (NULL != szDst)
            CopyMemory(szDst, szSrc, cchLength * sizeof(TCHAR));
    }
#endif
    return cchLength;
}


/*++

MoveToUnicodeString:

    This routine moves the internal string representation to a UNICODE output
    buffer.

Arguments:

    szDst receives the output string.  It must be sufficiently large enough to
        handle the string.  If this parameter is NULL, then the number of
        characters required to hold the result is returned.

    szSrc supplies the input string.

    cchLength supplies the length of the input string, with or without trailing
        nulls.  A -1 value implies the length should be computed based on a
        trailing null.

Return Value:

    The length of the resultant string, in characters, including the trailing
    null.

Throws:

    Errors as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 2/14/1997

--*/

DWORD
MoveToUnicodeString(
    LPWSTR szDst,
    LPCTSTR szSrc,
    DWORD cchLength)
{
    if ((DWORD)(-1) == cchLength)
        cchLength = lstrlen(szSrc);
    else
    {
        while ((0 < cchLength) && (0 == szSrc[cchLength - 1]))
            cchLength -= 1;
    }

#ifndef UNICODE
    if (0 == *szSrc)
        cchLength = 1;
    else if (NULL == szDst)
    {
        cchLength =
            MultiByteToWideChar(
            GetACP(),
            MB_PRECOMPOSED | MB_USEGLYPHCHARS,
            szSrc,
            cchLength,
            NULL,
            0);
        if (0 == cchLength)
            throw GetLastError();
        cchLength += 1;
    }
    else
    {
        cchLength =
            MultiByteToWideChar(
            GetACP(),
            MB_PRECOMPOSED | MB_USEGLYPHCHARS,
            szSrc,
            cchLength,
            szDst,
            cchLength);
        if (0 == cchLength)
            throw GetLastError();
        szDst[cchLength++] = 0;
    }
#else
    cchLength += 1;
    if (NULL != szDst)
        CopyMemory(szDst, szSrc, cchLength * sizeof(TCHAR));
#endif
    return cchLength;
}


/*++

MoveToAnsiMultistring:

    This routine moves the internal multistring representation to an ANSI output
    buffer.

Arguments:

    szDst receives the output string.  It must be sufficiently large enough to
        handle the multistring.  If this parameter is NULL, then the number of
        characters required to hold the result is returned.

    szSrc supplies the input multistring.

    cchLength supplies the length of the input string, in characters, with or
        without trailing nulls.  A -1 value implies the length should be
        computed based on a double trailing null.

Return Value:

    The length of the resultant string, in characters, including the trailing
    nulls.

Throws:

    Errors as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 2/17/1997

--*/

DWORD
MoveToAnsiMultiString(
    LPSTR mszDst,
    LPCTSTR mszSrc,
    DWORD cchLength)
{
    DWORD dwLen;

    if ((DWORD)(-1) == cchLength)
        cchLength = MStrLen(mszSrc);
    dwLen = MoveToAnsiString(mszDst, mszSrc, cchLength);
    if (0 == dwLen)
    {
        if (NULL != mszDst)
            mszDst[0] = mszDst[1] = 0;
        dwLen = 2;
    }
    else
    {
        if (NULL != mszDst)
            mszDst[dwLen] = 0;
        dwLen += 1;
    }
    return dwLen;
}


/*++

MoveToUnicodeMultistring:

    This routine moves the internal multistring representation to a
    Unicode output buffer.

Arguments:

    szDst receives the output string.  It must be sufficiently large enough to
        handle the multistring.  If this parameter is NULL, then the number of
        characters required to hold the result is returned.

    szSrc supplies the input multistring.

    cchLength supplies the length of the input string, in characters, with or
        without trailing nulls.  A -1 value implies the length should be
        computed based on a double trailing null.

Return Value:

    The length of the resultant string, in characters, including the trailing
    nulls.

Throws:

    Errors as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 2/17/1997

--*/

DWORD
MoveToUnicodeMultiString(
    LPWSTR mszDst,
    LPCTSTR mszSrc,
    DWORD cchLength)
{
    DWORD dwLen;

    if ((DWORD)(-1) == cchLength)
        cchLength = MStrLen(mszSrc);
    dwLen = MoveToUnicodeString(mszDst, mszSrc, cchLength);
    if (NULL != mszDst)
        mszDst[dwLen] = 0;
    dwLen += 1;
    return dwLen;
}


/*++

ErrorString:

    This routine does it's very best to translate a given error code into a
    text message.  Any trailing non-printable characters are striped from the
    end of the text message, such as carriage returns and line feeds.

Arguments:

    dwErrorCode supplies the error code to be translated.

Return Value:

    The address of a freshly allocated text string.  Use FreeErrorString to
    dispose of it.

Throws:

    Errors are thrown as DWORD status codes.

Remarks:



Author:

    Doug Barlow (dbarlow) 8/27/1998

--*/

LPCTSTR
ErrorString(
    DWORD dwErrorCode)
{
    LPTSTR szErrorString = NULL;

    try
    {
        DWORD dwLen;
        LPTSTR szLast;

        dwLen = FormatMessage(
                    FORMAT_MESSAGE_ALLOCATE_BUFFER
                    | FORMAT_MESSAGE_FROM_SYSTEM,
                    NULL,
                    dwErrorCode,
                    LANG_NEUTRAL,
                    (LPTSTR)&szErrorString,
                    0,
                    NULL);
        if (0 == dwLen)
        {
            ASSERT(NULL == szErrorString);
            dwLen = FormatMessage(
                        FORMAT_MESSAGE_ALLOCATE_BUFFER
                        | FORMAT_MESSAGE_FROM_HMODULE,
                        GetModuleHandle(NULL),
                        dwErrorCode,
                        LANG_NEUTRAL,
                        (LPTSTR)&szErrorString,
                        0,
                        NULL);
            if (0 == dwLen)
            {
                ASSERT(NULL == szErrorString);
                szErrorString = (LPTSTR)LocalAlloc(
                                        LMEM_FIXED,
                                        32 * sizeof(TCHAR));
                if (NULL == szErrorString)
                    throw (DWORD)SCARD_E_NO_MEMORY;
                _stprintf(szErrorString, TEXT("0x%08x"), dwErrorCode);
            }
        }

        ASSERT(NULL != szErrorString);
        for (szLast = szErrorString + lstrlen(szErrorString) - 1;
             szLast > szErrorString;
             szLast -= 1)
         {
            if (_istgraph(*szLast))
                break;
            *szLast = 0;
         }
    }
    catch (...)
    {
        FreeErrorString(szErrorString);
        throw;
    }

    return szErrorString;
}


/*++

FreeErrorString:

    This routine frees the Error String allocated by the ErrorString service.

Arguments:

    szErrorString supplies the error string to be deallocated.

Return Value:

    None

Throws:

    None

Remarks:



Author:

    Doug Barlow (dbarlow) 8/27/1998

--*/

void
FreeErrorString(
    LPCTSTR szErrorString)
{
    if (NULL != szErrorString)
        LocalFree((LPVOID)szErrorString);
}


/*++

SelectString:

    This routine compares a given string to a list of possible strings, and
    returns the index of the string that matches.  The comparison is done case
    insensitive, and abbreviations are allowed, as long as they're unique.

Arguments:

    szSource supplies the string to be compared against all other strings.

    Following strings supply a list of strings against which the source string
        can be compared.  The last parameter must be NULL.

Return Value:

    0 - No match, or ambiguous match.
    1-n - The source string matches the indexed template string.

Throws:

    None

Remarks:



Author:

    Doug Barlow (dbarlow) 8/27/1998

--*/

DWORD
SelectString(
    LPCTSTR szSource,
    ...)
{
    va_list vaArgs;
    DWORD cchSourceLen;
    DWORD dwReturn = 0;
    DWORD dwIndex = 1;
    LPCTSTR szTpl;


    va_start(vaArgs, szSource);


    //
    //  Step through each input parameter until we find an exact match.
    //

    cchSourceLen = lstrlen(szSource);
    if (0 == cchSourceLen)
        return 0;       //  Empty strings don't match anything.
    szTpl = va_arg(vaArgs, LPCTSTR);
    while (NULL != szTpl)
    {
        if (0 == _tcsncicmp(szTpl, szSource, cchSourceLen))
        {
            if (0 != dwReturn)
            {
                dwReturn = 0;
                break;
            }
            dwReturn = dwIndex;
        }
        szTpl = va_arg(vaArgs, LPCTSTR);
        dwIndex += 1;
    }
    va_end(vaArgs);
    return dwReturn;
}


/*++

StringFromGuid:

    This routine converts a GUID into its corresponding string representation.
    It's here so that it's not necessary to link all of OleBase into WinSCard.
    Otherwise, we'd just use StringFromCLSID.

Arguments:

    pguidSource supplies the GUID to convert.

    szGuid receives the GUID as a string.  This string is assumed to be at
        least 39 characters long.

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 1/20/1998

--*/

void
StringFromGuid(
    IN LPCGUID pguidResult,
    OUT LPTSTR szGuid)
{

    //
    // The following placement assumes Little Endianness.
    // {1D92589A-91E4-11d1-93AA-00C04FD91402}
    // 0123456789012345678901234567890123456789
    //           1         2         3
    //

    static const WORD wPlace[sizeof(GUID)]
        = { 8, 6, 4, 2, 13, 11, 18, 16, 21, 23, 26, 28, 30, 32, 34, 36 };
    static const WORD wPunct[]
        = { 0,         9,         14,        19,        24,        37,        38 };
    static const TCHAR chPunct[]
        = { TEXT('{'), TEXT('-'), TEXT('-'), TEXT('-'), TEXT('-'), TEXT('}'), TEXT('\000') };
    DWORD dwI, dwJ;
    TCHAR ch;
    LPTSTR pch;
    LPBYTE pbGuid = (LPBYTE)pguidResult;
    BYTE bVal;

    for (dwI = 0; dwI < sizeof(GUID); dwI += 1)
    {
        bVal = pbGuid[dwI];
        pch = &szGuid[wPlace[dwI]];
        for (dwJ = 0; dwJ < 2; dwJ += 1)
        {
            ch = bVal & 0x0f;
            ch += TEXT('0');
            if (ch > TEXT('9'))
                ch += TEXT('A') - (TEXT('9') + 1);
            *pch-- = ch;
            bVal >>= 4;
        }
    }

    dwI = 0;
    do
    {
        szGuid[wPunct[dwI]] = chPunct[dwI];
    } while (0 != chPunct[dwI++]);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\ui\wizards\wzrdpvk.h ===
//--------------------------------------------------------------
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       wzrdpvk.h
//
//  Contents:   The private include file for cryptext.dll.
//
//  History:    16-09-1997 xiaohs   created
//
//--------------------------------------------------------------
#ifndef WZRDPVK_H
#define WZRDPVK_H

#include    <windows.h>
#include    <stddef.h>
#include    <malloc.h>
#include    <shellapi.h>
#include    <shlobj.h>
#include    <string.h>
#include    <objbase.h>
#include    <windowsx.h>
#include    <lmcons.h>
#include    <prsht.h>
#include    <stdlib.h>
#include    <search.h>
#include    <commctrl.h>
#include    <rpc.h>
#include    <commdlg.h>
#include    <objsel.h>
#include    "wincrypt.h"
#include    "unicode.h"
#include    "unicode5.h"
#include    "crtem.h"
#include    "certcli.h"
#include    "certrpc.h"
#include    "cryptui.h"
#include    "lenroll.h"
#include    "pfx.h"
#include    "wintrust.h"
#include    "signer.h"
#include    "dbgdef.h"
#include    "keysvc.h"
#include    "keysvcc.h"
#include    "certsrv.h"
#include    "resource.h"
#include    "internal.h"
#include    "certca.h"

#ifdef __cplusplus
extern "C" {
#endif

//global data
extern HINSTANCE g_hmodThisDll;

#define MAX_STRING_SIZE             512
#define MAX_TITLE_LENGTH            200
#define g_dwMsgAndCertEncodingType  PKCS_7_ASN_ENCODING | X509_ASN_ENCODING
#define g_wszTimeStamp              L"http://timestamp.verisign.com/scripts/timstamp.dll"
    
// Macros to allow for easier definition of locally scoped functions
// and data.  In the example below, observe that the helper function
// "functionHelper" does not pollute the gobal namespace, yet still
// provides a procedural abstraction for use within "function".   
// 
// Example:  
//
// void function() { 
//     LocalScope(HelperScope): 
//         void functionHelper() { 
//             // Do something here. 
//         }
//     EndLocalScope; 
//
//     while (...) { 
//         ...
//         local.functionHelper(); 
//     }
// }
//
#define LocalScope(ScopeName) struct ScopeName##TheLocalScope { public
#define EndLocalScope } local

// Simple error-handling macros.  
//  

// Same as _JumpCondition, but with a third parameter, expr. 
// Expr is not used in the macro, and is executed for side effects only.  
#define _JumpConditionWithExpr(condition, label, expr) if (condition) { expr; goto label; } else { } 
    
// A macro for the common test & goto instruction combination: 
#define _JumpCondition(condition, label) if (condition) { goto label; } else { } 
 

//-----------------------------------------------------------------------
//  ENROLL_PURPOSE_INFO
//
//------------------------------------------------------------------------
typedef struct _ENROLL_PURPOSE_INFO
{
    LPSTR       pszOID;
    LPWSTR      pwszName;
    BOOL        fSelected;
    BOOL        fFreeOID;
    BOOL        fFreeName;
}ENROLL_PURPOSE_INFO;


//-----------------------------------------------------------------------
//  ENROLL_OID_INFO
//
//------------------------------------------------------------------------
typedef struct _ENROLL_OID_INFO
{
    LPWSTR      pwszName;
    BOOL        fSelected;
    LPSTR       pszOID;
}ENROLL_OID_INFO;


//-----------------------------------------------------------------------
//  ENROLL_CERT_TYPE_INFO
//
//------------------------------------------------------------------------
typedef struct _ENROLL_CERT_TYPE_INFO
{
    LPWSTR              pwszDNName;         //the fully distinguished DN name of the cert type
    LPWSTR              pwszCertTypeName;
    BOOL                fSelected;
    PCERT_EXTENSIONS    pCertTypeExtensions;
    DWORD               dwKeySpec;
    DWORD               dwMinKeySize; 
    DWORD               dwRASignature; 
    DWORD               dwCSPCount;          //the count of CSP list
    DWORD               *rgdwCSP;            //the array of CSP list
    DWORD               dwEnrollmentFlags;
    DWORD               dwSubjectNameFlags;
    DWORD               dwPrivateKeyFlags;
    DWORD               dwGeneralFlags; 
}ENROLL_CERT_TYPE_INFO;

//-----------------------------------------------------------------------
//  PURPOSE_INFO_CALL_BACK
//
//------------------------------------------------------------------------
typedef struct _PURPOSE_INFO_CALL_BACK
{
    DWORD                   *pdwCount;
    ENROLL_PURPOSE_INFO     ***pprgPurpose;
}PURPOSE_INFO_CALL_BACK;


//-----------------------------------------------------------------------
//  PURPOSE_INFO_CALL_BACK
//
//------------------------------------------------------------------------
typedef struct _OID_INFO_CALL_BACK
{
    DWORD                   *pdwOIDCount;
    ENROLL_OID_INFO         **pprgOIDInfo;
}OID_INFO_CALL_BACK;

///-----------------------------------------------------------------------
//  CRYPT_WIZ_CERT_CA
//
//------------------------------------------------------------------------
typedef struct _CRYPTUI_WIZ_CERT_CA
{
    DWORD                   dwSize;
    LPWSTR                  pwszCALocation;
    LPWSTR                  pwszCAName;
    BOOL                    fSelected;
    DWORD                   dwOIDInfo;
    ENROLL_OID_INFO         *rgOIDInfo;
    DWORD                   dwCertTypeInfo;
    ENROLL_CERT_TYPE_INFO   *rgCertTypeInfo;
}CRYPTUI_WIZ_CERT_CA, *PCRYPTUI_WIZ_CERT_CA;

typedef const CRYPTUI_WIZ_CERT_CA *PCCRYPTUI_WIZ_CERT_CA;


///-----------------------------------------------------------------------
//  CRYPTUI_WIZ_CERT_CA_INFO
//
//------------------------------------------------------------------------
typedef struct _CRYPTUI_WIZ_CERT_CA_INFO
{
    DWORD                   dwSize;
    DWORD                   dwCA;
    PCRYPTUI_WIZ_CERT_CA    rgCA;
}CRYPTUI_WIZ_CERT_CA_INFO, *PCRYPTUI_WIZ_CERT_CA_INFO;

typedef const CRYPTUI_WIZ_CERT_CA_INFO *PCCRYPTUI_WIZ_CERT_CA_INFO;

typedef void * HCERTREQUESTER; 

#define CRYPTUI_WIZ_CERT_REQUEST_STATUS_INSTALL_FAILED          10
#define CRYPTUI_WIZ_CERT_REQUEST_STATUS_INSTALL_CANCELLED       11
#define CRYPTUI_WIZ_CERT_REQUEST_STATUS_KEYSVC_FAILED           12
#define CRYPTUI_WIZ_CERT_REQUEST_STATUS_REQUEST_CREATED         13 

//-----------------------------------------------------------------------
//  CERT_WIZARD_INFO
//
//
//  This struct contains everything you will ever need to enroll(renew)
//  a certificate.  This struct is private to the dll
//------------------------------------------------------------------------
typedef struct _CERT_WIZARD_INFO
{
    DWORD               dwFlags;
    DWORD               dwPurpose;
    HWND                hwndParent;
    BOOL                fConfirmation;
    LPCWSTR             pwszConfirmationTitle;
    UINT                idsConfirmTitle;
    UINT                idsText;                    //the ids for message box
    HRESULT             hr;                         //the hresult of I_EnrollCertificate
    BOOL                fNewKey;
    DWORD               dwPostOption;
    PCCERT_CONTEXT      pCertContext;
    BOOL                fLocal;
    LPCWSTR             pwszMachineName;
    LPCWSTR             pwszAccountName;
    DWORD               dwStoreFlags;
    void                *pAuthentication;
    LPCWSTR             pwszRequestString;
    LPWSTR              pwszCALocation;
    LPWSTR              pwszCAName;
    PCRYPTUI_WIZ_CERT_CA_INFO  pCertCAInfo;
    DWORD               dwCAIndex;
    LPCWSTR             pwszDesStore;
    LPCWSTR              pwszCertDNName;
    LPCSTR              pszHashAlg;
    LPWSTR              pwszFriendlyName;
    LPWSTR              pwszDescription;
    DWORD               dwProviderType;
    LPWSTR              pwszProvider;
    DWORD               dwProviderFlags;
    LPCWSTR             pwszKeyContainer;
    DWORD               dwKeySpec;
    DWORD               dwGenKeyFlags;
    DWORD               dwMinKeySize; 
    DWORD               dwEnrollmentFlags;
    DWORD               dwSubjectNameFlags;
    DWORD               dwPrivateKeyFlags;
    DWORD               dwGeneralFlags; 
    HFONT               hBigBold;
    HFONT               hBold;
    DWORD               dwCSPCount;
    DWORD               *rgdwProviderType;
    LPWSTR              *rgwszProvider;
    BOOL                fCertTypeChanged;           //Whether user has changed the cert type selection:
    DWORD               dwStatus;
    PCERT_EXTENSIONS    pCertRequestExtensions;
    PCCERT_CONTEXT      pNewCertContext;
    LPWSTR              pwszSelectedCertTypeDN;     //the DN name of the selected cert type  
    BOOL                fUICSP;                     //fCSPPage: whether we need to show the CSP page in the UI
    BOOL                fUIAdv;                     //whether we need to show the advanced options in the UI
    BOOL                fCAInput;                   //whether user has passed me the CA information
    int                 iOrgCertType;               //mark the original selected CertType index
    int                 iOrgCSP;                    //mark the original selected CSP index
    DWORD               dwOrgCA;                    //mark the original selected CA.  This CA has priority when we make our CA selection
    BOOL                fMachine;
    BOOL                fIgnore;                    //whether we ignore the dwKeySpec and exportable GenKeyFlags.
    BOOL                fKnownCSP;                  //whether the CSP was selected  by the API
    DWORD               dwOrgCSPType;               //the orignal CSP type
    LPWSTR              pwszOrgCSPName;             //the orignal CSP name
    LPWSTR              *awszAllowedCertTypes;      //Allowed cert types for remote enrollment or local machin enrollment
    LPWSTR              *awszValidCA;		    //Allowed cert types for remote enrollment or local machin enrollment
    HCURSOR             hPrevCursor;                //the privous cursor before we change it to the hour glass
    HCURSOR             hWinPrevCursor;             //the privous cursor before we change it to the hour glass
    BOOL                fCursorChanged;             //keep track if the cursor has been changed
    LPWSTR		pwszCADisplayName;	    //the cached CA display name.
    HCERTREQUESTER      hRequester; 
}CERT_WIZARD_INFO;


//-----------------------------------------------------------------------
//  ENROLL_PAGE_INFO
//
//------------------------------------------------------------------------
typedef struct _ENROLL_PAGE_INFO
{
    LPCWSTR      pszTemplate;
    DLGPROC     pfnDlgProc;
}ENROLL_PAGE_INFO;



//-----------------------------------------------------------------------
//  Constats
//
//------------------------------------------------------------------------
#define     ENROLL_PROP_SHEET           6
#define     RENEW_PROP_SHEET            5
#define     IMPORT_PROP_SHEET           5
#define     BUILDCTL_PROP_SHEET         6
#define     SIGN_PROP_SHEET             10


//flags for the column sorting function's lParamSort
#define     SORT_COLUMN_ISSUER              0x0001
#define     SORT_COLUMN_SUBJECT             0x0002
#define     SORT_COLUMN_EXPIRATION          0x0004
#define     SORT_COLUMN_PURPOSE             0x0008
#define     SORT_COLUMN_NAME                0x0010
#define     SORT_COLUMN_LOCATION            0x0020


#define     SORT_COLUMN_ASCEND              0x00010000
#define     SORT_COLUMN_DESCEND             0x00020000

//-----------------------------------------------------------------------
//  Function Prototypes
//
//------------------------------------------------------------------------
BOOL    InitCertCAOID(PCCRYPTUI_WIZ_CERT_REQUEST_INFO   pCertRequestInfo,
                      DWORD                             *pdwOIDInfo,
                      ENROLL_OID_INFO                   **pprgOIDInfo);

BOOL    FreeCertCAOID(DWORD             dwOIDInfo,
                      ENROLL_OID_INFO   *pOIDInfo);

BOOL    InitCertCA(CERT_WIZARD_INFO         *pCertWizardInfo,
                   PCRYPTUI_WIZ_CERT_CA     pCertCA,
                   LPWSTR                   pwszCALocation,
                   LPWSTR                   pwszCAName,
                   BOOL                     fCASelected,
                   PCCRYPTUI_WIZ_CERT_REQUEST_INFO  pCertRequestInfo,
                   DWORD                    dwOIDInfo,
                   ENROLL_OID_INFO          *pOIDInfo,
                   BOOL                     fSearchForCertType);

BOOL    FreeCertCACertType(DWORD                    dwCertTypeInfo,
                           ENROLL_CERT_TYPE_INFO    *rgCertTypeInfo);

BOOL    AddCertTypeToCertCA(DWORD                   *pdwCertTypeInfo,
                            ENROLL_CERT_TYPE_INFO   **ppCertTypeInfo,
                            LPWSTR                  pwszDNName,
                            LPWSTR                  pwszCertType,
                            PCERT_EXTENSIONS        pCertExtensions,
                            BOOL                    fSelected,
                            DWORD                   dwKeySpec,
                            DWORD                   dwCertTypeFlag,
                            DWORD                   dwCSPCount,
                            DWORD                   *pdwCSPList,
			    DWORD                   dwRASignatures,
			    DWORD                   dwEnrollmentFlags,
			    DWORD                   dwSubjectNameFlags,
			    DWORD                   dwPrivateKeyFlags,
			    DWORD                   dwGeneralFlags
			    );

BOOL
WINAPI
CertRequestNoSearchCA(
            BOOL                            fSearchCertType,
            CERT_WIZARD_INFO                *pCertWizardInfo,
            DWORD                           dwFlags,
            HWND                            hwndParent,
            LPCWSTR                         pwszWizardTitle,
            PCCRYPTUI_WIZ_CERT_REQUEST_INFO pCertRequestInfo,
            PCCERT_CONTEXT                  *ppCertContext,
            DWORD                           *pCAdwStatus,
            UINT                            *pIds);

BOOL
WINAPI
CreateCertRequestNoSearchCANoDS
(IN  CERT_WIZARD_INFO  *pCertWizardInfo,
 IN  DWORD             dwFlags,
 IN  HCERTTYPE         hCertType, 
 OUT HANDLE            *pResult);

BOOL
WINAPI
CertRequestSearchCA(
            CERT_WIZARD_INFO                *pCertWizardInfo,
            DWORD                           dwFlags,
            HWND                            hwndParent,
            LPCWSTR                         pwszWizardTitle,
            PCCRYPTUI_WIZ_CERT_REQUEST_INFO pCertRequestInfo,
            PCCERT_CONTEXT                  *ppCertContext,
            DWORD                           *pCAdwStatus,
            UINT                            *pIds);

BOOL
WINAPI
SubmitCertRequestNoSearchCANoDS
(IN  HANDLE            hRequest,
 IN  LPCWSTR           pwszCAName,
 IN  LPCWSTR           pwszCALocation, 
 OUT DWORD            *pdwStatus, 
 OUT PCCERT_CONTEXT   *ppCertContext);

void
WINAPI
FreeCertRequestNoSearchCANoDS
(IN HANDLE  hRequest);

BOOL 
WINAPI
QueryCertRequestNoSearchCANoDS
(IN HANDLE hRequest, OUT CRYPTUI_WIZ_QUERY_CERT_REQUEST_INFO *pQueryInfo);

BOOL
WINAPI
CryptUIWizCertRequestWithCAInfo(
            CERT_WIZARD_INFO                *pCertWizardInfo,
            DWORD                           dwFlags,
            HWND                            hwndParent,
            LPCWSTR                         pwszWizardTitle,
            PCCRYPTUI_WIZ_CERT_REQUEST_INFO pCertRequestInfo,
            PCCRYPTUI_WIZ_CERT_CA_INFO      pCertRequestCAInfo,
            PCCERT_CONTEXT                  *ppCertContext,
            DWORD                           *pdwStatus,
            UINT                            *pIds);



int     I_MessageBox(
            HWND        hWnd,
            UINT        idsText,
            UINT        idsCaption,
            LPCWSTR     pwszCaption,
            UINT        uType);


HRESULT  MarshallRequestParameters(IN      DWORD                  dwCSPIndex,
                                   IN      CERT_WIZARD_INFO      *pCertWizardInfo,
                                   IN OUT  CERT_BLOB             *pCertBlob, 
                                   IN OUT  CERT_REQUEST_PVK_NEW  *pCertRequestPvkNew,
                                   IN OUT  CERT_REQUEST_PVK_NEW  *pCertRenewPvk, 
                                   IN OUT  LPWSTR                *ppwszHashAlg, 
                                   IN OUT  CERT_ENROLL_INFO      *pRequestInfo);
                                   

void FreeRequestParameters(IN LPWSTR                *ppwszHashAlg, 
			   IN CERT_REQUEST_PVK_NEW  *pCertRenewPvk, 
			   IN CERT_ENROLL_INFO      *RequestInfo);
			   



HRESULT WINAPI CreateRequest(DWORD                 dwFlags,         //IN  Required
			     DWORD                 dwPurpose,       //IN  Required: Whether it is enrollment or renew
			     LPWSTR                pwszCAName,      //IN  Required: 
			     LPWSTR                pwszCALocation,  //IN  Required: 
			     CERT_BLOB             *pCertBlob,      //IN  Required: The renewed certifcate
			     CERT_REQUEST_PVK_NEW  *pRenewKey,      //IN  Required: The private key on the certificate
			     BOOL                  fNewKey,         //IN  Required: Set the TRUE if new private key is needed
			     CERT_REQUEST_PVK_NEW  *pKeyNew,        //IN  Required: The private key information
			     LPWSTR                pwszHashAlg,     //IN  Optional: The hash algorithm
			     LPWSTR                pwszDesStore,    //IN  Optional: The destination store
			     DWORD                 dwStoreFlags,    //IN  Optional: The store flags
			     CERT_ENROLL_INFO     *pRequestInfo,    //IN  Required: The information about the cert request
			     HANDLE               *hRequest         //OUT Required: A handle to the PKCS10 request created
			     );

HRESULT WINAPI SubmitRequest(IN   HANDLE                hRequest, 
			     IN   BOOL                  fKeyService,     //IN Required: Whether the function is called remotely
			     IN   DWORD                 dwPurpose,       //IN Required: Whether it is enrollment or renew
			     IN   BOOL                  fConfirmation,   //IN Required: Set the TRUE if confirmation dialogue is needed
			     IN   HWND                  hwndParent,      //IN Optional: The parent window
			     IN   LPWSTR                pwszConfirmationTitle,   //IN Optional: The title for confirmation dialogue
			     IN   UINT                  idsConfirmTitle, //IN Optional: The resource ID for the title of the confirmation dialogue
			     IN   LPWSTR                pwszCALocation,  //IN Required: The ca machine name
			     IN   LPWSTR                pwszCAName,      //IN Required: The ca name
			     IN   LPWSTR                pwszCADisplayName, // IN Optional:  The display name of the CA.  
			     OUT  CERT_BLOB            *pPKCS7Blob,      //OUT Optional: The PKCS7 from the CA
			     OUT  CERT_BLOB            *pHashBlob,       //OUT Optioanl: The SHA1 hash of the enrolled/renewed certificate
			     OUT  DWORD                *pdwDisposition,  //OUT Optional: The status of the enrollment/renewal
			     OUT  PCCERT_CONTEXT       *ppCertContext    //OUT Optional: The enrolled certificate
			     );

void WINAPI FreeRequest(IN HANDLE hRequest);

BOOL WINAPI QueryRequest(IN HANDLE hRequest, OUT CRYPTUI_WIZ_QUERY_CERT_REQUEST_INFO *pQueryInfo);  

BOOL    WizardInit(BOOL fLoadRichEdit=FALSE);


BOOL    CheckPVKInfo(   DWORD                       dwFlags,
                        PCCRYPTUI_WIZ_CERT_REQUEST_INFO  pCertRequestInfo,
                          CERT_WIZARD_INFO          *pCertWizardInfo,
                          CRYPT_KEY_PROV_INFO       **ppKeyProvInfo);

BOOL  CheckPVKInfoNoDS(DWORD                                     dwFlags, 
		       DWORD                                     dwPvkChoice, 
		       PCCRYPTUI_WIZ_CERT_REQUEST_PVK_CERT       pCertRequestPvkContext,
		       PCCRYPTUI_WIZ_CERT_REQUEST_PVK_NEW        pCertRequestPvkNew,
		       PCCRYPTUI_WIZ_CERT_REQUEST_PVK_EXISTING   pCertRequestPvkExisting,
		       DWORD                                     dwCertChoice,
		       CERT_WIZARD_INFO                         *pCertWizardInfo,
		       CRYPT_KEY_PROV_INFO                     **ppKeyProvInfo);

void    ResetProperties(PCCERT_CONTEXT  pOldCertContext, PCCERT_CONTEXT pNewCertContext);


LRESULT Send_LB_GETTEXT(
            HWND hwnd,
            WPARAM wParam,
            LPARAM lParam);


LRESULT Send_LB_ADDSTRING(
            HWND hwnd,
            WPARAM wParam,
            LPARAM lParam);

void
SetControlFont(
    HFONT    hFont,
    HWND     hwnd,
    INT      nId
    );

BOOL
SetupFonts(
    HINSTANCE    hInstance,
    HWND         hwnd,
    HFONT        *pBigBoldFont,
    HFONT        *pBoldFont
    );

void
DestroyFonts(
    HFONT        hBigBoldFont,
    HFONT        hBoldFont
    );

HRESULT
WizardSZToWSZ
(IN LPCSTR   psz,
 OUT LPWSTR *ppwsz); 

LPVOID  WizardAlloc (
        ULONG cbSize);

LPVOID  WizardRealloc (
        LPVOID pv,
        ULONG cbSize);

VOID    WizardFree (
        LPVOID pv);

VOID    MyWizardFree (
        LPVOID pv);


LPWSTR WizardAllocAndCopyWStr(LPWSTR pwsz);

LPSTR  WizardAllocAndCopyStr(LPSTR psz);


BOOL    ConfirmToInstall(HWND               hwndParent,
                         LPWSTR             pwszConfirmationTitle,
                         UINT               idsConfirmTitle,
                         PCCERT_CONTEXT     pCertContext,
                         PCRYPT_DATA_BLOB   pPKCS7Blob);


BOOL GetValidKeySizes(IN  LPCWSTR  pwszProvider,
		      IN  DWORD    dwProvType,
		      IN  DWORD    dwUserKeySpec, 
		      OUT DWORD *  pdwMinLen,
		      OUT DWORD *  pdwMaxLen,
		      OUT DWORD *  pdwInc);

BOOL CAUtilAddSMIME(DWORD             dwExtensions, 
		    PCERT_EXTENSIONS *prgExtensions);


HRESULT CodeToHR(HRESULT hr);

HRESULT RetrieveBLOBFromFile(LPWSTR	pwszFileName,DWORD *pcb,BYTE **ppb);

HRESULT OpenAndWriteToFile(
    LPCWSTR  pwszFileName,
    PBYTE   pb,
    DWORD   cb);


int ListView_InsertItemU_IDS(HWND       hwndList,
                         LV_ITEMW       *plvItem,
                         UINT           idsString,
                         LPWSTR         pwszText);


BOOL MyFormatEnhancedKeyUsageString(LPWSTR *ppString, PCCERT_CONTEXT pCertContext, BOOL fPropertiesOnly, BOOL fMultiline);

BOOL WizardFormatDateString(LPWSTR *ppString, FILETIME ft, BOOL fIncludeTime);

void FreePurposeInfo(ENROLL_PURPOSE_INFO    **prgPurposeInfo,
                     DWORD                  dwOIDCount);


LRESULT
WINAPI
SendDlgItemMessageU_GETLBTEXT
(   HWND        hwndDlg,
    int         nIDDlgItem,
    int         iIndex,
    LPWSTR      *ppwsz
    );


void WINAPI GetListViewText(    HWND hwnd, 		    int iItem, 		
    int iSubItem, 	LPWSTR  *ppwsz	);		


void    FreeProviders(  DWORD               dwCSPCount,
                        DWORD               *rgdwProviderType,
                        LPWSTR              *rgwszProvider);


//the call back function to compare the certificate

int CALLBACK CompareCertificate(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);

BOOL    GetCertIssuer(PCCERT_CONTEXT    pCertContext, LPWSTR    *ppwsz);

BOOL    GetCertSubject(PCCERT_CONTEXT    pCertContext, LPWSTR    *ppwsz);

BOOL    GetCertPurpose(PCCERT_CONTEXT    pCertContext, LPWSTR    *ppwsz);

BOOL    GetCertFriendlyName(PCCERT_CONTEXT    pCertContext, LPWSTR    *ppwsz);

BOOL    GetCertLocation (PCCERT_CONTEXT  pCertContext, LPWSTR *ppwsz);

BOOL    CSPSupported(CERT_WIZARD_INFO *pCertWizardInfo);

BOOL    WizGetOpenFileName(LPOPENFILENAMEW pOpenFileName);


BOOL    WizGetSaveFileName(LPOPENFILENAMEW pOpenFileName);

BOOL AddChainToStore(
					HCERTSTORE			hCertStore,
					PCCERT_CONTEXT		pCertContext,
					DWORD				cStores,
					HCERTSTORE			*rghStores,
					BOOL				fDontAddRootCert,
					CERT_TRUST_STATUS	*pChainTrustStatus);

BOOL    FileExist(LPWSTR    pwszFileName);

int LoadFilterString(
            HINSTANCE hInstance,	
            UINT uID,	
            LPWSTR lpBuffer,	
            int nBufferMax);

BOOL    CASupportSpecifiedCertType(CRYPTUI_WIZ_CERT_CA     *pCertCA);

BOOL    GetCertTypeName(CERT_WIZARD_INFO *pCertWizardInfo);

BOOL    GetCAName(CERT_WIZARD_INFO *pCertWizardInfo);


LPWSTR ExpandAndAllocString(LPCWSTR pwsz);

HANDLE WINAPI ExpandAndCreateFileU (
    LPCWSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile
    );

WINCRYPT32API
BOOL
WINAPI
ExpandAndCryptQueryObject(
    DWORD            dwObjectType,
    const void       *pvObject,
    DWORD            dwExpectedContentTypeFlags,
    DWORD            dwExpectedFormatTypeFlags,
    DWORD            dwFlags,
    DWORD            *pdwMsgAndCertEncodingType,
    DWORD            *pdwContentType,
    DWORD            *pdwFormatType,
    HCERTSTORE       *phCertStore,
    HCRYPTMSG        *phMsg,
    const void       **ppvContext
    );


#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#ifdef __cplusplus

// Define an exportable interface to the EnrollmentCOMObjectFactory class. 
extern "C" 
{ 
    typedef struct _EnrollmentCOMObjectFactoryContext {
	BOOL              fIsCOMInitialized; 
	ICertRequest2    *pICertRequest2; 
	IDsObjectPicker  *pIDsObjectPicker; 
    } EnrollmentCOMObjectFactoryContext; 

    HRESULT EnrollmentCOMObjectFactory_getInstance(EnrollmentCOMObjectFactoryContext  *pContext, 
						   REFCLSID                            rclsid, 
						   REFIID                              riid, 
						   LPUNKNOWN                          *pUnknown,
						   LPVOID                             *ppInstance);
} // extern "C"

class IEnumCSP
{
 public:
    IEnumCSP(CERT_WIZARD_INFO * pCertWizardInfo);
    HRESULT HasNext(BOOL *pfResult); 
    HRESULT Next(DWORD *pdwNextCSP); 

 private:
    BOOL     *m_pfCSPs; 
    BOOL      m_fIsInitialized; 
    DWORD     m_cCSPs; 
    DWORD     m_dwCSPIndex; 
    HRESULT   m_hr; 
};


class IEnumCA
{
 public:
    IEnumCA(CERT_WIZARD_INFO * pCertWizardInfo) : m_pCertWizardInfo(pCertWizardInfo), 
        m_dwCAIndex(1) { }

    HRESULT HasNext(BOOL *pfResult); 
    HRESULT Next(PCRYPTUI_WIZ_CERT_CA pCertCA); 

 private:
    CERT_WIZARD_INFO  *m_pCertWizardInfo; 
    DWORD              m_dwCAIndex; 
};


//
// The EnrollmentObjectFactory class provides instances of useful COM interfaces 
// in a demand-driven manner.  Only one instance of each type is created, 
// and it is created only when needed.  
//
// NOTE: For efficiency, all COM objects should be instantiated through this
//       object factory.  
// 
class EnrollmentCOMObjectFactory 
{
 public: 
    EnrollmentCOMObjectFactory() { 
	m_context.fIsCOMInitialized = FALSE; 
	m_context.pICertRequest2    = NULL;
	m_context.pIDsObjectPicker  = NULL;
    }

    ~EnrollmentCOMObjectFactory() { 
	if (m_context.pICertRequest2    != NULL)  { m_context.pICertRequest2->Release(); } 
	if (m_context.pIDsObjectPicker  != NULL)  { m_context.pIDsObjectPicker->Release(); } 
	if (m_context.fIsCOMInitialized == TRUE)  { CoUninitialize(); }
    }
    
    // Returns a pointer to an implementation of ICertRequest2.  
    // Must release this pointer through ICertRequest2's release() method. 
    HRESULT getICertRequest2(ICertRequest2 ** ppCertRequest) { 
	return EnrollmentCOMObjectFactory_getInstance(&(this->m_context), 
						      CLSID_CCertRequest, 
						      IID_ICertRequest2, 
						      (LPUNKNOWN *)&(m_context.pICertRequest2), 
						      (LPVOID *)ppCertRequest);
    }

    // Returns a pointer to an implementation of IDsObjectPicker. 
    // Must release this pointer through ICertRequest2's release() method. 
    HRESULT getIDsObjectPicker(IDsObjectPicker ** ppObjectPicker) {
	return EnrollmentCOMObjectFactory_getInstance(&(this->m_context), 
						      CLSID_DsObjectPicker,
						      IID_IDsObjectPicker,
						      (LPUNKNOWN *)&(m_context.pIDsObjectPicker), 
						      (LPVOID *)ppObjectPicker); 
    }
    
 private: 

    // Disallow copy constructor and assignment operator: 
    EnrollmentCOMObjectFactory(const EnrollmentCOMObjectFactory &); 
    const EnrollmentCOMObjectFactory & operator=(const EnrollmentCOMObjectFactory &); 

    // Helper functions:
    HRESULT getInstance(REFCLSID rclsid, REFIID riid, LPUNKNOWN *pUnknown, LPVOID *ppInstance); 
   
    // Data: 
    EnrollmentCOMObjectFactoryContext m_context; 
}; 



#endif // __cplusplus

#endif  //WZRDPVK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\scardlib\clbmisc.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    ClbMisc

Abstract:

    This header file describes the miscellaneous services of the Calais Library.

Author:

    Doug Barlow (dbarlow) 7/16/1996

Environment:

    Win32, C++ w/ Exceptions

Notes:

--*/

#ifndef _CLBMISC_H_
#define _CLBMISC_H_

#define PLATFORM_UNKNOWN 0
#define PLATFORM_WIN95   ((VER_PLATFORM_WIN32_WINDOWS << 16) + (4 << 8))
#define PLATFORM_WIN98   ((VER_PLATFORM_WIN32_WINDOWS << 16) + (4 << 8)) + 10
#define PLATFORM_WINNT40 ((VER_PLATFORM_WIN32_NT << 16) + (4 << 8))
#define PLATFORM_WINNT50 ((VER_PLATFORM_WIN32_NT << 16) + (5 << 8))
#define IsWinNT (VER_PLATFORM_WIN32_NT == (GetPlatform() >> 16))


//
// Miscellaneous definitions.
//

extern DWORD
GetPlatform(            // Get the current operating system.
    void);

extern int
MemCompare(             // Non CRTL memory compare routine.
    IN LPCBYTE pbOne,
    IN LPCBYTE pbTwo,
    IN DWORD cbLength);

extern DWORD
MStrAdd(                // Add an ANSI string to a multistring.
    IN OUT CBuffer &bfMsz,
    IN LPCSTR szAdd);
extern DWORD
MStrAdd(                // Add a wide string to a multistring.
    IN OUT CBuffer &bfMsz,
    IN LPCWSTR szAdd);

extern DWORD
MStrLen(               // Return the length of an ANSI Multistring, in chars.
    LPCSTR mszString);
extern DWORD
MStrLen(               // Return the length of a wide Multistring, in chars.
    LPCWSTR mszString);

extern LPCTSTR
FirstString(            // Return first string segment in a multistring.
    IN LPCTSTR szMultiString);

extern LPCTSTR
NextString(             // Return next string segment in a multistring.
    IN LPCTSTR szMultiString);

extern LPCTSTR
StringIndex(            // Return n'th string segment in a multistring.
    IN LPCTSTR szMultiString,
    IN DWORD dwIndex);

extern DWORD
MStringCount(
        LPCTSTR mszInString);   // count strings in multistring

extern DWORD
MStringSort(            // Sort multistring, removing duplicates.
    LPCTSTR mszInString,
    CBuffer &bfOutString);

extern DWORD
MStringMerge(           // Merge two multistrings, eliminating duplicates.
    LPCTSTR mszOne,
    LPCTSTR mszTwo,
    CBuffer &bfOutString);

extern DWORD
MStringCommon(          // Get the intersection of two multistrings.
    LPCTSTR mszOne,
    LPCTSTR mszTwo,
    CBuffer &bfOutString);

extern DWORD
MStringRemove(          // Remove 2nd string entries from 1st string.
    LPCTSTR mszOne,
    LPCTSTR mszTwo,
    CBuffer &bfOutString);

extern BOOL
ParseAtr(               // Parse a smartcard ATR string.
    LPCBYTE pbAtr,
    LPDWORD pdwAtrLen = NULL,
    LPDWORD pdwHistOffset = NULL,
    LPDWORD pcbHistory = NULL,
    DWORD cbMaxLen = 33);

extern BOOL
AtrCompare(             // Compare an ATR to an ATR/Mask pair.
    LPCBYTE pbAtr1,
    LPCBYTE pbAtr2,
    LPCBYTE pbMask,  // = NULL
    DWORD cbAtr2);  // = 0

extern DWORD
MoveString(             // Move an ANSI string into a buffer, converting to
    CBuffer &bfDst,     // TCHARs.
    LPCSTR szSrc,
    DWORD dwLength = (DWORD)(-1));

extern DWORD
MoveString(             // Move a UNICODE string into a buffer, converting to
    CBuffer &bfDst,     // TCHARs.
    LPCWSTR szSrc,
    DWORD dwLength = (DWORD)(-1));

extern DWORD
MoveToAnsiString(       // Move a string into a UNICODE buffer, converting from
    LPSTR szDst,        // TCHARs.
    LPCTSTR szSrc,
    DWORD cchLength);

extern DWORD
MoveToUnicodeString(    // Move a string into an ANSI buffer, converting from
    LPWSTR szDst,       // TCHARs.
    LPCTSTR szSrc,
    DWORD cchLength);

extern DWORD
MoveToAnsiMultiString(  // Move a multistring into an ANSI buffer, converting
    LPSTR mszDst,       // from TCHARs.
    LPCTSTR mszSrc,
    DWORD cchLength);

extern DWORD
MoveToUnicodeMultiString(   // Move a multistring into a UNICODE buffer,
    LPWSTR mszDst,          // converting from TCHARs.
    LPCTSTR mszSrc,
    DWORD cchLength);

extern LPCTSTR
ErrorString(                // Convert an error code into a string.
    DWORD dwErrorCode);

extern void
FreeErrorString(            // Free the string returned from ErrorString.
    LPCTSTR szErrorString);

extern DWORD
SelectString(               // Index a given string against a list of possible
    LPCTSTR szSource,       // strings.  Last parameter is NULL.
    ...);

extern void
StringFromGuid(
    IN LPCGUID pguidResult, // GUID to convert to text
    OUT LPTSTR szGuid);     // 39+ character buffer to receive GUID as text.


//
//==============================================================================
//
//  CErrorString
//
//  A trivial class to simplify the use of the ErrorString service.
//

class CErrorString
{
public:

    //  Constructors & Destructor
    CErrorString(DWORD dwError = 0)
    {
        m_szErrorString = NULL;
        SetError(dwError);
    };

    ~CErrorString()
    {
        FreeErrorString(m_szErrorString);
    };

    //  Properties
    //  Methods
    void SetError(DWORD dwError)
    {
        m_dwError = dwError;
    };

    LPCTSTR Value(void)
    {
        FreeErrorString(m_szErrorString);
        m_szErrorString = ErrorString(m_dwError);
        return m_szErrorString;
    };

    //  Operators
    operator LPCTSTR(void)
    {
        return Value();
    };

protected:
    //  Properties
    DWORD m_dwError;
    LPCTSTR m_szErrorString;

    //  Methods
};

#endif // _CLBMISC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\scardlib\dynarray.h ===
/*++

Copyright (C) Microsoft Corporation, 1995 - 1999

Module Name:

    dynarray

Abstract:

    This header file implements a Dynamic Array.

Author:

    Doug Barlow (dbarlow) 10/5/1995

Environment:

    Win32, C++ /w Exception Handling

Notes:



--*/

#ifndef _DYNARRAY_H_
#define _DYNARRAY_H_


//
//==============================================================================
//
//  CDynamicArray
//

template <class T>
class CDynamicArray
{
public:

    //  Constructors & Destructor

    CDynamicArray(void)
    { m_Max = m_Mac = 0; m_pvList = NULL; };

    virtual ~CDynamicArray()
    { Clear(); };


    //  Properties
    //  Methods

    void
    Clear(void)
    {
        if (NULL != m_pvList)
        {
            delete[] m_pvList;
            m_pvList = NULL;
            m_Max = 0;
            m_Mac = 0;
        }
    };

    void
    Empty(void)
    { m_Mac = 0; };

    T *
    Set(
        IN int nItem,
        IN T *pvItem);

    T *
    Insert(
        IN int nItem,
        IN T *pvItem);

    T *
    Add(
        IN T *pvItem);

    T * const
    Get(
        IN int nItem)
    const;

    DWORD
    Count(void) const
    { return m_Mac; };

    T ** const
    Array(void) const
    { return m_pvList; };

    //  Operators
    T * const
    operator[](int nItem) const
    { return Get(nItem); };


protected:
    //  Properties

    DWORD
        m_Max,          // Number of element slots available.
        m_Mac;          // Number of element slots used.
    T **
        m_pvList;       // The elements.


    //  Methods
};


/*++

Set:

    This routine sets an item in the collection array.  If the array isn't that
    big, it is expanded with NULL elements to become that big.

Arguments:

    nItem - Supplies the index value to be set.
    pvItem - Supplies the value to be set into the given index.

Return Value:

    The value of the inserted value, or NULL on errors.

Author:

    Doug Barlow (dbarlow) 7/13/1995

--*/

template<class T>
inline T *
CDynamicArray<T>::Set(
    IN int nItem,
    IN T * pvItem)
{
    DWORD index;


    //
    // Make sure the array is big enough.
    //

    if ((DWORD)nItem >= m_Max)
    {
        int newSize = (0 == m_Max ? 4 : m_Max);
        while (nItem >= newSize)
            newSize *= 2;
        T **newList = new T*[newSize];
        if (NULL == newList)
            throw (DWORD)ERROR_OUTOFMEMORY;
        for (index = 0; index < m_Mac; index += 1)
            newList[index] = m_pvList[index];
        if (NULL != m_pvList)
            delete[] m_pvList;
        m_pvList = newList;
        m_Max = newSize;
    }


    //
    // Make sure intermediate elements are filled in.
    //

    if ((DWORD)nItem >= m_Mac)
    {
        for (index = m_Mac; index < (DWORD)nItem; index += 1)
            m_pvList[index] = NULL;
        m_Mac = (DWORD)nItem + 1;
    }


    //
    // Fill in the list element.
    //

    m_pvList[(DWORD)nItem] = pvItem;
    return pvItem;
}


/*++

Insert:

    This routine inserts an element in the array by moving all elements above it
    up one, then inserting the new element.

Arguments:

    nItem - Supplies the index value to be inserted.
    pvItem - Supplies the value to be set into the given index.

Return Value:

    The value of the inserted value, or NULL on errors.

Author:

    Doug Barlow (dbarlow) 10/10/1995

--*/

template<class T>
inline T *
CDynamicArray<T>::Insert(
    IN int nItem,
    IN T * pvItem)
{
    DWORD index;
    for (index = nItem; index < m_Mac; index += 1)
        if (NULL == Set(index + 1, Get(index)))
            return NULL;    // Only the first one can fail, so no change
                            // happens on errors.
    return Set(nItem, pvItem);
}


/*++

Add:

    This method adds an element to the end of the dynamic array.

Arguments:

    pvItem - Supplies the value to be added to the list.

Return Value:

    The value of the added value, or NULL on errors.

Author:

    Doug Barlow (dbarlow) 10/10/1995

--*/

template<class T>
inline T *
CDynamicArray<T>::Add(
    IN T *pvItem)
{
    return Set(Count(), pvItem);
}


/*++

Get:

    This method returns the element at the given index.  If there is no element
    previously stored at that element, it returns NULL.  It does not expand the
    array.

Arguments:

    nItem - Supplies the index into the list.

Return Value:

    The value stored at that index in the list, or NULL if nothing has ever been
    stored there.

Author:

    Doug Barlow (dbarlow) 7/13/1995

--*/

template <class T>
inline T * const
CDynamicArray<T>::Get(
    int nItem)
    const
{
    if (m_Mac <= (DWORD)nItem)
        return NULL;
    else
        return m_pvList[nItem];
}

#endif // _DYNARRAY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\scardlib\buffers.h ===
/*++

Copyright (C) Microsoft Corporation, 1995 - 1999

Module Name:

    buffers

Abstract:

    This header file provides dynamic buffer and string classes for general use.

Author:

    Doug Barlow (dbarlow) 10/5/1995

Environment:

    Win32, C++ w/ Exception Handling

Notes:



--*/

#ifndef _BUFFERS_H_
#define _BUFFERS_H_


//
//==============================================================================
//
//  CBuffer
//

class CBuffer
{
public:

    //  Constructors & Destructor

    CBuffer()           // Default Initializer
    { Initialize(); };

    CBuffer(            // Initialize with starting length.
        IN DWORD cbLength)
    { Initialize();
      Presize(cbLength, FALSE); };

    CBuffer(            // Initialize with starting data.
        IN const BYTE * const pbSource,
        IN DWORD cbLength)
    { Initialize();
      Set(pbSource, cbLength); };

    virtual ~CBuffer()  // Tear down.
    { Clear(); };


    //  Properties
    //  Methods

    void
    Clear(void);        // Free up any allocated memory.

    LPBYTE
    Reset(void);        // Return to default state (don't loose memory.)

    LPBYTE
    Presize(            // Make sure the buffer is big enough.
        IN DWORD cbLength,
        IN BOOL fPreserve = FALSE);

    LPBYTE
    Resize(         // Make sure the buffer & length are the right size.
        DWORD cbLength,
        BOOL fPreserve = FALSE);

    LPBYTE
    Set(            // Load a value.
        IN const BYTE * const pbSource,
        IN DWORD cbLength);

    LPBYTE
    Append(         // Append more data to the existing data.
        IN const BYTE * const pbSource,
        IN DWORD cbLength);

    DWORD
    Length(         // Return the length of the data.
        void) const
    { return m_cbDataLength; };

    DWORD
    Space(          // Return the length of the buffer.
        void) const
    { return m_cbBufferLength; };

    LPBYTE
    Access(         // Return the data, starting at an offset.
        DWORD offset = 0)
    const
    {
        if (m_cbBufferLength <= offset)
            return (LPBYTE)TEXT("\x00");
        else
            return &m_pbBuffer[offset];
    };

    int
    Compare(
        const CBuffer &bfSource)
    const;


    //  Operators

    CBuffer &
    operator=(
        IN const CBuffer &bfSource)
    { Set(bfSource.m_pbBuffer, bfSource.m_cbDataLength);
      return *this; };

    CBuffer &
    operator+=(
        IN const CBuffer &bfSource)
    { Append(bfSource.m_pbBuffer, bfSource.m_cbDataLength);
      return *this; };

    BYTE &
    operator[](
        DWORD offset)
        const
    { return *Access(offset); };

    int
    operator==(
        IN const CBuffer &bfSource)
        const
    { return 0 == Compare(bfSource); };

    int
    operator!=(
        IN const CBuffer &bfSource)
        const
    { return 0 != Compare(bfSource); };

    operator LPCBYTE(void)
    { return (LPCBYTE)Access(); };

    operator LPCTSTR(void)
    { return (LPCTSTR)Access(); };


protected:

    //  Properties

    LPBYTE m_pbBuffer;
    DWORD m_cbDataLength;
    DWORD m_cbBufferLength;


    //  Methods

    void
    Initialize(void)
    {
        m_pbBuffer = NULL;
        m_cbDataLength = 0;
        m_cbBufferLength = 0;
    };

    CBuffer(           //  Object assignment constructor.
        IN const CBuffer &bfSourceOne,
        IN const CBuffer &bfSourceTwo);

    friend
        CBuffer &
        operator+(
            IN const CBuffer &bfSourceOne,
            IN const CBuffer &bfSourceTwo);
};

#endif // _BUFFERS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\scardlib\noncom.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    noncom

Abstract:

    This module provides a means to bypass COM, such that typical in-process
    COM objects can be called directly in any operating system.

Author:

    Doug Barlow (dbarlow) 1/4/1999

Notes:

    ?Notes?

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include "scardlib.h"
#include <ole2.h>
#include <unknwn.h>
#include "noncom.h"

typedef HRESULT
(STDAPICALLTYPE *GetClassObjectFunc)(
    REFCLSID rclsid,
    REFIID riid,
    LPVOID * ppv);


#ifdef UNDER_TEST

typedef struct {
    IID iid;
    HINSTANCE hDll;
    GetClassObjectFunc pgco;
} NonComModuleStruct;

class NonComControlStruct
{
public:
    DWORD dwInitializeCount;
    CRITICAL_SECTION csLock;
    CDynamicArray<NonComModuleStruct> rgModules;
};

static NonComControlStruct *l_pControl = NULL;


/*++

NoCoInitialize:

    This function initializes the NonCOM subsystem.

Arguments:

    pvReserved - [in] Reserved; must be NULL.

Return Value:

    S_OK - The NonCOM subsystem was initialized correctly.
    S_FALSE - The NonCOM library is already initialized.

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 1/4/1999

--*/

STDAPI
NoCoInitialize(
    LPVOID pvReserved)
{
    HRESULT hReturn = E_UNEXPECTED;


    //
    // Validate parameters.
    //

    if (NULL != pvReserved)
    {
        hReturn = E_INVALIDARG;
        goto ErrorExit;
    }


    //
    // Create the Control structure, if necessary.
    //

    if (NULL == l_pControl)
    {
        l_pControl = new NonComControlStruct;
        if (NULL == l_pControl)
        {
            hReturn = E_OUTOFMEMORY;
            goto ErrorExit;
        }
        InitializeCriticalSection(&l_pControl->csLock);
        CCritSect csLock(&l_pControl->csLock);
        // ?code? Database initialization
        l_pControl->dwInitializeCount = 1;
    }
    else
    {
        CCritSect csLock(&l_pControl->csLock);
        ASSERT(0 < l_pControl->dwInitializeCount);
        l_pControl->dwInitializeCount += 1;
    }
    return S_OK;

ErrorExit:
    return hReturn;
}


/*++

NoCoUninitialize:

    Closes the NonCOM library on the current apartment, unloads all DLLs
    loaded by the apartment, frees any other resources that the apartment
    maintains, and forces all RPC connections on the apartment to close.

Arguments:

    None

Return Value:

    None

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 1/4/1999

--*/

STDAPI_(void)
NoCoUninitialize(
    void)
{
    DWORD dwI;
    NonComModuleStruct *pMod;

    if (NULL != l_pControl)
    {
        {
            CCritSect csLock(&l_pControl->csLock);
            ASSERT(0 < l_pControl->dwInitializeCount);
            l_pControl->dwInitializeCount -= 1;
            if (0 == l_pControl->dwInitializeCount)
            {
                for (dwI = l_pControl->rgModules.Count(); 0 < dwI;)
                {
                    pMod = l_pControl->rgModules[--dwI];
                    FreeLibrary(pMod->hDll);
                    delete pMod;
                }
                l_pControl->rgModules.Clear();
            }
        }
        DeleteCriticalSection(&l_pControl->csLock);
        delete l_pControl;
        l_pControl = NULL;
    }
}

#endif


/*++

NoCoGetClassObject:

    Provides a pointer to an interface on a class object associated with a
    specified CLSID. CoGetClassObject locates, and if necessary, dynamically
    loads the executable code required to do this.

Arguments:

    rclsid - [in] CLSID associated with the data and code that you will use to
        create the objects.

    riid - [in] Reference to the identifier of the interface, which will be
        supplied in ppv on successful return. This interface will be used to
        communicate with the class object.

    ppv - [out] Address of pointer variable that receives the interface
        pointer requested in riid. Upon successful return, *ppv contains the
        requested interface pointer.

Return Value:

    S_OK - Location and connection to the specified class object was successful.

    REGDB_E_CLASSNOTREG - CLSID is not properly registered. Can also indicate
        that the value you specified in dwClsContext is not in the registry.

    E_NOINTERFACE - Either the object pointed to by ppv does not support the
        interface identified by riid, or the QueryInterface operation on the
        class object returned E_NOINTERFACE.

    REGDB_E_READREGDB - Error reading the registration database.

    CO_E_DLLNOTFOUND - In-process DLL not found.

    E_ACCESSDENIED - General access failure.

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 1/4/1999

--*/

STDAPI
NoCoGetClassObject(
    REFCLSID rclsid,
    REFIID riid,
    LPVOID * ppv)
{
    DWORD dwStatus;
    HRESULT hReturn = E_UNEXPECTED;
    TCHAR szGuid[40];
    CBuffer szDll;
    HINSTANCE hDll = NULL;
    GetClassObjectFunc pfGetObject;

#ifdef UNDER_TEST
    if (NULL == l_pControl)
    {
        hReturn = NoCoInitialize(NULL);
        if (S_OK != hReturn)
            goto ErrorExit;
    }

    {
        DWORD dwI;
        CCritSect(&l_pControl->csLock);

        for (dwI = l_pControl->rgModules.Count(); 0 < dwI;)
        {
            dwI -= 1;
            if (IsEqualGUID(l_pControl->rgModules[dwI]->iid, rclsid))
            {
                try
                {
                    hReturn = (*l_pControl->rgModules[dwI]->pgco)(rclsid, riid, ppv);
                }
                catch (...)
                {
                    hReturn = E_UNEXPECTED;
                }
                goto ErrorExit;
            }
        }
    }
#endif

    StringFromGuid(&rclsid, szGuid);

    try
    {

        //
        // Open the Class Registry Database.
        //

        CRegistry regClsId(
                        HKEY_CLASSES_ROOT,
                        TEXT("ClsID"),
                        KEY_READ);
        dwStatus = regClsId.Status(TRUE);
        if (ERROR_SUCCESS != dwStatus)
        {
            hReturn = REGDB_E_READREGDB;
            goto ErrorExit;
        }


        //
        // Look up the specified Class.
        //

        CRegistry regClass(
                        regClsId,
                        szGuid,
                        KEY_READ);
        dwStatus = regClass.Status(TRUE);
        if (ERROR_SUCCESS != dwStatus)
        {
            hReturn = REGDB_E_CLASSNOTREG;
            goto ErrorExit;
        }


        //
        // Get the registered InProcess Server.
        //

        CRegistry regServer(
                        regClass,
                        TEXT("InprocServer32"),
                        KEY_READ);
        dwStatus = regServer.Status(TRUE);
        if (ERROR_SUCCESS != dwStatus)
        {
            hReturn = REGDB_E_CLASSNOTREG;
            goto ErrorExit;
        }


        //
        // Get the handler DLL name.
        //

        regServer.GetValue(TEXT(""), szDll);
    }
    catch (DWORD dwError)
    {
        switch (dwError)
        {
        case ERROR_OUTOFMEMORY:
            hReturn = E_OUTOFMEMORY;
            break;
        default:
            hReturn = HRESULT_FROM_WIN32(dwError);
        }
        goto ErrorExit;
    }


    //
    // We've got the target DLL.  Load it and look for the entrypoint.
    //

    hDll = LoadLibrary((LPCTSTR)szDll.Access());
    if (NULL == hDll)
    {
        hReturn = CO_E_DLLNOTFOUND;
        goto ErrorExit;
    }
    pfGetObject = (GetClassObjectFunc)GetProcAddress(
                                            hDll,
                                            "DllGetClassObject");
    if (NULL == pfGetObject)
    {
        hReturn = E_NOINTERFACE;
        goto ErrorExit;
    }

#ifdef UNDER_TEST
    {
        NonComModuleStruct *pMod = new NonComModuleStruct;

        if (NULL == pMod)
        {
            hReturn = E_OUTOFMEMORY;
            goto ErrorExit;
        }

        pMod->hDll = hDll;
        CopyMemory(&pMod->iid, &rclsid, sizeof(IID));
        pMod->pgco = pfGetObject;
        try
        {
            l_pControl->rgModules.Add(pMod);
        }
        catch (...)
        {
            delete pMod;
        }
    }
#endif

    try
    {
        hReturn = (*pfGetObject)(rclsid, riid, ppv);
    }
    catch (...)
    {
        hReturn = E_UNEXPECTED;
    }
    if (S_OK != hReturn)
        goto ErrorExit;


    //
    // Add the Handler to our database.
    //

    // ?code? -- No database yet.
    hDll = NULL;

    ASSERT(NULL == hDll);
    return S_OK;

ErrorExit:
    if (NULL != hDll)
        FreeLibrary(hDll);
    return hReturn;
}


/*++

NoCoCreateInstance:

    Creates a single uninitialized object of the class associated with a
    specified CLSID. Call CoCreateInstance when you want to create only one
    object on the local system.

Arguments:

    rclsid - [in] CLSID associated with the data and code that will be used to
        create the object.

    pUnkOuter - [in] If NULL, indicates that the object is not being created as
        part of an aggregate. If non-NULL, pointer to the aggregate object's
        IUnknown interface (the controlling IUnknown).

    riid - [in] Reference to the identifier of the interface to be used to
        communicate with the object.

    ppv - [out] Address of pointer variable that receives the interface
        pointer requested in riid. Upon successful return, *ppv contains the
        requested interface pointer.

Return Value:

    S_OK - An instance of the specified object class was successfully created.

    REGDB_E_CLASSNOTREG - A specified class is not registered in the
        registration database. Also can indicate that the type of server you
        requested in the CLSCTX enumeration is not registered or the values
        for the server types in the registry are corrupt.

Author:

    Doug Barlow (dbarlow) 1/15/1999

--*/

STDAPI
NoCoCreateInstance(
    REFCLSID rclsid,
    LPUNKNOWN pUnkOuter,
    REFIID riid,
    LPVOID * ppv)
{
    HRESULT hReturn = E_UNEXPECTED;
    IClassFactory *pCF = NULL;

    hReturn = NoCoGetClassObject(rclsid, IID_IClassFactory, (LPVOID*)&pCF);
    if (S_OK != hReturn)
        goto ErrorExit;
    hReturn = pCF->CreateInstance(pUnkOuter, riid, ppv);
    if (S_OK != hReturn)
        goto ErrorExit;
    pCF->Release();
    pCF = NULL;
    return S_OK;

ErrorExit:
    if (NULL != pCF)
        pCF->Release();
    return hReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\scardlib\noncom.h ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    noncom

Abstract:

    This header file describes the implementation of the Non-Com subsystem.

Author:

    Doug Barlow (dbarlow) 1/4/1999

Remarks:

    ?Remarks?

Notes:

    ?Notes?

--*/

#ifndef _NONCOM_H_
#define _NONCOM_H_
#ifndef __cplusplus
        #error NonCOM requires C++ compilation (use a .cpp suffix)
#endif
// #define UNDER_TEST

#ifdef _UNICODE
    #ifndef UNICODE
        #define UNICODE         // UNICODE is used by Windows headers
    #endif
#endif

#ifdef UNICODE
    #ifndef _UNICODE
        #define _UNICODE        // _UNICODE is used by C-runtime/MFC headers
    #endif
#endif

#ifdef _DEBUG
    #ifndef DEBUG
        #define DEBUG
    #endif
#endif

STDAPI_(void)
NoCoStringFromGuid(
    IN LPCGUID pguidResult,
    OUT LPTSTR szGuid);

#ifdef UNDER_TEST
STDAPI
NoCoInitialize(
    LPVOID pvReserved);

STDAPI_(void)
NoCoUninitialize(
    void);
#endif

STDAPI
NoCoGetClassObject(
    REFCLSID rclsid,
    REFIID riid,
    LPVOID * ppv);

STDAPI
NoCoCreateInstance(
    REFCLSID rclsid,
    LPUNKNOWN pUnkOuter,
    REFIID riid,
    LPVOID * ppv);

#ifdef SCARD_NO_COM
#define CoGetClassObject(rclsid, dwClsContext, pServerInfo, riid, ppv) \
    NoCoGetClassObject(rclsid, riid, ppv)
#define CoCreateInstance(rclsid, pUnkOuter, dwClsContext, riid, ppv) \
    NoCoCreateInstance(rclsid, pUnkOuter, riid, ppv)
#define CoCreateInstanceEx(rclsid, punkOuter, dwClsCtx, pServerInfo, cmq, pResults) \
    NoCoCreateInstanceEx(rclsid, punkOuter, cmq, pResults)
#endif

#endif // _NONCOM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\scardlib\scardlib.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    SCardLib

Abstract:

    This header file incorporates the various other header files and provides
    common definitions that we are willing to share with the public.

Author:

    Doug Barlow (dbarlow) 1/15/1998

Environment:

    Win32, C++ w/ Exceptions

Notes:

--*/

#ifndef _SCARDLIB_H_
#define _SCARDLIB_H_
#include <crtdbg.h>

#ifndef ASSERT
#if defined(_DEBUG)
#define ASSERT(x) _ASSERTE(x)
#if !defined(DBG)
#define DBG
#endif
#elif defined(DBG)
#define ASSERT(x)
#else
#define ASSERT(x)
#endif
#endif

#ifndef breakpoint
#if defined(_DEBUG)
#define breakpoint _CrtDbgBreak();
#elif defined(DBG)
#define breakpoint DebugBreak();
#else
#define breakpoint
#endif
#endif

#ifndef _LPCBYTE_DEFINED
#define _LPCBYTE_DEFINED
typedef const BYTE *LPCBYTE;
#endif
#ifndef _LPCVOID_DEFINED
#define _LPCVOID_DEFINED
typedef const VOID *LPCVOID;
#endif
#ifndef _LPCGUID_DEFINED
#define _LPCGUID_DEFINED
typedef const GUID *LPCGUID;
#endif
#ifndef _LPGUID_DEFINED
#define _LPGUID_DEFINED
typedef GUID *LPGUID;
#endif

#include "buffers.h"
#include "dynarray.h"
#include "Registry.h"
#include "Text.h"
#include "Handles.h"
#include "clbmisc.h"

#endif // _SCARDLIB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\scardlib\registry.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    Registry

Abstract:

    This module implements the CRegistry Class, simplifying access to the
    Registry Database.

Author:

    Doug Barlow (dbarlow) 7/15/1996

Environment:

    Win32, C++ w/ Exceptions

Notes:

    The only exceptions thrown are DWORDs, containing the error code.

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include "SCardLib.h"

#define NTOHL HTONL

static inline DWORD
HTONL(
    DWORD dwInVal)
{
    DWORD   dwOutVal;
    LPBYTE  pbIn = (LPBYTE)&dwInVal,
            pbOut = (LPBYTE)&dwOutVal;
    for (DWORD index = 0; index < sizeof(DWORD); index += 1)
        pbOut[sizeof(DWORD) - 1 - index] = pbIn[index];
    return dwOutVal;
}


//
//==============================================================================
//
//  CRegistry
//

/*++

CRegistry:

    These routines provide for the construction and destruction of Objects of
    this class.

Arguments:

    regBase - A CRegistry object to be used as a parent for this object.

    hBase - A Registry key to be the parent of this object.

    szName - The name of the Registry key, relative to the supplied parent.

    samDesired - The desired SAM.

    dwOptions - Any special creation optiopns.

Throws:

    None.  If the registry access fails, the error will be thrown on first use.

Author:

    Doug Barlow (dbarlow) 7/15/1996

--*/

CRegistry::CRegistry(
    HKEY hBase,
    LPCTSTR szName,
    REGSAM samDesired,
    DWORD dwOptions,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes)
:   m_bfResult()
{
    m_hKey = NULL;
    m_lSts = ERROR_BADKEY;
    Open(hBase, szName, samDesired, dwOptions, lpSecurityAttributes);
}

CRegistry::CRegistry()
{
    m_hKey = NULL;
    m_lSts = ERROR_BADKEY;
}

CRegistry::~CRegistry()
{
    Close();
}


/*++

Open:

    These methods allow a CRegistry object to attempt to access a given registry
    entry.

Arguments:

    regBase - A CRegistry object to be used as a parent for this object.

    hBase - A Registry key to be the parent of this object.

    szName - The name of the Registry key, relative to the supplied parent.

    samDesired - The desired SAM.

    dwOptions - Any special creation optiopns.

Return Value:

    None

Throws:

    None -- errors are saved for follow-on operations, so that Open can be used
            safely in a constructor.

Author:

    Doug Barlow (dbarlow) 12/2/1996

--*/

void CRegistry::Open(
    HKEY hBase,
    LPCTSTR szName,
    REGSAM samDesired,
    DWORD dwOptions,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes)
{
    Close();
    if (REG_OPTION_EXISTS == dwOptions)
    {
        m_lSts = RegOpenKeyEx(
                    hBase,
                    szName,
                    0,
                    samDesired,
                    &m_hKey);
        m_dwDisposition = REG_OPENED_EXISTING_KEY;
    }
    else
        m_lSts = RegCreateKeyEx(
                    hBase,
                    szName,
                    0,
                    TEXT(""),
                    dwOptions,
                    samDesired,
                    lpSecurityAttributes,
                    &m_hKey,
                    &m_dwDisposition);
}


/*++

Close:

    Shut down a CRegistry object, making it available for follow-on opens.

Arguments:

    None

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 12/2/1996

--*/

void
CRegistry::Close(
    void)
{
    HRESULT hrSts;

    if (NULL != m_hKey)
    {
        hrSts = RegCloseKey(m_hKey);
        ASSERT(ERROR_SUCCESS == hrSts);
        m_hKey = NULL;
    }
    m_lSts = ERROR_BADKEY;
    m_bfResult.Reset();
}


/*++

Status:

    This routine returns the status code from the construction routine.  This is
    useful to check for errors prior to having them thrown.

Arguments:

    fQuiet indicates whether or not to throw an error if the status is not
        ERROR_SUCCESS.

Return Value:

    The status code from the creation.

Author:

    Doug Barlow (dbarlow) 7/15/1996

--*/

LONG
CRegistry::Status(
    BOOL fQuiet)
const
{
    if ((ERROR_SUCCESS != m_lSts) && !fQuiet)
        throw (DWORD)m_lSts;
    return m_lSts;
}


/*++

Empty:

    This method cleans out the registry tree under the given key.  All
    underlying keys and values are removed.  This does it's best -- if an error
    occurs, the emptying operation stops, leaving the registry in an
    indeterminate state.

Arguments:

    None

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 1/16/1998

--*/

void
CRegistry::Empty(
    void)
{
    LPCTSTR szValue;
    LPCTSTR szKey;


    //
    // Go through all the values and delete them.
    //

    while (NULL != (szValue = Value(0)))
        DeleteValue(szValue, TRUE);


#if 0       // Obsolete code
    //
    // Go through all the Keys and empty them.
    //

    DWORD dwIndex;
    for (dwIndex = 0; NULL != (szKey = Subkey(dwIndex)); dwIndex += 1)
    {
        CRegistry regEmpty;

        regEmpty.Open(*this, szKey);
        regEmpty.Empty();
        regEmpty.Close();
    }
#endif


    //
    // Now delete all the keys.
    //

    while (NULL != (szKey = Subkey(0)))
        DeleteKey(szKey, TRUE);
}


/*++

Copy:

    This method loads the current registry keys with all the subkeys and values
    from the supplied key.  Current keys and values of this key are deleted.

Arguments:

    regSrc supplies the source registry key from which values and keys will be
        loaded.

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 1/16/1998

--*/

void
CRegistry::Copy(
    CRegistry &regSrc)
{
    LPCTSTR szValue;
    LPCTSTR szKey;
    DWORD dwIndex, dwType;
    CRegistry regSrcSubkey, regDstSubkey;
    CBuffer bfValue;


    //
    // Go through all the values and copy them.
    //

    for (dwIndex = 0; NULL != (szValue = regSrc.Value(dwIndex)); dwIndex += 1)
    {
        regSrc.GetValue(szValue, bfValue, &dwType);
        SetValue(szValue, bfValue.Access(), bfValue.Length(), dwType);
    }


    //
    // Now copy all the keys.
    //

    for (dwIndex = 0; NULL != (szKey = regSrc.Subkey(dwIndex)); dwIndex += 1)
    {
        regSrcSubkey.Open(regSrc, szKey, KEY_READ);
        regDstSubkey.Open(
                *this,
                szKey,
                KEY_ALL_ACCESS,
                REG_OPTION_NON_VOLATILE);
        regDstSubkey.Status();
        regDstSubkey.Copy(regSrcSubkey);
        regDstSubkey.Close();
        regSrcSubkey.Close();
    }
}


/*++

DeleteKey:

    This method deletes a subkey from this key.

Arguments:

    szKey supplies the name of the key to be deleted.

    fQuiet supplies whether or not to suppress errors.

Return Value:

    None

Throws:

    if fQuiet is FALSE, then any errors encountered are thrown as a DWORD.

Author:

    Doug Barlow (dbarlow) 7/15/1996

--*/

void
CRegistry::DeleteKey(
    LPCTSTR szKey,
    BOOL fQuiet)
const
{
    if (ERROR_SUCCESS == m_lSts)
    {
        try
        {
            CRegistry regSubkey(m_hKey, szKey);
            LPCTSTR szSubKey;

            if (ERROR_SUCCESS == regSubkey.Status(TRUE))
            {
                while (NULL != (szSubKey = regSubkey.Subkey(0)))
                    regSubkey.DeleteKey(szSubKey, fQuiet);
            }
        }
        catch (DWORD dwError)
        {
            if (!fQuiet)
                throw dwError;
        }

        LONG lSts = RegDeleteKey(m_hKey, szKey);
        if ((ERROR_SUCCESS != lSts) && !fQuiet)
            throw (DWORD)lSts;
    }
    else if (!fQuiet)
        throw (DWORD)m_lSts;
}


/*++

DeleteValue:

    This method deletes a Value from this key.

Arguments:

    szValue supplies the name of the Value to be deleted.

    fQuiet supplies whether or not to suppress errors.

Return Value:

    None

Throws:

    if fQuiet is FALSE, then any errors encountered are thrown as a DWORD.

Author:

    Doug Barlow (dbarlow) 7/15/1996

--*/

void
CRegistry::DeleteValue(
    LPCTSTR szValue,
    BOOL fQuiet)
const
{
    LONG lSts;

    if (fQuiet)
    {
        if (ERROR_SUCCESS == m_lSts)
            lSts = RegDeleteValue(m_hKey, szValue);
    }
    else
    {
        if (ERROR_SUCCESS != m_lSts)
            throw (DWORD)m_lSts;
        lSts = RegDeleteValue(m_hKey, szValue);
        if (ERROR_SUCCESS != lSts)
        throw (DWORD)lSts;
    }
}


/*++

Subkey:

    This method allows for iterating over the names of the subkeys of this key.

Arguments:

    dwIndex supplies the index into the set of subkeys.

Return Value:

    The name of the indexed subkey, or NULL if none exists.

Throws:

    Any error other than ERROR_NO_MORE_ITEMS is thrown.

Author:

    Doug Barlow (dbarlow) 7/15/1996

--*/

LPCTSTR
CRegistry::Subkey(
    DWORD dwIndex)
{
    LONG lSts;
    DWORD dwLen;
    LPCTSTR szResult = NULL;
    BOOL fDone = FALSE;
    FILETIME ftLastWrite;

    if (ERROR_SUCCESS != m_lSts)
        throw (DWORD)m_lSts;

    m_bfResult.Presize(128);
    while (!fDone)
    {
        dwLen = m_bfResult.Space() / sizeof(TCHAR);
        lSts = RegEnumKeyEx(
                    m_hKey,
                    dwIndex,
                    (LPTSTR)m_bfResult.Access(),
                    &dwLen,
                    NULL,
                    NULL,
                    NULL,
                    &ftLastWrite);
        switch (lSts)
        {
        case ERROR_SUCCESS:
            m_bfResult.Resize((dwLen + 1) * sizeof(TCHAR), TRUE);
            szResult = (LPCTSTR)m_bfResult.Access();
            fDone = TRUE;
            break;
        case ERROR_NO_MORE_ITEMS:
            szResult = NULL;
            fDone = TRUE;
            break;
        case ERROR_MORE_DATA:
            m_bfResult.Presize((dwLen + 1) * sizeof(TCHAR));
            continue;
        default:
            throw (DWORD)lSts;
        }
    }

    return szResult;
}


/*++

Value:

    This method allows for iterating over the names of the Values of this key.

Arguments:

    dwIndex supplies the index into the set of Values.

    pdwType receives the type of the entry.  This parameter may be NULL.

Return Value:

    The name of the indexed Value, or NULL if none exists.

Throws:

    Any error other than ERROR_NO_MORE_ITEMS is thrown.

Author:

    Doug Barlow (dbarlow) 7/15/1996

--*/

LPCTSTR
CRegistry::Value(
    DWORD dwIndex,
    LPDWORD pdwType)
{
    LONG lSts;
    DWORD dwLen, dwType;
    LPCTSTR szResult = NULL;
    BOOL fDone = FALSE;

    if (ERROR_SUCCESS != m_lSts)
        throw (DWORD)m_lSts;

    m_bfResult.Presize(128);    // Force it to not be zero length.
    while (!fDone)
    {
        dwLen = m_bfResult.Space() / sizeof(TCHAR);
        lSts = RegEnumValue(
                    m_hKey,
                    dwIndex,
                    (LPTSTR)m_bfResult.Access(),
                    &dwLen,
                    NULL,
                    &dwType,
                    NULL,
                    NULL);
        switch (lSts)
        {
        case ERROR_SUCCESS:
            m_bfResult.Resize((dwLen + 1) * sizeof(TCHAR), TRUE);
            if (NULL != pdwType)
                *pdwType = dwType;
            szResult = (LPCTSTR)m_bfResult.Access();
            fDone = TRUE;
            break;
        case ERROR_NO_MORE_ITEMS:
            szResult = NULL;
            fDone = TRUE;
            break;
        case ERROR_MORE_DATA:
            if (dwLen == m_bfResult.Space())
                throw (DWORD)ERROR_INSUFFICIENT_BUFFER; // Won't tell us how big.
            m_bfResult.Presize((dwLen + 1) * sizeof(TCHAR));
            break;
        default:
            throw (DWORD)lSts;
        }
    }

    return szResult;
}


/*++

GetValue:

    These methods provide access to the values of the Value entries.

Arguments:

    szKeyValue supplies the name of the Value entry to get.
    pszValue receives the value of the entry as a string.
    pdwValue receives the value of the entry as a DWORD.
    ppbValue receives the value of the entry as a Binary string.
    pcbLength receives the length of the entry when it's a binary string.
    pdwType receives the type of the registry entry.

Return Value:

    None

Throws:

    Any error encountered.

Author:

    Doug Barlow (dbarlow) 7/15/1996

--*/

void
CRegistry::GetValue(
    LPCTSTR szKeyValue,
    CBuffer &bfValue,
    LPDWORD pdwType)
{
    LONG lSts;
    DWORD dwLen, dwType = 0;
    BOOL fDone = FALSE;

    if (ERROR_SUCCESS != m_lSts)
        throw (DWORD)m_lSts;

    while (!fDone)
    {
        dwLen = bfValue.Space();
        lSts = RegQueryValueEx(
                    m_hKey,
                    szKeyValue,
                    NULL,
                    &dwType,
                    bfValue.Access(),
                    &dwLen);
        switch (lSts)
        {
        case ERROR_SUCCESS:
            bfValue.Resize(dwLen, TRUE);
            fDone = TRUE;
            break;
        case ERROR_MORE_DATA:
            bfValue.Presize(dwLen);
            break;
        default:
            throw (DWORD)lSts;
        }
    }
    if (NULL != pdwType)
        *pdwType = dwType;
}


void
CRegistry::GetValue(
    LPCTSTR szKeyValue,
    LPTSTR *pszValue,
    LPDWORD pdwType)
{
    DWORD dwLen, dwType;
    TCHAR chTmp;
    CBuffer bfUnexpanded;
    LONG lSts;

    dwLen = 0;
    lSts = RegQueryValueEx(
                m_hKey,
                szKeyValue,
                NULL,
                &dwType,
                NULL,
                &dwLen);
    if (ERROR_SUCCESS != lSts)
        throw (DWORD)lSts;
    switch (dwType)
    {
    case REG_EXPAND_SZ:
        bfUnexpanded.Presize(dwLen);
        GetValue(szKeyValue, bfUnexpanded, &dwType);
        dwLen = ExpandEnvironmentStrings(
                    (LPTSTR)bfUnexpanded.Access(),
                    &chTmp,
                    0);
        if (0 == dwLen)
            throw GetLastError();
        dwLen = ExpandEnvironmentStrings(
                    (LPTSTR)bfUnexpanded.Access(),
                    (LPTSTR)m_bfResult.Resize(dwLen),
                    dwLen);
        if (0 == dwLen)
            throw GetLastError();
        break;

    case REG_BINARY:
    case REG_MULTI_SZ:
    case REG_SZ:
        m_bfResult.Presize(dwLen);
        GetValue(szKeyValue, m_bfResult, &dwType);
        break;

    default:
        throw (DWORD)ERROR_BAD_FORMAT;
    }
    *pszValue = (LPTSTR)m_bfResult.Access();
    if (NULL != pdwType)
        *pdwType = dwType;
}

void
CRegistry::GetValue(
    LPCTSTR szKeyValue,
    LPDWORD pdwValue,
    LPDWORD pdwType)
const
{
    LONG lSts;
    DWORD dwLen, dwType;
    CBuffer szExpanded;

    if (ERROR_SUCCESS != m_lSts)
        throw (DWORD)m_lSts;

    dwLen = sizeof(DWORD);
    lSts = RegQueryValueEx(
                m_hKey,
                szKeyValue,
                NULL,
                &dwType,
                (LPBYTE)pdwValue,
                &dwLen);
    if (ERROR_SUCCESS != lSts)
        throw (DWORD)lSts;

    switch (dwType)
    {
    case REG_DWORD_BIG_ENDIAN:
        *pdwValue = NTOHL(*pdwValue);
        break;
    case REG_DWORD:
    // case REG_DWORD_LITTLE_ENDIAN:
        break;
    default:
        throw (DWORD)ERROR_BAD_FORMAT;
    }
    if (NULL != pdwType)
        *pdwType = dwType;
}

void
CRegistry::GetValue(
    LPCTSTR szKeyValue,
    LPBYTE *ppbValue,
    LPDWORD pcbLength,
    LPDWORD pdwType)
{
    DWORD dwType;

    GetValue(szKeyValue, m_bfResult, &dwType);
    *ppbValue = m_bfResult.Access();
    *pcbLength = m_bfResult.Length();
    if (NULL != pdwType)
        *pdwType = dwType;
}


/*++

SetValue:

    These methods provide write access to the values of the Value entries.

Arguments:

    szKeyValue supplies the name of the Value entry to set.
    szValue supplies the new value of the entry as a string.
    dwValue supplies the new value of the entry as a DWORD.
    pbValue supplies the new value of the entry as a Binary string.
    cbLength supplies the length of the entry when it's a binary string.
    dwType supplies the registry type value.

Return Value:

    None

Throws:

    Any error encountered.

Author:

    Doug Barlow (dbarlow) 7/15/1996

--*/

void
CRegistry::SetValue(
    LPCTSTR szKeyValue,
    LPCTSTR szValue,
    DWORD dwType)
const
{
    LONG lSts;

    if (ERROR_SUCCESS != m_lSts)
        throw (DWORD)m_lSts;

    lSts = RegSetValueEx(
                m_hKey,
                szKeyValue,
                0,
                dwType,
                (LPBYTE)szValue,
                (lstrlen(szValue) + 1) * sizeof(TCHAR));
    if (ERROR_SUCCESS != lSts)
        throw (DWORD)lSts;
}

void
CRegistry::SetValue(
    LPCTSTR szKeyValue,
    DWORD dwValue,
    DWORD dwType)
const
{
    LONG lSts;

    if (ERROR_SUCCESS != m_lSts)
        throw (DWORD)m_lSts;

    if (REG_DWORD_BIG_ENDIAN == dwType)
        dwValue = HTONL(dwValue);
    lSts = RegSetValueEx(
                m_hKey,
                szKeyValue,
                0,
                dwType,
                (LPBYTE)&dwValue,
                sizeof(DWORD));
    if (ERROR_SUCCESS != lSts)
        throw (DWORD)lSts;
}

void
CRegistry::SetValue(
    LPCTSTR szKeyValue,
    LPCBYTE pbValue,
    DWORD cbLength,
    DWORD dwType)
const
{
    LONG lSts;

    if (ERROR_SUCCESS != m_lSts)
        throw (DWORD)m_lSts;

    lSts = RegSetValueEx(
                m_hKey,
                szKeyValue,
                0,
                dwType,
                pbValue,
                cbLength);
    if (ERROR_SUCCESS != lSts)
        throw (DWORD)lSts;
}


/*++

GetStringValue:

    This is an alternate mechanism for obtaining a string value.

Arguments:

    szKeyValue supplies the name of the Key Value to obtain.

    pdwType, if non-null, receives the type of registry entry.

Return Value:

    The value of the registry entry as a string pointer.

Throws:

    Any errors encountered.

Author:

    Doug Barlow (dbarlow) 7/16/1996

--*/

LPCTSTR
CRegistry::GetStringValue(
    LPCTSTR szKeyValue,
    LPDWORD pdwType)
{
    LPTSTR szResult;
    GetValue(szKeyValue, &szResult, pdwType);
    return szResult;
}


/*++

GetNumericValue:

    This is an alternate mechanism for obtaining a numeric value.

Arguments:

    szKeyValue supplies the name of the Key Value to obtain.

    pdwType, if non-null, receives the type of registry entry.

Return Value:

    The value of the registry entry as a DWORD.

Throws:

    Any errors encountered.

Author:

    Doug Barlow (dbarlow) 7/16/1996

--*/

DWORD
CRegistry::GetNumericValue(
    LPCTSTR szKeyValue,
    LPDWORD pdwType)
const
{
    DWORD dwResult;
    GetValue(szKeyValue, &dwResult, pdwType);
    return dwResult;
}


/*++

GetBinaryValue:

    This is an alternate mechanism for obtaining a binary value.

Arguments:

    szKeyValue supplies the name of the Key Value to obtain.

    pdwType, if non-null, receives the type of registry entry.

Return Value:

    The value of the registry entry as a binary pointer.

Throws:

    Any errors encountered.

Author:

    Doug Barlow (dbarlow) 7/16/1996

--*/

LPCBYTE
CRegistry::GetBinaryValue(
    LPCTSTR szKeyValue,
    LPDWORD pcbLength,
    LPDWORD pdwType)
{
    LPBYTE pbResult;
    DWORD cbLength;
    GetValue(szKeyValue, &pbResult, &cbLength, pdwType);
    if (NULL != pcbLength)
        *pcbLength = cbLength;
    return pbResult;

}


/*++

GetValueLength:

    This routine is designed to work in conjunction with GetBinaryValue, but may
    have other uses as well.  It returns the length of the internal storage
    area, in bytes.  Note DWORDs are not stored internally, so this value will
    not represent the size of a DWORD following a GetNumericValue call.

Arguments:

    none

Return Value:

    The length of the internal storage buffer, in bytes.

Throws:

    Any errors encountered.

Author:

    Doug Barlow (dbarlow) 7/16/1996

--*/

DWORD
CRegistry::GetValueLength(
    void)
const
{
    if (ERROR_SUCCESS != m_lSts)
        throw (DWORD)m_lSts;

    return m_bfResult.Length();
}


/*++

ValueExists:

    This routine tests for the existance of a given value, and optionally
    returns its type and length.

Arguments:

    none

Return Value:

    A boolean indication as to whether or not the value exists.

Throws:

    Any errors encountered.

Author:

    Doug Barlow (dbarlow) 7/16/1996

--*/

BOOL
CRegistry::ValueExists(
    LPCTSTR szKeyValue,
    LPDWORD pcbLength,
    LPDWORD pdwType)
const
{
    LONG lSts;
    DWORD dwLen, dwType;
    BOOL fResult = FALSE;

    if (ERROR_SUCCESS != m_lSts)
        throw (DWORD)m_lSts;

    dwLen = 0;
    lSts = RegQueryValueEx(
                m_hKey,
                szKeyValue,
                NULL,
                &dwType,
                NULL,
                &dwLen);
    if (ERROR_SUCCESS == lSts)
    {
        if (NULL != pcbLength)
            *pcbLength = dwLen;
        if (NULL != pdwType)
            *pdwType = dwType;
        fResult = TRUE;
    }
    return fResult;
}


/*++

GetDisposition:

    This routine returns the disposition of creation.

Arguments:

    none

Return Value:

    The return disposition flag from creating the registry entry.

Throws:

    Any errors encountered.

Author:

    Doug Barlow (dbarlow) 7/16/1996

--*/

DWORD
CRegistry::GetDisposition(
    void)
const
{
    if (ERROR_SUCCESS != m_lSts)
        throw (DWORD)m_lSts;

    return m_dwDisposition;
}


/*++

SetMultiStringValue:

    This method simplifies the work of adding a MultiString value to the
    registry.

Arguments:

    szKeyValue supplies the name of the Value entry to set.
    mszValue supplies the new value of the entry as a multi-string.
    dwType supplies the registry type value.

Return Value:

    None

Throws:

    Any errors encountered as a DWORD status value.

Author:

    Doug Barlow (dbarlow) 11/6/1996

--*/

void
CRegistry::SetMultiStringValue(
    LPCTSTR szKeyValue,
    LPCTSTR mszValue,
    DWORD dwType)
const
{
    LONG lSts;

    if (ERROR_SUCCESS != m_lSts)
        throw (DWORD)m_lSts;

    lSts = RegSetValueEx(
                m_hKey,
                szKeyValue,
                0,
                dwType,
                (LPBYTE)mszValue,
                MStrLen(mszValue) * sizeof(TCHAR));
    if (ERROR_SUCCESS != lSts)
        throw (DWORD)lSts;
}


/*++

GetMultiStringValue:

    This method obtains a multi-string value from the registry.

Arguments:

    szKeyValue supplies the name of the Key Value to obtain.

    pdwType, if non-null, receives the type of registry entry.

Return Value:

    The registry value, as a multi-string.

Throws:

    Any errors encountered as a DWORD status value.

Author:

    Doug Barlow (dbarlow) 11/6/1996

--*/

LPCTSTR
CRegistry::GetMultiStringValue(
    LPCTSTR szKeyValue,
    LPDWORD pdwType)
{
    LPTSTR szResult;
    GetValue(szKeyValue, &szResult, pdwType);
    return szResult;
}


/*++

SetAcls:

    This method sets security attributes for a single key, or an entire key
    branch.

Arguments:

    SecurityInformation supplies the SECURITY_INFORMATION value (see
        RegSetKeySecurity in the SDK documentation).
    pSecurityDescriptor supplies the SECURITY_DESCRIPTOR value (see
        RegSetKeySecurity in the SDK documentation).
    fRecurse supplies an indicator as to whether to just set the ACL on this
        key (FALSE), or this key and all subkeys (TRUE).

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 11/10/1998

--*/

void
CRegistry::SetAcls(
    IN SECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN BOOL fRecurse)
{
    LONG lSts;

    if (ERROR_SUCCESS != m_lSts)
        throw (DWORD)m_lSts;

    lSts = RegSetKeySecurity(
                m_hKey,
                SecurityInformation,
                pSecurityDescriptor);
    if (ERROR_SUCCESS != lSts)
        throw (DWORD)lSts;
    if (fRecurse)
    {
        CRegistry regSub;
        LPCTSTR szSubKey;
        DWORD dwIndex;

        for (dwIndex = 0;
             NULL != (szSubKey = Subkey(dwIndex));
             dwIndex += 1)
        {
            regSub.Open(m_hKey, szSubKey);
            regSub.SetAcls(
                SecurityInformation,
                pSecurityDescriptor);
            regSub.Close();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\scardlib\registry.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    Registry

Abstract:

    This header file defines a class to provide simple interaction to values in
    the Registry Database.

Author:

    Doug Barlow (dbarlow) 7/15/1996

Environment:

    Win32, C++ w/ Exceptions

Notes:

--*/

#ifndef _REGISTRY_H_
#define _REGISTRY_H_

#include <winreg.h>

#define REG_OPTION_EXISTS (~REG_LEGAL_OPTION)


//
//==============================================================================
//
//  CRegistry
//

class CRegistry
{
public:

    //  Constructors & Destructor
    CRegistry(
        HKEY hBase,
        LPCTSTR szName,
        REGSAM samDesired = KEY_ALL_ACCESS,
        DWORD dwOptions = REG_OPTION_EXISTS,
        LPSECURITY_ATTRIBUTES lpSecurityAttributes = NULL);
    CRegistry(void);
    ~CRegistry();

    //  Properties
    //  Methods
    void
    Open(
        HKEY hBase,
        LPCTSTR szName,
        REGSAM samDesired = KEY_ALL_ACCESS,
        DWORD dwOptions = REG_OPTION_EXISTS,
        LPSECURITY_ATTRIBUTES lpSecurityAttributes = NULL);

    void Close(void);
    LONG Status(BOOL fQuiet = FALSE) const;
    void Empty(void);
    void Copy(CRegistry &regSrc);
    void DeleteKey(LPCTSTR szKey, BOOL fQuiet = FALSE) const;
    void DeleteValue(LPCTSTR szValue, BOOL fQuiet = FALSE) const;
    LPCTSTR Subkey(DWORD dwIndex);
    LPCTSTR Value(DWORD dwIndex, LPDWORD pdwType = NULL);
    void
    GetValue(
        LPCTSTR szKeyValue,
        LPTSTR *pszValue,
        LPDWORD pdwType = NULL);
    void
    GetValue(
        LPCTSTR szKeyValue,
        LPDWORD pdwValue,
        LPDWORD pdwType = NULL)
    const;
    void
    GetValue(
        LPCTSTR szKeyValue,
        LPBYTE *ppbValue,
        LPDWORD pcbLength,
        LPDWORD pdwType = NULL);
    void
    GetValue(
        LPCTSTR szKeyValue,
        CBuffer &bfValue,
        LPDWORD pdwType = NULL);
    void
    SetValue(
        LPCTSTR szKeyValue,
        LPCTSTR szValue,
        DWORD dwType = REG_SZ)
    const;
    void
    SetValue(
        LPCTSTR szKeyValue,
        DWORD dwValue,
        DWORD dwType = REG_DWORD)
    const;
    void
    SetValue(
        LPCTSTR szKeyValue,
        LPCBYTE pbValue,
        DWORD cbLength,
        DWORD dwType = REG_BINARY)
    const;
    void
    SetAcls(
        IN SECURITY_INFORMATION SecurityInformation,
        IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
        IN BOOL fRecurse = TRUE);
    void
    SetMultiStringValue(
        LPCTSTR szKeyValue,
        LPCTSTR mszValue,
        DWORD dwType = REG_MULTI_SZ)
    const;
    LPCTSTR
    GetStringValue(
        LPCTSTR szKeyValue,
        LPDWORD pdwType = NULL);
    DWORD
    GetNumericValue(
        LPCTSTR szKeyValue,
        LPDWORD pdwType = NULL)
    const;
    LPCBYTE
    GetBinaryValue(
        LPCTSTR szKeyValue,
        LPDWORD pcbLength = NULL,
        LPDWORD pdwType = NULL);
    LPCTSTR
    GetMultiStringValue(
        LPCTSTR szKeyValue,
        LPDWORD pdwType = NULL);
    DWORD
    GetValueLength(
        void)
    const;
    BOOL
    ValueExists(
        LPCTSTR szKeyValue,
        LPDWORD pcbLength = NULL,
        LPDWORD pdwType = NULL)
    const;
    DWORD
    GetDisposition(
        void)
    const;

    //  Operators
    operator HKEY(
        void)
    const
    { Status();
      return m_hKey; };

protected:
    //  Properties

    HKEY m_hKey;
    DWORD m_dwDisposition;
    CBuffer m_bfResult;
    LONG m_lSts;


    //  Methods

};


#endif // _REGISTRY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\scardlib\text.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1995 - 1999

Module Name:

    text

Abstract:

    This module provides the runtime code to support the CTextString class.

Author:

    Doug Barlow (dbarlow) 11/7/1995

Environment:

    Win32, C++ w/ Exceptions

Notes:

    None

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include "SCardLib.h"


/*++

CTextString::operator=:

    These methods set the CTextString object to the given value, properly
    adjusting the object to the type of text.

Arguments:

    tz supplies the new value as a CTextString object.
    sz supples the new value as an LPCSTR object (ANSI).
    wsz supplies the new value as an LPCWSTR object (Unicode).

Return Value:

    A reference to the CTextString object.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

CTextString &
CTextString::operator=(
    const CTextString &tz)
{

    //
    // See what the other CTextString object has that's good, and copy it over
    // here.
    //

    switch (m_fFlags = tz.m_fFlags)
    {
    case fNoneGood:
        // Nothing's Good!?!  ?Error?
        throw (DWORD)ERROR_INTERNAL_ERROR;
        break;

    case fAnsiGood:
        // The ANSI buffer is good.
        m_bfAnsi = tz.m_bfAnsi;
        break;

    case fUnicodeGood:
        // The Unicode buffer is good.
        m_bfUnicode = tz.m_bfUnicode;
        break;

    case fBothGood:
        // Everything is good.
        m_bfAnsi = tz.m_bfAnsi;
        m_bfUnicode = tz.m_bfUnicode;
        break;

    default:
        // Internal error.
        throw (DWORD)ERROR_INTERNAL_ERROR;
        break;
    }
    return *this;
}

LPCSTR
CTextString::operator=(
    LPCSTR sz)
{
    DWORD length;

    //
    // Reset the ANSI buffer.
    //

    if (NULL != sz)
    {
        length = Length(sz) + 1;
        m_bfAnsi.Set((LPBYTE)sz, length * sizeof(CHAR));
    }
    else
        m_bfAnsi.Reset();
    m_fFlags = fAnsiGood;
    return sz;
}

LPCWSTR
CTextString::operator=(
    LPCWSTR wsz)
{
    DWORD length;


    //
    // Reset the Unicode Buffer.
    //

    if (NULL != wsz)
    {
        length = Length(wsz) + 1;
        m_bfUnicode.Set((LPBYTE)wsz, length * sizeof(WCHAR));
    }
    else
        m_bfUnicode.Reset();
    m_fFlags = fUnicodeGood;
    return wsz;
}


/*++

CTextString::operator+=:

    These methods append the given data to the existing CTextString object
    value, properly adjusting the object to the type of text.

Arguments:

    tz supplies the new value as a CTextString object.
    sz supples the new value as an LPCSTR object (ANSI).
    wsz supplies the new value as an LPCWSTR object (Unicode).

Return Value:

    A reference to the CTextString object.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

CTextString &
CTextString::operator+=(
    const CTextString &tz)
{

    //
    // Append the other's good value to our value.
    //

    switch (tz.m_fFlags)
    {
    case fNoneGood:
        throw (DWORD)ERROR_INTERNAL_ERROR;
        break;

    case fAnsiGood:
        *this += (LPCSTR)tz.m_bfAnsi.Access();
        break;

    case fUnicodeGood:
        *this += (LPCWSTR)tz.m_bfUnicode.Access();
        break;

    case fBothGood:
#ifdef UNICODE
        *this += (LPCWSTR)tz.m_bfUnicode.Access();
#else
        *this += (LPCSTR)tz.m_bfAnsi.Access();
#endif
        break;

    default:
        throw (DWORD)ERROR_INTERNAL_ERROR;
        break;
    }
    return *this;
}

LPCSTR
CTextString::operator+=(
    LPCSTR sz)
{
    DWORD length;


    //
    // Extend ourself as an ANSI string.
    //

    if (NULL != sz)
    {
        length = Length(sz);
        if (0 < length)
        {
            length += 1;
            length *= sizeof(CHAR);
            Ansi();
            if (0 < m_bfAnsi.Length())
                m_bfAnsi.Resize(m_bfAnsi.Length() - sizeof(CHAR), TRUE);
            m_bfAnsi.Append((LPBYTE)sz, length);
            m_fFlags = fAnsiGood;
        }
    }
    return (LPCSTR)m_bfAnsi.Access();
}

LPCWSTR
CTextString::operator+=(
    LPCWSTR wsz)
{
    DWORD length;


    //
    // Extend ourself as a Unicode string.
    //

    if (NULL != wsz)
    {
        length = Length(wsz);
        if (0 < length)
        {
            length += 1;
            length *= sizeof(WCHAR);
            Unicode();
            if (0 < m_bfUnicode.Length())
                m_bfUnicode.Resize(m_bfUnicode.Length() - sizeof(WCHAR), TRUE);
            m_bfUnicode.Append((LPBYTE)wsz, length);
            m_fFlags = fUnicodeGood;
        }
    }
    return (LPCWSTR)m_bfUnicode.Access();
}


/*++

Unicode:

    This method returns the CTextString object as a Unicode string.

Arguments:

    None

Return Value:

    The value of the object expressed in Unicode.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

LPCWSTR
CTextString::Unicode(
    void)
{
    int length;


    //
    // See what data we've got, and if any conversion is necessary.
    //

    switch (m_fFlags)
    {
    case fNoneGood:
        // No valid values.  Report an error.
        throw (DWORD)ERROR_INTERNAL_ERROR;
        break;

    case fAnsiGood:
        // The ANSI value is good.  Convert it to Unicode.
        if (0 < m_bfAnsi.Length())
        {
            length =
                MultiByteToWideChar(
                    GetACP(),
                    MB_PRECOMPOSED,
                    (LPCSTR)m_bfAnsi.Access(),
                    m_bfAnsi.Length() - sizeof(CHAR),
                    NULL,
                    0);
            if (0 == length)
                throw GetLastError();
            m_bfUnicode.Resize((length + 1) * sizeof(WCHAR));
            length =
                MultiByteToWideChar(
                    GetACP(),
                    MB_PRECOMPOSED,
                    (LPCSTR)m_bfAnsi.Access(),
                    m_bfAnsi.Length() - sizeof(CHAR),
                    (LPWSTR)m_bfUnicode.Access(),
                    length);
            if (0 == length)
                throw GetLastError();
            *(LPWSTR)m_bfUnicode.Access(length * sizeof(WCHAR)) = 0;
        }
        else
            m_bfUnicode.Reset();
        m_fFlags = fBothGood;
        break;

    case fUnicodeGood:
    case fBothGood:
        // The Unicode value is good.  Just return that.
        break;

    default:
        // Internal error.
        throw (DWORD)ERROR_INTERNAL_ERROR;
        break;
    }


    //
    // If we don't have any value, return a null string.
    //

    if (0 == m_bfUnicode.Length())
        return L"\000";     // Double NULLs to support Multistrings
    else
        return (LPCWSTR)m_bfUnicode.Access();
}


/*++

CTextString::Ansi:

    This method returns the value of the object expressed in an ANSI string.

Arguments:

    None

Return Value:

    The value of the object expressed as an ANSI string.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

LPCSTR
CTextString::Ansi(
    void)
{
    int length;


    //
    // See what data we've got, and if any conversion is necessary.
    //

    switch (m_fFlags)
    {
    case fNoneGood:
        // Nothing is good!?!  Return an error.
        throw (DWORD)ERROR_INTERNAL_ERROR;
        break;

    case fUnicodeGood:
        // The Unicode buffer is good.  Convert it to ANSI.
        if (0 < m_bfUnicode.Length())
        {
            length =
                WideCharToMultiByte(
                    GetACP(),
                    0,
                    (LPCWSTR)m_bfUnicode.Access(),
                    (m_bfUnicode.Length() / sizeof(WCHAR)) - 1,
                    NULL,
                    0,
                    NULL,
                    NULL);
            if (0 == length)
                throw GetLastError();
            m_bfAnsi.Resize((length + 1) * sizeof(CHAR));
            length =
                WideCharToMultiByte(
                    GetACP(),
                    0,
                    (LPCWSTR)m_bfUnicode.Access(),
                    (m_bfUnicode.Length() / sizeof(WCHAR)) - 1,
                    (LPSTR)m_bfAnsi.Access(),
                    length,
                    NULL,
                    NULL);
            if (0 == length)
                throw GetLastError();
            *(LPSTR)m_bfAnsi.Access(length * sizeof(CHAR)) = 0;
        }
        else
            m_bfAnsi.Reset();
        m_fFlags = fBothGood;
        break;

    case fAnsiGood:
    case fBothGood:
        // The ANSI buffer is good.  We'll return that.
        break;

    default:
        // An internal error.
        throw (DWORD)ERROR_INTERNAL_ERROR;
        break;
    }


    //
    // If there's nothing in the ANSI buffer, return a null string.
    //

    if (0 == m_bfAnsi.Length())
        return "\000";  // Double NULLs to support Multistrings
    else
        return (LPCSTR)m_bfAnsi.Access();
}


/*++

Compare:

    These methods compare the value of this object to another value, and return
    a comparative value.

Arguments:

    tz supplies the value to be compared as a CTextString object.
    sz supplies the value to be compared as an ANSI string.
    wsz supplies the value to be compared as a Unicode string.

Return Value:

    < 0 - The supplied value is less than this object.
    = 0 - The supplied value is equal to this object.
    > 0 - The supplies value is greater than this object.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

int
CTextString::Compare(
    const CTextString &tz)
{
    int nResult;


    //
    // See what we've got to compare.
    //

    switch (tz.m_fFlags)
    {
    case fNoneGood:
        // Nothing!?!  Complain.
        throw (DWORD)ERROR_INTERNAL_ERROR;
        break;

    case fBothGood:
    case fAnsiGood:
        // Use the ANSI version for fastest comparison.
        Ansi();
        nResult = CompareStringA(
                    LOCALE_USER_DEFAULT,
                    0,
                    (LPCSTR)m_bfAnsi.Access(),
                    (m_bfAnsi.Length() / sizeof(CHAR)) - 1,
                    (LPCSTR)tz.m_bfAnsi.Access(),
                    (tz.m_bfAnsi.Length() / sizeof(CHAR)) - 1);
        break;

    case fUnicodeGood:
        // The Unicode version is good.
        Unicode();
        nResult = CompareStringW(
                    LOCALE_USER_DEFAULT,
                    0,
                    (LPCWSTR)m_bfUnicode.Access(),
                    (m_bfUnicode.Length() / sizeof(WCHAR)) - 1,
                    (LPCWSTR)tz.m_bfUnicode.Access(),
                    (tz.m_bfUnicode.Length() / sizeof(WCHAR)) - 1);
        break;

    default:
        // Internal Error.
        throw (DWORD)ERROR_INTERNAL_ERROR;
        break;
    }
    return nResult;
}

int
CTextString::Compare(
    LPCSTR sz)
{
    int nResult;


    //
    // Make sure our ANSI version is good.
    //

    Ansi();


    //
    // Do an ANSI comparison.
    //

    nResult = CompareStringA(
                LOCALE_USER_DEFAULT,
                0,
                (LPCSTR)m_bfAnsi.Access(),
                (m_bfAnsi.Length() / sizeof(CHAR)) - 1,
                sz,
                Length(sz));
    return nResult;
}

int
CTextString::Compare(
    LPCWSTR wsz)
{
    int nResult;


    //
    // Make sure our Unicode version is good.
    //

    Unicode();


    //
    // Do the comparison using Unicode.
    //

    nResult = CompareStringW(
                LOCALE_USER_DEFAULT,
                0,
                (LPCWSTR)m_bfUnicode.Access(),
                (m_bfUnicode.Length() / sizeof(WCHAR)) - 1,
                wsz,
                Length(wsz));
    return nResult;
}


/*++

Length:

    These routines return the length of strings, in Characters, not including
    any trailing null characters.

Arguments:

    sz supplies the value whos length is to be returned as an ANSI string.
    wsz supplies the value whos length is to be returned as a Unicode string.

Return Value:

    The length of the string, in characters, excluding the trailing null.

Author:

    Doug Barlow (dbarlow) 2/17/1997

--*/

DWORD
CTextString::Length(
    void)
{
    DWORD dwLength = 0;

    switch (m_fFlags)
    {
    case fNoneGood:
        // Nothing is good!?!  Return an error.
        throw (DWORD)ERROR_INTERNAL_ERROR;
        break;

    case fAnsiGood:
        // The ANSI buffer is good.  We'll return its length.
        if (0 < m_bfAnsi.Length())
            dwLength = (m_bfAnsi.Length() / sizeof(CHAR)) - 1;
        break;

    case fUnicodeGood:
        // The Unicode buffer is good.  Return it's length.
        if (0 < m_bfUnicode.Length())
            dwLength = (m_bfUnicode.Length() / sizeof(WCHAR)) - 1;
        break;

    case fBothGood:
#ifdef UNICODE
        // The Unicode buffer is good.  Return it's length.
        if (0 < m_bfUnicode.Length())
            dwLength = (m_bfUnicode.Length() / sizeof(WCHAR)) - 1;
#else
        // The ANSI buffer is good.  We'll return its length.
        if (0 < m_bfAnsi.Length())
            dwLength = (m_bfAnsi.Length() / sizeof(CHAR)) - 1;
#endif
        break;

    default:
        // An internal error.
        throw (DWORD)ERROR_INTERNAL_ERROR;
        break;
    }
    return dwLength;
}

DWORD
CTextString::Length(
    LPCWSTR wsz)
{
    return lstrlenW(wsz);
}

DWORD
CTextString::Length(
    LPCSTR sz)
{
    return lstrlenA(sz);
}


//
//==============================================================================
//
//  CTextMultistring
//

/*++

Length:

    These routines return the length of strings, in Characters, not including
    any trailing null characters.

Arguments:

    sz supplies the value whos length is to be returned as an ANSI string.
    wsz supplies the value whos length is to be returned as a Unicode string.

Return Value:

    The length of the string, in characters, excluding the trailing null.

Author:

    Doug Barlow (dbarlow) 2/17/1997

--*/

DWORD
CTextMultistring::Length(
    LPCWSTR wsz)
{
    return MStrLen(wsz) - 1;
}

DWORD
CTextMultistring::Length(
    LPCSTR sz)
{
    return MStrLen(sz) - 1;
}


/*++

Length:

    This routine returns the length of the stored MultiString in characters,
    including the trailing NULL characters.

Arguments:

    None

Return Value:

    The length, in characters, including trailing nulls.

Author:

    Doug Barlow (dbarlow) 2/25/1998

--*/

DWORD
CTextMultistring::Length(
    void)
{
    return CTextString::Length() + 1;
}


/*++

operator=:

    These methods assign values to the MultiString object.

Arguments:

    tz supplies the new value as a CTextMultistring
    sz supplies the new value as an ANSI string
    wsz supplies the new value as a UNICODE string

Return Value:

    The assigned string value, in its original form.

Author:

    Doug Barlow (dbarlow) 2/25/1998

--*/

CTextMultistring &
CTextMultistring::operator=(
    const CTextMultistring &tz)
{
    CTextString::operator=((const CTextString &)tz);
    return *this;
}

LPCSTR
CTextMultistring::operator=(
    LPCSTR sz)
{
    return CTextString::operator=(sz);
}

LPCWSTR
CTextMultistring::operator=(
    LPCWSTR wsz)
{
    return CTextString::operator=(wsz);
}


/*++

operator+=:

    These methods append values to the MultiString object.

Arguments:

    tz supplies the value to be appended as a CTextMultistring
    sz supplies the value to be appended as an ANSI string
    wsz supplies the value to be appended as a UNICODE string

Return Value:

    The concatenated string, in the form of the appended string.

Author:

    Doug Barlow (dbarlow) 2/25/1998

--*/

CTextMultistring &
CTextMultistring::operator+=(
    const CTextMultistring &tz)
{
    CTextString::operator+=((const CTextString &)tz);
    return *this;
}

LPCSTR
CTextMultistring::operator+=(
    LPCSTR sz)
{
    return CTextString::operator+=(sz);
}

LPCWSTR
CTextMultistring::operator+=(
    LPCWSTR wsz)
{
    return CTextString::operator+=(wsz);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\acert.cpp ===
// ACert.cpp -- CAbstractCertificate class definition

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#include <algorithm>
#include <functional>

#include "cciCert.h"
#include "cciCont.h"
#include "AKeyPair.h"
#include "TransactionWrap.h"
#include "AContHelp.h"

using namespace std;
using namespace cci;

/////////////////////////// LOCAL/HELPER  /////////////////////////////////

///////////////////////////    PUBLIC     /////////////////////////////////

                                                  // Types
                                                  // C'tors/D'tors
CAbstractCertificate::~CAbstractCertificate()
{}

                                                  // Operators
bool
CAbstractCertificate::operator==(CAbstractCertificate const &rhs) const
{
    CTransactionWrap wrap(m_hcard);
    CTransactionWrap rhswrap(rhs.m_hcard);

    return CProtectableCrypt::operator==(rhs) &&
        DoEquals(rhs);
}

bool
CAbstractCertificate::operator!=(CAbstractCertificate const &rhs) const
{
    return !(*this == rhs);
}

                                                  // Operations
void
CAbstractCertificate::Delete()
{
    CTransactionWrap wrap(m_hcard);

    // Remove any references to this object from the container
    vector<CContainer> vCont(m_hcard->EnumContainers());
    for_each(vCont.begin(), vCont.end(),
             EraseFromContainer<CCertificate, CAbstractKeyPair>(CCertificate(this),
                                                                CAbstractKeyPair::Certificate,
                                                                CAbstractKeyPair::Certificate));

    DoDelete();
}


                                                  // Access
                                                  // Predicates
                                                  // Static Variables

///////////////////////////   PROTECTED   /////////////////////////////////

                                                  // C'tors/D'tors
CAbstractCertificate::CAbstractCertificate(CAbstractCard const &racard,
                                           ObjectAccess oa,
                                           bool fAlwaysZip)
    : slbRefCnt::RCObject(),
      CAbstractZipValue(racard, oa, fAlwaysZip)
{}


                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables


///////////////////////////    PRIVATE    /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\acard.cpp ===
// ACard.cpp: implementation of the CAbstractCard class.
//
// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
//////////////////////////////////////////////////////////////////////
#include "NoWarning.h"

#include <functional>


#include "ACard.h"
#include "V1Card.h"
#include "V2Card.h"
#include "TransactionWrap.h"

using namespace std;
using namespace iop;
using namespace cci;
using namespace scu;

/////////////////////////// LOCAL/HELPER  /////////////////////////////////

namespace
{
	// Like std::mem_fun1_t but for constant member functions
	template<class R, class T, class A>
	class ConstMemFun1Type
		: public binary_function<T const *, A, R>
	{
	public:
		explicit ConstMemFun1Type(R (T::*Pm)(A) const)
			: m_Ptr(Pm)
		{}

		R operator()(T const *P, A Arg) const
		{
			return ((P->*m_Ptr)(Arg));
		}

	private:
		R (T::*m_Ptr)(A) const;
	};

	// Like std::mem_fun1 but for constant member functions
	template<class R, class T, class A> inline
	ConstMemFun1Type<R, T, A>
	ConstMemFun1(R (T::*Pm)(A) const)
	{
			return (ConstMemFun1Type<R, T, A>(Pm));
	}


    template<class R>
    ConstMemFun1Type<vector<R>, CAbstractCard const, ObjectAccess> const
    PriviledgedEnumFun(vector<R> (CAbstractCard::*pmf)(ObjectAccess) const)
    {
        return ConstMemFun1Type<vector<R>, CAbstractCard const, ObjectAccess>(pmf);
    }

    template<class T, class Op>
    vector<T>
    EnumAll(Op Enumerator)
    {
        vector<T> vResult = Enumerator(oaPublicAccess);
        vector<T> vPriv = Enumerator(oaPrivateAccess);

        vResult.reserve(vResult.size() + vPriv.size());
        vResult.insert(vResult.end(), vPriv.begin(), vPriv.end());
    
        return vResult;
    };

} // namespace

    
///////////////////////////    PUBLIC     /////////////////////////////////

                                                  // Types
                                                  // C'tors/D'tors

CAbstractCard::~CAbstractCard()
{}


                                                  // Operators
bool
CAbstractCard::operator==(CAbstractCard const &rhs) const
{
    CTransactionWrap wrap(this);
    CTransactionWrap rhswrap(rhs); // will throw if the card is pulled.

    return m_strReaderName == rhs.m_strReaderName;
}


bool
CAbstractCard::operator!=(CAbstractCard const &rhs) const
{
    return !(*this == rhs);
}

   
// Operations
void
CAbstractCard::AuthenticateUser(SecureArray<BYTE> const &rstrBuffer)
{
	m_apSmartCard->VerifyCHV(1, rstrBuffer.data());
}

void
CAbstractCard::ChangePIN(SecureArray<BYTE> const &rstrOldPIN,
                         SecureArray<BYTE> const &rstrNewPIN)
{
	if ((rstrOldPIN.size() != 0x08) || (rstrNewPIN.size() != 0x08))
        throw Exception(ccBadPinLength);

	m_apSmartCard->ChangeCHV(1,
                             rstrOldPIN.data(),
                             rstrNewPIN.data());
		
	
}

void
CAbstractCard::Logout()
{
	m_apSmartCard->LogoutAll();
}

CAbstractCard *
CAbstractCard::Make(string const &rstrReader)
{
    auto_ptr<CIOP> apiop(new CIOP());
    auto_ptr<CSmartCard>
        apSmartCard(apiop->Connect(rstrReader.c_str()));

    typedef auto_ptr<CAbstractCard>(*PCardMakerFun)(string const &rstrReader,
                                                    auto_ptr<CIOP> &rapiop,
                                                    auto_ptr<CSmartCard> &rapSmartCard);
    static PCardMakerFun aCardMakers[] = 
    {
        CV2Card::DoMake,
        CV1Card::DoMake,
        0
    };
    
    auto_ptr<CAbstractCard> apCard;
    for (PCardMakerFun *ppcmf = aCardMakers;
         (*ppcmf && !apCard.get()); ++ppcmf)
        apCard = auto_ptr<CAbstractCard>((*ppcmf)(rstrReader,
                                                  apiop,
                                                  apSmartCard));

    if (!apCard.get())
        throw Exception(ccNotPersonalized);

    apCard->Setup();

    return apCard.release();                      // caller given ownership
}

void
CAbstractCard::SetUserPIN(string const &rstrPin)
{
	if (rstrPin.size() != 8)
		throw Exception(ccBadPinLength);

    m_apSmartCard->ChangeCHV(1, reinterpret_cast<BYTE const *>(rstrPin.data()));
}

void
CAbstractCard::VerifyKey(string const &rstrKey,
                         BYTE bKeyNum)
{
	m_apSmartCard->VerifyKey(bKeyNum,
							 static_cast<WORD>(rstrKey.size()),
                             reinterpret_cast<BYTE const *>(rstrKey.data()));
}

void
CAbstractCard::VerifyTransportKey(string const &rstrKey)
{
	m_apSmartCard->VerifyTransportKey(reinterpret_cast<BYTE const *>(rstrKey.data()));
}

void 
CAbstractCard::GenRandom(DWORD dwNumBytes, BYTE *bpRand)
{
    m_apSmartCard->GetChallenge(dwNumBytes, bpRand);
}
                                                  // Access

SCardType
CAbstractCard::CardType()
{
	char const *szCardName = m_apSmartCard->getCardName();

    // TO DO: Kludge Alert--a better type interface is needed in the
    // IOP to determine the card type rather than keying on the name.
    // For now, the Cryptoflex8K type is interpreted to mean it's a
    // Cryptoflex card and Access16K means it's an Access card.  Thus
    // any "Cryptoflex" will map to Cryptoflex8K (including 4K) and
    // any "Cyberflex" will map to Access16K.  The folded mapping was
    // to minimize impact to PKCS with the impending release.
    //
    // All of this should be revisited with the IOP.
    SCardType sct = UnknownCard;

	if (strstr(szCardName, "Cryptoflex"))
		sct = Cryptoflex8K;
	if (strstr(szCardName, "Cyberflex"))
		sct = Access16K;

	return sct;

}

vector<CCertificate>
CAbstractCard::EnumCertificates() const
{
	CTransactionWrap wrap(this);

    return 
        EnumAll<CCertificate>(bind1st(PriviledgedEnumFun<CCertificate>(EnumCertificates), this));
}

vector<CDataObject>
CAbstractCard::EnumDataObjects() const
{
	CTransactionWrap wrap(this);

    return
        EnumAll<CDataObject>(bind1st(PriviledgedEnumFun<CDataObject>(EnumDataObjects), this));
}

vector <CPrivateKey>
CAbstractCard::EnumPrivateKeys() const
{
	CTransactionWrap wrap(this);

    return
        EnumAll<CPrivateKey>(bind1st(PriviledgedEnumFun<CPrivateKey>(EnumPrivateKeys), this));
}

vector<CPublicKey>
CAbstractCard::EnumPublicKeys() const
{
	CTransactionWrap wrap(this);

    return
        EnumAll<CPublicKey>(bind1st(PriviledgedEnumFun<CPublicKey>(EnumPublicKeys), this));

}

string
CAbstractCard::ReaderName() const
{
	return m_strReaderName;
}

CSmartCard &
CAbstractCard::SmartCard() const
{
    return *m_apSmartCard;
}

                                                  // Predicates

// Card is connected and available (e.g. in the reader)
bool
CAbstractCard::IsAvailable() const
{
    bool fIsAvailable = false;

    try
    {
        CTransactionWrap wrap(this);

        DWORD dwState;
        DWORD dwProtocol;
    
        m_apSmartCard->GetState(dwState, dwProtocol);
        fIsAvailable = (SCARD_SPECIFIC == dwState);
    }

    catch (...)
    {
    }

    return fIsAvailable;
}

    
                                                  // Static Variables

///////////////////////////   PROTECTED   /////////////////////////////////

                                                  // C'tors/D'tors

CAbstractCard::CAbstractCard(string const &rstrReaderName,
                             auto_ptr<iop::CIOP> &rapiop,
                             auto_ptr<CSmartCard> &rapSmartCard)
    : CCryptFactory(),
      slbRefCnt::RCObject(),
      m_strReaderName(rstrReaderName),
      m_apiop(rapiop),
      m_apSmartCard(rapSmartCard)
{}

                                                  // Operators
                                                  // Operations
void
CAbstractCard::DoSetup()
{}

                                                  // Access
                                                  // Predicates
                                                  // Static Variables


///////////////////////////    PRIVATE    /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations

void
CAbstractCard::Setup()
{
    CTransactionWrap wrap(this);

    DoSetup();
}

                                                  // Access
                                                  // Predicates
                                                  // Static Variables
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\scardlib\text.h ===
/*++

Copyright (C) Microsoft Corporation, 1995 - 1999

Module Name:

    text

Abstract:

    This header file provides a text handling class.

Author:

    Doug Barlow (dbarlow) 10/5/1995

Environment:

    Win32

Notes:



--*/

#ifndef _TEXT_H_
#define _TEXT_H_

//#include <string.h>
//#include <mbstring.h>
#include "buffers.h"


//
//==============================================================================
//
//  CTextString
//

class CTextString
{
public:

    //  Constructors & Destructor
    CTextString()
    :   m_bfUnicode(),
        m_bfAnsi()
    { m_fFlags = fBothGood; };
    virtual ~CTextString() {};

    //  Properties
    //  Methods
    void Clear(void)
    {
        m_bfUnicode.Clear();
        m_bfAnsi.Clear();
        m_fFlags = fBothGood;
    };
    void Reset(void)
    {
        m_bfUnicode.Reset();
        m_bfAnsi.Reset();
        m_fFlags = fBothGood;
    };
    virtual DWORD Length(void);

    //  Operators
    CTextString &operator=(const CTextString &tz);
    LPCSTR operator=(LPCSTR sz);
    LPCWSTR operator=(LPCWSTR wsz);
    CTextString &operator+=(const CTextString &tz);
    LPCSTR operator+=(LPCSTR sz);
    LPCWSTR operator+=( LPCWSTR wsz);
    BOOL operator==(const CTextString &tz)
    { return (0 == Compare(tz)); };
    BOOL operator==(LPCSTR sz)
    { return (0 == Compare(sz)); };
    BOOL operator==(LPCWSTR wsz)
    { return (0 == Compare(wsz)); };
    BOOL operator!=(const CTextString &tz)
    { return (0 != Compare(tz)); };
    BOOL operator!=(LPCSTR sz)
    { return (0 != Compare(sz)); };
    BOOL operator!=(LPCWSTR wsz)
    { return (0 != Compare(wsz)); };
    BOOL operator<=(const CTextString &tz)
    { return (0 <= Compare(tz)); };
    BOOL operator<=(LPCSTR sz)
    { return (0 <= Compare(sz)); };
    BOOL operator<=(LPCWSTR wsz)
    { return (0 <= Compare(wsz)); };
    BOOL operator>=(const CTextString &tz)
    { return (0 >= Compare(tz)); };
    BOOL operator>=(LPCSTR sz)
    { return (0 >= Compare(sz)); };
    BOOL operator>=(LPCWSTR wsz)
    { return (0 >= Compare(wsz)); };
    BOOL operator<(const CTextString &tz)
    { return (0 < Compare(tz)); };
    BOOL operator<(LPCSTR sz)
    { return (0 < Compare(sz)); };
    BOOL operator<(LPCWSTR wsz)
    { return (0 < Compare(wsz)); };
    BOOL operator>(const CTextString &tz)
    { return (0 > Compare(tz)); };
    BOOL operator>(LPCSTR sz)
    { return (0 > Compare(sz)); };
    BOOL operator>(LPCWSTR wsz)
    { return (0 > Compare(wsz)); };
    operator LPCSTR(void)
    { return Ansi(); };
    operator LPCWSTR(void)
    { return Unicode(); };

protected:
    enum {
        fNoneGood = 0,
        fAnsiGood = 1,
        fUnicodeGood = 2,
        fBothGood = 3
    } m_fFlags;

    //  Properties
    CBuffer
        m_bfUnicode,
        m_bfAnsi;

    //  Methods
    LPCWSTR Unicode(void);      // Return the text as a Unicode string.
    LPCSTR Ansi(void);          // Return the text as an Ansi string.
    int Compare(const CTextString &tz);
    int Compare(LPCSTR sz);
    int Compare(LPCWSTR wsz);
    virtual DWORD Length(LPCSTR szString);
    virtual DWORD Length(LPCWSTR szString);
};


//
//==============================================================================
//
//  CTextMultistring
//

class CTextMultistring
:   public CTextString
{
public:

    //  Constructors & Destructor

    CTextMultistring()
    :   CTextString()
    {};

    //  Properties
    //  Methods
    virtual DWORD Length(void);

    //  Operators
    CTextMultistring &operator=(const CTextMultistring &tz);
    CTextMultistring &operator+=(const CTextMultistring &tz);
    LPCSTR operator=(LPCSTR sz);
    LPCWSTR operator=(LPCWSTR wsz);
    LPCSTR operator+=(LPCSTR sz);
    LPCWSTR operator+=( LPCWSTR wsz);

protected:
    //  Properties
    //  Methods
    virtual DWORD Length(LPCSTR szString);
    virtual DWORD Length(LPCWSTR szString);
};

#endif // _TEXT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\aconthelp.h ===
// AContHelp.h -- Helpers with abstract containers

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#if !defined(SLBCCI_ACONTHELP_H)
#define SLBCCI_ACONTHELP_H

// Note:  This file should only be included by the CCI, not directly
// by the client.

#include <functional>

#include "cciKeyPair.h"
#include "MethodHelp.h"

namespace cci
{
    // Functor to erase an item (cert, pub/pri key) from both key
    // pairs of a container
    template<class T, class C>
    class EraseFromContainer
        : std::unary_function<CContainer &, void>
    {
    public:
        EraseFromContainer(T const &rItem,
                           typename AccessorMethod<T, C>::AccessorPtr Accessor,
                           typename ModifierMethod<T, C>::ModifierPtr Modifier)
            : m_Item(rItem),
              m_matAccess(Accessor),
              m_mmtModify(Modifier)
        {}

        result_type
        operator()(argument_type rhcont)
        {
            EraseFromKeyPair(rhcont->SignatureKeyPair());
            EraseFromKeyPair(rhcont->ExchangeKeyPair());
        }

    private:

        void
        EraseFromKeyPair(CKeyPair &rhkp)
        {
            if (rhkp)
            {
                T TmpItem(m_matAccess(*rhkp));
                if (TmpItem && (m_Item == TmpItem))
                    m_mmtModify(*rhkp, T());
            }
        }

        T const m_Item;
        MemberAccessorType<T, C> m_matAccess;
        MemberModifierType<T, C> m_mmtModify;
    };

} // namespace cci

#endif // SLBCCI_ACONTHELP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\acont.cpp ===
// ACont.cpp -- CAbstractContainer implementation

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#include "cciCont.h"
#include "TransactionWrap.h"

#include "cciCert.h"
#include "cciKeyPair.h"
#include "cciPriKey.h"
#include "cciPubKey.h"

using namespace std;
using namespace cci;

/////////////////////////// LOCAL/HELPER  /////////////////////////////////

namespace
{
    void
    Clear(CKeyPair const &rkp)
    {
            CPublicKey pubKey(rkp->PublicKey());
            if (pubKey)
                pubKey->Delete();

            CPrivateKey priKey(rkp->PrivateKey());
            if (priKey)
                priKey->Delete();

            CCertificate cert(rkp->Certificate());
            if (cert)
                cert->Delete();
        }

} // namespace


///////////////////////////    PUBLIC     /////////////////////////////////

                                                  // Types
                                                  // C'tors/D'tors
CAbstractContainer::~CAbstractContainer()
{}

                                                  // Operators
bool
CAbstractContainer::operator==(CAbstractContainer const &rhs) const
{
    CTransactionWrap wrap(m_hcard);
    CTransactionWrap rhswrap(rhs.m_hcard);

    return CCryptObject::operator==(rhs) &&
        DoEquals(rhs);
}

bool
CAbstractContainer::operator!=(CAbstractContainer const &rhs) const
{
    return !(*this == rhs);
}

                                                  // Operations
void
CAbstractContainer::Delete()
{
    CTransactionWrap wrap(m_hcard);

    // Delete all objects in this container
    Clear(ExchangeKeyPair());
    Clear(SignatureKeyPair());

    // If this container is the default container, re-set the default container
    if(m_hcard->DefaultContainer())
    {
    if (CContainer(this) == m_hcard->DefaultContainer())
        m_hcard->DefaultContainer(CContainer());
    }

    DoDelete();

}


                                                  // Access

CKeyPair
CAbstractContainer::ExchangeKeyPair()
{
    CTransactionWrap wrap(m_hcard);
    CContainer cont(this);
    return CKeyPair(m_hcard, cont, ksExchange);
}

CKeyPair
CAbstractContainer::GetKeyPair(KeySpec ks)
{
    CKeyPair kp;

    CTransactionWrap wrap(m_hcard);
    CContainer cont(this);
    switch (ks)
    {
    case ksExchange:
        kp = CKeyPair(m_hcard, cont, ksExchange);
        break;
    case ksSignature:
        kp = CKeyPair(m_hcard, cont, ksSignature);
        break;
    default:
        throw Exception(ccBadKeySpec);
    }
    return kp;
}

CKeyPair
CAbstractContainer::SignatureKeyPair()
{
    CTransactionWrap wrap(m_hcard);
    CContainer cont(this);
    return CKeyPair(m_hcard, cont, ksSignature);
}


                                                  // Predicates
bool
CAbstractContainer::KeyPairExists(KeySpec ks)
{

    bool fResult = true;

    CTransactionWrap wrap(m_hcard);

    CKeyPair kp(GetKeyPair(ks));

    if (!kp->PublicKey() && !kp->PrivateKey() && !kp->Certificate())
        fResult = false;

    return fResult;

}

                                                  // Static Variables

///////////////////////////   PROTECTED   /////////////////////////////////

                                                  // C'tors/D'tors
CAbstractContainer::CAbstractContainer(CAbstractCard const &racard)

    : slbRefCnt::RCObject(),
      CCryptObject(racard)
{}
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables


///////////////////////////    PRIVATE    /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\acard.h ===
// ACard.h: interface for the CAbstractCard class.
//
// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
//////////////////////////////////////////////////////////////////////

// Note:  This file should only be included by the CCI, not directly
// by the client.

#if !defined(SLBCCI_ACARD_H)
#define SLBCCI_ACARD_H


#include <functional>
#include <string>
#include <memory>                                 // for auto_ptr
#include <vector>
#include <utility>                                // for pair
#include <stddef.h>                               // for size_t

#include <iop.h>
#include <slbRCObj.h>
#include <iopPriBlob.h>
#include "slbCci.h"
#include "CryptFctry.h"
#include <scuMarker.h>

namespace cci
{
class CCard;
class CCertificate;
class CContainer;
class CDataObject;
class CPrivateKey;
class CPublicKey;

class CAbstractCard
    : public slbRefCnt::RCObject,
      protected CCryptFactory
{
    // To access factory methods
    friend class CContainer;
    friend class CCertificate;
    friend class CDataObject;
    friend class CKeyPair;
    friend class CPrivateKey;
    friend class CPublicKey;

public:
                                                  // Types
                                                  // C'tors/D'tors
    virtual
    ~CAbstractCard() throw();

                                                  // Operators
    virtual bool
    operator==(CAbstractCard const &rhs) const;
        // TO DO: this should be superceded by implementing singletons

    virtual bool
    operator!=(CAbstractCard const &rhs) const;
         // TO DO: this should be superceded by implementing singletons


                                                  // Operations
    void
    AuthenticateUser(scu::SecureArray<BYTE> const &rstrPIN);

    virtual void
    ChangePIN(scu::SecureArray<BYTE> const &rstrOldPIN,
              scu::SecureArray<BYTE> const &rstrNewPIN);

    virtual void
    DefaultContainer(CContainer const &rcont) = 0;

    virtual std::pair<std::string, // interpreted as the public modulus
                      cci::CPrivateKey>
    GenerateKeyPair(KeyType kt,
                    std::string const &rsExponent,
                    ObjectAccess oaPrivateKey = oaPrivateAccess) = 0;

    virtual void
    InitCard() = 0;

    virtual void
    InvalidateCache() = 0;

    virtual void
    Label(std::string const &rstrLabel) = 0;

    void
    Logout();

    static CAbstractCard *
    Make(std::string const &rstrReader);

    virtual void
    SetUserPIN(std::string const &rstrPin);

    virtual void
    VerifyKey(std::string const &rstrKey,
              BYTE bKeyNum);

    virtual void
    VerifyTransportKey(std::string const &rstrKey);

    void
    GenRandom(DWORD dwNumBytes, BYTE *bpRand);

                                                  // Access
    virtual size_t
    AvailableStringSpace(ObjectAccess oa) const = 0;

    SCardType
    CardType();

    virtual CContainer
    DefaultContainer() const = 0;

    std::vector<CCertificate>
    EnumCertificates() const;

    virtual std::vector<CContainer>
    EnumContainers() const = 0;

    std::vector<CDataObject>
    EnumDataObjects() const;

    std::vector<CPrivateKey>
    EnumPrivateKeys() const;

    std::vector<CPublicKey>
    EnumPublicKeys() const;

    virtual std::vector<CCertificate>
    EnumCertificates(ObjectAccess access) const = 0;

    virtual std::vector<CPublicKey>
    EnumPublicKeys(ObjectAccess access) const = 0;

    virtual std::vector<CPrivateKey>
    EnumPrivateKeys(ObjectAccess access) const = 0;

    virtual std::vector<CDataObject>
    EnumDataObjects(ObjectAccess access) const = 0;

    virtual std::string
    Label() const = 0;

    virtual scu::Marker<unsigned int>
    MarkerOnCard() const = 0;
    
    virtual BYTE
    MaxKeys(KeyType kt) const = 0;

    virtual size_t
    MaxStringSpace(ObjectAccess oa) const = 0;

    std::string
    ReaderName() const;

    iop::CSmartCard &
    SmartCard() const;                            // this should be protected

    virtual bool
    SupportedKeyFunction(KeyType kt,
                         CardOperation oper) const = 0;

                                                  // Predicates
    virtual bool
    IsCAPIEnabled() const = 0;

    bool
    IsAvailable() const;

    virtual bool
    IsPKCS11Enabled() const = 0;

    virtual bool
    IsEntrustEnabled() const = 0;

    virtual bool
    IsProtectedMode() const = 0;

    virtual bool
    IsKeyGenEnabled() const = 0;

    virtual bool
    IsMarkerOnCard() const = 0;
    

    virtual BYTE
    MajorVersion() const = 0;


protected:
                                                  // Types
                                                  // C'tors/D'tors
    CAbstractCard(std::string const &rstrReaderName,
                  std::auto_ptr<iop::CIOP> &rapiop,
                  std::auto_ptr<iop::CSmartCard> &rapSmartCard);
        // Note: To avoid memory leaks in the event of an exception,
        // CIOP and CSmartCard are passed as a reference to a
        // non-const auto_ptr so the constructed object can take
        // ownership responsibilities of the resource.

                                                  // Operators
                                                  // Operations
    virtual void
    DoSetup();

    static std::auto_ptr<CAbstractCard>
    DoMake(std::string const &rstrReaderName,
           std::auto_ptr<iop::CIOP> &rapiop,
           std::auto_ptr<iop::CSmartCard> &rapSmartCard);
        // not defined, should be defined by specializations
        // See note on constructor regarding rapiop and rapSmartCard.

                                                  // Access
                                                  // Predicates
                                                  // Variables

private:
                                                  // Types
                                                  // C'tors/D'tors
    CAbstractCard(CAbstractCard const &rhs);
        // not defined, copy not allowed.

                                                  // Operators
    CAbstractCard &
    operator=(CAbstractCard const &rhs);
        // not defined, initialization not allowed.

                                                  // Operations
    void
    Setup();
    
                                                  // Access
                                                  // Predicates
                                                  // Variables

    std::string m_strReaderName;
    std::auto_ptr<iop::CIOP> m_apiop;
    std::auto_ptr<iop::CSmartCard> m_apSmartCard;

};

}

#endif // !defined(SLBCCI_ACARD_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\acert.h ===
// ACert.h: interface for the CAbstractCertificate class.
//
// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
//////////////////////////////////////////////////////////////////////

// Note:  This file should only be included by the CCI, not directly
// by the client.

#if !defined(SLBCCI_ACERT_H)
#define SLBCCI_ACERT_H

#include <string>

#include <slbRCObj.h>

#include <iop.h>

#include "AZipValue.h"

namespace cci
{

class CAbstractCertificate
    : public slbRefCnt::RCObject,
      public CAbstractZipValue
{
public:
                                                  // Types
                                                  // C'tors/D'tors
    virtual
    ~CAbstractCertificate() = 0;

                                                  // Operators
    bool
    operator==(CAbstractCertificate const &rhs) const;
        // TO DO: this should be superceded by implementing singletons

    bool
    operator!=(CAbstractCertificate const &rhs) const;
        // TO DO: this should be superceded by implementing singletons

                                                  // Operations
    virtual void
    CredentialID(std::string const &rstrCredId) = 0;

    void
    Delete();

    virtual void
    ID(std::string const &rstrId) = 0;

    virtual void
    Issuer(std::string const &rstrIssuer) = 0;

    virtual void
    Label(std::string const &rstrLabel) = 0;

    virtual void
    Subject(std::string const &rstrSubject) = 0;

    virtual void
    Modifiable(bool flag) = 0;

    virtual void
    Serial(std::string const &rstrSerialNumber) = 0;

                                                  // Access
    virtual std::string
    CredentialID() = 0;

    virtual std::string
    ID() = 0;

    virtual std::string
    Issuer() = 0;

    virtual std::string
    Label() = 0;

    virtual bool
    Modifiable() = 0;

    virtual std::string
    Serial() = 0;

    virtual std::string
    Subject() = 0;

                                                  // Predicates

protected:
                                                  // Types
                                                  // C'tors/D'tors
    CAbstractCertificate(CAbstractCard const &racard,
                         ObjectAccess oa,
                         bool fAlwaysZip = false);

                                                  // Operators
                                                  // Operations
    virtual void
    DoDelete() = 0;

                                                  // Access
                                                  // Predicates
    virtual bool
    DoEquals(CAbstractCertificate const &rcert) const = 0;
        // TO DO: this should be superceded by implementing singletons

                                                  // Variables

private:
                                                  // Types
                                                  // C'tors/D'tors
    CAbstractCertificate(CAbstractCertificate const &rhs);
        // not defined, copying not allowed.

                                                  // Operators
    CAbstractCertificate &
    operator=(CAbstractCertificate const &rhs);
        // not defined, initialization not allowed.

                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables
};

}

#endif // !defined(SLBCCI_ACERT_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\adataobj.cpp ===
// ADataObj.cpp -- CAbstractDataObject class definition

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#include "cciDataObj.h"
#include "TransactionWrap.h"

using namespace std;
using namespace cci;

/////////////////////////// LOCAL/HELPER  /////////////////////////////////


///////////////////////////    PUBLIC     /////////////////////////////////

                                                  // Types
                                                  // C'tors/D'tors
CAbstractDataObject::~CAbstractDataObject()
{}

                                                  // Operators
bool
CAbstractDataObject::operator==(CAbstractDataObject const &rhs) const
{
    CTransactionWrap wrap(m_hcard);
    CTransactionWrap rhswrap(rhs.m_hcard);

    return CProtectableCrypt::operator==(rhs) &&
        DoEquals(rhs);
}

bool
CAbstractDataObject::operator!=(CAbstractDataObject const &rhs) const
{
    return !(*this == rhs);
}

                                                  // Operations
void
CAbstractDataObject::Delete()
{
    CTransactionWrap wrap(m_hcard);

    DoDelete();
}


                                                  // Access
                                                  // Predicates
                                                  // Static Variables

///////////////////////////   PROTECTED   /////////////////////////////////

                                                  // C'tors/D'tors
CAbstractDataObject::CAbstractDataObject(CAbstractCard const &racard,
                                         ObjectAccess oa,
                                         bool fAlwaysZip)
    : slbRefCnt::RCObject(),
      CAbstractZipValue(racard, oa, fAlwaysZip)
{}


                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables


///////////////////////////    PRIVATE    /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\acont.h ===
// ACont.h: interface for the CAbstractContainer class.
//
// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
//////////////////////////////////////////////////////////////////////

// Note:  This file should only be included by the CCI, not directly
// by the client.

#if !defined(SLBCCI_ACONT_H)
#define SLBCCI_ACONT_H

#include <string>

#include <slbRCObj.h>

#include "slbCci.h"
#include "CryptObj.h"
#include "KPCont.h"

namespace cci
{

class CAbstractContainer
    : public slbRefCnt::RCObject,
      public CCryptObject

{
public:
                                                  // Types
                                                  // C'tors/D'tors
    virtual
    ~CAbstractContainer() throw() = 0;
                                                  // Operators
    bool
    operator==(CAbstractContainer const &rhs) const;
        // TO DO: this should be superceded by implementing singletons

    bool
    operator!=(CAbstractContainer const &rhs) const;
        // TO DO: this should be superceded by implementing singletons

                                                  // Operations
    virtual
    void Delete();

    virtual void
    ID(std::string const &rstrID) = 0;

    virtual void
    Name(std::string const &rstrName) = 0;

                                                  // Access
    virtual CKeyPair
    ExchangeKeyPair();

    virtual CKeyPair
    GetKeyPair(KeySpec ks);

    virtual CKeyPair
    SignatureKeyPair();

    virtual std::string
    ID() = 0;

    virtual std::string
    Name() = 0;

                                                  // Predicates
    virtual bool
    KeyPairExists(KeySpec ks);


protected:
                                                  // Types
                                                  // C'tors/D'tors
    explicit
    CAbstractContainer(CAbstractCard const &racard);

                                                  // Operators
                                                  // Operations
    virtual void
    DoDelete() = 0;

                                                  // Access
                                                  // Predicates
    virtual bool
    DoEquals(CAbstractContainer const &rhs) const = 0;

                                                  // Variables

private:
                                                  // Types
                                                  // C'tors/D'tors
    CAbstractContainer(CAbstractContainer const &rhs);
        // not defined, copying not allowed.

                                                  // Operators
    CAbstractContainer &
    operator=(CAbstractContainer const &rhs);
        // not defined, initialization not allowed.

                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables
};

}

#endif // !defined(SLBCCI_ACONT_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\adataobj.h ===
// ADataObj.h: interface for the CAbstractDataObject class.
//
// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
//////////////////////////////////////////////////////////////////////

#if !defined(SLBCCI_ADATAOBJ_H)
#define SLBCCI_ADATAOBJ_H

// Note:  This file should only be included by the CCI, not directly
// by the client.

#include <string>

#include <slbRCObj.h>

#include "AZipValue.h"

namespace cci
{

class CAbstractDataObject
    : public slbRefCnt::RCObject,
      public CAbstractZipValue
{
public:
                                                  // Types
                                                  // C'tors/D'tors
    virtual
    ~CAbstractDataObject() throw() = 0;
                                                  // Operators
    bool
    operator==(CAbstractDataObject const &rhs) const;
        // TO DO: this should be superceded by implementing singletons

    bool
    operator!=(CAbstractDataObject const &rhs) const;
        // TO DO: this should be superceded by implementing singletons

                                                  // Operations
    virtual void
    Application(std::string const &rstr) = 0;

    void
    Delete();

    virtual void
    Label(std::string const &rstrLabel) = 0;

    virtual void
    Modifiable(bool flag) = 0;

                                                  // Access
    virtual std::string
    Application() = 0;

    virtual std::string
    Label() = 0;

    virtual bool
    Modifiable() = 0;


                                                  // Predicates

protected:
                                                  // Types
                                                  // C'tors/D'tors
    CAbstractDataObject(CAbstractCard const &racard,
                        ObjectAccess oa,
                        bool fAlwaysZip = false);

                                                  // Operators
                                                  // Operations
    virtual void
    DoDelete() = 0;

                                                  // Access
                                                  // Predicates
    virtual bool
    DoEquals(CAbstractDataObject const &rhs) const = 0;

                                                  // Variables

private:
                                                  // Types
                                                  // C'tors/D'tors
    CAbstractDataObject(CAbstractDataObject const &rhs);
        // not defined, copying not allowed.
                                                  // Operators
    CAbstractDataObject &
    operator=(CAbstractDataObject const &rhs);
        // not defined, initialization not allowed.

                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables

};

} // namespace cci

#endif // SLBCCI_ADATAOBJ_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\akeypair.cpp ===
// AKeyPair.cpp -- CAbstractKeyPair implementation

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#include "cciKeyPair.h"
#include "cciCont.h"
#include "TransactionWrap.h"

using namespace std;
using namespace cci;

/////////////////////////// LOCAL/HELPER  /////////////////////////////////


///////////////////////////    PUBLIC     /////////////////////////////////

                                                  // Types
                                                  // C'tors/D'tors
CAbstractKeyPair::~CAbstractKeyPair()
{}

                                                  // Operators
bool
CAbstractKeyPair::operator==(CAbstractKeyPair const &rhs) const
{
    CTransactionWrap wrap(m_hcard);
    CTransactionWrap rhswrap(rhs.m_hcard);

    return CCryptObject::operator==(rhs) &&
        (m_hcont == rhs.m_hcont) &&
        (m_ks == rhs.m_ks) &&
        DoEquals(rhs);
}

bool
CAbstractKeyPair::operator!=(CAbstractKeyPair const &rhs) const
{
    return !(*this == rhs);
}

                                                  // Operations
                                                  // Access

CContainer
CAbstractKeyPair::Container() const
{
    return m_hcont;
}

KeySpec
CAbstractKeyPair::Spec() const
{
    return m_ks;
}



                                                  // Predicates
                                                  // Static Variables

///////////////////////////   PROTECTED   /////////////////////////////////

                                                  // C'tors/D'tors
CAbstractKeyPair::CAbstractKeyPair(CAbstractCard const &racard,
                                   CContainer const &rhcont,
                                   KeySpec ks)
    : slbRefCnt::RCObject(),
      CCryptObject(racard),
      m_hcont(rhcont),
      m_ks(ks)
{
    if (ksNone == m_ks)
        throw Exception(ccBadKeySpec);
}
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables


///////////////////////////    PRIVATE    /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\apublickey.cpp ===
// APublicKey.cpp -- CAbstractPublicKey implementation

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#include <algorithm>

#include "cciPubKey.h"
#include "cciCont.h"
#include "AKeyPair.h"
#include "TransactionWrap.h"
#include "AContHelp.h"

using namespace std;
using namespace cci;

/////////////////////////// LOCAL/HELPER  /////////////////////////////////

///////////////////////////    PUBLIC     /////////////////////////////////

                                                  // Types
                                                  // C'tors/D'tors
CAbstractPublicKey::~CAbstractPublicKey()
{}


                                                  // Operators
bool
CAbstractPublicKey::operator==(CAbstractPublicKey const &rhs) const
{
    CTransactionWrap wrap(m_hcard);
    CTransactionWrap rhswrap(rhs.m_hcard);

    return CProtectableCrypt::operator==(rhs) &&
        DoEquals(rhs);

}

bool
CAbstractPublicKey::operator!=(CAbstractPublicKey const &rhs) const
{
    return !(*this == rhs);
}

                                                  // Operations
void
CAbstractPublicKey::Delete()
{
    CTransactionWrap wrap(m_hcard);

    // Remove any references to this object from the container
    vector<CContainer> vCont(m_hcard->EnumContainers());
    for_each(vCont.begin(), vCont.end(),
             EraseFromContainer<CPublicKey, CAbstractKeyPair>(CPublicKey(this),
                                                              CAbstractKeyPair::PublicKey,
                                                              CAbstractKeyPair::PublicKey));

    DoDelete();
}

                                                  // Access
                                                  // Predicates
                                                  // Static Variables

///////////////////////////   PROTECTED   /////////////////////////////////

                                                  // C'tors/D'tors
CAbstractPublicKey::CAbstractPublicKey(CAbstractCard const &racard,
                                       ObjectAccess oa)
    : slbRefCnt::RCObject(),
      CProtectableCrypt(racard, oa)
{}
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables


///////////////////////////    PRIVATE    /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\autobuildcount.h ===
// 2057
#ifndef AUTOBUILDCOUNT_H
#define AUTOBUILDCOUNT_H
#define BUILDCOUNT_NUM 2057
#define BUILDCOUNT_STR "2057"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\akeypair.h ===
// AKeyPair.h: interface for the CAbstractKeyPair class.
//
// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
//////////////////////////////////////////////////////////////////////

// Note:  This file should only be included by the CCI, not directly
// by the client.


#if !defined(SLBCCI_AKEYPAIR_H)
#define SLBCCI_AKEYPAIR_H

#include <string>

#include <slbRCObj.h>

#include "slbCci.h"
#include "cciCard.h"
#include "CryptObj.h"
#include "KPCont.h"

namespace cci
{

class CCertificate;
class CPrivateKey;
class CPublicKey;

class CAbstractKeyPair
    : public slbRefCnt::RCObject,
      public CCryptObject
{
public:
                                                  // Types
                                                  // C'tors/D'tors
    virtual
    ~CAbstractKeyPair() throw() = 0;

                                                  // Operators
    bool
    operator==(CAbstractKeyPair const &rhs) const;
        // TO DO: this should be superceded by implementing singletons

    bool
    operator!=(CAbstractKeyPair const &rhs) const;
        // TO DO: this should be superceded by implementing singletons

                                                  // Operations
    virtual void
    Certificate(CCertificate const &rcert) = 0;

    virtual void
    PrivateKey(CPrivateKey const &rprikey) = 0;

    virtual void
    PublicKey(CPublicKey const &rpubkey) = 0;

                                                  // Access
    virtual CCertificate
    Certificate() const = 0;

    CContainer
    Container() const;

    KeySpec
    Spec() const;

    virtual CPrivateKey
    PrivateKey() const = 0;

    virtual CPublicKey
    PublicKey() const = 0;


                                                  // Predicates

protected:
                                                  // Types
                                                  // C'tors/D'tors
    CAbstractKeyPair(CAbstractCard const &racard,
                     CContainer const &rhcont,
                     KeySpec ks);

                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
    virtual bool
    DoEquals(CAbstractKeyPair const &rhs) const = 0;
        // TO DO: this should be superceded by implementing singletons


                                                  // Variables
    KeySpec const m_ks;
    CContainer const m_hcont;

private:
                                                  // Types
                                                  // C'tors/D'tors
    CAbstractKeyPair(CAbstractKeyPair const &rhs);
        // not defined, copying not allowed.
                                                  // Operators
    CAbstractKeyPair &
    operator=(CAbstractKeyPair const &rhs);
        // not defined, initialization not allowed.

                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables
};

} // namespace

#endif // !defined(SLBCCI_AKEYPAIR_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\archivedvalue.h ===
// ArchivedValue.h: interface for the CArchivedValue class.
//
// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
//////////////////////////////////////////////////////////////////////

#if !defined(CCI_ARCHIVED_VALUE_H)
#define CCI_ARCHIVED_VALUE_H

#include "cciExc.h"

namespace cci
{

template<class T>
class CArchivedValue
{
public:
    CArchivedValue() : m_fIsCached(false) {};

    virtual ~CArchivedValue() {};

    bool IsCached() const
    {
        return m_fIsCached;
    };

    void Value(T const &rhs)
    {
        m_Value = rhs;
        m_fIsCached = true;
    };

    T Value()
    {
        if (!m_fIsCached)
            throw Exception(ccValueNotCached);
        return m_Value;
    };

    void Dirty()
    {
        m_fIsCached = false;
    }

    bool
    operator==(CArchivedValue<T> const &rhs) const
    {
        return (m_fIsCached == rhs.m_fIsCached) &&
            (m_Value == rhs.m_Value);
    }

    bool
    operator!=(CArchivedValue<T> const &rhs) const
    {
        return !(rhs == *this);
    }


private:
    bool m_fIsCached;
    T m_Value;
};

} // namespace cci

#endif // !defined(CCI_ARCHIVED_VALUE_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\apublickey.h ===
// APubKey.h: interface for the CAbstractPublicKey class.
//
// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
//////////////////////////////////////////////////////////////////////

#if !defined(SLBCCI_APUBLICKEY_H)
#define SLBCCI_APUBLICKEY_H

// Note:  This file should only be included by the CCI, not directly
// by the client.

#include <string>

#include <slbRCObj.h>

#include "ProtCrypt.h"

namespace cci {

class CAbstractPublicKey
    : public slbRefCnt::RCObject,
      public CProtectableCrypt
{
public:
                                                  // Types
                                                  // C'tors/D'tors
    virtual
    ~CAbstractPublicKey() throw() = 0;
                                                  // Operators
    bool
    operator==(CAbstractPublicKey const &rhs) const;
        // TO DO: this should be superceded by implementing singletons

    bool
    operator!=(CAbstractPublicKey const &rhs) const;
        // TO DO: this should be superceded by implementing singletons

                                                  // Operations
    virtual void
    CKInvisible(bool flag) = 0;

    virtual void
    CredentialID(std::string const &rstrID) = 0;

    virtual void
    Delete();

    virtual void
    Derive(bool flag) = 0;

    virtual void
    ID(std::string const &rstrID) = 0;

    virtual void
    EndDate(Date const &rdtEnd) = 0;

    virtual void
    Encrypt(bool flag) = 0;

    virtual void
    Exponent(std::string const &rstrExp) = 0;

    virtual void
    Label(std::string const  &rstrLabel) = 0;

    virtual void
    Local(bool flag) = 0;

    virtual void
    Modifiable(bool flag) = 0;

    virtual void
    Modulus(std::string const &rstrModulus) = 0;

    virtual void
    StartDate(Date const &rdtStart) = 0;

    virtual void
    Subject(std::string const &rstrSubject) = 0;

    virtual void
    Verify(bool flag) = 0;

    virtual void
    VerifyRecover(bool flag) = 0;

    virtual void
    Wrap(bool flag) = 0;

                                                  // Access
    virtual bool
    CKInvisible() = 0;

    virtual std::string
    CredentialID() = 0;

    virtual bool
    Derive() = 0;

    virtual bool
    Encrypt() = 0;

    virtual Date
    EndDate() = 0;

    virtual std::string
    Exponent() = 0;

    virtual std::string
    ID() = 0;

    virtual std::string
    Label() = 0;

    virtual bool
    Local() = 0;

    virtual bool
    Modifiable() = 0;

    virtual std::string
    Modulus() = 0;

    virtual bool
    Private() = 0;

    virtual Date
    StartDate() = 0;

    virtual std::string
    Subject() = 0;

    virtual bool
    Verify() = 0;

    virtual bool
    VerifyRecover() = 0;

    virtual bool
    Wrap() = 0;
                                                  // Predicates

protected:
                                                  // Types
                                                  // C'tors/D'tors
    CAbstractPublicKey(CAbstractCard const &racard,
                       ObjectAccess oa);

                                                  // Operators
                                                  // Operations
    virtual void
    DoDelete() = 0;

                                                  // Access
                                                  // Predicates
    virtual bool
    DoEquals(CAbstractPublicKey const &rhs) const = 0;
        // TO DO: this should be superceded by implementing singletons

                                                  // Variables

private:
                                                  // Types
                                                  // C'tors/D'tors
    CAbstractPublicKey(CAbstractPublicKey const &rhs);
        // not defined, copying not allowed.
                                                  // Operators
    CAbstractPublicKey &
    operator=(CAbstractPublicKey const &rhs);
        // not defined, initialization not allowed.

                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables

};

} // namespace cci

#endif // SLBCCI_APUBLICKEY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\azipvalue.cpp ===
// AZipValue.cpp -- CAbstractZipValue class definition

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
#include "NoWarning.h"

#include <windows.h>                              // for zip_public.h

#include <scuArrayP.h>

#include <slbZip.h>

#include "AZipValue.h"
#include "TransactionWrap.h"

using namespace std;
using namespace cci;

/////////////////////////// LOCAL/HELPER  /////////////////////////////////

namespace
{
    struct ZipBuffer
    {
        ZipBuffer()
            : m_pbData(0),
              m_uLength(0)
        {};

        ~ZipBuffer() throw()
        {
            try
            {
                if (m_pbData)
                    free(m_pbData);
            }

            catch (...)
            {
            }
        };

        BYTE *m_pbData;
        UINT m_uLength;
    };

    std::string
    AsString(ZipBuffer const &rzb)
    {
        return string(reinterpret_cast<char *>(rzb.m_pbData),
                      rzb.m_uLength);
    };

} // namespace


///////////////////////////    PUBLIC     /////////////////////////////////

                                                  // Types
                                                  // C'tors/D'tors
CAbstractZipValue::~CAbstractZipValue()
{}

                                                  // Operators
                                                  // Operations
void
CAbstractZipValue::Value(ValueType const &rhs)
{
    CTransactionWrap wrap(m_hcard);

    bool fReplaceData = !m_avData.IsCached() ||
          (m_avData.Value() != rhs);

    if (fReplaceData)
    {
        DoValue(Zip(rhs, m_fAlwaysZip));

        m_avData.Value(rhs);
    }

}

                                                  // Access
string
CAbstractZipValue::Value()
{
    CTransactionWrap wrap(m_hcard);

    if (!m_avData.IsCached())
        m_avData.Value(UnZip(DoValue()));

    return m_avData.Value();
}

                                                  // Predicates
                                                  // Static Variables

///////////////////////////   PROTECTED   /////////////////////////////////

                                                  // C'tors/D'tors
CAbstractZipValue::CAbstractZipValue(CAbstractCard const &racard,
                                     ObjectAccess oa,
                                     bool fAlwaysZip)
    : CProtectableCrypt(racard, oa),
      m_fAlwaysZip(fAlwaysZip),
      m_avData()
{}


                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables


///////////////////////////    PRIVATE    /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
// Compress (zip) the data, returning the smaller of the zipped or
// the original data.
CAbstractZipValue::ZipCapsule
CAbstractZipValue::Zip(std::string const &rsData,
                       bool fAlwaysZip)
{
    ZipBuffer zb;
    size_t const cTempLength =
        rsData.size() * sizeof string::value_type;
    scu::AutoArrayPtr<BYTE> aabTemp(new BYTE[cTempLength]);
    memcpy(aabTemp.Get(), rsData.data(), cTempLength);

    CompressBuffer(aabTemp.Get(), cTempLength, &zb.m_pbData, &zb.m_uLength);


    return (fAlwaysZip || (cTempLength > zb.m_uLength))
        ? ZipCapsule(AsString(zb), true)
        : ZipCapsule(rsData, false);
}

string
CAbstractZipValue::UnZip(ZipCapsule const &rzc)
{
    std::string strTemp(rzc.Data());
    if (rzc.IsCompressed())
    {
        // Need to decompress
        ZipBuffer zb;
        size_t cTempLength =
            strTemp.size() * sizeof string::value_type;
        scu::AutoArrayPtr<BYTE> aabTemp(new BYTE[cTempLength]);
        memcpy(aabTemp.Get(), strTemp.data(), cTempLength);

        DecompressBuffer(aabTemp.Get(), cTempLength,
                         &zb.m_pbData, &zb.m_uLength);

        strTemp = AsString(zb);
    }

    return strTemp;
}


                                                  // Access
                                                  // Predicates
                                                  // Static Variables
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\aprikey.cpp ===
// APriKey.cpp -- CAbstractPrivateKey implementation

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#include <algorithm>

#include "cciPriKey.h"
#include "cciCont.h"
#include "AKeyPair.h"
#include "TransactionWrap.h"
#include "AContHelp.h"

using namespace std;
using namespace cci;

/////////////////////////// LOCAL/HELPER  /////////////////////////////////


///////////////////////////    PUBLIC     /////////////////////////////////

                                                  // Types
                                                  // C'tors/D'tors
CAbstractPrivateKey::~CAbstractPrivateKey()
{}

                                                  // Operators
bool
CAbstractPrivateKey::operator==(CAbstractPrivateKey const &rhs) const
{
    CTransactionWrap wrap(m_hcard);
    CTransactionWrap rhswrap(rhs.m_hcard);

    return CProtectableCrypt::operator==(rhs) &&
        DoEquals(rhs);
}

bool
CAbstractPrivateKey::operator!=(CAbstractPrivateKey const &rhs) const
{
    return !(*this == rhs);
}

                                                 // Operations
void
CAbstractPrivateKey::Delete()
{
    CTransactionWrap wrap(m_hcard);

    // Remove any references to this object from the container
    vector<CContainer> vCont(m_hcard->EnumContainers());
    for_each(vCont.begin(), vCont.end(),
             EraseFromContainer<CPrivateKey, CAbstractKeyPair>(CPrivateKey(this),
                                                               CAbstractKeyPair::PrivateKey,
                                                               CAbstractKeyPair::PrivateKey));

    DoDelete();
}

void
CAbstractPrivateKey::Value(CPrivateKeyBlob const &rblob)
{
    CTransactionWrap wrap(m_hcard);

    DoWriteKey(rblob);
}

                                                  // Access
                                                  // Predicates
                                                  // Static Variables

///////////////////////////   PROTECTED   /////////////////////////////////

                                                  // C'tors/D'tors
CAbstractPrivateKey::CAbstractPrivateKey(CAbstractCard const &racard,
                                         ObjectAccess oa)
    : slbRefCnt::RCObject(),
      CProtectableCrypt(racard, oa)
{}
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables


///////////////////////////    PRIVATE    /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\aprikey.h ===
// APriKey.h: interface for the CAbstractPrivateKey class.
//
// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
//////////////////////////////////////////////////////////////////////

// Note:  This file should only be included by the CCI, not directly
// by the client.

#if !defined(SLBCCI_APRIKEY_H)
#define SLBCCI_APRIKEY_H

#include <string>

#include <slbRCObj.h>

#include "ProtCrypt.h"

namespace cci
{

using iop::CPrivateKeyBlob;

class CAbstractPrivateKey
    : public slbRefCnt::RCObject,
      public CProtectableCrypt
{
public:
                                                  // Types
                                                  // C'tors/D'tors
    virtual
    ~CAbstractPrivateKey() throw() = 0;
                                                  // Operators
    bool
    operator==(CAbstractPrivateKey const &rhs) const;
        // TO DO: this should be superceded by implementing singletons

    bool
    operator!=(CAbstractPrivateKey const &rhs) const;
        // TO DO: this should be superceded by implementing singletons

                                                  // Operations
    virtual void
    CredentialID(std::string const &rstrID) = 0;

    virtual void
    Decrypt(bool flag) = 0;

    void
    Delete();

    virtual void
    Derive(bool flag) = 0;

    virtual void
    EndDate(Date const &rEndDate) = 0;

    virtual void
    Exportable(bool flag) = 0;

    virtual void
    ID(std::string const &rstrID) = 0;

    virtual std::string
    InternalAuth(std::string const &rstrOld) = 0;

    virtual void
    Label(std::string const &rstrLabel) = 0;

    virtual void
    Local(bool flag) = 0;

    virtual void
    Modifiable(bool flag) = 0;

    virtual void
    Modulus(std::string const &rstrModulus) = 0;

    virtual void
    NeverExportable(bool flag) = 0;

    virtual void
    NeverRead(bool flag) = 0;

    virtual void
    PublicExponent(std::string const &rstrExponent) = 0;

    virtual void
    Read(bool flag) = 0;

    virtual void
    Sign(bool flag) = 0;

    virtual void
    SignRecover(bool flag) = 0;

    virtual void
    StartDate(Date &rdtStart) = 0;

    virtual void
    Subject(std::string const &rstrSubject) = 0;

    virtual void
    Unwrap(bool flag) = 0;

    void
    Value(CPrivateKeyBlob const &rblob);

                                                  // Access
    virtual std::string
    CredentialID() = 0;

    virtual bool
    Decrypt() = 0;

    virtual bool
    Derive() = 0;

    virtual Date
    EndDate() = 0;

    virtual bool
    Exportable() = 0;

    virtual std::string
    ID() = 0;

    virtual std::string
    Label() = 0;

    virtual bool
    Local() = 0;

    virtual bool
    Modifiable() = 0;

    virtual std::string
    Modulus() = 0;

    virtual bool
    NeverExportable() = 0;

    virtual bool
    NeverRead() = 0;

    virtual std::string
    PublicExponent() = 0;

    virtual bool
    Read() = 0;

    virtual bool
    Sign() = 0;

    virtual bool
    SignRecover() = 0;

    virtual Date
    StartDate() = 0;

    virtual std::string
    Subject() = 0;

    virtual bool
    Unwrap() = 0;


                                                  // Predicates

protected:
                                                  // Types
                                                  // C'tors/D'tors
    CAbstractPrivateKey(CAbstractCard const &racard,
                        ObjectAccess oa);

                                                  // Operators
                                                  // Operations
    virtual void
    DoDelete() = 0;

    virtual void
    DoWriteKey(CPrivateKeyBlob const &rblob) = 0;

                                                  // Access
                                                  // Predicates
    virtual bool
    DoEquals(CAbstractPrivateKey const &rhs) const = 0;
        // TO DO: this should be superceded by implementing singletons


                                                  // Variables

private:
                                                  // Types
                                                  // C'tors/D'tors
    CAbstractPrivateKey(CAbstractPrivateKey const &rhs);
        // not defined, copying not allowed.

                                                  // Operators
    CAbstractPrivateKey &
    operator=(CAbstractPrivateKey const &rhs);
        // not defined, initialization not allowed.

                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables
};

}

#endif // !defined(SLBCCI_APRIKEY_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\cardinfo.cpp ===
// CardInfo.cpp: implementation of the CCardInfo class.
//
// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
//////////////////////////////////////////////////////////////////////
#include "NoWarning.h"

#include "CardInfo.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

using namespace std;
using namespace scu;
using namespace cci;
using namespace iop;

CCardInfo::CCardInfo(CSmartCard &rCard)
    : m_rSmartCard(rCard),
      m_PersoDate(),
      m_Format(),
      m_sLabelSize(0),
      m_bUsagePolicy(0),
      m_bNum512Pri(0),
      m_bNum768Pri(0),
      m_bNum1024Pri(0),
      m_aabRSA512Keys(0),
      m_aabRSA768Keys(0),
      m_aabRSA1024Keys(0),
      m_sRSA512MaskOffset(0),
      m_sRSA512MaskSize(0),
      m_sRSA768MaskOffset(0),
      m_sRSA768MaskSize(0),
      m_sRSA1024MaskOffset(0),
      m_sRSA1024MaskSize(0)
{}

CCardInfo::~CCardInfo()
{}	

void CCardInfo::Reset()
{
	    
    m_rSmartCard.Select(CardInfoFilePath);

    if(m_sRSA512MaskSize)
    {
        memset(m_aabRSA512Keys.Get(),0,m_sRSA512MaskSize);
        m_rSmartCard.WriteBinary(m_sRSA512MaskOffset,
                                 m_sRSA512MaskSize, m_aabRSA512Keys.Get());
    }

    if(m_sRSA768MaskSize)
    {
        memset(m_aabRSA768Keys.Get(),0,m_sRSA768MaskSize);
        m_rSmartCard.WriteBinary(m_sRSA768MaskOffset,
                                 m_sRSA768MaskSize,
                                 m_aabRSA768Keys.Get());
    }
    
    if(m_sRSA1024MaskSize)
    {
        memset(m_aabRSA1024Keys.Get(),0,m_sRSA1024MaskSize);
        m_rSmartCard.WriteBinary(m_sRSA1024MaskOffset,
                                 m_sRSA1024MaskSize,
                                 m_aabRSA1024Keys.Get());
    }

    Label("");

}


void CCardInfo::UpdateCache()
{
    BYTE bMasterBlk[CardMasterBlkSize];
	    
    m_rSmartCard.Select(CardInfoFilePath);

    m_rSmartCard.ReadBinary(0, CardMasterBlkSize, bMasterBlk);

    // Get the personalization date out and convert it to a date struct
    // Card format is yyyyyyyy yyyyyymm mmdddddd

    DateArrayToDateStruct(&bMasterBlk[CardDateLoc], &m_PersoDate);

    // Get Format and convert to Format struct

    m_Format.bMajor = bMasterBlk[CardVersionMajorLoc];
    m_Format.bMinor = bMasterBlk[CardVersionMinorLoc];

    // Check that the version is supported.

    if(m_Format.bMajor!=2 && m_Format.bMinor!=0) throw Exception(ccFormatNotSupported);
	
    // Various parameters

    m_bUsagePolicy = bMasterBlk[CardUsagePolicyLoc];
    m_sLabelSize   = bMasterBlk[CardLabelSizeLoc+1]*256 + bMasterBlk[CardLabelSizeLoc];

    // Private key file parameters

    m_bNum512Pri = bMasterBlk[CardNumRSA512PrivLoc];
    m_bNum768Pri = bMasterBlk[CardNumRSA768PrivLoc];
    m_bNum1024Pri = bMasterBlk[CardNumRSA1024PrivLoc];

    // Calculate mask sizes and offsets

    m_sRSA512MaskSize = (m_bNum512Pri + 7) / 8;
    m_sRSA768MaskSize = (m_bNum768Pri + 7) / 8;
    m_sRSA1024MaskSize = (m_bNum1024Pri + 7) / 8;

    m_sRSA512MaskOffset = CardMasterBlkSize;
    m_sRSA768MaskOffset = m_sRSA512MaskOffset + m_sRSA512MaskSize;
    m_sRSA1024MaskOffset = m_sRSA768MaskOffset + m_sRSA768MaskSize;
        
    // Read and allocate the masks themselves

    m_aabRSA512Keys  = AutoArrayPtr<BYTE>(new BYTE[m_sRSA512MaskSize]);
    m_aabRSA768Keys  = AutoArrayPtr<BYTE>(new BYTE[m_sRSA768MaskSize]);
    m_aabRSA1024Keys = AutoArrayPtr<BYTE>(new BYTE[m_sRSA1024MaskSize]);
    
	AutoArrayPtr<BYTE> aabUsageBlk(new BYTE[UsageBlockSize()]);

    m_rSmartCard.ReadBinary(CardMasterBlkSize, UsageBlockSize(),
                            aabUsageBlk.Get());

    // Lay out the usage masks

    memcpy(m_aabRSA512Keys.Get(),
           &aabUsageBlk[m_sRSA512MaskOffset-CardMasterBlkSize],
           m_sRSA512MaskSize);
    memcpy(m_aabRSA768Keys.Get(),
           &aabUsageBlk[m_sRSA768MaskOffset-CardMasterBlkSize],
           m_sRSA768MaskSize);
    memcpy(m_aabRSA1024Keys.Get(),
           &aabUsageBlk[m_sRSA1024MaskOffset-CardMasterBlkSize],
           m_sRSA1024MaskSize);

}

BYTE CCardInfo::AllocatePrivateKey(BYTE bKeyType)
{
    BYTE *pbMask;
    BYTE bNumKeys;
    unsigned short sMaskSize;
    unsigned short sMaskOffset;

    switch(bKeyType)
    {

    case CardKeyTypeRSA512:
        pbMask = m_aabRSA512Keys.Get();
        bNumKeys = m_bNum512Pri;
        sMaskSize = m_sRSA512MaskSize;
        sMaskOffset = m_sRSA512MaskOffset;
        break;

    case CardKeyTypeRSA768:
        pbMask = m_aabRSA768Keys.Get();
        bNumKeys = m_bNum768Pri;
        sMaskSize = m_sRSA768MaskSize;
        sMaskOffset = m_sRSA768MaskOffset;
        break;

    case CardKeyTypeRSA1024:
        pbMask = m_aabRSA1024Keys.Get();
        bNumKeys = m_bNum1024Pri;
        sMaskSize = m_sRSA1024MaskSize;
        sMaskOffset = m_sRSA1024MaskOffset;
        break;

    default:
        throw Exception(ccBadKeySpec);
    }

    bool fFound = false;
    BYTE i = 0;
    while ((i < bNumKeys) && !fFound)
    {
        if (!BitSet(pbMask, i))
        {
            SetBit(pbMask, i);
            m_rSmartCard.Select(CardInfoFilePath);
            m_rSmartCard.WriteBinary(sMaskOffset, sMaskSize, pbMask);
            fFound = true;
        }
        else
            i++;
    }

    if (!fFound)
        throw Exception(ccOutOfPrivateKeySlots);

    return i;
}

void CCardInfo::FreePrivateKey(BYTE bKeyType, BYTE bKeyNum)
{
    BYTE *pbMask;
    BYTE bNumKeys;
    unsigned short sMaskSize;
    unsigned short sMaskOffset;

    switch(bKeyType)
    {

    case CardKeyTypeRSA512:
        pbMask = m_aabRSA512Keys.Get();
        bNumKeys = m_bNum512Pri;
        sMaskSize = m_sRSA512MaskSize;
        sMaskOffset = m_sRSA512MaskOffset;
        break;

    case CardKeyTypeRSA768:
        pbMask = m_aabRSA768Keys.Get();
        bNumKeys = m_bNum768Pri;
        sMaskSize = m_sRSA768MaskSize;
        sMaskOffset = m_sRSA768MaskOffset;
        break;

    case CardKeyTypeRSA1024:
        pbMask = m_aabRSA1024Keys.Get();
        bNumKeys = m_bNum1024Pri;
        sMaskSize = m_sRSA1024MaskSize;
        sMaskOffset = m_sRSA1024MaskOffset;
        break;

    default:
        throw Exception(ccBadKeySpec);
    }

    if(bKeyNum>=bNumKeys) throw Exception(ccKeyNotFound);
    if(!BitSet(pbMask,bKeyNum)) throw Exception(ccKeyNotFound);

    ResetBit(pbMask,bKeyNum);

    m_rSmartCard.Select(CardInfoFilePath);
    m_rSmartCard.WriteBinary(sMaskOffset, sMaskSize, pbMask);

}

void CCardInfo::Label(string const &rLabel)
{
    if(rLabel.size()>=m_sLabelSize) throw Exception(ccStringTooLong);
	
    unsigned short sLabelOffset = CardMasterBlkSize + UsageBlockSize() ;

    m_rSmartCard.Select(CardInfoFilePath);
   	m_rSmartCard.WriteBinary(sLabelOffset, rLabel.size()+1,
                             reinterpret_cast<BYTE const *>(rLabel.c_str()));

}

string CCardInfo::Label()
{
    string RetVal;
    AutoArrayPtr<char> aabBlk(new char[m_sLabelSize]);

    unsigned short sLabelOffset = CardMasterBlkSize + UsageBlockSize() ;

    m_rSmartCard.Select(CardInfoFilePath);
    m_rSmartCard.ReadBinary(sLabelOffset, m_sLabelSize,
                            reinterpret_cast<BYTE *>(aabBlk.Get()));
    aabBlk[m_sLabelSize-1] = '\0'; // Ensure termination

    RetVal.assign(aabBlk.Get());

    return RetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\azipvalue.h ===
// AZipValue.h -- interface declaration for the CAbstractZipValue

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#include <string>

#include "ProtCrypt.h"
#include "ArchivedValue.h"

#if !defined(SLBCCI_AZIPVALUE_H)
#define SLBCCI_AZIPVALUE_H

namespace cci
{

class CAbstractZipValue
    : public CProtectableCrypt
{
public:
                                                  // Types
    typedef std::string ValueType;

                                                  // C'tors/D'tors
    virtual
    ~CAbstractZipValue() throw() = 0;

                                                  // Operators
                                                  // Operations
    void
    Value(ValueType const &rData);

                                                  // Access
    ValueType
    Value();

                                                  // Predicates
                                                  // Variables

protected:
                                                  // Types
    class ZipCapsule
    {
    public:

        ZipCapsule(std::string sData,
                   bool fIsCompressed)
            : m_sData(sData),
              m_fIsCompressed(fIsCompressed)
        {};

        explicit
        ZipCapsule()
            : m_sData(),
              m_fIsCompressed(false)
        {};

        std::string
        Data() const
        {
            return m_sData;
        }

        bool
        IsCompressed() const
        {
            return m_fIsCompressed;
        }

    private:
        std::string m_sData;
        bool m_fIsCompressed;
    };


                                                  // C'tors/D'tors
    explicit
    CAbstractZipValue(CAbstractCard const &racard,
                      ObjectAccess oa,
                      bool fAlwaysZip);

                                                  // Operators
                                                  // Operations
    virtual void
    DoValue(ZipCapsule const &rzc) = 0;

                                                  // Access
    virtual ZipCapsule
    DoValue() = 0;

                                                  // Predicates
                                                  // Variables
private:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
    static ZipCapsule
    Zip(std::string const &rsData,
        bool fAlwaysZip);

    static std::string
    UnZip(ZipCapsule const &rzc);


                                                  // Access
                                                  // Predicates
                                                  // Variables
    bool const m_fAlwaysZip;
    CArchivedValue<ValueType> m_avData;

};

} // namespace cci

#endif // SLBCCI_AZIPVALUE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\ccicert.h ===
// cciCert.h: interface for the CCertificate class.
//
// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
//////////////////////////////////////////////////////////////////////

#if !defined(SLBCCI_CERT_H)
#define SLBCCI_CERT_H

#include <slbRCPtr.h>

#include "cciCard.h"
#include "ACert.h"

namespace cci
{

class CCertificate
    : public slbRefCnt::RCPtr<CAbstractCertificate,
                              slbRefCnt::DeepComparator<CAbstractCertificate> >
{

public:
                                                  // Types
                                                  // C'tors/D'tors
    CCertificate(ValueType *p = 0);

    CCertificate(CCard const &rhcard,
                 ObjectAccess oa = oaPublicAccess);

                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates

protected:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables

private:
                                                  // Types
    typedef slbRefCnt::RCPtr<ValueType,
                             slbRefCnt::DeepComparator<ValueType> > SuperClass;

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables

};

}

#endif // !defined(SLBCCI_CERT_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\ccicont.h ===
// cciCont.h: interface for the CContainer class.
//
// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
//////////////////////////////////////////////////////////////////////

#if !defined(SLBCCI_CONTAINER_H)
#define SLBCCI_CONTAINER_H

#include <slbRCPtr.h>

#include "cciCard.h"
#include "ACont.h"

// See KPCont.h

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\ccidataobj.h ===
// cciDataObj.h: interface for the CPublicKey class.
//
// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
//////////////////////////////////////////////////////////////////////

#if !defined(SLBCCI_DATAOBJ_H)
#define SLBCCI_DATAOBJ_H

#include <slbRCPtr.h>

#include "cciCard.h"
#include "ADataObj.h"

namespace cci
{
class CDataObject
    : public slbRefCnt::RCPtr<CAbstractDataObject,
                              slbRefCnt::DeepComparator<CAbstractDataObject> >
{

public:
                                                  // Types
                                                  // C'tors/D'tors
    CDataObject(ValueType *p = 0);

        CDataObject(CCard const &racard,
                ObjectAccess oa = oaPublicAccess);

                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates

protected:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables

private:
                                                  // Types
    typedef slbRefCnt::RCPtr<ValueType,
                             slbRefCnt::DeepComparator<ValueType> > SuperClass;

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables

};

}

#endif // !defined(SLBCCI_DATAOBJ_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\card.cpp ===
// Card.cpp: implementation of the CCard class.
//
// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
//////////////////////////////////////////////////////////////////////

#include "cciCard.h"

using namespace std;
using namespace cci;


/////////////////////////// LOCAL/HELPER  /////////////////////////////////

///////////////////////////    PUBLIC     /////////////////////////////////

                                                  // Types
                                                  // C'tors/D'tors
CCard::CCard(ValueType *p)
    : SuperClass(p)
{}

CCard::CCard(string const &rstrReaderName)
    : SuperClass(ValueType::Make(rstrReaderName))
{}

                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables

///////////////////////////   PROTECTED   /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables


///////////////////////////    PRIVATE    /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\ccicard.h ===
// cciCard.h -- interface for the CCard class

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#if !defined(SLBCCI_CARD_H)
#define SLBCCI_CARD_H

#include <string>

#include <slbRCPtr.h>

#include "ACard.h"

namespace cci
{

class CCard
    : public slbRefCnt::RCPtr<CAbstractCard,
                              slbRefCnt::DeepComparator<CAbstractCard> >

{
public:
                                                  // Types
                                                  // C'tors/D'tors
    CCard(ValueType *p = 0);

    explicit
    CCard(std::string const &rstrReaderName);
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates

protected:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables

private:
                                                  // Types
    typedef slbRefCnt::RCPtr<ValueType,
                             slbRefCnt::DeepComparator<ValueType> > SuperClass;
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables

};

} // namespace cci

#endif // SLBCCI_CARD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\cardinfo.h ===
// CardInfo.h: interface for the CCardInfo class.
//
// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_CARDINFO_H__F4AD08D3_143B_11D3_A587_00104BD32DA8__INCLUDED_)
#define AFX_CARDINFO_H__F4AD08D3_143B_11D3_A587_00104BD32DA8__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <scuArrayP.h>

#include <iop.h>

#include "slbCci.h"

namespace cci
{


class CCard;

class CCardInfo
{
public:


    CCardInfo(iop::CSmartCard &rCard);
    virtual ~CCardInfo();

    void UpdateCache();
    void Reset();

    Date PersonalizationDate() { return m_PersoDate; };
    void PersonalizationDate(Date const &rdtPerso);

    Format FormatVersion() { return m_Format; };

    unsigned short LabelSize() { return m_sLabelSize; };

    BYTE UsagePolicy() { return m_bUsagePolicy; };

    BYTE NumRSA512Keys() { return m_bNum512Pri; };
    BYTE NumRSA768Keys() { return m_bNum768Pri; };
    BYTE NumRSA1024Keys() { return m_bNum1024Pri; };

    BYTE AllocatePrivateKey(BYTE bKeyType);
    void FreePrivateKey(BYTE bKeyType, BYTE bKeyNum);

    void Label(std::string const &rLabel);
    std::string Label();

private:
    unsigned short UsageBlockSize() { return (m_sRSA512MaskSize + m_sRSA768MaskSize + m_sRSA1024MaskSize);};

    iop::CSmartCard &m_rSmartCard;

    Date        m_PersoDate;
    Format  m_Format;
    unsigned short m_sLabelSize;
    BYTE    m_bUsagePolicy;

    BYTE    m_bNum512Pri;
    BYTE    m_bNum768Pri;
    BYTE    m_bNum1024Pri;

    scu::AutoArrayPtr<BYTE> m_aabRSA512Keys;
    scu::AutoArrayPtr<BYTE> m_aabRSA768Keys;
    scu::AutoArrayPtr<BYTE> m_aabRSA1024Keys;

    unsigned short m_sRSA512MaskOffset;
    unsigned short m_sRSA512MaskSize;
    unsigned short m_sRSA768MaskOffset;
    unsigned short m_sRSA768MaskSize;
    unsigned short m_sRSA1024MaskOffset;
    unsigned short m_sRSA1024MaskSize;

};

const unsigned short CardDateLoc           = 0;
const unsigned short CardVersionMajorLoc   = 3;
const unsigned short CardVersionMinorLoc   = 4;
const unsigned short CardUsagePolicyLoc    = 5;
const unsigned short CardLabelSizeLoc      = 8;
const unsigned short CardNumRSA512PublLoc  = 20;
const unsigned short CardNumRSA512PrivLoc  = 21;
const unsigned short CardNumRSA768PublLoc  = 22;
const unsigned short CardNumRSA768PrivLoc  = 23;
const unsigned short CardNumRSA1024PublLoc = 24;
const unsigned short CardNumRSA1024PrivLoc = 25;
const unsigned short CardMasterBlkSize     = 42;

const BYTE CardCryptoAPIEnabledFlag = 0;
const BYTE CardPKCS11EnabledFlag    = 1;
const BYTE CardEntrustEnabledFlag   = 2;
const BYTE CardProtectedWriteFlag   = 3;
const BYTE CardKeyGenSupportedFlag  = 7;

const BYTE CardKeyTypeNone      = 0;
const BYTE CardKeyTypeRSA512    = 1;
const BYTE CardKeyTypeRSA768    = 2;
const BYTE CardKeyTypeRSA1024   = 3;

const char CardInfoFilePath[] = "/3f00/3f11/0020";

}
#endif // !defined(AFX_CARDINFO_H__F4AD08D3_143B_11D3_A587_00104BD32DA8__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\ccipubkey.h ===
// cciPubKey.h: interface for the CPublicKey class.
//
// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
//////////////////////////////////////////////////////////////////////

#if !defined(SLBCCI_PUBKEY_H)
#define SLBCCI_PUBKEY_H

#include <slbRCPtr.h>

#include "cciCard.h"
#include "APublicKey.h"

namespace cci
{
class CPublicKey
    : public slbRefCnt::RCPtr<CAbstractPublicKey,
                              slbRefCnt::DeepComparator<CAbstractPublicKey> >
{

public:
                                                  // Types
                                                  // C'tors/D'tors
    CPublicKey(ValueType *p = 0);

    CPublicKey(CCard const &rhcard,
               ObjectAccess oa = oaPublicAccess);

                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates

protected:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables

private:
                                                  // Types
    typedef slbRefCnt::RCPtr<ValueType,
                             slbRefCnt::DeepComparator<ValueType> > SuperClass;

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables

};

}

#endif // !defined(SLBCCI_PUBKEY_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\cert.cpp ===
// Cert.cpp -- CCertificate class definition

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
#include "NoWarning.h"

#include "CryptFctry.h"
#include "cciCert.h"

using namespace cci;

/////////////////////////// LOCAL/HELPER  /////////////////////////////////

///////////////////////////    PUBLIC     /////////////////////////////////

                                                  // Types
                                                  // C'tors/D'tors
CCertificate::CCertificate(ValueType *p)
    : SuperClass(p)
{}

CCertificate::CCertificate(CCard const &rhcard,
                           ObjectAccess oa)
    : SuperClass(rhcard->MakeCertificate(oa))
{}


                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables

///////////////////////////   PROTECTED   /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables


///////////////////////////    PRIVATE    /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\ccikeypair.h ===
// cciKeyPair.h: interface for the CKeyPair class.
//
// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
//////////////////////////////////////////////////////////////////////

#if !defined(SLBCCI_KEYPAIR_H)
#define SLBCCI_KEYPAIR_H

#include <slbRCPtr.h>

#include "cciCard.h"
#include "AKeyPair.h"

// See KPCont.h

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\certificateinforecord.cpp ===
// CertificateInfoRecord.cpp - Implementation of CCertificateInfoRecord class
//
// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
//////////////////////////////////////////////////////////////////////
#include "NoWarning.h"

#include "CertificateInfoRecord.h"
#include "TransactionWrap.h"

using namespace cci;

CCertificateInfoRecord::CCertificateInfoRecord(CV2Card const &rv2card,
                                               SymbolID bHandle,
                                               ObjectAccess access)
    : CObjectInfoRecord(rv2card, bHandle, access)
{
    Clear();
}

void CCertificateInfoRecord::Clear()
{

    m_bObjectFlags     = 0;
    m_bCompressAlg     = 0;
        m_bValue               = 0;
        m_bLabel               = 0;
    m_bID              = 0;
    m_bCredentialID    = 0;
        m_bSubject             = 0;
        m_bIssuer              = 0;
    m_bSerialNumber    = 0;

    m_fCached = false;

}

void CCertificateInfoRecord::Read()
{
    CTransactionWrap wrap(m_rcard);

    if(m_fCached) return;

    BYTE bBuffer[CertInfoRecordSize];

    m_rcard.ObjectInfoFile(m_Access).ReadObject(m_bHandle, bBuffer);

    m_bObjectFlags  = bBuffer[CertObjectFlagsLoc];
    m_bCompressAlg  = bBuffer[CertCompressAlgLoc];
        m_bValue            = bBuffer[CertValueLoc];
        m_bLabel            = bBuffer[CertLabelLoc];
        m_bID               = bBuffer[CertIDLoc];
    m_bCredentialID = bBuffer[CertCredentialIDLoc];
        m_bSubject          = bBuffer[CertSubjectLoc];
        m_bIssuer           = bBuffer[CertIssuerLoc];
    m_bSerialNumber = bBuffer[CertSerialNumberLoc];

    m_fCached = true;

}

void CCertificateInfoRecord::Write()
{
    CTransactionWrap wrap(m_rcard);

    BYTE bBuffer[CertInfoRecordSize];

    memset(bBuffer, 0, CertInfoRecordSize);

    bBuffer[CertObjectFlagsLoc]  = m_bObjectFlags;
    bBuffer[CertCompressAlgLoc]  = m_bCompressAlg;
    bBuffer[CertValueLoc]        = m_bValue;
    bBuffer[CertLabelLoc]        = m_bLabel;
    bBuffer[CertIDLoc]           = m_bID;
    bBuffer[CertCredentialIDLoc] = m_bCredentialID;
    bBuffer[CertSubjectLoc]      = m_bSubject;
    bBuffer[CertIssuerLoc]       = m_bIssuer;
    bBuffer[CertSerialNumberLoc] = m_bSerialNumber;

    m_rcard.ObjectInfoFile(m_Access).WriteObject(m_bHandle, bBuffer);

    m_fCached = true;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\cciprikey.h ===
// cciPriKey.h: interface for the CPrivateKey class.
//
// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
//////////////////////////////////////////////////////////////////////

#if !defined(SLBCCI_PRIKEY_H)
#define SLBCCI_PRIKEY_H

#include <slbRCPtr.h>

#include "cciCard.h"
#include "APriKey.h"

namespace cci
{

class CPrivateKey
    : public slbRefCnt::RCPtr<CAbstractPrivateKey,
                              slbRefCnt::DeepComparator<CAbstractPrivateKey> >
{

public:
                                                  // Types
                                                  // C'tors/D'tors
    CPrivateKey(ValueType *p = 0);

    CPrivateKey(CCard const &rhcard,
                ObjectAccess oa = oaPrivateAccess);

                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates

protected:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables

private:
                                                  // Types
    typedef slbRefCnt::RCPtr<ValueType,
                             slbRefCnt::DeepComparator<ValueType> > SuperClass;

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables

};

} // namespace cci

#endif // !defined(SLBCCI_PRIKEY_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\cciexc.h ===
// cciExc.h -- CCI Exception class declaration

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#if !defined(CCI_EXC_H)
#define CCI_EXC_H

#include <scuExc.h>

namespace cci
{

enum CauseCode
{
    ccBadKeySpec,
    ccBadAccessSpec,
    ccBadObjectType,
    ccBadLength,
    ccBadPinLength,
    ccFormatNotSupported,
    ccFormatError,
    ccInvalidParameter,
    ccKeyNotFound,
    ccNoCertificate,
    ccNotImplemented,
    ccNotPersonalized,
    ccOutOfPrivateKeySlots,
    ccOutOfSymbolTableSpace,
    ccOutOfSymbolTableEntries,
    ccStringTooLong,
    ccSymbolNotFound,
    ccSymbolDataCorrupted,
    ccValueNotCached,
};

typedef scu::ExcTemplate<scu::Exception::fcCCI, CauseCode> Exception;

///////////////////////////    HELPERS    /////////////////////////////////
char const *
Description(Exception const &rExc);

} // namespace cci

inline char const *
cci::Exception::Description() const
{
    return cci::Description(*this);
}

#endif // CCI_EXC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\certificateinforecord.h ===
// CertificateInfoRecord.h: interface for the CCertificateInfoRecord class.
//
// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
//////////////////////////////////////////////////////////////////////

#if !defined(SLBCCI_CERTIFICATEINFORECORD_H)
#define SLBCCI_CERTIFICATEINFORECORD_H

#include "slbCci.h"
#include "ObjectInfoRecord.h"

namespace cci
{

class CV2Card;

class CCertificateInfoRecord
    : public CObjectInfoRecord
{
public:

    CCertificateInfoRecord(CV2Card const &rcard,
                           SymbolID bHandle,
                           ObjectAccess access);

    virtual ~CCertificateInfoRecord() {};

    void Clear();
    void Read();
    void Write();

    BYTE *ObjectFlags() {return &m_bObjectFlags;};

    BYTE m_bCompressAlg;
    SymbolID m_bValue;
    SymbolID m_bLabel;
    SymbolID m_bID;
    SymbolID m_bCredentialID;
    SymbolID m_bSubject;
    SymbolID m_bIssuer;
    SymbolID m_bSerialNumber;

private:
    BYTE m_bObjectFlags;

};

const unsigned short CertObjectFlagsLoc  = 0;
const unsigned short CertCompressAlgLoc  = 1;
const unsigned short CertValueLoc        = 3;
const unsigned short CertLabelLoc        = 4;
const unsigned short CertIDLoc           = 5;
const unsigned short CertCredentialIDLoc = 6;
const unsigned short CertSubjectLoc      = 7;
const unsigned short CertIssuerLoc       = 8;
const unsigned short CertSerialNumberLoc = 9;
const unsigned short CertInfoRecordSize  = 10;

const BYTE CertModifiableFlag = 0;


}

#endif // !defined(SLBCCI_CERTIFICATEINFORECORD_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\container.cpp ===
// Conatiner.cpp -- CContainer class definition

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
#include "NoWarning.h"

#include "CryptFctry.h"
#include "cciCont.h"

using namespace std;
using namespace cci;

/////////////////////////// LOCAL/HELPER  /////////////////////////////////

///////////////////////////    PUBLIC     /////////////////////////////////

                                                  // Types
                                                  // C'tors/D'tors
CContainer::CContainer(ValueType *p)
    : SuperClass(p)
{}

CContainer::CContainer(CCard const &rhcard)
    : SuperClass(rhcard->MakeContainer())
{}


                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables

///////////////////////////   PROTECTED   /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables


///////////////////////////    PRIVATE    /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\containerinforecord.h ===
// ContainerInfoRecord.h: interface for the CContainerInfoRecord class.
//
// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
//////////////////////////////////////////////////////////////////////

#if !defined(__CONTAINERINFORECORD_H)
#define __CONTAINERINFORECORD_H

#include <string>
#include <windows.h>

#include "slbCci.h"
#include "slbArch.h"
#include "ObjectInfoRecord.h"

namespace cci {

class CV2Card;

typedef struct _kpItems {
    ObjectAccess bPubKeyAccess;
    SymbolID bPubKeyHandle;
    ObjectAccess bPriKeyAccess;
    SymbolID bPriKeyHandle;
    ObjectAccess bCertificateAccess;
    SymbolID bCertificateHandle;
} KPItems;

class CContainerInfoRecord
    : public CObjectInfoRecord
{
public:
    CContainerInfoRecord(CV2Card const &rv2card,
                         SymbolID bHandle);
    virtual ~CContainerInfoRecord() {};

    void Clear();
    void Read();
    void Write();

    BYTE *ObjectFlags() {return 0;};

    SymbolID m_bName;
    SymbolID m_bID;

    KPItems m_kpExchangeKey;
    KPItems m_kpSignatureKey;

    KPItems GetKeyPair(KeySpec ks);
    void SetKeyPair(KeySpec ks, KPItems kp);


private:

    static BYTE AccessToStorageRepr(ObjectAccess access);
    static ObjectAccess AccessFromStorageRepr(BYTE access);
    static KPItems KeyPairFromStorageRepr(BYTE *bBuffer);
    static void KeyPairToStorageRepr(KPItems const &kp, BYTE *bBuffer);

};

const unsigned short ContNameLoc        = 0;
const unsigned short ContIDLoc          = 1;
const unsigned short ContExchKeyPairLoc = 4;
const unsigned short ContSignKeyPairLoc = 10;
const unsigned short ContInfoRecordSize = 16;

const BYTE ContPublicAccess  = 1;
const BYTE ContPrivateAccess = 2;

}

#endif // !defined(__CONTAINERINFORECORD_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\containerinforecord.cpp ===
// ContainerInfoRecord.cpp: implementation of the CContainerInfoRecord class.
//
// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
//////////////////////////////////////////////////////////////////////
#include "NoWarning.h"

#include "slbCci.h"
#include "V2Card.h"
#include "TransactionWrap.h"
#include "ContainerInfoRecord.h"

using namespace cci;
using namespace iop;
//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////



CContainerInfoRecord::CContainerInfoRecord(CV2Card const &rv2card,
                                           SymbolID bHandle)
    : CObjectInfoRecord(rv2card, bHandle, oaPublicAccess)
{
    Clear();
}

KPItems CContainerInfoRecord::GetKeyPair(KeySpec ks)
{
    Read();

    KPItems kpitems;

    switch (ks)
    {
    case ksExchange:
        kpitems = m_kpExchangeKey;
        break;

    case ksSignature:
        kpitems = m_kpSignatureKey;
        break;

    default:
        throw Exception(ccBadKeySpec);
        break;
    }

    return kpitems;
}

void CContainerInfoRecord::SetKeyPair(KeySpec ks, KPItems kp)
{
	if (ks == ksExchange)
		m_kpExchangeKey = kp;
	else if (ks == ksSignature)
		m_kpSignatureKey = kp;
	else
		throw Exception(ccBadKeySpec);
	
	Write();
}

void CContainerInfoRecord::Clear()
{

	m_bName		= 0;
	m_bID		= 0;

	KPItems kp;

	kp.bPubKeyHandle      = 0;
	kp.bPubKeyAccess      = oaNoAccess;
	kp.bPriKeyHandle      = 0;
    kp.bPriKeyAccess      = oaNoAccess;
	kp.bCertificateHandle = 0;
	kp.bCertificateAccess = oaNoAccess;

    m_kpExchangeKey     = kp;
	m_kpSignatureKey    = kp;

    m_fCached = false;

}


void CContainerInfoRecord::Read()
{
	CTransactionWrap wrap(m_rcard);

    if(m_fCached) return;

	BYTE bBuffer[ContInfoRecordSize];

    m_rcard.ObjectInfoFile(oaPublicAccess).ReadObject(m_bHandle, bBuffer);

	m_kpExchangeKey  = KeyPairFromStorageRepr(&bBuffer[ContExchKeyPairLoc]);
    m_kpSignatureKey = KeyPairFromStorageRepr(&bBuffer[ContSignKeyPairLoc]);
		
	m_bName		= bBuffer[ContNameLoc];
	m_bID		= bBuffer[ContIDLoc];

    m_fCached = true;

}

void CContainerInfoRecord::Write()
{
	CTransactionWrap wrap(m_rcard);

	BYTE bBuffer[ContInfoRecordSize];

	memset(bBuffer, 0, ContInfoRecordSize);

    KeyPairToStorageRepr(m_kpExchangeKey, &bBuffer[ContExchKeyPairLoc]);
    KeyPairToStorageRepr(m_kpSignatureKey, &bBuffer[ContSignKeyPairLoc]);

	bBuffer[ContNameLoc]  = m_bName;
	bBuffer[ContIDLoc]    = m_bID;

    m_rcard.ObjectInfoFile(oaPublicAccess).WriteObject(m_bHandle, bBuffer);

    m_fCached = true;

}

BYTE CContainerInfoRecord::AccessToStorageRepr(ObjectAccess access)
{
    BYTE b;
    
    switch(access)
    {

    case oaNoAccess:
        b = 0;
        break;
    case oaPublicAccess:
        b = ContPublicAccess;
        break;

    case oaPrivateAccess:
        b = ContPrivateAccess;
        break;

    default:
        throw Exception(ccBadAccessSpec);
        break;
    }

    return b;
}

ObjectAccess CContainerInfoRecord::AccessFromStorageRepr(BYTE access)
{
    ObjectAccess oa;
    
    switch(access)
    {

    case 0:
        oa = oaNoAccess;
        break;

    case ContPublicAccess:
        oa = oaPublicAccess;
        break;
        
    case ContPrivateAccess:
        oa = oaPrivateAccess;
        break;
        
    default:
        throw Exception(ccBadAccessSpec);
        break;
    }

    return oa;
}

KPItems CContainerInfoRecord::KeyPairFromStorageRepr(BYTE *bBuffer)
{
	KPItems kp;

	kp.bPubKeyHandle      = bBuffer[0];
	kp.bPubKeyAccess      = AccessFromStorageRepr(bBuffer[1]);

    kp.bPriKeyHandle      = bBuffer[2];
    kp.bPriKeyAccess      = AccessFromStorageRepr(bBuffer[3]);

	kp.bCertificateHandle = bBuffer[4];
	kp.bCertificateAccess = AccessFromStorageRepr(bBuffer[5]);

    return kp;
}

void CContainerInfoRecord::KeyPairToStorageRepr(KPItems const &kp, BYTE *bBuffer)
{

	bBuffer[0] = kp.bPubKeyHandle;
	bBuffer[1] = AccessToStorageRepr(kp.bPubKeyAccess);

	bBuffer[2] = kp.bPriKeyHandle;
    bBuffer[3] = AccessToStorageRepr(kp.bPriKeyAccess);

	bBuffer[4] = kp.bCertificateHandle;
	bBuffer[5] = AccessToStorageRepr(kp.bCertificateAccess);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\dataobject.cpp ===
// DataObject.cpp: implementation of the CDataObject class.
//
// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
//////////////////////////////////////////////////////////////////////
#include "NoWarning.h"

#include "CryptFctry.h"
#include "cciDataObj.h"


using namespace cci;

/////////////////////////// LOCAL/HELPER  /////////////////////////////////

///////////////////////////    PUBLIC     /////////////////////////////////

                                                  // Types
                                                  // C'tors/D'tors
CDataObject::CDataObject(ValueType *p)
    : SuperClass(p)
{}

CDataObject::CDataObject(CCard const &racard,
                         ObjectAccess oa)
    : SuperClass(racard->MakeDataObject(oa))
{}

                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables

///////////////////////////   PROTECTED   /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables


///////////////////////////    PRIVATE    /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\cryptfctry.cpp ===
// CryptFctry.cpp -- implementation of the CCryptFactory class

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
//////////////////////////////////////////////////////////////////////
#include "NoWarning.h"

#include "CryptFctry.h"

using namespace cci;

/////////////////////////// LOCAL/HELPER  /////////////////////////////////

///////////////////////////    PUBLIC     /////////////////////////////////

                                                  // Types
                                                  // C'tors/D'tors
CCryptFactory::~CCryptFactory() throw()
{}

                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables

///////////////////////////   PROTECTED   /////////////////////////////////

                                                  // C'tors/D'tors
CCryptFactory::CCryptFactory()
{}

                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables


///////////////////////////    PRIVATE    /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\cryptfctry.h ===
// CryptFctry.h -- implementation of the CryptFactory template

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#if !defined(SLBCCI_CRYPTFCTRY_H)
#define SLBCCI_CRYPTFCTRY_H

#include "slbCci.h"

namespace cci
{

class CContainer;

class CAbstractCertificate;
class CAbstractContainer;
class CAbstractDataObject;
class CAbstractKeyPair;
class CAbstractPrivateKey;
class CAbstractPublicKey;

// Factory interface definition to make the various CCI cryptographic objects
class CCryptFactory
{
public:
                                                  // Types
                                                  // C'tors/D'tors
    virtual
    ~CCryptFactory() throw() = 0;

                                                  // Operators
                                                  // Operations
    virtual CAbstractCertificate *
    MakeCertificate(ObjectAccess oa) const = 0;

    virtual CAbstractContainer *
    MakeContainer() const = 0;

    virtual CAbstractDataObject *
    MakeDataObject(ObjectAccess oa) const = 0;

    virtual CAbstractKeyPair *
    MakeKeyPair(CContainer const &rhcont,
                KeySpec ks) const = 0;

    virtual CAbstractPrivateKey *
    MakePrivateKey(ObjectAccess oa) const = 0;

    virtual CAbstractPublicKey *
    MakePublicKey(ObjectAccess oa) const = 0;

                                                  // Access
                                                  // Predicates

protected:
                                                  // Types
                                                  // C'tors/D'tors
    explicit
    CCryptFactory();

                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables

private:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables

};

} // namespace cci

#endif // SLBCCI_CRYPTFCTRY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\cryptobj.cpp ===
// CryptObj.cpp -- implementation of the CCryptObject class

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#include "CryptObj.h"

using namespace cci;

/////////////////////////// LOCAL/HELPER  /////////////////////////////////

///////////////////////////    PUBLIC     /////////////////////////////////

                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
CCard
CCryptObject::Card()
{
    return m_hcard;
}

                                                  // Predicates
                                                  // Static Variables

///////////////////////////   PROTECTED   /////////////////////////////////

                                                  // C'tors/D'tors
CCryptObject::CCryptObject(CAbstractCard const &racard)
    : m_hcard(CCard(&const_cast<CAbstractCard &>(racard)))
{}

CCryptObject::~CCryptObject()
{}


                                                  // Operators
bool
CCryptObject::operator==(CCryptObject const &rhs) const
{
    return m_hcard == rhs.m_hcard;
}

bool
CCryptObject::operator!=(CCryptObject const &rhs) const
{
    return !(*this == rhs);
}

                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables


///////////////////////////    PRIVATE    /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\cryptobj.h ===
// CryptObj.h -- interface for the CCryptObject class

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

// Note:  This file should only be included by the CCI, not directly
// by the client.

#if !defined(SLBCCI_CRYPTOBJ_H)
#define SLBCCI_CRYPTOBJ_H

#include "cciCard.h"

namespace cci
{

class CCryptObject
{
public:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
    CCard
    Card();

                                                  // Predicates

protected:
                                                  // Types
                                                  // C'tors/D'tors
    explicit
    CCryptObject(CAbstractCard const &racard);

    virtual
    ~CCryptObject();

                                                  // Operators
    bool
    operator==(CCryptObject const &rhs) const;
        // TO DO: this should be superceded by implementing singletons

    bool
    operator!=(CCryptObject const &rhs) const;
        // TO DO: this should be superceded by implementing singletons

                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables
    CCard const m_hcard;

private:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables
};

} // namespace cci

#endif // SLBCCI_CRYPTOBJ_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\dataobjectinforecord.cpp ===
// DataObjectInfoRecord.cpp - Implementation of CDataObjectInfoRecord class
//
// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
//////////////////////////////////////////////////////////////////////
#include "NoWarning.h"

#include "DataObjectInfoRecord.h"
#include "TransactionWrap.h"

using namespace cci;

CDataObjectInfoRecord::CDataObjectInfoRecord(CV2Card const &rv2card,
                                             SymbolID bHandle,
                                             ObjectAccess access)
    : CObjectInfoRecord(rv2card, bHandle, access)
{
    Clear();
}

void CDataObjectInfoRecord::Clear()
{
    CTransactionWrap wrap(m_rcard);

    m_bObjectFlags  = 0;
    m_bCompressAlg  = 0;
        m_bValue            = 0;
        m_bLabel            = 0;
    m_bApplication  = 0;

    m_fCached = false;

}

void CDataObjectInfoRecord::Read()
{
    CTransactionWrap wrap(m_rcard);

    if(m_fCached) return;

    BYTE bBuffer[DataInfoRecordSize];

    m_rcard.ObjectInfoFile(m_Access).ReadObject(m_bHandle, bBuffer);

    m_bObjectFlags  = bBuffer[DataObjectFlagsLoc];
    m_bCompressAlg  = bBuffer[DataCompressAlgLoc];
        m_bLabel            = bBuffer[DataLabelLoc];
    m_bApplication  = bBuffer[DataApplicationLoc];
        m_bValue            = bBuffer[DataValueLoc];

    m_fCached = true;

}

void CDataObjectInfoRecord::Write()
{
    CTransactionWrap wrap(m_rcard);

    BYTE bBuffer[DataInfoRecordSize];

    memset(bBuffer, 0, DataInfoRecordSize);

    bBuffer[DataObjectFlagsLoc] = m_bObjectFlags;
    bBuffer[DataCompressAlgLoc] = m_bCompressAlg;
    bBuffer[DataLabelLoc]       = m_bLabel;
    bBuffer[DataApplicationLoc] = m_bApplication;
    bBuffer[DataValueLoc]       = m_bValue;

    m_rcard.ObjectInfoFile(m_Access).WriteObject(m_bHandle, bBuffer);

    m_fCached = true;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\keypair.cpp ===
// KeyPair.cpp -- CKeyPair class definition

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
//////////////////////////////////////////////////////////////////////
#include "NoWarning.h"

#include "CryptFctry.h"
#include "cciKeyPair.h"

using namespace cci;

/////////////////////////// LOCAL/HELPER  /////////////////////////////////

///////////////////////////    PUBLIC     /////////////////////////////////

                                                  // Types
                                                  // C'tors/D'tors
CKeyPair::CKeyPair(ValueType *p)
    : SuperClass(p)
{}

CKeyPair::CKeyPair(CCard const &rhcard,
                   CContainer const &rhcont,
                   KeySpec ks)
    : SuperClass(rhcard->MakeKeyPair(rhcont, ks))
{}


                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables

///////////////////////////   PROTECTED   /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables


///////////////////////////    PRIVATE    /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\exception.cpp ===
// Exception.cpp -- Exception class definition

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#include <scuExcHelp.h>
#include "cciExc.h"

/////////////////////////// LOCAL/HELPER  /////////////////////////////////
namespace
{
    using namespace cci;

    scu::CauseCodeDescriptionTable<CauseCode> ccdt[] =
    {
        {
            ccBadKeySpec,
            TEXT("Unsupported key spec.")
        },
        {
            ccBadAccessSpec,
            TEXT("Bad access spec.")
        },
        {
            ccBadObjectType,
            TEXT("Bad object type.")
        },
        {
            ccBadLength,
            TEXT("Bad length.")
        },
        {
            ccBadPinLength,
            TEXT("Bad PIN length.")
        },
        {
            ccFormatNotSupported,
            TEXT("The card format is not supported.")
        },
        {
            ccFormatError,
            TEXT("Error encountered in the card format.")
        },
        {
            ccInvalidParameter,
            TEXT("Invalid parameter.")
        },
        {
            ccNoCertificate,
            TEXT("No certificate found.")
        },
        {
            ccNotImplemented,
            TEXT("This function is not implemented for this card.")
        },
        {
            ccNotPersonalized,
            TEXT("Card is not personalized.")
        },
        {
            ccOutOfPrivateKeySlots,
            TEXT("No more private key slots available.")
        },
        {
            ccOutOfSymbolTableSpace,
            TEXT("No space for additional symbols.")
        },
        {
            ccOutOfSymbolTableEntries,
            TEXT("No more symbol slots available.")
        },
        {
            ccStringTooLong,
            TEXT("Attempt to store a string that was too long.")
        },
        {
            ccSymbolNotFound,
            TEXT("Symbol not found.")
        },
        {
            ccKeyNotFound,
            TEXT("Key not found.")
        },
        {
            ccSymbolDataCorrupted,
            TEXT("Symbol data corrupted.")
        },
        {
            ccValueNotCached,
            TEXT("The value has not been cached.  Cannot retrieve the "
                 "value.")
        },

    };
}

char const *
cci::Description(cci::Exception const &rExc)
{
    return scu::FindDescription(rExc.Cause(), ccdt,
                                sizeof ccdt / sizeof *ccdt);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\nowarning.h ===
// NoWarning.h - Turn off compiler warnings that may be safely
// ignored.

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

// NOTE: This file should only be included by CCI source files, not by
// any headers included by clients of the CCI--thus the reason for not
// prefixing the name of this file with "cci".  Otherwise forced
// inclusion of this header file into clients by the CCI imposes a
// compile-time policy on those clients which may be
// inappropriate/undesirable.

#if !defined(CCI_NOWARNING_H)
#define CCI_NOWARNING_H

//  Non-standard extension used: 'extern' before template explicit
//  instantiation
#pragma warning(disable : 4231)

//  Identifier truncated to 255 in debugger/browser info
#pragma warning(disable : 4786)

#endif // CCI_NOWARNING_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\objectinfofile.cpp ===
// ObjectInfoFile.cpp: implementation of the CObjectInfoFile class.
//
// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
//////////////////////////////////////////////////////////////////////

#include "cciCard.h"

#include "SymbolTable.h"
#include "ObjectInfoFile.h"

using std::string;
using namespace cci;
using namespace iop;




CObjectInfoFile::CObjectInfoFile(CSmartCard &rSmartCard,
                                 string const &Path,
                                 ObjectAccess oa)
    : m_oa(oa),
      m_Path(Path),
      m_SymbolTable(rSmartCard, Path, ObjMasterBlkSize),
      m_rSmartCard(rSmartCard)
{
}

void CObjectInfoFile::Reset()
{
	BYTE bMasterBlk[ObjMasterBlkSize];
    memset(bMasterBlk,0,ObjMasterBlkSize);

    m_rSmartCard.Select(m_Path.c_str());

    m_rSmartCard.WriteBinary(0, ObjMasterBlkSize, bMasterBlk);

    m_bDefaultContainer = 0;
    m_bFirstContainer   = 0;
    m_bFirstCertificate = 0;
    m_bFirstPublicKey   = 0;
    m_bFirstPrivateKey  = 0;
    m_bFirstDataObject  = 0;

    m_SymbolTable.Reset();

}

void CObjectInfoFile::UpdateCache()
{
	BYTE bMasterBlk[ObjMasterBlkSize];

    m_rSmartCard.Select(m_Path.c_str());

    m_rSmartCard.ReadBinary(0, ObjMasterBlkSize, bMasterBlk);

    m_bDefaultContainer = bMasterBlk[ObjDefaultContainerLoc];
    m_bFirstContainer   = bMasterBlk[ObjFirstContainerLoc];
    m_bFirstCertificate = bMasterBlk[ObjFirstCertificateLoc];
    m_bFirstPublicKey   = bMasterBlk[ObjFirstPublicKeyLoc];
    m_bFirstPrivateKey  = bMasterBlk[ObjFirstPrivateKeyLoc];
    m_bFirstDataObject  = bMasterBlk[ObjFirstDataObjectLoc];

}

ObjectAccess
CObjectInfoFile::AccessType() const
{
    return m_oa;
}

void CObjectInfoFile::DefaultContainer(SymbolID bHandle)
{

    m_rSmartCard.Select(m_Path.c_str());
    m_rSmartCard.WriteBinary(ObjDefaultContainerLoc, 1, &bHandle);
    m_bDefaultContainer = bHandle;

}

SymbolID CObjectInfoFile::AddSymbol(string aString)
{
    return m_SymbolTable.Add(aString);
}

string CObjectInfoFile::FindSymbol(SymbolID sid)
{
    return m_SymbolTable.Find(sid);
}

void CObjectInfoFile::RemoveSymbol(SymbolID sid)
{
    m_SymbolTable.Remove(sid);
}

SymbolID CObjectInfoFile::FirstObject(ObjectType type) const
{
    SymbolID sid;
    
    switch(type)
    {
    case otContainerObject:
        sid = m_bFirstContainer;
        break;

    case otCertificateObject:
        sid = m_bFirstCertificate;
        break;

    case otPublicKeyObject:
        sid = m_bFirstPublicKey;
        break;
        
    case otPrivateKeyObject:
        sid = m_bFirstPrivateKey;
        break;
        
    case otDataObjectObject:
        sid = m_bFirstDataObject;
        break;
        
    default:
        throw cci::Exception(ccBadObjectType);
        break;
        
    }

    return sid;
}

void CObjectInfoFile::FirstObject(ObjectType type, SymbolID bHandle)
{


    unsigned short sLoc;
    SymbolID *pbCachedValue;

    switch(type) {
    case otContainerObject:
        sLoc =  ObjFirstContainerLoc;
        pbCachedValue = &m_bFirstContainer;
        break;

    case otCertificateObject:
        sLoc =  ObjFirstCertificateLoc;
        pbCachedValue = &m_bFirstCertificate;
        break;

    case otPublicKeyObject:
        sLoc = ObjFirstPublicKeyLoc;
        pbCachedValue = &m_bFirstPublicKey;
        break;

    case otPrivateKeyObject:
        sLoc =  ObjFirstPrivateKeyLoc;
        pbCachedValue = &m_bFirstPrivateKey;
        break;

    case otDataObjectObject:
        sLoc = ObjFirstDataObjectLoc;
        pbCachedValue = &m_bFirstDataObject;
        break;

    default:
        throw cci::Exception(ccBadObjectType);

    }

    m_rSmartCard.Select(m_Path.c_str());
    m_rSmartCard.WriteBinary(sLoc, 1, &bHandle);
    *pbCachedValue = bHandle;   // Update cache after successful write

}

SymbolID CObjectInfoFile::NextObject(SymbolID bHandle)
{

    string ObjInfoRecord(m_SymbolTable.Find(bHandle));
    if (!ObjInfoRecord.size())
        throw cci::Exception(ccFormatError);
    return static_cast<SymbolID>(ObjInfoRecord[0]);

}

void CObjectInfoFile::NextObject(SymbolID bHandle, SymbolID bHandleNext)
{

    string ObjInfoRecord(m_SymbolTable.Find(bHandle));
    if (!ObjInfoRecord.size())
        throw cci::Exception(ccFormatError);
    ObjInfoRecord[0] = bHandleNext;
    m_SymbolTable.Replace(bHandle,ObjInfoRecord);

}

SymbolID CObjectInfoFile::AddObject(ObjectType type, unsigned short size)
{

    string strTemp;
    strTemp.resize(size+1);

    SymbolID bHandle;
    bHandle = m_SymbolTable.Add(strTemp, smExclusive);

    // Add to end of list
        
    SymbolID bLast = FirstObject(type);

    if(!bLast)  // No objects in list, add to head of list
    {
        FirstObject(type,bHandle);
    }
    else
    {
        // Search for the last object

        SymbolID bLastNext = NextObject(bLast);

        while(bLastNext) {
            bLast = bLastNext;
            bLastNext = NextObject(bLast);
        }

        NextObject(bLast,bHandle);
    }

    return bHandle;

}

void CObjectInfoFile::RemoveObject(ObjectType type, SymbolID bHandle)
{

    if (FirstObject(type) == bHandle)  // Remove from head of list
    {
        FirstObject(type,NextObject(bHandle));
    }
    else
    {
        // Remove from middle/end of list, search for the previous object

        SymbolID bPrevNext, bPrevious = FirstObject(type);
        while(bPrevious)
        {
            bPrevNext = NextObject(bPrevious);
            if (bHandle == bPrevNext)
                break;
            bPrevious = bPrevNext;
        }
        if (!bPrevious)
            throw cci::Exception(ccFormatError); // Object not linked
                                                 // through this list

        NextObject(bPrevious,NextObject(bHandle));
    }

    m_SymbolTable.Remove(bHandle);

}

void CObjectInfoFile::ReadObject(SymbolID bHandle, BYTE* bData)
{

    string ObjInfoRecord(m_SymbolTable.Find(bHandle));
    string::size_type size = ObjInfoRecord.size();
    if (!size)
        throw cci::Exception(ccFormatError);
    ObjInfoRecord.copy(reinterpret_cast<char*>(bData) , size - 1,
                       1);  // Skip the leading byte.

}

void CObjectInfoFile::WriteObject(SymbolID bHandle, BYTE* bData)
{

    string ObjInfoRecord(m_SymbolTable.Find(bHandle));
    string::size_type size = ObjInfoRecord.size();
    if (!size)
        throw cci::Exception(ccFormatError);
    ObjInfoRecord.resize(1);
    ObjInfoRecord += string(reinterpret_cast<char *>(bData), size - 1);

    m_SymbolTable.Replace(bHandle,ObjInfoRecord);
    
}

unsigned short CObjectInfoFile::TableSize()
{
    return m_SymbolTable.TableSize();
}

unsigned short CObjectInfoFile::FreeSpace()
{
    return m_SymbolTable.FreeSpace();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\objectinfofile.h ===
// ObjectInfoFile.h: interface for the CObjectInfoFile class.
//
// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
//////////////////////////////////////////////////////////////////////

#if !defined(CCI_OBJECTINFOFILE_H)
#define CCI_OBJECTINFOFILE_H

#include "slbCci.h"

namespace cci {

class CObjectInfoFile
{
public:
    CObjectInfoFile(iop::CSmartCard &rSmartCard,
                    std::string const &rPath,
                    ObjectAccess oa);

    virtual ~CObjectInfoFile() {};

    void Reset();
    void UpdateCache();

    ObjectAccess
    AccessType() const;

    CSymbolTable &SymbolTable() {return m_SymbolTable; };

    SymbolID AddSymbol(std::string aString);
    std::string FindSymbol(SymbolID sid);
    void RemoveSymbol(SymbolID sid);

    SymbolID DefaultContainer() const { return m_bDefaultContainer; };
    void DefaultContainer(SymbolID bHandle);

    SymbolID FirstObject(ObjectType type) const;
    void FirstObject(ObjectType type, SymbolID bHandle);

    SymbolID NextObject(SymbolID bHandle);
    void NextObject(SymbolID bHandle, SymbolID bHandleNext);

    SymbolID AddObject(ObjectType type, unsigned short size);
    void RemoveObject(ObjectType type, SymbolID bHandle);
    void ReadObject(SymbolID bHandle, BYTE* bData);
    void WriteObject(SymbolID bHandle, BYTE* bData);

    unsigned short TableSize();
    unsigned short FreeSpace();


private:
    ObjectAccess m_oa;
    std::string m_Path;
    CSymbolTable m_SymbolTable;
    iop::CSmartCard &m_rSmartCard;

    SymbolID m_bDefaultContainer;
    SymbolID m_bFirstContainer;
    SymbolID m_bFirstCertificate;
    SymbolID m_bFirstPublicKey;
    SymbolID m_bFirstPrivateKey;
    SymbolID m_bFirstDataObject;

};

const unsigned short ObjDefaultContainerLoc = 0;    // Location of default container handle
const unsigned short ObjFirstContainerLoc   = 1;    // Location of first container handle
const unsigned short ObjFirstCertificateLoc = 2;    // Location of first certificate handle
const unsigned short ObjFirstPublicKeyLoc   = 3;    // Location of first public key handle
const unsigned short ObjFirstPrivateKeyLoc  = 4;    // Location of first private key handle
const unsigned short ObjFirstDataObjectLoc  = 5;    // Location of first data object handle
const unsigned short ObjMasterBlkSize = 10;         // Size of master block


}

#endif // !defined(CCI_OBJECTINFOFILE_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\dataobjectinforecord.h ===
// DataObjectInfoRecord.h: interface for the CDataObjectInfoRecord class.
//
// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
//////////////////////////////////////////////////////////////////////

#if !defined(CCI_DATAOBJECTINFORECORD_H)
#define CCI_DATAOBJECTINFORECORD_H

#include "slbCci.h"
#include "V2Card.h"
#include "ObjectInfoRecord.h"


namespace cci {

class CDataObjectInfoRecord
    : public CObjectInfoRecord

{
public:
    CDataObjectInfoRecord(CV2Card const &rv2card,
                          SymbolID bHandle,
                          ObjectAccess access);
    virtual ~CDataObjectInfoRecord() {};

    void Clear();
    void Read();
    void Write();

    BYTE *ObjectFlags() {return &m_bObjectFlags;};

    BYTE m_bCompressAlg;
    SymbolID m_bValue;
    SymbolID m_bLabel;
    SymbolID m_bApplication;

private:
    BYTE m_bObjectFlags;

};

const unsigned short DataObjectFlagsLoc  = 0;
const unsigned short DataCompressAlgLoc  = 1;
const unsigned short DataLabelLoc        = 2;
const unsigned short DataApplicationLoc  = 3;
const unsigned short DataValueLoc        = 4;
const unsigned short DataInfoRecordSize  = 5;

const BYTE DataModifiableFlag = 0;

}

#endif // !defined(CCI_DATAOBJECTINFORECORD_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\kpcont.h ===
// KPCont.h: interface declarations for CContainer and CKeyPair.
//
// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
//////////////////////////////////////////////////////////////////////

// Note:  This file should only be included by the CCI, not directly
// by the client.

// CContainer and CKeyPair are declared here to break the circular
// dependency between their abstract versions.
#if !defined(SLBCCI_KPCONT_H)
#define SLBCCI_KPCONT_H

namespace cci
{

class CAbstractContainer;
class CAbstractKeyPair;

class CContainer
    : public slbRefCnt::RCPtr<CAbstractContainer,
                              slbRefCnt::DeepComparator<CAbstractContainer> >
{

public:
                                                  // Types
                                                  // C'tors/D'tors
    CContainer(ValueType *p = 0);

    explicit
    CContainer(CCard const &rhcard);

                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates

protected:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables

private:
                                                  // Types
    typedef slbRefCnt::RCPtr<ValueType,
                             slbRefCnt::DeepComparator<ValueType> > SuperClass;

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables

};


class CKeyPair
    : public slbRefCnt::RCPtr<CAbstractKeyPair,
                              slbRefCnt::DeepComparator<CAbstractKeyPair> >
{

public:
                                                  // Types
                                                  // C'tors/D'tors
    CKeyPair(ValueType *p = 0);

    CKeyPair(CCard const &rhcard,
             CContainer const &rhcont,
             KeySpec kp);

                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates

protected:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables

private:
                                                  // Types
    typedef slbRefCnt::RCPtr<ValueType,
                             slbRefCnt::DeepComparator<ValueType> > SuperClass;

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables

};


} // namespace cci

#endif // !defined(SLBCCI_KPCONT_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\methodhelp.h ===
// MethodHelp.h -- Helpers for class methods

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#if !defined(SLBCCI_METHODHELP_H)
#define SLBCCI_METHODHELP_H

// Note:  This file should only be included by the CCI, not directly
// by the client.

namespace cci
{
    // Similar to std:unary_function, AccessorMethod and ModifierMethod
    // help build templates dealing with method accessors and modifiers.
    template<class T, class C>
    struct AccessorMethod
    {
        typedef void ArgumentType;
        typedef T ResultType;
        typedef ResultType (C::*AccessorPtr)(ArgumentType) const;
    };

    template<class T, class C>
    struct ModifierMethod
    {
        typedef T const &ArgumentType;
        typedef void ResultType;
        typedef ResultType (C::*ModifierPtr)(ArgumentType);
    };

    // MemberAccessType and MemberModifierType are conceptually
    // equivalent to the C++ member function functors series
    // (e.g. std::mem_ref_fun_t) except they deal with invoking the
    // requested routine without a return (MemberModifierType).
    // MemberAccessType is like std::mem_ref_fun_t but included here
    // to contract MemberModifierType.
    template<class T, class C>
    class MemberAccessorType
        : public AccessorMethod<T, C>
    {
    public:
        explicit
        MemberAccessorType(AccessorPtr ap)
            : m_ap(ap)
        {}

        ResultType
        operator()(C &rObject) const
        {
            return (rObject.*m_ap)();
        }

    private:
        AccessorMethod<T, C>::AccessorPtr m_ap;
    };

    template<class T, class C>
    class MemberModifierType
        : public ModifierMethod<T, C>
    {
    public:
        explicit
        MemberModifierType(ModifierPtr mp)
            : m_mp(mp)
        {};

        ResultType
        operator()(C &rObject, ArgumentType Arg) const
        {
            (rObject.*m_mp)(Arg);
        }

    private:
        ModifierMethod<T, C>::ModifierPtr m_mp;
    };

} // namespace cci

#endif // SLBCCI_METHODHELP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\objectinforecord.h ===
// ObjectInfoRecord.h: interface for the CObjectInfoRecord class.
//
// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 2000. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
//////////////////////////////////////////////////////////////////////

#if !defined(CCI_OBJECTINFORECORD_H)
#define CCI_OBJECTINFORECORD_H

#include <string>

#include "slbCci.h"
#include "slbarch.h"
#include "V2Card.h"

namespace cci {


class CObjectInfoRecord
{

public:
    CObjectInfoRecord(CV2Card const &rcard,
                      SymbolID bHandle,
                      ObjectAccess access);

    virtual
    ~CObjectInfoRecord() {};

    virtual void
    Symbol(SymbolID *psid,
           std::string const &raString);

    virtual std::string
    Symbol(SymbolID const *psid);

    virtual void
    Flag(BYTE bFlagID,
         bool fFlag);

    virtual bool
    Flag(BYTE bFlagID);

    bool
    Private();

    virtual void
    Read() = 0;

    virtual void
    Write() = 0;

protected:

    virtual BYTE *ObjectFlags()=0;

    CV2Card const &m_rcard;
    SymbolID const m_bHandle;
    ObjectAccess const m_Access;
    bool m_fCached;

};

}

#endif // !defined(CCI_OBJECTINFORECORD_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\objectinforecord.cpp ===
// ObjectInfoRecord.cpp: implementation of the CObjectInfoRecord class.
//
// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 2000. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
//////////////////////////////////////////////////////////////////////
#include "NoWarning.h"

#include "ObjectInfoRecord.h"
#include "TransactionWrap.h"

using namespace std;
using namespace cci;

CObjectInfoRecord::CObjectInfoRecord(CV2Card const &rv2card,
                                     SymbolID bHandle,
                                     ObjectAccess access)
    : m_rcard(rv2card),
      m_bHandle(bHandle),
      m_Access(access),
      m_fCached(false)
{}

void
CObjectInfoRecord::Symbol(SymbolID *psid,
                          string const &raString)
{

    CTransactionWrap wrap(m_rcard);

    Read();

    string oldstr;

    SymbolID oldsid = *psid;
    if(oldsid)
    {
        oldstr =  m_rcard.ObjectInfoFile(m_Access).FindSymbol(oldsid);
        if(raString == oldstr)
            return;
		m_rcard.ObjectInfoFile(m_Access).RemoveSymbol(oldsid);
        *psid = 0;
    }

    if(raString.size()) 
    {
        try 
        {
            *psid = m_rcard.ObjectInfoFile(m_Access).AddSymbol(raString);
        }
        catch(Exception &rExc)
        {
            scu::Exception::ErrorCode err = rExc.Error();

            if(oldsid && (ccOutOfSymbolTableSpace==err || ccOutOfSymbolTableEntries==err))
            {
                *psid = m_rcard.ObjectInfoFile(m_Access).AddSymbol(oldstr);
                if(*psid != oldsid) Write();
            }
            throw;
        }
    }

    if(*psid != oldsid) Write();

}

string CObjectInfoRecord::Symbol(SymbolID const *psid)
{
   	CTransactionWrap wrap(m_rcard);

    Read();

    if(*psid) 
        return m_rcard.ObjectInfoFile(m_Access).FindSymbol(*psid);
    else
        return string();

}


void CObjectInfoRecord::Flag(BYTE bFlagID, bool fFlag)
{
   	
    CTransactionWrap wrap(m_rcard);

    Read();

    BYTE *bFlagArray = ObjectFlags();

    if(fFlag)
    {
        if(!BitSet(bFlagArray,bFlagID))
        {
            SetBit(bFlagArray,bFlagID);
            Write();
        }
    }
    else
    {
        if(BitSet(bFlagArray,bFlagID)) 
        {
            ResetBit(bFlagArray,bFlagID);
            Write();
        }
    }
}

bool CObjectInfoRecord::Flag(BYTE bFlagID)
{
   	CTransactionWrap wrap(m_rcard);

    Read();

    BYTE *bFlagArray = ObjectFlags();
    return BitSet(bFlagArray,bFlagID);

}

bool CObjectInfoRecord::Private()
{
    return (m_Access==oaPrivateAccess) ? true : false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\prikeyinforecord.cpp ===
// PriKeyInfoRecord.cpp - Implementation of CPriKeyInfoRecord class
//
// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
//////////////////////////////////////////////////////////////////////////////
#include "NoWarning.h"

#include "CardInfo.h"
#include "PriKeyInfoRecord.h"
#include "TransactionWrap.h"

using namespace cci;

CPriKeyInfoRecord::CPriKeyInfoRecord(CV2Card const &rv2card,
                                     SymbolID bHandle,
                                     ObjectAccess access)
    : CObjectInfoRecord(rv2card, bHandle, access)
{
    Clear();
}

void CPriKeyInfoRecord::Clear()
{

    memset(m_bObjectFlags,0,2);
    m_bKeyNum       = 0;
    m_bKeyType      = CardKeyTypeNone;

    m_dtStart.bDay = 0;
    m_dtStart.bMonth = 0;
    m_dtStart.dwYear = 0;

    m_dtEnd.bDay = 0;
    m_dtEnd.bMonth = 0;
    m_dtEnd.dwYear = 0;

    m_bLabel        = 0;
        m_bID               = 0;
    m_bCredentialID = 0;
        m_bSubject          = 0;
    m_bModulus      = 0;
    m_bPublExponent = 0;

    m_fCached = false;
}

void CPriKeyInfoRecord::Read()
{
    CTransactionWrap wrap(m_rcard);

    if(m_fCached) return;

    BYTE bBuffer[PrivInfoRecordSize];

    m_rcard.ObjectInfoFile(m_Access).ReadObject(m_bHandle, bBuffer);

    memcpy(m_bObjectFlags,&bBuffer[PrivObjectFlagsLoc],sizeof m_bObjectFlags);

    m_bKeyType      = bBuffer[PrivKeyTypeLoc];
    m_bKeyNum       = bBuffer[PrivKeyNumLoc];

    DateArrayToDateStruct(&bBuffer[PrivStartDateLoc], &m_dtStart);
    DateArrayToDateStruct(&bBuffer[PrivEndDateLoc], &m_dtEnd);

    m_bLabel        = bBuffer[PrivLabelLoc];
        m_bID               = bBuffer[PrivIDLoc];
    m_bCredentialID = bBuffer[PrivCredentialIDLoc];
        m_bSubject          = bBuffer[PrivSubjectLoc];
        m_bModulus          = bBuffer[PrivModulusLoc];
    m_bPublExponent = bBuffer[PrivPublExponentLoc];

    m_fCached = true;

}

void CPriKeyInfoRecord::Write()
{

    CTransactionWrap wrap(m_rcard);

    BYTE bBuffer[PrivInfoRecordSize];

    memset(bBuffer, 0, PrivInfoRecordSize);

    memcpy(&bBuffer[PrivObjectFlagsLoc],m_bObjectFlags,2);

    bBuffer[PrivKeyTypeLoc]         = m_bKeyType;
    bBuffer[PrivKeyNumLoc]          = m_bKeyNum;

    DateStructToDateArray(&m_dtStart, &bBuffer[PrivStartDateLoc]);
    DateStructToDateArray(&m_dtEnd, &bBuffer[PrivEndDateLoc]);

    bBuffer[PrivLabelLoc]           = m_bLabel;
    bBuffer[PrivIDLoc]              = m_bID;
    bBuffer[PrivCredentialIDLoc]    = m_bCredentialID;
    bBuffer[PrivSubjectLoc]         = m_bSubject;
    bBuffer[PrivModulusLoc]         = m_bModulus;
    bBuffer[PrivPublExponentLoc]    = m_bPublExponent;

    m_rcard.ObjectInfoFile(m_Access).WriteObject(m_bHandle, bBuffer);

    m_fCached = true;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\pubkeyinforecord.cpp ===
// PubKeyInfoRecord.cpp
//
// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
//////////////////////////////////////////////////////////////////////////////
#include "NoWarning.h"

#include "CardInfo.h"
#include "PubKeyInfoRecord.h"
#include "TransactionWrap.h"

using namespace cci;

CPubKeyInfoRecord::CPubKeyInfoRecord(CV2Card const &rcard,
                                     SymbolID bHandle,
                                     ObjectAccess access)
    : CObjectInfoRecord(rcard, bHandle, access)
{
    Clear();
}

void CPubKeyInfoRecord::Clear()
{

    memset(m_bObjectFlags,0,2);
    m_bKeyType      = CardKeyTypeNone;

    m_dtStart.bDay = 0;
    m_dtStart.bMonth = 0;
    m_dtStart.dwYear = 0;

    m_dtEnd.bDay = 0;
    m_dtEnd.bMonth = 0;
    m_dtEnd.dwYear = 0;

    m_bLabel        = 0;
        m_bID               = 0;
    m_bCredentialID = 0;
        m_bSubject          = 0;
    m_bModulus      = 0;
    m_bPublExponent = 0;

    m_fCached = false;

}

void CPubKeyInfoRecord::Read()
{
    CTransactionWrap wrap(m_rcard);

    if(m_fCached) return;

    BYTE bBuffer[PublInfoRecordSize];

    m_rcard.ObjectInfoFile(m_Access).ReadObject(m_bHandle, bBuffer);

    memcpy(m_bObjectFlags,&bBuffer[PublObjectFlagsLoc],2);
    m_bKeyType      = bBuffer[PublKeyTypeLoc];

    DateArrayToDateStruct(&bBuffer[PublStartDateLoc], &m_dtStart);
    DateArrayToDateStruct(&bBuffer[PublEndDateLoc], &m_dtEnd);

    m_bLabel        = bBuffer[PublLabelLoc];
        m_bID               = bBuffer[PublIDLoc];
    m_bCredentialID = bBuffer[PublCredentialIDLoc];
        m_bSubject          = bBuffer[PublSubjectLoc];
        m_bModulus          = bBuffer[PublModulusLoc];
    m_bPublExponent = bBuffer[PublPublExponentLoc];

    m_fCached = true;

}

void CPubKeyInfoRecord::Write()
{
    CTransactionWrap wrap(m_rcard);

    BYTE bBuffer[PublInfoRecordSize];

    memset(bBuffer, 0, PublInfoRecordSize);

    memcpy(&bBuffer[PublObjectFlagsLoc],m_bObjectFlags,2);
    bBuffer[PublKeyTypeLoc]         = m_bKeyType;

    DateStructToDateArray(&m_dtStart, &bBuffer[PublStartDateLoc]);
    DateStructToDateArray(&m_dtEnd, &bBuffer[PublEndDateLoc]);

    bBuffer[PublLabelLoc]           = m_bLabel;
    bBuffer[PublIDLoc]              = m_bID;
    bBuffer[PublCredentialIDLoc]    = m_bCredentialID;
    bBuffer[PublSubjectLoc]         = m_bSubject;
    bBuffer[PublModulusLoc]         = m_bModulus;
    bBuffer[PublPublExponentLoc]    = m_bPublExponent;

    m_rcard.ObjectInfoFile(m_Access).WriteObject(m_bHandle, bBuffer);

    m_fCached = true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\privatekey.cpp ===
// PrivateKey.cpp -- CPrivateKey class definition

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
//////////////////////////////////////////////////////////////////////
#include "NoWarning.h"

#include "CryptFctry.h"
#include "cciPriKey.h"

using namespace cci;

/////////////////////////// LOCAL/HELPER  /////////////////////////////////

///////////////////////////    PUBLIC     /////////////////////////////////

                                                  // Types
                                                  // C'tors/D'tors
CPrivateKey::CPrivateKey(ValueType *p)
    : SuperClass(p)
{}

CPrivateKey::CPrivateKey(CCard const &rhcard,
                         ObjectAccess oa)
    : SuperClass(rhcard->MakePrivateKey(oa))
{}


                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables

///////////////////////////   PROTECTED   /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables


///////////////////////////    PRIVATE    /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\protcrypt.h ===
// ProtCrypt.h -- declaration of CProtectableCrypt

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 2000. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#if !defined(SLBCCI_PROTCRYPT_H)
#define SLBCCI_PROTCRYPT_H

#include "slbCci.h"
#include "CryptObj.h"

namespace cci
{

// Pure virtual mixin for an object that has an ObjectAccess attribute
class CProtectableCrypt
    : public CCryptObject
{
public:
                                                  // Types
                                                  // C'tors/D'tors
    virtual
    ~CProtectableCrypt() = 0;


                                                  // Operators
                                                  // Operations
                                                  // Access
    ObjectAccess
    Access() const;

    virtual bool
    Private() = 0;

                                                  // Predicates

protected:
                                                  // Types
                                                  // C'tors/D'tors
    CProtectableCrypt(CAbstractCard const &racard,
                      ObjectAccess oa);

                                                  // Operators
    bool
    operator==(CProtectableCrypt const &rhs) const;
        // TO DO: this should be superceded by implementing singletons

    bool
    operator!=(CProtectableCrypt const &rhs) const;
        // TO DO: this should be superceded by implementing singletons

                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables
    ObjectAccess const m_oa;

private:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables

};

} // namespace cci

#endif // SLBCCI_PROTCRYPT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\protcrypt.cpp ===
// ProtCrypt.cpp -- definition of CProtectableCrypt

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 2000. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
//////////////////////////////////////////////////////////////////////
#include "NoWarning.h"

#include "ProtCrypt.h"

using namespace cci;

/////////////////////////// LOCAL/HELPER  /////////////////////////////////

///////////////////////////    PUBLIC     /////////////////////////////////

                                                  // Types
                                                  // C'tors/D'tors
CProtectableCrypt::~CProtectableCrypt()
{}

                                                  // Operators
                                                  // Operations
                                                  // Access
ObjectAccess
CProtectableCrypt::Access() const
{
    return m_oa;
}

                                                  // Predicates
                                                  // Static Variables

///////////////////////////   PROTECTED   /////////////////////////////////

                                                  // C'tors/D'tors
CProtectableCrypt::CProtectableCrypt(CAbstractCard const &racard,
                                     ObjectAccess oa)
    : CCryptObject(racard),
      m_oa(oa)
{}

                                                  // Operators
bool
CProtectableCrypt::operator==(CProtectableCrypt const &rhs) const
{
    return CCryptObject::operator==(rhs) &&
        (m_oa == rhs.m_oa);
}

bool
CProtectableCrypt::operator!=(CProtectableCrypt const &rhs) const
{
    return !(*this == rhs);
}

                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables


///////////////////////////    PRIVATE    /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\prikeyinforecord.h ===
// PriKeyInfoRecord.h: interface for the CPriKeyInfoRecord class.
//
// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
//////////////////////////////////////////////////////////////////////

#if !defined(SLBCCI_PRIKEYINFORECORD_H)
#define SLBCCI_PRIKEYINFORECORD_H

#include <iopPriBlob.h>

#include "slbCci.h"
#include "cciCard.h"
#include "ObjectInfoRecord.h"

namespace cci
{

class CPriKeyInfoRecord
    : public CObjectInfoRecord
{
public:

    CPriKeyInfoRecord(CV2Card const &rv2card,
                      SymbolID bHandle,
                      ObjectAccess access);
    virtual ~CPriKeyInfoRecord() {};

    void Read();
    void Write();
    void Clear();

    BYTE *ObjectFlags() {return m_bObjectFlags;};

    BYTE m_bKeyNum;
    BYTE m_bKeyType;

    Date m_dtStart;
    Date m_dtEnd;

    SymbolID m_bLabel;
    SymbolID m_bID;
    SymbolID m_bCredentialID;
    SymbolID m_bSubject;
    SymbolID m_bModulus;
    SymbolID m_bPublExponent;

private:
    BYTE m_bObjectFlags[2];

};

const unsigned short PrivObjectFlagsLoc     = 0;
const unsigned short PrivKeyTypeLoc         = 3;
const unsigned short PrivKeyNumLoc          = 4;
const unsigned short PrivStartDateLoc       = 5;
const unsigned short PrivEndDateLoc         = 8;
const unsigned short PrivLabelLoc           = 11;
const unsigned short PrivIDLoc              = 12;
const unsigned short PrivCredentialIDLoc    = 13;
const unsigned short PrivSubjectLoc         = 14;
const unsigned short PrivModulusLoc         = 15;
const unsigned short PrivPublExponentLoc    = 16;
const unsigned short PrivInfoRecordSize     = 17;

const BYTE PrivModifiableFlag       = 0;
const BYTE PrivDecryptFlag          = 1;
const BYTE PrivSignFlag             = 2;
const BYTE PrivSignRecoverFlag      = 3;
const BYTE PrivUnwrapFlag           = 4;
const BYTE PrivDeriveFlag           = 5;
const BYTE PrivLocalFlag            = 6;
const BYTE PrivReadFlag             = 7;
const BYTE PrivExportableFlag       = 8;
const BYTE PrivNeverReadFlag        = 9;
const BYTE PrivNeverExportableFlag  = 10;

}
#endif // !defined(SLBCCI_PRIKEYINFORECORD_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\publickey.cpp ===
// PublicKey.cpp -- CPublicKey class definition

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
//////////////////////////////////////////////////////////////////////
#include "NoWarning.h"

#include "CryptFctry.h"
#include "cciPubKey.h"

using namespace cci;

/////////////////////////// LOCAL/HELPER  /////////////////////////////////

///////////////////////////    PUBLIC     /////////////////////////////////

                                                  // Types
                                                  // C'tors/D'tors
CPublicKey::CPublicKey(ValueType *p)
    : SuperClass(p)
{}

CPublicKey::CPublicKey(CCard const &rhcard,
                       ObjectAccess oa)
    : SuperClass(rhcard->MakePublicKey(oa))
{}


                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables

///////////////////////////   PROTECTED   /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables


///////////////////////////    PRIVATE    /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\pubkeyinforecord.h ===
// PubKeyInfoRecord.h: interface for the CPubKeyInfoRecord class.
//
// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
//////////////////////////////////////////////////////////////////////

#if !defined(__PUBKEYINFORECORD_H)
#define __PUBKEYINFORECORD_H

#include "slbCci.h"
#include "V2Card.h"
#include "ObjectInfoRecord.h"

namespace cci {

    using std::string;
    using iop::CPublicKeyBlob;

class CPubKeyInfoRecord
    : public CObjectInfoRecord
{
public:

    CPubKeyInfoRecord(CV2Card const &rcard,
                      SymbolID bHandle,
                      ObjectAccess access) ;
    virtual ~CPubKeyInfoRecord() {};

    void Read();
    void Write();
    void Clear();

    BYTE *ObjectFlags() {return m_bObjectFlags;};

    BYTE m_bKeyType;

    Date m_dtStart;
    Date m_dtEnd;

    SymbolID m_bLabel;
    SymbolID m_bID;
    SymbolID m_bCredentialID;
    SymbolID m_bSubject;
    SymbolID m_bModulus;
    SymbolID m_bPublExponent;

private:
    BYTE m_bObjectFlags[2];

};

const unsigned short PublObjectFlagsLoc     = 0;
const unsigned short PublKeyTypeLoc         = 2;
const unsigned short PublStartDateLoc       = 3;
const unsigned short PublEndDateLoc         = 6;
const unsigned short PublLabelLoc           = 9;
const unsigned short PublIDLoc              = 10;
const unsigned short PublCredentialIDLoc    = 11;
const unsigned short PublSubjectLoc         = 12;
const unsigned short PublModulusLoc         = 13;
const unsigned short PublPublExponentLoc    = 14;
const unsigned short PublInfoRecordSize     = 15;

const BYTE PublModifiableFlag       = 0;
const BYTE PublEncryptFlag          = 1;
const BYTE PublVerifyFlag           = 2;
const BYTE PublVerifyRecoverFlag    = 3;
const BYTE PublWrapFlag             = 4;
const BYTE PublDeriveFlag           = 5;
const BYTE PublLocalFlag            = 6;
const BYTE PublCKInvisibleFlag     = 15;


}
#endif // !defined(__PUBKEYINFORECORD_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by slbcci.rc
//

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\slbcci.h ===
//  SLBCCI.H
//
//  This file contains all of the macro definitions and other defines
//  used within the common crypto interface layer.
//
// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
/////////////////////////////////////////////////////////////////////////////////

#ifndef SLBCCI_H
#define SLBCCI_H

#include "cciExc.h"
#include "SmartCard.h"

// OS dependent definitions and includes






#if defined(_WIN32)

// Export flags, so that the same headers can be used by client and server
#ifdef CCI_IN_DLL
#define CCI_INTERFACE   __declspec(dllexport)
#define EXP_IMP_TEMPLATE
#else
#define CCI_INTERFACE   __declspec(dllimport)
#define EXP_IMP_TEMPLATE        extern
#endif


#include <windows.h>

#elif defined(_OS_UNIX)

typedef DWORD unsigned long
typedef BYTE  unsigned char

#elif defined(_OS_MAC)



#else
#error  OS_NOT_DEFINED
#endif

namespace cci {

typedef struct CCI_Date
{
    BYTE bDay;
    BYTE bMonth;
    DWORD dwYear;   //  I'm not Y4Gig compliant....
} Date;

typedef struct CCI_Format
{
    BYTE bMajor;
    BYTE bMinor;
} Format;


enum ObjectAccess   { oaNoAccess, oaPublicAccess, oaPrivateAccess};

enum ShareMode      { smShared, smExclusive};

enum ObjectType     { otContainerObject,  otCertificateObject, otPublicKeyObject,
                      otPrivateKeyObject, otDataObjectObject};

typedef iop::KeyType KeyType;
using iop::ktRSA512;
using iop::ktRSA768;
using iop::ktRSA1024;

typedef iop::CardOperation CardOperation;
using iop::coEncryption;
using iop::coDecryption;
using iop::coKeyGeneration;

enum SCardType      { UnknownCard, Cryptoflex8K, Access16K };

enum KeySpec        { ksExchange = 0, ksSignature = 1, ksNone = -1 };

void DateStructToDateArray(cci::Date *dStruct, BYTE *bArray);
void DateArrayToDateStruct(BYTE *bArray, cci::Date *dStruct);

void SetBit(BYTE *Buf, unsigned int Bit);
void ResetBit(BYTE *Buf, unsigned int Bit);
bool BitSet(BYTE *Buf, unsigned int Bit);

}   // namespace cci

// Includes

#include "slbarch.h"


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\slbarch.h ===
//
//  slbArch.h
//
//  Assorted include info for the archival system
//
// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
////////////////////////////////////////////////////////////////////////////
#if !defined(CCI_SLBARCH_H)
#define CCI_SLBARCH_H

#include <string>

#include <windows.h>

#include "ArchivedValue.h"


namespace cci
{

typedef CArchivedValue<std::string> ArchivedSymbol;
typedef BYTE SymbolID;

} // namespace cci

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\symboltable.h ===
// SymbolTable.h: interface for the CSymbolTable class.
//
// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
//////////////////////////////////////////////////////////////////////

#if !defined(SLBCCI_SYMBOLTABLE_H)
#define SLBCCI_SYMBOLTABLE_H

#include <memory>                                 // for auto_ptr
#include <string>
#include <vector>

#include <scuArrayP.h>

#include "slbarch.h"

namespace cci {

class CSymbolTable
{

    friend class CFreeBlock;

public:

    CSymbolTable(iop::CSmartCard &rSmartCard,
                 const std::string &rPath,
                 unsigned short Offset);
    virtual ~CSymbolTable();

    std::string Find(SymbolID const &rsid);
        bool            Find(std::string const &rsOrig,
                     SymbolID *sid);


        SymbolID        Add(std::string const &strNew, ShareMode mode=smShared);
        bool            Remove(SymbolID const &rsid);
    void        Replace(SymbolID const &rsid, std::string const &strUpd);

    unsigned short NumSymbols();
    unsigned short FirstFreeBlock();
    void  FirstFreeBlock(unsigned short sFree);
    unsigned short TableSize();

    WORD Hash(std::string const &rstr);
    std::vector<std::string> CSymbolTable::EnumStrings();
    void Compress();
    void Reset();
    void DumpState();

    unsigned short FreeSpace();

private:

    void
    ClearTableEntry(BYTE const &rsid);

    void
    UpdateTableEntry(BYTE const &rsid,
                     WORD wNewHash,
                     WORD wNewOffset,
                     WORD wNewLength);

    BYTE RefCount(BYTE const &sidx);

    void GetSymbolTable();
    void SelectSymbolFile();
    void ReadSymbolFile(const WORD wOffset,  const WORD wDataLength,  BYTE* bDATA);
    void WriteSymbolFile(const WORD wOffset,  const WORD wDataLength,  const BYTE* bDATA);

    iop::CSmartCard &m_rSmartCard;

    unsigned short m_Offset;

    scu::AutoArrayPtr<std::string> m_aastrCachedStrings;
    scu::AutoArrayPtr<bool> m_aafCacheMask;

    scu::AutoArrayPtr<unsigned short> m_aasHashTable;
    scu::AutoArrayPtr<unsigned short> m_aasOffsetTable;
    scu::AutoArrayPtr<unsigned short> m_aasLengthTable;

    bool m_fSymbolTableLoaded;

    std::string m_Path;

    CArchivedValue<unsigned short> m_sMaxNumSymbols;
    CArchivedValue<unsigned short> m_sFirstFreeBlock;
    CArchivedValue<unsigned short> m_sTableSize;

};

class CFreeBlock
{
public:
    CFreeBlock(CSymbolTable *pSymTable, unsigned short sStartLocation);
    virtual ~CFreeBlock() {};

        std::auto_ptr<CFreeBlock>
    Next();

        void
    Update();

    unsigned short m_sStartLoc;
    unsigned short m_sBlockLength;
    unsigned short m_sNextBlock;

private:
    CSymbolTable *m_pSymbolTable;


};

const unsigned short SymbNumSymbolLoc = 0;     // Location of Number of symbols
const unsigned short SymbFreeListLoc  = 1;     // Location of Free list
const unsigned short SymbTableSizeLoc = 3;     // Location of symbol table size
const unsigned short SymbHashTableLoc = 5;     // Location of hash table


}
#endif // !defined(SLBCCI_SYMBOLTABLE_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\slbcci.cpp ===
// slbcci.cpp - Utility functions
//
// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
////////////////////////////////////////////////////////////////////////////
#include "NoWarning.h"

#include "slbCci.h"


void cci::DateStructToDateArray(Date *dStruct, BYTE *bArray)
{
    bArray[0] = dStruct->dwYear / 64;
    bArray[1] = ((dStruct->dwYear % 64) << 2 ) + dStruct->bMonth / 4;
    bArray[2] = ((dStruct->bMonth % 4) << 6 ) + dStruct->bDay;

}


void cci::DateArrayToDateStruct(BYTE *bArray, Date *dStruct)
{
    dStruct->dwYear = bArray[0] * 64 + (bArray[1] >> 2);
    dStruct->bMonth = (bArray[1] & 0x03) * 4 + (bArray[2] >> 6);
    dStruct->bDay   = (bArray[2] & 0x3F);
}

void cci::SetBit(BYTE *Buf, unsigned int i)
{
    BYTE Mask = 1 << (i % 8);
    Buf[i/8] |= Mask;
    return;
}

void cci::ResetBit(BYTE *Buf, unsigned int i)
{
    BYTE Mask = 1 << (i % 8);
    Buf[i/8] &= ~Mask;
    return;
}

bool cci::BitSet(BYTE *Buf, unsigned int i)
{
    BYTE Mask = 1 << (i % 8);
    return (Buf[i/8] & Mask) ? true : false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\transactionwrap.h ===
// TransactionWrap.h: interface for the CTransactionWrap class.
//
// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_TRANSACTIONWRAP_H__444C1291_7C1E_11D3_A5C4_00104BD32DA8__INCLUDED_)
#define AFX_TRANSACTIONWRAP_H__444C1291_7C1E_11D3_A5C4_00104BD32DA8__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "LockWrap.h"

namespace cci
{

class CCard;
class CAbstractCard;

class CTransactionWrap
{
public:

    explicit CTransactionWrap(CCard const &rcard);
    explicit CTransactionWrap(CAbstractCard const *pcard);
    explicit CTransactionWrap(CAbstractCard const &rcard);
    virtual ~CTransactionWrap();

private:
    iop::CLockWrap m_LockWrap;
};


}
#endif // !defined(AFX_TRANSACTIONWRAP_H__444C1291_7C1E_11D3_A5C4_00104BD32DA8__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\transactionwrap.cpp ===
// TransactionWrap.cpp: implementation of the CTransactionWrap class.
//
// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
//////////////////////////////////////////////////////////////////////

#include "TransactionWrap.h"
#include "cciCard.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

using namespace cci;

CTransactionWrap::CTransactionWrap(CCard const &rcard)
    : m_LockWrap(rcard->SmartCard().Lock())
{}

CTransactionWrap::CTransactionWrap(CAbstractCard const *pcard)

    : m_LockWrap(pcard->SmartCard().Lock())
{}

CTransactionWrap::CTransactionWrap(CAbstractCard const &rcard)

    : m_LockWrap(rcard.SmartCard().Lock())
{}

CTransactionWrap::~CTransactionWrap()
{}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\symboltable.cpp ===
// SymbolTable.cpp: implementation of the CSymbolTable class.
//
// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
//////////////////////////////////////////////////////////////////////
#include "NoWarning.h"

// Don't allow the min & max macros in WINDEF.H to be defined so the
// min/max methods declared in limits are accessible.
#define NOMINMAX

#include <limits>

#include <slbCrc32.h>

#include <scuArrayP.h>

// must include this file first (there is probably an error in some header file)   (scm)
#include "cciExc.h"

#include "cciCard.h"
#include "SymbolTable.h"

#ifdef _DEBUG
#include <iostream>
#endif

using namespace std;
using namespace scu;
using namespace cci;
using namespace iop;

#define CONCAT_BYTES(hi,lo) ((unsigned short)(hi*256 + lo))

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CSymbolTable::CSymbolTable(CSmartCard &rSmartCard,
                           const string &rPath,
                           unsigned short Offset)
    : m_rSmartCard(rSmartCard),
      m_Offset(Offset),
      m_aastrCachedStrings(),
      m_aafCacheMask(),
      m_aasHashTable(),
      m_aasOffsetTable(),
      m_aasLengthTable(),
      m_fSymbolTableLoaded(false),
      m_Path(rPath),
      m_sMaxNumSymbols(),
      m_sFirstFreeBlock(),
      m_sTableSize()
{
	m_aastrCachedStrings = AutoArrayPtr<string>(new string[NumSymbols()]);
	m_aafCacheMask		 = AutoArrayPtr<bool>(new bool[NumSymbols()]);
	for (int i = 0; i < NumSymbols(); i++)
	{
		m_aastrCachedStrings[i] = "";
		m_aafCacheMask[i]       = false;
	}
}

CSymbolTable::~CSymbolTable()
{}

bool CSymbolTable::Remove(const SymbolID &rsid)
{
	if (!m_fSymbolTableLoaded)
		GetSymbolTable();
	else 
		SelectSymbolFile();


    if(rsid<1 || rsid>NumSymbols())
        throw Exception(ccSymbolNotFound);

    BYTE sidx = rsid-1;

	if (m_aasOffsetTable[sidx] == 0)
	{
		// We have a bad reference!
        throw Exception(ccSymbolNotFound);
	}

	// Let's read in the header info for the string we want to delete.

	BYTE bBuffer[5];
	ReadSymbolFile(m_aasOffsetTable[sidx], 3, bBuffer);

	unsigned short sStrLen, sBlockLen;
	BYTE bRefCount;

	sStrLen = m_aasLengthTable[sidx];
	sBlockLen = CONCAT_BYTES(bBuffer[1],bBuffer[0]);

	bRefCount = bBuffer[2];

	// The trivial case is when the refcount is greater than one.  In that
	// case we just dec the count!

	if (bRefCount > 1)
	{
		bRefCount--;
		WriteSymbolFile(m_aasOffsetTable[sidx] + 2, 1, &bRefCount);
		return true;
	}

	// Need to take it out of the cache

	m_aastrCachedStrings[sidx] = "";
	m_aafCacheMask[sidx] = false;

    // Simply connect the deleted block to the head of the free list.

    bBuffer[0] = LOBYTE(FirstFreeBlock());
	bBuffer[1] = HIBYTE(FirstFreeBlock());
    WriteSymbolFile(m_aasOffsetTable[sidx]+2, 2, bBuffer);

	FirstFreeBlock(m_aasOffsetTable[sidx]);

    ClearTableEntry(sidx);

    return true;

}

void CSymbolTable::Replace(SymbolID const &rsid, string const &rstrUpd)
{
	if (!m_fSymbolTableLoaded)
		GetSymbolTable();
	else 
		SelectSymbolFile();


    if(rsid<1 || rsid>NumSymbols())
        throw Exception(ccSymbolNotFound);

    BYTE sidx = rsid-1;

	if (m_aasOffsetTable[sidx] == 0)
        throw Exception(ccSymbolNotFound);

    // This implementation require the new string to have the same size as the old.
    // It may be that this requirement should be lifted later, however it is essential
    // that the SymbolID is not changed by this function.

    if(rstrUpd.size() != m_aasLengthTable[sidx])
        throw Exception(ccBadLength);

	WriteSymbolFile(m_aasOffsetTable[sidx] + 3,
					static_cast<BYTE>(rstrUpd.size()),
                    reinterpret_cast<BYTE const *>(rstrUpd.data()));

    unsigned short sHash = Hash(rstrUpd);

    UpdateTableEntry(sidx, sHash, m_aasOffsetTable[sidx], m_aasLengthTable[sidx]);

	m_aastrCachedStrings[sidx] = rstrUpd;
	m_aafCacheMask[sidx] = true;

}

SymbolID CSymbolTable::Add(const string &rstrNew, ShareMode mode)
{

	if (!m_fSymbolTableLoaded)
		GetSymbolTable();
	else 
		SelectSymbolFile();

	SymbolID rsid;
	BYTE sidx;

    if(mode==smShared) {

	    bool fFind = Find(rstrNew, &rsid);

    	if (fFind)
	    {

            sidx = rsid-1;
		
            // The string is already in the table.  Just bump the ref count.

	    	BYTE bRefCount;
		    ReadSymbolFile(m_aasOffsetTable[sidx] + 2, 1, &bRefCount);
		    bRefCount++;
		    WriteSymbolFile(m_aasOffsetTable[sidx] + 2, 1, &bRefCount);

            return sidx+1;
	    }
	    // String is not in the table.  We have to add it.
    }

    // Need to allocate a new string. First make sure 
    // that there is a free slot in the hash table.
    
    sidx = 0;
	while (sidx < NumSymbols())
	{
		if (m_aasOffsetTable[sidx] == 0)
			break;

        sidx++;
	}
    if(sidx == NumSymbols()) 
        throw Exception(ccOutOfSymbolTableEntries);

	// Let's see if we have space for the new string.  To do this, we just
	// cruise the empty block chain until we find an available block

	unsigned short sLength = static_cast<unsigned short>(rstrNew.length());
    unsigned short sExtra = (sLength) ? 0 : 1; // To make sure that the block is minimum 4 bytes since 
                                               // this is the  minimum size for a free block.

	// If there is no first free block, then the card is completely full.  Need
	// to throw an error.

	if (FirstFreeBlock() == 0)
        throw Exception(ccOutOfSymbolTableSpace);

	// When we finally find a block of appropriate size, we need to keep track of the
	// previous block, so that we can chain together the empty spaces.


	// Set of free block pointers that we will use to track the free space.

	auto_ptr<CFreeBlock> apFreeBlock(new CFreeBlock(this, FirstFreeBlock()));
	auto_ptr<CFreeBlock> apNewLocation;
	auto_ptr<CFreeBlock> apPrevious;

	
	unsigned short sTotalFreeSize = 0;

	// We will loop until we find a free block that is large enough, or we
	// will throw an error.
	
	while (!apNewLocation.get()) 
	{
		//  Remember that not only the string but the header info must fit into the
		//  space.
		sTotalFreeSize += apFreeBlock->m_sBlockLength;
		if (apFreeBlock->m_sBlockLength >= sLength + 3 + sExtra)
		{
			// The string fits in this block
			apNewLocation = apFreeBlock;
		}
		else
		{
			// String doesn't fit.  See if it fits in the next block.
			
			apPrevious  = apFreeBlock;
			apFreeBlock = apPrevious->Next();

			//  The Next() method returns 0 if we are out of free spots

			if (!apFreeBlock.get())
			{
				if (sTotalFreeSize < sLength + 3 + sExtra)
					throw Exception(ccOutOfSymbolTableSpace);
				else
				{
                    Compress();
					return Add(rstrNew);
				}
			}
		}
	}

	// The block of space that is my size is sitting in pNewLocation.
	// I need to chain the empty spaces on either side together.

	// How much space will be left in this empty block after I put my string in it?

	unsigned short sRemaining =
        apNewLocation->m_sBlockLength - (sLength + 3 + sExtra);

	// If less than 6 bytes remain, it isn't really worth splitting this block

	if (sRemaining < 6)
	{
		sExtra += sRemaining;
		if (apPrevious.get())
		{
			apPrevious->m_sNextBlock = apNewLocation->m_sNextBlock;
			apPrevious->Update();
		}
		else
			FirstFreeBlock(apNewLocation->m_sNextBlock);
	}
	else
	{
		// There is enough space in the block to make splitting worthwhile

        unsigned short sNewOffset =
            apNewLocation->m_sStartLoc + sLength + 3 + sExtra;
		BYTE bBuffer[4];
		bBuffer[0] = LOBYTE(sRemaining);
		bBuffer[1] = HIBYTE(sRemaining);
		bBuffer[2] = LOBYTE(apNewLocation->m_sNextBlock);
		bBuffer[3] = HIBYTE(apNewLocation->m_sNextBlock);

		WriteSymbolFile(sNewOffset, 4, bBuffer);
		if (apPrevious.get())
		{
			apPrevious->m_sNextBlock = sNewOffset;
			apPrevious->Update();
		}
		else
			FirstFreeBlock(sNewOffset);
	}

	// Drop the string in the empty slot

	AutoArrayPtr<BYTE> aabTemp(new BYTE[3 + sLength]);
	
	aabTemp[0] = LOBYTE(sLength + 3 + sExtra);
	aabTemp[1] = HIBYTE(sLength + 3 + sExtra);

    // Shared symbols are indicated by a ref-count >=1

    if(mode==smShared) aabTemp[2] = 1;
    else aabTemp[2] = 0;   

	memcpy(&aabTemp[3], rstrNew.data(), sLength);

	WriteSymbolFile(apNewLocation->m_sStartLoc, 3 + sLength, aabTemp.Get());

//	cout << "Adding " << strNew << " at " << pNewLocation->m_sStartLoc << endl;
//	cout << "Length = " << sLength << "  Block Length = " << sLength + 5 + sExtra << endl;


    // Populate the hash table entry

    unsigned short sHash = Hash(rstrNew);

    UpdateTableEntry(sidx, sHash, apNewLocation->m_sStartLoc, sLength);

    m_aastrCachedStrings[sidx] = rstrNew;
	m_aafCacheMask[sidx] = true;

	return sidx+1;

}

void CSymbolTable::GetSymbolTable()
{
	// There are 6 bytes in each entry of the symbol table, and we'll go ahead and
	// read in the whole table.

	unsigned short sTableSize = 6 * NumSymbols();

	AutoArrayPtr<BYTE> aabBuffer(new BYTE[sTableSize]);

	SelectSymbolFile();

	ReadSymbolFile(SymbHashTableLoc, sTableSize, aabBuffer.Get());

	m_aasHashTable =
        AutoArrayPtr<unsigned short>(new unsigned short[NumSymbols()]);
	m_aasOffsetTable =
        AutoArrayPtr<unsigned short>(new unsigned short[NumSymbols()]);
	m_aasLengthTable =
        AutoArrayPtr<unsigned short>(new unsigned short[NumSymbols()]);

	m_fSymbolTableLoaded = true;

	for (int i = 0; i < NumSymbols(); i++)
	{
		m_aasHashTable[i]   = CONCAT_BYTES(aabBuffer[1 + i*6],
                                           aabBuffer[0 + i*6]);
		m_aasOffsetTable[i] = CONCAT_BYTES(aabBuffer[3 + i*6],
                                           aabBuffer[2 + i*6]);
		m_aasLengthTable[i] = CONCAT_BYTES(aabBuffer[5 + i*6],
                                           aabBuffer[4 + i*6]);
	}
}

WORD CSymbolTable::Hash(const string &rstr)
{
    // A 32-bit CRC is used to produce a 16-bit hash value is used.
    // There are several reasons for using a 32-bit CRC instead of a
    // 16-bit version:
    //
    // 1. A 16-bit CRC has the characteristics that the hash value 1
    // would occur twice for every 65536 CRC runs where all other values
    // would occur only once on average.  Using a 32-bit CRC the hash
    // values are spread evenly within a small percentage fraction
    // this problem doesn't occur.
    //
    // 2. The CCI uses a compression algorithm based on the same
    // 32-bit CRC.  The CRC algorithm is implemented with a table.
    // Using a 16-bit CRC would result in an additional CRC lookup
    // table of 512-bytes or require one of the algorithms not to be
    // table-driven and therefore slower.
    //
    // 3. On 32-bit architectures, a 32-bit CRC algorithm is faster
    // than a 16-bit algorithm.
    //
    DWORD crc = Crc32(rstr.data(), rstr.length());
    DWORD remainder = crc % std::numeric_limits<WORD>::max();
    WORD Value = static_cast<WORD>(remainder);

    return Value;
}

vector <string> CSymbolTable::EnumStrings()
{
	vector <string> vStrings;
	if (!m_fSymbolTableLoaded)
		GetSymbolTable();

	for (BYTE sidx = 0; sidx < NumSymbols(); sidx++)
	{
		if (m_aasOffsetTable[sidx])
		{
			vStrings.push_back(Find((SymbolID)(sidx+1)));
		}
	}

	return vStrings;
}

bool CSymbolTable::Find(const string &rsOrig, SymbolID *sid)
{
	unsigned short sICV = 0;
	unsigned short sHash = Hash(rsOrig);

	if (!m_fSymbolTableLoaded)
		GetSymbolTable();
	else 
		SelectSymbolFile();


	for (BYTE sidx = 0; sidx < NumSymbols(); sidx++)
	{
		if (m_aasOffsetTable[sidx] && sHash == m_aasHashTable[sidx])
		{
			// This is a potential match
			if (rsOrig == Find(sidx+1))
			{

                // Check that it is allowed to share it.

                if(RefCount(sidx)) { 
    				*sid = (SymbolID)(sidx+1);
	    			return true;
                }
			}
		}
	}
	return false;
}

string CSymbolTable::Find(const SymbolID &rsid)
{
    if(rsid<1 || rsid>NumSymbols())
        throw Exception(ccSymbolNotFound);

    BYTE sidx = rsid-1;

	if (m_aafCacheMask[sidx])
		return m_aastrCachedStrings[sidx];

	if (!m_fSymbolTableLoaded)
		GetSymbolTable();
	else 
		SelectSymbolFile();

	if (m_aasOffsetTable[sidx] == 0) 
        return string();

	unsigned short sLength = m_aasLengthTable[sidx];

	if (0 == sLength)
		return string();

    AutoArrayPtr<BYTE> aabBuffer(new BYTE[sLength]);
	ReadSymbolFile(m_aasOffsetTable[sidx] + 3, sLength, aabBuffer.Get());

	string strRetVal((char*)aabBuffer.Get(), sLength);

    // Verify the data isn't corrupted by hashing the data retrieved
    // and comparing that resulting hash against the hashed used to
    // find the data originally.  This provides checking for both the
    // string and the hash used to store the string.

    DWORD const dwHash = Hash(strRetVal);
    if (dwHash != m_aasHashTable[sidx])
        throw Exception(ccSymbolDataCorrupted);
    
	m_aastrCachedStrings[sidx] = strRetVal;
	m_aafCacheMask[sidx]       = true;

	return strRetVal;
}

BYTE CSymbolTable::RefCount(const BYTE &sidx)
{
	if (!m_fSymbolTableLoaded)
		GetSymbolTable();
	else
		SelectSymbolFile();

	if (m_aasOffsetTable[sidx] == 0)
	{
		return 0;
	}

	BYTE bBuffer;

	ReadSymbolFile(m_aasOffsetTable[sidx] + 2, 1, &bBuffer);

	return bBuffer;
}

unsigned short CSymbolTable::NumSymbols()
{
	if (!m_sMaxNumSymbols.IsCached())
	{
		SelectSymbolFile();	

		BYTE bSymbols[2];

		ReadSymbolFile(SymbNumSymbolLoc, 1, bSymbols);

		m_sMaxNumSymbols.Value(bSymbols[0]);
	}

	return m_sMaxNumSymbols.Value();

}

void CSymbolTable::FirstFreeBlock(unsigned short sOffset)
{
	BYTE bFBlock[2];
	bFBlock[0] = LOBYTE(sOffset);
	bFBlock[1] = HIBYTE(sOffset);

   	SelectSymbolFile();	
	WriteSymbolFile(SymbFreeListLoc, 2, bFBlock);

    m_sFirstFreeBlock.Value(sOffset);
}

unsigned short CSymbolTable::FirstFreeBlock()
{

	if (!m_sFirstFreeBlock.IsCached())
	{

        BYTE bSymbols[2];

    	SelectSymbolFile();	
        ReadSymbolFile(SymbFreeListLoc, 2, bSymbols);

		m_sFirstFreeBlock.Value(CONCAT_BYTES(bSymbols[1],bSymbols[0]));
	}

	return m_sFirstFreeBlock.Value();

}

unsigned short CSymbolTable::TableSize()
{
	if (!m_sTableSize.IsCached())
	{
		SelectSymbolFile();

		BYTE bSymbols[2];

		ReadSymbolFile(SymbTableSizeLoc,2, bSymbols);

		m_sTableSize.Value(CONCAT_BYTES(bSymbols[1],bSymbols[0]));
	}

	return m_sTableSize.Value();
}

unsigned short CSymbolTable::FreeSpace()
{
    unsigned short sTotalFreeSize = 0;

    if(FirstFreeBlock())
    {

		SelectSymbolFile();

        auto_ptr<CFreeBlock> apNextFreeBlock;
        auto_ptr<CFreeBlock> apFreeBlock(new CFreeBlock(this, FirstFreeBlock()));
	
	    sTotalFreeSize += apFreeBlock->m_sBlockLength;
	
    	while(apFreeBlock->m_sNextBlock) 
	    {
		    apNextFreeBlock = apFreeBlock->Next();
            apFreeBlock     = apNextFreeBlock;
		    sTotalFreeSize += apFreeBlock->m_sBlockLength;
	    }
    }

	return sTotalFreeSize;

}


void CSymbolTable::SelectSymbolFile()
{
	m_rSmartCard.Select(m_Path.c_str());
}

void CSymbolTable::ReadSymbolFile(const WORD wOffset,  const WORD wDataLength,  BYTE* bDATA)
{
    m_rSmartCard.ReadBinary(wOffset+m_Offset,wDataLength,bDATA);
}

void CSymbolTable::WriteSymbolFile(const WORD wOffset,  const WORD wDataLength,  const BYTE* bDATA)
{
    m_rSmartCard.WriteBinary(wOffset+m_Offset,wDataLength,bDATA);
}

#ifdef _DEBUG

void CSymbolTable::DumpState()
{
	cout << "Dumping card state." << endl;
	cout << "Symbol Table Global Info:" << endl;
	cout << "  Number of Symbols: " << NumSymbols();
	cout << "  Total table size:  " << TableSize();
	cout << "  First free block:  " << hex << FirstFreeBlock() << endl;
	cout << "Hash Table contents: " << endl;

	GetSymbolTable();
	cout << "Hash	Offset	Length" << endl;
	for (int i = 0; i < NumSymbols(); i++)
		cout << hex << m_aasHashTable[i] << "\t" << m_aasOffsetTable[i] << "\t" << m_aasLengthTable[i] << endl;

	unsigned short sFBOffset = FirstFreeBlock();

	cout << "Free Block List" << endl;
	if (!FirstFreeBlock())
		cout << endl << "NO FREE BLOCKS" << endl <<endl;
	else
	{
		CFreeBlock fb(this, sFBOffset);
		
		cout << dec << fb.m_sBlockLength << " bytes starting at " << hex << fb.m_sStartLoc 
			 << "\tNext = " << fb.m_sNextBlock << endl;
		while (fb.m_sNextBlock)
		{
			fb = CFreeBlock(this, fb.m_sNextBlock);
			cout << dec << fb.m_sBlockLength << " bytes starting at " << hex << fb.m_sStartLoc 
			 << "\tNext = " << fb.m_sNextBlock << endl;
		}
	}

	cout << "String List" << endl;

	cout << "Offset	StrLen	BlkLen	Refcnt	String" << endl;

	for (i = 0; i < NumSymbols(); i++)
		if (m_aasOffsetTable[i])
		{
			// Read in the header
			BYTE bHeader[5];
			ReadSymbolFile(m_aasOffsetTable[i], 3, bHeader);
			unsigned short sStrLen = m_aasLengthTable[i];
			unsigned short sBlockLen = CONCAT_BYTES(bHeader[1],bHeader[0]);
			BYTE bRefCnt = bHeader[2];
			
			AutoArrayPtr<BYTE> aabString(new BYTE[sStrLen]);

			ReadSymbolFile(m_aasOffsetTable[i] + 3, sStrLen, aabString.Get());
			
			string s1((char*)aabString.Get(), sStrLen);
// 			cout << hex << m_aasOffsetTable[i] << "\t" << sStrLen << "\t" << sBlockLen 
// 				<< "\t" << (int)bRefCnt << "\t" << s1 << endl;

		}

}

#endif

void CSymbolTable::Reset()
{
	unsigned short sSize = TableSize();
	unsigned short sNumSym = NumSymbols();
	unsigned short sTotalSize = SymbHashTableLoc + 6 * sNumSym + sSize;
	unsigned short sFirstFree = SymbHashTableLoc + 6 * sNumSym;
	AutoArrayPtr<BYTE> aabBuffer(new BYTE[sTotalSize]);

	memset(aabBuffer.Get(), 0, sTotalSize);
	aabBuffer[SymbNumSymbolLoc]   = sNumSym & 0xFF;
	aabBuffer[SymbFreeListLoc]    = LOBYTE(sFirstFree);
	aabBuffer[SymbFreeListLoc+1]  = HIBYTE(sFirstFree);
	aabBuffer[SymbTableSizeLoc]   = LOBYTE(sSize);
	aabBuffer[SymbTableSizeLoc+1] = HIBYTE(sSize);

	aabBuffer[sFirstFree]     = LOBYTE(sSize);
	aabBuffer[sFirstFree + 1] = HIBYTE(sSize);

	m_fSymbolTableLoaded = false;

	SelectSymbolFile();
	WriteSymbolFile( 0, sTotalSize, aabBuffer.Get());
	
	for (int i = 0; i < NumSymbols(); i++)
	{
		m_aafCacheMask[i] = false;
		m_aastrCachedStrings[i] = "";
	}
	
	m_sFirstFreeBlock.Dirty();

	GetSymbolTable();

}




void CSymbolTable::Compress()
{

	unsigned short sSize = TableSize();
	unsigned short sNumSym = NumSymbols();
	unsigned short sStringStart = SymbHashTableLoc + 6 * sNumSym;
	unsigned short sTotalSize = sStringStart + sSize;

//	cout << "Compressing..." << endl;

	GetSymbolTable();

	vector<string> vStringTable;
	
	AutoArrayPtr<unsigned short> aasStringSize(new unsigned short[sNumSym]);

//	cout << "Building table" << endl;

    BYTE sidx;
	for (sidx = 0; sidx < sNumSym; sidx++)
	{
		string strTemp;
		if (m_aasOffsetTable[sidx]) {
			strTemp = Find(sidx+1);
			aasStringSize[sidx] = static_cast<unsigned short>(strTemp.size());
		} else {
			strTemp = "";
		}
//		cout << "  Adding to table: " << strTemp << endl;
		vStringTable.push_back(strTemp);
	}

	AutoArrayPtr<BYTE> aabNewTable(new BYTE[sTotalSize]);

	memset(aabNewTable.Get(), 0, sTotalSize);

    aabNewTable[SymbNumSymbolLoc] = sNumSym & 0xFF;
	
	aabNewTable[SymbTableSizeLoc]   = LOBYTE(sSize);
	aabNewTable[SymbTableSizeLoc+1] = HIBYTE(sSize);

	unsigned short sCurrentWrite = sStringStart;

	for (sidx = 0; sidx < sNumSym; sidx++)
	{
		if (m_aasOffsetTable[sidx])
		{
			BYTE bTableEntry[6];
			bTableEntry[0] = LOBYTE(m_aasHashTable[sidx]);
			bTableEntry[1] = HIBYTE(m_aasHashTable[sidx]);
			bTableEntry[2] = LOBYTE(sCurrentWrite);
			bTableEntry[3] = HIBYTE(sCurrentWrite);
			bTableEntry[4] = LOBYTE(m_aasLengthTable[sidx]);
			bTableEntry[5] = HIBYTE(m_aasLengthTable[sidx]);

//			cout << "Placing '"<< vStringTable[i] << " at location " << hex << sCurrentWrite << endl;

            unsigned short sExtra = (aasStringSize[sidx]) ? 0 : 1;  // To make sure that the block is minimum 
                                                                // 4 bytes since this is the  minimum size 
                                                                // for a free block.
			AutoArrayPtr<BYTE> aabStringEntry(new BYTE[aasStringSize[sidx] + 3]);
			aabStringEntry[0] = LOBYTE(aasStringSize[sidx] + 3 + sExtra);
			aabStringEntry[1] = HIBYTE(aasStringSize[sidx] + 3 + sExtra);
			aabStringEntry[2] = RefCount(sidx);
			memcpy(&aabStringEntry[3], vStringTable[sidx].data(),
                   aasStringSize[sidx]);

			// Write the new entries

			memcpy(&aabNewTable[SymbHashTableLoc + sidx * 6], bTableEntry, 6);
			memcpy(&aabNewTable[sCurrentWrite], aabStringEntry.Get(),
                   aasStringSize[sidx] + 3);

			sCurrentWrite += aasStringSize[sidx] + 3 + sExtra;
		}
	}


	m_fSymbolTableLoaded = false;
	unsigned short sFreeSpace = sStringStart + sSize - sCurrentWrite;

	if (sFreeSpace < 8)
	{
		// Then there is essentially no more space on the card
		aabNewTable[SymbFreeListLoc] = 0;
		aabNewTable[SymbFreeListLoc+1] = 0;
	}
	else
	{
		aabNewTable[SymbFreeListLoc]   = LOBYTE(sCurrentWrite);
		aabNewTable[SymbFreeListLoc+1] = HIBYTE(sCurrentWrite);
		// Need to set up the last empty block as well.
		aabNewTable[sCurrentWrite]     = LOBYTE(sFreeSpace);
		aabNewTable[sCurrentWrite + 1] = HIBYTE(sFreeSpace);
	}

	// Phew!  Write the table back to the card.

	WriteSymbolFile(0, sTotalSize, aabNewTable.Get());

	m_sFirstFreeBlock.Dirty();

	// Clean up

	for (sidx = 0; sidx < NumSymbols(); sidx++)
	{
		m_aafCacheMask[sidx] = false;
		m_aastrCachedStrings[sidx] = "";
	}
}

void CSymbolTable::ClearTableEntry(BYTE const &sidx)
{
    UpdateTableEntry(sidx, 0, 0, 0);
}
    
           
void CSymbolTable::UpdateTableEntry(BYTE const &sidx,
                                    WORD wNewHash,
                                    WORD wNewOffset,
                                    WORD wNewLength)
{
        
    BYTE bBuffer[6];

    bBuffer[0] = LOBYTE(wNewHash);
    bBuffer[1] = HIBYTE(wNewHash);

    bBuffer[2] = LOBYTE(wNewOffset);
    bBuffer[3] = HIBYTE(wNewOffset);
        
    bBuffer[4] = LOBYTE(wNewLength);
    bBuffer[5] = HIBYTE(wNewLength);

    WriteSymbolFile(SymbHashTableLoc + (sidx * sizeof bBuffer),
                              sizeof bBuffer, bBuffer);

    m_aasHashTable[sidx]   = wNewHash;
    m_aasOffsetTable[sidx] = wNewOffset;
    m_aasLengthTable[sidx] = wNewLength;
        
}
    


CFreeBlock::CFreeBlock(CSymbolTable *pSymTable, unsigned short sStartLocation)
{
	m_pSymbolTable = pSymTable;

	m_sStartLoc = sStartLocation;

	BYTE bBuffer[4];

	m_pSymbolTable->ReadSymbolFile(m_sStartLoc, sizeof(bBuffer), bBuffer);

	m_sBlockLength = CONCAT_BYTES(bBuffer[1], bBuffer[0]);
	m_sNextBlock   = CONCAT_BYTES(bBuffer[3], bBuffer[2]);

}

void CFreeBlock::Update()
{
	BYTE bBuffer[4];

	bBuffer[0] = LOBYTE(m_sBlockLength);
	bBuffer[1] = HIBYTE(m_sBlockLength);
	bBuffer[2] = LOBYTE(m_sNextBlock);
	bBuffer[3] = HIBYTE(m_sNextBlock);

	m_pSymbolTable->WriteSymbolFile(m_sStartLoc, 4, bBuffer);
}



auto_ptr<CFreeBlock>
CFreeBlock::Next()
{
    auto_ptr<CFreeBlock> apNext((0 == m_sNextBlock)
                                ? 0
                                : new CFreeBlock(m_pSymbolTable,
                                                 m_sNextBlock));
    
    return  apNext;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\v1cert.h ===
// V1Cert.h: interface for the CV1Certificate class.
//
// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
//////////////////////////////////////////////////////////////////////

// Note:  This file should only be included by the CCI, not directly
// by the client.

#if !defined(SLBCCI_V1CERT_H)
#define SLBCCI_V1CERT_H

#include <string>
#include <memory>                                 // for auto_ptr

#include <slbRCObj.h>

#include "iop.h"
#include "slbarch.h"
#include "cciCard.h"
#include "ACert.h"

namespace cci {

class CV1Card;

class CV1Certificate
    : public CAbstractCertificate
{
public:
                                                  // Types
                                                  // C'tors/D'tors

    CV1Certificate(CV1Card const &rv1card,
                   KeySpec ks);

    virtual
    ~CV1Certificate() throw();

                                                  // Operators
                                                  // Operations

    void
    AssociateWith(KeySpec ks);

    virtual void
    CredentialID(std::string const &rstrCredId);

    virtual void
    ID(std::string const &rstrId);

    virtual void
    Issuer(std::string const &rstrIssuer);

    virtual void
    Label(std::string const &rstrLabel);

    static CV1Certificate *
    Make(CV1Card const &rv1card,
         KeySpec ks);

    virtual void
    Modifiable(bool flag);

    virtual void
    Subject(std::string const &rstrSubject);

    virtual void
    Serial(std::string const &rstrSerialNumber);

                                                  // Access
    virtual std::string
    CredentialID();

    virtual std::string
    ID();

    virtual std::string
    Issuer();

    virtual std::string
    Label();

    virtual bool
    Modifiable();

    virtual bool
    Private();

    virtual std::string
    Serial();

    virtual std::string
    Subject();

                                                  // Predicates

protected:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
    virtual void
    DoDelete();

    virtual void
    DoValue(ZipCapsule const &rzc);

                                                  // Access
    virtual ZipCapsule
    DoValue();

                                                  // Predicates
    virtual bool
    DoEquals(CAbstractCertificate const &rhs) const;

                                                  // Variables

private:
                                                  // Types
                                                  // C'tors/D'tors
    CV1Certificate(CV1Certificate const &rhs);
        // not defined, copying not allowed.

                                                  // Operators
    CV1Certificate &
    operator=(CV1Certificate const &rhs);
        // not defined, initialization not allowed.

                                                  // Operations

    void
    Store();

                                                  // Access
                                                  // Predicates
                                                  // Variables

    KeySpec m_ks;
    std::string m_sCertToStore;

};

}

#endif // !defined(SLBCCI_CERT_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\v1cont.cpp ===
// V1Cont.cpp: implementation of the CV1Container class.
//
// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
//////////////////////////////////////////////////////////////////////
#include "NoWarning.h"

#include <scuCast.h>

#include "slbCci.h"
#include "cciCard.h"
#include "TransactionWrap.h"

#include "V1ContRec.h"
#include "V1Cont.h"

using namespace std;
using namespace cci;

/////////////////////////// LOCAL/HELPER  /////////////////////////////////

///////////////////////////    PUBLIC     /////////////////////////////////

                                                  // Types
                                                  // C'tors/D'tors
CV1Container::CV1Container(CV1Card const &rv1card,
                           string const &rsCntrTag,
                           bool fCreateContainer)
    : SuperClass(rv1card)
{

    CV1ContainerRecord::CreateMode mode = fCreateContainer
        ? CV1ContainerRecord::cmAlways
        : CV1ContainerRecord::cmNoCheck;
    

    m_apcr =
        auto_ptr<CV1ContainerRecord>(new CV1ContainerRecord(rv1card,
                                                            rsCntrTag,
                                                            mode));
    
}

CV1Container::~CV1Container() throw()
{}


                                                  // Operators
                                                  // Operations

void
CV1Container::ID(string const &rstrID)
{
    throw Exception(ccNotImplemented);
}

CV1Container *
CV1Container::Make(CV1Card const &rv1card)
{
    CTransactionWrap wrap(rv1card);

    return new CV1Container(rv1card, CV1ContainerRecord::DefaultName(),
                            true);
}

void
CV1Container::Name(string const &rstrName)
{
    m_apcr->Name(rstrName);
}

                                                  // Access
string
CV1Container::ID()
{
    throw Exception(ccNotImplemented);

    return string();
}

string
CV1Container::Name()
{
    return m_apcr->Name();
}

CV1ContainerRecord &
CV1Container::Record() const
{
    return *m_apcr.get();
}

    
                                                  // Predicates
bool
CV1Container::Exists() const
{
    return m_apcr->Exists();
}

                                                  // Static Variables

///////////////////////////   PROTECTED   /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
void
CV1Container::DoDelete()
{
    m_hcard->InvalidateCache();                   // to forget the key pairs
    m_apcr->Delete();
}

                                                  // Access
                                                  // Predicates

bool
CV1Container::DoEquals(CAbstractContainer const &rhs) const
{
    return true; // there can only be one container
}

    
                                                  // Static Variables


///////////////////////////    PRIVATE    /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\v1card.cpp ===
// V1Card.cpp: implementation of the CV2Card class.
//
// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
//////////////////////////////////////////////////////////////////////
#include "NoWarning.h"

#include <algorithm>
#include <functional>

#include <memory>                                 // for auto_ptr

#include <scuArrayP.h>

#include <SmartCard.h>

#include "TransactionWrap.h"

#include "cciExc.h"
#include "MethodHelp.h"

#include "cciCert.h"
#include "cciKeyPair.h"
#include "cciPriKey.h"
#include "cciPubKey.h"

#include "V1Cert.h"
#include "V1Cont.h"
#include "V1ContRec.h"
#include "V1KeyPair.h"
#include "V1PriKey.h"
#include "V1PubKey.h"
#include "V1Paths.h"
#include "V1Card.h"

using namespace std;
using namespace cci;
using namespace scu;

/////////////////////////// LOCAL/HELPER  /////////////////////////////////

namespace
{
    // Enumerate T type objects in the exchange and signature key pair
    // using C::<Accessor> to get the T object, returning vector<T>
    // objects.
    template<class T>
    class EnumItems
        : std::unary_function<void, vector<T> >
    {
    public:
        EnumItems(CV1Card const &rv1card,
                  ObjectAccess oa,
                  typename AccessorMethod<T, CAbstractKeyPair>::AccessorPtr Accessor)
            : m_rv1card(rv1card),
              m_oa(oa),
              m_matAccess(Accessor),
              m_Result()
        {}

        result_type
        operator()(argument_type)
        {
            DoAppend(m_rv1card.DefaultContainer());
            return m_Result;
        }

    protected:
        void
        DoAppend(CContainer &rhcntr)
        {
            if (rhcntr)
            {
                AppendItem(rhcntr->ExchangeKeyPair());
                AppendItem(rhcntr->SignatureKeyPair());
            }
        }

    private:
        void
        AppendItem(CKeyPair &rhkp)
        {
            if (rhkp)
            {
                T hObject(m_matAccess(*rhkp));
                if (hObject && (m_oa == hObject->Access()))
                    m_Result.push_back(hObject);
            }
        }
        
        CV1Card const &m_rv1card;
        ObjectAccess m_oa;
        MemberAccessorType<T, CAbstractKeyPair> m_matAccess;
        result_type m_Result;
    };
    
    bool
    IsSupported(iop::CSmartCard &rSmartCard) throw()
    {
        bool fSupported = false;

        try
        {
            rSmartCard.Select(CV1Paths::Chv());
            rSmartCard.Select(CV1Paths::IcFile());
            rSmartCard.Select(CV1Paths::RootContainers());
            rSmartCard.Select(CV1Paths::PrivateKeys());
            rSmartCard.Select(CV1Paths::PublicKeys());

            fSupported = true;
        }

        catch(scu::Exception &)
        {}

        return fSupported;
    }

} // namespace

    
///////////////////////////    PUBLIC     /////////////////////////////////

                                                  // Types
                                                  // C'tors/D'tors
CV1Card::~CV1Card() throw()
{}


                                                  // Operators
                                                  // Operations

void
CV1Card::CardId(string const &rsNewCardId) const
{
    CTransactionWrap(this);
    
    DWORD dwLen = OpenFile(CV1Paths::IcFile());

    if (0 == dwLen)
        throw scu::OsException(NTE_FAIL);

    if (rsNewCardId.length() > dwLen)
        throw scu::OsException(ERROR_INVALID_PARAMETER);

    if (rsNewCardId.length() < dwLen)
        SmartCard().WriteBinary(0, rsNewCardId.length() + 1,
                                reinterpret_cast<BYTE const *>(rsNewCardId.c_str()));
    else
        SmartCard().WriteBinary(0,
								static_cast<WORD>(rsNewCardId.length()),
                                reinterpret_cast<BYTE const *>(rsNewCardId.data()));
    
    RefreshCardId();

}

void
CV1Card::ChangePIN(SecureArray<BYTE> const &rstrOldPIN,
                   SecureArray<BYTE> const &rstrNewPIN)
{
	CTransactionWrap wrap(this);	
	SmartCard().Select(CV1Paths::Root());
    SuperClass::ChangePIN(rstrOldPIN, rstrNewPIN);
}

void
CV1Card::DefaultContainer(CContainer const &rcont)
{
    m_avhDefaultCntr.Value(rcont);
    if(!m_avhDefaultCntr.Value())
        m_avhDefaultCntr.Dirty();        
    // Nothing more to do since, by definition, the one and only
    // container is already the default container.
}

pair<string, // interpreted as the public modulus
     CPrivateKey>
CV1Card::GenerateKeyPair(KeyType kt,
                         string const &rsExponent,
                         ObjectAccess oaPrivateKey)
{
    throw Exception(ccNotImplemented);

    return pair<string, CPrivateKey>();
}

void
CV1Card::InitCard()
{
	// We want to select /3f00/0015 (length 1744) and /3f00/3f11/0015 (length 300), and clear both files.
	CTransactionWrap wrap(this);
	BYTE bData[1744];
	memset(bData, 0, 1744);

	SmartCard().Select(CV1Paths::RootContainers());
	SmartCard().WriteBinary(0x0000, 0x06d0, bData); 
	SmartCard().Select(CV1Paths::PublicKeys());
	SmartCard().WriteBinary(0x0000, 0x012c, bData);

}

void
CV1Card::InvalidateCache()
{
    m_avhDefaultCntr.Value(CContainer());
    m_avhDefaultCntr.Dirty();
    
    m_avhExchangeKeyPair.Value(CKeyPair());
    m_avhExchangeKeyPair.Dirty();

    m_avhSignatureKeyPair.Value(CKeyPair());
    m_avhSignatureKeyPair.Dirty();
}

void
CV1Card::Label(string const &rLabel)
{
    throw Exception(ccNotImplemented);
}

DWORD
CV1Card::OpenFile(char const *szPath) const
{
    iop::FILE_HEADER fh;
    
    SmartCard().Select(szPath, &fh);

    return fh.file_size;
}

void
CV1Card::VerifyKey(string const &rstrKey,
                     BYTE bKeyNum)
{
	CTransactionWrap wrap(this);
	SmartCard().Select(CV1Paths::CryptoSys());
    SuperClass::VerifyKey(rstrKey, bKeyNum);
}


                                                  // Access
size_t
CV1Card::AvailableStringSpace(ObjectAccess oa) const
{
    throw Exception(ccNotImplemented);

    return 0;
}

string
CV1Card::CardId() const
{
    return m_sCardId;
}

CContainer
CV1Card::DefaultContainer() const
{
    CTransactionWrap wrap(this);
    
    if (!m_avhDefaultCntr.IsCached())
    {
        auto_ptr<CV1Container> apv1cntr(new CV1Container(*this,
                                                         CV1ContainerRecord::DefaultName(),
                                                         false));
        if (apv1cntr->Exists())
        {
            CContainer hcntr;
            hcntr = CContainer(apv1cntr.get());
            apv1cntr.release();
            m_avhDefaultCntr.Value(hcntr);
        }
    }
    
    return m_avhDefaultCntr.Value();
}

vector<CContainer>
CV1Card::EnumContainers() const
{
    CContainer hcntr(0);
    auto_ptr<CV1Container> apv1cntr(new CV1Container(*this,
                                                     CV1ContainerRecord::DefaultName(),
                                                     false));
    if (apv1cntr->Exists())
    {
        hcntr = CContainer(apv1cntr.get());
        apv1cntr.release();
    }
    vector<CContainer> vhcntr;
    if (hcntr)
        vhcntr.push_back(hcntr);

    return vhcntr;
}

vector<CCertificate>
CV1Card::EnumCertificates(ObjectAccess access) const
{
	CTransactionWrap wrap(this);

    EnumItems<CCertificate> Enumerator(*this, access,
                                       CAbstractKeyPair::Certificate);
        
    return Enumerator();
}

vector<CPublicKey>
CV1Card::EnumPublicKeys(ObjectAccess access) const
{
	CTransactionWrap wrap(this);

    EnumItems<CPublicKey> Enumerator(*this, access,
                                     CAbstractKeyPair::PublicKey);

    return Enumerator();
}

vector<CPrivateKey>
CV1Card::EnumPrivateKeys(ObjectAccess access) const
{
	CTransactionWrap wrap(this);

    EnumItems<CPrivateKey> Enumerator(*this, access,
                                      CAbstractKeyPair::PrivateKey);

    return Enumerator();
}

vector<CDataObject>
CV1Card::EnumDataObjects(ObjectAccess access) const
{
    return vector<CDataObject>(); // can never have data objects
}

string
CV1Card::Label() const
{
    throw Exception(ccNotImplemented);

    return string();
}
 
CAbstractCertificate *
CV1Card::MakeCertificate(ObjectAccess oa) const
{
    CTransactionWrap wrap(this);

    if (oaPublicAccess != oa)
        throw Exception(ccInvalidParameter);
    
    return new CV1Certificate(*this, ksNone);
}

CAbstractContainer *
CV1Card::MakeContainer() const
{
    CTransactionWrap wrap(this);

    return new CV1Container(*this,
                            CV1ContainerRecord::DefaultName(), true);
}

CAbstractDataObject *
CV1Card::MakeDataObject(ObjectAccess oa) const
{
    throw Exception(ccNotImplemented);

    return 0;
}

CAbstractKeyPair *
CV1Card::MakeKeyPair(CContainer const &rhcont,
                     KeySpec ks) const
{
    CTransactionWrap wrap(this);

    // If the key pair is cached, return it; otherwise make a new one
    // and cache it.
	CArchivedValue<CKeyPair> *pavhkp = 0;
    switch (ks)
    {
    case ksExchange:
        pavhkp = &m_avhExchangeKeyPair;
        break;

    case ksSignature:
        pavhkp = &m_avhSignatureKeyPair;
        break;

    default:
        throw Exception(ccBadKeySpec);
        break;
    }
    
    if (!pavhkp->IsCached() || !pavhkp->Value())
        pavhkp->Value(CKeyPair(new CV1KeyPair(*this, rhcont, ks)));

    return pavhkp->Value().operator->();           // yuk!
}

CAbstractPrivateKey *
CV1Card::MakePrivateKey(ObjectAccess oa) const
{
    CTransactionWrap wrap(this);

    if (oaPrivateAccess != oa)
        throw Exception(ccInvalidParameter);
    
    return new CV1PrivateKey(*this, ksNone);
}

CAbstractPublicKey *
CV1Card::MakePublicKey(ObjectAccess oa) const
{
    CTransactionWrap wrap(this);

    if (oaPublicAccess != oa)
        throw Exception(ccInvalidParameter);
    
    return new CV1PublicKey(*this, ksNone);
}

BYTE
CV1Card::MaxKeys(KeyType kt) const
{
    BYTE bCount;
    
    switch (kt)
    {
    case ktRSA1024:
        bCount = 2;
        break;

    default:
        bCount = 0;
        break;
    }
    
    return bCount;
}

size_t
CV1Card::MaxStringSpace(ObjectAccess oa) const
{
    throw Exception(ccNotImplemented);

    return 0;
}

bool
CV1Card::SupportedKeyFunction(KeyType kt,
                              CardOperation oper) const
{
    bool fSupported = false;
    
    switch (oper)
    {
    case coEncryption:    // .. or public key operations
        break;

    case coDecryption:    // .. or private key operations
        switch (kt)
        {
        
        case ktRSA1024:
            fSupported = true;
            break;
        
        default:
            break;
        }

    default:
        break;
    }

    return fSupported;
}

scu::Marker<unsigned int>
CV1Card::MarkerOnCard() const
{
    return scu::Marker<unsigned int>();
}
                                                  // Predicates
bool
CV1Card::IsCAPIEnabled() const
{
    return true;
}

bool
CV1Card::IsPKCS11Enabled() const
{
    return false;
}

bool
CV1Card::IsProtectedMode() const
{
    return true;
}

bool
CV1Card::IsKeyGenEnabled() const
{
	return false;
}

bool
CV1Card::IsEntrustEnabled() const
{
    return false;
}

BYTE 
CV1Card::MajorVersion() const
{
	return (BYTE)0;
}

bool 
CV1Card::IsMarkerOnCard() const
{
    return false;
}

                                                  // Static Variables

///////////////////////////   PROTECTED   /////////////////////////////////

                                                  // C'tors/D'tors
CV1Card::CV1Card(string const &rstrReaderName,
                 auto_ptr<iop::CIOP> &rapiop,
                 auto_ptr<iop::CSmartCard> &rapSmartCard)
    : SuperClass(rstrReaderName, rapiop, rapSmartCard),
      m_sCardId(),
      m_avhDefaultCntr(),
      m_avhExchangeKeyPair(),
      m_avhSignatureKeyPair()
{}

                                                  // Operators
                                                  // Operations
void
CV1Card::DoSetup()
{
    CAbstractCard::DoSetup();

    RefreshCardId();
}

                                                  // Access
                                                  // Predicates
                                                  // Static Variables


///////////////////////////    PRIVATE    /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations

auto_ptr<CAbstractCard>
CV1Card::DoMake(string const &rstrReaderName,
                auto_ptr<iop::CIOP> &rapiop,
                auto_ptr<iop::CSmartCard> &rapSmartCard)
{
    return IsSupported(*rapSmartCard.get())
        ? auto_ptr<CAbstractCard>(new CV1Card(rstrReaderName, rapiop,
                                              rapSmartCard))
        : auto_ptr<CAbstractCard>(0);
}

string
CV1Card::ReadCardId() const
{
    string sCardId;
    
    // *** BEGIN WORKAROUND ***
    // The following SetContext and OpenFile call is made to
    // make sure the card and this system's current path are
    // synchronized, pointing to the right directory.  Without
    // it, the subsequent call to ReadBinaryFile fails because
    // they appear to be out of synch.  It's not clear why
    // this happens but this workaround avoids the problem.
    try
    {
        SmartCard().Select(CV1Paths::RootContainers());
    }

    catch (...)
    {
    }
    // *** END WORKAROUND ***

    try
    {
        iop::FILE_HEADER fh;
        SmartCard().Select(CV1Paths::IcFile(), &fh);

        DWORD dwLen = fh.file_size;
        scu::AutoArrayPtr<BYTE> aaCardId(new BYTE[dwLen + 1]);
        SmartCard().ReadBinary(0, dwLen, aaCardId.Get());
		aaCardId[dwLen] = '\0';
        sCardId.assign(reinterpret_cast<char *>(aaCardId.Get()));
    }

    catch (...)
    {
    }

    return sCardId;
}

void
CV1Card::RefreshCardId() const
{
    m_sCardId = ReadCardId();
}

    
                                                  // Access
                                                  // Predicates
                                                  // Static Variables
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\v1cert.cpp ===
// CV1Cert.cpp: implementation of the CV1Certificate class.
//
// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
//////////////////////////////////////////////////////////////////////
#include "NoWarning.h"

#include <scuCast.h>

#include <iopPubBlob.h>

#include "slbCci.h"                               // for KeySpec
#include "cciExc.h"
#include "cciCard.h"
#include "TransactionWrap.h"

#include "V1Cert.h"
#include "V1ContRec.h"

using namespace std;
using namespace cci;
using namespace iop;

/////////////////////////// LOCAL/HELPER  /////////////////////////////////

///////////////////////////    PUBLIC     /////////////////////////////////

                                                  // Types
                                                  // C'tors/D'tors

CV1Certificate::CV1Certificate(CV1Card const &rv1card,
                               KeySpec ks)
    : CAbstractCertificate(rv1card, oaPublicAccess, true),
      m_ks(ks),
      m_sCertToStore()
{}

CV1Certificate::~CV1Certificate() throw()
{}

                                                  // Operators
                                                  // Operations

void
CV1Certificate::AssociateWith(KeySpec ks)
{
    CTransactionWrap wrap(m_hcard);
    
    m_ks = ks;

    Store();
}

void
CV1Certificate::CredentialID(string const &rstrCredID)
{
    throw Exception(ccNotImplemented);
}

void
CV1Certificate::ID(string const &rstrId)
{
    throw Exception(ccNotImplemented);
}


void
CV1Certificate::Issuer(string const &rstrIssuer)
{
    throw Exception(ccNotImplemented);
}

void
CV1Certificate::Label(string const &rstrLabel)
{
    throw Exception(ccNotImplemented);
}

CV1Certificate *
CV1Certificate::Make(CV1Card const &rv1card,
                     KeySpec ks)
{
    return new CV1Certificate(rv1card, ks);
}

void
CV1Certificate::Subject(string const &rstrSubject)
{
    throw Exception(ccNotImplemented);
}

void
CV1Certificate::Modifiable(bool flag)
{
    throw Exception(ccNotImplemented);
}

void
CV1Certificate::Serial(string const &rstrSerialNumber)
{
    throw Exception(ccNotImplemented);
}


                                                  // Access
string
CV1Certificate::CredentialID()
{
    throw Exception(ccNotImplemented);

    return string();
}

string
CV1Certificate::ID()
{
    throw Exception(ccNotImplemented);

    return string();
}

string
CV1Certificate::Issuer()
{
    throw Exception(ccNotImplemented);

    return string();
}

string
CV1Certificate::Label()
{
    throw Exception(ccNotImplemented);

    return string();
}

bool
CV1Certificate::Modifiable()
{
    throw Exception(ccNotImplemented);

    return false;
}

bool
CV1Certificate::Private()
{
    return false;
}

string
CV1Certificate::Serial()
{
    throw Exception(ccNotImplemented);

    return string();
}

string
CV1Certificate::Subject()
{
    throw Exception(ccNotImplemented);

    return string();
}


                                                  // Predicates
                                                  // Static Variables

///////////////////////////   PROTECTED   /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations

void
CV1Certificate::DoDelete()
{
    if (ksNone != m_ks)
    {
        m_sCertToStore.erase();
        Store();
    }
}

void
CV1Certificate::DoValue(ZipCapsule const &rzc)
{
    m_sCertToStore = rzc.Data();

    if (ksNone != m_ks)
        Store();
}

                                                  // Access
CV1Certificate::ZipCapsule
CV1Certificate::DoValue()
{
    CV1Card &rv1card = scu::DownCast<CV1Card &, CAbstractCard &>(*m_hcard);
    CV1ContainerRecord CertRec(rv1card,
                               CV1ContainerRecord::CertName(),
                               CV1ContainerRecord::cmConditionally);

    if (ksNone == m_ks)
        throw Exception(ccInvalidParameter);
    
    string sCompressedCert;
    CertRec.Read(m_ks, sCompressedCert);

	return ZipCapsule(sCompressedCert, true);
}
                                                  // Predicates

bool
CV1Certificate::DoEquals(CAbstractCertificate const &rhs) const
{
    CV1Certificate const &rv1rhs =
        scu::DownCast<CV1Certificate const &, CAbstractCertificate const &>(rhs);

    return rv1rhs.m_ks == m_ks;
}

                                                  // Static Variables


///////////////////////////    PRIVATE    /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
void
CV1Certificate::Store()
{
    if (ksNone != m_ks)
    {
        CV1Card &rv1card =
            scu::DownCast<CV1Card &, CAbstractCard &>(*m_hcard);
        CV1ContainerRecord CertRec(rv1card,
                                   CV1ContainerRecord::CertName(),
                                   CV1ContainerRecord::cmConditionally);

        CertRec.Write(m_ks, m_sCertToStore);
    }
    else
        throw Exception(ccInvalidParameter);
}

                                                  // Access
                                                  // Predicates
                                                  // Static Variables
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\v1cont.h ===
// V1Cont.h: interface for the CV1Container class.
//
// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
//////////////////////////////////////////////////////////////////////

// Note:  This file should only be included by the CCI, not directly
// by the client.

#if !defined(SLBCCI_V1CONT_H)
#define SLBCCI_V1CONT_H

#include <string>
#include <memory>                                 // for auto_ptr

#include "slbCci.h"
#include "cciCard.h"
#include "ACont.h"

namespace cci
{

class CV1Card;
class CV1ContainerRecord;

class CV1Container
    : public CAbstractContainer
{
public:
                                                  // Types
                                                  // C'tors/D'tors

    explicit
    CV1Container(CV1Card const &rv1card,
                 std::string const &rsCntrTag,
                 bool fCreateContainer);

    virtual
    ~CV1Container() throw();

                                                  // Operators
                                                  // Operations

    virtual void
    ID(std::string const &rstrID);

    static CV1Container *
    Make(CV1Card const &rv1card);

    virtual void
    Name(std::string const &rstrName);


                                                  // Access

    virtual std::string
    ID();

    virtual std::string
    Name();

    CV1ContainerRecord &
    Record() const;

                                                  // Predicates

    bool
    Exists() const;


protected:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations

    virtual void
    DoDelete();

                                                   // Access
                                                  // Predicates

    bool
    DoEquals(CAbstractContainer const &rhs) const;

                                                  // Variables

private:
                                                  // Types

    typedef CAbstractContainer SuperClass;
                                                  // C'tors/D'tors

    CV1Container(CV1Container const &rhs);
        // not defined, copying not allowed.

                                                  // Operators

    CV1Container &
    operator=(CV1Container const &rhs);
        // not defined, initialization not allowed.

                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables

    std::auto_ptr<CV1ContainerRecord> m_apcr;

};

} // namespace cci

#endif // !defined(SLBCCI_V1CONT_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\v1card.h ===
// cciV1Card.h: interface for the CV1Card class.
//
// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
//////////////////////////////////////////////////////////////////////

// Note: This header file should only be included by the CCI.  The
// client gets the declarations via cciCard.h

#if !defined(CCI_V1CARD_H)
#define CCI_V1CARD_H

#include <memory>                                 // for auto_ptr
#include <string>
#include <vector>

#include <iop.h>

#include <slbRCObj.h>

#include "ACard.h"
#include "cciCont.h"
#include "cciCert.h"
#include "cciKeyPair.h"
#include "cciPubKey.h"
#include "cciPriKey.h"
#include "cciDataObj.h"
#include "ArchivedValue.h"

namespace cci
{

class CV1Card                                     // concrete class
    : public CAbstractCard
{
    friend CAbstractCard *
    CAbstractCard::Make(std::string const &rstrReaderName);

public:
                                                  // Types
                                                  // C'tors/D'tors

    virtual
    ~CV1Card() throw();

                                                  // Operators
                                                  // Operations

    void
    CardId(std::string const &rsNewCardId) const;

    virtual void
    ChangePIN(scu::SecureArray<BYTE> const &rstrOldPIN,
              scu::SecureArray<BYTE> const &rstrNewPIN);

    virtual void
    DefaultContainer(CContainer const &rcont);

    virtual std::pair<std::string, // interpreted as the public modulus
                      CPrivateKey>
    GenerateKeyPair(KeyType kt,
                    std::string const &rsExponent,
                    ObjectAccess oaPrivateKey = oaPrivateAccess);

    virtual void
    InitCard();

    virtual void
    InvalidateCache();

    virtual void
    Label(std::string const &rstrLabel);

    DWORD
    OpenFile(char const *szPath) const;

    virtual void
    VerifyKey(std::string const &rstrKey,
              BYTE bKeyNum);

                                                  // Access

    size_t
    AvailableStringSpace(ObjectAccess oa) const;

    std::string
    CardId() const;

    virtual CContainer
    DefaultContainer() const;

    virtual std::vector<CContainer>
    EnumContainers() const;

    virtual std::vector<CCertificate>
    EnumCertificates(ObjectAccess access) const;

    virtual std::vector<CPublicKey>
    EnumPublicKeys(ObjectAccess access) const;

    virtual std::vector<CPrivateKey>
    EnumPrivateKeys(ObjectAccess access) const;

    virtual std::vector<CDataObject>
    EnumDataObjects(ObjectAccess access) const;

    virtual std::string
    Label() const;

    BYTE
    MaxKeys(KeyType kt) const;

    size_t
    MaxStringSpace(ObjectAccess oa) const;

    virtual bool
    SupportedKeyFunction(KeyType kt,
                         CardOperation oper) const;
    virtual scu::Marker<unsigned int>
    MarkerOnCard() const;

                                                  // Predicates

    virtual bool
    IsCAPIEnabled() const;

    virtual bool
    IsPKCS11Enabled() const;

    virtual bool
    IsEntrustEnabled() const;

    virtual bool
    IsProtectedMode() const;

    virtual bool
    IsKeyGenEnabled() const;
    
    virtual BYTE
    MajorVersion() const;
    
    virtual bool
    IsMarkerOnCard() const;
    


protected:
                                                  // Types
                                                  // C'tors/D'tors

    CV1Card(std::string const &rstrReaderName,
            std::auto_ptr<iop::CIOP> &rapiop,
            std::auto_ptr<iop::CSmartCard> &rapSmartCard);

                                                  // Operators
                                                  // Operations
    void
    DoSetup();

    virtual CAbstractCertificate *
    MakeCertificate(ObjectAccess oa) const;

    virtual CAbstractContainer *
    MakeContainer() const;

    virtual CAbstractDataObject *
    MakeDataObject(ObjectAccess oa) const;

    virtual CAbstractKeyPair *
    MakeKeyPair(CContainer const &rhcont,
                KeySpec ks) const;

    virtual CAbstractPrivateKey *
    MakePrivateKey(ObjectAccess oa) const;

    virtual CAbstractPublicKey *
    MakePublicKey(ObjectAccess oa) const;

                                                  // Access
                                                  // Predicates
                                                  // Variables

private:
                                                  // Types

    typedef CAbstractCard SuperClass;

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations

    static std::auto_ptr<CAbstractCard>
    DoMake(std::string const &rstrReaderName,
           std::auto_ptr<iop::CIOP> &rapiop,
           std::auto_ptr<iop::CSmartCard> &rapSmartCard);

    std::string
    ReadCardId() const;

    void
    RefreshCardId() const;

                                                  // Access
                                                  // Predicates
                                                  // Variables

    std::string mutable m_sCardId;
    CArchivedValue<CContainer> mutable m_avhDefaultCntr;
    CArchivedValue<CKeyPair> mutable m_avhExchangeKeyPair;
    CArchivedValue<CKeyPair> mutable m_avhSignatureKeyPair;

};

} // namespace cci

#endif // CCI_CV1CARD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\v1contrec.cpp ===
// V1ContRec.cpp -- definition of CV1ContainerRecord

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 2000. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
//////////////////////////////////////////////////////////////////////
#include "NoWarning.h"

#include <scuArrayP.h>

#include <slbCrc32.h>

#include <iopPubBlob.h>
#include <SmartCard.h>

#include "TransactionWrap.h"

#include "V1Paths.h"
#include "V1Card.h"
#include "V1ContRec.h"

using namespace std;
using namespace scu;
using namespace cci;
using namespace iop;

/////////////////////////// LOCAL/HELPER  /////////////////////////////////
namespace
{

    enum                                          // KeyId in card
    {
        kidExchange  = 0x00,
        kidSignature = 0x01,
        kidNone      = 0xFF
    };

    TCHAR const
        szCachedCertSignature[] = TEXT("CERTSI");

    TCHAR const
        szCachedCertExchange[] = TEXT("CERTEX");

    TCHAR const
        szCachedPublicKeySignature[] = TEXT("PUBKSI");

    TCHAR const
        szCachedPublicKeyExchange[] = TEXT("PUBKEX");


    BYTE
    AsKeyId(KeySpec ks)
    {
        BYTE kid;

        switch (ks)
        {
        case ksExchange:
            kid = kidExchange;
            break;

        case ksSignature:
            kid = kidSignature;
            break;

        default:
            throw cci::Exception(cci::ccBadKeySpec);
        }

        return kid;
    }

} // namespace

///////////////////////////    PUBLIC     /////////////////////////////////

                                                  // Types
                                                  // C'tors/D'tors
CV1ContainerRecord::CV1ContainerRecord(CV1Card const &rv1card,
                                       string const &rsCntrType,
                                       CreateMode mode)
    : m_rcard(rv1card),
      m_sCntrType(rsCntrType),
      m_szKeyPath(0)
{
    m_szKeyPath = IsDefault()
        ? CV1Paths::DefaultKey()
        : CV1Paths::DefaultContainer();

    switch (mode)
    {
    case cmNever:
        if (!Exists())
            throw Exception(ccInvalidParameter);
        break;

    case cmConditionally:
        if (!Exists())
            Create();
        break;

    case cmAlways:
        if (!Exists())
            Create();
        else
            throw Exception(ccOutOfSymbolTableEntries);
        break;

    case cmNoCheck:
        break;

    default:
        throw Exception(ccInvalidParameter);
        break;
    }
}

CV1ContainerRecord::~CV1ContainerRecord()
{}

                                                  // Operators
                                                  // Operations

string
CV1ContainerRecord::ComputeSignature(KeySpec ks,
                                     string const &rsCipher) const
{
    CTransactionWrap wrap(m_rcard);

    m_rcard.SmartCard().Select(m_szKeyPath);

    AutoArrayPtr<BYTE> aabBuffer(new BYTE[rsCipher.length()]);
    m_rcard.SmartCard().InternalAuth(ktRSA1024,
                                     AsKeyId(ks),
                                     static_cast<BYTE>(rsCipher.length()),
                                     reinterpret_cast<BYTE const *>(rsCipher.data()),
                                     aabBuffer.Get());

    return string(reinterpret_cast<char *>(aabBuffer.Get()),
                  rsCipher.length());
}

void
CV1ContainerRecord::Delete() const
{
    CTransactionWrap wrap(m_rcard);

//     if (IsEmpty())
//         throw scu::OsException(NTE_BAD_KEYSET_PARAM);

    // Open the container file and find the offset of the container
    DWORD dwFileSize = OpenContainer();

    DWORD dwOffset = 0x00;
    DWORD dwLen = FindOffset(dwOffset);

    // Actually check the existence of key container
    if (sizeof ContainerBuffer > dwLen)
        throw scu::OsException(NTE_BAD_KEYSET);

        // Intialize search variables
    DWORD dwNext = dwOffset + dwLen;

    // Get following ContainerBuffer
    ContainerBuffer container;
    GetContainer(dwNext, container);
    dwLen = container.Size;

    // Move all following blocks up to deleted block position
    while (sizeof container <= dwLen)
    {
        basic_string<BYTE> bsBuffer(reinterpret_cast<BYTE *>(&container),
                                    sizeof container);

        WORD cPublicKeysLength = dwLen - sizeof container;
        AutoArrayPtr<BYTE> aabPublicKeys(new BYTE[cPublicKeysLength]);
        if (cPublicKeysLength > 0)
        {
            m_rcard.SmartCard().ReadBinary(dwNext + sizeof container,
                                           cPublicKeysLength,
                                           aabPublicKeys.Get());
        }
        bsBuffer.append(aabPublicKeys.Get(), cPublicKeysLength);

        m_rcard.SmartCard().WriteBinary(dwOffset,
                                        static_cast<WORD>(bsBuffer.length()),
                                        bsBuffer.data());

        dwOffset += dwLen;
        dwNext += dwLen;

        GetContainer(dwNext, container);
        dwLen = container.Size;
    }; // end while loop

    // NO MORE CONTAINERS TO MOVE UP

    // if there is still room put 2 null bytes of termination
    const BYTE  NullSize[]= {0x00, 0x00};
    if ((dwOffset + 2) <= dwFileSize)
        m_rcard.SmartCard().WriteBinary(dwOffset, 2, NullSize);

}

void
CV1ContainerRecord::Name(string const &rsNewName)
{
    m_rcard.CardId(rsNewName);
}

void
CV1ContainerRecord::Read(KeySpec ks,
                         CPublicKeyBlob &rKeyBlob) const
{
    CTransactionWrap wrap(m_rcard);

    if ((ksSignature != ks) && (ksExchange != ks))
        throw Exception(ccBadKeySpec);

    string sBuffer;
    DWORD dwExponent;
    if (GetContainerContent(ks, sBuffer, dwExponent))
    {
        CopyMemory(rKeyBlob.bModulus, sBuffer.data(),
                   sBuffer.length());
        rKeyBlob.bModulusLength = static_cast<BYTE>(sBuffer.length());
        *reinterpret_cast<DWORD *>(rKeyBlob.bExponent) =
            dwExponent;
    }
    else
        rKeyBlob.bModulusLength = 0;
}

void
CV1ContainerRecord::Read(KeySpec ks,
                         string &rsBlob) const
{
    CTransactionWrap wrap(m_rcard);

    DWORD dwOriginalCrc = 0;

    // Get blob from the container
    if (!GetContainerContent(ks,
                             rsBlob,
                             dwOriginalCrc))
        throw Exception(ccNoCertificate);

    // If a non-zero CRC exists, then verify integrity of the
    // compressed certificate by comparing the CRC read
    // (original) against a test one generated using the
    // compressed certificate read.  If the CRCs aren't equal,
    // then the certificate is corrupted and it shouldn't be
    // decompressed because the decompress routine may go into
    // an infinite loop or otherwise fail badly without
    // notification.  If the original CRC is zero, then a CRC
    // wasn't performed so for backward compatibility with
    // earlier versions the decompression is taken with the
    // inherent risk.
    if (0 != dwOriginalCrc)
    {
        DWORD dwTestCrc = Crc32(rsBlob.data(), rsBlob.length());

        if (dwTestCrc != dwOriginalCrc)
            throw Exception(ccSymbolDataCorrupted);
    }
}

void
CV1ContainerRecord::Write(KeySpec ks,
                          CPrivateKeyBlob const &rKeyBlob)
{
    CTransactionWrap wrap(m_rcard);

    m_rcard.SmartCard().Select(CV1Paths::PrivateKeys());

    // Make sure that previous key blocks exists in Secret Key file
    // or at least the header of the block exists
    // in order for the Card OS to be able to retrieve the key
    // that is added in this procedure:
    // Write the header of previous keys

    WORD const wPrivateKeyBlockSize = 323;
    // inversion necessary for PRIVATE KEY BLOC SIZE
    WORD wBSize  = (wPrivateKeyBlockSize >> 8) & 0x00FF;
    wBSize += (wPrivateKeyBlockSize << 8) & 0x00FF00;

    BYTE bId;
    DWORD dwOffset;
    BYTE bKeyId = AsKeyId(ks);
    for (dwOffset = 0x00, bId = 0;
         bId < bKeyId;
         bId++, dwOffset += wPrivateKeyBlockSize)
    {
        BYTE Header[3];
        CopyMemory(Header, &wBSize, sizeof WORD);
        Header[2] = bId + 1;
        m_rcard.SmartCard().WriteBinary(dwOffset, 3, Header);
    }

    m_rcard.SmartCard().WritePrivateKey(rKeyBlob, bKeyId);

}

void
CV1ContainerRecord::Write(KeySpec ks,
                          CPublicKeyBlob const &rKeyBlob)
{
    CTransactionWrap wrap(m_rcard);

    DWORD dwExponent = *(reinterpret_cast<DWORD const *>(rKeyBlob.bExponent));
    Write(ks, reinterpret_cast<BYTE const *>(rKeyBlob.bModulus),
          rKeyBlob.bModulusLength, dwExponent);

}

void
CV1ContainerRecord::Write(KeySpec ks,
                          string const &rsBlob) const
{
    CTransactionWrap wrap(m_rcard);

    // Calculate the CRC to verify when reading reading the
    // blob back.
    DWORD dwCrc = 0;
    if (rsBlob.length())
        dwCrc = Crc32(rsBlob.data(), rsBlob.length());

    Write(ks, reinterpret_cast<BYTE const *>(rsBlob.data()),
          static_cast<WORD>(rsBlob.length()), dwCrc);
}

                                                  // Access

string
CV1ContainerRecord::CertName()
{
    static string const sCertContainerName("CERT");

    return sCertContainerName;
}

string
CV1ContainerRecord::DefaultName()
{
    static string const sDefaultName("USER");

    return sDefaultName;
}

string
CV1ContainerRecord::Name() const
{
    return m_rcard.CardId();
}

                                                  // Predicates
bool
CV1ContainerRecord::Exists() const
{
    CTransactionWrap wrap(m_rcard);

    DWORD dwLen = 0;

    try
    {
        if (m_rcard.CardId() == m_sCntrType)
            return true;

        DWORD dwOffset = 0x00;
        dwLen = FindOffset(dwOffset);
    }

    catch (iop::CSmartCard::Exception &)
    {
    }

    return (sizeof ContainerBuffer <= dwLen);

}

bool
CV1ContainerRecord::KeyExists(KeySpec ks) const
{
    CTransactionWrap wrap(m_rcard);

    bool fExists = false;

    //
    // Does a key of this type exist in this container?
    // Note: assumes that m_KeyPath is set to correct container path?
    //

    // Open the container file
    DWORD dwFileSize = OpenContainer();

    DWORD dwOffset = 0x00;
    DWORD const dwLen = FindOffset(dwOffset);

    //
    // Actually check the existence of key container
    // by seeing if we have a record of the right size
    //
    ContainerBuffer container;
    if (sizeof container <= dwLen)
    {
        GetContainer(dwOffset, container);

        //
        // Check which key exists by checking lengths
        //
        switch (ks)
        {
        case ksExchange:
            if (0x00 < container.XK_wLen)
                fExists = true;
            break;
        case ksSignature:
            if (0x00 < container.SK_wLen)
                fExists = true;
            break;
        }
    }

    return fExists;

}


                                                  // Static Variables

///////////////////////////   PROTECTED   /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables


///////////////////////////    PRIVATE    /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations

void
CV1ContainerRecord::Create() const
{
    // Open the file and find the offset to the container
    DWORD dwFileSize = OpenContainer();

    DWORD dwOffset = 0x00;
    DWORD dwLen = FindOffset(dwOffset);

    // Actually check the existence of key container
    if (sizeof ContainerBuffer <= dwLen)
        throw scu::OsException(NTE_EXISTS);

    // Set the new the container management data
    dwLen = SetContainer(dwOffset);

    // if there is still room put 2 null bytes of termination
    if ((dwOffset + dwLen + 2) <= dwFileSize)
    {
        const BYTE NullSize[] = { 0x00, 0x00 };
        m_rcard.SmartCard().WriteBinary(dwOffset + dwLen,
                                        sizeof NullSize, NullSize);
    }
}

DWORD
CV1ContainerRecord::FindOffset(DWORD &rdwOffset) const
{
    DWORD dwFileSize = OpenContainer();

    if ((rdwOffset + sizeof ContainerBuffer) > dwFileSize)
        return 0x00;

    bool fFound = false;
    DWORD dwLen = sizeof ContainerBuffer; // arbitrary value to start
    size_t const cBufferSize =
        sizeof WORD + (sizeof BYTE *
                       ContainerBuffer::cMaxContainerNameLength) + 1;
        // +1 allows null terminator
    AutoArrayPtr<BYTE> aabBuffer(new BYTE[cBufferSize]);
    while (!fFound &&
           (0x00 < dwLen) &&
           ((rdwOffset + sizeof ContainerBuffer) <= dwFileSize))
    {
        m_rcard.SmartCard().ReadBinary(rdwOffset,
                                       cBufferSize - 1,
                                       aabBuffer.Get());

        WORD const *pwLen = reinterpret_cast<WORD *>(aabBuffer.Get());
        dwLen = *pwLen;

        aabBuffer[cBufferSize - 1] = 0x00; // ensure null terminate string
        string sName(reinterpret_cast<char *>(&aabBuffer[sizeof WORD]));

        if ((m_sCntrType == sName) && (0x00 < dwLen))
            fFound = true;
        else
            rdwOffset += dwLen;
    }

    if (fFound)
        return (dwLen & 0x00FFFF);
    else
        return 0x00;

}

void
CV1ContainerRecord::GetContainer(DWORD dwOffset,
                                 ContainerBuffer &rcontainer) const

{
    bool fClearContainer = true;

    try
    {
        DWORD dwFileSize = OpenContainer();

        if ((dwOffset + sizeof rcontainer) <= dwFileSize)
        {
            m_rcard.SmartCard().ReadBinary(dwOffset, sizeof rcontainer,
                                           reinterpret_cast<BYTE *>(&rcontainer));
            fClearContainer = false;
        }

    }

    catch (...)
    {
    }

    if (fClearContainer)
    {
        rcontainer.Size = 0x00;
        rcontainer.Name[0] = '\0';
    }

}

bool
CV1ContainerRecord::GetContainerContent(KeySpec ks,
                                        string &rsBuffer,
                                        DWORD &rdwExponent) const
{
    bool fExists = false;

    OpenContainer();

    DWORD dwOffset = 0x00;
    if (0x00 != FindOffset(dwOffset))
    {
        fExists = true;

        ContainerBuffer container;
        GetContainer(dwOffset, container);

        DWORD dwKeyLength = 0;
        AutoArrayPtr<BYTE> aabKey;
        if (ksExchange == ks)
        {
            if (0x00 < container.XK_wLen)
            {
                rdwExponent = container.XK_dwExp;
                dwKeyLength = container.XK_wLen;
                aabKey = AutoArrayPtr<BYTE>(new BYTE[container.XK_wLen]);
                m_rcard.SmartCard().ReadBinary(dwOffset + sizeof container,
                                               container.XK_wLen,
                                               aabKey.Get());
            }
        }
        else
        {
            if (0x00 < container.SK_wLen)
            {
                rdwExponent = container.SK_dwExp;
                dwKeyLength = container.SK_wLen;
                aabKey = AutoArrayPtr<BYTE>(new BYTE[container.SK_wLen]);
                m_rcard.SmartCard().ReadBinary(dwOffset +
                                               sizeof container +
                                               container.XK_wLen,
                                               container.SK_wLen,
                                               aabKey.Get());
            }
        }

        if (aabKey.Get())
            rsBuffer.assign(reinterpret_cast<char *>(aabKey.Get()),
                            dwKeyLength);
    }

    return fExists;
}

DWORD
CV1ContainerRecord::OpenContainer() const
{
    DWORD dwFileSize;

    string sPath(m_szKeyPath);
    sPath.append("/");
    sPath.append(CV1Paths::RelativeContainers());

    dwFileSize = m_rcard.OpenFile(sPath.c_str());

    return dwFileSize;
}

DWORD
CV1ContainerRecord::SetContainer(DWORD dwOffset) const
{
    DWORD dwFileSize;
    dwFileSize = OpenContainer();

    if ((dwOffset + sizeof ContainerBuffer) > dwFileSize)
        throw Exception(ccOutOfSymbolTableSpace);

    // Create the container buffer
    ContainerBuffer container;
    ZeroMemory(&container, sizeof container);
    container.Size = sizeof container;

    // Security: Protect from buffer overrun
    if (m_sCntrType.length() > (sizeof container.Name / sizeof
                                *container.Name))
        throw cci::Exception(ccBadLength);
    CopyMemory(container.Name, m_sCntrType.data(), m_sCntrType.length());

    m_rcard.SmartCard().WriteBinary(dwOffset, sizeof container,
                                    reinterpret_cast<BYTE *>(&container));

    return container.Size;
}

void
CV1ContainerRecord::Write(KeySpec ks,
                          BYTE const *pbModulus,
                          WORD wModulusLength,
                          DWORD dwExponent) const
{
    // Open container, get the data
    DWORD dwFileSize = OpenContainer();

    DWORD dwOffset = 0x00;
    DWORD dwLen = FindOffset(dwOffset);

    ContainerBuffer container;
    GetContainer(dwOffset, container);

    // Check which key exists
    AutoArrayPtr<BYTE> aabXKey(new BYTE[container.XK_wLen]);
    if (0x00 < container.XK_wLen)
        m_rcard.SmartCard().ReadBinary(dwOffset + sizeof container,
                                       container.XK_wLen,
                                       aabXKey.Get());

    AutoArrayPtr<BYTE> aabSKey(new BYTE[container.SK_wLen]);
    if (0x00 < container.SK_wLen)
        m_rcard.SmartCard().ReadBinary(dwOffset + sizeof container +
                                       container.XK_wLen,
                                       container.SK_wLen,
                                       aabSKey.Get());

    // Give an arbitrary value if key spec not specified
    if ((ksSignature != ks) && (ksExchange != ks))
    {
        if (0x00 == container.XK_wLen)
            ks = ksExchange;
        else
        {
            if (0x00 == container.SK_wLen)
                ks = ksSignature;
            else
                throw Exception(ccBadKeySpec);
        }
    }

    // Is it the last container of Container file?
    ContainerBuffer NextContainer;
    GetContainer(dwOffset + dwLen, NextContainer);

    bool fDeleted = false;
    if (sizeof NextContainer <= NextContainer.Size)
    {
        // Delete the existing container
        Delete();
        fDeleted = true;
        // No need to recreate it now
    }
    // Now the container is at the end of the Container file

    // Find the "NEW" offset of the container which may not exist anymore
    dwOffset = 0x00;
    FindOffset(dwOffset); // keep the INITIAL dwLen of the container

    // Check that there is enough room to put the new key
    bool fEnoughMemory = false;
    switch (ks)
    {
    case ksExchange:
        if ((dwOffset + dwLen - container.XK_wLen +
             wModulusLength) <= dwFileSize)
        {
            aabXKey = AutoArrayPtr<BYTE>(new BYTE[wModulusLength]);
            CopyMemory(aabXKey.Get(), pbModulus, wModulusLength);
            container.XK_dwExp = dwExponent;
            container.XK_wLen  = wModulusLength;
            fEnoughMemory = true;
        }
        break;

    case ksSignature:
        if ((dwOffset + dwLen - container.SK_wLen +
             wModulusLength) <= dwFileSize)
        {
            aabSKey = AutoArrayPtr<BYTE>(new BYTE[wModulusLength]);
            CopyMemory(aabSKey.Get(), pbModulus, wModulusLength);
            container.SK_dwExp = dwExponent;
            container.SK_wLen  = wModulusLength;
            fEnoughMemory = true;
        }
        break;
    }

    // Recreate the container buffer accounting for "card tearing"
    // where the card could be pulled during the write operation.
    // This is done using a type of transact and commit phases.
    // The container size is initially set to zero, then the container
    // contents are written (transaction), followed by resetting the
    // container size to the actual length of the container to
    // "commit" the changes to the card.

    container.Size = 0;

    DWORD const dwTrueSize = sizeof container + container.XK_wLen +
        container.SK_wLen;

    size_t cBufferSize = dwTrueSize;
    BYTE const abNull[] = {0x00,0x00};
    bool fAppendNull = (dwTrueSize + sizeof abNull) <= dwFileSize;
    if (fAppendNull)
        cBufferSize += sizeof abNull;

    AutoArrayPtr<BYTE> aabBuffer(new BYTE[cBufferSize]);

    BYTE *pbBuffer = aabBuffer.Get();
    CopyMemory(pbBuffer, &container, sizeof container);
    pbBuffer += sizeof container;

    CopyMemory(pbBuffer, aabXKey.Get(), container.XK_wLen);
    pbBuffer += container.XK_wLen;

    CopyMemory(pbBuffer, aabSKey.Get(), container.SK_wLen);
    pbBuffer += container.SK_wLen;

    if (fAppendNull)
    {
        CopyMemory(pbBuffer, abNull, sizeof abNull);
        pbBuffer += sizeof abNull;
    }

    // Rewrite the container even if there is not enough to write the
    // NEW public key, then there should be enough room to write the
    // existing key.
    m_rcard.SmartCard().WriteBinary(dwOffset,
                                    pbBuffer - aabBuffer.Get(),
                                    aabBuffer.Get());

    // Now commit these changes with the actual size.
    container.Size = dwTrueSize;
    m_rcard.SmartCard().WriteBinary(dwOffset, sizeof container.Size,
                                    reinterpret_cast<BYTE *>(&container));

    if (!fEnoughMemory)
        throw Exception(ccOutOfSymbolTableSpace);
}

                                                  // Access
                                                  // Predicates

bool
CV1ContainerRecord::IsDefault() const
{
    return (DefaultName() == m_sCntrType);
}

                                                  // Static Variables
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\v1contrec.h ===
// V1ContRec.h -- declaration of CV1ContainerRecord

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 2000. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#if !defined(SLBCCI_V1CONTREC_H)
#define SLBCCI_V1CONTREC_H

#include <string>

#include <windows.h>

#include "V1Card.h"

namespace
{
struct ContainerBuffer;
}

namespace cci
{

class CV1ContainerRecord
{
public:
                                                  // Types

    enum CreateMode
    {
        cmAlways,
        cmConditionally,
        cmNever,
        cmNoCheck,
    };

                                                  // C'tors/D'tors
    explicit
    CV1ContainerRecord(CV1Card const &rv1card,
                       std::string const &rsCntrType,
                       CreateMode mode);

    ~CV1ContainerRecord();

                                                  // Operators
                                                  // Operations

    std::string
    ComputeSignature(KeySpec ks,
                     std::string const &rsCipher) const;

    void
    Delete() const;

    void
    Name(std::string const &rsNewName);

    void
    Read(KeySpec ks,
         iop::CPublicKeyBlob &rKeyBlob) const;

    void
    Read(KeySpec ks,
         std::string &rsBlob) const;

    void
    Write(KeySpec ks,
          CPrivateKeyBlob const &rblob);

    void
    Write(KeySpec ks,
          iop::CPublicKeyBlob const &rKeyBlob);

    void
    Write(KeySpec ks,
          std::string const &rsBlob) const;

                                                  // Access

    static std::string
    CertName();

    static std::string
    DefaultName();

    std::string
    Name() const;

                                                  // Predicates

    bool
    Exists() const;

    bool
    KeyExists(KeySpec ks) const;

protected:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables

private:
                                                  // Types

    // ContainerBuffer is written to the card one byte after the next,
    // no padding between the bytes.  Therefore the pack pragma is
    // necessary to prevent the compiler from aligning the members on
    // n-byte boundaries.
#pragma pack(push, 1)
    struct ContainerBuffer
    {
        enum
        {
            cMaxContainerNameLength = 10,
        };

        WORD    Size;
        BYTE    Name[cMaxContainerNameLength];
        DWORD   XK_dwExp;
        WORD    XK_wLen;
        DWORD   SK_dwExp;
        WORD    SK_wLen;
    };
#pragma pack(pop)

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
    void
    Create() const;

    DWORD
    FindOffset(DWORD &rdwOffset) const;

    void
    GetContainer(DWORD dwOffset,
                 ContainerBuffer &rcontainer) const;

    bool
    GetContainerContent(KeySpec ks,
                        std::string &rsBuffer,
                        DWORD &rdwExponent) const;

    DWORD
    OpenContainer() const;

    DWORD
    SetContainer(DWORD dwOffset) const;

    void
    Write(KeySpec ks,
          BYTE const *pbModulus,
          WORD wModulusLength,
          DWORD dwExponent) const;

                                                  // Access
                                                  // Predicates

    bool
    IsDefault() const;

                                                  // Variables
    CV1Card const &m_rcard;
    std::string const m_sCntrType;
    char const *m_szKeyPath;

};

} // namespace cci

#endif // SLBCCI_V1CONTREC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\v1keypair.cpp ===
// V1KeyPair.cpp: implementation of the CV1KeyPair class.
//
// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
//////////////////////////////////////////////////////////////////////
#include "NoWarning.h"

#include <scuCast.h>

#include "slbCci.h"
#include "cciCard.h"
#include "TransactionWrap.h"

#include "V1Cert.h"
#include "V1Cont.h"
#include "V1ContRec.h"
#include "V1KeyPair.h"
#include "V1PriKey.h"
#include "V1PubKey.h"

using namespace std;
using namespace cci;

/////////////////////////// LOCAL/HELPER  /////////////////////////////////

namespace
{

    // Functor to call the binary T::Make
    template<class T>
    class Maker
    {
    public:
        Maker(CCard const &rhcard)
            : m_rv1card(scu::DownCast<CV1Card const &,
                                      CAbstractCard const &>(*rhcard))
        {}

        auto_ptr<T>
        operator()(KeySpec ks) const
        {
            return auto_ptr<T>(T::Make(m_rv1card, ks));
        }

    private:
        CV1Card const &m_rv1card;
    };

    // Update the cache handle.  If the the handle has not been cached
    // and the key pair exists, then make the key pair.
    template<class R, class T>
    void
    UpdateCache(CArchivedValue<R> &ravhCache,
                CV1Container &rv1cntr,
                KeySpec ks,
                Maker<T> const &rMaker)
    {
        if (!ravhCache.IsCached())
        {
            auto_ptr<T> apObject(rv1cntr.Record().KeyExists(ks)
                                 ? rMaker(ks)
                                 : auto_ptr<T>(0));
            R Handle(apObject.get());
            apObject.release();                   // transfer ownership

            ravhCache.Value(Handle);
        }
    }

} // namespace


///////////////////////////    PUBLIC     /////////////////////////////////

                                                  // Types
                                                  // C'tors/D'tors

CV1KeyPair::CV1KeyPair(CV1Card const &rv1card,
                       CContainer const &rhcont,
                       KeySpec ks)
    : CAbstractKeyPair(rv1card, rhcont, ks),
      m_avhcert(),
      m_avhprikey(),
      m_avhpubkey(),
      m_cntrCert(rv1card, CV1ContainerRecord::CertName(), false)
{}

CV1KeyPair::~CV1KeyPair() throw()
{}


                                                  // Operators
                                                  // Operations


void
CV1KeyPair::Certificate(CCertificate const &rcert)
{
    CTransactionWrap wrap(m_hcard);

    if (rcert)
    {
        CV1Certificate &rv1cert =
            scu::DownCast<CV1Certificate &, CAbstractCertificate &>(*rcert);

        rv1cert.AssociateWith(m_ks);
    }
        // else to preserve the CCI semantics, the certificate is
        // actually deleted using CAbstractCertificate::Delete;
        // otherwise calling rcert->Delete here would be "infinitely"
        // recursive.  Unfortuantely, this means the Certificate
        // could "reappear" if CAbstractCertificate::Delete was never
        // called.

    m_avhcert.Value(rcert);
}

void
CV1KeyPair::PrivateKey(CPrivateKey const &rprikey)
{
    CTransactionWrap wrap(m_hcard);

    if (rprikey)
    {
        CV1PrivateKey &rv1prikey =
            scu::DownCast<CV1PrivateKey &, CAbstractPrivateKey &>(*rprikey);

        rv1prikey.AssociateWith(m_ks);
    }
        // else to preserve the CCI semantics, the key is
        // actually deleted using CAbstractPrivateKey::Delete;
        // otherwise calling rprikey->Delete here would be "infinitely"
        // recursive.  Unfortuantely, this means the Certificate
        // could "reappear" if CAbstractPrivateKey::Delete was never
        // called.

    m_avhprikey.Value(rprikey);
}

void
CV1KeyPair::PublicKey(CPublicKey const &rpubkey)
{
    CTransactionWrap wrap(m_hcard);

    if (rpubkey)
    {
        CV1PublicKey &rv1pubkey =
            scu::DownCast<CV1PublicKey &, CAbstractPublicKey &>(*rpubkey);

        rv1pubkey.AssociateWith(m_ks);
    }
        // else to preserve the CCI semantics, the key is
        // actually deleted using CAbstractPublicKey::Delete;
        // otherwise calling rpubkey->Delete here would be "infinitely"
        // recursive.  Unfortuantely, this means the Certificate
        // could "reappear" if CAbstractPublicKey::Delete was never
        // called.

    m_avhpubkey.Value(rpubkey);
}

                                                  // Access

CCertificate
CV1KeyPair::Certificate() const
{
    CTransactionWrap wrap(m_hcard);

    UpdateCache(m_avhcert, m_cntrCert, m_ks,
                Maker<CV1Certificate>(m_hcard));

    return m_avhcert.Value();
}

CPrivateKey
CV1KeyPair::PrivateKey() const
{
    CTransactionWrap wrap(m_hcard);

    CV1Container &rv1cntr =
        scu::DownCast<CV1Container &, CAbstractContainer &>(*m_hcont);

    UpdateCache(m_avhprikey, rv1cntr, m_ks,
                Maker<CV1PrivateKey>(m_hcard));

    return m_avhprikey.Value();
}

CPublicKey
CV1KeyPair::PublicKey() const
{
    CTransactionWrap wrap(m_hcard);

    CV1Container &rv1cntr =
        scu::DownCast<CV1Container &, CAbstractContainer &>(*m_hcont);

    UpdateCache(m_avhpubkey, rv1cntr, m_ks,
                Maker<CV1PublicKey>(m_hcard));

    return m_avhpubkey.Value();
}

                                                  // Predicates

bool
CV1KeyPair::DoEquals(CAbstractKeyPair const &rhs) const
{
    // Only one key pair can exists so must be the same.
    return true;
}

                                                  // Static Variables

///////////////////////////   PROTECTED   /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables


///////////////////////////    PRIVATE    /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\v1paths.h ===
// V1Paths.h -- declaration of CV1Paths

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 2000. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#if !defined(SLBCCI_V1PATHS_H)
#define SLBCCI_V1PATHS_H

#include <string>

namespace cci
{

class CV1Paths
{
public:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
    static char const *
    AdmKeys();

    static char const *
    Chv();

    static char const *
    CryptoSys();

    static char const *
    DefaultContainer();

    static char const *
    DefaultKey();

    static char const *
    IcFile();

    static char const *
    IdSys();

    static char const *
    PrivateKeys();

    static char const *
    PublicKeys();

    static char const *
    RelativeContainers();

    static char const *
    Root();

    static char const *
    RootContainers();


                                                  // Predicates

protected:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables

private:
                                                  // Types
                                                  // C'tors/D'tors
    // Can't create, copy or delete
    explicit
    CV1Paths();

    CV1Paths(CV1Paths const &rhs);

    ~CV1Paths();

                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables

};

} // namespace cci

#endif // SLBCCI_V1PATHS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\v1prikey.cpp ===
// V1PriKey.cpp: implementation of the CV1PriKey class.
//
// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
//////////////////////////////////////////////////////////////////////

#include <scuCast.h>

#include <iopPriBlob.h>

#include "cciExc.h"
#include "cciCard.h"
#include "TransactionWrap.h"

#include "V1Cont.h"
#include "V1ContRec.h"
#include "V1PriKey.h"
#include <iopPriBlob.h>

using namespace std;
using namespace cci;

/////////////////////////// LOCAL/HELPER  /////////////////////////////////

///////////////////////////    PUBLIC     /////////////////////////////////

                                                  // Types
                                                  // C'tors/D'tors
CV1PrivateKey::CV1PrivateKey(CV1Card const &rv1card,
                             KeySpec ks)
    : CAbstractPrivateKey(rv1card, oaPrivateAccess),
      m_ks(ks),
      m_apKeyBlob()
{}

CV1PrivateKey::~CV1PrivateKey()
{}

                                                  // Operators
                                                  // Operations

void
CV1PrivateKey::AssociateWith(KeySpec ks)
{
    CTransactionWrap wrap(m_hcard);
    
    m_ks = ks;

    Store();
}

void
CV1PrivateKey::CredentialID(string const &rstrID)
{
    throw Exception(ccNotImplemented);
}

void
CV1PrivateKey::Decrypt(bool flag)
{
    throw Exception(ccNotImplemented);
}

void
CV1PrivateKey::Derive(bool flag)
{
    throw Exception(ccNotImplemented);
}

void
CV1PrivateKey::EndDate(Date const &rEndDate)
{
    throw Exception(ccNotImplemented);
}

void
CV1PrivateKey::Exportable(bool flag)
{
    throw Exception(ccNotImplemented);
}

void
CV1PrivateKey::ID(string const &rstrID)
{
    throw Exception(ccNotImplemented);
}

string
CV1PrivateKey::InternalAuth(string const &rstrOld)
{
    CTransactionWrap wrap(m_hcard);

    CV1Card &rv1card =
        scu::DownCast<CV1Card &, CAbstractCard &>(*m_hcard);

    CV1ContainerRecord CntrRec(rv1card,
                               CV1ContainerRecord::DefaultName(), 
                               CV1ContainerRecord::cmNever);

    return CntrRec.ComputeSignature(m_ks, rstrOld);
}

void
CV1PrivateKey::Label(string const &rstrLabel)
{
    throw Exception(ccNotImplemented);
}

void
CV1PrivateKey::Local(bool flag)
{
    throw Exception(ccNotImplemented);
}

CV1PrivateKey *
CV1PrivateKey::Make(CV1Card const &rv1card,
                    KeySpec ks)
{
    CTransactionWrap wrap(rv1card);
    
    return new CV1PrivateKey(rv1card, ks);
}


void
CV1PrivateKey::Modifiable(bool flag)
{
    throw Exception(ccNotImplemented);
}

void
CV1PrivateKey::Modulus(string const &rstrModulus)
{
    throw Exception(ccNotImplemented);
}

void
CV1PrivateKey::NeverExportable(bool flag)
{
    throw Exception(ccNotImplemented);
}

void
CV1PrivateKey::NeverRead(bool flag)
{
    throw Exception(ccNotImplemented);
}

void
CV1PrivateKey::PublicExponent(string const &rstrExponent)
{
    throw Exception(ccNotImplemented);
}

void
CV1PrivateKey::Read(bool flag)
{
    throw Exception(ccNotImplemented);
}

void
CV1PrivateKey::Sign(bool flag)
{
    throw Exception(ccNotImplemented);
}

void
CV1PrivateKey::SignRecover(bool flag)
{
    throw Exception(ccNotImplemented);
}

void
CV1PrivateKey::StartDate(Date &rdtStart)
{
    throw Exception(ccNotImplemented);
}

void
CV1PrivateKey::Subject(string const &rstrSubject)
{
    throw Exception(ccNotImplemented);
}

void
CV1PrivateKey::Unwrap(bool flag)
{
    throw Exception(ccNotImplemented);
}

                                                  // Access
string
CV1PrivateKey::CredentialID()
{
    throw Exception(ccNotImplemented);

    return string();
}

bool
CV1PrivateKey::Decrypt()
{
    return true;
}

bool
CV1PrivateKey::Derive()
{
    return true;
}

Date
CV1PrivateKey::EndDate()
{
    throw Exception(ccNotImplemented);

    return Date();
}

bool
CV1PrivateKey::Exportable()
{
    return false;
}

string
CV1PrivateKey::ID()
{
    throw Exception(ccNotImplemented);

    return string();
}

string
CV1PrivateKey::Label()
{
    throw Exception(ccNotImplemented);

    return string();
}

bool
CV1PrivateKey::Local()
{
    throw Exception(ccNotImplemented);

    return false;
}

bool
CV1PrivateKey::Modifiable()
{
    return true;
}

string
CV1PrivateKey::Modulus()
{
    throw Exception(ccNotImplemented);

    return string();
}

bool
CV1PrivateKey::NeverExportable()
{
    return true;
}

bool
CV1PrivateKey::NeverRead()
{
    return true;
}

bool
CV1PrivateKey::Private()
{
    return true;
}

string
CV1PrivateKey::PublicExponent()
{
    throw Exception(ccNotImplemented);
}

bool
CV1PrivateKey::Read()
{
    return false;
}

bool
CV1PrivateKey::Sign()
{
    return true;
}

bool
CV1PrivateKey::SignRecover()
{
    return true;
}

Date
CV1PrivateKey::StartDate()
{
    throw Exception(ccNotImplemented);

    return Date();
}

string
CV1PrivateKey::Subject()
{
    throw Exception(ccNotImplemented);

    return string();
}

bool
CV1PrivateKey::Unwrap()
{
    return true;
}


                                                  // Predicates
                                                  // Static Variables

///////////////////////////   PROTECTED   /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
bool
CV1PrivateKey::DoEquals(CAbstractPrivateKey const &rhs) const
{
    CV1PrivateKey const &rv1rhs =
        scu::DownCast<CV1PrivateKey const &, CAbstractPrivateKey const &>(rhs);
    
    return rv1rhs.m_ks == m_ks;
}

                                                  // Operations
void
CV1PrivateKey::DoDelete()
{
    // nothing to do.
}

void
CV1PrivateKey::DoWriteKey(CPrivateKeyBlob const &rblob)
{
    // cache to potentially store later
    m_apKeyBlob =
        auto_ptr<CPrivateKeyBlob>(new CPrivateKeyBlob(rblob));

    if (ksNone != m_ks)
        Store();
}

                                                  // Access
                                                  // Predicates
                                                  // Static Variables


///////////////////////////    PRIVATE    /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations

void
CV1PrivateKey::Store()
{
    if (ksNone != m_ks)
    {
        if (m_apKeyBlob.get())
        {
            CV1Card &rv1card =
                scu::DownCast<CV1Card &, CAbstractCard &>(*m_hcard);

            CV1ContainerRecord CntrRec(rv1card,
                                       CV1ContainerRecord::DefaultName(), 
                                       CV1ContainerRecord::cmNever);

            CntrRec.Write(m_ks, *m_apKeyBlob.get());

            // clear and forget the private key
            m_apKeyBlob = auto_ptr<CPrivateKeyBlob>(0);
        }
    }
    else
        throw Exception(ccInvalidParameter);
}

                                                  // Access
                                                  // Predicates
                                                  // Static Variables
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\v1paths.cpp ===
// V1Paths.cpp -- definition of CV1Paths

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 2000. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

/////////////////////////// LOCAL/HELPER  /////////////////////////////////

#include "V1Paths.h"

using namespace std;
using namespace cci;

namespace
{

char const
    szDefaultKeyPath[] = "/3F00/3F11";            // Path to Public/Private key files

char const
    szDefaultContainerPath[] = "/3F00";           // Path to Container file

char const
    szICC_ROOT[] = "/3F00";                       // [3F00] ROOT level

char const
    szICC_CHV[] = "/3F00/0000";                   // [0000] at ROOT level

char const
    szICC_ADMKEYS[] = "/3F00/0011";               // [0011] at ROOT level

char const
    szICC_CRYPTO_SYS[] = "/3F00/3F11";            // [3F11] at ROOT level

char const
    szICC_ID_SYS[] = "/3F00/3F15";                // [3F15] at ROOT level

char const
    szICC_IC_FILE[] = "/3F00/0005";               // [0005] at ROOT level

char const
    szICC_RELATIVE_CONTAINERS[] = "0015";

char const
    szICC_ROOT_CONTAINERS[] = "/3F00/0015";

char const
    szICC_PUBLICKEYS[] = "/3F00/3F11/0015";

char const
    szICC_PRIVATEKEYS[] = "/3F00/3F11/0012";


} // namespace

///////////////////////////    PUBLIC     /////////////////////////////////

                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access

char const *
CV1Paths::AdmKeys()
{
    return szICC_ADMKEYS;
}

char const *
CV1Paths::Chv()
{
    return szICC_CHV;
}

char const *
CV1Paths::CryptoSys()
{
    return szICC_CRYPTO_SYS;
}

char const *
CV1Paths::DefaultContainer()
{
    return szDefaultContainerPath;
}

char const *
CV1Paths::DefaultKey()
{
    return szDefaultKeyPath;
}

char const *
CV1Paths::IcFile()
{
    return szICC_IC_FILE;
}

char const *
CV1Paths::IdSys()
{
    return szICC_ID_SYS;
}

char const *
CV1Paths::PrivateKeys()
{
    return szICC_PRIVATEKEYS;
}

char const *
CV1Paths::PublicKeys()
{
    return szICC_PUBLICKEYS;
}

char const *
CV1Paths::RelativeContainers()
{
    return szICC_RELATIVE_CONTAINERS;
}

char const *
CV1Paths::Root()
{
    return szICC_ROOT;
}

char const *
CV1Paths::RootContainers()
{
    return szICC_ROOT_CONTAINERS;
}


                                                  // Predicates
                                                  // Static Variables

///////////////////////////   PROTECTED   /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables


///////////////////////////    PRIVATE    /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\v1keypair.h ===
// V1KeyPair.h: interface for the CV1KeyPair class.
//
// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
//////////////////////////////////////////////////////////////////////

// Note:  This file should only be included by the CCI, not directly
// by the client.

#if !defined(SLBCCI_V1KEYPAIR_H)
#define SLBCCI_V1KEYPAIR_H

#include <string>

#include <slbRCObj.h>

#include "slbCci.h"
#include "cciCard.h"
#include "cciCert.h"
#include "cciCont.h"
#include "cciPriKey.h"
#include "cciPubKey.h"
#include "AKeyPair.h"
#include "ArchivedValue.h"

#include "V1Cert.h"

namespace cci
{

class CContainerInfoRecord;

class CV1KeyPair
    : public CAbstractKeyPair
{
public:
                                                  // Types
                                                  // C'tors/D'tors
    CV1KeyPair(CV1Card const &rv1card,
               CContainer const &rhcont,
               KeySpec ks);

    virtual
    ~CV1KeyPair() throw();

                                                  // Operators
                                                  // Operations
    virtual void
    Certificate(CCertificate const &rcert);

    virtual void
    PrivateKey(CPrivateKey const &rprikey);

    virtual void
    PublicKey(CPublicKey const &rpubkey);

                                                  // Access
    virtual CCertificate
    Certificate() const;

    virtual CPrivateKey
    PrivateKey() const;

    virtual CPublicKey
    PublicKey() const;


                                                  // Predicates

protected:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
    virtual bool
    DoEquals(CAbstractKeyPair const &rhs) const;

                                                  // Variables

private:
                                                  // Types
                                                  // C'tors/D'tors
    CV1KeyPair(CV1KeyPair const &rhs);
        // not defined, copying not allowed.

                                                  // Operators
    CV1KeyPair &
    operator=(CV1KeyPair const &rhs);
        // not defined, initialization not allowed.

                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables
    CArchivedValue<CCertificate> mutable m_avhcert;
    CArchivedValue<CPrivateKey> mutable m_avhprikey;
    CArchivedValue<CPublicKey> mutable m_avhpubkey;
    CV1Container mutable m_cntrCert;

};

} // namespace cci

#endif // !defined(SLBCCI_V1KEYPAIR_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\v1prikey.h ===
// V1PriKey.h: interface for the CV1PrivateKey class.
//
// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
//////////////////////////////////////////////////////////////////////

// Note:  This file should only be included by the CCI, not directly
// by the client.

#if !defined(SLBCCI_V1PRIKEY_H)
#define SLBCCI_V1PRIKEY_H

#include <string>
#include <vector>
#include <memory>                                 // for auto_ptr

#include <slbRCObj.h>

#include "slbCci.h"                               // for KeySpec

#include "APriKey.h"

namespace cci
{

class CV1Card;
class CPriKeyInfoRecord;

class CV1PrivateKey
    : public CAbstractPrivateKey
{
public:
                                                  // Types
                                                  // C'tors/D'tors

    CV1PrivateKey(CV1Card const &rv1card,
                  KeySpec ks);

    virtual
    ~CV1PrivateKey() throw();

                                                  // Operators
                                                  // Operations

    void
    AssociateWith(KeySpec ks);

    virtual void
    CredentialID(std::string const &rstrID);

    virtual void
    Decrypt(bool flag);

    virtual void
    Derive(bool flag);

    virtual void
    EndDate(Date const &rEndDate);

    virtual void
    Exportable(bool flag);

    virtual void
    ID(std::string const &rstrID);

    virtual std::string
    InternalAuth(std::string const &rstrOld);

    virtual void
    Label(std::string const &rstrLabel);

    virtual void
    Local(bool flag);

    static CV1PrivateKey *
    Make(CV1Card const &rv1card,
         KeySpec ks);

    virtual void
    Modifiable(bool flag);

    virtual void
    Modulus(std::string const &rstrModulus);

    virtual void
    NeverExportable(bool flag);

    virtual void
    NeverRead(bool flag);

    virtual void
    PublicExponent(std::string const &rstrExponent);

    virtual void
    Read(bool flag);

    virtual void
    Sign(bool flag);

    virtual void
    SignRecover(bool flag);

    virtual void
    StartDate(Date &rdtStart);

    virtual void
    Subject(std::string const &rstrSubject);

    virtual void
    Unwrap(bool flag);

                                                  // Access

    virtual std::string
    CredentialID();

    virtual bool
    Decrypt();

    virtual bool
    Derive();

    virtual Date
    EndDate();

    virtual bool
    Exportable();

    virtual std::string
    ID();

    virtual std::string
    Label();

    virtual bool
    Local();

    virtual bool
    Modifiable();

    virtual std::string
    Modulus();

    virtual bool
    NeverExportable();

    virtual bool
    NeverRead();

    virtual bool
    Private();

    virtual std::string
    PublicExponent();

    virtual bool
    Read();

    virtual bool
    Sign();

    virtual bool
    SignRecover();

    virtual Date
    StartDate();

    virtual std::string
    Subject();

    virtual bool
    Unwrap();


                                                  // Predicates

protected:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations

    virtual void
    DoDelete();

    virtual void
    DoWriteKey(CPrivateKeyBlob const &rblob);

                                                  // Access
                                                  // Predicates

    virtual bool
    DoEquals(CAbstractPrivateKey const &rhs) const;

                                                  // Variables

private:
                                                  // Types
                                                  // C'tors/D'tors

    CV1PrivateKey(CAbstractPrivateKey const &rhs);
        // not defined, copying not allowed.

                                                  // Operators

    CAbstractPrivateKey &
    operator=(CAbstractPrivateKey const &rhs);
        // not defined, initialization not allowed.

                                                  // Operations

    void
    Store();

                                                  // Access
                                                  // Predicates
                                                  // Variables

    KeySpec m_ks;
    std::auto_ptr<CPrivateKeyBlob> m_apKeyBlob;

};

} // namespace

#endif // !defined(SLBCCI_V1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\v1pubkey.h ===
// V1PubKey.h: interface for the CV1PublicKey class.
//
// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
//////////////////////////////////////////////////////////////////////

#if !defined(SLBCCI_V1PUBKEY_H)
#define SLBCCI_V1PUBKEY_H

// Note:  This file should only be included by the CCI, not directly
// by the client.

#include <string>
#include <vector>
#include <memory>                                 // for auto_ptr

#include <slbRCObj.h>


#include "slbCci.h"                               // for KeySpec
#include "APublicKey.h"

class iop::CPublicKeyBlob;

namespace cci
{

class CV1Card;
class CV1PublicKey
    : public CAbstractPublicKey
{
public:
                                                  // Types
                                                  // C'tors/D'tors

    CV1PublicKey(CV1Card const &rv1card,
                 KeySpec ks);

    virtual
    ~CV1PublicKey() throw();
                                                  // Operators
                                                  // Operations

    void
    AssociateWith(KeySpec ks);

    virtual void
    CKInvisible(bool flag);

    virtual void
    CredentialID(std::string const &rstrID);

    virtual void
    Derive(bool flag);

    virtual void
    ID(std::string const &rstrID);

    virtual void
    EndDate(Date const &rdtEnd);

    virtual void
    Encrypt(bool flag);

    virtual void
    Exponent(std::string const &rstrExp);

    virtual void
    Label(std::string const  &rstrLabel);

    virtual void
    Local(bool flag);

    static CV1PublicKey *
    Make(CV1Card const &rv1card,
         KeySpec ks);

    virtual void
    Modifiable(bool flag);

    virtual void
    Modulus(std::string const &rstrMod);

    virtual void
    StartDate(Date const &rdtStart);

    virtual void
    Subject(std::string const &rstrSubject);

    virtual void
    Verify(bool flag);

    virtual void
    VerifyRecover(bool flag);

    virtual void
    Wrap(bool flag);

                                                  // Access

    virtual bool
    CKInvisible();

    virtual std::string
    CredentialID();

    virtual bool
    Derive();

    virtual bool
    Encrypt();

    virtual Date
    EndDate();

    virtual std::string
    Exponent();

    virtual std::string
    ID();

    virtual std::string
    Label();

    virtual bool
    Local();

    virtual bool
    Modifiable();

    virtual std::string
    Modulus();

    virtual bool
    Private();

    virtual Date
    StartDate();

    virtual std::string
    Subject();

    virtual bool
    Verify();

    virtual bool
    VerifyRecover();

    virtual bool
    Wrap();
                                                  // Predicates

protected:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations

    virtual void
    DoDelete();

                                                  // Access
                                                  // Predicates

    virtual bool
    DoEquals(CAbstractPublicKey const &rhs) const;

                                                  // Variables

private:
                                                  // Types
                                                  // C'tors/D'tors

    CV1PublicKey(CAbstractPublicKey const &rhs);
        // not defined, copying not allowed.
                                                  // Operators

    CAbstractPublicKey &
    operator=(CAbstractPublicKey const &rhs);
        // not defined, initialization not allowed.

                                                  // Operations

    void
    Load();

    void
    Store();

                                                  // Access
                                                  // Predicates
                                                  // Variables

    KeySpec m_ks;
    std::auto_ptr<iop::CPublicKeyBlob> m_apKeyBlob;

};

} // namespace cci

#endif // SLBCCI_V1PUBKEY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\v1pubkey.cpp ===
// V1PubKey.cpp: implementation of the CV1PubKey class.
//
// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
//////////////////////////////////////////////////////////////////////

#include <scuCast.h>

#include <iopPubBlob.h>

#include "cciExc.h"
#include "cciCard.h"
#include "TransactionWrap.h"

#include "V1Cont.h"
#include "V1ContRec.h"
#include "V1PubKey.h"

using namespace std;
using namespace cci;
using namespace iop;

/////////////////////////// LOCAL/HELPER  /////////////////////////////////

///////////////////////////    PUBLIC     /////////////////////////////////

                                                  // Types
                                                  // C'tors/D'tors
CV1PublicKey::CV1PublicKey(CV1Card const &rv1card,
                           KeySpec ks)
    : CAbstractPublicKey(rv1card, oaPublicAccess),
      m_ks(ks),
      m_apKeyBlob()
{}

CV1PublicKey::~CV1PublicKey()
{}


                                                  // Operators
                                                  // Operations

void
CV1PublicKey::AssociateWith(KeySpec ks)
{
    CTransactionWrap wrap(m_hcard);
    
    m_ks = ks;

    Store();
}

void
CV1PublicKey::CKInvisible(bool flag)
{
    throw Exception(ccNotImplemented);
}

void
CV1PublicKey::CredentialID(string const &rstrID)
{
    throw Exception(ccNotImplemented);
}

void
CV1PublicKey::Derive(bool flag)
{
    throw Exception(ccNotImplemented);
}

void
CV1PublicKey::ID(string const &rstrID)
{
    throw Exception(ccNotImplemented);
}

void
CV1PublicKey::EndDate(Date const &rdtEnd)
{
    throw Exception(ccNotImplemented);
}

void
CV1PublicKey::Encrypt(bool flag)
{
    throw Exception(ccNotImplemented);
}

void
CV1PublicKey::Exponent(string const &rstrExp)
{
    CTransactionWrap wrap(m_hcard);
    
    if (!m_apKeyBlob.get())  // preserve the modulus, if previously cached
    {
        m_apKeyBlob =
            auto_ptr<CPublicKeyBlob>(new CPublicKeyBlob);
        Clear(*m_apKeyBlob.get());
    }

    // Security: guard against buffer overrun
    if (rstrExp.length() > (sizeof m_apKeyBlob->bExponent / sizeof
                            *m_apKeyBlob->bExponent))
        throw cci::Exception(ccBadLength);
    CopyMemory(m_apKeyBlob->bExponent,
               reinterpret_cast<BYTE const *>(rstrExp.data()),
               rstrExp.length());

    if (ksNone != m_ks)
        Store();
}

void
CV1PublicKey::Label(string const &rstrLabel)
{
    throw Exception(ccNotImplemented);
}

void
CV1PublicKey::Local(bool flag)
{
    throw Exception(ccNotImplemented);
}

CV1PublicKey *
CV1PublicKey::Make(CV1Card const &rv1card,
                   KeySpec ks)
{
    CTransactionWrap wrap(rv1card);
    
    return new CV1PublicKey(rv1card, ks);
}

void
CV1PublicKey::Modifiable(bool flag)
{
    throw Exception(ccNotImplemented);
}

void
CV1PublicKey::Modulus(string const &rstrMod)
{
    CTransactionWrap wrap(m_hcard);
    
    if (!m_apKeyBlob.get())  // preserve the exponent, if previously cached
    {
        m_apKeyBlob =
            auto_ptr<CPublicKeyBlob>(new CPublicKeyBlob);
        Clear(*m_apKeyBlob.get());
    }
    
    CopyMemory(m_apKeyBlob->bModulus,
               reinterpret_cast<BYTE const *>(rstrMod.data()),
               rstrMod.length());
    m_apKeyBlob->bModulusLength = static_cast<BYTE>(rstrMod.length());

    if (ksNone != m_ks)
        Store();
}

void
CV1PublicKey::StartDate(Date const &rdtStart)
{
    throw Exception(ccNotImplemented);
}

void
CV1PublicKey::Subject(string const &rstrSubject)
{
    throw Exception(ccNotImplemented);
}

void
CV1PublicKey::Verify(bool flag)
{
    throw Exception(ccNotImplemented);
}

void
CV1PublicKey::VerifyRecover(bool flag)
{
    throw Exception(ccNotImplemented);
}

void
CV1PublicKey::Wrap(bool flag)
{
    throw Exception(ccNotImplemented);
}

                                                  // Access
bool
CV1PublicKey::CKInvisible()
{
    return false;
}	

string
CV1PublicKey::CredentialID()
{
    throw Exception(ccNotImplemented);

    return string();
    
}

bool
CV1PublicKey::Derive()
{
    return true;
}

bool
CV1PublicKey::Encrypt()
{
    return true;
}

Date
CV1PublicKey::EndDate()
{
    throw Exception(ccNotImplemented);

    return Date();
}

string
CV1PublicKey::Exponent()
{
    CTransactionWrap wrap(m_hcard);
    
    if (!m_apKeyBlob.get())
        Load();

    return string(reinterpret_cast<char *>(m_apKeyBlob->bExponent),
                  sizeof m_apKeyBlob->bExponent);
}


string
CV1PublicKey::ID()
{
    throw Exception(ccNotImplemented);

    return string();
}

string
CV1PublicKey::Label()
{
    throw Exception(ccNotImplemented);
}

bool
CV1PublicKey::Local()
{
    return false;
}

bool
CV1PublicKey::Modifiable()
{
    return true;
}

string
CV1PublicKey::Modulus()
{
    CTransactionWrap wrap(m_hcard);
    
    if (!m_apKeyBlob.get())
        Load();

    return string(reinterpret_cast<char *>(m_apKeyBlob.get()->bModulus),
                  m_apKeyBlob.get()->bModulusLength);

}

bool
CV1PublicKey::Private()
{
    return false;
}

Date
CV1PublicKey::StartDate()
{
    throw Exception(ccNotImplemented);

    return Date();
}

string
CV1PublicKey::Subject()
{
    throw Exception(ccNotImplemented);

    return string();
}

bool
CV1PublicKey::Verify()
{
    return true;
}

bool
CV1PublicKey::VerifyRecover()
{
    throw true;
}

bool
CV1PublicKey::Wrap()
{
    return true;
}


                                                  // Predicates
                                                  // Static Variables

///////////////////////////   PROTECTED   /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
void
CV1PublicKey::DoDelete()
{
    if (ksNone != m_ks)
    {
        CContainer hcntr(m_hcard->DefaultContainer());

        if (!hcntr)
            throw Exception(ccInvalidParameter);
        
        CV1Container &rv1cntr =
            scu::DownCast<CV1Container &, CAbstractContainer &>(*hcntr);
        
        CPublicKeyBlob KeyBlob;
        Clear(KeyBlob);
        rv1cntr.Record().Write(m_ks, KeyBlob);
    }
    else
        throw Exception(ccInvalidParameter);
}

                                                  // Access
                                                  // Predicates
bool
CV1PublicKey::DoEquals(CAbstractPublicKey const &rhs) const
{
    CV1PublicKey const &rv1rhs =
        scu::DownCast<CV1PublicKey const &, CAbstractPublicKey const &>(rhs);
    
    return rv1rhs.m_ks == m_ks;
}

                                                  // Static Variables


///////////////////////////    PRIVATE    /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations

void
CV1PublicKey::Load()
{
    if (ksNone != m_ks)
    {
        CV1Card &rv1card =
            scu::DownCast<CV1Card &, CAbstractCard &>(*m_hcard);

        CV1ContainerRecord CntrRec(rv1card,
                                   CV1ContainerRecord::DefaultName(), 
                                   CV1ContainerRecord::cmNever);

        m_apKeyBlob =
            auto_ptr<CPublicKeyBlob>(new CPublicKeyBlob);
        CntrRec.Read(m_ks, *m_apKeyBlob.get());

    }
    else
        throw Exception(ccInvalidParameter);
}

void
CV1PublicKey::Store()
{
    if (ksNone != m_ks)
    {
        if (m_apKeyBlob.get())
        {
            CV1Card &rv1card =
                scu::DownCast<CV1Card &, CAbstractCard &>(*m_hcard);

            CV1ContainerRecord CntrRec(rv1card,
                                       CV1ContainerRecord::DefaultName(),
                                       CV1ContainerRecord::cmNever);

            CntrRec.Write(m_ks, *m_apKeyBlob.get());
        
        }
    }
    else
        throw Exception(ccInvalidParameter);
}

                                                  // Access
                                                  // Predicates
                                                  // Static Variables
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\v2card.h ===
// cciV2Card.h: interface for the CV2Card class.
//
// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
//////////////////////////////////////////////////////////////////////

// Note: This header file should only be included by the CCI.  The
// client gets the declarations via cciCard.h

#if !defined(CCI_V2CARD_H)
#define CCI_V2CARD_H

#include <memory>                                 // for auto_ptr
#include <string>
#include <vector>

#include <iop.h>

#include <slbRCObj.h>

#include "ACard.h"
#include "cciCont.h"
#include "CardInfo.h"
#include "SymbolTable.h"
#include "ObjectInfoFile.h"
#include "cciCert.h"
#include "cciPubKey.h"
#include "cciPriKey.h"
#include "cciDataObj.h"

namespace cci
{

class CV2Container;

class CV2Card                                     // concrete class
    : public CAbstractCard
{
    friend CAbstractCard *
    CAbstractCard::Make(std::string const &rstrReaderName);

public:
                                                  // Types
                                                  // C'tors/D'tors

    virtual
    ~CV2Card() throw();

                                                  // Operators
                                                  // Operations

    virtual void
    ChangePIN(scu::SecureArray<BYTE> const &rstrOldPIN,
              scu::SecureArray<BYTE> const &rstrNewPIN);

    virtual void
    DefaultContainer(CContainer const &rcont);

    virtual std::pair<std::string, // interpreted as the public modulus
                      cci::CPrivateKey>
    GenerateKeyPair(KeyType kt,
                    std::string const &rsExponent,
                    ObjectAccess oaPrivateKey = oaPrivateAccess);

    virtual void
    InitCard();

    virtual void
    InvalidateCache();

    virtual void
    Label(std::string const &rstrLabel);

    virtual void
    VerifyKey(std::string const &rstrKey,
              BYTE bKeyNum);

                                                  // Access

    size_t
    AvailableStringSpace(ObjectAccess oa) const;

    CCardInfo &
    CardInfo() const;

    virtual CContainer
    DefaultContainer() const;

    virtual std::vector<CContainer>
    EnumContainers() const;

    virtual std::vector<CCertificate>
    EnumCertificates(ObjectAccess access) const;

    virtual std::vector<CPublicKey>
    EnumPublicKeys(ObjectAccess access) const;

    virtual std::vector<CPrivateKey>
    EnumPrivateKeys(ObjectAccess access) const;

    virtual std::vector<CDataObject>
    EnumDataObjects(ObjectAccess access) const;

    virtual std::string
    Label() const;

    BYTE
    MaxKeys(KeyType kt) const;

    size_t
    MaxStringSpace(ObjectAccess oa) const;

    CObjectInfoFile &
    ObjectInfoFile(ObjectAccess oa) const;

    virtual std::string
    PrivateKeyPath(KeyType kt) const;

    virtual std::string const &
    RootPath() const;

    virtual bool
    SupportedKeyFunction(KeyType kt,
                         CardOperation oper) const;

    virtual scu::Marker<unsigned int>
    MarkerOnCard() const;
                                                  // Predicates

    virtual bool
    IsCAPIEnabled() const;

    virtual bool
    IsPKCS11Enabled() const;

    virtual bool
    IsEntrustEnabled() const;

    virtual bool
    IsProtectedMode() const;

    virtual bool
    IsKeyGenEnabled() const;
    
    virtual BYTE
    MajorVersion() const;
    
    virtual bool
    IsMarkerOnCard() const;
    

protected:
                                                  // Types
                                                  // C'tors/D'tors

    CV2Card(std::string const &rstrReaderName,
            std::auto_ptr<iop::CIOP> &rapiop,
            std::auto_ptr<iop::CSmartCard> &rapSmartCard);
        // Note/TO DO: CardInfo is likely to be specific to the
        // CV2Card's format version.  Therefore, the extent that a
        // subclass can be defined for CV2Card is limited by the
        // ability of that subclass to utilize CV2Card's CardInfo.  A
        // concept to revisit.

                                                  // Operators
                                                  // Operations
    void
    DoSetup();

    virtual CAbstractCertificate *
    MakeCertificate(ObjectAccess oa) const;

    virtual CAbstractContainer *
    MakeContainer() const;

    virtual CAbstractDataObject *
    MakeDataObject(ObjectAccess oa) const;

    virtual CAbstractKeyPair *
    MakeKeyPair(CContainer const &rhcont,
                KeySpec ks) const;

    virtual CAbstractPrivateKey *
    MakePrivateKey(ObjectAccess oa) const;

    virtual CAbstractPublicKey *
    MakePublicKey(ObjectAccess oa) const;

                                                  // Access
                                                  // Predicates
                                                  // Variables

private:
                                                  // Types

    typedef CAbstractCard SuperClass;

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
    static std::auto_ptr<CAbstractCard>
    DoMake(std::string const &rstrReaderName,
           std::auto_ptr<iop::CIOP> &rapiop,
           std::auto_ptr<iop::CSmartCard> &rapSmartCard);

                                                  // Access
                                                  // Predicates
                                                  // Variables
    std::auto_ptr<CCardInfo> m_apCardInfo;
    std::auto_ptr<CObjectInfoFile> mutable m_apPublicObjectInfoFile;
    std::auto_ptr<CObjectInfoFile> mutable m_apPrivateObjectInfoFile;

    ArchivedSymbol mutable m_asLabel;
};

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\v2cert.h ===
// V2Cert.h: interface for the CV2Certificate class.
//
// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
//////////////////////////////////////////////////////////////////////

// Note:  This file should only be included by the CCI, not directly
// by the client.

#if !defined(SLBCCI_V2CERT_H)
#define SLBCCI_V2CERT_H

#include <string>
#include <memory>                                 // for auto_ptr

#include <slbRCObj.h>

#include "iop.h"
#include "slbarch.h"
#include "cciCard.h"
#include "ACert.h"

namespace cci {

class CV2Card;
class CCertificateInfoRecord;

class CV2Certificate
    : public CAbstractCertificate
{
public:
                                                  // Types
                                                  // C'tors/D'tors
    CV2Certificate(CV2Card const &rv2card,
                   ObjectAccess oa);

    CV2Certificate(CV2Card const &rv2card,
                   SymbolID sidHandle,
                   ObjectAccess oa);

    virtual
    ~CV2Certificate() throw();

                                                  // Operators
                                                  // Operations
    virtual void
    CredentialID(std::string const &rstrCredId);

    virtual void
    ID(std::string const &rstrId);

    virtual void
    Issuer(std::string const &rstrIssuer);

    virtual void
    Label(std::string const &rstrLabel);

    static CV2Certificate *
    Make(CV2Card const &rv2card,
         SymbolID sidHandle,
         ObjectAccess oa);

    virtual void
    Modifiable(bool flag);

    virtual void
    Subject(std::string const &rstrSubject);

    virtual void
    Serial(std::string const &rstrSerialNumber);

                                                  // Access
    virtual std::string
    CredentialID();

    SymbolID
    Handle() const;

    virtual std::string
    ID();

    virtual std::string
    Issuer();

    virtual std::string
    Label();

    virtual bool
    Modifiable();

    virtual bool
    Private();

    virtual std::string
    Serial();

    virtual std::string
    Subject();

                                                  // Predicates

protected:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
    virtual void
    DoDelete();

    virtual void
    DoValue(ZipCapsule const &rzc);

                                                  // Access
    virtual ZipCapsule
    DoValue();

                                                  // Predicates
    virtual bool
    DoEquals(CAbstractCertificate const &rhs) const;

                                                  // Variables

private:
                                                  // Types
                                                  // C'tors/D'tors
    CV2Certificate(CV2Certificate const &rhs);
        // not defined, copying not allowed.

                                                  // Operators
    CV2Certificate &
    operator=(CV2Certificate const &rhs);
        // not defined, initialization not allowed.

                                                  // Operations
    void
    Setup(CV2Card const &rv2card);

                                                  // Access
                                                  // Predicates
                                                  // Variables
    SymbolID m_sidHandle;
    std::auto_ptr<CCertificateInfoRecord> m_apcir;
};

}

#endif // !defined(SLBCCI_CERT_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\v2cont.cpp ===
// V2Cont.cpp: implementation of the CV2Container class.
//
// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
//////////////////////////////////////////////////////////////////////
#include "NoWarning.h"

#include <scuCast.h>

#include "slbCci.h"
#include "cciCard.h"
#include "TransactionWrap.h"

#include "ContainerInfoRecord.h"
#include "V2Cont.h"

using namespace std;
using namespace cci;

/////////////////////////// LOCAL/HELPER  /////////////////////////////////

///////////////////////////    PUBLIC     /////////////////////////////////

                                                  // Types
                                                  // C'tors/D'tors
CV2Container::CV2Container(CV2Card const &rv2card)
    : CAbstractContainer(rv2card),
      m_sidHandle(0),
      m_apcir()
{
    // Allocate new entry in object info file

    m_sidHandle =
        rv2card.ObjectInfoFile(oaPublicAccess).AddObject(otContainerObject,
                                                         ContInfoRecordSize);

    Setup(rv2card);

    m_apcir->Clear();
    m_apcir->Write();

}

CV2Container::CV2Container(CV2Card const &rv2card,
                           SymbolID sidHandle)
    : CAbstractContainer(rv2card),
      m_sidHandle(sidHandle),
      m_apcir()
{
    Setup(rv2card);

    m_apcir->Read();
}

CV2Container::~CV2Container() throw()
{}


                                                  // Operators
                                                  // Operations

void
CV2Container::ID(string const &rstrID)
{
    m_apcir->Symbol(&m_apcir->m_bID, rstrID);
}

CV2Container *
CV2Container::Make(CV2Card const &rv2card,
                   SymbolID sidHandle)
{
    CTransactionWrap wrap(rv2card);

    return new CV2Container(rv2card, sidHandle);
}

void
CV2Container::Name(string const &rstrName)
{
    m_apcir->Symbol(&m_apcir->m_bName, rstrName);
}

                                                  // Access
CContainerInfoRecord &
CV2Container::CIR() const
{
    return *m_apcir;
}


SymbolID
CV2Container::Handle() const
{
    return m_sidHandle;
}

string
CV2Container::ID()
{
    return m_apcir->Symbol(&m_apcir->m_bID);
}

string
CV2Container::Name()
{
    return m_apcir->Symbol(&m_apcir->m_bName);
}

                                                  // Predicates
                                                  // Static Variables

///////////////////////////   PROTECTED   /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
void
CV2Container::DoDelete()
{
    CV2Card &rv2card = scu::DownCast<CV2Card &, CAbstractCard &>(*m_hcard);

    if (m_apcir->m_bID)
        rv2card.ObjectInfoFile(oaPublicAccess).RemoveSymbol(m_apcir->m_bID);
    if (m_apcir->m_bName)
        rv2card.ObjectInfoFile(oaPublicAccess).RemoveSymbol(m_apcir->m_bName);

    rv2card.ObjectInfoFile(oaPublicAccess).RemoveObject(otContainerObject,
                                                        m_sidHandle);

}

                                                  // Access
                                                  // Predicates
bool
CV2Container::DoEquals(CAbstractContainer const &rhs) const
{
    CV2Container const &rv2rhs =
        scu::DownCast<CV2Container const &, CAbstractContainer const &>(rhs);

    return (rv2rhs.m_sidHandle == m_sidHandle);
}


                                                  // Static Variables


///////////////////////////    PRIVATE    /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
void
CV2Container::Setup(CV2Card const &rv2card)
{

    m_apcir =
        auto_ptr<CContainerInfoRecord>(new CContainerInfoRecord(rv2card,
                                                                m_sidHandle));
}

                                                  // Access
                                                  // Predicates
                                                  // Static Variables
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\v2cert.cpp ===
// CV2Cert.cpp: implementation of the CV2Certificate class.
//
// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
//////////////////////////////////////////////////////////////////////

#include <scuCast.h>

#include "cciCard.h"
#include "TransactionWrap.h"

#include "V2Cert.h"
#include "CertificateInfoRecord.h"

using namespace std;
using namespace cci;

/////////////////////////// LOCAL/HELPER  /////////////////////////////////

///////////////////////////    PUBLIC     /////////////////////////////////

                                                  // Types
                                                  // C'tors/D'tors
CV2Certificate::CV2Certificate(CV2Card const &rv2card,
                               ObjectAccess oa)
    : CAbstractCertificate(rv2card, oa),
      m_sidHandle(0),
      m_apcir()
{

    m_sidHandle =
        rv2card.ObjectInfoFile(oa).AddObject(otCertificateObject,
                                             CertInfoRecordSize);

    Setup(rv2card);

    // write new certificate object into info file
    m_apcir->Write();
}

CV2Certificate::CV2Certificate(CV2Card const &rv2card,
                               SymbolID sidHandle,
                               ObjectAccess oa)
    : CAbstractCertificate(rv2card, oa),
      m_sidHandle(sidHandle),
      m_apcir()
{
    Setup(rv2card);

}

CV2Certificate::~CV2Certificate() throw()
{}

                                                  // Operators
                                                  // Operations
void
CV2Certificate::CredentialID(string const &rstrCredID)
{
    m_apcir->Symbol(&m_apcir->m_bCredentialID, rstrCredID);
}

void
CV2Certificate::ID(string const &rstrId)
{
    m_apcir->Symbol(&m_apcir->m_bID, rstrId);
}


void
CV2Certificate::Issuer(string const &rstrIssuer)
{
    m_apcir->Symbol(&m_apcir->m_bIssuer, rstrIssuer);
}

void
CV2Certificate::Label(string const &rstrLabel)
{
    m_apcir->Symbol(&m_apcir->m_bLabel, rstrLabel);
}

CV2Certificate *
CV2Certificate::Make(CV2Card const &rv2card,
                     SymbolID sidHandle,
                     ObjectAccess oa)
{
    return new CV2Certificate(rv2card, sidHandle, oa);
}

void
CV2Certificate::Subject(string const &rstrSubject)
{
    m_apcir->Symbol(&m_apcir->m_bSubject, rstrSubject);
}

void
CV2Certificate::Modifiable(bool flag)
{
    m_apcir->Flag(CertModifiableFlag, flag);
}

void
CV2Certificate::Serial(string const &rstrSerialNumber)
{
    m_apcir->Symbol(&m_apcir->m_bSerialNumber, rstrSerialNumber);
}

                                                  // Access
string
CV2Certificate::CredentialID()
{
    return m_apcir->Symbol(&m_apcir->m_bCredentialID);
}

SymbolID
CV2Certificate::Handle() const
{
    return m_sidHandle;
}

string
CV2Certificate::ID()
{
    return m_apcir->Symbol(&m_apcir->m_bID);
}

string
CV2Certificate::Issuer()
{
    return m_apcir->Symbol(&m_apcir->m_bIssuer);
}

string
CV2Certificate::Label()
{
    return m_apcir->Symbol(&m_apcir->m_bLabel);
}

bool
CV2Certificate::Modifiable()
{
    return m_apcir->Flag(CertModifiableFlag);
}

bool
CV2Certificate::Private()
{
    return m_apcir->Private();
}

string
CV2Certificate::Serial()
{
    return m_apcir->Symbol(&m_apcir->m_bSerialNumber);
}

string
CV2Certificate::Subject()
{
    return m_apcir->Symbol(&m_apcir->m_bSubject);
}


                                                  // Predicates
                                                  // Static Variables

///////////////////////////   PROTECTED   /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
void
CV2Certificate::DoDelete()
{
    m_apcir->Read();

    CV2Card &rv2card = scu::DownCast<CV2Card &, CAbstractCard &>(*m_hcard);

    CObjectInfoFile &roif = rv2card.ObjectInfoFile(m_oa);

    if (m_apcir->m_bValue)
        roif.RemoveSymbol(m_apcir->m_bValue);
    if (m_apcir->m_bLabel)
        roif.RemoveSymbol(m_apcir->m_bLabel);
    if (m_apcir->m_bID)
        roif.RemoveSymbol(m_apcir->m_bID);
    if (m_apcir->m_bCredentialID)
        roif.RemoveSymbol(m_apcir->m_bCredentialID);
    if (m_apcir->m_bSubject)
        roif.RemoveSymbol(m_apcir->m_bSubject);
    if (m_apcir->m_bIssuer)
        roif.RemoveSymbol(m_apcir->m_bIssuer);
    if (m_apcir->m_bSerialNumber)
        roif.RemoveSymbol(m_apcir->m_bSerialNumber);

    roif.RemoveObject(otCertificateObject,m_sidHandle);

}

void
CV2Certificate::DoValue(ZipCapsule const &rzc)
{
    m_apcir->Read();

    m_apcir->m_bCompressAlg = rzc.IsCompressed();
    m_apcir->Symbol(&m_apcir->m_bValue, rzc.Data());

    m_apcir->Write();
}

                                                  // Access
CV2Certificate::ZipCapsule
CV2Certificate::DoValue()
{
    m_apcir->Read();

    return ZipCapsule(m_apcir->Symbol(&m_apcir->m_bValue),
                      (1 == m_apcir->m_bCompressAlg));
}
                                                  // Predicates

bool
CV2Certificate::DoEquals(CAbstractCertificate const &rhs) const
{
    CV2Certificate const &rv2rhs =
        scu::DownCast<CV2Certificate const &, CAbstractCertificate const &>(rhs);

    return rv2rhs.m_sidHandle == m_sidHandle;
}

                                                  // Static Variables


///////////////////////////    PRIVATE    /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
void
CV2Certificate::Setup(CV2Card const &rv2card)
{
    m_apcir =
        auto_ptr<CCertificateInfoRecord>(new CCertificateInfoRecord(rv2card,
                                                                    m_sidHandle,
                                                                    m_oa));

}

                                                  // Access
                                                  // Predicates
                                                  // Static Variables
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\v2cont.h ===
// V2Cont.h: interface for the CV2Container class.
//
// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
//////////////////////////////////////////////////////////////////////

// Note:  This file should only be included by the CCI, not directly
// by the client.

#if !defined(SLBCCI_V2CONT_H)
#define SLBCCI_V2CONT_H

#include <string>
#include <memory>                                 // for auto_ptr

#include "slbCci.h"
#include "cciCard.h"
#include "ACont.h"

namespace cci
{

class CV2Card;
class CContainerInfoRecord;

class CV2Container
    : public CAbstractContainer
{
public:
                                                  // Types
                                                  // C'tors/D'tors
    explicit
    CV2Container(CV2Card const &rv2card);

    CV2Container(CV2Card const &rv2card,
                 SymbolID sidHandle);

    virtual
    ~CV2Container() throw();

                                                  // Operators
                                                  // Operations
    virtual void
    ID(std::string const &rstrID);

    static CV2Container *
    Make(CV2Card const &rv2card,
         SymbolID sidHandle);

    virtual void
    Name(std::string const &rstrName);


                                                  // Access
    CContainerInfoRecord &
    CIR() const;

    SymbolID
    Handle() const;

    virtual std::string
    ID();

    virtual std::string
    Name();

                                                  // Predicates

protected:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
    virtual void
    DoDelete();

                                                  // Access
                                                  // Predicates
    virtual bool
    DoEquals(CAbstractContainer const &rhs) const;

                                                  // Variables

private:
                                                  // Types
                                                  // C'tors/D'tors
    CV2Container(CV2Container const &rhs);
        // not defined, copying not allowed.

                                                  // Operators
    CV2Container &
    operator=(CV2Container const &rhs);
        // not defined, initialization not allowed.

                                                  // Operations
    void
    Setup(CV2Card const &rv2card);

                                                  // Access
                                                  // Predicates
                                                  // Variables
    SymbolID m_sidHandle;
    std::auto_ptr<CContainerInfoRecord> m_apcir;
};

} // namespace cci

#endif // !defined(SLBCCI_V2CONT_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\v2card.cpp ===
// V2Card.cpp: implementation of the CV2Card class.
//
// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
//////////////////////////////////////////////////////////////////////
#include "NoWarning.h"

#include <scuCast.h>

#include "TransactionWrap.h"

#include "V2Card.h"

#include "V2Cert.h"
#include "V2Cont.h"
#include "V2PriKey.h"
#include "V2PubKey.h"
#include "V2KeyPair.h"
#include "V2DataObj.h"

using namespace std;
using namespace cci;
using namespace scu;

/////////////////////////// LOCAL/HELPER  /////////////////////////////////

namespace
{
    // Functors to make a T for a given symbol id (handle/symbol id)
    template<class T>
    class MakerFunction
    {
    public:
        typedef T ValueType;

        virtual
        ~MakerFunction() throw()
        {}

        virtual auto_ptr<T>
        operator()(SymbolID sid) const = 0;

    protected:
        MakerFunction(CV2Card const &rv2card)
            : m_rv2card(rv2card)
        {}

        CV2Card const &m_rv2card;
    };

    template<class T>
    class Maker2
        : public MakerFunction<T>
    {
    public:
        Maker2(CV2Card const &rv2card)
            : MakerFunction<T>(rv2card)
        {}

        auto_ptr<T>
        operator()(SymbolID sid) const
        {
            return auto_ptr<T>(new T(m_rv2card, sid));
        }
    };

    template<class T>
    class Maker3
        : public MakerFunction<T>
    {
    public:
        Maker3(CV2Card const &rv2card,
               ObjectAccess oa)
            : MakerFunction<T>(rv2card),
              m_oa(oa)
        {}

        auto_ptr<T>
        operator()(SymbolID sid) const
        {
            return auto_ptr<T>(new T(m_rv2card, sid, m_oa));
        }

    private:
        ObjectAccess m_oa;
    };


    // Enumerate objects in the object info file of object type OT,
    // returning a vector of R(object)
    template<class R, ObjectType OT, class T>
    vector<R>
    EnumPriviledgedObjects(CObjectInfoFile &rObjInfo,
                           MakerFunction<T> &rMaker)
    {
        SymbolID sid = rObjInfo.FirstObject(OT);

        vector<R> vResult;
        while (sid)
        {
            auto_ptr<MakerFunction<T>::ValueType> apObject(rMaker(sid));
            R Handle(apObject.get());

            apObject.release(); // transfer ownership to handle

            vResult.push_back(Handle);
            sid = rObjInfo.NextObject(sid);
        }

        return vResult;
    }

    bool
    IsSupported(iop::CSmartCard &rSmartCard) throw()
    {
        bool fSupported = false;

        try
        {
            rSmartCard.Select("/3f00/0000");
            rSmartCard.Select("/3f00/3f11/0020");
            rSmartCard.Select("/3f00/3f11/0030");
            rSmartCard.Select("/3f00/3f11/0031");

            fSupported = true;
        }

        catch(scu::Exception &)
        {}

        return fSupported;
    }
} // namespace


///////////////////////////    PUBLIC     /////////////////////////////////

                                                  // Types
                                                  // C'tors/D'tors
CV2Card::~CV2Card() throw()
{}


                                                  // Operators
                                                  // Operations
void
CV2Card::ChangePIN(SecureArray<BYTE> const &rstrOldPIN,
                   SecureArray<BYTE> const &rstrNewPIN)
{
    CTransactionWrap wrap(this);
        SmartCard().Select(RootPath().c_str());
    SuperClass::ChangePIN(rstrOldPIN, rstrNewPIN);
}

void
CV2Card::DefaultContainer(CContainer const &rcont)
{
    SymbolID sid = 0;

    if (rcont)
    {
        CV2Container &rv2cont = scu::DownCast<CV2Container &, CAbstractContainer &>(*rcont);
        sid = rv2cont.Handle();
    }

    ObjectInfoFile(oaPublicAccess).DefaultContainer(sid);
}

pair<string, // interpreted as the public modulus
     CPrivateKey>
CV2Card::GenerateKeyPair(KeyType kt,
                         string const &rsExponent,
                         ObjectAccess oaPrivateKey)
{
    CTransactionWrap wrap(this);

    // For the time being, assume this is implict RSA only....

    string::size_type const cExponentLength = rsExponent.size();

    if ((cExponentLength < 1) || (cExponentLength > 4))
        throw Exception(ccInvalidParameter);

    BYTE bKeyType;

    switch (kt)
    {
    case ktRSA512:
        bKeyType = CardKeyTypeRSA512;
        break;

    case ktRSA768:
        bKeyType = CardKeyTypeRSA768;
        break;

    case ktRSA1024:
        bKeyType = CardKeyTypeRSA1024;
        break;

    default:
        throw Exception(ccBadKeySpec);
        break;
    }

    // Allocated a slot in the key file, unless a correct one is
    // already allocated?

    CCardInfo &rci = this->CardInfo();

    BYTE bKeyNum = rci.AllocatePrivateKey(bKeyType);

    // Generate private key
        this->SmartCard().Select(PrivateKeyPath(kt).c_str());

    iop::CPublicKeyBlob pubkb(this->SmartCard().GenerateKeyPair(reinterpret_cast<BYTE const *>(rsExponent.data()),
                                                                static_cast<WORD>(cExponentLength),
                                                                bKeyNum,
                                                                kt));

    this->SmartCard().Select(RootPath().c_str());

    auto_ptr<CV2PrivateKey> apv2prikey(new CV2PrivateKey(*this,
                                                         bKeyType,
                                                         bKeyNum,
                                                         oaPrivateKey));
    string sModulus(reinterpret_cast<char *>(pubkb.bModulus),
                    pubkb.bModulusLength);

    return pair<string, CPrivateKey>(sModulus, apv2prikey.release());
}

void
CV2Card::InitCard()
{
    CTransactionWrap wrap(this);

    m_apCardInfo->Reset();

    ObjectInfoFile(oaPublicAccess).Reset();
    ObjectInfoFile(oaPrivateAccess).Reset();
}

void
CV2Card::InvalidateCache()
{

    CTransactionWrap wrap(this);
    m_apCardInfo->UpdateCache();
    m_asLabel.Dirty();

    m_apPublicObjectInfoFile = auto_ptr<CObjectInfoFile>(0);
    m_apPrivateObjectInfoFile = auto_ptr<CObjectInfoFile>(0);
}

void
CV2Card::Label(string const &rLabel)
{
    CTransactionWrap wrap(this);

    m_apCardInfo->Label(rLabel);
    m_asLabel.Value(rLabel);
}

void
CV2Card::VerifyKey(string const &rstrKey,
                     BYTE bKeyNum)
{
    CTransactionWrap wrap(this);
        SmartCard().Select(RootPath().c_str());
    SuperClass::VerifyKey(rstrKey, bKeyNum);
}


                                                  // Access
size_t
CV2Card::AvailableStringSpace(ObjectAccess oa) const
{
    CTransactionWrap wrap(this);
    return ObjectInfoFile(oa).FreeSpace();
}

CCardInfo &
CV2Card::CardInfo() const
{
    return *m_apCardInfo;
}

CContainer
CV2Card::DefaultContainer() const
{
    CTransactionWrap wrap(this);

    SymbolID sid = ObjectInfoFile(oaPublicAccess).DefaultContainer();
    return sid
        ? CContainer(CV2Container::Make(*this, sid))
        : CContainer();
}

vector<CContainer>
CV2Card::EnumContainers() const
{
    CTransactionWrap wrap(this);

    Maker2<CV2Container> Maker(*this);

    return
        EnumPriviledgedObjects<CContainer,
                               otContainerObject>(ObjectInfoFile(oaPublicAccess),
                                                  Maker);
}

vector<CCertificate>
CV2Card::EnumCertificates(ObjectAccess access) const
{
    CTransactionWrap wrap(this);

    Maker3<CV2Certificate> Maker(*this, access);

    return
        EnumPriviledgedObjects<CCertificate,
                               otCertificateObject>(ObjectInfoFile(access),
                                                    Maker);
}

vector<CPublicKey>
CV2Card::EnumPublicKeys(ObjectAccess access) const
{
    CTransactionWrap wrap(this);

    Maker3<CV2PublicKey> Maker(*this, access);

    return
        EnumPriviledgedObjects<CPublicKey,
                               otPublicKeyObject>(ObjectInfoFile(access),
                                                  Maker);
}

vector<CPrivateKey>
CV2Card::EnumPrivateKeys(ObjectAccess access) const
{
    CTransactionWrap wrap(this);

    Maker3<CV2PrivateKey> Maker(*this, access);

    return
        EnumPriviledgedObjects<CPrivateKey,
                               otPrivateKeyObject>(ObjectInfoFile(access),
                                                   Maker);
}

vector<CDataObject>
CV2Card::EnumDataObjects(ObjectAccess access) const
{
    CTransactionWrap wrap(this);

    Maker3<CV2DataObject> Maker(*this, access);

    return
        EnumPriviledgedObjects<CDataObject,
                               otDataObjectObject>(ObjectInfoFile(access),
                                                   Maker);
}

string
CV2Card::Label() const
{

    CTransactionWrap wrap(this);

    if (!m_asLabel.IsCached())
            m_asLabel.Value(m_apCardInfo->Label());

    return m_asLabel.Value();
}

CAbstractCertificate *
CV2Card::MakeCertificate(ObjectAccess oa) const
{
    CTransactionWrap wrap(this);

    return new CV2Certificate(*this, oa);
}

CAbstractContainer *
CV2Card::MakeContainer() const
{
    CTransactionWrap wrap(this);

    return new CV2Container(*this);
}

CAbstractDataObject *
CV2Card::MakeDataObject(ObjectAccess oa) const
{
    CTransactionWrap wrap(this);

    return new CV2DataObject(*this, oa);
}

CAbstractKeyPair *
CV2Card::MakeKeyPair(CContainer const &rhcont,
                     KeySpec ks) const
{
    CTransactionWrap wrap(this);

    return new CV2KeyPair(*this, rhcont, ks);
}

CAbstractPrivateKey *
CV2Card::MakePrivateKey(ObjectAccess oa) const
{
    CTransactionWrap wrap(this);

    return new CV2PrivateKey(*this, oa);
}

CAbstractPublicKey *
CV2Card::MakePublicKey(ObjectAccess oa) const
{
    CTransactionWrap wrap(this);

    return new CV2PublicKey(*this, oa);
}

BYTE
CV2Card::MaxKeys(KeyType kt) const
{
    BYTE bCount;

    switch (kt)
    {
    case ktRSA512:
        bCount = m_apCardInfo->NumRSA512Keys();
        break;

    case ktRSA768:
        bCount = m_apCardInfo->NumRSA768Keys();
        break;

    case ktRSA1024:
        bCount = m_apCardInfo->NumRSA1024Keys();
        break;

    default:
        bCount = 0;
        break;
    }

    return bCount;
}

size_t
CV2Card::MaxStringSpace(ObjectAccess oa) const
{
    return ObjectInfoFile(oa).TableSize();
}

string
CV2Card::PrivateKeyPath(KeyType kt) const
{
    string sPrivateKeyPath(RootPath());

    switch (kt)
    {
    case ktRSA512:
        sPrivateKeyPath += "3f01";
        break;

    case ktRSA768:
        sPrivateKeyPath += "3f02";
        break;

    case ktRSA1024:
        sPrivateKeyPath += "3f03";
        break;

    default:
        throw Exception(ccBadKeySpec);
        break;
    }

    return sPrivateKeyPath;
}

string const &
CV2Card::RootPath() const
{
    static string const sRootPath("/3f00/3f11/");

    return sRootPath;
}

bool
CV2Card::SupportedKeyFunction(KeyType kt,
                              CardOperation oper) const
{
    bool fSupported = false;

    switch (oper)
    {
    case coEncryption:    // .. or public key operations
        switch (kt)
        {

        case ktRSA512:
        case ktRSA768:
        case ktRSA1024:
            fSupported = false;
            break;

        default:
            fSupported = false;
            break;
        }

    case coDecryption:    // .. or private key operations
        switch (kt)
        {

        case ktRSA512:
        case ktRSA768:
        case ktRSA1024:
            fSupported = true;
            break;

        default:
            fSupported = false;
            break;
        }

    case coKeyGeneration:
        switch (kt)
        {

        case ktRSA512:
        case ktRSA768:
        case ktRSA1024:
            {
                BYTE flag = m_apCardInfo->UsagePolicy();
                fSupported = BitSet(&flag, CardKeyGenSupportedFlag);
                break;
            }


        default:
            break;
        }
    default:
        break;
    }

    return fSupported;
}

scu::Marker<unsigned int>
CV2Card::MarkerOnCard() const
{
    // Security: in order to avoid using the insecure mapped file
    // object we use a marker on the card. This reduces efficiency but
    // improves security. We use the last 4 butes (RFU) from the
    // object info file of the 0030 file. The 0030 file is readable
    // but write protected by the user pin.  

    WORD wOffset = 6;// the last 4 out of 10 bytes will be used
    unsigned int nMarker = 0;
    const WORD wBufLength = 4;
    
    CTransactionWrap wrap(this);    

    this->SmartCard().Select("/3f00/3f11/0030");    
    this->SmartCard().ReadBinary(wOffset,
                                 wBufLength,
                                 (BYTE*)&nMarker);
    if(this->SmartCard().Dirty())
    {
        // Information was written to the card. Update the marker
        nMarker++;
        this->SmartCard().WriteBinary(wOffset,
                                      wBufLength,
                                      (BYTE*)&nMarker);
    }
    
    return scu::Marker<unsigned int>(nMarker);
}

                                                  // Predicates
bool
CV2Card::IsCAPIEnabled() const
{
    BYTE flag = m_apCardInfo->UsagePolicy();
    return BitSet(&flag,CardCryptoAPIEnabledFlag);
}

bool
CV2Card::IsPKCS11Enabled() const
{
    BYTE flag = m_apCardInfo->UsagePolicy();
    return BitSet(&flag,CardPKCS11EnabledFlag);
}

bool
CV2Card::IsProtectedMode() const
{
    BYTE flag = m_apCardInfo->UsagePolicy();
    return BitSet(&flag,CardProtectedWriteFlag);
}

bool
CV2Card::IsKeyGenEnabled() const
{
        BYTE flag = m_apCardInfo->UsagePolicy();
        return BitSet(&flag,CardKeyGenSupportedFlag);
}

bool
CV2Card::IsEntrustEnabled() const
{
    BYTE flag = m_apCardInfo->UsagePolicy();
    return BitSet(&flag,CardEntrustEnabledFlag);
}

BYTE
CV2Card::MajorVersion() const
{
        return m_apCardInfo->FormatVersion().bMajor;
}

bool
CV2Card::IsMarkerOnCard() const
{
    return true;
}

                                                  // Static Variables

///////////////////////////   PROTECTED   /////////////////////////////////

                                                  // C'tors/D'tors
CV2Card::CV2Card(string const &rstrReaderName,
                 auto_ptr<iop::CIOP> &rapiop,
                 auto_ptr<iop::CSmartCard> &rapSmartCard)
    : SuperClass(rstrReaderName, rapiop, rapSmartCard),
      m_apCardInfo(auto_ptr<CCardInfo>(new CCardInfo(*rapSmartCard.get()))),
      m_apPublicObjectInfoFile(),
      m_apPrivateObjectInfoFile(),
      m_asLabel()
{}

                                                  // Operators
                                                  // Operations
void
CV2Card::DoSetup()
{
    CAbstractCard::DoSetup();

    m_apCardInfo->UpdateCache();
}

                                                  // Access
                                                  // Predicates
                                                  // Static Variables


///////////////////////////    PRIVATE    /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
auto_ptr<CAbstractCard>
CV2Card::DoMake(string const &rstrReaderName,
                auto_ptr<iop::CIOP> &rapiop,
                auto_ptr<iop::CSmartCard> &rapSmartCard)
{
    return IsSupported(*rapSmartCard.get())
        ? auto_ptr<CAbstractCard>(new CV2Card(rstrReaderName, rapiop,
                                              rapSmartCard))
        : auto_ptr<CAbstractCard>(0);
}


                                                  // Access
CObjectInfoFile &
CV2Card::ObjectInfoFile(ObjectAccess oa) const
{

    CObjectInfoFile *poif;

    switch (oa)
    {

    case oaPublicAccess:
        if (!m_apPublicObjectInfoFile.get())
        {
            m_apPublicObjectInfoFile =
                auto_ptr<CObjectInfoFile>(new
                                          CObjectInfoFile(SmartCard(),
                                                          "/3f00/3f11/0030",
                                                          oa));
            m_apPublicObjectInfoFile->UpdateCache();
        }
        poif = m_apPublicObjectInfoFile.get();
        break;

    case oaPrivateAccess:
        if (!m_apPrivateObjectInfoFile.get())
        {
            m_apPrivateObjectInfoFile =
                auto_ptr<CObjectInfoFile>(new
                                          CObjectInfoFile(SmartCard(),
                                                          "/3f00/3f11/0031",
                                                          oa));
            m_apPrivateObjectInfoFile->UpdateCache();
        }
        poif = m_apPrivateObjectInfoFile.get();
        break;

    default:
        throw Exception(ccBadAccessSpec);
    }

    return *poif;
}

                                                  // Predicates
                                                  // Static Variables
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\v2dataobj.cpp ===
// CV2DataObj.cpp: implementation of the CV2DataObject class.
//
// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
//////////////////////////////////////////////////////////////////////
#include "NoWarning.h"

#include <scuCast.h>

#include "TransactionWrap.h"

#include "V2DataObj.h"
#include "DataObjectInfoRecord.h"

using namespace std;
using namespace cci;

/////////////////////////// LOCAL/HELPER  /////////////////////////////////

///////////////////////////    PUBLIC     /////////////////////////////////

                                                  // Types
                                                  // C'tors/D'tors
CV2DataObject::CV2DataObject(CV2Card const &rv2card,
                             ObjectAccess oa)
    : CAbstractDataObject(rv2card, oa),
      m_sidHandle(0),
      m_apcir()
{
    // Allocate new entry in object info file
    m_sidHandle =
        rv2card.ObjectInfoFile(oa).AddObject(otDataObjectObject,
                                             DataInfoRecordSize);
    Setup(rv2card);

    m_apcir->Clear();
    m_apcir->Write();
}

CV2DataObject::CV2DataObject(CV2Card const &rv2card,
                             SymbolID sidHandle,
                             ObjectAccess oa)
    : CAbstractDataObject(rv2card, oa),
      m_sidHandle(sidHandle),
      m_apcir()
{
    Setup(rv2card);
}

CV2DataObject::~CV2DataObject() throw()
{}

                                                  // Operators
                                                  // Operations
void
CV2DataObject::Application(std::string const &rstr)
{
    m_apcir->Symbol(&m_apcir->m_bApplication, rstr);
}

void
CV2DataObject::Label(string const &rstrLabel)
{
    m_apcir->Symbol(&m_apcir->m_bLabel, rstrLabel);
}

void
CV2DataObject::Modifiable(bool flag)
{
    m_apcir->Flag(DataModifiableFlag,flag);
}

CV2DataObject *
CV2DataObject::Make(CV2Card const &rv2card,
                    SymbolID sidHandle,
                    ObjectAccess oa)
{
    return new CV2DataObject(rv2card, sidHandle, oa);
}

                                                  // Access
string
CV2DataObject::Application()
{
    return m_apcir->Symbol(&m_apcir->m_bApplication);
}

SymbolID
CV2DataObject::Handle()
{
    return m_sidHandle;
}

string
CV2DataObject::Label()
{
    return m_apcir->Symbol(&m_apcir->m_bLabel);
}

bool
CV2DataObject::Modifiable()
{
    return m_apcir->Flag(DataModifiableFlag);
}

bool
CV2DataObject::Private()
{
    return m_apcir->Private();
}


                                                  // Predicates
                                                  // Static Variables

///////////////////////////   PROTECTED   /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
void
CV2DataObject::DoDelete()
{
    CV2Card &rv2card = scu::DownCast<CV2Card &, CAbstractCard &>(*Card());

    CObjectInfoFile &roif = rv2card.ObjectInfoFile(m_oa);

    m_apcir->Read();

    if (m_apcir->m_bLabel)
        roif.RemoveSymbol(m_apcir->m_bLabel);
    if (m_apcir->m_bApplication)
        roif.RemoveSymbol(m_apcir->m_bApplication);
    if (m_apcir->m_bValue)
        roif.RemoveSymbol(m_apcir->m_bValue);

    roif.RemoveObject(otDataObjectObject, m_sidHandle);
}

void
CV2DataObject::DoValue(ZipCapsule const &rzc)
{
    m_apcir->Read();

    m_apcir->m_bCompressAlg = rzc.IsCompressed();
    m_apcir->Symbol(&m_apcir->m_bValue, rzc.Data());

    m_apcir->Write();
}

                                                  // Access
CV2DataObject::ZipCapsule
CV2DataObject::DoValue()
{
    m_apcir->Read();

    return ZipCapsule(m_apcir->Symbol(&m_apcir->m_bValue),
                      ((0 != m_apcir->m_bValue) && // nils are not compressed
                       (1 == m_apcir->m_bCompressAlg)));
}

                                                  // Predicates
bool
CV2DataObject::DoEquals(CAbstractDataObject const &rhs) const
{
    CV2DataObject const &rv2rhs =
        scu::DownCast<CV2DataObject const &, CAbstractDataObject const &>(rhs);

    return rv2rhs.m_sidHandle == m_sidHandle;
}

                                                  // Static Variables


///////////////////////////    PRIVATE    /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
void
CV2DataObject::Setup(CV2Card const &rv2card)
{
    m_apcir =
        auto_ptr<CDataObjectInfoRecord>(new CDataObjectInfoRecord(rv2card,
                                                                  m_sidHandle,
                                                                  m_oa));
}

                                                  // Access
                                                  // Predicates
                                                  // Static Variables
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\v2dataobj.h ===
// V2DataObj.h: interface for the CV2DataObject class.
//
// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
//////////////////////////////////////////////////////////////////////

// Note:  This file should only be included by the CCI, not directly
// by the client.

#if !defined(SLBCCI_V2DATAOBJ_H)
#define SLBCCI_V2DATAOBJ_H

#include <string>
#include <memory>                                 // for auto_ptr

#include <slbRCObj.h>

#include "iop.h"
#include "slbarch.h"
#include "ADataObj.h"

namespace cci {

class CV2Card;
class CDataObjectInfoRecord;

class CV2DataObject
    : public CAbstractDataObject
{

public:
                                                  // Types
                                                  // C'tors/D'tors
    CV2DataObject(CV2Card const &rv2card,
                  ObjectAccess oa);

    CV2DataObject(CV2Card const &rv2card,
                  SymbolID sidHandle,
                  ObjectAccess oa);

    virtual
    ~CV2DataObject() throw();

                                                  // Operators
                                                  // Operations
    virtual void
    Application(std::string const &rstr);

    virtual void
    Label(std::string const &rstrLabel);

    static CV2DataObject *
    Make(CV2Card const &rv2card,
          SymbolID sidHandle,
          ObjectAccess oa);

    virtual void
    Modifiable(bool flag);


                                                  // Access
    virtual std::string
    Application();

    SymbolID
    Handle();

    virtual std::string
    Label();

    virtual bool
    Modifiable();

    virtual bool
    Private();

                                                  // Predicates

protected:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
    virtual void
    DoDelete();

    virtual void
    DoValue(ZipCapsule const &rzc);

                                                  // Access
    virtual ZipCapsule
    DoValue();

                                                  // Predicates
    virtual bool
    DoEquals(CAbstractDataObject const &rhs) const;

                                                  // Variables

private:
                                                  // Types
                                                  // C'tors/D'tors
    CV2DataObject(CV2DataObject const &rhs);
        // not defined, copying not allowed.

                                                  // Operators
    CV2DataObject &
    operator=(CV2DataObject const &rhs);
        // not defined, initialization not allowed.

                                                  // Operations
    void
    Setup(CV2Card const &rv2card);


                                                  // Access
                                                  // Predicates
                                                  // Variables
    SymbolID m_sidHandle;
    std::auto_ptr<CDataObjectInfoRecord> m_apcir;
};

}

#endif // !defined(SLBCCI_CERT_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\v2prikey.cpp ===
// V2PriKey.cpp: implementation of the CV2PriKey class.
//
// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
//////////////////////////////////////////////////////////////////////

#include <scuCast.h>

#include <iopPubBlob.h>

#include "cciCard.h"
#include "TransactionWrap.h"

#include "V2PriKey.h"
#include "PriKeyInfoRecord.h"

using namespace std;
using namespace cci;

/////////////////////////// LOCAL/HELPER  /////////////////////////////////

///////////////////////////    PUBLIC     /////////////////////////////////

                                                  // Types
                                                  // C'tors/D'tors
CV2PrivateKey::CV2PrivateKey(CV2Card const &rv2card,
                             ObjectAccess oa)
    : CAbstractPrivateKey(rv2card, oa),
      m_sidHandle(0),
      m_apcir()
{
    Setup(rv2card);

    // write new private key object into info file
    m_apcir->Write();
}

CV2PrivateKey::CV2PrivateKey(CV2Card const &rv2card,
                             SymbolID sidHandle,
                             ObjectAccess oa)
    : CAbstractPrivateKey(rv2card, oa),
      m_sidHandle(0),
      m_apcir()
{
    Setup(rv2card, sidHandle);
}

CV2PrivateKey::CV2PrivateKey(CV2Card const &rv2card,
                             BYTE bKeyType,
                             BYTE bKeyNumber,
                             ObjectAccess oa)
    : CAbstractPrivateKey(rv2card, oa),
      m_sidHandle(0),
      m_apcir()
{
    Setup(rv2card);

    m_apcir->m_bKeyType = bKeyType;
    m_apcir->m_bKeyNum  = bKeyNumber;

    // write new private key object into info file
        m_apcir->Write();
}

CV2PrivateKey::~CV2PrivateKey()
{}

                                                  // Operators
                                                  // Operations

void
CV2PrivateKey::CredentialID(string const &rstrID)
{
    m_apcir->Symbol(&m_apcir->m_bCredentialID, rstrID);
}

void
CV2PrivateKey::Decrypt(bool flag)
{
    m_apcir->Flag(PrivDecryptFlag, flag);
}

void
CV2PrivateKey::Derive(bool flag)
{
    m_apcir->Flag(PrivDeriveFlag, flag);
}

void
CV2PrivateKey::EndDate(Date const &rEndDate)
{
    CTransactionWrap wrap(m_hcard);

    m_apcir->Read();
    m_apcir->m_dtEnd = rEndDate;
    m_apcir->Write();
}

void
CV2PrivateKey::Exportable(bool flag)
{
    m_apcir->Flag(PrivExportableFlag, flag);
}

void
CV2PrivateKey::ID(string const &rstrID)
{
    m_apcir->Symbol(&m_apcir->m_bID, rstrID);
}

string
CV2PrivateKey::InternalAuth(string const &rstrOld)
{
    CTransactionWrap wrap(m_hcard);

    m_apcir->Read();

    string strRetVal;
    if (rstrOld.size() > 0x80)
        throw Exception(ccBadLength);

    if(m_apcir->m_bKeyType == CardKeyTypeNone)
        throw Exception(ccKeyNotFound);

    BYTE bKeyNum = m_apcir->m_bKeyNum;

    BYTE bData[128];
    m_hcard->SmartCard().Select("/3f00/3f11/3f03");

    // TODO: Handling of keys with length != 1024 is incomplete

    m_hcard->SmartCard().InternalAuth(ktRSA1024, bKeyNum,
                                      static_cast<BYTE>(rstrOld.length()),
                                      reinterpret_cast<BYTE const *>(rstrOld.data()),
                                      bData);

    strRetVal = string(reinterpret_cast<char *>(bData), rstrOld.length());

    m_hcard->SmartCard().Select("/3f00/3f11");

    return strRetVal;
}

void
CV2PrivateKey::Label(string const &rstrLabel)
{
    m_apcir->Symbol(&m_apcir->m_bLabel, rstrLabel);
}

void
CV2PrivateKey::Local(bool flag)
{
    m_apcir->Flag(PrivLocalFlag, flag);
}

CV2PrivateKey *
CV2PrivateKey::Make(CV2Card const &rv2card,
                    SymbolID sidHandle,
                    ObjectAccess oa)
{
    return new CV2PrivateKey(rv2card, sidHandle, oa);
}


void
CV2PrivateKey::Modifiable(bool flag)
{
    m_apcir->Flag(PrivModifiableFlag, flag);
}

void
CV2PrivateKey::Modulus(string const &rstrModulus)
{
    m_apcir->Symbol(&m_apcir->m_bModulus, rstrModulus);
}

void
CV2PrivateKey::NeverExportable(bool flag)
{
    m_apcir->Flag(PrivNeverExportableFlag, flag);
}

void
CV2PrivateKey::NeverRead(bool flag)
{
    m_apcir->Flag(PrivNeverReadFlag, flag);
}

void
CV2PrivateKey::PublicExponent(string const &rstrExponent)
{
    m_apcir->Symbol(&m_apcir->m_bPublExponent, rstrExponent);
}

void
CV2PrivateKey::Read(bool flag)
{
    m_apcir->Flag(PrivReadFlag, flag);
}

void
CV2PrivateKey::Sign(bool flag)
{
    m_apcir->Flag(PrivSignFlag, flag);
}

void
CV2PrivateKey::SignRecover(bool flag)
{
    m_apcir->Flag(PrivSignRecoverFlag, flag);
}

void
CV2PrivateKey::StartDate(Date &rdtStart)
{
    CTransactionWrap wrap(m_hcard);

    m_apcir->Read();
    m_apcir->m_dtStart = rdtStart;
    m_apcir->Write();
}

void
CV2PrivateKey::Subject(string const &rstrSubject)
{
    m_apcir->Symbol(&m_apcir->m_bSubject, rstrSubject);
}

void
CV2PrivateKey::Unwrap(bool flag)
{
    m_apcir->Flag(PrivUnwrapFlag, flag);
}

                                                  // Access
string
CV2PrivateKey::CredentialID()
{
    return m_apcir->Symbol(&m_apcir->m_bCredentialID);
}

bool
CV2PrivateKey::Decrypt()
{
    return m_apcir->Flag(PrivDecryptFlag);
}

bool
CV2PrivateKey::Derive()
{
    return m_apcir->Flag(PrivDeriveFlag);
}

Date
CV2PrivateKey::EndDate()
{
    CTransactionWrap wrap(m_hcard);

    m_apcir->Read();
    return m_apcir->m_dtEnd;
}

bool
CV2PrivateKey::Exportable()
{
    return m_apcir->Flag(PrivExportableFlag);
}

SymbolID
CV2PrivateKey::Handle() const
{
    return m_sidHandle;
}

string
CV2PrivateKey::ID()
{
    return m_apcir->Symbol(&m_apcir->m_bID);
}

string
CV2PrivateKey::Label()
{
    return m_apcir->Symbol(&m_apcir->m_bLabel);
}

bool
CV2PrivateKey::Local()
{
    return m_apcir->Flag(PrivLocalFlag);
}

bool
CV2PrivateKey::Modifiable()
{
    return m_apcir->Flag(PrivModifiableFlag);
}

string
CV2PrivateKey::Modulus()
{
    return m_apcir->Symbol(&m_apcir->m_bModulus);
}

bool
CV2PrivateKey::NeverExportable()
{
    return m_apcir->Flag(PrivNeverExportableFlag);
}

bool
CV2PrivateKey::NeverRead()
{
    return m_apcir->Flag(PrivNeverReadFlag);
}

bool
CV2PrivateKey::Private()
{
    return m_apcir->Private();
}

string
CV2PrivateKey::PublicExponent()
{
    return m_apcir->Symbol(&m_apcir->m_bPublExponent);
}

bool
CV2PrivateKey::Read()
{
    return m_apcir->Flag(PrivReadFlag);
}

bool
CV2PrivateKey::Sign()
{
    return m_apcir->Flag(PrivSignFlag);
}

bool
CV2PrivateKey::SignRecover()
{
    return m_apcir->Flag(PrivSignRecoverFlag);
}

Date
CV2PrivateKey::StartDate()
{
    CTransactionWrap wrap(m_hcard);

    m_apcir->Read();
    return m_apcir->m_dtStart;

}

string
CV2PrivateKey::Subject()
{
    return m_apcir->Symbol(&m_apcir->m_bSubject);
}

bool
CV2PrivateKey::Unwrap()
{
    return m_apcir->Flag(PrivUnwrapFlag);
}


                                                  // Predicates
                                                  // Static Variables

///////////////////////////   PROTECTED   /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
bool
CV2PrivateKey::DoEquals(CAbstractPrivateKey const &rhs) const
{
    CV2PrivateKey const &rv2rhs =
        scu::DownCast<CV2PrivateKey const &, CAbstractPrivateKey const &>(rhs);

    return (rv2rhs.m_sidHandle == m_sidHandle);
}

                                                  // Operations

void
CV2PrivateKey::DoDelete()
{
    m_apcir->Read();

    CV2Card &rv2card = scu::DownCast<CV2Card &, CAbstractCard &>(*m_hcard);

    CObjectInfoFile &roif = rv2card.ObjectInfoFile(m_oa);

    // Remove allocation of entry in private key file
    if (m_apcir->m_bKeyType!=CardKeyTypeNone)
    {
        CCardInfo &rci = rv2card.CardInfo();
        rci.FreePrivateKey(m_apcir->m_bKeyType, m_apcir->m_bKeyNum);
    }

    // Release symbols

    if (m_apcir->m_bLabel)
        roif.RemoveSymbol(m_apcir->m_bLabel);
    if (m_apcir->m_bID)
        roif.RemoveSymbol(m_apcir->m_bID);
    if (m_apcir->m_bCredentialID)
        roif.RemoveSymbol(m_apcir->m_bCredentialID);
    if (m_apcir->m_bSubject)
        roif.RemoveSymbol(m_apcir->m_bSubject);
    if (m_apcir->m_bModulus)
        roif.RemoveSymbol(m_apcir->m_bModulus);
    if (m_apcir->m_bPublExponent)
        roif.RemoveSymbol(m_apcir->m_bPublExponent);

    // Delete info record

    roif.RemoveObject(otPrivateKeyObject, m_sidHandle);

}

void
CV2PrivateKey::DoWriteKey(CPrivateKeyBlob const &rblob)
{
    m_apcir->Read();

    BYTE bKeyType;
    KeyType kt;
    switch(rblob.bPLen)
    {
    case 0x20:
        bKeyType = CardKeyTypeRSA512;
        kt       = ktRSA512;
        break;

    case 0x30:
        bKeyType = CardKeyTypeRSA768;
        kt       = ktRSA768;
        break;

    case 0x40:
        bKeyType = CardKeyTypeRSA1024;
        kt       = ktRSA1024;
        break;

    default:
        throw Exception(ccBadKeySpec);
    }

    // Allocated a slot in the key file, unless a correct one is
    // already allocated?
    CV2Card &rv2card = scu::DownCast<CV2Card &, CAbstractCard &>(*m_hcard);
    CCardInfo &rci = rv2card.CardInfo();

    BYTE bKeyNum;
    if (CardKeyTypeNone != m_apcir->m_bKeyType)
    {
        if (m_apcir->m_bKeyType != bKeyType)
        {
            rci.FreePrivateKey(m_apcir->m_bKeyType, m_apcir->m_bKeyNum);
            m_apcir->m_bKeyType = CardKeyTypeNone;
            m_apcir->Write();
        }
        else
            bKeyNum = m_apcir->m_bKeyNum;
    }

    if (CardKeyTypeNone == m_apcir->m_bKeyType)
        bKeyNum = rci.AllocatePrivateKey(bKeyType);

    // Store private key blob
        rv2card.SmartCard().Select(rv2card.PrivateKeyPath(kt).c_str());
        rv2card.SmartCard().WritePrivateKey(rblob, bKeyNum);

    m_apcir->m_bKeyType = bKeyType;
    m_apcir->m_bKeyNum  = bKeyNum;

    rv2card.SmartCard().Select(rv2card.RootPath().c_str());
    m_apcir->Write();
}

                                                  // Access
                                                  // Predicates
                                                  // Static Variables


///////////////////////////    PRIVATE    /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations

void
CV2PrivateKey::Setup(CV2Card const &rv2card)
{
    Setup(rv2card,
          rv2card.ObjectInfoFile(m_oa).AddObject(otPrivateKeyObject,
                                                 PrivInfoRecordSize));

}

void
CV2PrivateKey::Setup(CV2Card const &rv2card,
                     SymbolID sidHandle)
{
    m_sidHandle = sidHandle;

    m_apcir =
        auto_ptr<CPriKeyInfoRecord>(new CPriKeyInfoRecord(rv2card,
                                                          m_sidHandle,
                                                          m_oa));
}


                                                  // Access
                                                  // Predicates
                                                  // Static Variables
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\v2pubkey.cpp ===
// V2PubKey.cpp: implementation of the CV2PubKey class.
//
// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
//////////////////////////////////////////////////////////////////////

#include <scuCast.h>

#include "cciCard.h"
#include "TransactionWrap.h"

#include "V2PubKey.h"
#include "PubKeyInfoRecord.h"

using namespace std;
using namespace cci;

/////////////////////////// LOCAL/HELPER  /////////////////////////////////

///////////////////////////    PUBLIC     /////////////////////////////////

                                                  // Types
                                                  // C'tors/D'tors
CV2PublicKey::CV2PublicKey(CV2Card const &rv2card,
                           ObjectAccess oa)
    : CAbstractPublicKey(rv2card, oa),
      m_sidHandle(0),
      m_apcir()
{

    m_sidHandle =
        rv2card.ObjectInfoFile(m_oa).AddObject(otPublicKeyObject,
                                               PublInfoRecordSize);

    Setup(rv2card);

    // write new public key object into info file
    m_apcir->Clear();
    m_apcir->Write();
}

CV2PublicKey::CV2PublicKey(CV2Card const &rv2card,
                           SymbolID sidHandle,
                           ObjectAccess oa)
    : CAbstractPublicKey(rv2card, oa),
      m_sidHandle(sidHandle),
      m_apcir()
{
    Setup(rv2card);
}

CV2PublicKey::~CV2PublicKey()
{}


                                                  // Operators
                                                  // Operations
void
CV2PublicKey::CKInvisible(bool flag)
{
    m_apcir->Flag(PublCKInvisibleFlag, flag);
}

void
CV2PublicKey::CredentialID(string const &rstrID)
{
    m_apcir->Symbol(&m_apcir->m_bCredentialID, rstrID);
}

void
CV2PublicKey::Derive(bool flag)
{
    m_apcir->Flag(PublDeriveFlag, flag);
}

void
CV2PublicKey::ID(string const &rstrID)
{
    m_apcir->Symbol(&m_apcir->m_bID, rstrID);
}

void
CV2PublicKey::EndDate(Date const &rdtEnd)
{
    CTransactionWrap wrap(m_hcard);
    m_apcir->Read();
    m_apcir->m_dtEnd = rdtEnd;
    m_apcir->Write();
}

bool
CV2PublicKey::Encrypt()
{
    return m_apcir->Flag(PublEncryptFlag);
}

void
CV2PublicKey::Exponent(string const &rstrExp)
{
    m_apcir->Symbol(&m_apcir->m_bPublExponent, rstrExp);
}

void
CV2PublicKey::Label(string const &rstrLabel)
{
    m_apcir->Symbol(&m_apcir->m_bLabel, rstrLabel);
}

void
CV2PublicKey::Local(bool flag)
{
    m_apcir->Flag(PublLocalFlag, flag);
}

CV2PublicKey *
CV2PublicKey::Make(CV2Card const &rv2card,
                   SymbolID sidHandle,
                   ObjectAccess oa)
{
    return new CV2PublicKey(rv2card, sidHandle, oa);
}

void
CV2PublicKey::Modifiable(bool flag)
{
    m_apcir->Flag(PublModifiableFlag, flag);
}

void
CV2PublicKey::Modulus(string const &rstrMod)
{
    CTransactionWrap wrap(m_hcard);

    m_apcir->Read();

    m_apcir->Symbol(&m_apcir->m_bModulus, rstrMod);

    if (rstrMod.size() == 0x80)
        m_apcir->m_bKeyType = CardKeyTypeRSA1024;
    else if (rstrMod.size() == 0x60)
        m_apcir->m_bKeyType = CardKeyTypeRSA768;
    else if (rstrMod.size() == 0x40)
        m_apcir->m_bKeyType = CardKeyTypeRSA512;
    else
        m_apcir->m_bKeyType = CardKeyTypeNone;

    m_apcir->Write();

}

void
CV2PublicKey::StartDate(Date const &rdtStart)
{
    CTransactionWrap wrap(m_hcard);
    m_apcir->Read();
    m_apcir->m_dtStart = rdtStart;
    m_apcir->Write();

}

void
CV2PublicKey::Subject(string const &rstrSubject)
{
    m_apcir->Symbol(&m_apcir->m_bSubject, rstrSubject);
}

void
CV2PublicKey::Verify(bool flag)
{
    m_apcir->Flag(PublVerifyFlag, flag);
}

void
CV2PublicKey::VerifyRecover(bool flag)
{
    m_apcir->Flag(PublVerifyRecoverFlag, flag);
}

void
CV2PublicKey::Wrap(bool flag)
{
    m_apcir->Flag(PublWrapFlag, flag);
}

                                                  // Access
bool
CV2PublicKey::CKInvisible()
{
    return m_apcir->Flag(PublCKInvisibleFlag);
}

string
CV2PublicKey::CredentialID()
{
    return m_apcir->Symbol(&m_apcir->m_bCredentialID);
}

bool
CV2PublicKey::Derive()
{
    return m_apcir->Flag(PublDeriveFlag);
}

void
CV2PublicKey::Encrypt(bool flag)
{
    m_apcir->Flag(PublEncryptFlag, flag);
}

Date
CV2PublicKey::EndDate()
{
    CTransactionWrap wrap(m_hcard);
    m_apcir->Read();
    return m_apcir->m_dtEnd;
}

string
CV2PublicKey::Exponent()
{
    return m_apcir->Symbol(&m_apcir->m_bPublExponent);
}

SymbolID
CV2PublicKey::Handle() const
{
    return m_sidHandle;
}

string
CV2PublicKey::ID()
{
    return m_apcir->Symbol(&m_apcir->m_bID);
}

string
CV2PublicKey::Label()
{
    return m_apcir->Symbol(&m_apcir->m_bLabel);
}

bool
CV2PublicKey::Local()
{
    return m_apcir->Flag(PublLocalFlag);
}

bool
CV2PublicKey::Modifiable()
{
    return m_apcir->Flag(PublModifiableFlag);
}

string
CV2PublicKey::Modulus()
{
    return m_apcir->Symbol(&m_apcir->m_bModulus);
}

bool
CV2PublicKey::Private()
{
    return m_apcir->Private();
}

Date
CV2PublicKey::StartDate()
{
    CTransactionWrap wrap(m_hcard);
    m_apcir->Read();
    return m_apcir->m_dtStart;
}

string
CV2PublicKey::Subject()
{
    return m_apcir->Symbol(&m_apcir->m_bSubject);
}

bool
CV2PublicKey::Verify()
{
    return m_apcir->Flag(PublVerifyFlag);
}

bool
CV2PublicKey::VerifyRecover()
{
    return m_apcir->Flag(PublVerifyRecoverFlag);
}

bool
CV2PublicKey::Wrap()
{
    return m_apcir->Flag(PublWrapFlag);
}


                                                  // Predicates
                                                  // Static Variables

///////////////////////////   PROTECTED   /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
void
CV2PublicKey::DoDelete()
{
    CV2Card &rv2card = scu::DownCast<CV2Card &, CAbstractCard &>(*m_hcard);

    CObjectInfoFile &roif = rv2card.ObjectInfoFile(m_oa);

    m_apcir->Read();

    // Remove allocation of entry in private key file

    if (m_apcir->m_bLabel)
        roif.RemoveSymbol(m_apcir->m_bLabel);
    if (m_apcir->m_bID)
        roif.RemoveSymbol(m_apcir->m_bID);
    if (m_apcir->m_bCredentialID)
        roif.RemoveSymbol(m_apcir->m_bCredentialID);
    if (m_apcir->m_bSubject)
        roif.RemoveSymbol(m_apcir->m_bSubject);
    if (m_apcir->m_bModulus)
        roif.RemoveSymbol(m_apcir->m_bModulus);
    if (m_apcir->m_bPublExponent)
        roif.RemoveSymbol(m_apcir->m_bPublExponent);

    // Delete info record

    roif.RemoveObject(otPublicKeyObject, m_sidHandle);

}

                                                  // Access
                                                  // Predicates
bool
CV2PublicKey::DoEquals(CAbstractPublicKey const &rhs) const
{
    CV2PublicKey const &rv2rhs =
        scu::DownCast<CV2PublicKey const &, CAbstractPublicKey const &>(rhs);

    return (rv2rhs.m_sidHandle == m_sidHandle);
}

                                                  // Static Variables


///////////////////////////    PRIVATE    /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
void
CV2PublicKey::Setup(CV2Card const &rv2card)
{

    m_apcir =
        auto_ptr<CPubKeyInfoRecord>(new CPubKeyInfoRecord(rv2card,
                                                          m_sidHandle,
                                                          m_oa));
}

                                                  // Access
                                                  // Predicates
                                                  // Static Variables
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\v2keypair.cpp ===
// V2KeyPair.cpp: implementation of the CV2KeyPair class.
//
// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
//////////////////////////////////////////////////////////////////////
#include "NoWarning.h"

#include <scuCast.h>

#include "slbCci.h"
#include "cciCard.h"
#include "TransactionWrap.h"

#include "V2Cert.h"
#include "V2PriKey.h"
#include "V2PubKey.h"
#include "V2Cont.h"
#include "V2KeyPair.h"
#include "ContainerInfoRecord.h"

using namespace std;
using namespace cci;

/////////////////////////// LOCAL/HELPER  /////////////////////////////////

///////////////////////////    PUBLIC     /////////////////////////////////

                                                  // Types
                                                  // C'tors/D'tors
CV2KeyPair::CV2KeyPair(CV2Card const &rv2card,
                       CContainer const &rhcont,
                       KeySpec ks)
    : CAbstractKeyPair(rv2card, rhcont, ks),
      m_bPubKeyAccess(oaNoAccess),
      m_bPriKeyAccess(oaNoAccess),
      m_bCertificateAccess(oaNoAccess),
      m_bPubKeyHandle(0),
      m_bPriKeyHandle(0),
      m_bCertificateHandle(0)
{
    CContainerInfoRecord &rcir =
        (scu::DownCast<CV2Container &,
                       CAbstractContainer &>(*m_hcont)).CIR();

    rcir.Read();

    m_bPubKeyHandle = rcir.GetKeyPair(ks).bPubKeyHandle;
    m_bPriKeyHandle = rcir.GetKeyPair(ks).bPriKeyHandle;
    m_bCertificateHandle = rcir.GetKeyPair(ks).bCertificateHandle;

    m_bPubKeyAccess = rcir.GetKeyPair(ks).bPubKeyAccess;
    m_bPriKeyAccess = rcir.GetKeyPair(ks).bPriKeyAccess;
    m_bCertificateAccess = rcir.GetKeyPair(ks).bCertificateAccess;

}

CV2KeyPair::~CV2KeyPair() throw()
{}


                                                  // Operators
                                                  // Operations

// After I update any of these, I'd better be sure that the
// key pair is marked as valid and that the indices in the
// container are updated.

void
CV2KeyPair::Certificate(CCertificate const &rcert)
{
    CTransactionWrap wrap(m_hcard);

    if (!rcert)
    {
        m_bCertificateAccess = oaNoAccess;
        m_bCertificateHandle = 0;
    }
    else
    {
        CV2Certificate const &rv2cert =
            scu::DownCast<CV2Certificate const &, CAbstractCertificate const &>(*rcert);

        m_bCertificateAccess = rv2cert.Access();
        m_bCertificateHandle = rv2cert.Handle();
    }
    Update();
}

void
CV2KeyPair::PrivateKey(CPrivateKey const &rprikey)
{
    CTransactionWrap wrap(m_hcard);
    if (!rprikey)
    {
        m_bPriKeyAccess = oaNoAccess;
        m_bPriKeyHandle = 0;
    }
    else
    {
        CV2PrivateKey const &rv2prikey =
            scu::DownCast<CV2PrivateKey const &, CAbstractPrivateKey const &>(*rprikey);

        m_bPriKeyAccess = rv2prikey.Access();
        m_bPriKeyHandle = rv2prikey.Handle();
    }
    Update();
}

void
CV2KeyPair::PublicKey(CPublicKey const &rpubkey)
{
    CTransactionWrap wrap(m_hcard);
    if (!rpubkey)
    {
        m_bPubKeyAccess = oaNoAccess;
        m_bPubKeyHandle = 0;
    }
    else
    {
        CV2PublicKey const &rv2pubkey =
            scu::DownCast<CV2PublicKey const &, CAbstractPublicKey const &>(*rpubkey);
        m_bPubKeyAccess = rv2pubkey.Access();
        m_bPubKeyHandle = rv2pubkey.Handle();
    }
    Update();
}

                                                  // Access
CCertificate
CV2KeyPair::Certificate() const
{
    CTransactionWrap wrap(m_hcard);

    CCertificate aCert;

    if (m_bCertificateHandle)
    {
        CV2Card const &rv2card =
            scu::DownCast<CV2Card &, CAbstractCard &>(*m_hcard);
        aCert = CCertificate(CV2Certificate::Make(rv2card,
                                                  m_bCertificateHandle,
                                                  m_bCertificateAccess));
    }
    else
        aCert = CCertificate();
    return aCert;
}

CPrivateKey
CV2KeyPair::PrivateKey() const
{
    CTransactionWrap wrap(m_hcard);

    CPrivateKey aKey;

    if (m_bPriKeyHandle)
    {
        CV2Card const &rv2card =
            scu::DownCast<CV2Card &, CAbstractCard &>(*m_hcard);
        aKey = CPrivateKey(CV2PrivateKey::Make(rv2card, m_bPriKeyHandle,
                                               m_bPriKeyAccess));
    }
    else
        aKey = CPrivateKey();

    return aKey;
}

CPublicKey
CV2KeyPair::PublicKey() const
{
    CTransactionWrap wrap(m_hcard);

    CPublicKey aKey;

    if (m_bPubKeyHandle)
    {
        CV2Card const &rv2card =
            scu::DownCast<CV2Card &, CAbstractCard &>(*m_hcard);
        aKey = CPublicKey(CV2PublicKey::Make(rv2card, m_bPubKeyHandle,
                                             m_bPubKeyAccess));
    }
    else
        aKey = CPublicKey();

    return aKey;
}

                                                  // Predicates

bool
CV2KeyPair::DoEquals(CAbstractKeyPair const &rhs) const
{
    CV2KeyPair const &rv2rhs =
        scu::DownCast<CV2KeyPair const &, CAbstractKeyPair const &>(rhs);

    return (rv2rhs.m_bPubKeyAccess == m_bPubKeyAccess) &&
        (rv2rhs.m_bPriKeyAccess == m_bPriKeyAccess) &&
        (rv2rhs.m_bCertificateAccess == m_bCertificateAccess) &&
        (rv2rhs.m_bPubKeyHandle == m_bPubKeyHandle) &&
        (rv2rhs.m_bPriKeyHandle == m_bPriKeyHandle) &&
        (rv2rhs.m_bCertificateHandle == m_bCertificateHandle);
}

                                                  // Static Variables

///////////////////////////   PROTECTED   /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables


///////////////////////////    PRIVATE    /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
void
CV2KeyPair::Update()
{
    KPItems kp;

    kp.bPubKeyAccess      = m_bPubKeyAccess;
    kp.bPriKeyAccess      = m_bPriKeyAccess;
    kp.bCertificateAccess = m_bCertificateAccess;

    kp.bPubKeyHandle      = m_bPubKeyHandle;
    kp.bPriKeyHandle      = m_bPriKeyHandle;
    kp.bCertificateHandle = m_bCertificateHandle;

    CContainerInfoRecord &rcir =
        (scu::DownCast<CV2Container &,
                       CAbstractContainer &>(*m_hcont)).CIR();
    rcir.SetKeyPair(m_ks, kp);

}
                                                  // Access
                                                  // Predicates
                                                  // Static Variables
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcrc\autobuildcount.h ===
// 9
#ifndef AUTOBUILDCOUNT_H
#define AUTOBUILDCOUNT_H
#define BUILDCOUNT_NUM 9
#define BUILDCOUNT_STR "9"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\v2keypair.h ===
// V2KeyPair.h: interface for the CV2KeyPair class.
//
// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
//////////////////////////////////////////////////////////////////////

// Note:  This file should only be included by the CCI, not directly
// by the client.

#if !defined(SLBCCI_V2KEYPAIR_H)
#define SLBCCI_V2KEYPAIR_H

#include <string>

#include <slbRCObj.h>

#include "slbCci.h"
#include "cciCard.h"
#include "cciCont.h"
#include "AKeyPair.h"

namespace cci
{

class CContainerInfoRecord;

class CV2KeyPair
    : public CAbstractKeyPair
{
public:
                                                  // Types
                                                  // C'tors/D'tors
    CV2KeyPair(CV2Card const &rv2card,
               CContainer const &rhcont,
               KeySpec ks);

    virtual
    ~CV2KeyPair() throw();

                                                  // Operators
                                                  // Operations
    virtual void
    Certificate(CCertificate const &rcert);

    virtual void
    PrivateKey(CPrivateKey const &rprikey);

    virtual void
    PublicKey(CPublicKey const &rpubkey);

                                                  // Access
    virtual CCertificate
    Certificate() const;

    virtual CPrivateKey
    PrivateKey() const;

    virtual CPublicKey
    PublicKey() const;


                                                  // Predicates

protected:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
    virtual bool
    DoEquals(CAbstractKeyPair const &rhs) const;

                                                  // Variables

private:
                                                  // Types
                                                  // C'tors/D'tors
    CV2KeyPair(CV2KeyPair const &rhs);
        // not defined, copying not allowed.

                                                  // Operators
    CV2KeyPair &
    operator=(CV2KeyPair const &rhs);
        // not defined, initialization not allowed.

                                                  // Operations
    void
    Update();

                                                  // Access
                                                  // Predicates
                                                  // Variables
    ObjectAccess m_bPubKeyAccess;
    ObjectAccess m_bPriKeyAccess;
    ObjectAccess m_bCertificateAccess;

    BYTE m_bPubKeyHandle;
    BYTE m_bPriKeyHandle;
    BYTE m_bCertificateHandle;
};

} // namespace cci

#endif // !defined(SLBCCI_V2KEYPAIR_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\v2prikey.h ===
// V2PriKey.h: interface for the CV2PrivateKey class.
//
// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
//////////////////////////////////////////////////////////////////////

// Note:  This file should only be included by the CCI, not directly
// by the client.

#if !defined(SLBCCI_V2PRIKEY_H)
#define SLBCCI_V2PRIKEY_H

#include <string>
#include <vector>
#include <memory>                                 // for auto_ptr

#include <slbRCObj.h>

#include "APriKey.h"

namespace cci
{

class CV2Card;
class CPriKeyInfoRecord;

class CV2PrivateKey
    : public CAbstractPrivateKey
{
public:
                                                  // Types
                                                  // C'tors/D'tors

    CV2PrivateKey(CV2Card const &rv2card,
                  ObjectAccess oa);

    CV2PrivateKey(CV2Card const &rv2card,
                  SymbolID sidHandle,
                  ObjectAccess oa);

    CV2PrivateKey(CV2Card const &rv2card,
                  BYTE bKeyType,
                  BYTE bKeyNumber,
                  ObjectAccess oa);

    virtual
    ~CV2PrivateKey() throw();

                                                  // Operators
                                                  // Operations

    virtual void
    CredentialID(std::string const &rstrID);

    virtual void
    Decrypt(bool flag);

    virtual void
    Derive(bool flag);

    virtual void
    EndDate(Date const &rEndDate);

    virtual void
    Exportable(bool flag);

    virtual void
    ID(std::string const &rstrID);

    virtual std::string
    InternalAuth(std::string const &rstrOld);

    virtual void
    Label(std::string const &rstrLabel);

    virtual void
    Local(bool flag);

    static CV2PrivateKey *
    Make(CV2Card const &rv2card,
         SymbolID sidHandle,
         ObjectAccess oa);

    virtual void
    Modifiable(bool flag);

    virtual void
    Modulus(std::string const &rstrModulus);

    virtual void
    NeverExportable(bool flag);

    virtual void
    NeverRead(bool flag);

    virtual void
    PublicExponent(std::string const &rstrExponent);

    virtual void
    Read(bool flag);

    virtual void
    Sign(bool flag);

    virtual void
    SignRecover(bool flag);

    virtual void
    StartDate(Date &rdtStart);

    virtual void
    Subject(std::string const &rstrSubject);

    virtual void
    Unwrap(bool flag);

                                                  // Access

    virtual std::string
    CredentialID();

    virtual bool
    Decrypt();

    virtual bool
    Derive();

    virtual Date
    EndDate();

    virtual bool
    Exportable();

    SymbolID
    Handle() const;

    virtual std::string
    ID();

    virtual std::string
    Label();

    virtual bool
    Local();

    virtual bool
    Modifiable();

    virtual std::string
    Modulus();

    virtual bool
    NeverExportable();

    virtual bool
    NeverRead();

    virtual bool
    Private();

    virtual std::string
    PublicExponent();

    virtual bool
    Read();

    virtual bool
    Sign();

    virtual bool
    SignRecover();

    virtual Date
    StartDate();

    virtual std::string
    Subject();

    virtual bool
    Unwrap();


                                                  // Predicates

protected:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations

    virtual void
    DoDelete();

    virtual void
    DoWriteKey(CPrivateKeyBlob const &rblob);

                                                  // Access
                                                  // Predicates

    virtual bool
    DoEquals(CAbstractPrivateKey const &rhs) const;

                                                  // Variables

private:
                                                  // Types
                                                  // C'tors/D'tors

    CV2PrivateKey(CAbstractPrivateKey const &rhs);
        // not defined, copying not allowed.

                                                  // Operators

    CAbstractPrivateKey &
    operator=(CAbstractPrivateKey const &rhs);
        // not defined, initialization not allowed.

                                                  // Operations

    void
    Setup(CV2Card const &rv2card);

    void
    Setup(CV2Card const &rv2card,
          SymbolID sidHandle);

                                                  // Access
                                                  // Predicates
                                                  // Variables
    SymbolID m_sidHandle;
    std::auto_ptr<CPriKeyInfoRecord> m_apcir;
};

} // namespace

#endif // !defined(SLBCCI_V2PRIKEY_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcrc\crc32.cpp ===
//------------------------------------------------------------------------
// Copyright (C) Sewell Development Corporation, 1994 - 1998.
//     Web: www.sewelld.com      E-mail: support@sewelld.com
//
// LICENSE: This source code was generated by CrcGen, a product of Sewell
// Development Corporation.  Paid-up licensees of CrcGen are authorized to
// use this code on a site-wide basis without restriction as to
// the type of product it is incorporated in, except that it may not be
// resold as stand-alone CRC code, and the copyright notice and license
// agreement must not be removed from the code.
//------------------------------------------------------------------------
#include "slbCrc32.h"


// Implementation of 32-bit CRC (cyclic redundancy check) class:
//     Polynomial:                 04C11DB7
//     Initial CRC register value: FFFFFFFF
//     Reflected input and output: Yes
//     Inverted final output:      Yes
//     CRC of string "123456789":  CBF43926

static unsigned __int32 m_table32r[256] = {
    0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3,
    0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988, 0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91,
    0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
    0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5,
    0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172, 0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B,
    0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,
    0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F,
    0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924, 0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D,
    0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
    0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01,
    0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E, 0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457,
    0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,
    0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB,
    0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0, 0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9,
    0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,
    0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD,
    0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A, 0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683,
    0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,
    0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7,
    0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC, 0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5,
    0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,
    0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55, 0x316E8EEF, 0x4669BE79,
    0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236, 0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F,
    0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,
    0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713,
    0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38, 0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21,
    0x86D3D2D4, 0xF1D4E242, 0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,
    0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45,
    0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2, 0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB,
    0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
    0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693, 0x54DE5729, 0x23D967BF,
    0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94, 0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D
};

void Crc32::Compute(const void* buffer, unsigned int count)
{
    const unsigned char* ptr = (const unsigned char *) buffer;
    while (count--) {
        m_crc = m_table32r[ (unsigned char) m_crc ^ *ptr++] ^ (m_crc >> 8);
    }
}

void Crc32::Compute(unsigned char value)
{
    m_crc = m_table32r[ (unsigned char) m_crc ^ value] ^ (m_crc >> 8);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcrc\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by slbCrc.rc
//

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcci\v2pubkey.h ===
// V2PubKey.h: interface for the CV2PublicKey class.
//
// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
//////////////////////////////////////////////////////////////////////

#if !defined(SLBCCI_V2PUBKEY_H)
#define SLBCCI_V2PUBKEY_H

// Note:  This file should only be included by the CCI, not directly
// by the client.

#include <string>
#include <vector>
#include <memory>                                 // for auto_ptr

#include <slbRCObj.h>

#include "APublicKey.h"
#include "slbarch.h"

namespace cci
{

class CV2Card;
class CPubKeyInfoRecord;

class CV2PublicKey
    : public CAbstractPublicKey
{
public:
                                                  // Types
                                                  // C'tors/D'tors
    CV2PublicKey(CV2Card const &rv2card,
                 ObjectAccess oa);

    CV2PublicKey(CV2Card const &rv2card,
                 SymbolID sidHandle,
                 ObjectAccess oa);

    virtual
    ~CV2PublicKey() throw();
                                                  // Operators
                                                  // Operations
    virtual void
    CKInvisible(bool flag);

    virtual void
    CredentialID(std::string const &rstrID);

    virtual void
    Derive(bool flag);

    virtual void
    ID(std::string const &rstrID);

    virtual void
    EndDate(Date const &rdtEnd);

    virtual void
    Encrypt(bool flag);

    virtual void
    Exponent(std::string const &rstrExp);

    virtual void
    Label(std::string const  &rstrLabel);

    virtual void
    Local(bool flag);

    static CV2PublicKey *
    Make(CV2Card const &rv2card,
         SymbolID sidHandle,
         ObjectAccess oa);

    virtual void
    Modifiable(bool flag);

    virtual void
    Modulus(std::string const &rstrMod);

    virtual void
    StartDate(Date const &rdtStart);

    virtual void
    Subject(std::string const &rstrSubject);

    virtual void
    Verify(bool flag);

    virtual void
    VerifyRecover(bool flag);

    virtual void
    Wrap(bool flag);

                                                  // Access
    virtual bool
    CKInvisible();

    virtual std::string
    CredentialID();

    virtual SymbolID
    Handle() const;

    virtual bool
    Derive();

    virtual bool
    Encrypt();

    virtual Date
    EndDate();

    virtual std::string
    Exponent();

    virtual std::string
    ID();

    virtual std::string
    Label();

    virtual bool
    Local();

    virtual bool
    Modifiable();

    virtual std::string
    Modulus();

    virtual bool
    Private();

    virtual Date
    StartDate();

    virtual std::string
    Subject();

    virtual bool
    Verify();

    virtual bool
    VerifyRecover();

    virtual bool
    Wrap();
                                                  // Predicates

protected:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
    virtual void
    DoDelete();

                                                  // Access
                                                  // Predicates
    virtual bool
    DoEquals(CAbstractPublicKey const &rhs) const;

                                                  // Variables

private:
                                                  // Types
                                                  // C'tors/D'tors
    CV2PublicKey(CAbstractPublicKey const &rhs);
        // not defined, copying not allowed.
                                                  // Operators
    CAbstractPublicKey &
    operator=(CAbstractPublicKey const &rhs);
        // not defined, initialization not allowed.

                                                  // Operations
    void
    Setup(CV2Card const &rv2card);

                                                  // Access
                                                  // Predicates
                                                  // Variables

    SymbolID m_sidHandle;
    std::auto_ptr<CPubKeyInfoRecord> m_apcir;
};

} // namespace cci

#endif // SLBCCI_V2PUBKEY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcrc\slbcrc32.h ===
//------------------------------------------------------------------------
// Copyright (C) Sewell Development Corporation, 1994 - 1998.
//     Web: www.sewelld.com      E-mail: support@sewelld.com
//
// LICENSE: This source code was generated by CrcGen, a product of Sewell
// Development Corporation.  Paid-up licensees of CrcGen are authorized to
// use this code on a site-wide basis without restriction as to
// the type of product it is incorporated in, except that it may not be
// resold as stand-alone CRC code, and the copyright notice and license
// agreement must not be removed from the code.
//------------------------------------------------------------------------

// Interface definition for 32-bit CRC (cyclic redundancy check) class:
//     Polynomial:                 04C11DB7
//     Initial CRC register value: FFFFFFFF
//     Reflected input and output: Yes
//     Inverted final output:      Yes
//     CRC of string "123456789":  CBF43926

class Crc32 {
public:
    explicit
    Crc32() {
        m_crc = 0xFFFFFFFF;
    }
    explicit
    Crc32(unsigned __int32 uiInitialCrc) {
        m_crc = uiInitialCrc;
    }
    Crc32(const void* buffer, unsigned int count) {
        m_crc = 0xFFFFFFFF;
        Compute(buffer, count);
    }
    void Compute(const void* buffer, unsigned int count);
    void Compute(unsigned char value);
    operator unsigned __int32 () const {
        return m_crc ^ 0xFFFFFFFF;
    }

private:
    unsigned __int32 m_crc;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\accesstok.cpp ===
// AccessTok.cpp -- Access Token class definition

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
#include "NoWarning.h"
#include "ForceLib.h"

#include <limits>
#include <memory>

#include <WinError.h>

#include <scuOsExc.h>

#include "Blob.h"
#include "AccessTok.h"

using namespace std;
using namespace scu;

/////////////////////////// LOCAL/HELPER  /////////////////////////////////

namespace
{
    const char PinPad = '\xFF';

    void
    DoAuthenticate(HCardContext const &rhcardctx,
                   SecureArray<BYTE> &rsPin)
    {
        rhcardctx->Card()->AuthenticateUser(rsPin);
    }
}

///////////////////////////    PUBLIC     /////////////////////////////////

                                                  // Types
                                                  // C'tors/D'tors
AccessToken::AccessToken(HCardContext const &rhcardctx,
                         LoginIdentity const &rlid)
    : m_hcardctx(rhcardctx),
      m_lid(rlid),
      m_hpc(0),
      m_sPin()
{
    // TO DO: Support Administrator and Manufacturing PINs
    switch (m_lid)
    {
    case User:
        break;

    case Administrator:
        // TO DO: Support authenticating admin (aut 0)
        throw scu::OsException(E_NOTIMPL);

    case Manufacturer:
        // TO DO: Support authenticating manufacturer (aut ?)
        throw scu::OsException(E_NOTIMPL);

    default:
        throw scu::OsException(ERROR_INVALID_PARAMETER);
    }

    //m_sPin.append(MaxPinLength, '\0');
}

AccessToken::AccessToken(AccessToken const &rhs)
    : m_hcardctx(rhs.m_hcardctx),
      m_lid(rhs.m_lid),
      m_hpc(0),                                   // doesn't commute
      m_sPin(rhs.m_sPin)
{}

AccessToken::~AccessToken()
{
    try
    {
        FlushPin();
    }

    catch (...)
    {
    }
}


                                                  // Operators
                                                  // Operations
void
AccessToken::Authenticate()
{
    // Only the user pin (CHV) is supported.
    DWORD dwError = ERROR_SUCCESS;
    
    SecureArray<BYTE> bPin(MaxPinLength);
    DWORD cbPin =  bPin.size();
    if ((0 == m_hpc) || (0 != m_sPin.length_string()))
    {
        // The MS pin cache is either uninitialized (empty) or a new
        // pin supplied. Authenticate using requested pin, having the MS pin
        // cache library update the cache if authentication succeeds.
        if (m_sPin.length() > cbPin)
            throw scu::OsException(ERROR_BAD_LENGTH);
        bPin=m_sPin;
        cbPin=bPin.size();
        PINCACHE_PINS pcpins = {
            cbPin,
            bPin.data(),
            0,
            0
        };

        dwError = PinCacheAdd(&m_hpc, &pcpins, VerifyPin, this);
        if (ERROR_SUCCESS != dwError)
        {
            m_sPin = SecureArray<BYTE>(0);// clear this pin ?
            if (Exception())
                PropagateException();
            else
                throw scu::OsException(dwError);
        }
    }
    else
    {
        // The MS pin cache must already be initialized at this point.
        // Retrieve it and authenticate.
        dwError = PinCacheQuery(m_hpc, bPin.data(), &cbPin);
        if (ERROR_SUCCESS != dwError)
            throw scu::OsException(dwError);

        SecureArray<BYTE> blbPin(bPin.data(), cbPin);
        DoAuthenticate(m_hcardctx, blbPin);
        m_sPin = blbPin;                // cache in case changing pin
    }
}

void
AccessToken::ChangePin(AccessToken const &ratNew)
{
    DWORD dwError = ERROR_SUCCESS;

    SecureArray<BYTE> bPin(MaxPinLength);
    DWORD cbPin = bPin.size();
    if (m_sPin.length() > cbPin)
        throw scu::OsException(ERROR_BAD_LENGTH);
    bPin = m_sPin;
    cbPin = bPin.size();
    
    SecureArray<BYTE> bNewPin(MaxPinLength);
    DWORD cbNewPin = bNewPin.size();
    if (ratNew.m_sPin.length() > cbPin)
        throw scu::OsException(ERROR_BAD_LENGTH);
    bNewPin = ratNew.m_sPin;
    cbNewPin = bNewPin.size();
    
    PINCACHE_PINS pcpins = {
        cbPin,
        bPin.data(),
        cbNewPin,
        bNewPin.data()
    };

    dwError = PinCacheAdd(&m_hpc, &pcpins, ChangeCardPin, this);
    if (ERROR_SUCCESS != dwError)
    {
        if (Exception())
            PropagateException();
        else
            throw scu::OsException(dwError);
    }

    m_sPin = ratNew.m_sPin;                       // cache the new pin
    
}

void
AccessToken::ClearPin()
{
    m_sPin = SecureArray<BYTE>(0);
}

void
AccessToken::FlushPin()
{
    PinCacheFlush(&m_hpc);

    ClearPin();
}

    
void
AccessToken::Pin(char const *pczPin,
                 bool fInHex)
{
    if (!pczPin)
        throw scu::OsException(ERROR_INVALID_PARAMETER);

    if (fInHex)
        throw scu::OsException(ERROR_INVALID_PARAMETER);
    else
        m_sPin = SecureArray<BYTE>((BYTE*)pczPin, strlen(pczPin));

    if (m_sPin.length() > MaxPinLength)
        // clear the existing pin to replace it later with invalid chars
        m_sPin = SecureArray<BYTE>();
    
    if (m_sPin.length() < MaxPinLength)           // always pad the pin
        m_sPin.append(MaxPinLength - m_sPin.length(), PinPad);
}

                                                  // Access

HCardContext
AccessToken::CardContext() const
{
    return m_hcardctx;
}

LoginIdentity
AccessToken::Identity() const
{
    return m_lid;
}

SecureArray<BYTE>
AccessToken::Pin() const
{
    return m_sPin;
}

                                                  // Predicates
bool
AccessToken::PinIsCached() const
{
    DWORD cbPin;
    DWORD dwError = PinCacheQuery(m_hpc, 0, &cbPin);
    bool fIsCached = (0 != cbPin);

    return fIsCached;
}

                                                  // Static Variables

///////////////////////////   PROTECTED   /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables


///////////////////////////    PRIVATE    /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations

DWORD
AccessToken::ChangeCardPin(PPINCACHE_PINS pPins,
                           PVOID pvCallbackCtx)
{
    AccessToken *pat = reinterpret_cast<AccessToken *>(pvCallbackCtx);
    DWORD dwError = ERROR_SUCCESS;

    EXCCTX_TRY
    {
        pat->ClearException();

        SecureArray<BYTE> blbPin(pPins->pbCurrentPin, pPins->cbCurrentPin);
        SecureArray<BYTE> blbNewPin(pPins->pbNewPin, pPins->cbNewPin);
        pat->m_hcardctx->Card()->ChangePIN(blbPin,
                                           blbNewPin);
    }

    EXCCTX_CATCH(pat, false);

    if (pat->Exception())
        dwError = E_FAIL;

    return dwError;
}

DWORD
AccessToken::VerifyPin(PPINCACHE_PINS pPins,
                       PVOID pvCallbackCtx)
{
    AccessToken *pat = reinterpret_cast<AccessToken *>(pvCallbackCtx);
    DWORD dwError = ERROR_SUCCESS;

    EXCCTX_TRY
    {
        pat->ClearException();

        SecureArray<BYTE> blbPin(pPins->pbCurrentPin, pPins->cbCurrentPin);
        DoAuthenticate(pat->m_hcardctx, blbPin);
    }

    EXCCTX_CATCH(pat, false);

    if (pat->Exception())
        dwError = E_FAIL;

    return dwError;
    
}
        
                                                  // Access
                                                  // Predicates
                                                  // Static Variables
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\acntrkey.cpp ===
// ACntrKey.cpp -- Adaptive CoNTaineR Key class implementation

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
#include "NoWarning.h"
#include "ForceLib.h"
#include "ACntrKey.h"

using namespace std;

/////////////////////////// LOCAL/HELPER  /////////////////////////////////

///////////////////////////    PUBLIC     /////////////////////////////////
                                                  // Types
                                                  // C'tors/D'tors
HAdaptiveContainerKey::HAdaptiveContainerKey(AdaptiveContainerKey *pcntrk)
    : slbRefCnt::RCPtr<AdaptiveContainerKey>(pcntrk)
{}

                                                  // Types
                                                  // C'tors/D'tors

                                                  // Types
                                                  // C'tors/D'tors
AdaptiveContainerKey::AdaptiveContainerKey(HCardContext const &rhcardctx,
                                           string const &rsContainerName)
    : m_hcardctx(rhcardctx),
      m_sContainerName(rsContainerName)
{}

AdaptiveContainerKey::~AdaptiveContainerKey()
{}

                                                  // Operators
bool
AdaptiveContainerKey::operator==(AdaptiveContainerKey const &rhs) const
{
    int iComparison = m_sContainerName.compare(rhs.m_sContainerName);
    if (0 == iComparison)
    {
        if(m_hcardctx && rhs.m_hcardctx)
            iComparison =
                m_hcardctx->Card()->ReaderName().compare(rhs.m_hcardctx->Card()->ReaderName());
        else if(m_hcardctx != rhs.m_hcardctx)
            iComparison = -1;
    }
    
    return iComparison == 0;
}

bool
AdaptiveContainerKey::operator<(AdaptiveContainerKey const &rhs) const
{
    int iComparison = m_sContainerName.compare(rhs.m_sContainerName);
    if (0 == iComparison)
    {
        if(m_hcardctx && rhs.m_hcardctx)
            iComparison =
                m_hcardctx->Card()->ReaderName().compare(rhs.m_hcardctx->Card()->ReaderName());
		//We are comparing keys of expired containers, i.e.
        //keys with null CardCtx. Such keys exist when a card gets
        //removed from the reader. They are maintained to enable the
        //reconnect logic. In cases like this we must preserve the
        //ordering of the elements in the collection: a key with null
        //card context is less than a key with defined context.
 
        else if(!m_hcardctx && rhs.m_hcardctx)
			iComparison = -1;
    }
    
    return iComparison < 0;
}

                                                  // Operations
                                                  // Access
HCardContext
AdaptiveContainerKey::CardContext() const
{
    return m_hcardctx;
}

void
AdaptiveContainerKey::ClearCardContext()
{
    m_hcardctx = 0;
}

std::string
AdaptiveContainerKey::ContainerName() const
{
    return m_sContainerName;
}

                                                  // Predicates
                                                  // Static Variables

///////////////////////////   PROTECTED   /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables


///////////////////////////    PRIVATE    /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\acntrfinder.cpp ===
// CntrFinder.cpp -- AContainerFinder class implementation

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#include "stdafx.h"

#include <string>

#include <scuOsExc.h>
#include <scuCast.h>

#include "ACntrFinder.h"

using namespace std;
using namespace scu;
using namespace cci;

/////////////////////////// LOCAL/HELPER  /////////////////////////////////

/////////////////////////// PUBLIC HELPER /////////////////////////////////

///////////////////////////    PUBLIC     /////////////////////////////////

                                                  // Types
                                                  // C'tors/D'tors

AContainerFinder::AContainerFinder(DialogDisplayMode ddm,
                                 HWND hwnd,
                                 CString const &rsDialogTitle)
    : ContainerFinder(ddm, hwnd, rsDialogTitle),
      m_hacntr()
{}

AContainerFinder::~AContainerFinder()
{}


                                                  // Operators
                                                  // Operations

Secured<HAdaptiveContainer>
AContainerFinder::Find(CSpec const &rcsContainer)
{
    DoFind(rcsContainer);

    return Secured<HAdaptiveContainer>(ContainerFound());
}


                                                  // Access
                                                  // Predicates
                                                  // Static Variables

///////////////////////////   PROTECTED   /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations

void
AContainerFinder::ContainerFound(HAdaptiveContainer &rhacntr)
{
    m_hacntr = rhacntr;
}

void
AContainerFinder::DoDisconnect()
{
    ContainerFound(HAdaptiveContainer(0));

        CardFinder::DoDisconnect();
}


                                                  // Access

HAdaptiveContainer
AContainerFinder::ContainerFound() const
{
    return m_hacntr;
}

                                                  // Predicates

bool
AContainerFinder::DoIsValid()
{
    ContainerFound(HAdaptiveContainer(0));
    if (CardFinder::DoIsValid())
    {
        AdaptiveContainerKey Key(CardFound(),
                                 CardSpec().CardId());
        HAdaptiveContainer hacntr(AdaptiveContainer::Find(Key));
        ContainerFound(hacntr);
    }

    if (!ContainerFound())
        throw scu::OsException(NTE_BAD_KEYSET);

    return true;
}

void
AContainerFinder::DoOnError()
{
    CardFinder::DoOnError();

    scu::Exception const *pexc = Exception();
    if (pexc && (DialogDisplayMode::ddmNever != DisplayMode()))
    {
        switch (pexc->Facility())
        {
        case scu::Exception::fcOS:
            {
                scu::OsException const *pOsExc =
                    DownCast<scu::OsException const *>(pexc);
                if (NTE_BAD_KEYSET == pOsExc->Cause())
                {
                    YNPrompt(IDS_CONTAINER_NOT_FOUND);
                    ClearException();
                }
            }
        break;

        default:
            break;
        }
    }
}




                                                  // Static Variables


///////////////////////////    PRIVATE    /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\accesstok.h ===
// AccessTok.h -- Card Access Token class declaration.

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#if !defined(SLBCSP_ACCESSTOK_H)
#define SLBCSP_ACCESSTOK_H


#include <string>

#include <pincache.h>

#include "HCardCtx.h"
#include "LoginId.h"
#include "ExceptionContext.h"


// Describes a security context of a card consisting of the identity and
// password.

class AccessToken
    : protected ExceptionContext
{
public:
                                                  // Types
    enum
    {
        MaxPinLength = 8
    };

                                                  // C'tors/D'tors

    AccessToken(HCardContext const &rhcardctx,
                LoginIdentity const &rlid);

    AccessToken(AccessToken const &rhs);

    ~AccessToken();

                                                  // Operators
                                                  // Operations

    void
    Authenticate();

    void
    ChangePin(AccessToken const &ratNew);

    void
    ClearPin();

    void
    FlushPin();

    void
    Pin(char const *pczPin,
        bool fInHex = false);

                                                  // Access

    HCardContext
    CardContext() const;
    
    LoginIdentity
    Identity() const;

    scu::SecureArray<BYTE>
    Pin() const;

                                                  // Predicates

    bool
    PinIsCached() const;

protected:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables

private:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations

    static DWORD
    ChangeCardPin(PPINCACHE_PINS pPins,
                  PVOID pvCallbackCtx);

    static DWORD 
    VerifyPin(PPINCACHE_PINS pPins,
              PVOID pvCallbackCtx);
                                                  // Access
                                                  // Predicates
                                                  // Variables

    HCardContext const m_hcardctx;
    LoginIdentity const m_lid;
    PINCACHE_HANDLE m_hpc;
    scu::SecureArray<BYTE> m_sPin; // non-null terminated container
};

#endif // SLBCSP_ACCESSTOK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\acntrfinder.h ===
// CntrFinder.h -- Container Finder class header

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#if !defined(SLBCSP_ACNTRFINDER_H)
#define SLBCSP_ACNTRFINDER_H

#include "cciCont.h"

#include "HAdptvCntr.h"
#include "Secured.h"
#include "CntrFinder.h"

class AContainerFinder
    : public ContainerFinder
{
public:
                                                  // Types
                                                  // C'tors/D'tors
    AContainerFinder(DialogDisplayMode ddm,
                    HWND hwnd = 0,
                    CString const &rsDialogTitle = StringResource(IDS_SEL_SLB_CRYPTO_CARD).AsCString());

    virtual ~AContainerFinder();

                                                  // Operators
                                                  // Operations
    Secured<HAdaptiveContainer>
    Find(CSpec const &rcsContainer);
                                                  // Access
                                                  // Predicates

protected:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations

    void
    ContainerFound(HAdaptiveContainer &rhacntr);

    void
    DoDisconnect();

    virtual void
    DoOnError();

                                                  // Access

    HAdaptiveContainer
    ContainerFound() const;

                                                  // Predicates

    bool
    DoIsValid();

                                                  // Variables

private:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables

    HAdaptiveContainer m_hacntr;
};

#endif // SLBCSP_ACNTRFINDER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\acntrreg.h ===
// ACntrReg.h -- Adaptive CoNTaineR Registrar class declaration

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#if !defined(SLBCSP_ACNTRREG_H)
#define SLBCSP_ACNTRREG_H

#include <string>
#include <functional>

#include "Registrar.h"
#include "ACntrKey.h"

class AdaptiveContainer;                           // forward declaration

typedef Registrar<AdaptiveContainerKey, AdaptiveContainer>
    AdaptiveContainerRegistrar;

#endif // SLBCSP_ACNTRREG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\acntrreg.cpp ===
// ACntrReg.cpp -- Adaptive CoNTaineR REGistrar implementation

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
#include "NoWarning.h"
#include "ForceLib.h"
#include "ACntrReg.h"

/////////////////////////// LOCAL/HELPER  /////////////////////////////////

///////////////////////////    PUBLIC     /////////////////////////////////

                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables

///////////////////////////   PROTECTED   /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables


///////////////////////////    PRIVATE    /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables

// Obligatory definitions
AdaptiveContainerRegistrar::RegistryType *AdaptiveContainerRegistrar::m_pregistry = 0;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\acntrkey.h ===
// ACntrKey.h -- Adaptive CoNTaiNeR Key struct declaration

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#if !defined(SLBCSP_ACNTRKEY_H)
#define SLBCSP_ACNTRKEY_H

#include "HCardCtx.h"

// Key to an AdaptiveContainer.  Together, the HCardContext and
// container name enable uniquely identifies the container.  The
// operator== and operator< are used for comparing with a keys
// lexically.

// Forward declaration necessary to satisfy HAdaptiveContainerKey's declaration

class AdaptiveContainerKey;
class HAdaptiveContainerKey
    : public slbRefCnt::RCPtr<AdaptiveContainerKey>
{
public:
                                                  // Types
                                                  // C'tors/D'tors
    HAdaptiveContainerKey(AdaptiveContainerKey *pacntrk = 0);

                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates

protected:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables

private:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables
};

class AdaptiveContainerKey
    : public slbRefCnt::RCObject
{
public:
                                                  // Types
                                                  // C'tors/D'tors
    AdaptiveContainerKey(HCardContext const &rhcardctx,
                         std::string const &rsContainerName);

    ~AdaptiveContainerKey();

                                                  // Operators
    bool
    operator==(AdaptiveContainerKey const &rhs) const;

    bool
    operator<(AdaptiveContainerKey const &rhs) const;

                                                  // Operations
                                                  // Access
    HCardContext
    CardContext() const;

	void
	ClearCardContext();

    std::string
    ContainerName() const;

                                                  // Predicates

protected:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables

private:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables
    HCardContext m_hcardctx;
    std::string m_sContainerName;
};

#endif // SLBCSP_ACNTRKEY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\autobuildcount.h ===
// 15
#ifndef AUTOBUILDCOUNT_H
#define AUTOBUILDCOUNT_H
#define BUILDCOUNT_NUM 15
#define BUILDCOUNT_STR "15"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\alignedblob.cpp ===
// AlignedBlob.cpp -- Aligned Blob class implementation

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 2001. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#include "AlignedBlob.h"

using namespace scu;

/////////////////////////// LOCAL/HELPER  /////////////////////////////////

///////////////////////////    PUBLIC     /////////////////////////////////

                                                  // Types
                                                  // C'tors/D'tors
AlignedBlob::AlignedBlob(Blob const &rblb)
    : m_aaBlob(AutoArrayPtr<AlignedBlob::ValueType>(new AlignedBlob::ValueType[rblb.length()])),
      m_cLength(rblb.length())
{
    memcpy(m_aaBlob.Get(), rblb.data(), m_cLength);
}

AlignedBlob::AlignedBlob(AlignedBlob::ValueType const *p,
                         AlignedBlob::SizeType cLength)
    : m_aaBlob(AutoArrayPtr<AlignedBlob::ValueType>(new AlignedBlob::ValueType[cLength])),
      m_cLength(cLength)
{
    memcpy(m_aaBlob.Get(), p, m_cLength);
}

AlignedBlob::AlignedBlob(AlignedBlob const &rhs)
    : m_aaBlob(0),
      m_cLength(0)
{
    *this = rhs;
}

    
AlignedBlob::~AlignedBlob() throw()
{}
                                                  // Operators
AlignedBlob &
AlignedBlob::operator=(AlignedBlob const &rhs)
{
    if (this != &rhs)
    {
        m_aaBlob = AutoArrayPtr<AlignedBlob::ValueType>(new AlignedBlob::ValueType[rhs.m_cLength]);
        memcpy(m_aaBlob.Get(), rhs.m_aaBlob.Get(), rhs.m_cLength);
        m_cLength = rhs.m_cLength;
    }

    return *this;
}

                                                  // Operations
                                                  // Access
AlignedBlob::ValueType *
AlignedBlob::Data() const throw()
{
    return m_aaBlob.Get();
}

AlignedBlob::SizeType
AlignedBlob::Length() const throw()
{
    return m_cLength;
}
    
                                                  // Predicates
                                                  // Static Variables

///////////////////////////   PROTECTED   /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables


///////////////////////////    PRIVATE    /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\adptvcntr.cpp ===
// AdptvCntr.cpp -- ADaPTiVe CoNTaineR class implementation

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
#include "stdafx.h"
#include "NoWarning.h"
#include "ForceLib.h"

#include <vector>
#include <algorithm>
#include <functional>

#include <scuOsExc.h>

#include <cciPriKey.h>

#include "RsaKey.h"
#include "CSpec.h"
#include "HAdptvCntr.h"
#include "Secured.h"
#include "ACntrFinder.h"
#include <scarderr.h>
#include <assert.h>

using namespace std;
using namespace cci;

/////////////////////////// LOCAL/HELPER  /////////////////////////////////
namespace
{
    // Predicate helper functor (function object) returning true iff
    // the container object's name matches the pattern.
    class ContainerMatcher
        : public unary_function<string, bool>
    {
    public:
        explicit
        ContainerMatcher(string const &rsPattern)
            : m_sPattern(rsPattern)
        {}

        bool
        operator()(CContainer &rcntr) const
        {
            return CSpec::Equiv(m_sPattern, rcntr->Name());
        }


    private:
        string const m_sPattern;
    };

    CContainer
    FindOnCard(HCardContext &rhcardctx,
               string const &rsContainer)
    {
        Secured<HCardContext> shcardctx(rhcardctx);

        vector<CContainer> vcContainers(shcardctx->Card()->EnumContainers());

        vector<CContainer>::const_iterator
            ci(find_if(vcContainers.begin(),
                       vcContainers.end(),
                       ContainerMatcher(rsContainer)));

        CContainer hcntr;
        if (vcContainers.end() != ci)
            hcntr = *ci;

        return hcntr;
    }

} // namespace


///////////////////////////    PUBLIC     /////////////////////////////////

                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
void
AdaptiveContainer::ClearCache()
{
    m_hcntr = 0;
}

                                                  // Access
CContainer
AdaptiveContainer::TheCContainer() 
{
    
    if (!m_hcntr)
    {
        RefreshContainer();
        if (!m_hcntr)
        {
            Discard(*m_hacKey);
            throw scu::OsException(NTE_BAD_KEYSET);
        }
    }

    return m_hcntr;
}

HCardContext
AdaptiveContainer::CardContext(bool bReconnect)
{
    if(bReconnect)
    {
        if(m_fValidContext)
        {
            try
            {
                //Verify that the card context is good
                Retained<HCardContext>(m_hacKey->CardContext());
            }
            catch(scu::OsException const &rExc)
            {
                ReconnectOnError(rExc, Retained<HCardContext>(0));
            }   
        }
        else
        {
            scu::OsException Exc(SCARD_W_REMOVED_CARD);
            ReconnectOnError(Exc, Retained<HCardContext>(0));
        }
    }
    
    return m_hacKey->CardContext();
}

AdaptiveContainer::EnrolleeType
AdaptiveContainer::Find(AdaptiveContainerKey const &rKey)
{
    // Take a lazy approach to finding the container.  If it wasn't
    // first found in the registry but exists on the card, then make
    // an instance.
    EnrolleeType enrollee = AdaptiveContainerRegistrar::Find(rKey);
    if (!enrollee)
    {
        // See if it exists on the card
        CContainer hcntr(FindOnCard(rKey.CardContext(),
                                    rKey.ContainerName()));
        if (hcntr)
            enrollee = Instance(rKey);
    }

    return enrollee;
}

string
AdaptiveContainer::Name() const
{
    return m_hacKey->ContainerName();
}

void
AdaptiveContainer::NullifyCard() 
{
    Guarded<Lockable *> guard(&AdaptiveContainerRegistrar::Registry());  // serialize registry access

    AdaptiveContainerKey aKey(*m_hacKey);
	m_hacKey->ClearCardContext();
    Enroll(*m_hacKey, this);
    Discard(aKey);
    Expire();
}

                                                  // Predicates
                                                  // Static Variables

///////////////////////////   PROTECTED   /////////////////////////////////

                                                  // C'tors/D'tors
AdaptiveContainer::AdaptiveContainer(AdaptiveContainerKey const &rKey)
    : Lockable(),
      Securable(),
      AdaptiveContainerRegistrar(rKey),
      m_hacKey(HAdaptiveContainerKey(new AdaptiveContainerKey(rKey))),
      m_stkRetainedCardContexts(),
      m_stkSecuredCardContexts(),
      m_fValidContext(false)
{
    Secured<HCardContext> shcardctx(m_hacKey->CardContext());

    RefreshContainer();

    // Create the container if it doesn't exist on the card.
    if (!m_hcntr)
    {
        // To make native Windows (pure CAPI) environment more robust,
        // test that there is enough room for a private key before
        // creating the container.
        CCard hcard(shcardctx->Card());
        if (!hcard->IsPKCS11Enabled())
        {
            CPrivateKey hprikey(hcard);

            CPrivateKeyBlob prikb;

            // Divide by 2 since the key info is divided in the structures.
            prikb.bPLen = prikb.bQLen = prikb.bInvQLen =
                prikb.bKsecModQLen = prikb.bKsecModPLen =
                InOctets(KeyLimits<RsaKey>::cMaxStrength) / 2;

            // Now test there is a key slot available by trying to
            // allocate a key slot on the card.  If there isn't enough
            // space or some other failure occurs, then try to delete
            // the new key (ignoring any exception that occurs during
            // the delete), then throw the original exception.
            try 
            {
                
                hprikey->Value(prikb);            // actually alloc's
                                                  // key slot
            }

            catch (...)
            {
                try
                {
                    hprikey->Delete();            // cleanup after
                                                  // test
                }
                catch (...)
                {
                }

                throw;                            // throw original error
            }
            
            // There's key space available, so delete the test key.
            hprikey->Delete();
            hprikey = 0;
        }

        m_hcntr = CContainer(hcard);
        m_hcntr->Name(rKey.ContainerName());

    }
}

AdaptiveContainer::~AdaptiveContainer()
{}

                                                  // Operators
                                                  // Operations
void
AdaptiveContainer::ClearCardContext()
{
	m_hacKey->ClearCardContext();   
}

void
AdaptiveContainer::DiscardHook()
{
    Expire();
    RemoveReference();
}

AdaptiveContainer::EnrolleeType
AdaptiveContainer::DoInstantiation(AdaptiveContainerKey const &rKey)
{
    return new AdaptiveContainer(rKey);
}

void
AdaptiveContainer::EnrollHook()
{
    AddReference();
    m_fValidContext = true;
}

                                                  // Access
                                                  // Predicates
bool
AdaptiveContainer::KeepEnrolled()
{
    bool fKeep = true;
    
    try
    {
        RefreshContainer();
    }

    catch (...)
    {
        fKeep = false;
    }

    return fKeep;
}

void
AdaptiveContainer::ReconnectOnError(scu::OsException const &rExc,
                                    Retained<HCardContext> &rhcardctx)
{
    rhcardctx = Retained<HCardContext>(0);
    if ((rExc.Cause() == SCARD_W_REMOVED_CARD 
         || rExc.Cause() == ERROR_BROKEN_PIPE
         || rExc.Cause() == SCARD_E_SERVICE_STOPPED
         || rExc.Cause() == SCARD_E_NO_SERVICE
         || rExc.Cause() == SCARD_E_READER_UNAVAILABLE) && m_hacKey)
    {
        //Handle the case of card removed by trying to
        //determine if the card has been re-inserted in
        //any of the available readers. If so, reconnect
        //silently

        // Declared here to remain in scope for CntrFinder
        // destructor in case of an exception...some anomaly that's as
        // yet unexplained.
        CString sEmptyWinTitle;
        try
        {
            //Find, adapt, and enroll it properly
            //First, discard the old card context before acquiring
            //a new one. This is essential in order to avoid
            //resource mgr hangup.
            Guarded<Lockable *> guard(&AdaptiveContainerRegistrar::Registry());  // serialize registry access
            std::string sContainerName(m_hacKey->ContainerName());
            RemoveEnrollee(*m_hacKey);
            Expire();
            ContainerFinder CntrFinder(CardFinder::DialogDisplayMode::ddmNever,
                                       0,//window handle
                                       sEmptyWinTitle);
            //Don't know the reader where the card may be in.
            //Use a non fully qualified name to look for the card.
            CSpec cspec(string(), sContainerName);
            HContainer hcntr = CntrFinder.Find(cspec);
            m_hcntr = hcntr->TheCContainer();
            m_hacKey = CntrFinder.MakeAdaptiveContainerKey();
            m_fValidContext = true;
            InsertEnrollee(*m_hacKey, this);
            rhcardctx =
                Retained<HCardContext>(m_hacKey->CardContext());
        }
        catch(...)
        {
            //Didn't work. Apparently the card is gone
            //permanently for the duration of this session.
            //Cleanup and raise the original exception...
            Expire();
            rExc.Raise();
        }
    }
    else
    {
        //Cannot handle this exception. Let the system handle it
        rExc.Raise();
    }
}


                                                  // Static Variables


///////////////////////////    PRIVATE    /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
void
AdaptiveContainer::Abandon()
{
    // Simplifying assumptions: (1) Abandon is only called by the
    // Secured destructor, (2) once the object is constructed, Secure
    // and Abandon are the only routines that access
    // m_stkSecuredCardContexts, and (3) Abandon is called by a thread
    // within the scope of a Retain (e.g. using Retained) which the
    // Secured class enforces.  Because of (1) and (2), an underflow
    // check on m_stkSecuredCardContexts is not necessary since Secure
    // will have already been called.  Because of (3), protection
    // against race conditions accessing m_stkSecuredCardContexts
    // isn't necessary since Retain acts as a lock.
    m_stkSecuredCardContexts.pop_front();
}

void
AdaptiveContainer::Expire()
{
    // allow the resources to be released so that other resources can
    // be acquired that may have a dependency (e.g. releasing the
    // container's card context so that another card context can be
    // acquired later on the same reader without the RM blocking).
    m_fValidContext = false;
    m_hacKey->ClearCardContext();
    ClearCache();
}
    
void
AdaptiveContainer::RefreshContainer() 
{
	if(m_hacKey->CardContext())
	{
		try
		{
			m_hcntr = FindOnCard(m_hacKey->CardContext(),
				                 m_hacKey->ContainerName());
		}
		catch(scu::OsException const &rExc)
		{
			ReconnectOnError(rExc, Retained<HCardContext>(0));
		}
	}
	else
	{
		scu::OsException Exc(SCARD_W_REMOVED_CARD);
		ReconnectOnError(Exc, Retained<HCardContext>(0));
	}
}

void
AdaptiveContainer::Relinquish()
{
    // Simplifying assumptions: (1) Relinquish is only called by the
    // Retained destructor and (2) once the object is constructed,
    // Retain and Relinquish are the only routines that access the
    // m_stkRetainedCardContexts.  Because of (1) and (2), an
    // underflow check on m_stkRetainedCardContexts is not necessary
    // since Retain will have already been called.

    // Note: Retained<HCardContext> acts as a lock protecting against
    // race conditions updating m_stkRetainedCardContexts.
    Retained<HCardContext> hrcc(m_stkRetainedCardContexts.front());

    m_stkRetainedCardContexts.pop_front();
}

void
AdaptiveContainer::Retain()
{
    // Simplifying assumptions: (1) Retain is only called by the
    // Retained constructor and (2) once the object is constructed,
    // Retain and Relinquish are the only routines that access the
    // m_stkRetainedCardContexts.  Because of (1) and (2), an
    // underflow check on m_stkRetainedCardContexts is not necessary
    // since Retain will have already been called.
    Retained<HCardContext> rhcardctx;
    try
    {
        rhcardctx = Retained<HCardContext>(m_hacKey->CardContext());
    }
    
    catch(scu::OsException const &rExc)
    {
        ReconnectOnError(rExc, rhcardctx);
    }

    m_stkRetainedCardContexts.push_front(rhcardctx);
}

void
AdaptiveContainer::Secure()
{
    // Simplifying assumptions: (1) Secure is always called by a
    // thread within the scope of a Retain (e.g. using Retained).  The
    // Secured template enforces this allowing Retain to act as a lock
    // to prevent race conditions updating
    // m_stkSecuredCardContexts. (2) Once the object is constructed,
    // Secure and Abandon are the only routines that access
    // m_stkSecuredCardContexts.
    m_stkSecuredCardContexts.push_front(Secured<HCardContext>(m_hacKey->CardContext()));
}


                                                  // Access
                                                  // Predicates
                                                  // Static Variables
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\autoreg.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

(c) Copyright Schlumberger Technology Corp., unpublished work, created
1999. This computer program includes Confidential, Proprietary
Information and is a Trade Secret of Schlumberger Technology Corp. All
use, disclosure, and/or reproduction is prohibited unless authorized
in writing.  All Rights Reserved.

Module Name:

    autoreg

Abstract:

    This module provides autoregistration capabilities to a CSP.  It allows
    regsvr32 to call the DLL directly to add and remove Registry settings.

Author:

    Doug Barlow (dbarlow) 3/11/1998

Environment:

    Win32

Notes:

    Look for "?vendor?" tags and edit appropriately.

--*/

#if defined(_UNICODE)
  #if !defined(UNICODE)
    #define UNICODE
  #endif //!UNICODE
#endif //_UNICODE

#if defined(UNICODE)
  #if !defined(_UNICODE)
    #define _UNICODE
  #endif //!_UNICODE
#endif //UNICODE

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#ifdef _AFXDLL
#include "stdafx.h"
#else
#include <windows.h>
#endif
#include <string>
#include <basetsd.h>
#include <wincrypt.h>
#include <cspdk.h>                                // CRYPT_SIG_RESOURCE_NUMBER
#include <winscard.h>
#include <tchar.h>

#include "CspProfile.h"
#include "Blob.h"
#include "StResource.h"

using namespace std;
using namespace ProviderProfile;

namespace
{
    typedef DWORD
        (*LPSETCARDTYPEPROVIDERNAME)(IN SCARDCONTEXT hContext,
                                     IN LPCTSTR szCardName,
                                     IN DWORD dwProviderId,
                                     IN LPCTSTR szProvider);

    LPCTSTR szCardRegPath =
        TEXT("SOFTWARE\\Microsoft\\Cryptography\\Calais\\SmartCards");

    // Remove the legacy Cryptoflex card from the registry.  This
    // will ease transition of W2K beta users to its commercial
    // release as well as Cryptoflex SDK 1.x users.  The supported
    // cards are added by IntroduceVendorCard.
    LPCTSTR aCardsToForget[] =
    {
        TEXT("Schlumberger Cryptoflex"),
        TEXT("Schlumberger Cryptoflex 4k"),
        TEXT("Schlumberger Cryptoflex 8k"),
        TEXT("Schlumberger Cryptoflex 8k v2")
    };

    HRESULT
    ForgetVendorCard(LPCTSTR szCardToForget)
    {
        bool fCardIsForgotten = false;
        HRESULT hReturnStatus = NO_ERROR;

#if !defined(UNICODE)
        string
#else
        wstring
#endif // !defined(UNICODE)
            sRegCardToForget(szCardRegPath);

        sRegCardToForget.append(TEXT("\\"));
        sRegCardToForget.append(szCardToForget);

        for (DWORD dwIndex = 0; !fCardIsForgotten; dwIndex += 1)
        {
            HKEY hCalais(0);
            SCARDCONTEXT hCtx(0);
            DWORD dwStatus;
            LONG nStatus;

            switch (dwIndex)
            {
            case 0:
                dwStatus = SCardEstablishContext(SCARD_SCOPE_SYSTEM, 0, 0, &hCtx);
                if (ERROR_SUCCESS != dwStatus)
                    continue;
                dwStatus = SCardForgetCardType(hCtx,
                                               szCardToForget);
                if (ERROR_SUCCESS != dwStatus)
                    continue;
                dwStatus = SCardReleaseContext(hCtx);
                hCtx = NULL;
                if (ERROR_SUCCESS != dwStatus)
                {
                    if (0 == (dwStatus & 0xffff0000))
                        hReturnStatus = HRESULT_FROM_WIN32(dwStatus);
                    else
                        hReturnStatus = (HRESULT)dwStatus;
                    goto ErrorExit;
                }
                // Ignore the return code since the previous probably deleted it.
                nStatus = RegDeleteKey(HKEY_LOCAL_MACHINE,
                                       sRegCardToForget.c_str());
                fCardIsForgotten = true;
                break;

            case 1:
                // Last try, if not successful then it must not exist...
                nStatus = RegDeleteKey(HKEY_LOCAL_MACHINE,
                                       sRegCardToForget.c_str());
                fCardIsForgotten = true;
                break;

            default:
                hReturnStatus = ERROR_ACCESS_DENIED;
                goto ErrorExit;
            }

        ErrorExit:
            if (NULL != hCtx)
                SCardReleaseContext(hCtx);
            if (NULL != hCalais)
                RegCloseKey(hCalais);
            break;
        }

        return hReturnStatus;
    }

    HRESULT
    IntroduceVendorCard(CString const &rsCspName,
                        CardProfile const &rcp)
    {
        // Try various techniques until one works.

        ATR const &ratr = rcp.ATR();
        bool fCardIntroduced = false;
        HRESULT hReturnStatus = NO_ERROR;

        for (DWORD dwIndex = 0; !fCardIntroduced; dwIndex += 1)
        {
            HKEY hCalais(0);
            SCARDCONTEXT hCtx(0);
            DWORD dwDisp;
            DWORD dwStatus;
            LONG nStatus;
            HKEY hVendor(0);

            switch (dwIndex)
            {
            case 0:
                {
                    HMODULE hWinSCard = NULL;
                    LPSETCARDTYPEPROVIDERNAME pfSetCardTypeProviderName = NULL;

                    hWinSCard = GetModuleHandle(TEXT("WinSCard.DLL"));
                    if (NULL == hWinSCard)
                        continue;
#if defined(UNICODE)
                    pfSetCardTypeProviderName =
                        reinterpret_cast<LPSETCARDTYPEPROVIDERNAME>(GetProcAddress(hWinSCard,
                                                                                   AsCCharP(TEXT("SCardSetCardTypeProviderNameW"))));

#else
                    pfSetCardTypeProviderName =
                        reinterpret_cast<LPSETCARDTYPEPROVIDERNAME>(GetProcAddress(hWinSCard,
                                                                              TEXT("SCardSetCardTypeProviderNameA")));

#endif
                    if (!pfSetCardTypeProviderName)
                        continue;
                    dwStatus = SCardIntroduceCardType(NULL,
                                                      (LPCTSTR)rcp.csRegistryName(),
                                                      NULL, NULL, 0,
                                                      ratr.String(),
                                                      ratr.Mask(),
                                                      ratr.Size());

                    if ((ERROR_SUCCESS != dwStatus) &&
                        (ERROR_ALREADY_EXISTS != dwStatus))
                        continue;
                    dwStatus = (*pfSetCardTypeProviderName)(NULL,
                                                            (LPCTSTR)rcp.csRegistryName(),
                                                            SCARD_PROVIDER_CSP,
                                                            (LPCTSTR)rsCspName);
                    if (ERROR_SUCCESS != dwStatus)
                    {
                        if (0 == (dwStatus & 0xffff0000))
                            hReturnStatus = HRESULT_FROM_WIN32(dwStatus);
                        else
                            hReturnStatus = (HRESULT)dwStatus;
                        goto ErrorExit;
                    }
                    fCardIntroduced = TRUE;
                    break;
                }

            case 1:
                dwStatus = SCardEstablishContext(SCARD_SCOPE_SYSTEM, 0, 0, &hCtx);
                if (ERROR_SUCCESS != dwStatus)
                    continue;
                dwStatus = SCardIntroduceCardType(hCtx,
                                                  (LPCTSTR)rcp.csRegistryName(),
                                                  &rcp.PrimaryProvider(),
                                                  NULL, 0, ratr.String(),
                                                  ratr.Mask(),
                                                  ratr.Size());
                if ((ERROR_SUCCESS != dwStatus)
                    && (ERROR_ALREADY_EXISTS != dwStatus))
                {
                    if (0 == (dwStatus & 0xffff0000))
                        hReturnStatus = HRESULT_FROM_WIN32(dwStatus);
                    else
                        hReturnStatus = (HRESULT)dwStatus;
                    goto ErrorExit;
                }
                dwStatus = SCardReleaseContext(hCtx);
                hCtx = NULL;
                if (ERROR_SUCCESS != dwStatus)
                {
                    if (0 == (dwStatus & 0xffff0000))
                        hReturnStatus = HRESULT_FROM_WIN32(dwStatus);
                    else
                        hReturnStatus = (HRESULT)dwStatus;
                    goto ErrorExit;
                }
                nStatus = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                                         TEXT("SOFTWARE\\Microsoft\\Cryptography\\Calais\\SmartCards"),
                                         0, TEXT(""),
                                         REG_OPTION_NON_VOLATILE,
                                         KEY_ALL_ACCESS, NULL, &hCalais,
                                         &dwDisp);
                if (ERROR_SUCCESS != nStatus)
                {
                    hReturnStatus = HRESULT_FROM_WIN32(nStatus);
                    goto ErrorExit;
                }
                nStatus = RegCreateKeyEx(hCalais, (LPCTSTR)rcp.csRegistryName(),
                                         0, TEXT(""),
                                         REG_OPTION_NON_VOLATILE,
                                         KEY_ALL_ACCESS, NULL, &hVendor,
                                         &dwDisp);
                if (ERROR_SUCCESS != nStatus)
                {
                    hReturnStatus = HRESULT_FROM_WIN32(nStatus);
                    goto ErrorExit;
                }
                nStatus = RegCloseKey(hCalais);
                hCalais = NULL;
                if (ERROR_SUCCESS != nStatus)
                {
                    hReturnStatus = HRESULT_FROM_WIN32(nStatus);
                    goto ErrorExit;
                }

                nStatus = RegSetValueEx(hVendor, TEXT("Crypto Provider"),
                                        0, REG_SZ,
                                        reinterpret_cast<LPCBYTE>((LPCTSTR)rsCspName),
                                        (_tcslen((LPCTSTR)rsCspName) +
                                         1) * sizeof TCHAR);
                if (ERROR_SUCCESS != nStatus)
                {
                    hReturnStatus = HRESULT_FROM_WIN32(nStatus);
                    goto ErrorExit;
                }

                nStatus = RegCloseKey(hVendor);
                hVendor = NULL;
                if (ERROR_SUCCESS != nStatus)
                {
                    hReturnStatus = HRESULT_FROM_WIN32(nStatus);
                    goto ErrorExit;
                }
                fCardIntroduced = TRUE;
                break;

            case 2:
                nStatus = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                                         TEXT("SOFTWARE\\Microsoft\\Cryptography\\Calais\\SmartCards"),
                                         0, TEXT(""),
                                         REG_OPTION_NON_VOLATILE,
                                         KEY_ALL_ACCESS, NULL, &hCalais,
                                         &dwDisp);
                if (ERROR_SUCCESS != nStatus)
                    continue;
                nStatus = RegCreateKeyEx(hCalais,
                                         (LPCTSTR)rcp.csRegistryName(), 0,
                                         TEXT(""),
                                         REG_OPTION_NON_VOLATILE,
                                         KEY_ALL_ACCESS, NULL, &hVendor,
                                         &dwDisp);
                if (ERROR_SUCCESS != nStatus)
                {
                    hReturnStatus = HRESULT_FROM_WIN32(nStatus);
                    goto ErrorExit;
                }
                nStatus = RegCloseKey(hCalais);
                hCalais = NULL;
                if (ERROR_SUCCESS != nStatus)
                {
                    hReturnStatus = HRESULT_FROM_WIN32(nStatus);
                    goto ErrorExit;
                }
                nStatus = RegSetValueEx(hVendor, TEXT("Primary Provider"),
                                        0, REG_BINARY,
                                        (LPCBYTE)&rcp.PrimaryProvider(),
                                        sizeof LPCBYTE);
                if (ERROR_SUCCESS != nStatus)
                {
                    hReturnStatus = HRESULT_FROM_WIN32(nStatus);
                    goto ErrorExit;
                }
                nStatus = RegSetValueEx(hVendor, TEXT("ATR"), 0,
                                        REG_BINARY, ratr.String(),
                                        ratr.Size());
                if (ERROR_SUCCESS != nStatus)
                {
                    hReturnStatus = HRESULT_FROM_WIN32(nStatus);
                    goto ErrorExit;
                }
                nStatus = RegSetValueEx(hVendor, TEXT("ATRMask"), 0,
                                        REG_BINARY, ratr.Mask(),
                                        ratr.Size());
                if (ERROR_SUCCESS != nStatus)
                {
                    hReturnStatus = HRESULT_FROM_WIN32(nStatus);
                    goto ErrorExit;
                }
                nStatus = RegSetValueEx(hVendor, TEXT("Crypto Provider"),
                                        0, REG_SZ,
                                        reinterpret_cast<LPCBYTE>((LPCTSTR)rsCspName),
                                        (_tcslen((LPCTSTR)rsCspName) + 1) * sizeof TCHAR);
                if (ERROR_SUCCESS != nStatus)
                {
                    hReturnStatus = HRESULT_FROM_WIN32(nStatus);
                    goto ErrorExit;
                }
                nStatus = RegCloseKey(hVendor);
                hVendor = NULL;
                if (ERROR_SUCCESS != nStatus)
                {
                    hReturnStatus = HRESULT_FROM_WIN32(nStatus);
                    goto ErrorExit;
                }
                fCardIntroduced = TRUE;
                break;

            default:
                hReturnStatus = ERROR_ACCESS_DENIED;
                goto ErrorExit;
            }

        ErrorExit:
            if (NULL != hCtx)
                SCardReleaseContext(hCtx);
            if (NULL != hCalais)
                RegCloseKey(hCalais);
            if (NULL != hVendor)
                RegCloseKey(hVendor);
            break;
        }

        return hReturnStatus;
    }

} // namespace

/*++

DllUnregisterServer:

    This service removes the registry entries associated with this CSP.

Arguments:

    None

Return Value:

    Status code as an HRESULT.

Author:

    Doug Barlow (dbarlow) 3/11/1998

--*/

STDAPI
DllUnregisterServer(void)
{
    LONG nStatus;
    DWORD dwDisp;
    HRESULT hReturnStatus = NO_ERROR;
    HKEY hProviders = NULL;
    SCARDCONTEXT hCtx = NULL;
    CString sProvName;
#ifdef _AFXDLL
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
#endif

    CspProfile const &rProfile = CspProfile::Instance();
    sProvName = rProfile.Name();
    //
    // Delete the Registry key for this CSP.
    //

    nStatus = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                             TEXT("SOFTWARE\\Microsoft\\Cryptography\\Defaults\\Provider"),
                             0, TEXT(""), REG_OPTION_NON_VOLATILE,
                             KEY_ALL_ACCESS, NULL, &hProviders, &dwDisp);
    if (ERROR_SUCCESS == nStatus)
    {
        RegDeleteKey(hProviders, (LPCTSTR)sProvName);
        RegCloseKey(hProviders);
        hProviders = NULL;
    }


    //
    // Remove the cards introduced.
    //
    {
        vector<CardProfile> const &rvcp = rProfile.Cards();
        for (vector<CardProfile>::const_iterator it = rvcp.begin();
             it != rvcp.end(); ++it)
        {
            hReturnStatus = ForgetVendorCard((LPCTSTR)(it->csRegistryName()));
            if (NO_ERROR != hReturnStatus)
                break;
        }

        if (NO_ERROR != hReturnStatus)
            goto ErrorExit;
    }

    //
    // Forget the card type.
    //

    hCtx = NULL;
    SCardEstablishContext(SCARD_SCOPE_SYSTEM, 0, 0, &hCtx);
    SCardForgetCardType(hCtx, (LPCTSTR)sProvName);
    if (NULL != hCtx)
    {
        SCardReleaseContext(hCtx);
        hCtx = NULL;
    }



    //
    // All done!
    //
ErrorExit:
    return hReturnStatus;
}


/*++

DllRegisterServer:

    This function installs the proper registry entries to enable this CSP.

Arguments:

    None

Return Value:

    Status code as an HRESULT.

Author:

    Doug Barlow (dbarlow) 3/11/1998

--*/

STDAPI
DllRegisterServer(void)
{
    TCHAR szModulePath[MAX_PATH+1];  // Security: Leave room to zero
                                     // terminate the buffer for 
                                     // subsequent operations.

    BYTE pbSignature[136];  // Room for a 1024 bit signature, with padding.
    OSVERSIONINFO osVer;
    LPTSTR szFileName, szFileExt;
    HINSTANCE hThisDll;
    HRSRC hSigResource;
    DWORD dwStatus;
    LONG nStatus;
    BOOL fStatus;
    DWORD dwDisp;
    DWORD dwIndex;
    DWORD dwSigLength = 0;
    HRESULT hReturnStatus = NO_ERROR;
    HKEY hProviders = NULL;
    HKEY hMyCsp = NULL;
    HKEY hCalais = NULL;
    HKEY hVendor = NULL;
    BOOL fSignatureFound = FALSE;
    HANDLE hSigFile = INVALID_HANDLE_VALUE;
    SCARDCONTEXT hCtx = NULL;
    CString sProvName;
    
    // TO DO: Card registration should be made by the CCI/IOP, not
    // the CSP.

#ifdef _AFXDLL
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
#endif

    CspProfile const &rProfile = CspProfile::Instance();

    //
    // Figure out the file name and path.
    //

    hThisDll = rProfile.DllInstance();
    if (NULL == hThisDll)
    {
        hReturnStatus = HRESULT_FROM_WIN32(ERROR_INVALID_HANDLE);
        goto ErrorExit;
    }

    dwStatus = GetModuleFileName(hThisDll, szModulePath,
                                 sizeof(szModulePath)/sizeof(TCHAR));
    if (0 == dwStatus)
    {
        hReturnStatus = HRESULT_FROM_WIN32(GetLastError());
        goto ErrorExit;
    }

    // Zero terminate buffer.
    szModulePath[dwStatus] = 0;
    
    szFileName = _tcsrchr(szModulePath, TEXT('\\'));
    if (NULL == szFileName)
        szFileName = szModulePath;
    else
        szFileName += 1;
    szFileExt = _tcsrchr(szFileName, TEXT('.'));
    if (NULL == szFileExt)
    {
        hReturnStatus = HRESULT_FROM_WIN32(ERROR_INVALID_NAME);
        goto ErrorExit;
    }
    else
        szFileExt += 1;


    //
    // Create the Registry key for this CSP.
    //

    nStatus = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                             TEXT("SOFTWARE\\Microsoft\\Cryptography\\Defaults\\Provider"),
                             0, TEXT(""), REG_OPTION_NON_VOLATILE,
                             KEY_ALL_ACCESS, NULL, &hProviders,
                             &dwDisp);
    if (ERROR_SUCCESS != nStatus)
    {
        hReturnStatus = HRESULT_FROM_WIN32(nStatus);
        goto ErrorExit;
    }

    sProvName = rProfile.Name();
    
    nStatus = RegCreateKeyEx(hProviders, (LPCTSTR)sProvName, 0,
                             TEXT(""), REG_OPTION_NON_VOLATILE,
                             KEY_ALL_ACCESS, NULL, &hMyCsp, &dwDisp);
    if (ERROR_SUCCESS != nStatus)
    {
        hReturnStatus = HRESULT_FROM_WIN32(nStatus);
        goto ErrorExit;
    }
    nStatus = RegCloseKey(hProviders);
    hProviders = NULL;
    if (ERROR_SUCCESS != nStatus)
    {
        hReturnStatus = HRESULT_FROM_WIN32(nStatus);
        goto ErrorExit;
    }


    //
    // Install the trivial registry values.
    //
    
    // Security/sysprep requirement: the module path must be replaced
    // with just the dll name to faclilitate sysprep. Corresponding
    // changes to LoadLibrary imply that there are no security risks
    // for system processes. The security implications of such
    // installation for applications is an open question. 
    nStatus = RegSetValueEx(hMyCsp, TEXT("Image Path"), 0, REG_SZ,
                            (LPBYTE)szFileName,//szModulePath,
                            (_tcslen(szFileName/*szModulePath*/) + 1) * sizeof(TCHAR));
    if (ERROR_SUCCESS != nStatus)
    {
        hReturnStatus = HRESULT_FROM_WIN32(nStatus);
        goto ErrorExit;
    }

    {
        DWORD ProviderType = rProfile.Type();
        nStatus = RegSetValueEx(hMyCsp, TEXT("Type"), 0, REG_DWORD,
                                (LPBYTE)&ProviderType,
                                sizeof ProviderType);
        if (ERROR_SUCCESS != nStatus)
        {
            hReturnStatus = HRESULT_FROM_WIN32(nStatus);
            goto ErrorExit;
        }
    }


    //
    // See if we're self-signed.  On NT5, CSP images can carry their own
    // signatures.
    //

    hSigResource = FindResource(hThisDll,
                                MAKEINTRESOURCE(CRYPT_SIG_RESOURCE_NUMBER),
                                RT_RCDATA);


    //
    // Install the file signature.
    //

    ZeroMemory(&osVer, sizeof(OSVERSIONINFO));
    osVer.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    fStatus = GetVersionEx(&osVer);
    if (fStatus &&
        (VER_PLATFORM_WIN32_NT == osVer.dwPlatformId) &&
        (5 <= osVer.dwMajorVersion) &&
        (NULL != hSigResource))
    {

        //
        // Signature in file flag is sufficient.
        //

        dwStatus = 0;
        nStatus = RegSetValueEx(hMyCsp, TEXT("SigInFile"), 0,
                                REG_DWORD, (LPBYTE)&dwStatus,
                                sizeof(DWORD));
        if (ERROR_SUCCESS != nStatus)
        {
            hReturnStatus = HRESULT_FROM_WIN32(nStatus);
            goto ErrorExit;
        }
    }
    else
    {

        //
        // We have to install a signature entry.
        // Try various techniques until one works.
        //

        for (dwIndex = 0; !fSignatureFound; dwIndex += 1)
        {
            switch (dwIndex)
            {

            //
            // Look for an external *.sig file and load that into the registry.
            //

            case 0:
                _tcscpy(szFileExt, TEXT("sig"));
                hSigFile = CreateFile(
                                szModulePath,
                                GENERIC_READ,
                                FILE_SHARE_READ,
                                NULL,
                                OPEN_EXISTING,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL);
                if (INVALID_HANDLE_VALUE == hSigFile)
                    continue;
                dwSigLength = GetFileSize(hSigFile, NULL);
                if ((dwSigLength > sizeof(pbSignature))
                    || (dwSigLength < 72))      // Accept a 512-bit signature
                {
                    hReturnStatus = NTE_BAD_SIGNATURE;
                    goto ErrorExit;
                }

                fStatus = ReadFile(
                            hSigFile,
                            pbSignature,
                            sizeof(pbSignature),
                            &dwSigLength,
                            NULL);
                if (!fStatus)
                {
                    hReturnStatus = HRESULT_FROM_WIN32(GetLastError());
                    goto ErrorExit;
                }
                fStatus = CloseHandle(hSigFile);
                hSigFile = NULL;
                if (!fStatus)
                {
                    hReturnStatus = HRESULT_FROM_WIN32(GetLastError());
                    goto ErrorExit;
                }
                fSignatureFound = TRUE;
                break;


            //
            // Other cases may be added in the future.
            //

            default:
                hReturnStatus = NTE_BAD_SIGNATURE;
                goto ErrorExit;
            }

            if (fSignatureFound)
            {
                for (dwIndex = 0; dwIndex < dwSigLength; dwIndex += 1)
                {
                    if (0 != pbSignature[dwIndex])
                        break;
                }
                if (dwIndex >= dwSigLength)
                    fSignatureFound = FALSE;
            }
        }


        //
        // We've found a signature somewhere!  Install it.
        //

        nStatus = RegSetValueEx(
                        hMyCsp,
                        TEXT("Signature"),
                        0,
                        REG_BINARY,
                        pbSignature,
                        dwSigLength);
        if (ERROR_SUCCESS != nStatus)
        {
            hReturnStatus = HRESULT_FROM_WIN32(nStatus);
            goto ErrorExit;
        }
    }

    nStatus = RegCloseKey(hMyCsp);
    hMyCsp = NULL;
    if (ERROR_SUCCESS != nStatus)
    {
        hReturnStatus = HRESULT_FROM_WIN32(nStatus);
        goto ErrorExit;
    }

    for (dwIndex = 0;
         dwIndex < (sizeof aCardsToForget / sizeof *aCardsToForget);
         dwIndex++)
    {
        hReturnStatus = ForgetVendorCard(aCardsToForget[dwIndex]);
        if (NO_ERROR != hReturnStatus)
            goto ErrorExit;
    }

    //
    // Introduce the vendor cards.  Try various techniques until one works.
    //

    {
        vector<CardProfile> const &rvcp = rProfile.Cards();
        for (vector<CardProfile>::const_iterator it = rvcp.begin();
             it != rvcp.end(); ++it)
        {
            hReturnStatus = IntroduceVendorCard(rProfile.Name(), *it);
            if (NO_ERROR != hReturnStatus)
                break;
        }

        if (NO_ERROR != hReturnStatus)
            goto ErrorExit;
    }


    //
    // ?vendor?
    // Add any additional initialization required here.
    //


    //
    // All done!
    //

    return hReturnStatus;


    //
    // An error was detected.  Clean up any outstanding resources and
    // return the error.
    //

ErrorExit:
    if (NULL != hCtx)
        SCardReleaseContext(hCtx);
    if (NULL != hCalais)
        RegCloseKey(hCalais);
    if (NULL != hVendor)
        RegCloseKey(hVendor);
    if (INVALID_HANDLE_VALUE != hSigFile)
        CloseHandle(hSigFile);
    if (NULL != hMyCsp)
        RegCloseKey(hMyCsp);
    if (NULL != hProviders)
        RegCloseKey(hProviders);
    DllUnregisterServer();
    return hReturnStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\auxcontext.h ===
// AuxContext.h -- Auxiliary Provider Context wrapper functor header to
// manage allocation of a context to one of the Microsoft CSPs (for
// use as a supplemental CSP).

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#if !defined(SLBCSP_AUXCONTEXT_H)
#define SLBCSP_AUXCONTEXT_H

#include <windows.h>
#include <wincrypt.h>

class AuxContext
{
public:
                                                  // Types
                                                  // C'tors/D'tors
    explicit
    AuxContext();

    AuxContext(HCRYPTPROV hcryptprov,
               bool fTransferOwnership = false);

    ~AuxContext();
                                                  // Operators
    HCRYPTPROV
    operator()() const;
                                                  // Operations
                                                  // Access
                                                  // Predicates

protected:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables

private:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables
    HCRYPTPROV m_hcryptprov;
    bool m_fDeleteOnDestruct;
    LPCTSTR m_szProvider;
};


#endif // SLBCSP_AUXCONTEXT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\alignedblob.h ===
// AlignedBlob.h -- Simple Aligned Blob (Binary Large OBject)

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 2001. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#if !defined(SLBCSP_ALIGNEDBLOB_H)
#define SLBCSP_ALIGNEDBLOB_H

#include <stddef.h>                               // for size_t

#include <scuArrayP.h>

#include "Blob.h"

// Copies an Blob into a data buffer that is guaranteed to be
// aligned.  The data buffer in Blob's (std::basic_string/string) are
// not guaranteed to be aligned.  Therefore interpreting the data buffer
// as a structure and dereferencing a non-byte member could result in
// alignment faults.  AlignedBlob creates an aligned data buffer from
// a Blob.   Useful for 64-bit architectures.  AlignedBlob's are
// fixed length and can not grow.  Very primitive.  Their intent is
// only to transform a Blob into something that is data aligned
// for dereferencing purposes only.
class AlignedBlob
{
public:
                                                  // Types
    typedef Blob::value_type ValueType;
    typedef Blob::size_type SizeType;
    
    
                                                  // C'tors/D'tors
    explicit
    AlignedBlob(Blob const &rblb = Blob());

    AlignedBlob(ValueType const *p,
                SizeType cLength);

    AlignedBlob(AlignedBlob const &rhs);
    
    virtual
    ~AlignedBlob() throw();

                                                  // Operators
    AlignedBlob &
    operator=(AlignedBlob const &rhs);
    
    
                                                  // Operations
                                                  // Access
    ValueType *
    Data() const throw();

    SizeType
    Length() const throw();
    
                                                  // Predicates

protected:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables

private:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables
    scu::AutoArrayPtr<ValueType> m_aaBlob;
    SizeType m_cLength;
};

#endif // SLBCSP_ALIGNEDBLOB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\auxcontext.cpp ===
// AuxContext.cpp -- Auxiliary Provider Context wrapper functor to
// manage allocation of a temporal context to one of the Microsoft
// CSPs (for use as a supplemental CSP).

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#include "stdafx.h"
#include <string>
#include <memory>

#include <scuOsExc.h>

#include "AuxContext.h"
#include "Uuid.h"

using namespace std;

///////////////////////////    HELPER     /////////////////////////////////

///////////////////////////    PUBLIC     /////////////////////////////////

                                                  // Types
                                                  // C'tors/D'tors
AuxContext::AuxContext()
    : m_hcryptprov(0),
      m_fDeleteOnDestruct(false),
      m_szProvider()
{
    // Acquire a context to a "temporal" container to one of the
    // Microsoft CSPs for use as an auxiliary CSP.  Attempt is first
    // made for the strong crypto provider (MS Enhanced CSP).  If that
    // isn't available (installed), then an attempt is made for the MS
    // Base CSP.

    // The existence of any objects stored in the acquired container
    // is only for the life of this context object (temporal).  This
    // is implemented by using a feature (as yet undocumented) that
    // was added to the Microsoft CSPs to support the notion of
    // "temporal" or "memory resident" container.  Temporal containers
    // are created by acquiring context with a NULL/empty container
    // name using the CRYPT_VERIFYCONTEXT flag.  These are containers
    // whose associated contents (keys, hashes, etc.) are deleted when
    // the last context to that container is released.  Temporal
    // containers are preferred over creating and releasing/deleting
    // containers with temporary names so the resources used will be
    // freed if the application exists abnormally and not pollute the
    // container name space.

    // COMPATIBILITY ISSUE: Since temporal containers weren't
    // supported by the MS CSP until Windows 2000 Beta 2 (Build 1840),
    // a few hurdles are overcome to acheive similar functionality
    // using previous versions.  It's unclear when temporal containers
    // will be supported on W95/98 & NT 4.  As a result, two methods
    // of acquiring a context to the auxiliary CSP is used.

    // For environments that don't support temporal containers, a
    // normal context is acquired to a uniquely named container since
    // the default container may be used by other
    // applications/threads.  The CRYPT_VERIFYCONTEXT flag can not be
    // used since keys may want to be imported to the temporal
    // container and this characteristic isn't support until Windows 2000.
    // Upon destruction of the object, the container is deleted along
    // with any of its contents just as a first class temporal
    // container.

    static LPCTSTR const aszCandidateProviders[] = {
        MS_ENHANCED_PROV,
        MS_DEF_PROV
    };

    OSVERSIONINFO osVer;
    ZeroMemory(&osVer, sizeof osVer);
    osVer.dwOSVersionInfoSize = sizeof osVer;

    if (!GetVersionEx(&osVer))
        throw scu::OsException(GetLastError());

    basic_string<unsigned char> sContainerName;
    DWORD dwAcquisitionFlags;
    if ((VER_PLATFORM_WIN32_WINDOWS == osVer.dwPlatformId) ||
        ((VER_PLATFORM_WIN32_NT == osVer.dwPlatformId) &&
         (5 > osVer.dwMajorVersion)))
    {
        m_fDeleteOnDestruct = true;

        // Construct a container name that is unique for this thread
        static char unsigned const szRootContainerName[] = "SLBCSP-";
        sContainerName = szRootContainerName;     // prefix for easy debugging
        sContainerName.append(Uuid().AsUString());

        dwAcquisitionFlags = CRYPT_NEWKEYSET;
    }
    else
    {
        m_fDeleteOnDestruct = false;
        dwAcquisitionFlags = CRYPT_VERIFYCONTEXT;
    }

    bool fCandidateFound = false;
    for (size_t i = 0;
         (i < (sizeof aszCandidateProviders /
               sizeof *aszCandidateProviders) && !fCandidateFound); i++)
    {
		CString csCntrName(sContainerName.c_str());
        if (CryptAcquireContext(&m_hcryptprov,
                                (LPCTSTR)csCntrName,
                                aszCandidateProviders[i],
                                PROV_RSA_FULL, dwAcquisitionFlags))
        {
            fCandidateFound = true;
            m_szProvider = aszCandidateProviders[i];
        }
    }

    if (!fCandidateFound)
        throw scu::OsException(GetLastError());
}

AuxContext::AuxContext(HCRYPTPROV hcryptprov,
                       bool fTransferOwnership)
    : m_hcryptprov(hcryptprov),
      m_fDeleteOnDestruct(fTransferOwnership),
      m_szProvider()
{}

AuxContext::~AuxContext()
{
    if (0 != m_hcryptprov)
    {
        if (m_fDeleteOnDestruct)
        {
            auto_ptr<char> apszContainerName(0);
            
            DWORD dwNameLength;
            if (CryptGetProvParam(m_hcryptprov, PP_CONTAINER, NULL,
                                  &dwNameLength, 0))
            {
                apszContainerName =
                    auto_ptr<char>(new char[dwNameLength]);
                if (!CryptGetProvParam(m_hcryptprov, PP_CONTAINER,
                                       reinterpret_cast<char unsigned *>(apszContainerName.get()),
                                       &dwNameLength, 0))
                    apszContainerName = auto_ptr<char>(0);
            }

            if (CryptReleaseContext(m_hcryptprov, 0))
            {
                if (apszContainerName.get())
                    CryptAcquireContext(&m_hcryptprov, (LPCTSTR)apszContainerName.get(),
                                        m_szProvider, PROV_RSA_FULL,
                                        CRYPT_DELETEKEYSET);
            }
        }
        else    // Just release the context
        {
            CryptReleaseContext(m_hcryptprov, 0);
        }
    }
}



                                                  // Operators
HCRYPTPROV
AuxContext::operator()() const
{
    return m_hcryptprov;
}

                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables

///////////////////////////   PROTECTED   /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables


///////////////////////////    PRIVATE    /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\auxhash.cpp ===
// AuxHash.cpp -- Auxillary Hash class implementation

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
#include "NoWarning.h"
#include "ForceLib.h"

#include <memory>                               

#include <windows.h>
#include <wincrypt.h>

#include <scuOsExc.h>
#include <scuArrayP.h>

#include "AuxHash.h"

using namespace std;
using namespace scu;

///////////////////////////    HELPER     /////////////////////////////////

///////////////////////////  LOCAL VAR    /////////////////////////////////

///////////////////////////    PUBLIC     /////////////////////////////////

                                                  // Types
                                                  // C'tors/D'tors
AuxHash::AuxHash(AuxContext &rauxcontext,
                 ALG_ID ai,
                 HCRYPTKEY hKey)
    : m_hHash(0)
{
    if (!CryptCreateHash(rauxcontext(), ai, hKey, 0, &m_hHash))
        throw scu::OsException(GetLastError());
}

AuxHash::~AuxHash()
{
    if (m_hHash)
        CryptDestroyHash(m_hHash);
}


                                                  // Operators
                                                  // Operations

// Import a hash value into the hash object.
void
AuxHash::Import(Blob const &rblbHashValue)
{
    if (!CryptSetHashParam(m_hHash, HP_HASHVAL,
                           const_cast<BYTE *>(rblbHashValue.data()), 0))
        throw scu::OsException(GetLastError());
}

// Update the hash value with the data blob.
void
AuxHash::Update(Blob const &rblob)
{
    if (!CryptHashData(m_hHash, rblob.data(), rblob.length(), 0))
        throw scu::OsException(GetLastError());
}

                                                  // Access
ALG_ID
AuxHash::AlgId() const
{
    ALG_ID ai;
    DWORD c = sizeof ai;

    if (!CryptGetHashParam(m_hHash, HP_ALGID,
                           reinterpret_cast<BYTE *>(&ai), &c, 0))
        throw scu::OsException(GetLastError());

    return ai;
}

DWORD
AuxHash::Size() const
{
    DWORD dwSize;
    DWORD cSize = sizeof dwSize;

    if (!CryptGetHashParam(m_hHash, HP_ALGID,
                           reinterpret_cast<BYTE *>(&dwSize), &cSize, 0))
        throw scu::OsException(GetLastError());

    return dwSize;
}

// Completes the hash returning the hash value.  No more hashing can
// occur with this object.
Blob
AuxHash::Value() const
{
    DWORD dwSize = Size();

    AutoArrayPtr<BYTE> apb(new BYTE[dwSize]);
    if (!CryptGetHashParam(m_hHash, HP_HASHVAL, apb.Get(), &dwSize, 0))
        throw scu::OsException(GetLastError());

    return Blob(apb.Get(), dwSize);
}

// Returns the hash of the data blob passed.  No more hashing can
// occur with this object.
Blob
AuxHash::Value(Blob const &rblob)
{
    Update(rblob);

    return Value();
}



                                                  // Predicates
                                                  // Static Variables

///////////////////////////   PROTECTED   /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables


///////////////////////////    PRIVATE    /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\cachingobj.cpp ===
// CachingObj.cpp -- Caching Object class definition

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#include "CachingObj.h"

/////////////////////////// LOCAL/HELPER  /////////////////////////////////

///////////////////////////    PUBLIC     /////////////////////////////////

                                                  // Types
                                                  // C'tors/D'tors
CachingObject::CachingObject()
{}

CachingObject::~CachingObject()
{}

                                                  // Operators
                                                  // Operations
void
CachingObject::DeleteCache()
{}

                                                  // Access
                                                  // Predicates
                                                  // Static Variables

///////////////////////////   PROTECTED   /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables


///////////////////////////    PRIVATE    /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\auxhash.h ===
// AuxHash.h -- Auxillary Hash class declaration

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#if !defined(SLBCSP_AUXHASH_H)
#define SLBCSP_AUXHASH_H

#include <wincrypt.h>

#include "Blob.h"

#include "AuxContext.h"

// Base class for all hash classes using a CSP (Auxillary provider)
class AuxHash
{
public:
                                                  // Types
                                                  // C'tors/D'tors

    AuxHash(AuxContext &rauxcontext,              // Context to use
            ALG_ID ai,                            // Hashing algorithm
            HCRYPTKEY hKey = 0);                   // Encryption key

    virtual
    ~AuxHash();

                                                  // Operators
                                                  // Operations
    void
    Import(Blob const &rblob);

    void
    Update(Blob const &rblob);

                                                  // Access
    ALG_ID
    AlgId() const;

    DWORD
    Size() const;

    Blob
    Value() const;

    Blob
    Value(Blob const &rblob);

                                                  // Predicates

protected:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables

private:
                                                  // Types
                                                  // C'tors/D'tors

    AuxHash(AuxHash const &rhs);                  // do not define

                                                  // Operators

    AuxHash &
    operator=(AuxHash const &rhs);                // do not define

                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables
    HCRYPTHASH m_hHash;
};

#endif // SLBCSP_AUXHASH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\cachingobj.h ===
// CachingObj.h -- Caching Object class declaration

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#if !defined(SLBCSP_CACHINGOBJ_H)
#define SLBCSP_CACHINGOBJ_H

// Base class for objects that caches information and need to be
// notified when to mark the cache stale and delete the cache.
class CachingObject
{
public:
                                                  // Types
                                                  // C'tors/D'tors
    explicit
    CachingObject();

    virtual
    ~CachingObject();


                                                  // Operators
                                                  // Operations
    // Clears any cached information.
    virtual void
    ClearCache() = 0;

    // Deletes the cache.  Some classes may need free the cache
    // resource and related information as if the object had been
    // delete.  The base class version doesn't do anything.
    virtual void
    DeleteCache();


                                                  // Access
                                                  // Predicates

protected:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables

private:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables

};

#endif // SLBCSP_CACHINGOBJ_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\blob.h ===
// Blob.h -- Blob type and primitives

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#if !defined(SLBCSP_BLOB_H)
#define SLBCSP_BLOB_H

#if defined(_UNICODE)
  #if !defined(UNICODE)
    #define UNICODE
  #endif //!UNICODE
#endif //_UNICODE

#if defined(UNICODE)
  #if !defined(_UNICODE)
    #define _UNICODE
  #endif //!_UNICODE
#endif //UNICODE

#include <string>

#include <windows.h>

// Blob -- a Binary Large Object
typedef std::basic_string<BYTE> Blob;

// Helper routines

Blob const
AsBlob(std::string const &rrhs);

Blob
AsBlob(std::string &rrhs);

std::string const
AsString(Blob const &rlhs);

std::string
AsString(Blob &rlhs);

const char*
AsCCharP(LPCTSTR pczs);

Blob::size_type
LengthFromBits(size_t cBitLength);

size_t
LengthInBits(Blob::size_type cSize);

#endif // SLBCSP_BLOB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\blob.cpp ===
// Blob.cpp -- Blob primitives

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
#if defined(_UNICODE)
  #if !defined(UNICODE)
    #define UNICODE
  #endif //!UNICODE
#endif //_UNICODE

#if defined(UNICODE)
  #if !defined(_UNICODE)
    #define _UNICODE
  #endif //!_UNICODE
#endif //UNICODE

#include "NoWarning.h"
#include "ForceLib.h"

#include <limits>

#include "Blob.h"

using namespace std;

Blob const
AsBlob(std::string const &rrhs)
{
    return reinterpret_cast<Blob const &>(rrhs);
}

Blob
AsBlob(std::string &rrhs)
{
    return reinterpret_cast<Blob &>(rrhs);
}


string const
AsString(Blob const &rrhs)
{
    return reinterpret_cast<string const &>(rrhs);
}

string
AsString(Blob &rrhs)
{
    return reinterpret_cast<string &>(rrhs);
}

const char*
AsCCharP(LPCTSTR pczs)
{
    return reinterpret_cast<const char*>(pczs);
}

Blob::size_type
LengthFromBits(size_t cBitLength)
{
    Blob::size_type cLength =
        cBitLength / numeric_limits<Blob::value_type>::digits;

    if (0 != (cBitLength % numeric_limits<Blob::value_type>::digits))
        ++cLength;

    return cLength;
}

size_t
LengthInBits(Blob::size_type cSize)
{
    return cSize * numeric_limits<Blob::value_type>::digits;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\cardctxreg.cpp ===
// CardCtxReg.cpp -- Card ConTeXt Registrar implementation

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
#include "NoWarning.h"
#include "ForceLib.h"

#include "CardCtxReg.h"

/////////////////////////// LOCAL/HELPER  /////////////////////////////////

// Obligatory definitions
CardContextRegistrar::RegistryType *CardContextRegistrar::m_pregistry = 0;


///////////////////////////    PUBLIC     /////////////////////////////////

                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables

///////////////////////////   PROTECTED   /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables


///////////////////////////    PRIVATE    /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\cardctx.cpp ===
// CardCtx.cpp -- Card ConTeXt class definition

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

// Don't allow the min & max macros in WINDEF.H to be defined so the
// min/max methods declared in limits are accessible.
#define NOMINMAX

#include "NoWarning.h"
#include "ForceLib.h"

#include <limits>
#include <algorithm>
#include <numeric>

#include <scuOsExc.h>
#include <scuCast.h>
#include "HCardCtx.h"
#include "LoginCtx.h"
#include "Procedural.h"
#include "HAdptvCntr.h"
#include "Guarded.h"
#include <scarderr.h>                             // always last for now

using namespace std;
using namespace cci;


/////////////////////////// LOCAL/HELPER  /////////////////////////////////
namespace
{
    class StaleContainerKeyAccumulator
        : public binary_function<vector<AdaptiveContainerRegistrar::EnrolleeType>,
                                 AdaptiveContainerRegistrar::RegistryType::CollectionType::value_type,
                                 vector<AdaptiveContainerRegistrar::EnrolleeType> >
    {
    public:

        explicit
        StaleContainerKeyAccumulator(HCardContext const &rhcardctx)
            : m_rhcardctx(rhcardctx)
        {}


        result_type
        operator()(first_argument_type &rvStaleCntrs,
                   second_argument_type const &rvt) const
        {
            if (rvt.second->CardContext(false) == m_rhcardctx)
                rvStaleCntrs.push_back(rvt.second);

            return rvStaleCntrs;
        }

    private:

        HCardContext const &m_rhcardctx;
    };

    void
    ClearAdaptiveContainerCache(AdaptiveContainerRegistrar::EnrolleeType enrollee,
                                HCardContext hcardctx)
    {
        if (enrollee->CardContext(false) == hcardctx)
		{
			enrollee->ClearCache();
		}
    }

    void
    DeleteAdaptiveContainerCache(AdaptiveContainerRegistrar::EnrolleeType enrollee,
                                 HCardContext hcardctx)
    {
        if (enrollee->CardContext(false) == hcardctx)
            enrollee->DeleteCache();
    }

    void
    DeactivateLoginContext(auto_ptr<LoginContext> const &raplc)
    {
        raplc->Deactivate();
    }
}

///////////////////////////    PUBLIC     /////////////////////////////////

                                                  // Types
                                                  // C'tors/D'tors
CardContext::CardContext(std::string const &rsReaderName)
    : RCObject(),
      Lockable(),
      Securable(),
      CachingObject(),
      CardContextRegistrar(rsReaderName),
      m_stkapGuards(),
      m_aptwCard(),
      m_cSecurers(0),
      m_card(CCard(rsReaderName)),
      m_mloginctx(),
      m_nMrkLastWrite()
{}

CardContext::~CardContext() throw()
{}


                                                  // Operators
                                                  // Operations
void
CardContext::ClearLogin(LoginIdentity const &rlid)
{
    Guarded<CardContext *> guard(this);

    auto_ptr<LoginContext> &raplc = m_mloginctx[rlid];

    if (raplc.get())
        raplc = auto_ptr<LoginContext>(0);
}

void
CardContext::Login(LoginIdentity const &rlid,
                   LoginTask &rlt,
                   bool fForceLogin)
{
    Guarded<CardContext *> guard(this);

    auto_ptr<LoginContext> &raplc = m_mloginctx[rlid];

    if (!raplc.get())
        raplc = auto_ptr<LoginContext>(new LoginContext(HCardContext(this),
                                                        rlid));

    if (fForceLogin || !raplc->IsActive())
        raplc->Activate(rlt);
}

void
CardContext::Logout()
{
    ForEachMappedValue(m_mloginctx.begin(), m_mloginctx.end(),
                       DeactivateLoginContext);
}

                                                  // Access
CCard
CardContext::Card()
{
    return m_card;
}

                                                  // Predicates
                                                  // Static Variables

///////////////////////////   PROTECTED   /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
void
CardContext::DiscardHook()
{
    DeleteCache();
    RemoveReference();
}

CardContext *
CardContext::DoInstantiation(std::string const &rsReaderName)
{
    return new CardContext(rsReaderName);
}

void
CardContext::EnrollHook()
{
    AddReference();
}

                                                  // Access
                                                  // Predicates
bool
CardContext::KeepEnrolled()
{
    return (m_card && m_card->IsAvailable())
        ? true
        : false;
}

                                                  // Static Variables


///////////////////////////    PRIVATE    /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
void
CardContext::Abandon()
{
    // Simplifying assumptions: (1) Abandon is only called by the
    // Secured destructor, (2) once the object is constructed, Secure
    // and Abandon are the only routines that access the count, and
    // (3) Abandon is called by a thread within the scope of a Retain
    // (e.g. using Retained) which the Secured class enforces.
    // Because of (1) and (2), an underflow check on the count is not
    // necessary since Secure will have already been called.  Because
    // of (3), protection against race conditions accessing count
    // isn't necessary since Retain acts as a lock.
    --m_cSecurers;
    if (0 == m_cSecurers)
    {
        // Security: markers are moved to the card. Updating them
        // requires authentication by the user pin.
        // Notify any changes to this card during this transaction
        // before letting someone else have access and before loggin
        // out.
        try
        {
            UpdateMarkers();
        }
        catch(...)
        {
            // do not leave the card in authenticated state
            Logout();
            throw;
        }
        
        Logout();
    }
}

// Optionally clear the cached info
void
CardContext::ClearCache()
{
    // Security: markers reside on the card. We trade off performance for
    // security because any update of the marker requires
    // authentication by the user pin. On the other hand, reading
    // markers from the card is considerably slower than reading from
    // memory. 

    if(!Card()->IsMarkerOnCard() || m_nMrkLastWrite != Card()->MarkerOnCard())
    {
        ForEachEnrollee(AdaptiveContainerRegistrar::Registry(),
                        ProcedureBind2nd(PointerProcedure(ClearAdaptiveContainerCache),
                                         HCardContext(this)));
        Card()->InvalidateCache();
    }
}

// Delete any cached info, never to be refreshed
void
CardContext::DeleteCache()
{
    m_mloginctx.clear();

    Guarded<Lockable *> guard(&AdaptiveContainerRegistrar::Registry());  // serialize registry access

    AdaptiveContainerRegistrar::ConstRegistryType &rRegistry = 
        AdaptiveContainerRegistrar::Registry();

    AdaptiveContainerRegistrar::ConstRegistryType::CollectionType
        &rcollection = rRegistry();

    HCardContext hcardctx(this);

    // Any containers associated with this card should be marked stale
    // now because on Whistler (W2K Upgrade) trying to access them
    // later when another context has a begin transaction on the same
    // reader will cause a wait.  On earlier platforms, the RM would
    // return an error (e.g. card removed) when attempting to access
    // the container.
    vector<AdaptiveContainerRegistrar::EnrolleeType>
        vStaleCntrs(accumulate(rcollection.begin(), rcollection.end(),
                              vector<AdaptiveContainerRegistrar::EnrolleeType>(),
                              StaleContainerKeyAccumulator(hcardctx)));
    for (vector<AdaptiveContainerRegistrar::EnrolleeType>::iterator iCurrent(vStaleCntrs.begin());
         iCurrent != vStaleCntrs.end(); ++iCurrent)
    {
            (*iCurrent)->NullifyCard();
    }
}

void
CardContext::Relinquish()
{
    // Simplifying assumptions: (1) Relinquish is only called by the
    // Retained destructor and (2) once the object is constructed,
    // Retain and Relinquish are the only routines that access the
    // m_stkapGuards and m_aptwCard.  Because of (1) and (2), an
    // underflow check on m_stkRetainedCardContexts is not necessary
    // since Retain will have already been called.

    // Protect against exceptions by fist assigning the newly acquired
    // "locks" to temporary variables until all the actions necessary
    // are successfully completed before assigning transfering
    // ownership of the locks to the associated member variables.
    auto_ptr<Guarded<CardContext *> > apgcardctx(m_stkapGuards.front());
    m_stkapGuards.pop_front();

    if (m_stkapGuards.empty())
    {
        try
        {
            m_aptwCard = auto_ptr<CTransactionWrap>(0);
        }
        catch (...)
        {
        }        
    }
}

void
CardContext::Retain()
{
    // Simplifying assumptions: (1) Retain is only called by the
    // Retained constructor and (2) once the object is constructed,
    // Retain and Relinquish are the only routines that access the
    // m_stkapGuards and m_aptwCard.  Because of (1) and (2), an
    // underflow check on m_stkRetainedCardContexts is not necessary
    // since Retain will have already been called.

    // Protect against exceptions by fist assigning the newly acquired
    // "locks" to temporary variables until all the actions necessary
    // are successfully completed before assigning transfering
    // ownership of the locks to the associated member variables.
    auto_ptr<Guarded<CardContext *> > apgcardctx(new Guarded<CardContext *>(this));
    auto_ptr<CTransactionWrap> aptwCard;

    if (m_stkapGuards.empty())
    {
        aptwCard = auto_ptr<CTransactionWrap>(new CTransactionWrap(m_card));
        ClearCache();
    }
    
    m_stkapGuards.push_front(apgcardctx);
    if (aptwCard.get())
        m_aptwCard = aptwCard;
}

void
CardContext::UpdateMarkers()
{
    // Security: there is only one marker and it resides on the
    // card. The marker indicates if any data on the card changed. 
    m_nMrkLastWrite = Card()->MarkerOnCard();
}

void
CardContext::Secure()
{
    // Simplifying assumptions: (1) Secure is always called by a thread
    // within the scope of a Retain (e.g. using Retained).  The
    // Secured template enforces this allowing Retain to act as a lock
    // to prevent race conditions updating m_cSecurers.  (2) Once the
    // object is constructed, Secure and Abandon are the only routines
    // that access m_cSecurers.
    if (0 >= (m_cSecurers + 1))
        throw scu::OsException(ERROR_INVALID_HANDLE_STATE);

    ++m_cSecurers;
}

                                                  // Access
                                                  // Predicates
                                                  // Static Variables
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\cardctxreg.h ===
// CardCtxReg.h -- Card ConTeXt template class declaration

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#if !defined(SLBCSP_CARDCTXREG_H)
#define SLBCSP_CARDCTXREG_H

#include <string>

#include "Registrar.h"

class CardContext;                                // forward declaration

typedef Registrar<std::string, CardContext> CardContextRegistrar;

#endif // SLBCSP_CardCtxReg_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\cardenum.cpp ===
// CardEnum.cpp -- CardEnumerator class implementation

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 2001. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
#if defined(_UNICODE)
  #if !defined(UNICODE)
    #define UNICODE
  #endif //!UNICODE
#endif //_UNICODE

#if defined(UNICODE)
  #if !defined(_UNICODE)
    #define _UNICODE
  #endif //!_UNICODE
#endif //UNICODE

#include "StdAfx.h"
#include "CardEnum.h"

using namespace std;
using namespace scu;

/////////////////////////// LOCAL/HELPER  /////////////////////////////////


///////////////////////////    PUBLIC     /////////////////////////////////

                                                  // Types
                                                  // C'tors/D'tors
CardEnumerator::CardEnumerator()
    : CardFinder(ddmNever),
      m_lhcardctx()
{}

CardEnumerator::~CardEnumerator()
{}

                                                  // Operators
                                                  // Operations

auto_ptr<list<HCardContext> >
CardEnumerator::Cards()
{
   DoFind(CSpec());                               // any card

   return auto_ptr<list<HCardContext> >(new list<HCardContext>(m_lhcardctx));
}

void
CardEnumerator::DoOnError()
{
    // don't throw any errors so all cards in all readers are processed.
    ClearException();
}

void
CardEnumerator::DoProcessSelection(DWORD dwStatus,
                                   OpenCardNameType &ropencardname,
                                   bool &rfContinue)
{
    rfContinue = false;

    m_lhcardctx.unique();
}


                                                  // Access
                                                  // Predicates
                                                  // Static Variables

///////////////////////////   PROTECTED   /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates

bool
CardEnumerator::DoIsValid()
{
    bool fIsValid = CardFinder::DoIsValid();

    if (fIsValid)
        m_lhcardctx.push_front(CardFound());

    return fIsValid;
}

                                                  // Static Variables


///////////////////////////    PRIVATE    /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\certificateextensions.h ===
// CertificateExtensions.h -- Certificate Extensions class

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 2001. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#if !defined(SLBCSP_CERTIFICATEEXTENSIONS_H)
#define SLBCSP_CERTIFICATEEXTENSIONS_H

#include <WinCrypt.h>

#include "Blob.h"

class CertificateExtensions
{
public:
                                                  // Types
                                                  // C'tors/D'tors
    explicit
    CertificateExtensions(Blob const &rblbCertificate);

    ~CertificateExtensions();
    
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates

    bool
    HasEKU(char *szOID);
    
protected:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables

private:
                                                  // Types
                                                  // C'tors/D'tors
    // not defined.
    explicit
    CertificateExtensions(CertificateExtensions const &rhs);
    

                                                  // Operators

    // not defined
    CertificateExtensions &
    operator=(CertificateExtensions const &rhs);
    
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables
    PCCERT_CONTEXT m_pCertCtx;
};

#endif // SLBCSP_CERTIFICATEEXTENSIONS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\cardenum.h ===
// CardEnum.cpp -- Card Enumerator

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 2001. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#if !defined(SLBCSP_CARDENUMERATOR_H)
#define SLBCSP_CARDENUMERATOR_H

#include "CardFinder.h"

class CardEnumerator
    : protected CardFinder
{
public:
                                                  // Types
                                                  // C'tors/D'tors
    explicit
    CardEnumerator();

    virtual
    ~CardEnumerator();

                                                  // Operators
                                                  // Operations
    std::auto_ptr<std::list<HCardContext> >
    Cards();

                                                  // Access
                                                  // Predicates
                                                  // Static Variables
protected:

                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
    virtual void
    DoOnError();

    virtual void
    DoProcessSelection(DWORD dwStatus,
                       OpenCardNameType &ropencardname,
                       bool &rfContinue);

                                                  // Access
                                                  // Predicates

    virtual bool
    DoIsValid();

                                                  // Variables

private:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables

    std::list<HCardContext> m_lhcardctx;
    
};

#endif // SLBCSP_CARDFINDER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\cardfinder.h ===
// CardFinder.h -- CardFinder class header

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#if !defined(SLBCSP_CARDFINDER_H)
#define SLBCSP_CARDFINDER_H

#if defined(_UNICODE)
  #if !defined(UNICODE)
    #define UNICODE
  #endif //!UNICODE
#endif //_UNICODE

#if defined(UNICODE)
  #if !defined(_UNICODE)
    #define _UNICODE
  #endif //!_UNICODE
#endif //UNICODE

#include <string>
#include <memory>                                 // for auto_ptr

#include <windef.h>

#include <scuOsVersion.h>

#include "StResource.h"
#include "HSCardCtx.h"
#include "cspec.h"
#include "HCardCtx.h"
#include "Secured.h"
#include "MultiStrZ.h"
#include "ExceptionContext.h"

#if defined(SLB_NOWIN2K_BUILD)
#define SLBCSP_USE_SCARDUIDLGSELECTCARD 0
#else
#define SLBCSP_USE_SCARDUIDLGSELECTCARD 1
#endif

class CardFinder
    : protected ExceptionContext
{

    friend class OpenCardCallbackContext;         // for Do* routines

public:
                                                  // Types
    enum DialogDisplayMode
    {
        ddmNever,
        ddmIfNecessary,
        ddmAlways
    };

                                                  // C'tors/D'tors
    CardFinder(DialogDisplayMode ddm,
               HWND hwnd = 0,
               CString const &rsDialogTitle = StringResource(IDS_SEL_SLB_CRYPTO_CARD).AsCString());

    virtual
    ~CardFinder();

                                                  // Operators
                                                  // Operations
    Secured<HCardContext>
    Find(CSpec const &rsReader);

                                                  // Access

    DialogDisplayMode
    DisplayMode() const;

    HWND
    Window() const;

                                                  // Predicates
                                                  // Static Variables
protected:

    // Note: CardFinder uses GetOpenCardName/SCardUIDlgSelect to find
    // the card.  These routines do not propagate exception thrown by
    // the callback routines.  To throw these exceptions from
    // CardFinder and its derived classes, a set of wrapper callback
    // routines Connect, Disconnect and IsValid are defined for
    // DoConnect, DoDisconnect, and DoIsValid (repectively) which catch
    // exceptions thrown by these Do routines and set the
    // CallbackException attribute.  When control is returned from
    // GetOpenCardName/SCardUIDlgSelect, the DoOnError routine is
    // called.  If a callback exception still exists, then the
    // exception is propagated to the caller of CardFinder class.

                                                  // Types
#if !SLBCSP_USE_SCARDUIDLGSELECTCARD
    typedef OPENCARDNAME OpenCardNameType;
#else
    typedef OPENCARDNAME_EX OpenCardNameType;
#endif

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations

    void
    CardFound(Secured<HCardContext> const &rshcardctx);

    virtual SCARDHANDLE
    DoConnect(std::string const &rsSelectedReader);

    virtual void
    DoDisconnect();

    void
    DoFind(CSpec const &rcspec);

    virtual void
    DoOnError();

    virtual void
    DoProcessSelection(DWORD dwStatus,
                       OpenCardNameType &ropencardname,
                       bool &rfContinue);
    
    void
    YNPrompt(UINT uID) const;

                                                  // Access

    CSpec const &
    CardSpec() const;

    Secured<HCardContext>
    CardFound() const;

                                                  // Predicates

    virtual bool
    DoIsValid();

                                                  // Variables

private:
                                                  // Types

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations

    void
    CheckFn(LPOCNCHKPROC lpfnCheck);

    static SCARDHANDLE __stdcall
    Connect(SCARDCONTEXT scardctx,
            LPTSTR szReader,
            LPTSTR mszCards,
            LPVOID lpvUserData);

    void
    ConnectFn(LPOCNCONNPROC lpfnConnect);

    static void __stdcall
    Disconnect(SCARDCONTEXT scardctx,
               SCARDHANDLE hSCard,
               LPVOID lpvUserData);

    void
    DisconnectFn(LPOCNDSCPROC lpfnDisconnect);

    void
    OnError();

    DWORD
        SelectCard(OpenCardNameType &ropcn);

    void
    UserData(void *pvUserData);

    void
    WorkaroundOpenCardDefect(OpenCardNameType const &ropcnDlgCtrl,
                             DWORD &rdwStatus);    
                                                   // Access

    LPOCNCHKPROC
    CheckFn() const;

    LPOCNDSCPROC
    DisconnectFn() const;

                                                  // Predicates

    static BOOL __stdcall
    IsValid(SCARDCONTEXT scardctx,
            SCARDHANDLE hSCard,
            LPVOID lpvUserData);

                                                  // Variables

    CString const m_sDialogTitle;
    DialogDisplayMode const m_ddm;
    HWND const m_hwnd;
    std::auto_ptr<MultiStringZ> m_apmszSupportedCards;
    OpenCardNameType m_opcnDlgCtrl;
#if SLBCSP_USE_SCARDUIDLGSELECTCARD
    OPENCARD_SEARCH_CRITERIA m_opcnCriteria;
    CString m_sInsertPrompt;
#endif
    CSpec m_cspec;
    HSCardContext m_hscardctx;
    Secured<HCardContext> m_shcardctx;
};

#endif // SLBCSP_CARDFINDER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\certificateextensions.cpp ===
// CertificateExtensions..cpp -- Certificate Extensions class

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 2001. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#include <scuOsExc.h>
#include <scuArrayP.h>

#include "CertificateExtensions.h"

using namespace std;

/////////////////////////// LOCAL/HELPER  /////////////////////////////////
///////////////////////////    PUBLIC     /////////////////////////////////

                                                  // Types
                                                  // C'tors/D'tors
CertificateExtensions::CertificateExtensions(Blob const &rblbCertificate)
    : m_pCertCtx(CertCreateCertificateContext(X509_ASN_ENCODING |
                                              PKCS_7_ASN_ENCODING,
                                              rblbCertificate.data(),
                                              rblbCertificate.size()))
{
    if (!m_pCertCtx)
        throw scu::OsException(GetLastError());
}

CertificateExtensions::~CertificateExtensions()
{
    try
    {
        if (m_pCertCtx)
        {
            CertFreeCertificateContext(m_pCertCtx);
            m_pCertCtx = 0;
        }
    }

    catch (...)
    {
    }
}

                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
bool
CertificateExtensions::HasEKU(char *szOID)
{
    bool fFound = false;

    CERT_EXTENSION      *pExtension = NULL;
    DWORD               cbSize = 0;
    DWORD               dwIndex = 0;

    CERT_ENHKEY_USAGE   *pEnhKeyUsage=NULL;

    if (m_pCertCtx->pCertInfo)
    {

        //find the EKU extension
        pExtension =CertFindExtension(szOID_ENHANCED_KEY_USAGE,
                                      m_pCertCtx->pCertInfo->cExtension,
                                      m_pCertCtx->pCertInfo->rgExtension);

        if(pExtension)
        {
            if(CryptDecodeObject(X509_ASN_ENCODING,
                              X509_ENHANCED_KEY_USAGE,
                              pExtension->Value.pbData,
                              pExtension->Value.cbData,
                              0,
                              NULL,
                              &cbSize))

            {
                scu::AutoArrayPtr<BYTE> aabEKU(new BYTE[cbSize]);
                pEnhKeyUsage=reinterpret_cast<CERT_ENHKEY_USAGE *>(aabEKU.Get());

                if(pEnhKeyUsage)
                {
                    if(CryptDecodeObject(X509_ASN_ENCODING,
                                      X509_ENHANCED_KEY_USAGE,
                                      pExtension->Value.pbData,
                                      pExtension->Value.cbData,
                                      0,
                                      aabEKU.Get(),
                                      &cbSize))
                    {
                        for(dwIndex=0; dwIndex < pEnhKeyUsage->cUsageIdentifier; dwIndex++)
                        {
                            if(0 == strcmp(szOID, 
                                           (pEnhKeyUsage->rgpszUsageIdentifier)[dwIndex]))
                            {
                                //we find it
                                fFound=TRUE;
                                break;
                            }
                        }
                    }
                }
            }
        }
    }

/*
    PCERT_INFO const pCertInfo = m_pCertCtx->pCertInfo;
    for (DWORD dwExtension = 0;
         !fFound && (dwExtension < pCertInfo->cExtension);
         dwExtension++)
    {
        PCERT_EXTENSION const pCertExt =
            &pCertInfo->rgExtension[dwExtension];
        if (0 == strcmp(pCertExt->pszObjId, rsExt.c_str()))
            fFound = true;
    }
*/
    return fFound;
}

    
        
                                                  // Static Variables

///////////////////////////   PROTECTED   /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables


///////////////////////////    PRIVATE    /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\cntrenum.h ===
// CntrEnum.h -- Card Container Enumerator

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#if !defined(SLBCSP_CNTRENUM_H)
#define SLBCSP_CNTRENUM_H

#include <string>
#include <list>
#include <vector>

#include "HCardCtx.h"
#include "CardEnum.h"

class ContainerEnumerator
{
public:
                                                  // Types
                                                  // C'tors/D'tors
    // explicit -- TO DO: compiler erroneously complains if explicit used here
    ContainerEnumerator();
    
    explicit
    ContainerEnumerator(std::list<HCardContext> const &rlHCardContexts);

    // explicit -- TO DO: compiler complains erroneously if explicit used here
    ContainerEnumerator(ContainerEnumerator const &rhs);

                                                  // Operators
    ContainerEnumerator &
    operator=(ContainerEnumerator const &rhs);

                                                  // Operations
                                                  // Access
    std::vector<std::string>::const_iterator &
    Iterator();

    std::vector<std::string> const &
    Names() const;

                                                  // Predicates

protected:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables

private:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables
    std::vector<std::string> m_vsNames;
    std::vector<std::string>::const_iterator m_it;
};

#endif // SLBCSP_CNTRENUM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\cntrenum.cpp ===
// CntrEnum.cpp -- Card Container Enumerator

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
#include "StdAfx.h"
#include "NoWarning.h"
#include "ForceLib.h"

#include <algorithm>
#include <numeric>

#include <cciCont.h>

#include "Secured.h"
#include "CntrEnum.h"

using namespace std;
using namespace cci;

/////////////////////////// LOCAL/HELPER  /////////////////////////////////
namespace
{
    vector<string>
    AccumulateUniqueNameOf(vector<string> &rvsNames,
                     CContainer &rcntr)
    {
        string sName(rcntr->Name());
        if (rvsNames.end() == find(rvsNames.begin(), rvsNames.end(), sName))
            rvsNames.push_back(sName);
        
        return rvsNames;
    }

    class ContainerNameAccumulator
        : public unary_function<HCardContext const, void>
    {
    public:

        explicit
        ContainerNameAccumulator(vector<string> &rvsContainers)
            : m_rvsContainers(rvsContainers)
        {}

        result_type
        operator()(argument_type &rhcardctx) const
        {
            try
            {
                vector<CContainer> vContainers(rhcardctx->Card()->EnumContainers());

                vector<string> vs(accumulate(vContainers.begin(),
                                             vContainers.end(),
                                             m_rvsContainers,
                                             AccumulateUniqueNameOf));

                m_rvsContainers.insert(m_rvsContainers.end(),
                                       vs.begin(), vs.end());
                
            }

            catch(...)
            {
                // ignore cards we have problems with
            }
            
        }

    private:

        vector<string> &m_rvsContainers;
    };
}

///////////////////////////    PUBLIC     /////////////////////////////////

                                                  // Types
                                                  // C'tors/D'tors
ContainerEnumerator::ContainerEnumerator()
    : m_vsNames(),
      m_it(m_vsNames.end())
{}

ContainerEnumerator::ContainerEnumerator(list<HCardContext> const &rlHCardContexts)
{
    for_each(rlHCardContexts.begin(), rlHCardContexts.end(),
             ContainerNameAccumulator(m_vsNames));

    m_it = m_vsNames.begin();
}

ContainerEnumerator::ContainerEnumerator(ContainerEnumerator const &rhs)
{
    *this = rhs;
}


                                                  // Operators
ContainerEnumerator &
ContainerEnumerator::operator=(ContainerEnumerator const &rhs)
{
    if (this != &rhs)
    {
        m_vsNames = rhs.m_vsNames;

        m_it = m_vsNames.begin();
        advance(m_it, distance(rhs.m_vsNames.begin(), rhs.m_it));
    }

    return *this;
}

                                                  // Operations
                                                  // Access
vector<string>::const_iterator &
ContainerEnumerator::Iterator()
{
    return m_it;
}

vector<string> const &
ContainerEnumerator::Names() const
{
    return m_vsNames;
}

                                                  // Predicates
                                                  // Static Variables

///////////////////////////   PROTECTED   /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables


///////////////////////////    PRIVATE    /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\cardfinder.cpp ===
// CardFinder.cpp -- CardFinder class implementation

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#if defined(_UNICODE)
  #if !defined(UNICODE)
    #define UNICODE
  #endif //!UNICODE
#endif //_UNICODE

#if defined(UNICODE)
  #if !defined(_UNICODE)
    #define _UNICODE
  #endif //!_UNICODE
#endif //UNICODE

#include "StdAfx.h"

#include <string>
#include <numeric>

#include <Windows.h>
#include <WinUser.h>

#include <scuOsExc.h>
#include <scuCast.h>

#include "PromptUser.h"
#include "CardFinder.h"
#include "CspProfile.h"
#include "StResource.h"
#include "ExceptionContext.h"
#include "Blob.h"

using namespace std;
using namespace scu;
using namespace cci;
using namespace ProviderProfile;

using CardFinder::DialogDisplayMode;

/////////////////////////// LOCAL/HELPER  /////////////////////////////////

namespace
{
    // Lengths as specified by OPENCARDNAME
    size_t const cMaxCardNameLength = 256;
    size_t const cMaxReaderNameLength = 256;

    // In a preemptive, multi-threaded, environment it's assumed
    // access to these scratch buffers does not need to be mutually
    // exclusive.
    TCHAR CardNamesScratchBuffer[cMaxCardNameLength];
    TCHAR ReaderNamesScratchBuffer[cMaxReaderNameLength];

    DWORD
    AsDialogFlag(DialogDisplayMode ddm)
    {
        DWORD dwDialogFlag;

        switch (ddm)
        {
        case CardFinder::ddmNever:
            dwDialogFlag = SC_DLG_NO_UI;
            break;

        case CardFinder::ddmIfNecessary:
            dwDialogFlag = SC_DLG_MINIMAL_UI;
            break;

        case CardFinder::ddmAlways:
            dwDialogFlag =  SC_DLG_FORCE_UI;
            break;

        default:
            throw scu::OsException(E_INVALIDARG);
        }

        return dwDialogFlag;
    }

    vector<string> &
    CardNameAccumulator(vector<string> &rvs,
                        CardProfile &rcp)
    {
        rvs.push_back(rcp.RegistryName());
        return rvs;
    }

    vector<CString>
    csCardNameAccumulator(vector<CString> &rvs,
                          CardProfile &rcp)
    {
        rvs.push_back(rcp.csRegistryName());
        return rvs;
    }

} // namespace


///////////////////////////    PUBLIC     /////////////////////////////////

                                                  // Types
                                                  // C'tors/D'tors
CardFinder::CardFinder(DialogDisplayMode ddm,
                       HWND hwnd,
                       CString const &rsDialogTitle)
    : m_sDialogTitle(rsDialogTitle),
      m_ddm(ddm),
      m_hwnd(hwnd),
      m_apmszSupportedCards(),
      m_opcnDlgCtrl(),
#if SLBCSP_USE_SCARDUIDLGSELECTCARD
      m_opcnCriteria(),
      m_sInsertPrompt(StringResource(IDS_INS_SLB_CRYPTO_CARD).AsCString()),
#endif
      m_cspec(),
      m_hscardctx()
{

    m_hscardctx.Establish();

    // TO DO: Since the CCI doesn't provide enough information about
    // the cards, the CSP creates its own version for CSP
    // registration.  Rather than use the CCI's KnownCards routine to
    // get the card names, the CSPs version is used until the CCI
    // provides enough information.
    vector<CardProfile> vcp(CspProfile::Instance().Cards());
    m_apmszSupportedCards =
        auto_ptr<MultiStringZ>(new MultiStringZ(accumulate(vcp.begin(),
                                                           vcp.end(),
                                                           vector<CString>(),
                                                           csCardNameAccumulator)));

    // Fill the Open Card Name Dialog, pvUserData which is set by
    // DoFind.
    m_opcnDlgCtrl.dwStructSize            = sizeof(m_opcnDlgCtrl);  // REQUIRED
    m_opcnDlgCtrl.hSCardContext           = m_hscardctx.AsSCARDCONTEXT(); // REQUIRED
    m_opcnDlgCtrl.hwndOwner               = m_hwnd;               // OPTIONAL
    m_opcnDlgCtrl.dwFlags                 = AsDialogFlag(DisplayMode());  // OPTIONAL -- default is SC_DLG_MINIMAL_UI
    m_opcnDlgCtrl.lpstrTitle              = (LPCTSTR)m_sDialogTitle; // OPTIONAL
    m_opcnDlgCtrl.dwShareMode             = SCARD_SHARE_SHARED;   // OPTIONAL - if lpfnConnect is NULL, dwShareMode and
    m_opcnDlgCtrl.dwPreferredProtocols    = SCARD_PROTOCOL_T0;   // OPTIONAL dwPreferredProtocols will be used to
                                                                 //   connect to the selected card
    m_opcnDlgCtrl.lpstrRdr                = ReaderNamesScratchBuffer; // REQUIRED [IN|OUT] Name of selected reader
    m_opcnDlgCtrl.nMaxRdr                 = sizeof ReaderNamesScratchBuffer /
        sizeof *ReaderNamesScratchBuffer;                   // REQUIRED [IN|OUT]
    m_opcnDlgCtrl.lpstrCard               = CardNamesScratchBuffer; // REQUIRED [IN|OUT] Name of selected card
    m_opcnDlgCtrl.nMaxCard                = sizeof CardNamesScratchBuffer /
        sizeof *CardNamesScratchBuffer;                          // REQUIRED [IN|OUT]
    m_opcnDlgCtrl.dwActiveProtocol        = 0;                   // [OUT] set only if dwShareMode not NULL
    m_opcnDlgCtrl.hCardHandle             = NULL;                // [OUT] set if a card connection was indicated

    CheckFn(IsValid);
    ConnectFn(Connect);
    DisconnectFn(Disconnect);

#if !SLBCSP_USE_SCARDUIDLGSELECTCARD

    m_opcnDlgCtrl.lpstrGroupNames         = 0;
    m_opcnDlgCtrl.nMaxGroupNames          = 0;
    m_opcnDlgCtrl.lpstrCardNames          = (LPTSTR)m_apmszSupportedCards->csData();
    m_opcnDlgCtrl.nMaxCardNames           = m_apmszSupportedCards->csLength();
    m_opcnDlgCtrl.rgguidInterfaces        = 0;
    m_opcnDlgCtrl.cguidInterfaces         = 0;

#else
    m_opcnDlgCtrl.lpstrSearchDesc         = (LPCTSTR)m_sInsertPrompt; // OPTIONAL (eg. "Please insert your <brandname> smart card.")
    m_opcnDlgCtrl.hIcon                   = NULL;                 // OPTIONAL 32x32 icon for your brand insignia
    m_opcnDlgCtrl.pOpenCardSearchCriteria = &m_opcnCriteria;      // OPTIONAL

    m_opcnCriteria.dwStructSize           = sizeof(m_opcnCriteria);
    m_opcnCriteria.lpstrGroupNames        = 0;                    // OPTIONAL reader groups to include in
    m_opcnCriteria.nMaxGroupNames         = 0;                    //   search.  NULL defaults to
                                                                  //   SCard$DefaultReaders
    m_opcnCriteria.rgguidInterfaces       = 0;                    // OPTIONAL requested interfaces
    m_opcnCriteria.cguidInterfaces        = 0;                    //   supported by card's SSP
    m_opcnCriteria.lpstrCardNames         = (LPTSTR)m_apmszSupportedCards->csData();         // OPTIONAL requested card names; all cards w/
    m_opcnCriteria.nMaxCardNames          = m_apmszSupportedCards->csLength();                            //    matching ATRs will be accepted
    m_opcnCriteria.dwShareMode            = SCARD_SHARE_SHARED;   // OPTIONAL must be set if lpfnCheck is not null
    m_opcnCriteria.dwPreferredProtocols   = SCARD_PROTOCOL_T0;    // OPTIONAL

#endif // !SLBCSP_USE_SCARDUIDLGSELECTCARD

}

CardFinder::~CardFinder()
{}

                                                  // Operators
                                                  // Operations

Secured<HCardContext>
CardFinder::Find(CSpec const &rcsReader)
{
    DoFind(rcsReader);

    return CardFound();
}

                                                  // Access

DialogDisplayMode
CardFinder::DisplayMode() const
{
    return m_ddm;
}

HWND
CardFinder::Window() const
{
    return m_hwnd;
}

                                                  // Predicates
                                                  // Static Variables

///////////////////////////   PROTECTED   /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations

void
CardFinder::CardFound(Secured<HCardContext> const &rshcardctx)
{
    m_shcardctx = rshcardctx;
}

SCARDHANDLE
CardFinder::DoConnect(string const &rsSelectedReader)
{
    SCARDHANDLE hSCard = reinterpret_cast<SCARDHANDLE>(INVALID_HANDLE_VALUE);

    // If the reader spec's match...
    if (CSpec::Equiv(CardSpec().Reader(), rsSelectedReader))
    {
        HCardContext hcardctx(rsSelectedReader);
        CardFound(Secured<HCardContext>(hcardctx));
    }
    else
    {
        CardFound(Secured<HCardContext>(0));
        hSCard = 0;
    }

    return hSCard;
}

void
CardFinder::DoDisconnect()
{
    CardFound(Secured<HCardContext>(0));
}

void
CardFinder::DoFind(CSpec const &rcspec)
{
    m_cspec = rcspec;

    // Bind to the callers call context
    UserData(reinterpret_cast<void *>(this));

    // Cache to override later
    OpenCardNameType opencardname(m_opcnDlgCtrl);
    bool fContinue = true;

    do
    {
        DWORD dwStatus(SelectCard(opencardname));
        DoProcessSelection(dwStatus, opencardname, fContinue);
    } while (fContinue);

    OnError();
}

void
CardFinder::DoOnError()
{
    scu::Exception const *pexc = Exception();
    if (pexc && (ddmNever != DisplayMode()))
    {
        switch (pexc->Facility())
        {
        case scu::Exception::fcOS:
            {
                OsException const *pOsExc =
                    DownCast<OsException const *>(pexc);
                switch (pOsExc->Cause())
                {
                case SCARD_E_UNSUPPORTED_FEATURE:
                    YNPrompt(IDS_NOT_CAPI_ENABLED);
                    ClearException();
                    break;

                case ERROR_INVALID_PARAMETER:
                    YNPrompt(IDS_READER_NOT_MATCH);
                    ClearException();
                    break;

                default:
                    break;
                }
            }
        break;

        case scu::Exception::fcCCI:
            {
                cci::Exception const *pCciExc =
                    DownCast<cci::Exception const *>(pexc);
                if (ccNotPersonalized == pCciExc->Cause())
                {
                    YNPrompt(IDS_CARD_NOT_INIT);
                    ClearException();
                }
            }
        break;

        default:
            break;
        }
    }
}

void
CardFinder::DoProcessSelection(DWORD dwStatus,
                               OpenCardNameType &ropencardname,
                               bool &rfContinue)
{
    rfContinue = true;
    
    // Handle the error conditions
    if (Exception() &&
        !((SCARD_E_CANCELLED == dwStatus) ||
          (SCARD_W_CANCELLED_BY_USER == dwStatus)))
        rfContinue = false;
    else
    {
        WorkaroundOpenCardDefect(ropencardname, dwStatus);

        if (SCARD_S_SUCCESS != dwStatus)
        {
            // Translate the cancellation error as needed.
            if ((SCARD_E_CANCELLED == dwStatus) ||
                (SCARD_W_CANCELLED_BY_USER == dwStatus))
            {
                if (ddmNever == DisplayMode())
                {
                    if ((SCARD_E_CANCELLED == dwStatus) &&
                        !CardFound())
                        // SCARD_E_NO_SMARTCARD is returned
                        // because the Smart Card Dialog will
                        // return SCARD_E_CANCELLED when the GUI
                        // is not allowed and there is no smart
                        // card in the reader, so the error is
                        // translated here.
                        dwStatus = SCARD_E_NO_SMARTCARD;
                    else
                        // NTE_BAD_KEYSET is returned because some version
                        // of a Microsoft application would go into an
                        // infinite loop when ERROR_CANCELLED was returned
                        // under these conditions.  Doug Barlow at
                        // Microsoft noticed the behaviour and implemented
                        // the workaround.  It's unclear what that
                        // application was and if the workaround remains
                        // necessary.
                        dwStatus = NTE_BAD_KEYSET; // how can this happen?
                }
                else
                    dwStatus = ERROR_CANCELLED;
            }

            Exception(auto_ptr<scu::Exception const>(scu::OsException(dwStatus).Clone()));
            rfContinue = false;
        }
        else
            rfContinue = false;
    }
    
    if (SC_DLG_MINIMAL_UI == ropencardname.dwFlags)
        ropencardname.dwFlags = SC_DLG_FORCE_UI;
}

void
CardFinder::YNPrompt(UINT uID) const
{
    int iResponse = PromptUser(Window(), uID, MB_YESNO | MB_ICONWARNING);
    
    switch (iResponse)
    {
    case IDABORT: // fall-through intentional
    case IDCANCEL: 
    case IDNO:
        throw scu::OsException(ERROR_CANCELLED);
        break;

    case IDOK:
    case IDYES:
    case IDRETRY:
        break;

    case 0:
        throw scu::OsException(GetLastError());
        break;
        
    default:
        throw scu::OsException(ERROR_INTERNAL_ERROR);
        break;
    }
}

                                                  // Access

CSpec const &
CardFinder::CardSpec() const
{
    return m_cspec;
}

Secured<HCardContext>
CardFinder::CardFound() const
{
    return m_shcardctx;
}

                                                  // Predicates

bool
CardFinder::DoIsValid()
{
    Secured<HCardContext> shcardctx(CardFound());
    if (shcardctx &&
        !shcardctx->Card()->IsCAPIEnabled())
        throw scu::OsException(SCARD_E_UNSUPPORTED_FEATURE);

    return (shcardctx != 0);
}

                                                  // Static Variables


///////////////////////////    PRIVATE    /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations

void
CardFinder::CheckFn(LPOCNCHKPROC lpfnCheck)
{

#if !SLBCSP_USE_SCARDUIDLGSELECTCARD
    m_opcnDlgCtrl.lpfnCheck  = lpfnCheck;
#else
    m_opcnCriteria.lpfnCheck = lpfnCheck;
#endif

}

SCARDHANDLE __stdcall
CardFinder::Connect(SCARDCONTEXT scardctx,
                      LPTSTR szReader,
                      LPTSTR mszCards,
                      LPVOID lpvUserData)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CardFinder *pfinder =
        reinterpret_cast<CardFinder *>(lpvUserData);

    SCARDHANDLE hResult = reinterpret_cast<SCARDHANDLE>(INVALID_HANDLE_VALUE);

    EXCCTX_TRY
    {
        // Starting fresh, clear any earler exception
        pfinder->ClearException();
		string sSelectedReader(StringResource::AsciiFromUnicode(szReader));
        hResult =
            pfinder->DoConnect(sSelectedReader);
    }

    EXCCTX_CATCH(pfinder, false);

    return hResult;
}

void
CardFinder::ConnectFn(LPOCNCONNPROC lpfnConnect)
{

    m_opcnDlgCtrl.lpfnConnect  = lpfnConnect;

#if SLBCSP_USE_SCARDUIDLGSELECTCARD
    m_opcnCriteria.lpfnConnect = m_opcnDlgCtrl.lpfnConnect;
#endif
}

void __stdcall
CardFinder::Disconnect(SCARDCONTEXT scardctx,
                         SCARDHANDLE hSCard,
                       LPVOID lpvUserData)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CardFinder *pfinder =
        reinterpret_cast<CardFinder *>(lpvUserData);

    EXCCTX_TRY
    {
        pfinder->DoDisconnect();
    }

    EXCCTX_CATCH(pfinder, false);
}

void
CardFinder::DisconnectFn(LPOCNDSCPROC lpfnDisconnect)
{

#if !SLBCSP_USE_SCARDUIDLGSELECTCARD
    m_opcnDlgCtrl.lpfnDisconnect  = lpfnDisconnect;
#else
    m_opcnCriteria.lpfnDisconnect = lpfnDisconnect;
#endif
}

void
CardFinder::OnError()
{
    if (Exception())
    {
        DoOnError();
        PropagateException();
    }
}

DWORD
CardFinder::SelectCard(OpenCardNameType &ropcn)
{
#if !SLBCSP_USE_SCARDUIDLGSELECTCARD
        return GetOpenCardName(&ropcn);
#else
        return SCardUIDlgSelectCard(&ropcn);
#endif
}

void
CardFinder::UserData(void *pvUserData)
{
    m_opcnDlgCtrl.pvUserData = pvUserData;

#if SLBCSP_USE_SCARDUIDLGSELECTCARD
        m_opcnCriteria.pvUserData = m_opcnDlgCtrl.pvUserData;
#endif
}

void
CardFinder::WorkaroundOpenCardDefect(OpenCardNameType const &ropcnDlgCtrl,
                                     DWORD &rdwStatus)
{
    // On systems using Smart Card Kit v1.0 and prior (in other words
    // systems prior to Windows 2000/NT 5.0), MS' GetOpenCardName
    // (scarddlg.dll) has a defect that manifests when the check
    // routine always returns FALSE.  In this case, the common dialog
    // will call connect routine one additional time without calling
    // check or disconnect routine.  Therefore upon return, it appears
    // a card match was found when there really wasn't.  The
    // workaround is to make additional calls to the check routine
    // after the call to GetOpenCardName.  If there isn't a match,
    // then the card is invalid and should act as if the card was not
    // connected.  Fortunately, this workaround behaves correctly on
    // the good scarddlg.dll as well (post Smart Card Kit v1.0).

    if (SCARD_S_SUCCESS == rdwStatus)
    {
        try
        {
            LPOCNCHKPROC lpfnCheck = CheckFn();
            LPOCNDSCPROC lpfnDisconnect = DisconnectFn();

            if (CardFound() &&
                !lpfnCheck(ropcnDlgCtrl.hSCardContext, 0, this))
                lpfnDisconnect(ropcnDlgCtrl.hSCardContext, 0, this);

            if (!CardFound() &&
                (SC_DLG_MINIMAL_UI == ropcnDlgCtrl.dwFlags))
            {
                // A card didn't matched and the user wasn't actually
                // prompted, so force the smart card dialog to prompt
                // the user to select a card.
                lpfnDisconnect(ropcnDlgCtrl.hSCardContext, 0, this);

                OpenCardNameType opencardname = ropcnDlgCtrl;
                opencardname.dwFlags = SC_DLG_FORCE_UI;

                rdwStatus = SelectCard(opencardname);

                if ((SCARD_S_SUCCESS == rdwStatus) &&
                    !Exception() &&
                    !lpfnCheck(opencardname.hSCardContext, 0, this))
                    lpfnDisconnect(opencardname.hSCardContext, 0, this);
            }
        }

        catch (...)
        {
            // propagate the exception here if one didn't occur in
            // one of the callback routines.
            if (!Exception())
                throw;
        }

        OnError();
    }
}

                                                  // Access

LPOCNCHKPROC
CardFinder::CheckFn() const
{
#if !SLBCSP_USE_SCARDUIDLGSELECTCARD
    return m_opcnDlgCtrl.lpfnCheck;
#else
    return m_opcnCriteria.lpfnCheck;
#endif
}

LPOCNDSCPROC
CardFinder::DisconnectFn() const
{
#if !SLBCSP_USE_SCARDUIDLGSELECTCARD
    return m_opcnDlgCtrl.lpfnDisconnect;
#else
    return m_opcnCriteria.lpfnDisconnect;
#endif
}

                                                  // Predicates

BOOL __stdcall
CardFinder::IsValid(SCARDCONTEXT scardctx,
                      SCARDHANDLE hSCard,
                    LPVOID lpvUserData)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CardFinder *pfinder =
        reinterpret_cast<CardFinder *>(lpvUserData);

    bool fResult = false;

    EXCCTX_TRY
    {
        fResult = pfinder->DoIsValid();
    }

    // Throwing the callback exception is optional because the
    // Microsoft Smart Card Dialog sensitive to throwing from the
    // IsValid callback, particularly when multiple readers are
    // connected.
    EXCCTX_CATCH(pfinder, false);

    return fResult
        ? TRUE
        : FALSE;
}


                                                  // Static Variables
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\container.cpp ===
// AdptvCntr.cpp -- ADaPTiVe CoNTaineR class implementation

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
#include "stdafx.h"
#include "NoWarning.h"
#include "ForceLib.h"

#include <vector>
#include <algorithm>
#include <functional>

#include <scuOsExc.h>

#include <cciPriKey.h>

#include "RsaKey.h"
#include "CSpec.h"
#include "Container.h"
#include "Secured.h"
#include "CntrFinder.h"
#include <scarderr.h>

using namespace std;
using namespace cci;

/////////////////////////// LOCAL/HELPER  /////////////////////////////////

///////////////////////////    PUBLIC     /////////////////////////////////

                                                  // Types
                                                  // C'tors/D'tors
HContainer::HContainer(Container *pcntr)
    : slbRefCnt::RCPtr<Container>(pcntr)
{}

                                                  // Types
                                                  // C'tors/D'tors
Container::~Container()
{}

HContainer
Container::MakeContainer(CSpec const & rcspec,
                         cci::CContainer const &rccntr)
{
    Container *pcntr = new Container(rcspec, rccntr);
    
    return HContainer(pcntr);
}

                                                  // Operators
                                                  // Operations
void
Container::ClearCache()
{
    m_hcntr = 0;
}

                                                  // Access
cci::CContainer
Container::TheCContainer() const
{
    if (!m_hcntr)
    {
        throw scu::OsException(NTE_BAD_KEYSET);
    }
    return m_hcntr;
}


HContainer
Container::Find(CSpec const &rKey)
{
    //Work in a silent mode...
    CString sEmptyTitle;
    
    ContainerFinder CntrFinder(CardFinder::DialogDisplayMode::ddmNever,
                               0,//a window handle
                               sEmptyTitle);
    return CntrFinder.Find(rKey);
}

CSpec const &
Container::TheCSpec() const
{
    return m_cspec;
}


                                                  // Predicates
                                                  // Static Variables

///////////////////////////   PROTECTED   /////////////////////////////////

                                                  // C'tors/D'tors
Container::Container()
    : RCObject(),
      CachingObject(),
      m_hcntr(),
      m_cspec()
{}
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates

                                                  // Static Variables


///////////////////////////    PRIVATE    /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
Container::Container(CSpec const &rKey)
    : RCObject(),
      CachingObject(),
      m_hcntr(),
      m_cspec(rKey)
{}

Container::Container(CSpec const &rKey,
                     cci::CContainer const &rccard)
    : RCObject(),
      CachingObject(),
      m_hcntr(rccard),
      m_cspec(rKey)
{}

                                                  // Access
                                                  // Predicates
                                                  // Static Variables
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\cryptctx.h ===
// CryptCtx.h -- Cryptographic Context class header

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#if !defined(SLBCSP_CRYPTCTX_H)
#define SLBCSP_CRYPTCTX_H

#include <memory>                                 // for auto_ptr

#include <windef.h>
#include <wincrypt.h>                             // required by cspdk.h
#include <cspdk.h>                                // for CRYPT_RETURN_HWND &
                                                  // PVTableProvStruc

#include <handles.h>

#include <scuArrayP.h>

#include "Lockable.h"
#include "HAdptvCntr.h"
#include "CntrEnum.h"
#include "AuxContext.h"
#include "LoginId.h"
#include "Blob.h"
#include "AlignedBlob.h"

class CSpec;
class CHashContext;
class CKeyContext;
class CPublicKeyContext;
class CSessionKeyContext;

// Maintains the context acquired and used to access a CAPI container.
class CryptContext
    : public CHandle,
      public Lockable
{
public:
                                                  // Types
                                                  // C'tors/D'tors
    CryptContext(CSpec const &CntrSpec,
                 PVTableProvStruc const pVTable,
                 bool fGuiEnabled,
                 bool fCreateContainer = false,
                 bool fEphemeralContainer = false);
    ~CryptContext();

                                                  // Operators
                                                  // Operations

    HCRYPTHASH
    Add(std::auto_ptr<CHashContext> &rapHashCtx);

    HCRYPTKEY
    Add(std::auto_ptr<CKeyContext> &rapKeyCtx);

    HCRYPTKEY
    Add(std::auto_ptr<CPublicKeyContext> &rapPublicKeyCtx);

    HCRYPTKEY
    Add(std::auto_ptr<CSessionKeyContext> &rapSessionKeyCtx);

    std::auto_ptr<CHashContext>
    CloseHash(HCRYPTHASH const hHash);

    std::auto_ptr<CKeyContext>
    CloseKey(HCRYPTKEY const hKey);

    void
    CntrEnumerator(ContainerEnumerator const &rce);

    void
    EnumAlgorithms(DWORD dwPara,
                   DWORD dwFlags,
                   bool fPostAdvanceIterator,
                   AlignedBlob &rabAlgInfo);
    
    HCRYPTKEY
    GenerateKey(ALG_ID algid,
                DWORD dwFlags);

    std::auto_ptr<CPublicKeyContext>
    ImportPrivateKey(scu::SecureArray<BYTE> const &rblbMsPrivateKey,
                     DWORD dwKeySpec,
                     bool fExportable,
                     HCRYPTKEY hEncKey);
    
    std::auto_ptr<CPublicKeyContext>
    ImportPublicKey(scu::SecureArray<BYTE> const &rblbMsPublicKey,
                    DWORD dwKeySpec);

    void
    Login(LoginIdentity const &rlid);

    void
    Pin(LoginIdentity const &rlid,
        char const *pszPin);

    void
    RemoveContainer();

    std::auto_ptr<CSessionKeyContext>
    UseSessionKey(BYTE const *pbKeyBlob,
                  DWORD cbKeyBlobLen,
                  HCRYPTKEY hAuxImpKey,
                  DWORD dwFlags);
                                                  // Access
    HAdaptiveContainer
    AdaptiveContainer() const;

    HCRYPTPROV
    AuxContext() const;

    ContainerEnumerator
    CntrEnumerator(bool fReset);

    CHashContext *
    LookupHash(HCRYPTHASH hHash);

    CKeyContext *
    LookupKey(HCRYPTKEY hKey);

    CPublicKeyContext *
    LookupPublicKey(HCRYPTKEY hKey);

    CSessionKeyContext *
    LookupSessionKey(HCRYPTKEY hKey);

    HWND
    Window() const;

                                                  // Predicates
    bool
    GuiEnabled() const;

    bool
    IsEphemeral() const;


protected:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables

private:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
    void
    CreateNewContainer(CSpec const &rcspec);

    void
    DeleteContainer(Secured<HCardContext> &rhscardctx,
                    cci::CContainer &rhcntr);

    void
    Login(LoginIdentity const &rlid,
          Secured<HCardContext> &rhscardctx);

    void
    OkDeletingCredentials() const;

                                                  // Access

    HCardContext
    CardContext() const;

    CKeyContext *
    LookupChecked(HCRYPTKEY hKey,
                  DWORD const dwKeyType);

    void
    OpenExistingContainer(CSpec const &rcspec);

                                                  // Predicates
                                                  // Variables

    // Id of thread that created this context, making it the owner
    DWORD const m_dwOwnerThreadId;

    HAdaptiveContainer m_hacntr;

    // If CRYPT_VERIFYCONTEXT was used when creating this context.
    bool const m_fEphemeralContainer;

    // If the client specified the GUI was enabled/disabled using CRYPT_SILENT
    bool const m_fGuiEnabled;

    // Window to use when interacting with the user
    HWND m_hwnd;

    // Hashes and keys (both session and those on the card) created/acquired
    // in this context.
    CHandleList m_hlHashes;
    CHandleList m_hlKeys;

    ::AuxContext const m_auxcontext;

    ContainerEnumerator m_ce;                     // used by CPGetProvParam
    std::auto_ptr<AlignedBlob> m_apabCachedAlg;
};

#endif // SLBCSP_CRYPTCTX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\cspec.cpp ===
// CSpec.cpp -- Card Specification

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1998. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#include <scuOsExc.h>

#include "cspec.h"

using namespace std;

bool
CSpec::ValidName(string const &rsName) const
{
    return (rsName.find(BreakToken()) == string::npos);
}

// Parse specification (possibly a Fully Qualified Card [container]
// Name) into the respective tokens.  A FQCN takes the form
// "[\\.\<readerName>[\{<cardId>|}]]|[{\}<cardId>]". The preceding
// backslash-backslash-period-backslash is used in Win32 to identify a
// specific device name.  It is used to identify that everything from
// there to the next backslash or end-of-string indicates the exact
// reader in which the card in question is to be found.  Anything
// following that last backslash occurrence indicates the actual card
// Id and container name, with an empty string implying the default
// for the card in the specified reader.
CSpec::CSpec(string const &rsSpec)
{
    string sRHSpec;

    if (0 == rsSpec.find(DeviceIdToken()))
    {
        sRHSpec = rsSpec.substr(DeviceIdToken().length());

        // Find the reader
        string::size_type const stEndOfName(sRHSpec.find(BreakToken()));
        if (0 == stEndOfName)
            throw scu::OsException(NTE_BAD_KEYSET_PARAM);
        if (string::npos != stEndOfName)
        {
            string const sReader(sRHSpec.substr(0, stEndOfName));
            if (ValidName(sReader))
                m_sReader = sReader;
            else
                throw scu::OsException(NTE_BAD_KEYSET_PARAM);
            sRHSpec = sRHSpec.substr(stEndOfName + 1);
        }
        else
        {
            m_sReader = sRHSpec;
            sRHSpec.erase();
        }
    }
    else
        sRHSpec = rsSpec;

    // Check for well-formed card id
    if (ValidName(sRHSpec))
        m_sCardId = sRHSpec;
    else
        throw scu::OsException(NTE_BAD_KEYSET_PARAM);

    RefreshSpec();
}

CSpec::CSpec(string const &rsReader,
             string const &rsCardId)
{
    if (!ValidName(rsReader) || !ValidName(rsCardId))
        throw scu::OsException(NTE_BAD_KEYSET_PARAM);

    m_sReader = rsReader;
    m_sCardId = rsCardId;
    RefreshSpec();
}

CSpec::CSpec(CSpec const &rhs)
    : m_sReader(rhs.m_sReader),
      m_sCardId(rhs.m_sCardId),
      m_sSpec(rhs.m_sSpec)
{
}

void
CSpec::Empty(void)
{
    m_sReader.erase();
    m_sCardId.erase();
    m_sSpec.erase();
}

void
CSpec::EmptyCardId(void)
{
    m_sCardId.erase();
    RefreshSpec();
}

void
CSpec::EmptyReader(void)
{
    m_sReader.erase();
    RefreshSpec();
}

bool
CSpec::Equiv(string const &rsSpec,
             string const &rsName)
{
    return rsSpec.empty() || (rsSpec == rsName);
}

bool
CSpec::Equiv(CSpec const &rhs) const
{
    return Equiv(m_sReader, rhs.m_sReader) &&
        Equiv(m_sCardId, rhs.m_sCardId);
}

void
CSpec::RefreshSpec(void)
{
    if (m_sReader.empty())
        m_sSpec = m_sCardId;
    else
    {
        m_sSpec = DeviceIdToken();
        m_sSpec += m_sReader;
        m_sSpec += BreakToken();
        m_sSpec += m_sCardId;
    }
}

void
CSpec::SetCardId(string const &rsCardId)
{
    m_sCardId = rsCardId;
    RefreshSpec();
}

void
CSpec::SetReader(string const &rsReader)
{
    m_sReader = rsReader;
    RefreshSpec();
}

CSpec &
CSpec::operator=(CSpec const &rhs)
{
    if (this == &rhs)
        return *this;

    m_sReader = rhs.m_sReader;
    m_sCardId = rhs.m_sCardId;
    RefreshSpec();

    return *this;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\cntrfinder.cpp ===
// CntrFinder.cpp -- ContainerFinder class implementation

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#include "stdafx.h"

#include <string>

#include <scuOsExc.h>
#include <scuCast.h>

#include "CntrFinder.h"

using namespace std;
using namespace scu;
using namespace cci;

/////////////////////////// LOCAL/HELPER  /////////////////////////////////
namespace
{
    // Predicate helper functor (function object) returning true iff
    // the container object's name matches the pattern.
    class ContainerMatcher
        : public unary_function<string, bool>
    {
    public:
        explicit
        ContainerMatcher(string const &rsPattern)
            : m_sPattern(rsPattern)
        {}

        bool
        operator()(CContainer &rcntr) const
        {
            return CSpec::Equiv(m_sPattern, rcntr->Name());
        }


    private:
        string const m_sPattern;
    };

    CContainer
    FindOnCard(HCardContext &rhcardctx,
               string const &rsContainer)
    {
        Secured<HCardContext> shcardctx(rhcardctx);

        vector<CContainer> vcContainers(shcardctx->Card()->EnumContainers());

        vector<CContainer>::const_iterator
            ci(find_if(vcContainers.begin(),
                       vcContainers.end(),
                       ContainerMatcher(rsContainer)));

        CContainer hcntr;
        if (vcContainers.end() != ci)
            hcntr = *ci;

        return hcntr;
    }

} // namespace


/////////////////////////// PUBLIC HELPER /////////////////////////////////

///////////////////////////    PUBLIC     /////////////////////////////////

                                                  // Types
                                                  // C'tors/D'tors

ContainerFinder::ContainerFinder(DialogDisplayMode ddm,
                                 HWND hwnd,
                                 CString const &rsDialogTitle)
    : CardFinder(ddm, hwnd, rsDialogTitle),
      m_hcntr()
{}

ContainerFinder::~ContainerFinder()
{}


                                                  // Operators
                                                  // Operations

HContainer
ContainerFinder::Find(CSpec const &rcsContainer)
{
    DoFind(rcsContainer);

    return ContainerFound();
}

HAdaptiveContainerKey
ContainerFinder::MakeAdaptiveContainerKey()
{
    return HAdaptiveContainerKey(new 
                                 AdaptiveContainerKey(CardFound(),
                                                      CardSpec().CardId()));
}

                                                  // Access
                                                  // Predicates
                                                  // Static Variables

///////////////////////////   PROTECTED   /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations

void
ContainerFinder::ContainerFound(HContainer hcntr)
{
    m_hcntr = hcntr;
}

void
ContainerFinder::DoDisconnect()
{
    ContainerFound(0);

    CardFinder::DoDisconnect();
}


                                                  // Access

HContainer
ContainerFinder::ContainerFound() const
{
    return m_hcntr;
}

                                                  // Predicates

bool
ContainerFinder::DoIsValid()
{
    ContainerFound(HContainer(0));
    if (CardFinder::DoIsValid())
    {
        AdaptiveContainerKey Key(CardFound(),
                                 CardSpec().CardId());
        CContainer hccntr(FindOnCard(Key.CardContext(),
                                    Key.ContainerName()));
        if(hccntr)
        {
            HContainer hcntr = Container::MakeContainer(CardSpec(),
                                                        hccntr);
            ContainerFound(hcntr);
        }
    }

    if (!ContainerFound())
        throw scu::OsException(NTE_BAD_KEYSET);

    return true;
}

void
ContainerFinder::DoOnError()
{
    CardFinder::DoOnError();

    scu::Exception const *pexc = Exception();
    if (pexc && (DialogDisplayMode::ddmNever != DisplayMode()))
    {
        switch (pexc->Facility())
        {
        case scu::Exception::fcOS:
            {
                scu::OsException const *pOsExc =
                    DownCast<scu::OsException const *>(pexc);
                if (NTE_BAD_KEYSET == pOsExc->Cause())
                {
                    YNPrompt(IDS_CONTAINER_NOT_FOUND);
                    ClearException();
                }
            }
        break;

        default:
            break;
        }
    }
}




                                                  // Static Variables


///////////////////////////    PRIVATE    /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\cntrfinder.h ===
// CntrFinder.h -- Container Finder class header

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#if !defined(SLBCSP_CNTRFINDER_H)
#define SLBCSP_CNTRFINDER_H

#include "cciCont.h"

#include "CardFinder.h"
#include "HAdptvCntr.h"
#include "Secured.h"

class ContainerFinder
    : public CardFinder
{
public:
                                                  // Types
                                                  // C'tors/D'tors
    ContainerFinder(DialogDisplayMode ddm,
                    HWND hwnd = 0,
                    CString const &rsDialogTitle = StringResource(IDS_SEL_SLB_CRYPTO_CARD).AsCString());

    virtual ~ContainerFinder();

                                                  // Operators
                                                  // Operations
    HContainer
    Find(CSpec const &rcsContainer);

    HAdaptiveContainerKey
    MakeAdaptiveContainerKey();
                                                  // Access
                                                  // Predicates

protected:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations

    void
    ContainerFound(HContainer hcntr);

    void
    DoDisconnect();

    virtual void
    DoOnError();

                                                  // Access

    HContainer
    ContainerFound() const;

                                                  // Predicates

    bool
    DoIsValid();

                                                  // Variables

private:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables

    HContainer m_hcntr;
};

#endif // SLBCSP_CNTRFINDER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\container.h ===
// Container.h -- Container class declaration

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#if !defined(SLBCSP_CONTAINER_H)
#define SLBCSP_CONTAINER_H

#include <string>
#include <stack>

#include <cciCont.h>

#include "slbRCPtr.h"
#include "CachingObj.h"
#include "cspec.h"

// Forward declaration necessary to satisfy HContainer's declaration

class Container;

class HContainer
    : public slbRefCnt::RCPtr<Container>
{
public:
                                                  // Types
                                                  // C'tors/D'tors
    HContainer(Container *pacntr = 0);

                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates

protected:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables

private:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables
};



// Container is a reference counted wrapper to a CCI
//
// One unique CCI container is maintained for all threads since
// the CCI does not reflect changes made to one CContainer in all
// CContainer objects that refer to the same container.
//
// The container cannot be created unless the container
// it represents is exists on the card. 

class Container
    : public slbRefCnt::RCObject,
      public CachingObject
{
public:
                                                  // Types
                                                  // Friends
                                                  // C'tors/D'tors
    
    static HContainer
    MakeContainer(CSpec const & rcspec,
                  cci::CContainer const &rccntr);    
    ~Container();
                                                  // Operators
                                                  // Operations
    void
    ClearCache();

                                                  // Access
    virtual cci::CContainer
    TheCContainer() const;

    static HContainer
    Find(CSpec const &rKey);               

    CSpec const &
    TheCSpec() const;

                                                  // Predicates

protected:
                                                  // Types
                                                  // C'tors/D'tors
    Container();  //Default c'tor    


                                                  // Operators
                                                  // Operations

                                                  // Variables
    cci::CContainer mutable m_hcntr;              // cached container

private:
                                                  // Types
                                                  // C'tors/D'tors
    explicit
    Container(CSpec const &rKey);

    explicit
    Container(CSpec const &rKey,
              cci::CContainer const &rccard);

                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables

    // The card could be derived from the CCI container object but
    // since the CCI allows card objects to be reused, the card may
    // not be the container originally found.  The CardContext class
    // tries to mitigate that problem by storing an HCardContext in a
    // container's context object.

    CSpec m_cspec;
};

#endif // SLBCSP_CONTAINER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\cryptctx.cpp ===
// CryptCtx.cpp -- Cryptographic Context class implementation

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#include "stdafx.h"

#include <algorithm>

#include <scuOsExc.h>
#include <scuArrayP.h>

#include <cciPubKey.h>
#include <cciPriKey.h>
#include <cciKeyPair.h>

#include "LoginId.h"
#include "ACntrFinder.h"
#include "Secured.h"
#include "ILoginTask.h"
#include "NILoginTsk.h"
#include "SesKeyCtx.h"
#include "PubKeyCtx.h"
#include "HashCtx.h"
#include "CryptCtx.h"
#include "Uuid.h"
#include "PromptUser.h"
#include "AlignedBlob.h"

#include "scarderr.h"                             // must be last for now

using namespace std;
using namespace scu;
using namespace cci;


///////////////////////////  LOCAL/HELPER   /////////////////////////////////

namespace
{
    WORD const dwHandleIdKeyContext  = 13;
    WORD const dwHandleIdHashContext = 7;

    template<class T>
    HANDLE_TYPE
    AddHandle(auto_ptr<T> &rapObject,
        CHandleList &rhl)
    {
        HANDLE_TYPE handle = rhl.Add(rapObject.get());
        rapObject.release();

        return handle;
    }

    CardFinder::DialogDisplayMode
    DefaultDialogMode(bool fGuiEnabled)
    {
        using CardFinder::DialogDisplayMode;

        return fGuiEnabled
            ? CardFinder::DialogDisplayMode::ddmIfNecessary
            : CardFinder::DialogDisplayMode::ddmNever;
    }

    bool
    IsEmpty(CContainer &rcntr)
    {
        return !rcntr->KeyPairExists(ksExchange) &&
            !rcntr->KeyPairExists(ksSignature);
    }

    bool
    IsProtected(CKeyPair const &rhkp)
    {
        bool fIsProtected = false;

        CCard hcard(rhkp->Card());
        if (hcard->IsProtectedMode())
            fIsProtected = true;
        else
        {
            if (hcard->IsPKCS11Enabled())
            {
                CPrivateKey hprikey(rhkp->PrivateKey());
                if (hprikey && hprikey->Private())
                    fIsProtected = true;
                else
                {
                    CPublicKey hpubkey(rhkp->PublicKey());
                    if (hpubkey && hpubkey->Private())
                        fIsProtected = true;
                    else
                    {
                        CCertificate hcert(rhkp->Certificate());
                        fIsProtected = (hcert && hcert->Private());
                    }
                }
            }
        }

        return fIsProtected;
    }

    bool
    IsProtected(CContainer &rhcntr)
    {
        return IsProtected(rhcntr->GetKeyPair(ksExchange)) ||
            IsProtected(rhcntr->GetKeyPair(ksSignature));
    }

} // namespace

///////////////////////////    PUBLIC     /////////////////////////////////

                                                  // Types
                                                  // C'tors/D'tors
CryptContext::CryptContext(CSpec const &rcspec,
                           PVTableProvStruc const pVTable,
                           bool fGuiEnabled,
                           bool fCreateContainer,
                           bool fEphemeralContainer)
    : CHandle(),
      m_dwOwnerThreadId(GetCurrentThreadId()),
      m_hacntr(),
      m_fEphemeralContainer(fEphemeralContainer),
      m_fGuiEnabled(fGuiEnabled),
      m_hwnd(0),
      m_hlKeys(dwHandleIdKeyContext),
      m_hlHashes(dwHandleIdHashContext),
      m_auxcontext(),
      m_ce(),
      m_apabCachedAlg()
{
    if (pVTable && pVTable->FuncReturnhWnd)
        (reinterpret_cast<CRYPT_RETURN_HWND>(pVTable->FuncReturnhWnd))(&m_hwnd);
    // An ephemeral container cannot be "created"
    if (m_fEphemeralContainer && fCreateContainer)
        throw scu::OsException(ERROR_INVALID_PARAMETER);

        if (fCreateContainer)
            CreateNewContainer(rcspec);
        else
            OpenExistingContainer(rcspec);
    }

CryptContext::~CryptContext()
{
    if (m_hacntr)
    {
        try
        {
            m_hacntr = 0;
        }
        catch (...)
        {
            // don't allow exceptions to propagate out of destructor
        }

    }
}

                                                  // Operators
                                                  // Operations

HCRYPTHASH
CryptContext::Add(auto_ptr<CHashContext> &rapHashCtx)
{
    return AddHandle(rapHashCtx, m_hlHashes);
}

HCRYPTKEY
CryptContext::Add(auto_ptr<CKeyContext> &rapKeyCtx)
{
    return AddHandle(rapKeyCtx, m_hlKeys);
}

HCRYPTKEY
CryptContext::Add(auto_ptr<CPublicKeyContext> &rapPublicKeyCtx)
{
    return AddHandle(rapPublicKeyCtx, m_hlKeys);

}

HCRYPTKEY
CryptContext::Add(auto_ptr<CSessionKeyContext> &rapSessionKeyCtx)
{
    return AddHandle(rapSessionKeyCtx, m_hlKeys);
}

auto_ptr<CHashContext>
CryptContext::CloseHash(HCRYPTHASH const hHash)
{
    return auto_ptr<CHashContext>(reinterpret_cast<CHashContext *>(m_hlHashes.Close(hHash)));
}

auto_ptr<CKeyContext>
CryptContext::CloseKey(HCRYPTKEY const hKey)
{
   return auto_ptr<CKeyContext>(reinterpret_cast<CKeyContext *>(m_hlKeys.Close(hKey)));
}

void
CryptContext::CntrEnumerator(ContainerEnumerator const &rce)
{
    m_ce = rce;
}

void
CryptContext::EnumAlgorithms(DWORD dwParam,
                             DWORD dwFlags,
                             bool fPostAdvanceIterator,
                             AlignedBlob &rabAlgInfo)
{
    bool fFirst = dwFlags & CRYPT_FIRST;

    if (fFirst)
        m_apabCachedAlg = auto_ptr<AlignedBlob>(0);

    if (!m_apabCachedAlg.get())
    {
        DWORD dwDataLen;
        bool bSkip;
        do
        {
            if (CryptGetProvParam(m_auxcontext(),
                                  dwParam,
                                  NULL,
                                  &dwDataLen,
                                  dwFlags) == CRYPT_FAILED)
                throw scu::OsException(GetLastError());

            AutoArrayPtr<BYTE> apbAlgInfo (new BYTE[dwDataLen]);
            
            if (CryptGetProvParam(m_auxcontext(),
                                  dwParam,
                                  apbAlgInfo.Get(),
                                  &dwDataLen,
                                  dwFlags) == CRYPT_FAILED)
                throw scu::OsException(GetLastError());
                
            m_apabCachedAlg =
                auto_ptr<AlignedBlob>(new AlignedBlob(apbAlgInfo.Get(), dwDataLen));

            // Override SIGN and KEYX and algorithms not suported
            ALG_ID algid = (PP_ENUMALGS == dwParam)
                ? reinterpret_cast<PROV_ENUMALGS *>(m_apabCachedAlg->Data())->aiAlgid
                : reinterpret_cast<PROV_ENUMALGS_EX *>(m_apabCachedAlg->Data())->aiAlgid;

            switch (GET_ALG_CLASS(algid))
            {
            case ALG_CLASS_SIGNATURE: // fall-through intentional
            case ALG_CLASS_KEY_EXCHANGE:
                if (PP_ENUMALGS == dwParam)
                {
                    PROV_ENUMALGS *pAlgEnum =
                        reinterpret_cast<PROV_ENUMALGS *>(m_apabCachedAlg->Data());
                    pAlgEnum->dwBitLen = 1024;
                }
                else
                {
                    PROV_ENUMALGS_EX *pAlgEnum =
                        reinterpret_cast<PROV_ENUMALGS_EX *>(m_apabCachedAlg->Data());
                    
                    pAlgEnum->dwDefaultLen =
                        pAlgEnum->dwMinLen =
                        pAlgEnum->dwMaxLen = 1024;
                }
                bSkip = false;
                break;

            case ALG_CLASS_HASH:
                bSkip = (!CHashContext::IsSupported(algid));
                break;

            case ALG_CLASS_DATA_ENCRYPT:
                bSkip = false;
                break;
                    
            default:
                m_apabCachedAlg = auto_ptr<AlignedBlob>(0);
                bSkip = true;
                break;
            }

            dwFlags = dwFlags & ~CRYPT_FIRST;

        } while (bSkip);
    }

    rabAlgInfo = m_apabCachedAlg.get()
        ? *m_apabCachedAlg
        : AlignedBlob();

    if (fPostAdvanceIterator)
        m_apabCachedAlg = auto_ptr<AlignedBlob>(0);
}
    
    
auto_ptr<CPublicKeyContext>
CryptContext::ImportPrivateKey(SecureArray<BYTE> const &rblbMsPrivateKey,
                               DWORD dwKeySpec,
                               bool fExportable,
                               HCRYPTKEY hEncKey)
{
    Secured<HAdaptiveContainer> hsacntr(m_hacntr);

    auto_ptr<CPublicKeyContext>
        apKeyCtx(ImportPublicKey(rblbMsPrivateKey, dwKeySpec));
    SecureArray<BYTE> apb(0);
    
    BYTE const *pbKeyData = 0;
    DWORD dwKeyDataLen    = 0;
    if (hEncKey || m_fEphemeralContainer)
    {
        // Export the key in plain text by importing to the aux provider
        // and then exporting.
        HCRYPTKEY hAuxKey;

        if (!CryptImportKey(m_auxcontext(),
                            rblbMsPrivateKey.data(),
                            rblbMsPrivateKey.length(), hEncKey,
                            CRYPT_EXPORTABLE, &hAuxKey))
            throw scu::OsException(GetLastError());

        if (!m_fEphemeralContainer)
        {
            // Export the key in plain text
            if (!CryptExportKey(m_auxcontext(), NULL, PRIVATEKEYBLOB, 0, NULL,
                                &dwKeyDataLen))
                throw scu::OsException(GetLastError());

            apb = SecureArray<BYTE>(dwKeyDataLen);
            if (!CryptExportKey(m_auxcontext(), NULL, PRIVATEKEYBLOB, 0, apb.data(),
                                &dwKeyDataLen))
                throw scu::OsException(GetLastError());
            pbKeyData = apb.data();

            // Scrub the key imported into the aux provider.  To do this,
            // the auxillary key must be destroyed and another key be put
            // (generated) in its place. 
            if (!CryptDestroyKey(hAuxKey))
                throw scu::OsException(GetLastError());

            hAuxKey = NULL;
            if (!CryptGenKey(m_auxcontext(), dwKeySpec, 0, &hAuxKey))
                throw scu::OsException(GetLastError());

            if (!CryptDestroyKey(hAuxKey))
                throw scu::OsException(GetLastError());
        }
    }
    else
    {
        pbKeyData    = rblbMsPrivateKey.data();
        dwKeyDataLen = rblbMsPrivateKey.length();
    }
    
    if (!m_fEphemeralContainer)
    {
        // Now continue importing the key that's now in plain text.
        MsRsaPrivateKeyBlob msprikb(pbKeyData, dwKeyDataLen);

        apKeyCtx->ImportPrivateKey(msprikb, fExportable);
    }

    return apKeyCtx;
}

auto_ptr<CPublicKeyContext>
CryptContext::ImportPublicKey(SecureArray<BYTE> const &rblbMsPublicKey,
                              DWORD dwKeySpec)
{
    Secured<HAdaptiveContainer> hsacntr(m_hacntr);

    auto_ptr<CPublicKeyContext>
        apKeyCtx(new CPublicKeyContext(m_auxcontext(), *this,
                                       dwKeySpec, false));

    if (m_fEphemeralContainer)
        apKeyCtx->AuxPublicKey(rblbMsPublicKey);
    else
    {
        MsRsaPublicKeyBlob mspubkb(rblbMsPublicKey.data(),
                                   rblbMsPublicKey.length());
        apKeyCtx->ImportPublicKey(mspubkb);
    }

    return apKeyCtx;
}

void
CryptContext::Login(LoginIdentity const &rlid)
{
    Secured<HCardContext> hscardctx(AdaptiveContainer()->CardContext());

    Login(rlid, hscardctx);
}

void
CryptContext::Pin(LoginIdentity const &rlid,
                  char const *pszPin)
{
    Secured<HCardContext> hscardctx(AdaptiveContainer()->CardContext());

    // TO DO: Support Entrust
    if (pszPin)
        hscardctx->Login(rlid, NonInteractiveLoginTask(pszPin));
    else
        hscardctx->ClearLogin(rlid);
}

// Remove (destroy) the container from the card
void
CryptContext::RemoveContainer()
{
    Secured<HCardContext> hscardctx(AdaptiveContainer()->CardContext());

    CContainer hcntr(m_hacntr->TheCContainer());

    DeleteContainer(hscardctx, hcntr);

    m_hacntr = 0;                                // disconnect from container
}

// Generate a key, string it in the context
HCRYPTKEY
CryptContext::GenerateKey(ALG_ID algid,
                          DWORD dwFlags)
{
    // TO DO: Revisit this method, implement as a manager/factory?

    HCRYPTKEY hKey = 0;
    auto_ptr<CKeyContext> apKey;

    bool bError = false;
    DWORD dwErrorCode = NO_ERROR;

    //
    // Verify the parameters.
    //
    switch(algid)
    {
    case AT_KEYEXCHANGE:
    case AT_SIGNATURE:
        {
            if (dwFlags & (CRYPT_CREATE_SALT | CRYPT_NO_SALT | CRYPT_PREGEN))
                throw scu::OsException(NTE_BAD_FLAGS);

            Secured<HAdaptiveContainer> hsacntr(m_hacntr);

            apKey =
                auto_ptr<CKeyContext>(new CPublicKeyContext(m_auxcontext(),
                                                            *this,
                                                            algid,
                                                            false));
            apKey->Generate(algid, dwFlags);
        }
    break;

    default:
        apKey =
            auto_ptr<CKeyContext>(new CSessionKeyContext(m_auxcontext()));
        apKey->Generate(algid, dwFlags);
        break;
    }

    hKey = Add(apKey);

    return hKey;
}

// Load an external Session Key.
auto_ptr<CSessionKeyContext>
CryptContext::UseSessionKey(BYTE const *pbKeyBlob,
                            DWORD cbKeyBlobLen,
                            HCRYPTKEY hAuxImpKey,
                            DWORD dwFlags)
{
    // TO DO: Revisit this method, really necessary??

    auto_ptr<CSessionKeyContext>
        apKeyCtx(new CSessionKeyContext(m_auxcontext()));

    if (!apKeyCtx.get())
        throw scu::OsException(NTE_NO_MEMORY);

    // Decrypt key blob if encrypted with Key Exchange Key
    // otherwise forward blob to Auxiliary CSP directly
    ALG_ID const *pAlgId =
        reinterpret_cast<ALG_ID const *>(&pbKeyBlob[sizeof(BLOBHEADER)]);

    if (CALG_RSA_KEYX == *pAlgId)
    {
        // Get Key exchange key
        // TO DO: Shouldn't this be getting a private key?
        auto_ptr<CPublicKeyContext>
            apXKey(new CPublicKeyContext(m_auxcontext(), *this,
                                         AT_KEYEXCHANGE));

        // Decrypt key blob
        // TO DO: Support multiple key sizes
        Blob EncryptedKey(pbKeyBlob + sizeof BLOBHEADER + sizeof ALG_ID,
                          128);
        Blob DecryptedKey(apXKey->Decrypt(EncryptedKey));

        // Recreate the blob
        Blob DecryptedBlob(pbKeyBlob, sizeof BLOBHEADER + sizeof ALG_ID);

        // we must trim out 64 bytes of the random data from the simple
        // blob and then terminate it. (Termination occurs by making the
        // n-1 byte = 0x02 and the nth byte = 0x00.) This is necessary
        // in order to import this blob into the CSP.
        DecryptedBlob.append(DecryptedKey.data(),
                             (DecryptedKey.length() / 2) - 2);
        BYTE bTerminationBytes[] = { 0x02, 0x00 };
        DecryptedBlob.append(bTerminationBytes, sizeof bTerminationBytes);

        // Load Decrypted blob into key context
        apKeyCtx->LoadKey(DecryptedBlob.data(),
                          DecryptedBlob.length(), 0, dwFlags);

    }
    else
    {
        // Load Encrypted blob into key context
        apKeyCtx->LoadKey(pbKeyBlob, cbKeyBlobLen, hAuxImpKey, dwFlags);
    }

    // Import decrypted blob into Auxiliary CSP
    apKeyCtx->ImportToAuxCSP();

    return apKeyCtx;
}


                                                  // Access
HAdaptiveContainer
CryptContext::AdaptiveContainer() const
{
    if (!m_hacntr)
        throw scu::OsException(ERROR_INVALID_PARAMETER);

    return m_hacntr;
}

HCRYPTPROV
CryptContext::AuxContext() const
{
    return m_auxcontext();
}

HCardContext
CryptContext::CardContext() const
{
    return AdaptiveContainer()->CardContext();
}

ContainerEnumerator
CryptContext::CntrEnumerator(bool fReset)
{
    if (fReset)
    {
        if (m_hacntr)
            m_ce = ContainerEnumerator(list<HCardContext>(1, m_hacntr->CardContext()));
        else
        {
            CardEnumerator ce;
            m_ce = ContainerEnumerator(*(ce.Cards()));
        }
    }
    
    return m_ce;
}

CHashContext *
CryptContext::LookupHash(HCRYPTHASH hHash)
{
    return reinterpret_cast<CHashContext *>(m_hlHashes[hHash]);
}

CKeyContext *
CryptContext::LookupKey(HCRYPTKEY hKey)
{
    return reinterpret_cast<CKeyContext *>(m_hlKeys[hKey]);
}

CPublicKeyContext *
CryptContext::LookupPublicKey(HCRYPTKEY hKey)
{
    return reinterpret_cast<CPublicKeyContext *>(LookupChecked(hKey, KT_PUBLICKEY));
}

CSessionKeyContext *
CryptContext::LookupSessionKey(HCRYPTKEY hKey)
{
    return reinterpret_cast<CSessionKeyContext *>(LookupChecked(hKey, KT_SESSIONKEY));
}

HWND
CryptContext::Window() const
{
    HWND hwndActive = m_hwnd;

    // Find a window if the designated one isn't valid. If the
    // designated one is NULL, don't use the result of GetActiveWindow
    // because the mouse is locked when displaying a dialog box using
    // that as the parent window from certain applications (IE and
    // Outlook Express).
    return (m_hwnd && !IsWindow(m_hwnd))
        ? GetActiveWindow()
        : m_hwnd;
}


                                                  // Predicates
bool
CryptContext::GuiEnabled() const
{
    return m_fGuiEnabled;
}

bool
CryptContext::IsEphemeral() const
{
    return m_fEphemeralContainer;
}


                                                  // Static Variables

///////////////////////////   PROTECTED   /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables


///////////////////////////    PRIVATE    /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations

// Create and open a new container (named by rcspec). If the
// container does exist, then it must be empty.
void
CryptContext::CreateNewContainer(CSpec const &rcspec)
{
    ASSERT (!m_hacntr);

    // Find the card in the reader specified.
    CardFinder cardfinder(DefaultDialogMode(GuiEnabled()), Window());

    CSpec csReader(rcspec);
    csReader.SetReader(rcspec.Reader());

    Secured<HCardContext> hscardctx(cardfinder.Find(csReader));

    // Default the container name a UUID (GUID) if it wasn't supplied.
    string sCntrToCreate(rcspec.CardId());
    if (sCntrToCreate.empty())
    {
        Uuid uuid;
        sCntrToCreate = AsString(uuid.AsUString());
    }

    AdaptiveContainerKey Key(hscardctx, sCntrToCreate);
    m_hacntr = AdaptiveContainer::Find(Key);     // find the existing one
    if(m_hacntr)
    {
        //according to spec, a new container cannot have the
        //same name as an old one.
        throw scu::OsException(NTE_EXISTS);
    }

    if (hscardctx->Card()->IsProtectedMode())
        Login(User, hscardctx);

    m_hacntr = HAdaptiveContainer(Key);

}


void
CryptContext::DeleteContainer(Secured<HCardContext> &rhscardctx,
                              CContainer &rhcntr)
{
    if (IsProtected(rhcntr))
        Login(User, rhscardctx);

    AdaptiveContainer::Discard(AdaptiveContainerKey(rhscardctx,
                                                    rhcntr->Name()));
    rhcntr->Delete();
}
    
void
CryptContext::Login(LoginIdentity const &rlid,
                    Secured<HCardContext> &rhscardctx)
{
    // TO DO: Support Entrust
    if (m_fGuiEnabled)
        rhscardctx->Login(rlid, InteractiveLoginTask(Window()));
    else
        rhscardctx->Login(rlid, LoginTask());
}

void
CryptContext::OkDeletingCredentials() const
{
    if (GuiEnabled())
    {
        UINT uiResponse = PromptUser(Window(),
                                     IDS_DELETE_CREDENTIALS,
                                     MB_OKCANCEL | MB_ICONWARNING);

        switch (uiResponse)
        {
        case IDCANCEL:
            throw scu::OsException(ERROR_CANCELLED);
            break;

        case IDOK:
            break;
            
        default:
            throw scu::OsException(ERROR_INTERNAL_ERROR);
            break;
        };
    }
    else
        throw scu::OsException(NTE_EXISTS);
}

                                                  // Access
CKeyContext *
CryptContext::LookupChecked(HCRYPTKEY hKey,
                            DWORD const dwKeyType)
{
    CKeyContext *pKeyCtx = LookupKey(hKey);

    if (dwKeyType != pKeyCtx->TypeOfKey())
        throw scu::OsException(ERROR_INVALID_PARAMETER);

    return pKeyCtx;
}

// Open to an existing container specified by the container
// specification rcspec.  If container name is empty, then open the
// default container.
void
CryptContext::OpenExistingContainer(CSpec const &rcspec)
{
    if (rcspec.CardId().empty())
    {
        if (!m_fEphemeralContainer)
        {
            CardFinder cardfinder(DefaultDialogMode(GuiEnabled()), Window());
            Secured<HCardContext> hscardctx(cardfinder.Find(rcspec));
            CContainer hcntr(hscardctx->Card()->DefaultContainer());

            if (hcntr)
                m_hacntr =
                    HAdaptiveContainer(AdaptiveContainerKey(hscardctx,
                                                            hcntr->Name()));
        }
    }
    else
    {
        AContainerFinder cntrfinder(DefaultDialogMode(GuiEnabled()), Window());

        m_hacntr = cntrfinder.Find(rcspec);
    }

    if (!m_hacntr && (!rcspec.CardId().empty() || !m_fEphemeralContainer))
        throw scu::OsException(NTE_BAD_KEYSET);
}

                                                  // Predicates
                                                  // Static Variables
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\cspi.h ===
// Cspi.h -- Cryptographic Service Provider Interface declaration

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#if !defined(SLBCSP_CSPI_H)
#define SLBCSP_CSPI_H

#if defined(_UNICODE)
  #if !defined(UNICODE)
    #define UNICODE
  #endif //!UNICODE
#endif //_UNICODE
#if defined(UNICODE)
  #if !defined(_UNICODE)
    #define _UNICODE
  #endif //!_UNICODE
#endif //UNICODE

#include <basetsd.h>
#include <wincrypt.h>
#include <cspdk.h>

#include <scuOsVersion.h>

#define SLBCSPAPI BOOL WINAPI


#endif // SLBCSP_CSPI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\cspec.h ===
// CSpec.h -- Card Specification

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1998. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#if !defined(SLBCSP_CSPEC_H)
#define SLBCSP_CSPEC_H

#include <string>
#include <windows.h>

class CSpec
{
    std::string m_sReader;
    std::string m_sCardId;
    std::string m_sSpec;

    char const &BreakToken(void) const
    {
        static char const cBreakToken('\\');

        return cBreakToken;
    }

    std::string const &
    DeviceIdToken(void)
    {
        static std::string const sDeviceId("\\\\.\\");

        return sDeviceId;
    }

    void
    SetSpec(void);

    bool
    ValidName(std::string const &rsName) const;

public:

    CSpec(std::string const &rsSpec);
    CSpec(std::string const &rsReader,
          std::string const &rsCardId);
    CSpec(CSpec const &rhs);
    CSpec() {};

    virtual
    ~CSpec() {};

    virtual void
    Empty(void);

    void
    EmptyCardId(void);

    void
    EmptyReader(void);

    static bool
    Equiv(std::string const &rsSpec,
          std::string const &rsName);

    virtual bool
    Equiv(CSpec const &rhs) const;

    virtual bool
    IsEmpty(void) const
    {
        return m_sSpec.empty() == true;
    }

    std::string const &
    Reader(void) const
    {
        return m_sReader;
    }

    std::string const &
    CardId(void) const
    {
        return m_sCardId;
    }

    virtual void
    RefreshSpec(void);

    void
    SetCardId(std::string const &rcsCardId);

    void
    SetReader(std::string const &rcsReader);

    virtual std::string const &
    Spec(void) const
    {
        return m_sSpec;
    }

    virtual CSpec &
    operator=(CSpec const &rhs);

    operator std::string const &()
    {
        return Spec();
    }

};

#endif // SLBCSP_CSPEC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\cspi.cpp ===
// Cspi.cpp -- Schlumberger Cryptographic Service Provider Interface definition

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

// Don't allow the min & max macros in WINDEF.H to be defined so the
// min/max methods declared in limits are accessible.
#define NOMINMAX

#if defined(_UNICODE)
  #if !defined(UNICODE)
    #define UNICODE
  #endif //!UNICODE
#endif //_UNICODE

#if defined(UNICODE)
  #if !defined(_UNICODE)
    #define _UNICODE
  #endif //!_UNICODE
#endif //UNICODE

#include "stdafx.h"

#include <memory>                                 // for auto_ptr
#include <limits>
#include <string>
#include <vector>
#include <functional>
#include <algorithm>
#include <numeric>

#include <stddef.h>
#include <rpc.h>

#include <SCardLib.h>

#include <scuOsExc.h>
#include <pkiExc.h>

#include "Guard.h"
#include "slbCsp.h"
#include "CspProfile.h"
#include "CryptCtx.h"
#include "SesKeyCtx.h"
#include "PubKeyCtx.h"
#include "HashCtx.h"
#include "CSpec.h"
#include "Blob.h"
#include "Cspi.h"
#include "StResource.h"
#include "scarderr.h"                             // must be last for now

using namespace std;
using namespace scu;

#define HANDLEID_CRYPT_CONTEXT  17
static CHandleList hlCryptContexts(HANDLEID_CRYPT_CONTEXT);

#if defined(_DEBUG)
#define CSPI_DEFINE_ROUTINE_NAME(sRoutine) \
    LPCTSTR cspi_sRoutine = sRoutine
#define CSPI_TRACE_ROUTINE(sFlag) \
    TRACE(TEXT("%s %s, Thread Id %08X\n"), cspi_sRoutine, \
          sFlag, GetCurrentThreadId());
#else
#define CSPI_DEFINE_ROUTINE_NAME(sRoutine)
#define CSPI_TRACE_ROUTINE(sFlag)
#endif // defined(_DEBUG)

typedef DWORD CapiError;

#define CSPI_TRY(Routine)                                            \
    {                                                                \
        bool cspi_fExceptionCaught = false;                          \
        CapiError cspi_ce = AsCapiError(ERROR_SUCCESS);              \
                                                                     \
        {                                                            \
            AFX_MANAGE_STATE(AfxGetStaticModuleState());             \
                                                                     \
            CSPI_DEFINE_ROUTINE_NAME(TEXT(#Routine));                \
            CSPI_TRACE_ROUTINE(TEXT("Begin"));                       \
                                                                     \
            CWaitCursor cspi_wc;                                     \
                                                                     \
            try

#define CSPI_CATCH(fStatus)                                          \
            catch (scu::Exception const &rExc)                       \
            {                                                        \
                cspi_fExceptionCaught = true;                        \
                cspi_ce = AsCapiError(rExc);                         \
            }                                                        \
                                                                     \
            catch (std::bad_alloc const &rExc)                       \
            {                                                        \
                cspi_fExceptionCaught = true;                        \
                cspi_ce = AsCapiError(rExc);                         \
            }                                                        \
                                                                     \
            catch (DWORD dwError)                                    \
            {                                                        \
                cspi_fExceptionCaught = true;                        \
                cspi_ce = AsCapiError(dwError);                      \
            }                                                        \
                                                                     \
            catch (...)                                              \
            {                                                        \
                cspi_fExceptionCaught = true;                        \
                cspi_ce = AsCapiError(NTE_FAIL);                     \
            }                                                        \
                                                                     \
            CSPI_TRACE_ROUTINE(TEXT("End"));                         \
                                                                     \
            (fStatus) = cspi_fExceptionCaught                        \
                        ? CRYPT_FAILED                               \
                        : CRYPT_SUCCEED;                             \
        }                                                            \
                                                                     \
        SetLastError(cspi_ce);                                       \
                                                                     \
    }

namespace
{                                                 // Helper routines

    template<class CauseCode>
    struct ErrorCodeMap
    {
        typename CauseCode m_cc;
        DWORD m_dwErrorCode;
    };

    template<class CauseCode>
    DWORD
    FindErrorCode(ErrorCodeMap<typename CauseCode> const *pFirst,
                  ErrorCodeMap<typename CauseCode> const *pLast,
                  typename CauseCode cc)
    {
        bool fFound = false;
        DWORD dwErrorCode = NTE_FAIL;
        for (ErrorCodeMap<CauseCode> const *p = pFirst;
             !fFound && (p < pLast); p++)
        {
            if (p->m_cc == cc)
            {
                dwErrorCode = p->m_dwErrorCode;
                fFound = true;
            }
        }

        return dwErrorCode;
    }


    ErrorCodeMap<cci::CauseCode> CciErrorMap[] =
    {
        { cci::ccBadKeySpec, SCARD_E_INVALID_VALUE },
        { cci::ccBadPinLength, SCARD_E_INVALID_VALUE },
        { cci::ccNoCertificate, SCARD_E_NO_SUCH_CERTIFICATE },
        { cci::ccNotPersonalized, SCARD_E_UNSUPPORTED_FEATURE },
        { cci::ccOutOfPrivateKeySlots, NTE_TOKEN_KEYSET_STORAGE_FULL },
        { cci::ccOutOfSymbolTableSpace, NTE_TOKEN_KEYSET_STORAGE_FULL },
        { cci::ccOutOfSymbolTableEntries, NTE_TOKEN_KEYSET_STORAGE_FULL },
    };

    ErrorCodeMap<iop::CSmartCard::CauseCode> SmartCardErrorMap[] =
    {
        { iop::CSmartCard::ccAccessConditionsNotMet, SCARD_W_SECURITY_VIOLATION },
        { iop::CSmartCard::ccAlgorithmIdNotSupported, CRYPT_E_UNKNOWN_ALGO },
        { iop::CSmartCard::ccAuthenticationFailed, SCARD_W_WRONG_CHV },
        { iop::CSmartCard::ccChvVerificationFailedMoreAttempts,
          SCARD_W_WRONG_CHV },
        { iop::CSmartCard::ccDataPossiblyCorrupted, ERROR_FILE_CORRUPT },
        { iop::CSmartCard::ccFileExists, ERROR_FILE_EXISTS },
        { iop::CSmartCard::ccInsufficientSpace, NTE_TOKEN_KEYSET_STORAGE_FULL },
        { iop::CSmartCard::ccOutOfSpaceToCreateFile, NTE_TOKEN_KEYSET_STORAGE_FULL },
        { iop::CSmartCard::ccKeyBlocked, SCARD_W_CHV_BLOCKED },
        { iop::CSmartCard::ccNoAccess, SCARD_W_SECURITY_VIOLATION },
        { iop::CSmartCard::ccReturnedDataCorrupted, ERROR_FILE_CORRUPT },
        { iop::CSmartCard::ccTimeOut, E_UNEXPECTED },
        { iop::CSmartCard::ccUnidentifiedTechnicalProblem, E_UNEXPECTED },
        { iop::CSmartCard::ccVerificationFailed, SCARD_W_WRONG_CHV },
    };

    ErrorCodeMap<iop::CauseCode> IopErrorMap[] =
    {
        { iop::ccAlgorithmIdNotSupported, CRYPT_E_UNKNOWN_ALGO },
        { iop::ccInvalidParameter, E_INVALIDARG },
        { iop::ccNoResponseAvailable, E_UNEXPECTED },
        { iop::ccResourceManagerDisabled, SCARD_E_NO_SERVICE },
        { iop::ccUnknownCard, SCARD_E_UNKNOWN_CARD },
        { iop::ccUnsupportedCommand, SCARD_E_UNSUPPORTED_FEATURE },
    };

    bool
    IsHResult(DWORD dwError)
    {
        return (0 != HRESULT_SEVERITY(static_cast<HRESULT>(dwError)))
            ? true
            : false;
    }

    CapiError
    AsCapiError(HRESULT hr)
    {
        // If the HRESULT has been converted from a Win32 error code
        // (WIN32 facility), then convert it back to a Win32 error
        // code.  These types of HRESULTs confuse WinLogon, according
        // to Doug Barlow (Microsoft)
        return (FACILITY_WIN32 == HRESULT_FACILITY(hr))
            ? HRESULT_CODE(hr)
            : static_cast<DWORD>(hr);
    }

    CapiError
    AsCapiError(DWORD dwError)
    {
        if (IsHResult(dwError))
            dwError = AsCapiError(static_cast<HRESULT>(dwError));

        return dwError;
    }

    CapiError
    AsCapiError(cci::Exception const &rExc)
    {
        return AsCapiError(FindErrorCode(CciErrorMap,
                                         (CciErrorMap +
                                          (sizeof CciErrorMap /
                                           sizeof *CciErrorMap)),
                                         rExc.Cause()));
    }

    CapiError
    AsCapiError(iop::Exception const &rExc)
    {
        return AsCapiError(FindErrorCode(IopErrorMap,
                                         (IopErrorMap +
                                          (sizeof IopErrorMap /
                                           sizeof *IopErrorMap)),
                                         rExc.Cause()));
    }

    CapiError
    AsCapiError(scu::OsException const &rExc)
    {
        return AsCapiError(rExc.Cause());
    }

    CapiError
    AsCapiError(iop::CSmartCard::Exception const &rExc)
    {
        return AsCapiError(FindErrorCode(SmartCardErrorMap,
                                         (SmartCardErrorMap +
                                          (sizeof SmartCardErrorMap /
                                           sizeof *SmartCardErrorMap)),
                                         rExc.Cause()));
  