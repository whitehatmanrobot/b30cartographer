ack pointer to the packet pool.
    //
    PACKETPOOL* pPool;

    // Number of individual packets in this block.
    //
    ULONG ulPackets;

    // Number of individual packets in this block on the free list.
    //
    ULONG ulFreePackets;
}
PACKETBLOCKHEAD;


// Control information for an individual packet.  For the packet pool, this
// "header" does not actually preceed anything, but this keeps the terminology
// consistent with the very similar buffer pool routines.
//
typedef struct
_PACKETHEAD
{
    // Link to next packet header in the packet pool's free list.
    //
    LIST_ENTRY linkFreePackets;

    // Back link to owning packet block header.
    //
    PACKETBLOCKHEAD* pBlock;

    // NDIS packet descriptor of this buffer.
    //
    NDIS_PACKET* pNdisPacket;
}
PACKETHEAD;


//-----------------------------------------------------------------------------
// Interface prototypes and inline definitions
//-----------------------------------------------------------------------------

VOID
InitPacketPool(
    OUT PACKETPOOL* pPool,
    IN ULONG ulProtocolReservedLength,
    IN ULONG ulMaxPackets,
    IN ULONG ulPacketsPerBlock,
    IN ULONG ulFreesPerCollection,
    IN ULONG ulTag );

BOOLEAN
FreePacketPool(
    IN PACKETPOOL* pPool );

NDIS_PACKET*
GetPacketFromPool(
    IN PACKETPOOL* pPool,
    OUT PACKETHEAD** ppHead );

VOID
FreePacketToPool(
    IN PACKETPOOL* pPool,
    IN PACKETHEAD* pHead,
    IN BOOLEAN fGarbageCollection );

PACKETPOOL*
PacketPoolFromPacketHead(
    IN PACKETHEAD* pHead );

__inline
PACKETPOOL*
PacketPoolFromPacketHead(
    IN PACKETHEAD* pHead )

    // Returns the address of the pool, given 'pHead', the address of a
    // PACKETHEAD like the one returned from GetPacketFromPool.
    //
{
    return pHead->pBlock->pPool;
}


#endif // PPOOL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\raspti\ptiwan.h ===
// Copyright (c) 1997, Microsoft Corporation, all rights reserved
// Copyright (c) 1997, Parallel Technologies, Inc., all rights reserved
//
// ptiwan.h
// RAS DirectParallel WAN mini-port/call-manager driver
// Main private header (precompiled)
//
// 01/07/97 Steve Cobb
// 09/15/97 Jay Lowe, Parallel Technologies, Inc.
//
//
// About naming:
//
// This driver contains code for both the DirectParallel mini-port and call
// manager.  All handler routines exported to NDIS are prefixed with either
// 'Pti' for the mini-port handlers or 'PtiCm' for the call manager handlers.
//
//
// About locks:
//
// Data structures that may change during simultaneous requests to different
// processors in a multi-processor system must be protected with spin-locks or
// accessed only with interlocked routines.  Where locking is required to
// access a data field in this header, the comment for that field indicates
// same.  A CoNDIS client is a trusted kernel mode component and presumed to
// follow the documented call sequences of CoNDIS.  Some access conflicts that
// might be caused by goofy clients are not checked, though the easy ones are.
// Cases where multiple clients might conflict are protected even though, for
// now, the TAPI proxy is expected to be the only client.
//

#ifndef _PTIWAN_H_
#define _PTIWAN_H_

#include <ntddk.h>
#include <ndis.h>
#include <ndiswan.h>
#include <ndistapi.h>
//#include <ndisadd.h>        // Temporary
#include <debug.h>
#include <bpool.h>
#include <ppool.h>
#include <ptilink.h>        // PTILINK device (lower edge)


//-----------------------------------------------------------------------------
// Constants
//-----------------------------------------------------------------------------

// The NDIS version we report when registering mini-port and address family.
//
#define NDIS_MajorVersion 5
#define NDIS_MinorVersion 0

// Frame and buffer sizes.  The "plus 2 times 2" is necessary to account for
// the byte-stuffing that is necessary for Win9x legacy reasons.  See the
// HdlcFromAsyncFraming and AsyncFromHdlcFraming routines.
//
#define PTI_MaxFrameSize    1500
#define PTI_FrameBufferSize (((PTI_MaxFrameSize + 2) * 2) + 32)

// Default reported speed of a DirectParallel in bits/second.
// ??? dynamically report line speed
//
#define PTI_LanBps 4000000                  // 100K Bytes/sec typical 4BIT
                                            // 500K Bytes/sec typical enhanced

//-----------------------------------------------------------------------------
// Data types
//-----------------------------------------------------------------------------

// Forward declarations.
//
typedef struct _VCCB VCCB;

// Adapter control block defining the state of a single DirectParallel
// connection.  The DirectParallel driver may support simultaneous connections
// over multiple LPT ports on the same machine
//
// ??? Do we support multiple LPT connections on one machine
// ??? Need to check PTILINK, here in PTIWAN we will allow them
//
// ADAPTERCBs are allocated in MiniportInitialize and deallocated in
// MiniportHalt.
//
typedef struct
_ADAPTERCB
{
    // Set to MTAG_ADAPTERCB for easy identification in memory dumps and use
    // in assertions.
    //
    ULONG ulTag;

    // Reference count on this control block.  The reference pairs are:
    //
    // (a) A reference is added when the MiniportAdapterHandle field is set,
    //     i.e. when LmpInitialize succeeds and cleared when the LmpHalt
    //     handler is called.  The adapter block is actually passed to NDIS
    //     before it's known if LmpInitialize will succeed but according to
    //     ArvindM NDIS will not call halt unless it succeeds.
    //
    // (b) A reference is added when the NdisAfHandle field is set and removed
    //     when it is cleared.
    //
    // (c) A reference is added when the NdisSapHandle field is set and
    //     removed when it is cleared.
    //
    // (d) A reference is added for the VCCB's back pointer and removed when
    //     the VCCB is freed.
    //
    // (e) A reference is added when an NDIS_WORK_ITEM is scheduled and
    //     removed when it has completed.
    //
    // Access is via ReferenceAdapter and DereferenceAdapter only.
    //
    LONG lRef;

    // ACBF_* bit flags indicating various options.  Access restrictions are
    // indicated for each individual flag.
    //
    // ACBF_SapActive: Set when the NdisSapHandle may be used with incoming
    //     calls.  Access is protected by 'lockSap'.
    //
    ULONG ulFlags;
        #define ACBF_SapActive 0x00000001

    // Our framing and bearer capablities bit masks as passed in StartCcReq.
    //
    ULONG ulFramingCaps;
    ULONG ulBearerCaps;

    // Milliseconds to delay OpenAf to give PARPORT a chance to initialize all
    // the parallel ports, and the secondary delay to perform only if no
    // parallel ports are enumerated after the first wait.
    //
    ULONG ulParportDelayMs;
    ULONG ulExtraParportDelayMs;

    // Got to keep handles on all open PtiLink ports to prevent reopen
    //  due to bizarrely involuted CoNdis sequences re Saps and Vcs
    //
    HANDLE hPtiLinkTable[NPORTS];

    // Table of TAPI Line Ids by port
    //
    ULONG ulLineIds[NPORTS];

    // Table of PtiLink interface status bit flags by port
    //
    ULONG ulPtiLinkState[NPORTS];
        #define PLSF_PortExists  0x00000001
        #define PLSF_LineIdValid 0x00000002

    // Parallel port name.  Valid only when port exists.
    //
    WCHAR szPortName[ NPORTS ][ MAXLPTXNAME + 1 ];

    // VC TABLE --------------------------------------------------------------

    // The maximum number of simultaneous VCs.  The value is read from the
    // registry during initialization.
    //
    // ??? This is currently used as the maximum LPT port index in validation,
    // though this may need to change if PTILINK can return a disjoint set of
    // LPT ports
    //
    USHORT usMaxVcs;

    // The actual number of devices for Vcs available to RasPti via PtiLink
    // Determined at OID_CO_TAPI_CM_CAPS time using PtiQueryDeviceStatus
    //
    ULONG ulActualVcs;

    // Table of Temporary Listening VCCBs, one for each possible port.
    //   We open PtiLink for listening at RegisterSap time, and we
    //   don't have a Vc then.  So, at RegisterSap time, we'll make a
    //   VCCB, put a pointer to it here, and use it to listen on.

    VCCB* pListenVc;

    // RESOURCE POOLS --------------------------------------------------------

    // Lookaside list of NDIS_WORK_ITEM scheduling descriptors with extra
    // context space used by all tunnels and VCs attached to the adapter.
    //
    NPAGED_LOOKASIDE_LIST llistWorkItems;

    // Lookaside list of VCCBs from which the control blocks dynamically
    // attached to '*ppVcs' are allocated.
    //
    NPAGED_LOOKASIDE_LIST llistVcs;

    // Pool of full frame buffers with pre-attached NDIS_BUFFER descriptors.
    // The pool is accessed via the interface defined in bpool.h, which
    // handles all locking internally.
    //
    BUFFERPOOL poolFrameBuffers;
    PNDIS_HANDLE phBufferPool;

    // Pool of NDIS_PACKET descriptors used in indication of received frames.
    // The pool is accessed via the interface defined in ppool.h, which
    // handles all locking internally.
    //
    PACKETPOOL poolPackets;
    PNDIS_HANDLE phPacketPool;

    // NDIS BOOKKEEPING ------------------------------------------------------

    // NDIS's handle for this mini-port adapter passed to us in
    // MiniportInitialize.  This is passed back to various NdisXxx calls.
    //
    NDIS_HANDLE MiniportAdapterHandle;

    // NDIS's handle for our SAP as passed to our CmRegisterSapHandler or NULL
    // if none.  Only one SAP handle is supported because (a) the TAPI proxy's
    // is expected to be the only one, and (b) there are no PTI SAP properties
    // that would ever lead us to direct a call to a second SAP anyway.  Any
    // client's attempt to register a second SAP will fail.  A value of NULL
    // indicates no SAP handle is currently registered.  Access is via
    // Interlocked routines.
    //
    NDIS_HANDLE NdisSapHandle;

    // NDIS's handle for our Address Family as passed to our CmOpenAfHandler
    // or NULL if none.  Only one is supported.  See NdisSapHandle above.
    // Access is via Interlocked routines.
    //
    NDIS_HANDLE NdisAfHandle;

    // Reference count on the NdisAfHandle.  The reference pairs are:
    //
    // (a) A reference is added when the address family is opened and removed
    //     when it is closed.
    //
    // (b) A reference is added when a SAP is registered on the address family
    //     and removed when it is deregistered.
    //
    // (c) A reference is added when a VC is created on the address family and
    //     removed when it is deleted.
    //
    // Access is via ReferenceAf and DereferenceAf only.
    //
    LONG lAfRef;

    // Reference count on the NdisSapHandle.  The reference pairs are:
    //
    // (a) A reference is added when the SAP is registered and removed when it
    //     is de-registered.
    //
    // (b) A reference is added when a tunnels TCBF_SapReferenced flag is set
    //     and removed when the flag is cleared before the tunnel control
    //     block is freed.
    //
    // (c) A reference is always added before accesses ADAPTERCB.pListenVc and
    //     removed afterward.
    //
    // Access is via ReferenceSap and DereferenceSap only, excepting initial
    // reference by RegisterSapPassive.  Access is protected by 'lockSap'.
    //
    LONG lSapRef;

    // 0-based port index of the port to listen on.  Valid only when
    // 'NdisSapHandle' is non-NULL.
    //
    // ??? Is listening on only 1 port at a time a problem?
    //
    ULONG ulSapPort;

    // This lock protects the 'lSapRef' and 'NdisSapHandle' fields.
    //
    NDIS_SPIN_LOCK lockSap;
    // This adapter's capabilities as returned to callers on
    // OID_WAN_CO_GET_INFO.  These capabilities are also used as defaults for
    // the corresponding VCCB.linkinfo settings during MiniportCoCreateVc.
    //
    NDIS_WAN_CO_INFO info;
}
ADAPTERCB;

// Virtual circuit control block defining the state of a single PTI VC, i.e.
// one line device endpoint and the call, if any, active on it.  A VC is never
// used for incoming and outgoing calls simultaneously.  A single NDIS VC maps
// to one of these.
//
typedef struct
_VCCB
{
    // Set to MTAG_VCCB for easy identification in memory dumps and use in
    // assertions.
    //
    ULONG ulTag;

    // Reference count on this VC control block.  The reference pairs are:
    //
    // (a) PtiCoCreateVc adds a reference that is removed by PtiCoDeleteVc.
    //     This covers all clients that learn of the VCCB via NDIS.
    //
    // (b) All PtiCmXxx handlers take a reference on entry that is released
    //     before exit.
    //
    // (c) For the "listen" VC, a reference is taken when a SAP is registered
    //     and removed when the SAP is deregistered.
    //
    // The field is accessed only by the ReferenceVc and DereferenceVc
    // routines, which protect with Interlocked routines.
    //
    LONG lRef;

    // Back pointer to owning adapter's control block.
    //
    ADAPTERCB* pAdapter;

    // This lock protects VCCB payload send and receive paths as noted in
    // other field descriptions.  In cases where both 'lockV' and
    // 'pTunnel->lockT' are required 'lockT' must be obtained first.
    //
    NDIS_SPIN_LOCK lockV;

    // Lower edge API stuff --------------------------------------------------

    // file handle on the PTILINKx device, <>0 means we have device open
    HANDLE hPtiLink;

    // Parallel Port Index (0=LPT1) in use for this VC
    ULONG ulVcParallelPort;

    // pointer to device extension for the PTILINKx device
    PVOID Extension;

    // pointer to the PTILINK internal extension within the device extension
    //   this is a bit hacky, but it appears too complex to include the
    //   internal PtiLink structures (PtiStruc.h) here
    //   so we'll have PtiInitialize return pointers to both
    PVOID PtiExtension;


    // CALL SETUP ------------------------------------------------------------

    // Our unique call identifier sent back to us by peer in the L2TP header.
    // The value is a 1-based index into the 'ADAPTERCB.ppVcs' array.
    //
    USHORT usCallId;

    // VCBF_* bit flags indicating various options and states.  Access is via
    // the interlocked ReadFlags/SetFlags/ClearFlags routines.
    //
    // VCBF_IndicateReceivedTime: Set if MakeCall caller sets the
    //     MediaParameters.Flags RECEIVE_TIME_INDICATION flag requesting the
    //     TimeReceived field of the NDIS packet be filled with a timestamp.
    //
    // VCBF_CallClosableByClient: Set when a call is in a state where
    //     PtiCmCloseCall requests to initiate clean-up should be accepted.
    //     This may be set when VCBF_CallClosableByPeer is not, which means we
    //     have indicated an incoming close to client and are waiting for him
    //     to do a client close in response (in that weird CoNDIS way).  The
    //     flag is protected by 'lockV'.
    //
    // VCBF_CallClosableByPeer: Set when the call is in a state where an idle
    //     transition without operations pending should be mapped to a
    //     PeerClose event.  This will never be set when
    //     VCBF_CallClosableByClient is not.  The flag is protected by
    //     'lockV'.
    //
    // VCBF_PeerInitiatedCall: Set when an the active call was initiated by
    //     the peer, clear if it was initiated by the client.
    //
    // VCBF_VcCreated: Set when the VC has been created successfully.  This is
    //     the "creation" that occurs with the client, not the mini-port.
    // VCBF_VcActivated: Set when the VC has been activated successfully.
    // VCBF_VcDispatched: Set when the VC has dispatched an incoming call to
    //     the client.
    // VCBM_VcState: Bit mask that includes each of the 3 NDIS state flags.
    //
    // The pending bits below are mutually exclusive, and so require lock
    // protection by 'lockV':
    //
    // VCBF_PeerOpenPending: Set when peer attempts to establish a call, and
    //     the result is not yet known.
    // VCBF_ClientOpenPending: Set when client attempts to establish a call,
    //     and the result is not yet known.
    // VCBF_PeerClosePending: Set when peer attempts to close an established
    //     call and the result is not yet known.  Access is protected by
    //     'lockV'.
    // VCBF_ClientClosePending: Set when client attempts to close an
    //     established call and the result is not yet known.  Access is
    //     protected by 'lockV'.
    // VCBLM_Pending: Bit mask that includes each of the 4 pending flags.
    //
    // VCBF_ClientCloseCompletion: Set when client close completion is in
    //     progress.
    // VCBF_CallInProgress: Set when incoming packets should not trigger the
    //     setup of a new incoming call.
    //
    ULONG ulFlags;
        #define VCBF_IndicateTimeReceived  0x00000001
        #define VCBF_CallClosableByClient  0x00000002
        #define VCBF_CallClosableByPeer    0x00000004
        #define VCBF_IncomingFsm           0x00000010
        #define VCBF_PeerInitiatedCall     0x00000020
        #define VCBF_Sequencing            0x00000040
        #define VCBF_VcCreated             0x00000100
        #define VCBF_VcActivated           0x00000200
        #define VCBF_VcDispatched          0x00000400
        #define VCBM_VcState               0x00000700
        #define VCBF_VcCloseDispatched     0x00000800
        #define VCBF_PeerOpenPending       0x00001000
        #define VCBF_ClientOpenPending     0x00002000
        #define VCBF_PeerClosePending      0x00004000
        #define VCBF_ClientClosePending    0x00008000
        #define VCBM_Pending               0x0000F000
        #define VCBF_ClientCloseCompletion 0x00010000
        #define VCBF_CallInProgress        0x00020000

    // Reference count on the active call.  References may only be added when
    // the VCCB_VcActivated flag is set, and this is enforced by
    // ReferenceCall.  The reference pairs are:
    //
    // (a) A reference is added when a VC is activated and removed when it is
    //     de-activated.
    //
    // (b) A reference is added when the send handler accepts a packet and
    //     released by the send complete routine.
    //
    // (c) A reference is added before entering PtiRx and removed on exit from
    //     same.
    //
    // The field is accessed only by the ReferenceCall and DereferenceCall
    // routines, which protect the field with 'lockCall'.
    //
    LONG lCallRef;
    NDIS_SPIN_LOCK lockCall;

    // This is set to the result to be reported to client and is meaningful
    // only when the VC is on the tunnels list of completing VCs.
    //
    NDIS_STATUS status;

    // Address of the call parameters block passed up in
    // NdisMCmDispatchIncomingCall, or NULL if none.
    //
    CO_CALL_PARAMETERS* pInCall;

    // Shortcut address of the TAPI-specific call parameters in the 'pInCall'
    // incoming call buffer.  Valid only when 'pInCall' is valid, i.e.
    // non-NULL.
    //
    CO_AF_TAPI_INCOMING_CALL_PARAMETERS* pTiParams;

    // Address of the call parameters passed down in CmMakeCall.  This field
    // will only be valid until the NdisMCmMakeCallComplete notification for
    // the associated call is made, at which time it is reset to NULL.  Access
    // is via Interlocked routines.
    //
    CO_CALL_PARAMETERS* pMakeCall;

    // Shortcut address of the TAPI-specific call parameters in the
    // 'pMakeCall' outgoing call buffer.  Valid only when 'pMakeCall' is
    // valid, i.e. non-NULL.
    //
    CO_AF_TAPI_MAKE_CALL_PARAMETERS UNALIGNED* pTmParams;

    // The result and error to report in the coming incoming/outgoing call
    // reply message.
    //
    USHORT usResult;
    USHORT usError;

    // The connect speed in bits/second.  This is the value reported to
    // NDISWAN.
    //
    ULONG ulConnectBps;

    // Number of packets across the link since PtiOpenPtiLink
    //
    ULONG ulTotalPackets;

    // SEND STATE ------------------------------------------------------------

    // Next Sent, the sequence number of next payload packet transmitted on
    // this call.  The field is initialized to 0 and incremented after
    // assignment to an outgoing packet, excepting retransmissions.  Access is
    // protected by 'lockV'.
    //
    USHORT usNs;

    // Double-linked list of outstanding sends, i.e. PAYLOADSENTs sorted by
    // the 'usNs' field with lower values near the head.  Access is protected
    // by 'lockV'.
    //
    LIST_ENTRY listSendsOut;

    // The number of sent but unacknowledged packets that may be outstanding.
    // This value is adjusted dynamically.  Per the draft/RFC, when
    // 'ulAcksSinceSendTimeout' reaches the current setting, the window is
    // increased by one.  When a send timeout expires the window is reduced by
    // half.  The actual send window throttling is done by NDISWAN, based on
    // our indications of the changing window size.  Access is protected by
    // 'lockV'.
    //
    ULONG ulSendWindow;

    // The maximum value of 'ulSendWindow'.  Peer chooses this value during
    // call setup.
    //
    ULONG ulMaxSendWindow;

    // The number of packets acknowledged since the last timeout.  The value
    // is reset when a timeout occurs or the send window is adjusted upward.
    // See 'ulSendWindow'.  Access is protected by 'lockV'.
    //
    ULONG ulAcksSinceSendTimeout;

    // The estimated round trip time in milliseconds.  This is the RTT value
    // from Appendix A of the draft/RFC.  The value is adjusted as each
    // acknowledge is received.  It is initialized to the Packet Processing
    // Delay reported by peer.  See 'ulSendTimeoutMs'.  Access is protected by
    // 'lockV'.
    //
    ULONG ulRoundTripMs;

    // The estimated mean deviation in milliseconds, an approximation of the
    // standard deviation.  This is the DEV value from Appendix A of the
    // draft/RFC.  The value is adjusted as each acknowledge is received.  It
    // is initially 0.  See 'ulSendTimeoutMs'.  Access is protected by
    // 'lockV'.
    //
    LONG lDeviationMs;

    // Milliseconds before it is assumed a sent packet will never be
    // acknowledged.  This is the ATO value from Appendix A of the draft/RFC.
    // This value is adjusted as each acknowledge is received, with a maximum
    // of 'ADAPTERCB.ulMaxSendTimeoutMs'.  Access is protected by 'lockV'.
    //
    ULONG ulSendTimeoutMs;

    // The timer event descriptor scheduled to occur when it is time to stop
    // waiting for an outgoing send on which to piggyback an acknowledge.
    // This will be NULL when no delayed acknowledge is pending.  Per the
    // draft/RFC, the timeout used is 1/4 of the 'ulSendTimeoutMs'.  Access is
    // protected by 'lockV'.
    //
//  TIMERQITEM* pTqiDelayedAck;


    // RECEIVE STATE ---------------------------------------------------------

    // Next Received, the sequence number one higher than that of the last
    // payload packet received on this call or 0 if none.  Access is protected
    // by 'lockV'.
    //
    USHORT usNr;

    // Double-linked list of out-of-order receives, i.e. PAYLOADRECEIVEs
    // sorted by the 'usNs' field with lower values near the head.  The
    // maximum queue length is 'ADAPTERCB.sMaxOutOfOrder'.  Access is
    // protected by 'lockV'.
    //
    LIST_ENTRY listOutOfOrder;

    // The timer event descriptor scheduled to occur when it is time to assume
    // peer's current 'Next Received' packet has been lost, and "receive" the
    // first packet in 'listOutOfOrder'.  This will be NULL when
    // 'listOutOfOrder' is empty.  Access is protected by 'lockV'.
    //
//  TIMERQITEM* pTqiAssumeLost;

    // NDIS BOOKKEEPING ------------------------------------------------------

    // NDIS's handle for this VC passed to us in MiniportCoCreateVcHandler.
    // This is passed back to NDIS in various NdisXxx calls.
    //
    NDIS_HANDLE NdisVcHandle;

    // Configuration settings returned to callers on OID_WAN_CO_GET_INFO and
    // modified by callers on OID_WAN_CO_SET_INFO.  Older NDISWAN references to
    // "LINK" map straight to "VC" in the NDIS 5.0 world.  Access is not
    // protected because each ULONG in the structure is independent so no
    // incoherency can result from multiple access.
    //
    NDIS_WAN_CO_GET_LINK_INFO linkinfo;
}
VCCB;



//-----------------------------------------------------------------------------
// Macros/inlines
//-----------------------------------------------------------------------------

// These basics are not in the DDK headers for some reason.
//
#define min( a, b ) (((a) < (b)) ? (a) : (b))
#define max( a, b ) (((a) > (b)) ? (a) : (b))

#define InsertBefore( pNewL, pL )    \
{                                    \
    (pNewL)->Flink = (pL);           \
    (pNewL)->Blink = (pL)->Blink;    \
    (pNewL)->Flink->Blink = (pNewL); \
    (pNewL)->Blink->Flink = (pNewL); \
}

#define InsertAfter( pNewL, pL )     \
{                                    \
    (pNewL)->Flink = (pL)->Flink;    \
    (pNewL)->Blink = (pL);           \
    (pNewL)->Flink->Blink = (pNewL); \
    (pNewL)->Blink->Flink = (pNewL); \
}


// Winsock-ish host/network byte order converters for short and long integers.
//
#if (defined(_M_IX86) && (_MSC_FULL_VER > 13009037)) || ((defined(_M_AMD64) || defined(_M_IA64)) && (_MSC_FULL_VER > 13009175))
#define htons(x) _byteswap_ushort((USHORT)(x))
#define htonl(x) _byteswap_ulong((ULONG)(x))
#else
#define htons( a ) ((((a) & 0xFF00) >> 8) |\
                    (((a) & 0x00FF) << 8))
#define htonl( a ) ((((a) & 0xFF000000) >> 24) | \
                    (((a) & 0x00FF0000) >> 8)  | \
                    (((a) & 0x0000FF00) << 8)  | \
                    (((a) & 0x000000FF) << 24))
#endif
#define ntohs( a ) htons(a)
#define ntohl( a ) htonl(a)

// Place in a TRACE argument list to correspond with a format of "%d.%d.%d.%d"
// to print network byte-ordered IP address 'x' in human readable form.
//
#define IPADDRTRACE(x) ((x) & 0x000000FF),         \
                       (((x) >> 8) & 0x000000FF),  \
                       (((x) >> 16) & 0x000000FF), \
                       (((x) >> 24) & 0x000000FF)


// All memory allocations and frees are done with these ALLOC_*/FREE_*
// macros/inlines to allow memory management scheme changes without global
// editing.  For example, might choose to lump several lookaside lists of
// nearly equal sized items into a single list for efficiency.
//
// NdisFreeMemory requires the length of the allocation as an argument.  NT
// currently doesn't use this for non-paged memory, but according to JameelH,
// Windows95 does.  These inlines stash the length at the beginning of the
// allocation, providing the traditional malloc/free interface.
//
__inline
VOID*
ALLOC_NONPAGED(
    IN ULONG ulBufLength,
    IN ULONG ulTag )
{
    CHAR* pBuf;

    NdisAllocateMemoryWithTag(
        &pBuf, (UINT )(ulBufLength + MEMORY_ALLOCATION_ALIGNMENT), ulTag );
    if (!pBuf)
    {
        return NULL;
    }

    ((ULONG* )pBuf)[ 0 ] = ulBufLength;
    ((ULONG* )pBuf)[ 1 ] = ulTag;
    return pBuf + MEMORY_ALLOCATION_ALIGNMENT;
}

__inline
VOID
FREE_NONPAGED(
    IN VOID* pBuf )
{
    ULONG ulBufLen;

    ulBufLen = *((ULONG* )(((CHAR* )pBuf) - MEMORY_ALLOCATION_ALIGNMENT));
    NdisFreeMemory(
        ((CHAR* )pBuf) - MEMORY_ALLOCATION_ALIGNMENT,
        (UINT )(ulBufLen + MEMORY_ALLOCATION_ALIGNMENT),
        0 );
}

#define ALLOC_VCCB( pA ) \
    NdisAllocateFromNPagedLookasideList( &(pA)->llistVcs )
#define FREE_VCCB( pA, pV ) \
    NdisFreeToNPagedLookasideList( &(pA)->llistVcs, (pV) )

#define ALLOC_NDIS_WORK_ITEM( pA ) \
    NdisAllocateFromNPagedLookasideList( &(pA)->llistWorkItems )
#define FREE_NDIS_WORK_ITEM( pA, pNwi ) \
    NdisFreeToNPagedLookasideList( &(pA)->llistWorkItems, (pNwi) )


//-----------------------------------------------------------------------------
// Prototypes (alphabetically)
//-----------------------------------------------------------------------------

VOID
CallCleanUp(
    IN VCCB* pVc );

VOID
CallTransitionComplete(
    IN VCCB* pVc );

VOID
ClearFlags(
    IN OUT ULONG* pulFlags,
    IN ULONG ulMask );

VOID
CloseCallPassive(
    IN NDIS_WORK_ITEM* pWork,
    IN VOID* pContext );

VOID
CompleteVc(
    IN VCCB* pVc );

VOID
DereferenceAdapter(
    IN ADAPTERCB* pAdapter );

VOID
DereferenceAf(
    IN ADAPTERCB* pAdapter );

VOID
DereferenceCall(
    IN VCCB* pVc );

VOID
DereferenceSap(
    IN ADAPTERCB* pAdapter );

VOID
DereferenceVc(
    IN VCCB* pVc );

BOOLEAN
IsWin9xPeer(
    IN VCCB* pVc );

PVOID
PtiCbGetReadBuffer(
    IN  PVOID   pVc,
    OUT PULONG  BufferSize,
    OUT PVOID*  RequestContext
    );

VOID
PtiRx(
    IN  PVOID       pVc,
    IN  PVOID       ReadBuffer,
    IN  NTSTATUS    Status,
    IN  ULONG       BytesTransfered,
    IN  PVOID       RequestContext
    );

VOID
PtiCbLinkEventHandler(
    IN  PVOID       pVc,
    IN  ULONG       PtiLinkEventId,
    IN  ULONG       PtiLinkEventData
    );

NDIS_STATUS
PtiCmOpenAf(
    IN NDIS_HANDLE CallMgrBindingContext,
    IN PCO_ADDRESS_FAMILY AddressFamily,
    IN NDIS_HANDLE NdisAfHandle,
    OUT PNDIS_HANDLE CallMgrAfContext );

NDIS_STATUS
PtiCmCloseAf(
    IN NDIS_HANDLE CallMgrAfContext );

NDIS_STATUS
PtiCmRegisterSap(
    IN NDIS_HANDLE CallMgrAfContext,
    IN PCO_SAP Sap,
    IN NDIS_HANDLE NdisSapHandle,
    OUT PNDIS_HANDLE CallMgrSapContext );

VOID
RegisterSapPassive(
    IN NDIS_WORK_ITEM* pWork,
    IN VOID* pContext );

NDIS_STATUS
PtiCmDeregisterSap(
    NDIS_HANDLE CallMgrSapContext );

VOID
DeregisterSapPassive(
    IN NDIS_WORK_ITEM* pWork,
    IN VOID* pContext );

NDIS_STATUS
PtiCmCreateVc(
    IN NDIS_HANDLE ProtocolAfContext,
    IN NDIS_HANDLE NdisVcHandle,
    OUT PNDIS_HANDLE ProtocolVcContext );

NDIS_STATUS
PtiCmDeleteVc(
    IN NDIS_HANDLE ProtocolVcContext );

NDIS_STATUS
PtiCmMakeCall(
    IN NDIS_HANDLE CallMgrVcContext,
    IN OUT PCO_CALL_PARAMETERS CallParameters,
    IN NDIS_HANDLE NdisPartyHandle,
    OUT PNDIS_HANDLE CallMgrPartyContext );

VOID
MakeCallPassive(
    IN NDIS_WORK_ITEM* pWork,
    IN VOID* pContext );

NDIS_STATUS
PtiCmCloseCall(
    IN NDIS_HANDLE CallMgrVcContext,
    IN NDIS_HANDLE CallMgrPartyContext,
    IN PVOID CloseData,
    IN UINT Size );

VOID
PtiCmIncomingCallComplete(
    IN NDIS_STATUS Status,
    IN NDIS_HANDLE CallMgrVcContext,
    IN PCO_CALL_PARAMETERS CallParameters );

VOID
PtiCmActivateVcComplete(
    IN NDIS_STATUS Status,
    IN NDIS_HANDLE CallMgrVcContext,
    IN PCO_CALL_PARAMETERS CallParameters );

VOID
PtiCmDeactivateVcComplete(
    IN NDIS_STATUS Status,
    IN NDIS_HANDLE CallMgrVcContext );

NDIS_STATUS
PtiCmModifyCallQoS(
    IN NDIS_HANDLE CallMgrVcContext,
    IN PCO_CALL_PARAMETERS CallParameters );

NDIS_STATUS
PtiCmRequest(
    IN NDIS_HANDLE CallMgrAfContext,
    IN NDIS_HANDLE CallMgrVcContext,
    IN NDIS_HANDLE CallMgrPartyContext,
    IN OUT PNDIS_REQUEST NdisRequest );

NDIS_STATUS
PtiInit(
    OUT PNDIS_STATUS OpenErrorStatus,
    OUT PUINT SelectedMediumIndex,
    IN PNDIS_MEDIUM MediumArray,
    IN UINT MediumArraySize,
    IN NDIS_HANDLE MiniportAdapterHandle,
    IN NDIS_HANDLE WrapperConfigurationContext );

VOID
PtiHalt(
    IN NDIS_HANDLE MiniportAdapterContext );

NDIS_STATUS
PtiReset(
    OUT PBOOLEAN AddressingReset,
    IN NDIS_HANDLE MiniportAdapterContext );

VOID
PtiReturnPacket(
    IN NDIS_HANDLE MiniportAdapterContext,
    IN PNDIS_PACKET Packet );

NDIS_STATUS
PtiQueryInformation(
    IN NDIS_HANDLE MiniportAdapterContext,
    IN NDIS_OID Oid,
    IN PVOID InformationBuffer,
    IN ULONG InformationBufferLength,
    OUT PULONG BytesWritten,
    OUT PULONG BytesNeeded );

NDIS_STATUS
PtiSetInformation(
    IN NDIS_HANDLE MiniportAdapterContext,
    IN NDIS_OID Oid,
    IN PVOID InformationBuffer,
    IN ULONG InformationBufferLength,
    OUT PULONG BytesRead,
    OUT PULONG BytesNeeded );

NDIS_STATUS
PtiCoActivateVc(
    IN NDIS_HANDLE MiniportVcContext,
    IN OUT PCO_CALL_PARAMETERS CallParameters );

NDIS_STATUS
PtiCoDeactivateVc(
    IN NDIS_HANDLE MiniportVcContext );

VOID
PtiCoSendPackets(
    IN NDIS_HANDLE MiniportVcContext,
    IN PPNDIS_PACKET PacketArray,
    IN UINT NumberOfPackets );

NDIS_STATUS
PtiCoRequest(
    IN NDIS_HANDLE MiniportAdapterContext,
    IN NDIS_HANDLE MiniportVcContext,
    IN OUT PNDIS_REQUEST NdisRequest );

VOID
PtiReceive(
    IN VOID* pAddress,
    IN CHAR* pBuffer,
    IN ULONG ulOffset,
    IN ULONG ulBufferLen );

ULONG
ReadFlags(
    IN ULONG* pulFlags );

VOID
ReferenceAdapter(
    IN ADAPTERCB* pAdapter );

VOID
ReferenceAf(
    IN ADAPTERCB* pAdapter );

BOOLEAN
ReferenceCall(
    IN VCCB* pVc );

BOOLEAN
ReferenceSap(
    IN ADAPTERCB* pAdapter );

VOID
ReferenceVc(
    IN VCCB* pVc );

NDIS_STATUS
ScheduleWork(
    IN ADAPTERCB* pAdapter,
    IN NDIS_PROC pProc,
    IN PVOID pContext );

VOID
SendClientString(
    IN PVOID pPtiExtension );

VOID
SetFlags(
    IN OUT ULONG* pulFlags,
    IN ULONG ulMask );

VOID
SetupVcAsynchronously(
    IN ADAPTERCB* pAdapter );

ULONG
StrCmp(
    IN LPSTR cs,
    IN LPSTR ct,
    ULONG n );

ULONG
StrCmpW(
    IN WCHAR* psz1,
    IN WCHAR* psz2 );

VOID
StrCpyW(
    IN WCHAR* psz1,
    IN WCHAR* psz2 );

CHAR*
StrDup(
    IN CHAR* psz );

CHAR*
StrDupNdisString(
    IN NDIS_STRING* pNdisString );

CHAR*
StrDupSized(
    IN CHAR* psz,
    IN ULONG ulLength,
    IN ULONG ulExtra );

ULONG
StrLenW(
    IN WCHAR* psz );

#endif // _PTIWAN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\raspti\ppool.c ===
// Copyright (c) 1997, Microsoft Corporation, all rights reserved
//
// ppool.c
// RAS L2TP WAN mini-port/call-manager driver
// Packet pool management routines
//
// 01/07/97 Steve Cobb, adapted from Gurdeep's WANARP code.


#include "ptiwan.h"


//-----------------------------------------------------------------------------
// Local prototypes (alphabetically)
//-----------------------------------------------------------------------------

PACKETHEAD*
AddPacketBlockToPool(
    IN PACKETPOOL* pPool );

VOID
FreeUnusedPacketPoolBlocks(
    IN PACKETPOOL* pPool );


//-----------------------------------------------------------------------------
// Interface routines
//-----------------------------------------------------------------------------

VOID
InitPacketPool(
    OUT PACKETPOOL* pPool,
    IN ULONG ulProtocolReservedLength,
    IN ULONG ulMaxPackets,
    IN ULONG ulPacketsPerBlock,
    IN ULONG ulFreesPerCollection,
    IN ULONG ulTag )

    // Initialize caller's packet pool control block 'pPool'.
    // 'UlProtocolReservedLength' is the size in bytes of the
    // 'ProtocolReserved' array of each individual packet.  'UlMaxPackets' is
    // the maximum number of packets allowed in the entire pool, or 0 for
    // unlimited.  'UlPacketsPerBlock' is the number of packets to include in
    // each block of packets.  'UlFreesPerCollection' is the number of
    // FreePacketToPool calls until the next garbage collect scan, or 0 for
    // default.  'UlTag' is the memory identification tag to use when
    // allocating blocks.
    //
    // IMPORTANT: Caller's 'pPool' packet must be protected from multiple
    //            access during this call.
    //
{
    pPool->ulProtocolReservedLength = ulProtocolReservedLength;
    pPool->ulPacketsPerBlock = ulPacketsPerBlock;
    pPool->ulMaxPackets = ulMaxPackets;
    pPool->ulFreesSinceCollection = 0;
    pPool->ulTag = ulTag;

    if (ulFreesPerCollection)
    {
        pPool->ulFreesPerCollection = ulFreesPerCollection;
    }
    else
    {
        // Calculate default garbage collection trigger.  Don't want to be too
        // aggressive here.
        //
        pPool->ulFreesPerCollection = 50 * pPool->ulPacketsPerBlock;
    }

    TRACE( TL_N, TM_Pool, ( "InitPp tag=$%08x pr=%d cnt=%d",
        pPool->ulTag,
        pPool->ulProtocolReservedLength,
        pPool->ulPacketsPerBlock ) );

    InitializeListHead( &pPool->listBlocks );
    InitializeListHead( &pPool->listFreePackets );
    NdisAllocateSpinLock( &pPool->lock );
}


BOOLEAN
FreePacketPool(
    IN PACKETPOOL* pPool )

    // Free up all resources allocated in packet pool 'pPool'.  This is the
    // inverse of InitPacketPool.
    //
    // Returns true if successful, false if any of the pool could not be freed
    // due to outstanding packets.
    //
{
    BOOLEAN fSuccess;

    TRACE( TL_N, TM_Pool, ( "FreePp" ) );

    NdisAcquireSpinLock( &pPool->lock );
    {
        FreeUnusedPacketPoolBlocks( pPool );
        fSuccess = (pPool->ulCurPackets == 0);
    }
    NdisReleaseSpinLock( &pPool->lock );

    return fSuccess;
}


NDIS_PACKET*
GetPacketFromPool(
    IN PACKETPOOL* pPool,
    OUT PACKETHEAD** ppHead )

    // Returns the address of the NDIS_PACKET descriptor allocated from the
    // pool 'pPool'.  The pool is expanded, if necessary, but caller should
    // still check for NULL return since the pool may have been at maximum
    // size.  'PpHead' is the "cookie" that is used to return the packet to
    // the pool (see FreePacketToPool).  Caller would normally stash this
    // value in the appropriate 'reserved' areas of the packet for retrieval
    // later.
    //
{
    LIST_ENTRY* pLink;
    PACKETHEAD* pHead;
    NDIS_PACKET* pPacket;

    NdisAcquireSpinLock( &pPool->lock );
    {
        if (IsListEmpty( &pPool->listFreePackets ))
        {
            pLink = NULL;
        }
        else
        {
            pLink = RemoveHeadList( &pPool->listFreePackets );
            pHead = CONTAINING_RECORD( pLink, PACKETHEAD, linkFreePackets );
            --pHead->pBlock->ulFreePackets;
        }
    }
    NdisReleaseSpinLock( &pPool->lock );

    if (!pLink)
    {
        // The free list was empty.  Try to expand the pool.
        //
        pHead = AddPacketBlockToPool( pPool );
        if (!pHead)
        {
            TRACE( TL_A, TM_Pool, ( "GetPfP failed?" ) );
            return NULL;
        }
    }

    TRACE( TL_N, TM_Pool,
        ( "GetPfP=$%p/h=$%p, %d free",
        pHead->pNdisPacket, pHead, pHead->pBlock->ulFreePackets ) );

    *ppHead = pHead;
    return pHead->pNdisPacket;
}


VOID
FreePacketToPool(
    IN PACKETPOOL* pPool,
    IN PACKETHEAD* pHead,
    IN BOOLEAN fGarbageCollection )

    // Returns 'pPacket' to the pool of unused packets 'pPool'.  'PPacket'
    // must have been previously allocated with GetPacketFromPool.
    // 'FGarbageCollection' is set when the free should be considered for
    // purposes of garbage collection.  This is used by the AddPacketToPool
    // routine to avoid counting the initial "add" frees.  Normal callers
    // should set this flag.
    //
{
    DBG_if (fGarbageCollection)
    {
        TRACE( TL_N, TM_Pool,
            ( "FreePtoP($%p,h=$%p) %d free",
            pHead->pNdisPacket, pHead, pHead->pBlock->ulFreePackets ) );
    }

    NdisAcquireSpinLock( &pPool->lock );
    {
        InsertHeadList( &pPool->listFreePackets, &pHead->linkFreePackets );
        ++pHead->pBlock->ulFreePackets;

        if (fGarbageCollection)
        {
            ++pPool->ulFreesSinceCollection;

            if (pPool->ulFreesSinceCollection >= pPool->ulFreesPerCollection)
            {
                // Time to collect garbage, i.e. free any blocks in the pool
                // not in use.
                //
                FreeUnusedPacketPoolBlocks( pPool );
                pPool->ulFreesSinceCollection = 0;
            }
        }
    }
    NdisReleaseSpinLock( &pPool->lock );
}


//-----------------------------------------------------------------------------
// Utility routines (alphabetically)
//-----------------------------------------------------------------------------

PACKETHEAD*
AddPacketBlockToPool(
    IN PACKETPOOL* pPool )

    // Allocate a new packet block and add it to the packet pool 'pPool'.
    //
    // Returns the PACKETHEAD allocated from the pool or NULL if none.
    //
{
    NDIS_STATUS status;
    PACKETBLOCKHEAD* pNew;
    ULONG ulSize;
    ULONG ulCount;
    BOOLEAN fOk;
    PACKETHEAD* pReturn;

    TRACE( TL_A, TM_Pool, ( "AddPpBlock(%d+%d)",
        pPool->ulCurPackets, pPool->ulPacketsPerBlock ) );

    fOk = FALSE;
    pNew = NULL;

    NdisAcquireSpinLock( &pPool->lock );
    {
        do
        {
            if (pPool->ulMaxPackets
                && pPool->ulCurPackets >= pPool->ulMaxPackets)
            {
                // No can do.  The pool's already at maximum size.
                //
                TRACE( TL_A, TM_Pool, ( "Pp maxed?" ) );
                break;
            }

            // Calculate the contiguous block's size and the number of packets
            // it will hold.
            //
            ulCount = pPool->ulPacketsPerBlock;
            if (pPool->ulMaxPackets)
            {
                if (ulCount > pPool->ulMaxPackets - pPool->ulCurPackets)
                    ulCount = pPool->ulMaxPackets - pPool->ulCurPackets;
            }
            ulSize = sizeof(PACKETBLOCKHEAD) + (ulCount * sizeof(PACKETHEAD));

            // Allocate the contiguous memory block for the PACKETBLOCK header
            // and the individual PACKETHEADs.
            //
            pNew = ALLOC_NONPAGED( ulSize, pPool->ulTag );
            if (!pNew)
            {
                TRACE( TL_A, TM_Pool, ( "Alloc PB?") );
                break;
            }

            /* Zero only the block header portion.
            */
            NdisZeroMemory( pNew, sizeof(PACKETBLOCKHEAD) );

            // Allocate a pool of NDIS_PACKET descriptors.
            //
            NdisAllocatePacketPool(
                &status,
                &pNew->hNdisPool,
                ulCount,
                pPool->ulProtocolReservedLength );

            if (status != NDIS_STATUS_SUCCESS)
            {
                TRACE( TL_A, TM_Pool, ( "AllocPp=$%p?", status ) );
                break;
            }

            // Fill in the back pointer to the pool.
            //
            pNew->pPool = pPool;

            // Link the new block.  At this point, all the packets are
            // effectively "in use".  They are made available in the loop
            // below.
            //
            pNew->ulPackets = ulCount;
            pPool->ulCurPackets += ulCount;
            InsertHeadList( &pPool->listBlocks, &pNew->linkBlocks );

            fOk = TRUE;
        }
        while (FALSE);
    }
    NdisReleaseSpinLock( &pPool->lock );

    if (!fOk)
    {
        // Bailing, undo whatever succeeded.
        //
        if (pNew)
        {
            FREE_NONPAGED( pNew );
            if (pNew->hNdisPool)
            {
                NdisFreePacketPool( pNew->hNdisPool );
            }
        }

        return NULL;
    }

    // Initialize each individual packet header and add it to the list of free
    // packets.
    //
    {
        ULONG i;
        PACKETHEAD* pHead;

        pReturn = NULL;

        // For each PACKETHEAD of the block...
        //
        for (i = 0, pHead = (PACKETHEAD* )(pNew + 1);
             i < ulCount;
             ++i, ++pHead)
        {
            InitializeListHead( &pHead->linkFreePackets );
            pHead->pBlock = pNew;
            pHead->pNdisPacket = NULL;

            // Associate an NDIS_PACKET descriptor from the pool we
            // allocated above.
            //
            NdisAllocatePacket( &status, &pHead->pNdisPacket, pNew->hNdisPool );

            if (status != NDIS_STATUS_SUCCESS)
            {
                TRACE( TL_A, TM_Pool, ( "AllocP=$%p?", status ) );
                continue;
            }

            if (pReturn)
            {
                // Add the constructed packet to the list of free packets.
                // The 'FALSE' tells the garbage collection algorithm the
                // operation is an "add" rather than a "release" and should be
                // ignored.
                //
                FreePacketToPool( pPool, pHead, FALSE );
            }
            else
            {
                // The first successfully constructed packet is returned by
                // this routine.
                //
                pReturn = pHead;
            }
        }
    }

    return pReturn;
}


VOID
FreeUnusedPacketPoolBlocks(
    IN PACKETPOOL* pPool )

    // Check if any of the blocks in pool 'pPool' are not in use, and if so,
    // free them.
    //
    // IMPORTANT: Caller must hold the pool lock.
    //
    // NOTE: The MSDN doc says that no locks may be held while calling
    // NdisFreePacketXxx, but according to JameelH that is incorrect.
    //
{
    LIST_ENTRY* pLink;

    TRACE( TL_A, TM_Pool, ( "FreeUnusedPpBlocks" ) );

    // For each block in the pool...
    //
    pLink = pPool->listBlocks.Flink;
    while (pLink != &pPool->listBlocks)
    {
        LIST_ENTRY* pLinkNext;
        PACKETBLOCKHEAD* pBlock;

        pLinkNext = pLink->Flink;

        pBlock = CONTAINING_RECORD( pLink, PACKETBLOCKHEAD, linkBlocks );
        if (pBlock->ulFreePackets >= pBlock->ulPackets)
        {

#if 1 // Assume all buffers are free at time of call.

            ULONG i;
            PACKETHEAD* pHead;

            TRACE( TL_A, TM_Pool, ( "FreePpBlock(%d-%d)",
                pPool->ulCurPackets, pPool->ulPacketsPerBlock ) );

            // Found a block with no packets in use.  Walk the packet block
            // removing each packet from the pool's free list and freeing any
            // associated NDIS_PACKET descriptor.
            //
            for (i = 0, pHead = (PACKETHEAD* )(pBlock + 1);
                 i < pBlock->ulPackets;
                 ++i, ++pHead)
            {
                RemoveEntryList( &pHead->linkFreePackets );

                if (pHead->pNdisPacket)
                {
                    NdisFreePacket( pHead->pNdisPacket );
                }
            }

#else  // Assume some buffers may not be free at time of call.

            LIST_ENTRY* pLink2;

            // Found a block with no packets in use.  Walk the pool's free
            // list looking for buffers from this block.
            //
            TRACE( TL_A, TM_Pool, ( "FreePpBlock(%d-%d)",
                pPool->ulCurPackets, pPool->ulPacketsPerBlock ) );

            pLink2 = pPool->listFreePackets.Flink;
            while (pLink2 != &pPool->listFreePackets)
            {
                LIST_ENTRY* pLink2Next;
                PACKETHEAD* pHead;

                pLink2Next = pLink2->Flink;

                pHead = CONTAINING_RECORD( pLink2, PACKETHEAD, linkFreePackets );
                if (pHead->pBlock == pBlock)
                {
                    // Found a packet from the unused block.  Remove it.
                    //
                    RemoveEntryList( pLink2 );
                    --pBlock->ulFreePackets;

                    if (pHead->pNdisPacket)
                    {
                        NdisFreePacket( pHead->pNdisPacket );
                    }
                }
            }

            ASSERT( pBlock->ulFreePackets == 0 );
#endif

            // Remove and release the unused block.
            //
            RemoveEntryList( pLink );
            pPool->ulCurPackets -= pBlock->ulPackets;

            if (pBlock->hNdisPool)
            {
                NdisFreePacketPool( pBlock->hNdisPool );
            }

            FREE_NONPAGED( pBlock );
        }

        pLink = pLinkNext;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\raspti\util.c ===
// Copyright (c) 1997, Microsoft Corporation, all rights reserved
// Copyright (c) 1997, Parallel Technologies, Inc., all rights reserved
//
// util.c
// DirectParallel WAN mini-port/call-manager driver
// General utility routines
//
// 01/07/97 Steve Cobb
// 09/15/97 Jay Lowe, Parallel Technologies, Inc.

#include "ptiwan.h"


//-----------------------------------------------------------------------------
// Local prototypes (alphabetically)
//-----------------------------------------------------------------------------

ULONG
atoul(
    IN CHAR* pszNumber );

VOID
ReversePsz(
    IN OUT CHAR* psz );

VOID
ultoa(
    IN ULONG ul,
    OUT CHAR* pszBuf );


//-----------------------------------------------------------------------------
// General utility routines (alphabetically)
//-----------------------------------------------------------------------------


VOID
ClearFlags(
    IN OUT ULONG* pulFlags,
    IN ULONG ulMask )

    // Set 'ulMask' bits in '*pulFlags' flags as an interlocked operation.
    //
{
    ULONG ulFlags;
    ULONG ulNewFlags;

    do
    {
        ulFlags = ReadFlags( pulFlags );
        ulNewFlags = ulFlags & ~(ulMask);
    }
    while (InterlockedCompareExchange(
               pulFlags, ulNewFlags, ulFlags ) != (LONG)ulFlags);
}

VOID
IndicateLinkStatus(
    IN VCCB* pVc )

    // Indicate new WAN_CO_LINKPARAMS settings for 'pVc' to NDISWAN.
    //
{
    ADAPTERCB* pAdapter;
    WAN_CO_LINKPARAMS params;

    pAdapter = pVc->pAdapter;

    params.TransmitSpeed = pVc->ulConnectBps;
    params.ReceiveSpeed = params.TransmitSpeed;
    params.SendWindow = 1;
    TRACE( TL_N, TM_Mp, ( "NdisMCoIndStatus(LINK) cid=%d bps=%d sw=%d",
        pVc->usCallId, params.TransmitSpeed, params.SendWindow ) );
    NdisMCoIndicateStatus(
        pAdapter->MiniportAdapterHandle,
        pVc->NdisVcHandle,
        NDIS_STATUS_WAN_CO_LINKPARAMS,
        &params,
        sizeof(params) );
    TRACE( TL_N, TM_Mp, ( "NdisMCoIndStatus done" ) );
}

ULONG
ReadFlags(
    IN ULONG* pulFlags )

    // Read the value of '*pulFlags' as an interlocked operation.
    //
{
    return InterlockedExchangeAdd( pulFlags, 0 );
}


NDIS_STATUS
ScheduleWork(
    IN ADAPTERCB* pAdapter,
    IN NDIS_PROC pProc,
    IN PVOID pContext )

    // Schedules a PASSIVE IRQL callback to routine 'pProc' which will be
    // passed 'pContext'.  'PAdapter' is the adapter control block from which
    // the work item is allocated.  This routine takes an adapter reference
    // that should be removed by the called 'pProc'.
    //
    // Returns NDIS_STATUS_SUCCESS or an error code.
    //
{
    NDIS_STATUS status;
    NDIS_WORK_ITEM* pWork;

    pWork = ALLOC_NDIS_WORK_ITEM( pAdapter );
    if (!pWork)
    {
        ASSERT( !"Alloc work?" );
        return NDIS_STATUS_RESOURCES;
    }

    NdisInitializeWorkItem( pWork, pProc, pContext );

    ReferenceAdapter( pAdapter );
    status = NdisScheduleWorkItem( pWork );
    if (status != NDIS_STATUS_SUCCESS)
    {
        ASSERT( !"SchedWork?" );
        FREE_NDIS_WORK_ITEM( pAdapter, pWork );
        DereferenceAdapter( pAdapter );
    }

    return status;
}


VOID
SetFlags(
    IN OUT ULONG* pulFlags,
    IN ULONG ulMask )

    // Set 'ulMask' bits in '*pulFlags' flags as an interlocked operation.
    //
{
    ULONG ulFlags;
    ULONG ulNewFlags;

    do
    {
        ulFlags = ReadFlags( pulFlags );
        ulNewFlags = ulFlags | ulMask;
    }
    while (InterlockedCompareExchange(
               pulFlags, ulNewFlags, ulFlags ) != (LONG )ulFlags);
}


ULONG
StrCmp(
    IN LPSTR cs,
    IN LPSTR ct,
    ULONG n 
)
	// Return 0 if string cs = string ct for length n
    //
{
    char ret=0;

    while (n--)
    {
        ret = *cs - *ct;

        if (ret)
            break;

        cs++;
        ct++;
    }

    return (ULONG)ret;
}


ULONG
StrCmpW(
    IN WCHAR* psz1,
    IN WCHAR* psz2 )

	// Returns 0 if 'psz1' matches 'psz2'.
    //
{
    WCHAR pch;

    pch = (WCHAR )0;
    while (*psz1 && *psz2)
    {
        pch = *psz1 - *psz2;
        if (pch)
        {
            break;
        }

        psz1++;
        psz2++;
    }

    return (ULONG )pch;
}


VOID
StrCpyW(
    IN WCHAR* psz1,
    IN WCHAR* psz2 )

	// Copies 'psz2' to 'psz1'.
    //
{
    while (*psz2)
    {
        *psz1++ = *psz2++;
    }

    *psz1 = L'\0';
}


CHAR*
StrDup(
    IN CHAR* psz )

    // Return a duplicate of 'psz'.  Caller must eventually call FREE_NONPAGED
    // on the returned string.
    //
{
    return StrDupSized( psz, strlen( psz ), 0 );
}


CHAR*
StrDupNdisString(
    IN NDIS_STRING* pNdisString )

    // Returns null-terminated ASCII copy of the NDIS_STRING 'pNdisString'
    // Caller must eventually call FREE_NONPAGED on the returned string.
    //
{
    CHAR* pszDup;

    pszDup = ALLOC_NONPAGED( pNdisString->Length + 1, MTAG_UTIL );
    if (pszDup)
    {
        NdisZeroMemory( pszDup, pNdisString->Length + 1 );
        if (pNdisString->Length)
        {
            NdisMoveMemory( pszDup, pNdisString->Buffer, pNdisString->Length );
        }

        // NDIS_STRING is UNICODE_STRING on NT but need the corresponding
        // ASCII (not multi-byte ANSI) value from NDIS_STRING on any system.
        // If it looks like a Unicode string then "convert" it by picking out
        // every other byte, hopefully all the non-zero ones.  This is not
        // foolproof, but then Unicode doesn't convert to ASCII in any
        // foolproof way.
        //
        if (pNdisString->Length > 1 && pszDup[ 1 ] == '\0')
        {
            USHORT i;

            for (i = 0; i * 2 < pNdisString->Length; ++i)
            {
                pszDup[ i ] = pszDup[ i * 2 ];
            }

            pszDup[ i ] = '\0';
        }
    }

    return pszDup;
}


CHAR*
StrDupSized(
    IN CHAR* psz,
    IN ULONG ulLength,
    IN ULONG ulExtra )

    // Return a duplicate of the first 'ulLength' bytes of 'psz' followed by a
    // null character and 'ulExtra' extra bytes, or NULL on error.  Caller
    // must eventually call FREE_NONPAGED on the returned string.
    //
{
    CHAR* pszDup;

    pszDup = ALLOC_NONPAGED( ulLength + 1 + ulExtra, MTAG_UTIL );
    if (pszDup)
    {
        if (ulLength)
        {
            NdisMoveMemory( pszDup, psz, ulLength );
        }
        pszDup[ ulLength ] = '\0';
    }

    return pszDup;
}


ULONG
StrLenW(
    IN WCHAR* psz )

    // Returns number of characters in a null-terminated Unicode string.
    //
{
    ULONG ul;

    ul = 0;
    while (*psz++)
    {
        ++ul;
    }

    return ul;
}


//-----------------------------------------------------------------------------
// Local utility routines (alphabetically)
//-----------------------------------------------------------------------------

ULONG
atoul(
    IN CHAR* pszNumber )

    // Convert string of digits 'pszNumber' to it's ULONG value.
    //
{
    ULONG ulResult;

    ulResult = 0;
    while (*pszNumber && *pszNumber >= '0' && *pszNumber <= '9')
    {
        ulResult *= 10;
    ulResult += *pszNumber - '0';
    ++pszNumber;
    }

    return ulResult;
}


VOID
ReversePsz(
    IN OUT CHAR* psz )

    // Reverse the order of the characters in 'psz' in place.
    //
{
    CHAR* pchLeft;
    CHAR* pchRight;

    pchLeft = psz;
    pchRight = psz + strlen( psz ) - 1;

    while (pchLeft < pchRight)
    {
        CHAR ch;

        ch = *pchLeft;
        *pchLeft = *pchRight;
        *pchRight = *pchLeft;
    }
}


#if 0
VOID
ultoa(
    IN ULONG ul,
    OUT CHAR* pszBuf )

    // Convert 'ul' to null-terminated string form in caller's 'pszBuf'.
    //
{
    CHAR* pch;

    pch = pszBuf;
    do
    {
        *pch++ = (CHAR )((ul % 10) + '0');
        ul /= 10;
    }
    while (ul);
    *pch = '\0';

    ReversePsz( pszBuf );
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\raspti\ptilink.h ===
/*++

Copyright (c) 1995  Microsoft Corporation
Copyright (c) 1997  Parallel Technologies, Inc.  All Rights Reserved.

Module Name:

    ptilink.h

Abstract:

    This file defines the interface for the Parallel Technologies
    DirectParallel IO driver.

    This driver doubles as an NT device driver and an export library.

Author:

    Norbert P. Kusters  4-Jan-1995
    Jay Lowe, Parallel Technologies, Inc.

Revision History:

--*/

#ifndef _PTILINK_
#define _PTILINK_

#define NPORTS  3                           // number of PTILINKx devices to make
#define MAXLPTXNAME 99

typedef struct _PTI_EXTENSION PTI_EXTENSION;

//
// This structure contains configuration data, much of which
// is read from the registry.
//
typedef struct _PAR_REG_DATA {
    ULONG           PollInterval;
    ULONG           TraceLevel;
    ULONG           TraceMask;
    ULONG           IoWait;
    ULONG           SyncWait;
} PAR_REG_DATA,*PPAR_REG_DATA;

//
//  Client callbacks from PtiLink
//

// Ptilink requests a read buffer from the upward client

typedef
PVOID
(*GET_READ_BUFFER_ROUTINE)(
    IN  PVOID   ParentContext,
    OUT PULONG  BufferSize,
    OUT PVOID*  RequestContext
    );

// Ptilink returns a completed read buffer to the upward client

typedef
VOID
(*COMPLETE_READ_BUFFER_ROUTINE)(
    IN  PVOID       ParentContext,
    IN  PVOID       ReadBuffer,
    IN  NTSTATUS    Status,
    IN  ULONG       BytesTransfered,
    IN  PVOID       RequestContext
    );

// PtiLink notifies upward client of a link event

typedef
VOID
(*NOTIFY_LINK_EVENT)(
    IN  PVOID       ParentContext,
    IN  ULONG       PtiLinkEventId,
    IN  ULONG       PtiLinkEventData
    );

// PtilinkEventIds

#define PTILINK_LINK_UP     2           // link has been established
                                        //   a LINK_OPEN or dataframe
                                        //   was received on SHUT link
                                        //   i.e., link is starting

#define PTILINK_LINK_DOWN   4           // link has been terminated
                                        //   peer has issued a LINK_SHUT
                                        //   and is departing

//
//  Device driver routines ... are of the form ParXXXXXX
//

BOOLEAN
ParInterruptService(
    IN      PKINTERRUPT Interrupt,
    IN OUT  PVOID       Extension
    );

VOID
ParDpcForIsr(
    IN  PKDPC           Dpc,
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           Extension
    );

VOID
ParDeferredPortCheck(
    IN  PVOID   Extension
    );

VOID
ParAllocTimerDpc(
    IN  PKDPC   Dpc,
    IN  PVOID   Extension,
    IN  PVOID   SystemArgument1,
    IN  PVOID   SystemArgument2
    );

NTSTATUS
ParCreate(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    );

NTSTATUS
ParClose(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    );

NTSTATUS
ParRead(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    );

PVOID
ParGetReadBuffer(
    IN  PVOID   ParentContext,
    OUT PULONG  BufferSize,
    OUT PVOID*  RequestContext
    );

VOID
ParCompleteReadBuffer(
    IN  PVOID       ParentContext,
    IN  PVOID       ReadBuffer,
    IN  NTSTATUS    Status,
    IN  ULONG       BytesTransfered,
    IN  PVOID       RequestContext
    );

VOID
ParLinkEventNotification(
    IN  PVOID       ParentContext,
    IN  ULONG       PtiLinkEventId,
    IN  ULONG       PtiLinkEventData
    );

NTSTATUS
ParWrite(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    );

NTSTATUS
ParCleanup(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    );

VOID
ParUnload(
    IN  PDRIVER_OBJECT  DriverObject
    );


//
//  Link Level Routines ... are of the form PtiXXXXXX
//

NTSTATUS
PtiInitialize(
    IN  ULONG   PortId,
    OUT PVOID   pExtension,
    OUT PVOID   pPtiExtension
    );

//
// a word about registering callbacks: Par (the device driver level)
// registers callbacks to itself at ParCreate time.  If you are using
// the Ptilink service API in a non-irp fashion, you need to open the
// Ptilink device, and then re-register your own callbacks, which
// effectively disconnects the Par device driver level - it will be
// reconnected, of course, at the next ParCreate.
//
// So the sequence to use the PtiLink API without IRP's is:
//
//      ZwCreateFile("\\\\.\\PTILINKx", ...)
//          at this time, Ptilink attempts tp make a link on LPTx
//          the ParCreate hooks up interrupts, calls PtiInit, etc
//          the only Ptilink stuff exposed to you are the callbacks
//
//      PtiRegisterCallbacks(...your handlers here...)
//          you are overriding the inherent callbacks of the Par level
//
//      PtiWrite(...)
//      ...
//      ... etc, etc ...
//      ...
//
//      ZwClose()
//

#ifndef PID_STANDARD
#define PID_STANDARD 0x13
#endif
#ifndef PID_LINK
#define PID_LINK 0x11
#endif

NTSTATUS
PtiQueryDeviceStatus(
    IN ULONG PortId,      // parallel port number (0..2)
    OUT WCHAR* szPortName  // Buffer of at least LPTXMAXNAME + 1 bytes
    );

NTSTATUS
PtiRegisterCallbacks(
    IN  PVOID                           Extension,
    IN  GET_READ_BUFFER_ROUTINE         GetReadBuffer,
    IN  COMPLETE_READ_BUFFER_ROUTINE    CompleteReadBuffer,
    IN  NOTIFY_LINK_EVENT               LinkEventNotification,
    IN  PVOID                           ParentContext
    );

VOID
PtiCleanup(
    IN  PVOID   PtiExtension
    );

NTSTATUS
PtiWrite(
    IN  PVOID   PtiExtension,
    IN  PVOID   Buffer,
    IN  ULONG   BufferSize,
    IN  UCHAR   Pid
    );

BOOLEAN
PtiIsReadPending(
    IN  PVOID   PtiExtension
    );

VOID
PtiRead(
    IN  PVOID   PtiExtension
    );

ULONG
PtiQueryMaxReadSize(
    );

VOID
PtiPortNameFromPortId(
    IN ULONG PortId,
    OUT CHAR* szPortName
    );

//************************************************************************
//*  Platform Id Codes                                                   *
//************************************************************************

#define PLAT_WIN9X      0               // Win95 and Win98
#define PLAT_DOS        1               // Dos
#define PLAT_NT         2               // WinNT v4 and v5

//************************************************************************
//*  LinkInformation Structure                                           *
//************************************************************************
//
// LinkInformation - Link Management Information
//
// This structure contains information which is exchanged by the Nodes
// within Link Management Packets
//
// This structure must be maintained in parallel with it's twin in PTI.INC
//
// All changes must be backward compatible with all previous driver versions

#define LINKINFOSIZE 45*4           // explicitly define expected size

typedef struct _LINK_INFORMATION {
    UCHAR   LinkFunction;           // 1] Current/Last Link Function
    UCHAR   res1;
    UCHAR   res2;
    UCHAR   res3;

    UCHAR   VerPlat;                // 2] Platform ID byte (see PLAT_XXXX)
    UCHAR   VerReserved;            // reserved
    UCHAR   VerMajor;               // Link Major version
    UCHAR   VerMinor;               // Link Minor version

    UCHAR   IOMode;                 // 3] Current IO transfer mode
    UCHAR   CableType;              // Detected cable type
    UCHAR   PortType;               // Physical parallel port type
    UCHAR   Station;                // Address of this station

    USHORT  FIFOlen;                // 4] ECP FIFO length, if ECP port
    USHORT  FIFOwidth;              //    ECP FIFO width, if ECP port

    ULONG   CPUType;                // 5] CPU type
    ULONG   CPUSpeed;               // 6] CPU speed rating
    ULONG   RxBufSize;              // 7] Rx buffer size
    ULONG   NominalSpd;             // 8] Estimated speed rating
    ULONG   ActualSpd;              // 9] Actual performance to date

    ULONG   PpIOWait;               // 10] default IO wait time
    ULONG   PpLongWait;             // 11] default synchronization wait time
    ULONG   PpShortWait;            // 12] default synchronization wait time

    ULONG   LastLinkTime;           // 13] time of last link receive activity
    ULONG   CableTestTime;          // 14] time of last cable detect
                                    // These times are not used on NT because
                                    // NT times are 64 bits ... see NT time below

    // some basic counters

    ULONG   RxAttempts;             // 15] Number of Ints w/ real RATTNs
    ULONG   RxPackets;              // 16] Number of good received packets
    ULONG   TxAttempts;             // 17] Number of TxPackets attempted
    ULONG   TxPackets;              // 18] Number of successful TxPackets
    ULONG   GoodPackets;            // 19] Number of successful recent Txs / Rxs
    ULONG   HwIRQs;                 // 20] Number of real hardware IRQs

    // Main Error Counter Group

    ULONG   TxHdrDataErrors;        // 21] data error during header
    ULONG   RxHdrDataErrors;        // 22] data error during header
    ULONG   TxHdrSyncErrors;        // 23] sync error during header
    ULONG   RxHdrSyncErrors;        // 24] sync error during header
    ULONG   TxSyncErrors;           // 25] sync error during packet
    ULONG   RxSyncErrors;           // 26] sync error during packet

    // Tx Details Group

    ULONG   TxTimeoutErrors1;       // 27] timeouts in Tx IO code
    ULONG   TxTimeoutErrors2;       // 28] timeouts in Tx IO code
    ULONG   TxTimeoutErrors3;       // 29] timeouts in Tx IO code
    ULONG   TxTimeoutErrors4;       // 30] timeouts in Tx IO code
    ULONG   TxTimeoutErrors5;       // 31] timeouts in Tx IO code
    ULONG   TxCollision;            // 32] Collision in Tx IO code

    // Rx Details Group

    ULONG   RxTimeoutErrors1;       // 33] timeouts in Rx IO code
    ULONG   RxTimeoutErrors2;       // 34] timeouts in Rx IO code
    ULONG   RxTimeoutErrors3;       // 35] timeouts in Rx IO code
    ULONG   RxTimeoutErrors4;       // 36] timeouts in Rx IO code
    ULONG   RxTimeoutErrors5;       // 37] timeouts in Rx IO code
    ULONG   RxTooBigErrors;         // 38] Rx packet too big or won't fit

    // Misc Error Details Group

    ULONG   CableDetects;           // 39] Attempts to detect type of cable
    ULONG   TxRetries;              // 40] Tx Retry attempts
    ULONG   TxRxPreempts;           // 41] Tx Receive preemptions
    ULONG   InternalErrors;         // 42] Internal screwups
    ULONG   ReservedError;          // 43]

    // NT Specific Group

    TIME    LastPacketTime;         // 45] time of last good TX or Rx

} LINK_INFORMATION, *PLINK_INFORMATION;


//
//  This structure is filled in by ECP detection at PtiInitialize time
//

typedef struct _PTI_ECP_INFORMATION {
    BOOLEAN         IsEcpPort;              // Is this an ECP port?
    ULONG           FifoWidth;              // Number of bytes in a PWord.
    ULONG           FifoDepth;              // Number of PWords in FIFO.
} PTI_ECP_INFORMATION, *PPTI_ECP_INFORMATION;

//
// The internal structure for the 'PtiExtension'.
//

typedef struct _PTI_EXTENSION {

    //
    // Base I/O address for parallel port.
    //

    PUCHAR Port;
    PUCHAR wPortECR;        // ECR register if obtained from ParPort
    PUCHAR wPortDFIFO;      // Data FIFO register if obtained from ParPort

    //
    // The link state
    //

    ULONG LinkState;

    //
    // TRUE if we are polling
    //

    BOOLEAN Polling;

    // "mutex" on the line
    // InterlockedCompareExchange64 to TRUE when using wire, FALSE when done
    //
    ULONG Busy;

    //
    // This structure holds the PTI-derived ECP port information.
    //

    PTI_ECP_INFORMATION EcpInfo;

    // Time of last good packet Tx or Rx
    //
    TIME LastGoodPacket;

    // Time of last pass through WatchDog
    //
    TIME LastDogTime;

    //
    // Functions for getting and completing read buffers.
    //

    GET_READ_BUFFER_ROUTINE GetReadBuffer;
    COMPLETE_READ_BUFFER_ROUTINE CompleteReadBuffer;
    NOTIFY_LINK_EVENT LinkEventNotify;
    PVOID ParentContext;

    //
    // Our and His Link Information.
    //

    LINK_INFORMATION Our;
    LINK_INFORMATION His;

} PTI_EXTENSION, *PPTI_EXTENSION;

#endif // _PTILINK_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\aaaa\aaaaconfig.h ===
//////////////////////////////////////////////////////////////////////////////
//
// Copyright Microsoft Corporation
//
// Module Name:
//
//    aaaaconfig.h
//
//////////////////////////////////////////////////////////////////////////////
#ifndef _AAAACONFIG_H_
#define _AAAACONFIG_H_

#include "datastore2.h"

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

FN_HANDLE_CMD    HandleAaaaConfigSet;
FN_HANDLE_CMD    HandleAaaaConfigShow;

DWORD AaaaConfigDumpConfig(IAS_SHOW_TOKEN_LIST showType);

#ifdef __cplusplus
}
#endif
#endif //_AAAACONFIG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\aaaa\aaaaconfig.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
// Copyright Microsoft Corporation
//
// Module Name:
//
//    aaaaConfig.cpp
//
// Abstract:
//
//    Handlers for aaaa config commands
//
//////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"

#include "strdefs.h"
#include "rmstring.h"
#include "aaaamon.h"
#include "aaaaversion.h"
#include "aaaaconfig.h"
#include "utils.h"
#include "iasdefs.h"
#include "ias.h"

namespace
{
   const wchar_t* const tokenArray[] =
   {
      {TOKEN_VERSION},
      {TOKEN_CONFIG},
      {TOKEN_SERVER_SETTINGS},
      {TOKEN_CLIENTS},
      {TOKEN_CONNECTION_REQUEST_POLICIES},
      {TOKEN_LOGGING},
      {TOKEN_REMOTE_ACCESS_POLICIES},
   };
};

//
//  NOTE since WIN32 errors are assumed to fall in the range -32k to 32k
//  (see comment in winerror.h near HRESULT_FROM_WIN32 definition), we can
//  re-create original Win32 error from low-order 16 bits of HRESULT.
//
#define WIN32_FROM_HRESULT(x) \
    ( (HRESULT_FACILITY(x) == FACILITY_WIN32) ? ((DWORD)((x) & 0x0000FFFF)) : (x) )


//////////////////////////////////////////////////////////////////////////////
//
// Parses the Aaaa set config from the command line
//
//////////////////////////////////////////////////////////////////////////////
DWORD
AaaaConfigParseSetCommandLine(
    IN  PWCHAR              *ppwcArguments,
    IN  DWORD               dwCurrentIndex,
    IN  DWORD               dwArgCount,
    IN  DWORD               dwCmdFlags
                            )

{
   const WCHAR IAS_MDB[]     = L"%SystemRoot%\\System32\\ias\\ias.mdb";
   DWORD dwErr = NO_ERROR;

   static TOKEN_VALUE rgEnumType[] =
   {
      {TOKEN_SERVER_SETTINGS, SERVER_SETTINGS},
      {TOKEN_CLIENTS, CLIENTS},
      {TOKEN_CONNECTION_REQUEST_POLICIES, CONNECTION_REQUEST_POLICIES},
      {TOKEN_LOGGING, LOGGING},
      {TOKEN_REMOTE_ACCESS_POLICIES, REMOTE_ACCESS_POLICIES},
   };

   static AAAAMON_CMD_ARG pArgs[] =
   {
      {
         AAAAMONTR_CMD_TYPE_ENUM,
         {TOKEN_TYPE,    FALSE,   FALSE},
         rgEnumType,
         sizeof(rgEnumType) / sizeof(*rgEnumType),
         NULL
      },
      {
         AAAAMONTR_CMD_TYPE_STRING,
         // tag string, required or not, present or not
         {TOKEN_BLOB, NS_REQ_PRESENT,   FALSE}, //tag_type
         NULL,
         0,
         NULL ,
      },
   };

   wchar_t* blobString = 0;
   do
   {
      // Parse
      //
      dwErr = RutlParse(
                           ppwcArguments,
                           dwCurrentIndex,
                           dwArgCount,
                           NULL,
                           pArgs,
                           sizeof(pArgs) / sizeof(*pArgs));
      if ( dwErr != NO_ERROR )
      {
         break;
      }

      _ASSERT(pBlobString != 0);

      blobString = AAAAMON_CMD_ARG_GetPsz(&pArgs[1]);
      if (!blobString)
      {
         dwErr = ERROR_INVALID_SYNTAX;
         break;
      }

      IAS_SHOW_TOKEN_LIST restoreType;
      DWORD dwordType = (AAAAMON_CMD_ARG_GetDword(&pArgs[0]));
      if (dwordType == -1)
      {
         // optional parameter not set
         restoreType = CONFIG;
      }
      else
      {
         restoreType = (IAS_SHOW_TOKEN_LIST)dwordType;
      }

      // Config
      //
      if ( !pArgs[1].rgTag.bPresent )
      {
         // tag blob not found
         DisplayMessage(g_hModule, MSG_AAAACONFIG_SET_FAIL);
         dwErr = ERROR_INVALID_SYNTAX;
         break;
      }

      // tag blob found
      // Now try to restore the database from the script

      HRESULT hres = IASRestoreConfig(blobString, restoreType);
      if ( FAILED(hres) )
      {
         if (hres != IAS_E_LICENSE_VIOLATION)
         {
            DisplayMessage(g_hModule, MSG_AAAACONFIG_SET_FAIL);
            dwErr = WIN32_FROM_HRESULT(hres);
         }
         else
         {
            DisplayMessage(g_hModule, MSG_AAAACONFIG_LICENSE_VIOLATION);
            dwErr = NO_ERROR;
         }

         break;
      }

      // set config successfull: refresh the service
      hres = RefreshIASService();
      if ( FAILED(hres) )
      {
         ///////////////////////////
         // Refresh should not fail.
         ///////////////////////////
         DisplayMessage(g_hModule, MSG_AAAACONFIG_SET_REFRESH_FAIL);
         dwErr = NO_ERROR;
      }
      else
      {
         DisplayMessage(g_hModule, MSG_AAAACONFIG_SET_SUCCESS);
         dwErr = NO_ERROR;
      }

   } while ( FALSE );

   RutlFree(blobString);

   return dwErr;
}


//////////////////////////////////////////////////////////////////////////////
// Function Name:AaaConfigDumpConfig
//
// Parameters: none
//
// Description: writes the current config (header, content...) to the output
//
// Returns: NO_ERROR or ERROR_SUPPRESS_OUTPUT
//
//////////////////////////////////////////////////////////////////////////////
DWORD AaaaConfigDumpConfig(IAS_SHOW_TOKEN_LIST showType)
{
   const int MAX_SIZE_DISPLAY_LINE  = 80;
   const int SIZE_MAX_STRING        = 512;

   DisplayMessage(g_hModule, MSG_AAAACONFIG_SHOW_HEADER);

   bool bCoInitialized = false;
   do
   {
      HRESULT hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
      if ( FAILED(hr) )
      {
         if ( hr != RPC_E_CHANGED_MODE )
         {
            break;
         }
      }
      else
      {
         bCoInitialized = true;
      }

      LONG lVersion;
      hr = AaaaVersionGetVersion(&lVersion);
      if ( FAILED(hr) )
      {
         DisplayMessage(g_hModule, MSG_AAAACONFIG_SHOW_FAIL);
         break;
      }

      // Sanity check to make sure that the actual database is a Whistler DB
      if ( lVersion != IAS_CURRENT_VERSION )
      {
         DisplayMessage(g_hModule, MSG_AAAACONFIG_SHOW_FAIL);
         break;
      }

      wchar_t sDisplayString[SIZE_MAX_STRING] = L"";
      // This will not create a buffer overrun
      swprintf(
                  sDisplayString,
                  L"# IAS.MDB Version = %d\n",
                  lVersion
               );

      DisplayMessageT(sDisplayString);

      ULONG ulSize;
      wchar_t* pDumpString;
      hr = IASDumpConfig(&pDumpString, &ulSize);

      if ( SUCCEEDED(hr) )
      {
         ULONG RelativePos = 0;
         ULONG CurrentPos = 0;
         wchar_t DisplayLine [MAX_SIZE_DISPLAY_LINE];

         DisplayMessageT(MSG_AAAACONFIG_BLOBBEGIN_A);
         switch (showType)
         {
         case SERVER_SETTINGS:
            {
               DisplayMessageT(MSG_AAAACONFIG_BLOBBEGIN_B);
               DisplayMessageT(TOKEN_SERVER_SETTINGS);
               break;
            }
         case CLIENTS:
            {
               DisplayMessageT(MSG_AAAACONFIG_BLOBBEGIN_B);
               DisplayMessageT(TOKEN_CLIENTS);
               break;
            }
         case CONNECTION_REQUEST_POLICIES:
            {
               DisplayMessageT(MSG_AAAACONFIG_BLOBBEGIN_B);
               DisplayMessageT(TOKEN_CONNECTION_REQUEST_POLICIES);
               break;
            }
         case LOGGING:
            {
               DisplayMessageT(MSG_AAAACONFIG_BLOBBEGIN_B);
               DisplayMessageT(TOKEN_LOGGING);
               break;
            }
         case REMOTE_ACCESS_POLICIES:
            {
               DisplayMessageT(MSG_AAAACONFIG_BLOBBEGIN_B);
               DisplayMessageT(TOKEN_REMOTE_ACCESS_POLICIES);
               break;
            }
         case CONFIG:
         default:
            {
               break;
            }
         }
         DisplayMessageT(MSG_AAAACONFIG_BLOBBEGIN_C);
         while ( CurrentPos <= ulSize )
         {
            wchar_t TempChar = pDumpString[CurrentPos++];
            DisplayLine[RelativePos++] = TempChar;
            if ( TempChar == L'\r' )
            {
               DisplayLine[RelativePos] = L'\0';
               DisplayMessageT(DisplayLine);
               RelativePos = 0;
            }
         }
         DisplayMessageT(L"*");

         free(pDumpString); // was allocated by malloc
         DisplayMessageT(MSG_AAAACONFIG_BLOBEND);

         DisplayMessage(
                           g_hModule,
                           MSG_AAAACONFIG_SHOW_FOOTER
                        );
      }
      else
      {
         DisplayMessage(g_hModule, MSG_AAAACONFIG_SHOW_INVALID_SYNTAX);
         DisplayMessage(g_hModule, HLP_AAAACONFIG_SHOW);
      }
   }
   while (false);

   if (bCoInitialized)
   {
      CoUninitialize();
   }

   return  NO_ERROR;
}


//////////////////////////////////////////////////////////////////////////////
//
// Handles the aaaa config set command
//
//////////////////////////////////////////////////////////////////////////////
DWORD
HandleAaaaConfigSet(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return AaaaConfigParseSetCommandLine(
                                          ppwcArguments,
                                          dwCurrentIndex,
                                          dwArgCount,
                                          dwFlags
                                      );
}

//////////////////////////////////////////////////////////////////////////////
//
// Parses the Aaaa set config from the command line
//
//////////////////////////////////////////////////////////////////////////////
DWORD
AaaaConfigParseShowCommandLine(
    IN  PWCHAR              *ppwcArguments,
    IN  DWORD               dwCurrentIndex,
    IN  DWORD               dwArgCount,
    IN  DWORD               dwCmdFlags
                            )

{
   const size_t arraySize = sizeof(tokenArray)/sizeof(*tokenArray);

   BOOL bFound = FALSE;
   for (DWORD index = 0; index < arraySize; ++index)
   {
      if (MatchToken(ppwcArguments[dwCurrentIndex-1], tokenArray[index]))
      {
         bFound = TRUE;
         break;
      }
   }
   const size_t SIZE_MAX_STRING = 512;
   DWORD dwErr = NO_ERROR;
   if (bFound == TRUE)
   {
      switch (index)
      {
      case VERSION:
         {
            LONG lVersion;
            HRESULT hr = AaaaVersionGetVersion(&lVersion);
            if (SUCCEEDED(hr))
            {
               wchar_t sDisplayString[SIZE_MAX_STRING];
               // This will not create a buffer overrun
               swprintf(
                           sDisplayString,
                           L"Version = %d\n",
                           lVersion
                        );
               DisplayMessageT(sDisplayString);
            }
            else
            {
               DisplayMessage(g_hModule, MSG_AAAAVERSION_GET_FAIL);
               dwErr = ERROR;
            }
            break;
         }

      case CONFIG:
         {
            AaaaConfigDumpConfig(CONFIG);
            break;
         }

      case SERVER_SETTINGS:
         {
            AaaaConfigDumpConfig(SERVER_SETTINGS);
            break;
         }

      case CLIENTS:
         {
            AaaaConfigDumpConfig(CLIENTS);
            break;
         }

      case CONNECTION_REQUEST_POLICIES:
         {
            AaaaConfigDumpConfig(CONNECTION_REQUEST_POLICIES);
            break;
         }

      case LOGGING:
         {
            AaaaConfigDumpConfig(LOGGING);
            break;
         }

      case REMOTE_ACCESS_POLICIES:
         {
            AaaaConfigDumpConfig(REMOTE_ACCESS_POLICIES);
            break;
         }

      default:
         {
            DisplayMessage(g_hModule, MSG_AAAACONFIG_SHOW_INVALID_SYNTAX);
         }
      }
   }
   return dwErr;
}


//////////////////////////////////////////////////////////////////////////////
//
// Handles the aaaa config show command
//
//////////////////////////////////////////////////////////////////////////////
DWORD
HandleAaaaConfigShow(
                IN      LPCWSTR   pwszMachine,
                IN OUT  LPWSTR   *ppwcArguments,
                IN      DWORD     dwCurrentIndex,
                IN      DWORD     dwArgCount,
                IN      DWORD     dwFlags,
                IN      LPCVOID   pvData,
                OUT     BOOL     *pbDone
                )
{
   if (dwCurrentIndex < dwArgCount)
   {
      DisplayMessage(g_hModule, MSG_AAAACONFIG_SHOW_FAIL);
      DisplayMessage(g_hModule, HLP_AAAACONFIG_SHOW);
   }
   else
   {
      return AaaaConfigParseShowCommandLine(
                                             ppwcArguments,
                                             dwCurrentIndex,
                                             dwArgCount,
                                             dwFlags
                                       );
   }

   return  NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\aaaa\aaaahndl.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
// Copyright Microsoft Corporation
// 
// Module Name:
// 
//   aaaahndl.c
//
// Abstract:
//
//    Handlers for aaaa commands
//
//////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"

#include "strdefs.h"
#include "rmstring.h"
#include "aaaamon.h"
#include "aaaahndl.h"
#include "aaaaconfig.h"
#include "iasdefs.h"


//////////////////////////////////////////////////////////////////////////////
// AaaaDumpScriptHeader
// 
// Routine Description:
// 
//     Dumps the header of a script to the given file or to the 
//     screen if the file is NULL.
//     
//////////////////////////////////////////////////////////////////////////////
DWORD AaaaDumpScriptHeader(IN HANDLE hFile)
{
    DisplayMessage(g_hModule, MSG_AAAA_SCRIPTHEADER);
    return NO_ERROR;        
}


//////////////////////////////////////////////////////////////////////////////
// AaaaDumpScriptFooter
//
// Routine Description:
// 
//     Dumps the header of a script to the given file or to the 
//     screen if the file is NULL.
//////////////////////////////////////////////////////////////////////////////
DWORD AaaaDumpScriptFooter(IN HANDLE hFile)
{
    DisplayMessage(g_hModule, MSG_AAAA_SCRIPTFOOTER);
    return NO_ERROR;        
}


//////////////////////////////////////////////////////////////////////////////
// AaaaDump
//////////////////////////////////////////////////////////////////////////////
DWORD
WINAPI
AaaaDump(
        IN      LPCWSTR     pwszRouter,
        IN OUT  LPWSTR     *ppwcArguments,
        IN      DWORD       dwArgCount,
        IN      LPCVOID     pvData
        )
{
    AaaaDumpScriptHeader( NULL );
    AaaaConfigDumpConfig(CONFIG);
    DisplayMessageT(MSG_NEWLINE);
    AaaaDumpScriptFooter( NULL );
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\aaaa\aaaahndl.h ===
//////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1999  Microsoft Corporation
// 
// Module Name:
// 
//   aaaahndl.h
//
// Abstract:
//
//
// Revision History:
//
//    Thierry Perraut 04/02/1999
//////////////////////////////////////////////////////////////////////////////
#ifndef _AAAAHNDL_H_
#define _AAAAHNDL_H_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

// FN_HANDLE_CMD    HandleAaaaShowServers;

NS_CONTEXT_DUMP_FN  AaaaDump;

#ifdef __cplusplus
}
#endif
#endif //_AAAAHNDL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\aaaa\aaaamon.h ===
//////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998-1999  Microsoft Corporation
// 
// Module Name:
// 
//      aaaamon.h
//
// Abstract:                           
//
//      Prototype for fns called in aaaamon.c
//
// Revision History:
//
//      Anand Mahalingam    7/10/98 (ipmon.h)
//      Thierry Perraut 04/02/1999  (aaaamon.h)
//
//////////////////////////////////////////////////////////////////////////////
#ifndef _AAAAMON_H_
#define _AAAAMON_H_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

extern HANDLE   g_hModule;

#ifdef __cplusplus
}
#endif

#endif // _AAAAMON_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\aaaa\aaaamon.c ===
//////////////////////////////////////////////////////////////////////////////
//
// Copyright Microsoft Corporation
// 
// Module Name:
//
//     aaaamon.c
// 
//////////////////////////////////////////////////////////////////////////////
#define AAAA_HELPER_VERSION 1

#include <windows.h>
#include "strdefs.h"
#include "rmstring.h"
#include <netsh.h>
#include "aaaamontr.h"
#include "context.h"
#include "aaaahndl.h"
#include "aaaaconfig.h"
#include "aaaaversion.h"

GUID g_AaaamontrGuid    = AAAAMONTR_GUID;
GUID g_NetshGuid        = NETSH_ROOT_GUID;

//
// Reminder
//
// #define CREATE_CMD_ENTRY(t,f)   {CMD_##t, f, HLP_##t, HLP_##t##_EX, CMD_FLAG_PRIVATE}
// #define CREATE_CMD_ENTRY_EX(t,f,i) {CMD_##t, f, HLP_##t, HLP_##t##_EX, i}
// #define CMD_FLAG_PRIVATE     0x01 // not valid in sub-contexts
// #define CMD_FLAG_INTERACTIVE 0x02 // not valid from outside netsh
// #define CMD_FLAG_IMMEDIATE   0x04 // not valid from ancestor contexts
// #define CMD_FLAG_LOCAL       0x08 // not valid from a remote machine
// #define CMD_FLAG_ONLINE      0x10 // not valid in offline/non-commit mode

CMD_ENTRY g_AaaaSetCmdTable[] =
{
    CREATE_CMD_ENTRY_EX(AAAACONFIG_SET, HandleAaaaConfigSet,(CMD_FLAG_PRIVATE | CMD_FLAG_ONLINE)),
};                   

CMD_ENTRY g_AaaaShowCmdTable[] =
{
    CREATE_CMD_ENTRY_EX(AAAAVERSION_SHOW, HandleAaaaConfigShow,(CMD_FLAG_PRIVATE | CMD_FLAG_ONLINE)),
    CREATE_CMD_ENTRY_EX(AAAACONFIG_SHOW, HandleAaaaConfigShow,(CMD_FLAG_PRIVATE | CMD_FLAG_ONLINE)),
    CREATE_CMD_ENTRY_EX(AAAACONFIG_SERVER_SETTINGS, HandleAaaaConfigShow,(CMD_FLAG_PRIVATE | CMD_FLAG_ONLINE)),
    CREATE_CMD_ENTRY_EX(AAAACONFIG_CLIENTS, HandleAaaaConfigShow,(CMD_FLAG_PRIVATE | CMD_FLAG_ONLINE)),
    CREATE_CMD_ENTRY_EX(AAAACONFIG_CONNECTION_REQUEST_POLICIES, HandleAaaaConfigShow,(CMD_FLAG_PRIVATE | CMD_FLAG_ONLINE)),
    CREATE_CMD_ENTRY_EX(AAAACONFIG_LOGGING, HandleAaaaConfigShow,(CMD_FLAG_PRIVATE | CMD_FLAG_ONLINE)),
    CREATE_CMD_ENTRY_EX(AAAACONFIG_REMOTE_ACCESS_POLICIES, HandleAaaaConfigShow,(CMD_FLAG_PRIVATE | CMD_FLAG_ONLINE)),
};


CMD_GROUP_ENTRY g_AaaaCmdGroups[] =
{
    CREATE_CMD_GROUP_ENTRY(GROUP_SET,   g_AaaaSetCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_SHOW,  g_AaaaShowCmdTable),

};

ULONG g_ulNumGroups = sizeof(g_AaaaCmdGroups)/sizeof(CMD_GROUP_ENTRY);

HANDLE   g_hModule;
BOOL     g_bCommit;
DWORD    g_dwNumTableEntries;
DWORD                 ParentVersion;
BOOL                  g_bAaaaDirty = FALSE;
NS_CONTEXT_CONNECT_FN AaaaConnect;

ULONG   g_ulInitCount;

//////////////////////////////////////////////////////////////////////////////
// AaaaCommit
//////////////////////////////////////////////////////////////////////////////
DWORD
WINAPI
AaaaCommit(
            IN  DWORD   dwAction
          )
{
    switch(dwAction)
    {
        case NETSH_COMMIT:
        {
            if(g_bCommit)
            {
                return NO_ERROR;
            }

            g_bCommit = TRUE;

            break;
        }

        case NETSH_UNCOMMIT:
        {
            g_bCommit = FALSE;

            return NO_ERROR;
        }

        case NETSH_SAVE:
        {
            if(g_bCommit)
            {
                return NO_ERROR;
            }

            break;
        }

        case NETSH_FLUSH:
        {
            //
            // Action is a flush. If current state is commit, then
            // nothing to be done.
            //

            if(g_bCommit)
            {
                return NO_ERROR;
            }
            break;
        }

        default:
        {
            return NO_ERROR;
        }
    }

    //
    // Switched to commit mode. So set all valid info in the
    // strutures. Free memory and invalidate the info.
    //

    return NO_ERROR;
}


//////////////////////////////////////////////////////////////////////////////
// AaaaStartHelper
//////////////////////////////////////////////////////////////////////////////
DWORD
WINAPI
AaaaStartHelper(
                 IN CONST GUID *pguidParent,
                 IN DWORD       dwVersion
               )
{
    DWORD dwErr;
    NS_CONTEXT_ATTRIBUTES attMyAttributes;

    ParentVersion         = dwVersion;

    ZeroMemory( &attMyAttributes, sizeof(attMyAttributes) );

    attMyAttributes.pwszContext = L"aaaa";
    attMyAttributes.guidHelper  = g_AaaamontrGuid;
    attMyAttributes.dwVersion   = 1;
    attMyAttributes.dwFlags     = CMD_FLAG_LOCAL;
    attMyAttributes.ulNumTopCmds  = 0;
    attMyAttributes.pTopCmds      = NULL;
    attMyAttributes.ulNumGroups   = g_ulNumGroups;
    attMyAttributes.pCmdGroups    = (CMD_GROUP_ENTRY (*)[])&g_AaaaCmdGroups;
    attMyAttributes.pfnCommitFn = AaaaCommit;
    attMyAttributes.pfnDumpFn   = AaaaDump;
    attMyAttributes.pfnConnectFn= AaaaConnect;

    dwErr = RegisterContext( &attMyAttributes );

    return      dwErr;
}


//////////////////////////////////////////////////////////////////////////////
// AaaaUnInit
//////////////////////////////////////////////////////////////////////////////
DWORD
WINAPI
AaaaUnInit(
            IN  DWORD   dwReserved
          )
{
    if(InterlockedDecrement(&g_ulInitCount) != 0)
    {
        return  NO_ERROR;
    }

    return  NO_ERROR;
}


//////////////////////////////////////////////////////////////////////////////
// AaaaDllEntry
//////////////////////////////////////////////////////////////////////////////
BOOL
WINAPI
DllMain(
                HINSTANCE   hInstDll,
                DWORD       fdwReason,
                LPVOID      pReserved
            )
{
    switch (fdwReason)
    {
        case DLL_PROCESS_ATTACH:
        {
            g_hModule = hInstDll;
            DisableThreadLibraryCalls(hInstDll);
            break;
        }
        case DLL_PROCESS_DETACH:
        {
            g_hModule = NULL;
            break;
        }

        default:
        {
            break;
        }
    }

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////////
// InitHelperDll
//////////////////////////////////////////////////////////////////////////////
DWORD WINAPI
InitHelperDll(
        IN  DWORD      dwNetshVersion,
        OUT PVOID      pReserved
             )
{
    DWORD  dwErr;
    NS_HELPER_ATTRIBUTES attMyAttributes;

    //
    // See if this is the first time we are being called
    //

    if(InterlockedIncrement(&g_ulInitCount) != 1)
    {
        return NO_ERROR;
    }

    g_bCommit = TRUE;

    // Register this module as a helper to the netsh root
    // context.
    //
    ZeroMemory( &attMyAttributes, sizeof(attMyAttributes) );
    attMyAttributes.guidHelper         = g_AaaamontrGuid;
    attMyAttributes.dwVersion          = AAAA_HELPER_VERSION;
    attMyAttributes.pfnStart           = AaaaStartHelper;
    attMyAttributes.pfnStop            = NULL;
    RegisterHelper( &g_NetshGuid, &attMyAttributes );

    // Register any sub contexts implemented in this dll
    //
    dwErr = AaaaContextInstallSubContexts();
    if (dwErr != NO_ERROR)
    {
        AaaaUnInit(0);
        return  dwErr;
    }

    return  NO_ERROR;
}


//////////////////////////////////////////////////////////////////////////////
// AaaaConnect
//////////////////////////////////////////////////////////////////////////////
DWORD WINAPI
AaaaConnect(
               IN LPCWSTR pwszRouter
           )
{
    // If context info is dirty, reregister it
    if (g_bAaaaDirty)
    {
        AaaaStartHelper(NULL, ParentVersion);
    }

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\aaaa\aaaaversion.h ===
//////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
// 
// Module Name:
// 
//    aaaaVersion.h
//
//////////////////////////////////////////////////////////////////////////////
#ifndef _AAAAVERSION_H_
#define _AAAAVERSION_H_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

HRESULT 
AaaaVersionGetVersion(
                      LONG*   pVersion
                      );

#ifdef __cplusplus
}
#endif
#endif // _AAAAVERSION_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\aaaa\aaaaversion.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
// Copyright Microsoft Corporation
// 
// Module Name:
// 
//    aaaaVersion.cpp
//
// Abstract:                           
//
//    Handlers for aaaa version command
//
//////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"

#include "strdefs.h"
#include "aaaamon.h"
#include "aaaaversion.h"

//////////////////////////////////////////////////////////////////////////////
// AaaaVersionGetVersion
//////////////////////////////////////////////////////////////////////////////
HRESULT AaaaVersionGetVersion(LONG*   pVersion)
{
    const int SIZE_MAX_STRING = 512; 
    const WCHAR c_wcSELECT_VERSION[] = L"SELECT * FROM Version";
    const WCHAR c_wcIASMDBFileName[] = L"%SystemRoot%\\System32\\ias\\ias.mdb";
    if ( !pVersion )
    {
        return ERROR;
    }

    bool bCoInitialized = false;
    HRESULT hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    if ( FAILED(hr) )
    {
        if ( hr == RPC_E_CHANGED_MODE )
        {
            hr = S_OK;
        }
        else
        {
            *pVersion = 0;
            return hr;
        }
    }
    else
    {
        bCoInitialized = true;
    }

    WCHAR   wc_TempString[SIZE_MAX_STRING];
    // put the path to the DB in the property.  
    BOOL bResult = ExpandEnvironmentStringsForUserW(
                                               NULL,
                                               c_wcIASMDBFileName,
                                               wc_TempString,
                                               SIZE_MAX_STRING
                                               );


    do
    {
        if ( bResult )
        {
            CComPtr<IIASNetshJetHelper>     JetHelper;
            hr = CoCreateInstance(
                                     __uuidof(CIASNetshJetHelper),
                                     NULL,
                                     CLSCTX_SERVER,
                                     __uuidof(IIASNetshJetHelper),
                                     (PVOID*) &JetHelper
                                 );
            if ( FAILED(hr) )
            {
                break;
            }

            CComBSTR     DBPath(wc_TempString);
            if ( !DBPath ) 
            {
                hr = E_OUTOFMEMORY; 
                break;
            } 

            hr = JetHelper->OpenJetDatabase(DBPath, FALSE);
            if ( FAILED(hr) )
            {
                WCHAR sDisplayString[SIZE_MAX_STRING];
                DisplayError(NULL, EMSG_OPEN_DB_FAILED);
                break;
            }

            CComBSTR     SelectVersion(c_wcSELECT_VERSION);
            if ( !SelectVersion ) 
            { 
                hr = E_OUTOFMEMORY; 
                break;
            } 

            hr = JetHelper->ExecuteSQLFunction(
                                                  SelectVersion, 
                                                  pVersion
                                              );
            if ( FAILED(hr) ) // no Misc Table for instance
            {
                *pVersion = 0; //default value.
                hr = S_OK; // that's not an error 
            }
            hr = JetHelper->CloseJetDatabase();
        }
        else
        {
            DisplayMessage(g_hModule, MSG_AAAAVERSION_GET_FAIL);   
            hr = E_FAIL;
            break;
        }
    } while(false);

    if (bCoInitialized)
    {
        CoUninitialize();
    }
    return      hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\aaaa\base64tool.h ===
//////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1999  Microsoft Corporation
//
// Module Name:
//
//    base64tool.h
//
// Abstract:
//
//      Header for the base64 encoding and decoding functions
//
//
// Revision History:
//  
//    Thierry Perraut 04/02/1999
//
//////////////////////////////////////////////////////////////////////////////
#ifndef _BASE64TOOL_H_
#define _BASE64TOOL_H_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif


HRESULT ToBase64(LPVOID pv, ULONG cByteLength, BSTR* pbstr);
HRESULT FromBase64(BSTR bstr, BLOB* pblob, int Index); 


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\aaaa\aaaamontr.h ===
//////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
// 
// Module Name:
// 
//    aaaamontr.h
//
// Abstract:                           
//
//    This file contains definitions which are needed by AAAAMONTR.DLL
//    and all NetSh helper DLLs which register under it.
//
//////////////////////////////////////////////////////////////////////////////
#ifndef _AAAAMONTR_H_
#define _AAAAMONTR_H_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//{1D0FA29B-E93E-11d2-A91E-009027450464}
#define AAAAMONTR_GUID \
{ 0x1D0FA29B, 0xE93E, 0x11d2, { 0xA9, 0x1E, 0x00, 0x90, 0x27, 0x45, 0x04, 0x64 } }

#define AAAAMONTR_VERSION_50     0x0005000
#define AAAAMONTR_OS_BUILD_NT40  1381

//
// Enumerations for types of arguments (see AAAAMON_CMD_ARG)
//
#define AAAAMONTR_CMD_TYPE_STRING 0x1
#define AAAAMONTR_CMD_TYPE_ENUM   0x2

// 
// Macros to operate on AAAAMON_CMD_ARG's
//
#define AAAAMON_CMD_ARG_GetPsz(pArg)     \
    (((pArg)->rgTag.bPresent) ? (pArg)->Val.pszValue : NULL)

#define AAAAMON_CMD_ARG_GetDword(pArg)     \
    (((pArg)->rgTag.bPresent) ? (pArg)->Val.dwValue : -1)

// 
// Structure defining a command line argument
//
typedef struct _AAAAMON_CMD_ARG
{
    IN  DWORD dwType;           // AAAAMONTR_CMD_TYPE_*
    IN  TAG_TYPE rgTag;         // The tag for this command
    IN  TOKEN_VALUE* rgEnums;   // The enumerations for this arg
    IN  DWORD dwEnumCount;      // Count of enums
    union
    {
        OUT PWCHAR pszValue;        // Valid only for AAAAMONTR_CMD_TYPE_STRING
        OUT DWORD dwValue;          // Valid only for AAAAMONTR_CMD_TYPE_ENUM
    } Val;        
    
} AAAAMON_CMD_ARG, *PAAAAMON_CMD_ARG;

//
// Api's that aaaamontr requires of its helpers
//
typedef
DWORD
(WINAPI AAAA_CONTEXT_ENTRY_FN)(
    IN    PWCHAR               pszServer,
    IN    DWORD                dwBuild,
    IN    PTCHAR               *pptcArguments,
    IN    DWORD                dwArgCount,
    IN    DWORD                dwFlags,
    OUT   PWCHAR               pwcNewContext
    );
typedef AAAA_CONTEXT_ENTRY_FN *PAAAA_CONTEXT_ENTRY_FN;

typedef
DWORD
(WINAPI AAAA_CONTEXT_DUMP_FN)(
    IN  HANDLE  hFile
    );
typedef AAAA_CONTEXT_DUMP_FN* PAAAA_CONTEXT_DUMP_FN;

//
// Api's that aaaamontr exposes to its helpers
//
typedef 
PVOID
(WINAPI AAAA_ALLOC_FN)(
    IN DWORD dwBytes,
    IN BOOL bZero
    );
typedef AAAA_ALLOC_FN* PAAAA_ALLOC_FN;

typedef 
VOID
(WINAPI AAAA_FREE_FN)(
    IN PVOID pvData
    );
typedef AAAA_FREE_FN* PAAAA_FREE_FN;

typedef 
PWCHAR
(WINAPI AAAA_STRDUP_FN)(
    IN PWCHAR pwszSrc
    );
typedef AAAA_STRDUP_FN* PAAAA_STRDUP_FN;

typedef
LPDWORD
(WINAPI AAAA_DWORDDUP_FN)(
    IN DWORD dwSrc
    );
typedef AAAA_DWORDDUP_FN* PAAAA_DWORDDUP_FN;

typedef 
DWORD
(WINAPI AAAA_CREATE_DUMP_FILE_FN)(
    IN  PWCHAR  pwszName,
    OUT PHANDLE phFile
    );
typedef AAAA_CREATE_DUMP_FILE_FN* PAAAA_CREATE_DUMP_FILE_FN;

typedef 
VOID
(WINAPI AAAA_CLOSE_DUMP_FILE_FN)(
    HANDLE  hFile
    );
typedef AAAA_CLOSE_DUMP_FILE_FN* PAAAA_CLOSE_DUMP_FILE_FN;

typedef 
DWORD
(WINAPI AAAA_GET_OS_VERSION_FN)(
    IN  PWCHAR  pwszRouter, 
    OUT LPDWORD lpdwVersion);
typedef AAAA_GET_OS_VERSION_FN* PAAAA_GET_OS_VERSION_FN;
    
typedef 
DWORD
(WINAPI AAAA_GET_TAG_TOKEN_FN)(
    IN  HANDLE      hModule,
    IN  PWCHAR      *ppwcArguments,
    IN  DWORD       dwCurrentIndex,
    IN  DWORD       dwArgCount,
    IN  PTAG_TYPE   pttTagToken,
    IN  DWORD       dwNumTags,
    OUT PDWORD      pdwOut
    );
typedef AAAA_GET_TAG_TOKEN_FN* PAAAA_GET_TAG_TOKEN_FN;

typedef
DWORD
(WINAPI AAAA_PARSE_FN)(
    IN  PWCHAR*         ppwcArguments,
    IN  DWORD           dwCurrentIndex,
    IN  DWORD           dwArgCount,
    IN  BOOL*           pbDone,
    OUT AAAAMON_CMD_ARG* pAaaaArgs,
    IN  DWORD           dwAaaaArgCount);
typedef AAAA_PARSE_FN* PAAAA_PARSE_FN;

typedef
BOOL
(WINAPI AAAA_IS_HELP_TOKEN_FN)(
    PWCHAR  pwszToken
    );
typedef AAAA_IS_HELP_TOKEN_FN* PAAAA_IS_HELP_TOKEN_FN;

typedef 
PWCHAR
(WINAPI AAAA_ASSIGN_FROM_TOKENS_FN)(
    IN HINSTANCE hModule,
    IN PWCHAR pwszTokenTkn,
    IN PWCHAR pwszTokenCmd);
typedef AAAA_ASSIGN_FROM_TOKENS_FN* PAAAA_ASSIGN_FROM_TOKENS_FN;

//
// Defines information exported to all aaaa helpers by the 
// aaaamontr module.
//
typedef struct _AAAAMONTR_ATTRIBUTES
{
    union
    {
        ULONGLONG       _ullAlign;

        struct 
        {
            DWORD       dwVersion;
            DWORD       dwReserved;
        };
    };

    // Aaaamontr functions (common utilities)
    //
    PAAAA_ALLOC_FN               pfnAlloc;
    PAAAA_FREE_FN                pfnFree;
    PAAAA_STRDUP_FN              pfnStrDup;
    PAAAA_DWORDDUP_FN            pfnDwordDup;
    PAAAA_CREATE_DUMP_FILE_FN    pfnCreateDumpFile;
    PAAAA_CLOSE_DUMP_FILE_FN     pfnCloseDumpFile;
    PAAAA_GET_OS_VERSION_FN      pfnGetOsVersion;
    PAAAA_GET_TAG_TOKEN_FN       pfnGetTagToken;
    PAAAA_PARSE_FN               pfnParse;
    PAAAA_IS_HELP_TOKEN_FN       pfnIsHelpToken;
    PAAAA_ASSIGN_FROM_TOKENS_FN  pfnAssignFromTokens;

} AAAAMONTR_ATTRIBUTES, *PAAAAMONTR_ATTRIBUTES;

#ifdef __cplusplus
}
#endif

#endif // _AAAAMONTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\aaaa\base64tool.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1999  Microsoft Corporation
// 
// Module Name:
// 
//    base64tool.cpp
//
// Abstract:                           
//
//    base64 encoding and decoding functions
//
// Revision History:
//
//    Comes from SimpleLogObj.cpp (provided as part of the Microsoft 
//    Transaction Server Software Development Kit 
//    Copyright (C) 1997 Microsoft Corporation, All rights reserved 
//
//    Thierry Perraut 04/02/1999 (many minor changes)
//    10/19/1999 Change CoTaskMemAlloc(0) into CoTaskMemAlloc(sizeof(BSTR*))
//               fix the bug 416872 (memory used after the free). This bug 
//               became visible after fixing the first one, on checked builds.
//
//////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "base64tool.h"

// These characters are the legal digits, in order, that are 
// used in Base64 encoding 
// 
namespace
{
    const WCHAR rgwchBase64[] = 
                                L"ABCDEFGHIJKLMNOPQ" 
                                L"RSTUVWXYZabcdefgh" 
                                L"ijklmnopqrstuvwxy" 
                                L"z0123456789+/"; 
}
  

//////////////////////////////////////////////////////////////////////////////
//
// Encode and return the bytes in base 64 
//
//////////////////////////////////////////////////////////////////////////////
HRESULT ToBase64(LPVOID pv, ULONG cByteLength, BSTR* pbstr) 
{ 
    if ( !pbstr )
    {
        return E_OUTOFMEMORY;
    }

    ULONG   cb         = cByteLength; 
    int     cchPerLine = 72;        
            // conservative, must be mult of 4 for us 
    int     cbPerLine  = cchPerLine / 4 * 3; 
    LONG    cbSafe     = cb + 3;                    // allow for padding 
    LONG    cLine      = cbSafe / cbPerLine + 2;    // conservative 
    LONG    cchNeeded  = cLine * (cchPerLine + 4 /*CRLF*/) + 1 /*slash NULL*/;
    LONG    cbNeeded   = cchNeeded * sizeof(WCHAR); 
    HRESULT hr         = S_OK;

    LPWSTR wsz = static_cast<LPWSTR>(CoTaskMemAlloc(cbNeeded)); 
  
    if ( !wsz ) 
    { 
        return E_OUTOFMEMORY;
    }

    BYTE*  pb   = (BYTE*)pv; 
    WCHAR* pch  = wsz ; 
    int cchLine = 0; 
    // 
    // Main encoding loop 
    // 
    while (cb >= 3) 
    { 
        BYTE b0 =                     ((pb[0]>>2) & 0x3F); 
        BYTE b1 = ((pb[0]&0x03)<<4) | ((pb[1]>>4) & 0x0F); 
        BYTE b2 = ((pb[1]&0x0F)<<2) | ((pb[2]>>6) & 0x03); 
        BYTE b3 = ((pb[2]&0x3F)); 

        *pch++ = rgwchBase64[b0]; 
        *pch++ = rgwchBase64[b1]; 
        *pch++ = rgwchBase64[b2]; 
        *pch++ = rgwchBase64[b3]; 

        pb += 3; 
        cb -= 3; 
         
        // put in line breaks 
        cchLine += 4; 
        if (cchLine >= cchPerLine) 
        { 
            *pch++ = L'\\'; 
            *pch++ = L'\r'; 
            cchLine = 0; 
        } 
    } 
    // 
    // Account for gunk at the end 
    // 
    *pch++ = L'\\'; 
    *pch++ = L'\r';     // easier than keeping track 
    if (cb==0) 
    { 
        // nothing to do 
    } 
    else if (cb==1) 
    { 
        BYTE b0     = ((pb[0]>>2) & 0x3F); 
        BYTE b1     = ((pb[0]&0x03)<<4) | 0; 
        *pch++      = rgwchBase64[b0]; 
        *pch++      = rgwchBase64[b1]; 
    } 
    else if (cb==2) 
    { 
        BYTE b0 =                     ((pb[0]>>2) & 0x3F); 
        BYTE b1 = ((pb[0]&0x03)<<4) | ((pb[1]>>4) & 0x0F); 
        BYTE b2 = ((pb[1]&0x0F)<<2) | 0; 
        *pch++  = rgwchBase64[b0]; 
        *pch++  = rgwchBase64[b1]; 
        *pch++  = rgwchBase64[b2]; 
    }
    else
    {
        // should never go there
    }
     
    // 
    // NULL terminate the string 
    // 
    *pch++ = L'\\'; 
    *pch++ = L'\r';     // easier than keeping track 
    *pch++ = NULL; 

    // 
    // Allocate our final output 
    // 

    *pbstr = SysAllocString(wsz); 
    if ( !*pbstr )
    {
        return E_OUTOFMEMORY;
    }

    CoTaskMemFree(wsz); 
    wsz = NULL;

    #ifdef _DEBUG 
    if (hr==S_OK) 
    { 
        BLOB b; 
        FromBase64(*pbstr, &b); 
        _ASSERTE(b.cbSize == cByteLength); 
        _ASSERTE(memcmp(b.pBlobData, pv, cByteLength) == 0); 
        CoTaskMemFree(b.pBlobData); 
    } 
    #endif 
 
    return hr; 
} 
 
 
 
//////////////////////////////////////////////////////////////////////////////
// 
// Decode and return the Base64 encoded bytes 
// 
// Allocates the memory for the blob.
//
//////////////////////////////////////////////////////////////////////////////
HRESULT FromBase64(BSTR bstr, BLOB* pblob, int Index) 
{ 
    ASSERT(Index >= 0);
    ASSERT(pblob);

    if (bstr == NULL)
    {
#ifdef DEBUG
        wprintf(L"FromBase64 (bstr == NULL)\n");
#endif //DEBUG
        return      E_FAIL;
    }

    HRESULT     hr  = S_OK; 
    ULONG       cbNeeded = wcslen(bstr); // an upper bound 
    BYTE*       rgb = static_cast<BYTE*>(CoTaskMemAlloc(cbNeeded)); 
    if ( !rgb )
    {
        return E_OUTOFMEMORY;
    }

    memset(rgb, 0, cbNeeded);

    BYTE    mpwchb[256]; 
    BYTE    bBad = (BYTE)-1; 

    // 
    // Initialize our decoding array 
    // 
    memset(&mpwchb[0], bBad, 256); 
    for ( BYTE i = 0; i < 64; ++i ) 
    { 
        WCHAR wch = rgwchBase64[i]; 
        mpwchb[wch] = i; 
    } 

    // 
    // Loop over the entire input buffer 
    // 
    // what we're in the process of filling up 
    ULONG   bCurrent   = 0;        
    // how many bits in it we've filled
    int     cbitFilled = 0;         
    // current destination (not filled)
    BYTE*   pb         = rgb;              
    
    // SysStringLen doesn't include the termination NULL character
    LONG    LoopCounter = static_cast<LONG>(SysStringLen(bstr) + 1);  
    for ( WCHAR* pwch = bstr; *pwch; ++pwch ) 
    { 
        WCHAR wch = *pwch; 
        // 
        // Ignore white space 
        // 
        if ( wch==0x0A || wch==0x0D || wch==0x20 || wch==0x09 ) 
        {
            continue; 
        }

        if ( Index > 0 )
        {
            LoopCounter--;
            ////////////////////////////////////////////
            // At least one section needs to be skipped
            ////////////////////////////////////////////

            if ( wch != L'*' ) 
            {
                //////////////////////////////////
                // Not the end of the section yet
                //////////////////////////////////
                continue; 
            }
            else
            {
                ///////////////////////////////
                // End of section marker found
                // decrease index and loop
                ///////////////////////////////
                Index --;
                continue;
            }
        }
        else  if ( wch == L'*' ) 
        {
            ////////////////////////////////
            // End of the section to decode 
            ////////////////////////////////
            break; 
        }

        // 
        // Have we reached the end? 
        // 
        if ( LoopCounter-- <= 0 )
        {
            break;
        }


        // 
        // How much is this character worth? 
        // 
        BYTE    bDigit = mpwchb[wch]; 

        if ( bDigit == bBad ) 
        { 
            hr = E_INVALIDARG; 
            break; 
        } 

        // 
        // Add in its contribution 
        // 
        bCurrent        <<= 6; 
        bCurrent        |= bDigit; 
        cbitFilled      += 6; 
        // 
        // If we've got enough, output a byte 
        // 
        if ( cbitFilled >= 8 ) 
        { 
            // get's top eight valid bits 
            ULONG       b   = (bCurrent >> (cbitFilled-8));
            *pb++           = (BYTE)(b&0xFF);// store the byte away 
            cbitFilled      -= 8; 
        } 
    } 

    if ( hr == S_OK ) 
    { 
        pblob->pBlobData    = rgb; 
        pblob->cbSize       = (ULONG) (pb - rgb); 
    } 
    else 
    { 
        CoTaskMemFree(rgb); 
        pblob->pBlobData    = NULL; 
    } 

    return      hr; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\aaaa\context.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1999  Microsoft Corporation
//
//
//    File:   context.c
//
//    Abstract: 
//
//      Mechanisms to process contexts relevant to aaaamontr.
//
//    Revision:
//
//    Thierry Perraut 04/02/1999
//
//////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "context.h"

//////////////////////////////////////////////////////////////////////////////
//
// Installs all of the sub contexts provided
// in this .dll (for example, "aaaa ip", "aaaa client", etc.)
//
//////////////////////////////////////////////////////////////////////////////
DWORD 
AaaaContextInstallSubContexts()
{
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\aaaa\context.h ===
//////////////////////////////////////////////////////////////////////////////
// Copyright (c) 1999  Microsoft Corporation
//
// Module Name:
//
//    File:   context.h
//
// Abstract:
//
//    Definitions for mechanisms to process contexts relevant to 
//    aaaamontr.
//
// Revision History:
//  
//    Thierry Perraut 04/02/1999
//
//////////////////////////////////////////////////////////////////////////////
#ifndef _CONTEXT_H_
#define _CONTEXT_H_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

DWORD 
AaaaContextInstallSubContexts(
    );

#ifdef __cplusplus
}
#endif
#endif //_CONTEXT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\aaaa\iasmdbtool.h ===
//////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// Module Name:
//
//    iasmdbtool.h
//
// Abstract:
//      Header for the base64 encoding and decoding functions
//
//////////////////////////////////////////////////////////////////////////////
#ifndef _IASMDBTOOL_H_
#define _IASMDBTOOL_H_

#include "datastore2.h"

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif


HRESULT IASDumpConfig(
                        /*inout*/ WCHAR **ppDumpString, 
                        /*inout*/ ULONG *ulSize
                     );

HRESULT IASRestoreConfig(
                           /*in*/ const WCHAR *pRestoreString, 
                           /*in*/ IAS_SHOW_TOKEN_LIST configType
                        );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\aaaa\stdafx.cpp ===
#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\aaaa\iasmdbtool.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// Module Name:
//
//    iasmdbtool.cpp
//
// Abstract:
//
//    dump the "Properties" table from ias.mdb to a text format
//              and also restore ias.mdb from such dump
//              saves and restore the reg keys too.
//
//////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"

#include <string>
#include <shlwapi.h>
#include "datastore2.h"

using namespace std;

//////////////////////////////////////////////////////////////////////////////
HRESULT IASExpandString(const wchar_t* pInputString, wchar_t** ppOutputString);
//////////////////////////////////////////////////////////////////////////////

#ifdef DEBUG
    #define CHECK_CALL_HRES(expr) \
        hres = expr;      \
        if (FAILED(hres)) \
        {       \
            wprintf(L"### %S returned 0x%X ###\n",  ## #expr, hres); \
            return hres; \
        }                       

    #define CHECK_CALL_HRES_NO_RETURN(expr) \
        hres = expr;      \
        if (FAILED(hres)) \
        {       \
            wprintf(L"### %S returned 0x%X  ###\n",  ## #expr, hres); \
        }                       
    #define CHECK_CALL_HRES_BREAK(expr) \
        hres = expr;      \
        if (FAILED(hres)) \
        {       \
            wprintf(L"### %S returned 0x%X  ###\n",  ## #expr, hres); \
            break; \
        }                       
#else //no printf, only the error code return if needed
    #define CHECK_CALL_HRES(expr) \
        hres = expr;      \
        if (FAILED(hres)) \
        {       \
            return hres; \
        }                       

    #define CHECK_CALL_HRES_NO_RETURN(expr) \
        hres = expr;      

    #define CHECK_CALL_HRES_BREAK(expr) \
        hres = expr;      \
        if (FAILED(hres)) break;                       

#endif //DEBUG


#define celems(_x)          (sizeof(_x) / sizeof(_x[0]))

#ifdef DBG
#define IgnoreVariable(v) { (v) = (v); }
#else
#define IgnoreVariable(v)
#endif

namespace
{
    const int   SIZELINEMAX       = 512;
    const int   SIZE_LONG_MAX     = 33;
    // Number of files generated
    // here one: backup.mdb
    const int   MAX_FILES         = 1; 
    const int   EXTRA_CHAR_SPACE  = 32;

    // file order
    const int   BACKUP_NB         = 0;
    const int   BINARY_NB         = 100;

    // that's a lot
    const int   DECOMPRESS_FACTOR = 100;
    const int   FILE_BUFFER_SIZE  = 1024;
    
    struct IASKEY
    {
        const wchar_t*    c_wcKey;
        const wchar_t*    c_wcValue;
        DWORD     c_dwType;
    } IAS_Key_Struct;

    IASKEY c_wcKEYS[] = 
    {
        {
            L"SYSTEM\\CurrentControlSet\\Services\\IAS\\Parameters",
            L"Allow SNMP Set",
            REG_DWORD
        },
        {
            L"SYSTEM\\CurrentControlSet\\Services\\RasMan\\PPP\\ControlProtocols\\BuiltIn",
            L"DefaultDomain",
            REG_SZ
        },
        {
            L"SYSTEM\\CurrentControlSet\\Services\\RemoteAccess\\Parameters\\AccountLockout",
            L"MaxDenials",
            REG_DWORD
        },
        {
            L"SYSTEM\\CurrentControlSet\\Services\\RemoteAccess\\Parameters\\AccountLockout",
            L"ResetTime (mins)",
            REG_DWORD
        },
        {
            L"SYSTEM\\CurrentControlSet\\Services\\RemoteAccess\\Policy",
            L"Allow LM Authentication",
            REG_DWORD
        },
        {
            L"SYSTEM\\CurrentControlSet\\Services\\RemoteAccess\\Policy",
            L"Default User Identity",
            REG_SZ
        },
        {
            L"SYSTEM\\CurrentControlSet\\Services\\RemoteAccess\\Policy",
            L"User Identity Attribute",
            REG_DWORD
        },
        {
            L"SYSTEM\\CurrentControlSet\\Services\\RemoteAccess\\Policy",
            L"Override User-Name",
            REG_DWORD
        },
        {
            L"SYSTEM\\CurrentControlSet\\Services\\IAS\\Parameters",
            L"Ping User-Name",
            REG_SZ
        },
    };

    const wchar_t c_wcKEYS_FILE[]     = L"%TEMP%\\";

#ifdef _WIN64
    const wchar_t c_wcIAS_MDB_FILE_NAME[] = 
                                     L"%SystemRoot%\\SysWow64\\ias\\ias.mdb";
    const wchar_t c_wcIAS_OLD[] = L"%SystemRoot%\\SysWow64\\ias\\iasold.mdb";

#else
    const wchar_t c_wcIAS_MDB_FILE_NAME[] = 
                                     L"%SystemRoot%\\System32\\ias\\ias.mdb";

    const wchar_t c_wcIAS_OLD[] = L"%SystemRoot%\\System32\\ias\\iasold.mdb";
#endif 

    const wchar_t c_wcFILE_BACKUP[] = L"%TEMP%\\Backup.mdb";

    const wchar_t c_wcSELECT_PROPERTIES_INTO[] = 
                                    L"SELECT * " 
                                    L"INTO Properties IN "
                                    L"\"%TEMP%\\Backup.mdb\" "
                                    L"FROM Properties;";

    const wchar_t c_wcSELECT_OBJECTS_INTO[] = 
                                    L"SELECT * " 
                                    L"INTO Objects IN "
                                    L"\"%TEMP%\\Backup.mdb\" "
                                    L"FROM Objects;";

    const wchar_t c_wcSELECT_VERSION_INTO[] = 
                                    L"SELECT * " 
                                    L"INTO Version IN "
                                    L"\"%TEMP%\\Backup.mdb\" "
                                    L"FROM Version;";
}


//////////////////////////////////////////////////////////////////////////////
//
// WideToAnsi 
// 
//  CALLED BY:everywhere 
// 
//  PARAMETERS: lpStr - destination string 
//  lpWStr - string to convert 
//  cchStr - size of dest buffer 
// 
//  DESCRIPTION: 
//  converts unicode lpWStr to ansi lpStr. 
//  fills in unconvertable chars w/ DPLAY_DEFAULT_CHAR "-" 
// 
// 
//  RETURNS:  if cchStr is 0, returns the size required to hold the string 
//  otherwise, returns the number of chars converted 
//
//////////////////////////////////////////////////////////////////////////////
int WideToAnsi(char* lpStr,unsigned short* lpWStr, int cchStr) 
{ 
    BOOL        bDefault; 
 
    // use the default code page (CP_ACP) 
    // -1 indicates WStr must be null terminated 
    return WideCharToMultiByte(GetConsoleOutputCP(),0,lpWStr,-1,lpStr,cchStr,"-",&bDefault); 
} 


/////////////////////////////////////////////////////////////////////////////
//
// IASEnableBackupPrivilege
//
/////////////////////////////////////////////////////////////////////////////
HRESULT IASEnableBackupPrivilege()
{
    LONG lResult = ERROR_SUCCESS;
    HANDLE hToken  = NULL;
    do
    {
        if ( ! OpenProcessToken(
                                GetCurrentProcess(),
                                TOKEN_ADJUST_PRIVILEGES,
                                &hToken
                                ))
        {
            lResult = ERROR_CAN_NOT_COMPLETE;
            break;
        }

        LUID luidB;
        if ( ! LookupPrivilegeValue(NULL, SE_BACKUP_NAME, &luidB))
        {
            lResult = ERROR_CAN_NOT_COMPLETE;
            break;
        }

        LUID luidR;
        if ( ! LookupPrivilegeValue(NULL, SE_RESTORE_NAME, &luidR))
        {
            lResult = ERROR_CAN_NOT_COMPLETE;
            break;
        }

        TOKEN_PRIVILEGES            tp;
        tp.PrivilegeCount           = 1;
        tp.Privileges[0].Luid       = luidB;
        tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

        if ( ! AdjustTokenPrivileges(
                                        hToken, 
                                        FALSE, 
                                        &tp, 
                                        sizeof(TOKEN_PRIVILEGES),
                                        NULL, 
                                        NULL 
                                        ) )
        {
            lResult = ERROR_CAN_NOT_COMPLETE;
            break;
        }

        tp.PrivilegeCount           = 1;
        tp.Privileges[0].Luid       = luidR;
        tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

        if ( ! AdjustTokenPrivileges(
                                        hToken, 
                                        FALSE, 
                                        &tp, 
                                        sizeof(TOKEN_PRIVILEGES),
                                        NULL, 
                                        NULL 
                                        ) )
        {
            lResult = ERROR_CAN_NOT_COMPLETE;
            break;
        }
    } while (false);

    if ( hToken )
    {
        CloseHandle(hToken);
    }

    if ( lResult == ERROR_SUCCESS )
    {
        return S_OK;
    }
    else
    {
        return E_FAIL;
    }
}


/////////////////////////////////////////////////////////////////////////////
//
// IASSaveRegKeys
//
/////////////////////////////////////////////////////////////////////////////
HRESULT IASSaveRegKeys()
{
   ASSERT(celems(c_wcKEYS) != 0);
    
   ////////////////////////////
   // Enable backup privilege. 
   ////////////////////////////
   HRESULT hres;
   CHECK_CALL_HRES (IASEnableBackupPrivilege());
   
   wchar_t* completeFile;
   CHECK_CALL_HRES (IASExpandString(c_wcKEYS_FILE, &completeFile));
   size_t c_NbKeys = celems(c_wcKEYS);

   for ( int i = 0; i < c_NbKeys; ++i )
   {
      DWORD dwType = 0;
      DWORD cbData = SIZELINEMAX / 2;

      LPVOID pvData = CoTaskMemAlloc(sizeof(wchar_t) * SIZELINEMAX);
      if (!pvData)
      {
         hres = E_OUTOFMEMORY;
         break;
      }

      DWORD lResult = SHGetValueW(
                                    HKEY_LOCAL_MACHINE,
                                    c_wcKEYS[i].c_wcKey,
                                    c_wcKEYS[i].c_wcValue,
                                    &dwType,
                                    pvData,
                                    &cbData
                                 );

      //
      // Try to allocate more memory if cbData returned the size needed
      //
      if ((lResult != ERROR_SUCCESS) && (cbData > SIZELINEMAX))
      {
         CoTaskMemFree(pvData);
         pvData = CoTaskMemAlloc(sizeof(wchar_t) * cbData);
         if ( !pvData )
         {
            hres = E_OUTOFMEMORY;
            break;
         }
         lResult = SHGetValue(
                                 HKEY_LOCAL_MACHINE,
                                 c_wcKEYS[i].c_wcKey,
                                 c_wcKEYS[i].c_wcValue,
                                 &dwType,
                                 pvData,
                                 &cbData
                              );
         if ( lResult  != ERROR_SUCCESS )
         {
            hres = E_OUTOFMEMORY;
            CoTaskMemFree(pvData);
            break;
         }
      }

      //
      // Create the file (in all situations)
      //
      wstring sFileName(completeFile);
      wchar_t buffer[SIZE_LONG_MAX];

      _itow(i, buffer, 10); // 10 means base 10
      sFileName += buffer;
      sFileName += L".txt";

      HANDLE hFile = CreateFileW(
                                    sFileName.c_str(),
                                    GENERIC_WRITE,       
                                    0,           
                                    NULL,
                                    CREATE_ALWAYS,  
                                    FILE_ATTRIBUTE_NORMAL,   
                                    NULL
                                 );
   

      if ( hFile == INVALID_HANDLE_VALUE )
      {
         hres = E_FAIL;
         CoTaskMemFree(pvData);
         break;
      }
      
      //
      // lResult = result of SHGetValue            
      // and might be an error but not 
      // a memory problem
      //
      if ( lResult == ERROR_SUCCESS )
      {
         //
         // Wrong data type
         //
         if ( dwType != c_wcKEYS[i].c_dwType )   
         {
            hres = E_FAIL;
            CoTaskMemFree(pvData);
            CloseHandle(hFile);
            break;
         }
         else
         {
            //
            // Save the value to the file
            //
            BYTE*   bBuffer = static_cast<BYTE*>(VirtualAlloc
                                       (
                                          NULL,
                                          (cbData > FILE_BUFFER_SIZE)? 
                                             cbData:FILE_BUFFER_SIZE,
                                          MEM_COMMIT,
                                          PAGE_READWRITE
                                       ));
            if ( !bBuffer )
            {
               CoTaskMemFree(pvData);
               CloseHandle(hFile);
               hres = E_FAIL;
               break;
            }
                  
            memset(bBuffer, '\0', (cbData > FILE_BUFFER_SIZE)? 
                                       cbData:FILE_BUFFER_SIZE);

            if ( REG_SZ == c_wcKEYS[i].c_dwType )
            {
               wcscpy((wchar_t*)bBuffer, (wchar_t*)pvData);
            }
            else
            {
               memcpy(bBuffer, pvData, cbData);
            }

            CoTaskMemFree(pvData);

            DWORD NumberOfBytesWritten;

            BOOL bResult = WriteFile(
                                       hFile,
                                       bBuffer,
                                       (cbData > FILE_BUFFER_SIZE)?
                                          cbData:FILE_BUFFER_SIZE,
                                       &NumberOfBytesWritten,
                                       NULL
                                    );

            VirtualFree(
                           bBuffer,  
                           (cbData > FILE_BUFFER_SIZE)?
                              cbData:FILE_BUFFER_SIZE,
                           MEM_RELEASE
                        ); // ignore result
            CloseHandle(hFile);
            if ( bResult )
            {
               hres = S_OK;
            }
            else
            {
               hres = E_FAIL;
               break;
            }
         }
      }
      else 
      {
         //
         // create an empty file
         BYTE bBuffer[FILE_BUFFER_SIZE];
         memset(bBuffer, '#', (cbData > FILE_BUFFER_SIZE)? 
                                             cbData:FILE_BUFFER_SIZE);

         DWORD NumberOfBytesWritten;
         BOOL bResult = WriteFile(
                                 hFile,
                                 &bBuffer,
                                 FILE_BUFFER_SIZE,
                                 &NumberOfBytesWritten,
                                 NULL
                                 );

         CoTaskMemFree(pvData);
         CloseHandle(hFile);

         if ( bResult == TRUE )
         {
            hres = S_OK;
         }
         else
         {
            hres = E_FAIL;
            break;
         }
      }
   }
   ////////////
   // Clean
   ////////////
   CoTaskMemFree(completeFile);

   return hres;
}


//////////////////////////////////////////////////////////////////////////////
//
// KeyShouldBeRestored
//
// maps the reg keys to the netsh tokens
   /*
   L"SYSTEM\\CurrentControlSet\\Services\\IAS\\Parameters",
   L"Allow SNMP Set",
   server

   L"SYSTEM\\CurrentControlSet\\Services\\RasMan\\PPP\\ControlProtocols\\BuiltIn",
   L"DefaultDomain",
   rap

   L"SYSTEM\\CurrentControlSet\\Services\\RemoteAccess\\Parameters\\AccountLockout",
   L"MaxDenials",
   server

   L"SYSTEM\\CurrentControlSet\\Services\\RemoteAccess\\Parameters\\AccountLockout",
   L"ResetTime (mins)",
   server

   L"SYSTEM\\CurrentControlSet\\Services\\RemoteAccess\\Policy",
   L"Allow LM Authentication",
   rap

   L"SYSTEM\\CurrentControlSet\\Services\\RemoteAccess\\Policy",
   L"Default User Identity",
   rap

   L"SYSTEM\\CurrentControlSet\\Services\\RemoteAccess\\Policy",
   L"User Identity Attribute",
   rap

   L"SYSTEM\\CurrentControlSet\\Services\\RemoteAccess\\Policy",
   L"Override User-Name",
   rap

   L"SYSTEM\\CurrentControlSet\\Services\\IAS\\Parameters",
   L"Ping User-Name",
   server
   */
//
//////////////////////////////////////////////////////////////////////////////
bool KeyShouldBeRestored(size_t keyIndex, IAS_SHOW_TOKEN_LIST configType)
{
   // keyIndex maps to the index of the key in the array of keys
   // configType is the token to use.
   bool retVal = false;
   switch(configType)
   {
   case CONFIG:
      {
         // true for everything
         retVal = true;
         break;
      }
   case SERVER_SETTINGS:
      {
         if ( (keyIndex == 0) ||
              (keyIndex == 2) ||
              (keyIndex == 3) ||
              (keyIndex == 8)
            )
         {
            retVal = true;
         }
         break;
      }
   case REMOTE_ACCESS_POLICIES:
      {
         if ( (keyIndex == 1) ||
              (keyIndex == 4) ||
              (keyIndex == 5) ||
              (keyIndex == 6) ||
              (keyIndex == 7) 
            )
         {
            retVal = true;
         }
         break;
      }
   case CONNECTION_REQUEST_POLICIES:
   case CLIENTS:
   case LOGGING:
   default:
      {
         retVal = false;
         break;
      }
   }
   return retVal;
}



//////////////////////////////////////////////////////////////////////////////
//
// IASRestoreRegKeys
//
// if something cannot be restored because of an empty 
// backup file (no key saved), that's not an error
//
//////////////////////////////////////////////////////////////////////////////
HRESULT IASRestoreRegKeys(/*in*/ IAS_SHOW_TOKEN_LIST configType)
{
   ASSERT(celems(c_wcKEYS) != 0);

   ////////////////////////////
   // Enable backup privilege. 
   // and sets hres
   ////////////////////////////
   HRESULT hres;
   CHECK_CALL_HRES (IASEnableBackupPrivilege());

   wchar_t* completeFile;
   CHECK_CALL_HRES (IASExpandString(c_wcKEYS_FILE, &completeFile));

   size_t c_NbKeys = celems(c_wcKEYS);
   for (size_t i = 0; i < c_NbKeys; ++i )
   {
      if (!KeyShouldBeRestored(i, configType))
      {
         continue;
      }

      wstring sFileName(completeFile);
      wchar_t buffer[SIZE_LONG_MAX];
      DWORD dwDisposition;

      _itow(i, buffer, 10); // 10 means base 10
      sFileName += buffer;
      sFileName += L".txt";

      // open the file
      HANDLE hFile = CreateFileW(
                                    sFileName.c_str(),
                                    GENERIC_READ,       
                                    0,           
                                    NULL,
                                    OPEN_EXISTING,  
                                    FILE_ATTRIBUTE_NORMAL,   
                                    NULL
                                 );
      

      if (INVALID_HANDLE_VALUE == hFile)
      {
         // maybe some reg keys were not saved in that file.
         // for instance Ping User-Name wasn't saved.
         continue;
      }

      // check the type of data expected
      LPVOID lpBuffer = NULL;
      DWORD SizeToRead; 
      if (REG_SZ == c_wcKEYS[i].c_dwType)
      {
         lpBuffer = CoTaskMemAlloc(sizeof(wchar_t) * FILE_BUFFER_SIZE);
         SizeToRead = FILE_BUFFER_SIZE;
      }
      else if (REG_DWORD == c_wcKEYS[i].c_dwType)
      {
         lpBuffer = CoTaskMemAlloc(sizeof(DWORD));
         SizeToRead = sizeof(DWORD);
      }
      else
      {
         // unknown
         ASSERT(FALSE);
      }

      if (!lpBuffer)
      {
         CloseHandle(hFile);
         hres = E_OUTOFMEMORY;
         break;
      }

      memset(lpBuffer,'\0',SizeToRead);

      // read the file
      DWORD NumberOfBytesRead;
      BOOL b = ReadFile(
                           hFile,
                           lpBuffer,
                           SizeToRead, 
                           &NumberOfBytesRead,
                           NULL
                        ); // ignore return value. uses NumberOfBytesRead
                           // to determine success condition
      IgnoreVariable(b);
      CloseHandle(hFile);

      // check if the file contains ####
      if ( NumberOfBytesRead == 0 )
      {
         // problem
         CoTaskMemFree(lpBuffer);
         hres = E_FAIL;
         break;
      }
      else
      {
         BYTE TempBuffer[sizeof(DWORD)];
         memset(TempBuffer, '#', sizeof(DWORD));
         
         if (0 == memcmp(lpBuffer, TempBuffer, sizeof(DWORD)))
         {
            // no key saved, delete existing key if any
            HKEY hKeyToDelete = NULL;
            if (ERROR_SUCCESS == RegOpenKeyW(
                                             HKEY_LOCAL_MACHINE,
                                             c_wcKEYS[i].c_wcKey, 
                                             &hKeyToDelete
                                          ))
            {
               if (ERROR_SUCCESS != RegDeleteValueW
                                             (
                                             hKeyToDelete,
                                             c_wcKEYS[i].c_wcValue   
                                             ))
               {
                  // delete existing key failed\n");
               }
               RegCloseKey(hKeyToDelete);
            }
            // 
            // else do nothing: key doesn't exist
            //
         }
         else
         {
            // key saved: restore value
            // what if the value is bigger than
            // the buffer size?

            HKEY hKeyToUpdate;
            LONG lResult = RegCreateKeyExW(
                                          HKEY_LOCAL_MACHINE,
                                          c_wcKEYS[i].c_wcKey,
                                          0, 
                                          NULL,
                                          REG_OPTION_NON_VOLATILE |
                                          REG_OPTION_BACKUP_RESTORE ,
                                          KEY_ALL_ACCESS,
                                          NULL,
                                          &hKeyToUpdate,        
                                          &dwDisposition
                                          );

            if (ERROR_SUCCESS != lResult)
            {
               lResult = RegCreateKeyW(
                                          HKEY_LOCAL_MACHINE,
                                          c_wcKEYS[i].c_wcKey,
                                          &hKeyToUpdate        
                                       );
               if (ERROR_SUCCESS != lResult)
               {
                  RegCloseKey(hKeyToUpdate);
                  hres = E_FAIL;
                  break;
               }
            }

            if (REG_SZ == c_wcKEYS[i].c_dwType)
            {
               // nb of 
               NumberOfBytesRead = (
                                       ( wcslen((wchar_t*)lpBuffer)
                                          + 1               // for /0
                                       ) * sizeof(wchar_t)
                                    );
            };

            //
            // Key created or key existing 
            // both can be here (error = break)
            //
            if (ERROR_SUCCESS != RegSetValueExW(
                                                hKeyToUpdate,           
                                                c_wcKEYS[i].c_wcValue,
                                                0,
                                                c_wcKEYS[i].c_dwType,
                                                (BYTE*)lpBuffer,
                                                NumberOfBytesRead
                                                ))
            {
               RegCloseKey(hKeyToUpdate);
               hres = E_FAIL;
               break;
            }

            RegCloseKey(hKeyToUpdate);
            hres = S_OK;
         }

         CoTaskMemFree(lpBuffer);
      }
   }

   /////////
   // Clean
   /////////
   CoTaskMemFree(completeFile);
   return hres;
}


/////////////////////////////////////////////////////////////////////////////
//
// IASExpandString
//
// Expands strings containing %ENV_VARIABLE% 
//
// The output string is allocated only when the function succeed
/////////////////////////////////////////////////////////////////////////////
HRESULT 
IASExpandString(const wchar_t* pInputString, /*in/out*/ wchar_t** ppOutputString)
{
    _ASSERTE(pInputString);
    _ASSERTE(pppOutputString);
    
    HRESULT hres;

    *ppOutputString = static_cast<wchar_t*>(CoTaskMemAlloc(
                                                            SIZELINEMAX
                                                            * sizeof(wchar_t)
                                                        ));
    
    if ( ! *ppOutputString )
    {
        hres = E_OUTOFMEMORY;
    }
    else
    {
        if ( ExpandEnvironmentStringsForUserW(
                                                 NULL,
                                                 pInputString,
                                                 *ppOutputString,
                                                 SIZELINEMAX
                                             )
           )

        {
            hres = S_OK;            
        }
        else
        {
            CoTaskMemFree(*ppOutputString);
            hres = E_FAIL;
        }
    }
#ifdef DEBUG // DEBUG
    wprintf(L"#ExpandString: %s\n", *ppOutputString);
#endif //DEBUG

    return      hres;
};


/////////////////////////////////////////////////////////////////////////////
//
// DeleteTemporaryFiles()
//
// delete the temporary files if any
//
/////////////////////////////////////////////////////////////////////////////
HRESULT DeleteTemporaryFiles()
{
    HRESULT         hres;
    wchar_t*          sz_FileBackup;

    CHECK_CALL_HRES (IASExpandString(c_wcFILE_BACKUP,
                                    &sz_FileBackup
                                   )
                    );
     
    DeleteFile(sz_FileBackup); //return value not checked
    CoTaskMemFree(sz_FileBackup);

    wchar_t*      TempPath;
    
    CHECK_CALL_HRES (IASExpandString(c_wcKEYS_FILE, &TempPath));

    int     c_NbKeys = celems(c_wcKEYS);
    for ( int i = 0; i < c_NbKeys; ++i )
    {
        wstring         sFileName(TempPath);
        wchar_t           buffer[SIZE_LONG_MAX];
        _itow(i, buffer, 10); // 10 means base 10
        sFileName += buffer;
        sFileName += L".txt";
    
        DeleteFile(sFileName.c_str()); //return value not checked
    }
   
    CoTaskMemFree(TempPath);

    return      hres;
}        


/////////////////////////////////////////////////////////////////////////////
//
// IASCompress
//
// Wrapper for RtlCompressBuffer
//
/////////////////////////////////////////////////////////////////////////////
HRESULT IASCompress(
                   PUCHAR pInputBuffer, 
                   ULONG*  pulFileSize,
                   PUCHAR* ppCompressedBuffer
                  )
{
    ULONG       size, ignore;

    NTSTATUS status = RtlGetCompressionWorkSpaceSize(
                COMPRESSION_FORMAT_LZNT1 | COMPRESSION_ENGINE_MAXIMUM,
                &size,
                &ignore
                );


    if (!NT_SUCCESS(status))
    {
    #ifdef DEBUG
        printf("RtlGetCompressionWorkSpaceSize returned 0x%08X.\n", status);
    #endif //DEBUG
        return E_FAIL;
    }

    PVOID workSpace;
    workSpace = RtlAllocateHeap(
                                   RtlProcessHeap(),
                                   0,
                                   size
                               );
    if ( !workSpace )
    {
        return E_OUTOFMEMORY;
    }

    size = *pulFileSize;

    // That's a minimum buffer size that can be used
    if ( size < FILE_BUFFER_SIZE )
    {
        size = FILE_BUFFER_SIZE;
    }

    *ppCompressedBuffer = static_cast<PUCHAR>(RtlAllocateHeap(
                                                              RtlProcessHeap(),
                                                              0,
                                                              size
                                                            ));

    if ( !*ppCompressedBuffer )
    {
        return E_OUTOFMEMORY;
    }

    status = RtlCompressBuffer(
                COMPRESSION_FORMAT_LZNT1 | COMPRESSION_ENGINE_MAXIMUM,
                pInputBuffer,
                size,
                *ppCompressedBuffer,
                size,
                0,
                &size,
                workSpace
                );

    if (!NT_SUCCESS(status))
    {
        if (STATUS_BUFFER_TOO_SMALL == status)
        {
#ifdef DEBUG
            printf("STATUS_BUFFER_TOO_SMALL\n");
            printf("RtlCompressBuffer returned 0x%08X.\n", status);
#endif //DEBUG
        }
        else
        {
#ifdef DEBUG
            printf("RtlCompressBuffer returned 0x%08X.\n", status);
#endif //DEBUG
        }
        return E_FAIL;
    }

    *pulFileSize = size;

    RtlFreeHeap(
                   RtlProcessHeap(),
                   0,
                   workSpace
               );

    return  S_OK;
}


/////////////////////////////////////////////////////////////////////////////
//
// IASUnCompress
//
//
/////////////////////////////////////////////////////////////////////////////
HRESULT IASUnCompress(
                   PUCHAR pInputBuffer, 
                   ULONG*  pulFileSize,
                   PUCHAR* ppDeCompressedBuffer
                  )
{
    ULONG size, ignore;

    NTSTATUS status = RtlGetCompressionWorkSpaceSize(
                COMPRESSION_FORMAT_LZNT1 | COMPRESSION_ENGINE_MAXIMUM,
                &size,
                &ignore
                );


   if ( !NT_SUCCESS(status) )
   {
#ifdef DEBUG
      printf("RtlGetCompressionWorkSpaceSize returned 0x%08X.\n", status);
#endif //DEBUG
      return        E_FAIL;
   }

   size = *pulFileSize;

   if( FILE_BUFFER_SIZE >= size)
   {
       size = FILE_BUFFER_SIZE;
   }

   *ppDeCompressedBuffer = static_cast<PUCHAR>(RtlAllocateHeap(
                RtlProcessHeap(),
                0,
                size * DECOMPRESS_FACTOR
                ));
   if ( !*ppDeCompressedBuffer )
   {
       return E_OUTOFMEMORY;
   }

   ULONG        UncompressedSize;

   status = RtlDecompressBuffer(
                COMPRESSION_FORMAT_LZNT1 | COMPRESSION_ENGINE_MAXIMUM,
                *ppDeCompressedBuffer,
                size * DECOMPRESS_FACTOR,
                pInputBuffer,
                *pulFileSize ,
                &UncompressedSize
                );

   if ( !NT_SUCCESS(status) )
   {
#ifdef DEBUG
        printf("RtlUnCompressBuffer returned 0x%08X.\n", status);
#endif //DEBUG

        switch (status)
        {
        case STATUS_INVALID_PARAMETER:
#ifdef DEBUG
            printf("STATUS_INVALID_PARAMETER");
#endif //DEBUG
            break;

        case STATUS_BAD_COMPRESSION_BUFFER:
#ifdef DEBUG
            printf("STATUS_BAD_COMPRESSION_BUFFER ");
            printf("size = %d %d",pulFileSize,UncompressedSize);

#endif //DEBUG
            break;
        case STATUS_UNSUPPORTED_COMPRESSION:
#ifdef DEBUG
            printf("STATUS_UNSUPPORTED_COMPRESSION  ");
#endif //DEBUG
            break;
        }
      return        E_FAIL;
   }

   *pulFileSize = UncompressedSize;

    return      S_OK;
}


/////////////////////////////////////////////////////////////////////////////
//
// IASFileToBase64
//
// Compress then encode to Base64
//
//  BSTR by Allocated IASFileToBase64, should be freed by the caller
//
/////////////////////////////////////////////////////////////////////////////
HRESULT 
IASFileToBase64(const wchar_t* pFileName, /*out*/ BSTR* pOutputBSTR)
{
    _ASSERTE(pFileName);
    _ASSERTE(pppOutputString);
    
    HRESULT hres;
    
    HANDLE hFileHandle = CreateFileW(
                        pFileName,  
                        GENERIC_READ,    
                        FILE_SHARE_READ, 
                        NULL,           
                        OPEN_EXISTING,  
                        FILE_ATTRIBUTE_NORMAL,   
                        NULL        
                      );
 
    if ( hFileHandle == INVALID_HANDLE_VALUE )
    {
#ifdef DEBUG
        wprintf(L"#filename = %s",pFileName);
        wprintf(L"### INVALID_HANDLE_VALUE ###\n");
#endif //DEBUG

        hres = E_FAIL;
        return      hres;
    }

    // safe cast from DWORD to ULONG
    ULONG ulFileSize = (ULONG) GetFileSize(
                                hFileHandle, // file for which to get size
                                NULL// high-order word of file size
                                  );

    if (0xFFFFFFFF == ulFileSize)
    {
#ifdef DEBUG
        wprintf(L"### GetFileSize Failed ###\n");
#endif //DEBUG

        hres = E_FAIL;
        return      hres;
    }
 

    HANDLE hFileMapping = CreateFileMapping(
                             hFileHandle,   // handle to file to map
                             NULL,          // optional security attributes
                             PAGE_READONLY, // protection for mapping object
                             0,         // high-order 32 bits of object size
                             0,         // low-order 32 bits of object size
                             NULL       // name of file-mapping object
                            );
 
    if (NULL == hFileMapping)
    {
#ifdef DEBUG
        wprintf(L"### CreateFileMapping Failed ###\n");
#endif //DEBUG

        hres = E_FAIL;
        return      hres;
    }

    LPVOID pMemoryFile = MapViewOfFile(
                         hFileMapping,  // file-mapping object to map into 
                                                   //  address space
                         FILE_MAP_READ,      // access mode
                         0,     // high-order 32 bits of file offset
                         0,      // low-order 32 bits of file offset
                         0  // number of bytes to map
                        );
 
    if (NULL == pMemoryFile)
    {
#ifdef DEBUG
        wprintf(L"### MapViewOfFile Failed ###\n");
#endif //DEBUG

        hres = E_FAIL;
        return      hres;
    }


    /////////////////////////////
    // NOW compress 
    /////////////////////////////

    wchar_t* pCompressedBuffer;

    CHECK_CALL_HRES (IASCompress((PUCHAR) pMemoryFile, 
               /*IN OUT*/(ULONG *)  &ulFileSize, 
               /*IN OUT*/(PUCHAR*) &pCompressedBuffer));

    /////////////////////
    // Encode to Base64
    /////////////////////

    CHECK_CALL_HRES (ToBase64(
                                pCompressedBuffer,
                                (ULONG) ulFileSize, 
                                pOutputBSTR
                              )
                    );
    
    /////////////////////////////
    // Clean
    /////////////////////////////

    RtlFreeHeap(
                RtlProcessHeap(),
                0,
                pCompressedBuffer
               );
    
    BOOL bResult = UnmapViewOfFile(
                                   pMemoryFile// address where mapped view begins
                                  );
    if (FALSE == bResult)
    {
#ifdef DEBUG
        wprintf(L"### UnmapViewOfFile Failed ###\n");
#endif //DEBUG

        hres = E_FAIL;
    }

    CloseHandle(hFileMapping);
    CloseHandle(hFileHandle);

    return      hres;
}


/////////////////////////////////////////////////////////////////////////////
//
// IASDumpConfig
//
// Dump the configuration to some temporary files, then indidually 
// compress then encode them.
// one big string is created from those multiple Base64 strings.
//
// Remarks: IASDumpConfig does a malloc and allocates memory for
// *ppDumpString. The calling function will have to free that memory 
//
/////////////////////////////////////////////////////////////////////////////
HRESULT 
IASDumpConfig(/*inout*/ wchar_t **ppDumpString, /*inout*/ ULONG *ulSize)
{
    _ASSERTE(ppDumpString);
    _ASSERTE(ulSize);
    
    HRESULT         hres;

    /////////////////////////////////////// 
    // delete the temporary files if any
    /////////////////////////////////////// 
    CHECK_CALL_HRES (DeleteTemporaryFiles());

    ////////////////////////////////////////////////////
    // Save the Registry keys. that creates many files
    ////////////////////////////////////////////////////
    CHECK_CALL_HRES (IASSaveRegKeys());

    ////////////////////// 
    // connect to the DB
    ////////////////////// 
    wchar_t* sz_DBPath;

    CHECK_CALL_HRES (IASExpandString(c_wcIAS_MDB_FILE_NAME, &sz_DBPath));

    CComPtr<IIASNetshJetHelper>     JetHelper;
    CHECK_CALL_HRES (CoCreateInstance(
                                         __uuidof(CIASNetshJetHelper),
                                         NULL,
                                         CLSCTX_SERVER,
                                         __uuidof(IIASNetshJetHelper),
                                         (PVOID*) &JetHelper
                                     ));
    
    CComBSTR     DBPath(sz_DBPath);
    if ( !DBPath ) { return E_OUTOFMEMORY; } 
    CHECK_CALL_HRES (JetHelper->OpenJetDatabase(DBPath, TRUE));

    //////////////////////////////////////
    // Create a new DB named "Backup.mdb"
    //////////////////////////////////////
    wchar_t* sz_FileBackup;

    CHECK_CALL_HRES (IASExpandString(c_wcFILE_BACKUP,
                                    &sz_FileBackup
                                   )
                    );

    CComBSTR BackupDb(sz_FileBackup);
    if ( !BackupDb ) { return E_OUTOFMEMORY; } 
    CHECK_CALL_HRES (JetHelper->CreateJetDatabase(BackupDb));

    
    ////////////////////////////////////////////////////////// 
    // exec the sql statements (to export)
    // the content into the temp database
    ////////////////////////////////////////////////////////// 
    wchar_t*  sz_SelectProperties;

    CHECK_CALL_HRES (IASExpandString(c_wcSELECT_PROPERTIES_INTO,
                                    &sz_SelectProperties  
                                   )
                    );

    CComBSTR     SelectProperties(sz_SelectProperties);
    if ( !SelectProperties ) { return E_OUTOFMEMORY; } 
    CHECK_CALL_HRES (JetHelper->ExecuteSQLCommand(SelectProperties));

    wchar_t*  sz_SelectObjects;

    CHECK_CALL_HRES (IASExpandString(c_wcSELECT_OBJECTS_INTO,
                                    &sz_SelectObjects
                                   )
                    );
    
    CComBSTR     SelectObjects(sz_SelectObjects);
    if ( !SelectObjects ) { return E_OUTOFMEMORY; } 
    CHECK_CALL_HRES (JetHelper->ExecuteSQLCommand(SelectObjects));

    wchar_t*  sz_SelectVersion;

    CHECK_CALL_HRES (IASExpandString(c_wcSELECT_VERSION_INTO,
                                    &sz_SelectVersion
                                   )
                    );

    CComBSTR     SelectVersion(sz_SelectVersion);
    if ( !SelectVersion ) { return E_OUTOFMEMORY; } 
    CHECK_CALL_HRES (JetHelper->ExecuteSQLCommand(SelectVersion));

    /////////////////////////////////////////////
    // transform the file into Base64 BSTR
    /////////////////////////////////////////////

    BSTR       FileBackupBSTR;

    CHECK_CALL_HRES (IASFileToBase64(
                                    sz_FileBackup,
                                    &FileBackupBSTR
                                    )
                    );

    int     NumberOfKeyFiles = celems(c_wcKEYS);

    BSTR    pFileKeys[celems(c_wcKEYS)];

    wchar_t*  sz_FileRegistry;

    CHECK_CALL_HRES (IASExpandString(c_wcKEYS_FILE,
                                    &sz_FileRegistry
                                   )
                    );

    for ( int i = 0; i < NumberOfKeyFiles; ++i )
    {

        wstring         sFileName(sz_FileRegistry);
        wchar_t           buffer[SIZE_LONG_MAX];
        _itow(i, buffer, 10); // 10 means base 10
        sFileName += buffer;
        sFileName += L".txt";

        CHECK_CALL_HRES (IASFileToBase64(
                                        sFileName.c_str(),
                                        &pFileKeys[i]
                                        )
                        );

    }
    CoTaskMemFree(sz_FileRegistry);

    
    ///////////////////////////////////////////////
    // alloc the memory for full the Base64 string
    ///////////////////////////////////////////////

    *ulSize = SysStringByteLen(FileBackupBSTR)
              + EXTRA_CHAR_SPACE;

    for ( int j = 0; j < NumberOfKeyFiles; ++j )
    {
        *ulSize += SysStringByteLen(pFileKeys[j]);
        *ulSize += 2; // extra characters
    }

    *ppDumpString = (wchar_t *) calloc(
                                      *ulSize ,
                                      sizeof(wchar_t)
                                     );

    //////////////////////////////////////////////////
    // copy the different strings into one big string
    //////////////////////////////////////////////////
    if (*ppDumpString)
    {
        wcsncpy(
                (wchar_t*) *ppDumpString, 
                (wchar_t*) FileBackupBSTR, 
                SysStringLen(FileBackupBSTR)
               );
        
        for ( int k = 0; k < NumberOfKeyFiles; ++k )
        {
            wcscat(
                    (wchar_t*) *ppDumpString, 
                    L"*\\\n" 
                  );

            wcsncat(
                    (wchar_t*) *ppDumpString,
                    (wchar_t*) pFileKeys[k], 
                    SysStringLen(pFileKeys[k])
                   );
        }

        wcscat(
                (wchar_t*) *ppDumpString, 
                L"QWER    *    QWER\\\n" 
              );   

        *ulSize = wcslen(*ppDumpString);
    }
    else
    {
        hres = E_OUTOFMEMORY;
#ifdef DEBUG
        wprintf(L"### calloc failed ###\n");
#endif //DEBUG

    }

    /////////////////////////////////////// 
    // delete the temporary files if any
    /////////////////////////////////////// 
    CHECK_CALL_HRES (DeleteTemporaryFiles());

    /////////////////////////////////////////////
    // Clean
    /////////////////////////////////////////////
    
    for ( int k = 0; k < NumberOfKeyFiles; ++k )
    {
        SysFreeString(pFileKeys[k]);
    }

    CoTaskMemFree(sz_SelectVersion);
    CoTaskMemFree(sz_SelectProperties);
    CoTaskMemFree(sz_SelectObjects);
    CoTaskMemFree(sz_FileBackup);
    CoTaskMemFree(sz_DBPath);
    SysFreeString(FileBackupBSTR);
    CHECK_CALL_HRES (JetHelper->CloseJetDatabase());

    return      hres;
}


/////////////////////////////////////////////////////////////////////////////
//
//  IASSaveToFile
//
// Remark: if a new table has to be saved, an "entry" for that should be 
// created in that function to deal with the filemname
//
/////////////////////////////////////////////////////////////////////////////
HRESULT IASSaveToFile(
                     /* in */ int Index, 
                     /* in */ wchar_t* pContent, 
                     DWORD lSize = 0
                    )
{
    HRESULT hres;
    wstring sFileName;

    switch (Index)
    {
    case BACKUP_NB:
        {
            wchar_t* sz_FileBackup;

            CHECK_CALL_HRES (IASExpandString(c_wcIAS_OLD,
                                               &sz_FileBackup
                                              )
                            );
            sFileName = sz_FileBackup;

            CoTaskMemFree(sz_FileBackup);
            break;
        }

    ///////////
    // binary
    ///////////
    default:
        {
            ///////////////////////////////////
            // i + BINARY_NB is the parameter
            ///////////////////////////////////
            wchar_t* sz_FileRegistry;

            CHECK_CALL_HRES (IASExpandString(c_wcKEYS_FILE,
                                            &sz_FileRegistry
                                           )
                            );

            sFileName = sz_FileRegistry;
            wchar_t           buffer[SIZE_LONG_MAX];

            _itow(Index - BINARY_NB, buffer, 10); // 10 means base 10
            sFileName += buffer;
            sFileName += L".txt";
    
            CoTaskMemFree(sz_FileRegistry);
            break;
        }
    }

    HANDLE hFile = CreateFileW(
                                sFileName.c_str(),
                                GENERIC_WRITE,
                                FILE_SHARE_WRITE | FILE_SHARE_READ,
                                NULL,
                                CREATE_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL
                              );

    if (INVALID_HANDLE_VALUE == hFile)
    {
        hres = E_FAIL;
    }
    else
    {
        DWORD NumberOfBytesWritten;
        BOOL bResult = WriteFile(
                                    hFile,
                                    (LPVOID) pContent,
                                    lSize,     
                                    &NumberOfBytesWritten,
                                    NULL
                                 );

        if (bResult)
        {
            hres = S_OK;
        }
        else
        {
            hres = E_FAIL;
        }
        CloseHandle(hFile);
    }

    return hres;
}


/////////////////////////////////////////////////////////////////////////////
// IASRestoreConfig
//
// Clean the DB first, then insert back everything.
/////////////////////////////////////////////////////////////////////////////
HRESULT IASRestoreConfig(
                           /*in*/ const wchar_t *pRestoreString, 
                           /*in*/ IAS_SHOW_TOKEN_LIST configType
                        )
{
   _ASSERTE(pRestoreString);

   bool bCoInitialized = false;
   HRESULT hres = CoInitializeEx(NULL, COINIT_MULTITHREADED);
   
   if (FAILED(hres))
   {   
      if (RPC_E_CHANGED_MODE == hres)
      {
         hres = S_OK;
      }
      else
      {
         return hres;
      }
   }
   else
   {
      bCoInitialized = true;
   }

   BSTR bstr = NULL;
   do
   {
      /////////////////////////////////////// 
      // delete the temporary files if any
      /////////////////////////////////////// 
      CHECK_CALL_HRES_BREAK (DeleteTemporaryFiles());

      CComPtr<IIASNetshJetHelper> JetHelper;
      CHECK_CALL_HRES_BREAK (CoCreateInstance(
                                          __uuidof(CIASNetshJetHelper),
                                          NULL,
                                          CLSCTX_SERVER,
                                          __uuidof(IIASNetshJetHelper),
                                          (PVOID*) &JetHelper
                                       ));
    
      bstr = SysAllocStringLen(
                                 pRestoreString, 
                                 wcslen(pRestoreString) + 2
                              );
    
      if (bstr == NULL)
      {
   #ifdef DEBUG
         wprintf(L"### IASRestoreConfig->SysAllocStringLen failed\n"); 
   #endif //DEBUG

         return E_OUTOFMEMORY;
      }

      int RealNumberOfFiles = MAX_FILES + celems(c_wcKEYS);

      for ( int i = 0; i < RealNumberOfFiles; ++i )
      {
         BLOB lBlob;

         lBlob.cbSize    = 0;
         lBlob.pBlobData = NULL;
         // split the files and registry info
         // uncompress (in memory ?)

         CHECK_CALL_HRES_BREAK (FromBase64(bstr, &lBlob, i));

         ULONG ulSize = lBlob.cbSize;
         PUCHAR pDeCompressedBuffer;

         if (ulSize == 0)
         {
            // file with less sections than expected
            // for instance before the number of reg keys increased
            // ignore
            continue;
         }

         ////////////////////////////////////
         // decode and decompress the base64
         ////////////////////////////////////

         CHECK_CALL_HRES_BREAK (IASUnCompress(
                                          lBlob.pBlobData, 
                                          &ulSize,
                                          &pDeCompressedBuffer
                                       ))

         if ( i >= MAX_FILES )
         {
            /////////////////////////////////////
            // Binary;  i + BINARY_NB used here
            /////////////////////////////////////
            IASSaveToFile( 
                        i - MAX_FILES + BINARY_NB, 
                        (wchar_t*)pDeCompressedBuffer, 
                        (DWORD) ulSize
                        );
         }
         else
         {
            IASSaveToFile( 
                        i, 
                        (wchar_t*)pDeCompressedBuffer, 
                        (DWORD) ulSize
                        );
         }
        
         ////////////
         // Clean
         ////////////
         RtlFreeHeap(RtlProcessHeap(), 0, pDeCompressedBuffer);

         CoTaskMemFree(lBlob.pBlobData);
      }

      ///////////////////////////////////////////////////
      // Now Upgrade the database (That's transactional)
      ///////////////////////////////////////////////////
      hres = JetHelper->MigrateOrUpgradeDatabase(configType);

      if ( SUCCEEDED(hres) )
      {
   #ifdef DEBUG
         wprintf(L"### IASRestoreConfig->DB stuff successful\n"); 
   #endif //DEBUG

         ////////////////////////////////////////////////////////
         // Now restore the registry.
         ////////////////////////////////////////////////////////
         hres = IASRestoreRegKeys(configType);
         if ( FAILED(hres) )
         {
#ifdef DEBUG
         wprintf(L"### IASRestoreConfig->restore reg keys failed\n"); 
#endif //DEBUG
         }
      }
      // delete the temporary files 
      DeleteTemporaryFiles(); // do not check the result
   } while (false);

   SysFreeString(bstr);    
   
   if (bCoInitialized)
   {
      CoUninitialize();
   }
   return  hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\aaaa\rmstring.h ===
//////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// Module Name:
//
//    rmstring.h
//
//////////////////////////////////////////////////////////////////////////////
#ifndef _RMSTRING_H__
#define _RMSTRING_H__
#if _MSC_VER > 1000
#pragma once
#endif

#define MSG_HELP_START                      L"%1!-14s! - "
#define MSG_NEWLINE                         L"\n"

#define MSG_AAAACONFIG_DUMP                 L""
#define MSG_AAAACONFIG_BLOBBEGIN_A          L"pushd aaaa\nset config "
#define MSG_AAAACONFIG_BLOBBEGIN_B          L"type="
#define MSG_AAAACONFIG_BLOBBEGIN_C          L" blob=\\\n"
#define MSG_AAAACONFIG_BLOBEND              L"\npopd\n"


#define CMD_GROUP_SHOW                      L"show"
#define CMD_GROUP_SET                       L"set"

#define CMD_AAAA_HELP1                      L"help"
#define CMD_AAAA_HELP2                      L"?"
#define CMD_AAAA_DUMP                       L"dump" 

#define CMD_AAAAVERSION_SHOW                L"version"

#define CMD_AAAACONFIG_SET                  L"config"
#define CMD_AAAACONFIG_SHOW                 L"config"

#define CMD_AAAACONFIG_SERVER_SETTINGS               L"server_settings"
#define CMD_AAAACONFIG_CLIENTS                       L"clients"
#define CMD_AAAACONFIG_CONNECTION_REQUEST_POLICIES   L"connection_request_policies"
#define CMD_AAAACONFIG_LOGGING                       L"logging"
#define CMD_AAAACONFIG_REMOTE_ACCESS_POLICIES        L"remote_access_policies"

#define TOKEN_SET                           L"set"
#define TOKEN_BLOB                          L"blob"
#define TOKEN_SHOW                          L"show"
#define TOKEN_TYPE                          L"type"
#define TOKEN_VERSION                       L"version"
#define TOKEN_CONFIG                        L"config"
#define TOKEN_SERVER_SETTINGS               L"server_settings"
#define TOKEN_CLIENTS                       L"clients"
#define TOKEN_CONNECTION_REQUEST_POLICIES   L"connection_request_policies"
#define TOKEN_LOGGING                       L"logging"
#define TOKEN_REMOTE_ACCESS_POLICIES        L"remote_access_policies"

#endif //_RMSTRING_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\aaaa\stdafx.h ===
//////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2000  Microsoft Corporation
//
// Module Name:
//
//    stdafx.h
//
// Abstract:
//
// Revision History:
//  
//    Thierry Perraut 04/17/2000
//
//////////////////////////////////////////////////////////////////////////////
#ifndef MAX_DLL_NAME
#define MAX_DLL_NAME    48
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>

#include <oleauto.h>
#include <objbase.h>
#include <atlbase.h>
#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <memory.h>
#include <malloc.h>
#include <tchar.h>
#include <rtutils.h>
#include <dsgetdc.h>

#include "iasmdbtool.h"
#include "base64tool.h"
#include <netsh.h>
#include <netshp.h>
#include "aaaamontr.h"
#include "utils.h"
#include "context.h"
#include "userenv.h"

// for the Jet wrapper
#include "datastore2.h"
#include "iasuuid.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\aaaa\utils.h ===
//////////////////////////////////////////////////////////////////////////////
//
// Copyright Microsoft Corporation
//
// Module Name:
//
//    utils.h
//
//////////////////////////////////////////////////////////////////////////////
#ifndef _UTILS_H_
#define _UTILS_H_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#define BREAK_ON_DWERR(_e) if ((_e)) break;

#define RutlDispTokenErrMsg(hModule, dwMsgId, pwszTag, pwszValue) \
        DisplayMessage( hModule, dwMsgId, pwszValue, pwszTag)

HRESULT RefreshIASService();

AAAA_PARSE_FN               RutlParse;

VOID 
WINAPI
RutlFree(
            IN PVOID pvData
        );


#ifdef __cplusplus
}
#endif
#endif //_UTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\aaaa\utils.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1999  Microsoft Corporation
//
// Module Name:
//
//    utils.c
//
// Abstract:
//
//      utils functions
//
// Revision History:
//  
//    Thierry Perraut 04/07/1999
//
//////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"

#include <netsh.h>
#include "aaaamontr.h"
#include "strdefs.h"
#include "rmstring.h"
#include "aaaamon.h"
#include "context.h"
#include <rtutils.h>
#include "utils.h"
#include "base64tool.h"

const WCHAR c_szCurrentBuildNumber[]      = L"CurrentBuildNumber";
const WCHAR c_szWinVersionPath[]          =
    L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion";
const WCHAR c_szAssignFmt[]               = L"%s = %s";
const WCHAR pszAAAAEngineParamStub[]   = 
    L"SYSTEM\\CurrentControlSet\\Services\\AAAAEngine\\Parameters\\";

AAAA_ALLOC_FN               RutlAlloc;
AAAA_DWORDDUP_FN            RutlDwordDup;
AAAA_CREATE_DUMP_FILE_FN    RutlCreateDumpFile;
AAAA_CLOSE_DUMP_FILE_FN     RutlCloseDumpFile;
AAAA_ASSIGN_FROM_TOKENS_FN  RutlAssignmentFromTokens;
AAAA_STRDUP_FN              RutlStrDup;
AAAA_FREE_FN                RutlFree;
AAAA_GET_OS_VERSION_FN      RutlGetOsVersion;
AAAA_GET_TAG_TOKEN_FN       RutlGetTagToken;
AAAA_IS_HELP_TOKEN_FN       RutlIsHelpToken;



//////////////////////////////////////////////////////////////////////////////
// RutlGetTagToken
// 
// Routine Description:
// 
//     Identifies each argument based on its tag. It assumes that each argument
//     has a tag. It also removes tag= from each argument.
// 
// Arguments:
// 
//     ppwcArguments  - The argument array. Each argument has tag=value form
//     dwCurrentIndex - ppwcArguments[dwCurrentIndex] is first arg.
//     dwArgCount     - ppwcArguments[dwArgCount - 1] is last arg.
//     pttTagToken    - Array of tag token ids that are allowed in the args
//     dwNumTags      - Size of pttTagToken
//     pdwOut         - Array identifying the type of each argument.
// 
// Return Value:
// 
//     NO_ERROR, ERROR_INVALID_PARAMETER, ERROR_INVALID_OPTION_TAG
// 
//////////////////////////////////////////////////////////////////////////////
DWORD
WINAPI
RutlGetTagToken(
                IN  HANDLE      hModule,
                IN  PWCHAR      *ppwcArguments,
                IN  DWORD       dwCurrentIndex,
                IN  DWORD       dwArgCount,
                IN  PTAG_TYPE   pttTagToken,
                IN  DWORD       dwNumTags,
                OUT PDWORD      pdwOut
               )
{
    PWCHAR     pwcTag,pwcTagVal,pwszArg = NULL;

    //
    // This function assumes that every argument has a tag
    // It goes ahead and removes the tag.
    //

    for ( DWORD i = dwCurrentIndex; i < dwArgCount; ++i )
    {
        DWORD len = wcslen(ppwcArguments[i]);

        if ( !len )
        {
            //
            // something wrong with arg
            //

            pdwOut[i] = static_cast<DWORD> (-1);
            continue;
        }

        pwszArg = static_cast<unsigned short *>(RutlAlloc(
                                                   (len + 1) * sizeof(WCHAR),
                                                   FALSE));

        if ( !pwszArg )
        {
            DisplayError(NULL, ERROR_NOT_ENOUGH_MEMORY);
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        wcscpy(pwszArg, ppwcArguments[i]);

        pwcTag = wcstok(pwszArg, NETSH_ARG_DELIMITER);

        //
        // Got the first part
        // Now if next call returns NULL then there was no tag
        //

        pwcTagVal = wcstok((PWCHAR)NULL,  NETSH_ARG_DELIMITER);

        if ( !pwcTagVal )
        {
            DisplayMessage(g_hModule, 
                           ERROR_NO_TAG,
                           ppwcArguments[i]);

            RutlFree(pwszArg);

            return ERROR_INVALID_PARAMETER;
        }

        //
        // Got the tag. Now try to match it
        //

        BOOL bFound = FALSE;
        pdwOut[i - dwCurrentIndex] = (DWORD) -1;

        for ( DWORD j = 0; j < dwNumTags; ++j )
        {
            if ( MatchToken(pwcTag, pttTagToken[j].pwszTag) )
            {
                //
                // Tag matched
                //

                bFound = TRUE;
                pdwOut[i - dwCurrentIndex] = j;
                break;
            }
        }

        if ( bFound )
        {
            //
            // Remove tag from the argument
            //

            wcscpy(ppwcArguments[i], pwcTagVal);
        }
        else
        {
            DisplayError(NULL,
                         ERROR_INVALID_OPTION_TAG, 
                         pwcTag);

            RutlFree(pwszArg);

            return ERROR_INVALID_OPTION_TAG;
        }

        RutlFree(pwszArg);
    }

    return NO_ERROR;
}


//////////////////////////////////////////////////////////////////////////////
// RutlCreateDumpFile
//////////////////////////////////////////////////////////////////////////////
DWORD
WINAPI
RutlCreateDumpFile(
                   IN  PWCHAR  pwszName,
                   OUT PHANDLE phFile
                  )
{
    HANDLE  hFile;

    *phFile = NULL;

    // Create/open the file
    hFile = CreateFileW(pwszName,
                        GENERIC_WRITE,
                        FILE_SHARE_READ | FILE_SHARE_DELETE,
                        NULL,
                        OPEN_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);

    if ( hFile == INVALID_HANDLE_VALUE )
    {
        return GetLastError();
    }

    // Go to the end of the file
    SetFilePointer(hFile, 0, NULL, FILE_END);    

    *phFile = hFile;

    return NO_ERROR;
}


//////////////////////////////////////////////////////////////////////////////
// RutlCloseDumpFile
//////////////////////////////////////////////////////////////////////////////
VOID
WINAPI
RutlCloseDumpFile(HANDLE  hFile)
{
    CloseHandle(hFile);
}


//////////////////////////////////////////////////////////////////////////////
//
// RutlAlloc
//
// Returns an allocated block of memory conditionally
// zeroed of the given size.
//
//////////////////////////////////////////////////////////////////////////////
PVOID 
WINAPI
RutlAlloc(
    IN DWORD    dwBytes,
    IN BOOL     bZero
    )
{
    DWORD dwFlags = 0;

    if ( bZero )
    {
        dwFlags |= HEAP_ZERO_MEMORY;
    }

    return HeapAlloc(GetProcessHeap(), dwFlags, dwBytes);
}


//////////////////////////////////////////////////////////////////////////////
//
// RutlFree
//
// Conditionally free's a pointer if it is non-null
//
//////////////////////////////////////////////////////////////////////////////
VOID 
WINAPI
RutlFree(
            IN PVOID pvData
        )
{
    HeapFree(GetProcessHeap(), 0, pvData);
}


//////////////////////////////////////////////////////////////////////////////
// 
// RutlStrDup
// 
// Uses RutlAlloc to copy a string
//
//////////////////////////////////////////////////////////////////////////////
PWCHAR
WINAPI
RutlStrDup(
            IN PWCHAR pwszSrc
          )
{
    PWCHAR  pszRet = NULL;
    DWORD   dwLen; 
    
    if (( !pwszSrc ) || ((dwLen = wcslen(pwszSrc)) == 0))
    {
        return NULL;
    }

    pszRet = static_cast<PWCHAR>(RutlAlloc((dwLen + 1) * sizeof(WCHAR),FALSE));
    if ( pszRet )
    {
        wcscpy(pszRet, pwszSrc);
    }

    return pszRet;
}


//////////////////////////////////////////////////////////////////////////////
// RutlDwordDup
// 
// Uses RutlAlloc to copy a dword
//
//////////////////////////////////////////////////////////////////////////////
LPDWORD
WINAPI
RutlDwordDup(
              IN DWORD dwSrc
            )
{
    LPDWORD lpdwRet = NULL;
    
    lpdwRet = static_cast<LPDWORD>(RutlAlloc(sizeof(DWORD), FALSE));
    if ( lpdwRet )
    {
        *lpdwRet = dwSrc;
    }

    return lpdwRet;
}

    
//////////////////////////////////////////////////////////////////////////////
//
// RutlGetOsVersion
//
// Returns the build number of operating system
//
//////////////////////////////////////////////////////////////////////////////
DWORD
WINAPI
RutlGetOsVersion(
    IN  PWCHAR  pwszRouter, 
    OUT LPDWORD lpdwVersion)
{

    DWORD   dwErr, dwType = REG_SZ, dwLength;
    HKEY    hkMachine = NULL, hkVersion = NULL;
    WCHAR   pszBuildNumber[64];
    PWCHAR  pszMachine = pwszRouter;

    //
    // Validate and initialize
    //
    if ( !lpdwVersion ) 
    { 
        return ERROR_INVALID_PARAMETER; 
    }
    *lpdwVersion = FALSE;

    do 
    {
        //
        // Connect to the remote server
        //
        dwErr = RegConnectRegistry(
                    pszMachine,
                    HKEY_LOCAL_MACHINE,
                    &hkMachine);
        if ( dwErr != ERROR_SUCCESS )        
        {
            break;
        }

        //
        // Open the windows version key
        //

        dwErr = RegOpenKeyEx(
                    hkMachine, 
                    c_szWinVersionPath, 
                    0, 
                    KEY_QUERY_VALUE, 
                    &hkVersion
                    );
        if ( dwErr != NO_ERROR ) 
        { 
            break; 
        }

        //
        // Read in the current version key
        //
        dwLength = sizeof(pszBuildNumber);
        dwErr = RegQueryValueEx (
                    hkVersion, 
                    c_szCurrentBuildNumber, 
                    NULL, 
                    &dwType,
                    (BYTE*)pszBuildNumber, 
                    &dwLength
                    );
        if ( dwErr != NO_ERROR ) 
        { 
            break; 
        }

        *lpdwVersion = static_cast<DWORD>(wcstol(pszBuildNumber, NULL, 10));
        
    } while (FALSE);


    // Cleanup
    if ( hkVersion )
    {
        RegCloseKey( hkVersion );
    }
    if ( hkMachine )
    {
        RegCloseKey( hkMachine );
    }

    return dwErr;
}


//////////////////////////////////////////////////////////////////////////////
//
// RutlParseOptions
// 
// Routine Description:
// 
//     Based on an array of tag types returns which options are
//     included in the given command line.
// 
// Arguments:
// 
//     ppwcArguments   - Argument array
//     dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
//     dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg
// 
// Return Value:
// 
//     NO_ERROR
// 
//////////////////////////////////////////////////////////////////////////////
DWORD 
WINAPI
RutlParseOptions(
                    IN  PWCHAR*                 ppwcArguments,
                    IN  DWORD                   dwCurrentIndex,
                    IN  DWORD                   dwArgCount,
                    IN  DWORD                   dwNumArgs,
                    IN  TAG_TYPE*               rgTags,
                    IN  DWORD                   dwTagCount,
                    OUT LPDWORD*                ppdwTagTypes
                )
{
    LPDWORD     pdwTagType;
    DWORD       i, dwErr = NO_ERROR;
    
    // If there are no arguments, there's nothing to to
    //
    if ( !dwNumArgs )
    {   
        return NO_ERROR;
    }

    // Set up the table of present options
    pdwTagType = static_cast<LPDWORD>(RutlAlloc(
                                                 dwArgCount * sizeof(DWORD), 
                                                 TRUE
                                               ));
    if( !pdwTagType )
    {
        DisplayError(NULL, ERROR_NOT_ENOUGH_MEMORY);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    do {
        //
        // The argument has a tag. Assume all of them have tags
        //
        if( wcsstr(ppwcArguments[dwCurrentIndex], NETSH_ARG_DELIMITER) )
        {
            dwErr = RutlGetTagToken(
                        g_hModule, 
                        ppwcArguments,
                        dwCurrentIndex,
                        dwArgCount,
                        rgTags,
                        dwTagCount,
                        pdwTagType);

            if( dwErr != NO_ERROR )
            {
                if( dwErr == ERROR_INVALID_OPTION_TAG )
                {
                    dwErr = ERROR_INVALID_SYNTAX;
                    break;
                }
            }
        }
        else
        {
            //
            // No tags - all args must be in order
            //
            for( i = 0; i < dwNumArgs; ++i )
            {
                pdwTagType[i] = i;
            }
        }
        
    } while (FALSE);        

    // Cleanup
    {
        if ( dwErr == NO_ERROR )
        {
            *ppdwTagTypes = pdwTagType;
        }
        else
        {
            RutlFree(pdwTagType);
        }
    }

    return dwErr;
}


//////////////////////////////////////////////////////////////////////////////
//
// RutlIsHelpToken
//
//////////////////////////////////////////////////////////////////////////////
BOOL
WINAPI
RutlIsHelpToken(PWCHAR  pwszToken)
{
    if( MatchToken(pwszToken, CMD_AAAA_HELP1) )
    {
        return TRUE;
    }

    if( MatchToken(pwszToken, CMD_AAAA_HELP2) )
    {
        return TRUE;
    }

    return FALSE;
}


//////////////////////////////////////////////////////////////////////////////
//
// RutlAssignmentFromTokens
//
//////////////////////////////////////////////////////////////////////////////
PWCHAR
WINAPI
RutlAssignmentFromTokens(
                            IN HINSTANCE hModule,
                            IN PWCHAR pwszToken,
                            IN PWCHAR pszString
                        )
{
    PWCHAR pszRet = NULL, pszCmd = NULL;
    DWORD dwErr = NO_ERROR, dwSize;
    
    do 
    {
        pszCmd = pwszToken;

        // Compute the string lenghth needed
        //
        dwSize = wcslen(pszString)      + 
                 wcslen(pszCmd)         + 
                 wcslen(c_szAssignFmt)  + 
                 1;
        dwSize *= sizeof(WCHAR);

        // Allocate the return value
        pszRet = (PWCHAR) RutlAlloc(dwSize, FALSE);
        if (pszRet == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        // Copy in the command assignment
        _snwprintf(
                    pszRet, 
                    dwSize,
                    c_szAssignFmt, 
                    pszCmd, 
                    pszString
                  );

    } while ( FALSE );

    // Cleanup
    {
        if ( dwErr != NO_ERROR )
        {
            if ( pszRet )
            {
                RutlFree(pszRet);
            }
            pszRet = NULL;
        }
    }
    return pszRet;
}


//////////////////////////////////////////////////////////////////////////////
//
// RutlRegReadDword
//
//////////////////////////////////////////////////////////////////////////////
DWORD
RutlRegReadDword(
                    IN  HKEY hKey,
                    IN  PWCHAR pszValName,
                    OUT LPDWORD lpdwValue
                )
{
    DWORD dwSize = sizeof(DWORD), dwType = REG_DWORD, dwErr;

    dwErr = RegQueryValueExW(
                hKey,
                pszValName,
                NULL,
                &dwType,
                (LPBYTE)lpdwValue,
                &dwSize);
    if ( dwErr == ERROR_FILE_NOT_FOUND )
    {
        dwErr = NO_ERROR;
    }

    return dwErr;                
}                
        

//////////////////////////////////////////////////////////////////////////////
//
// RutlRegReadString
//
//////////////////////////////////////////////////////////////////////////////
DWORD
RutlRegReadString(
                    IN  HKEY hKey,
                    IN  PWCHAR pszValName,
                    OUT PWCHAR* ppszValue
                 )
{
    DWORD dwErr = NO_ERROR, dwSize = 0;

    *ppszValue = NULL;
    
    // Findout how big the buffer should be
    //
    dwErr = RegQueryValueExW(
                hKey,
                pszValName,
                NULL,
                NULL,
                NULL,
                &dwSize);
    if ( dwErr == ERROR_FILE_NOT_FOUND )
    {
        return NO_ERROR;
    }
    if ( dwErr != ERROR_SUCCESS )
    {
        return dwErr;
    }

    // Allocate the string
    //
    *ppszValue = (PWCHAR) RutlAlloc(dwSize, TRUE);
    if ( ! *ppszValue )
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    // Read the value in and return 
    //
    dwErr = RegQueryValueExW(
                hKey,
                pszValName,
                NULL,
                NULL,
                (LPBYTE)*ppszValue,
                &dwSize);
                
    return dwErr;
}


//////////////////////////////////////////////////////////////////////////////
//
// RutlRegReadString
//
//////////////////////////////////////////////////////////////////////////////
DWORD
RutlRegWriteDword(
                    IN HKEY hKey,
                    IN PWCHAR pszValName,
                    IN DWORD dwValue
                 )
{
    return RegSetValueExW(
                hKey,
                pszValName,
                0,
                REG_DWORD,
                (LPBYTE)&dwValue,
                sizeof(DWORD));
}


//////////////////////////////////////////////////////////////////////////////
//
// RutlRegWriteString
//
//////////////////////////////////////////////////////////////////////////////
DWORD
RutlRegWriteString(
                    IN HKEY hKey,
                    IN PWCHAR pszValName,
                    IN PWCHAR pszValue
                  )
{
    return RegSetValueExW(
                hKey,
                pszValName,
                0,
                REG_SZ,
                (LPBYTE)pszValue,
                (wcslen(pszValue) + 1) * sizeof(WCHAR));
}


//////////////////////////////////////////////////////////////////////////////
//RutlParse
//
// Generic parse
//
//////////////////////////////////////////////////////////////////////////////
DWORD
RutlParse(
            IN  PWCHAR*         ppwcArguments,
            IN  DWORD           dwCurrentIndex,
            IN  DWORD           dwArgCount,
            IN  BOOL*           pbDone,
            OUT AAAAMON_CMD_ARG* pAaaaArgs,
            IN  DWORD           dwAaaaArgCount
         )
{
    DWORD            i, dwNumArgs, dwErr, dwLevel = 0;
    LPDWORD          pdwTagType = NULL;
    TAG_TYPE*        pTags = NULL;
    AAAAMON_CMD_ARG*  pArg = NULL;

    if ( !dwAaaaArgCount )
    {
        return ERROR_INVALID_PARAMETER;
    }

    do 
    {
        // Initialize
        dwNumArgs = dwArgCount - dwCurrentIndex;
        
        // Generate a list of the tags
        //
        pTags = (TAG_TYPE*)
            RutlAlloc(dwAaaaArgCount * sizeof(TAG_TYPE), TRUE);
        if ( !pTags )
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }
        for ( i = 0; i < dwAaaaArgCount; ++i )
        {
            CopyMemory(&pTags[i], &pAaaaArgs[i].rgTag, sizeof(TAG_TYPE));
        }
    
        // Get the list of present options
        //
        dwErr = RutlParseOptions(
                    ppwcArguments,
                    dwCurrentIndex,
                    dwArgCount,
                    dwNumArgs,
                    pTags,
                    dwAaaaArgCount,
                    &pdwTagType);
        if ( dwErr != NO_ERROR )
        {
            break;
        }

        // Copy the tag info back
        //
        for ( i = 0; i < dwAaaaArgCount; ++i )
        {
            CopyMemory(&pAaaaArgs[i].rgTag, &pTags[i], sizeof(TAG_TYPE));
        }
    
        for( i = 0; i < dwNumArgs; ++i )
        {
            // Validate the current argument
            //
            if ( pdwTagType[i] >= dwAaaaArgCount )
            {
                i = dwNumArgs;
                dwErr = ERROR_INVALID_SYNTAX;
                break;
            }
            pArg = &pAaaaArgs[pdwTagType[i]];

            // Get the value of the argument
            //
            switch ( pArg->dwType )
            {
                case AAAAMONTR_CMD_TYPE_STRING:
                {
                    pArg->Val.pszValue = 
                        RutlStrDup(ppwcArguments[i + dwCurrentIndex]);
                    break;
                }
                    
                case AAAAMONTR_CMD_TYPE_ENUM:
                {
                    dwErr = MatchEnumTag(g_hModule,
                                         ppwcArguments[i + dwCurrentIndex],
                                         pArg->dwEnumCount,
                                         pArg->rgEnums,
                                         &(pArg->Val.dwValue));

                    if(dwErr != NO_ERROR)
                    {
                        RutlDispTokenErrMsg(
                            g_hModule, 
                            EMSG_BAD_OPTION_VALUE,
                            pArg->rgTag.pwszTag,
                            ppwcArguments[i + dwCurrentIndex]);
                        i = dwNumArgs;
                        dwErr = ERROR_INVALID_PARAMETER;
                    }
                    break;
                }
            }
            if ( dwErr != NO_ERROR )
            {
                break;
            }

            // Mark the argument as present if needed
            //
            if ( pArg->rgTag.bPresent )
            {
                dwErr = ERROR_TAG_ALREADY_PRESENT;
                i = dwNumArgs;
                break;
            }
            pArg->rgTag.bPresent = TRUE;
        }
        if( dwErr != NO_ERROR )
        {
            break;
        }

        // Make sure that all of the required parameters have
        // been included.
        //
        for ( i = 0; i < dwAaaaArgCount; ++i )
        {
            if ( (pAaaaArgs[i].rgTag.dwRequired & NS_REQ_PRESENT)
             && !pAaaaArgs[i].rgTag.bPresent )
            {
                DisplayMessage(g_hModule, EMSG_CANT_FIND_EOPT);
                dwErr = ERROR_INVALID_SYNTAX;
                break;
            }
        }
        if ( dwErr != NO_ERROR )
        {
            break;
        }

    } while (FALSE);  
    
    // Cleanup
    {
        if ( pTags )
        {
            RutlFree(pTags);
        }
        if ( pdwTagType )
        {
            RutlFree(pdwTagType);
        }
    }

    return dwErr;
}

    
//////////////////////////////////////////////////////////////////////////////
// RefreshIASService
//
// Send a control 128 (refresh)to IAS
//
//////////////////////////////////////////////////////////////////////////////
HRESULT RefreshIASService()
{
    SC_HANDLE   hManager = OpenSCManager(
                                          NULL,   
                                          SERVICES_ACTIVE_DATABASE,
                                          SC_MANAGER_CONNECT |
                                          SC_MANAGER_ENUMERATE_SERVICE |
                                          SC_MANAGER_QUERY_LOCK_STATUS
                                        );
    if ( !hManager )
    {
        return E_FAIL;
    }


    SC_HANDLE hService = OpenServiceW(
                                         hManager,  
                                         L"IAS",
                                         SERVICE_USER_DEFINED_CONTROL | 
                                         SERVICE_QUERY_STATUS
                                     );
    
    if ( !hService )
    {
        CloseServiceHandle(hManager);
        return E_FAIL;
    }
 
    SERVICE_STATUS      ServiceStatus;
    BOOL    bResultOk = QueryServiceStatus(
                                            hService,
                                            &ServiceStatus  
                                          );
    HRESULT     hres;
    if ( bResultOk )
    {
        if ( (SERVICE_STOPPED == ServiceStatus.dwCurrentState) ||
             (SERVICE_STOP_PENDING == ServiceStatus.dwCurrentState))
        {
            //////////////////////////////////////////////////
            // service not running = nothing to do to refresh
            //////////////////////////////////////////////////
            hres = S_OK;
        }
        else 
        {
            /////////////////////////////////////////////////////
            // the service is running thus send the refresh code
            /////////////////////////////////////////////////////
            BOOL    bControlOk = ControlService(
                                                   hService,
                                                   128,
                                                   &ServiceStatus  
                                               );
            if ( bControlOk == FALSE )
            {
                hres = E_FAIL;
            }
            else
            {
                hres = S_OK;
            }
        }
    }
    else
    {
        hres = E_FAIL;
    }

    //////////
    // clean
    //////////
    CloseServiceHandle(hService);
    CloseServiceHandle(hManager);
    // hres is always defined here.
    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\aaaa\strdefs.h ===
//////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// Module Name:
//
//    strdef.h
//
// Abstract:
//
//      NOTE - DONT USE 15000-15999
//
//////////////////////////////////////////////////////////////////////////////
#ifndef __STRDEFS_H__
#define __STRDEFS_H__
#if _MSC_VER > 1000
#pragma once
#endif

#define MSG_NULL                               1001
#define MSG_CMD_NOT_IMPLEMENTED                1004

#define HLP_AAAA_HELP1                          2300
#define HLP_AAAA_HELP1_EX                       2301
#define HLP_AAAA_HELP2                          HLP_AAAA_HELP1
#define HLP_AAAA_HELP2_EX                       HLP_AAAA_HELP1_EX

#define HLP_AAAA_DUMP                          3201
#define HLP_AAAA_DUMP_EX                       3202

#define HLP_AAAAVERSION_SHOW                   2342
#define HLP_AAAAVERSION_SHOW_EX                2343
#define HLP_AAAACONFIG_SET                     2344
#define HLP_AAAACONFIG_SET_EX                  2345
#define HLP_AAAACONFIG_SHOW                    2346
#define HLP_AAAACONFIG_SHOW_EX                 2347

#define HLP_AAAACONFIG_SERVER_SETTINGS                2348
#define HLP_AAAACONFIG_SERVER_SETTINGS_EX             2349
#define HLP_AAAACONFIG_CLIENTS                        2350
#define HLP_AAAACONFIG_CLIENTS_EX                     2351
#define HLP_AAAACONFIG_CONNECTION_REQUEST_POLICIES    2352
#define HLP_AAAACONFIG_CONNECTION_REQUEST_POLICIES_EX 2353
#define HLP_AAAACONFIG_LOGGING                        2354
#define HLP_AAAACONFIG_LOGGING_EX                     2355
#define HLP_AAAACONFIG_REMOTE_ACCESS_POLICIES         2356
#define HLP_AAAACONFIG_REMOTE_ACCESS_POLICIES_EX      2357

#define HLP_GROUP_SET                          3292
#define HLP_GROUP_SHOW                         3293

#define HLP_SHOW_SERVERS                       3301
#define HLP_SHOW_SERVERS_EX                    3302

#define MSG_AAAA_SCRIPTHEADER                  4501
#define MSG_AAAA_SCRIPTFOOTER                  4502
#define MSG_AAAA_SHOW_SERVERS_HEADER           4503

#define MSG_AAAACONFIG_SET_SUCCESS             5402
#define MSG_AAAACONFIG_SET_FAIL                5403
#define MSG_AAAACONFIG_SHOW_SUCCESS            5404
#define MSG_AAAACONFIG_SHOW_FAIL               5405
#define MSG_AAAACONFIG_SHOW_HEADER             5406
#define MSG_AAAACONFIG_SHOW_FOOTER             5407
#define MSG_AAAAVERSION_SHOW_SUCCESS           5408
#define MSG_AAAAVERSION_SHOW_FAIL              5409
#define MSG_AAAAVERSION_GET_FAIL               5410
#define MSG_AAAACONFIG_SHOW_INVALID_SYNTAX     5411
#define MSG_AAAACONFIG_SET_REGISTRY_FAIL       5412
#define MSG_AAAACONFIG_SET_REFRESH_FAIL        5413
#define MSG_AAAACONFIG_LICENSE_VIOLATION       5414

#define EMSG_TAG_ALREADY_PRESENT               10001
#define EMSG_CANT_FIND_EOPT                    10002
#define EMSG_BAD_OPTION_VALUE                  10003
#define EMSG_UNABLE_TO_CREATE_FILE             10005
#define EMSG_OPEN_DB_FAILED                    10006
#define EMSG_AAAACONFIG_SHOW_FAIL              10007
#define EMSG_AAAACONFIG_UPGRADE_FAIL           10008

#define EMSG_INCOMPLETE_COMMAND                11002

#endif //__STDEFS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\if\context.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    routing\netsh\if\context.h

Abstract:

Revision History:

--*/

DWORD
IfContextInstallSubContexts(
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\if\context.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    routing\netsh\if\ip\context.c

Abstract:

    If subcontexts.

Revision History:

    lokeshs

--*/

#include "precomp.h"

// Includes for the sub contexts
//
#include "ifip.h"

NS_HELPER_ATTRIBUTES g_pSubContexts[] =
{
    // Ip subcontext
    //
    {
        { IFIP_VERSION, 0 }, IFIP_GUID, IfIpStartHelper, NULL
    },
};

#define g_dwSubContextCount \
            (sizeof(g_pSubContexts) / sizeof(*g_pSubContexts))





//
// Installs all of the sub contexts provided
// in this .dll (for example, "if ip", and any new ones.)
//
DWORD
IfContextInstallSubContexts(
    )
{
    DWORD dwErr = NO_ERROR, i;

    PNS_HELPER_ATTRIBUTES pCtx = NULL;

    for (i = 0, pCtx = g_pSubContexts; i < g_dwSubContextCount; i++, pCtx++)
    {
        // Initialize helper attributes
        //
        RegisterHelper( &g_IfGuid, pCtx );
    }

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\if\ifhandle.h ===
FN_HANDLE_CMD    HandleIfAddIf;
FN_HANDLE_CMD    HandleIfDelIf;
FN_HANDLE_CMD    HandleIfSetCredentials;
FN_HANDLE_CMD    HandleIfShowIf;
FN_HANDLE_CMD    HandleIfShowCredentials;
FN_HANDLE_CMD    HandleIfSet;
FN_HANDLE_CMD    HandleIfResetAll;

NS_CONTEXT_DUMP_FN IfDump;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\if\ifhandle.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    routing\netsh\if\ifhandle.c

Abstract:

    Handlers for commands

Revision History:

    AmritanR

--*/

#include "precomp.h"
#pragma hdrstop

//
// Remove this when one can change interface friendly names
//
#define CANT_RENAME_IFS

extern ULONG g_ulNumTopCmds;
extern ULONG g_ulNumGroups;

extern CMD_GROUP_ENTRY      g_IfCmdGroups[];
extern CMD_ENTRY            g_IfCmds[];

DWORD
HandleIfAddIf(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description:

    Handler for adding an interface

Arguments:

    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg

Return Value:

    NO_ERROR

--*/

{
    return RtrHandleAdd(
                ppwcArguments,
                dwCurrentIndex,
                dwArgCount,
                pbDone);
}

DWORD
HandleIfDelIf(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )

/*++

Routine Description:

    Handler for deleting an interface

Arguments:

    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg

Return Value:

    NO_ERROR

--*/

{
    return RtrHandleDel(
                ppwcArguments,
                dwCurrentIndex,
                dwArgCount,
                pbDone);

}

DWORD
HandleIfShowIf(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description:

    Handler for displaying interfaces

Arguments:

    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg

Return Value:

    NO_ERROR

--*/

{
    if (dwArgCount == dwCurrentIndex)
    {
        DisplayMessage(g_hModule, MSG_IF_TABLE_HDR);
    }

    return RtrHandleShow(
                ppwcArguments,
                dwCurrentIndex,
                dwArgCount,
                pbDone);
}

DWORD
HandleIfShowCredentials(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description:

    Handler for showing credentials of an interface

Arguments:

    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg

Return Value:

    NO_ERROR

--*/
{
    return RtrHandleShowCredentials(
                ppwcArguments,
                dwCurrentIndex,
                dwArgCount,
                pbDone);
}

DWORD
HandleIfSetCredentials(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description:

    Handler for displaying interfaces

Arguments:

    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg

Return Value:

    NO_ERROR

--*/
{
    return RtrHandleSetCredentials(
                ppwcArguments,
                dwCurrentIndex,
                dwArgCount,
                pbDone);
}

DWORD
HandleIfSet(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description:

    Handler for displaying interfaces

Arguments:

    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg

Return Value:

    NO_ERROR

--*/
{
    return RtrHandleSet(
                ppwcArguments,
                dwCurrentIndex,
                dwArgCount,
                pbDone);
}

DWORD
HandleIfResetAll(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description:

    Handler for resetting everything.
    
Arguments:

    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg

Return Value:

    NO_ERROR

--*/
{
    return RtrHandleResetAll(
                ppwcArguments,
                dwCurrentIndex,
                dwArgCount,
                pbDone);
}

DWORD
IfDump(
    IN  LPCWSTR     pwszRouter,
    IN  LPWSTR     *ppwcArguments,
    IN  DWORD       dwArgCount,
    IN  LPCVOID     pvData
    )
{
    DWORD dwErr;

    dwErr = ConnectToRouter(pwszRouter);
    if (dwErr)
    {
        return dwErr;
    }

    return RtrDump(
                ppwcArguments,
                dwArgCount
                );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\if\defs.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    routing\monitor2\if\defs.h

Abstract:

    global definitions

Revision History:

    AmritanR

--*/


#define is      ==
#define isnot   !=
#define and     &&
#define or      ||

#define MAX_IF_FRIENDLY_NAME_LEN        512

#define LOCAL_ROUTER_PB_PATHW  L"%SystemRoot%\\system32\\RAS\\Router.Pbk"
#define REMOTE_ROUTER_PB_PATHW L"\\\\%ls\\Admin$\\system32\\RAS\\Router.Pbk"

#define IFMON_ERROR_BASE                0xFEFF0000

typedef DWORD          IPV4_ADDRESS, *PIPV4_ADDRESS;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\if\ifip.h ===
//=============================================================================
// Copyright (c) 1999 Microsoft Corporation
// File: ifip.h
//
// Author: K.S.Lokesh (lokeshs@)   8-1-99
//=============================================================================


#ifndef __IFIP_H
#define __IFIP_H


#define DBG1 0

//kslksl

#define TCP_XMT_CHECKSUM_OFFLOAD  0x00000001
#define IP_XMT_CHECKSUM_OFFLOAD   0x00000002
#define TCP_RCV_CHECKSUM_OFFLOAD  0x00000004
#define IP_RCV_CHECKSUM_OFFLOAD   0x00000008
#define TCP_LARGE_SEND_OFFLOAD    0x00000010

//
// IPSEC General Xmit\Recv capabilities
//
#define IPSEC_OFFLOAD_CRYPTO_ONLY   0x00000020      // Raw crypto mode supported
#define IPSEC_OFFLOAD_AH_ESP        0x00000040      // Combined AH+ESP supported
#define IPSEC_OFFLOAD_TPT_TUNNEL    0x00000080      // Combined Tpt+Tunnel supported
#define IPSEC_OFFLOAD_V4_OPTIONS    0x00000100      // IPV4 Options supported
#define IPSEC_OFFLOAD_QUERY_SPI     0x00000200      // Get SPI supported

//
// IPSEC AH Xmit\Recv capabilities
//
#define IPSEC_OFFLOAD_AH_XMT        0x00000400      // IPSEC supported on Xmit
#define IPSEC_OFFLOAD_AH_RCV        0x00000800      // IPSEC supported on Rcv
#define IPSEC_OFFLOAD_AH_TPT        0x00001000      // IPSEC transport mode supported
#define IPSEC_OFFLOAD_AH_TUNNEL     0x00002000      // IPSEC tunnel mode supported
#define IPSEC_OFFLOAD_AH_MD5        0x00004000      // MD5 supported as AH and ESP algo
#define IPSEC_OFFLOAD_AH_SHA_1      0x00008000      // SHA_1 supported as AH and ESP algo

//
// IPSEC ESP Xmit\Recv capabilities
//
#define IPSEC_OFFLOAD_ESP_XMT       0x00010000      // IPSEC supported on Xmit
#define IPSEC_OFFLOAD_ESP_RCV       0x00020000      // IPSEC supported on Rcv
#define IPSEC_OFFLOAD_ESP_TPT       0x00040000      // IPSEC transport mode supported
#define IPSEC_OFFLOAD_ESP_TUNNEL    0x00080000      // IPSEC tunnel mode supported
#define IPSEC_OFFLOAD_ESP_DES       0x00100000      // DES supported as ESP algo
#define IPSEC_OFFLOAD_ESP_DES_40    0x00200000      // DES40 supported as ESP algo
#define IPSEC_OFFLOAD_ESP_3_DES     0x00400000      // 3DES supported as ESP algo
#define IPSEC_OFFLOAD_ESP_NONE      0x00800000      // Null ESP supported as ESP algo





#define IFIP_GUID \
{0x89d00931, 0x1e00, 0x11d3, {0x87, 0x38, 0x00, 0x60, 0x08, 0x37, 0xc7, 0x75} }


#define IFIP_VERSION 1

#define ADD_FLAG 1
#define SET_FLAG 2
#define DEL_FLAG 4

#define RETURN_ERROR_OKAY(dwErr) \
    return (dwErr) == NO_ERROR? ERROR_OKAY : dwErr;


#if DBG1
#define DEBUG_PRINT_CONFIG(pRemoteIpInfo) {\
        DisplayMessage(g_hModule, MSG_DEBUG_HDR);\
        DisplayMessage(g_hModule,\
                   MSG_IPADDR_LIST,\
                   (pRemoteIpInfo)->pszwIpAddrList,\
                   (pRemoteIpInfo)->pszwSubnetMaskList);\
    \
        DisplayMessage(g_hModule,\
                   MSG_OPTIONS_LIST,\
                   (pRemoteIpInfo)->pszwOptionList);\
        DisplayMessage(g_hModule, MSG_DEBUG_HDR);\
    \
}
#else
#define DEBUG_PRINT_CONFIG(pRemoteIpInfo)
#endif

typedef enum _DISPLAY_TYPE {
    TYPE_ADDR=0x01,
    TYPE_GATEWAY=0x02,
    TYPE_IPADDR=0x03,
    TYPE_DNS=0x04,
    TYPE_WINS=0x08,
    TYPE_IFMETRIC=0x10,
    TYPE_DDNS=0x20,
    TYPE_IP_ALL=0xff,

    TYPE_OFFLOAD=0x0100
} DISPLAY_TYPE;

typedef enum _REGISTER_MODE {
    REGISTER_NONE      = 0,
    REGISTER_PRIMARY   = 1,
    REGISTER_BOTH      = 3,
    REGISTER_UNCHANGED = 0xff
} REGISTER_MODE;

NS_HELPER_START_FN IfIpStartHelper;
NS_CONTEXT_DUMP_FN  IfIpDump;

FN_HANDLE_CMD IfIpHandleSetAddress;
FN_HANDLE_CMD IfIpHandleSetDns;
FN_HANDLE_CMD IfIpHandleSetWins;
FN_HANDLE_CMD IfIpHandleAddAddress;
FN_HANDLE_CMD IfIpHandleAddDns;
FN_HANDLE_CMD IfIpHandleAddWins;
FN_HANDLE_CMD IfIpHandleSetLmhosts;


DWORD
IfIpAddMany(
    IN  PWCHAR  *ppwcArguments,
    IN  DWORD   dwCurrentIndex,
    IN  DWORD   dwArgCount,
    IN  BOOL    *pbDone,
    IN  DWORD   Type
    );

DWORD
IfIpSetDhcpModeMany(
    LPCWSTR     pwszIfFriendlyName,
    GUID         *pGuid,
    DWORD        dwRegisterMode,
    DISPLAY_TYPE Type
    );

DWORD
IfIpAddSetAddress(
    LPCWSTR     pwszIfFriendlyName,
    GUID         *pGuid,
    LPCWSTR      pwszAddr,
    LPCWSTR      pwszMask,
    DWORD        Flags
    );

DWORD
IfIpAddSetGateway(
    LPCWSTR pwszIfFriendlyName,
    GUID         *pGuid,
    LPCWSTR      pwszGateway,
    LPCWSTR      pwszGatewayMetric,
    DWORD        Flags
    );

FN_HANDLE_CMD IfIpHandleDelAddress;
FN_HANDLE_CMD IfIpHandleDelDns;
FN_HANDLE_CMD IfIpHandleDelWins;

DWORD
IfIpDelMany(
    IN  PWCHAR  *ppwcArguments,
    IN  DWORD   dwCurrentIndex,
    IN  DWORD   dwArgCount,
    IN  BOOL    *pbDone,
    IN  DISPLAY_TYPE Type
    );

FN_HANDLE_CMD IfIpHandleShowConfig;
FN_HANDLE_CMD IfIpHandleShowAddress;
FN_HANDLE_CMD IfIpHandleShowOffload;
FN_HANDLE_CMD IfIpHandleShowDns;
FN_HANDLE_CMD IfIpHandleShowWins;
FN_HANDLE_CMD IfIpHandleDelArpCache;
FN_HANDLE_CMD IfIpHandleReset;

DWORD
ShowInfoIpaddr(
    ULONG       IfIndex,
    GUID        *pGuid,
    PWCHAR      pFriendlyIfName
    );

DWORD
IfIpShowMany(
    IN  LPCWSTR pwszMachineName,
    IN  PWCHAR  *ppwcArguments,
    IN  DWORD   dwCurrentIndex,
    IN  DWORD   dwArgCount,
    IN  BOOL    *pbDone,
    IN  DISPLAY_TYPE  dtType
    );

DWORD
IfIpShowAllInterfaceInfo(
    LPCWSTR pwszMachineName,
    DISPLAY_TYPE Type,
    HANDLE hFile
    );

DWORD
IfIpHandleDelIpaddrEx(
    LPCWSTR wszIfFriendlyName,
    GUID         *pGuid,
    LPCWSTR      pwszIpAddr,
    LPCWSTR      pwszGateway,
    ULONG        Flags
    );

DWORD
OpenDriver(
    HANDLE *Handle,
    LPWSTR DriverName
    );

NTSTATUS
DoIoctl(
    HANDLE     Handle,
    DWORD      IoctlCode,
    PVOID      Request,
    DWORD      RequestSize,
    PVOID      Response,
    PDWORD     ResponseSize
    );


DWORD
IfIpShowManyEx(
    LPCWSTR pwszMachineName,
    ULONG IfIndex,
    PWCHAR wszIfFriendlyName,
    GUID *guid,
    DISPLAY_TYPE dtType,
    HANDLE hFile
    );

DWORD
IfIpShowManyExEx(
    LPCWSTR     pwszMachineName,
    ULONG       IfIndex,
    PWCHAR      pFriendlyIfName,
    GUID       *pGuid,
    ULONG       Flags,
    HANDLE      hFile
    );

DWORD
IfIpShowInfoOffload(
    ULONG IfIndex,
    PWCHAR wszIfFriendlyName
    );

DWORD
IfIpSetMany(
    IN  PWCHAR  *ppwcArguments,
    IN  DWORD   dwCurrentIndex,
    IN  DWORD   dwArgCount,
    IN  BOOL    *pbDone,
    IN  DWORD   Type
    );

DWORD
IfIpAddSetDelMany(
    PWCHAR wszIfFriendlyName,
    GUID         *pGuid,
    PWCHAR       pwszAddress,
    DWORD        dwIndex,
    DWORD        dwRegisterMode,
    DISPLAY_TYPE Type,
    DWORD        Flags
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\if\ifip.c ===
//=============================================================================
// Copyright (c) 1999 Microsoft Corporation
// File: ifip.c
// Abstract:
//      This module implements the if/ip apis
//
// Author: K.S.Lokesh (lokeshs@)   8-1-99
//=============================================================================


#include "precomp.h"
#pragma hdrstop
#include "ifip.h"

//
// global variables
//

#define IFIP_IFNAME_MASK   0x0001
#define IFIP_SOURCE_MASK   0X0002
#define IFIP_ADDR_MASK     0X0004
#define IFIP_MASK_MASK     0X0008
#define IFIP_GATEWAY_MASK  0X0010
#define IFIP_GWMETRIC_MASK 0X0020
#define IFIP_INDEX_MASK    0X0040

#define DHCP 1
#define STATIC 2
#define NONE ~0
#define ALL ~0


// The guid for this context
//
GUID g_IfIpGuid = IFIP_GUID;

// The commands supported in this context
//

CMD_ENTRY  g_IfIpAddCmdTable[] =
{
    CREATE_CMD_ENTRY_EX(IFIP_ADD_IPADDR,IfIpHandleAddAddress,CMD_FLAG_LOCAL),
    CREATE_CMD_ENTRY_EX(IFIP_ADD_DNS,IfIpHandleAddDns,CMD_FLAG_LOCAL),
    CREATE_CMD_ENTRY_EX(IFIP_ADD_WINS,IfIpHandleAddWins,CMD_FLAG_LOCAL),
};

CMD_ENTRY  g_IfIpSetCmdTable[] =
{
    CREATE_CMD_ENTRY_EX(IFIP_SET_IPADDR,IfIpHandleSetAddress,CMD_FLAG_LOCAL),
    CREATE_CMD_ENTRY_EX(IFIP_SET_DNS,IfIpHandleSetDns,CMD_FLAG_LOCAL),
    CREATE_CMD_ENTRY_EX(IFIP_SET_WINS,IfIpHandleSetWins,CMD_FLAG_LOCAL),
};

CMD_ENTRY  g_IfIpDelCmdTable[] =
{
    CREATE_CMD_ENTRY_EX(IFIP_DEL_IPADDR,IfIpHandleDelAddress,CMD_FLAG_LOCAL),
    CREATE_CMD_ENTRY_EX(IFIP_DEL_DNS,IfIpHandleDelDns,CMD_FLAG_LOCAL),
    CREATE_CMD_ENTRY_EX(IFIP_DEL_WINS,IfIpHandleDelWins,CMD_FLAG_LOCAL),
    CREATE_CMD_ENTRY_EX(IFIP_DEL_ARPCACHE,IfIpHandleDelArpCache,CMD_FLAG_LOCAL),
};


CMD_ENTRY  g_IfIpShowCmdTable[] =
{
    CREATE_CMD_ENTRY_EX(IFIP_SHOW_CONFIG,IfIpHandleShowConfig,CMD_FLAG_LOCAL),
    CREATE_CMD_ENTRY_EX(IFIP_SHOW_IPADDR,IfIpHandleShowAddress,CMD_FLAG_LOCAL),
    CREATE_CMD_ENTRY_EX(IFIP_SHOW_OFFLOAD,IfIpHandleShowOffload,CMD_FLAG_LOCAL),
    CREATE_CMD_ENTRY_EX(IFIP_SHOW_DNS, IfIpHandleShowDns,CMD_FLAG_LOCAL),
    CREATE_CMD_ENTRY_EX(IFIP_SHOW_WINS, IfIpHandleShowWins,CMD_FLAG_LOCAL),
    CREATE_CMD_ENTRY(IPMIB_SHOW_INTERFACE, HandleIpMibShowObject),
    CREATE_CMD_ENTRY(IPMIB_SHOW_IPSTATS,   HandleIpMibShowObject),
    CREATE_CMD_ENTRY(IPMIB_SHOW_IPADDRESS, HandleIpMibShowObject),
    CREATE_CMD_ENTRY(IPMIB_SHOW_IPNET,     HandleIpMibShowObject),
    CREATE_CMD_ENTRY(IPMIB_SHOW_ICMP,      HandleIpMibShowObject),
    CREATE_CMD_ENTRY(IPMIB_SHOW_TCPSTATS,  HandleIpMibShowObject),
    CREATE_CMD_ENTRY(IPMIB_SHOW_TCPCONN,   HandleIpMibShowObject),
    CREATE_CMD_ENTRY(IPMIB_SHOW_UDPSTATS,  HandleIpMibShowObject),
    CREATE_CMD_ENTRY(IPMIB_SHOW_UDPCONN,   HandleIpMibShowObject),
    CREATE_CMD_ENTRY_EX(IPMIB_SHOW_JOINS,  HandleIpShowJoins,CMD_FLAG_LOCAL),
};


CMD_GROUP_ENTRY g_IfIpCmdGroups[] =
{
    CREATE_CMD_GROUP_ENTRY(GROUP_ADD, g_IfIpAddCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_SET, g_IfIpSetCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_DELETE, g_IfIpDelCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_SHOW, g_IfIpShowCmdTable),
};

ULONG g_ulIfIpNumGroups = sizeof(g_IfIpCmdGroups)/sizeof(CMD_GROUP_ENTRY);


CMD_ENTRY g_IfIpTopCmds[] =
{
    CREATE_CMD_ENTRY_EX(IFIP_RESET, IfIpHandleReset, CMD_FLAG_LOCAL | CMD_FLAG_ONLINE),
};

ULONG g_ulIfIpNumTopCmds = sizeof(g_IfIpTopCmds)/sizeof(CMD_ENTRY);

#define DispTokenErrMsg(hModule, dwMsgId, pwszTag, pwszValue) \
        DisplayMessage( hModule, dwMsgId, pwszValue, pwszTag)



DWORD
WINAPI
IfIpStartHelper(
    IN CONST GUID *pguidParent,
    IN DWORD       dwVersion)
/*++

Routine Description

    Used to initialize the helper.

Arguments

    pguidParent     Ifmon's guid

Return Value

    NO_ERROR
    other error code
--*/
{

    DWORD dwErr = NO_ERROR;
    NS_CONTEXT_ATTRIBUTES       attMyAttributes;


    // Initialize
    //
    ZeroMemory(&attMyAttributes, sizeof(attMyAttributes));

    attMyAttributes.pwszContext = L"ip";
    attMyAttributes.guidHelper  = g_IfIpGuid;
    attMyAttributes.dwVersion   = IFIP_VERSION;
    attMyAttributes.dwFlags     = 0;
    attMyAttributes.ulNumTopCmds= g_ulIfIpNumTopCmds;
    attMyAttributes.pTopCmds    = (CMD_ENTRY (*)[])&g_IfIpTopCmds;
    attMyAttributes.ulNumGroups = g_ulIfIpNumGroups;
    attMyAttributes.pCmdGroups  = (CMD_GROUP_ENTRY (*)[])&g_IfIpCmdGroups;
    attMyAttributes.pfnDumpFn   = IfIpDump;

    dwErr = RegisterContext( &attMyAttributes );

    return dwErr;
}

DWORD
WINAPI
IfIpDump(
    IN  LPCWSTR     pwszRouter,
    IN  LPWSTR     *ppwcArguments,
    IN  DWORD       dwArgCount,
    IN  LPCVOID     pvData
    )
/*++

Routine Description

    Used when dumping all contexts

Arguments

Return Value

    NO_ERROR

--*/
{
    DWORD   dwErr;
    HANDLE  hFile = (HANDLE)-1;

    DisplayMessage( g_hModule, DMP_IFIP_HEADER );
    DisplayMessageT(DMP_IFIP_PUSHD);

    IfIpShowAllInterfaceInfo(pwszRouter, TYPE_IP_ALL, hFile);

    DisplayMessageT(DMP_IFIP_POPD);
    DisplayMessage( g_hModule, DMP_IFIP_FOOTER );

    return NO_ERROR;
}

DWORD
IfIpHandleSetAddress(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description

Arguments

Return Value

    NO_ERROR

--*/
{
    WCHAR       wszInterfaceName[MAX_INTERFACE_NAME_LEN + 1] = L"\0";
    PWCHAR      wszIfFriendlyName = NULL;

    DWORD       dwBufferSize = sizeof(wszInterfaceName);
    DWORD       dwErr = NO_ERROR,dwRes, dwErrIndex=-1;
    TAG_TYPE    pttTags[] = {
        {TOKEN_NAME,FALSE,FALSE},
        {TOKEN_SOURCE,FALSE,FALSE},
        {TOKEN_ADDR,FALSE,FALSE},
        {TOKEN_MASK,FALSE,FALSE},
        {TOKEN_GATEWAY,FALSE,FALSE},
        {TOKEN_GWMETRIC,FALSE,FALSE}};

    PDWORD      pdwTagType;
    DWORD       dwNumOpt, dwBitVector=0;
    DWORD       dwNumArg, i, j;
    DWORD       dwAddSource, dwAddAddr, dwAddMask, dwAddGateway, dwAddGwmetric;
    PWCHAR      pwszAddAddr, pwszAddMask, pwszAddGateway, pwszAddGwmetric;
    BOOL        EmptyGateway = FALSE;


    // At least interface name & address should be specified.

    if (dwCurrentIndex +1 >= dwArgCount)
    {
        return ERROR_SHOW_USAGE;
    }


    dwNumArg = dwArgCount - dwCurrentIndex;

    pdwTagType = HeapAlloc(GetProcessHeap(),
                           0,
                           dwNumArg * sizeof(DWORD));

    if (pdwTagType is NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    dwErr = MatchTagsInCmdLine(g_hModule,
                        ppwcArguments,
                        dwCurrentIndex,
                        dwArgCount,
                        pttTags,
                        NUM_TAGS_IN_TABLE(pttTags),
                        pdwTagType);

    if (dwErr isnot NO_ERROR)
    {
        IfutlFree(pdwTagType);
        if (dwErr is ERROR_INVALID_OPTION_TAG)
        {
            return ERROR_INVALID_SYNTAX;
        }

        return dwErr;
    }

    for ( i = 0; i < dwNumArg; i++)
    {
        switch (pdwTagType[i])
        {
            case 0 :
            {
                dwErr = GetIfNameFromFriendlyName(ppwcArguments[i + dwCurrentIndex],
                                                 wszInterfaceName,&dwBufferSize);

                if (dwErr isnot NO_ERROR)
                {
                    DisplayMessage(g_hModule, EMSG_INVALID_INTERFACE,
                        ppwcArguments[i + dwCurrentIndex]);
                    dwErr = ERROR_SUPPRESS_OUTPUT;
                    break;
                }

                wszIfFriendlyName = ppwcArguments[i + dwCurrentIndex];

                dwBitVector |= IFIP_IFNAME_MASK;

                break;
            }


            case 1:
            {
                //
                // dhcp or static
                //

                TOKEN_VALUE    rgEnums[] =
                    {{TOKEN_VALUE_DHCP, DHCP},
                     {TOKEN_VALUE_STATIC,STATIC}};

                dwErr = MatchEnumTag(g_hModule,
                                      ppwcArguments[i + dwCurrentIndex],
                                      NUM_TOKENS_IN_TABLE(rgEnums),
                                      rgEnums,
                                      &dwRes);

                if (dwErr != NO_ERROR)
                {
                    dwErrIndex = i;
                    i = dwNumArg;
                    dwErr = ERROR_INVALID_PARAMETER;
                    break;
                }

                dwAddSource = dwRes ;
                dwBitVector |= IFIP_SOURCE_MASK;
                break;
            }



            case 2:
            {
                //
                // ip address for static
                //

                dwErr = GetIpAddress(ppwcArguments[i + dwCurrentIndex],
                                     &dwAddAddr);

                if((dwErr != NO_ERROR) or CHECK_UNICAST_IP_ADDR(dwAddAddr))
                {
                    DispTokenErrMsg(g_hModule,
                                    EMSG_BAD_OPTION_VALUE,
                                    pttTags[pdwTagType[i]].pwszTag,
                                    ppwcArguments[i + dwCurrentIndex]);

                    dwErr = ERROR_SUPPRESS_OUTPUT;
                    break;
                }

                pwszAddAddr = ppwcArguments[i + dwCurrentIndex];
                dwBitVector |= IFIP_ADDR_MASK;

                break;
            }


           case 3:
            {
                //
                // get mask
                //

                dwErr = GetIpAddress(ppwcArguments[i + dwCurrentIndex],
                                     &dwAddAddr);

                if((dwErr != NO_ERROR) or CHECK_NETWORK_MASK(dwAddAddr))
                {
                    DispTokenErrMsg(g_hModule,
                                    EMSG_BAD_OPTION_VALUE,
                                    pttTags[pdwTagType[i]].pwszTag,
                                    ppwcArguments[i + dwCurrentIndex]);

                    dwErr = ERROR_SUPPRESS_OUTPUT;
                    break;
                }

                pwszAddMask = ppwcArguments[i + dwCurrentIndex];
                dwBitVector |= IFIP_MASK_MASK;

                break;
            }

            case 4:
            {
                //
                // get default gateway addr
                //

                TOKEN_VALUE    rgEnums[] =
                    {{TOKEN_VALUE_NONE, NONE}};

                dwErr = MatchEnumTag(g_hModule,
                                      ppwcArguments[i + dwCurrentIndex],
                                      NUM_TOKENS_IN_TABLE(rgEnums),
                                      rgEnums,
                                      &dwRes);

                if (dwErr == NO_ERROR) {
                    EmptyGateway = TRUE;
                    pwszAddGateway = pwszAddGwmetric = NULL;
                }
                else {
                    dwErr = GetIpAddress(ppwcArguments[i + dwCurrentIndex], &dwAddAddr);

                    if((dwErr != NO_ERROR) or CHECK_UNICAST_IP_ADDR(dwAddAddr))
                    {
                        DispTokenErrMsg(g_hModule,
                                        EMSG_BAD_OPTION_VALUE,
                                        pttTags[pdwTagType[i]].pwszTag,
                                        ppwcArguments[i + dwCurrentIndex]);

                        dwErr = ERROR_SUPPRESS_OUTPUT;
                    }

                    pwszAddGateway = ppwcArguments[i + dwCurrentIndex];

                }

                dwBitVector |= IFIP_GATEWAY_MASK;

                break;
            }

            case 5:
            {
                //
                // gwmetric
                //

                dwAddGwmetric =
                        _tcstoul(ppwcArguments[i + dwCurrentIndex], NULL, 10);


                if ( dwAddGwmetric > 9999 )
                {
                    dwErrIndex = i;
                    dwErr = ERROR_INVALID_PARAMETER;
                    i = dwNumArg;
                    break;
                }

                pwszAddGwmetric = ppwcArguments[i + dwCurrentIndex];
                dwBitVector |= IFIP_GWMETRIC_MASK;

                break;
            }

            default:
            {
                i = dwNumArg;
                dwErr = ERROR_INVALID_PARAMETER;
                break;
            }

        } //switch

        if (dwErr != NO_ERROR)
            break ;

     }

    switch(dwErr)
    {
        case NO_ERROR :
            break;

        case ERROR_INVALID_PARAMETER:
            if (dwErrIndex != -1)
            {
                DispTokenErrMsg(g_hModule,
                                EMSG_BAD_OPTION_VALUE,
                                pttTags[pdwTagType[dwErrIndex]].pwszTag,
                                ppwcArguments[dwErrIndex + dwCurrentIndex]);
                dwErr = ERROR_SUPPRESS_OUTPUT;
            }
            break;

        default:
            // error message already printed
            break;
    }

    if (pdwTagType)
        IfutlFree(pdwTagType);

    if (dwErr != NO_ERROR)
        return dwErr;



    // interface name should be present

    if ( !(dwBitVector & IFIP_IFNAME_MASK)) {
        return ERROR_INVALID_SYNTAX;
    }


    if ( (dwBitVector & (IFIP_ADDR_MASK|IFIP_MASK_MASK))
         && (dwAddSource != STATIC))
    {
        return ERROR_INVALID_SYNTAX;

    }

    if (( (dwBitVector&IFIP_ADDR_MASK) && !(dwBitVector&IFIP_MASK_MASK)  )
        ||( !(dwBitVector&IFIP_ADDR_MASK) && (dwBitVector&IFIP_MASK_MASK)  )
        ||( (dwBitVector&IFIP_ADDR_MASK) && !(dwBitVector&IFIP_SOURCE_MASK)  )
        ||( (dwBitVector&IFIP_GATEWAY_MASK) && !EmptyGateway && !(dwBitVector&IFIP_GWMETRIC_MASK)  )
        ||( !(dwBitVector&IFIP_GATEWAY_MASK) && (dwBitVector&IFIP_GWMETRIC_MASK)  )
        ||((dwAddSource==STATIC) && !(dwBitVector&IFIP_ADDR_MASK)
                && !(dwBitVector&IFIP_GATEWAY_MASK) )
        ||( (dwBitVector&IFIP_GWMETRIC_MASK) && EmptyGateway)
       )
    {
        return ERROR_INVALID_SYNTAX;
    }

    {
        GUID guid;

        CLSIDFromString(wszInterfaceName, &guid);

        if (dwAddSource == DHCP) {

            dwErr = IfIpSetDhcpModeMany(wszIfFriendlyName, &guid, REGISTER_UNCHANGED, TYPE_IPADDR) ;
            RETURN_ERROR_OKAY(dwErr);
        }
        else {

            if (dwBitVector&IFIP_ADDR_MASK) {
                dwErr = IfIpAddSetAddress(wszIfFriendlyName, &guid, pwszAddAddr, pwszAddMask, SET_FLAG);
            }

            if ( (dwBitVector&IFIP_GATEWAY_MASK) && (dwErr == NO_ERROR)) {
                dwErr = IfIpAddSetGateway(wszIfFriendlyName, &guid, pwszAddGateway, pwszAddGwmetric, SET_FLAG);
                RETURN_ERROR_OKAY(dwErr);
            }

            if (dwBitVector&IFIP_ADDR_MASK) {
                RETURN_ERROR_OKAY(dwErr);
            }

            if (!(dwBitVector&IFIP_ADDR_MASK) && !(dwBitVector&IFIP_GATEWAY_MASK)) {

                DisplayMessage(g_hModule, EMSG_STATIC_INPUT);

                return ERROR_SUPPRESS_OUTPUT;
            }
        }

    };

    RETURN_ERROR_OKAY(dwErr);
}


DWORD
IfIpHandleSetDns(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description

Arguments

Return Value

--*/
{
    DWORD dwErr;

    dwErr = IfIpSetMany(
                ppwcArguments,
                dwCurrentIndex,
                dwArgCount,
                pbDone,
                TYPE_DNS
                );

    RETURN_ERROR_OKAY(dwErr);
}


DWORD
IfIpHandleSetWins(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description

Arguments

Return Value

--*/
{
    DWORD dwErr;

    dwErr = IfIpSetMany(
                ppwcArguments,
                dwCurrentIndex,
                dwArgCount,
                pbDone,
                TYPE_WINS
                );

    RETURN_ERROR_OKAY(dwErr);
}


DWORD
IfIpSetMany(
    IN  PWCHAR  *ppwcArguments,
    IN  DWORD   dwCurrentIndex,
    IN  DWORD   dwArgCount,
    IN  BOOL    *pbDone,
    IN  DWORD   Type
    )
/*++

Routine Description

Arguments

Return Value

--*/
{
    WCHAR       wszInterfaceName[MAX_INTERFACE_NAME_LEN + 1] = L"\0";
    PWCHAR      wszIfFriendlyName = NULL;

    DWORD       dwBufferSize = sizeof(wszInterfaceName);
    DWORD       dwErr = NO_ERROR,dwRes, dwErrIndex=-1;
    TAG_TYPE    pttTags[] = {
        {TOKEN_NAME,FALSE,FALSE},
        {TOKEN_SOURCE,FALSE,FALSE},
        {TOKEN_ADDR,FALSE,FALSE},
        {TOKEN_REGISTER,FALSE,FALSE}};

    PDWORD      pdwTagType;
    DWORD       dwNumOpt, dwBitVector=0;
    DWORD       dwNumArg, i, j;
    DWORD       dwAddSource, dwAddAddr;
    DWORD       dwRegisterMode = REGISTER_UNCHANGED;
    PWCHAR      pwszAddAddr;


    // At least interface name,source should be specified.

    if (dwCurrentIndex +1 >= dwArgCount)
    {
        return ERROR_SHOW_USAGE;
    }


    dwNumArg = dwArgCount - dwCurrentIndex;

    pdwTagType = HeapAlloc(GetProcessHeap(),
                           0,
                           dwNumArg * sizeof(DWORD));

    if (pdwTagType is NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    dwErr = MatchTagsInCmdLine(g_hModule,
                        ppwcArguments,
                        dwCurrentIndex,
                        dwArgCount,
                        pttTags,
                        NUM_TAGS_IN_TABLE(pttTags),
                        pdwTagType);

    if (dwErr isnot NO_ERROR)
    {
        IfutlFree(pdwTagType);
        if (dwErr is ERROR_INVALID_OPTION_TAG)
        {
            return ERROR_INVALID_SYNTAX;
        }

        return dwErr;
    }

    for ( i = 0; i < dwNumArg; i++)
    {
        switch (pdwTagType[i])
        {
            case 0 :
            {
                dwErr = GetIfNameFromFriendlyName(ppwcArguments[i + dwCurrentIndex],
                                                 wszInterfaceName,&dwBufferSize);

                if (dwErr isnot NO_ERROR)
                {
                    DisplayMessage(g_hModule, EMSG_INVALID_INTERFACE,
                        ppwcArguments[i + dwCurrentIndex]);
                    dwErr = ERROR_SUPPRESS_OUTPUT;
                    break;
                }


                wszIfFriendlyName = ppwcArguments[i + dwCurrentIndex];

                dwBitVector |= IFIP_IFNAME_MASK;

                break;
            }


            case 1:
            {
                //
                // dhcp or static
                //

                TOKEN_VALUE    rgEnums[] =
                    {{TOKEN_VALUE_DHCP, DHCP},
                     {TOKEN_VALUE_STATIC,STATIC}};

                dwErr = MatchEnumTag(g_hModule,
                                      ppwcArguments[i + dwCurrentIndex],
                                      NUM_TOKENS_IN_TABLE(rgEnums),
                                      rgEnums,
                                      &dwRes);

                if (dwErr != NO_ERROR)
                {
                    dwErrIndex = i;
                    i = dwNumArg;
                    dwErr = ERROR_INVALID_PARAMETER;
                    break;
                }

                dwAddSource = dwRes ;
                dwBitVector |= IFIP_SOURCE_MASK;

                //
                // If DHCP, then ADDR argument is not needed, so if the
                // syntax looks right (only one more argument), but we
                // classified the last argument as ADDR, then reclassify
                // it as REGISTER.
                //
                if ((dwRes == DHCP) && (i+2 == dwNumArg) && (pdwTagType[i+1] == 2))
                {
                    pdwTagType[i+1] = 3;
                }
                break;
            }


            case 2:
            {
                //
                // dns/wins address
                //

                TOKEN_VALUE    rgEnums[] =
                    {{TOKEN_VALUE_NONE, NONE}};

                dwErr = MatchEnumTag(g_hModule,
                                      ppwcArguments[i + dwCurrentIndex],
                                      NUM_TOKENS_IN_TABLE(rgEnums),
                                      rgEnums,
                                      &dwRes);

                if (dwErr == NO_ERROR) {
                    pwszAddAddr = NULL;
                }

                else {
                    dwErr = GetIpAddress(ppwcArguments[i + dwCurrentIndex], &dwAddAddr);

                    if((dwErr != NO_ERROR) or CHECK_UNICAST_IP_ADDR(dwAddAddr))
                    {
                        DispTokenErrMsg(g_hModule,
                                        EMSG_BAD_OPTION_VALUE,
                                        pttTags[pdwTagType[i]].pwszTag,
                                        ppwcArguments[i + dwCurrentIndex]);

                        dwErr = ERROR_SUPPRESS_OUTPUT;
                        break;
                    }

                    pwszAddAddr = ppwcArguments[i + dwCurrentIndex];
                }

                dwBitVector |= IFIP_ADDR_MASK;

                break;
            }

            case 3:
            {
                //
                // ddns enabled or disabled
                //

                TOKEN_VALUE    rgEnums[] =
                    {{TOKEN_VALUE_NONE,    REGISTER_NONE},
                     {TOKEN_VALUE_PRIMARY, REGISTER_PRIMARY},
                     {TOKEN_VALUE_BOTH,    REGISTER_BOTH}};

                dwErr = MatchEnumTag(g_hModule,
                                      ppwcArguments[i + dwCurrentIndex],
                                      NUM_TOKENS_IN_TABLE(rgEnums),
                                      rgEnums,
                                      &dwRes);

                if (dwErr != NO_ERROR)
                {
                    dwErrIndex = i;
                    i = dwNumArg;
                    dwErr = ERROR_INVALID_PARAMETER;
                    break;
                }

                dwRegisterMode = dwRes ;
                break;
            }

            default:
            {
                i = dwNumArg;
                dwErr = ERROR_INVALID_PARAMETER;
                break;
            }

        } //switch

        if (dwErr != NO_ERROR)
            break ;

     }

    switch(dwErr)
    {
        case NO_ERROR :
            break;

        case ERROR_INVALID_PARAMETER:
            if (dwErrIndex != -1)
            {
                DispTokenErrMsg(g_hModule,
                                EMSG_BAD_OPTION_VALUE,
                                pttTags[pdwTagType[dwErrIndex]].pwszTag,
                                ppwcArguments[dwErrIndex + dwCurrentIndex]);
                dwErr = ERROR_SUPPRESS_OUTPUT;
            }
            break;

        default:
            // error message already printed
            break;
    }

    if (pdwTagType)
        IfutlFree(pdwTagType);

    if (dwErr != NO_ERROR)
        return dwErr;

    // interface name and source should be present

    if ( !(dwBitVector & IFIP_IFNAME_MASK)
            || (! (dwBitVector & IFIP_SOURCE_MASK))) {
        return ERROR_INVALID_SYNTAX;
    }

    if ( ((dwBitVector & IFIP_ADDR_MASK) && (dwAddSource != STATIC))
        ||(!(dwBitVector & IFIP_ADDR_MASK) && (dwAddSource == STATIC)) )
    {
        return ERROR_INVALID_SYNTAX;
    }

    {
        GUID guid;

        CLSIDFromString(wszInterfaceName, &guid);

        if (dwAddSource == DHCP) {

            return IfIpSetDhcpModeMany(wszIfFriendlyName, &guid, dwRegisterMode, Type) ;
        }
        else {

            return IfIpAddSetDelMany(wszIfFriendlyName, &guid, pwszAddAddr, 0, dwRegisterMode, Type, SET_FLAG);
        }
    }

    return dwErr;
}


DWORD
IfIpHandleAddAddress(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description

Arguments

Return Value

--*/
{
    WCHAR       wszInterfaceName[MAX_INTERFACE_NAME_LEN + 1] = L"\0";
    PWCHAR      wszIfFriendlyName = NULL;

    DWORD       dwBufferSize = sizeof(wszInterfaceName);
    DWORD       dwErr = NO_ERROR,dwRes, dwErrIndex=-1;
    TAG_TYPE    pttTags[] = {
        {TOKEN_NAME,FALSE,FALSE},
        {TOKEN_ADDR,FALSE,FALSE},
        {TOKEN_MASK,FALSE,FALSE},
        {TOKEN_GATEWAY,FALSE,FALSE},
        {TOKEN_GWMETRIC,FALSE,FALSE}};

    PDWORD      pdwTagType;
    DWORD       dwNumOpt, dwBitVector=0;
    DWORD       dwNumArg, i, j;
    DWORD       dwAddSource, dwAddAddr, dwAddMask, dwAddGateway, dwAddGwmetric;
    PWCHAR      pwszAddAddr, pwszAddMask, pwszAddGateway, pwszAddGwmetric;


    if (dwCurrentIndex >= dwArgCount)
    {
        // No arguments specified. At least interface name should be specified.

        return ERROR_SHOW_USAGE;
    }


    dwNumArg = dwArgCount - dwCurrentIndex;

    pdwTagType = HeapAlloc(GetProcessHeap(),
                           0,
                           dwNumArg * sizeof(DWORD));

    if (pdwTagType is NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    dwErr = MatchTagsInCmdLine(g_hModule,
                        ppwcArguments,
                        dwCurrentIndex,
                        dwArgCount,
                        pttTags,
                        NUM_TAGS_IN_TABLE(pttTags),
                        pdwTagType);

    if (dwErr isnot NO_ERROR)
    {
        IfutlFree(pdwTagType);
        if (dwErr is ERROR_INVALID_OPTION_TAG)
        {
            return ERROR_INVALID_SYNTAX;
        }

        return dwErr;
    }

    for ( i = 0; i < dwNumArg; i++)
    {
        switch (pdwTagType[i])
        {
            case 0 :
            {
                dwErr = GetIfNameFromFriendlyName(ppwcArguments[i + dwCurrentIndex],
                                                 wszInterfaceName,&dwBufferSize);

                if (dwErr isnot NO_ERROR)
                {
                    DisplayMessage(g_hModule, EMSG_INVALID_INTERFACE,
                        ppwcArguments[i + dwCurrentIndex]);
                    dwErr = ERROR_SUPPRESS_OUTPUT;
                    break;
                }


                wszIfFriendlyName = ppwcArguments[i + dwCurrentIndex];

                dwBitVector |= IFIP_IFNAME_MASK;

                break;
            }

            case 1:
            {
                //
                // ip address for static
                //

                dwErr = GetIpAddress(ppwcArguments[i + dwCurrentIndex], &dwAddAddr);

                if((dwErr != NO_ERROR) or CHECK_UNICAST_IP_ADDR(dwAddAddr))
                {
                    DispTokenErrMsg(g_hModule,
                                    EMSG_BAD_OPTION_VALUE,
                                    pttTags[pdwTagType[i]].pwszTag,
                                    ppwcArguments[i + dwCurrentIndex]);

                    dwErr = ERROR_SUPPRESS_OUTPUT;
                    break;
                }

                pwszAddAddr = ppwcArguments[i + dwCurrentIndex];
                dwBitVector |= IFIP_ADDR_MASK;

                break;
            }


           case 2:
            {
                //
                // get mask
                //

                dwErr = GetIpAddress(ppwcArguments[i + dwCurrentIndex], &dwAddAddr);

                if((dwErr != NO_ERROR) or CHECK_NETWORK_MASK(dwAddAddr))
                {
                    DispTokenErrMsg(g_hModule,
                                    EMSG_BAD_OPTION_VALUE,
                                    pttTags[pdwTagType[i]].pwszTag,
                                    ppwcArguments[i + dwCurrentIndex]);

                    dwErr = ERROR_SUPPRESS_OUTPUT;
                    break;
                }

                pwszAddMask = ppwcArguments[i + dwCurrentIndex];
                dwBitVector |= IFIP_MASK_MASK;

                break;
            }

            case 3:
            {
                //
                // get default gateway addr
                //

                dwErr = GetIpAddress(ppwcArguments[i + dwCurrentIndex],
                                     &dwAddAddr);

                if((dwErr != NO_ERROR) or CHECK_UNICAST_IP_ADDR(dwAddAddr))
                {
                    DispTokenErrMsg(g_hModule,
                                    EMSG_BAD_OPTION_VALUE,
                                    pttTags[pdwTagType[i]].pwszTag,
                                    ppwcArguments[i + dwCurrentIndex]);

                    dwErr = ERROR_SUPPRESS_OUTPUT;
                    break;
                }

                pwszAddGateway = ppwcArguments[i + dwCurrentIndex];
                dwBitVector |= IFIP_GATEWAY_MASK;

                break;
            }

            case 4:
            {
                //
                // gwmetric
                //

                dwAddGwmetric =
                        _tcstoul(ppwcArguments[i + dwCurrentIndex], NULL, 10);


                if ( dwAddGwmetric > 9999 )
                {
                    dwErrIndex = i;
                    dwErr = ERROR_INVALID_PARAMETER;
                    i = dwNumArg;
                    break;
                }

                pwszAddGwmetric = ppwcArguments[i + dwCurrentIndex];
                dwBitVector |= IFIP_GWMETRIC_MASK;

                break;
            }

            default:
            {
                i = dwNumArg;
                dwErr = ERROR_INVALID_PARAMETER;
                break;
            }

        } //switch

        if (dwErr != NO_ERROR)
            break ;

     }

    // interface name should be present

    if (!pttTags[0].bPresent)
    {
        dwErr = ERROR_INVALID_SYNTAX;
    }


    switch(dwErr)
    {
        case NO_ERROR :
            break;

        case ERROR_INVALID_PARAMETER:
            if (dwErrIndex != -1)
            {
                DispTokenErrMsg(g_hModule,
                                EMSG_BAD_OPTION_VALUE,
                                pttTags[pdwTagType[dwErrIndex]].pwszTag,
                                ppwcArguments[dwErrIndex + dwCurrentIndex]);
                dwErr = ERROR_SUPPRESS_OUTPUT;
            }
            break;

        default:
            // error message already printed
            break;
    }

    if (pdwTagType)
        IfutlFree(pdwTagType);

    if (dwErr != NO_ERROR)
        return dwErr;


    // interface name should be present

    if ( !(dwBitVector & IFIP_IFNAME_MASK) ) {
        return ERROR_INVALID_SYNTAX;
    }


    if (( (dwBitVector&IFIP_ADDR_MASK) && !(dwBitVector&IFIP_MASK_MASK)  )
        ||( !(dwBitVector&IFIP_ADDR_MASK) && (dwBitVector&IFIP_MASK_MASK)  )
        ||( (dwBitVector&IFIP_GATEWAY_MASK) && !(dwBitVector&IFIP_GWMETRIC_MASK)  )
        ||( !(dwBitVector&IFIP_GATEWAY_MASK) && (dwBitVector&IFIP_GWMETRIC_MASK)  )
       )
    {
        return ERROR_INVALID_SYNTAX;
    }

    {
        GUID guid;

        if (FAILED(CLSIDFromString(wszInterfaceName, &guid))) {
            return ERROR_INVALID_PARAMETER;
        }

        if (dwBitVector&IFIP_ADDR_MASK) {
            dwErr = IfIpAddSetAddress(wszIfFriendlyName, &guid, pwszAddAddr, pwszAddMask, ADD_FLAG);
        }

        if ( (dwBitVector&IFIP_GATEWAY_MASK) && (dwErr == NO_ERROR)) {

            dwErr = IfIpAddSetGateway(wszIfFriendlyName, &guid, pwszAddGateway, pwszAddGwmetric, ADD_FLAG);

            RETURN_ERROR_OKAY(dwErr);
        }

        if (dwBitVector&IFIP_ADDR_MASK) {
            RETURN_ERROR_OKAY(dwErr);
        }

        if (!(dwBitVector&IFIP_ADDR_MASK) && !(dwBitVector&IFIP_GATEWAY_MASK)) {

            DisplayMessage(g_hModule, EMSG_STATIC_INPUT);

            return ERROR_SUPPRESS_OUTPUT;
        }
    }

    RETURN_ERROR_OKAY(dwErr);
}

DWORD
IfIpHandleAddDns(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description

Arguments

Return Value

--*/
{
    DWORD dwErr;

    dwErr = IfIpAddMany(
                ppwcArguments,
                dwCurrentIndex,
                dwArgCount,
                pbDone,
                TYPE_DNS
                );

    RETURN_ERROR_OKAY(dwErr);
}


DWORD
IfIpHandleAddWins(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description

Arguments

Return Value

--*/
{
    DWORD dwErr;

    dwErr = IfIpAddMany(
                ppwcArguments,
                dwCurrentIndex,
                dwArgCount,
                pbDone,
                TYPE_WINS
                );

    RETURN_ERROR_OKAY(dwErr);
}


DWORD
IfIpAddMany(
    IN  PWCHAR  *ppwcArguments,
    IN  DWORD   dwCurrentIndex,
    IN  DWORD   dwArgCount,
    IN  BOOL    *pbDone,
    IN  DWORD   Type
    )
/*++

Routine Description

Arguments

Return Value

--*/
{
    WCHAR       wszInterfaceName[MAX_INTERFACE_NAME_LEN + 1] = L"\0";
    PWCHAR      wszIfFriendlyName = NULL;

    DWORD       dwBufferSize = sizeof(wszInterfaceName);
    DWORD       dwErr = NO_ERROR,dwRes, dwErrIndex=-1;
    TAG_TYPE    pttTags[] = {
        {TOKEN_NAME,FALSE,FALSE},
        {TOKEN_ADDR,FALSE,FALSE},
        {TOKEN_INDEX,FALSE,FALSE}};

    PDWORD      pdwTagType;
    DWORD       dwNumOpt, dwBitVector=0;
    DWORD       dwNumArg, i, j;
    DWORD       dwAddSource, dwAddAddr, dwAddIndex=~(0);
    PWCHAR      pwszAddAddr;


    // At least interface name/new address should be specified.

    if (dwCurrentIndex +1 >= dwArgCount)
    {
        return ERROR_SHOW_USAGE;
    }


    dwNumArg = dwArgCount - dwCurrentIndex;

    pdwTagType = HeapAlloc(GetProcessHeap(),
                           0,
                           dwNumArg * sizeof(DWORD));

    if (pdwTagType is NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    dwErr = MatchTagsInCmdLine(g_hModule,
                        ppwcArguments,
                        dwCurrentIndex,
                        dwArgCount,
                        pttTags,
                        NUM_TAGS_IN_TABLE(pttTags),
                        pdwTagType);

    if (dwErr isnot NO_ERROR)
    {
        IfutlFree(pdwTagType);
        if (dwErr is ERROR_INVALID_OPTION_TAG)
        {
            return ERROR_INVALID_SYNTAX;
        }

        return dwErr;
    }

    for ( i = 0; i < dwNumArg; i++)
    {
        switch (pdwTagType[i])
        {
            case 0 :
            {
                dwErr = GetIfNameFromFriendlyName(ppwcArguments[i + dwCurrentIndex],
                                                 wszInterfaceName,&dwBufferSize);

                if (dwErr isnot NO_ERROR)
                {
                    DisplayMessage(g_hModule, EMSG_INVALID_INTERFACE,
                        ppwcArguments[i + dwCurrentIndex]);
                    dwErr = ERROR_SUPPRESS_OUTPUT;
                    break;
                }


                wszIfFriendlyName = ppwcArguments[i + dwCurrentIndex];

                dwBitVector |= IFIP_IFNAME_MASK;

                break;
            }

            case 1:
            {
                //
                // dns/wins address
                //

                dwErr = GetIpAddress(ppwcArguments[i + dwCurrentIndex], &dwAddAddr);

                if((dwErr != NO_ERROR) or CHECK_UNICAST_IP_ADDR(dwAddAddr))
                {
                    DispTokenErrMsg(g_hModule,
                                    EMSG_BAD_OPTION_VALUE,
                                    pttTags[pdwTagType[i]].pwszTag,
                                    ppwcArguments[i + dwCurrentIndex]);

                    dwErr = ERROR_SUPPRESS_OUTPUT;
                    break;
                }

                pwszAddAddr = ppwcArguments[i + dwCurrentIndex];
                dwBitVector |= IFIP_ADDR_MASK;

                break;
            }


            case 2:
            {
                //
                // index
                //

                dwAddIndex =
                        _tcstoul(ppwcArguments[i + dwCurrentIndex], NULL, 10);


                if ( (dwAddIndex <= 0 || dwAddIndex > 999) )
                {
                    dwErrIndex = i;
                    dwErr = ERROR_INVALID_PARAMETER;
                    i = dwNumArg;
                    break;
                }

                dwBitVector |= IFIP_INDEX_MASK;

                break;
            }

            default:
            {
                i = dwNumArg;
                dwErr = ERROR_INVALID_PARAMETER;
                break;
            }

        } //switch

        if (dwErr != NO_ERROR)
            break ;

     }

    switch(dwErr)
    {
        case NO_ERROR :
            break;

        case ERROR_INVALID_PARAMETER:
            if (dwErrIndex != -1)
            {
                DispTokenErrMsg(g_hModule,
                                EMSG_BAD_OPTION_VALUE,
                                pttTags[pdwTagType[dwErrIndex]].pwszTag,
                                ppwcArguments[dwErrIndex + dwCurrentIndex]);
                dwErr = ERROR_SUPPRESS_OUTPUT;
            }
            break;

        default:
            // error message already printed
            break;
    }

    if (pdwTagType)
        IfutlFree(pdwTagType);

    if (dwErr != NO_ERROR)
        return dwErr;

    // interface name and new address should be present

    if ( !(dwBitVector & IFIP_IFNAME_MASK)
            || (! (dwBitVector & IFIP_ADDR_MASK))) {
        return ERROR_INVALID_SYNTAX;
    }


    {
        GUID guid;

        CLSIDFromString(wszInterfaceName, &guid);

        #pragma prefast(suppress:1, "pwszAddAddr is initialized if IFIP_IFNAME_MASK is set")
        return IfIpAddSetDelMany(wszIfFriendlyName, &guid, pwszAddAddr, dwAddIndex, REGISTER_UNCHANGED, Type, ADD_FLAG);
    }

    return dwErr;
}


DWORD
IfIpHandleDelAddress(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description

Arguments

Return Value

--*/
{
    WCHAR       wszInterfaceName[MAX_INTERFACE_NAME_LEN + 1] = L"\0";
    PWCHAR      wszIfFriendlyName = NULL;

    DWORD       dwBufferSize = sizeof(wszInterfaceName);
    DWORD       dwErr = NO_ERROR,dwRes, dwErrIndex=-1;
    TAG_TYPE    pttTags[] = {
        {TOKEN_NAME,FALSE,FALSE},
        {TOKEN_ADDR,FALSE,FALSE},
        {TOKEN_GATEWAY,FALSE,FALSE}};

    PDWORD      pdwTagType;
    DWORD       dwNumOpt, dwBitVector=0;
    DWORD       dwNumArg, i, j, Flags = 0;
    PWCHAR      pwszDelAddr=NULL, pwszDelGateway=NULL;


    // At least interface name and ipaddr/gateway should be specified.

    if (dwCurrentIndex + 1 >= dwArgCount)
    {
        return ERROR_SHOW_USAGE;
    }


    dwNumArg = dwArgCount - dwCurrentIndex;

    pdwTagType = HeapAlloc(GetProcessHeap(),
                           0,
                           dwNumArg * sizeof(DWORD));

    if (pdwTagType is NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    dwErr = MatchTagsInCmdLine(g_hModule,
                        ppwcArguments,
                        dwCurrentIndex,
                        dwArgCount,
                        pttTags,
                        NUM_TAGS_IN_TABLE(pttTags),
                        pdwTagType);

    if (dwErr isnot NO_ERROR)
    {
        IfutlFree(pdwTagType);
        if (dwErr is ERROR_INVALID_OPTION_TAG)
        {
            return ERROR_INVALID_SYNTAX;
        }

        return dwErr;
    }

    for ( i = 0; i < dwNumArg; i++)
    {
        switch (pdwTagType[i])
        {

            case 0 :
            {
                // get IfName

                dwErr = GetIfNameFromFriendlyName(ppwcArguments[i + dwCurrentIndex],
                                                 wszInterfaceName,&dwBufferSize);

                if (dwErr isnot NO_ERROR)
                {
                    DisplayMessage(g_hModule, EMSG_INVALID_INTERFACE,
                        ppwcArguments[i + dwCurrentIndex]);
                    dwErr = ERROR_SUPPRESS_OUTPUT;
                    break;
                }

                wszIfFriendlyName = ppwcArguments[i + dwCurrentIndex];

                dwBitVector |= IFIP_IFNAME_MASK;

                break;
            }

            case 1:
            {
                //
                // ip address for static
                //

                ULONG dwDelAddr;

                dwErr = GetIpAddress(ppwcArguments[i + dwCurrentIndex],
                                     &dwDelAddr);

                if((dwErr != NO_ERROR) or CHECK_UNICAST_IP_ADDR(dwDelAddr))
                {
                    DispTokenErrMsg(g_hModule,
                                    EMSG_BAD_OPTION_VALUE,
                                    pttTags[pdwTagType[i]].pwszTag,
                                    ppwcArguments[i + dwCurrentIndex]);

                    dwErr = ERROR_SUPPRESS_OUTPUT;
                    break;

                }

                pwszDelAddr = ppwcArguments[i + dwCurrentIndex];
                dwBitVector |= IFIP_ADDR_MASK;
                Flags |= TYPE_ADDR;

                break;
            }

            case 2:
            {
                //
                // get default gateway addr
                //

                ULONG dwDelGateway;
                TOKEN_VALUE    rgEnums[] =
                    {{TOKEN_VALUE_ALL, ALL}};

                dwErr = MatchEnumTag(g_hModule,
                                      ppwcArguments[i + dwCurrentIndex],
                                      NUM_TOKENS_IN_TABLE(rgEnums),
                                      rgEnums,
                                      &dwRes);

                if (dwErr == NO_ERROR) {
                    pwszDelGateway = NULL;
                }
                else {

                    dwErr = NO_ERROR;

                    dwErr = GetIpAddress(ppwcArguments[i + dwCurrentIndex],
                                     &dwDelGateway);

                    if((dwErr != NO_ERROR) or CHECK_UNICAST_IP_ADDR(dwDelGateway))
                    {
                        DispTokenErrMsg(g_hModule,
                                        EMSG_BAD_OPTION_VALUE,
                                        pttTags[pdwTagType[i]].pwszTag,
                                        ppwcArguments[i + dwCurrentIndex]);

                        dwErr = ERROR_SUPPRESS_OUTPUT;
                        break;
                    }

                    pwszDelGateway = ppwcArguments[i + dwCurrentIndex];
                }

                dwBitVector |= IFIP_GATEWAY_MASK;
                Flags |= TYPE_GATEWAY;

                break;
            }

            default:
            {
                i = dwNumArg;
                dwErr = ERROR_INVALID_PARAMETER;
                break;
            }

        } //switch

        if (dwErr != NO_ERROR)
            break ;

     }


    switch(dwErr)
    {
        case NO_ERROR :
            break;

        case ERROR_INVALID_PARAMETER:
            if (dwErrIndex != -1)
            {
                DispTokenErrMsg(g_hModule,
                                EMSG_BAD_OPTION_VALUE,
                                pttTags[pdwTagType[dwErrIndex]].pwszTag,
                                ppwcArguments[dwErrIndex + dwCurrentIndex]);
                dwErr = ERROR_SUPPRESS_OUTPUT;
            }
            break;

        default:
            // error message already printed
            break;
    }

    if (pdwTagType)
        IfutlFree(pdwTagType);

    if (dwErr != NO_ERROR)
        return dwErr;


    // interface name and addr/all should be present

    if ( !(dwBitVector & IFIP_IFNAME_MASK)
        || !(dwBitVector & (IFIP_GATEWAY_MASK | IFIP_ADDR_MASK))
        ) {
        return ERROR_INVALID_SYNTAX;
    }


    {
        GUID guid;

        CLSIDFromString(wszInterfaceName, &guid);

        dwErr = IfIpHandleDelIpaddrEx(wszIfFriendlyName, &guid, pwszDelAddr, pwszDelGateway, Flags);

        RETURN_ERROR_OKAY(dwErr);
    }

    RETURN_ERROR_OKAY(dwErr);
}


DWORD
IfIpHandleDelDns(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description

Arguments

Return Value

--*/
{
    DWORD dwErr;
    dwErr = IfIpDelMany(
                ppwcArguments,
                dwCurrentIndex,
                dwArgCount,
                pbDone,
                TYPE_DNS
                );

    RETURN_ERROR_OKAY(dwErr);
}


DWORD
IfIpHandleDelWins(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description

Arguments

Return Value

--*/
{
    DWORD dwErr;
    dwErr = IfIpDelMany(
                ppwcArguments,
                dwCurrentIndex,
                dwArgCount,
                pbDone,
                TYPE_WINS
                );

    RETURN_ERROR_OKAY(dwErr);
}

DWORD
IfIpDelMany(
    IN  PWCHAR  *ppwcArguments,
    IN  DWORD   dwCurrentIndex,
    IN  DWORD   dwArgCount,
    IN  BOOL    *pbDone,
    IN  DISPLAY_TYPE Type
    )
/*++

Routine Description

Arguments

Return Value

--*/
{
    WCHAR       wszInterfaceName[MAX_INTERFACE_NAME_LEN + 1] = L"\0";
    PWCHAR      wszIfFriendlyName = NULL;

    DWORD       dwBufferSize = sizeof(wszInterfaceName);
    DWORD       dwErr = NO_ERROR,dwRes, dwErrIndex=-1;
    TAG_TYPE    pttTags[] = {
        {TOKEN_NAME,FALSE,FALSE},
        {TOKEN_ADDR,FALSE,FALSE}};

    PDWORD      pdwTagType;
    DWORD       dwNumOpt, dwBitVector=0;
    DWORD       dwNumArg, i, j;
    PWCHAR      pwszDelAddr=NULL;


    // At least interface name/address should be specified.

    if (dwCurrentIndex +1 >= dwArgCount)
    {
        return ERROR_SHOW_USAGE;
    }


    dwNumArg = dwArgCount - dwCurrentIndex;

    pdwTagType = HeapAlloc(GetProcessHeap(),
                           0,
                           dwNumArg * sizeof(DWORD));

    if (pdwTagType is NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    dwErr = MatchTagsInCmdLine(g_hModule,
                        ppwcArguments,
                        dwCurrentIndex,
                        dwArgCount,
                        pttTags,
                        NUM_TAGS_IN_TABLE(pttTags),
                        pdwTagType);

    if (dwErr isnot NO_ERROR)
    {
        IfutlFree(pdwTagType);
        if (dwErr is ERROR_INVALID_OPTION_TAG)
        {
            return ERROR_INVALID_SYNTAX;
        }

        return dwErr;
    }

    for ( i = 0; i < dwNumArg; i++)
    {
        switch (pdwTagType[i])
        {

            case 0 :
            {
                // get IfName

                dwErr = GetIfNameFromFriendlyName(ppwcArguments[i + dwCurrentIndex],
                                                 wszInterfaceName,&dwBufferSize);

                if (dwErr isnot NO_ERROR)
                {
                    DisplayMessage(g_hModule, EMSG_INVALID_INTERFACE,
                        ppwcArguments[i + dwCurrentIndex]);
                    dwErr = ERROR_SUPPRESS_OUTPUT;
                    break;
                }


                wszIfFriendlyName = ppwcArguments[i + dwCurrentIndex];

                dwBitVector |= IFIP_IFNAME_MASK;

                break;
            }

            case 1:
            {
                //
                // address
                //

                ULONG dwDelAddr;

                TOKEN_VALUE    rgEnums[] =
                    {{TOKEN_VALUE_ALL, ALL}};

                dwErr = MatchEnumTag(g_hModule,
                                      ppwcArguments[i + dwCurrentIndex],
                                      NUM_TOKENS_IN_TABLE(rgEnums),
                                      rgEnums,
                                      &dwRes);

                if (dwErr == NO_ERROR) {
                    pwszDelAddr = NULL;
                }
                else {

                    dwErr = GetIpAddress(ppwcArguments[i + dwCurrentIndex], &dwDelAddr);

                    if((dwErr != NO_ERROR) or CHECK_UNICAST_IP_ADDR(dwDelAddr))
                    {
                        DispTokenErrMsg(g_hModule,
                                        EMSG_BAD_OPTION_VALUE,
                                        pttTags[pdwTagType[i]].pwszTag,
                                        ppwcArguments[i + dwCurrentIndex]);

                        dwErr = ERROR_SUPPRESS_OUTPUT;
                        break;
                    }

                    pwszDelAddr = ppwcArguments[i + dwCurrentIndex];
                }

                dwBitVector |= IFIP_ADDR_MASK;

                break;
            }

            default:
            {
                i = dwNumArg;
                dwErr = ERROR_INVALID_PARAMETER;
                break;
            }

        } //switch

        if (dwErr != NO_ERROR)
            break ;

     }


    switch(dwErr)
    {
        case NO_ERROR :
            break;

        case ERROR_INVALID_PARAMETER:
            if (dwErrIndex != -1)
            {
                DispTokenErrMsg(g_hModule,
                                EMSG_BAD_OPTION_VALUE,
                                pttTags[pdwTagType[dwErrIndex]].pwszTag,
                                ppwcArguments[dwErrIndex + dwCurrentIndex]);
                dwErr = ERROR_SUPPRESS_OUTPUT;
            }
            break;

        default:
            // error message already printed
            break;
    }

    if (pdwTagType)
        IfutlFree(pdwTagType);

    if (dwErr != NO_ERROR)
        return dwErr;


    // interface name and address should be present

    if ( !(dwBitVector & IFIP_IFNAME_MASK)
        || !(dwBitVector & IFIP_ADDR_MASK)) {
        return ERROR_INVALID_SYNTAX;
    }


    {
        GUID guid;

        CLSIDFromString(wszInterfaceName, &guid);

        return IfIpAddSetDelMany(wszIfFriendlyName, &guid, pwszDelAddr, 0, REGISTER_UNCHANGED, Type, DEL_FLAG);
    }
}

DWORD
IfIpHandleShowAddress(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description

Arguments

Return Value

--*/
{
    return IfIpShowMany(
                pwszMachine,
                ppwcArguments,
                dwCurrentIndex,
                dwArgCount,
                pbDone,
                TYPE_IPADDR
                );
}



DWORD
IfIpHandleShowConfig(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description

Arguments

Return Value

--*/
{
    return IfIpShowMany(
                pwszMachine,
                ppwcArguments,
                dwCurrentIndex,
                dwArgCount,
                pbDone,
                TYPE_IP_ALL
                );
}

DWORD
IfIpHandleShowOffload(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description

Arguments

Return Value

--*/
{
    return IfIpShowMany(
                pwszMachine,
                ppwcArguments,
                dwCurrentIndex,
                dwArgCount,
                pbDone,
                TYPE_OFFLOAD
                );
}


DWORD
IfIpHandleShowDns(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description

Arguments

Return Value

--*/
{
    return IfIpShowMany(
                pwszMachine,
                ppwcArguments,
                dwCurrentIndex,
                dwArgCount,
                pbDone,
                TYPE_DNS
                );
}


DWORD
IfIpHandleShowWins(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description

Arguments

Return Value

--*/
{
    return IfIpShowMany(
                pwszMachine,
                ppwcArguments,
                dwCurrentIndex,
                dwArgCount,
                pbDone,
                TYPE_WINS
                );
}

DWORD
IfIpShowMany(
    IN  LPCWSTR pwszMachineName,
    IN  PWCHAR  *ppwcArguments,
    IN  DWORD   dwCurrentIndex,
    IN  DWORD   dwArgCount,
    IN  BOOL    *pbDone,
    IN  DISPLAY_TYPE  dtType
    )
/*++

Routine Description

Arguments

Return Value

--*/
{
    DWORD dwErr = NO_ERROR;
    ULONG Flags = 0, IfIndex;
    WCHAR       wszInterfaceName[MAX_INTERFACE_NAME_LEN + 1] = L"\0";
    PWCHAR      wszIfFriendlyName = NULL;

    DWORD       dwBufferSize = sizeof(wszInterfaceName);
    TAG_TYPE    pttTags[] = {
        {TOKEN_NAME,FALSE,FALSE}};

    PDWORD      pdwTagType;
    DWORD       dwNumOpt, dwBitVector=0;
    DWORD       dwNumArg, i;
    BOOLEAN     bAll = FALSE;

    //
    // get interface friendly name
    //

    if (dwCurrentIndex > dwArgCount)
    {
        // No arguments specified. At least interface name should be specified.

        return ERROR_SHOW_USAGE;
    }
    else if (dwCurrentIndex == dwArgCount)
    {
        // show for all interfaces

        bAll = TRUE;
    }

    else {

        dwNumArg = dwArgCount - dwCurrentIndex;

        pdwTagType = HeapAlloc(GetProcessHeap(),
                               0,
                               dwNumArg * sizeof(DWORD));

        if (pdwTagType is NULL)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        dwErr = MatchTagsInCmdLine(g_hModule,
                            ppwcArguments,
                            dwCurrentIndex,
                            dwArgCount,
                            pttTags,
                            NUM_TAGS_IN_TABLE(pttTags),
                            pdwTagType);

        if (dwErr isnot NO_ERROR)
        {
            IfutlFree(pdwTagType);
            if (dwErr is ERROR_INVALID_OPTION_TAG)
            {
                return ERROR_INVALID_SYNTAX;
            }

            return dwErr;
        }

        for ( i = 0; i < dwNumArg; i++)
        {
            switch (pdwTagType[i])
            {
                case 0 :
                {
                    dwErr = GetIfNameFromFriendlyName(ppwcArguments[i + dwCurrentIndex],
                                                     wszInterfaceName,&dwBufferSize);

                    if (dwErr isnot NO_ERROR)
                    {
                        DisplayMessage(g_hModule, EMSG_INVALID_INTERFACE,
                            ppwcArguments[i + dwCurrentIndex]);
                        dwErr = ERROR_SUPPRESS_OUTPUT;
                        break;
                    }


                    wszIfFriendlyName = ppwcArguments[i + dwCurrentIndex];

                    dwBitVector |= IFIP_IFNAME_MASK;

                    break;
                }

                default:
                {
                    dwErr = ERROR_INVALID_PARAMETER;
                    break;
                }

            } //switch

            if (dwErr != NO_ERROR)
                break ;

         }


        // interface name should be present

        if (!pttTags[0].bPresent)
        {
            dwErr = ERROR_INVALID_SYNTAX;
        }


        if (pdwTagType)
            IfutlFree(pdwTagType);

    }

    if (dwErr != NO_ERROR)
        return dwErr;


    //
    // show for all interfaces
    //

    if (bAll) {

        dwErr = IfIpShowAllInterfaceInfo(pwszMachineName, dtType, NULL);
    }

    // show for specified interface
    else {

        GUID guid;

        dwErr = IfutlGetIfIndexFromInterfaceName(
                wszInterfaceName,
                &IfIndex);

        CLSIDFromString(wszInterfaceName, &guid);


        dwErr = IfIpShowManyEx(pwszMachineName,
                               IfIndex, wszIfFriendlyName, &guid, dtType, NULL);
        if (dwErr != NO_ERROR)
            return dwErr;
    }

    return dwErr;
}

DWORD
IfIpShowAllInterfaceInfo(
    LPCWSTR pwszMachineName,
    DISPLAY_TYPE dtType,
    HANDLE hFile
    )
/*++

Routine Description

Arguments

Return Value

--*/
{
    GUID    TmpGuid;
    PWCHAR  TmpGuidStr;
    WCHAR   wszIfFriendlyName[MAX_INTERFACE_NAME_LEN + 1];
    PIP_INTERFACE_NAME_INFO pTable;
    DWORD dwErr, dwCount, i, dwBufferSize;

    // get interface index

    dwErr = NhpAllocateAndGetInterfaceInfoFromStack(
                &pTable,
                &dwCount,
                FALSE,
                GetProcessHeap(),
                0);

    if (dwErr != NO_ERROR)
        return dwErr;


    for (i=0;  i<dwCount;  i++) {

        // Don't dump the properties for
        // Demand Dial (IF_CONNECTION_DEMAND),
        // Dial Out    (IF_CONNECTION_DEMAND),
        // or Dial in  (IF_CONNECTION_PASSIVE) interfaces
        // i.e. dump properties for Dedicated connections only
        if ( pTable[i].ConnectionType != IF_CONNECTION_DEDICATED )
            continue;


        // If InterfaceGuid is all Zeros we will use DeviceGuid to get the
        // friendly name
        if ( IsEqualCLSID(&(pTable[i].InterfaceGuid), &GUID_NULL) ) {
            TmpGuid = pTable[i].DeviceGuid;
        }
        else {
            TmpGuid = pTable[i].InterfaceGuid;
        }


        // get ifname as a string
        dwErr = StringFromCLSID(&TmpGuid, &TmpGuidStr);
        if (dwErr != S_OK)
            return dwErr;


        // get friendly name
        dwBufferSize = sizeof(wszIfFriendlyName);
        IfutlGetInterfaceDescription(TmpGuidStr, wszIfFriendlyName,
                        &dwBufferSize);


        IfIpShowManyEx(pwszMachineName, pTable[i].Index, wszIfFriendlyName,
                    &TmpGuid, dtType, hFile);

        CoTaskMemFree(TmpGuidStr);
    }

    return dwErr==S_OK ? NO_ERROR : dwErr;
}


DWORD
IfIpHandleDelArpCache(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description

Arguments

Return Value

--*/
{
    DWORD       dwErr, dwCount, i, j, dwNumArg;
    TAG_TYPE    Tags[] = {{TOKEN_NAME,FALSE,FALSE}};
    PDWORD      pdwTagType;
    WCHAR       wszInterfaceName[MAX_INTERFACE_NAME_LEN + 1] = L"\0";
    DWORD       dwBufferSize = sizeof(wszInterfaceName);
    GUID        Guid;

    PIP_INTERFACE_NAME_INFO pTable;

    dwErr = NhpAllocateAndGetInterfaceInfoFromStack(&pTable,
                                                    &dwCount,
                                                    FALSE,
                                                    GetProcessHeap(),
                                                    0);

    if (dwErr != NO_ERROR)
    {
        return dwErr;
    }

    dwNumArg = dwArgCount - dwCurrentIndex;

    if(dwNumArg == 0)
    {
        for(i = 0 ; i < dwCount; i++)
        {
            dwErr = FlushIpNetTableFromStack(pTable[i].Index);
        }

        return ERROR_OKAY;
    }

    pdwTagType = HeapAlloc(GetProcessHeap(),
                           0,
                           dwNumArg * sizeof(DWORD));

    if (pdwTagType is NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    dwErr = MatchTagsInCmdLine(g_hModule,
                               ppwcArguments,
                               dwCurrentIndex,
                               dwArgCount,
                               Tags,
                               NUM_TAGS_IN_TABLE(Tags),
                               pdwTagType);

    if(dwErr isnot NO_ERROR)
    {
        IfutlFree(pdwTagType);

        if(dwErr is ERROR_INVALID_OPTION_TAG)
        {
            return ERROR_INVALID_SYNTAX;
        }

        return dwErr;
    }

    for(j = 0; j < dwNumArg; j++)
    {
        switch(pdwTagType[j])
        {
            case 0 :
            {
                dwErr = GetIfNameFromFriendlyName(
                            ppwcArguments[j + dwCurrentIndex],
                            wszInterfaceName,
                            &dwBufferSize);

                if (dwErr isnot NO_ERROR)
                {
                    j = dwNumArg;

                    break;
                }

                CLSIDFromString(wszInterfaceName, &Guid);

                for(i = 0; i < dwCount; i ++)
                {
                    if(IsEqualGUID(&Guid,
                                   &(pTable[i].DeviceGuid)))
                    {
                        FlushIpNetTableFromStack(pTable[i].Index);
                        break;
                    }
                }

                if(i == dwCount)
                {
                    DisplayMessage(g_hModule,
                                   MSG_NO_SUCH_IF,
                                   ppwcArguments[j + dwCurrentIndex]);

                    dwErr = ERROR_SUPPRESS_OUTPUT;
                }

                break;
            }

            default:
            {
                j = dwNumArg;

                dwErr = ERROR_INVALID_SYNTAX;

                break;
            }
        }
    }

    if(dwErr == NO_ERROR)
    {
        dwErr = ERROR_OKAY;
    }

    return dwErr;

}

DWORD
TrRepair(
    FILE* LogFile
    );

DWORD
IfIpHandleReset(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description

Arguments

Return Value

--*/
{
    DWORD       dwErr, i;
    TAG_TYPE    pttTags[] = {{TOKEN_NAME,TRUE,FALSE}};
    DWORD       rgdwTagType[sizeof(pttTags)/sizeof(TAG_TYPE)];
    PCWSTR      pwszLogFileName;
    FILE        *LogFile;

    // Parse arguments

    dwErr = PreprocessCommand(g_hModule,
                              ppwcArguments,
                              dwCurrentIndex,
                              dwArgCount,
                              pttTags,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              0,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              rgdwTagType );
    if (dwErr isnot NO_ERROR) {
        return dwErr;
    }

    for (i=0; (dwErr == NO_ERROR) && (i<dwArgCount-dwCurrentIndex); i++) {
        switch(rgdwTagType[i]) {
        case 0: // NAME
            pwszLogFileName = ppwcArguments[i + dwCurrentIndex];
            break;
        default:
            dwErr = ERROR_INVALID_SYNTAX;
            break;
        }
    }

    if (dwErr isnot NO_ERROR) {
        return dwErr;
    }

    // Open the log file for append.
    //
    LogFile = _wfopen(pwszLogFileName, L"a+");
    if (LogFile == NULL) {
        DisplayMessage(g_hModule, EMSG_OPEN_APPEND);
        return ERROR_SUPPRESS_OUTPUT;
    }

    dwErr = TrRepair(LogFile);

    fprintf(LogFile, "<completed>\n\n");
    fclose(LogFile);

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\if\ifmon.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    routing\netsh\if\ifmon.c

Abstract:

    If Command dispatcher.

Revision History:

    AmritanR

--*/

#include "precomp.h"


#define IFMON_GUID \
{ 0x705eca1, 0x7aac, 0x11d2, { 0x89, 0xdc, 0x0, 0x60, 0x8, 0xb0, 0xe5, 0xb9 } }

GUID g_IfGuid = IFMON_GUID;

static const GUID g_NetshGuid = NETSH_ROOT_GUID;

#define IF_HELPER_VERSION 1


//
// The monitor's commands are broken into 2 sets
//      - The top level commands are those which deal with the monitor
//        itself (meta commands) and others which take 0 arguments
//      - The rest of the commands are split into "command groups"
//        i.e, commands grouped by the VERB where the VERB is ADD, DELETE,
//        GET or SET.  This is not for any technical reason - only for
//        staying with the semantics used in other monitors and helpers
//
// A command is described using a CMD_ENTRY structure. It requires the
// command token, the handler, a short help message token and an extended 
// help message token.  To make it easier to create we use the 
// CREATE_CMD_ENTRY macro. This, however puts restrictions on how the tokens
// are named.
//
// The command groups are simply arrays of the CMD_ENTRY structure.  The 
// top level commands are also grouped in a similar array.
//
// The info about a complete command group is put in a CMD_GROUP_ENTRY
// structure, all of which are put in an array.
//
 

//
// NOTE: Since we have only one entry per group, currently, we really didnt
// need command groups. This is done for later extensibility.
// To add a command entry to a group, simply add the command to the appropriate
// array
// To add a command group - create and array and add its info to the
// command group array
//

CMD_ENTRY  g_IfAddCmdTable[] = 
{
    CREATE_CMD_ENTRY(IF_ADD_IF, HandleIfAddIf),
};

CMD_ENTRY  g_IfDelCmdTable[] = 
{
    CREATE_CMD_ENTRY(IF_DEL_IF,  HandleIfDelIf),
};

CMD_ENTRY  g_IfSetCmdTable[] = 
{
    CREATE_CMD_ENTRY(IF_SET_INTERFACE, HandleIfSet),
    CREATE_CMD_ENTRY(IF_SET_CREDENTIALS, HandleIfSetCredentials),
};

CMD_ENTRY g_IfShowCmdTable[] = 
{
    CREATE_CMD_ENTRY(IF_SHOW_IF, HandleIfShowIf),
    CREATE_CMD_ENTRY(IF_SHOW_CREDENTIALS, HandleIfShowCredentials),
};

CMD_ENTRY g_IfResetCmdTable[] = 
{
    CREATE_CMD_ENTRY(IF_RESET_ALL, HandleIfResetAll),
};

CMD_GROUP_ENTRY g_IfCmdGroups[] = 
{
    CREATE_CMD_GROUP_ENTRY(GROUP_ADD, g_IfAddCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_DELETE, g_IfDelCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_SHOW, g_IfShowCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_SET, g_IfSetCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_RESET, g_IfResetCmdTable),
};

ULONG   g_ulNumGroups = sizeof(g_IfCmdGroups)/sizeof(CMD_GROUP_ENTRY);

HANDLE   g_hModule;
HANDLE   g_hMprConfig = NULL;
HANDLE   g_hMprAdmin  = NULL;
HANDLE   g_hMIBServer = NULL;
BOOL     g_bCommit;
PWCHAR   g_pwszRouter = NULL;

DWORD                ParentVersion;
BOOL                 g_bIfDirty = FALSE;

ULONG   g_ulInitCount;
 
NS_CONTEXT_CONNECT_FN           IfConnect;

DWORD
WINAPI
IfCommit(
    IN  DWORD   dwAction
    )
{
    BOOL    bCommit, bFlush = FALSE;

    switch(dwAction)
    {
        case NETSH_COMMIT:
        {
            if(g_bCommit)
            {
                return NO_ERROR;
            }

            g_bCommit = TRUE;

            break;
        }

        case NETSH_UNCOMMIT:
        {
            g_bCommit = FALSE;

            return NO_ERROR;
        }

        case NETSH_SAVE:
        {
            if(g_bCommit)
            {
                return NO_ERROR;
            }

            break;
        }

        case NETSH_FLUSH:
        {
            //
            // Action is a flush. If current state is commit, then
            // nothing to be done.
            //

            if(g_bCommit)
            {
                return NO_ERROR;
            }

            bFlush = TRUE;

            break;
        }

        default:
        {
            return NO_ERROR;
        }
    }

    //
    // Switched to commit mode. So set all valid info in the
    // strutures. Free memory and invalidate the info.
    //

    return NO_ERROR;
}

BOOL 
WINAPI
IfDllEntry(
    HINSTANCE   hInstDll,
    DWORD       fdwReason,
    LPVOID      pReserved
    )
{
    switch (fdwReason)
    {
        case DLL_PROCESS_ATTACH:
        {
            g_hModule = hInstDll;

            DisableThreadLibraryCalls(hInstDll);

            break;
        }
        case DLL_PROCESS_DETACH:
        {
            
            break;
        }

        default:
        {
            break;
        }
    }

    return TRUE;
}

DWORD
WINAPI
IfStartHelper(
    IN CONST GUID *pguidParent,
    IN DWORD       dwVersion
    )
{
    DWORD dwErr;
    NS_CONTEXT_ATTRIBUTES attMyAttributes;

    ParentVersion         = dwVersion;

    ZeroMemory(&attMyAttributes, sizeof(attMyAttributes));

    attMyAttributes.pwszContext = L"interface";
    attMyAttributes.guidHelper  = g_IfGuid;
    attMyAttributes.dwVersion   = 1;
    attMyAttributes.dwFlags     = CMD_FLAG_PRIORITY;
    attMyAttributes.ulPriority  = 10; // very low so gets dumped first
    attMyAttributes.ulNumTopCmds  = 0;
    attMyAttributes.pTopCmds      = NULL;
    attMyAttributes.ulNumGroups   = g_ulNumGroups;
    attMyAttributes.pCmdGroups    = (CMD_GROUP_ENTRY (*)[])&g_IfCmdGroups;
    attMyAttributes.pfnCommitFn = IfCommit;
    attMyAttributes.pfnDumpFn   = IfDump;
    attMyAttributes.pfnConnectFn= IfConnect;

    dwErr = RegisterContext( &attMyAttributes );

    return dwErr;
}

DWORD WINAPI
IfConnect(
    IN  LPCWSTR pwszRouter
    )
{
    // If context info is dirty, reregister it
    if (g_bIfDirty)
    {
        IfStartHelper(NULL, ParentVersion);
    }

    return ConnectToRouter(pwszRouter);
}


DWORD WINAPI
InitHelperDll(
    IN  DWORD      dwNetshVersion,
    OUT PVOID      pReserved
    )
{
    DWORD   dwErr;
    NS_HELPER_ATTRIBUTES attMyAttributes;
    WSADATA              wsa;

    //
    // See if this is the first time we are being called
    //

    if(InterlockedIncrement(&g_ulInitCount) != 1)
    {
        return NO_ERROR;
    }

    dwErr = WSAStartup(MAKEWORD(2,0), &wsa);

    g_bCommit = TRUE;

    // Register helpers

    ZeroMemory( &attMyAttributes, sizeof(attMyAttributes) );
    attMyAttributes.guidHelper         = g_IfGuid;
    attMyAttributes.dwVersion          = IF_HELPER_VERSION;
    attMyAttributes.pfnStart           = IfStartHelper;
    attMyAttributes.pfnStop            = NULL;

    RegisterHelper( &g_NetshGuid, &attMyAttributes );


    //
    // Register any sub contexts implemented in this dll
    //
    
    dwErr = IfContextInstallSubContexts();
    if (dwErr isnot NO_ERROR)
    {
        IfUnInit(0);
        return dwErr;
    }
    
    return NO_ERROR;
}

DWORD
ConnectToRouter(
    IN  LPCWSTR  pwszRouter
    )
{
    DWORD    dwErr = NO_ERROR;

    do
    {
        // Change the router name if needed
        //
        if ((g_pwszRouter != pwszRouter) &&
            (!g_pwszRouter || !pwszRouter || lstrcmpi(g_pwszRouter,pwszRouter)))
        {
            if (g_hMprConfig)
            {
                MprConfigServerDisconnect(g_hMprConfig);
                g_hMprConfig = NULL;
            }

            if (g_hMprAdmin)
            {
                MprAdminServerDisconnect(g_hMprAdmin);
                g_hMprAdmin = NULL;
            }

            if (g_hMIBServer)
            {
                MprAdminMIBServerDisconnect(g_hMIBServer);
                g_hMIBServer = NULL;
            }
        }

        // Cleanup the old router name
        //
        if (g_pwszRouter)
        {
            IfutlFree(g_pwszRouter);
        }

        // Copy the new router name in
        //
        if (pwszRouter)
        {
            g_pwszRouter = IfutlStrDup(pwszRouter);
            if (g_pwszRouter == NULL)
            {
                dwErr = ERROR_CONNECT_REMOTE_CONFIG;
                break;
            }
        }
        else
        {
            g_pwszRouter = NULL;
        }

        if (!g_hMprConfig)
        {
            //
            // first time connecting to router config
            //

            dwErr = MprConfigServerConnect((LPWSTR)pwszRouter, &g_hMprConfig);

            if (dwErr isnot NO_ERROR)
            {
                //
                // cannot connect to router config.
                //
                break;
            }
        }

        //
        // Check to see if router is running. If so, get the handles
        //

        if (MprAdminIsServiceRunning((LPWSTR)pwszRouter))
        {
            if(MprAdminServerConnect((LPWSTR)pwszRouter, &g_hMprAdmin) != NO_ERROR)
            {
                g_hMprAdmin = NULL;
            }
        }

    } while (FALSE);

    return dwErr;    
}

DWORD
WINAPI
IfUnInit(
    IN  DWORD   dwReserved
    )
{
    if(InterlockedDecrement(&g_ulInitCount) isnot 0)
    {
        return NO_ERROR;
    }

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\if\ifmon.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:
     net\routing\netsh\ip\ifmon.h   

Abstract:

     Prototype for fns called in ipmon.c

Author:

     Anand Mahalingam    7/10/98

--*/


#ifndef _IFMON_H_
#define _IFMON_H_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif


extern HANDLE   g_hModule;
extern HANDLE   g_hMprConfig; 
extern HANDLE   g_hMprAdmin;
extern HANDLE   g_hMIBServer;
extern BOOL     g_bCommit;
extern DWORD    g_dwNumTableEntries;
extern PWCHAR   g_pwszRouter;
extern BOOL     g_bIfDirty;

//
// Api's that ifmon requires of its helpers
//
typedef
DWORD
(WINAPI IF_CONTEXT_ENTRY_FN)(
    IN    PWCHAR               pwszMachineName,
    IN    PTCHAR               *pptcArguments,
    IN    DWORD                dwArgCount,
    IN    DWORD                dwFlags,
    IN    MIB_SERVER_HANDLE    hMibServer,
    OUT   PWCHAR               pwcNewContext
    );
typedef IF_CONTEXT_ENTRY_FN *PIF_CONTEXT_ENTRY_FN;

extern GUID g_IfGuid;

DWORD
ShowMIB(
    MIB_SERVER_HANDLE    hMIBServer,
    PTCHAR                *pptcArguments,
    DWORD                dwArgCount
    );

NS_CONTEXT_COMMIT_FN IfCommit;
NS_CONTEXT_DUMP_FN   IfDump;

DWORD
ConnectToRouter(
    IN  LPCWSTR  pwszRouter
    );

BOOL
WINAPI
IfDllEntry(
    HINSTANCE   hInstDll,
    DWORD       fdwReason,
    LPVOID      pReserved
    );

DWORD
WINAPI
IfUnInit(
    IN  DWORD   dwReserved
    );

#define GetIfNameFromFriendlyName(x,y,z) \
      NsGetIfNameFromFriendlyName(g_hMprConfig,x,y,z)
#define GetFriendlyNameFromIfName(x,y,z) \
      NsGetFriendlyNameFromIfName(g_hMprConfig,x,y,z)



#ifdef __cplusplus
}
#endif

#endif // _IFMON_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\if\ifip1.c ===
//=============================================================================
// Copyright (c) 1999 Microsoft Corporation
// File: ifip1.c
// Abstract:
//      This module implements the helpers for if/ip apis
//
// Author: K.S.Lokesh (lokeshs@)   8-1-99
//=============================================================================


#include "precomp.h"
#include <iphlpapi.h>
#include <iptypes.h>
#include <llinfo.h>
#include "ifip.h"
#include "ifstring.h"

const WCHAR c_wszListSeparatorComma[] = L",";
const WCHAR c_wListSeparatorComma = L',';
const WCHAR c_wListSeparatorSC = L';';
const WCHAR c_wszListSeparatorSC[] = L";";
const WCHAR c_wcsDefGateway[] = L"DefGw=";
const WCHAR c_wcsGwMetric[] = L"GwMetric=";
const WCHAR c_wcsIfMetric[] = L"IfMetric=";
const WCHAR c_wcsDns[] = L"DNS=";
const WCHAR c_wcsDdns[] = L"DynamicUpdate=";
const WCHAR c_wcsDdnsSuffix[] = L"NameRegistration=";
const WCHAR c_wcsWins[] = L"WINS=";
const WCHAR c_wEqual = L'=';


BOOL g_fInitCom = TRUE;

HRESULT
HrUninitializeAndUnlockINetCfg (
    INetCfg*    pnc
    )
/*++

Routine Description

    Uninitializes and unlocks the INetCfg object
    
Arguments

    pnc [in]    INetCfg to uninitialize and unlock
    
Return Value

    S_OK if success, OLE or Win32 error otherwise

Author:     danielwe   13 Nov 1997

--*/
{
    HRESULT     hr = S_OK;

    hr = pnc->lpVtbl->Uninitialize(pnc);
    if (SUCCEEDED(hr))
    {
        INetCfgLock *   pnclock;

        // Get the locking interface
        hr = pnc->lpVtbl->QueryInterface(pnc, &IID_INetCfgLock,
                                 (LPVOID *)(&pnclock));
        if (SUCCEEDED(hr))
        {
            // Attempt to lock the INetCfg for read/write
            hr = pnclock->lpVtbl->ReleaseWriteLock(pnclock);

            if (pnclock)
            {
                pnclock->lpVtbl->Release(pnclock);
            }
            pnclock = NULL;
        }
    }

    // TraceResult("HrUninitializeAndUnlockINetCfg", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrUninitializeAndReleaseINetCfg
//
//  Purpose:    Unintialize and release an INetCfg object.  This will
//              optionally uninitialize COM for the caller too.
//
//  Arguments:
//      fUninitCom [in] TRUE to uninitialize COM after the INetCfg is
//                      uninitialized and released.
//      pnc        [in] The INetCfg object.
//      fHasLock   [in] TRUE if the INetCfg was locked for write and
//                          must be unlocked.
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   7 May 1997
//
//  Notes:      The return value is the value returned from
//              INetCfg::Uninitialize.  Even if this fails, the INetCfg
//              is still released.  Therefore, the return value is for
//              informational purposes only.  You can't touch the INetCfg
//              object after this call returns.
//
HRESULT
HrUninitializeAndReleaseINetCfg (
    BOOL        fUninitCom,
    INetCfg*    pnc,
    BOOL        fHasLock
    )
/*++

Routine Description

Arguments
    
Return Value

--*/
{
//    Assert (pnc);
    HRESULT hr = S_OK;

    if (fHasLock)
    {
        hr = HrUninitializeAndUnlockINetCfg(pnc);
    }
    else
    {
        hr = pnc->lpVtbl->Uninitialize (pnc);
    }

    if (pnc)
    {
        pnc->lpVtbl->Release(pnc);
    }
    
    pnc = NULL;

    if (fUninitCom)
    {
        CoUninitialize ();
    }
    // TraceResult("HrUninitializeAndReleaseINetCfg", hr);
    return hr;
}


/*!--------------------------------------------------------------------------
    HrGetIpPrivateInterface
        -
    Author: TongLu, KennT
 ---------------------------------------------------------------------------*/
HRESULT HrGetIpPrivateInterface(INetCfg* pNetCfg,
                                ITcpipProperties **ppTcpProperties
                                )
/*++

Routine Description

Arguments
    
Return Value

--*/
{
    HRESULT hr;
    INetCfgClass* pncclass = NULL;

    if ((pNetCfg == NULL) || (ppTcpProperties == NULL))
        return E_INVALIDARG;

    hr = pNetCfg->lpVtbl->QueryNetCfgClass (pNetCfg, &GUID_DEVCLASS_NETTRANS, &IID_INetCfgClass,
                (void**)(&pncclass));
    if (SUCCEEDED(hr))
    {
        INetCfgComponent * pnccItem = NULL;

        // Find the component.
        hr = pncclass->lpVtbl->FindComponent(pncclass, TEXT("MS_TCPIP"), &pnccItem);
        //AssertSz (SUCCEEDED(hr), "pncclass->Find failed.");
        if (S_OK == hr)
        {
            INetCfgComponentPrivate* pinccp = NULL;
            hr = pnccItem->lpVtbl->QueryInterface(pnccItem, &IID_INetCfgComponentPrivate,
                                          (void**)(&pinccp));
            if (SUCCEEDED(hr))
            {
                hr = pinccp->lpVtbl->QueryNotifyObject(pinccp, &IID_ITcpipProperties,
                                     (void**)(ppTcpProperties));
                pinccp->lpVtbl->Release(pinccp);
            }
        }

        if (pnccItem)
            pnccItem->lpVtbl->Release(pnccItem);
    }

    if (pncclass)
        pncclass->lpVtbl->Release(pncclass);

    // S_OK indicates success (interface returned)
    // S_FALSE indicates Ipx not installed
    // other values are errors
    // TraceResult("HrGetIpPrivateInterface", hr);
    return hr;
}








HRESULT
HrCreateAndInitializeINetCfg (
    BOOL*       pfInitCom,
    INetCfg**   ppnc,
    BOOL        fGetWriteLock,
    DWORD       cmsTimeout,
    LPCWSTR     szwClientDesc,
    LPWSTR *    ppszwClientDesc
    )
/*++

Routine Description

    Cocreate and initialize the root INetCfg object.  This will
    optionally initialize COM for the caller too.

Arguments

    pfInitCom       [in,out]   TRUE to call CoInitialize before creating.
                               returns TRUE if COM was successfully
                               initialized FALSE if not.  If NULL, means
                               don't initialize COM.
    ppnc            [out]  The returned INetCfg object.
    fGetWriteLock   [in]   TRUE if a writable INetCfg is needed
    cmsTimeout      [in]   See INetCfg::LockForWrite
    szwClientDesc   [in]   See INetCfg::LockForWrite
    ppszwClientDesc [out]   See INetCfg::LockForWrite    
    
Return Value

    S_OK or an error code.
    
--*/
{
    HRESULT hr;
    

    // Initialize the output parameter.
    *ppnc = NULL;

    if (ppszwClientDesc)
        *ppszwClientDesc = NULL;

    // Initialize COM if the caller requested.
    hr = S_OK;
    if (pfInitCom && *pfInitCom)
    {
        hr = CoInitializeEx( NULL,
                COINIT_DISABLE_OLE1DDE | COINIT_APARTMENTTHREADED );
        if (RPC_E_CHANGED_MODE == hr)
        {
            hr = S_OK;
            if (pfInitCom)
            {
                *pfInitCom = FALSE;
            }
        }
    }
    if (SUCCEEDED(hr))
    {
        // Create the object implementing INetCfg.
        //
        INetCfg* pnc;
        hr = CoCreateInstance(&CLSID_CNetCfg, NULL, CLSCTX_INPROC_SERVER,
                              &IID_INetCfg, (void**)(&pnc));
        // TraceResult("HrCreateAndInitializeINetCfg - CoCreateInstance(CLSID_CNetCfg)", hr);
        if (SUCCEEDED(hr))
        {
            INetCfgLock* pnclock = NULL;
            if (fGetWriteLock)
            {
                // Get the locking interface
                hr = pnc->lpVtbl->QueryInterface(pnc, &IID_INetCfgLock,
                                         (LPVOID *)(&pnclock));
                // TraceResult("HrCreateAndInitializeINetCfg - QueryInterface(IID_INetCfgLock", hr);
                if (SUCCEEDED(hr))
                {
                    // Attempt to lock the INetCfg for read/write
                    hr = pnclock->lpVtbl->AcquireWriteLock(pnclock, cmsTimeout, szwClientDesc,
                                               ppszwClientDesc);
                    // TraceResult("HrCreateAndInitializeINetCfg - INetCfgLock::LockForWrite", hr);
                    if (S_FALSE == hr)
                    {
                        // Couldn't acquire the lock
                        hr = NETCFG_E_NO_WRITE_LOCK;
                    }
                }
            }

            if (SUCCEEDED(hr))
            {
                // Initialize the INetCfg object.
                //
                hr = pnc->lpVtbl->Initialize (pnc, NULL);
                // TraceResult("HrCreateAndInitializeINetCfg - Initialize", hr);
                if (SUCCEEDED(hr))
                {
                    *ppnc = pnc;
                    if (pnc)
                        pnc->lpVtbl->AddRef(pnc);
                }
                else
                {
                    if (pnclock)
                    {
                        pnclock->lpVtbl->ReleaseWriteLock(pnclock);
                    }
                }
                // Transfer reference to caller.
            }

            if (pnclock)
            {
                pnclock->lpVtbl->Release(pnclock);
            }
            
            pnclock = NULL;


            if (pnc)
            {
                pnc->lpVtbl->Release(pnc);
            }
            
            pnc = NULL;
        }

        // If we failed anything above, and we've initialized COM,
        // be sure an uninitialize it.
        //
        if (FAILED(hr) && pfInitCom && *pfInitCom)
        {
            CoUninitialize ();
        }

    }

    return hr;
}

DWORD
GetTransportConfig(
    INetCfg **   pNetCfg,
    ITcpipProperties ** pTcpipProperties,
    REMOTE_IPINFO   **pRemoteIpInfo,
    GUID *pGuid,
    LPCWSTR pwszIfFriendlyName
    )
/*++

Routine Description

Arguments
    
Return Value

--*/
{
    WCHAR    wszDesc[] = L"Test of Change IP settings";
    HRESULT  hr;

    // Create the INetCfg, we get the write lock because we need read and write
    hr = HrCreateAndInitializeINetCfg(&g_fInitCom, /* &g_fInitCom, */
                                      pNetCfg,
                                      TRUE /* fGetWriteLock */,  
                                      500     /* cmsTimeout */,
                                      wszDesc/* swzClientDesc */,
                                      NULL  /* ppszwClientDesc */);
    
    if (hr == S_OK)
    {
        hr = HrGetIpPrivateInterface(*pNetCfg, pTcpipProperties);
    }

    if (hr == NETCFG_E_NO_WRITE_LOCK) {

        DisplayMessage( g_hModule, EMSG_NETCFG_WRITE_LOCK );
        return ERROR_SUPPRESS_OUTPUT;
    }
    
    if (hr == S_OK)
    {
        hr = (*pTcpipProperties)->lpVtbl->GetIpInfoForAdapter(*pTcpipProperties, pGuid, pRemoteIpInfo);

        if (hr != S_OK)
        {
            DisplayMessage(g_hModule, EMSG_PROPERTIES, pwszIfFriendlyName);
            hr = ERROR_SUPPRESS_OUTPUT;
        }
    }

    return (hr==S_OK) ? NO_ERROR : hr;
}


VOID
UninitializeTransportConfig(
    INetCfg *   pNetCfg,
    ITcpipProperties * pTcpipProperties,
    REMOTE_IPINFO   *pRemoteIpInfo
    )
/*++

Routine Description

Arguments
    
Return Value

--*/
{
    if (pTcpipProperties)
        pTcpipProperties->lpVtbl->Release(pTcpipProperties);

    if (pNetCfg)
    {
        HrUninitializeAndReleaseINetCfg(FALSE,
                                        pNetCfg,
                                        TRUE   /* fHasLock */);
    }

    if (pRemoteIpInfo) CoTaskMemFree(pRemoteIpInfo);
    
    return;
}
    
DWORD
IfIpAddSetAddress(
    LPCWSTR pwszIfFriendlyName,
    GUID *pGuid,
    LPCWSTR wszIp,
    LPCWSTR wszMask,
    DWORD Flags
    )
/*++

Routine Description

Arguments
    
Return Value

--*/
{
    INetCfg *   pNetCfg = NULL;
    ITcpipProperties *  pTcpipProperties = NULL;
    DWORD       dwNetwork;
    DWORD     dwErr =  NO_ERROR;
    REMOTE_IPINFO   *pRemoteIpInfo = NULL;
    REMOTE_IPINFO    newIPInfo;
    

    if (pGuid == NULL)
        return E_INVALIDARG;


    dwErr = HRESULT_CODE(GetTransportConfig(
                                &pNetCfg,
                                &pTcpipProperties,
                                &pRemoteIpInfo,
                                pGuid,
                                pwszIfFriendlyName
                                ));
        

    while (dwErr == NO_ERROR) { //breakout block
    
        PWCHAR ptrAddr, ptrMask;
        DWORD Found = FALSE;
        PWCHAR pszwRemoteIpAddrList=NULL, pszwRemoteIpSubnetMaskList=NULL,
                pszwRemoteOptionList=pRemoteIpInfo->pszwOptionList;//i copy options list
        PWCHAR IpAddrListEnd;
        ULONG Length = wcslen(wszIp);

        // currently in static mode
        
        if (pRemoteIpInfo->dwEnableDhcp == FALSE) {

            pszwRemoteIpAddrList = pRemoteIpInfo->pszwIpAddrList;
            pszwRemoteIpSubnetMaskList = pRemoteIpInfo->pszwSubnetMaskList;
            IpAddrListEnd = pszwRemoteIpAddrList + wcslen(pszwRemoteIpAddrList);
        }

        
        //
        // if adding ipaddr, check if the IpAddr and Mask is already present
        //

        if (Flags & ADD_FLAG) {

            //
            // make sure it is in static mode
            //
            
            if (pRemoteIpInfo->dwEnableDhcp == TRUE) {

                DisplayMessage(g_hModule,
                           EMSG_ADD_IPADDR_DHCP);

                dwErr = ERROR_SUPPRESS_OUTPUT;
                break;
            }
            
            ptrAddr = pszwRemoteIpAddrList;
            ptrMask = pszwRemoteIpSubnetMaskList;

            while (ptrAddr && (ptrAddr + Length <= IpAddrListEnd) ){

                if (wcsncmp(ptrAddr, wszIp, Length) == 0) {

                    if ( *(ptrAddr+Length)==0 || *(ptrAddr+Length)==c_wListSeparatorComma){

                        Found = TRUE;
                        break;
                    }
                }

                ptrAddr = wcschr(ptrAddr, c_wListSeparatorComma);
                ptrMask = wcschr(ptrMask, c_wListSeparatorComma);

                if (ptrAddr){
                    ptrAddr++;
                    ptrMask++;
                }
            }
            
            if (Found) {

                PWCHAR MaskEnd;
                MaskEnd = wcschr(ptrMask, c_wListSeparatorComma);
                if (MaskEnd)
                    *MaskEnd = 0;
                    
                DisplayMessage(g_hModule,
                           EMSG_IPADDR_PRESENT,
                           wszIp, ptrMask);

                if (MaskEnd)
                    *MaskEnd = c_wListSeparatorComma;
                
                dwErr = ERROR_SUPPRESS_OUTPUT;
                break;
            }
        }
        memcpy(&newIPInfo, pRemoteIpInfo, sizeof(newIPInfo));
        newIPInfo.dwEnableDhcp = FALSE;

        //
        // copy ip addr list
        //
        
        if (Flags & ADD_FLAG) {
        
            ULONG IpAddrListLength = 0;
            
            if (pszwRemoteIpAddrList)
                IpAddrListLength = wcslen(pszwRemoteIpAddrList);
                
            newIPInfo.pszwIpAddrList = IfutlAlloc (sizeof(WCHAR) * 
                                            (IpAddrListLength +
                                            Length + 2), TRUE);

            if (!newIPInfo.pszwIpAddrList)
                return ERROR_NOT_ENOUGH_MEMORY;
                
            newIPInfo.pszwIpAddrList[0] = 0;
            
            if (pszwRemoteIpAddrList) {
                wcscat(newIPInfo.pszwIpAddrList, pszwRemoteIpAddrList);
                wcscat(newIPInfo.pszwIpAddrList, c_wszListSeparatorComma);
            }
            
            wcscat(newIPInfo.pszwIpAddrList, wszIp);
        }
        else {
                newIPInfo.pszwIpAddrList = IfutlAlloc (sizeof(WCHAR) * 
                                                (Length + 1), FALSE);

                if (!newIPInfo.pszwIpAddrList)
                    return ERROR_NOT_ENOUGH_MEMORY;
                
                wcscpy(newIPInfo.pszwIpAddrList, wszIp);
        }

        //
        // copy subnet mask list
        //
        
        if (Flags & ADD_FLAG) {
        
            ULONG RemoteIpSubnetMaskListLen = 0;
            
            if (pszwRemoteIpSubnetMaskList)
                RemoteIpSubnetMaskListLen = wcslen(pszwRemoteIpSubnetMaskList);
                
            newIPInfo.pszwSubnetMaskList = IfutlAlloc (sizeof(WCHAR) * 
                                                (RemoteIpSubnetMaskListLen +
                                                wcslen(wszMask) + 2), TRUE);

            if (!newIPInfo.pszwSubnetMaskList)
                return ERROR_NOT_ENOUGH_MEMORY;

            newIPInfo.pszwSubnetMaskList[0]= 0;
            
            if (pszwRemoteIpSubnetMaskList) {
                wcscpy(newIPInfo.pszwSubnetMaskList, pszwRemoteIpSubnetMaskList);
                wcscat(newIPInfo.pszwSubnetMaskList, c_wszListSeparatorComma);
            }
        
            wcscat(newIPInfo.pszwSubnetMaskList, wszMask);
        }
        else {
                newIPInfo.pszwSubnetMaskList = IfutlAlloc (sizeof(WCHAR) * 
                                                    (wcslen(wszMask) + 1), FALSE);
                                                
                if (!newIPInfo.pszwSubnetMaskList)
                    return ERROR_NOT_ENOUGH_MEMORY;

                wcscpy(newIPInfo.pszwSubnetMaskList, wszMask);
        }

        

        // copy old options list
        
        newIPInfo.pszwOptionList = _wcsdup(pszwRemoteOptionList);

        DEBUG_PRINT_CONFIG(&newIPInfo);

        //
        // set the ip address
        //
        dwErr = HRESULT_CODE(pTcpipProperties->lpVtbl->SetIpInfoForAdapter(
                                    pTcpipProperties, pGuid, &newIPInfo));

        if (dwErr == NO_ERROR)
            dwErr = HRESULT_CODE(pNetCfg->lpVtbl->Apply(pNetCfg));


        if (newIPInfo.pszwIpAddrList) IfutlFree(newIPInfo.pszwIpAddrList);
        if (newIPInfo.pszwSubnetMaskList) IfutlFree(newIPInfo.pszwSubnetMaskList);
        if (newIPInfo.pszwOptionList) free(newIPInfo.pszwOptionList);

        break; //breakout block
        
    } //breakout block
    

    UninitializeTransportConfig(
                pNetCfg,
                pTcpipProperties,
                pRemoteIpInfo
                );

    return dwErr;
}

VOID
AppendDdnsOptions(
    PWCHAR ptrDstn,
    PWCHAR ptrOptionList,
    DWORD Flags,
    DWORD dwRegisterMode
    )
/*++

Routine Description

    Adds the appropriate "DynamicUpdate=...;NameRegistration=...;"
    string to a net config option list.

Arguments

    ptrDstn        [in] Buffer to which to append DDNS options.
    ptrOptionList  [in] Old option list.
    Flags          [in] Used to tell whether this is in a SET or ADD.
    dwRegisterMode [in] New mode to convert to options values.
    
Return Value

    None.

--*/
{
    PWCHAR      ptrBegin, ptrEnd;

    //
    // Insert DynamicUpdate=...;
    //
    wcscat(ptrDstn, c_wcsDdns);
    if ((Flags & SET_FLAG) && (dwRegisterMode != REGISTER_UNCHANGED)) {
        //
        // Insert the new value.
        //
        if (dwRegisterMode == REGISTER_NONE) {
            wcscat(ptrDstn, L"0");
        } else {
            wcscat(ptrDstn, L"1");
        }
    } else {
        //
        // Copy the previous value.
        //
        ptrBegin = wcsstr(ptrOptionList, c_wcsDdns) + 
                   wcslen(c_wcsDdns);
        ptrEnd = wcschr(ptrBegin, c_wListSeparatorSC);

        ptrDstn += wcslen(ptrDstn);
        wcsncpy(ptrDstn, ptrBegin, (DWORD)(ptrEnd - ptrBegin));
        ptrDstn += (ULONG)(ptrEnd - ptrBegin);
        *ptrDstn = 0;
    }
    wcscat(ptrDstn, c_wszListSeparatorSC);

    //
    // Insert NameRegistration=...;
    //
    wcscat(ptrDstn, c_wcsDdnsSuffix);
    if ((Flags & SET_FLAG) && (dwRegisterMode != REGISTER_UNCHANGED)) {
        //
        // Insert the new value.
        //
        if (dwRegisterMode == REGISTER_BOTH) {
            wcscat(ptrDstn, L"1");
        } else {
            wcscat(ptrDstn, L"0");
        }
    } else {
        //
        // Copy the previous value.
        //
        ptrBegin = wcsstr(ptrOptionList, c_wcsDdnsSuffix) + 
                   wcslen(c_wcsDdnsSuffix);
        ptrEnd = wcschr(ptrBegin, c_wListSeparatorSC);

        ptrDstn += wcslen(ptrDstn);
        wcsncpy(ptrDstn, ptrBegin, (DWORD)(ptrEnd - ptrBegin));
        ptrDstn += (ULONG)(ptrEnd - ptrBegin);
        *ptrDstn = 0;
    }
    wcscat(ptrDstn, c_wszListSeparatorSC);
}

DWORD
IfIpSetDhcpModeMany(
    LPCWSTR pwszIfFriendlyName,    
    GUID         *pGuid,
    DWORD        dwRegisterMode,
    DISPLAY_TYPE Type
    )
/*++

Routine Description

Arguments
    
Return Value

--*/
{
    INetCfg *   pNetCfg = NULL;
    ITcpipProperties *  pTcpipProperties = NULL;
    DWORD       dwNetwork;
    HRESULT     hr = S_OK;
    REMOTE_IPINFO   *pRemoteIpInfo = NULL;
    REMOTE_IPINFO    newIPInfo;
    
    if (pGuid == NULL)
        return E_INVALIDARG;


    hr = GetTransportConfig(
                &pNetCfg,
                &pTcpipProperties,
                &pRemoteIpInfo,
                pGuid,
                pwszIfFriendlyName
                );
        

    while (hr == NO_ERROR) { //breakout block

        PWCHAR pszwBuffer;
        PWCHAR ptr, newPtr;
        
        PWCHAR pszwRemoteOptionList=pRemoteIpInfo->pszwOptionList;

        try {
            #pragma prefast(suppress:263, "This is a breakout block, not while loop")
            pszwBuffer = (PWCHAR) _alloca(sizeof(WCHAR) *
                            (wcslen(pszwRemoteOptionList) + 100)) ;
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }


        
        // if setting ipaddr, check if dhcp already enabled. return.
        
        if (Type==TYPE_IPADDR && pRemoteIpInfo->dwEnableDhcp) {

            DisplayMessage(g_hModule,
                       EMSG_DHCP_MODE);

            hr = ERROR_SUPPRESS_OUTPUT;
            break;
        }
        

        memcpy(&newIPInfo, pRemoteIpInfo, sizeof(REMOTE_IPINFO));
        newIPInfo.dwEnableDhcp = pRemoteIpInfo->dwEnableDhcp;
        newIPInfo.pszwOptionList = pszwBuffer;


        pszwBuffer[0] = 0;
        switch(Type) {
            case TYPE_DNS:
                wcscpy(pszwBuffer, c_wcsDns);
                wcscat(pszwBuffer, c_wszListSeparatorSC);

                AppendDdnsOptions(pszwBuffer + wcslen(pszwBuffer),
                                  pRemoteIpInfo->pszwOptionList,
                                  SET_FLAG, dwRegisterMode); 
                break;
                
            case TYPE_WINS:
                wcscpy(pszwBuffer, c_wcsWins);
                wcscat(pszwBuffer, c_wszListSeparatorSC);
                break;
                
            
            case TYPE_IPADDR:

                newIPInfo.dwEnableDhcp = TRUE;

                newIPInfo.pszwIpAddrList = NULL;
                newIPInfo.pszwSubnetMaskList = NULL;

                wcscpy(pszwBuffer, c_wcsDefGateway);
                wcscat(pszwBuffer, c_wszListSeparatorSC);
                wcscat(pszwBuffer, c_wcsGwMetric);
                wcscat(pszwBuffer, c_wszListSeparatorSC);
                break;
        }
        
        DEBUG_PRINT_CONFIG(&newIPInfo);

        
        
        //
        // set the ip address
        //
        hr = pTcpipProperties->lpVtbl->SetIpInfoForAdapter(pTcpipProperties, pGuid, &newIPInfo);

        if (hr == S_OK)
            hr = pNetCfg->lpVtbl->Apply(pNetCfg);

        break;
        
    } //breakout block


    UninitializeTransportConfig(
                pNetCfg,
                pTcpipProperties,
                pRemoteIpInfo
                );   

    return (hr == S_OK) ? NO_ERROR : hr;
}


DWORD
IfIpAddSetDelMany(
    PWCHAR wszIfFriendlyName,
    GUID         *pGuid,
    PWCHAR       pwszAddress,
    DWORD        dwIndex,
    DWORD        dwRegisterMode,
    DISPLAY_TYPE Type,
    DWORD        Flags
    )
/*++

Routine Description

Arguments
    
Return Value

--*/
{
    INetCfg *           pNetCfg = NULL;
    ITcpipProperties *  pTcpipProperties = NULL;
    DWORD               dwNetwork;
    HRESULT             hr = S_OK;
    REMOTE_IPINFO   *   pRemoteIpInfo = NULL;
    REMOTE_IPINFO       newIPInfo;

    if (pGuid == NULL)
        return E_INVALIDARG;

    hr = GetTransportConfig(
                &pNetCfg,
                &pTcpipProperties,
                &pRemoteIpInfo,
                pGuid,
                wszIfFriendlyName
                );
        

    while (hr==NO_ERROR) { //breakout block
    
        PWCHAR ptrBegin, ptrEnd, ptrTmp, ptrDstn, ptrDel=NULL;
        const WCHAR * Token;

        switch (Type) {

            case TYPE_DNS:
                Token = c_wcsDns;
                break;

            case TYPE_WINS:
                Token = c_wcsWins;
                break;
        }
        
        ptrBegin = wcsstr(pRemoteIpInfo->pszwOptionList, Token) + wcslen(Token);
        ptrEnd = wcschr(ptrBegin, c_wListSeparatorSC);
        
        //
        // check if the address is already present
        //
        if ( (Flags & (ADD_FLAG | DEL_FLAG)) && (pwszAddress)) {
        
            ULONG Length = wcslen(pwszAddress), Found = FALSE;
            
            ptrTmp = ptrBegin;

            while (ptrTmp && (ptrTmp+Length <= ptrEnd) ){

                if (ptrTmp = wcsstr(ptrTmp, pwszAddress)) {

                    if ( ((*(ptrTmp+Length)==c_wListSeparatorComma)
                            || (*(ptrTmp+Length)==c_wListSeparatorSC) )
                        && ( (*(ptrTmp-1)==c_wListSeparatorComma)
                            || (*(ptrTmp-1)==c_wEqual)) )
                    {
                        Found = TRUE;
                        ptrDel = ptrTmp;
                        break;
                    }
                    else {
                        ptrTmp = wcschr(ptrTmp, c_wListSeparatorComma);
                    }
                }
            }

            if (Found && (Flags & ADD_FLAG)) {
            
                DisplayMessage(g_hModule,
                       EMSG_SERVER_PRESENT,
                       pwszAddress);
                hr = ERROR_SUPPRESS_OUTPUT;
                break; //from breakout block
            }
            else if (!Found && (Flags & DEL_FLAG)) {

                DisplayMessage(g_hModule,
                       EMSG_SERVER_ABSENT,
                       pwszAddress);
                hr = ERROR_SUPPRESS_OUTPUT;
                break; //from breakout block

            }
            
        } // breakout block    

        memcpy(&newIPInfo, pRemoteIpInfo, sizeof(newIPInfo));

        // copy ip addr list
        {
            newIPInfo.pszwIpAddrList = pRemoteIpInfo->pszwIpAddrList;
        }

        // copy subnet mask list
        {
            newIPInfo.pszwSubnetMaskList = pRemoteIpInfo->pszwSubnetMaskList;
        }

        try {
            #pragma prefast(suppress:263, "This is a breakout block, not while loop")
            newIPInfo.pszwOptionList = 
                (PWCHAR) _alloca(sizeof(PWCHAR) * 
                (wcslen(pRemoteIpInfo->pszwOptionList)+
                (pwszAddress?wcslen(pwszAddress):0) + 1));

        } except (EXCEPTION_EXECUTE_HANDLER) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

                
        // copy token in all cases

        ptrDstn = newIPInfo.pszwOptionList;
        ptrDstn[0] = 0;
        wcscpy(ptrDstn, Token);
        ptrDstn += wcslen(Token);
        
        if (Flags & ADD_FLAG) {

            DWORD i;
            
            ptrTmp = ptrBegin;
            
            for (i=0;  i<dwIndex-1 && ptrTmp && ptrTmp<ptrEnd;  i++) {

                ptrTmp = wcschr(ptrTmp, c_wListSeparatorComma);
                if (ptrTmp) ptrTmp++;
            }

            if (!ptrTmp || (ptrTmp > ptrEnd)) {
                ptrTmp = ptrEnd;
            }

            if (*(ptrTmp-1) == c_wListSeparatorComma)
                ptrTmp--;
                
            // copy addresses before index

            if (ptrTmp>ptrBegin) {
                wcsncpy(ptrDstn, ptrBegin, (DWORD)(ptrTmp-ptrBegin));
                ptrDstn += (ULONG) (ptrTmp - ptrBegin);

                ptrTmp++;
                *ptrDstn++ = c_wListSeparatorComma;
                *ptrDstn = 0;
            }
            
        }

        // copy new address
        
        if (Flags & (ADD_FLAG|SET_FLAG) ) {

            if (pwszAddress) {
                wcscat(ptrDstn, pwszAddress);
                ptrDstn += wcslen(pwszAddress);
            }
        }
        
        // copy addresses after index

        if (Flags & ADD_FLAG) {

            if (ptrTmp < ptrEnd) {
                *ptrDstn++ = c_wListSeparatorComma;
                *ptrDstn = 0;

                wcsncpy(ptrDstn, ptrTmp, (DWORD)(ptrEnd - ptrTmp));
                ptrDstn += (ULONG)(ptrEnd - ptrTmp);
                *ptrDstn = 0;
            }
        }

        if (Flags & (ADD_FLAG|SET_FLAG) ) {
            wcscat(ptrDstn, c_wszListSeparatorSC);
        }


        if (Flags & DEL_FLAG) {

            if (pwszAddress && ptrDel) {//ptrDel to make prefast happy
                                        //if ptrDel not set, then I would have 
                                        //got out of breakout block.

                BOOL AddrPrepend = FALSE;
            
                if (ptrDel > ptrBegin) {
                    wcsncat(ptrDstn, ptrBegin, (DWORD)(ptrDel-ptrBegin));
                    ptrDstn += (ULONG)(ptrDel-ptrBegin);
                    AddrPrepend = TRUE;
                    if ( *(ptrDstn-1) == c_wListSeparatorComma) {
                        *(--ptrDstn) = 0;
                    }
                }
                
                ptrTmp = ptrDel + wcslen(pwszAddress);
                if (*ptrTmp == c_wListSeparatorComma) 
                    ptrTmp++;

                if (AddrPrepend && *ptrTmp!=c_wListSeparatorSC)
                    *ptrDstn++ = c_wListSeparatorComma;

                wcsncat(ptrDstn, ptrTmp, (DWORD)(ptrEnd - ptrTmp));
                ptrDstn += (ULONG)(ptrEnd - ptrTmp);
                *ptrDstn = 0;
            }
            
            wcscat(ptrDstn, c_wszListSeparatorSC);
        }

        if (Type == TYPE_DNS) {
            AppendDdnsOptions(ptrDstn, pRemoteIpInfo->pszwOptionList,
                              Flags, dwRegisterMode); 
        }

        DEBUG_PRINT_CONFIG(&newIPInfo);

        
        //
        // set the ip address
        //
        hr = pTcpipProperties->lpVtbl->SetIpInfoForAdapter(pTcpipProperties, pGuid, &newIPInfo);

        if (hr == S_OK)
            hr = pNetCfg->lpVtbl->Apply(pNetCfg);

        break;
        
    } //breakout block
            
    
    UninitializeTransportConfig(
                pNetCfg,
                pTcpipProperties,
                pRemoteIpInfo
                );
                
    return (hr == S_OK) ? NO_ERROR : hr;
}


DWORD
IfIpAddSetGateway(
    LPCWSTR pwszIfFriendlyName,
    GUID         *pGuid,
    LPCWSTR      pwszGateway,
    LPCWSTR      pwszGwMetric,
    DWORD        Flags
    )
/*++

Routine Description

Arguments
    
Return Value

--*/
{
    INetCfg *   pNetCfg = NULL;
    ITcpipProperties *  pTcpipProperties = NULL;
    DWORD       dwNetwork;
    HRESULT     hr = S_OK;
    REMOTE_IPINFO   *pRemoteIpInfo = NULL;
    REMOTE_IPINFO    newIPInfo;
    PWCHAR      Gateways, GatewaysEnd, GwMetrics, GwMetricsEnd;

    if (pGuid == NULL)
        return E_INVALIDARG;

    hr = GetTransportConfig(
                &pNetCfg,
                &pTcpipProperties,
                &pRemoteIpInfo,
                pGuid,
                pwszIfFriendlyName
                );
        
    while (hr==NO_ERROR) { //breakout block
    
        PWCHAR ptrAddr, ptrMask;
        DWORD bFound = FALSE;
        PWCHAR pszwRemoteIpAddrList=NULL, pszwRemoteIpSubnetMaskList=NULL,
                pszwRemoteOptionList=NULL;


        pszwRemoteIpAddrList = pRemoteIpInfo->pszwIpAddrList;
        pszwRemoteIpSubnetMaskList = pRemoteIpInfo->pszwSubnetMaskList;
        pszwRemoteOptionList = pRemoteIpInfo->pszwOptionList;

        Gateways = wcsstr(pszwRemoteOptionList, c_wcsDefGateway) + wcslen(c_wcsDefGateway);
        GatewaysEnd = wcschr(Gateways, c_wListSeparatorSC);
        GwMetrics = wcsstr(pszwRemoteOptionList, c_wcsGwMetric) + wcslen(c_wcsGwMetric);
        GwMetricsEnd = wcschr(GwMetrics, c_wListSeparatorSC);
            


        //
        // check if the gateway is already present
        //

        if (Flags & ADD_FLAG) {
        
            ULONG Length = wcslen(pwszGateway), Found = FALSE;
            PWCHAR TmpPtr;
            
            TmpPtr = Gateways;

            while (TmpPtr && (TmpPtr+Length <= GatewaysEnd) ){

                if (TmpPtr = wcsstr(TmpPtr, pwszGateway)) {

                    if ( ((*(TmpPtr+Length)==c_wListSeparatorComma)
                            || (*(TmpPtr+Length)==c_wListSeparatorSC) )
                        && ( (*(TmpPtr-1)==c_wListSeparatorComma)
                            || (*(TmpPtr-1)==c_wEqual)) )
                    {
                        Found = TRUE;
                        break;
                    }
                    else {
                        TmpPtr = wcschr(TmpPtr, c_wListSeparatorComma);
                    }
                }
            }

            if (Found) {
                DisplayMessage(g_hModule,
                       EMSG_DEFGATEWAY_PRESENT,
                       pwszGateway);
                hr = ERROR_SUPPRESS_OUTPUT;
                break; //from breakout block
            }
        }
        
        memcpy(&newIPInfo, pRemoteIpInfo, sizeof(newIPInfo));


        // copy ip addr list
        newIPInfo.pszwIpAddrList = pRemoteIpInfo->pszwIpAddrList;


        // copy subnet mask list
        newIPInfo.pszwSubnetMaskList = pRemoteIpInfo->pszwSubnetMaskList;

        // copy old options list

        if (Flags & ADD_FLAG) {
        
            newIPInfo.pszwOptionList = IfutlAlloc (sizeof(WCHAR) * 
                                            (wcslen(pszwRemoteOptionList) +
                                             wcslen(pwszGateway) +
                                             wcslen(pwszGwMetric) +
                                             3), TRUE);
            if (!newIPInfo.pszwOptionList) {
                hr = ERROR_NOT_ENOUGH_MEMORY;
                break; //from breakout block
            }

            wcsncpy(newIPInfo.pszwOptionList, pszwRemoteOptionList,
                        (DWORD)(GatewaysEnd - pszwRemoteOptionList));

            *(newIPInfo.pszwOptionList + (GatewaysEnd - pszwRemoteOptionList)) = 0;
            if (*(GatewaysEnd-1) != c_wEqual) {
                wcscat(newIPInfo.pszwOptionList, c_wszListSeparatorComma);
            }
            wcscat(newIPInfo.pszwOptionList, pwszGateway);
            wcscat(newIPInfo.pszwOptionList, c_wszListSeparatorSC);

            {
                ULONG Length;
                Length = wcslen(newIPInfo.pszwOptionList);
            
                wcsncat(newIPInfo.pszwOptionList, GatewaysEnd+1,
                        (DWORD)(GwMetricsEnd - (GatewaysEnd+1)));
                Length += (DWORD) (GwMetricsEnd - (GatewaysEnd+1));

                newIPInfo.pszwOptionList[Length] = 0;
            }
            
            if (*(GwMetricsEnd-1) != c_wEqual) {
                wcscat(newIPInfo.pszwOptionList, c_wszListSeparatorComma);
            }
            
            wcscat(newIPInfo.pszwOptionList, pwszGwMetric);
            wcscat(newIPInfo.pszwOptionList, c_wszListSeparatorSC);
            wcscat(newIPInfo.pszwOptionList, GwMetricsEnd+1);
        }
        else {

            ULONG Length;
            
            Length = sizeof(WCHAR) * (wcslen(c_wcsDefGateway) + wcslen(c_wcsGwMetric) + 3);
            if (pwszGateway) 
                Length += sizeof(WCHAR) * (wcslen(pwszGateway) + wcslen(pwszGwMetric));
                
            newIPInfo.pszwOptionList = (PWCHAR) IfutlAlloc (Length, FALSE);
            if (newIPInfo.pszwOptionList == NULL) {
                hr = ERROR_NOT_ENOUGH_MEMORY;
                break; //from breakout block
            }
            newIPInfo.pszwOptionList[0] = 0;

            // cat gateway
            
            wcscat(newIPInfo.pszwOptionList, c_wcsDefGateway);
            if (pwszGateway)
                wcscat(newIPInfo.pszwOptionList, pwszGateway);

            wcscat(newIPInfo.pszwOptionList, c_wszListSeparatorSC);

            // cat gwmetric

            wcscat(newIPInfo.pszwOptionList, c_wcsGwMetric);
            if (pwszGateway)
                wcscat(newIPInfo.pszwOptionList, pwszGwMetric);

            wcscat(newIPInfo.pszwOptionList, c_wszListSeparatorSC);
        }


        DEBUG_PRINT_CONFIG(&newIPInfo);

        
        //
        // set the ip address
        //
        hr = pTcpipProperties->lpVtbl->SetIpInfoForAdapter(pTcpipProperties, pGuid, &newIPInfo);

        if (hr == S_OK)
            hr = pNetCfg->lpVtbl->Apply(pNetCfg);


        if (newIPInfo.pszwOptionList) IfutlFree(newIPInfo.pszwOptionList);

        break;
        
    } //breakout block
            

    UninitializeTransportConfig(
                pNetCfg,
                pTcpipProperties,
                pRemoteIpInfo
                );   

    return (hr == S_OK) ? NO_ERROR : hr;
}

// 
// Display an IP address in Unicode form.  If First is false, 
// a string of spaces will first be printed so that the list lines up.
// For the first address, the caller is responsible for printing the
// header before calling this function.
//
VOID
ShowUnicodeAddress(
    BOOL  *pFirst, 
    PWCHAR pwszAddress)
{
    if (*pFirst) {
        *pFirst = FALSE;
    } else {
        DisplayMessage(g_hModule, MSG_ADDR2);
    }
    DisplayMessage(g_hModule, MSG_ADDR1, pwszAddress);
}

// Same as ShowUnicodeAddress, except that the address is passed 
// in multibyte form, such as is used by IPHLPAPI
VOID
ShowCharAddress(
    BOOL *pFirst, 
    char *chAddress)
{
    WCHAR pwszBuffer[16];

    if (!chAddress[0]) {
        return;
    }

    MultiByteToWideChar(GetConsoleOutputCP(), 0, chAddress, strlen(chAddress)+1,
                        pwszBuffer, 16);

    ShowUnicodeAddress(pFirst, pwszBuffer);
}

DWORD
IfIpShowManyExEx(
    LPCWSTR     pwszMachineName,
    ULONG       IfIndex,
    PWCHAR      pFriendlyIfName,
    GUID       *pGuid,
    ULONG       Flags,
    HANDLE      hFile
    )
/*++

Routine Description

Arguments
    
Return Value

--*/
{
    INetCfg *   pNetCfg = NULL;
    ITcpipProperties *  pTcpipProperties = NULL;
    DWORD       dwNetwork, dwSize = 0, dwErr;
    HRESULT     hr = S_OK;
    REMOTE_IPINFO   *pRemoteIpInfo = NULL;
    REMOTE_IPINFO    newIPInfo;
    PWCHAR      pQuotedFriendlyIfName = NULL;
    PIP_PER_ADAPTER_INFO pPerAdapterInfo = NULL;
    PIP_ADAPTER_INFO pAdaptersInfo = NULL, pAdapterInfo = NULL;
    DWORD            dwRegisterMode;

    if (pGuid == NULL)
        return E_INVALIDARG;

    if (hFile && pwszMachineName) {
        // not currently remotable
        return NO_ERROR;
    }

    if (!hFile && !pwszMachineName) {
        //
        // If we're not doing a "dump", and we're looking at the local
        // machine, then get active per-adapter information such as the
        // current DNS and WINS server addresses
        //

        GetPerAdapterInfo(IfIndex, NULL, &dwSize);
        pPerAdapterInfo = (PIP_PER_ADAPTER_INFO)IfutlAlloc(dwSize,FALSE);
        if (!pPerAdapterInfo) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        dwErr = GetPerAdapterInfo(IfIndex, pPerAdapterInfo, &dwSize);
        if (dwErr != NO_ERROR) {
            IfutlFree(pPerAdapterInfo);
            pPerAdapterInfo = NULL; 
        }

        dwSize = 0;
        GetAdaptersInfo(NULL, &dwSize);
        pAdaptersInfo = (PIP_ADAPTER_INFO)IfutlAlloc(dwSize,FALSE);
        if (!pAdaptersInfo) {
            IfutlFree(pPerAdapterInfo);
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        dwErr = GetAdaptersInfo(pAdaptersInfo, &dwSize);
        if (dwErr != NO_ERROR) {
            IfutlFree(pAdaptersInfo);
            pAdaptersInfo = NULL; 
        }
        if (pAdaptersInfo) {
            for (pAdapterInfo = pAdaptersInfo; 
                 pAdapterInfo && pAdapterInfo->Index != IfIndex; 
                 pAdapterInfo = pAdapterInfo->Next);
        }
    }

    hr = GetTransportConfig(
                &pNetCfg,
                &pTcpipProperties,
                &pRemoteIpInfo,
                pGuid,
                pFriendlyIfName
                );
        
    while (hr==NO_ERROR) { //breakout block
    
        PWCHAR ptrAddr, ptrMask, ptrAddrNew, ptrMaskNew;


        if (hr != NO_ERROR)
            break;


        pQuotedFriendlyIfName = MakeQuotedString( pFriendlyIfName );

        if ( pQuotedFriendlyIfName == NULL ) {
            hr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }


        DEBUG_PRINT_CONFIG(pRemoteIpInfo);
        

        if (hFile) {
            DisplayMessage(g_hModule,
                    DMP_IFIP_INTERFACE_HEADER,
                    pQuotedFriendlyIfName);
        }
        else {
        
            DisplayMessage(g_hModule,
                    MSG_IFIP_HEADER,
                    pQuotedFriendlyIfName);
        }
        

        //
        // display ipaddress list
        //

        if (Flags & TYPE_IPADDR) {

            if (hFile) {
                DisplayMessageT(
                    (pRemoteIpInfo->dwEnableDhcp) ? DMP_DHCP : DMP_STATIC,
                    pQuotedFriendlyIfName
                    );
            }
            else {
                DisplayMessage(g_hModule,
                       (pRemoteIpInfo->dwEnableDhcp) ? MSG_DHCP : MSG_STATIC);
            }    

        
            if (!pRemoteIpInfo->dwEnableDhcp) {
            
                ptrAddr = pRemoteIpInfo->pszwIpAddrList;
                ptrMask = pRemoteIpInfo->pszwSubnetMaskList;
            } else if (!pwszMachineName) {
                // If on the local machine, get the active list
                ptrAddr = NULL;
                ptrMask = NULL;
            }

            if (ptrAddr && ptrMask) {

                    DWORD First = TRUE;
                    
                    while (ptrAddr && ptrMask && *ptrAddr!=0 && *ptrMask != 0) {
                        
                        ptrAddrNew = wcschr(ptrAddr, c_wListSeparatorComma);
                        ptrMaskNew = wcschr(ptrMask, c_wListSeparatorComma);

                        if (ptrAddrNew)
                            *ptrAddrNew = 0;
                        if (ptrMaskNew)
                            *ptrMaskNew = 0;

                        if (hFile) {

                            if (First) {
                                DisplayMessageT(
                                    DMP_IPADDR1,
                                    ptrAddr, ptrMask
                                    );
                                First = FALSE;
                            }
                            else {
                                DisplayMessageT(
                                    DMP_IPADDR2,
                                    pQuotedFriendlyIfName,
                                    ptrAddr, ptrMask
                                    );
                            }
                        }
                        else {
                            DisplayMessage(g_hModule,
                                MSG_IPADDR_LIST1,
                                ptrAddr, ptrMask);
                        }
                        
                        ptrAddr = ptrAddrNew ? ++ptrAddrNew : NULL;
                        ptrMask = ptrMaskNew ? ++ptrMaskNew : NULL;
                    }
            }
            
        } // end display ipaddr

        
        //
        // display options list
        //

        {
            PWCHAR IfMetric1, Gateways1, GwMetrics1, Dns1, Wins1,
                    Ptr1, Ptr2, Equal, SemiColon, Ddns1, DdnsSuffix1,
                    End1;

            if (hr != NO_ERROR)
                break;
                    
            Ptr1 = pRemoteIpInfo->pszwOptionList;
            IfMetric1 = wcsstr(Ptr1, c_wcsIfMetric);
            Gateways1 = wcsstr(Ptr1, c_wcsDefGateway);
            GwMetrics1 = wcsstr(Ptr1, c_wcsGwMetric);
            Dns1 = wcsstr(Ptr1, c_wcsDns);
            Wins1 = wcsstr(Ptr1, c_wcsWins);
            Ddns1 = wcsstr(Ptr1, c_wcsDdns);
            DdnsSuffix1 = wcsstr(Ptr1, c_wcsDdnsSuffix);

            while (*Ptr1) {
            
                Equal = wcschr(Ptr1, c_wEqual);
                SemiColon = wcschr(Ptr1, c_wListSeparatorSC);
                if (!Equal || !SemiColon)
                    break;

                Ptr2 = Ptr1;
                Ptr1 = SemiColon + 1;
                *SemiColon = 0;
                

                // display IfMetric
                
                if (Ptr2 == IfMetric1) {

                    if (! (Flags & TYPE_IPADDR))
                        continue;

                    if (hFile) {
                    }
                    else {
                        DisplayMessage(g_hModule,
                            MSG_IFMETRIC,
                            Equal+1);
                    }
                    
                }

                // display Gateways
                
                else if (Ptr2 == Gateways1) {

                    PWCHAR Gateway, GwMetric, GatewayEnd, GwMetricEnd,
                           Comma1, Comma2;
                    BOOL First = TRUE;

                    
                    if (! (Flags & TYPE_IPADDR))
                        continue;
                        

                    // gateways list null
                    
                    if (SemiColon == (Ptr2 + wcslen(c_wcsDefGateway)))
                        continue;


                    Gateway = Equal + 1;
                    GatewayEnd = SemiColon;

                    GwMetric = wcschr(GwMetrics1, c_wEqual) + 1;
                    GwMetricEnd = wcschr(GwMetrics1, c_wListSeparatorSC);
                    *GwMetricEnd = 0;
                    

                    do {
                        
                        Comma1 = wcschr(Gateway, c_wListSeparatorComma);
                        if (Comma1) *Comma1 = 0;

                        Comma2 = wcschr(GwMetric, c_wListSeparatorComma);
                        if (Comma2) *Comma2 = 0;

                        if (hFile) {

                            if (First) {
                                DisplayMessageT(
                                    DMP_GATEWAY2,
                                    pQuotedFriendlyIfName,
                                    Gateway, GwMetric
                                    );
                                First = FALSE;
                            }
                            else {
                                DisplayMessageT(
                                    DMP_GATEWAY3,
                                    pQuotedFriendlyIfName,
                                    Gateway, GwMetric
                                    );
                            }
                        }
                        else {
                            DisplayMessage(g_hModule,
                                MSG_GATEWAY,
                                Gateway, GwMetric);
                        }
                        
                        if (Comma1) *Comma1 = c_wListSeparatorComma;
                        if (Comma2) *Comma2 = c_wListSeparatorComma;

                        Gateway = Comma1 + 1;
                        GwMetric = Comma2 + 1;

                    } while (Comma1 && Gateway<GatewayEnd);

                    if (hFile && First) {
                        DisplayMessageT(
                            DMP_GATEWAY1,
                            pQuotedFriendlyIfName
                            );
                    }
                    
                    *GwMetricEnd = c_wListSeparatorSC;
                }

                else if (Ptr2 == GwMetrics1) {

                }

                // display wins and dns
                
                else if ( (Ptr2 == Dns1) || (Ptr2==Wins1)) {

                    PWCHAR BeginPtr, EndPtr;
                    BOOL bDns = Ptr2==Dns1;
                    
                    if (Ptr2==Dns1) {
                        if (! (Flags & TYPE_DNS))
                            continue;
                    }
                    else {
                        if (! (Flags & TYPE_WINS))
                            continue;
                    }

                    BeginPtr = Equal + 1;
                    EndPtr = SemiColon;


                    // empty list
                    
                    if (BeginPtr==EndPtr) {
                    
                        if (hFile) {
                            DisplayMessageT(
                                pRemoteIpInfo->dwEnableDhcp
                                ? (bDns?DMP_DNS_DHCP:DMP_WINS_DHCP)
                                : (bDns?DMP_DNS_STATIC_NONE:DMP_WINS_STATIC_NONE),
                                pQuotedFriendlyIfName
                                );

                            if (bDns) {
                                //
                                // When generating a DNS (not WINS) line,
                                // also include the REGISTER=... argument.
                                // We need to look ahead in the option list
                                // since the DDNS info may occur after the
                                // WINS info, but we have to output it before.
                                //
                                if (!wcstol(Ddns1+wcslen(c_wcsDdns), &End1, 10)) {
                                    DisplayMessageT(DMP_STRING_ARG, 
                                        TOKEN_REGISTER, TOKEN_VALUE_NONE);
                                } else if (!wcstol(DdnsSuffix1+wcslen(
                                                c_wcsDdnsSuffix), &End1, 10)) {
                                    DisplayMessageT(DMP_STRING_ARG, 
                                        TOKEN_REGISTER, TOKEN_VALUE_PRIMARY);
                                } else {
                                    DisplayMessageT(DMP_STRING_ARG, 
                                        TOKEN_REGISTER, TOKEN_VALUE_BOTH);
                                }
                            }
                        }
                        else {
                            if (pRemoteIpInfo->dwEnableDhcp) {
                                IP_ADDR_STRING      *pAddr;
                                BOOL                 First = TRUE;

                                if (!pwszMachineName) {
                                    DisplayMessage(g_hModule,
                                        (bDns?MSG_DNS_DHCP_HDR:MSG_WINS_DHCP_HDR)
                                        );

                                    // Display active list
                            
                                    if (bDns && pPerAdapterInfo) {        
                                        for (pAddr = &pPerAdapterInfo->DnsServerList;
                                             pAddr; 
                                             pAddr = pAddr->Next) 
                                        {
                                            ShowCharAddress(&First, pAddr->IpAddress.String);
                                        }
                                    } else if (!bDns && pAdapterInfo) {
                                        if (strcmp(pAdapterInfo->PrimaryWinsServer.IpAddress.String, "0.0.0.0")) {
                                            ShowCharAddress(&First, pAdapterInfo->PrimaryWinsServer.IpAddress.String);
                                        }
                                        if (strcmp(pAdapterInfo->SecondaryWinsServer.IpAddress.String, "0.0.0.0")) {
                                            ShowCharAddress(&First, pAdapterInfo->SecondaryWinsServer.IpAddress.String);
                                        }
                                    }

                                    if (First) {
                                        DisplayMessage(g_hModule, MSG_NONE);
                                    }
                                } else {
                                    DisplayMessage(g_hModule,
                                        (bDns?MSG_DNS_DHCP:MSG_WINS_DHCP)
                                        );
                                }
                            }
                            else {
                                DisplayMessage(g_hModule,
                                    bDns?MSG_DNS_HDR:MSG_WINS_HDR);
                                DisplayMessage(g_hModule,
                                    MSG_NONE);
                            }

                            //
                            // For show commands, we output either DNS or WINS
                            // information but not both, so we can wait until
                            // we process the DDNS information normally,
                            // before outputting the DDNS state.
                            //
                        }

                        continue;
                    }

                    {
                        PWCHAR Comma1;
                        BOOL   First = TRUE;
                        DWORD  Index = 0;

                        if (!hFile) {
                            DisplayMessage(g_hModule,
                                bDns?MSG_DNS_HDR:MSG_WINS_HDR);
                        }
                    
                        do {
                            Index++;
                            Comma1 = wcschr(BeginPtr, c_wListSeparatorComma);
                            if (Comma1) *Comma1 = 0;
                    
                            if (hFile) {
                                DisplayMessageT(
                                    First 
                                    ? (First=FALSE,(bDns?DMP_DNS_STATIC_ADDR1:DMP_WINS_STATIC_ADDR1)) 
                                    : (bDns?DMP_DNS_STATIC_ADDR2:DMP_WINS_STATIC_ADDR2),
                                    pQuotedFriendlyIfName,
                                    BeginPtr);

                                if (bDns && (Index == 1)) {
                                    //
                                    // When generating a DNS (not WINS) line,
                                    // also include the REGISTER=... argument.
                                    // We need to look ahead in the option list
                                    // since the DDNS info may occur after the
                                    // WINS info, but we have to output it 
                                    // before.
                                    //
                                    if (!wcstol(Ddns1+wcslen(c_wcsDdns), &End1, 10)) {
                                        DisplayMessageT(DMP_STRING_ARG,
                                            TOKEN_REGISTER, TOKEN_VALUE_NONE);
                                    } else if (!wcstol(DdnsSuffix1+wcslen(
                                                    c_wcsDdnsSuffix), &End1, 10)) {
                                        DisplayMessageT(DMP_STRING_ARG,
                                            TOKEN_REGISTER, TOKEN_VALUE_PRIMARY);
                                    } else {
                                        DisplayMessageT(DMP_STRING_ARG,
                                            TOKEN_REGISTER, TOKEN_VALUE_BOTH);
                                    }
                                } else if (Index > 1) {
                                    DisplayMessageT(DMP_INTEGER_ARG,
                                                    TOKEN_INDEX, Index);
                                }
                            } else {
                                ShowUnicodeAddress(&First, BeginPtr);
                            }
                            
                            if (Comma1) *Comma1 = c_wListSeparatorComma;
                            BeginPtr = Comma1 + 1;

                        } while (Comma1 && BeginPtr<EndPtr);
                    }
                }

                else if (Ptr2 == Ddns1) {
                    if (! (Flags & TYPE_DNS))
                        continue;

                    //
                    // When we see DynamicUpdate=..., save the value.
                    // We won't know the complete register mode until
                    // we see the subsequent NameRegistration=... value.
                    // NetConfig guarantees that DynamicUpdate will occur
                    // first.
                    //
                    dwRegisterMode = wcstol(Equal+1, &End1, 10)? REGISTER_PRIMARY : REGISTER_NONE;
                }
                else if (Ptr2 == DdnsSuffix1) {
                    if (! (Flags & TYPE_DNS))
                        continue;
                    if (hFile) {
                        //
                        // If this is a dump, we've already looked at
                        // this value, when we processed the DNS=... option.
                        //
                    } else {
                        PWCHAR pwszValue;

                        //
                        // Now that we've seen NameRegistration=...,
                        // we know the complete register mode and can
                        // output it accordingly.
                        //
                        if ((dwRegisterMode == REGISTER_PRIMARY) && 
                            wcstol(Equal+1, &End1, 10)) {
                            pwszValue = MakeString(g_hModule, STRING_BOTH);
                        } else if (dwRegisterMode == REGISTER_PRIMARY) {
                            pwszValue = MakeString(g_hModule, STRING_PRIMARY);
                        } else {
                            pwszValue = MakeString(g_hModule, STRING_NONE);
                        }

                        DisplayMessage(g_hModule, MSG_DDNS_SUFFIX, pwszValue);

                        FreeString(pwszValue);
                    }
                }
                
                // any other option
                
                else {
                
                    *Equal = 0;

                    if (!hFile) {
                        DisplayMessage(g_hModule,
                            MSG_OPTION,
                            Ptr2, Equal+1);
                    }                        
                }
            }
        } //end options list

        break;
        
    } // breakout block

    if ( pQuotedFriendlyIfName ) {
        FreeQuotedString( pQuotedFriendlyIfName );
    }
    
    UninitializeTransportConfig(
                pNetCfg,
                pTcpipProperties,
                pRemoteIpInfo
                );

        
    IfutlFree(pPerAdapterInfo);
    IfutlFree(pAdaptersInfo);

    return (hr == S_OK) ? NO_ERROR : hr;
}



DWORD
IfIpHandleDelIpaddrEx(
    LPCWSTR      pwszIfFriendlyName,
    GUID         *pGuid,
    LPCWSTR      pwszIpAddr,
    LPCWSTR      pwszGateway,
    ULONG        Flags
    )
/*++

Routine Description

Arguments
    
Return Value

--*/
{
    INetCfg *   pNetCfg = NULL;
    ITcpipProperties *  pTcpipProperties = NULL;
    DWORD       dwNetwork;
    HRESULT     hr = S_OK;
    REMOTE_IPINFO   *pRemoteIpInfo = NULL;

    if (pGuid == NULL)
        return E_INVALIDARG;

    hr = GetTransportConfig(
                &pNetCfg,
                &pTcpipProperties,
                &pRemoteIpInfo,
                pGuid,
                pwszIfFriendlyName
                );
        
    while (hr==NO_ERROR) { //breakout block

        if (Flags & TYPE_ADDR) {

            PWCHAR IpAddr, IpAddrEnd;
            PWCHAR Mask, MaskEnd;
            PWCHAR pszwRemoteIpAddrList = pRemoteIpInfo->pszwIpAddrList;
            PWCHAR pszwRemoteSubnetMaskList = pRemoteIpInfo->pszwSubnetMaskList;
            PWCHAR EndIpAddrList = pszwRemoteIpAddrList + wcslen(pszwRemoteIpAddrList);
            BOOL Found = FALSE;
            ULONG Length = wcslen(pwszIpAddr);

            
            IpAddr = pszwRemoteIpAddrList;
            Mask = pszwRemoteSubnetMaskList;
            
            while (IpAddr && (IpAddr + Length <= EndIpAddrList) ){

                if (wcsncmp(IpAddr, pwszIpAddr, Length) == 0) {

                    if ( *(IpAddr+Length)==0 || *(IpAddr+Length)==c_wListSeparatorComma){

                        Found = TRUE;
                        break;
                    }
                }

                IpAddr = wcschr(IpAddr, c_wListSeparatorComma);
                Mask = wcschr(Mask, c_wListSeparatorComma);

                if (IpAddr){
                    IpAddr++;
                    Mask++;
                }
            }

            
            // IpAddr not present
            
            if (!Found) {
                DisplayMessage(g_hModule,
                   EMSG_ADDRESS_NOT_PRESENT);

                hr = ERROR_SUPPRESS_OUTPUT;
                break;
            }

            
            // cannot delete addr in dhcp mode
            
            if (pRemoteIpInfo->dwEnableDhcp == TRUE) {

                DisplayMessage(g_hModule,
                   EMSG_DHCP_DELETEADDR);

                hr = ERROR_SUPPRESS_OUTPUT;
                break;
            }


            
            IpAddrEnd = wcschr(IpAddr, c_wListSeparatorComma);
            MaskEnd = wcschr(Mask, c_wListSeparatorComma);
            
            if (*(IpAddr-1) == c_wListSeparatorComma) {
                IpAddr --;
                Mask --;
            }
            else if (IpAddrEnd) {
                IpAddrEnd++;
                MaskEnd++;
            }

            
            pszwRemoteIpAddrList[IpAddr - pszwRemoteIpAddrList] = 0;
            pszwRemoteSubnetMaskList[Mask - pszwRemoteSubnetMaskList] = 0;
            
            if (IpAddrEnd) {
                wcscat(pszwRemoteIpAddrList, IpAddrEnd);
                wcscat(pszwRemoteSubnetMaskList, MaskEnd);
            }

            
            // should have at least one addr in static mode
            
            if (wcslen(pszwRemoteIpAddrList)==0 && 
                pRemoteIpInfo->dwEnableDhcp == FALSE)
            {
                DisplayMessage(g_hModule,
                   EMSG_MIN_ONE_ADDR);

                hr = ERROR_SUPPRESS_OUTPUT;
                break;

            }
        } //end delete ipaddr

    
        if (Flags & TYPE_GATEWAY) {

            PWCHAR pszwRemoteOptionList = pRemoteIpInfo->pszwOptionList;
            PWCHAR Gateways, GatewaysEnd, GwMetrics, GwMetricsEnd, GwMetrics1;
            BOOL Found = FALSE;
            
            Gateways = wcsstr(pszwRemoteOptionList, c_wcsDefGateway)
                + wcslen(c_wcsDefGateway);
            GwMetrics1 = GwMetrics = wcsstr(pszwRemoteOptionList, c_wcsGwMetric)
                + wcslen(c_wcsGwMetric);
            GatewaysEnd = wcschr(Gateways, c_wListSeparatorSC);

            // check if the gateway is present
        
            if (pwszGateway) {

                ULONG Length = wcslen(pwszGateway);

                while ((Gateways+Length) <= GatewaysEnd) {

                    if ( (wcsncmp(pwszGateway, Gateways, Length)==0)
                        && ( (*(Gateways+Length)==c_wListSeparatorComma)
                            || (*(Gateways+Length)==c_wListSeparatorSC)) )
                    {

                        Found = TRUE;
                        break;
                    }
                    else {

                        if (Gateways = wcschr(Gateways, c_wListSeparatorComma)) {

                            Gateways++;
                            GwMetrics = wcschr(GwMetrics, c_wListSeparatorComma) + 1;
                        }
                        else {
                            break;
                        }
                    }
                }
            
                if (!Found) {

                    DisplayMessage(g_hModule,
                       EMSG_GATEWAY_NOT_PRESENT);

                    hr = ERROR_SUPPRESS_OUTPUT;
                    
                    break; //from breakout block
                }
            }
            
            if (!pwszGateway) {

                wcscpy(pszwRemoteOptionList, c_wcsDefGateway);
                wcscat(pszwRemoteOptionList, c_wszListSeparatorSC);
                wcscat(pszwRemoteOptionList, c_wcsGwMetric);
                wcscat(pszwRemoteOptionList, c_wszListSeparatorSC);
            }
            else {
                PWCHAR GatewaysListEnd, GwMetricsListEnd, TmpPtr;

                GatewaysListEnd = wcschr(Gateways, c_wListSeparatorSC);
                GwMetricsListEnd = wcschr(GwMetrics, c_wListSeparatorSC);

                GatewaysEnd = Gateways + wcslen(pwszGateway);
                GwMetricsEnd = wcschr(GwMetrics, c_wListSeparatorComma);
                if (!GwMetricsEnd || GwMetricsEnd>GwMetricsListEnd)
                    GwMetricsEnd = wcschr(GwMetrics, c_wListSeparatorSC);
                    

                if (*(Gateways-1)==c_wListSeparatorComma) {
                    Gateways--;
                    GwMetrics--;
                    
                } else if (*GatewaysEnd==c_wListSeparatorComma) {
                    GatewaysEnd++;
                    GwMetricsEnd++;
                }
                
                wcsncpy(Gateways, GatewaysEnd, (DWORD)(GwMetrics - GatewaysEnd));
                TmpPtr = Gateways + (GwMetrics - GatewaysEnd);
                *TmpPtr = 0;
                wcscat(TmpPtr, GwMetricsEnd);
            }
        } //end delete gateway


        //
        // set the config
        //

        if (hr == S_OK)
            hr = pTcpipProperties->lpVtbl->SetIpInfoForAdapter(pTcpipProperties, pGuid, pRemoteIpInfo);

        if (hr == S_OK)
            hr = pNetCfg->lpVtbl->Apply(pNetCfg);

        break;
        
    }//end breakout block
                       

    UninitializeTransportConfig(
                pNetCfg,
                pTcpipProperties,
                pRemoteIpInfo
                );

    return (hr == S_OK) ? NO_ERROR : hr;
}

DWORD
OpenDriver(
    HANDLE *Handle,
    LPWSTR DriverName
    )
/*++

Routine Description:

    This function opens a specified IO drivers.

Arguments:

    Handle - pointer to location where the opened drivers handle is
        returned.

    DriverName - name of the driver to be opened.

Return Value:

    Windows Error Code.
Notes: copied from net\sockets\tcpcmd\ipcfgapi\ipcfgapi.c

--*/
{
    OBJECT_ATTRIBUTES   objectAttributes;
    IO_STATUS_BLOCK     ioStatusBlock;
    UNICODE_STRING      nameString;
    NTSTATUS            status;

    *Handle = NULL;

    //
    // Open a Handle to the IP driver.
    //

    RtlInitUnicodeString(&nameString, DriverName);

    InitializeObjectAttributes(
        &objectAttributes,
        &nameString,
        OBJ_CASE_INSENSITIVE,
        (HANDLE) NULL,
        (PSECURITY_DESCRIPTOR) NULL
        );

    status = NtCreateFile(
        Handle,
        SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
        &objectAttributes,
        &ioStatusBlock,
        NULL,
        FILE_ATTRIBUTE_NORMAL,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        FILE_OPEN_IF,
        0,
        NULL,
        0
        );

    return( RtlNtStatusToDosError( status ) );
}

NTSTATUS
DoIoctl(
    HANDLE     Handle,
    DWORD      IoctlCode,
    PVOID      Request,
    DWORD      RequestSize,
    PVOID      Response,
    PDWORD     ResponseSize
    )
/*++

Routine Description:

    Utility routine used to issue a filtering ioctl to the tcpip driver.

Arguments:

    Handle - An open file handle on which to issue the request.

    IoctlCode - The IOCTL opcode.

    Request - A pointer to the input buffer.

    RequestSize - Size of the input buffer.

    Response - A pointer to the output buffer.

    ResponseSize - On input, the size in bytes of the output buffer.
                   On output, the number of bytes returned in the output 
buffer.

Return Value:

    NT Status Code.
Notes: copied from net\sockets\tcpcmd\ipcfgapi\ipcfgapi.c
--*/
{
    IO_STATUS_BLOCK    ioStatusBlock;
    NTSTATUS           status;


    ioStatusBlock.Information = 0;

    status = NtDeviceIoControlFile(
                 Handle,                          // Driver handle
                 NULL,                            // Event
                 NULL,                            // APC Routine
                 NULL,                            // APC context
                 &ioStatusBlock,                  // Status block
                 IoctlCode,                       // Control code
                 Request,                         // Input buffer
                 RequestSize,                     // Input buffer size
                 Response,                        // Output buffer
                 *ResponseSize                    // Output buffer size
                 );

    if (status == STATUS_PENDING) {
        status = NtWaitForSingleObject(
                     Handle,
                     TRUE,
                     NULL
                     );
    }

 
    if (status == STATUS_SUCCESS) {
        status = ioStatusBlock.Status;
        *ResponseSize = (ULONG)ioStatusBlock.Information;
    }
    else {
        *ResponseSize = 0;
    }

    return(status);
}


DWORD
IfIpGetInfoOffload(
    ULONG IfIndex,
    IFOffloadCapability* IFOC
    )
/*++

Routine Description

Arguments
    
Return Value

--*/
{
    NTSTATUS Status;
    HANDLE Handle;
    ULONG ResponseBufferSize = sizeof(*IFOC);
    
    Status = OpenDriver(&Handle, L"\\Device\\Ip");    
    if (!NT_SUCCESS(Status)) {
        return(RtlNtStatusToDosError(Status));
    }    

    Status = DoIoctl(
                 Handle,
                 IOCTL_IP_GET_OFFLOAD_CAPABILITY,
                 &IfIndex,
                 sizeof(IfIndex),
                 IFOC,
                 &ResponseBufferSize
                 );

    CloseHandle(Handle);

    if (!NT_SUCCESS(Status)) {
        return(RtlNtStatusToDosError(Status));
    }

    return NO_ERROR;
}


DWORD
IfIpShowManyEx(
    LPCWSTR pwszMachineName,
    ULONG IfIndex,
    PWCHAR wszIfFriendlyName,
    GUID *guid,
    DISPLAY_TYPE dtType,
    HANDLE hFile
    )
/*++

Routine Description

Arguments
    
Return Value

--*/
{
    switch (dtType) {

        case TYPE_IPADDR:
        case TYPE_DNS:
        case TYPE_WINS:
        case TYPE_IP_ALL:
            return IfIpShowManyExEx(pwszMachineName, IfIndex, wszIfFriendlyName, guid, dtType, hFile);
        
        case TYPE_OFFLOAD:
            return IfIpShowInfoOffload(IfIndex, wszIfFriendlyName);
            
    }
    
    return NO_ERROR;
}

DWORD
IfIpShowInfoOffload(
    ULONG IfIndex,
    PWCHAR wszIfFriendlyName
    )
/*++

Routine Description

Arguments
    
Return Value

--*/
{
    IFOffloadCapability IFOC;
    DWORD dwErr;
    PWCHAR pQuotedFriendlyIfName = NULL;


    pQuotedFriendlyIfName = MakeQuotedString( wszIfFriendlyName );
    if ( pQuotedFriendlyIfName == NULL ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

        
    dwErr = IfIpGetInfoOffload(IfIndex, &IFOC);
    if (dwErr != NO_ERROR)
        return dwErr;

        
    DisplayMessage(g_hModule,
               MSG_OFFLOAD_HDR, pQuotedFriendlyIfName, IfIndex);

    if (IFOC.ifoc_OffloadFlags & TCP_XMT_CHECKSUM_OFFLOAD) {
        DisplayMessage(g_hModule,
            MSG_TCP_XMT_CHECKSUM_OFFLOAD);
    }

    if (IFOC.ifoc_OffloadFlags & IP_XMT_CHECKSUM_OFFLOAD) {
        DisplayMessage(g_hModule,
            MSG_IP_XMT_CHECKSUM_OFFLOAD);
    }

    if (IFOC.ifoc_OffloadFlags & TCP_RCV_CHECKSUM_OFFLOAD) {
        DisplayMessage(g_hModule,
            MSG_TCP_RCV_CHECKSUM_OFFLOAD);
    }

    if (IFOC.ifoc_OffloadFlags & IP_RCV_CHECKSUM_OFFLOAD) {
        DisplayMessage(g_hModule,
            MSG_IP_RCV_CHECKSUM_OFFLOAD);
    }

    if (IFOC.ifoc_OffloadFlags & TCP_LARGE_SEND_OFFLOAD) {
        DisplayMessage(g_hModule,
            MSG_TCP_LARGE_SEND_OFFLOAD);
    }



    if (IFOC.ifoc_IPSecOffloadFlags & IPSEC_OFFLOAD_CRYPTO_ONLY) {
        DisplayMessage(g_hModule,
            MSG_IPSEC_OFFLOAD_CRYPTO_ONLY);
    }

    if (IFOC.ifoc_IPSecOffloadFlags & IPSEC_OFFLOAD_AH_ESP) {
        DisplayMessage(g_hModule,
            MSG_IPSEC_OFFLOAD_AH_ESP);
    }

    if (IFOC.ifoc_IPSecOffloadFlags & IPSEC_OFFLOAD_TPT_TUNNEL) {
        DisplayMessage(g_hModule,
            MSG_IPSEC_OFFLOAD_TPT_TUNNEL);
    }

    if (IFOC.ifoc_IPSecOffloadFlags & IPSEC_OFFLOAD_V4_OPTIONS) {
        DisplayMessage(g_hModule,
            MSG_IPSEC_OFFLOAD_V4_OPTIONS);
    }

    if (IFOC.ifoc_IPSecOffloadFlags & IPSEC_OFFLOAD_QUERY_SPI) {
        DisplayMessage(g_hModule,
            MSG_IPSEC_OFFLOAD_QUERY_SPI);
    }



    if (IFOC.ifoc_IPSecOffloadFlags & IPSEC_OFFLOAD_AH_XMT) {
        DisplayMessage(g_hModule,
            MSG_IPSEC_OFFLOAD_AH_XMT);
    }

    if (IFOC.ifoc_IPSecOffloadFlags & IPSEC_OFFLOAD_AH_RCV) {
        DisplayMessage(g_hModule,
            MSG_IPSEC_OFFLOAD_AH_RCV);
    }

    if (IFOC.ifoc_IPSecOffloadFlags & IPSEC_OFFLOAD_AH_TPT) {
        DisplayMessage(g_hModule,
            MSG_IPSEC_OFFLOAD_AH_TPT);
    }

    if (IFOC.ifoc_IPSecOffloadFlags & IPSEC_OFFLOAD_AH_TUNNEL) {
        DisplayMessage(g_hModule,
            MSG_IPSEC_OFFLOAD_AH_TUNNEL);
    }

    if (IFOC.ifoc_IPSecOffloadFlags & IPSEC_OFFLOAD_AH_MD5) {
        DisplayMessage(g_hModule,
            MSG_IPSEC_OFFLOAD_AH_MD5);
    }

    if (IFOC.ifoc_IPSecOffloadFlags & IPSEC_OFFLOAD_AH_SHA_1) {
        DisplayMessage(g_hModule,
            MSG_IPSEC_OFFLOAD_AH_SHA_1);
    }



    if (IFOC.ifoc_IPSecOffloadFlags & IPSEC_OFFLOAD_ESP_XMT) {
        DisplayMessage(g_hModule,
            MSG_IPSEC_OFFLOAD_ESP_XMT);
    }

    if (IFOC.ifoc_IPSecOffloadFlags & IPSEC_OFFLOAD_ESP_RCV) {
        DisplayMessage(g_hModule,
            MSG_IPSEC_OFFLOAD_ESP_RCV);
    }

    if (IFOC.ifoc_IPSecOffloadFlags & IPSEC_OFFLOAD_ESP_TPT) {
        DisplayMessage(g_hModule,
            MSG_IPSEC_OFFLOAD_ESP_TPT);
    }

    if (IFOC.ifoc_IPSecOffloadFlags & IPSEC_OFFLOAD_ESP_TUNNEL) {
        DisplayMessage(g_hModule,
            MSG_IPSEC_OFFLOAD_ESP_TUNNEL);
    }

    if (IFOC.ifoc_IPSecOffloadFlags & IPSEC_OFFLOAD_ESP_DES) {
        DisplayMessage(g_hModule,
            MSG_IPSEC_OFFLOAD_ESP_DES);
    }

    if (IFOC.ifoc_IPSecOffloadFlags & IPSEC_OFFLOAD_ESP_DES_40) {
        DisplayMessage(g_hModule,
            MSG_IPSEC_OFFLOAD_ESP_DES_40);
    }

    if (IFOC.ifoc_IPSecOffloadFlags & IPSEC_OFFLOAD_ESP_3_DES) {
        DisplayMessage(g_hModule,
            MSG_IPSEC_OFFLOAD_ESP_3_DES);
    }

    if (IFOC.ifoc_IPSecOffloadFlags & IPSEC_OFFLOAD_ESP_NONE) {
        DisplayMessage(g_hModule,
            MSG_IPSEC_OFFLOAD_ESP_NONE);
    }

    if ( pQuotedFriendlyIfName ) {
        FreeQuotedString( pQuotedFriendlyIfName );
    }

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\if\repair.c ===
#include "precomp.h"

EXTERN_C
VOID
WINAPI
NetCfgDiagRepairRegistryBindings (
    IN FILE* pLogFile);

#define REG_DELETE  100

CONST CHAR Empty[] = "";

typedef union _TR_VALUE_DATA {
    ULONG_PTR __asignany;
    ULONG Value;
    CONST BYTE* Pointer;
} TR_VALUE_DATA;

typedef
VOID
(TR_CONDITIONAL_ROUTINE)(
    IN CONST struct _TR_REPAIR_CONTEXT *Ctx,
    IN CONST struct _TR_KEY_DESCRIPTOR *Kd,
    IN CONST struct _TR_VALUE_DESCRIPTOR *Vd,
    OUT DWORD *RegType,
    OUT TR_VALUE_DATA *Data,
    OUT DWORD *DataSize
    );

typedef TR_CONDITIONAL_ROUTINE *PTR_CONDITIONAL_ROUTINE;

typedef struct _TR_VALUE_DESCRIPTOR {
    PCSTR SubKeyName;
    PCSTR ValueName;
    DWORD RegType;
    TR_VALUE_DATA Data;
    DWORD DataSize;

    //
    // If Conditional is TRUE, then Data and DataSize are obtained at run-time
    // by invoking the routine whose address is in ConditionalRoutine.
    // ConditionalData may be used to hold arbitrary information for use by
    // ConditionalRoutine.
    //
    BOOLEAN Conditional;
    PTR_CONDITIONAL_ROUTINE ConditionalRoutine;
    TR_VALUE_DATA ConditionalData;
} TR_VALUE_DESCRIPTOR;

#define TRV_DW(_subkey, _valuename, _data) \
    { _subkey, _valuename, REG_DWORD, (ULONG_PTR)_data, sizeof(DWORD) },

#define TRV_ESZ(_subkey, _valuename, _esz) \
    { _subkey, _valuename, REG_EXPAND_SZ, (ULONG_PTR)_esz, sizeof(_esz) },

#define TRV_MSZ(_subkey, _valuename, _msz) \
    { _subkey, _valuename, REG_MULTI_SZ, (ULONG_PTR)_msz, sizeof(_msz) },

#define TRV_SZ(_subkey, _valuename, _sz) \
    { _subkey, _valuename, REG_SZ, (ULONG_PTR)_sz, sizeof(_sz) },

#define TRV_DEL(_subkey, _valuename) \
    { _subkey, _valuename, REG_DELETE, 0, 0 },

#define TRV_COND(_subkey, _valuename, _routine, _cdata) \
    { _subkey, _valuename, REG_NONE, 0, 0, TRUE, _routine, _cdata },

#define TRV_END() \
    { NULL, NULL, REG_NONE, 0, 0 }

typedef struct _TR_KEY_DESCRIPTOR {
    //
    // RootKey is one of the HKEY_* values.  (e.g. HKEY_LOCAL_MACHINE)
    //
    HKEY RootKey;

    //
    // ParentKey is the name of a subkey (under RootKey) where either the
    // values reside or subkeys are to be enumerated and values found under
    // each subkey.
    //
    PCSTR ParentKeyName;

    //
    // TRUE if all subkeys of Parentkey are to be enumerated and values
    // found under each of those subkeys.
    //
    BOOL EnumKey;

    //
    // Pointer to an array of value descriptors.  The array is terminated
    // with an entry of all zeros.
    //
    CONST TR_VALUE_DESCRIPTOR *Value;
} TR_KEY_DESCRIPTOR;


#define DHCP_OPT_TCPIP(_name) \
    "SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters\\"_name"\0"

#define DHCP_OPT_TCPIP_INTERFACE(_name) \
    "SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters\\Interfaces\\?\\"_name"\0"

#define DHCP_OPT_LEGACY_TCPIP_INTERFACE(_name) \
    "SYSTEM\\CurrentControlSet\\Services\\?\\Parameters\\Tcpip\\"_name"\0"

#define DHCP_OPT_NETBT(_name) \
    "SYSTEM\\CurrentControlSet\\Services\\NetBT\\Parameters\\"_name

#define DHCP_OPT_NETBT_INTERFACE(_name) \
    "SYSTEM\\CurrentControlSet\\Services\\NetBT\\Parameters\\Interfaces\\Tcpip_?\\"_name"\0"

#define DHCP_OPT_NETBT_ADAPTER(_name) \
    "SYSTEM\\CurrentControlSet\\Services\\NetBT\\Adapters\\?\\"_name"\0"

CONST TR_VALUE_DESCRIPTOR DhcpParameterOptions_Values [] =
{
    TRV_DW ("1",  "KeyType",      7)
    TRV_MSZ("1",  "RegLocation",  DHCP_OPT_TCPIP_INTERFACE       ("DhcpSubnetMaskOpt")
                                  DHCP_OPT_LEGACY_TCPIP_INTERFACE("DhcpSubnetMaskOpt"))
    TRV_DW ("3",  "KeyType",      7)
    TRV_MSZ("3",  "RegLocation",  DHCP_OPT_TCPIP_INTERFACE       ("DhcpDefaultGateway")
                                  DHCP_OPT_LEGACY_TCPIP_INTERFACE("DhcpDefaultGateway"))
    TRV_DW ("6",  "KeyType",      1)
    TRV_MSZ("6",  "RegLocation",  DHCP_OPT_TCPIP_INTERFACE("DhcpNameServer")
                                  DHCP_OPT_TCPIP          ("DhcpNameServer"))
    TRV_DW ("15", "KeyType",      1)
    TRV_MSZ("15", "RegLocation",  DHCP_OPT_TCPIP_INTERFACE("DhcpDomain")
                                  DHCP_OPT_TCPIP          ("DhcpDomain"))
    TRV_DW ("44", "KeyType",      1)
    TRV_MSZ("44", "RegLocation",  DHCP_OPT_NETBT_INTERFACE("DhcpNameServerList")
                                  DHCP_OPT_NETBT_ADAPTER  ("DhcpNameServer"))
    TRV_DW ("46", "KeyType",      4)
    TRV_SZ ("46", "RegLocation",  DHCP_OPT_NETBT("DhcpNodeType"))
    TRV_DW ("47", "KeyType",      1)
    TRV_SZ ("47", "RegLocation",  DHCP_OPT_NETBT("DhcpScopeID"))
    TRV_DW ("DhcpNetbiosOptions", "KeyType",      4)
    TRV_DW ("DhcpNetbiosOptions", "OptionId",     1)
    TRV_DW ("DhcpNetbiosOptions", "VendorType",   1)
    TRV_MSZ("DhcpNetbiosOptions", "RegLocation",  DHCP_OPT_NETBT_INTERFACE("DhcpNetbiosOptions"))
    TRV_END()
};
CONST TR_KEY_DESCRIPTOR DhcpParameterOptions =
{
    HKEY_LOCAL_MACHINE,
    "SYSTEM\\CurrentControlSet\\Services\\Dhcp\\Parameters\\Options",
    FALSE,
    DhcpParameterOptions_Values
};


CONST TR_VALUE_DESCRIPTOR DhcpParameter_Values [] =
{
    TRV_ESZ(NULL, "ServiceDll", "%SystemRoot%\\System32\\dhcpcsvc.dll")
    TRV_END()
};
CONST TR_KEY_DESCRIPTOR DhcpParameters =
{
    HKEY_LOCAL_MACHINE,
    "SYSTEM\\CurrentControlSet\\Services\\Dhcp\\Parameters",
    FALSE,
    DhcpParameter_Values
};


CONST TR_VALUE_DESCRIPTOR DnscacheParameter_Values [] =
{
    TRV_ESZ(NULL, "ServiceDll", "%SystemRoot%\\System32\\dnsrslvr.dll")
    TRV_DEL(NULL, "AdapterTimeoutCacheTime")
    TRV_DEL(NULL, "CacheHashTableBucketSize")
    TRV_DEL(NULL, "CacheHashTableSize")
    TRV_DEL(NULL, "DefaultRegistrationRefreshInterval")
    TRV_DEL(NULL, "MaxCacheEntryTtlLimit")
    TRV_DEL(NULL, "MaxSoaCacheEntryTtlLimit")
    TRV_DEL(NULL, "NegativeCacheTime")
    TRV_DEL(NULL, "NegativeSoaCacheTime")
    TRV_DEL(NULL, "NetFailureCacheTime")
    TRV_DEL(NULL, "NetFailureErrorPopupLimit")
    TRV_END()
};
CONST TR_KEY_DESCRIPTOR DnscacheParameters =
{
    HKEY_LOCAL_MACHINE,
    "SYSTEM\\CurrentControlSet\\Services\\Dnscache\\Parameters",
    FALSE,
    DnscacheParameter_Values
};


CONST TR_VALUE_DESCRIPTOR LmHostsParameter_Values [] =
{
    TRV_ESZ(NULL, "ServiceDll", "%SystemRoot%\\System32\\lmhsvc.dll")
    TRV_END()
};
CONST TR_KEY_DESCRIPTOR LmHostsParameters =
{
    HKEY_LOCAL_MACHINE,
    "SYSTEM\\CurrentControlSet\\Services\\LmHosts\\Parameters",
    FALSE,
    LmHostsParameter_Values
};


CONST TR_VALUE_DESCRIPTOR NetbtInterface_Values [] =
{
    TRV_DEL(NULL, "EnableAdapterDomainNameRegistration")
    TRV_MSZ(NULL, "NameServerList", "")
    TRV_DW (NULL, "NetbiosOptions", 0)
    TRV_END()
};
CONST TR_KEY_DESCRIPTOR NetbtInterfaces =
{
    HKEY_LOCAL_MACHINE,
    "SYSTEM\\CurrentControlSet\\Services\\Netbt\\Parameters\\Interfaces",
    TRUE,
    NetbtInterface_Values
};


CONST TR_VALUE_DESCRIPTOR NetbtParameter_Values [] =
{
    TRV_DEL(NULL, "BacklogIncrement")
    TRV_DW (NULL, "BcastNameQueryCount", 3)
    TRV_DW (NULL, "BcastQueryTimeout", 750)
    TRV_DEL(NULL, "BroadcastAddress")
    TRV_DEL(NULL, "CachePerAdapterEnabled")
    TRV_DW (NULL, "CacheTimeout", 600000)
    TRV_DEL(NULL, "ConnectOnRequestedInterfaceOnly")
    TRV_DEL(NULL, "EnableDns")
    TRV_DEL(NULL, "EnableLmhosts")
    TRV_DEL(NULL, "EnableProxy")
    TRV_DEL(NULL, "EnableProxyRegCheck")
    TRV_DEL(NULL, "InitialRefreshT.O.")
    TRV_DEL(NULL, "LmhostsTimeout")
    TRV_DEL(NULL, "MaxConnBackLog")
    TRV_DEL(NULL, "MaxDgramBuffering")
    TRV_DEL(NULL, "MaxPreloadEntries")
    TRV_DEL(NULL, "MinimumFreeLowerConnections")
    TRV_DEL(NULL, "MinimumRefreshSleepTime")
    TRV_DW (NULL, "NameServerPort", 137)
    TRV_DW (NULL, "NameSrvQueryCount", 3)
    TRV_DW (NULL, "NameSrvQueryTimeout", 1500)
    TRV_SZ (NULL, "NbProvider", "_tcp")
    TRV_DEL(NULL, "NodeType")
    TRV_DEL(NULL, "NoNameReleaseOnDemand")
    TRV_DEL(NULL, "RandomAdapter")
    TRV_DEL(NULL, "RefreshOpCode")
    TRV_DEL(NULL, "ScopeId")
    TRV_DW (NULL, "SessionKeepAlive", 3600000)
    TRV_DEL(NULL, "SingleResponse")
    TRV_DW (NULL, "Size/Small/Medium/Large", 1)
    TRV_DEL(NULL, "SmbDeviceEnabled")
    TRV_SZ (NULL, "TransportBindName", "\\Device\\")
    TRV_DEL(NULL, "TryAllIpAddrs")
    TRV_DEL(NULL, "TryAllNameServers")
    TRV_DEL(NULL, "UseDnsOnlyForNameResolutions")
    TRV_DEL(NULL, "WinsDownTimeout")
    TRV_END()
};
CONST TR_KEY_DESCRIPTOR NetbtParameters =
{
    HKEY_LOCAL_MACHINE,
    "SYSTEM\\CurrentControlSet\\Services\\Netbt\\Parameters",
    FALSE,
    NetbtParameter_Values
};


CONST TR_VALUE_DESCRIPTOR NlaParameter_Values [] =
{
    TRV_ESZ(NULL, "ServiceDll", "%SystemRoot%\\System32\\mswsock.dll")
    TRV_END()
};
CONST TR_KEY_DESCRIPTOR NlaParameters =
{
    HKEY_LOCAL_MACHINE,
    "SYSTEM\\CurrentControlSet\\Services\\Nla\\Parameters",
    FALSE,
    NlaParameter_Values
};

typedef enum {
    TrAddressTypeTcpipValue,
    TrDefaultGatewayMetricTcpipValue,
    TrDisableDynamicUpdateTcpipValue,
    TrDontAddDefaultGatewayTcpipValue,
    TrEnableDhcpTcpipValue,
    TrNameServerTcpipValue,
    TrRawIpAllowedProtocolsTcpipValue,
    TrTcpAllowedPortsTcpipValue,
    TrUdpAllowedPortsTcpipValue,
    TrEnableDeadGwDetectTcpipValue,
} TR_TCPIP_VALUE;

TR_CONDITIONAL_ROUTINE TrTcpipWanConditionalRoutine;
TR_CONDITIONAL_ROUTINE TrTcpipRrasConditionalRoutine;

CONST TR_VALUE_DESCRIPTOR TcpipInterface_Values [] =
{
    TRV_COND(NULL, "AddressType", 
             TrTcpipWanConditionalRoutine,
             TrAddressTypeTcpipValue)
    TRV_MSZ (NULL, "DefaultGateway", "")
    TRV_COND(NULL, "DefaultGatewayMetric",
             TrTcpipWanConditionalRoutine,
             TrDefaultGatewayMetricTcpipValue)
    TRV_COND(NULL, "DisableDynamicUpdate",
             TrTcpipWanConditionalRoutine,
             TrDisableDynamicUpdateTcpipValue)
    TRV_DEL (NULL, "DisableReverseAddressRegistrations")
    TRV_COND(NULL, "DontAddDefaultGateway",
             TrTcpipRrasConditionalRoutine,
             TrDontAddDefaultGatewayTcpipValue)
    TRV_COND(NULL, "EnableDhcp",
             TrTcpipWanConditionalRoutine,
             TrEnableDhcpTcpipValue)
    TRV_MSZ (NULL, "IpAddress", "0.0.0.0\0")
    TRV_DEL (NULL, "IpAutoconfigurationAddress")
    TRV_DEL (NULL, "IpAutoconfigurationEnabled")
    TRV_DEL (NULL, "IpAutoconfigurationMask")
    TRV_DEL (NULL, "IpAutoconfigurationSeed")
    TRV_DEL (NULL, "IpAutoconfigurationSubnet")
    TRV_DEL (NULL, "MaxForwardPending")
    TRV_DEL (NULL, "Mtu")
    TRV_COND(NULL, "NameServer",
             TrTcpipWanConditionalRoutine,
             TrNameServerTcpipValue)
    TRV_DEL (NULL, "PerformRouterDiscovery")
    TRV_DEL (NULL, "PerformRouterDiscoveryBackup")
    TRV_DEL (NULL, "PptpFiltering")
    TRV_COND(NULL, "RawIpAllowedProtocols",
             TrTcpipWanConditionalRoutine,
             TrRawIpAllowedProtocolsTcpipValue)
    TRV_DEL (NULL, "SolicitationAddressBcast")
    TRV_MSZ (NULL, "SubnetMask", "0.0.0.0\0")
    TRV_COND(NULL, "TcpAllowedPorts",
             TrTcpipWanConditionalRoutine,
             TrTcpAllowedPortsTcpipValue)
    TRV_DEL (NULL, "TcpDelAckTicks")
    TRV_DEL (NULL, "TcpInitialRtt")
    TRV_DEL (NULL, "TcpWindowSize")
    TRV_DEL (NULL, "TypeOfInterface")
    TRV_COND(NULL, "UdpAllowedPorts",
             TrTcpipWanConditionalRoutine,
             TrUdpAllowedPortsTcpipValue)
    TRV_DW  (NULL, "UseZeroBroadcast", 0)
    TRV_END ()
};

CONST TR_KEY_DESCRIPTOR TcpipInterfaces =
{
    HKEY_LOCAL_MACHINE,
    "SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters\\Interfaces",
    TRUE,
    TcpipInterface_Values
};

CONST TR_VALUE_DESCRIPTOR TcpipParameter_Values [] =
{
    TRV_DEL (NULL, "AllowUnqualifiedQuery")
    TRV_DEL (NULL, "AllowUserRawAccess")
    TRV_DEL (NULL, "ArpAlwaysSourceRoute")
    TRV_DEL (NULL, "ArpCacheLife")
    TRV_DEL (NULL, "ArpCacheMinReferencedLife")
    TRV_DEL (NULL, "ArpRetryCount")
    TRV_DEL (NULL, "ArpTrSingleRoute")
    TRV_DEL (NULL, "ArpUseEtherSnap")
    TRV_ESZ (NULL, "DatabasePath", "%SystemRoot%\\System32\\drivers\\etc")
    TRV_DEL (NULL, "DefaultRegistrationTtl")
    TRV_DEL (NULL, "DefaultTosValue")
    TRV_DEL (NULL, "DefaultTtl")
    TRV_DEL (NULL, "DisableDhcpMediaSense")
    TRV_DEL (NULL, "DisableDynamicUpdate")
    TRV_DEL (NULL, "DisableIpSourceRouting")
    TRV_DEL (NULL, "DisableMediaSenseEventLog")
    TRV_DEL (NULL, "DisableReplaceAddressesInConflicts")
    TRV_DEL (NULL, "DisableTaskOffload")
    TRV_DEL (NULL, "DisableUserTosSetting")
    TRV_DEL (NULL, "DisjointNameSpace")
    TRV_DEL (NULL, "DontAddDefaultGatewayDefault")
    TRV_DEL (NULL, "DnsQueryTimeouts")
    TRV_DEL (NULL, "EnableAddrMaskReply")
    TRV_DEL (NULL, "EnableBcastArpReply")
    TRV_COND(NULL, "EnableDeadGwDetect",
             TrTcpipRrasConditionalRoutine,
             TrEnableDeadGwDetectTcpipValue)
    TRV_DEL (NULL, "EnableFastRouteLookup")
    TRV_DEL (NULL, "EnableIcmpRedirect")
    TRV_DEL (NULL, "EnableMulticastForwarding")
    TRV_DEL (NULL, "EnablePmtuBhDetect")
    TRV_DEL (NULL, "EnablePmtuDiscovery")
    TRV_DEL (NULL, "EnableSecurityFilters")
    TRV_DEL (NULL, "FfpControlFlags")
    TRV_DEL (NULL, "FfpFastForwardingCacheSize")
    TRV_DW  (NULL, "ForwardBroadcasts", 0)
    TRV_DEL (NULL, "ForwardBufferMemory")
    TRV_DEL (NULL, "GlobalMaxTcpWindowSize")
    TRV_DEL (NULL, "IgmpLevel")
    TRV_DEL (NULL, "IpAutoconfigurationEnabled")
    TRV_DEL (NULL, "IpAutoconfigurationMask")
    TRV_DEL (NULL, "IpAutoconfigurationSeed")
    TRV_DW  (NULL, "IpEnableRouter", 0)
    TRV_DEL (NULL, "IpEnableRouterBackup")
    TRV_DEL (NULL, "KeepAliveInterval")
    TRV_DEL (NULL, "KeepAliveTime")
    TRV_SZ  (NULL, "NameServer", "")
    TRV_DEL (NULL, "MaxForwardBufferMemory")
    TRV_DEL (NULL, "MaxFreeTWTcbs")
    TRV_DEL (NULL, "MaxFreeTcbs")
    TRV_DEL (NULL, "MaxHashTableSize")
    TRV_DEL (NULL, "MaxNormLookupMemory")
    TRV_DEL (NULL, "MaxNumForwardPackets")
    TRV_DEL (NULL, "MaxUserPort")
    TRV_DEL (NULL, "NumForwardPackets")
    TRV_DEL (NULL, "NumTcbTablePartitions")
    TRV_DEL (NULL, "PptpTcpMaxDataRetransmissions")
    TRV_DEL (NULL, "PrioritizeRecordData")
    TRV_DEL (NULL, "QueryIpMatching")
    TRV_DEL (NULL, "SackOpts")
    TRV_DEL (NULL, "SearchList")
    TRV_DEL (NULL, "SynAttackProtect")
    TRV_DEL (NULL, "Tcp1323Opts")
    TRV_DEL (NULL, "TcpMaxConnectResponseRetransmissions")
    TRV_DEL (NULL, "TcpMaxConnectRetransmissions")
    TRV_DEL (NULL, "TcpMaxDataRetransmissions")
    TRV_DEL (NULL, "TcpMaxDupAcks")
    TRV_DEL (NULL, "TcpMaxHalfOpen")
    TRV_DEL (NULL, "TcpMaxHalfOpenRetried")
    TRV_DEL (NULL, "TcpMaxPortsExhausted")
    TRV_DEL (NULL, "TcpMaxSendFree")
    TRV_DEL (NULL, "TcpNumConnections")
    TRV_DEL (NULL, "TcpTimedWaitDelay")
    TRV_DEL (NULL, "TcpUseRfc1122UrgentPointer")
    TRV_DEL (NULL, "TcpWindowSize")
    TRV_DEL (NULL, "TrFunctionalMcastAddress")
    TRV_DEL (NULL, "UpdateSecurityLevel")
    TRV_DEL (NULL, "UseDomainNameDevolution")
    TRV_DW  ("Winsock", "UseDelayedAcceptance", 0)
    TRV_END ()
};
CONST TR_KEY_DESCRIPTOR TcpipParameters =
{
    HKEY_LOCAL_MACHINE,
    "SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters",
    FALSE,
    TcpipParameter_Values
};


CONST TR_VALUE_DESCRIPTOR TcpipPerformance_Values [] =
{
    TRV_SZ (NULL, "Close", "CloseTcpIpPerformanceData")
    TRV_SZ (NULL, "Collect", "CollectTcpIpPerformanceData")
    TRV_SZ (NULL, "Library", "Perfctrs.dll")
    TRV_SZ (NULL, "Open", "OpenTcpIpPerformanceData")
    TRV_SZ (NULL, "Object List", "502 510 546 582 638 658")
    TRV_END()
};
CONST TR_KEY_DESCRIPTOR TcpipPerformance =
{
    HKEY_LOCAL_MACHINE,
    "SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Performance",
    FALSE,
    TcpipPerformance_Values
};


CONST TR_VALUE_DESCRIPTOR TcpipServiceProvider_Values [] =
{
    TRV_DW (NULL, "Class", 8)
    TRV_DW (NULL, "DnsPriority", 2000)
    TRV_DW (NULL, "HostsPriority", 500)
    TRV_DW (NULL, "LocalPriority", 499)
    TRV_DW (NULL, "NetbtPriority", 2001)
    TRV_SZ (NULL, "Name", "TCP/IP")
    TRV_ESZ(NULL, "ProviderPath", "%SystemRoot%\\System32\\wsock32.dll")
    TRV_END()
};
CONST TR_KEY_DESCRIPTOR TcpipServiceProvider =
{
    HKEY_LOCAL_MACHINE,
    "SYSTEM\\CurrentControlSet\\Services\\Tcpip\\ServiceProvider",
    FALSE,
    TcpipServiceProvider_Values
};


CONST TR_KEY_DESCRIPTOR* TrRepairSet [] =
{
    &DhcpParameterOptions,
    &DhcpParameters,
    &DnscacheParameters,
    &LmHostsParameters,
    &NetbtInterfaces,
    &NetbtParameters,
    &NlaParameters,
    &TcpipInterfaces,
    &TcpipParameters,
    &TcpipPerformance,
    &TcpipServiceProvider,
    NULL
};


#define SAM_DESIRED KEY_READ | KEY_WRITE | DELETE


typedef enum _TR_LOG_ACTION {
    TR_ADDED,
    TR_DELETED,
    TR_RESET,
} TR_LOG_ACTION;

CONST PCSTR LogActionPrefix [] = {
    "added  ",
    "deleted",
    "reset  ",
};

typedef struct _TR_REPAIR_CONTEXT {
    HANDLE Heap;
    FILE *LogFile;
    PBYTE RegData;
    ULONG RegDataSize;
    CHAR EnumKeyName [MAX_PATH];
} TR_REPAIR_CONTEXT, *PTR_REPAIR_CTX;


BOOL
TrInitializeRepairContext(
    IN PTR_REPAIR_CTX Ctx,
    IN FILE *LogFile
    )
{
    ZeroMemory(Ctx, sizeof(TR_REPAIR_CONTEXT));
    Ctx->Heap = GetProcessHeap();
    Ctx->LogFile = LogFile;

    Ctx->RegDataSize = 1024;
    Ctx->RegData = HeapAlloc(Ctx->Heap, 0, Ctx->RegDataSize);

    *Ctx->EnumKeyName = 0;

    return (Ctx->RegData != NULL);
}

VOID
TrCleanupRepairContext(
    IN PTR_REPAIR_CTX Ctx
    )
{
    if (Ctx->RegData != NULL) {
        HeapFree(Ctx->Heap, 0, Ctx->RegData);
        Ctx->RegData = NULL;
    }
}

VOID
TrLogAction(
    IN TR_LOG_ACTION Action,
    IN PTR_REPAIR_CTX Ctx,
    IN CONST TR_KEY_DESCRIPTOR *Kd,
    IN CONST TR_VALUE_DESCRIPTOR *Vd,
    IN DWORD RegType
    )
{
    fprintf(Ctx->LogFile, "%s %s\\",
            LogActionPrefix[Action], Kd->ParentKeyName);

    if (Vd->SubKeyName != NULL) {
        fprintf(Ctx->LogFile, "%s\\", Vd->SubKeyName);
    }

    if (Kd->EnumKey) {
        fprintf(Ctx->LogFile, "%s\\", Ctx->EnumKeyName);
    }

    fprintf(Ctx->LogFile, "%s\n", Vd->ValueName);

    //
    // Show the value we are replacing.
    //
    if (TR_RESET == Action) {
        switch (RegType) {
        case REG_DWORD:
            fprintf(Ctx->LogFile, "            old REG_DWORD = %d\n\n", *(PULONG)Ctx->RegData);
            break;

        case REG_EXPAND_SZ:
            fprintf(Ctx->LogFile, "            old REG_EXPAND_SZ = %s\n\n", (PCSTR)Ctx->RegData);
            break;

        case REG_MULTI_SZ:
        {
            PCSTR Msz = (PCSTR)Ctx->RegData;

            fprintf(Ctx->LogFile, "            old REG_MULTI_SZ =\n");
            if (*Msz) {
                while (*Msz) {
                    fprintf(Ctx->LogFile, "                %s\n", Msz);
                    Msz += strlen(Msz) + 1;
                }
            } else {
                fprintf(Ctx->LogFile, "                <empty>\n");
            }
            fprintf(Ctx->LogFile, "\n");
            break;
        }

        case REG_SZ:
            fprintf(Ctx->LogFile, "            old REG_SZ = %s\n\n", (PCSTR)Ctx->RegData);
            break;

        default:
            break;
        }
    }
}

LONG
TrReadRegData(
    IN PTR_REPAIR_CTX Ctx,
    IN HKEY Key,
    IN CONST TR_VALUE_DESCRIPTOR *Vd,
    OUT PULONG ReturnedSize
    )
{
    LONG Error;
    ULONG Type, Size;

    *ReturnedSize = 0;

    Size = Ctx->RegDataSize;
    Error = RegQueryValueExA(Key, Vd->ValueName, NULL, &Type,
                             Ctx->RegData, &Size);

    if (ERROR_MORE_DATA == Error) {
        HeapFree(Ctx->Heap, 0, Ctx->RegData);
        Ctx->RegDataSize = (Size + 63) & ~63;
        Ctx->RegData = HeapAlloc(Ctx->Heap, 0, Ctx->RegDataSize);

        if (Ctx->RegData != NULL) {
            Size = Ctx->RegDataSize;
            Error = RegQueryValueExA(Key, Vd->ValueName, NULL, &Type,
                                     Ctx->RegData, &Size);
            if (NOERROR != Error) {
                fprintf(Ctx->LogFile,
                        "   RegQueryValueEx still failed. error = %d\n",
                        Error);
            } else {
                *ReturnedSize = Size;
            }
        } else {
            Error = ERROR_NOT_ENOUGH_MEMORY;
        }
    } else if (NOERROR == Error) {
        *ReturnedSize = Size;
    }

    return Error;
}

VOID
TrSetRegData(
    IN HKEY Key,
    IN CONST TR_VALUE_DESCRIPTOR *Vd,
    IN DWORD RegType,
    IN TR_VALUE_DATA* Data,
    IN DWORD DataSize
    )
{
    RegSetValueExA(Key, Vd->ValueName, 0, RegType,
                   (REG_DWORD == RegType) ? (CONST BYTE*)&Data->Value
                                          : Data->Pointer,
                   DataSize);
}

VOID
TrProcessOpenKey(
    IN PTR_REPAIR_CTX Ctx,
    IN HKEY ParentKey,
    IN CONST TR_KEY_DESCRIPTOR *Kd
    )
{
    LONG Error = NOERROR;
    ULONG i, Size;
    CONST TR_VALUE_DESCRIPTOR *Vd, *PrevVd;
    HKEY SubKey, UseKey;
    DWORD RegType;
    TR_VALUE_DATA Data;
    DWORD DataSize;

    PrevVd = NULL;
    SubKey = INVALID_HANDLE_VALUE;

    for (i = 0; Kd->Value[i].ValueName != NULL; i++) {
        Vd = &Kd->Value[i];

        if (Vd->SubKeyName == NULL) {
            UseKey = ParentKey;
            Error = NOERROR;
        }

        //
        // Open a subkey if needed, and only if its not the same as
        // the one already open.
        //
        else if (((PrevVd == NULL) || (Vd->SubKeyName != PrevVd->SubKeyName))) {

            if (SubKey != INVALID_HANDLE_VALUE) {
                RegCloseKey(SubKey);
            }

            Error = RegOpenKeyExA(ParentKey, Vd->SubKeyName, 0,
                                 SAM_DESIRED, &SubKey);
            if (NOERROR == Error) {
                UseKey = SubKey;
            } else {
                SubKey = INVALID_HANDLE_VALUE;
            }
        }

        if (NOERROR == Error) {
            Error = TrReadRegData(Ctx, UseKey, Vd, &Size);
        }

        //
        // If the key is handled specially, consult its conditional-routine
        // to obtain the settings to be used below. From here onwards,
        // all processing for this value must use the local variables
        // 'RegType', 'Data', and 'DataSize' rather than the corresponding
        // fields of 'Vd'.
        //
        // (Also see 'TrSetRegData' and 'TrLogAction'.)
        //
        if (Vd->Conditional) {
            Vd->ConditionalRoutine(Ctx, Kd, Vd, &RegType, &Data, &DataSize);
        } else {
            RegType = Vd->RegType;
            Data = Vd->Data;
            DataSize = Vd->DataSize;
        }

        if (ERROR_FILE_NOT_FOUND == Error) {

            if (REG_DELETE != RegType) {
                //
                // The value should exist, so set its default value.
                //
                TrSetRegData(UseKey, Vd, RegType, &Data, DataSize);
                TrLogAction(TR_ADDED, Ctx, Kd, Vd, RegType);
            }

        } else if (NOERROR == Error) {
            //
            // The value exists and we read its data.
            //
            if (REG_DELETE == RegType) {
                //
                // Need to delete the existing value.
                //
                RegDeleteValueA(UseKey, Vd->ValueName);
                TrLogAction(TR_DELETED, Ctx, Kd, Vd, RegType);
            } else {
                BOOL MisCompare = TRUE;
                //
                // Compare the value we read with the default value and reset
                // it if it is different.
                //
                if (Size == DataSize) {
                    if (REG_DWORD == RegType) {
                        MisCompare = (*(PULONG)Ctx->RegData != Data.Value);
                    } else {
                        MisCompare = memcmp(Ctx->RegData, Data.Pointer,
                                            Size);
                    }
                }
                if (MisCompare) {
                    TrSetRegData(UseKey, Vd, RegType, &Data, DataSize);
                    TrLogAction(TR_RESET, Ctx, Kd, Vd, RegType);
                }
            }

        } else {
            fprintf(Ctx->LogFile, "\nerror reading registry value (%s) (%d)\n", Vd->ValueName, Error);
        }

        PrevVd = Vd;
    }

    if (SubKey != INVALID_HANDLE_VALUE) {
        RegCloseKey(SubKey);
    }
}

VOID
TrProcessKey(
    IN PTR_REPAIR_CTX Ctx,
    IN CONST TR_KEY_DESCRIPTOR *Kd
    )
{
    LONG Error;
    HKEY ParentKey;

    Error = RegOpenKeyExA(Kd->RootKey, Kd->ParentKeyName, 0,
                          SAM_DESIRED, &ParentKey);
    if (NOERROR == Error) {

        if (Kd->EnumKey) {
            ULONG i;
            ULONG EnumKeyNameLen;
            FILETIME LastWriteTime;
            HKEY SubKey;

            for (i = 0; NOERROR == Error; i++) {
                EnumKeyNameLen = sizeof(Ctx->EnumKeyName);
                Error = RegEnumKeyExA(ParentKey, i, Ctx->EnumKeyName, &EnumKeyNameLen,
                                      NULL, NULL, NULL, &LastWriteTime);
                if (NOERROR != Error) {
                    if (ERROR_NO_MORE_ITEMS != Error) {
                        fprintf(Ctx->LogFile, "enum error = %d  (index = %d)\n",
                                Error, i);
                    }
                    break;
                }

                Error = RegOpenKeyExA(ParentKey, Ctx->EnumKeyName, 0,
                                      SAM_DESIRED, &SubKey);
                if (NOERROR == Error) {
                    TrProcessOpenKey(Ctx, SubKey, Kd);

                    RegCloseKey(SubKey);
                }
            }
        } else {
            TrProcessOpenKey(Ctx, ParentKey, Kd);
        }

        RegCloseKey(ParentKey);
    }
}


VOID
TrProcessSet(
    IN PTR_REPAIR_CTX Ctx,
    IN CONST TR_KEY_DESCRIPTOR *Set[]
    )
{
    ULONG i;

    //
    // Process each TR_KEY_DESCRIPTOR element in the set.
    //
    for (i = 0; Set[i] != NULL; i++) {
        TrProcessKey(Ctx, Set[i]);
    }
}


DWORD
TrRepair(
    FILE* LogFile
    )
{
    TR_REPAIR_CONTEXT Ctx;

    if (TrInitializeRepairContext(&Ctx, LogFile)) {

        TrProcessSet(&Ctx, TrRepairSet);

        NetCfgDiagRepairRegistryBindings(LogFile);

        TrCleanupRepairContext(&Ctx);
    }

    return NOERROR;
}

BOOLEAN
IsRrasInstalled(
    IN CONST struct _TR_REPAIR_CONTEXT *Ctx,
    IN CONST struct _TR_KEY_DESCRIPTOR *Kd
    )
{
    ULONG Error;
    BOOLEAN RrasInstalled;
    HKEY RrasKey;
    CONST CHAR RrasKeyName[] =
        "SYSTEM\\CurrentControlSet\\Services\\RemoteAccess";

    Error = RegOpenKeyExA(Kd->RootKey, RrasKeyName, 0, SAM_DESIRED, &RrasKey);

    if (NOERROR != Error) {
        RrasInstalled = FALSE;
    } else {
        DWORD ConfigurationFlags;
        DWORD Size;
        DWORD Type;
        Size = sizeof(DWORD);
        Error = RegQueryValueExA(RrasKey, "ConfigurationFlags", NULL, &Type,
                                 (LPBYTE)&ConfigurationFlags, &Size);
        if (NOERROR != Error) {
            RrasInstalled = FALSE;
        } else {
            RrasInstalled = (ConfigurationFlags != 0);
        }
        RegCloseKey(RrasKey);
    }

    return RrasInstalled;
}

BOOLEAN
IsWanInterface(
    IN CONST struct _TR_REPAIR_CONTEXT *Ctx,
    IN CONST struct _TR_KEY_DESCRIPTOR *Kd
    )
{
    HKEY AdaptersKey;
    CONST CHAR AdaptersKeyName[] =
        "SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters\\Adapters";
    LONG Error;
    BOOLEAN IsWan;
    HKEY Key;

    //
    // Open the TCP/IP adapters key.
    // If successful, look for a subkey with the same name
    // as the one in 'Kd'. If present, this is not a LAN interface.
    //
    Error = RegOpenKeyExA(Kd->RootKey, AdaptersKeyName, 0, SAM_DESIRED,
                          &AdaptersKey);
    if (NOERROR != Error) {
        //
        // Assume this is a LAN interface.
        //
        IsWan = FALSE;
    } else {
        Error = RegOpenKeyExA(AdaptersKey, Ctx->EnumKeyName, 0, SAM_DESIRED,
                              &Key);
        if (NOERROR != Error) {
            IsWan = TRUE;
        } else {
            IsWan = FALSE;
            RegCloseKey(Key);
        }
        RegCloseKey(AdaptersKey);
    }

    return IsWan;
}

VOID
TrTcpipWanConditionalRoutine(
    IN CONST struct _TR_REPAIR_CONTEXT *Ctx,
    IN CONST struct _TR_KEY_DESCRIPTOR *Kd,
    IN CONST struct _TR_VALUE_DESCRIPTOR *Vd,
    OUT DWORD *RegType,
    OUT TR_VALUE_DATA *Data,
    OUT DWORD *DataSize
    )
{
    //
    // Return the appropriate setting for the given registry value,
    // based on whether its key is for a WAN or LAN interface.
    //
    if (IsWanInterface(Ctx, Kd)) {
        switch((TR_TCPIP_VALUE)Vd->ConditionalData.Value) {

        case TrAddressTypeTcpipValue:
        case TrDefaultGatewayMetricTcpipValue:
        case TrDisableDynamicUpdateTcpipValue:
        case TrNameServerTcpipValue:
        case TrRawIpAllowedProtocolsTcpipValue:
        case TrTcpAllowedPortsTcpipValue:
        case TrUdpAllowedPortsTcpipValue:
        default:
            *RegType = REG_DELETE;
            break;

        case TrEnableDhcpTcpipValue:
        case TrDontAddDefaultGatewayTcpipValue:
            *RegType = REG_DWORD;
            Data->Value = 0;
            *DataSize = sizeof(DWORD);
            break;
        }
    } else {
        switch((TR_TCPIP_VALUE)Vd->ConditionalData.Value) {

        case TrDontAddDefaultGatewayTcpipValue:
        default:
            *RegType = REG_DELETE;
            break;

        case TrAddressTypeTcpipValue:
        case TrDisableDynamicUpdateTcpipValue:
            *RegType = REG_DWORD;
            Data->Value = 0;
            *DataSize = sizeof(DWORD);
            break;

        case TrEnableDhcpTcpipValue:
            *RegType = REG_DWORD;
            Data->Value = 1;
            *DataSize = sizeof(DWORD);
            break;

        case TrNameServerTcpipValue:
            *RegType = REG_SZ;
            Data->Pointer = Empty;
            *DataSize = sizeof(Empty);
            break;

        case TrDefaultGatewayMetricTcpipValue:
        case TrRawIpAllowedProtocolsTcpipValue:
        case TrTcpAllowedPortsTcpipValue:
        case TrUdpAllowedPortsTcpipValue:
            *RegType = REG_MULTI_SZ;
            Data->Pointer = Empty;
            *DataSize = sizeof(Empty);
            break;
        }
    }
}

VOID
TrTcpipRrasConditionalRoutine(
    IN CONST struct _TR_REPAIR_CONTEXT *Ctx,
    IN CONST struct _TR_KEY_DESCRIPTOR *Kd,
    IN CONST struct _TR_VALUE_DESCRIPTOR *Vd,
    OUT DWORD *RegType,
    OUT TR_VALUE_DATA *Data,
    OUT DWORD *DataSize
    )
{
    //
    // Return the appropriate setting for the given registry value,
    // based on whether RRAS is installed.
    //
    // N.B. The setting for 'DontAddDefaultGateway' is further dependent
    // on whether the key is for a WAN or LAN interface.
    //
    if (IsRrasInstalled(Ctx, Kd)) {
        switch((TR_TCPIP_VALUE)Vd->ConditionalData.Value) {
        case TrDontAddDefaultGatewayTcpipValue:
            if (IsWanInterface(Ctx, Kd)) {
                *RegType = REG_DWORD;
                Data->Value = 1;
                *DataSize = sizeof(DWORD);
            } else {
                *RegType = REG_DELETE;
            }
            break;
        case TrEnableDeadGwDetectTcpipValue:
            *RegType = REG_DWORD;
            Data->Value = 0;
            *DataSize = sizeof(DWORD);
            break;
        default:
            *RegType = REG_DELETE;
            break;
        }
    } else {
        switch((TR_TCPIP_VALUE)Vd->ConditionalData.Value) {
        case TrDontAddDefaultGatewayTcpipValue:
        case TrEnableDeadGwDetectTcpipValue:
        default:
            *RegType = REG_DELETE;
            break;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\if\ifstring.h ===
#define MSG_HELP_START                         _T("%1!-14s! - ")

    //
    // Tokens for commands
    // These must be in lower case
    //

#define CMD_GROUP_ADD                           L"add"
#define CMD_GROUP_DELETE                        L"delete"
#define CMD_GROUP_SHOW                          L"show"
#define CMD_GROUP_SET                           L"set"
#define CMD_GROUP_RESET                         L"reset"

#define CMD_DUMP                                L"dump"
#define CMD_HELP1                               L"help"
#define CMD_HELP2                               L"?"
#define CMD_IF_DUMP                             CMD_DUMP
#define CMD_IF_HELP1                            CMD_HELP1
#define CMD_IF_HELP2                            CMD_HELP2

#define CMD_IF_ADD_IF                           L"interface"
#define CMD_IF_DEL_IF                           L"interface"
#define CMD_IF_SHOW_IF                          L"interface"

#define CMD_IF_SET_CREDENTIALS                  L"credentials"
#define CMD_IF_SHOW_CREDENTIALS                 L"credentials"

#define CMD_IF_SET_INTERFACE                    L"interface"

#define CMD_IF_RESET_ALL                        L"all"


    // IF_IP commands
#define CMD_IFIP_SHOW_CONFIG                    L"config"

#define CMD_IFIP_ADD_IPADDR                     L"address"
#define CMD_IFIP_SET_IPADDR                     L"address"
#define CMD_IFIP_DEL_IPADDR                     L"address"
#define CMD_IFIP_SHOW_IPADDR                    L"address"

#define CMD_IFIP_ADD_DNS                        L"dns"
#define CMD_IFIP_SET_DNS                        L"dns"
#define CMD_IFIP_DEL_DNS                        L"dns"
#define CMD_IFIP_SHOW_DNS                       L"dns"

#define CMD_IFIP_ADD_WINS                       L"wins"
#define CMD_IFIP_SET_WINS                       L"wins"
#define CMD_IFIP_DEL_WINS                       L"wins"
#define CMD_IFIP_SHOW_WINS                      L"wins"

#define CMD_IFIP_SHOW_OFFLOAD                   L"offload"

#define CMD_IPMIB_SHOW_INTERFACE                L"interface"
#define CMD_IPMIB_SHOW_IPSTATS                  L"ipstats"
#define CMD_IPMIB_SHOW_IPADDRESS                L"ipaddress"
#define CMD_IPMIB_SHOW_IPNET                    L"ipnet"
#define CMD_IPMIB_SHOW_ICMP                     L"icmp"
#define CMD_IPMIB_SHOW_TCPSTATS                 L"tcpstats"
#define CMD_IPMIB_SHOW_TCPCONN                  L"tcpconn"
#define CMD_IPMIB_SHOW_UDPSTATS                 L"udpstats"
#define CMD_IPMIB_SHOW_UDPCONN                  L"udpconn"
#define CMD_IPMIB_SHOW_JOINS                    L"joins"

#define CMD_IFIP_DEL_ARPCACHE                   L"arpcache"

#define CMD_IFIP_RESET                          L"reset"

    //
    // TOKEN_Xxx are tokens for arguments
    // These must be in lower case
    //

#define TOKEN_NAME                             _T("name")
#define TOKEN_TYPE                             _T("type")
#define TOKEN_FULL                             _T("full")
#define TOKEN_USER                             _T("user")
#define TOKEN_DOMAIN                           _T("domain")
#define TOKEN_PASSWORD                         _T("password")
#define TOKEN_ADMIN                            _T("admin")
#define TOKEN_CONNECT                          _T("connect")
#define TOKEN_NEWNAME                          _T("newname")


    // tokens for interface/ip

#define TOKEN_SOURCE                            _T("source")
#define TOKEN_ADDR                              _T("addr")
#define TOKEN_MASK                              _T("mask")
#define TOKEN_GATEWAY                           _T("gateway")
#define TOKEN_GWMETRIC                          _T("gwmetric")
#define TOKEN_INDEX                             _T("index")
#define TOKEN_REGISTER                          _T("register")

#define TOKEN_MIB_OBJECT_INTERFACE              L"interface"
#define TOKEN_MIB_OBJECT_IPSTATS                L"ipstats"
#define TOKEN_MIB_OBJECT_IPADDRESS              L"ipaddress"
#define TOKEN_MIB_OBJECT_IPNET                  L"ipnet"
#define TOKEN_MIB_OBJECT_ICMP                   L"icmp"
#define TOKEN_MIB_OBJECT_TCPSTATS               L"tcpstats"
#define TOKEN_MIB_OBJECT_TCPCONN                L"tcpconn"
#define TOKEN_MIB_OBJECT_UDPSTATS               L"udpstats"
#define TOKEN_MIB_OBJECT_UDPCONN                L"udpconn"
#define TOKEN_MIB_OBJECT_JOINS                  L"joins"

    //
    // TOKEN_VALUE_Xxx are tokens for possible values than an argument
    // can take
    // These must be in upper case
    //

#define TOKEN_VALUE_ENABLED                    _T("ENABLED")
#define TOKEN_VALUE_DISABLED                   _T("DISABLED")
#define TOKEN_VALUE_CONNECTED                  _T("CONNECTED")
#define TOKEN_VALUE_DISCONNECTED               _T("DISCONNECTED")


// token values for ifIp

#define TOKEN_VALUE_DHCP                        _T("DHCP")
#define TOKEN_VALUE_STATIC                      _T("STATIC")
#define TOKEN_VALUE_NONE                        _T("NONE")
#define TOKEN_VALUE_ALL                         _T("ALL")
#define TOKEN_VALUE_PRIMARY                     _T("PRIMARY")
#define TOKEN_VALUE_BOTH                        _T("BOTH")


//
// Messages used to dump config - these closely follow the
// set/add help messages
//

#define DMP_IF_NEWLINE              L"\n"
#define DMP_IF_ADD_IF               L"\nadd interface name=%1!s! type=%2!s!"
#define DMP_IF_SET_IF               L"\nset interface name=%1!s! admin=%2!s!"
#define DMP_IF_SET_CRED_IF          L"\nset credentials name=%1!s! user=%2!s! domain=%3!s!"
#define DMP_IF_SET_CRED_IF_NOD      L"\nset credentials name=%1!s! user=%2!s!"
#define DMP_IF_HEADER               L"pushd interface\n\nreset all\n"
#define DMP_IF_FOOTER               L"\n\npopd\n"
#define DMP_IF_NOT_SUPPORTED        L"# Not yet supported"
#define DMP_IF_IPTUNNEL_CONFIG      L" srcaddr=%1!s! destaddr=%2!s! ttl=%3!d!"

#define DMP_IFIP_PUSHD              L"pushd interface ip\n"
#define DMP_IFIP_POPD               L"\n\n\npopd\n"
#define DMP_DHCP                    L"\nset address name=%1!s! source=dhcp "
#define DMP_STATIC                  L"\nset address name=%1!s! source=static "
#define DMP_IPADDR1                 L"addr=%1!s! mask=%2!s!"
#define DMP_IPADDR2                 L"\nadd address name=%1!s! addr=%2!s! mask=%3!s!"
#define DMP_GATEWAY1                L"\nset address name=%1!s! gateway=none"
#define DMP_GATEWAY2                L"\nset address name=%1!s! gateway=%2!s! gwmetric=%3!s!"
#define DMP_GATEWAY3                L"\nadd address name=%1!s! gateway=%2!s! gwmetric=%3!s!"
#define DMP_DNS_DHCP                L"\nset dns name=%1!s! source=dhcp"
#define DMP_DNS_STATIC_NONE         L"\nset dns name=%1!s! source=static addr=none"
#define DMP_DNS_STATIC_ADDR1        L"\nset dns name=%1!s! source=static addr=%2!s!"
#define DMP_DNS_STATIC_ADDR2        L"\nadd dns name=%1!s! addr=%2!s!"
#define DMP_WINS_DHCP               L"\nset wins name=%1!s! source=dhcp"
#define DMP_WINS_STATIC_NONE        L"\nset wins name=%1!s! source=static addr=none"
#define DMP_WINS_STATIC_ADDR1       L"\nset wins name=%1!s! source=static addr=%2!s!"
#define DMP_WINS_STATIC_ADDR2       L"\nadd wins name=%1!s! addr=%2!s!"

#define DMP_STRING_ARG              L" %1!s!=%2!s!"
#define DMP_INTEGER_ARG             L" %1!s!=%2!d!"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\if\precomp.h ===
#define MAX_DLL_NAME    48

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <memory.h>
#include <malloc.h>
#include <tchar.h>
#include <winsock2.h>

#include <netcfgx.h>
#include <netcfgn.h>
#include <netcfgp.h>

#define COBJMACROS
#include <netcon.h>
#include <netconp.h>
#include <setupapi.h>
#include <devguid.h>


#include <rpc.h>
#include <rtutils.h>
#include <mprerror.h>
#include <ras.h>
#include <raserror.h>
#include <mprapi.h>
#include <nhapi.h>

#include <netsh.h>
#include <netshp.h>

// These 5 includes required by IP Tunnels
// The requirement for so many files should hopefully go away soon
#include <fltdefs.h>  // reqd by iprtinfo.h below
#include <iprtinfo.h> // required for IPINIP_CONFIG_INFO
#include <ipmontr.h>  // reqd for ADDR_LENGTH, IP_TO_WSTR
#include <ipinfoid.h> // reqd for IP_IPINIP_CFG_INFO
#include <rtinfo.h>   // reqd for RTR_INFO_BLOCK_HEADER

#include "strdefs.h"
#include "ifstring.h"
#include "defs.h"
#include "ifmon.h"
#include "routerdb.h"
#include "routerif.h"
#include "ifhandle.h"
#include "utils.h"

// required for ifip
#include "context.h"
#include <ipexport.h>
#include <ipinfo.h>
#include <iprtrmib.h>
#include <ntddip.h>
#include <iphlpstk.h>
#include "showmib.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\if\routerdb.c ===
/*
    File    routerdb.c

    Implements a database abstraction for accessing router interfaces.

    If any caching/transactioning/commit-noncommit-moding is done, it
    should be implemented here with the api's remaining constant.

*/

#include "precomp.h"

EXTERN_C
HRESULT APIENTRY HrRenameConnection(const GUID* guidId, PCWSTR pszNewName);

typedef
DWORD 
(WINAPI *PRasValidateEntryName)(
    LPWSTR lpszPhonebook,   // pointer to full path and filename of phone-book file
    LPWSTR lpszEntry    // pointer to the entry name to validate
    );

typedef struct _RTR_IF_LIST
{
    WCHAR pszName[MAX_INTERFACE_NAME_LEN + 1];
    struct _RTR_IF_LIST* pNext;
    
} RTR_IF_LIST;

//
// Callback for RtrdbInterfaceEnumerate that adds the interface
// to a list if the interface is type wan.
//
DWORD 
RtrdbAddWanIfToList(
    IN  PWCHAR  pwszIfName,
    IN  DWORD   dwLevel,
    IN  DWORD   dwFormat,
    IN  PVOID   pvData,
    IN  HANDLE  hData)
{
    MPR_INTERFACE_0* pIf0 = (MPR_INTERFACE_0*)pvData;
    RTR_IF_LIST** ppList = (RTR_IF_LIST**)hData;
    RTR_IF_LIST* pNode = NULL;
    DWORD dwErr = NO_ERROR, dwSize;

    do
    {
        // See if the interface type is right
        //
        if (pIf0->dwIfType == ROUTER_IF_TYPE_FULL_ROUTER)
        {
            // Initialize a new node for the list
            //
            pNode = (RTR_IF_LIST*) 
                IfutlAlloc(sizeof(RTR_IF_LIST), TRUE);
            if (pNode == NULL)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            dwSize = sizeof(pNode->pszName);
            dwErr = GetIfNameFromFriendlyName(
                        pwszIfName,
                        pNode->pszName,
                        &dwSize);
            BREAK_ON_DWERR(dwErr);

            // Add the interface to the list
            //
            pNode->pNext = *ppList;
            *ppList = pNode;
        }

    } while (FALSE);

    // Cleanup
    {
        if (dwErr != NO_ERROR)
        {
            IfutlFree(pNode);
        }
    }

    return dwErr;
}

DWORD
RtrdbValidatePhoneBookEntry(
    PWSTR  pwszInterfaceName
    )
{
    HMODULE                     hRasApi32;
    PRasValidateEntryName       pfnRasValidateEntryName;
    DWORD                       dwErr;
    WCHAR                       rgwcPath[MAX_PATH+1];


    //
    // get phone book path + file name
    //

    if(g_pwszRouter is NULL)
    {
        dwErr =
            ExpandEnvironmentStringsW(LOCAL_ROUTER_PB_PATHW,
                                      rgwcPath,
                                      sizeof(rgwcPath)/sizeof(rgwcPath[0]));
    }
    else
    {
        dwErr = wsprintfW(rgwcPath,
                          REMOTE_ROUTER_PB_PATHW,
                          g_pwszRouter);
    }

    ASSERT(dwErr > 0);

    //
    // Load RASAPI32 DLL and call into it to verify specified
    // phone book entry
    //

    hRasApi32 = LoadLibraryW(L"RASAPI32.DLL");

    if(hRasApi32 isnot NULL)
    {
        pfnRasValidateEntryName =
            (PRasValidateEntryName) GetProcAddress(hRasApi32,
                                                   "RasValidateEntryNameW");
        
        if(pfnRasValidateEntryName isnot NULL )
        {
            dwErr = pfnRasValidateEntryName(rgwcPath,
                                            pwszInterfaceName);
                
            if(dwErr is NO_ERROR)
            {
                dwErr = ERROR_CANNOT_FIND_PHONEBOOK_ENTRY;
            }
            else
            {
                if(dwErr is ERROR_ALREADY_EXISTS)
                {
                    dwErr = NO_ERROR;
                }
            }
        }
        else
        {
            dwErr = GetLastError ();
        }

        FreeLibrary(hRasApi32);
    }
    else
    {
        dwErr = GetLastError();
    }

    return dwErr;
}

DWORD
RtrInterfaceCreate(
    PMPR_INTERFACE_0    pIfInfo
    )
{
    DWORD   dwErr;
    HANDLE  hIfCfg, hIfAdmin;

    dwErr = MprConfigInterfaceCreate(g_hMprConfig,
                                     0,
                                     (PBYTE)pIfInfo,
                                     &hIfCfg);
                        
    if(dwErr isnot NO_ERROR)
    {
        DisplayError(g_hModule,
                     dwErr);
        
        return dwErr;
    }
                
    //
    // if router service is running add the interface
    // to it too.
    //
    
    if(IfutlIsRouterRunning())
    {
        dwErr = MprAdminInterfaceCreate(g_hMprAdmin,
                                        0,
                                        (PBYTE)pIfInfo,
                                        &hIfAdmin);
                            
        if(dwErr isnot NO_ERROR)
        {
            DisplayError(g_hModule,
                         dwErr);
        
            return dwErr;
        }
    }

    return NO_ERROR;
}

DWORD
RtrdbInterfaceAdd(
    IN PWCHAR pszInterface,
    IN DWORD  dwLevel,
    IN PVOID  pvInfo
    )

/*++

Routine Description:

    Adds an interface to the router

Arguments:

    pIfInfo     - Info for adding the interface

Return Value:

    NO_ERROR

--*/

{
    DWORD   dwErr;
    HANDLE  hIfAdmin, hIfCfg;
    GUID    Guid;
    MPR_INTERFACE_0* pIfInfo = (MPR_INTERFACE_0*)pvInfo;

    //
    // If an interface with this name exists, bug out
    //
    
    if(pIfInfo->dwIfType is ROUTER_IF_TYPE_FULL_ROUTER)
    {
        //
        // to create an interface we need a phone book entry
        // for it.
        //

        dwErr = RtrdbValidatePhoneBookEntry(pIfInfo->wszInterfaceName);
        
        if(dwErr isnot NO_ERROR)
        {
            DisplayMessage(g_hModule,
                           EMSG_NO_PHONEBOOK,
                           pIfInfo->wszInterfaceName);

            return dwErr;
        }
    }
    else
    {
        DisplayMessage(g_hModule,
                       EMSG_BAD_IF_TYPE,
                       pIfInfo->dwIfType);

        return ERROR_INVALID_PARAMETER;
    }
     
    //
    // create interface with defaults
    //
            
    pIfInfo->hInterface = INVALID_HANDLE_VALUE;

    dwErr = RtrInterfaceCreate(pIfInfo);

    if(dwErr isnot NO_ERROR)
    {
        DisplayMessage(g_hModule,
                       EMSG_CANT_CREATE_IF,
                       pIfInfo->wszInterfaceName,
                       dwErr);
    }

    return dwErr;
}

DWORD
RtrdbInterfaceDelete(
    IN  PWCHAR  pwszIfName
    )

{
    DWORD   dwErr, dwSize, dwIfType;
    HANDLE  hIfCfg, hIfAdmin;
    GUID    Guid;

    PMPR_INTERFACE_0    pIfInfo;

    do
    {
        dwErr = MprConfigInterfaceGetHandle(g_hMprConfig,
                                            pwszIfName,
                                            &hIfCfg);

        if(dwErr isnot NO_ERROR)
        {
            break;
        }
    
        dwErr = MprConfigInterfaceGetInfo(g_hMprConfig,
                                          hIfCfg,
                                          0,
                                          (PBYTE *)&pIfInfo,
                                          &dwSize);
    
        if(dwErr isnot NO_ERROR)
        {
            break;
        }
        
        if(pIfInfo->dwIfType isnot ROUTER_IF_TYPE_FULL_ROUTER)
        {
            MprConfigBufferFree(pIfInfo);
        
            dwErr = ERROR_INVALID_PARAMETER;
        
            break;
        }

        if(IfutlIsRouterRunning())
        {        
            dwErr = MprAdminInterfaceGetHandle(g_hMprAdmin,
                                               pwszIfName,
                                               &hIfAdmin,
                                               FALSE);
        
            if(dwErr isnot NO_ERROR)
            {
                break;
            }
        
            dwErr = MprAdminInterfaceDelete(g_hMprAdmin,
                                            hIfAdmin);
            if(dwErr isnot NO_ERROR)
            {
                break;
            }
        
        }
       
        dwIfType = pIfInfo->dwIfType;

        dwErr = MprConfigInterfaceDelete(g_hMprConfig,
                                         hIfCfg);
   
        MprConfigBufferFree(pIfInfo);
        
        if(dwErr isnot NO_ERROR)
        {
            break;
        }

    }while(FALSE);

    return dwErr;
}

DWORD
RtrdbInterfaceEnumerate(
    IN DWORD dwLevel,
    IN DWORD dwFormat,
    IN RTR_IF_ENUM_FUNC pEnum,
    IN HANDLE hData 
    )
{
    DWORD dwErr, i, dwCount, dwTotal, dwResume, dwPrefBufSize;
    MPR_INTERFACE_0* pCurIf = NULL;
    LPBYTE pbBuffer = NULL;
    BOOL bRouter, bContinue;

    // Validate / Initiazlize
    if (pEnum == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }
    dwPrefBufSize = sizeof(MPR_INTERFACE_0) * 100; 
    bRouter = IfutlIsRouterRunning();
    dwResume = 0;

    do 
    {
        // Enumerate the first n interfaces
        //
        if (bRouter)
        {
            dwErr = MprAdminInterfaceEnum(
                        g_hMprAdmin,
                        0,
                        &pbBuffer,
                        dwPrefBufSize,
                        &dwCount,
                        &dwTotal,
                        &dwResume);
        }
        else
        {
            dwErr = MprConfigInterfaceEnum(
                        g_hMprConfig,
                        0,
                        &pbBuffer,
                        dwPrefBufSize,
                        &dwCount,
                        &dwTotal,
                        &dwResume);
        }
        if (dwErr == ERROR_MORE_DATA)
        {
            dwErr = NO_ERROR;
            bContinue = TRUE;
        }
        else
        {
            bContinue = FALSE;
        }
        if (dwErr != NO_ERROR)
        {
            break;
        }

        // Call the callback for each interface as long
        // as we're instructed to continue
        pCurIf = (MPR_INTERFACE_0*)pbBuffer;
        for (i = 0; (i < dwCount) && (dwErr == NO_ERROR); i++)
        {
            dwErr = (*pEnum)(
                        pCurIf->wszInterfaceName,
                        dwLevel,
                        dwFormat,
                        (PVOID)pCurIf,
                        hData);
            pCurIf++;                                
        }
        if (dwErr != NO_ERROR)
        {
            break;
        }
        
        // Free up the interface list buffer
	    if (pbBuffer)
	    {
	        if (bRouter)
	        {
	            MprAdminBufferFree(pbBuffer);
	        }
	        else 
	        {
    		    MprConfigBufferFree(pbBuffer);
    		}
            pbBuffer = NULL;
		}

		// Keep this loop going until there are 
		// no more interfaces
		//

    } while (bContinue);

    // Cleanup
    {
    }

    return dwErr;
}

DWORD
RtrdbInterfaceRead(
    IN  PWCHAR     pwszIfName,
    IN  DWORD      dwLevel,
    IN  PVOID      pvInfo,
    IN  BOOL       bReadFromConfigOnError
    )
{
    DWORD   dwErr=NO_ERROR, dwSize;
    HANDLE  hIfCfg, hIfAdmin;
    
    PMPR_INTERFACE_0 pInfo;
    
    do
    {
        pInfo = NULL;
        
        if(IfutlIsRouterRunning())
        {
            dwErr = MprAdminInterfaceGetHandle(g_hMprAdmin,
                                               pwszIfName,
                                               &hIfAdmin,
                                               FALSE);

            if(dwErr isnot NO_ERROR)
            {
                break;
            }
            
            dwErr = MprAdminInterfaceGetInfo(g_hMprAdmin,
                                             hIfAdmin,
                                             0,
                                             (PBYTE *)&pInfo);
    
            if(dwErr isnot NO_ERROR)
            {
                break;
            }

            if (pInfo == NULL)
            {
                dwErr = ERROR_CAN_NOT_COMPLETE;
                break;
            }

            *((MPR_INTERFACE_0*)pvInfo) = *pInfo;

            MprAdminBufferFree(pInfo);
            
        }
    } while (FALSE);

    if (!IfutlIsRouterRunning()
        || (dwErr==ERROR_NO_SUCH_INTERFACE&&bReadFromConfigOnError))
    {
        do
        {
            pInfo = NULL;
            dwErr = MprConfigInterfaceGetHandle(g_hMprConfig,
                                                pwszIfName,
                                                &hIfCfg);

            if(dwErr isnot NO_ERROR)
            {
                break;
            }
            
            dwErr = MprConfigInterfaceGetInfo(g_hMprConfig,
                                              hIfCfg,
                                              0,
                                              (PBYTE *)&pInfo,
                                              &dwSize);
    
            if(dwErr isnot NO_ERROR)
            {
                break;
            }

            *((MPR_INTERFACE_0*)pvInfo) = *pInfo;

            MprConfigBufferFree(pInfo);
        
        } while(FALSE);
    }
    return dwErr;
}

DWORD
RtrdbInterfaceWrite(
    IN  PWCHAR     pwszIfName,
    IN  DWORD      dwLevel,
    IN  PVOID      pvInfo
    )
{
    DWORD   dwErr;
    HANDLE  hIfCfg = NULL;
    MPR_INTERFACE_0* pIfInfo = (MPR_INTERFACE_0*)pvInfo;
    
    do
    {
        if(IfutlIsRouterRunning())
        {
            dwErr = MprAdminInterfaceSetInfo(g_hMprAdmin,
                                             pIfInfo->hInterface,
                                             0,
                                             (BYTE*)pIfInfo);
    
            if(dwErr isnot NO_ERROR)
            {
                break;
            }

            dwErr = MprConfigInterfaceGetHandle(g_hMprConfig,
                                                pIfInfo->wszInterfaceName,
                                                &hIfCfg);

            if(dwErr isnot NO_ERROR)
            {
                break;
            }

            dwErr = MprConfigInterfaceSetInfo(g_hMprConfig,
                                              hIfCfg,
                                              0,
                                              (BYTE*)pIfInfo);
    
            if(dwErr isnot NO_ERROR)
            {
                break;
            }
        }
        else
        {
            dwErr = MprConfigInterfaceSetInfo(g_hMprConfig,
                                              pIfInfo->hInterface,
                                              0,
                                              (BYTE*)pIfInfo);

            if(dwErr isnot NO_ERROR)
            {
                break;
            }
        }            
        
    } while(FALSE);

    return dwErr;
}

DWORD
RtrdbInterfaceReadCredentials(
    IN  PWCHAR     pszIfName,
    IN  PWCHAR     pszUser            OPTIONAL,
    IN  PWCHAR     pszPassword        OPTIONAL,
    IN  PWCHAR     pszDomain          OPTIONAL
    )
{
    MPR_INTERFACE_0 If0;
    DWORD dwErr = NO_ERROR;

    do
    {
        ZeroMemory(&If0, sizeof(If0));
        dwErr = RtrdbInterfaceRead(
                    pszIfName,
                    0,
                    (PVOID)&If0,
                    FALSE);
        BREAK_ON_DWERR(dwErr);

        if (If0.dwIfType != ROUTER_IF_TYPE_FULL_ROUTER)
        {
            DisplayError(g_hModule, EMSG_IF_BAD_CREDENTIALS_TYPE);
            dwErr = ERROR_CAN_NOT_COMPLETE;
            break;
        }

        // Set the credentials
        //
        if (pszUser)
        {   
            pszUser[0] = L'\0';
        }
        if (pszDomain)
        {
            pszDomain[0] = L'\0';
        }
        if (pszPassword)
        {
            pszPassword[0] = L'\0';
        }            
        dwErr = MprAdminInterfaceGetCredentials(
                    g_pwszRouter,
                    pszIfName,
                    pszUser,
                    NULL,
                    pszDomain);
        BREAK_ON_DWERR(dwErr);

        if (pszPassword)
        {
            wcscpy(pszPassword, L"**********");
        }            
        
    } while (FALSE);        

    // Cleanup
    {
    }

    return dwErr;
}

DWORD
RtrdbInterfaceWriteCredentials(
    IN  PWCHAR     pszIfName,
    IN  PWCHAR     pszUser            OPTIONAL,
    IN  PWCHAR     pszPassword        OPTIONAL,
    IN  PWCHAR     pszDomain          OPTIONAL
    )
{
    MPR_INTERFACE_0 If0;
    DWORD dwErr = NO_ERROR;
    
    do
    {
        ZeroMemory(&If0, sizeof(If0));
        dwErr = RtrdbInterfaceRead(
                    pszIfName,
                    0,
                    (PVOID)&If0,
                    FALSE);
        BREAK_ON_DWERR(dwErr);
        if (If0.dwIfType != ROUTER_IF_TYPE_FULL_ROUTER)
        {
            DisplayError(g_hModule, EMSG_IF_BAD_CREDENTIALS_TYPE);
            dwErr = ERROR_CAN_NOT_COMPLETE;
            break;
        }

        // Set the credentials
        //
        dwErr = MprAdminInterfaceSetCredentials(
                    g_pwszRouter,
                    pszIfName,
                    pszUser,
                    pszDomain,
                    pszPassword);
        BREAK_ON_DWERR(dwErr);
        
    } while (FALSE);        

    // Cleanup
    {
    }

    return dwErr;
}

DWORD
RtrdbInterfaceEnableDisable(
    IN  PWCHAR     pwszIfName,
    IN  BOOL       bEnable)
{
    HRESULT hr = E_FAIL;
    INetConnectionManager *pNetConnectionManager = NULL;

    CoInitialize(NULL);

    hr = CoCreateInstance(&CLSID_ConnectionManager, 
                          NULL, 
                          CLSCTX_LOCAL_SERVER | CLSCTX_NO_CODE_DOWNLOAD, 
                          &IID_INetConnectionManager, 
                          (void**)(&pNetConnectionManager)
                         );
    if (SUCCEEDED(hr))
    {
        // Get an enumurator for the set of connections on the system
        IEnumNetConnection* pEnumNetConnection;
        ULONG ulCount = 0;
        BOOL fFound = FALSE;
        HRESULT hrT = S_OK;

        INetConnectionManager_EnumConnections(pNetConnectionManager, NCME_DEFAULT, &pEnumNetConnection);

        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
        

        // Enumurate through the list of adapters on the system and look for the one we want
        // NOTE: To include per-user RAS connections in the list, you need to set the COM
        //       Proxy Blanket on all the interfaces. This is not needed for All-user RAS
        //       connections or LAN connections.
        do
        {
            NETCON_PROPERTIES* pProps = NULL;
            INetConnection *   pConn;

            // Find the next (or first connection)
            hrT = IEnumNetConnection_Next(pEnumNetConnection, 1, &pConn, &ulCount); 
            
            if (SUCCEEDED(hrT) && 1 == ulCount)
            {
                hrT = INetConnection_GetProperties(pConn, &pProps); // Get the connection properties

                if (S_OK == hrT)
                {
                    if (pwszIfName)
                    {
                        // Check if we have the correct connection (based on the name)
                        if (CompareString(LOCALE_USER_DEFAULT, NORM_IGNORECASE, pwszIfName, -1, pProps->pszwName, -1) == CSTR_EQUAL)
                        {
                            fFound = TRUE;
                        }
                    }
                    /*else
                    {
                        // Check if we have the correct connection (based on the GUID)
                        if (IsEqualGUID(pProps->guidId, gdConnectionGuid))
                        {   
                            fFound = TRUE;
                        }
                    }*/

                    if (fFound)
                    {
                        if (bEnable)
                        {
                            hr = INetConnection_Connect(pConn);
                        }
                        else
                        {
                            hr = INetConnection_Disconnect(pConn);
                        }
                    }

                    CoTaskMemFree (pProps->pszwName);
                    CoTaskMemFree (pProps->pszwDeviceName);
                    CoTaskMemFree (pProps);
                }

                INetConnection_Release(pConn);
                pConn = NULL;
            }

        } while (SUCCEEDED(hrT) && 1 == ulCount && !fFound);

        if (FAILED(hrT))
        {
            hr = hrT;
        }

        INetConnection_Release(pEnumNetConnection);
    }
    
    if (FAILED(hr) && hr != HRESULT_FROM_WIN32(ERROR_RETRY))
    {
        //printf("Could not enable or disable connection (0x%08x)\r\n", hr);
    }

    INetConnectionManager_Release(pNetConnectionManager);

    CoUninitialize();

    if (ERROR_RETRY == HRESULT_CODE(hr))
    {
        DisplayMessage(g_hModule, EMSG_COULD_NOT_GET_IPADDRESS);
        return ERROR_OKAY; 
    }
    
    return HRESULT_CODE(hr);
}


DWORD
RtrdbInterfaceRename(
    IN  PWCHAR     pwszIfName,
    IN  DWORD      dwLevel,
    IN  PVOID      pvInfo,
    IN  PWCHAR     pszNewName)
{
    DWORD dwErr = NO_ERROR;
    HRESULT hr = S_OK;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    UNICODE_STRING us;
    GUID Guid;

    do
    {
        // Get the guid from the interface name
        //
        RtlInitUnicodeString(&us, pwszIfName);
        ntStatus = RtlGUIDFromString(&us, &Guid);
        if (ntStatus != STATUS_SUCCESS)
        {
            dwErr = ERROR_BAD_FORMAT;
            break;
        }

        // Rename the interface
        //
        hr = HrRenameConnection(&Guid, pszNewName);
        if (FAILED(hr))
        {
            dwErr = HRESULT_CODE(hr);
            break;
        }
        
    } while (FALSE);

    // Cleanup
    //
    {
    }

    return dwErr;
}

DWORD
RtrdbResetAll()
{
    RTR_IF_LIST* pList = NULL, *pCur = NULL;
    DWORD dwErr = NO_ERROR;

    do
    {
        // Build a list of interfaces that can be 
        // deleted
        //
        dwErr = RtrdbInterfaceEnumerate(
                    0,
                    0,
                    RtrdbAddWanIfToList,
                    (HANDLE)&pList);
        BREAK_ON_DWERR(dwErr);

        // Delete all of the interfaces
        //
        pCur = pList;
        while (pCur)
        {
            RtrdbInterfaceDelete(pCur->pszName);
            pCur = pCur->pNext;
            IfutlFree(pList);
            pList = pCur;
        }

    } while (FALSE);

    // Cleanup
    {
    }

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\if\routerdb.h ===
/*
    File    routerdb.h

    Implements a database abstraction for accessing router interfaces.

    If any caching/transactioning/commit-noncommit-moding is done, it
    should be implemented here with the api's remaining constant.

*/

#ifndef IFMON_ROUTERDB_H
#define IFMON_ROUTERDB_H

//
// Defines a function callback that receives enumerated 
// interfaces.
//
typedef
DWORD
(*RTR_IF_ENUM_FUNC)(
    IN  PWCHAR  pwszIfName,
    IN  DWORD   dwLevel,
    IN  DWORD   dwFormat,
    IN  PVOID   pvData,
    IN  HANDLE  hData
    );

DWORD
RtrdbInterfaceAdd(
    IN PWCHAR pszInterface,
    IN DWORD  dwLevel,
    IN PVOID  pvInfo
    );

DWORD
RtrdbInterfaceDelete(
    IN  PWCHAR  pwszIfName
    );

DWORD
RtrdbInterfaceEnumerate(
    IN DWORD dwLevel,
    IN DWORD dwFormat,
    IN RTR_IF_ENUM_FUNC pEnum,
    IN HANDLE hData 
    );

DWORD
RtrdbInterfaceRead(
    IN  PWCHAR     pwszIfName,
    IN  DWORD      dwLevel,
    IN  PVOID      pvInfo,
    IN  BOOL       bReadFromConfigOnError
    );

DWORD
RtrdbInterfaceWrite(
    IN  PWCHAR     pwszIfName,
    IN  DWORD      dwLevel,
    IN  PVOID      pvInfo
    );

DWORD
RtrdbInterfaceReadCredentials(
    IN  PWCHAR     pszIfName,
    IN  PWCHAR     pszUser            OPTIONAL,
    IN  PWCHAR     pszPassword        OPTIONAL,
    IN  PWCHAR     pszDomain          OPTIONAL
    );

DWORD
RtrdbInterfaceWriteCredentials(
    IN  PWCHAR     pszIfName,
    IN  PWCHAR     pszUser            OPTIONAL,
    IN  PWCHAR     pszPassword        OPTIONAL,
    IN  PWCHAR     pszDomain          OPTIONAL
    );

DWORD
RtrdbInterfaceEnableDisable(
    IN  PWCHAR     pwszIfName,
    IN  BOOL       bEnable);

DWORD
RtrdbInterfaceRename(
    IN  PWCHAR     pwszIfName,
    IN  DWORD      dwLevel,
    IN  PVOID      pvInfo,
    IN  PWCHAR     pszNewName);

DWORD
RtrdbResetAll();


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\if\routerif.c ===
/*
    File: routerif.c

    Defines callbacks needed to deal with interfaces supported by
    the router.
*/

#include "precomp.h"

DWORD
RtruiInterfaceShow(
    IN  PWCHAR  pwszIfName,
    IN  DWORD   dwLevel,
    IN  DWORD   dwFormat,
    IN  PVOID   pvData,
    IN  HANDLE  hData
    )

/*++

Routine Description:

    Prints interface info to display or file

Arguments:

    pIfInfo     - Info for adding the interface

Return Value:

    NO_ERROR

--*/

{
    DWORD   dwErr, dwSize;
    WCHAR   rgwcIfDesc[MAX_INTERFACE_NAME_LEN + 1];
    PWCHAR  pwszEnabled, pwszDisabled, pwszConnected, pwszDisconn;
    PWCHAR  pwszConnecting, pwszUnreachable, pwszClient, pwszHome, pwszFull;
    PWCHAR  pwszDedicated, pwszInternal, pwszLoop;
    PWCHAR  pwszAdminState, pwszState, pwszType;
    MPR_INTERFACE_0* pIfInfo = (MPR_INTERFACE_0*)pvData;
    BOOL    bDump = (hData) && (*((BOOL*)hData));
    
    pwszEnabled     = MakeString(g_hModule, STRING_ENABLED);
    pwszDisabled    = MakeString(g_hModule, STRING_DISABLED);
    pwszConnected   = MakeString(g_hModule, STRING_CONNECTED);
    pwszDisconn     = MakeString(g_hModule, STRING_DISCONNECTED);
    pwszConnecting  = MakeString(g_hModule, STRING_CONNECTING);
    pwszUnreachable = MakeString(g_hModule, STRING_UNREACHABLE);
    pwszClient      = MakeString(g_hModule, STRING_CLIENT);
    pwszHome        = MakeString(g_hModule, STRING_HOME_ROUTER);
    pwszFull        = MakeString(g_hModule, STRING_FULL_ROUTER);
    pwszDedicated   = MakeString(g_hModule, STRING_DEDICATED);
    pwszInternal    = MakeString(g_hModule, STRING_INTERNAL);
    pwszLoop        = MakeString(g_hModule, STRING_LOOPBACK);

    do
    {
        if(!pwszEnabled or
           !pwszDisabled or
           !pwszConnected or
           !pwszDisconn or
           !pwszConnecting or
           !pwszUnreachable or
           !pwszClient or
           !pwszHome or
           !pwszFull or
           !pwszDedicated or
           !pwszInternal or
           !pwszLoop)
        {

            DisplayError(NULL,
                         ERROR_NOT_ENOUGH_MEMORY);

            break;
        }

        dwSize = sizeof(rgwcIfDesc);

        IfutlGetInterfaceDescription(pIfInfo->wszInterfaceName,
                                rgwcIfDesc,
                                &dwSize);
        
        switch(pIfInfo->dwConnectionState)
        {
            case ROUTER_IF_STATE_UNREACHABLE:
            {
                pwszState = pwszUnreachable;

                break;
            }
            
            case ROUTER_IF_STATE_DISCONNECTED:
            {
                pwszState = pwszDisconn;

                break;
            }
            
            case ROUTER_IF_STATE_CONNECTING:
            {
                pwszState = pwszConnecting;

                break;
            }

            case ROUTER_IF_STATE_CONNECTED:
            {
                pwszState = pwszConnected;

                break;
            }

            default:
            {
                pwszState = L"";
                
                break;
            }
                
        }

        if (bDump == FALSE)
        {
            switch(pIfInfo->dwIfType)
            {
                case ROUTER_IF_TYPE_CLIENT:
                    pwszType = pwszClient;
                    break;

                case ROUTER_IF_TYPE_HOME_ROUTER:
                    pwszType = pwszHome;
                    break;
                    
                case ROUTER_IF_TYPE_FULL_ROUTER:
                    pwszType = pwszFull;
                    break;
                
                case ROUTER_IF_TYPE_DEDICATED:
                    pwszType = pwszDedicated;
                    break;
                
                case ROUTER_IF_TYPE_INTERNAL:
                    pwszType = pwszInternal;
                    break;
                
                case ROUTER_IF_TYPE_LOOPBACK:
                    pwszType = pwszLoop;
                    break;
                    
                default:
                    pwszType = L"";
                    break;
            }
            
            if(pIfInfo->fEnabled)
            {
                pwszAdminState = pwszEnabled;
            }
            else
            {
                pwszAdminState = pwszDisabled;
            }
        }
        else
        {
            switch(pIfInfo->dwIfType)
            {
                case ROUTER_IF_TYPE_FULL_ROUTER:
                    pwszType = TOKEN_FULL;
                    break;
                
                default:
                    pwszType = L"";
                    break;
            }
            
            if(pIfInfo->fEnabled)
            {
                pwszAdminState = TOKEN_VALUE_ENABLED;
            }
            else
            {
                pwszAdminState = TOKEN_VALUE_DISABLED;
            }
        }
                
        if (bDump)
        {
            
            PWCHAR pwszQuoted = NULL;
            
            if (wcscmp(pIfInfo->wszInterfaceName, rgwcIfDesc))
            {
                pwszQuoted = MakeQuotedString( rgwcIfDesc );
            }
            else
            {
                pwszQuoted = MakeQuotedString( pIfInfo->wszInterfaceName );
            }

            if (pIfInfo->dwIfType == ROUTER_IF_TYPE_FULL_ROUTER)
            {               
                WCHAR pwszUser[256], pwszDomain[256];
                PWCHAR pszQuoteUser = NULL, pszQuoteDomain = NULL;

                DisplayMessageT( DMP_IF_ADD_IF,
                                 pwszQuoted,
                                 pwszType);

                DisplayMessageT( DMP_IF_SET_IF,
                                 pwszQuoted,
                                 pwszAdminState);

                dwErr = RtrdbInterfaceReadCredentials(
                    pIfInfo->wszInterfaceName,
                    pwszUser,
                    NULL,
                    pwszDomain);

                if (dwErr == NO_ERROR)
                {
                    pszQuoteUser = MakeQuotedString( pwszUser );
                    if (pszQuoteUser == NULL)
                    {
                        break;
                    }
                    if (*pwszDomain == L'\0')
                    {
                        DisplayMessageT( DMP_IF_SET_CRED_IF_NOD,
                                         pwszQuoted,
                                         pszQuoteUser);
                    }
                    else
                    {
                        pszQuoteDomain = MakeQuotedString( pwszDomain );
                        if (pszQuoteUser == NULL)
                        {
                            FreeString(pszQuoteUser);
                            break;
                        }
                        DisplayMessageT( DMP_IF_SET_CRED_IF,
                                         pwszQuoted,
                                         pszQuoteUser,
                                         pszQuoteDomain);
                        FreeString(pszQuoteDomain);
                    }                                             
                }
                
                DisplayMessageT( DMP_IF_NEWLINE );
            }

            FreeQuotedString(pwszQuoted);
        }

        else
        {
            DisplayMessage(g_hModule,
                           (dwFormat>0)? MSG_IF_ENTRY_LONG : MSG_IF_ENTRY_SHORT,
                           pwszAdminState,
                           pwszState,
                           pwszType,
                           rgwcIfDesc );
        } 
    }while(FALSE);
    
    
    if(pwszEnabled)
    {
        FreeString(pwszEnabled);
    }
        
    if(pwszDisabled)
    {
        FreeString(pwszDisabled);
    }
    
    if(pwszConnected)
    {
        FreeString(pwszConnected);
    }
    
    if(pwszDisconn)
    {
        FreeString(pwszDisconn);
    }
    
    if(pwszConnecting)
    {
        FreeString(pwszConnecting);
    }
    
    if(pwszUnreachable)
    {
        FreeString(pwszUnreachable);
    }
    
    if(pwszClient)
    {
        FreeString(pwszClient);
    }
    
    if(pwszHome)
    {
        FreeString(pwszHome);
    }
    
    if(pwszFull)
    {
        FreeString(pwszFull);
    }
    
    if(pwszDedicated)
    {
        FreeString(pwszDedicated);
    }
    
    if(pwszInternal)
    {
        FreeString(pwszInternal);
    }
        
    if(pwszLoop)
    {
        FreeString(pwszLoop);
    }
    
    return NO_ERROR;
}

DWORD
RtrHandleResetAll(
    IN  PWCHAR  *ppwcArguments,
    IN  DWORD   dwCurrentIndex,
    IN  DWORD   dwArgCount,
    IN  BOOL    *pbDone
    )
/*++

Routine Description:

    Handler for displaying interfaces

Arguments:

    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg

Return Value:

    NO_ERROR

--*/
{
    DWORD           dwErr = NO_ERROR, dwSize;
    MPR_INTERFACE_0 If0;
    WCHAR pszName[MAX_INTERFACE_NAME_LEN];

    do 
    {
        // Make sure no arguments were passed in
        //
        if (dwArgCount - dwCurrentIndex != 0)
        {
            dwErr = ERROR_INVALID_SYNTAX;
            break;
        }
        
        dwErr = RtrdbResetAll();
        BREAK_ON_DWERR(dwErr);

    } while (FALSE);

    // Cleanup
    {
    }

    return dwErr;
}

DWORD
RtrHandleAddDel(
    IN  PWCHAR  *ppwcArguments,
    IN  DWORD   dwCurrentIndex,
    IN  DWORD   dwArgCount,
    IN  BOOL    bAdd
    )

/*++

Routine Description:

    The actual parser for the add and delete commands

Arguments:

    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg
    bAdd            - TRUE to add the interface
Return Value:

    NO_ERROR

--*/

{
    DWORD       i, dwNumArgs, dwRes, dwErr, dwIfType, dwSize;
    MPR_INTERFACE_0 IfInfo;
    PWCHAR pszIfDesc = NULL;
    TOKEN_VALUE rgEnumType[] = 
    {
        {TOKEN_FULL,   ROUTER_IF_TYPE_FULL_ROUTER}
    };
    IFMON_CMD_ARG  pArgs[] = 
    {
        {
            IFMON_CMD_TYPE_STRING, 
            {TOKEN_NAME,   TRUE,   FALSE}, 
            NULL,
            0,
            NULL
        },

        {
            IFMON_CMD_TYPE_ENUM, 
            {TOKEN_TYPE,    FALSE,   FALSE}, 
            rgEnumType,
            sizeof(rgEnumType) / sizeof(*rgEnumType),
            NULL
        }
    };   

    // Initialize
    //
    ZeroMemory(&IfInfo, sizeof(IfInfo));
    IfInfo.fEnabled = TRUE;


    do
    {
        // Parse out the values
        //
        dwErr = IfutlParse(
                    ppwcArguments,
                    dwCurrentIndex,
                    dwArgCount,
                    NULL,
                    pArgs,
                    sizeof(pArgs) / sizeof(*pArgs));
        if (dwErr isnot NO_ERROR)
        {
            break;
        }

        //
        // Get the arguments that were specified
        //
        pszIfDesc = IFMON_CMD_ARG_GetPsz(&pArgs[0]);
        if (!pszIfDesc) {
            dwErr = ERROR_INVALID_SYNTAX;
            break;
        }

        IfInfo.dwIfType = IFMON_CMD_ARG_GetDword(&pArgs[1]);

        if(bAdd)
        {
            // Make sure the type was specified
            //
            if (! pArgs[1].rgTag.bPresent)
            {
                dwErr = ERROR_INVALID_SYNTAX;
                break;
            }
            
            wcscpy(
                IfInfo.wszInterfaceName,
                pszIfDesc
                );
                
            dwErr = RtrdbInterfaceAdd(
                        IfInfo.wszInterfaceName,
                        0,
                        (PVOID)&IfInfo);
        }
        else
        {
            WCHAR pszName[MAX_INTERFACE_NAME_LEN + 1];
            dwSize = sizeof(pszName);
            
            IfutlGetInterfaceName(
                pszIfDesc,
                pszName,
                &dwSize);
        
            dwErr = RtrdbInterfaceDelete(pszName);
        }

    } while(FALSE);

    // Cleanup
    {
        IfutlFree(pszIfDesc);
    }

    return dwErr;
}

DWORD
RtrHandleAdd(
    IN  PWCHAR  *ppwcArguments,
    IN  DWORD   dwCurrentIndex,
    IN  DWORD   dwArgCount,
    IN  BOOL    *pbDone
    )

/*++

Routine Description:

    Handler for adding an dial interface to the router

Arguments:

    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg

Return Value:

    NO_ERROR

--*/

{

    return RtrHandleAddDel(
                ppwcArguments,
                dwCurrentIndex,
                dwArgCount,
                TRUE);

}

DWORD
RtrHandleDel(
    IN  PWCHAR  *ppwcArguments,
    IN  DWORD   dwCurrentIndex,
    IN  DWORD   dwArgCount,
    IN  BOOL    *pbDone
    )

/*++

Routine Description:

    Handler for deleting a dial interface or from the router

Arguments:

    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg

Return Value:

    NO_ERROR

--*/

{
    return RtrHandleAddDel(
                ppwcArguments,
                dwCurrentIndex,
                dwArgCount,
                FALSE);

}

DWORD
RtrHandleSet(
    IN  PWCHAR  *ppwcArguments,
    IN  DWORD   dwCurrentIndex,
    IN  DWORD   dwArgCount,
    IN  BOOL    *pbDone
    )
/*++

Routine Description:

    Handler for displaying interfaces

Arguments:

    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg

Return Value:

    NO_ERROR

--*/
{
    DWORD           dwErr = NO_ERROR, dwSize;
    MPR_INTERFACE_0 If0;
    TOKEN_VALUE rgEnumAdmin[] = 
    {
        {TOKEN_VALUE_ENABLED,  TRUE},
        {TOKEN_VALUE_DISABLED, FALSE}
    };
    TOKEN_VALUE rgEnumConnect[] = 
    {
        {TOKEN_VALUE_CONNECTED,  TRUE},
        {TOKEN_VALUE_DISCONNECTED, FALSE}
    };
    IFMON_CMD_ARG  pArgs[] = 
    {
        {
            IFMON_CMD_TYPE_STRING, 
            {TOKEN_NAME,   TRUE,   FALSE}, 
            NULL,
            0,
            NULL
        },

        {
            IFMON_CMD_TYPE_ENUM, 
            {TOKEN_ADMIN,  FALSE,   FALSE}, 
            rgEnumAdmin,
            sizeof(rgEnumAdmin) / sizeof(*rgEnumAdmin),
            NULL
        },
        
        {
            IFMON_CMD_TYPE_ENUM, 
            {TOKEN_CONNECT,  FALSE,   FALSE}, 
            rgEnumConnect,
            sizeof(rgEnumConnect) / sizeof(*rgEnumConnect),
            NULL
        },

        {
            IFMON_CMD_TYPE_STRING, 
            {TOKEN_NEWNAME,  FALSE,   FALSE}, 
            NULL,
            0,
            NULL
        }
    };   
    PWCHAR pszIfName = NULL, pszNewName = NULL;
    WCHAR pszName[MAX_INTERFACE_NAME_LEN];
    BOOL fEnable = FALSE, fConnect = FALSE;
    BOOL fEnablePresent = FALSE, fConnectPresent = FALSE;

    do 
    {
        // Parse
        //
        dwErr = IfutlParse(
                    ppwcArguments,
                    dwCurrentIndex,
                    dwArgCount,
                    NULL,
                    pArgs,
                    sizeof(pArgs)/sizeof(*pArgs));
        BREAK_ON_DWERR(dwErr);                    

        // Get the returned values from the parse
        //
        pszIfName   = IFMON_CMD_ARG_GetPsz(&pArgs[0]);
        fEnable     = IFMON_CMD_ARG_GetDword(&pArgs[1]);
        fConnect    = IFMON_CMD_ARG_GetDword(&pArgs[2]);
        pszNewName  = IFMON_CMD_ARG_GetPsz(&pArgs[3]);
        fEnablePresent = pArgs[1].rgTag.bPresent;
        fConnectPresent = pArgs[2].rgTag.bPresent;
        
        // Get the interface info so that we can 
        // make sure we have the right type.
        //
        dwSize = sizeof(pszName);
        dwErr = GetIfNameFromFriendlyName(
                    pszIfName,
                    pszName,
                    &dwSize);
        BREAK_ON_DWERR(dwErr);

        ZeroMemory(&If0, sizeof(If0));
        dwErr = RtrdbInterfaceRead(
                    pszName,
                    0,
                    (PVOID*)&If0,
                    fEnablePresent? TRUE: FALSE);
        BREAK_ON_DWERR(dwErr);

        // Rename the interface if that is the request
        //
        if ( If0.dwIfType == ROUTER_IF_TYPE_DEDICATED )
        {
            if (!pszNewName && !fEnablePresent)
            {
                DisplayError(
                    g_hModule,
                    EMSG_CANT_FIND_EOPT);

                dwErr = ERROR_INVALID_SYNTAX;
                break;
            }

            if (g_pwszRouter)
            {
                DisplayError(
                    g_hModule,
                    EMSG_IF_NEWNAME_ONLY_FOR_LOCAL);

                dwErr = ERROR_CAN_NOT_COMPLETE;
                break;
            }
            
            if (fConnectPresent)
            {
                DisplayError(
                    g_hModule,
                    EMSG_IF_LAN_ONLY_COMMAND);

                dwErr = ERROR_CAN_NOT_COMPLETE;
                break;
            }

            // Rename the interface
            //
            if (pszNewName)
            {
                dwErr = RtrdbInterfaceRename(
                            pszName,
                            0,
                            (PVOID)&If0,
                            pszNewName);
                if (dwErr != NO_ERROR)
                    break;
            }

            if (fEnablePresent)
            {
                dwErr = RtrdbInterfaceEnableDisable(
                            pszIfName,
                            //(PVOID)&If0,
                            fEnable
                            );
            }
            
            break;                        
        }

        if (pszNewName)
        {
            DisplayError(
                g_hModule,
                EMSG_IF_NEWNAME_ONLY_FOR_LAN);

            dwErr = ERROR_CAN_NOT_COMPLETE;
            break;
        }
            
        // Make sure that at least one option was specified
        //
        if (!fEnablePresent && !fConnectPresent)
        {
            dwErr = ERROR_INVALID_SYNTAX;
            break;
        }

        // Validate the interface type
        //
        //if ( ( If0.dwIfType == ROUTER_IF_TYPE_DEDICATED ) ||
        //     ( If0.dwIfType == ROUTER_IF_TYPE_INTERNAL ) 
        //   )
        if ( If0.dwIfType != ROUTER_IF_TYPE_FULL_ROUTER )
        {
            DisplayError(
                g_hModule,
                EMSG_IF_WAN_ONLY_COMMAND);

            dwErr = ERROR_CAN_NOT_COMPLETE;
            break;
        }

        // Allow the connection request to override
        // the admin enabling.
        if (fConnectPresent)
        {
            if (!IfutlIsRouterRunning())
            {
                DisplayError(
                    g_hModule,
                    EMSG_IF_CONNECT_ONLY_WHEN_ROUTER_RUNNING);

                dwErr = ERROR_CAN_NOT_COMPLETE;
                break;
            }

            if (fConnect)
            {
                fEnablePresent = TRUE;
                fEnable = TRUE;
            }                
        }

        // Enable if requested
        //
        if (fEnablePresent)
        {
            // Enable/disable the interface
            //
            If0.fEnabled = fEnable;

            // Commit
            //
            dwErr = RtrdbInterfaceWrite(
                        If0.wszInterfaceName, 
                        0, 
                        (PVOID)&If0);
            BREAK_ON_DWERR(dwErr);                    
        }

        // Connect if requested
        //
        if (fConnectPresent)
        {
            if (fConnect)
            {
                dwErr = MprAdminInterfaceConnect(
                            g_hMprAdmin,
                            If0.hInterface,
                            NULL,
                            TRUE);

                BREAK_ON_DWERR(dwErr);                
            }
            else
            {
                dwErr = MprAdminInterfaceDisconnect(
                            g_hMprAdmin,
                            If0.hInterface);
                    
                BREAK_ON_DWERR(dwErr);                
            }
        }
        
    } while (FALSE);

    // Cleanup
    {
        IfutlFree(pszIfName);
        IfutlFree(pszNewName);
    }

    return dwErr;
}

DWORD
RtrHandleSetCredentials(
    IN  PWCHAR  *ppwcArguments,
    IN  DWORD   dwCurrentIndex,
    IN  DWORD   dwArgCount,
    IN  BOOL    *pbDone
    )
/*++

Routine Description:

    Handler for displaying interfaces

Arguments:

    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg

Return Value:

    NO_ERROR

--*/
{
    DWORD           dwErr = NO_ERROR, dwSize;
    MPR_INTERFACE_0 If0;
    IFMON_CMD_ARG  pArgs[] = 
    {
        {
            IFMON_CMD_TYPE_STRING, 
            {TOKEN_NAME,   TRUE,   FALSE}, 
            NULL,
            0,
            NULL
        },

        {
            IFMON_CMD_TYPE_STRING, 
            {TOKEN_USER,   TRUE,   FALSE}, 
            NULL,
            0,
            NULL
        },

        {
            IFMON_CMD_TYPE_STRING, 
            {TOKEN_DOMAIN,   FALSE,   FALSE}, 
            NULL,
            0,
            NULL
        },

        {
            IFMON_CMD_TYPE_STRING,
            {TOKEN_PASSWORD,  FALSE,  FALSE}, 
            NULL,
            0,
            NULL
        }
    };   
    PWCHAR pszIfName = NULL, pszUser = NULL;
    PWCHAR pszPassword = NULL, pszDomain = NULL;
    WCHAR pszName[MAX_INTERFACE_NAME_LEN];

    do 
    {
        // Parse
        //
        dwErr = IfutlParse(
                    ppwcArguments,
                    dwCurrentIndex,
                    dwArgCount,
                    NULL,
                    pArgs,
                    sizeof(pArgs)/sizeof(*pArgs));
        BREAK_ON_DWERR(dwErr);                    

        // Get the returned values from the parse
        //
        pszIfName   = IFMON_CMD_ARG_GetPsz(&pArgs[0]);
        pszUser     = IFMON_CMD_ARG_GetPsz(&pArgs[1]);
        pszDomain   = IFMON_CMD_ARG_GetPsz(&pArgs[2]);
        pszPassword = IFMON_CMD_ARG_GetPsz(&pArgs[3]);

        // Get the interface info so that we can 
        // make sure we have the right type.
        //
        dwSize = sizeof(pszName);
        dwErr = GetIfNameFromFriendlyName(
                    pszIfName,
                    pszName,
                    &dwSize);
        BREAK_ON_DWERR(dwErr);

        dwErr = RtrdbInterfaceWriteCredentials(
                    pszName,
                    pszUser,
                    pszPassword,
                    pszDomain);
        BREAK_ON_DWERR(dwErr);                    
        
    } while (FALSE);

    // Cleanup
    {
        IfutlFree(pszIfName);
        IfutlFree(pszUser);
        if (pszPassword)
            RtlSecureZeroMemory(pszPassword, wcslen(pszPassword)*sizeof(WCHAR));
        IfutlFree(pszPassword);
        IfutlFree(pszDomain);
    }

    return dwErr;
}

DWORD
RtrHandleShow(
    IN  PWCHAR  *ppwcArguments,
    IN  DWORD   dwCurrentIndex,
    IN  DWORD   dwArgCount,
    IN  BOOL    *pbDone
    )

/*++

Routine Description:

    Handler for displaying interfaces

Arguments:

    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg

Return Value:

    NO_ERROR

--*/

{
    DWORD           dwErr = NO_ERROR, dwSize;
    MPR_INTERFACE_0 If0;
    IFMON_CMD_ARG  pArgs[] = 
    {
        {
            IFMON_CMD_TYPE_STRING, 
            {TOKEN_NAME,   FALSE,   FALSE}, 
            NULL,
            0,
            NULL
        }
    };   
    PWCHAR pszIfName = NULL;
    WCHAR pszName[MAX_INTERFACE_NAME_LEN];

    do 
    {
        // Parse
        //
        dwErr = IfutlParse(
                    ppwcArguments,
                    dwCurrentIndex,
                    dwArgCount,
                    NULL,
                    pArgs,
                    sizeof(pArgs)/sizeof(*pArgs));
        BREAK_ON_DWERR(dwErr);                    

        // Get the returned values from the parse
        //
        pszIfName   = IFMON_CMD_ARG_GetPsz(&pArgs[0]);

        // Handle the no argument case
        //
        if (pszIfName == NULL)
        {
            RtrdbInterfaceEnumerate(0, 0, RtruiInterfaceShow, NULL);
            dwErr = NO_ERROR;
            break;
        }

        // Map the name
        //
        dwSize = sizeof(pszName);
        GetIfNameFromFriendlyName(
            pszIfName,
            pszName,
            &dwSize);

        // Get the info
        //
        dwErr = RtrdbInterfaceRead(
                    pszName,
                    0,
                    (PVOID)&If0,
                    FALSE);
        BREAK_ON_DWERR( dwErr );                    

        RtruiInterfaceShow(
            If0.wszInterfaceName, 
            0, 
            1, 
            (PVOID)&If0, 
            NULL
            );
        
    } while (FALSE);

    // Cleanup
    //
    {
        if (pszIfName != NULL)
        {
            IfutlFree(pszIfName);
        }
    }

    return dwErr;
}

DWORD
RtrHandleShowCredentials(
    IN  PWCHAR  *ppwcArguments,
    IN  DWORD   dwCurrentIndex,
    IN  DWORD   dwArgCount,
    IN  BOOL    *pbDone
    )
/*++

Routine Description:

    Handler for showing credentials of an interface

Arguments:

    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg

Return Value:

    NO_ERROR

--*/
{
    DWORD           dwErr = NO_ERROR, dwSize;
    MPR_INTERFACE_0 If0;
    IFMON_CMD_ARG  pArgs[] = 
    {
        {
            IFMON_CMD_TYPE_STRING, 
            {TOKEN_NAME,   TRUE,   FALSE}, 
            NULL,
            0,
            NULL
        },
    };   
    PWCHAR pszIfName = NULL;
    WCHAR pszName[MAX_INTERFACE_NAME_LEN];
    WCHAR pszUser[256], pszDomain[256], pszPassword[256];

    do 
    {
        // Parse
        //
        dwErr = IfutlParse(
                    ppwcArguments,
                    dwCurrentIndex,
                    dwArgCount,
                    NULL,
                    pArgs,
                    sizeof(pArgs)/sizeof(*pArgs));
        BREAK_ON_DWERR(dwErr);                    

        // Get the returned values from the parse
        //
        pszIfName   = IFMON_CMD_ARG_GetPsz(&pArgs[0]);

        // Get the interface info so that we can 
        // make sure we have the right type.
        //
        dwSize = sizeof(pszName);
        dwErr = GetIfNameFromFriendlyName(
                    pszIfName,
                    pszName,
                    &dwSize);
        BREAK_ON_DWERR(dwErr);

        dwErr = RtrdbInterfaceReadCredentials(
                    pszName,
                    pszUser,
                    pszPassword,
                    pszDomain);
        BREAK_ON_DWERR(dwErr);

        DisplayMessage(
            g_hModule,
            MSG_IF_CREDENTIALS,
            pszIfName,
            pszUser,
            pszDomain,
            pszPassword);
        
    } while (FALSE);

    // Cleanup
    {
        RtlSecureZeroMemory(pszPassword, sizeof(pszPassword));

        IfutlFree(pszIfName);
    }

    return dwErr;
}

DWORD
RtrHandleDump(
    PWCHAR    *ppwcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    BOOL      *pbDone
    )
{
    DWORD               dwErr, dwCount, dwTotal;
    ULONG               i;
    PMPR_INTERFACE_0    pIfTable;
    BOOL                bFormat = TRUE;

    // Display dump header
    //
    DisplayMessage(g_hModule, DMP_IF_HEADER_COMMENTS);

    DisplayMessageT(DMP_IF_HEADER);

    // Display the interfaces
    //
    RtrdbInterfaceEnumerate(0, 0, RtruiInterfaceShow, &bFormat);

    // Display dump footer
    //
    DisplayMessageT(DMP_IF_FOOTER);

    DisplayMessage(g_hModule, DMP_IF_FOOTER_COMMENTS);

    return NO_ERROR;
}

DWORD
RtrDump(
    IN  PWCHAR     *ppwcArguments,
    IN  DWORD       dwArgCount
    )
{
    BOOL bDone;

    return RtrHandleDump(ppwcArguments, 1, dwArgCount, &bDone);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\if\routerif.h ===
/*
    File: routerif.h

    Defines callbacks needed to deal with interfaces supported by
    the router.
*/

DWORD
RtrHandleResetAll(
    IN  PWCHAR  *ppwcArguments,
    IN  DWORD   dwCurrentIndex,
    IN  DWORD   dwArgCount,
    IN  BOOL    *pbDone
    );

DWORD
RtrHandleAdd(
    IN  PWCHAR  *ppwcArguments,
    IN  DWORD   dwCurrentIndex,
    IN  DWORD   dwArgCount,
    IN  BOOL    *pbDone
    );

DWORD
RtrHandleDel(
    IN  PWCHAR  *ppwcArguments,
    IN  DWORD   dwCurrentIndex,
    IN  DWORD   dwArgCount,
    IN  BOOL    *pbDone
    );

DWORD
RtrHandleSet(
    IN  PWCHAR  *ppwcArguments,
    IN  DWORD   dwCurrentIndex,
    IN  DWORD   dwArgCount,
    IN  BOOL    *pbDone
    );

DWORD
RtrHandleSetCredentials(
    IN  PWCHAR  *ppwcArguments,
    IN  DWORD   dwCurrentIndex,
    IN  DWORD   dwArgCount,
    IN  BOOL    *pbDone
    );

DWORD
RtrHandleShow(
    IN  PWCHAR  *ppwcArguments,
    IN  DWORD   dwCurrentIndex,
    IN  DWORD   dwArgCount,
    IN  BOOL    *pbDone
    );

DWORD
RtrHandleShowCredentials(
    IN  PWCHAR  *ppwcArguments,
    IN  DWORD   dwCurrentIndex,
    IN  DWORD   dwArgCount,
    IN  BOOL    *pbDone
    );

DWORD
RtrHandleDump(
    PWCHAR    *ppwcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    BOOL      *pbDone
    );

DWORD
RtrDump(
    IN  PWCHAR     *ppwcArguments,
    IN  DWORD       dwArgCount
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\if\showmib.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:
     net\routing\netsh\if\showmib.c

Abstract:

    Fns to parse and show MIB information

Author:

     v raman

Revision History:

     Anand Mahalingam
     Dave Thaler
--*/

#include "precomp.h"
#pragma hdrstop
#include <time.h>

#define MALLOC(x) HeapAlloc(GetProcessHeap(), 0, (x))
#define FREE(x)   HeapFree(GetProcessHeap(), 0, (x))

HANDLE g_hConsole, g_hStdOut;

MIB_OBJECT_PARSER   MIBObjectMap[] =
{
    {TOKEN_MIB_OBJECT_INTERFACE,1,GetMIBIfIndex},
    {TOKEN_MIB_OBJECT_IPSTATS,  0,NULL},
    {TOKEN_MIB_OBJECT_IPADDRESS,1,GetMIBIpAddress},
    {TOKEN_MIB_OBJECT_IPNET,    2,GetMIBIpNetIndex},
    {TOKEN_MIB_OBJECT_ICMP,     0,NULL},
    {TOKEN_MIB_OBJECT_TCPSTATS, 0,NULL},
    {TOKEN_MIB_OBJECT_TCPCONN,  4,GetMIBTcpConnIndex},
    {TOKEN_MIB_OBJECT_UDPSTATS, 0,NULL},
    {TOKEN_MIB_OBJECT_UDPCONN,  2,GetMIBUdpConnIndex},
};

ULONG   g_ulNumMibObjects = sizeof(MIBObjectMap)/sizeof(MIB_OBJECT_PARSER);

MAGIC_TABLE    MIBVar[] = {
    {IF_ROW,          PrintIfRow},
    {IF_TABLE,        PrintIfTable},
    {IP_STATS,        PrintIpStats},
    {IP_STATS,        PrintIpStats},
    {IP_ADDRROW,      PrintIpAddrRow},
    {IP_ADDRTABLE,    PrintIpAddrTable},
    {IP_NETROW,       PrintIpNetRow},
    {IP_NETTABLE,     PrintIpNetTable},
    {ICMP_STATS,      PrintIcmp},
    {ICMP_STATS,      PrintIcmp},
    {TCP_STATS,       PrintTcpStats},
    {TCP_STATS,       PrintTcpStats},
    {TCP_ROW,         PrintTcpRow},
    {TCP_TABLE,       PrintTcpTable},
    {UDP_STATS,       PrintUdpStats},
    {UDP_STATS,       PrintUdpStats},
    {UDP_ROW,         PrintUdpRow},
    {UDP_TABLE,       PrintUdpTable},
};

DWORD
GetMIBIfIndex(
    IN    PTCHAR   *pptcArguments,
    IN    DWORD    dwCurrentIndex,
    OUT   PDWORD   pdwIndices,
    OUT   PDWORD   pdwNumParsed 
    )
/*++

Routine Description:

    Gets the interface index.

Arguments:

    pptcArguments  - Argument array
    dwCurrentIndex - Index of the first argument in array
    pdwIndices     - Indices specified in command
    pdwNumParsed   - Number of indices in command
    
Return Value:

    NO_ERROR, ERROR_INVALID_PARAMETER
    
--*/
{
    DWORD dwErr = NO_ERROR;

    *pdwNumParsed = 1;

    // If index was specified just use it

    if (iswdigit(pptcArguments[dwCurrentIndex][0]))
    {
        pdwIndices[0] = _tcstoul(pptcArguments[dwCurrentIndex],NULL,10);

        return NO_ERROR;
    }

    // Try converting a friendly name to an ifindex

    return IfutlGetIfIndexFromFriendlyName( pptcArguments[dwCurrentIndex],
                                       &pdwIndices[0] );
}
    
DWORD
GetMIBIpAddress(
    IN    PTCHAR    *pptcArguments,
    IN    DWORD    dwCurrentIndex,
    OUT   PDWORD   pdwIndices,
    OUT   PDWORD   pdwNumParsed 
    )
/*++

Routine Description:

    Gets the IP address.

Arguments:

    pptcArguments  - Argument array
    dwCurrentIndex - Index of the first argument in array
    pdwIndices     - Indices specified in command
    pdwNumParsed   - Number of indices in command
    
Return Value:

    NO_ERROR
    
--*/
{
    DWORD dwErr = GetIpAddress(pptcArguments[dwCurrentIndex], &pdwIndices[0]);

    *pdwNumParsed = 1;

    return dwErr;
}

DWORD
GetMIBIpNetIndex(
    IN    PTCHAR    *pptcArguments,
    IN    DWORD    dwCurrentIndex,
    OUT   PDWORD   pdwIndices,
    OUT   PDWORD   pdwNumParsed 
    )
/*++

Routine Description:

    Gets the IP net index

Arguments:

    pptcArguments  - Argument array
    dwCurrentIndex - Index of the first argument in array
    pdwIndices     - Indices specified in command
    pdwNumParsed   - Number of indices in command
    
Return Value:

    NO_ERROR
    
--*/
{
    DWORD dwErr;

    pdwIndices[0] = _tcstoul(pptcArguments[dwCurrentIndex],NULL,10);

    dwErr = GetIpAddress(pptcArguments[dwCurrentIndex + 1], &pdwIndices[1]);

    *pdwNumParsed = 2;

    return dwErr;
}


DWORD
GetMIBTcpConnIndex(
    IN    PTCHAR    *pptcArguments,
    IN    DWORD    dwCurrentIndex,
    OUT   PDWORD   pdwIndices,
    OUT   PDWORD   pdwNumParsed 
    )
/*++

Routine Description:

    Gets the tco conn index

Arguments:

    pptcArguments  - Argument array
    dwCurrentIndex - Index of the first argument in array
    pdwIndices     - Indices specified in command
    pdwNumParsed   - Number of indices in command
    
Return Value:

    NO_ERROR
    
--*/
{
    DWORD dwErr = GetIpAddress(pptcArguments[dwCurrentIndex], &pdwIndices[0]);

    if (dwErr isnot NO_ERROR)
    {
        return dwErr;
    }
    
    pdwIndices[1] = htons((WORD)(_tcstoul(pptcArguments[dwCurrentIndex + 1],NULL,10)));

    dwErr = GetIpAddress(pptcArguments[dwCurrentIndex + 2], &pdwIndices[2]);

    pdwIndices[3] = htons((WORD)(_tcstoul(pptcArguments[dwCurrentIndex + 3],
                                          NULL,10)));

    *pdwNumParsed = 4;

    return dwErr;
}

DWORD
GetMIBUdpConnIndex(
    IN    PTCHAR    *pptcArguments,
    IN    DWORD    dwCurrentIndex,
    OUT   PDWORD   pdwIndices,
    OUT   PDWORD   pdwNumParsed 
    )
/*++

Routine Description:

    Gets the udp conn index

Arguments:

    pptcArguments  - Argument array
    dwCurrentIndex - Index of the first argument in array
    pdwIndices     - Indices specified in command
    pdwNumParsed   - Number of indices in command
    
Return Value:

    NO_ERROR
    
--*/
{
    DWORD dwErr = GetIpAddress(pptcArguments[dwCurrentIndex], &pdwIndices[0]);

    pdwIndices[1] = htons((WORD)(_tcstoul(pptcArguments[dwCurrentIndex + 1],
                                          NULL,10)));

    *pdwNumParsed = 2;

    return dwErr;
}

DWORD
GetIgmpList(IN IPV4_ADDRESS NTEAddr,
        OUT IPV4_ADDRESS *pIgmpList,
        OUT PULONG dwOutBufLen
        );

DWORD
GetPrintJoinRow(
    IPV4_ADDRESS ipAddr
    )
{
    DWORD         dwOutBufLen = 0;
    IPV4_ADDRESS *pIgmpList = NULL;
    DWORD         dwStatus;
    DWORD i;

    dwStatus = GetIgmpList( ipAddr,
                            pIgmpList,
                            &dwOutBufLen );

    if (dwStatus == ERROR_INSUFFICIENT_BUFFER) 
    {
       pIgmpList = HeapAlloc(GetProcessHeap(), 0, dwOutBufLen);
       if (!pIgmpList)
           return ERROR_NOT_ENOUGH_MEMORY;

       dwStatus = GetIgmpList( ipAddr,
                               pIgmpList,
                               &dwOutBufLen );
    }
      
    if (dwStatus == STATUS_SUCCESS) 
    {
        WCHAR pwszIfAddr[20], pwszGrAddr[20];
        DWORD dwTotal = dwOutBufLen/sizeof(ipAddr);

        MakeAddressStringW(pwszIfAddr, ipAddr);
        if (!pwszIfAddr)
            return ERROR_NOT_ENOUGH_MEMORY;

        for (i=0; i<dwTotal; i++)
        {
            MakeAddressStringW(pwszGrAddr, pIgmpList[i]);
            if (!pwszGrAddr)
                return ERROR_NOT_ENOUGH_MEMORY;
                
            DisplayMessage(    g_hModule, 
                               MSG_MIB_JOIN_ROW,
                               pwszIfAddr,
                               pwszGrAddr );
        }
    }

    if (pIgmpList)
        HeapFree(GetProcessHeap(), 0, pIgmpList);

    return dwStatus;
}

DWORD
GetIPv4Addresses(
    IN LPSOCKET_ADDRESS_LIST *ppList)
{
    LPSOCKET_ADDRESS_LIST pList = NULL;
    ULONG                 ulSize = 0;
    DWORD                 dwErr;
    DWORD                 dwBytesReturned;
    SOCKET                s;

    *ppList = NULL;

    s = socket(AF_INET, SOCK_DGRAM, 0);
    if (s == INVALID_SOCKET)
        return WSAGetLastError();

    for (;;) {
        dwErr = WSAIoctl(s, SIO_ADDRESS_LIST_QUERY, NULL, 0, pList, ulSize, 
                         &dwBytesReturned, NULL, NULL);

        if (!dwErr) {
            break;
        }

        if (pList) {
            FREE(pList);
            pList = NULL;
        }
    
        dwErr = WSAGetLastError();
        if (dwErr != WSAEFAULT)
            break;
    
        pList = MALLOC(dwBytesReturned);
        if (!pList) {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        ulSize = dwBytesReturned;
    }

    closesocket(s);

    *ppList = pList;
    return dwErr;
}

DWORD
HandleIpShowJoins(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    MIB_OPAQUE_QUERY Query;
    PMIB_IPADDRTABLE lprpcTable;
    DWORD            dwOutBufLen = 0 , 
                     dwNumParsed;
    IPV4_ADDRESS    *pIgmpList = NULL, 
                     ipAddr;
    DWORD            dwResult = NO_ERROR,
                     dwOutEntrySize;
    DWORD            i;
    PMIB_OPAQUE_INFO pRpcInfo;
    PWCHAR           pszIfAddr;
    IFMON_CMD_ARG    pArgs[] = 
    {
        {
            IFMON_CMD_TYPE_STRING,
            {TOKEN_ADDR,  FALSE, FALSE},
            NULL,
            0,
            NULL
        }
    };

    do 
    {
        dwResult = IfutlParse( ppwcArguments,
                               dwCurrentIndex,
                               dwArgCount,
                               NULL,
                               pArgs,
                               sizeof(pArgs) / sizeof(*pArgs));
        if (dwResult)
        {
            break;
        }

        DisplayMessage(g_hModule, MSG_MIB_JOIN_HDR);

        if (pArgs[0].rgTag.bPresent)
        {
            // address specified
            pszIfAddr = IFMON_CMD_ARG_GetPsz(&pArgs[0]);

            dwResult = GetIpAddress( pszIfAddr, &ipAddr );
            if (dwResult)
            {
                break;
            }
    
            GetPrintJoinRow(ipAddr);
        }
        else
        {
            SOCKET_ADDRESS_LIST *pList;
            INT                  j;

            // Get all IPv4 addresses
            dwResult = GetIPv4Addresses(&pList);
            if (dwResult != NO_ERROR)
                break;

            // For each IPv4 address
            for (j=0; j<pList->iAddressCount; j++)
            {
                GetPrintJoinRow( ((LPSOCKADDR_IN)pList->Address[j].lpSockaddr)->sin_addr.s_addr );
            }

            FREE(pList);
        }

    } while (FALSE);

    return dwResult;
}

DWORD
HandleIpMibShowObject(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description:

    Parses command to get MIB object and optional parameters

Arguments:

Return Value:

--*/
{
    DWORD                dwIndices[MAX_NUM_INDICES];
    DWORD                dwNumParsed = 0;
    PMIB_OPAQUE_QUERY    pQuery = NULL;
    PMIB_OPAQUE_INFO     pRpcInfo;
    DWORD                dwQuerySize;
    BOOL                 bFound = FALSE,bOptPresent = FALSE;
    DWORD                dwRefreshRate;
    DWORD                dwOutEntrySize;
    DWORD                i,dwResult,dwErr;
    DWORD                dwMIBIndex, dwIndex;
    BOOL                 bIndex = FALSE, dwType;
    DWORD                dwRR = 0, dwInd = 0;
    HANDLE               hMib;
    
#if 0
    TOKEN_VALUE          tvMfeTypes[] =
    {
        { TOKEN_VALUE_POSITIVE, PositiveMfe },
        { TOKEN_VALUE_NEGATIVE, NegativeMfe },
        { TOKEN_VALUE_BOTH, Both }
    };
#endif

    
    if ( ! IfutlIsRouterRunning() )
    {
        if (g_pwszRouter)
        {
            DisplayMessage(g_hModule, 
                           MSG_IP_REMOTE_ROUTER_NOT_RUNNING, 
                           g_pwszRouter);
        } 
        else 
        {
            DisplayMessage(g_hModule, 
                           MSG_IP_LOCAL_ROUTER_NOT_RUNNING);
        }

        return NO_ERROR;
    }
    
    //
    // Match MIB object
    //

    ppwcArguments += (dwCurrentIndex-1);
    dwArgCount    -= (dwCurrentIndex-1);
    dwCurrentIndex = 1;

    //DEBUG2("In IP MIB Show : %s\n",pptcArguments[0]);

    for (i = 0; i < sizeof(MIBObjectMap)/sizeof(MIB_OBJECT_PARSER); i++)
    {
        if (MatchToken(ppwcArguments[0],MIBObjectMap[i].pwszMIBObj))
        {
            dwIndex = i;
            bFound = TRUE;
        
            break;
        }
    
    }
    
    if (!bFound)
    {
        return ERROR_CMD_NOT_FOUND;
    }

#if 0
    //
    // Special case for MFEs where MFE type is specified
    // before index option
    //

    if ( ( MIBVar[ 2 * dwIndex ].dwId is MCAST_MFE ) ||
         ( MIBVar[ 2 * dwIndex ].dwId is MCAST_MFE_STATS ) )
    {
        if ( dwArgCount > 1 )
        {
            if ( !_wcsnicmp( ppwcArguments[ 1 ], L"TYPE=", 5 ) )
            {
                wcscpy( ppwcArguments[ 1 ], &ppwcArguments[ 1 ][ 5 ] );  
            }
            
            dwErr = MatchEnumTag(
                        g_hModule, ppwcArguments[ 1 ],
                        NUM_TOKENS_IN_TABLE( tvMfeTypes ), tvMfeTypes,
                        &dwType
                        );
        }
        else
        {
            dwErr = ERROR_INVALID_PARAMETER;
        }
        
        if (dwErr isnot NO_ERROR)
        {
            return ERROR_INVALID_SYNTAX;
        }
        
        dwErr = GetMibTagToken(&ppwcArguments[2],
                               dwArgCount - 2,
                               MIBObjectMap[dwIndex].dwMinOptArg,
                               &dwRR,
                               &bIndex,
                               &dwInd);
    }

    else
#endif
    {
        dwErr = GetMibTagToken(&ppwcArguments[1],
                               dwArgCount - 1,
                               MIBObjectMap[dwIndex].dwMinOptArg,
                               &dwRR,
                               &bIndex,
                               &dwInd);
    }

    
    if (dwErr isnot NO_ERROR)
    {
        return ERROR_INVALID_SYNTAX;
    }

    if (bIndex)
    {
        dwMIBIndex = dwIndex * 2;
        bOptPresent = TRUE;
    }
    else
    {
        dwMIBIndex = dwIndex * 2 + 1;
    }

    //
    // Convert refresh rate to msec
    //
    
    dwRR *= 1000;

    if (!InitializeConsole(&dwRR, &hMib, &g_hConsole))
    {
        return ERROR_INIT_DISPLAY;
    }

    //
    // Query the MIB
    //

    pQuery = NULL;

    for ( ; ; )
    {
        if(dwRR)
        {
            DisplayMessageToConsole(g_hModule,
                              g_hConsole,
                              MSG_CTRL_C_TO_QUIT);
        }

        // always...
        {
            if (!(dwMIBIndex % 2))
            {
                (*MIBObjectMap[dwIndex].pfnMIBObjParser)(ppwcArguments,
                                                         1,
                                                         dwIndices,
                                                         &dwNumParsed);
            }

            dwQuerySize = ( sizeof( MIB_OPAQUE_QUERY ) - sizeof( DWORD ) ) + 
                (dwNumParsed) * sizeof(DWORD);
        
            pQuery = (PMIB_OPAQUE_QUERY)HeapAlloc(GetProcessHeap(),
                                                  0,
                                                  dwQuerySize);
    
    
            if (pQuery is NULL)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                DisplayMessage(g_hModule, MSG_IP_NOT_ENOUGH_MEMORY);
        
                return dwErr;
            }

            pQuery->dwVarId = MIBVar[dwMIBIndex].dwId;
    
            for( i = 0; i < dwNumParsed; i++ )
            {
                pQuery->rgdwVarIndex[i] = dwIndices[i];
            }
        
            dwResult = MibGet(             PID_IP,
                                           IPRTRMGR_PID,
                                           (PVOID) pQuery,
                                           dwQuerySize,
                                           (PVOID *) &pRpcInfo,
                                           &dwOutEntrySize );
    
            if ( dwResult isnot NO_ERROR )
            {
                DisplayMessage(g_hModule,  MSG_IP_DIM_ERROR, dwResult );
                return dwResult;
            }
        
            if ( pRpcInfo is NULL )
            {
                DisplayMessage(g_hModule,  MSG_IP_NO_ENTRIES );
                return dwResult;
            }

            (*MIBVar[dwMIBIndex].pfnPrintFunction)(g_hMIBServer, pRpcInfo);

            MprAdminMIBBufferFree( (PVOID) pRpcInfo );
        }
    
        if(pQuery != NULL )
        {
            HeapFree(GetProcessHeap(),0,pQuery);
        }

        if (!RefreshConsole(hMib, g_hConsole, dwRR))
        {
            break;
        }
    }
    
    return dwResult;
}
    
VOID 
PrintIfTable(
    MIB_SERVER_HANDLE hMibServer,
    PMIB_OPAQUE_INFO  prpcInfo
    )
/*++

Routine Description:

    Prints interface table information

Arguments:

Return Value:

--*/
{
    PMIB_IFTABLE lprpcTable = (PMIB_IFTABLE)(prpcInfo->rgbyData);
    PTCHAR ptszIfType, ptszOper, ptszAdmin;
    TCHAR  tszDescr[MAXLEN_IFDESCR + 1], tszIfName[MAX_INTERFACE_NAME_LEN + 1];
    TCHAR  tszPhysAddr[DISPLAYLEN_PHYSADDR + 1];
    WCHAR  wszBuffer[MAX_INTERFACE_NAME_LEN+1];
    DWORD  dwSize;
    
    DWORD dwCount = lprpcTable->dwNumEntries;
    DWORD i;
    
    DisplayMessageToConsole(g_hModule, 
                      g_hConsole,
                      MSG_MIB_IF_HDR);
    
    if ( dwCount is 0 )
    {
        DisplayMessageToConsole(g_hModule, g_hConsole, MSG_IP_NO_ENTRIES);
        return;
    }
    
    for(i = 0; i < dwCount; i++)
    {
        switch(lprpcTable->table[i].dwType)
        {
            case IF_TYPE_ETHERNET_CSMACD:
            {
                ptszIfType = MakeString(g_hModule, STRING_ETHERNET);
                break;
            }
            case IF_TYPE_ISO88025_TOKENRING:
            {
                ptszIfType = MakeString(g_hModule, STRING_TOKENRING);
                break;
            }
            case IF_TYPE_FDDI:
            {
                ptszIfType = MakeString(g_hModule, STRING_FDDI);
                break;
            }
            case IF_TYPE_PPP:
            {
                ptszIfType = MakeString(g_hModule, STRING_PPP);
                break;
            }
            case IF_TYPE_SOFTWARE_LOOPBACK:
            {
                ptszIfType = MakeString(g_hModule, STRING_LOOPBACK);
                break;
            }
            case IF_TYPE_SLIP:
            {
                ptszIfType = MakeString(g_hModule, STRING_SLIP);
                break;
            }
            case IF_TYPE_OTHER:
            default:
            {
                ptszIfType = MakeString(g_hModule, STRING_OTHER);
                break;
            }
        }
        
        switch(lprpcTable->table[i].dwAdminStatus)
        {
            case IF_ADMIN_STATUS_UP:
            {
                ptszAdmin = MakeString(g_hModule, STRING_UP);
                break;
            }
            case IF_ADMIN_STATUS_TESTING:
            {
                ptszAdmin = MakeString(g_hModule, STRING_TESTING);
                break;
            }
            case IF_ADMIN_STATUS_DOWN:
            default:
            {
                ptszAdmin = MakeString(g_hModule, STRING_DOWN);
                break;
            }
        }
        
        switch(lprpcTable->table[i].dwOperStatus)
        {
            case IF_OPER_STATUS_UNREACHABLE:
            {
                ptszOper = MakeString(g_hModule, STRING_UNREACHABLE);
                break;
            }
            case IF_OPER_STATUS_DISCONNECTED:
            {
                ptszOper = MakeString(g_hModule, STRING_DISCONNECTED);
                break;
            }
            case IF_OPER_STATUS_CONNECTING:
            {
                ptszOper = MakeString(g_hModule, STRING_CONNECTING);
                break;
            }
            case IF_OPER_STATUS_CONNECTED:
            {
                ptszOper = MakeString(g_hModule, STRING_CONNECTED);
                break;
            }
            case IF_OPER_STATUS_OPERATIONAL:
            {
                ptszOper = MakeString(g_hModule, STRING_OPERATIONAL);
                break;
            }
            case IF_OPER_STATUS_NON_OPERATIONAL:
            default:
            {
                ptszOper = MakeString(g_hModule, STRING_NON_OPERATIONAL);
                break;
            }
        }
    
#ifdef UNICODE
        wcscpy(tszIfName, lprpcTable->table[i].wszName);
        
        MultiByteToWideChar(GetConsoleOutputCP(),
                            0,
                            lprpcTable->table[i].bDescr,
                            -1,
                            tszDescr,
                            MAXLEN_IFDESCR);
#else
        WideCharToMultiByte(GetConsoleOutputCP(),
                            0,
                            lprpcTable->table[i].wszName,
                            -1,
                            tszIfName,
                            MAX_INTERFACE_NAME_LEN,
                            NULL,
                            NULL);
        
        strcpy(tszDescr,lprpcTable->table[i].bDescr);
#endif
        if (lprpcTable->table[i].dwPhysAddrLen == 0)
        {
            tszPhysAddr[0] = TEXT('\0');
        }
        else
        {
            MakeUnicodePhysAddr(tszPhysAddr,
                                lprpcTable->table[i].bPhysAddr,
                                lprpcTable->table[i].dwPhysAddrLen);
        }

        dwSize = sizeof(wszBuffer);
        IfutlGetInterfaceDescription( tszIfName, wszBuffer, &dwSize );

        DisplayMessageToConsole(g_hModule, g_hConsole,MSG_MIB_INTERFACE,
                       lprpcTable->table[i].dwIndex,
                       wszBuffer,
                       tszIfName,
                       ptszIfType,
                       lprpcTable->table[i].dwMtu,
                       lprpcTable->table[i].dwSpeed,
                       tszPhysAddr,
                       ptszAdmin,
                       ptszOper,
                       lprpcTable->table[i].dwLastChange,
                       lprpcTable->table[i].dwInOctets,
                       lprpcTable->table[i].dwInUcastPkts,
                       lprpcTable->table[i].dwInNUcastPkts,
                       lprpcTable->table[i].dwInDiscards,
                       lprpcTable->table[i].dwInErrors,
                       lprpcTable->table[i].dwInUnknownProtos,
                       lprpcTable->table[i].dwOutOctets,
                       lprpcTable->table[i].dwOutUcastPkts,
                       lprpcTable->table[i].dwOutNUcastPkts,
                       lprpcTable->table[i].dwOutDiscards,
                       lprpcTable->table[i].dwOutErrors,
                       lprpcTable->table[i].dwOutQLen,
                       tszDescr);
        
        FreeString(ptszIfType);
        FreeString(ptszAdmin);
        FreeString(ptszOper);
    }
}

VOID 
PrintIfRow(
    MIB_SERVER_HANDLE hMibServer,
    PMIB_OPAQUE_INFO  prpcInfo
    )
/*++

Routine Description:

    Prints interface row information

Arguments:

Return Value:

--*/
{
    PMIB_IFROW ieRow = (PMIB_IFROW)(prpcInfo->rgbyData); 
    PTCHAR ptszIfType, ptszOper, ptszAdmin;
    TCHAR  tszDescr[MAXLEN_IFDESCR + 1], tszIfName[MAX_INTERFACE_NAME_LEN + 1];
    TCHAR  tszPhysAddr[DISPLAYLEN_PHYSADDR + 1];
    WCHAR  wszBuffer[MAX_INTERFACE_NAME_LEN+1];
    DWORD  dwSize;
    
    DisplayMessageToConsole(g_hModule, 
                      g_hConsole,
                      MSG_MIB_IF_HDR);
    
    switch(ieRow->dwType)
    {
        case IF_TYPE_ETHERNET_CSMACD:
        {
            ptszIfType = MakeString(g_hModule, STRING_ETHERNET);
            break;
        }
        case IF_TYPE_ISO88025_TOKENRING:
        {
            ptszIfType = MakeString(g_hModule, STRING_TOKENRING);
            break;
        }
        case IF_TYPE_FDDI:
        {
            ptszIfType = MakeString(g_hModule, STRING_FDDI);
            break;
        }
        case IF_TYPE_PPP:
        {
            ptszIfType = MakeString(g_hModule, STRING_PPP);
            break;
        }
        case IF_TYPE_SOFTWARE_LOOPBACK:
        {
            ptszIfType = MakeString(g_hModule, STRING_LOOPBACK);
            break;
        }
        case IF_TYPE_SLIP:
        {
            ptszIfType = MakeString(g_hModule, STRING_SLIP);
            break;
        }
        case IF_TYPE_OTHER:
        default:
        {
            ptszIfType = MakeString(g_hModule, STRING_OTHER);
            break;
        }
    }

    switch(ieRow->dwAdminStatus)
    {
        case IF_ADMIN_STATUS_UP:
        {
            ptszAdmin = MakeString(g_hModule, STRING_UP);
            break;
        }
        case IF_ADMIN_STATUS_TESTING:
        {
            ptszAdmin = MakeString(g_hModule, STRING_TESTING);
            break;
        }
        case IF_ADMIN_STATUS_DOWN:
        default:
        {
            ptszAdmin = MakeString(g_hModule, STRING_DOWN);
            break;
        }
    }

    switch(ieRow->dwOperStatus)
    {
        case IF_OPER_STATUS_UNREACHABLE:
        {
            ptszOper = MakeString(g_hModule, STRING_UNREACHABLE);
            break;
        }
        case IF_OPER_STATUS_DISCONNECTED:
        {
            ptszOper = MakeString(g_hModule, STRING_DISCONNECTED);
            break;
        }
        case IF_OPER_STATUS_CONNECTING:
        {
            ptszOper = MakeString(g_hModule, STRING_CONNECTING);
            break;
        }
        case IF_OPER_STATUS_CONNECTED:
        {
            ptszOper = MakeString(g_hModule, STRING_CONNECTED);
            break;
        }
        case IF_OPER_STATUS_OPERATIONAL:
        {
            ptszOper = MakeString(g_hModule, STRING_OPERATIONAL);
            break;
        }
        case IF_OPER_STATUS_NON_OPERATIONAL:
        default:
        {
            ptszOper = MakeString(g_hModule, STRING_NON_OPERATIONAL);
            break;
        }
   }
    
    
#ifdef UNICODE
    wcscpy(tszIfName, ieRow->wszName);
    
    MultiByteToWideChar(GetConsoleOutputCP(),
                        0,
                        ieRow->bDescr,
                        -1,
                        tszDescr,
                        MAXLEN_IFDESCR);
#else
    WideCharToMultiByte(GetConsoleOutputCP(),
                        0,
                        ieRow->wszName,
                        -1,
                        tszIfName,
                        MAX_INTERFACE_NAME_LEN,
                        NULL,
                        NULL);

    strcpy(tszDescr,ieRow->bDescr);
#endif

    if (ieRow->dwPhysAddrLen == 0)
    {
        tszPhysAddr[0] = TEXT('\0');
    }
    else
    {
        MakeUnicodePhysAddr(tszPhysAddr,ieRow->bPhysAddr,ieRow->dwPhysAddrLen);
    }

    dwSize = sizeof(wszBuffer);
    IfutlGetInterfaceDescription( tszIfName, wszBuffer, &dwSize );
    
    DisplayMessageToConsole(g_hModule, g_hConsole,MSG_MIB_INTERFACE,
                   ieRow->dwIndex,
                   wszBuffer,
                   tszIfName,
                   ptszIfType,
                   ieRow->dwMtu,
                   ieRow->dwSpeed,
                   tszPhysAddr,
                   ptszAdmin,
                   ptszOper,
                   ieRow->dwLastChange,
                   ieRow->dwInOctets,
                   ieRow->dwInUcastPkts,
                   ieRow->dwInNUcastPkts,
                   ieRow->dwInDiscards,
                   ieRow->dwInErrors,
                   ieRow->dwInUnknownProtos,
                   ieRow->dwOutOctets,
                   ieRow->dwOutUcastPkts,
                   ieRow->dwOutNUcastPkts,
                   ieRow->dwOutDiscards,
                   ieRow->dwOutErrors,
                   ieRow->dwOutQLen,
                   tszDescr);
    
    FreeString(ptszIfType);
    FreeString(ptszAdmin);
    FreeString(ptszOper);
    
}

VOID 
PrintIcmp(
    MIB_SERVER_HANDLE hMibServer,
    PMIB_OPAQUE_INFO prpcInfo
    )
/*++

Routine Description:

    Prints ICMP information.

Arguments:

Return Value:

--*/
{
    PMIB_ICMP lprpcIcmp = (PMIB_ICMP)(prpcInfo->rgbyData);
    
    DisplayMessageToConsole(g_hModule, g_hConsole,MSG_MIB_ICMP,
                   lprpcIcmp->stats.icmpInStats.dwMsgs,
                   lprpcIcmp->stats.icmpInStats.dwErrors,
                   lprpcIcmp->stats.icmpInStats.dwDestUnreachs,
                   lprpcIcmp->stats.icmpInStats.dwTimeExcds,
                   lprpcIcmp->stats.icmpInStats.dwParmProbs,
                   lprpcIcmp->stats.icmpInStats.dwSrcQuenchs,
                   lprpcIcmp->stats.icmpInStats.dwRedirects,
                   lprpcIcmp->stats.icmpInStats.dwEchos,
                   lprpcIcmp->stats.icmpInStats.dwEchoReps,
                   lprpcIcmp->stats.icmpInStats.dwTimestamps,
                   lprpcIcmp->stats.icmpInStats.dwTimestampReps,
                   lprpcIcmp->stats.icmpInStats.dwAddrMasks,
                   lprpcIcmp->stats.icmpInStats.dwAddrMaskReps,
                   lprpcIcmp->stats.icmpOutStats.dwMsgs,
                   lprpcIcmp->stats.icmpOutStats.dwErrors,
                   lprpcIcmp->stats.icmpOutStats.dwDestUnreachs,
                   lprpcIcmp->stats.icmpOutStats.dwTimeExcds,
                   lprpcIcmp->stats.icmpOutStats.dwParmProbs,
                   lprpcIcmp->stats.icmpOutStats.dwSrcQuenchs,
                   lprpcIcmp->stats.icmpOutStats.dwRedirects,
                   lprpcIcmp->stats.icmpOutStats.dwEchos,
                   lprpcIcmp->stats.icmpOutStats.dwEchoReps,
                   lprpcIcmp->stats.icmpOutStats.dwTimestamps,
                   lprpcIcmp->stats.icmpOutStats.dwTimestampReps,
                   lprpcIcmp->stats.icmpOutStats.dwAddrMasks,
                   lprpcIcmp->stats.icmpOutStats.dwAddrMaskReps);
}

VOID 
PrintUdpStats(
    MIB_SERVER_HANDLE hMibServer,
    PMIB_OPAQUE_INFO prpcInfo
    )
/*++

Routine Description:

    Prints UDP statistics.

Arguments:

Return Value:

--*/
{
    PMIB_UDPSTATS lprpcUdp = (PMIB_UDPSTATS)(prpcInfo->rgbyData);
    
    DisplayMessageToConsole(g_hModule, g_hConsole,MSG_MIB_UDP_STATS,
                   lprpcUdp->dwInDatagrams,
                   lprpcUdp->dwNoPorts,
                   lprpcUdp->dwInErrors,
                   lprpcUdp->dwOutDatagrams);
}

VOID 
PrintUdpTable(
    MIB_SERVER_HANDLE hMibServer,
    PMIB_OPAQUE_INFO prpcInfo
    )
/*++

Routine Description:

    Prints UDP table information.

Arguments:

Return Value:

--*/
{
    PMIB_UDPTABLE lprpcTable = (PMIB_UDPTABLE)(prpcInfo->rgbyData);
    
    TCHAR tszAddr[ADDR_LENGTH + 1];
    DWORD i;
    
    DisplayMessageToConsole(g_hModule, g_hConsole,MSG_MIB_UDP_ENTRY_HDR);
    
    if(lprpcTable->dwNumEntries is 0)
    {
        DisplayMessageToConsole(g_hModule, g_hConsole,MSG_IP_NO_ENTRIES);
        return;
    }
    
    for(i = 0; i < lprpcTable->dwNumEntries; i++)
    {
        MakeUnicodeIpAddr(tszAddr,
                          inet_ntoa(*((struct in_addr *)(&lprpcTable->table[i].dwLocalAddr))));

        DisplayMessageToConsole(g_hModule, g_hConsole,MSG_MIB_UDP_ENTRY,
                       tszAddr,
                       ntohs((WORD)lprpcTable->table[i].dwLocalPort));
    }
}

VOID 
PrintUdpRow(
    MIB_SERVER_HANDLE hMibServer,
    PMIB_OPAQUE_INFO prpcInfo
    )
/*++

Routine Description:

    Prints UDP row information.

Arguments:

Return Value:

--*/
{
    PMIB_UDPROW ueRow = (PMIB_UDPROW)(prpcInfo->rgbyData);
    
    TCHAR tszAddr[ADDR_LENGTH + 1];
    
    DisplayMessageToConsole(g_hModule, g_hConsole,MSG_MIB_UDP_ENTRY_HDR);
    
    MakeUnicodeIpAddr(tszAddr,inet_ntoa(*((struct in_addr *)
                                          (&ueRow->dwLocalAddr))));
    
    DisplayMessageToConsole(g_hModule, g_hConsole,MSG_MIB_UDP_ENTRY,
                   tszAddr,
                   ntohs((WORD)ueRow->dwLocalPort));
}

VOID 
PrintTcpStats(
    MIB_SERVER_HANDLE hMibServer,
    PMIB_OPAQUE_INFO prpcInfo
    )
/*++

Routine Description:

    Prints TCP Statistics

Arguments:

Return Value:

--*/

{
    PMIB_TCPSTATS lprpcTcp = (PMIB_TCPSTATS)(prpcInfo->rgbyData);
    
    PTCHAR ptszMaxConn, ptszAlgo;
    
    switch(lprpcTcp->dwRtoAlgorithm)
    {
        case MIB_TCP_RTO_CONSTANT:
        {
            ptszAlgo = MakeString(g_hModule, STRING_CONSTANT);
            break;
        }
        case MIB_TCP_RTO_RSRE:
        {
            ptszAlgo = MakeString(g_hModule, STRING_RSRE);
            break;
        }
        case MIB_TCP_RTO_VANJ:
        {
            ptszAlgo = MakeString(g_hModule, STRING_VANJ);
            break;
        }
        case MIB_TCP_RTO_OTHER:
        default:
        {
            ptszAlgo = MakeString(g_hModule, STRING_OTHER);
            break;
        }
    }
    
    if(lprpcTcp->dwMaxConn is MIB_TCP_MAXCONN_DYNAMIC)
    {
        ptszMaxConn = MakeString(g_hModule, STRING_DYNAMIC);
    }
    else
    {
        ptszMaxConn = HeapAlloc(GetProcessHeap(),0,20);
        
        if(ptszMaxConn is NULL)
        {
            return;
        }
        _stprintf(ptszMaxConn,TEXT("%d"),lprpcTcp->dwMaxConn);
    }
    
    DisplayMessageToConsole(g_hModule, g_hConsole,MSG_MIB_TCP_STATS,
                   ptszAlgo,
                   lprpcTcp->dwRtoMin,
                   lprpcTcp->dwRtoMax,
                   ptszMaxConn,
                   lprpcTcp->dwActiveOpens,
                   lprpcTcp->dwPassiveOpens,
                   lprpcTcp->dwAttemptFails,
                   lprpcTcp->dwEstabResets,
                   lprpcTcp->dwCurrEstab,
                   lprpcTcp->dwInSegs,
                   lprpcTcp->dwOutSegs,
                   lprpcTcp->dwRetransSegs,
                   lprpcTcp->dwInErrs,
                   lprpcTcp->dwOutRsts);
    
    FreeString(ptszAlgo);

    if(lprpcTcp->dwMaxConn is MIB_TCP_MAXCONN_DYNAMIC)
    {
        FreeString(ptszMaxConn);
    }
    else
    {
        HeapFree(GetProcessHeap,0,ptszMaxConn);
    }
    
}

VOID 
PrintTcpTable(
    MIB_SERVER_HANDLE hMibServer,
    PMIB_OPAQUE_INFO prpcInfo
    )
/*++

Routine Description:

    Prints TCP table information.

Arguments:

Return Value:

--*/
{
    PMIB_TCPTABLE lprpcTable = (PMIB_TCPTABLE)(prpcInfo->rgbyData);
    
    TCHAR  tszLAddr[ADDR_LENGTH + 1], tszRAddr[ADDR_LENGTH + 1];
    PTCHAR ptszState;
    DWORD i;

    DisplayMessageToConsole(g_hModule, g_hConsole,MSG_MIB_TCP_ENTRY_HDR);
    
    if(lprpcTable->dwNumEntries is 0)
    {
        DisplayMessageToConsole(g_hModule, g_hConsole,MSG_IP_NO_ENTRIES);
        return;
    }
    
    for(i = 0; i < lprpcTable->dwNumEntries; i++)
    {
        switch(lprpcTable->table[i].dwState)
        {
            case MIB_TCP_STATE_CLOSED:
            {
                ptszState = MakeString(g_hModule, STRING_CLOSED);
                break;
            }
            case MIB_TCP_STATE_LISTEN:
            {
                ptszState = MakeString(g_hModule, STRING_LISTEN);
                break;
            }
            case MIB_TCP_STATE_SYN_SENT:
            {
                ptszState = MakeString(g_hModule, STRING_SYN_SENT);
                break;
            }
            case MIB_TCP_STATE_SYN_RCVD:
            {
                ptszState = MakeString(g_hModule, STRING_SYN_RCVD);
                break;
            }
            case MIB_TCP_STATE_ESTAB:
            {
                ptszState = MakeString(g_hModule, STRING_ESTAB);
                break;
            }
            case MIB_TCP_STATE_FIN_WAIT1:
            {
                ptszState = MakeString(g_hModule, STRING_FIN_WAIT1);
                break;
            }
            case MIB_TCP_STATE_FIN_WAIT2:
            {
                ptszState = MakeString(g_hModule, STRING_FIN_WAIT2);
                break;
            }
            case MIB_TCP_STATE_CLOSE_WAIT:
            {
                ptszState = MakeString(g_hModule, STRING_CLOSE_WAIT);
                break;
            }
            case MIB_TCP_STATE_CLOSING:
            {
                ptszState = MakeString(g_hModule, STRING_CLOSING);
                break;
            }
            case MIB_TCP_STATE_LAST_ACK:
            {
                ptszState = MakeString(g_hModule, STRING_LAST_ACK);
                break;
            }
            case MIB_TCP_STATE_TIME_WAIT:
            {
                ptszState = MakeString(g_hModule, STRING_TIME_WAIT);
                break;
            }
            case MIB_TCP_STATE_DELETE_TCB :
            {
                ptszState = MakeString(g_hModule, STRING_DELETE_TCB);
                break;
            }
        }
    
        MakeUnicodeIpAddr(tszLAddr, 
                          inet_ntoa(*((struct in_addr *)
                                      (&lprpcTable->table[i].dwLocalAddr))));
        MakeUnicodeIpAddr(tszRAddr, 
                          inet_ntoa(*((struct in_addr *)
                                      (&lprpcTable->table[i].dwRemoteAddr))));
        
        DisplayMessageToConsole(g_hModule, g_hConsole,MSG_MIB_TCP_ENTRY,
                       tszLAddr,
                       ntohs((WORD)lprpcTable->table[i].dwLocalPort),
                       tszRAddr,
                       ntohs((WORD)lprpcTable->table[i].dwRemotePort),
                       ptszState);
        
        FreeString(ptszState);
    }
}

VOID 
PrintTcpRow(
    MIB_SERVER_HANDLE hMibServer,
    PMIB_OPAQUE_INFO prpcInfo
    )
/*++

Routine Description:

    Prints TCP row information.

Arguments:

Return Value:

--*/
{
    PMIB_TCPROW tcteRow = (PMIB_TCPROW)(prpcInfo->rgbyData);
    TCHAR  tszLAddr[ADDR_LENGTH + 1], tszRAddr[ADDR_LENGTH + 1];
    PTCHAR ptszState;
    
    DisplayMessageToConsole(g_hModule, g_hConsole,MSG_MIB_TCP_ENTRY_HDR);
    
    switch(tcteRow->dwState)
    {
        case MIB_TCP_STATE_CLOSED:
        {
            ptszState = MakeString(g_hModule, STRING_CLOSED);
            break;
        }
        case MIB_TCP_STATE_LISTEN:
        {
            ptszState = MakeString(g_hModule, STRING_LISTEN);
            break;
        }
        case MIB_TCP_STATE_SYN_SENT:
        {
            ptszState = MakeString(g_hModule, STRING_SYN_SENT);
            break;
        }
        case MIB_TCP_STATE_SYN_RCVD:
        {
            ptszState = MakeString(g_hModule, STRING_SYN_RCVD);
            break;
        }
        case MIB_TCP_STATE_ESTAB:
        {
            ptszState = MakeString(g_hModule, STRING_ESTAB);
            break;
        }
        case MIB_TCP_STATE_FIN_WAIT1:
        {
            ptszState = MakeString(g_hModule, STRING_FIN_WAIT1);
            break;
        }
        case MIB_TCP_STATE_FIN_WAIT2:
        {
            ptszState = MakeString(g_hModule, STRING_FIN_WAIT2);
            break;
        }
        case MIB_TCP_STATE_CLOSE_WAIT:
        {
            ptszState = MakeString(g_hModule, STRING_CLOSE_WAIT);
            break;
        }
        case MIB_TCP_STATE_CLOSING:
        {
            ptszState = MakeString(g_hModule, STRING_CLOSING);
            break;
        }
        case MIB_TCP_STATE_LAST_ACK:
        {
            ptszState = MakeString(g_hModule, STRING_LAST_ACK);
            break;
        }
        case MIB_TCP_STATE_TIME_WAIT:
        {
            ptszState = MakeString(g_hModule, STRING_TIME_WAIT);
            break;
        }
        case MIB_TCP_STATE_DELETE_TCB :
        {
            ptszState = MakeString(g_hModule, STRING_DELETE_TCB);
            break;
        }
    }
    
    MakeUnicodeIpAddr(tszLAddr, inet_ntoa(*((struct in_addr *)
                                            (&tcteRow->dwLocalAddr))));
    MakeUnicodeIpAddr(tszRAddr, inet_ntoa(*((struct in_addr *)
                                            (&tcteRow->dwRemoteAddr))));
    
    DisplayMessageToConsole(g_hModule, g_hConsole,MSG_MIB_TCP_ENTRY,
                      tszLAddr,
                      ntohs((WORD)tcteRow->dwLocalPort),
                      tszRAddr,
                      ntohs((WORD)tcteRow->dwRemotePort),
                      ptszState);
    
    FreeString(ptszState);
}

VOID 
PrintIpStats(
    MIB_SERVER_HANDLE hMibServer,
    PMIB_OPAQUE_INFO prpcInfo
    )
{
    PMIB_IPSTATS lprpcIp = (PMIB_IPSTATS)(prpcInfo->rgbyData);
    PTCHAR   ptszForw;

    
    if(lprpcIp->dwForwarding is MIB_IP_FORWARDING)
    {
        ptszForw = MakeString(g_hModule, STRING_ENABLED);
    }
    else
    {
        ptszForw = MakeString(g_hModule, STRING_DISABLED);
    }
     
    DisplayMessageToConsole(g_hModule, g_hConsole,MSG_MIB_IP_STATS,
                      ptszForw,
                      lprpcIp->dwDefaultTTL,
                      lprpcIp->dwInReceives,
                      lprpcIp->dwInHdrErrors,
                      lprpcIp->dwInAddrErrors,
                      lprpcIp->dwForwDatagrams,
                      lprpcIp->dwInUnknownProtos,
                      lprpcIp->dwInDiscards,
                      lprpcIp->dwInDelivers,
                      lprpcIp->dwOutRequests,
                      lprpcIp->dwRoutingDiscards,
                      lprpcIp->dwOutDiscards,
                      lprpcIp->dwOutNoRoutes,
                      lprpcIp->dwReasmTimeout,
                      lprpcIp->dwReasmReqds,
                      lprpcIp->dwReasmOks,
                      lprpcIp->dwReasmFails,
                      lprpcIp->dwFragOks,
                      lprpcIp->dwFragFails,
                      lprpcIp->dwFragCreates);
    
    FreeString(ptszForw);
}

VOID 
PrintIpAddrTable(
    MIB_SERVER_HANDLE hMibServer,
    PMIB_OPAQUE_INFO prpcInfo
    )
/*++

Routine Description:

    Prints IP address table.

Arguments:

Return Value:

--*/
{
    WCHAR wszFriendlyName[MAX_INTERFACE_NAME_LEN + 1];
    PMIB_IPADDRTABLE lprpcTable;
    TCHAR tszAddr[ADDR_LENGTH + 1], tszMask[ADDR_LENGTH + 1];
    DWORD i, dwErr = NO_ERROR;

    lprpcTable = (PMIB_IPADDRTABLE)(prpcInfo->rgbyData);
    
    DisplayMessageToConsole(g_hModule, g_hConsole,MSG_MIB_IP_ADDR_HDR);
    
    if(lprpcTable->dwNumEntries is 0)
    {
        DisplayMessageToConsole(g_hModule, g_hConsole,MSG_IP_NO_ENTRIES);
        return;
    }
    
    for(i = 0; i < lprpcTable->dwNumEntries; i++)
    {
        DWORD BufLen;
        
        MakeUnicodeIpAddr(tszAddr,
                          inet_ntoa(*((struct in_addr *)
                                      (&lprpcTable->table[i].dwAddr))));
        MakeUnicodeIpAddr(tszMask,
                          inet_ntoa(*((struct in_addr *)
                                      (&lprpcTable->table[i].dwMask))));

        BufLen = sizeof(wszFriendlyName);
        dwErr = IfutlGetFriendlyNameFromIfIndex( hMibServer,
                                            lprpcTable->table[i].dwIndex,
                                            wszFriendlyName,//in bytes. not chars
                                            BufLen );

        DisplayMessageToConsole(g_hModule, g_hConsole,MSG_MIB_IP_ADDR_ENTRY,
                          tszAddr,
                          tszMask,
                          lprpcTable->table[i].dwBCastAddr,
                          lprpcTable->table[i].dwReasmSize,
                          wszFriendlyName
                         );
    }
}

VOID 
PrintIpAddrRow(
    MIB_SERVER_HANDLE hMibServer,
    PMIB_OPAQUE_INFO prpcInfo
    )
/*++

Routine Description:

    Prints IP address table row.

Arguments:

Return Value:

--*/
{
    WCHAR wszFriendlyName[MAX_INTERFACE_NAME_LEN + 1];
    PMIB_IPADDRROW iaeRow = (PMIB_IPADDRROW)(prpcInfo->rgbyData);
    DWORD          dwErr = NO_ERROR;
    
    TCHAR           tszAddr[ADDR_LENGTH + 1], tszMask[ADDR_LENGTH + 1];
    DWORD           BufLen;

    MakeUnicodeIpAddr(tszAddr,
                      inet_ntoa(*((struct in_addr *)(&iaeRow->dwAddr))));
    MakeUnicodeIpAddr(tszMask,
                      inet_ntoa(*((struct in_addr *)(&iaeRow->dwMask))));

    BufLen = sizeof(wszFriendlyName);
    dwErr = IfutlGetFriendlyNameFromIfIndex( hMibServer,
                                        iaeRow->dwIndex,
                                        wszFriendlyName,//in bytes. not chars
                                        BufLen );

    DisplayMessageToConsole(g_hModule, g_hConsole,MSG_MIB_IP_ADDR_HDR);
    
    DisplayMessageToConsole(g_hModule, g_hConsole,MSG_MIB_IP_ADDR_ENTRY,
                          tszAddr,
                          tszMask,
                          iaeRow->dwBCastAddr,
                          iaeRow->dwReasmSize,
                          wszFriendlyName );
}

VOID 
PrintIpNetTable(
    MIB_SERVER_HANDLE hMibServer,
    PMIB_OPAQUE_INFO prpcInfo
    )
/*++

Routine Description:

    Prints IP net table information.

Arguments:

Return Value:

--*/
{
    WCHAR           wszFriendlyName[MAX_INTERFACE_NAME_LEN + 1];
    PMIB_IPNETTABLE lprpcTable = (PMIB_IPNETTABLE)(prpcInfo->rgbyData);
    TCHAR           tszPhysAddr[DISPLAYLEN_PHYSADDR + 1],
                    tszIpAddr[ADDR_LENGTH + 1];
    PTCHAR          ptszType;
    DWORD           i, dwErr = NO_ERROR;
    
    DisplayMessageToConsole(g_hModule, g_hConsole,MSG_MIB_IP_NET_HDR);
    
    if(lprpcTable->dwNumEntries is 0)
    {
        DisplayMessageToConsole(g_hModule, g_hConsole,MSG_IP_NO_ENTRIES);
        return;
    }
    
    for(i = 0; i < lprpcTable->dwNumEntries; i++)
    {
        DWORD BufLen;
        
        switch(lprpcTable->table[i].dwType)
        {
            case MIB_IPNET_TYPE_INVALID:
            {
                ptszType = MakeString(g_hModule, STRING_INVALID);
                break;
            }
            case MIB_IPNET_TYPE_DYNAMIC:
            {
                ptszType = MakeString(g_hModule, STRING_DYNAMIC);
                break;
            }
            case MIB_IPNET_TYPE_STATIC:
            {
                ptszType = MakeString(g_hModule, STRING_STATIC);
                break;
            }
            case MIB_IPNET_TYPE_OTHER:
            default:
            {
                ptszType = MakeString(g_hModule, STRING_OTHER);
                break;
            }
        }
    
        MakeUnicodeIpAddr(tszIpAddr, 
                          inet_ntoa(*((struct in_addr *)
                                      (&lprpcTable->table[i].dwAddr))));
        
        MakeUnicodePhysAddr(tszPhysAddr,
                            lprpcTable->table[i].bPhysAddr,
                            lprpcTable->table[i].dwPhysAddrLen);

        BufLen = sizeof(wszFriendlyName);
        dwErr = IfutlGetFriendlyNameFromIfIndex( hMibServer,
                                            lprpcTable->table[i].dwIndex,
                                            wszFriendlyName,//in bytes. not chars
                                            BufLen);

        if (dwErr != NO_ERROR) {
            wcscpy(wszFriendlyName, L"?");
        }

        DisplayMessageToConsole(g_hModule, g_hConsole,MSG_MIB_IP_NET_ENTRY,
                       wszFriendlyName,
                       tszPhysAddr,
                       tszIpAddr,
                       ptszType);
        
        FreeString(ptszType);
    }
}

VOID 
PrintIpNetRow(
    MIB_SERVER_HANDLE hMibServer,
    PMIB_OPAQUE_INFO prpcInfo
    )
/*++

Routine Description:

    Prints IP net row information.

Arguments:

Return Value:

--*/
{
    WCHAR         wszFriendlyName[MAX_INTERFACE_NAME_LEN + 1];
    PMIB_IPNETROW inmeRow = (PMIB_IPNETROW)(prpcInfo->rgbyData);
    TCHAR         tszPhysAddr[DISPLAYLEN_PHYSADDR + 1],
                  tszIpAddr[ADDR_LENGTH + 1];
    PTCHAR        ptszType;
    DWORD         dwErr = NO_ERROR;
    DWORD         BufLen;
    
    switch(inmeRow->dwType)
    {
        case MIB_IPNET_TYPE_INVALID:
        {
            ptszType = MakeString(g_hModule, STRING_INVALID);
            break;
        }
        case MIB_IPNET_TYPE_DYNAMIC:
        {
            ptszType = MakeString(g_hModule, STRING_DYNAMIC);
            break;
        }
        case MIB_IPNET_TYPE_STATIC:
        {
            ptszType = MakeString(g_hModule, STRING_STATIC);
            break;
        }
        case MIB_IPNET_TYPE_OTHER:
        default:
        {
            ptszType = MakeString(g_hModule, STRING_OTHER);
            break;
        }
    }
    
    MakeUnicodeIpAddr(tszIpAddr,
                      inet_ntoa(*((struct in_addr *)(&inmeRow->dwAddr))));
    
    MakeUnicodePhysAddr(tszPhysAddr,inmeRow->bPhysAddr,inmeRow->dwPhysAddrLen);

    BufLen = sizeof(wszFriendlyName);
    dwErr = IfutlGetFriendlyNameFromIfIndex( hMibServer,
                                        inmeRow->dwIndex,
                                        wszFriendlyName,
                                        BufLen);//in bytes. not chars
    
    DisplayMessageToConsole(g_hModule, g_hConsole,MSG_MIB_IP_NET_HDR);
    
    DisplayMessageToConsole(g_hModule, g_hConsole,MSG_MIB_IP_NET_ENTRY,
                   wszFriendlyName,
                   tszPhysAddr,
                   tszIpAddr,
                   ptszType);
        
    
    FreeString(ptszType);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\if\strdefs.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:


Abstract:

    NOTE - DONT USE 15000-15999

Author:

    Amritansh Raghav  01/25/1996

Revision History:


--*/

#ifndef __STRDEFS_H__
#define __STRDEFS_H__

#define MSG_NULL                                1001

#define HLP_IF_DUMP                             2501
#define HLP_IF_DUMP_EX                          2502
#define HLP_DUMP                                HLP_IF_DUMP
#define HLP_DUMP_EX                             HLP_IF_DUMP_EX

#define HLP_HELP                                2601
#define HLP_HELP_EX                             2602
#define HLP_IF_HELP1                            HLP_HELP
#define HLP_IF_HELP1_EX                         HLP_HELP_EX
#define HLP_IF_HELP2                            HLP_HELP
#define HLP_IF_HELP2_EX                         HLP_HELP_EX
#define HLP_HELP1                               HLP_HELP
#define HLP_HELP1_EX                            HLP_HELP_EX
#define HLP_HELP2                               HLP_HELP
#define HLP_HELP2_EX                            HLP_HELP_EX


#define HLP_IF_ADD_IF                           3101
#define HLP_IF_ADD_IF_EX                        3102

#define HLP_IF_DEL_IF                           3201
#define HLP_IF_DEL_IF_EX                        3202

#define HLP_IF_SET_CREDENTIALS                  3301
#define HLP_IF_SET_CREDENTIALS_EX               3302

#define HLP_IF_SHOW_IF                          3401
#define HLP_IF_SHOW_IF_EX                       3402

#define HLP_IF_SHOW_CREDENTIALS                 3450
#define HLP_IF_SHOW_CREDENTIALS_EX              3451

#define HLP_IF_SET_INTERFACE                    3500
#define HLP_IF_SET_INTERFACE_EX                 3501

#define HLP_IF_RESET_ALL                        3550
#define HLP_IF_RESET_ALL_EX                     3551

#define HLP_GROUP_ADD                           3901
#define HLP_GROUP_DELETE                        3903
#define HLP_GROUP_SET                           3905
#define HLP_GROUP_SHOW                          3907
#define HLP_GROUP_RESET                         3908

    // ifip
#define HLP_IFIP_SHOW_CONFIG                    4001
#define HLP_IFIP_SHOW_CONFIG_EX                 4002
#define HLP_IFIP_ADD_IPADDR                     4003
#define HLP_IFIP_ADD_IPADDR_EX                  4004
#define HLP_IFIP_SET_IPADDR                     4005
#define HLP_IFIP_SET_IPADDR_EX                  4006
#define HLP_IFIP_DEL_IPADDR                     4007
#define HLP_IFIP_DEL_IPADDR_EX                  4008
#define HLP_IFIP_SHOW_IPADDR                    4009
#define HLP_IFIP_SHOW_IPADDR_EX                 4010


#define HLP_IFIP_ADD_DNS                        4011
#define HLP_IFIP_ADD_DNS_EX                     4012
#define HLP_IFIP_SET_DNS                        4013
#define HLP_IFIP_SET_DNS_EX                     4014
#define HLP_IFIP_DEL_DNS                        4015
#define HLP_IFIP_DEL_DNS_EX                     4016
#define HLP_IFIP_SHOW_DNS                       4017
#define HLP_IFIP_SHOW_DNS_EX                    4018


#define HLP_IFIP_ADD_WINS                       4021
#define HLP_IFIP_ADD_WINS_EX                    4022
#define HLP_IFIP_SET_WINS                       4023
#define HLP_IFIP_SET_WINS_EX                    4024
#define HLP_IFIP_DEL_WINS                       4025
#define HLP_IFIP_DEL_WINS_EX                    4026
#define HLP_IFIP_SHOW_WINS                      4027
#define HLP_IFIP_SHOW_WINS_EX                   4028


    // ifip offload
#define HLP_IFIP_SHOW_OFFLOAD                   4031
#define HLP_IFIP_SHOW_OFFLOAD_EX                4032

#define HLP_IFIP_DEL_ARPCACHE                   4040
#define HLP_IFIP_DEL_ARPCACHE_EX                4041

#define HLP_IFIP_RESET                          4050
#define HLP_IFIP_RESET_EX                       4051

#define HLP_IPMIB_SHOW_IPSTATS                  9300
#define HLP_IPMIB_SHOW_IPSTATS_EX               9301
#define HLP_IPMIB_SHOW_IPADDRESS                9302
#define HLP_IPMIB_SHOW_IPADDRESS_EX             9303
#define HLP_IPMIB_SHOW_IPFORWARD                9304
#define HLP_IPMIB_SHOW_IPFORWARD_EX             9305
#define HLP_IPMIB_SHOW_TCPSTATS                 9306
#define HLP_IPMIB_SHOW_TCPSTATS_EX              9307
#define HLP_IPMIB_SHOW_TCPCONN                  9308
#define HLP_IPMIB_SHOW_TCPCONN_EX               9309
#define HLP_IPMIB_SHOW_UDPSTATS                 9310
#define HLP_IPMIB_SHOW_UDPSTATS_EX              9311
#define HLP_IPMIB_SHOW_UDPCONN                  9312
#define HLP_IPMIB_SHOW_UDPCONN_EX               9313
#define HLP_IPMIB_SHOW_JOINS                    9314
#define HLP_IPMIB_SHOW_JOINS_EX                 9315
#define HLP_IPMIB_SHOW_IPNET                    9322
#define HLP_IPMIB_SHOW_IPNET_EX                 9323
#define HLP_IPMIB_SHOW_ICMP                     9324
#define HLP_IPMIB_SHOW_ICMP_EX                  9325
#define HLP_IPMIB_SHOW_INTERFACE                9328
#define HLP_IPMIB_SHOW_INTERFACE_EX             9329

//
// STRING_Xxx are used to display configuration etc.
// These should generally be lower case, first letter capitalized
//

#define STRING_ENABLED                          9001
#define STRING_DISABLED                         9002
#define STRING_CONNECTED                        9003
#define STRING_DISCONNECTED                     9004
#define STRING_CONNECTING                       9005
#define STRING_CLIENT                           9006
#define STRING_HOME_ROUTER                      9007
#define STRING_FULL_ROUTER                      9008
#define STRING_DEDICATED                        9009
#define STRING_INTERNAL                         9010
#define STRING_LOOPBACK                         9011
#define STRING_PRIMARY                          9012
#define STRING_BOTH                             9013
#define STRING_NONE                             9014

#define STRING_OTHER                            30001
#define STRING_ETHERNET                         30002
#define STRING_TOKENRING                        30003
#define STRING_FDDI                             30004
#define STRING_PPP                              30005
#define STRING_SLIP                             30007

#define STRING_STATIC                           33020
#define STRING_INVALID                          34002

    // interface status
#define STRING_UP                               36001
#define STRING_DOWN                             36002
#define STRING_TESTING                          36003

#define STRING_NON_OPERATIONAL                  36051
#define STRING_UNREACHABLE                      36052
#define STRING_OPERATIONAL                      36056    // interface status

    // TCP constants
#define STRING_CONSTANT                         31002
#define STRING_RSRE                             31003
#define STRING_VANJ                             31004

    // TCP states
#define STRING_CLOSED                           32001
#define STRING_LISTEN                           32002
#define STRING_SYN_SENT                         32003
#define STRING_SYN_RCVD                         32004
#define STRING_ESTAB                            32005
#define STRING_FIN_WAIT1                        32006
#define STRING_FIN_WAIT2                        32007
#define STRING_CLOSE_WAIT                       32008
#define STRING_CLOSING                          32009
#define STRING_LAST_ACK                         32010
#define STRING_TIME_WAIT                        32011
#define STRING_DELETE_TCB                       32012
#define STRING_DYNAMIC                          32013

#define EMSG_NO_PHONEBOOK                       11001
#define EMSG_BAD_OPTION_VALUE                   11004
#define EMSG_CANT_CREATE_IF                     11006
#define EMSG_CAN_NOT_CONNECT_DIM                11011
#define EMSG_BAD_IF_TYPE                        11012
#define EMSG_IF_ALREADY_EXISTS                  11013
#define EMSG_CANT_FIND_EOPT                     11014
#define EMSG_IF_BAD_CREDENTIALS_TYPE            11015
#define EMSG_IF_CONNECT_ONLY_WHEN_ROUTER_RUNNING 11016
#define EMSG_IF_WAN_ONLY_COMMAND                11017
#define EMSG_IF_LAN_ONLY_COMMAND                11018
#define EMSG_IF_NEWNAME_ONLY_FOR_LAN            11019
#define EMSG_IF_NEWNAME_ONLY_FOR_LOCAL          11020
#define EMSG_COULD_NOT_GET_IPADDRESS            11021

// error messages for IfIp
#define EMSG_IPADDR_PRESENT                     11031
#define EMSG_DHCP_MODE                          11032
#define EMSG_DEFGATEWAY_PRESENT                 11033
#define EMSG_STATIC_INPUT                       11035
#define EMSG_DHCP_DELETEADDR                    11036
#define EMSG_ADDRESS_NOT_PRESENT                11037
#define EMSG_MIN_ONE_ADDR                       11038
#define EMSG_GATEWAY_NOT_PRESENT                11039
#define EMSG_ADD_IPADDR_DHCP                    11040
#define EMSG_PROPERTIES                         11041
#define EMSG_SERVER_PRESENT                     11042
#define EMSG_SERVER_ABSENT                      11043
#define EMSG_INVALID_INTERFACE                  11044
#define EMSG_NETCFG_WRITE_LOCK                  11045
#define EMSG_OPEN_APPEND                        11046

#define DMP_IF_HEADER_COMMENTS                  20001
#define DMP_IF_FOOTER_COMMENTS                  20002

#define MSG_MIB_IF_HDR                          21002
#define MSG_MIB_INTERFACE                       21003
#define MSG_MIB_IP_STATS                        21004
#define MSG_MIB_IP_ADDR_HDR                     21005
#define MSG_MIB_IP_ADDR_ENTRY                   21006
#define MSG_MIB_IP_NET_HDR                      21009
#define MSG_MIB_IP_NET_ENTRY                    21010
#define MSG_MIB_ICMP                            21011
#define MSG_MIB_UDP_STATS                       21012
#define MSG_MIB_UDP_ENTRY_HDR                   21013
#define MSG_MIB_UDP_ENTRY                       21014
#define MSG_MIB_TCP_STATS                       21015
#define MSG_MIB_TCP_ENTRY_HDR                   21016
#define MSG_MIB_TCP_ENTRY                       21017
#define MSG_MIB_JOIN_HDR                        21059
#define MSG_MIB_JOIN_ROW                        21060

#define MSG_IF_TABLE_HDR                        50001
#define MSG_IF_ENTRY_LONG                       50002
#define MSG_IF_CREDENTIALS                      50003
#define MSG_IF_ENTRY_SHORT                      50004


// msgs for ifip

#define MSG_DHCP                                50021
#define MSG_STATIC                              50022
#define MSG_IPADDR_LIST                         50023
#define MSG_IPADDR_LIST1                        50024
#define MSG_IFIP_HEADER                         50025
#define MSG_OPTIONS_LIST                        50026
#define MSG_IFMETRIC                            50028
#define MSG_GATEWAY                             50030
#define MSG_DNS_HDR                             50031
#define MSG_DNS_DHCP                            50032
#define MSG_WINS_HDR                            50033
#define MSG_WINS_DHCP                           50034
#define MSG_ADDR1                               50035
#define MSG_ADDR2                               50036
#define MSG_OPTION                              50037
#define MSG_NONE                                50038
#define MSG_DEBUG_HDR                           50039
#define MSG_DNS_DHCP_HDR                        50040
#define MSG_WINS_DHCP_HDR                       50041
#define DMP_IFIP_HEADER                         50051
#define DMP_IFIP_FOOTER                         50052
#define DMP_IFIP_INTERFACE_HEADER               50053
#define MSG_DDNS_SUFFIX                         50054


// Capability Flags

#define MSG_OFFLOAD_HDR                         50100
#define MSG_TCP_XMT_CHECKSUM_OFFLOAD            50101
#define MSG_IP_XMT_CHECKSUM_OFFLOAD             50102
#define MSG_TCP_RCV_CHECKSUM_OFFLOAD            50103
#define MSG_IP_RCV_CHECKSUM_OFFLOAD             50104
#define MSG_TCP_LARGE_SEND_OFFLOAD              50105


// IPSEC General Xmit\Recv capabilities

#define MSG_IPSEC_OFFLOAD_CRYPTO_ONLY           50111
#define MSG_IPSEC_OFFLOAD_AH_ESP                50112
#define MSG_IPSEC_OFFLOAD_TPT_TUNNEL            50113
#define MSG_IPSEC_OFFLOAD_V4_OPTIONS            50114
#define MSG_IPSEC_OFFLOAD_QUERY_SPI             50115


// IPSEC AH Xmit\Recv capabilities

#define MSG_IPSEC_OFFLOAD_AH_XMT                50121
#define MSG_IPSEC_OFFLOAD_AH_RCV                50122
#define MSG_IPSEC_OFFLOAD_AH_TPT                50123
#define MSG_IPSEC_OFFLOAD_AH_TUNNEL             50124
#define MSG_IPSEC_OFFLOAD_AH_MD5                50125
#define MSG_IPSEC_OFFLOAD_AH_SHA_1              50126

// IPSEC ESP Xmit\Recv capabilities

#define MSG_IPSEC_OFFLOAD_ESP_XMT               50131
#define MSG_IPSEC_OFFLOAD_ESP_RCV               50132
#define MSG_IPSEC_OFFLOAD_ESP_TPT               50133
#define MSG_IPSEC_OFFLOAD_ESP_TUNNEL            50134
#define MSG_IPSEC_OFFLOAD_ESP_DES               50135
#define MSG_IPSEC_OFFLOAD_ESP_DES_40            50136
#define MSG_IPSEC_OFFLOAD_ESP_3_DES             50137
#define MSG_IPSEC_OFFLOAD_ESP_NONE              50138


#define MSG_IP_DIM_ERROR                        60005
#define MSG_NO_SUCH_IF                          60006
#define MSG_IP_LOCAL_ROUTER_NOT_RUNNING         60011
#define MSG_IP_REMOTE_ROUTER_NOT_RUNNING        60013
#define MSG_IP_NO_ENTRIES                       60015
#define MSG_IP_NOT_ENOUGH_MEMORY                60024
#define MSG_CTRL_C_TO_QUIT                      60062

#endif //__STDEFS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\if\utils.c ===
#include "precomp.h"

BOOL    g_bRouterRunning;
ULONG   g_ulNumChecks;

VOID
IfutlGetInterfaceName(
    IN  PWCHAR pwszIfDesc,
    OUT PWCHAR pwszIfName,
    IN  PDWORD pdwSize
    )
/*++

Routine Description:

    Gets Guid Interface Name from Friendly Interface Name

Arguments:

    pwszIfDesc      - Buffer holding Friendly Interace Name
    pwszIfName      - Buffer to hold the Guid Interface Name
    pdwSize         - Pointer to the size (in Bytes) of pwszIfName buffer

--*/
{
    DWORD   dwErr;

    dwErr = GetIfNameFromFriendlyName(pwszIfDesc,
                                      pwszIfName,
                                      pdwSize);

    if(dwErr isnot NO_ERROR)
    {
        wcsncpy(pwszIfName,
                pwszIfDesc,
                (*pdwSize)/sizeof(WCHAR));
    }

}

VOID
IfutlGetInterfaceDescription(
    IN  PWCHAR pwszIfName,
    OUT PWCHAR pwszIfDesc,
    IN  PDWORD pdwSize
    )
/*++

Routine Description:

    Gets Friendly Interface Name from Guid Interface Name

Arguments:

    pwszIfName      - Buffer holding Guid Interace Name
    pwszIfDesc      - Buffer to hold the Friendly Interface Name
    pdwSize         - Pointer to the size (in Bytes) of pwszIfDesc buffer

--*/

{
    DWORD   dwErr;
    DWORD   dwLen = (*pdwSize)/sizeof(WCHAR) - 1;

    dwErr = GetFriendlyNameFromIfName(pwszIfName,
                                      pwszIfDesc,
                                      pdwSize);

    if(dwErr isnot NO_ERROR)
    {
        wcsncpy(pwszIfDesc,
                pwszIfName,
                dwLen);
        pwszIfDesc[dwLen] = 0;
    }
}

DWORD
IfutlGetTagToken(
    IN  HANDLE      hModule,
    IN  PWCHAR      *ppwcArguments,
    IN  DWORD       dwCurrentIndex,
    IN  DWORD       dwArgCount,
    IN  PTAG_TYPE   pttTagToken,
    IN  DWORD       dwNumTags,
    OUT PDWORD      pdwOut
    )

/*++

Routine Description:

    Identifies each argument based on its tag. It assumes that each argument
    has a tag. It also removes tag= from each argument.

Arguments:

    ppwcArguments  - The argument array. Each argument has tag=value form
    dwCurrentIndex - ppwcArguments[dwCurrentIndex] is first arg.
    dwArgCount     - ppwcArguments[dwArgCount - 1] is last arg.
    pttTagToken    - Array of tag token ids that are allowed in the args
    dwNumTags      - Size of pttTagToken
    pdwOut         - Array identifying the type of each argument.

Return Value:

    NO_ERROR, ERROR_INVALID_PARAMETER, ERROR_INVALID_OPTION_TAG

--*/

{
    DWORD      i,j,len;
    PWCHAR     pwcTag,pwcTagVal,pwszArg;
    BOOL       bFound = FALSE;

    //
    // This function assumes that every argument has a tag
    // It goes ahead and removes the tag.
    //

    for (i = dwCurrentIndex; i < dwArgCount; i++)
    {
        len = wcslen(ppwcArguments[i]);

        if (len is 0)
        {
            //
            // something wrong with arg
            //

            pdwOut[i] = (DWORD) -1;
            continue;
        }

        pwszArg = HeapAlloc(GetProcessHeap(),0,(len + 1) * sizeof(WCHAR));

        if (pwszArg is NULL)
        {
            DisplayError(NULL, 
                         ERROR_NOT_ENOUGH_MEMORY);

            return ERROR_NOT_ENOUGH_MEMORY;
        }

        wcscpy(pwszArg, ppwcArguments[i]);

        pwcTag = wcstok(pwszArg, NETSH_ARG_DELIMITER);

        //
        // Got the first part
        // Now if next call returns NULL then there was no tag
        //

        pwcTagVal = wcstok((PWCHAR)NULL,  NETSH_ARG_DELIMITER);

        if (pwcTagVal is NULL)
        {
            DisplayMessage(g_hModule, 
                           ERROR_NO_TAG,
                           ppwcArguments[i]);

            HeapFree(GetProcessHeap(),0,pwszArg);

            return ERROR_INVALID_PARAMETER;
        }

        //
        // Got the tag. Now try to match it
        //

        bFound = FALSE;
        pdwOut[i - dwCurrentIndex] = (DWORD) -1;

        for ( j = 0; j < dwNumTags; j++)
        {
            if (MatchToken(pwcTag, pttTagToken[j].pwszTag))
            {
                //
                // Tag matched
                //

                bFound = TRUE;
                pdwOut[i - dwCurrentIndex] = j;
                break;
            }
        }

        if (bFound)
        {
            //
            // Remove tag from the argument
            //

            wcscpy(ppwcArguments[i], pwcTagVal);
        }
        else
        {
            DisplayError(NULL,
                         ERROR_INVALID_OPTION_TAG, 
                         pwcTag);

            HeapFree(GetProcessHeap(),0,pwszArg);

            return ERROR_INVALID_OPTION_TAG;
        }

        HeapFree(GetProcessHeap(),0,pwszArg);
    }

    return NO_ERROR;
}

//
// Helper to IfutlParse that parses options
//
DWORD 
WINAPI
IfutlParseOptions(
    IN  PWCHAR*                 ppwcArguments,
    IN  DWORD                   dwCurrentIndex,
    IN  DWORD                   dwArgCount,
    IN  DWORD                   dwNumArgs,
    IN  TAG_TYPE*               rgTags,
    IN  DWORD                   dwTagCount,
    OUT LPDWORD*                ppdwTagTypes)

/*++

Routine Description:

    Based on an array of tag types returns which options are
    included in the given command line.

Arguments:

    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg

Return Value:

    NO_ERROR

--*/
    
{
    LPDWORD     pdwTagType;
    DWORD       i, dwErr = NO_ERROR;
    
    // If there are no arguments, there's nothing to to
    //
    if ( dwNumArgs == 0 )
    {   
        return NO_ERROR;
    }

    // Set up the table of present options
    pdwTagType = (LPDWORD) IfutlAlloc(dwArgCount * sizeof(DWORD), TRUE);
    if(pdwTagType is NULL)
    {
        DisplayError(NULL, ERROR_NOT_ENOUGH_MEMORY);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    do {
        //
        // The argument has a tag. Assume all of them have tags
        //
        if(wcsstr(ppwcArguments[dwCurrentIndex], NETSH_ARG_DELIMITER))
        {
            dwErr = IfutlGetTagToken(
                        g_hModule, 
                        ppwcArguments,
                        dwCurrentIndex,
                        dwArgCount,
                        rgTags,
                        dwTagCount,
                        pdwTagType);

            if(dwErr isnot NO_ERROR)
            {
                if(dwErr is ERROR_INVALID_OPTION_TAG)
                {
                    dwErr = ERROR_INVALID_SYNTAX;
                    break;
                }
            }
        }
        else
        {
            //
            // No tags - all args must be in order
            //
            for(i = 0; i < dwNumArgs; i++)
            {
                pdwTagType[i] = i;
            }
        }
        
    } while (FALSE);        

    // Cleanup
    {
        if (dwErr is NO_ERROR)
        {
            *ppdwTagTypes = pdwTagType;
        }
        else
        {
            IfutlFree(pdwTagType);
        }
    }

    return dwErr;
}


//
// Generic parse
//
DWORD
IfutlParse(
    IN  PWCHAR*         ppwcArguments,
    IN  DWORD           dwCurrentIndex,
    IN  DWORD           dwArgCount,
    IN  BOOL*           pbDone,
    OUT IFMON_CMD_ARG*  pIfArgs,
    IN  DWORD           dwIfArgCount)
{
    DWORD            i, dwNumArgs, dwErr, dwLevel = 0;
    LPDWORD          pdwTagType = NULL;
    TAG_TYPE*        pTags = NULL;
    IFMON_CMD_ARG*   pArg = NULL;

    if (dwIfArgCount == 0)
    {
        return ERROR_INVALID_PARAMETER;
    }

    do {
        // Initialize
        dwNumArgs = dwArgCount - dwCurrentIndex;
        
        // Generate a list of the tags
        //
        pTags = (TAG_TYPE*)
            IfutlAlloc(dwIfArgCount * sizeof(TAG_TYPE), TRUE);
        if (pTags == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }
        for (i = 0; i < dwIfArgCount; i++)
        {
            CopyMemory(&pTags[i], &pIfArgs[i].rgTag, sizeof(TAG_TYPE));
        }
    
        // Get the list of present options
        //
        dwErr = IfutlParseOptions(
                    ppwcArguments,
                    dwCurrentIndex,
                    dwArgCount,
                    dwNumArgs,
                    pTags,
                    dwIfArgCount,
                    &pdwTagType);
        if (dwErr isnot NO_ERROR)
        {
            break;
        }

        // Copy the tag info back
        //
        for (i = 0; i < dwIfArgCount; i++)
        {
            CopyMemory(&pIfArgs[i].rgTag, &pTags[i], sizeof(TAG_TYPE));
        }
    
        for(i = 0; i < dwNumArgs; i++)
        {
            // Validate the current argument
            //
            if (pdwTagType[i] >= dwIfArgCount)
            {
                i = dwNumArgs;
                dwErr = ERROR_INVALID_SYNTAX;
                break;
            }
            pArg = &pIfArgs[pdwTagType[i]];

            // Get the value of the argument
            //
            switch (pArg->dwType)
            {
                case IFMON_CMD_TYPE_STRING:
                    pArg->Val.pszValue = 
                        IfutlStrDup(ppwcArguments[i + dwCurrentIndex]);
                    break;
                    
                case IFMON_CMD_TYPE_ENUM:
                    dwErr = MatchEnumTag(g_hModule,
                                         ppwcArguments[i + dwCurrentIndex],
                                         pArg->dwEnumCount,
                                         pArg->rgEnums,
                                         &(pArg->Val.dwValue));

                    if(dwErr != NO_ERROR)
                    {
                        IfutlDispTokenErrMsg(
                            g_hModule, 
                            EMSG_BAD_OPTION_VALUE,
                            pArg->rgTag.pwszTag,
                            ppwcArguments[i + dwCurrentIndex]);
                        i = dwNumArgs;
                        dwErr = ERROR_INVALID_PARAMETER;
                    }
                    break;
            }
            if (dwErr != NO_ERROR)
            {
                break;
            }

            // Mark the argument as present if needed
            //
            if (pArg->rgTag.bPresent)
            {
                dwErr = ERROR_TAG_ALREADY_PRESENT;
                i = dwNumArgs;
                break;
            }
            pArg->rgTag.bPresent = TRUE;
        }
        if(dwErr isnot NO_ERROR)
        {
            break;
        }

        // Make sure that all of the required parameters have
        // been included.
        //
        for (i = 0; i < dwIfArgCount; i++)
        {
            if ((pIfArgs[i].rgTag.dwRequired & NS_REQ_PRESENT) 
             && !pIfArgs[i].rgTag.bPresent)
            {
                DisplayMessage(g_hModule, EMSG_CANT_FIND_EOPT);
                dwErr = ERROR_INVALID_SYNTAX;
                break;
            }
        }
        if(dwErr isnot NO_ERROR)
        {
            break;
        }

    } while (FALSE);  
    
    // Cleanup
    {
        if (pTags)
        {
            IfutlFree(pTags);
        }
        if (pdwTagType)
        {
            IfutlFree(pdwTagType);
        }
    }

    return dwErr;
    
}

//
// Returns an allocated block of memory conditionally
// zeroed of the given size.
//
PVOID 
WINAPI
IfutlAlloc(
    IN DWORD dwBytes,
    IN BOOL bZero
    )
{
    PVOID pvRet;
    DWORD dwFlags = 0;

    if (bZero)
    {
        dwFlags |= HEAP_ZERO_MEMORY;
    }

    return HeapAlloc(GetProcessHeap(), dwFlags, dwBytes);
}

//
// Conditionally free's a pointer if it is non-null
//
VOID 
WINAPI
IfutlFree(
    IN PVOID pvData
    )
{
    if (pvData)
    {
        HeapFree(GetProcessHeap(), 0, pvData);
    }        
}

// 
// Uses IfutlAlloc to copy a string
//
PWCHAR
WINAPI
IfutlStrDup(
    IN LPCWSTR pwszSrc
    )
{
    PWCHAR pszRet = NULL;
    DWORD dwLen; 
    
    if ((pwszSrc is NULL) or
        ((dwLen = wcslen(pwszSrc)) == 0)
       )
    {
        return NULL;
    }

    pszRet = (PWCHAR) IfutlAlloc((dwLen + 1) * sizeof(WCHAR), FALSE);
    if (pszRet isnot NULL)
    {
        wcscpy(pszRet, pwszSrc);
    }

    return pszRet;
}

BOOL
IfutlIsRouterRunning(
    VOID
    )

/*++

Routine Description:

    Gets the status of the router

Arguments:


Return Value:


--*/

{
    DWORD   dwErr;

    //
    // Check every 5th call
    //

    if(g_ulNumChecks isnot 0)
    {
        return g_bRouterRunning;
    }

    g_ulNumChecks++;

    g_ulNumChecks %= 5;

    if(MprAdminIsServiceRunning(g_pwszRouter))
    {
        if(g_bRouterRunning)
        {
            return TRUE;
        }

        dwErr = MprAdminServerConnect(g_pwszRouter,
                                      &g_hMprAdmin);

        if(dwErr isnot NO_ERROR)
        {
            DisplayError(NULL,
                         dwErr);

            DisplayMessage(g_hModule,
                           EMSG_CAN_NOT_CONNECT_DIM,
                           dwErr);

            return FALSE;
        }

        dwErr = MprAdminMIBServerConnect(g_pwszRouter,
                                         &g_hMIBServer);

        if(dwErr isnot NO_ERROR)
        {
            DisplayError(NULL,
                         dwErr);

            DisplayMessage(g_hModule,
                           EMSG_CAN_NOT_CONNECT_DIM,
                           dwErr);

            MprAdminServerDisconnect(g_hMprAdmin);

            g_hMprAdmin = NULL;

            return FALSE;
        }

        g_bRouterRunning = TRUE;
    }
    else
    {
        if(g_bRouterRunning)
        {
            g_bRouterRunning = FALSE;
            g_hMprAdmin      = NULL;
            g_hMIBServer     = NULL;
        }
    }

    return g_bRouterRunning;
}

DWORD
GetIpAddress(
    IN  PWCHAR        ppwcArg,
    OUT PIPV4_ADDRESS pipAddress
    )
/*++

Routine Description:

    Gets the ip address from the string.

Arguments:

    pwszIpAddr - Ip address string
    pipAddress - IP address

Return Value:

    NO_ERROR, ERROR_INVALID_PARAMETER

--*/
{
    CHAR     pszIpAddr[ADDR_LENGTH+1];

    // Make sure all characters are legal [0-9.]

    if (ppwcArg[ wcsspn(ppwcArg, L"0123456789.") ])
    {
        return ERROR_INVALID_PARAMETER;
    }

    // make sure there are 3 "." (periods)
    {
        DWORD i;
        PWCHAR TmpPtr;
        
        for (i=0,TmpPtr=ppwcArg;  ;  i++) {
            TmpPtr = wcschr(TmpPtr, L'.');
            if (TmpPtr)
                TmpPtr++;
            else
                break;
        }

        if (i!=3)
            return ERROR_INVALID_PARAMETER;
    }

     
    WideCharToMultiByte(GetConsoleOutputCP(),
                        0,
                        ppwcArg,
                        -1,
                        pszIpAddr,
                        ADDR_LENGTH,
                        NULL,
                        NULL);

    pszIpAddr[ADDR_LENGTH] = '\0';

    *pipAddress = (DWORD) inet_addr(pszIpAddr);

    // if there was an error, make sure that the address
    // specified was not 255.255.255.255
    
    if (*pipAddress == INADDR_NONE
        && wcscmp(ppwcArg,L"255.255.255.255"))
    {
        return ERROR_INVALID_PARAMETER;
    }

    if ((*pipAddress&0x000000FF) == 0)
        return ERROR_INVALID_PARAMETER;
        
    return NO_ERROR;
}



// NOTE: CheckMask fails when IpAddr is 0xffffffff!
BOOL
CheckMask(
    DWORD IpAddr
    )
{
    DWORD i,Mask;
    
    IpAddr = htonl(IpAddr);

    for (i=0,Mask=0;  i<32;  (Mask = ((Mask>>1) + 0x80000000)), i++ ) {
        if (IpAddr == Mask)
            return FALSE;
    }
    
    return TRUE;
}


DWORD
IfutlGetIfIndexFromFriendlyName(
    PWCHAR IfFriendlyName,
    PULONG pdwIfIndex
    )
{
    WCHAR wszGuid[200];
    DWORD dwSize = sizeof(wszGuid);
    

    IfutlGetInterfaceName(
                IfFriendlyName,
                wszGuid,
                &dwSize
                );

    return IfutlGetIfIndexFromInterfaceName(
                wszGuid,
                pdwIfIndex);
}

DWORD
IfutlGetIfIndexFromInterfaceName(
    IN  PWCHAR            pwszGuid,
    OUT PDWORD            pdwIfIndex
    )
{
    GUID guid;
    DWORD dwErr, i, dwCount;
    PIP_INTERFACE_NAME_INFO pTable;
    BOOL bFound = FALSE;
    PWCHAR TmpGuid;
    
    *pdwIfIndex = 0;
    
    dwErr = NhpAllocateAndGetInterfaceInfoFromStack(
                &pTable,
                &dwCount,
                FALSE,
                GetProcessHeap(),
                0);

    if (dwErr != NO_ERROR)
        return dwErr;

    for (i=0;  i<dwCount;  i++) {

        dwErr = StringFromCLSID(&pTable[i].DeviceGuid, &TmpGuid);
        if (dwErr != S_OK)
            return dwErr;

        
        if (wcscmp(TmpGuid, pwszGuid) == 0) {
            bFound = TRUE;
            *pdwIfIndex = pTable[i].Index;
            break;
        }

        CoTaskMemFree(TmpGuid);
    }

    if (!bFound)
        return ERROR_CAN_NOT_COMPLETE;

    return NO_ERROR;
}

DWORD
WINAPI
InterfaceEnum(
    OUT    PBYTE               *ppb,
    OUT    PDWORD              pdwCount,
    OUT    PDWORD              pdwTotal
    )
{
    DWORD               dwRes;
    PMPR_INTERFACE_0    pmi0;

    /*if(!IsRouterRunning())*/
    {
    
        dwRes = MprConfigInterfaceEnum(g_hMprConfig,
                                       0,
                                       (LPBYTE*) &pmi0,
                                       (DWORD) -1,
                                       pdwCount,
                                       pdwTotal,
                                       NULL);

        if(dwRes == NO_ERROR)
        {
            *ppb = (PBYTE)pmi0;
        }
    }
    /*else
    {
        dwRes = MprAdminInterfaceEnum(g_hMprAdmin,
                                      0,
                                      (LPBYTE*) &pmi0,
                                      (DWORD) -1,
                                      pdwCount,
                                      pdwTotal,
                                      NULL);


        if(dwRes == NO_ERROR)
        {
            *ppb = HeapAlloc(GetProcessHeap(),
                             0,
                             sizeof(MPR_INTERFACE_0) * (*pdwCount));


            if(*ppb == NULL)
            {
                DisplayMessage(g_hModule, MSG_IP_NOT_ENOUGH_MEMORY);

                return ERROR_NOT_ENOUGH_MEMORY;
            }

            CopyMemory(*ppb, pmi0, sizeof(MPR_INTERFACE_0) * (*pdwCount));

            MprAdminBufferFree(pmi0);

        }
    }*/

    return dwRes;
}

VOID
MakeAddressStringW(
    OUT PWCHAR       pwcPrefixStr,
    IN  IPV4_ADDRESS ipAddr
    )
{
    swprintf( pwcPrefixStr,
              L"%d.%d.%d.%d",
              PRINT_IPADDR(ipAddr) );
}

DWORD
GetGuidFromIfIndex(
    IN  MIB_SERVER_HANDLE hMibServer,
    IN  DWORD             dwIfIndex,
    OUT PWCHAR            pwszBuffer,
    IN  DWORD             dwBufferSize
    )
{
    MIB_OPAQUE_QUERY  Query;
    PMIB_IFROW        pIfRow;
    DWORD             dwErr, dwOutEntrySize;
    PMIB_OPAQUE_INFO  pRpcInfo;

    Query.dwVarId         = IF_ROW;
    Query.rgdwVarIndex[0] = dwIfIndex;

    dwErr = MibGet(             PID_IP,
                                IPRTRMGR_PID,
                                (PVOID) &Query,
                                sizeof(Query),
                                (PVOID *) &pRpcInfo,
                                &dwOutEntrySize );

    if (dwErr isnot NO_ERROR)
    {
        return dwErr;
    }

    pIfRow = (PMIB_IFROW)(pRpcInfo->rgbyData);

    wcscpy( pwszBuffer, pIfRow->wszName );

    MprAdminMIBBufferFree( (PVOID) pRpcInfo );

    return NO_ERROR;
}

DWORD
IfutlGetFriendlyNameFromIfIndex(
    IN  MIB_SERVER_HANDLE hMibServer,
    IN  DWORD             dwIfIndex,
    OUT PWCHAR            pwszBuffer,
    IN  DWORD             dwBufferSize
    )
/*++

Routine Description:

    Gets Friendly Interface Name from Interface Index

Arguments:

    hMibServer      - Handle to the MIB server
    dwIfIndex       - Interface index
    pwszBuffer      - Buffer to hold the Friendly Interface Name
    dwBufferSize    - Size (in Bytes) of pwszBuffer buffer

--*/
{
    WCHAR        wszGuid[MAX_INTERFACE_NAME_LEN + 1];
    DWORD        dwErr, BufLen;

    BufLen = sizeof(wszGuid); //in bytes. not chars
    dwErr = GetGuidFromIfIndex(hMibServer, dwIfIndex, wszGuid, BufLen);

    if (dwErr isnot NO_ERROR)
    {
        return dwErr;
    }

    IfutlGetInterfaceDescription(wszGuid, pwszBuffer, &dwBufferSize);

    return NO_ERROR;
}

DWORD
GetMibTagToken(
    IN  PWCHAR  *ppwcArguments,
    IN  DWORD   dwArgCount,
    IN  DWORD   dwNumIndices,
    OUT PDWORD  pdwRR,
    OUT PBOOL   pbIndex,
    OUT PDWORD  pdwIndex
    )

/*++

Routine Description:

    Looks for indices and refresh rate arguments in the command. If index
    tag is present, it would be of the form index= index1 index2 ....
    The index= is removed by this function. So is rr= if it is there in
    the command. If pdwRR is 0 then, no refresh sought.

Arguments:

    ppwcArguments  - The argument array. Each argument has tag=value form
    dwCurrentIndex - ppwcArguments[dwCurrentIndex] is first arg.
    dwArgCount     - ppwcArguments[dwArgCount - 1] is last arg.
    pttTagToken    - Array of tag token ids that are allowed in the args
    dwNumTags      - Size of pttTagToken
    pdwOut         - Array identifying the type of each argument.

Return Value:

    NO_ERROR, ERROR_INVALID_PARAMETER, ERROR_INVALID_OPTION_TAG

--*/
{
    DWORD    i;
    BOOL     bTag;

    if (dwArgCount is 0)
    {
        *pdwRR = 0;
        *pbIndex = FALSE;

        return NO_ERROR;
    }

    if (dwArgCount < dwNumIndices)
    {
        //
        // No index
        //

        *pbIndex = FALSE;

        if (dwArgCount > 1)
        {
            *pdwRR = 0;

            return ERROR_INVALID_PARAMETER;
        }

        //
        // No Index specified. Make sure refresh rate is specified
        // with tag.
        //

        if (_wcsnicmp(ppwcArguments[0],L"RR=",3) == 0)
        {
            //
            // get the refresh rate
            //

            *pdwRR = wcstoul(&ppwcArguments[0][3], NULL, 10);
        }
        else
        {
            return ERROR_INVALID_PARAMETER;
        }
    }
    else
    {
        //
        // Check for index tag
        //

        if (_wcsnicmp(ppwcArguments[0],L"INDEX=",6) == 0)
        {
            *pbIndex = TRUE;
            *pdwIndex = 0;

            //
            // remove tag and see if refresh rate is specified
            //

            wcscpy(ppwcArguments[0], &ppwcArguments[0][6]);

            if (dwArgCount > dwNumIndices)
            {
                //
                // Make sure that argument has RR tag
                //

                if (_wcsnicmp(ppwcArguments[dwNumIndices],L"RR=",3) == 0)
                {
                    //
                    // get the refresh rate
                    //

                    *pdwRR = wcstoul(&ppwcArguments[dwNumIndices][3], NULL , 10);
                }
                else
                {
                    return ERROR_INVALID_PARAMETER;
                }
            }
            else
            {
                //
                // No refresh rate specified
                //

                *pdwRR = 0;
                return NO_ERROR;
            }
        }
        else
        {
            //
            // Not index tag, See if it has an RR tag
            //

            if (_wcsnicmp(ppwcArguments[0],L"RR=",3) == 0)
            {
                //
                // get the refresh rate
                //

                *pdwRR = wcstoul(&ppwcArguments[0][3], NULL , 10);

                //
                // See if the index follows
                //

                if (dwArgCount > dwNumIndices)
                {
                    if (dwArgCount > 1)
                    {
                        if (_wcsnicmp(ppwcArguments[1],L"INDEX=",6) == 0)
                        {
                            wcscpy(ppwcArguments[1], &ppwcArguments[1][6]);
                            *pbIndex = TRUE;
                            *pdwIndex = 1;

                            return NO_ERROR;
                        }
                        else
                        {
                            *pdwRR = 0;
                            return ERROR_INVALID_PARAMETER;
                        }
                    }
                    else
                    {
                        return NO_ERROR;
                    }
                }
            }
            //
            // No RR Tag either
            //
            else if (dwArgCount > dwNumIndices)
            {
                //
                // Assume ppwcArguments[dwNumIndices] is the refresh rate
                //

                *pdwRR = wcstoul(ppwcArguments[dwNumIndices], NULL , 10);

                if (dwNumIndices != 0)
                {
                    *pbIndex = TRUE;
                    *pdwIndex = 0;
                }
            }
            else
            {
                //
                // only index present with no tag
                //
                *pbIndex = TRUE;
                *pdwIndex = 0;
            }
        }
    }

    return NO_ERROR;
}

DWORD
MibGet(
    DWORD   dwTransportId,
    DWORD   dwRoutingPid,
    LPVOID  lpInEntry,
    DWORD   dwInEntrySize,
    LPVOID *lplpOutEntry,
    LPDWORD lpdwOutEntrySize
    )
{
    DWORD dwErr;

    dwErr = MprAdminMIBEntryGet( g_hMIBServer,
                                 dwTransportId,
                                 dwRoutingPid,
                                 lpInEntry,
                                 dwInEntrySize,
                                 lplpOutEntry,
                                 lpdwOutEntrySize );

    if (dwErr is RPC_S_INVALID_BINDING)
    {
        g_bRouterRunning = FALSE;
        g_hMprAdmin      = NULL;
        g_hMIBServer     = NULL;
    }

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\if\utils.h ===
#define ADDR_LENGTH          24

//
// Misc macros
//
#define IfutlDispTokenErrMsg(hModule, dwMsgId, pwszTag, pwszValue) \
        DisplayMessage( hModule, dwMsgId, pwszValue, pwszTag)

#define BREAK_ON_DWERR(x) if ((x) != NO_ERROR) break;

// 
// Macros for dealing with IFMON_CMD_ARGS
//
#define IFMON_CMD_ARG_GetPsz(pArg)     \
    (((pArg)->rgTag.bPresent) ? (pArg)->Val.pszValue : NULL)

#define IFMON_CMD_ARG_GetDword(pArg)     \
    (((pArg)->rgTag.bPresent) ? (pArg)->Val.dwValue : 0)

//
// Enumerations for types of arguments (see RASMON_CMD_ARG)
//
#define IFMON_CMD_TYPE_STRING 0x1
#define IFMON_CMD_TYPE_ENUM   0x2



#define CHECK_UNICAST_IP_ADDR(Addr) \
    (((DWORD)((Addr) & 0x000000E0) >= (DWORD)0x000000E0) or \
    ((DWORD)((Addr) & 0x000000FF) == (DWORD)0x0000007F) or \
    ((Addr) == 0))


BOOL
CheckMask(
    DWORD Mask
    );


#define CHECK_NETWORK_MASK(Mask) \
    (CheckMask(Mask) || (Mask==0xFFFFFFFF) || (Mask==0))

// 
// Structure defining a command line argument
//
typedef struct _IFMON_CMD_ARG
{
    IN  DWORD dwType;           // RASMONTR_CMD_TYPE_*
    IN  TAG_TYPE rgTag;         // The tag for this command
    IN  TOKEN_VALUE* rgEnums;   // The enumerations for this arg
    IN  DWORD dwEnumCount;      // Count of enums
    union
    {
        OUT PWCHAR pszValue;        // Valid only for RASMONTR_CMD_TYPE_STRING
        OUT DWORD dwValue;          // Valid only for RASMONTR_CMD_TYPE_ENUM
    } Val;        
    
} IFMON_CMD_ARG, *PIFMON_CMD_ARG;

DWORD
IfutlGetTagToken(
    IN  HANDLE      hModule,
    IN  PWCHAR      *ppwcArguments,
    IN  DWORD       dwCurrentIndex,
    IN  DWORD       dwArgCount,
    IN  PTAG_TYPE   pttTagToken,
    IN  DWORD       dwNumTags,
    OUT PDWORD      pdwOut
    );

VOID
IfutlGetInterfaceName(
    IN  PWCHAR pwszIfDesc,
    OUT PWCHAR pwszIfName,
    IN  PDWORD pdwSize
    );

VOID
IfutlGetInterfaceDescription(
    IN  PWCHAR pwszIfName,
    OUT PWCHAR pwszIfDesc,
    IN  PDWORD pdwSize
    );

PVOID 
WINAPI
IfutlAlloc(
    IN DWORD dwBytes,
    IN BOOL bZero
    );

VOID 
WINAPI
IfutlFree(
    IN PVOID pvData
    );

PWCHAR
WINAPI
IfutlStrDup(
    IN LPCWSTR pwszSrc
    );
    
DWORD
IfutlParse(
    IN  PWCHAR*         ppwcArguments,
    IN  DWORD           dwCurrentIndex,
    IN  DWORD           dwArgCount,
    IN  BOOL*           pbDone,
    OUT IFMON_CMD_ARG*  pIfArgs,
    IN  DWORD           dwIfArgCount);

BOOL
IfutlIsRouterRunning(
    VOID
    );
   
DWORD
GetIpAddress(
    PWCHAR        ppwcArg,
    PIPV4_ADDRESS ipAddress
    );

DWORD
IfutlGetIfIndexFromInterfaceName(
    IN  PWCHAR            pwszGuid,
    OUT PDWORD            pdwIfIndex
    );


DWORD
WINAPI
InterfaceEnum(
    OUT    PBYTE               *ppb,
    OUT    PDWORD              pdwCount,
    OUT    PDWORD              pdwTotal
    );

DWORD
IfutlGetIfIndexFromFriendlyName(
    PWCHAR IfFriendlyName,
    PULONG pdwIfIndex
    );

VOID
MakeAddressStringW(
    OUT PWCHAR       pwcPrefixStr,
    IN  IPV4_ADDRESS ipAddr
    );

DWORD
IfutlGetFriendlyNameFromIfIndex(
    IN  MIB_SERVER_HANDLE hMibServer,
    IN  DWORD             dwIfIndex,
    OUT PWCHAR            pwszBuffer,
    IN  DWORD             dwBufferSize
    );

DWORD
MibGet(
    DWORD   dwTransportId,
    DWORD   dwRoutingPid,
    LPVOID  lpInEntry,
    DWORD   dwInEntrySize,
    LPVOID *lplpOutEntry,
    LPDWORD lpdwOutEntrySize
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\inc\ipmontr.h ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    ipmontr.h

Abstract:
    This file contains definitions which are needed by IPMONTR.DLL
    and all NetSh helper DLLs which register under it.

--*/

#ifndef _IPMONTR_H_
#define _IPMONTR_H_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

// {65EC23C0-D1B9-11d2-89E4-006008B0E5B9}
#define ROUTING_GUID \
{ 0x65ec23c0, 0xd1b9, 0x11d2, { 0x89, 0xe4, 0x0, 0x60, 0x8, 0xb0, 0xe5, 0xb9 } }


// {0705ECA0-7AAC-11d2-89DC-006008B0E5B9}
#define IPMONTR_GUID \
{ 0x705eca0, 0x7aac, 0x11d2, { 0x89, 0xdc, 0x0, 0x60, 0x8, 0xb0, 0xe5, 0xb9 } }

#define IPMON_VERSION_50    0x0005000

#define ADDR_LENGTH          24
#define ADDR_LEN              4

#define PRINT_IPADDR(x) \
    ((x)&0x000000ff),(((x)&0x0000ff00)>>8),(((x)&0x00ff0000)>>16),(((x)&0xff000000)>>24)

#define IP_TO_WSTR(str,addr) swprintf((str),L"%d.%d.%d.%d", \
                    (addr)[0],    \
                    (addr)[1],    \
                    (addr)[2],    \
                    (addr)[3])

#ifdef UNICODE
#define MakeUnicodeIpAddr(ptszUnicode,pszAddr)             \
    MultiByteToWideChar(GetConsoleOutputCP(),                            \
                        0,                                 \
                        (pszAddr),                         \
                        -1,                                \
                        (ptszUnicode),                     \
                        ADDR_LENGTH)
#else
#define MakeUnicodeIpAddr(ptszUnicode,pszAddr)             \
    strcpy((ptszUnicode),(pszAddr))
#endif //UNICODE

//
// API prototypes and structures used by them
//

typedef
DWORD
(WINAPI IP_CONTEXT_ENTRY_FN)(
    IN     LPCWSTR              pwszMachine,
    IN OUT LPWSTR              *pptcArguments,
    IN     DWORD                dwArgCount,
    IN     DWORD                dwFlags,
    IN     MIB_SERVER_HANDLE    hMIBServer,
    OUT    LPWSTR               pwcNewContext
    );

typedef IP_CONTEXT_ENTRY_FN *PIP_CONTEXT_ENTRY_FN;

typedef
DWORD
(WINAPI ROUTING_CONTEXT_ENTRY_FN)(
    IN     LPCWSTR              pwszRouter,
    IN OUT LPSTR               *pptcArguments,
    IN     DWORD                dwArgCount,
    IN     DWORD                dwFlags,
    OUT    LPSTR                pwcNewContext
    );

typedef ROUTING_CONTEXT_ENTRY_FN *PROUTING_CONTEXT_ENTRY_FN;

typedef
DWORD
(WINAPI ROUTING_CONTEXT_COMMIT_FN)(
    IN  DWORD   dwAction
    );

typedef ROUTING_CONTEXT_COMMIT_FN *PROUTING_CONTEXT_COMMIT_FN;

DWORD WINAPI
IpmontrDeleteInfoBlockFromInterfaceInfo(
    IN  LPCWSTR     pwszIfName,
    IN  DWORD       dwType
    );

DWORD WINAPI
IpmontrDeleteInfoBlockFromGlobalInfo(
    IN  DWORD       dwType
    );

DWORD WINAPI
IpmontrDeleteProtocol(
    IN  DWORD       dwProtoId
    );

DWORD WINAPI
IpmontrGetInfoBlockFromGlobalInfo(
    IN  DWORD       dwType,
    OUT BYTE        **ppbInfoBlk,
    OUT PDWORD      pdwSize,
    OUT PDWORD      pdwCount
    );

DWORD WINAPI
IpmontrGetInfoBlockFromInterfaceInfo(
    IN  LPCWSTR     pwszIfName,
    IN  DWORD       dwType,
    OUT BYTE        **ppbInfoBlk,
    OUT PDWORD      pdwSize,
    OUT PDWORD      pdwCount,
    OUT PDWORD      pdwIfType
    );

DWORD WINAPI
IpmontrSetInfoBlockInGlobalInfo(
    IN  DWORD       dwType,
    IN  PBYTE       pbInfoBlk,
    IN  DWORD       dwSize,
    IN  DWORD       dwCount
    );

DWORD WINAPI
IpmontrSetInfoBlockInInterfaceInfo(
    IN  LPCWSTR     pwszIfName,
    IN  DWORD       dwType,
    IN  PBYTE       pbInfoBlk,
    IN  DWORD       dwSize,
    IN  DWORD       dwCount
    );

DWORD WINAPI
IpmontrInterfaceEnum(
    OUT BYTE        **ppb,
    OUT PDWORD      pdwCount,
    OUT PDWORD      pdwTotal
    );

typedef
BOOL
(WINAPI *PIM_ROUTER_STATUS)(
    VOID
    );

DWORD WINAPI
IpmontrGetInterfaceType(
    IN  LPCWSTR   pwszIfName,
    OUT PDWORD    pdwIfType
    );

typedef
DWORD
(WINAPI *PIM_MATCH_ROUT_PROTO)(
    IN  LPCWSTR   pwszToken
    );

DWORD WINAPI
IpmontrGetFriendlyNameFromIfIndex(
    IN  MIB_SERVER_HANDLE hMibServer,
    IN  DWORD             dwIfIndex,
    OUT LPWSTR            pwszBuffer,
    IN  DWORD             dwBufferSize
    );

DWORD WINAPI
IpmontrGetIfIndexFromFriendlyName(
    IN  MIB_SERVER_HANDLE hMibServer,
    IN  LPCWSTR           pwszBuffer,
    OUT PDWORD            pdwIfIndex
    );

DWORD WINAPI
IpmontrGetFriendlyNameFromIfName(
    IN  LPCWSTR pwszName,
    OUT LPWSTR  pwszBuffer,
    IN  PDWORD  pdwBufSize
    );

DWORD WINAPI
IpmontrGetIfNameFromFriendlyName(
    IN  LPCWSTR pwszName,
    OUT LPWSTR  pwszBuffer,
    IN  PDWORD  pdwBufSize
    );

#ifdef KSL_IPINIP
DWORD WINAPI
IpmontrCreateInterface(
    IN  LPCWSTR pwszMachineName,
    IN  LPCWSTR pwszInterfaceName,
    IN  DWORD   dwLocalAddress,
    IN  DWORD   dwRemoteAddress,
    IN  BYTE    byTtl
    );

DWORD WINAPI
IpmontrDeleteInterface(
    IN  LPCWSTR pwszMachineName,
    IN  LPCWSTR pwszInterfaceName
    );
#endif //KSL_IPINIP


#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4201)

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4201)
#endif

#ifdef __cplusplus
}
#endif

#endif // _IPMONTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\inc\macros.h ===
#ifndef _DEBUG
#define DEBUG(s)
#define DEBUG1(s1,s2)
#define DEBUG2(s1,s2)
#else
#define DEBUG(s) wprintf(L"%s\n", L##s)
#define DEBUG1(s1,s2) wprintf(L##s1, L##s2)
#define DEBUG2(s1,s2) wprintf(L##s1, L##s2)
#endif

#define PRINT(s) wprintf(L"%s\n",s)
#define PRINT1(s,s1) wprintf(L##s , L##s1)

#define is ==
#define isnot !=
#define or ||
#define and &&

#define FREE_STRING_NOT_NULL(ptszString) if (ptszString) FreeString(ptszString)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\inc\ipxmontr.h ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    ipxmontr.h

Abstract:
    This file contains definitions which are needed by IPXMONTR.DLL
    and all NetSh helper DLLs which register under it.

--*/

#ifndef _IPXMONTR_H_
#define _IPXMONTR_H_


#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

// {b1641451-84b8-11d2-b940-3078302c2030}
#define IPXMONTR_GUID \
{                                                           \
    0xb1641451, 0x84b8, 0x11d2,                             \
    {                                                       \
        0xb9, 0x40, 0x30, 0x78, 0x30, 0x2c, 0x20, 0x30      \
    }                                                       \
}


#define IPXMON_VERSION_50       0x0005000


//
// API prototypes and structures used by them
//

typedef
DWORD
(WINAPI IPX_CONTEXT_ENTRY_FN)(
    IN     LPCWSTR              pwszMachine,
    IN OUT LPWSTR               *ppwcArguments,
    IN     DWORD                dwArgCount,
    IN     DWORD                dwFlags,
    IN     MIB_SERVER_HANDLE    hMIBServer,
    OUT    LPWSTR               pwcNewContext
    );

typedef IPX_CONTEXT_ENTRY_FN *PIPX_CONTEXT_ENTRY_FN;

typedef struct _PROTO_STRING
{
    DWORD    dwProtoId;
    DWORD    dwTokenId;
}PROTO_STRING, *PPROTO_STRING;

typedef
DWORD
(WINAPI *PIM_DEL_INFO_BLK_IF)(
    IN  LPCWSTR     pwszIfName,
    IN  DWORD       dwType
    );

typedef
DWORD
(WINAPI *PIM_DEL_INFO_BLK_GLOBAL)(
    IN  DWORD       dwType
    );

typedef
DWORD
(WINAPI *PIM_DEL_PROTO)(
    IN  DWORD       dwProtoId
    );

typedef
DWORD
(WINAPI *PIM_GET_INFO_BLK_GLOBAL)(
    IN  DWORD       dwType,
    OUT BYTE        **ppbInfoBlk,
    OUT PDWORD      pdwSize,
    OUT PDWORD      pdwCount
    );

typedef
DWORD
(WINAPI *PIM_GET_INFO_BLK_IF)(
    IN  LPCWSTR     pwszIfName,
    IN  DWORD       dwType,
    OUT BYTE        **ppbInfoBlk,
    OUT PDWORD      pdwSize,
    OUT PDWORD      pdwCount,
    OUT PDWORD      pdwIfType
    );

typedef
DWORD
(WINAPI *PIM_SET_INFO_BLK_GLOBAL)(
    IN  DWORD       dwType,
    IN  PBYTE       pbInfoBlk,
    IN  DWORD       dwSize,
    IN  DWORD       dwCount
    );

typedef
DWORD
(WINAPI *PIM_SET_INFO_BLK_IF)(
    IN  LPCWSTR     pwszIfName,
    IN  DWORD       dwType,
    IN  PBYTE       pbInfoBlk,
    IN  DWORD       dwSize,
    IN  DWORD       dwCount
    );

typedef
DWORD
(WINAPI *PIM_IF_ENUM)(
    OUT BYTE        **ppb,
    OUT PDWORD      pdwCount,
    OUT PDWORD      pdwTotal
    );

typedef
DWORD
(WINAPI *PIM_PROTO_LIST)(
    OUT PPROTO_STRING    *ppps,
    OUT PDWORD           pdwNumProto
    );

typedef
BOOL
(WINAPI *PIM_ROUTER_STATUS)(
    VOID
    );

typedef
DWORD
(WINAPI *PIM_GET_IF_TYPE)(
    IN  LPCWSTR   pwszIfName,
    OUT PDWORD    pdwIfType
    );

typedef
DWORD
(WINAPI *PIM_MATCH_ROUT_PROTO)(
    IN  LPCWSTR   pwszToken
    );

#ifdef __cplusplus
}
#endif

#endif // _IPXMONTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\if\showmib.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:
     net\routing\netsh\if\showmib.h

Abstract:



Author:

     Dave Thaler    7/21/99

Revision History:


--*/

#ifndef __IFMON_SHOWMIB_H__
#define __IFMON_SHOWMIB_H__

#define MAX_NUM_INDICES 6

typedef
DWORD
(*PGET_OPT_FN)(
    IN    PTCHAR   *pptcArguments,
    IN    DWORD    dwCurrentIndex,
    OUT   PDWORD   pdwIndices,
    OUT   PDWORD   pdwNumParsed
    );

typedef struct _MIB_OBJECT_PARSER
{
    PWCHAR         pwszMIBObj;
    DWORD          dwMinOptArg;
    PGET_OPT_FN    pfnMIBObjParser;
} MIB_OBJECT_PARSER,*PMIB_OBJECT_PARSER;

DWORD
GetMIBIfIndex(
    IN    PTCHAR   *pptcArguments,
    IN    DWORD    dwCurrentIndex,
    OUT   PDWORD   pdwIndices,
    OUT   PDWORD   pdwNumParsed
);

DWORD
GetMIBIpAddress(
    IN    PTCHAR    *pptcArguments,
    IN    DWORD    dwCurrentIndex,
    OUT   PDWORD   pdwIndices,
    OUT   PDWORD   pdwNumParsed
);

DWORD
GetMIBIpNetIndex(
    IN    PTCHAR    *pptcArguments,
    IN    DWORD    dwCurrentIndex,
    OUT   PDWORD   pdwIndices,
    OUT   PDWORD   pdwNumParsed
);

DWORD
GetMIBTcpConnIndex(
    IN    PTCHAR    *pptcArguments,
    IN    DWORD    dwCurrentIndex,
    OUT   PDWORD   pdwIndices,
    OUT   PDWORD   pdwNumParsed
);

DWORD
GetMIBUdpConnIndex(
    IN    PTCHAR    *pptcArguments,
    IN    DWORD    dwCurrentIndex,
    OUT   PDWORD   pdwIndices,
    OUT   PDWORD   pdwNumParsed
);

typedef
VOID
(PRINT_FN)(
    IN MIB_SERVER_HANDLE hMibServer,
    IN PMIB_OPAQUE_INFO  pInfo
    );

typedef PRINT_FN *PPRINT_FN;

PRINT_FN PrintIfTable;
PRINT_FN PrintIfRow;
PRINT_FN PrintIcmp;
PRINT_FN PrintUdpStats;
PRINT_FN PrintUdpTable;
PRINT_FN PrintUdpRow;
PRINT_FN PrintTcpStats;
PRINT_FN PrintTcpTable;
PRINT_FN PrintTcpRow;
PRINT_FN PrintIpStats;
PRINT_FN PrintIpAddrTable;
PRINT_FN PrintIpAddrRow;
PRINT_FN PrintIpNetTable;
PRINT_FN PrintIpNetRow;

typedef struct _MAGIC_TABLE
{
    DWORD      dwId;
    PPRINT_FN  pfnPrintFunction;
}MAGIC_TABLE, *PMAGIC_TABLE;

FN_HANDLE_CMD HandleIpMibShowObject;

DWORD
GetMibTagToken(
    IN  PWCHAR  *ppwcArguments,
    IN  DWORD   dwArgCount,
    IN  DWORD   dwNumIndices,
    OUT PDWORD  pdwRR,
    OUT PBOOL   pbIndex,
    OUT PDWORD  pdwIndex
    );

#define DISPLAYLEN_PHYSADDR 3*MAXLEN_PHYSADDR + 8

#ifdef UNICODE
#define MakeUnicodePhysAddr(ptszUnicode,pszAddr,dwLen)      \
{                                                           \
    CHAR __szTemp[DISPLAYLEN_PHYSADDR + 1];                 \
    DWORD __i,__dwTempLen;                                  \
    __dwTempLen = (((dwLen) <= MAXLEN_PHYSADDR) ? (dwLen) : MAXLEN_PHYSADDR); \
    for(__i = 0; __i < __dwTempLen; __i++)                  \
    {                                                       \
        sprintf(&(__szTemp[3*__i]),"%02X-",pszAddr[__i]);   \
    }                                                       \
    MultiByteToWideChar(GetConsoleOutputCP(),                             \
                        0,                                  \
                        (__szTemp),                         \
                        -1,                                 \
                        (ptszUnicode),                      \
                        3*__i);                             \
    ptszUnicode[(3*__i) - 1] = TEXT('\0');                  \
}
#else
#define MakeUnicodePhysAddr(ptszUnicode,pszAddr,dwLen)      \
{                                                           \
    CHAR __szTemp[DISPLAYLEN_PHYSADDR + 1];                 \
    DWORD __i,__dwTempLen;                                  \
    __dwTempLen = (((dwLen) <= MAXLEN_PHYSADDR) ? (dwLen) : MAXLEN_PHYSADDR); \
    for(__i = 0; __i < __dwTempLen; __i++)                  \
    {                                                       \
        sprintf(&(__szTemp[3*__i]),"%02X-",pszAddr[__i]);   \
    }                                                       \
    strncpy((ptszUnicode),__szTemp,3*__i);                  \
    ptszUnicode[(3*__i) - 1] = TEXT('\0');                  \
}
#endif //UNICODE

FN_HANDLE_CMD    HandleIpShowJoins;

#endif // __IFMON_SHOWMIB_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ip\ipmon\boundary.h ===
typedef DWORD          IPV4_ADDRESS, *PIPV4_ADDRESS;

FN_HANDLE_CMD HandleIpAddScope;
FN_HANDLE_CMD HandleIpDelScope;
FN_HANDLE_CMD HandleIpSetScope;
FN_HANDLE_CMD HandleIpShowScope;

FN_HANDLE_CMD HandleIpAddBoundary;
FN_HANDLE_CMD HandleIpDelBoundary;
FN_HANDLE_CMD HandleIpSetBoundary;
FN_HANDLE_CMD HandleIpShowBoundary;

DWORD
GetPrintBoundaryInfo(
    MIB_SERVER_HANDLE hMIBServer
    );

#if 0
DWORD
GetPrintScopeInfo(
    MIB_SERVER_HANDLE hMIBServer
    );
#endif

DWORD
ShowScopes(
    IN HANDLE  hFile
    );

DWORD
ShowBoundaryInfoForInterface(
    IN  HANDLE  hFile,
    IN  LPCWSTR pwszIfName,
    OUT PDWORD  pdwNumRows
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ip\ipmon\filter.h ===
DWORD
UpdateFragCheckInfo(
    IN    LPCWSTR pwszIfName,
    IN    BOOL    bFragCheck
    );


DWORD
SetFragCheckInfo(
    IN    LPCWSTR pwszIfName,
    IN    BOOL    bFragChk
    );

DWORD
SetFilterInfo(
    IN    LPCWSTR   pwszIfName,
    IN    DWORD     dwFilterType,
    IN    DWORD     dwAction
    );

DWORD
AddDelFilterInfo(
    IN    FILTER_INFO    fi,
    IN    LPCWSTR        pwszIfName,
    IN    DWORD          dwFilterType,
    IN    BOOL           bAdd
    );

DWORD
AddNewFilter( 
    IN    PFILTER_DESCRIPTOR    pfd,
    IN    FILTER_INFO           fi,
    IN    DWORD                 dwBlkSize, 
    OUT   PFILTER_DESCRIPTOR    *ppfd,
    OUT   PDWORD                pdwSize
    );

DWORD
DeleteFilter( 
    IN    PFILTER_DESCRIPTOR    pfd,
    IN    FILTER_INFO           fi,
    IN    DWORD                 dwBlkSize,
    OUT   PFILTER_DESCRIPTOR    *ppfd,
    OUT   PDWORD                pdwSize
    );

BOOL
IsFilterPresent(
    PFILTER_DESCRIPTOR pfd,
    FILTER_INFO        fi,
    PDWORD pdwInd
    );

DWORD
DisplayFilters(
    HANDLE                  hFile,
    PFILTER_DESCRIPTOR      pfd,
    PWCHAR                  pwszIfName,
    PWCHAR                  pwszQuotedIfName,
    DWORD                   dwFilterType
    );

DWORD
ShowIpIfFilter(
    IN     HANDLE   hFile,
    IN     DWORD    dwFormat,
    IN     LPCWSTR  pwszIfName,
    IN OUT PDWORD   pdwNumRows
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ip\ipmon\info.h ===
typedef struct _TRANSPORT_INFO
{
    PRTR_INFO_BLOCK_HEADER    pibhInfo;
    BOOL                      bValid;
}TRANSPORT_INFO,*PTRANSPORT_INFO;

typedef struct _INTERFACE_STORE
{
    LIST_ENTRY                le;
    PWCHAR                    pwszIfName;
    PRTR_INFO_BLOCK_HEADER    pibhInfo;
    DWORD                     dwIfType;
    BOOL                      bValid;
}INTERFACE_STORE,*PINTERFACE_STORE;

extern LIST_ENTRY           g_leIfListHead;
extern TRANSPORT_INFO       g_tiTransport;


#define FREE_BUFFER(pibh)               \
{                                       \
    HeapFree(GetProcessHeap(),          \
             0,                         \
             pibh);                     \
    pibh = NULL;                        \
}

DWORD
ValidateInterfaceInfo(
    IN  LPCWSTR                 pwszIfName,
    OUT RTR_INFO_BLOCK_HEADER   **ppInfo,   OPTIONAL
    OUT PDWORD                  pdwIfType,  OPTIONAL
    OUT INTERFACE_STORE         **ppIfStore OPTIONAL
    );

DWORD
ValidateGlobalInfo(
    OUT RTR_INFO_BLOCK_HEADER   **ppInfo
    );

DWORD
GetGlobalInfo(
    OUT  RTR_INFO_BLOCK_HEADER  **ppibhInfo
    );

DWORD
SetGlobalInfo(
    IN  PRTR_INFO_BLOCK_HEADER  pibhInfo
    );

DWORD
GetInterfaceInfo(
    IN     LPCWSTR                 pwszIfName,
    OUT    PRTR_INFO_BLOCK_HEADER  *ppibhInfo,
    IN     PMPR_INTERFACE_0        pMprIf0,
    OUT    PDWORD                  pdwIfType
    );

DWORD
SetInterfaceInfo(
    IN    PRTR_INFO_BLOCK_HEADER    pibhInfo,
    IN    LPCWSTR                   pwszIfName
    );

DWORD
AddInterfaceInfo(
    IN    LPCWSTR                   pwszIfName
    );

DWORD
DeleteInterfaceInfo(
    IN    LPCWSTR                   pwszIfName
    );

DWORD
WINAPI
IpCommit(
    IN  DWORD   dwAction
    );

#ifdef KSL_IPINIP
DWORD
CreateInterface(
    IN  LPCWSTR pwszFriendlyName,
    IN  LPCWSTR pwszGuidName,
    IN  DWORD   dwIfType,
    IN  BOOL    bCreateRouterIf
    );
#endif //KSL_IPINIP


#define IFCLASS_LOOPBACK  1
#define IFCLASS_P2P       2
#define IFCLASS_BROADCAST 3
#define IFCLASS_NBMA      4

DWORD
GetInterfaceClass(
    IN  LPCWSTR pwszIfName,
    OUT PDWORD  pdwIfClass
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ip\ipmon\info.c ===
#include "precomp.h"

WCHAR   g_wszRtrMgrDLL[]    = L"%SystemRoot%\\system32\\IPRTRMGR.DLL";
DWORD   g_dwIfState         = MIB_IF_ADMIN_STATUS_UP;
BOOL    g_bDiscEnable       = FALSE;

#define IP_KEY L"Ip"

#undef EXTRA_DEBUG

DWORD
ValidateInterfaceInfo(
    IN  LPCWSTR                 pwszIfName,
    OUT RTR_INFO_BLOCK_HEADER   **ppInfo,   OPTIONAL
    OUT PDWORD                  pdwIfType,  OPTIONAL
    OUT INTERFACE_STORE         **ppIfStore OPTIONAL
    )
{
    PRTR_INFO_BLOCK_HEADER    pOldInfo = NULL;
    DWORD                     dwErr, dwIfType, dwTmpSize;
    BOOL                      bFound = FALSE;
    LIST_ENTRY                *ple;
    PINTERFACE_STORE           pii;

    if(ppInfo)
    {
        *ppInfo = NULL;
    }

    if(ppIfStore)
    {
        *ppIfStore  = NULL;
    }
   
    //
    // If the current mode is commit, get info from config/router
    //

    if(g_bCommit)
    {
        dwErr = GetInterfaceInfo(pwszIfName,
                                 ppInfo,
                                 NULL,
                                 pdwIfType);

        return dwErr;
    }

    //
    // Uncommit mode. Try to find the interface in the list
    //
    
    bFound = FALSE;
    
    for(ple = g_leIfListHead.Flink;
        ple != &g_leIfListHead;
        ple = ple->Flink)
    {
        pii = CONTAINING_RECORD(ple, INTERFACE_STORE, le);
        
        if (_wcsicmp(pii->pwszIfName, pwszIfName) == 0)
        {
            bFound = TRUE;
            
            break;
        }
    }
    
    if(!bFound ||
       !pii->bValid)
    {
        //
        // the required one was not found, or it was not valid
        // Need to get the info for both cases
        //
        
        dwErr = GetInterfaceInfo(pwszIfName,
                                 &pOldInfo,
                                 NULL,
                                 &dwIfType);
        
        if (dwErr isnot NO_ERROR)
        {
            return dwErr;
        }
    }
    
    if(bFound)
    {
        if(!pii->bValid)
        {
            //
            // Update
            //
            
            pii->pibhInfo   = pOldInfo;
            pii->bValid     = TRUE;
            pii->dwIfType   = dwIfType;
        }
    }
    else
    {
        //
        // No entry for the interface in the list.
        //
        
        pii = HeapAlloc(GetProcessHeap(),
                        0,
                        sizeof(INTERFACE_STORE));
        
        if(pii == NULL)
        {
            FREE_BUFFER(pOldInfo);
            
            DisplayMessage(g_hModule,  MSG_IP_NOT_ENOUGH_MEMORY );
            
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        
        pii->pwszIfName =
            HeapAlloc(GetProcessHeap(),
                      0,
                      (wcslen(pwszIfName) + 1) * sizeof(WCHAR));
        
        if(pii->pwszIfName == NULL)
        {
            FREE_BUFFER(pOldInfo);
            
            HeapFree(GetProcessHeap(),
                     0,
                     pii);
            
            DisplayMessage(g_hModule,  MSG_IP_NOT_ENOUGH_MEMORY );
            
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        
        InsertHeadList(&g_leIfListHead, &(pii->le));
        
        wcscpy(pii->pwszIfName, pwszIfName);
        
        pii->pibhInfo   = pOldInfo;
        pii->bValid     = TRUE;
        pii->dwIfType   = dwIfType;
    }

    if(ppIfStore)
    {
        *ppIfStore = pii;
    }

    if(pdwIfType)
    {
        *pdwIfType = pii->dwIfType;
    }

    if(ppInfo)
    {
        *ppInfo = pii->pibhInfo;
    }

    return NO_ERROR;
}

DWORD
ValidateGlobalInfo(
    OUT RTR_INFO_BLOCK_HEADER   **ppInfo
    )
{
    DWORD                     dwErr;
    
    //
    // If the current mode is commit, get info from config/router
    //

    if(g_bCommit)
    {
        dwErr = GetGlobalInfo(ppInfo);

        return dwErr;
    }

    //
    // Uncommit mode. Check if the info in g_tiTransport is valid
    //
    
    if(g_tiTransport.bValid)
    {
        *ppInfo = g_tiTransport.pibhInfo;
    }
    else
    {   
        //
        // Get the info from config/router and store in g_tiTransport
        // Mark the info to be valid.
        //
        
        dwErr = GetGlobalInfo(ppInfo);
        
        if (dwErr isnot NO_ERROR)
        {
            return dwErr;
        }

        g_tiTransport.pibhInfo = *ppInfo;
        g_tiTransport.bValid   = TRUE;
    }

    return NO_ERROR;
}


DWORD
GetGlobalInfo(
    OUT PRTR_INFO_BLOCK_HEADER  *ppibhInfo
    )

/*++

Routine Description:

    Gets global transport information from registry or router.

Arguments:

    bMprConfig  - Info from Registry or info from router
    ppibhInfo   - ptr to header
    
Return Value:

    NO_ERROR, ERROR_INVALID_PARAMETER, ERROR_ROUTER_STOPPED
    
--*/

{

    HANDLE    hTransport = (HANDLE) NULL;
    DWORD     dwRes, dwSize;
    PRTR_INFO_BLOCK_HEADER  pibhInfo = (PRTR_INFO_BLOCK_HEADER ) NULL;
   
    if(ppibhInfo == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    do
    {

#ifdef READROUTERINFO
        if (IsRouterRunning())
        {
            //
            // Retrieve global protocol information from router
            //

            dwRes = MprAdminTransportGetInfo(g_hMprAdmin,
                                             PID_IP,
                                             (LPBYTE*) &pibhInfo,
                                             &dwSize,
                                             NULL,
                                             NULL);

            if ( dwRes != NO_ERROR )
            {
                break;
            }
            
            if ( pibhInfo == (PRTR_INFO_BLOCK_HEADER) NULL )
            {
                dwRes = ERROR_INVALID_PARAMETER;
                break;
            }

            //
            // unfortunately, the memory allocation mechanisms 
            // are different between the apis that access the registry
            // and those that access that the running router. To make
            // the source of the info transparent to the caller, we
            // need to copy this info out.
            //

            *ppibhInfo = HeapAlloc(GetProcessHeap(),
                                   0,
                                   dwSize);

            if ( *ppibhInfo == NULL)
            {
                dwRes = GetLastError();

                break;
            }

            CopyMemory(*ppibhInfo,
                       pibhInfo,
                       dwSize);

            MprAdminBufferFree(pibhInfo);
        }
        else
#endif
        {
#ifdef READROUTERINFO
            //
            // Router not running, get info from the registry
            //
#else
            //
            // Always get the information from the registry.
            // Doesn't matter if the router is running or not.
            // When setting the global information,
            // write it to registry and to the router (if it is running).
            //
#endif

            dwRes = MprConfigTransportGetHandle(g_hMprConfig,
                                                PID_IP,
                                                &hTransport);

            if ( dwRes != NO_ERROR )
            {
                break;
            }

            dwRes = MprConfigTransportGetInfo(g_hMprConfig,
                                              hTransport,
                                              (LPBYTE*) &pibhInfo,
                                              &dwSize,
                                              NULL,
                                              NULL,
                                              NULL);

            if ( dwRes != NO_ERROR )
            {
                break;
            }

            if(( pibhInfo == (PRTR_INFO_BLOCK_HEADER) NULL )
             or (dwSize < sizeof(RTR_INFO_BLOCK_HEADER)))
            {
                dwRes = ERROR_TRANSPORT_NOT_PRESENT;
                
                break;
            }    

            //
            // HACKHACK: we know that MprConfigXxx apis allocate from
            // process heap, so we can return the same block
            //
            
            *ppibhInfo = pibhInfo;
        }
         
    } while(FALSE);

    return dwRes;
}

DWORD
SetGlobalInfo(
    IN  PRTR_INFO_BLOCK_HEADER  pibhInfo
    )

/*++

Routine Description:

    Sets global transport information to both the registry and the router

Arguments:

    pibhInfo    - ptr to header
    
Return Value:

    NO_ERROR, ERROR_ROUTER_STOPPED
    
--*/

{
    DWORD                   dwARes = NO_ERROR,
                            dwCRes = NO_ERROR;
    HANDLE                  hTransport;
    UINT                    i;
    PRTR_INFO_BLOCK_HEADER  pibhNewInfo, pibhOldInfo;

    // 
    // Create a new info block with all 0-length blocks removed
    // since we don't want to write them to the registry,
    // we only need to send them to the router which we
    // will do with the original info block below.
    //

    pibhOldInfo = NULL;
    pibhNewInfo = pibhInfo;

    for (i=0; (dwCRes is NO_ERROR) && (i<pibhInfo->TocEntriesCount); i++)
    {
        if (pibhInfo->TocEntry[i].InfoSize is 0)
        {
            pibhOldInfo = pibhNewInfo;

            dwCRes = MprInfoBlockRemove(pibhOldInfo, 
                                        pibhOldInfo->TocEntry[i].InfoType,
                                        &pibhNewInfo);

            if (pibhOldInfo isnot pibhInfo)
            {
                FREE_BUFFER(pibhOldInfo);
            }
        }
    }

    if (dwCRes is NO_ERROR)
    {
        dwCRes = MprConfigTransportGetHandle(g_hMprConfig,
                                             PID_IP,
                                             &hTransport);
    }

    if (dwCRes is NO_ERROR)
    {
        dwCRes = MprConfigTransportSetInfo(g_hMprConfig,
                                           hTransport,
                                           (LPBYTE) pibhNewInfo,
                                           pibhNewInfo->Size,
                                           NULL,
                                           0,
                                           NULL);
    }

    if (pibhNewInfo isnot pibhInfo)
    {
        FREE_BUFFER(pibhNewInfo);
    }

    //
    // Even if we failed to write to the registry, we still want
    // to write to the router.
    //
    // We use the original format when writing to the router, since it 
    // needs to see the 0-length blocks in order to delete config info.
    //

    if(IsRouterRunning())
    {
        dwARes = MprAdminTransportSetInfo(g_hMprAdmin,
                                          PID_IP,
                                          (LPBYTE) pibhInfo,
                                          pibhInfo->Size,
                                          NULL,
                                          0);

    }

    return (dwARes isnot NO_ERROR)? dwARes : dwCRes;
}

DWORD
GetInterfaceInfo(
    IN     LPCWSTR                 pwszIfName,
    OUT    RTR_INFO_BLOCK_HEADER   **ppibhInfo, OPTIONAL
    OUT    PMPR_INTERFACE_0        pMprIfInfo, OPTIONAL
    OUT    PDWORD                  pdwIfType   OPTIONAL
    )

/*++

Routine Description:

    Gets global transport information from registry or router.

    If one of the out information is not required, then the parameter
    can be NULL.
    
Arguments:

    pwszIfName  - Interface Name
    bMprConfig  - Info from Registry or info from router
    ppibhInfo   - ptr to header
    pMprIfInfo  - ptr to interface info
    pdwIfType   - Type of interface
    
Return Value:

    NO_ERROR, 
    ERROR_NO_SUCH_INTERFACE
    ERROR_TRANSPORT_NOT_PRESENT

--*/

{
    PMPR_INTERFACE_0          pMprIf = NULL;
    PRTR_INFO_BLOCK_HEADER    pibh;
    HANDLE                    hInterface,hIfTransport;
    DWORD                     dwRes, dwSize;

   
    if(((ULONG_PTR)ppibhInfo | (ULONG_PTR)pMprIfInfo | (ULONG_PTR)pdwIfType) ==
       (ULONG_PTR)NULL)
    {
        return NO_ERROR;
    }
 
    do 
    {

#ifdef READROUTERINFO
        if(IsRouterRunning())
        {
            //
            // Get info from the router
            //
            
            dwRes = MprAdminInterfaceGetHandle(g_hMprAdmin,
                                               (LPWSTR)pwszIfName,
                                               &hInterface,
                                               FALSE);

            if( dwRes != NO_ERROR )
            {
                break;
            }


            if(pMprIfInfo || pdwIfType)
            {
                dwRes = MprAdminInterfaceGetInfo(g_hMprAdmin,
                                                 hInterface,
                                                 0,
                                                 (LPBYTE *) &pMprIf);

                if ( dwRes != NO_ERROR )
                {
                    break;
                }

                if (pMprIf == NULL)
                {
                    dwRes = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }
                
                if(pMprIfInfo)
                {
                    //
                    // structure copy
                    //

                    *pMprIfInfo= *pMprIf;
                }

                if(pdwIfType)
                {
                    *pdwIfType = pMprIf->dwIfType;
                }

                MprAdminBufferFree(pMprIf);

            }


            if(ppibhInfo)
            {
                dwRes = MprAdminInterfaceTransportGetInfo(g_hMprAdmin,
                                                          hInterface,
                                                          PID_IP,
                                                          (LPBYTE*) &pibh,
                                                          &dwSize);

                if(dwRes != NO_ERROR)
                {
                    break;
                }
            
                if(pibh == (PRTR_INFO_BLOCK_HEADER) NULL)
                {
                    dwRes = ERROR_TRANSPORT_NOT_PRESENT;

                    break;
                }

                //
                // The info returned to the user must be from
                // process heap. Admin calls use MIDL allocation, so
                // copy out info
                //
                
                *ppibhInfo = HeapAlloc(GetProcessHeap(),
                                       0,
                                       dwSize);

                if(*ppibhInfo == NULL)
                {
                    dwRes = GetLastError();

                    break;
                }

                CopyMemory(*ppibhInfo,
                           pibh,
                           dwSize);

                MprAdminBufferFree(pibh);
            }

        }
        else
#endif
        {
#ifdef READROUTERINFO
            //
            // Router not running, get info from the registry
            //
#else
            //
            // Always get the information from the registry. 
            // Doesn't matter if the router is running or not.
            // When setting the interface information,
            // write it to registry and to the router (if it is running).
            //
#endif            
            dwRes = MprConfigInterfaceGetHandle(g_hMprConfig,
                                                (LPWSTR)pwszIfName,         
                                                &hInterface);

            if(dwRes != NO_ERROR)
            {
                break;
            }

            if(pMprIfInfo || pdwIfType)
            {
                dwRes = MprConfigInterfaceGetInfo(g_hMprConfig,
                                                  hInterface,
                                                  0,
                                                  (LPBYTE *) &pMprIf,
                                                  &dwSize);
            
                if(dwRes != NO_ERROR)
                {
                    break;
                }

                if (pMprIf == NULL)
                {
                    dwRes = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }
                
                if(pdwIfType)
                {
                    *pdwIfType = pMprIf->dwIfType;
                }

                if(pMprIfInfo)
                {
                    *pMprIfInfo = *pMprIf;
                }

                MprConfigBufferFree(pMprIf);
            }
            
            if (ppibhInfo)
            {
                dwRes = MprConfigInterfaceTransportGetHandle(g_hMprConfig,
                                                             hInterface,
                                                             PID_IP,
                                                             &hIfTransport);

                if(dwRes != NO_ERROR)
                {
                    break;
                } 
            
                dwRes = MprConfigInterfaceTransportGetInfo(g_hMprConfig,
                                                           hInterface,
                                                           hIfTransport,
                                                           (LPBYTE*) &pibh,
                                                           &dwSize);

                if(dwRes != NO_ERROR)
                {
                    break;
                }
            
                if((pibh == (PRTR_INFO_BLOCK_HEADER) NULL)
                  or (dwSize < sizeof(RTR_INFO_BLOCK_HEADER)))
                {
                    dwRes = ERROR_TRANSPORT_NOT_PRESENT;

                    break;
                }

                //
                // Again, since this is also allocated from process heap
                //
                
                *ppibhInfo = pibh;
            }
        }

    } while (FALSE);

    return dwRes;
}

DWORD
MakeIPGlobalInfo( LPBYTE* ppBuff )
{

    DWORD                   dwSize      = 0,
            				dwRes       = (DWORD) -1;
    LPBYTE                  pbDataPtr   = (LPBYTE) NULL;

    PRTR_TOC_ENTRY          pTocEntry   = (PRTR_TOC_ENTRY) NULL;

    PGLOBAL_INFO            pGlbInfo    = NULL;
    PPRIORITY_INFO          pPriorInfo  = NULL;

    PRTR_INFO_BLOCK_HEADER  pIBH        = (PRTR_INFO_BLOCK_HEADER) NULL;

    
    //
    // Alocate for minimal global Information
    //
    
    dwSize = sizeof( RTR_INFO_BLOCK_HEADER ) + sizeof(GLOBAL_INFO) +
             sizeof( RTR_TOC_ENTRY ) + SIZEOF_PRIORITY_INFO(7) + 
             2 * ALIGN_SIZE;

    pIBH = (PRTR_INFO_BLOCK_HEADER) HeapAlloc( GetProcessHeap(), 0, dwSize );

    if ( pIBH == (PRTR_INFO_BLOCK_HEADER) NULL )
    {
        DisplayMessage( g_hModule, MSG_IP_NOT_ENOUGH_MEMORY );
        *ppBuff = (LPBYTE) NULL;
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // init. infobase fields
    //
    *ppBuff                 = (LPBYTE) pIBH;

    pIBH-> Version          = RTR_INFO_BLOCK_VERSION;
    pIBH-> TocEntriesCount  = 2;
    pIBH-> Size             = dwSize;

    pbDataPtr = (LPBYTE) &( pIBH-> TocEntry[ pIBH-> TocEntriesCount ] );
    ALIGN_POINTER( pbDataPtr );

    //
    // make IP rtr mgr global info.
    //
    
    pTocEntry                   = &(pIBH-> TocEntry[ 0 ]);

    pTocEntry-> InfoType        = IP_GLOBAL_INFO;
    pTocEntry-> Count           = 1;
    pTocEntry-> Offset          = (ULONG)(pbDataPtr - (PBYTE) pIBH);
    pTocEntry-> InfoSize        = sizeof(GLOBAL_INFO);


    pGlbInfo                    = (PGLOBAL_INFO) pbDataPtr;
    pGlbInfo-> bFilteringOn     = TRUE;
    pGlbInfo-> dwLoggingLevel   = IPRTR_LOGGING_ERROR;

    pbDataPtr += pTocEntry->Count * pTocEntry-> InfoSize;
    ALIGN_POINTER( pbDataPtr );
    
    //
    // make IP rtr priority. Info
    //
    
    pTocEntry               = &(pIBH-> TocEntry[ 1 ]);


    pTocEntry-> InfoType    = IP_PROT_PRIORITY_INFO;
    pTocEntry-> Count       = 1;
    pTocEntry-> Offset      = (DWORD)(pbDataPtr - (PBYTE) pIBH);
    pTocEntry-> InfoSize    = SIZEOF_PRIORITY_INFO(7);


    pPriorInfo                      = (PPRIORITY_INFO) pbDataPtr;
    pPriorInfo-> dwNumProtocols     = 7;

    pPriorInfo-> ppmProtocolMetric[ 0 ].dwProtocolId   = PROTO_IP_LOCAL;
    pPriorInfo-> ppmProtocolMetric[ 0 ].dwMetric       = 1;

    pPriorInfo-> ppmProtocolMetric[ 1 ].dwProtocolId   = PROTO_IP_NT_STATIC;
    pPriorInfo-> ppmProtocolMetric[ 1 ].dwMetric       = 3;

    pPriorInfo-> ppmProtocolMetric[ 2 ].dwProtocolId   = PROTO_IP_NT_STATIC_NON_DOD;
    pPriorInfo-> ppmProtocolMetric[ 2 ].dwMetric       = 5;

    pPriorInfo-> ppmProtocolMetric[ 3 ].dwProtocolId   = PROTO_IP_NT_AUTOSTATIC;
    pPriorInfo-> ppmProtocolMetric[ 3 ].dwMetric       = 7;

    pPriorInfo-> ppmProtocolMetric[ 4 ].dwProtocolId   = PROTO_IP_NETMGMT;
    pPriorInfo-> ppmProtocolMetric[ 4 ].dwMetric       = 10;

    pPriorInfo-> ppmProtocolMetric[ 5 ].dwProtocolId   = PROTO_IP_OSPF;
    pPriorInfo-> ppmProtocolMetric[ 5 ].dwMetric       = 110;

    pPriorInfo-> ppmProtocolMetric[ 6 ].dwProtocolId   = PROTO_IP_RIP;
    pPriorInfo-> ppmProtocolMetric[ 6 ].dwMetric       = 120;

    return NO_ERROR;
}

DWORD 
MakeIPInterfaceInfo( 
    LPBYTE* ppBuff,
    DWORD   dwIfType
    )
{
    DWORD           dwSize          = (DWORD) -1;
    DWORD           dwTocEntries    = 2;
    LPBYTE          pbDataPtr       = (LPBYTE) NULL;

    PRTR_TOC_ENTRY  pTocEntry       = (PRTR_TOC_ENTRY) NULL;

#if 0
    PRTR_DISC_INFO  pRtrDisc        = (PRTR_DISC_INFO) NULL;
#endif

    PINTERFACE_STATUS_INFO  pifStat = (PINTERFACE_STATUS_INFO) NULL;

    PRTR_INFO_BLOCK_HEADER   pIBH   = (PRTR_INFO_BLOCK_HEADER) NULL;

#ifdef KSL_IPINIP
    PIPINIP_CONFIG_INFO pIpIpCfg;
#endif //KSL_IPINIP


    //
    // Allocate for minimal interface Info.
    // a TOC entry is allocated for IP_ROUTE_INFO, but no route info
    // block is created, since initially there are no static routes.
    //
    
    dwSize = sizeof( RTR_INFO_BLOCK_HEADER )                                + 
             sizeof( RTR_TOC_ENTRY ) + sizeof( INTERFACE_STATUS_INFO )      +
             2 * ALIGN_SIZE;

#if 0
    if (dwIfType is ROUTER_IF_TYPE_DEDICATED)
    {
        dwSize += sizeof( RTR_TOC_ENTRY ) 
                + sizeof( RTR_DISC_INFO )
                + ALIGN_SIZE;

        dwTocEntries++;
    }
#endif

    pIBH = (PRTR_INFO_BLOCK_HEADER) HeapAlloc( GetProcessHeap(), 0, dwSize );
    
    if ( pIBH == (PRTR_INFO_BLOCK_HEADER) NULL )
    {
        *ppBuff = (LPBYTE) NULL;
        DisplayMessage( g_hModule, MSG_IP_NOT_ENOUGH_MEMORY  );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    *ppBuff                     = (LPBYTE) pIBH;

    pIBH-> Version              = RTR_INFO_BLOCK_VERSION;
    pIBH-> TocEntriesCount      = dwTocEntries;
    pIBH-> Size                 = dwSize;

    
    pbDataPtr = (LPBYTE) &( pIBH-> TocEntry[ pIBH-> TocEntriesCount ] );
    ALIGN_POINTER( pbDataPtr );

    //
    // Create empty route info block
    //
    
    pTocEntry                   = (PRTR_TOC_ENTRY) &( pIBH-> TocEntry[ 0 ] );
    pTocEntry-> InfoType        = IP_ROUTE_INFO;
    pTocEntry-> InfoSize        = sizeof( MIB_IPFORWARDROW );
    pTocEntry-> Count           = 0;
    pTocEntry-> Offset          = (ULONG) (pbDataPtr - (PBYTE) pIBH);
            
    pbDataPtr += pTocEntry-> Count * pTocEntry-> InfoSize;
    ALIGN_POINTER( pbDataPtr );
    
    //
    // Create interface status block.
    //

    pTocEntry                   = (PRTR_TOC_ENTRY) &( pIBH-> TocEntry[ 1 ] );
    pTocEntry-> InfoType        = IP_INTERFACE_STATUS_INFO;
    pTocEntry-> InfoSize        = sizeof( INTERFACE_STATUS_INFO );
    pTocEntry-> Count           = 1;
    pTocEntry-> Offset          = (ULONG) (pbDataPtr - (LPBYTE) pIBH);
    
    pifStat                     = (PINTERFACE_STATUS_INFO) pbDataPtr;
    pifStat-> dwAdminStatus     = g_dwIfState;
    
    pbDataPtr += pTocEntry-> Count * pTocEntry-> InfoSize;
    ALIGN_POINTER( pbDataPtr );
    
#if 0
    if (dwIfType is ROUTER_IF_TYPE_DEDICATED)
    {
        //
        // Create Router Disc. Info.
        //
    
        pTocEntry                   = (PRTR_TOC_ENTRY) &( pIBH-> TocEntry[ 2 ]);
        pTocEntry-> InfoType        = IP_ROUTER_DISC_INFO;
        pTocEntry-> InfoSize        = sizeof( RTR_DISC_INFO );
        pTocEntry-> Count           = 1;
        pTocEntry-> Offset          = (ULONG) (pbDataPtr - (LPBYTE) pIBH);
        
    
        pRtrDisc                    = (PRTR_DISC_INFO) pbDataPtr;
    
        pRtrDisc-> bAdvertise       = TRUE;
        pRtrDisc-> wMaxAdvtInterval = g_wMaxAdvtInterval;
        pRtrDisc-> wMinAdvtInterval = g_wMinAdvtInterval;
        pRtrDisc-> wAdvtLifetime    = g_wAdvtLifeTime;
        pRtrDisc-> lPrefLevel		= g_lPrefLevel;

        pbDataPtr += pTocEntry-> Count * pTocEntry-> InfoSize;

        ALIGN_POINTER( pbDataPtr );
    }
#endif

    return NO_ERROR;
}

DWORD
AddInterfaceInfo(
    IN    LPCWSTR                    pwszIfName
    )
{
    DWORD       dwRes               = (DWORD) -1,
                dwIfType,
                dwSize              = 0;
    BOOL        bAddRtrMgr          = FALSE;

    HANDLE      hInterface          = (HANDLE) NULL,
                hTransport          = (HANDLE) NULL,
                hIfAdmin            = (HANDLE) NULL,
                hIfTransport        = (HANDLE) NULL;

    PRTR_INFO_BLOCK_HEADER  pibhTmp = (PRTR_INFO_BLOCK_HEADER) NULL;

#ifdef EXTRA_DEBUG
    PRINT(L"AddInterfaceInfo:");
    PRINT(pwszIfName);
#endif

    do
    {
        PMPR_INTERFACE_0 pmiIfInfo;

        //
        // verify interface name.
        //

        dwRes = MprConfigInterfaceGetHandle( g_hMprConfig,
                                             (LPWSTR)pwszIfName,
                                             &hInterface );
        if ( dwRes != NO_ERROR )
        {
            DisplayMessage( g_hModule, MSG_NO_INTERFACE, pwszIfName );
            break;
        }

        // Make sure interface exists

        dwRes = MprConfigInterfaceGetInfo(g_hMprConfig,
                                          hInterface,
                                          0,
                                          (BYTE **)&pmiIfInfo,
                                          &dwSize);
        if( dwRes != NO_ERROR )
        {
            DisplayError( NULL, dwRes );
            break;
        }

        dwIfType = pmiIfInfo->dwIfType;


#ifdef KSL_IPINIP
        // Here's a hack due apparently due to the inability of
        // the current stack to do Foo-over-IP tunnels, so adding 
        // an ipip tunnel both creates the tunnel and enables IP 
        // on it.

        if(dwIfType is ROUTER_IF_TYPE_TUNNEL1)
        {
            MprConfigBufferFree(pmiIfInfo);

            dwRes = ERROR_INVALID_PARAMETER;
            DisplayMessage(g_hModule, MSG_IP_IF_IS_TUNNEL);

            break;
        }
#endif //KSL_IPINIP


        MprConfigBufferFree(pmiIfInfo);

        //
        // Is IP RtrMgr present on this router.
        //
        // if specified IP router manager is absent,
        // we shall need to add global info for this
        // router manager "before" we add the interface
        // information
        //

        //
        // Try to get a handle to the rtr mgr.
        //

        dwRes = MprConfigTransportGetHandle(g_hMprConfig,
                                            PID_IP,
                                            &hTransport);
        if ( dwRes != NO_ERROR )
        {
            if ( dwRes == ERROR_UNKNOWN_PROTOCOL_ID )
            {
                bAddRtrMgr = TRUE;
            }
            else
            {
                DisplayError( NULL, dwRes );
                break;
            }
        }

        //
        // if handle is available, try to retrieve global info.
        // if not available we shall need to add the global info.
        //

        if ( !bAddRtrMgr )
        {
            dwRes = MprConfigTransportGetInfo(g_hMprConfig,
                                              hTransport,
                                              (LPBYTE*) &pibhTmp,
                                              &dwSize,
                                              NULL,
                                              NULL,
                                              NULL);
            if ( dwRes != NO_ERROR )
            {
                DisplayError( NULL, dwRes );
                break;
            }

            if ( pibhTmp == (PRTR_INFO_BLOCK_HEADER) NULL )
            {
                bAddRtrMgr = TRUE;
            }

            else
            {
                MprConfigBufferFree( pibhTmp );
                pibhTmp = NULL;
            }
        }

        //
        // If IP is already present on router, see if IP was already
        // added to the interface.  If so, complain.
        //

        if ( !bAddRtrMgr )
        {
            dwRes = MprConfigInterfaceTransportGetHandle(g_hMprConfig,
                                                         hInterface,
                                                         PID_IP,
                                                         &hIfTransport);
            if ( dwRes == NO_ERROR )
            {
                dwRes =  ERROR_INVALID_PARAMETER;
                // was SetInterfaceInRouterConfig(); to update
                break;
            }
        }

        //
        // If IP RtrMgr is not present, add global info.
        //

        if ( bAddRtrMgr )
        {
            dwRes = MakeIPGlobalInfo( (LPBYTE *)&pibhTmp );
            if ( dwRes != NO_ERROR )
            {
                break;
            }
            dwRes = MprConfigTransportCreate( g_hMprConfig,
                                              PID_IP,
                                              IP_KEY,
                                              (LPBYTE) pibhTmp,
                                              pibhTmp-> Size,
                                              NULL,
                                              0,
                                              g_wszRtrMgrDLL,
                                              &hTransport );
            if ( dwRes != NO_ERROR )
            {
                DisplayError( NULL, dwRes );
                break;
            }

            HeapFree( GetProcessHeap(), 0, pibhTmp );
        }

        pibhTmp = (PRTR_INFO_BLOCK_HEADER) NULL;

        //
        // Add IP Rtr Mgr. information for the interface
        //

        dwRes = MakeIPInterfaceInfo( (LPBYTE*) &pibhTmp, dwIfType);

        if ( dwRes != NO_ERROR )
        {
            break;
        }

        dwRes = MprConfigInterfaceTransportAdd( g_hMprConfig,
                                                hInterface,
                                                PID_IP,
                                                IP_KEY,
                                                (LPBYTE) pibhTmp,
                                                pibhTmp-> Size,
                                                &hIfTransport );
        if ( dwRes != NO_ERROR )
        {
            DisplayError( NULL, dwRes );
            break;
        }

        if(IsRouterRunning())
        {
            dwRes = MprAdminInterfaceGetHandle(g_hMprAdmin,
                                               (LPWSTR)pwszIfName,
                                               &hIfAdmin,
                                               FALSE);

            if ( dwRes != NO_ERROR )
            {
                break;
            }

            dwRes = MprAdminInterfaceTransportAdd( g_hMprAdmin,
                                                   hIfAdmin,
                                                   PID_IP,
                                                   (LPBYTE) pibhTmp,
                                                   pibhTmp->Size );

            if ( dwRes != NO_ERROR )
            {
                DisplayMessage( g_hModule, ERROR_ADMIN, dwRes );
                break;
            }

            break;
        }

    } while( FALSE );

    //
    // Free all allocations
    //

    if ( pibhTmp ) { HeapFree( GetProcessHeap(), 0, pibhTmp ); }

    return dwRes;
}

DWORD
DeleteInterfaceInfo(
    IN    LPCWSTR    pwszIfName
    )
{
    DWORD     dwRes, dwIfType = 0, dwErr;
    HANDLE    hIfTransport, hInterface;

    do
    {
        dwRes = MprConfigInterfaceGetHandle(g_hMprConfig,
                                            (LPWSTR)pwszIfName,
                                            &hInterface);
            
        if ( dwRes != NO_ERROR )
        {
            break;
        }
       
        //
        // Get the type of the interface
        //

        dwErr = GetInterfaceInfo(pwszIfName,
                                 NULL,
                                 NULL,
                                 &dwIfType);

        if(dwErr != NO_ERROR)
        {
            break;
        }

        dwRes = MprConfigInterfaceTransportGetHandle(g_hMprConfig,
                                                     hInterface,
                                                     PID_IP,
                                                     &hIfTransport);
        
        if ( dwRes != NO_ERROR )
        {
            break;
        }
        
        dwRes = MprConfigInterfaceTransportRemove(g_hMprConfig,
                                                  hInterface,
                                                  hIfTransport);

#ifdef KSL_IPINIP
        //
        // If its an ip in ip tunnel, clear out its name and delete from the
        // router
        //

        if(dwIfType == ROUTER_IF_TYPE_TUNNEL1)
        {
            dwRes = MprConfigInterfaceDelete(g_hMprConfig,
                                             hInterface);

            if(dwRes == NO_ERROR)
            {
                GUID      Guid;

                dwRes = ConvertStringToGuid(pwszIfName,
                                            (USHORT)(wcslen(pwszIfName) * sizeof(WCHAR)),
                                            &Guid);
        
                if(dwRes != NO_ERROR)
                {
                    break;
                }

                MprSetupIpInIpInterfaceFriendlyNameDelete(g_pwszRouter,
                                                          &Guid);
            }
        }
#endif //KSL_IPINIP


        if(IsRouterRunning())
        {
            dwRes = MprAdminInterfaceGetHandle(g_hMprAdmin,
                                               (LPWSTR)pwszIfName,
                                               &hInterface,
                                               FALSE);

            if ( dwRes != NO_ERROR )
            {
                break;
            }

            dwRes = MprAdminInterfaceTransportRemove(g_hMprAdmin,
                                                     hInterface,
                                                     PID_IP);

#ifdef KSL_IPINIP
            if(dwIfType == ROUTER_IF_TYPE_TUNNEL1)
            {
                dwRes = MprAdminInterfaceDelete(g_hMprAdmin,
                                                hInterface);
            }
#endif //KSL_IPINIP


            break;
        }
        
    } while (FALSE);

    return dwRes;
}

DWORD
SetInterfaceInfo(
    IN    PRTR_INFO_BLOCK_HEADER    pibhInfo,
    IN    LPCWSTR                   pwszIfName
    )

/*++

Routine Description:

    Sets interface transport information in registry or router.
    
Arguments:

    pwszIfName  - Interface Name
    pibhInfo   - ptr to header
    
Return Value:

    NO_ERROR, ERROR_ROUTER_STOPPED
    
--*/

{
    DWORD                   dwARes = NO_ERROR,
                            dwCRes = NO_ERROR;
    HANDLE                  hIfTransport, hInterface;
    UINT                    i;
    PRTR_INFO_BLOCK_HEADER  pibhNewInfo, pibhOldInfo;

    // 
    // Create a new info block with all 0-length blocks removed
    // since we don't want to write them to the registry,
    // we only need to send them to the router which we
    // will do with the original info block below.
    //

    pibhNewInfo = pibhInfo;
    pibhOldInfo = NULL;

    for (i=0; (dwCRes is NO_ERROR) && (i<pibhInfo->TocEntriesCount); i++)
    {
        if (pibhInfo->TocEntry[i].InfoSize is 0)
        {
            pibhOldInfo = pibhNewInfo;

            dwCRes = MprInfoBlockRemove(pibhOldInfo, 
                                        pibhInfo->TocEntry[i].InfoType,
                                        &pibhNewInfo);

            if (pibhOldInfo isnot pibhInfo)
            {
                FREE_BUFFER(pibhOldInfo);
            }
        }
    }

    if (dwCRes is NO_ERROR)
    {
        dwCRes = MprConfigInterfaceGetHandle(g_hMprConfig,
                                             (LPWSTR)pwszIfName,
                                             &hInterface);
    }

    if (dwCRes is NO_ERROR)
    {
        dwCRes = MprConfigInterfaceTransportGetHandle(g_hMprConfig,
                                                      hInterface,
                                                      PID_IP,
                                                      &hIfTransport);
    }

    if (dwCRes is NO_ERROR)
    {
        dwCRes = MprConfigInterfaceTransportSetInfo(g_hMprConfig,
                                                    hInterface,
                                                    hIfTransport,
                                                    (LPBYTE) pibhNewInfo,
                                                    pibhNewInfo->Size);
    }

    if (pibhNewInfo isnot pibhInfo)
    {
        FREE_BUFFER(pibhNewInfo);
    }

    //
    // Even if we failed to write to the registry, we still want
    // to write to the router.
    //
    // We use the original format when writing to the router, since it 
    // needs to see the 0-length blocks in order to delete config info.
    //

    if(IsRouterRunning())
    {
        dwARes = MprAdminInterfaceGetHandle(g_hMprAdmin,
                                            (LPWSTR)pwszIfName,
                                            &hInterface,
                                            FALSE);

        if (dwARes is NO_ERROR)
        {
            dwARes = MprAdminInterfaceTransportSetInfo(g_hMprAdmin,
                                                       hInterface,
                                                       PID_IP,
                                                       (LPBYTE) pibhInfo,
                                                       pibhInfo->Size);
        }
    }

    return (dwARes isnot NO_ERROR)? dwARes : dwCRes;
}

DWORD
WINAPI
IpCommit(
    IN  DWORD   dwAction
    )
{
    PINTERFACE_STORE    pii;
    PLIST_ENTRY        ple, pleTmp;
    BOOL               bCommit, bFlush = FALSE;

    switch(dwAction)
    {
        case NETSH_COMMIT:
        {
            if (g_bCommit == TRUE)
            {
                return NO_ERROR;
            }

            g_bCommit = TRUE;

            break;
        }

        case NETSH_UNCOMMIT:
        {
            g_bCommit = FALSE;

            return NO_ERROR;
        }

        case NETSH_SAVE:
        {
            if (g_bCommit)
            {
                return NO_ERROR;
            }

            break;
        }

        case NETSH_FLUSH:
        {
            //
            // Action is a flush. If current state is commit, then
            // nothing to be done.

            if (g_bCommit)
            {
                return NO_ERROR;
            }

            bFlush = TRUE;

            break;
        }

        default:
        {
            return NO_ERROR;
        }
    }

    //
    // Switched to commit mode. So set all valid info in the
    // strutures. Free memory and invalidate the info.
    //

    if((g_tiTransport.bValid && g_tiTransport.pibhInfo) &&
        !bFlush)
    {
        SetGlobalInfo(g_tiTransport.pibhInfo);

    }

    g_tiTransport.bValid = FALSE;

    if(g_tiTransport.pibhInfo)
    {
        FREE_BUFFER(g_tiTransport.pibhInfo);

        g_tiTransport.pibhInfo = NULL;
    }

    //
    // Set the interface info
    //

    while(!IsListEmpty(&g_leIfListHead))
    {
        ple = RemoveHeadList(&g_leIfListHead);

        pii = CONTAINING_RECORD(ple,
                                INTERFACE_STORE,
                                le);

        if ((pii->bValid && pii->pibhInfo) &&
            !bFlush)
        {
            // Set the info in config

            SetInterfaceInfo(pii->pibhInfo,
                             pii->pwszIfName);
        }

        pii->bValid = FALSE;

        if(pii->pibhInfo)
        {
            FREE_BUFFER(pii->pibhInfo);

            pii->pibhInfo = NULL;
        }

        if(pii->pwszIfName)
        {
            HeapFree(GetProcessHeap(),
                     0,
                     pii->pwszIfName);

            pii->pwszIfName = NULL;
        }

        //
        // Free the list entry
        //

        HeapFree(GetProcessHeap(),
                 0,
                 pii);
    }

    return NO_ERROR;
}

#ifdef KSL_IPINIP
DWORD
CreateInterface(
    IN  LPCWSTR pwszFriendlyName,
    IN  LPCWSTR pwszGuidName,
    IN  DWORD   dwIfType,
    IN  BOOL    bCreateRouterIf
    )

{
    DWORD   i, dwErr, dwType, dwSize;
    HANDLE  hIfCfg, hIfAdmin, hIfTransport;
    PBYTE   pbyData;

    PRTR_INFO_BLOCK_HEADER  pInfo;
    PINTERFACE_STATUS_INFO  pStatus;
#if 0
    PRTR_DISC_INFO          pDisc;
#endif

    //
    // The only type we can create in the router is TUNNEL1
    //

    if(dwIfType != ROUTER_IF_TYPE_TUNNEL1)
    {
        ASSERT(FALSE);

        return ERROR_INVALID_PARAMETER;
    }

    hIfAdmin = NULL;
    hIfCfg   = NULL;

    if(bCreateRouterIf)
    {
        MPR_INTERFACE_0         IfInfo;

        //
        // The caller wants us to create an interface in the router, also
        //

        wcsncpy(IfInfo.wszInterfaceName,
                pwszGuidName,
                MAX_INTERFACE_NAME_LEN);

        IfInfo.fEnabled = TRUE;

        IfInfo.dwIfType = dwIfType;

        IfInfo.wszInterfaceName[MAX_INTERFACE_NAME_LEN] = UNICODE_NULL;

        dwErr = MprConfigInterfaceCreate(g_hMprConfig,
                                         0,
                                         (PBYTE)&IfInfo,
                                         &hIfCfg);

        if(dwErr isnot NO_ERROR)
        {
            DisplayError(NULL,
                         dwErr);

            return dwErr;
        }

        //
        // if router service is running add the interface
        // to it too.
        //

        if(IsRouterRunning())
        {
            dwErr = MprAdminInterfaceCreate(g_hMprAdmin,
                                            0,
                                            (PBYTE)&IfInfo,
                                            &hIfAdmin);

            if(dwErr isnot NO_ERROR)
            {
                DisplayError(NULL,
                             dwErr);


                MprConfigInterfaceDelete(g_hMprConfig,
                                         hIfCfg);
   
                return dwErr;
            }
        }
    }
    else
    {
        //
        // The interface existed in the router but not in IP
        //

        dwErr = MprConfigInterfaceGetHandle(g_hMprConfig,
                                            (LPWSTR)pwszGuidName,
                                            &hIfCfg);

        if(dwErr isnot NO_ERROR)
        {
            DisplayError(NULL,
                         dwErr);

            return dwErr;
        }

        if(IsRouterRunning())
        {
            dwErr = MprAdminInterfaceGetHandle(g_hMprAdmin,
                                               (LPWSTR)pwszGuidName,
                                               &hIfAdmin,
                                               FALSE);

            if(dwErr isnot NO_ERROR)
            {
                DisplayError(NULL,
                             dwErr);

                return dwErr;
            }
        }
    }

    //
    // At this point we have an interface which doesnt have IP on it
    // We have the handles to config and admin (if router is running)
    // Set the default information for the interface
    //

    dwSize  =  FIELD_OFFSET(RTR_INFO_BLOCK_HEADER, TocEntry[0]);

    dwSize += (sizeof(INTERFACE_STATUS_INFO) +
               sizeof(RTR_TOC_ENTRY) +
               ALIGN_SIZE);

#if 0
    dwSize += (sizeof(RTR_DISC_INFO) +
               sizeof(RTR_TOC_ENTRY) +
               ALIGN_SIZE);
#endif

    pInfo = HeapAlloc(GetProcessHeap(),
                      0,
                      dwSize);

    if(pInfo is NULL)
    {
        DisplayError(NULL,
                     ERROR_NOT_ENOUGH_MEMORY);

        if(bCreateRouterIf)
        {
            MprConfigInterfaceDelete(g_hMprConfig,
                                     hIfCfg);
        }

        return ERROR_NOT_ENOUGH_MEMORY;
    }

    pInfo->Version          = IP_ROUTER_MANAGER_VERSION;
    pInfo->TocEntriesCount  = 1;
    pInfo->Size             = dwSize;

    //
    // Make data point to N+1th entry
    //

    pbyData = (PBYTE)&(pInfo->TocEntry[1]);

    ALIGN_POINTER(pbyData);

    pStatus = (PINTERFACE_STATUS_INFO)pbyData;

    pStatus->dwAdminStatus =  IF_ADMIN_STATUS_UP;

    pInfo->TocEntry[0].InfoSize  = sizeof(INTERFACE_STATUS_INFO);
    pInfo->TocEntry[0].InfoType  = IP_INTERFACE_STATUS_INFO;
    pInfo->TocEntry[0].Count     = 1;
    pInfo->TocEntry[0].Offset    = (ULONG)(pbyData - (PBYTE)pInfo);

    pbyData = (PBYTE)((ULONG_PTR)pbyData + sizeof(INTERFACE_STATUS_INFO));

    ALIGN_POINTER(pbyData);

#if 0
    pDisc = (PRTR_DISC_INFO)pbyData;

    pDisc->wMaxAdvtInterval = 
        DEFAULT_MAX_ADVT_INTERVAL;
    pDisc->wMinAdvtInterval = 
        (WORD)(DEFAULT_MIN_ADVT_INTERVAL_RATIO * DEFAULT_MAX_ADVT_INTERVAL);
    pDisc->wAdvtLifetime    = 
        DEFAULT_ADVT_LIFETIME_RATIO * DEFAULT_MAX_ADVT_INTERVAL;
    pDisc->bAdvertise       = FALSE;
    pDisc->lPrefLevel       = DEFAULT_PREF_LEVEL;

    pInfo->TocEntry[1].InfoSize  = sizeof(RTR_DISC_INFO);
    pInfo->TocEntry[1].InfoType  = IP_ROUTER_DISC_INFO;
    pInfo->TocEntry[1].Count     = 1;
    pInfo->TocEntry[1].Offset    = (ULONG)(pbyData - (PBYTE)pInfo);
#endif

    dwErr = MprConfigInterfaceTransportAdd(g_hMprConfig,
                                           hIfCfg,
                                           PID_IP,
                                           IP_KEY,
                                           (PBYTE) pInfo,
                                           dwSize,
                                           &hIfTransport);

    if(dwErr isnot NO_ERROR)
    {
        HeapFree(GetProcessHeap(),
                 0,
                 pInfo);

        DisplayMessage(g_hModule,
                       EMSG_CANT_CREATE_IF,
                       pwszFriendlyName,
                       dwErr);

        if(bCreateRouterIf)
        {
            MprConfigInterfaceDelete(g_hMprConfig,
                                     hIfCfg);
        }

        return dwErr;
    }

    if(hIfAdmin isnot NULL)
    {
        dwErr = MprAdminInterfaceTransportAdd(g_hMprAdmin,
                                              hIfAdmin,
                                              PID_IP,
                                              (PBYTE) pInfo,
                                              dwSize);

        if(dwErr isnot NO_ERROR)
        {
            DisplayMessage(g_hModule,
                           EMSG_CANT_CREATE_IF,
                           pwszFriendlyName,
                           dwErr);

            MprConfigInterfaceTransportRemove(g_hMprConfig,
                                              hIfCfg,
                                              hIfTransport);

            if(bCreateRouterIf)
            {
                MprConfigInterfaceDelete(g_hMprConfig,
                                         hIfCfg);
            }

        }
    }

    HeapFree(GetProcessHeap(),
             0,
             pInfo);

    return NO_ERROR;
}
#endif //KSL_IPINIP


DWORD
GetInterfaceClass(
    IN  LPCWSTR pwszIfName,
    OUT PDWORD  pdwIfClass
    )
/*++
Description:
    Determine whether an interface is of class Loopback, P2P,
    Subnet, or NBMA.  Currently there is no global way to do this,
    so we test for some enumerated types and assume everything else
    is Subnet.
Returns:
    IFCLASS_xxx (see info.h)
--*/
{
    DWORD   dwErr, dwType;

    dwErr = GetInterfaceInfo(pwszIfName,
                             NULL,
                             NULL,
                             &dwType);

    if (dwErr)
    {
        return dwErr;
    }

    switch (dwType) {
    case ROUTER_IF_TYPE_FULL_ROUTER : *pdwIfClass = IFCLASS_P2P;       break;
    case ROUTER_IF_TYPE_INTERNAL    : *pdwIfClass = IFCLASS_NBMA;      break;
    case ROUTER_IF_TYPE_LOOPBACK    : *pdwIfClass = IFCLASS_LOOPBACK;  break;
#ifdef KSL_IPINIP
    case ROUTER_IF_TYPE_TUNNEL1     : *pdwIfClass = IFCLASS_P2P;       break;
#endif //KSL_IPINIP
    case ROUTER_IF_TYPE_DIALOUT     : *pdwIfClass = IFCLASS_P2P;       break;
    default:                          *pdwIfClass = IFCLASS_BROADCAST; break;
    }

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ip\ipmon\filter.c ===
#include "precomp.h"

DWORD
UpdateFragCheckInfo(
    IN    LPCWSTR pwszIfName,
    IN    BOOL    bFragCheck
    )

/*++

Routine Description:

    Updates fragcheck variable

Arguments:

    pwszIfName - Interface Name
    bFragCheck - enabled or disabled
    
Return Value:

    NO_ERROR
    
--*/

{
    DWORD              dwBlkSize, dwCount, dwErr = NO_ERROR;
    PIFFILTER_INFO     pfi     = NULL;
    IFFILTER_INFO      Info;
    DWORD              dwIfType;

    do
    {
        //
        // Make sure that the input or output filter blocks are present
        //

        if ((IpmontrGetInfoBlockFromInterfaceInfo(pwszIfName,
                                           IP_IN_FILTER_INFO,
                                           NULL,
                                           NULL,
                                           NULL,
                                           NULL) != NO_ERROR) &&
            (IpmontrGetInfoBlockFromInterfaceInfo(pwszIfName,
                                           IP_OUT_FILTER_INFO,
                                           NULL,
                                           NULL,
                                           NULL,
                                           NULL) != NO_ERROR))
        {
            dwErr = ERROR_INVALID_PARAMETER;

            DisplayMessage(g_hModule,  MSG_IP_NO_FILTER_FOR_FRAG);

            break;
        }            
            
        //
        // Get the IP_IFFILTER_INFO block from router config/router
        //

        dwErr = IpmontrGetInfoBlockFromInterfaceInfo(pwszIfName,
                                              IP_IFFILTER_INFO,
                                              (PBYTE *) &pfi,
                                              &dwBlkSize,
                                              &dwCount,
                                              &dwIfType);

        if (dwErr is NO_ERROR)
        {
            pfi->bEnableFragChk = bFragCheck;

            dwErr = IpmontrSetInfoBlockInInterfaceInfo(pwszIfName,
                                                IP_IFFILTER_INFO,
                                                (PBYTE) pfi,
                                                dwBlkSize,
                                                dwCount);

            break;
        }

        if (dwErr isnot ERROR_NOT_FOUND)
        {
            break;
        }

        Info.bEnableFragChk = bFragCheck;

        dwErr = IpmontrSetInfoBlockInInterfaceInfo(pwszIfName,
                                            IP_IFFILTER_INFO,
                                            (PBYTE) &Info,
                                            sizeof(IFFILTER_INFO),
                                            1);

    } while (FALSE);

    if (pfi)
    {
        HeapFree(GetProcessHeap(), 0, pfi);
    }

    switch(dwErr)
    {
        case NO_ERROR:
            break;

        case ERROR_NOT_ENOUGH_MEMORY:
            DisplayMessage(g_hModule, MSG_IP_NOT_ENOUGH_MEMORY);
            break;

        case ERROR_INVALID_PARAMETER:
            break;
            
        default:
            DisplayError(g_hModule,
                         dwErr);
            break;
    }

    return dwErr;
}

DWORD
SetFragCheckInfo(
    IN    LPCWSTR pwszIfName,
    IN    BOOL    bFragChk
    )

/*++

Routine Description:

    Updates fragcheck info in router and router config

Arguments:

    pwszIfName - Interface Name
    bFragCheck - enabled or disabled
    
Return Value:

    NO_ERROR
    
--*/

{
    DWORD    dwErr;

    dwErr = UpdateFragCheckInfo(pwszIfName, bFragChk);

    return dwErr;
}

DWORD
SetFilterInfo(
    IN    LPCWSTR   pwszIfName,
    IN    DWORD     dwFilterType,
    IN    DWORD     dwAction
    )

/*++

Routine Description:

    Sets filter info

Arguments:

    pwszIfName   - interface name
    dwFilterType - Filter type (input, output or dial)
    dwAction     - drop or forward 
    
Return Value:

    ERROR_OKAY
    
--*/

{
    PFILTER_DESCRIPTOR      pfd = (PFILTER_DESCRIPTOR) NULL;
    FILTER_DESCRIPTOR       Info;
    DWORD                   dwRes = NO_ERROR;
    DWORD                   dwBlkSize, dwIfType, dwCount;
    BOOL                    bFree;

    bFree = FALSE;
 
    do
    {
        dwRes = IpmontrGetInfoBlockFromInterfaceInfo(pwszIfName,
                                              dwFilterType,
                                              (PBYTE *) &pfd,
                                              &dwBlkSize,
                                              &dwCount,
                                              &dwIfType);
        
        if (dwRes != NO_ERROR)
        {
            Info.dwVersion          = IP_FILTER_DRIVER_VERSION;
            Info.dwNumFilters       = 0;
            Info.faDefaultAction    = (PFFORWARD_ACTION) dwAction;

            dwCount     = 1;
            dwBlkSize   = FIELD_OFFSET(FILTER_DESCRIPTOR, fiFilter[0]);

            pfd         = &Info;

            bFree       = FALSE;
        }
        else
        {
            pfd->faDefaultAction = (PFFORWARD_ACTION) dwAction;

            bFree = TRUE;
        }

        dwRes = IpmontrSetInfoBlockInInterfaceInfo(pwszIfName,
                                            dwFilterType,
                                            (PBYTE) pfd,
                                            dwBlkSize,
                                            dwCount);
        
        if ( dwRes != NO_ERROR )
        {
            break;
        }

    } while (FALSE);

    if (bFree)
    {
        HeapFree(GetProcessHeap(), 0, pfd);
    }

    switch(dwRes)
    {
        case NO_ERROR:
            dwRes = ERROR_OKAY;
            break;

        case ERROR_NOT_FOUND:
            DisplayMessage(g_hModule, EMSG_IP_NO_FILTER_INFO);
            break;

        case ERROR_NOT_ENOUGH_MEMORY:
            DisplayMessage(g_hModule, MSG_IP_NOT_ENOUGH_MEMORY);
            break;

        default:
            DisplayError(g_hModule, dwRes);
            break;
    }

    return dwRes;
}



DWORD
AddDelFilterInfo(
    IN    FILTER_INFO    fi,
    IN    LPCWSTR        pwszIfName,
    IN    DWORD          dwFilterType,
    IN    BOOL           bAdd
    )

/*++

Routine Description:

    Adds/deletes interface filters

Arguments:

    fi            -  Filter info
    pwszIfName    -  Interface Name
    dwFilterType  -  FilterType
    bAdd          -  To add or not 
    
Return Value:

    ERROR_OKAY
    
--*/

{
    DWORD                 dwRes = (DWORD) -1;
    PFILTER_DESCRIPTOR    pfd = NULL, pfdNew = NULL;
    DWORD                 dwIfType, dwBlkSize, dwNewSize, dwCount;

    
    do
    {
        dwRes = IpmontrGetInfoBlockFromInterfaceInfo(pwszIfName,
                                              dwFilterType,
                                              (PBYTE *) &pfd,
                                              &dwBlkSize,
                                              &dwCount,
                                              &dwIfType);

        if (dwRes is ERROR_NOT_FOUND && bAdd)
        {
            //
            // No filter info of this type is currently present
            //
            
            pfd = NULL;
            dwRes = NO_ERROR;
            dwCount = 1;
        }
        
        if (dwRes isnot NO_ERROR)
        {
            break;
        }
        
        dwRes = (bAdd) ? AddNewFilter(pfd, fi, dwBlkSize, &pfdNew, &dwNewSize):
                DeleteFilter(pfd, fi, dwBlkSize, &pfdNew, &dwNewSize);
            
        if ( dwRes != NO_ERROR )
        {
            break;
        }

        dwRes = IpmontrSetInfoBlockInInterfaceInfo(pwszIfName,
                                            dwFilterType,
                                            (PBYTE) pfdNew,
                                            dwNewSize,
                                            dwCount);

        if (dwRes isnot NO_ERROR)
        {
            break;
        }
        
        if (pfd)
        {
            HeapFree(GetProcessHeap(), 0 , pfd);
            pfd = NULL;
        }
        
        HeapFree(GetProcessHeap(), 0 , pfdNew);
        pfdNew = NULL;
        
        DEBUG("Made Changes to Route config");

    } while ( FALSE );

    if (pfd)
    {
        HeapFree(GetProcessHeap(), 0, pfd);
    }

    switch(dwRes)
    {
        case NO_ERROR:
            dwRes = ERROR_OKAY;
            break;

        case ERROR_NOT_FOUND :
            DisplayMessage(g_hModule, EMSG_IP_NO_FILTER_INFO);
            break;
            
        case ERROR_NOT_ENOUGH_MEMORY:
            DisplayMessage(g_hModule, MSG_IP_NOT_ENOUGH_MEMORY);
            break;

        default:
            DisplayError(g_hModule, dwRes);
            break;
    }
    
    return dwRes;
}

DWORD
AddNewFilter( 
    IN    PFILTER_DESCRIPTOR    pfd,
    IN    FILTER_INFO           fi,
    IN    DWORD                 dwBlkSize, 
    OUT   PFILTER_DESCRIPTOR    *ppfd,
    OUT   PDWORD                pdwSize
    )

/*++

Routine Description:

    Adds interface filter

Arguments:

Return Value:

    NO_ERROR
    
--*/

{
    DWORD                   dwNumFilt = 0, dwSize = 0, dwInd = 0;
    DWORD                   dwRes = (DWORD) -1;
    PFILTER_DESCRIPTOR      pfdSrc = (PFILTER_DESCRIPTOR) NULL;
    PFILTER_DESCRIPTOR      pfdDst = (PFILTER_DESCRIPTOR) NULL;

    pfdSrc = pfd;
    
    do
    {
        //
        // If filter info block was found, check if the filter being added 
        // is already present.  If it is quit and return ok
        //

        if ( pfdSrc )
        {
            if ( IsFilterPresent( pfdSrc, fi, &dwInd ) )
            {
                dwRes = ERROR_OBJECT_ALREADY_EXISTS;

                break;
            }

            //
            // We can be left with a FILTER_DESCRIPTOR with no filters if
            // the added filters have all been deleted.  Once a 
            // FILTER_DESCRIPTOR has been added, it is never deleted even
            // if all the filters in it have been.
            //
            
            dwSize = dwBlkSize + sizeof(FILTER_INFO);

            dwNumFilt = pfdSrc-> dwNumFilters;
        }
        
        else
        {
            dwNumFilt = 0;
            
            dwSize = sizeof( FILTER_DESCRIPTOR );
        }

        //
        // Create new info block 
        //
        
        pfdDst = HeapAlloc(GetProcessHeap(), 
                           0, 
                           dwSize);
        
        if ( pfdDst is NULL )
        {
            dwRes = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        if (pfdSrc)
        {
            //
            // Copy info blocks as is.
            //
        
            CopyMemory(pfdDst, pfdSrc, dwSize);
        }
        else
        {
            //
            // if new filter info block has to be added set up the
            // FILTER_DESCRIPTOR 
            //

            pfdDst-> dwVersion           = IP_FILTER_DRIVER_VERSION;
            pfdDst-> faDefaultAction     = PF_ACTION_FORWARD;
            pfdDst-> dwNumFilters        = 0;
        }

        //
        // Append new filter
        //
        
        pfdDst-> fiFilter[ dwNumFilt ].dwSrcAddr     = fi.dwSrcAddr;
        pfdDst-> fiFilter[ dwNumFilt ].dwSrcMask     = fi.dwSrcMask;
        pfdDst-> fiFilter[ dwNumFilt ].dwDstAddr     = fi.dwDstAddr;
        pfdDst-> fiFilter[ dwNumFilt ].dwDstMask     = fi.dwDstMask;
        pfdDst-> fiFilter[ dwNumFilt ].dwProtocol    = fi.dwProtocol;

        pfdDst-> fiFilter[ dwNumFilt ].fLateBound    = fi.fLateBound;
        // !@# check when tcp established

        pfdDst-> fiFilter[ dwNumFilt ].wSrcPort  = fi.wSrcPort;
        pfdDst-> fiFilter[ dwNumFilt ].wDstPort  = fi.wDstPort;

        pfdDst-> dwNumFilters++;
        
        *ppfd = pfdDst;

        *pdwSize = dwSize;
        
        dwRes = NO_ERROR;
        
    } while ( FALSE );

    return dwRes;
}


DWORD
DeleteFilter( 
    IN    PFILTER_DESCRIPTOR    pfd,
    IN    FILTER_INFO           fi,
    IN    DWORD                 dwBlkSize,
    OUT   PFILTER_DESCRIPTOR    *ppfd,
    OUT   PDWORD                pdwSize
    )

/*++

Routine Description:

    Deletes interface filter

Arguments:

Return Value:

    NO_ERROR
    
--*/

{
    
    DWORD                   dwRes = NO_ERROR, dwSize = 0, dwNumFilt = 0;
    DWORD                   dwInd = 0, dwSrc = 0, dwDst = 0;
    PFILTER_DESCRIPTOR      pfdSrc      = (PFILTER_DESCRIPTOR) NULL,
                            pfdDst      = (PFILTER_DESCRIPTOR) NULL; 

    
    do
    {
    
        pfdSrc = pfd;

        //
        // if no filter information was found or
        // the specified filter was not found quit.
        //
        
        if ( !pfdSrc )
        {
            dwRes = ERROR_NOT_FOUND;
            break;
        }

        if ( !IsFilterPresent( pfdSrc, fi, &dwInd ) )
        {
            dwRes = ERROR_NOT_FOUND;
            break;
        }

        //
        // delete the filter info. for the specified filter.
        //
        
        dwSize      = dwBlkSize - sizeof( FILTER_INFO );

        dwNumFilt   = pfdSrc-> dwNumFilters - 1;
                   
        pfdDst = HeapAlloc( GetProcessHeap( ), 0, dwSize );
                   
        if ( pfdDst == NULL )
        {
            dwRes = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        pfdDst-> dwVersion              = pfdSrc-> dwVersion;
        pfdDst-> dwNumFilters           = pfdSrc-> dwNumFilters - 1;
        pfdDst-> faDefaultAction        = pfdSrc-> faDefaultAction;
        
        //
        // copy each filter, skipping over the filter to be deleted.
        //
                
        for ( dwSrc = 0, dwDst = 0; 
              dwSrc < pfdSrc-> dwNumFilters;
              dwSrc++
            )
        {
            if ( dwSrc == dwInd )
            {
                continue;
            }
            
            pfdDst-> fiFilter[ dwDst ] = pfdSrc-> fiFilter[ dwSrc ];
            
            dwDst++;                          
         }

        *ppfd = pfdDst;

        *pdwSize = dwSize;
         
    } while( FALSE );

    return dwRes;
}


BOOL
IsFilterPresent(
    PFILTER_DESCRIPTOR pfd,
    FILTER_INFO        fi,
    PDWORD pdwInd
    )

/*++

Routine Description:

    Checks to see if filter is already present

Arguments:

Return Value:

    NO_ERROR
    
--*/

{
    DWORD   dwInd   = 0;

    for ( dwInd = 0; dwInd < pfd-> dwNumFilters; dwInd++ )
    {
        if ( pfd-> fiFilter[ dwInd ].dwSrcAddr != fi.dwSrcAddr ||
             pfd-> fiFilter[ dwInd ].dwSrcMask != fi.dwSrcMask ||
             pfd-> fiFilter[ dwInd ].dwDstAddr != fi.dwDstAddr ||
             pfd-> fiFilter[ dwInd ].dwDstMask != fi.dwDstMask ||
             pfd-> fiFilter[ dwInd ].dwProtocol != fi.dwProtocol )
        {
            continue;
        }

        switch ( fi.dwProtocol )
        {
        case FILTER_PROTO_TCP:
            // compare tcp and tcp established
            if (IsTcpEstablished(&pfd-> fiFilter[ dwInd ]) !=
                IsTcpEstablished(&fi))
            {
                continue;
            }
            // fall through...
            
        case FILTER_PROTO_UDP:
        case FILTER_PROTO_ICMP:
            if ( ( pfd-> fiFilter[ dwInd ].wSrcPort == fi.wSrcPort ) &&
                 ( pfd-> fiFilter[ dwInd ].wDstPort == fi.wDstPort ) )
            {
                *pdwInd = dwInd;
                return TRUE;
            }

            break;

        case FILTER_PROTO_ANY:
            *pdwInd = dwInd;
            return TRUE;

        default:
            *pdwInd = dwInd;
            return TRUE;

        }            
    }

    return FALSE;
}

DWORD
DisplayFilters(
    HANDLE                  hFile,
    PFILTER_DESCRIPTOR      pfd,
    PWCHAR                  pwszIfName,
    PWCHAR                  pwszQuotedIfName,
    DWORD                   dwFilterType
    )

/*++

Routine Description:

    Displays filter information.

Arguments:

    pfd           - Filter to be displayed
    pwszIfName    - Interface name
    dwFilterType  - Filter Type (input , output , dial)
    
Return Value:

    NO_ERROR
    
--*/

{

    DWORD       dwCnt           = 0,
                dwInd           = 0,
                dwRes;

    PWCHAR      pwszType        = (PTCHAR) NULL,
                pwszAction      = (PTCHAR) NULL,
                pwszProtocol    = (PTCHAR) NULL;

    WCHAR       wszSrcAddr[ ADDR_LENGTH + 1 ],
                wszSrcMask[ ADDR_LENGTH + 1 ],
                wszDstAddr[ ADDR_LENGTH + 1 ],
                wszDstMask[ ADDR_LENGTH + 1 ],
                wszProtoNum[24];

    BYTE        *pbyAddr;
    BOOL        bDontFree;


    //
    // Display header
    //

    switch(dwFilterType)
    {
        case IP_IN_FILTER_INFO:
        {
            pwszType = MakeString(g_hModule,  STRING_INPUT );

            break;
        }

        case IP_OUT_FILTER_INFO:
        {
            pwszType = MakeString(g_hModule,  STRING_OUTPUT );

            break;
        }
        case IP_DEMAND_DIAL_FILTER_INFO:
        {
            pwszType = MakeString(g_hModule,  STRING_DIAL );

            break;
        }
    }

    if ( pfd-> faDefaultAction == PF_ACTION_DROP )
    {
        pwszAction  = MakeString(g_hModule,  STRING_DROP );
    }
    else
    {
        pwszAction  = MakeString(g_hModule,  STRING_FORWARD );
    }

    if(pfd->dwNumFilters ||
       (pfd->faDefaultAction == PF_ACTION_DROP))
    {
        if(hFile != NULL)
        {
            DisplayMessageT( DMP_IP_SET_IF_FILTER,
                        pwszQuotedIfName,
                        pwszType,
                        pwszAction);
        }
        else
        {
            DisplayMessage(g_hModule, MSG_RTR_FILTER_HDR,
                           pwszType, 
                           pwszAction);
        }
    }
    
    //
    // Enumerate Filters
    //

    bDontFree = FALSE;

    for ( dwInd = 0;
          dwInd < pfd-> dwNumFilters;
          dwInd++ )
    {
        pbyAddr = (PBYTE) &(pfd-> fiFilter[ dwInd ].dwSrcAddr);
        IP_TO_WSTR(wszSrcAddr, pbyAddr);

        pbyAddr = (PBYTE) &(pfd-> fiFilter[ dwInd ].dwSrcMask);
        IP_TO_WSTR(wszSrcMask, pbyAddr);

        pbyAddr = (PBYTE) &(pfd-> fiFilter[ dwInd ].dwDstAddr);
        IP_TO_WSTR(wszDstAddr, pbyAddr);

        pbyAddr = (PBYTE) &(pfd-> fiFilter[ dwInd ].dwDstMask);
        IP_TO_WSTR(wszDstMask, pbyAddr);

        switch( pfd-> fiFilter[ dwInd ].dwProtocol )
        {
            case FILTER_PROTO_TCP:
                if (IsTcpEstablished(&pfd-> fiFilter[ dwInd ]))
                {
                    pwszProtocol = MakeString(g_hModule,  STRING_TCP_ESTAB );
                }
                else
                {
                    pwszProtocol = MakeString(g_hModule,  STRING_TCP );
                }

                break;

            case FILTER_PROTO_UDP:
                pwszProtocol = MakeString(g_hModule,  STRING_UDP );
                break;
    
            case FILTER_PROTO_ICMP:
                pwszProtocol = MakeString(g_hModule,  STRING_ICMP );
                break;

            case FILTER_PROTO_ANY:
                pwszProtocol = MakeString(g_hModule,  STRING_PROTO_ANY );
                break;

            default:
                wsprintf(wszProtoNum,
                         L"%d",
                         pfd-> fiFilter[ dwInd ].dwProtocol);

                pwszProtocol = wszProtoNum;

                bDontFree = TRUE;

                break;
        }

        if(hFile != NULL)
        {
            DisplayMessageT( DMP_IP_ADD_IF_FILTER,
                        pwszQuotedIfName,                
                        pwszType,
                        wszSrcAddr,
                        wszSrcMask,
                        wszDstAddr,
                        wszDstMask,
                        pwszProtocol);

            if((pfd-> fiFilter[dwInd].dwProtocol == FILTER_PROTO_TCP) ||
               (pfd-> fiFilter[dwInd].dwProtocol == FILTER_PROTO_UDP))
            {
                DisplayMessageT( DMP_IP_ADD_IF_FILTER_PORT,
                            ntohs(pfd->fiFilter[dwInd].wSrcPort),
                            ntohs(pfd->fiFilter[dwInd].wDstPort)); 
            }

            if(pfd-> fiFilter[dwInd].dwProtocol == FILTER_PROTO_ICMP)
            {
                DisplayMessageT( DMP_IP_ADD_IF_FILTER_TC,
                            pfd->fiFilter[dwInd].wSrcPort,
                            pfd->fiFilter[dwInd].wDstPort);
            }
        }
        else
        {
            if ( pfd-> fiFilter[ dwInd ].dwProtocol == FILTER_PROTO_ICMP )
            {
                DisplayMessage(g_hModule, 
                               MSG_RTR_FILTER_INFO,
                               wszSrcAddr,
                               wszSrcMask,
                               wszDstAddr,
                               wszDstMask,
                               pwszProtocol,
                               pfd->fiFilter[ dwInd ].wSrcPort,
                               pfd->fiFilter[ dwInd ].wDstPort);
            }
            else
            {
                DisplayMessage(g_hModule, 
                               MSG_RTR_FILTER_INFO,
                               wszSrcAddr,
                               wszSrcMask,
                               wszDstAddr,
                               wszDstMask,
                               pwszProtocol,
                               ntohs(pfd->fiFilter[dwInd].wSrcPort),
                               ntohs(pfd->fiFilter[dwInd].wDstPort));
            }
        }
   
        if(!bDontFree)
        {
             FreeString(pwszProtocol); 
        }
    }

    FreeString(pwszType);

    FreeString(pwszAction);

    return NO_ERROR;
}

DWORD
ShowIpIfFilter(
    IN    HANDLE    hFile,
    IN    DWORD     dwFormat,
    IN    LPCWSTR   pwszIfName,
    IN OUT PDWORD   pdwNumRows
    )

/*++

Routine Description:

    Gets filter information for the interface and displays it.

Arguments:

     pwszIfName - Interface name
     
Return Value:

    NO_ERROR
    
--*/

{
    DWORD                 dwErr, dwBlkSize, dwCount, dwIfType, i;
    PFILTER_DESCRIPTOR    pfd[3];
    DWORD                 pdwType[] = { IP_IN_FILTER_INFO,
                                        IP_OUT_FILTER_INFO,
                                        IP_DEMAND_DIAL_FILTER_INFO };
    WCHAR                 wszIfDesc[MAX_INTERFACE_NAME_LEN + 1];
    PIFFILTER_INFO        pFragInfo = NULL;
    DWORD                 dwNumParsed = 0;
    PWCHAR                pwszFrag, pwszTokenFrag, pwszQuoted;


    for ( i = 0 ; i < 3; i++)
    {
        dwErr = IpmontrGetInfoBlockFromInterfaceInfo(pwszIfName,
                                              pdwType[i],
                                              (PBYTE *) &(pfd[i]),
                                              &dwBlkSize,
                                              &dwCount,
                                              &dwIfType);

        if (dwErr isnot NO_ERROR)
        {
            if (dwErr is ERROR_NO_SUCH_INTERFACE)
            {
                // DisplayMessage(g_hModule, MSG_NO_INTERFACE, pwszIfName);
                return dwErr;
            }

            pfd[i] = NULL;
        }
    }

    dwErr = IpmontrGetInfoBlockFromInterfaceInfo(pwszIfName,
                                          IP_IFFILTER_INFO,
                                          (PBYTE *) &pFragInfo,
                                          &dwBlkSize,
                                          &dwCount,
                                          &dwIfType);


    if (dwErr isnot NO_ERROR)
    {
        pFragInfo = NULL;
    }
    
    
    dwErr = GetInterfaceDescription(pwszIfName,
                                    wszIfDesc,
                                    &dwNumParsed);

    if (!dwNumParsed)
    {
        wcscpy(wszIfDesc, pwszIfName);
    }

    pwszQuoted = MakeQuotedString(wszIfDesc);

    pwszFrag = NULL;
 
    if((pFragInfo is NULL) || 
       (pFragInfo->bEnableFragChk is FALSE))
    {
        pwszFrag      = MakeString(g_hModule, STRING_DISABLED);
        pwszTokenFrag = TOKEN_VALUE_DISABLE;
    }
    else
    {
        pwszFrag      = MakeString(g_hModule, STRING_ENABLED);
        pwszTokenFrag = TOKEN_VALUE_ENABLE;
    }

    //
    // First lets handle the table case
    //

    if(dwFormat is FORMAT_TABLE)
    {
        DWORD   dwInput, dwOutput, dwDemand;
        PWCHAR  pwszDrop, pwszForward;

        pwszDrop    = MakeString(g_hModule,  STRING_DROP);
        pwszForward = MakeString(g_hModule,  STRING_FORWARD);

        dwInput  = (pfd[0] is NULL) ? 0 : pfd[0]->dwNumFilters;
        dwOutput = (pfd[1] is NULL) ? 0 : pfd[1]->dwNumFilters;
        dwDemand = (pfd[2] is NULL) ? 0 : pfd[2]->dwNumFilters;


        if(*pdwNumRows is 0)
        {
            DisplayMessage(g_hModule, MSG_RTR_FILTER_HDR2);
        }

#define __PF_ACT(x) \
    ((((x) is NULL) || ((x)->faDefaultAction is PF_ACTION_FORWARD)) ? \
     pwszForward : pwszDrop)
 
        DisplayMessage(g_hModule, 
                       MSG_RTR_FILTER_INFO2,
                       dwInput,
                       __PF_ACT(pfd[0]),
                       dwOutput,
                       __PF_ACT(pfd[1]),
                       dwDemand,
                       __PF_ACT(pfd[2]),
                       pwszFrag,
                       wszIfDesc);

#undef __PF_ACT

        (*pdwNumRows)++;

        return NO_ERROR;
    }


    if(hFile == NULL)
    {
        DisplayMessage(g_hModule, MSG_RTR_FILTER_HDR1, wszIfDesc);

        //
        // Can display the frag check status before displaying filters
        //

        DisplayMessage(g_hModule, MSG_IP_FRAG_CHECK,
                       pwszFrag);
    }

    FreeString(pwszFrag);

    if ( pfd[0] == (PFILTER_DESCRIPTOR) NULL )
    {
        if(hFile == NULL)
        {
            DisplayMessage(g_hModule,  MSG_IP_NO_INPUT_FILTER);
        }
    }
    else
    {
        DisplayFilters(hFile,
                       pfd[0], 
                       wszIfDesc,
                       pwszQuoted, 
                       IP_IN_FILTER_INFO);

        (*pdwNumRows)++;
    }

    if ( pfd[1] == (PFILTER_DESCRIPTOR) NULL )
    {
        if(hFile == NULL)
        {
            DisplayMessage(g_hModule,  MSG_IP_NO_OUTPUT_FILTER);
        }
    }
    else
    {
        DisplayFilters(hFile,
                       pfd[1], 
                       wszIfDesc, 
                       pwszQuoted,
                       IP_OUT_FILTER_INFO);

        (*pdwNumRows)++;
    }

    if(pfd[2] == (PFILTER_DESCRIPTOR) NULL)
    {
        if(hFile == NULL)
        {
            DisplayMessage(g_hModule, MSG_IP_NO_DIAL_FILTER);
        }
    }
    else
    {
        DisplayFilters(hFile,
                       pfd[2], 
                       wszIfDesc, 
                       pwszQuoted,
                       IP_DEMAND_DIAL_FILTER_INFO);

        (*pdwNumRows)++;
    }

    for (i = 0; i < 3 ; i++)
    {
        if (pfd[i])
        {
            HeapFree(GetProcessHeap(), 0, pfd[i]);
        }
    }

    if(hFile != NULL)
    {
        DisplayMessageT( DMP_IP_SET_IF_FILTER_FRAG,
                    pwszQuoted,
                    pwszTokenFrag);
    }

    if(pFragInfo)
    {
        HeapFree(GetProcessHeap(), 0, pFragInfo);
    }

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ip\ipmon\ipcfg.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    routing\monitor2\ip\ipcfg.h

Abstract:

    ProtoTypes for fns in ipcfg.c

Revision History:

    Anand Mahalingam         7/10/98  Created

--*/

DWORD
AddProtocolInfo(
    IN    LPCWSTR           pwszIfName,
    IN    DWORD             dwRoutingProtId,
    IN    BOOL              bInterface
    );

DWORD
DeleteProtocolInfo(
    IN    LPCWSTR           pwszIfName,
    IN    DWORD             dwRoutingProtId,
    IN    BOOL              bInterface
    );

DWORD
MakeIpRipGlobalInfo(
    OUT      PBYTE                   *ppbStart,
    OUT      PDWORD                  pdwSize
    );

DWORD
MakeIpRipInterfaceInfo(
    IN      ROUTER_INTERFACE_TYPE   rifType,
    OUT     PBYTE                   *ppbStart,
    OUT     PDWORD                  pdwSize
    );

DWORD
MakeIpOspfGlobalInfo(
    OUT      PBYTE                   *ppbStart,
    OUT      PDWORD                   pdwSize
    );
DWORD
MakeIpOspfInterfaceInfo(
    IN      ROUTER_INTERFACE_TYPE   rifType,
    OUT     PBYTE                   *ppbStart,
    OUT     PDWORD                  pdwSize
    );

DWORD 
MakeProtocolBlock(
    DWORD                   dwProtId,
    BOOL                    bGlobal,
    DWORD                   dwIfType,
    PBYTE                   *ppbBlk,
    PDWORD                  pdwSize
    );

DWORD
AddDeleteRoutePrefLevel ( 
    IN    PPROTOCOL_METRIC    ppm,
    IN    DWORD               dwNumProto,
    IN    BOOL                bAdd
    );

DWORD
AddNewRoutePrefToBlock (
    IN    PPRIORITY_INFO            ppi,
    IN    DWORD                     dwBlkSize,
    IN    PPROTOCOL_METRIC          ppm,
    IN    DWORD                     dwNumProto,
    OUT   PPRIORITY_INFO            *pppi,
    OUT   PDWORD                    pdwSize
    );

DWORD
DeleteRoutePrefFromBlock (
    IN    PPRIORITY_INFO            ppi,
    IN    DWORD                     dwBlkSize,
    IN    PPROTOCOL_METRIC          ppm,
    IN    DWORD                     dwNumProto,
    OUT   PPRIORITY_INFO            *pppi,
    OUT   PDWORD                    pdwSize  
    );

DWORD
SetRoutePrefLevel ( 
    IN    PROTOCOL_METRIC    pm
    );

DWORD
UpdateRtrPriority(
    IN    PPRIORITY_INFO            ppi,
    IN    PROTOCOL_METRIC           pm
    );

DWORD
SetGlobalConfigInfo(
    IN    DWORD    dwLoggingLevel
    );

DWORD
ShowRoutePref(
    HANDLE  hFile   OPTIONAL
    );

DWORD
ShowIpProtocol(
    VOID 
    );

DWORD
ShowIpGlobal(
    IN HANDLE hFile OPTIONAL
    );

DWORD
ListIpInterface(
    VOID
    );

DWORD
ShowIpInterface(
    IN  DWORD     dwFormat,
    IN  LPCWSTR   pwszIfName,
    IN OUT PDWORD pdwNumRows
    );

#define FORMAT_TABLE       1
#define FORMAT_VERBOSE     2
#define FORMAT_DUMP        3

DWORD
UpdateInterfaceStatusInfo(
    IN    DWORD          dwAction,
    IN    LPCWSTR        pwszIfName,
    IN    DWORD          dwStatus
    );

DWORD
CreateDumpFile(
    IN  LPCWSTR  pwszName,
    OUT PHANDLE  phFile
    );

VOID
DumpIpInformation(
    HANDLE  hFile
    );

VOID
CloseDumpFile(
    HANDLE  hFile
    );

DWORD
UpdateAutoStaticRoutes(
    IN  LPCWSTR  pwszIfName
    );

PWCHAR
GetProtoProtoString(
    IN  DWORD  dwProtoType,
    IN  DWORD  dwProtoVendor,
    IN  DWORD  dwProtoProto
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ip\ipmon\ipcfg.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    routing\monitor2\ip\ipcfg.c

Abstract:

    Fns to change configuration at the IP Rtr Mgr level

Revision History:

    Anand Mahalingam         7/10/98  Created

--*/

#include "precomp.h"
#pragma hdrstop

DWORD
AddDeleteRoutePrefLevel ( 
    IN    PPROTOCOL_METRIC    ppm,
    IN    DWORD               dwNumProto,
    IN    BOOL                bAdd
    )
/*++

Routine Description:

    Adds, deletes route preferences

Arguments:

    ppm         - array of protocols to be added/deleted
    dwNumProto  - Number of protocols to be added/deleted
    bAdd        - To add or not to add
    
Return Value:

    NO_ERROR
    
--*/
{
    DWORD                   dwRes = (DWORD) -1, dwSize = 0;
    PPRIORITY_INFO          ppi = NULL, ppiNew = NULL;
    DWORD                   dwBlkSize, dwNewBlkSize, dwCount;
    
    DEBUG("In AddDelRoutePrefLevel");
    
    if (dwNumProto is 0)
    {
        return NO_ERROR;
    }
   
 

    do
    {
        dwRes = IpmontrGetInfoBlockFromGlobalInfo(IP_PROT_PRIORITY_INFO,
                                           (PBYTE *) &ppi,
                                           &dwBlkSize,
                                           &dwCount);
    
        if(dwRes != NO_ERROR)
        {
            break;
        }

        if(bAdd)
        {
            dwRes = AddNewRoutePrefToBlock(ppi,
                                           dwBlkSize,
                                           ppm,
                                           dwNumProto,
                                           &ppiNew,
                                           &dwNewBlkSize);
        }
        else
        {
            dwRes = DeleteRoutePrefFromBlock(ppi,
                                             dwBlkSize,
                                             ppm,
                                             dwNumProto,
                                             &ppiNew,
                                             &dwNewBlkSize);
        }

        if(dwRes != NO_ERROR)
        {
            if(dwRes is ERROR_NO_CHANGE)
            {
                //
                // No Change in config, proceed to change in router
                //
    
                dwRes = NO_ERROR;

                ppiNew = NULL;

                break;
            }
        }
        else
        {
            if(ppiNew)
            {
                dwRes = IpmontrSetInfoBlockInGlobalInfo(IP_PROT_PRIORITY_INFO,
                                                (PBYTE) ppiNew,
                                                dwNewBlkSize,
                                                dwCount);
            }
        }

    }while(FALSE);

    //        
    // free allocations
    //

    if(ppi)
    { 
        FreeInfoBuffer(ppi);

        ppi = NULL;
    }

    if(ppiNew)
    { 
        FREE(ppiNew);

        ppiNew = NULL;
    }

    switch(dwRes)
    {
        case NO_ERROR:
            break;

        case ERROR_NOT_FOUND:
            DisplayMessage(g_hModule, EMSG_IP_NO_PRIO_INFO, L"Router");

            break;

        case ERROR_NOT_ENOUGH_MEMORY:
            DisplayMessage(g_hModule, MSG_IP_NOT_ENOUGH_MEMORY);
            break;

        default:
            DisplayError(g_hModule, dwRes);
            break;
    }
    
    return dwRes;
}

DWORD
AddNewRoutePrefToBlock (
    IN    PPRIORITY_INFO            ppi,
    IN    DWORD                     dwBlkSize,
    IN    PPROTOCOL_METRIC          ppm,
    IN    DWORD                     dwNumProto,
    OUT   PPRIORITY_INFO            *pppi,
    OUT   PDWORD                    pdwSize
    )

/*++

Routine Description:

    creates route preference block 

Arguments:

    ppi          - preference block
    dwNumBlkSize - size of block
    ppm          - protocols to be added
    dwNumProto   - number of protocols
    pppi         - new preference block
    pdwSize      - size of new block
    
Return Value:

    NO_ERROR
    
--*/

{
    PPRIORITY_INFO  pPriorInfoOld = NULL, pPriorInfoNew = NULL;
    DWORD           i = 0, dwNewSize = 0, dwRes = NO_ERROR;
    BOOL            bFound = FALSE;
    PDWORD          pdwValid;
    DWORD           j, dwProtoCount;
    
    //
    // Have an array to tell which ones are valid.
    //
    pdwValid = MALLOC( dwNumProto * sizeof(DWORD));

    if (pdwValid is NULL)
    {
        DisplayMessage(g_hModule, MSG_IP_NOT_ENOUGH_MEMORY);

        return ERROR_NOT_ENOUGH_MEMORY;
    }

    ZeroMemory(pdwValid, dwNumProto * sizeof(DWORD));

    //
    // find the PrefLevel block
    //
    
    pPriorInfoOld = ppi;
        
    if ( pPriorInfoOld == (PPRIORITY_INFO) NULL )
    {
        DisplayMessage(g_hModule,  MSG_IP_CORRUPT_INFO );
        FREE(pdwValid);
        
        return ERROR_INVALID_PARAMETER;
    }

    
    for ( j = 0, dwNewSize = 0; j < dwNumProto; j++)
    {
        //
        // make sure preference level for the protocol does not already exist.
        //

        for ( i = 0;  i < pPriorInfoOld-> dwNumProtocols;  i++ )
        {
            if (pPriorInfoOld->ppmProtocolMetric[ i ].dwProtocolId 
                == ppm[j].dwProtocolId)
            {
                bFound = TRUE;
                break;
            }
        }

        if (bFound)
        {
            pdwValid[j] = 0;
            DisplayMessage(g_hModule, MSG_IP_PROTO_PREF_LEVEL_EXISTS, 
                           pPriorInfoOld->ppmProtocolMetric[ i ].dwMetric);
            
            bFound = FALSE;
        }
        else
        {
            pdwValid[j] = 1;
            dwNewSize += sizeof(PROTOCOL_METRIC);
        }
    }

    //
    // allocate new info block
    //

    if (dwNewSize is 0)
    {
        //
        // All specified protocols already present
        //

        FREE(pdwValid);

        return ERROR_NO_CHANGE;
    }

    dwProtoCount = dwNewSize / sizeof(PROTOCOL_METRIC);
    
    dwNewSize += dwBlkSize;
    
    pPriorInfoNew = MALLOC(dwNewSize);

    if ( pPriorInfoNew == NULL )
    {
        DisplayMessage(g_hModule,  MSG_IP_NOT_ENOUGH_MEMORY );
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        return dwRes;
    }

    do
    {
        //
        // copy the old PrefLevels and set the number of protocols
        //
        
        CopyMemory((PBYTE) &pPriorInfoNew-> ppmProtocolMetric, 
                   (PBYTE) &pPriorInfoOld-> ppmProtocolMetric,
                   sizeof(PROTOCOL_METRIC)*pPriorInfoOld-> dwNumProtocols);

        pPriorInfoNew-> dwNumProtocols = pPriorInfoOld-> dwNumProtocols +
                                         dwProtoCount;


        //
        // add the new PrefLevel and increment count of protocols
        // with PrefLevels
        //

        i = pPriorInfoOld-> dwNumProtocols;
        
        for ( j = 0 ; j < dwNumProto ; j++)
        {
            if (pdwValid[j])
            {
                //
                // Add the protocol priority
                //
            
                pPriorInfoNew-> ppmProtocolMetric[i].dwProtocolId
                    = ppm[j].dwProtocolId;
                
                pPriorInfoNew-> ppmProtocolMetric[i++].dwMetric 
                    = ppm[j].dwMetric;
            }
        }
        
    } while (FALSE);

    FREE(pdwValid);
    
    if ( dwRes == NO_ERROR )
    {
        *pppi = pPriorInfoNew;
        *pdwSize = dwNewSize;
    }

    return dwRes;
}


DWORD
DeleteRoutePrefFromBlock (
    IN    PPRIORITY_INFO            ppi,
    IN    DWORD                     dwBlkSize,
    IN    PPROTOCOL_METRIC          ppm,
    IN    DWORD                     dwNumProto,
    OUT   PPRIORITY_INFO            *pppi,
    OUT   PDWORD                    pdwSize  
    )
/*++

Routine Description:

    creates route preference block 

Arguments:

    ppi          - preference block
    dwNumBlkSize - size of block
    ppm          - protocols to be added
    dwNumProto   - number of protocols
    pppi         - new preference block
    pdwSize      - size of new block
    
Return Value:

    NO_ERROR
    
--*/
{
    PPRIORITY_INFO          pPriorInfoOld = NULL, pPriorInfoNew = NULL;
    DWORD                   dwInd = 0, dwNewSize = 0, dwRes = NO_ERROR, i, j;
    BOOL                    bFound = FALSE;
    PDWORD                  pdwToDelete;


    // find the PrefLevel block

    pPriorInfoOld = ppi;

    if ( pPriorInfoOld == (PPRIORITY_INFO) NULL )
    {
        DisplayMessage(g_hModule,  MSG_IP_CORRUPT_INFO );
        return ERROR_INVALID_PARAMETER;
    }

    pdwToDelete = MALLOC( pPriorInfoOld-> dwNumProtocols * sizeof(DWORD));

    if (pdwToDelete is NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    ZeroMemory(pdwToDelete, pPriorInfoOld-> dwNumProtocols * sizeof(DWORD));

    for ( i = 0, dwNewSize = 0; i < dwNumProto; i++)
    {
        //
        // make sure preference level for the protocol already exists.
        //

        for ( dwInd = 0;  dwInd < pPriorInfoOld-> dwNumProtocols;  dwInd++ )
        {
            if (pPriorInfoOld-> ppmProtocolMetric[ dwInd ].dwProtocolId 
                == ppm[i].dwProtocolId)
            {
                bFound = TRUE;
                break;
            }
        }
    
        if (!bFound)
        {
            DisplayMessage(g_hModule, MSG_IP_PROTO_PREF_LEVEL_NOT_FOUND,
                           ppm[i].dwProtocolId);
        }
        else
        {
            bFound = FALSE;
            pdwToDelete[dwInd] = 1;
            dwNewSize += sizeof(PROTOCOL_METRIC);
        }
    }

    if (dwNewSize is 0)
    {
        //
        // None of the protocols specified were found.
        //

        FREE(pdwToDelete);
        return ERROR_NO_CHANGE;
    }
    
    //
    // allocate new info block
    //

    dwNewSize = dwBlkSize - dwNewSize;
    
    pPriorInfoNew = MALLOC(dwNewSize);

    if ( pPriorInfoNew == NULL )
    {
        FREE(pdwToDelete);
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        return dwRes;
    }

    do
    {
        for ( i = 0, j = 0; i < pPriorInfoOld-> dwNumProtocols; i++)
        {
            if (pdwToDelete[i])
            {
                //
                // Do not copy this protocol
                //
            }
            else
            {
                pPriorInfoNew->ppmProtocolMetric[j].dwProtocolId =
                    pPriorInfoOld->ppmProtocolMetric[i].dwProtocolId;
                pPriorInfoNew->ppmProtocolMetric[j++].dwMetric =
                    pPriorInfoOld->ppmProtocolMetric[i].dwMetric;
            }
        }
        
        pPriorInfoNew-> dwNumProtocols = j;
        
    } while (FALSE);

    FREE(pdwToDelete);
    
    if ( dwRes == NO_ERROR )
    {
        *pppi = pPriorInfoNew;
        *pdwSize = dwNewSize;
    }

    return dwRes;
}

DWORD
SetRoutePrefLevel ( 
    IN    PROTOCOL_METRIC    pm
    )
/*++

Routine Description:

    sets route preference

Arguments:

    ppm - preference to set
    
Return Value:

    NO_ERROR
    
--*/
{
    DWORD                   dwRes = (DWORD) -1, dwSize = 0;
    PPRIORITY_INFO          ppi = NULL;
    DWORD                   dwBlkSize, dwCount;

    DEBUG("In SetRoutePrefLevel");
 
    do
    {
        //
        // get router config, add new router preference level,
        // and set the config
        //

        dwRes = IpmontrGetInfoBlockFromGlobalInfo(IP_PROT_PRIORITY_INFO,
                                           (PBYTE *) &ppi,
                                           &dwBlkSize,
                                           &dwCount);
        
        if (dwRes != NO_ERROR)
        {
            break;
        }

        dwRes = UpdateRtrPriority(ppi, pm);
        
        if ( dwRes != NO_ERROR )
        {
            break;
        }

        dwRes = IpmontrSetInfoBlockInGlobalInfo(IP_PROT_PRIORITY_INFO,
                                        (PBYTE) ppi,
                                        dwBlkSize,
                                        dwCount);
        
        if ( dwRes != NO_ERROR )
        {
            break;
        }

        PRINT(L"Made Changes to Router Config");

        if (!IsRouterRunning())
        {
            break;
        }
        
    } while (FALSE);
    
    //
    // Free all allocations
    //

    if ( ppi )
    { 
        FREE(ppi);
    }

    switch(dwRes)
    {
        case NO_ERROR:
            break;

        case ERROR_NOT_FOUND:
            DisplayMessage(g_hModule, EMSG_IP_NO_PRIO_INFO, L"Router");

            break;

        case ERROR_NOT_ENOUGH_MEMORY:
            DisplayMessage(g_hModule, MSG_IP_NOT_ENOUGH_MEMORY);
            break;

        case ERROR_INVALID_PARAMETER:
            break;
            
        default:
            DisplayError(g_hModule, dwRes);
            break;
    }
    
    return dwRes;
}

DWORD
UpdateRtrPriority(
    IN    PPRIORITY_INFO            ppi,
    IN    PROTOCOL_METRIC           pm
    )
/*++

Routine Description:

    sets route preference

Arguments:

    ppi - route preference block
    ppm - preference to set
    
Return Value:

    NO_ERROR
    
--*/
{
    BOOL            bFound = FALSE;
    DWORD           i = 0;


    if ( ppi == (PPRIORITY_INFO) NULL )
    {
        DisplayMessage(g_hModule,  MSG_IP_CORRUPT_INFO );
        return ERROR_INVALID_PARAMETER;
    }


    // search for the protocol
    
    for ( i = 0;  i < ppi-> dwNumProtocols;  i++ )
    {
        if (ppi-> ppmProtocolMetric[ i ].dwProtocolId 
                    == pm.dwProtocolId )
        {
            ppi-> ppmProtocolMetric[ i ].dwMetric = pm.dwMetric;
            
            bFound = TRUE;
            break;
        }
    }

    
    if (!bFound)
    {
        // preference level for that protocolId does not exist

        DisplayMessage(g_hModule,  MSG_IP_NO_PREF_FOR_PROTOCOL_ID,
                        pm.dwProtocolId );
        
        return ERROR_INVALID_PARAMETER;
    }
    
    return NO_ERROR;
}

DWORD
SetGlobalConfigInfo(
    IN    DWORD    dwLoggingLevel
    )
/*++

Routine Description:

    sets global logging level

Arguments:

    dwLoggingLevel - Loggging level
    
Return Value:

    NO_ERROR
    
--*/
{
    PGLOBAL_INFO     pgi = NULL;
    DWORD            dwBlkSize, dwCount, dwErr = NO_ERROR;
 
    do
    {
        //
        // Get the IP_GLOBAL_INFO block from router config
        //

        dwErr = IpmontrGetInfoBlockFromGlobalInfo(IP_GLOBAL_INFO,
                                           (PBYTE *) &pgi,
                                           &dwBlkSize,
                                           &dwCount);

        if (dwErr isnot NO_ERROR)
        {
            break;
        }

        pgi->dwLoggingLevel = dwLoggingLevel;

        //
        // Set the IP_GLOBAL_INFO block in router config
        //

        dwErr = IpmontrSetInfoBlockInGlobalInfo(IP_GLOBAL_INFO,
                                        (PBYTE) pgi,
                                        dwBlkSize,
                                        dwCount);

        if (dwErr isnot NO_ERROR)
        {
            break;
        }

        FREE(pgi);

        pgi = NULL;
        
        DEBUG("Set logging level in router config\n");
        
    }while (FALSE);

    if (pgi)
    {
        FREE(pgi);
    }

    switch(dwErr)
    {
        case NO_ERROR:
            break;

        case ERROR_NOT_FOUND:
            DisplayMessage(g_hModule, EMSG_IP_NO_PRIO_INFO, L"Router");

            break;

        case ERROR_NOT_ENOUGH_MEMORY:
            DisplayMessage(g_hModule, MSG_IP_NOT_ENOUGH_MEMORY);
            break;

        default:
            DisplayError(g_hModule, dwErr);
            break;
    }

    return dwErr;
}

DWORD
UpdateInterfaceStatusInfo(
    IN    DWORD          dwAction,
    IN    LPCWSTR        pwszIfName,
    IN    DWORD          dwStatus
    )

/*++

Routine Description:

    Sets interface discovery information

Arguments:

    pwszIfName   - interface name
    dwStatus     - enabled or disabled
    
Return Value:

    NO_ERROR
    
--*/

{
    PINTERFACE_STATUS_INFO  pifStat = (PINTERFACE_STATUS_INFO) NULL;
    DWORD                   dwRes = NO_ERROR, dwBlkSize;
    DWORD                   dwCount, dwIfType;
    
    do
    {
        dwRes = IpmontrGetInfoBlockFromInterfaceInfo(pwszIfName,
                                              IP_INTERFACE_STATUS_INFO,
                                              (PBYTE *) &pifStat,
                                              &dwBlkSize,
                                              &dwCount,
                                              &dwIfType);

        if (dwRes is ERROR_NOT_FOUND)
        {
            //
            // No info of this type is currently present
            //

            dwRes = NO_ERROR;
            dwCount = 0;

            // Add interface
            if (dwAction is ADD_COMMAND) {
                pifStat = (PINTERFACE_STATUS_INFO)MALLOC(
                    sizeof(INTERFACE_STATUS_INFO));
                if (pifStat is NULL) {
                    dwRes = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }
                dwCount++;
            }
        }
        
        if (dwRes != NO_ERROR)
        {
            break;
        }

        if (dwCount is 0)
            return ERROR_NOT_FOUND;

        if (dwAction is DELETE_COMMAND)
        {
            dwCount = 0;
        }
        else
        {
            pifStat->dwAdminStatus = dwStatus;
        }
        
        dwRes = IpmontrSetInfoBlockInInterfaceInfo( pwszIfName,
                                             IP_INTERFACE_STATUS_INFO,
                                             (PBYTE) pifStat,
                                             dwBlkSize,
                                             dwCount);
        
    } while (FALSE);
    
    //
    // Free all allocations
    //

    if ( pifStat )
    { 
        FREE(pifStat);
    }

    switch(dwRes)
    {
        case NO_ERROR:
            break;

        case ERROR_NOT_FOUND:
            DisplayMessage(g_hModule, EMSG_IP_NO_IF_STATUS_INFO, L"Router");

            break;

        case ERROR_NOT_ENOUGH_MEMORY:
            DisplayMessage(g_hModule, MSG_IP_NOT_ENOUGH_MEMORY);
            break;

        default:
            DisplayError(g_hModule, dwRes);
            break;
    }
    
    return dwRes;
}




DWORD
ShowRoutePref(
    HANDLE  hFile
    )

/*++

Routine Description:

    Displays the protocol route preferences.

Arguments:

    
Return Value:

    NO_ERROR
    
--*/

{
    PPRIORITY_INFO    ppi;
    DWORD             dwBlkSize, dwCount, dwNumProto, i;
    DWORD             dwErr;
    WCHAR             wszBuff[80]; 

    dwErr = IpmontrGetInfoBlockFromGlobalInfo(IP_PROT_PRIORITY_INFO,
                                       (PBYTE *)&ppi,
                                       &dwBlkSize,
                                       &dwCount);


    if (dwErr isnot NO_ERROR)
    {
        DisplayError(g_hModule, dwErr);
    
        return ERROR_SUPPRESS_OUTPUT;
    }

    dwNumProto = ppi-> dwNumProtocols;

    if (dwNumProto && 
        (hFile == NULL))
    {
        DisplayMessage(g_hModule, MSG_RTR_PRIO_INFO_HDR);
    }
    
    for (i=0;  i < dwNumProto;  i++)
    {
        PTCHAR  ptszProto, ptszToken;
        
        switch (ppi-> ppmProtocolMetric[ i ].dwProtocolId)
        {
            case PROTO_IP_LOCAL:
            {
                ptszProto = MakeString(g_hModule,  STRING_LOCAL );
                ptszToken = TOKEN_VALUE_LOCAL;

                break;
            }

            case PROTO_IP_NETMGMT:
            {
                ptszProto = MakeString(g_hModule,  STRING_NETMGMT );
                ptszToken = TOKEN_VALUE_NETMGMT;

                break;
            }

            case PROTO_IP_OSPF :
            {
                ptszProto = MakeString(g_hModule,  STRING_OSPF );
                ptszToken = TOKEN_VALUE_OSPF;

                break;
            }

            case PROTO_IP_RIP :
            {
                ptszProto = MakeString(g_hModule,  STRING_RIP );
                ptszToken = TOKEN_VALUE_RIP;

                break;
            }

            case PROTO_IP_NT_AUTOSTATIC :
            {
                ptszProto = MakeString(g_hModule,  STRING_NT_AUTOSTATIC );
                ptszToken = TOKEN_VALUE_AUTOSTATIC;
                
                break;
            }

            case PROTO_IP_NT_STATIC :
            {
                ptszProto = MakeString(g_hModule,  STRING_STATIC );
                ptszToken = TOKEN_VALUE_STATIC;

                break;
            }

            case PROTO_IP_NT_STATIC_NON_DOD :
            {
                ptszProto = MakeString(g_hModule,  STRING_NONDOD );
                ptszToken = TOKEN_VALUE_NONDOD;
                
                break;
            }

            default:
            {
                ptszProto = NULL;
                ptszToken = NULL;

                break;
            }
        }

        if ( ptszProto == NULL || ptszToken == NULL )
        {
            swprintf( wszBuff, 
                      L"%d", 
                      ppi-> ppmProtocolMetric[ i ].dwProtocolId );
        }
            
        if(hFile != NULL)
        {
            DisplayMessageT( DMP_IP_SET_PROTOPREF,
                        (ptszToken)? ptszToken : wszBuff,
                        ppi->ppmProtocolMetric[i].dwMetric);
            
        }
        else
        {
            DisplayMessage(g_hModule, 
                           MSG_RTR_PRIO_INFO, 
                           (ptszProto)? ptszProto : wszBuff,
                           ppi->ppmProtocolMetric[i].dwMetric);
        }

        if(ptszProto)
        {
            FreeString(ptszProto);
        }
    }

    FREE(ppi);

    return NO_ERROR;
}


DWORD
ShowIpGlobal(
    HANDLE  hFile
    )

/*++

Routine Description:

    Displays the logging level for IP

Arguments:

    
Return Value:

    NO_ERROR
    
--*/

{
    PGLOBAL_INFO     pgi = NULL;
    DWORD            dwBlkSize, dwCount;
    DWORD            dwErr;
    PWCHAR           ptszLoglevel, ptszLog;
    WCHAR             wszBuff[80];
    
    dwErr = IpmontrGetInfoBlockFromGlobalInfo(IP_GLOBAL_INFO,
                                       (PBYTE *)&pgi,
                                       &dwBlkSize,
                                       &dwCount);

    if (dwErr isnot NO_ERROR)
    {
        DisplayError(g_hModule, dwErr);

        return dwErr;
    }

    switch (pgi->dwLoggingLevel)
    {
        case IPRTR_LOGGING_NONE:
        {
            ptszLoglevel = MakeString(g_hModule, STRING_LOGGING_NONE);
            ptszLog      = TOKEN_VALUE_NONE;
            
            break;
        }

        case IPRTR_LOGGING_ERROR:
        {
            ptszLoglevel = MakeString(g_hModule, STRING_LOGGING_ERROR);
            ptszLog      = TOKEN_VALUE_ERROR;
            
            break;
        }

        case IPRTR_LOGGING_WARN:
        {
            ptszLoglevel = MakeString(g_hModule, STRING_LOGGING_WARN);
            ptszLog      = TOKEN_VALUE_WARN;
            
            break;
        }
        
        case IPRTR_LOGGING_INFO:
        {
            ptszLoglevel = MakeString(g_hModule, STRING_LOGGING_INFO);
            ptszLog      = TOKEN_VALUE_INFO;
            
            break;
        }
    }

    if ( ptszLoglevel == NULL || ptszLog == NULL )
    {
        swprintf( wszBuff, 
                  L"%d", 
                  pgi->dwLoggingLevel);
    }

    if(hFile)
    {
        DisplayMessageT( DMP_IP_SET_LOGLEVEL,
                    (ptszLog) ? ptszLog : wszBuff);
    }
    else
    {
        DisplayMessage(g_hModule, MSG_IP_GLOBAL_HDR);
        DisplayMessage(g_hModule, MSG_IP_LOG_LEVEL, 
                    (ptszLoglevel) ? ptszLoglevel : wszBuff);
    }

    if ( ptszLoglevel )
    {
        FreeString(ptszLoglevel);
    }
    
    FREE(pgi);

    return NO_ERROR;
}

PWCHAR
GetIfTypeString(
    DWORD  dwIfType
    )
{
    PWCHAR        pwszStr;
    static WCHAR  buff[80];
    VALUE_STRING  ppsList[] = {{ROUTER_IF_TYPE_CLIENT,      STRING_CLIENT},
                               {ROUTER_IF_TYPE_HOME_ROUTER, STRING_HOME_ROUTER},
                               {ROUTER_IF_TYPE_FULL_ROUTER, STRING_FULL_ROUTER},
                               {ROUTER_IF_TYPE_DEDICATED,   STRING_DEDICATED},
                               {ROUTER_IF_TYPE_INTERNAL,    STRING_INTERNAL},
                               {ROUTER_IF_TYPE_LOOPBACK,    STRING_LOOPBACK},
#ifdef KSL_IPINIP                               
                               {ROUTER_IF_TYPE_TUNNEL1,     STRING_TUNNEL},
#endif //KSL_IPINIP
                            };
    DWORD         dwNum = sizeof(ppsList)/sizeof(VALUE_STRING), i;
    DWORD         dwMsgId = 0;

    for (i=0; i<dwNum; i++)
    {
        if (dwIfType == ppsList[i].dwValue)
        {
            dwMsgId = ppsList[i].dwStringId;
            break;
        }
    }

    if (dwMsgId)
    {
        pwszStr = MakeString( g_hModule, dwMsgId);
        if ( pwszStr )
        {
            wcscpy(buff, pwszStr);
            FreeString(pwszStr);
        }
        else
        {
            wsprintf(buff, L"%d", dwIfType);
        }
    }
    else
    {
        wsprintf(buff, L"%d", dwIfType);
    }

    return buff;
}

PWCHAR
GetProtoTypeString(
    DWORD  dwProtoType
    )
{
    PWCHAR        pwszStr;
    static WCHAR  buff[80];
    VALUE_STRING  ppsList[] = {{PROTO_TYPE_UCAST, STRING_UNICAST},
                               {PROTO_TYPE_MCAST, STRING_MULTICAST},
                               {PROTO_TYPE_MS1,   STRING_GENERAL},
                               {PROTO_TYPE_MS0,   STRING_GENERAL},
                              };
    DWORD         dwNum = sizeof(ppsList)/sizeof(VALUE_STRING), i;
    DWORD         dwMsgId = 0;

    for (i=0; i<dwNum; i++)
    {
        if (dwProtoType == ppsList[i].dwValue)
        {
            dwMsgId = ppsList[i].dwStringId;
            break;
        }
    }

    if (dwMsgId)
    {
        pwszStr = MakeString( g_hModule, dwMsgId);
        if ( pwszStr )
        {
            wcscpy(buff, pwszStr);
            FreeString(pwszStr);
        }
        else
        {
            wsprintf(buff, L"%d", dwProtoType);
        }
    }
    else
    {
        wsprintf(buff, L"%d", dwProtoType);
    }

    return buff;
}

PWCHAR
GetProtoVendorString(  
    DWORD  dwProtoVendor
    )
{
    PWCHAR        pwszStr;
    static WCHAR  buff[80];
    VALUE_TOKEN   ppsList[] = {{PROTO_VENDOR_MS0, TOKEN_MICROSOFT0},
                               {PROTO_VENDOR_MS1, TOKEN_MICROSOFT1},
                               {PROTO_VENDOR_MS2, TOKEN_MICROSOFT2},
                              };
    DWORD         dwNum = sizeof(ppsList)/sizeof(VALUE_STRING), i;
    DWORD         dwMsgId = 0;

    for (i=0; i<dwNum; i++)
    {
        if (dwProtoVendor == ppsList[i].dwValue)
        {
            return (PWCHAR)ppsList[i].pwszToken;
            break;
        }
    }

    wsprintf(buff, L"%d", dwProtoVendor);

    return buff;
}

PWCHAR
GetProtoProtoString( 
    DWORD  dwProtoType,
    DWORD  dwProtoVendor,
    DWORD  dwProtoProto
    )
{
    PWCHAR        pwszStr;
    static WCHAR  buff[80];
    VALUE_STRING  ppsUList[] = {{PROTO_IP_RIP,    STRING_RIP},
                                {PROTO_IP_OSPF,   STRING_OSPF},
                                {PROTO_IP_BOOTP,  STRING_BOOTP},
                                {PROTO_IP_NAT,    STRING_NAT},
                                {PROTO_IP_LOCAL,  STRING_LOCAL},
                                {PROTO_IP_OTHER,  STRING_OTHER},
                                {PROTO_IP_NETMGMT,STRING_NETMGMT},
                                {PROTO_IP_NT_AUTOSTATIC,STRING_NT_AUTOSTATIC},
                                {PROTO_IP_NT_STATIC,    STRING_STATIC},
                                {PROTO_IP_NT_STATIC_NON_DOD,STRING_NONDOD},
#ifdef MS_IP_BGP
                                {PROTO_IP_BGP,    STRING_BGP},
#endif
                               };
    VALUE_STRING  ppsMList[] = {{PROTO_IP_IGMP,  STRING_IGMP},
                               };
    VALUE_STRING  ppsGList[] = {{IP_IN_FILTER_INFO,  STRING_IN_FILTER},
                                {IP_OUT_FILTER_INFO, STRING_OUT_FILTER},
                                {IP_GLOBAL_INFO,     STRING_GLOBAL_INFO},
                                {IP_INTERFACE_STATUS_INFO, STRING_IF_STATUS},
                                {IP_ROUTE_INFO,      STRING_ROUTE_INFO},
                                {IP_PROT_PRIORITY_INFO, STRING_PROT_PRIORITY},
                                {IP_ROUTER_DISC_INFO, STRING_RTRDISC},
                                {IP_DEMAND_DIAL_FILTER_INFO, STRING_DD_FILTER},
                                {IP_MCAST_HEARBEAT_INFO, STRING_MC_HEARTBEAT},
                                {IP_MCAST_BOUNDARY_INFO, STRING_MC_BOUNDARY},
#ifdef KSL_IPINIP
                                {IP_IPINIP_CFG_INFO,     STRING_IPIP},
#endif //KSL_IPINIP
                                {IP_IFFILTER_INFO,       STRING_IF_FILTER},
                                {IP_MCAST_LIMIT_INFO,    STRING_MC_LIMIT},
                               };
    VALUE_STRING  pps2List[] = {{PROTO_IP_DNS_PROXY,     STRING_DNS_PROXY},
                                {PROTO_IP_DHCP_ALLOCATOR,STRING_DHCP_ALLOCATOR},
                                {PROTO_IP_NAT,           STRING_NAT},
                                {PROTO_IP_DIFFSERV,      STRING_DIFFSERV},
                                {PROTO_IP_VRRP,          STRING_VRRP},
                               };
                                   
    VALUE_STRING *pVS;
    DWORD         dwNum, i;
    DWORD         dwMsgId = 0;

    switch (dwProtoType) {
    case PROTO_TYPE_UCAST:
        pVS   = ppsUList;
        dwNum = sizeof(ppsUList)/sizeof(VALUE_STRING);
        break;

    case PROTO_TYPE_MCAST:
        pVS   = ppsMList;
        dwNum = sizeof(ppsMList)/sizeof(VALUE_STRING);
        break;

    case PROTO_TYPE_MS1:
        pVS   = ppsGList;
        dwNum = sizeof(ppsGList)/sizeof(VALUE_STRING);
        break;
    
    case PROTO_TYPE_MS0:
        pVS   = pps2List;
        dwNum = sizeof(pps2List)/sizeof(VALUE_STRING);
        break;
    
    default:
        dwNum = 0;
    }

    for (i=0; i<dwNum; i++)
    {
        if (dwProtoProto == PROTO_FROM_PROTO_ID(pVS[i].dwValue))
        {
            dwMsgId = pVS[i].dwStringId;
            break;
        }
    }

    if (dwMsgId)
    {
        pwszStr = MakeString( g_hModule, dwMsgId);
        if ( pwszStr )
        {
            wcscpy(buff, pwszStr);
            FreeString(pwszStr);
        }
        else
        {
            wsprintf(buff, L"%d", dwProtoProto);
        }
    }
    else
    {
        wsprintf(buff, L"%d", dwProtoProto);
    }

    return buff;
}

DWORD
ShowIpIfProtocols(
    IN LPCWSTR pwszIfName
    )
{
    DWORD            dwNumProto, dwErr, i;
    PBYTE            pby;
    DWORD            dwBlkSize, dwCount;
    RTR_INFO_BLOCK_HEADER *pInfoHdr;
    DWORD            dwProtoType, dwProtoVendor, dwProtoProto;

    dwErr = ValidateInterfaceInfo(pwszIfName, &pInfoHdr, NULL, NULL);

    if (dwErr isnot NO_ERROR)
    {
        return dwErr;
    }

    // Do this check just to keep the prefix checker happy
    if (!pInfoHdr)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    DisplayMessage(g_hModule, MSG_RTR_INTERFACE_PROTOCOL_HDR);

    DisplayMessage(g_hModule, MSG_IP_PROTOCOL_HDR);

    // Walk pInfo and output a line for each protocol found

    for (i=0; i<pInfoHdr->TocEntriesCount; i++)
    {
        // Extract type, vendorid, and protocolid
        
        dwProtoType   = TYPE_FROM_PROTO_ID(  pInfoHdr->TocEntry[i].InfoType);
        dwProtoVendor = VENDOR_FROM_PROTO_ID(pInfoHdr->TocEntry[i].InfoType);
        dwProtoProto  = PROTO_FROM_PROTO_ID( pInfoHdr->TocEntry[i].InfoType);

        DisplayMessageT(L"%1!-11s! %2!-13s! %3!s!\n",
            GetProtoTypeString(  dwProtoType),
            GetProtoVendorString(dwProtoVendor),
            GetProtoProtoString( dwProtoType, dwProtoVendor, dwProtoProto));
    }

    if (i is 0)
    {
        DisplayMessage(g_hModule, MSG_IP_NO_PROTOCOL);
    }
    
    return NO_ERROR;
}

DWORD
ShowIpProtocol(
    VOID
    )

/*++

Routine Description:

    Displays all the protocols under IP RTR MGR.

Arguments:

    
Return Value:

    NO_ERROR
    
--*/

{
    DWORD            dwNumProto, dwErr, i;
    PBYTE            pby;
    DWORD            dwBlkSize, dwCount;
    RTR_INFO_BLOCK_HEADER *pInfoHdr;
    DWORD            dwProtoType, dwProtoVendor, dwProtoProto;

    dwErr = ValidateGlobalInfo(&pInfoHdr);

    if (dwErr isnot NO_ERROR)
    {
        return dwErr;
    }

    DisplayMessage(g_hModule, MSG_IP_PROTOCOL_HDR);

    // Walk pInfo and output a line for each protocol found

    for (i=0; i<pInfoHdr->TocEntriesCount; i++)
    {
        // Extract type, vendorid, and protocolid
        
        dwProtoType   = TYPE_FROM_PROTO_ID(  pInfoHdr->TocEntry[i].InfoType);
        dwProtoVendor = VENDOR_FROM_PROTO_ID(pInfoHdr->TocEntry[i].InfoType);
        dwProtoProto  = PROTO_FROM_PROTO_ID( pInfoHdr->TocEntry[i].InfoType);

        DisplayMessageT(L"%1!-11s! %2!-13s! %3!s!\n",
            GetProtoTypeString(  dwProtoType),
            GetProtoVendorString(dwProtoVendor),
            GetProtoProtoString( dwProtoType, dwProtoVendor, dwProtoProto));
    }

    if (i is 0)
    {
        DisplayMessage(g_hModule, MSG_IP_NO_PROTOCOL);
    }
    
    return NO_ERROR;
}

DWORD
ListIpInterface(
    VOID
    )

/*++

Routine Description:

    Lists all interfaces under ip

Arguments:

Return Value:

    NO_ERROR
    
--*/

{
    DWORD                dwErr;
    DWORD                dwCount, dwTotal, i, dwNumParsed = 0;
    PMPR_INTERFACE_0     pmi0;
    WCHAR                wszIfDesc[MAX_INTERFACE_NAME_LEN + 1];
    HANDLE               hIfTransport = (HANDLE) NULL,
                         hInterface;

    DisplayMessage(g_hModule, MSG_IP_INTERFACE_HDR);
    
    //
    // No interface name specified. List all interfaces under IP
    //

    dwErr = IpmontrInterfaceEnum((PBYTE *) &pmi0, &dwCount, &dwTotal);

    if (dwErr isnot NO_ERROR)
    {
        DisplayError(g_hModule, dwErr);

        return dwErr;
    }

    for ( i = 0; i < dwCount; i++)
    {
        // Make sure IP is enabled on this interface

        dwErr = MprConfigInterfaceGetHandle(g_hMprConfig,
                                            pmi0[i].wszInterfaceName,
                                            &hInterface);

        dwErr = MprConfigInterfaceTransportGetHandle(g_hMprConfig,
                                                     hInterface,
                                                     PID_IP,
                                                     &hIfTransport);

        if (dwErr isnot NO_ERROR)
            continue;

        dwErr = GetInterfaceDescription(pmi0[i].wszInterfaceName,
                                        wszIfDesc,
                                        &dwNumParsed);

        if (!dwNumParsed)
        {
            wcscpy(wszIfDesc, pmi0[i].wszInterfaceName);
        }

        DisplayMessage(g_hModule, MSG_IP_INTERFACE_INFO, wszIfDesc);
    }

    if (dwCount is 0)
    {
        DisplayMessage(g_hModule, MSG_IP_NO_INTERFACE);
    }
    
    return NO_ERROR;
}

#ifdef KSL_IPINIP
DWORD
ShowIpInIpInfo(
    IN DWORD   dwFormat, 
    IN LPCWSTR pwszIfName, 
    IN LPCWSTR pwszQuoted
    )
{
    PIPINIP_CONFIG_INFO     pIpIpInfo;
    WCHAR                   rgwcLocalAddr[ADDR_LENGTH + 1];
    WCHAR                   rgwcRemAddr[ADDR_LENGTH + 1];
    DWORD                   dwBlkSize, dwCount, dwIfType, dwErr;

    // IP-in-IP info

    dwErr = IpmontrGetInfoBlockFromInterfaceInfo(pwszIfName,
                                          IP_IPINIP_CFG_INFO,
                                          (PBYTE *) &pIpIpInfo,
                                          &dwBlkSize,
                                          &dwCount,
                                          &dwIfType);


    if(dwErr is NO_ERROR)
    {
        ASSERT(dwIfType is ROUTER_IF_TYPE_TUNNEL1);

        IP_TO_WSTR(rgwcLocalAddr, ((PBYTE)&(pIpIpInfo->dwLocalAddress)));
        IP_TO_WSTR(rgwcRemAddr, ((PBYTE)&(pIpIpInfo->dwRemoteAddress)));

        switch (dwFormat) 
        {
        case FORMAT_VERBOSE:
            DisplayMessage(g_hModule,  
                           MSG_RTR_INTERFACE_IPIP_INFO,
                           rgwcLocalAddr,
                           rgwcRemAddr,
                           MAKELONG(MAKEWORD(pIpIpInfo->byTtl, 0x00), 0x0000));
            break;

        // IP-in-IP tunnels need to be added in the interface context in
        // ifmon.dll, not here.  But this is how it works for now!!!  So
        // we'll just dump the command that works.
        case FORMAT_DUMP:
            DisplayMessageT(DMP_IP_ADD_IPIPTUNNEL,
                            pwszQuoted,
                            rgwcLocalAddr,
                            rgwcRemAddr,
                            MAKELONG(MAKEWORD(pIpIpInfo->byTtl,0x00), 0x0000));
            break;

        default:
            break;
        }
    }

    if (pIpIpInfo)
    {
        FREE_BUFFER(pIpIpInfo);
    }

    return dwErr;
}
#endif //KSL_IPINIP

DWORD
ShowIpInterface(
    IN     DWORD   dwFormat,
    IN     LPCWSTR pwszIfName,
    IN OUT PDWORD  pdwNumRows
    )

/*++

Routine Description:

    Show the interface info for the interface
    The interface info consists of
        AdminStatus
        Router Discovery Info
        Protocols on the interface
    Other information like filters and routes are should using different
    commands

Arguments:

    pwszIfName - Interface name
    
Return Value:

    NO_ERROR
    
--*/

{
    DWORD                   dwErr;
    WCHAR                   wszIfDesc[MAX_INTERFACE_NAME_LEN + 1];
    PVALUE_STRING           pps;
    DWORD                   dwNumProto, dwBlkSize, dwCount, dwNumParsed;
    DWORD                   dwIfType , i;
    PBYTE                   pby;
    PWCHAR                  pwszStatus, pwszQuoted;
    PWCHAR                  pwszTokenStatus, pwszIfType;
    PINTERFACE_STATUS_INFO  pifStat;

    //
    // Interface status info
    //
 
    dwErr = IpmontrGetInfoBlockFromInterfaceInfo(pwszIfName,
                                          IP_INTERFACE_STATUS_INFO,
                                          (PBYTE *) &pifStat,
                                          &dwBlkSize,
                                          &dwCount,
                                          &dwIfType);
        
    if (dwErr != NO_ERROR)
    {
        // DisplayMessage(g_hModule, EMSG_IP_NO_STATUS_INFO);
        return dwErr;
    }

    if (pifStat->dwAdminStatus is IF_ADMIN_STATUS_UP)
    {
        pwszStatus      = MakeString(g_hModule, STRING_ENABLED);
        pwszTokenStatus = TOKEN_VALUE_ENABLE;
    }
    else
    {
        pwszStatus      = MakeString(g_hModule, STRING_DISABLED);
        pwszTokenStatus = TOKEN_VALUE_DISABLE;
    }

    FREE_BUFFER(pifStat);

    // Get description
   
    dwErr = GetInterfaceDescription(pwszIfName,
                                    wszIfDesc,
                                    &dwNumParsed);

    if (!dwNumParsed)
    {
        wcscpy(wszIfDesc, pwszIfName);
    }
   
    if(dwFormat is FORMAT_DUMP)
    {
        pwszQuoted = MakeQuotedString(wszIfDesc);
    }
    else
    {
        pwszQuoted = NULL;
    }
 
    pwszIfType = GetIfTypeString(dwIfType);

    // Display generic interface info

    switch (dwFormat) {
    case FORMAT_VERBOSE:
        DisplayMessage(g_hModule,  
                       MSG_RTR_INTERFACE_HDR, 
                       wszIfDesc);

        DisplayMessage(g_hModule, 
                       MSG_IP_IF_STATUS, 
                       pwszStatus);

        ShowIpIfProtocols(pwszIfName);

        break;

    case FORMAT_TABLE:
        if (*pdwNumRows is 0)
        {
            DisplayMessage(g_hModule, MSG_IP_IF_HEADER);
        }
        DisplayMessage(g_hModule, MSG_IP_IF_ENTRY, pwszStatus, pwszIfType,
                       wszIfDesc);
        break;

    case FORMAT_DUMP:
        DisplayMessageT(DMP_IP_ADD_IF, pwszQuoted, pwszTokenStatus);
        break;
    }
    (*pdwNumRows)++;

#ifdef KSL_IPINIP
    ShowIpInIpInfo(dwFormat, pwszIfName, pwszQuoted);
#endif //KSL_IPINIP

    FreeQuotedString(pwszQuoted);
    FreeString(pwszStatus);
    
    return NO_ERROR;
}


DWORD
CreateDumpFile(
    IN  LPCWSTR pwszName,
    OUT PHANDLE phFile
    )
{
    HANDLE  hFile;

    *phFile = NULL;

    hFile = CreateFileW(pwszName,
                        GENERIC_WRITE,
                        FILE_SHARE_READ | FILE_SHARE_DELETE,
                        NULL,
                        OPEN_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);

    if(hFile == INVALID_HANDLE_VALUE)
        return GetLastError();

    *phFile = hFile;

    return NO_ERROR;
}

VOID
DumpIpInformation(
    HANDLE  hFile
    )

/*++

Routine Description:

    Dumps all the IP Router manager information to the given file

Arguments:

    hFile   Handle of file

Return Value:

    None

--*/

{
    DWORD               dwErr, dwCount, dwTotal;
    DWORD               dwNumParsed, i;
    PMPR_INTERFACE_0    pmi0;
    WCHAR               wszIfDesc[MAX_INTERFACE_NAME_LEN + 1];
    DWORD               dwNumRows = 0;

    // Display dump header

    DisplayMessage(g_hModule, DMP_IP_HEADER_COMMENTS);

    DisplayMessageT(DMP_IP_HEADER);

    //
    // First dump the global information
    //

    ShowIpGlobal(hFile);

    ShowRoutePref(hFile);

    ShowScopes(hFile);

    //
    // Dump the per interface info
    //

    dwErr = IpmontrInterfaceEnum((PBYTE *) &pmi0, 
                          &dwCount, 
                          &dwTotal);

    if(dwErr != NO_ERROR)
    {
        DisplayError(g_hModule,
                     dwErr);

        return;
    }

    for(i = 0; i < dwCount; i++)
    {
        ShowIpInterface(FORMAT_DUMP,
                        pmi0[i].wszInterfaceName, &dwNumRows);

        ShowIpIfFilter(hFile,
                       FORMAT_DUMP,
                       pmi0[i].wszInterfaceName, &dwNumRows);

        ShowIpPersistentRoute(hFile,
                              pmi0[i].wszInterfaceName, &dwNumRows);

        ShowBoundaryInfoForInterface(hFile,
                                     pmi0[i].wszInterfaceName,
                                     &dwNumRows);
    }
    
    // Display dump footer

    DisplayMessageT(DMP_POPD);

    DisplayMessage(g_hModule, DMP_IP_FOOTER_COMMENTS);
}

DWORD
UpdateAutoStaticRoutes(
    IN  LPCWSTR pwszIfName
    )

{
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ip\ipmon\boundary.c ===
#include "precomp.h"
#pragma hdrstop

#ifdef SN_UNICODE
# define  sn_strlen  wcslen
# define  sn_strcpy  wcscpy
# define  sn_sprintf wsprintf
# define  sn_strcmp  wcscmp
# define  SN_EMPTYSTRING L""
# define  SN_L       L
#else
# define  sn_strlen  strlen
# define  sn_strcpy  strcpy
# define  sn_sprintf sprintf
# define  sn_strcmp  strcmp
# define  SN_EMPTYSTRING ""
# define  SN_L
#endif

IPV4_ADDRESS g_ipGrpAddr,
             g_ipGrpMask;
SCOPE_NAME   g_snScopeName;

enum RouterOps
{
    ADD_BOUNDARY       = 1,
    DELETE_BOUNDARY,
    ADD_SCOPE,
    DELETE_SCOPE,
    SET_SCOPE
};

typedef struct _SCOPE_ENTRY {
    IPV4_ADDRESS      ipGroupAddress;
    IPV4_ADDRESS      ipGroupMask;
    ULONG             ulNumNames;
    BOOL              bDivisible;
    LANGID            idLanguage;
    SCOPE_NAME_BUFFER snScopeNameBuffer;
    DWORD             dwNumInterfaces;
} SCOPE_ENTRY, *PSCOPE_ENTRY;

#define MIN_SCOPE_ADDR         0xef000000
#define MAX_SCOPE_ADDR        (0xefff0000 - 1)

DWORD
UpdateBoundaryBlock( 
    IN     DWORD  dwAction,
    IN     PBYTE  pib,
    OUT    PBYTE *ppibNew,
    IN OUT DWORD *pdwBlkSize,
    IN OUT DWORD *pdwCount,
    OUT    BOOL  *bChanged
    );

PSCOPE_ENTRY
FindScopeByPrefix(
    IN  IPV4_ADDRESS      ipGroupAddress,
    IN  IPV4_ADDRESS      ipGroupMask,
    IN  PSCOPE_ENTRY      pScopes,
    IN  ULONG             ulNumScopes
    )
{
    DWORD dwInd;

    for (dwInd = 0; dwInd < ulNumScopes; dwInd++)
    {
        if ( pScopes[dwInd].ipGroupAddress == ipGroupAddress
          && pScopes[dwInd].ipGroupMask    == ipGroupMask )
        {
            return &pScopes[dwInd];
        }
    }

    return NULL;
}

DWORD
FindScopeByName(
    IN  SCOPE_NAME    snScopeName,
    IN  PSCOPE_ENTRY  pScopes,
    IN  ULONG         ulNumScopes,
    OUT PSCOPE_ENTRY *ppScope
    )
{
    DWORD dwErr = NO_ERROR;
    ULONG i, j, dwCnt = 0;

    for (i = 0; i < ulNumScopes; i++)
    {
        if ( !sn_strcmp(snScopeName, pScopes[i].snScopeNameBuffer))
        {
            *ppScope = &pScopes[i];

            dwCnt++;
        }
    }

    switch (dwCnt) 
    {
    case 0:
        *ppScope = NULL;

        return ERROR_NOT_FOUND;

    case 1: 
        return NO_ERROR;

    default:
        return ERROR_MORE_DATA;
    }
}


DWORD
MakeInfoFromScopes2(
    OUT    PBYTE        pBuffer,
    IN OUT ULONG       *pulBufferLen,
    IN     PSCOPE_ENTRY pScopes,
    IN     ULONG        ulNumScopes
    )
/*++
Description:
    Compose registry block from array of scopes.
--*/
{
    DWORD dwLen, i, dwSize, dwNumNames, j, dwLanguage, dwFlags;
    PLIST_ENTRY pleNode;

    if (ulNumScopes is 0) {
        *pulBufferLen = 0;
        return NO_ERROR;
    }

    // Compute size needed

    dwSize = sizeof(DWORD);

    for (i=0; i< ulNumScopes; i++) 
    {
        dwSize += 2 * sizeof(IPV4_ADDRESS) + 2 * sizeof(DWORD);
        
        // Currently we only store at most one name.
        for (j=0; j<pScopes[i].ulNumNames; j++)
        {
            dwSize += (DWORD)(2*sizeof(DWORD)
                   + sn_strlen(pScopes[i].snScopeNameBuffer) * sizeof(SN_CHAR));
        }
    }

    if (dwSize > *pulBufferLen)
    {
        *pulBufferLen = dwSize;
        return ERROR_INSUFFICIENT_BUFFER;
    }

    //
    // Save scope count in first DWORD
    //

    *((PDWORD) pBuffer) = ulNumScopes;
    pBuffer += sizeof(DWORD);

    //
    // Now step through and add each scope to the buffer
    //

    for (i=0; i< ulNumScopes; i++)
    {
       // Copy scope address, and mask
       dwLen = 2 * sizeof(IPV4_ADDRESS);
       CopyMemory(pBuffer, &pScopes[i], dwLen);
       pBuffer += dwLen;

       // Copy flags
       dwFlags = pScopes[i].bDivisible;
       CopyMemory(pBuffer, &dwFlags, sizeof(dwFlags));
       pBuffer += sizeof(dwFlags);

       // Copy # of names
       CopyMemory(pBuffer, &pScopes[i].ulNumNames, sizeof(DWORD));
       pBuffer += sizeof(DWORD);

       // Currently we only save at most one name
       for (j=0; j<pScopes[i].ulNumNames; j++)
       {
           // Save language
           dwLanguage = pScopes[i].idLanguage;
           CopyMemory(pBuffer, &dwLanguage, sizeof(dwLanguage));
           pBuffer += sizeof(dwLanguage);

           // Copy scope name (save length in words)
           dwLen = sn_strlen(pScopes[i].snScopeNameBuffer);
           CopyMemory(pBuffer, &dwLen, sizeof(DWORD));
           pBuffer += sizeof(DWORD);
           dwLen *= sizeof(SN_CHAR);

           if (dwLen) 
           {
               CopyMemory(pBuffer, pScopes[i].snScopeNameBuffer, dwLen);
               pBuffer += dwLen;
           }
       }
    }

    return NO_ERROR;
}

DWORD
MakeInfoFromScopes( 
    OUT PBYTE       *ppibNew, 
    OUT DWORD       *pdwSize, 
    IN  PSCOPE_ENTRY pScopes, 
    IN  ULONG        ulNumScopes
    )
/*++
Description:
    Caller is responsible for freeing buffer returned.
--*/
{
    *pdwSize = 0;
    *ppibNew = NULL;

    if (MakeInfoFromScopes2(NULL, pdwSize, pScopes, ulNumScopes)
      is ERROR_INSUFFICIENT_BUFFER)
    {
        *ppibNew = MALLOC( *pdwSize );

        if ( *ppibNew == NULL )
        {
            DisplayMessage( g_hModule, MSG_IP_NOT_ENOUGH_MEMORY );
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    return MakeInfoFromScopes2(*ppibNew, pdwSize, pScopes, ulNumScopes);
}

PSCOPE_ENTRY
GetScopesFromInfo(
    IN  PBYTE                   pBuffer,
    OUT PULONG                  pulNumScopes
    )
/*++
Description:
    Convert a registry block into an array of scope information.
    Caller is responsible for freeing pointer returned.
--*/
{
    PSCOPE_ENTRY pScopes;
    DWORD        dwLen, i, dwNumNames, j, dwLanguage, dwFlags;

    if (pBuffer is NULL) 
    {
        *pulNumScopes = 0;
        return NULL;
    }

    //
    // Retrieve scope count from first DWORD
    //

    *pulNumScopes = *((PDWORD) pBuffer);
    pBuffer += sizeof(DWORD);

    //
    // Malloc enough space for pScopes
    //

    pScopes = MALLOC( (*pulNumScopes) * sizeof(SCOPE_ENTRY) );
    if (pScopes is NULL)
    {
        *pulNumScopes = 0;
        return NULL;
    }

    //
    // Now step through and add each scope to the array
    //

    for (i=0; i< *pulNumScopes; i++)
    {
       // Copy scope address, and mask
       dwLen = 2 * sizeof(IPV4_ADDRESS);
       CopyMemory(&pScopes[i], pBuffer, dwLen);
       pBuffer += dwLen;

       // Get flags
       CopyMemory(&dwFlags, pBuffer, sizeof(dwFlags));   
       pScopes[i].bDivisible = dwFlags;
       pBuffer += sizeof(dwFlags);

       // Get # of names
       CopyMemory(&dwNumNames, pBuffer, sizeof(DWORD));   
       pScopes[i].ulNumNames = dwNumNames;
       pBuffer += sizeof(DWORD);

       // Get names.  Currently, we'll only keep the last name (if any)
       // and throw out the rest.
       for (j=0; j<dwNumNames; j++)
       {
           // Set language name
           CopyMemory(&dwLanguage, pBuffer, sizeof(dwLanguage));
           pBuffer += sizeof(dwLanguage);
           pScopes[i].idLanguage = (LANGID)dwLanguage;
           
           CopyMemory(&dwLen, pBuffer, sizeof(DWORD));
           pBuffer += sizeof(DWORD);
           CopyMemory( pScopes[i].snScopeNameBuffer, 
                       pBuffer, 
                       dwLen * sizeof(SN_CHAR) );
           pScopes[i].snScopeNameBuffer[ dwLen ] = '\0';
           pBuffer += dwLen * sizeof(SN_CHAR);

           pScopes[i].ulNumNames = 1;
       }

       pScopes[i].dwNumInterfaces = 0; // this value is ignored
    }

    return pScopes;
}

PSCOPE_ENTRY
GetScopes(
    OUT PULONG                  pulNumScopes,
    OUT PBYTE                  *ppBuffer
    )
/*++
Description:
    Creates a SCOPE_ENTRY array by parsing the info block
    Caller is responsible for freeing both the pointer returned
    and the buffer passed back.
Called by:
    ShowBoundaryInfoForInterface(), UpdateScopeBlock()
--*/
{
    DWORD         i, dwLen, dwErr, dwBlkSize, dwCount;
    DWORD         dwInd;
    PSCOPE_ENTRY  pScopes;

    if ( IpmontrGetInfoBlockFromGlobalInfo( IP_MCAST_BOUNDARY_INFO,
                                     ppBuffer,
                                     &dwBlkSize,
                                     &dwCount ) isnot NO_ERROR)
    {
        *pulNumScopes = 0;
        return NULL;
    }

    pScopes = GetScopesFromInfo(*ppBuffer, pulNumScopes);

    return pScopes;
}

DWORD
ScopeNameToPrefix(
    IN  SCOPE_NAME    snScopeName,
    OUT IPV4_ADDRESS *pipScopeAddr,
    OUT IPV4_ADDRESS *pipScopeMask
    )
{
    DWORD        dwErr = ERROR_NOT_FOUND;
    ULONG        ulNumScopes;
    PBYTE        pBuffer = NULL;
    PSCOPE_ENTRY pScopes, pScope;

    // If first character is a digit, then assume it's
    // an address, not a name.

    if (iswdigit(snScopeName[0]))
    {
        dwErr = GetIpAddress(snScopeName, pipScopeAddr);

        if (dwErr is NO_ERROR)
        {
            return NO_ERROR;
        }
    }

    pScopes = GetScopes( &ulNumScopes, &pBuffer );

    if (pScopes)
    {
        dwErr = FindScopeByName(snScopeName, pScopes, ulNumScopes, &pScope);

        if (dwErr is NO_ERROR)
        {
            *pipScopeAddr = pScope->ipGroupAddress;
            *pipScopeMask = pScope->ipGroupMask;

            dwErr = NO_ERROR;
        }

        FREE(pScopes);
    }

    if (pBuffer)
        FREE(pBuffer);

    return dwErr;
}

DWORD
UpdateScope( 
    IN      PSCOPE_ENTRY  pScopeToUpdate,
    IN      PSCOPE_ENTRY  pScopes,
    IN      ULONG         ulNumScopes,
    OUT     PBYTE        *ppibNew,
    OUT     DWORD        *pdwSizeNew
    )
/*++
Description:
    Caller is responsible for freeing buffer returned.
--*/
{
    // Update the scope name

    sn_strcpy(pScopeToUpdate->snScopeNameBuffer, g_snScopeName);

    pScopeToUpdate->ulNumNames = 1;
    pScopeToUpdate->idLanguage = GetUserDefaultLangID();

    // Now convert the array to a buffer

    return MakeInfoFromScopes( ppibNew, pdwSizeNew, pScopes, ulNumScopes);
}

DWORD
DeleteBoundaryFromInterface( 
    IN  LPCWSTR      pwszIfName,
    IN  PSCOPE_ENTRY pScopeToDelete 
    )
{
    BOOL  bChanged;
    DWORD dwErr, dwBlkSize, dwCount, dwIfType;
    PBYTE pibNew, pib;

    dwErr = IpmontrGetInfoBlockFromInterfaceInfo( pwszIfName,
                                           IP_MCAST_BOUNDARY_INFO,
                                           &pib,
                                           &dwBlkSize,
                                           &dwCount,
                                           &dwIfType );

    if (dwErr is ERROR_NOT_FOUND)
        return NO_ERROR;

    if (dwErr isnot NO_ERROR)
        return dwErr;

    dwErr = UpdateBoundaryBlock( DELETE_BOUNDARY,
                                 pib,
                                 &pibNew,
                                 &dwBlkSize,
                                 &dwCount,
                                 &bChanged );

    if (dwErr is NO_ERROR && bChanged)
    {
        dwErr = IpmontrSetInfoBlockInInterfaceInfo( pwszIfName,
                                             IP_MCAST_BOUNDARY_INFO,
                                             pibNew,
                                             dwBlkSize,
                                             dwCount );
    }

    if (pib)
        FREE(pib);

    if (pibNew)
        FREE(pibNew);
    
    return dwErr;
}

DWORD
DeleteScopeBoundaries(
    IN      PSCOPE_ENTRY  pScopeToDelete
    )
{
    DWORD dwErr, dwCount, dwTotal, i;
    PMPR_INTERFACE_0     pmi0;

    // Enumerate interfaces

    dwErr = IpmontrInterfaceEnum((PBYTE *) &pmi0, &dwCount, &dwTotal);

    if (dwErr isnot NO_ERROR)
    {
        DisplayError(g_hModule, dwErr);

        return dwErr;
    }

    // Delete scope boundaries for each interface

    for ( i = 0; i < dwCount && dwErr is NO_ERROR; i++)
    {
        dwErr = DeleteBoundaryFromInterface( pmi0[i].wszInterfaceName,
                                             pScopeToDelete );

        // Ignore ERROR_NO_SUCH_INTERFACE since it may be that IP
        // is not enabled on the interface, so we expect to get this
        // error sometimes.

        if (dwErr is ERROR_NO_SUCH_INTERFACE)
        {
            dwErr = NO_ERROR;
        }
    }

    return dwErr;
}

DWORD
DeleteScope( 
    IN      PSCOPE_ENTRY  pScopeToDelete,
    IN      PSCOPE_ENTRY  pScopes,
    IN      ULONG        *pulNumScopes,
    OUT     PBYTE        *ppibNew,
    OUT     DWORD        *pdwSizeNew
    )
/*++
Description:
    Creates a new info block which does not include the scope given
    by pScopeToDelete.
    Caller is responsible for freeing buffer returned.
Called by:
    UpdateScopeBlock()
--*/
{
    DWORD dwErr;

    // Delete all boundaries for this scope

    dwErr = DeleteScopeBoundaries(pScopeToDelete);

    if (dwErr isnot NO_ERROR)
        return dwErr;

    // Delete the scope from the array

    MoveMemory( pScopeToDelete, 
                pScopeToDelete+1, 
                ((PBYTE)(pScopes + *pulNumScopes)) 
                  - ((PBYTE)(pScopeToDelete + 1) ));

    (*pulNumScopes)--;

    // Now convert the array to a buffer

    return MakeInfoFromScopes( ppibNew, pdwSizeNew, pScopes, *pulNumScopes);
}

DWORD
AddScope(
    IN OUT  PSCOPE_ENTRY *ppScopes,
    IN      ULONG        *pulNumScopes,
    OUT     PBYTE        *ppibNew,
    OUT     DWORD        *pdwSizeNew
    )
/*++
Description:
    Creates a new info block which includes the scope given
    by g_snScopeName, g_dwDstAddr, and g_dwDstMask.
    Caller is responsible for freeing buffer returned.
Called by:
    UpdateScopeBlock()
--*/
{
    PBYTE                  *pBuff;

    DWORD                   dwRes       = NO_ERROR,
                            dwInd,
                            dwSize      = 0,
                            dwSizeReqd  = 0;

    SCOPE_ENTRY            *pScopes = *ppScopes;

    do
    {
        // Make room for the new scope

        if (*pulNumScopes > 0)
        {
            LPVOID Tmp;
            
            Tmp = REALLOC( pScopes, 
                               (*pulNumScopes + 1) * sizeof(SCOPE_ENTRY) );
            if (Tmp==NULL && pScopes)
            {
                FREE( pScopes );
            }
            pScopes = Tmp;
        }
        else
            pScopes = MALLOC( sizeof(SCOPE_ENTRY) );
        
        if (!pScopes)
            return ERROR_NOT_ENOUGH_MEMORY;

        dwInd = (*pulNumScopes)++;

        // Fill in the new scope 

        ZeroMemory(&pScopes[dwInd], sizeof(SCOPE_ENTRY));
        pScopes[dwInd].ipGroupAddress = g_ipGrpAddr;
        pScopes[dwInd].ipGroupMask    = g_ipGrpMask;
        sn_strcpy(pScopes[dwInd].snScopeNameBuffer, g_snScopeName);
        pScopes[dwInd].ulNumNames = 1;
        pScopes[dwInd].idLanguage = GetUserDefaultLangID();

        // Now convert the array to a buffer

        dwRes = MakeInfoFromScopes( ppibNew, &dwSize, pScopes, *pulNumScopes);

    } while ( FALSE );

    *pdwSizeNew = dwSize;

    *ppScopes = pScopes;

    return dwRes;
}

BOOL
IsContiguous(
    IN IPV4_ADDRESS dwMask
    )
{
    register int i;

    dwMask = ntohl(dwMask);

    // Set i to index of lowest 1 bit, or 32 if none
    for (i=0; i<32 && !(dwMask & (1<<i)); i++);

    // Set i to index of lowest 0 bit greater than the 1 bit found,
    // or 32 if none
    for (; i<32 && (dwMask & (1<<i)); i++);

    // Mask is contiguous if we got up to 32 without finding such
    // a 0 bit.
    return (i is 32);
}

DWORD
UpdateScopeBlock( 
    DWORD  dwAction,
    PBYTE  pib,
    PBYTE *ppibNew,
    DWORD *pdwBlkSize,
    DWORD *pdwCount
    )
/*++
Description:
    Caller is responsible for freeing buffer returned.
Called by:
    IpAddSetDelScope()
--*/
{
    DWORD                   dwRes       = (DWORD) -1,
                            dwInd       = 0,
                            dwSize      = 0;

    ULONG                   ulNumScopes = 0;

    PSCOPE_ENTRY            pScopes     = NULL,
                            pFoundScope = NULL;

    do
    {
        *ppibNew = NULL;
        *pdwBlkSize = 0;
        *pdwCount = 0;

        //
        // Verify scope info.
        //

        if ( ( g_ipGrpAddr & g_ipGrpMask ) != g_ipGrpAddr
         || ntohl(g_ipGrpAddr) < MIN_SCOPE_ADDR
         || ntohl(g_ipGrpAddr) > MAX_SCOPE_ADDR)
        {
            dwRes = ERROR_INVALID_PARAMETER;
            break;
        }

        // Make sure mask is contiguous
        if (!IsContiguous(g_ipGrpMask))
        {
            char buff[20], *lpstr;

            lpstr = inet_ntoa( *((struct in_addr *) &g_ipGrpMask));

            if (lpstr != NULL)
            {
                strcpy( buff, lpstr );
                DisplayMessage( g_hModule,  MSG_IP_BAD_IP_MASK, buff );
            }
            break;
        }

        //
        // Find if specified scope is present
        //

        pScopes = GetScopesFromInfo( pib, &ulNumScopes );

        if ( pScopes )
        {
            pFoundScope = FindScopeByPrefix( g_ipGrpAddr,
                                             g_ipGrpMask,
                                             pScopes,
                                             ulNumScopes
                                           );
        }

        //
        // Update the scope infoblock.
        //

        switch ( dwAction )
        {

        case ADD_SCOPE:

            //
            // If scope is not present, add it. Else return error.
            //

            if ( !pFoundScope )
            {
                dwRes = AddScope( &pScopes, &ulNumScopes, ppibNew, &dwSize );

                if ( dwRes == NO_ERROR )
                {
                    *pdwBlkSize = dwSize;

                    *pdwCount = 1;
                }

                break;
            }
            // else fall through into SET_SCOPE.

        case SET_SCOPE:

            //
            // if scope present, update it.
            //

            if ( pFoundScope )
            {
                dwRes = UpdateScope( pFoundScope,
                                     pScopes,
                                     ulNumScopes,
                                     ppibNew,
                                     &dwSize );

                if ( dwRes == NO_ERROR )
                {
                    *pdwBlkSize = dwSize;

                    *pdwCount = 1;
                }
            }
            else
            {
                dwRes = ERROR_INVALID_PARAMETER;
            }

            break;

        case DELETE_SCOPE:

            //
            // Delete scope only if present.
            //

            if ( pFoundScope )
            {
                dwRes = DeleteScope( pFoundScope, 
                                     pScopes, 
                                     &ulNumScopes,
                                     ppibNew, 
                                     &dwSize );

                if ( dwRes == NO_ERROR )
                {
                    *pdwBlkSize = dwSize;

                    *pdwCount = (dwSize>0)? 1 : 0;
                }
            }
            else
            {
                dwRes = ERROR_INVALID_PARAMETER;
            }

            break;
        }

    } while ( FALSE );

    if (pScopes)
        FREE( pScopes );

    return dwRes;
}

DWORD
VerifyBoundaryPrefix(
    IPV4_ADDRESS ipAddr,
    IPV4_ADDRESS ipMask
    )
{
    WCHAR                   wstr1[20], wstr2[20];

    //
    // Verify boundary info.
    //

    if (ntohl(ipAddr) < MIN_SCOPE_ADDR
     || ntohl(ipAddr) > MAX_SCOPE_ADDR)
    {
        MakeAddressStringW(wstr1, htonl(MIN_SCOPE_ADDR));
        MakeAddressStringW(wstr2, htonl(MAX_SCOPE_ADDR));

        DisplayMessage( g_hModule, 
                        EMSG_INVALID_ADDR, 
                        wstr1, 
                        wstr2 );

        return ERROR_INVALID_PARAMETER;
    }

    if ( ( ipAddr & ipMask ) != ipAddr )
    {
        DisplayMessage( g_hModule, EMSG_PREFIX_ERROR );

        return ERROR_INVALID_PARAMETER;
    }

    // Make sure mask is contiguous
    if (!IsContiguous(ipMask))
    {
        char buff[20], *lpstr;

        lpstr = inet_ntoa( *((struct in_addr *) &g_ipGrpMask));

        if (lpstr != NULL)
        {
            strcpy( buff, lpstr );
            DisplayMessage( g_hModule,  MSG_IP_BAD_IP_MASK, buff );
        }

        return ERROR_INVALID_PARAMETER;
    }

    return NO_ERROR;
}

DWORD
IpAddSetDelScope( 
    DWORD     dwAction,
    PWCHAR   *ppwcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount
    )
{
    DWORD        dwErr;
    TAG_TYPE     pttTags[] = {{TOKEN_GROUP_ADDRESS,FALSE,FALSE},
                             {TOKEN_GROUP_MASK,    FALSE,FALSE},
                             {TOKEN_SCOPE_NAME,    FALSE,FALSE}};
    SCOPE_NAME_BUFFER snScopeName;
    DWORD        rgdwTagType[sizeof(pttTags)/sizeof(TAG_TYPE)];
    IPV4_ADDRESS ipGroup, ipMask;
    DWORD        dwBlkSize, dwCount, i, dwNumParsed;
    PBYTE        pib, pibNew = NULL;
    DWORD        dwArgsReqd = (dwAction is DELETE_SCOPE)? 1 : 3;
    PWCHAR       p;    

    // Do generic processing

    dwErr = PreHandleCommand( ppwcArguments,
                              dwCurrentIndex,
                              dwArgCount,
                              pttTags,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              dwArgsReqd,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              rgdwTagType );

    if (dwErr) 
    {
        return dwErr;
    }

    g_ipGrpAddr = g_ipGrpMask = 0;

    for(i = 0; i < dwArgCount - dwCurrentIndex; i ++)
    {
        switch (rgdwTagType[i])
        {
            case 1: // GRPMASK
            {
                dwErr = GetIpMask(ppwcArguments[i + dwCurrentIndex], 
                                  &g_ipGrpMask);

                if (dwErr is ERROR_INVALID_PARAMETER)
                {
                    DisplayMessage( g_hModule,  MSG_IP_BAD_IP_ADDR,
                                    ppwcArguments[i + dwCurrentIndex]);

                    DispTokenErrMsg(g_hModule, MSG_IP_BAD_OPTION_VALUE,
                                    pttTags[rgdwTagType[i]].pwszTag,
                                    ppwcArguments[i + dwCurrentIndex]);

                    return NO_ERROR;
                }

                break;
            }

            case 0: // GRPADDR
            {
                dwErr = GetIpPrefix(ppwcArguments[i + dwCurrentIndex], 
                                    &g_ipGrpAddr,
                                    &g_ipGrpMask);

                if (!((dwErr is ERROR_INVALID_PARAMETER)
                      && (dwAction is DELETE_SCOPE)))
                {
                    break;
                }

                // FALLTHROUGH
            }


            case 2 : // SCOPENAME
            {
                // Strip leading and trailing whitespace
                for (p = ppwcArguments[i + dwCurrentIndex]; iswspace(*p); p++);
                while (iswspace( p[wcslen(p) - 1] ))
                {
                    p[ wcslen(p)-1 ] = 0;
                }

                if (wcslen(p) > MAX_SCOPE_NAME_LEN)
                {
                    DisplayMessage( g_hModule, 
                                    EMSG_SCOPE_NAME_TOO_LONG,
                                    MAX_SCOPE_NAME_LEN );

                    return NO_ERROR;
                }

                sn_strcpy( snScopeName, p);
                g_snScopeName = snScopeName;

                if (dwAction is DELETE_SCOPE)
                {
                    dwErr = ScopeNameToPrefix(snScopeName,
                                              &g_ipGrpAddr,
                                              &g_ipGrpMask);

                    if (dwErr is ERROR_MORE_DATA)
                    {
                        DisplayMessage( g_hModule,  EMSG_AMBIGUOUS_SCOPE_NAME,
                                        ppwcArguments[i + dwCurrentIndex]);

                        return NO_ERROR;
                    }
                }

                break;
            }
        }
    }

    if (dwErr isnot NO_ERROR)
    {
        return dwErr;
    }

    if (!g_ipGrpAddr || !g_ipGrpMask)
    {
        return ERROR_INVALID_SYNTAX;
    }

    dwErr = VerifyBoundaryPrefix(g_ipGrpAddr, g_ipGrpMask);

    if (dwErr)
    {
        return NO_ERROR;
    }

    do {

        dwErr = IpmontrGetInfoBlockFromGlobalInfo( IP_MCAST_BOUNDARY_INFO,
                                            &pib,
                                            &dwBlkSize,
                                            &dwCount );

        if (dwErr is ERROR_NOT_FOUND)
        {
            //
            // No info of this type is currently present
            //
     
            dwErr = NO_ERROR;
            dwCount = 1;
        }

        if (dwErr isnot NO_ERROR)
            break;

        dwErr = UpdateScopeBlock( dwAction,
                                  pib, 
                                  &pibNew, 
                                  &dwBlkSize, 
                                  &dwCount );

        if (dwErr isnot NO_ERROR)
            break;

        dwErr = IpmontrSetInfoBlockInGlobalInfo( IP_MCAST_BOUNDARY_INFO,
                                          pibNew,
                                          dwBlkSize,
                                          dwCount );

    } while (FALSE);

    if (pib)
        HeapFree(GetProcessHeap(), 0 , pib);

    if (pibNew)
        HeapFree(GetProcessHeap(), 0 , pibNew);

    return dwErr;
}

DWORD
HandleIpAddScope(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )

/*++

Routine Description:

Arguments:

    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg

Return Value:

    NO_ERROR

--*/

{
    return IpAddSetDelScope( ADD_SCOPE,
                             ppwcArguments,
                             dwCurrentIndex,
                             dwArgCount );
}

DWORD
HandleIpDelScope(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )

/*++

Routine Description:

Arguments:

    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg

Return Value:

    NO_ERROR

--*/

{
    return IpAddSetDelScope( DELETE_SCOPE,
                             ppwcArguments,
                             dwCurrentIndex,
                             dwArgCount );
}

DWORD
HandleIpSetScope(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )

/*++

Routine Description:

Arguments:

    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg

Return Value:

    NO_ERROR

--*/

{
    return IpAddSetDelScope( SET_SCOPE,
                             ppwcArguments,
                             dwCurrentIndex,
                             dwArgCount );
}


DWORD
ShowScopes(
    IN HANDLE  hFile
    )
{
    DWORD                   dwRes        = (DWORD) -1,
                            dwCnt        = 0,
                            dwInd        = 0,
                            dwGlobalSize = 0;

    ULONG                   ulNumScopes    = 0;

    CHAR                    szAddr1[ ADDR_LENGTH ],
                            szAddr2[ ADDR_LENGTH ];

    PSCOPE_ENTRY            pScope,
                            pScopes;

    HANDLE                  hTransport    = (HANDLE) NULL;

    PBYTE                   pScopesBuffer;

    SCOPE_NAME_BUFFER       snScopeNameBuffer;

    do
    {
        pScopes = GetScopes( &ulNumScopes, &pScopesBuffer );

        if (hFile is NULL)
        {
            if (ulNumScopes)
            {
                DisplayMessage( g_hModule, MSG_RTR_SCOPE_HDR );
            }
            else
            {
                DisplayMessage( g_hModule, MSG_IP_NO_ENTRIES );
            }
        }

        //
        // Enumerate the scopes
        //

        for ( dwCnt = 0; dwCnt < ulNumScopes; dwCnt++ )
        {
            pScope = &pScopes[dwCnt];

            strcpy(
                    szAddr1,
                    inet_ntoa( *((struct in_addr *) &pScope->ipGroupAddress) )
                  );

            strcpy(
                    szAddr2,
                    inet_ntoa( *((struct in_addr *) &pScope->ipGroupMask) )
                  );

            MakePrefixStringW(snScopeNameBuffer,
                              pScope->ipGroupAddress,
                              pScope->ipGroupMask);

            if (hFile)
            {
                PWCHAR pwszQuoted = MakeQuotedString( (pScope->ulNumNames)? 
                    pScope->snScopeNameBuffer : snScopeNameBuffer );

                DisplayMessageT( DMP_SCOPE_INFO,
                                 szAddr1,
                                 szAddr2,
                                 pwszQuoted );

                FreeQuotedString(pwszQuoted);
            }
            else
            {
                DisplayMessage( g_hModule,
                    MSG_RTR_SCOPE_INFO,
                    szAddr1,
                    szAddr2,
                    (pScope->ulNumNames)? pScope->snScopeNameBuffer 
                                        : snScopeNameBuffer );
            }
        }

        dwRes = NO_ERROR;

        if (pScopes)
            FREE(pScopes);

        if (pScopesBuffer)
            FREE(pScopesBuffer);

    } while ( FALSE );

    return dwRes;
}

DWORD
HandleIpShowScope(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )

/*++

Routine Description:

Arguments:

    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg

Return Value:

    NO_ERROR

--*/

{
    return ShowScopes(0);
}





DWORD
DeleteBoundary(
   IN     DWORD  dwDelInd,
   IN     PBYTE  pib,
   OUT    PBYTE *ppibNew,
   IN OUT DWORD *pdwCount
   )
/*++
Description:
    Creates a new info block header which does not include the
    boundary with the specified index.
    Caller is responsible for freeing buffer returned.
Called by:
    UpdateBoundaryBlock()
--*/
{
    DWORD                   dwInd   = 0,
                            dwCnt   = 0,
                            dwCnt0  = 0,
                            dwSize  = 0,
                            dwRes   = NO_ERROR;

    LPBYTE                  pbDst   = (LPBYTE) NULL,
                            pbSrc   = (LPBYTE) NULL;

    PRTR_INFO_BLOCK_HEADER  pibh    = (PRTR_INFO_BLOCK_HEADER) NULL;

    PMIB_BOUNDARYROW      pimbSrc  = (PMIB_BOUNDARYROW) NULL;
    PMIB_BOUNDARYROW      pimbDst  = (PMIB_BOUNDARYROW) NULL;

    //
    // Create new info block with boundary removed.
    //

    dwSize = (*pdwCount - 1) * sizeof( MIB_BOUNDARYROW );

    if (dwSize is 0) 
    {
        *ppibNew = NULL;

        *pdwCount = 0;

        return NO_ERROR;
    }

    *ppibNew = MALLOC( dwSize );

    if ( *ppibNew == NULL )
    {
        DisplayMessage( g_hModule, MSG_IP_NOT_ENOUGH_MEMORY );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Copy boundaries, skip boundary to be deleted
    //

    pimbDst = (PMIB_BOUNDARYROW) *ppibNew;
    pimbSrc = (PMIB_BOUNDARYROW) pib;

    for ( dwCnt = 0, dwCnt0 = 0;
          dwCnt < *pdwCount;
          dwCnt++ )
    {
        if ( dwCnt == dwDelInd )
        {
            continue;
        }

        pimbDst[ dwCnt0 ] = pimbSrc[ dwCnt ];
        dwCnt0++;
    }

    (*pdwCount)--;

    return NO_ERROR;
}

DWORD
AddBoundary (
   IN     PBYTE  pib,
   OUT    PBYTE *ppibNew,
   IN OUT DWORD *pdwCount
   )
/*++
Description:
   Creates a new info block which includes a boundary for the
   scope identified by g_ipGrpAddr/g_ipGrpMask.
   Caller is responsible for freeing buffer returned.
Called by:
   UpdateBoundaryBlock()
--*/
{
    DWORD                   dwRes     = NO_ERROR,
                            dwInd     = 0,
                            dwSize    = 0;

    LPBYTE                  pbDst     = (LPBYTE) NULL,
                            pbSrc     = (LPBYTE) NULL;

    PMIB_BOUNDARYROW        pimb      = (PMIB_BOUNDARYROW ) NULL;

    dwRes = VerifyBoundaryPrefix(g_ipGrpAddr, g_ipGrpMask);

    if (dwRes)
    {
        return NO_ERROR;
    }

    do
    {
        *ppibNew = NULL;

        //
        // If this is the first boundary, create info block
        // with an extra TocEntry.
        //

        dwSize = (*pdwCount + 1) * sizeof( MIB_BOUNDARYROW );

        *ppibNew = MALLOC( dwSize );

        if ( *ppibNew == NULL )
        {
            DisplayMessage(g_hModule, MSG_IP_NOT_ENOUGH_MEMORY );
            dwRes = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        pbDst = *ppibNew;

        CopyMemory( pbDst, pib, (*pdwCount) * sizeof(MIB_BOUNDARYROW) );

        pbDst += (*pdwCount) * sizeof(MIB_BOUNDARYROW);

        (*pdwCount)++;

        pimb = (PMIB_BOUNDARYROW) pbDst;
        pimb-> dwGroupAddress = g_ipGrpAddr;
        pimb-> dwGroupMask    = g_ipGrpMask;

        pbDst += sizeof( MIB_BOUNDARYROW );

    } while ( FALSE );

    return dwRes;
}

BOOL
IsBoundaryPresent(
   IN  IPV4_ADDRESS        ipGroupAddress,
   IN  IPV4_ADDRESS        ipGroupMask,
   IN  PMIB_BOUNDARYROW    pimb,
   IN  DWORD               dwNumBoundaries,
   OUT PDWORD              pdwInd
   )
/*++
Returns:
   TRUE if present, and sets dwInd to index
   FALSE if not present, and sets dwInd to -1
Called by:
   UpdateBoundaryBlock()
--*/
{
    DWORD       dwInd = 0;

    *pdwInd = (DWORD) -1;

    for ( dwInd = 0; dwInd < dwNumBoundaries; dwInd++, pimb++ )
    {
        if ( pimb-> dwGroupAddress != ipGroupAddress
          || pimb-> dwGroupMask    != ipGroupMask )
        {
            continue;
        }

        *pdwInd = dwInd;
        return TRUE;
    }

    return FALSE;
}

DWORD
UpdateBoundaryBlock( 
    IN     DWORD  dwAction,
    IN     PBYTE  pib,
    OUT    PBYTE *ppibNew,
    IN OUT DWORD *pdwBlkSize,
    IN OUT DWORD *pdwCount,
    OUT    BOOL  *pbChanged
    )
/*++
Description:
    Caller is responsible for freeing buffer returned.
Called by:
    IpAddDelBoundary(), DeleteBoundaryFromInterface()
--*/
{
    DWORD                   dwRes           = NO_ERROR,
                            dwInd           = 0,
                            dwInd0          = 0;

    BOOL                    bBoFound        = FALSE;

    PMIB_BOUNDARYROW        pimb            = (PMIB_BOUNDARYROW) NULL;

    *pbChanged = FALSE;

    do
    {
        *ppibNew = NULL;

        //
        // Find if specified boundary is present
        //

        bBoFound = IsBoundaryPresent( g_ipGrpAddr,
                                      g_ipGrpMask,
                                      (PMIB_BOUNDARYROW)pib,
                                      *pdwCount,
                                      &dwInd0 );

        //
        // Update the boundary infoblock.
        //

        switch ( dwAction )
        {

        case ADD_BOUNDARY:

            //
            // If boundary is not present, add it. Else return error.
            //

            if ( !bBoFound )
            {
                dwRes = AddBoundary( pib, ppibNew, pdwCount );

                *pdwBlkSize = sizeof(MIB_BOUNDARYROW);

                *pbChanged = TRUE;
            }
            else
            {
                dwRes = ERROR_OBJECT_ALREADY_EXISTS;
            }
            break;

        case DELETE_BOUNDARY:

            //
            // Delete boundary only if present.
            //

            if ( bBoFound )
            {
                dwRes = DeleteBoundary( dwInd0, pib, ppibNew, pdwCount );

                *pbChanged = TRUE;
            }

            // If not present, return success but don't set the changed flag.

            break;
        }

    } while ( FALSE );

    return dwRes;
}


DWORD
IpAddDelBoundary(
    DWORD     dwAction,
    PWCHAR   *ppwcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount
    )
{
    DWORD        dwErr;
    TAG_TYPE     pttTags[] = {{TOKEN_NAME,          TRUE, FALSE},
                              {TOKEN_GROUP_ADDRESS, FALSE,FALSE},
                              {TOKEN_GROUP_MASK,    FALSE,FALSE},
                              {TOKEN_SCOPE_NAME,    FALSE,FALSE},
                             };
    WCHAR        rgwcIfName[MAX_INTERFACE_NAME_LEN + 1];
    DWORD        rgdwTagType[sizeof(pttTags)/sizeof(TAG_TYPE)];
    IPV4_ADDRESS ipGroup, ipMask;
    DWORD        dwBlkSize, dwCount, dwIfType, i, dwNumParsed;
    PBYTE        pib, pibNew = NULL;
    BOOL         bChanged; 

    // Do generic processing

    dwErr = PreHandleCommand( ppwcArguments,
                              dwCurrentIndex,
                              dwArgCount,
                              pttTags,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              2,
                              3,
                              rgdwTagType );

    if (dwErr) 
    {
        return dwErr;
    }

    g_ipGrpAddr = g_ipGrpMask = 0;

    for(i = 0; i < dwArgCount - dwCurrentIndex; i ++)
    {
        switch (rgdwTagType[i])
        {
            case 0 : // NAME
            {
                DWORD BufLen = sizeof(rgwcIfName);
                GetInterfaceName(ppwcArguments[i + dwCurrentIndex],
                                 rgwcIfName,
                                 BufLen,
                                 &dwNumParsed);

                break;
            }

            case 1: // GRPADDR
            {
                dwErr = GetIpPrefix(ppwcArguments[i + dwCurrentIndex], 
                                    &g_ipGrpAddr,
                                    &g_ipGrpMask);

                if (!((dwErr is ERROR_INVALID_PARAMETER)
                      && (dwAction is DELETE_BOUNDARY)))
                {
                    break;
                }

                // FALLTHROUGH
            }

            case 3: // SCOPENAME
            {
                dwErr = ScopeNameToPrefix( ppwcArguments[i + dwCurrentIndex],
                                           &g_ipGrpAddr,
                                           &g_ipGrpMask );

                if (dwErr is ERROR_MORE_DATA)
                {
                    DisplayMessage( g_hModule,  EMSG_AMBIGUOUS_SCOPE_NAME,
                                    ppwcArguments[i + dwCurrentIndex]);

                    return NO_ERROR;
                }

                break;
            }

            case 2: // GRPMASK
            {
                dwErr = GetIpMask(ppwcArguments[i + dwCurrentIndex], 
                                  &g_ipGrpMask);

                if (dwErr is ERROR_INVALID_PARAMETER)
                {
                    DisplayMessage( g_hModule,  MSG_IP_BAD_IP_ADDR,
                                    ppwcArguments[i + dwCurrentIndex]);

                    DispTokenErrMsg(g_hModule, MSG_IP_BAD_OPTION_VALUE,
                                    pttTags[rgdwTagType[i]].pwszTag,
                                    ppwcArguments[i + dwCurrentIndex]);

                    return NO_ERROR;
                }

                break;
            }
        }
    }

    if (dwErr isnot NO_ERROR)
    {
        return dwErr;
    }

    if (!g_ipGrpAddr || !g_ipGrpMask)
    {
        return ERROR_INVALID_SYNTAX;
    }

    do {

        dwErr = IpmontrGetInfoBlockFromInterfaceInfo( rgwcIfName,
                                               IP_MCAST_BOUNDARY_INFO,
                                               &pib,
                                               &dwBlkSize,
                                               &dwCount,
                                               &dwIfType );

        if (dwErr is ERROR_NOT_FOUND)
        {
            //
            // No info of this type is currently present
            //
     
            dwErr = NO_ERROR;
            dwCount = 0;
        }

        if (dwErr isnot NO_ERROR)
            break;

        dwErr = UpdateBoundaryBlock( dwAction,
                                     pib, 
                                     &pibNew, 
                                     &dwBlkSize, 
                                     &dwCount,
                                     &bChanged );

        if (dwErr isnot NO_ERROR)
            break;

        if (bChanged)
        {
            dwErr = IpmontrSetInfoBlockInInterfaceInfo( rgwcIfName,
                                                 IP_MCAST_BOUNDARY_INFO,
                                                 pibNew,
                                                 dwBlkSize,
                                                 dwCount );
        }

    } while (FALSE);

    if (pib)
        FREE(pib);

    if (pibNew)
        FREE(pibNew);

    return dwErr;
}

DWORD
HandleIpAddBoundary(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )


/*++

Routine Description:

Arguments:

    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg

Return Value:

    NO_ERROR

--*/

{
    return IpAddDelBoundary( ADD_BOUNDARY,
                             ppwcArguments,
                             dwCurrentIndex,
                             dwArgCount );
}

DWORD
HandleIpDelBoundary(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )

/*++

Routine Description:

Arguments:

    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg

Return Value:

    NO_ERROR

--*/

{
    return IpAddDelBoundary( DELETE_BOUNDARY,
                             ppwcArguments,
                             dwCurrentIndex,
                             dwArgCount );
}

DWORD
ShowBoundaryInfoForInterface(
    IN  HANDLE  hFile,
    IN  LPCWSTR pwszIfName,
    OUT PDWORD  pdwNumRows
    )
/*++
Called by:
   ShowBoundaryInfo()
--*/
{
    DWORD                   dwErr,
                            dwBlkSize,
                            dwCount,
                            dwIfType,
                            dwNumParsed,
                            dwInd          = 0,
                            dwCnt          = 0,
                            dwSize         = 0,
                            dwGlobalSize   = 0,
                            dwIfLen        = 0;

    WCHAR                   wszIfDesc[MAX_INTERFACE_NAME_LEN + 1];

    ULONG                   ulNumScopes    = 0;

    CHAR                    szAddr1[ ADDR_LENGTH ],
                            szAddr2[ ADDR_LENGTH ];

    HANDLE                  hIfTransport   = (HANDLE) NULL,
                            hTransport     = (HANDLE) NULL;

    PRTR_INFO_BLOCK_HEADER  pibhIfInfo     = (PRTR_INFO_BLOCK_HEADER) NULL,
                            pibhGlobalInfo = (PRTR_INFO_BLOCK_HEADER) NULL;

    PMIB_BOUNDARYROW        pimb;

    PSCOPE_ENTRY            pScope,
                            pScopes;

    PBYTE                   pScopesBuffer;

    SCOPE_NAME_BUFFER       snScopeNameBuffer;

    do
    {
        dwErr = IpmontrGetInfoBlockFromInterfaceInfo( pwszIfName,
                                               IP_MCAST_BOUNDARY_INFO,
                                               (PBYTE*)&pimb,
                                               &dwBlkSize,
                                               &dwCount,
                                               &dwIfType );

        if (dwErr is ERROR_NOT_FOUND)
            dwErr = NO_ERROR;

        if (dwErr isnot NO_ERROR)
            return dwErr;

        if ( !dwCount )
            break;

        dwErr = GetInterfaceDescription(pwszIfName,
                                        wszIfDesc,
                                        &dwNumParsed);

        if (!dwNumParsed)
        {
            wcscpy(wszIfDesc, pwszIfName);
        }

        dwIfLen = wcslen(wszIfDesc);

        //
        // Retrieve the list of scopes in pScopes[]
        //

        pScopes = GetScopes( &ulNumScopes, &pScopesBuffer );

        //
        // Enumerate the boundaries
        //

        for ( dwCnt = 0; dwCnt < dwCount; dwCnt++ )
        {
            pScope = FindScopeByPrefix( pimb[dwCnt].dwGroupAddress,
                                        pimb[dwCnt].dwGroupMask,
                                        pScopes,
                                        ulNumScopes );

            strcpy( szAddr1,
                    inet_ntoa( *((struct in_addr *) &pimb[dwCnt].dwGroupAddress)
)
                  );

            strcpy( szAddr2,
                    inet_ntoa( *((struct in_addr *) &pimb[dwCnt].dwGroupMask) )
                  );

            // Copy prefix to snScopeNameBuffer

            MakePrefixStringW(snScopeNameBuffer,
                              pimb[dwCnt].dwGroupAddress,
                              pimb[dwCnt].dwGroupMask);

            if (hFile)
            {
                PWCHAR pwszQuoted = MakeQuotedString(wszIfDesc);

                DisplayMessageT( DMP_BOUNDARY_INFO,
                    pwszQuoted,
                    szAddr1,
                    szAddr2,
                    (pScope && pScope->ulNumNames)? 
                       pScope->snScopeNameBuffer : snScopeNameBuffer );

                FreeQuotedString(pwszQuoted);
            }
            else
            {
                if ( !*pdwNumRows )
                {
                    DisplayMessage( g_hModule, MSG_RTR_BOUNDARY_HDR );
                }

                if (dwIfLen <= 15) 
                {
                    DisplayMessage( g_hModule,
                        MSG_RTR_BOUNDARY_INFO_2,
                        wszIfDesc,
                        szAddr1,
                        szAddr2,
                        (pScope && pScope->ulNumNames)? 
                           pScope->snScopeNameBuffer : snScopeNameBuffer );
                }
                else
                {
                    DisplayMessage( g_hModule,
                        MSG_RTR_BOUNDARY_INFO_0,
                        wszIfDesc
                    );
                    DisplayMessage( g_hModule,
                        MSG_RTR_BOUNDARY_INFO_1,
                        szAddr1,
                        szAddr2,
                        (pScope && pScope->ulNumNames)? 
                            pScope->snScopeNameBuffer : snScopeNameBuffer );
                }
            }

            (*pdwNumRows) ++;
        }

        dwErr = NO_ERROR;

        if (pScopes)
            FREE(pScopes);

        if (pScopesBuffer)
            FREE(pScopesBuffer);

    } while ( FALSE );

    if ( pimb ) { FREE(pimb); }

    return dwErr;
}

DWORD
HandleIpShowBoundary(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )


/*++

Routine Description:

Arguments:

    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg

Return Value:

    NO_ERROR

--*/
{
    DWORD        dwErr, dwTotal;
    TAG_TYPE     pttTags[] = {{TOKEN_NAME,FALSE,FALSE}};
    WCHAR        rgwcIfName[MAX_INTERFACE_NAME_LEN + 1];
    DWORD        rgdwTagType[sizeof(pttTags)/sizeof(TAG_TYPE)];
    DWORD        dwBlkSize, dwCount, dwIfType, i, dwNumParsed;
    PBYTE        pib, pibNew = NULL;
    PMPR_INTERFACE_0     pmi0;
    DWORD        dwNumRows = 0;

    // Do generic processing

    dwErr = PreHandleCommand( ppwcArguments,
                              dwCurrentIndex,
                              dwArgCount,
                              pttTags,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              0,
                              1,
                              rgdwTagType );

    if (dwErr) 
    {
        return dwErr;
    }

    // If interface specified, show boundaries for specified interface only.

    if (dwArgCount > dwCurrentIndex)
    {
        DWORD BufLen = sizeof(rgwcIfName);

        GetInterfaceName( ppwcArguments[dwCurrentIndex],
                          rgwcIfName,
                          BufLen,
                          &dwNumParsed );

        dwErr = ShowBoundaryInfoForInterface( 0, rgwcIfName, &dwNumRows );

        if (!dwNumRows)
        {
            DisplayMessage( g_hModule, MSG_IP_NO_ENTRIES );
        }

        return dwErr;
    }

    // No Interface specified.  Enumerate interfaces and show
    // boundaries for each interface.

    //
    // No interface name specified. List all interfaces under IP
    //

    dwErr = IpmontrInterfaceEnum((PBYTE *) &pmi0, &dwCount, &dwTotal);

    if (dwErr isnot NO_ERROR)
    {
        DisplayError(g_hModule, dwErr);

        return dwErr;
    }

    for ( i = 0; i < dwCount && dwErr is NO_ERROR; i++)
    {
        dwErr = ShowBoundaryInfoForInterface( 0, 
                                              pmi0[i].wszInterfaceName, 
                                              &dwNumRows );

        if (dwErr is ERROR_NO_SUCH_INTERFACE)
        {
            dwErr = NO_ERROR;
        }
    }

    if (!dwNumRows)
    {
        DisplayMessage( g_hModule, MSG_IP_NO_ENTRIES );
    }

    return dwErr;
}

//----------------------------------------------------------------------------
// PrintScope   
//
//
//----------------------------------------------------------------------------

static VOID
PrintScope(
    PMIB_OPAQUE_INFO            prpcInfo,
    PDWORD                      pdwLastAddr,
    PDWORD                      pdwLastMask
)
{
    TCHAR                       ptszAddr[ ADDR_LENGTH + 1 ],
                                ptszMask[ ADDR_LENGTH + 1 ],
                                ptszBuffer[ MAX_SCOPE_NAME_LEN + 40 ];
                    
    PMIB_IPMCAST_SCOPE          pmims;

    //
    // get scope
    //
    
    pmims = (PMIB_IPMCAST_SCOPE) prpcInfo->rgbyData;
    
    *pdwLastAddr = pmims-> dwGroupAddress;
    
    MakeUnicodeIpAddr(ptszAddr,
        inet_ntoa(*((struct in_addr *)(&pmims-> dwGroupAddress))));

    *pdwLastMask = pmims-> dwGroupMask;
    
    MakeUnicodeIpAddr(ptszMask,
                      inet_ntoa(*((struct in_addr *)(&pmims-> dwGroupMask))));

    _stprintf(ptszBuffer, _T("%-15.15s  %-15.15s  %s"), 
        ptszAddr, 
        ptszMask,
        pmims-> snNameBuffer
        );

    DisplayMessage( g_hModule,
        MSG_MIB_SCOPE_INFO,
        ptszBuffer
        );
        
    return;
}

//----------------------------------------------------------------------------
// PrintBoundary
//
//
//----------------------------------------------------------------------------

static VOID
PrintBoundary(
    MIB_SERVER_HANDLE           hMibServer,
    PMIB_OPAQUE_INFO            prpcInfo,
    PDWORD                      pdwLastIfIndex,
    PDWORD                      pdwLastAddr,
    PDWORD                      pdwLastMask
)
{
    WCHAR   wszBuffer[MAX_INTERFACE_NAME_LEN+1];
    DWORD   BufLen = sizeof(wszBuffer);
    TCHAR                       ptszAddr[ ADDR_LENGTH + 1 ],
                                ptszMask[ ADDR_LENGTH + 1 ];
                    
    PMIB_IPMCAST_BOUNDARY       pmims;

    //
    // get boundary
    //
    
    pmims = (PMIB_IPMCAST_BOUNDARY) prpcInfo->rgbyData;
    
    *pdwLastIfIndex = pmims-> dwIfIndex;
     
    *pdwLastAddr = pmims-> dwGroupAddress;
    
    MakeUnicodeIpAddr(ptszAddr,
        inet_ntoa(*((struct in_addr *)(&pmims-> dwGroupAddress))));

    *pdwLastMask = pmims-> dwGroupMask;
    
    MakeUnicodeIpAddr(ptszMask,
                      inet_ntoa(*((struct in_addr *)(&pmims-> dwGroupMask))));

    IpmontrGetFriendlyNameFromIfIndex( hMibServer,
                                pmims->dwIfIndex,
                                wszBuffer,
                                BufLen );


    DisplayMessageToConsole( g_hModule, g_hConsole,
        MSG_MIB_BOUNDARY_INFO,
        ptszAddr, 
        ptszMask,
        wszBuffer
        );
        
    return;
}

#if 0
//----------------------------------------------------------------------------
// GetPrintScopeInfo
//
//----------------------------------------------------------------------------

DWORD
GetPrintScopeInfo(
    MIB_SERVER_HANDLE hMIBServer
    )
{
    DWORD                       dwErr, dwOutEntrySize = 0, dwQuerySize,
                                dwLastAddr = 0, 
                                dwLastMask = 0, i;
    
    PMIB_OPAQUE_INFO            pRpcInfo = NULL;

    PMIB_IPMCAST_SCOPE          pmims = NULL;

    PMIB_OPAQUE_QUERY           pQuery;
    
    do
    {
        //
        // allocate and setup query structure
        //
        
        dwQuerySize = sizeof( MIB_OPAQUE_QUERY ) + sizeof(DWORD);
        
        pQuery = (PMIB_OPAQUE_QUERY) HeapAlloc(
                                        GetProcessHeap(), 0, dwQuerySize
                                        );
        
        if ( pQuery == NULL )
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;

            DisplayMessage( g_hModule, ERROR_CONFIG, dwErr );

            break;
        }

        
        pQuery->dwVarId = MCAST_SCOPE;
        
        for( i = 0; i < 2; i++ )
        {
            pQuery->rgdwVarIndex[i] = 0;
        }

        
        //
        // get first scope
        //

        dwErr = MibGetFirst(
                    PID_IP,
                    IPRTRMGR_PID,
                    (PVOID) pQuery,
                    dwQuerySize,
                    (PVOID *) &pRpcInfo,
                    &dwOutEntrySize
                    );

        if ( dwErr != NO_ERROR )
        {
            DisplayError( g_hModule, dwErr );
            break;
        }

        
        //
        // if no scopes are present print a message to tell the user
        //

        pmims = (PMIB_IPMCAST_SCOPE)( pRpcInfo->rgbyData );

#if 0
        if ( pTable->dwNumEntries is 0 )
        {
            //
            // no scopes present.
            //

            DisplayMessage( g_hModule, MSG_MIB_NO_SCOPES );

            break;
        }
#endif


        //
        // print the scope
        //

        DisplayMessage( g_hModule, MSG_MIB_SCOPE_HDR );

        PrintScope( pRpcInfo, &dwLastAddr, &dwLastMask );

        MprAdminMIBBufferFree( pRpcInfo );

        pRpcInfo = NULL;

        dwOutEntrySize = 0;


        //
        // while there are more scopes
        //  get next scope
        //  print it.
        //

        pQuery->rgdwVarIndex[ 0 ] = dwLastAddr;
        pQuery->rgdwVarIndex[ 1 ] = dwLastMask;

        while ( ( dwErr = MibGetNext(
                            PID_IP, IPRTRMGR_PID, (PVOID) pQuery,
                            dwQuerySize, (PVOID *) &pRpcInfo, &dwOutEntrySize
                            ) ) == NO_ERROR )
        {
            //
            // if no scopes are present quit
            //

            pmims = (PMIB_IPMCAST_SCOPE)( pRpcInfo->rgbyData );
#if 0
            pTable = (PMIB_IPMCAST_SCOPE)( pRpcInfo->rgbyData );

            if ( pTable->dwNumEntries is 0 )
            {
                break;
            }
#endif


            //
            // print the scope
            //

            PrintScope( pRpcInfo, &dwLastAddr, &dwLastMask );

            MprAdminMIBBufferFree( pRpcInfo );

            pRpcInfo = NULL;

            dwOutEntrySize = 0;


            //
            // set up the next query
            //
            
            pQuery->rgdwVarIndex[ 0 ] = dwLastAddr;
            pQuery->rgdwVarIndex[ 1 ] = dwLastMask;
        }

        if ( dwErr != NO_ERROR )
        {
            DisplayMessage( g_hModule, ERROR_ADMIN, dwErr );
        }
        
    } while ( FALSE );

    return dwErr;
}
#endif

//----------------------------------------------------------------------------
// GetPrintBoundaryInfo
//
//----------------------------------------------------------------------------

DWORD
GetPrintBoundaryInfo(
    MIB_SERVER_HANDLE hMIBServer
    )
{
    DWORD                       dwErr, dwOutEntrySize = 0, dwQuerySize,
                                dwLastIfIndex = 0, dwLastAddr = 0, 
                                dwLastMask = 0, i;
    
    PMIB_OPAQUE_INFO            pRpcInfo = NULL;

    PMIB_IPMCAST_BOUNDARY       pmims = NULL;

    PMIB_OPAQUE_QUERY           pQuery;
    
    do
    {
        //
        // allocate and setup query structure
        //
        
        dwQuerySize = sizeof( MIB_OPAQUE_QUERY ) + 2 * sizeof(DWORD);
        
        pQuery = (PMIB_OPAQUE_QUERY) HeapAlloc(
                                        GetProcessHeap(), 0, dwQuerySize
                                        );
        
        if ( pQuery == NULL )
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;

            DisplayMessage( g_hModule, ERROR_CONFIG, dwErr );

            break;
        }

        
        pQuery->dwVarId = MCAST_BOUNDARY;
        
        for( i = 0; i < 2; i++ )
        {
            pQuery->rgdwVarIndex[i] = 0;
        }

        
        //
        // get first boundary
        //

        dwErr = MibGetFirst(
                    PID_IP,
                    IPRTRMGR_PID,
                    (PVOID) pQuery,
                    dwQuerySize,
                    (PVOID *) &pRpcInfo,
                    &dwOutEntrySize
                    );

        if ( dwErr != NO_ERROR )
        {
            DisplayError( g_hModule, dwErr );
            break;
        }

        
        //
        // if no boundaries are present print a message to tell the user
        //

        pmims = (PMIB_IPMCAST_BOUNDARY)( pRpcInfo->rgbyData );

#if 0
        if ( pTable->dwNumEntries is 0 )
        {
            //
            // no boundaries present.
            //

            DisplayMessage( g_hModule, MSG_MIB_NO_BOUNDARIES );

            break;
        }
#endif


        //
        // print the boundary
        //

        DisplayMessageToConsole( g_hModule, g_hConsole, MSG_MIB_BOUNDARY_HDR );

        PrintBoundary( hMIBServer,
                       pRpcInfo, &dwLastIfIndex, &dwLastAddr, &dwLastMask );

        MprAdminMIBBufferFree( pRpcInfo );

        pRpcInfo = NULL;

        dwOutEntrySize = 0;


        //
        // while there are more boundaries
        //  get next boundary
        //  print it.
        //

        pQuery->rgdwVarIndex[ 0 ] = dwLastIfIndex;
        pQuery->rgdwVarIndex[ 1 ] = dwLastAddr;
        pQuery->rgdwVarIndex[ 2 ] = dwLastMask;

        while ( ( dwErr = MibGetNext(
                            PID_IP, IPRTRMGR_PID, (PVOID) pQuery,
                            dwQuerySize, (PVOID *) &pRpcInfo, &dwOutEntrySize
                            ) ) == NO_ERROR )
        {
            //
            // if no boundaries are present quit
            //

            pmims = (PMIB_IPMCAST_BOUNDARY)( pRpcInfo->rgbyData );
#if 0
            pTable = (PMIB_IPMCAST_BOUNDARY)( pRpcInfo->rgbyData );

            if ( pTable->dwNumEntries is 0 )
            {
                break;
            }
#endif


            //
            // print the boundary
            //

            PrintBoundary( 
                hMIBServer,
                pRpcInfo, &dwLastIfIndex, &dwLastAddr, &dwLastMask 
                );

            MprAdminMIBBufferFree( pRpcInfo );

            pRpcInfo = NULL;

            dwOutEntrySize = 0;


            //
            // set up the next query
            //
            
            pQuery->rgdwVarIndex[ 0 ] = dwLastIfIndex;
            pQuery->rgdwVarIndex[ 1 ] = dwLastAddr;
            pQuery->rgdwVarIndex[ 2 ] = dwLastMask;
        }

        if ( dwErr != NO_ERROR )
        {
            DisplayMessage( g_hModule, ERROR_ADMIN, dwErr );
        }
        
    } while ( FALSE );

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ip\ipmon\ipmon.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:
     net\routing\monitor\ip\showmib.h   

Abstract:

     Prototype for fns called in ipmon.c

Author:

     Anand Mahalingam    7/10/98

--*/

#define MALLOC(x)    HeapAlloc( GetProcessHeap(), 0, x )
#define REALLOC(x,y) HeapReAlloc( GetProcessHeap(), 0, x, y )
#define FREE(x)      HeapFree( GetProcessHeap(), 0, x )

extern HANDLE g_hModule;
extern HANDLE g_hMprConfig; 
extern HANDLE g_hMprAdmin;
extern HANDLE g_hMIBServer;
extern BOOL   g_bCommit;
extern PWCHAR g_pwszRouter;
extern const GUID g_IpGuid;

DWORD
ShowMIB(
    MIB_SERVER_HANDLE    hMIBServer,
    PTCHAR                *pptcArguments,
    DWORD                dwArgCount
    );

DWORD
GetHelperAttributes(
    IN  LPCWSTR                pwszRouter,
    IN  DWORD                  dwIndex,
    OUT PIP_CONTEXT_ENTRY_FN    *ppfnEntryFn,
    OUT PNS_CONTEXT_DUMP_FN     *ppfnDumpFn
    );

enum IpMonCommands
{
    ADD_COMMAND = 0,
    SET_COMMAND,
    DELETE_COMMAND
};

NS_DLL_STOP_FN StopHelperDll;

//
// Misc Macros
//

#define CHECK_ROUTER_RUNNING()                                \
    if  (!IsRouterRunning())                                  \
    {                                                         \
        if (g_pwszRouter)                                     \
        {                                                     \
            DisplayMessage(g_hModule,                         \
                           MSG_IP_REMOTE_ROUTER_NOT_RUNNING,  \
                           g_pwszRouter);                     \
        }                                                     \
        else                                                  \
        {                                                     \
            DisplayMessage(g_hModule,                         \
                           MSG_IP_LOCAL_ROUTER_NOT_RUNNING);  \
        }                                                     \
                                                              \
        return ERROR_SUPPRESS_OUTPUT;                         \
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ip\ipmon\iphandle.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:
     net\routing\monitor\ip\ipgetopt.c

Abstract:

     Prototype for the IP get opt functions.

Author:

     Anand Mahalingam    7/10/98
     Dave Thaler        10/26/98

--*/

NS_CONTEXT_DUMP_FN      IpDump;
NS_CONTEXT_SUBENTRY_FN  IpSubEntry;

FN_HANDLE_CMD HandleIpUpdate;
FN_HANDLE_CMD HandleIpReset;
FN_HANDLE_CMD HandleIpUninstall;
FN_HANDLE_CMD HandleIpInstall;

FN_HANDLE_CMD HandleIpAddIfFilter;
FN_HANDLE_CMD HandleIpDelIfFilter;

FN_HANDLE_CMD HandleIpAddRtmRoute;
FN_HANDLE_CMD HandleIpSetRtmRoute;
FN_HANDLE_CMD HandleIpDelRtmRoute;

FN_HANDLE_CMD HandleIpAddPersistentRoute;
FN_HANDLE_CMD HandleIpSetPersistentRoute;
FN_HANDLE_CMD HandleIpDelPersistentRoute;
FN_HANDLE_CMD HandleIpShowPersistentRoute;

FN_HANDLE_CMD HandleIpAddRoutePref;
FN_HANDLE_CMD HandleIpSetRoutePref;
FN_HANDLE_CMD HandleIpDelRoutePref;
FN_HANDLE_CMD HandleIpShowRoutePref;

FN_HANDLE_CMD HandleIpAddInterface;
FN_HANDLE_CMD HandleIpSetInterface;
FN_HANDLE_CMD HandleIpDelInterface;
FN_HANDLE_CMD HandleIpShowInterface;

FN_HANDLE_CMD HandleIpSetIfFilter;
FN_HANDLE_CMD HandleIpShowIfFilter;

FN_HANDLE_CMD HandleIpSetLogLevel;
FN_HANDLE_CMD HandleIpShowLogLevel;

FN_HANDLE_CMD HandleIpShowProtocol;

#ifdef KSL_IPINIP
FN_HANDLE_CMD HandleIpAddIpIpTunnel;
FN_HANDLE_CMD HandleIpSetIpIpTunnel;
#endif //KSL_IPINIP

FN_HANDLE_CMD HandleIpShowRtmDestinations;
FN_HANDLE_CMD HandleIpShowRtmRoutes;


#ifdef KSL_IPINIP
DWORD
IpAddSetIpIpTunnel(
    PWCHAR    *ppwcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    BOOL      bAdd
    );
#endif //KSL_IPINIP


DWORD
PreHandleCommand(
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,

    IN      TAG_TYPE *pttTags,
    IN      DWORD     dwTagCount,
    IN      DWORD     dwMinArgs,
    IN      DWORD     dwMaxArgs,
    OUT     DWORD    *pdwTagType
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ip\ipmon\ipstring.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:
     net\routing\monitor2\ip\ipstring.h

Abstract:

    Definitions of command line tokens are not localized.

Author:

     Dave Thaler
     
Revision History:

    V Raman                 1/19/99
--*/



#define MSG_NEWLINE                             L"\n"
#define MSG_STRING                              L"%1!s!"
#define MSG_HELP_START                          L"%1!-14s! - "

#define TOKEN_MIB_OBJECT_MFE                    L"mfe"
#define TOKEN_MIB_OBJECT_MFESTATS               L"mfestats"
#define TOKEN_MIB_OBJECT_BOUNDARY               L"boundarystats"
#define TOKEN_MIB_OBJECT_SCOPE                  L"scope"
#define TOKEN_MIB_OBJECT_JOINS                  L"joins"
#define TOKEN_MIB_OBJECT_RTMDESTINATIONS        L"rtmdestinations"
#define TOKEN_MIB_OBJECT_RTMROUTES              L"rtmroutes"

#define CMD_IPMIB_SHOW_INTERFACE                L"interface"
#define CMD_IPMIB_SHOW_IPSTATS                  L"ipstats"
#define CMD_IPMIB_SHOW_IPADDRESS                L"ipaddress"
#define CMD_IPMIB_SHOW_IPFORWARD                L"ipforward"
#define CMD_IPMIB_SHOW_IPNET                    L"ipnet"
#define CMD_IPMIB_SHOW_TCPSTATS                 L"tcpstats"
#define CMD_IPMIB_SHOW_TCPCONN                  L"tcpconn"
#define CMD_IPMIB_SHOW_UDPSTATS                 L"udpstats"
#define CMD_IPMIB_SHOW_UDPCONN                  L"udpconn"
#define CMD_IPMIB_SHOW_MFE                      L"mfe"
#define CMD_IPMIB_SHOW_MFESTATS                 L"mfestats"
#define CMD_IPMIB_SHOW_JOINS                    L"joins"
#define CMD_IPMIB_SHOW_RTMDEST                  L"rtmdestinations"
#define CMD_IPMIB_SHOW_RTMROUTE                 L"rtmroutes"
#define CMD_IPMIB_SHOW_BOUNDARY                 L"boundarystats"
#define CMD_IPMIB_SHOW_SCOPE                    L"scope"

//
// TOKEN_Xxx are tokens for arguments
// These must be in lower case
//

#define TOKEN_NAME                              L"name"
#define TOKEN_STATUS                            L"state"
#define TOKEN_LOCALADDR                         L"localaddr"
#define TOKEN_REMADDR                           L"remaddr"
#define TOKEN_TTL                                L"ttl"

#define TOKEN_FILTER_TYPE                        L"filtertype"
#define TOKEN_SOURCE_ADDRESS                    L"srcaddr"
#define TOKEN_SOURCE_MASK                       L"srcmask"
#define TOKEN_DEST_ADDRESS                      L"dstaddr"
#define TOKEN_DEST_MASK                         L"dstmask"
#define TOKEN_ACTION                            L"action"
#define TOKEN_CODE                              L"code"
#define TOKEN_SOURCE_PORT                       L"srcport"
#define TOKEN_DEST_PORT                         L"dstport"
#define TOKEN_FILTER                            L"filtering"
#define TOKEN_FRAGCHECK                         L"fragcheck"
#define TOKEN_OPERATOR                          L"operator"
#define TOKEN_VIEW                              L"view"

#define TOKEN_DEST                              L"dest"
#define TOKEN_MASK                              L"mask"
#define TOKEN_NAMEINDEX                         L"nameorindex"
#define TOKEN_NHOP                              L"nhop"
#define TOKEN_METRIC                            L"metric"
#define TOKEN_PREFERENCE                        L"preference"
#define TOKEN_PROTOCOL                          L"proto"
#define TOKEN_TYPE                               L"type"
#define TOKEN_PREF_LEVEL                        L"preflevel"
#define TOKEN_REFRESH                           L"rr"
#define TOKEN_STATS                             L"stats"

// Multicast scope options
#define TOKEN_GROUP_ADDRESS                     L"grpaddr"
#define TOKEN_GROUP_MASK                        L"grpmask"
#define TOKEN_SCOPE_NAME                        L"scopename"

#define TOKEN_LOG_LEVEL                         L"loglevel"

#define TOKEN_DEFAULT                           L"default"

//
// TOKEN_VALUE_Xxx are tokens for possible values than an argument
// can take
// These must be in upper case
//

#define TOKEN_VALUE_RIP                         L"RIP"
#define TOKEN_VALUE_OSPF                        L"OSPF"

#define TOKEN_VALUE_TCP                         L"TCP"
#define TOKEN_VALUE_TCP_ESTAB                   L"TCP-EST"
#define TOKEN_VALUE_UDP                         L"UDP"
#define TOKEN_VALUE_ICMP                        L"ICMP"
#define TOKEN_VALUE_NETMGMT                     L"NetMgmt"
#define TOKEN_VALUE_LOCAL                       L"LOCAL"
#define TOKEN_VALUE_STATIC                      L"STATIC"
#define TOKEN_VALUE_AUTOSTATIC                  L"AUTOSTATIC"
#define TOKEN_VALUE_NONDOD                      L"NONDOD"
#define TOKEN_VALUE_ANY                         L"ANY"


#define TOKEN_VALUE_ERROR                       L"error"
#define TOKEN_VALUE_WARN                        L"warn"
#define TOKEN_VALUE_INFO                        L"info"

#define TOKEN_VALUE_INPUT                       L"input"
#define TOKEN_VALUE_OUTPUT                      L"output"
#define TOKEN_VALUE_DIAL                        L"dial"

#define TOKEN_VALUE_ENABLE                      L"enable"
#define TOKEN_VALUE_DISABLE                     L"disable"

#define TOKEN_VALUE_YES                         L"yes"
#define TOKEN_VALUE_NO                          L"no"

#define TOKEN_VALUE_NONE                        L"none"

#define TOKEN_VALUE_DROP                        L"drop"
#define TOKEN_VALUE_FORWARD                     L"forward"

#define TOKEN_VALUE_POSITIVE                    L"active"
#define TOKEN_VALUE_NEGATIVE                    L"negative"
#define TOKEN_VALUE_BOTH                        L"both"

#define TOKEN_VALUE_ALL                         L"all"

#define TOKEN_VALUE_UNICAST                     L"unicast"
#define TOKEN_VALUE_MULTICAST                   L"multicast"

#define TOKEN_VALUE_MATCHING                    L"matching"
#define TOKEN_VALUE_SHORTER                     L"shorterthan"
#define TOKEN_VALUE_LONGER                      L"longerthan"

#define TOKEN_MICROSOFT0                        L"MS-0000"
#define TOKEN_MICROSOFT1                        L"Microsoft"
#define TOKEN_MICROSOFT2                        L"-"

//
// Tokens for commands
// These must be in lower case
//

#define CMD_GROUP_ADD                           L"add"
#define CMD_GROUP_DELETE                        L"delete"
#define CMD_GROUP_SET                           L"set"
#define CMD_GROUP_SHOW                          L"show"

#define CMD_IP_LIST                             L"list"
#define CMD_IP_HELP1                                L"?"
#define CMD_IP_HELP2                                L"help"
#define CMD_IP_INSTALL                          L"install"
#define CMD_IP_UNINSTALL                        L"uninstall"
#define CMD_IP_RESET                            L"reset"
#define CMD_IP_DUMP                             L"dump"
#define CMD_IP_UPDATE                           L"update"
#define CMD_IP_MIB                              L"mib"

#define CMD_IP_ADD_PROTOPREF                    L"preferenceforprotocol"
#define CMD_IP_ADD_INTERFACE                    L"interface"
#define CMD_IP_ADD_IF_FILTER                    L"filter"
#define CMD_IP_ADD_RTMROUTE                     L"rtmroute"
#define CMD_IP_ADD_PERSISTENTROUTE              L"persistentroute"
#define CMD_IP_ADD_IPIPTUNNEL                   L"ipiptunnel"
#define CMD_IP_ADD_SCOPE                        L"scope"
#define CMD_IP_ADD_BOUNDARY                     L"boundary"
#define CMD_IP_ADD_HELPER                       L"helper"

#define CMD_IP_DEL_PROTOPREF                    L"preferenceforprotocol"
#define CMD_IP_DEL_INTERFACE                    L"interface"
#define CMD_IP_DEL_IF_FILTER                    L"filter"
#define CMD_IP_DEL_RTMROUTE                     L"rtmroute"
#define CMD_IP_DEL_PERSISTENTROUTE              L"persistentroute"
#define CMD_IP_DEL_SCOPE                        L"scope"
#define CMD_IP_DEL_BOUNDARY                     L"boundary"
#define CMD_IP_DEL_HELPER                       L"helper"

#define CMD_IP_SET_PROTOPREF                    L"preferenceforprotocol"
#define CMD_IP_SET_INTERFACE                    L"interface"
#define CMD_IP_SET_IF_FILTER                    L"filter"
#define CMD_IP_SET_LOGLEVEL                     L"loglevel"
#define CMD_IP_SET_IPIPTUNNEL                   L"ipiptunnel"
#define CMD_IP_SET_RTMROUTE                     L"rtmroute"
#define CMD_IP_SET_PERSISTENTROUTE              L"persistentroute"
#define CMD_IP_SET_SCOPE                        L"scope"

#define CMD_IP_SHOW_PROTOPREF                   L"preferenceforprotocol"
#define CMD_IP_SHOW_PROTOCOL                    L"protocol"
#define CMD_IP_SHOW_INTERFACE                   L"interface"
#define CMD_IP_SHOW_IF_FILTER                   L"filter"
#define CMD_IP_SHOW_PERSISTENTROUTE             L"persistentroutes"
#define CMD_IP_SHOW_LOGLEVEL                    L"loglevel"
#define CMD_IP_SHOW_SCOPE                       L"scope"
#define CMD_IP_SHOW_BOUNDARY                    L"boundary"
#define CMD_IP_SHOW_HELPER                      L"helper"

#define MSG_IP_MIB_CMD                          L"%1!s! %2!s!\n"

#define DMP_IP_ADD_IF                           L"\
\nadd interface name=%1!s! state=%2!s!"

#define DMP_IP_ADD_IF_FILTER                    L"\
\nadd filter name=%1!s! filtertype=%2!s! srcaddr=%3!s! srcmask=%4!s! \
    dstaddr=%5!s! dstmask=%6!s! proto=%7!s! "

#define DMP_IP_ADD_IF_FILTER_PORT               L"\
srcport=%1!d! dstport=%2!d!"

#define DMP_IP_ADD_IF_FILTER_TC                 L"\
type=%1!d! code=%2!d!"

#define DMP_IP_ADDSET_PERSISTENTROUTE           L"\
\nadd persistentroute dest=%1!s! mask=%2!s! name=%3!s! nhop=%4!s! proto=%5!s! \
    preference=%6!d! metric=%7!d! view=%8!s!\
\nset persistentroute dest=%1!s! mask=%2!s! name=%3!s! nhop=%4!s! proto=%5!s! \
    preference=%6!d! metric=%7!d! view=%8!s!"

#define DMP_IP_ADDSET_P2P_PERSISTENTROUTE           L"\
\nadd persistentroute dest=%1!s! mask=%2!s! name=%3!s! proto=%4!s! \
    preference=%5!d! metric=%6!d! view=%7!s!\
\nset persistentroute dest=%1!s! mask=%2!s! name=%3!s! proto=%4!s! \
    preference=%5!d! metric=%6!d! view=%7!s!"

#define DMP_IP_SET_PROTOPREF                    L"\
\nadd preferenceforprotocol proto=%1!s! preflevel=%2!d!"

#define DMP_IP_SET_LOGLEVEL                     L"\
\nset loglevel %1!s!"

#define DMP_IP_SET_IF                           L"\
\nset interface name=%1!s! state=%2!s! disc=%3!s! minint=%4!d!\
 maxint=%5!d! life=%6!d! level=%7!d!"

#define DMP_IP_SET_RTR_DISC_INFO                L"\
\nset interface name=%1!s! disc=%2!s! minint=%3!d!\
 maxint=%4!d! life=%5!d! level=%6!d!"

#define DMP_IP_SET_IF_FILTER_FRAG               L"\
\nset filter name=%1!s! fragcheck=%2!s!"

#define DMP_IP_SET_IF_FILTER                    L"\
\nset filter name=%1!s! filtertype=%2!s! action=%3!s!"

#define DMP_IP_ADD_IPIPTUNNEL                   L"\
\nadd ipiptunnel name=%1!s! localaddr=%2!s! remaddr=%3!s! ttl=%4!d!"

#define DMP_ROUTING_HEADER                      L"pushd routing\nreset"

#define DMP_IP_HEADER                           L"pushd routing ip\nreset"

#define DMP_POPD                                L"\npopd\n"

#define DMP_SCOPE_INFO                          L"\
\nadd scope grpaddr=%1!hs! grpmask=%2!hs! scopename=%3!s!"

#define DMP_BOUNDARY_INFO                       L"\
\nadd boundary name=%1!s! grpaddr=%2!hs! grpmask=%3!hs!"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ip\ipmon\ipmon.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    routing\netsh\ip\ipmon\ipmon.c

Abstract:

    IP Command dispatcher.

Revision History:

    Anand Mahalingam         7/10/98  Created

--*/

#include "precomp.h"

const GUID g_IpGuid      = IPMONTR_GUID;

#define IP_HELPER_VERSION 1

DWORD             g_dwNumTableEntries = 0; // 6;

//
// The table of Add, Delete, Set and Show Commands for IP RTR MGR
// To add a command to one of the command groups, just add the
// CMD_ENTRY to the correct table. To add a new cmd group, create its
// cmd table and then add the group entry to group table
//

//
// The commands are prefix-matched with the command-line, in sequential
// order. So a command like 'ADD INTERFACE FILTER' must come before
// the command 'ADD INTERFACE' in the table.  Likewise,
// a command like 'ADD ROUTE' must come before the command 
// 'ADD ROUTEXXXX' in the table.
//

CMD_ENTRY  g_IpAddCmdTable[] = {
    CREATE_CMD_ENTRY(IP_ADD_BOUNDARY,   HandleIpAddBoundary),
    CREATE_CMD_ENTRY(IP_ADD_IF_FILTER,  HandleIpAddIfFilter),
    CREATE_CMD_ENTRY(IP_ADD_INTERFACE,  HandleIpAddInterface),
#ifdef KSL_IPINIP
    //CREATE_CMD_ENTRY(IP_ADD_IPIPTUNNEL, HandleIpAddIpIpTunnel),
#endif //KSL_IPINIP
    CREATE_CMD_ENTRY(IP_ADD_PROTOPREF,  HandleIpAddRoutePref),
    CREATE_CMD_ENTRY(IP_ADD_SCOPE,      HandleIpAddScope),
    CREATE_CMD_ENTRY(IP_ADD_RTMROUTE,   HandleIpAddRtmRoute),
    CREATE_CMD_ENTRY(IP_ADD_PERSISTENTROUTE,HandleIpAddPersistentRoute),
};

CMD_ENTRY  g_IpDelCmdTable[] = {
    CREATE_CMD_ENTRY(IP_DEL_BOUNDARY,   HandleIpDelBoundary),
    CREATE_CMD_ENTRY(IP_DEL_IF_FILTER,  HandleIpDelIfFilter),
    CREATE_CMD_ENTRY(IP_DEL_INTERFACE,  HandleIpDelInterface),
    CREATE_CMD_ENTRY(IP_DEL_PROTOPREF,  HandleIpDelRoutePref),
    CREATE_CMD_ENTRY(IP_DEL_SCOPE,      HandleIpDelScope),
    CREATE_CMD_ENTRY(IP_DEL_RTMROUTE,   HandleIpDelRtmRoute),
    CREATE_CMD_ENTRY(IP_DEL_PERSISTENTROUTE,HandleIpDelPersistentRoute),
};

CMD_ENTRY g_IpSetCmdTable[] = {
    CREATE_CMD_ENTRY(IP_SET_IF_FILTER,  HandleIpSetIfFilter),
    CREATE_CMD_ENTRY(IP_SET_INTERFACE,  HandleIpSetInterface),
#ifdef KSL_IPINIP
    //CREATE_CMD_ENTRY(IP_SET_IPIPTUNNEL, HandleIpSetIpIpTunnel),
#endif //KSL_IPINIP
    CREATE_CMD_ENTRY(IP_SET_LOGLEVEL,   HandleIpSetLogLevel),
    CREATE_CMD_ENTRY(IP_SET_PROTOPREF,  HandleIpSetRoutePref),
    CREATE_CMD_ENTRY(IP_SET_SCOPE,      HandleIpSetScope),
    CREATE_CMD_ENTRY(IP_SET_RTMROUTE,   HandleIpSetRtmRoute),
    CREATE_CMD_ENTRY(IP_SET_PERSISTENTROUTE,HandleIpSetPersistentRoute)
};

CMD_ENTRY g_IpShowCmdTable[] = {
    CREATE_CMD_ENTRY(IP_SHOW_BOUNDARY,     HandleIpShowBoundary),
    CREATE_CMD_ENTRY(IPMIB_SHOW_BOUNDARY,  HandleIpMibShowObject),
    CREATE_CMD_ENTRY(IPMIB_SHOW_RTMDEST,   HandleIpShowRtmDestinations),
    CREATE_CMD_ENTRY(IP_SHOW_IF_FILTER,    HandleIpShowIfFilter),
    CREATE_CMD_ENTRY(IP_SHOW_INTERFACE,    HandleIpShowInterface),
//  CREATE_CMD_ENTRY(IPMIB_SHOW_IPFORWARD, HandleIpMibShowObject),
    CREATE_CMD_ENTRY(IP_SHOW_LOGLEVEL,     HandleIpShowLogLevel),
    CREATE_CMD_ENTRY(IPMIB_SHOW_MFE,       HandleIpMibShowObject),
    CREATE_CMD_ENTRY(IPMIB_SHOW_MFESTATS,  HandleIpMibShowObject),
    CREATE_CMD_ENTRY(IP_SHOW_PROTOCOL,     HandleIpShowProtocol),
    CREATE_CMD_ENTRY(IPMIB_SHOW_RTMROUTE,  HandleIpShowRtmRoutes),
    CREATE_CMD_ENTRY(IP_SHOW_PROTOPREF,    HandleIpShowRoutePref),
    CREATE_CMD_ENTRY(IP_SHOW_SCOPE,        HandleIpShowScope),
    CREATE_CMD_ENTRY(IP_SHOW_PERSISTENTROUTE,HandleIpShowPersistentRoute)
};

CMD_GROUP_ENTRY g_IpCmdGroups[] = 
{
    CREATE_CMD_GROUP_ENTRY(GROUP_ADD,    g_IpAddCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_DELETE, g_IpDelCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_SET,    g_IpSetCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_SHOW,   g_IpShowCmdTable),
};

ULONG   g_ulNumGroups = sizeof(g_IpCmdGroups)/sizeof(CMD_GROUP_ENTRY);

CMD_ENTRY g_IpCmds[] = 
{
//  CREATE_CMD_ENTRY(IP_INSTALL,   HandleIpInstall),
    CREATE_CMD_ENTRY(IP_RESET,     HandleIpReset),
    CREATE_CMD_ENTRY_EX(IP_UPDATE, HandleIpUpdate, 0),
//  CREATE_CMD_ENTRY(IP_UNINSTALL, HandleIpUninstall),
};

ULONG g_ulNumTopCmds = sizeof(g_IpCmds)/sizeof(CMD_ENTRY);

BOOL   g_bIpDirty = FALSE;
HANDLE g_hModule;
HANDLE g_hMprConfig = NULL;
HANDLE g_hMprAdmin  = NULL;
HANDLE g_hMIBServer = NULL;
BOOL   g_bCommit;
DWORD  g_dwNumTableEntries;

TRANSPORT_INFO      g_tiTransport;
LIST_ENTRY          g_leIfListHead;
NS_CONTEXT_CONNECT_FN IpConnect;

ULONG   g_ulInitCount;

DWORD
WINAPI
IpUnInit(
    IN  DWORD   dwReserved
    );

static DWORD                ParentVersion = 0;

DWORD
WINAPI
IpStartHelper(
    IN CONST GUID *pguidParent,
    IN DWORD       dwVersion
    )
{
    DWORD dwErr;
    NS_CONTEXT_ATTRIBUTES attMyAttributes;
    PNS_PRIV_CONTEXT_ATTRIBUTES  pNsPrivContextAttributes;

    pNsPrivContextAttributes = MALLOC(sizeof(NS_PRIV_CONTEXT_ATTRIBUTES));
    if (!pNsPrivContextAttributes)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    
    ParentVersion         = dwVersion;

    ZeroMemory(&attMyAttributes, sizeof(attMyAttributes));
    ZeroMemory(pNsPrivContextAttributes, sizeof(NS_PRIV_CONTEXT_ATTRIBUTES));

    attMyAttributes.pwszContext   = L"ip";
    attMyAttributes.guidHelper    = g_IpGuid;
    attMyAttributes.dwVersion     = 1;
    attMyAttributes.dwFlags       = 0;
    attMyAttributes.ulNumTopCmds  = g_ulNumTopCmds;
    attMyAttributes.pTopCmds      = (CMD_ENTRY (*)[])&g_IpCmds;
    attMyAttributes.ulNumGroups   = g_ulNumGroups;
    attMyAttributes.pCmdGroups    = (CMD_GROUP_ENTRY (*)[])&g_IpCmdGroups;
    attMyAttributes.pfnCommitFn   = IpCommit;
    attMyAttributes.pfnDumpFn     = IpDump;
    attMyAttributes.pfnConnectFn  = IpConnect;
   
    pNsPrivContextAttributes->pfnEntryFn    = NULL;
    pNsPrivContextAttributes->pfnSubEntryFn = IpSubEntry;
    attMyAttributes.pReserved     = pNsPrivContextAttributes;

    dwErr = RegisterContext( &attMyAttributes );

    return dwErr;
}

DWORD WINAPI
IpSubEntry(
    IN      const NS_CONTEXT_ATTRIBUTES *pSubContext,
    IN      LPCWSTR                      pwszMachine,
    IN OUT  LPWSTR                      *ppwcArguments,
    IN      DWORD                        dwArgCount,
    IN      DWORD                        dwFlags,
    IN      LPCVOID                      pvData,
    OUT     LPWSTR                       pwcNewContext
    )
{
    PNS_PRIV_CONTEXT_ATTRIBUTES pNsPrivContextAttributes = pSubContext->pReserved;
    
    if ( (!pNsPrivContextAttributes) || (!pNsPrivContextAttributes->pfnEntryFn) )
    {
        return GenericMonitor(pSubContext,
                               pwszMachine,
                               ppwcArguments,
                               dwArgCount,
                               dwFlags,
                               g_hMIBServer,
                               pwcNewContext );
    }

    return (*pNsPrivContextAttributes->pfnEntryFn)( pwszMachine,
                                    ppwcArguments,
                                    dwArgCount,
                                    dwFlags,
                                    g_hMIBServer,
                                    pwcNewContext );
}

DWORD
WINAPI
InitHelperDll(
    IN  DWORD               dwNetshVersion,
    OUT PNS_DLL_ATTRIBUTES  pDllTable
    )
{
    WORD       wVersion = MAKEWORD(1,1);
    WSADATA    wsaData;
    DWORD      dwErr;
    NS_HELPER_ATTRIBUTES attMyAttributes;

    //
    // See if this is the first time we are being called
    //

    if(InterlockedIncrement(&g_ulInitCount) != 1)
    {
        return NO_ERROR;
    }

    dwErr = WSAStartup(wVersion,&wsaData);

    if(dwErr isnot NO_ERROR)
    {
        return dwErr;
    }

    //
    // Initialize interface list and the Transport Info Block
    //

    InitializeListHead(&g_leIfListHead);

    g_tiTransport.bValid   = FALSE;
    g_tiTransport.pibhInfo = NULL;

    g_bCommit = TRUE;

    pDllTable->dwVersion     = NETSH_VERSION_50;
    pDllTable->pfnStopFn     = StopHelperDll;

    // Register helpers
    // We have 2 helpers (ROUTING, IP)

    ZeroMemory( &attMyAttributes, sizeof(attMyAttributes) );
    attMyAttributes.guidHelper               = g_RoutingGuid;
    attMyAttributes.dwVersion                = IP_HELPER_VERSION;
    attMyAttributes.pfnStart                 = RoutingStartHelper;
    attMyAttributes.pfnStop                  = NULL;

    RegisterHelper( &g_NetshGuid, &attMyAttributes );

    attMyAttributes.guidHelper               = g_IpGuid;
    attMyAttributes.dwVersion                = IP_HELPER_VERSION;
    attMyAttributes.pfnStart                 = IpStartHelper;
    attMyAttributes.pfnStop                  = NULL;

    RegisterHelper( &g_RoutingGuid, &attMyAttributes );

    return NO_ERROR;
}

DWORD
WINAPI
StopHelperDll(
    IN  DWORD   dwReserved
    )
{
    if(InterlockedDecrement(&g_ulInitCount) isnot 0)
    {
        return NO_ERROR;
    }

    IpCommit(NETSH_FLUSH);
   
    return NO_ERROR;
}
 
BOOL 
WINAPI
IpDllEntry(
    HINSTANCE   hInstDll,
    DWORD       fdwReason,
    LPVOID      pReserved
    )
{

    switch (fdwReason)
    {
        case DLL_PROCESS_ATTACH:
        {
            g_hModule = hInstDll;

            DisableThreadLibraryCalls(hInstDll);

            break;
        }
        case DLL_PROCESS_DETACH:
        {
            
            break;
        }

        default:
        {
            break;
        }
    }

    return TRUE;
}

DWORD WINAPI
IpConnect(
    IN  LPCWSTR pwszRouter
    )
{
    // If context info is dirty, reregister it
    if (g_bIpDirty)
    {
        IpStartHelper(NULL, ParentVersion);
    }

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ip\ipmon\precomp.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>

#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <memory.h>
#include <malloc.h>
#include <tchar.h>
#include <winsock2.h>

#include <rpc.h>
#include <nhapi.h>

#include <fltdefs.h>
#include <rtutils.h>
#include <mprerror.h>
#include <routprot.h>
#include <ipinfoid.h>
#include <iprtrmib.h>
#include <rtinfo.h>
#include <iprtinfo.h>
#include <priopriv.h>
#include <ipriprm.h>
#include <ipbootp.h>
#include <ospf_cfg.h>
#include <mprapi.h>
#include <ipinfoid.h>
#include <rtmv2.h>
#include <macros.h>
#include <netsh.h>
#include <netshp.h>
#include <ipmontr.h>

#include "ipmon.h"
#include "strdefs.h"
#include "ipstring.h"
#include "info.h"
#include "ipcfg.h"
#include "iphandle.h"
#include "mprip.h"
#include "route.h"
#include "filter.h"
#include "showmib.h"
#include "boundary.h"
#include "utils.h"
#include "routing.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ip\ipmon\iphandle.c ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    routing\netsh\ip\iphandle.c

Abstract:

    Fns to get command options

Revision History:

    Anand Mahalingam         7/10/98  Created

--*/

#include "precomp.h"
#pragma hdrstop

#undef EXTRA_DEBUG

#define SHOW_IF_FILTER          0
#define SHOW_INTERFACE          1
#define SHOW_PERSISTENTROUTE    2

extern ULONG g_ulNumTopCmds;
extern ULONG g_ulNumGroups;

extern CMD_GROUP_ENTRY      g_IpCmdGroups[];
extern CMD_ENTRY            g_IpCmds[];

DWORD
PreHandleCommand(
    IN  LPWSTR   *ppwcArguments,
    IN  DWORD     dwCurrentIndex,
    IN  DWORD     dwArgCount,

    IN  TAG_TYPE *pttTags,
    IN  DWORD     dwTagCount,
    IN  DWORD     dwMinArgs,
    IN  DWORD     dwMaxArgs,
    OUT DWORD    *pdwTagType
    )
{
    ZeroMemory(pdwTagType, sizeof(DWORD) * dwMaxArgs);
    
    return PreprocessCommand(g_hModule,
                             ppwcArguments,
                             dwCurrentIndex,
                             dwArgCount,
                             pttTags,
                             dwTagCount,
                             dwMinArgs,
                             dwMaxArgs,
                             pdwTagType);
}

DWORD
HandleIpUpdate(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )

/*++

Routine Description:

    Updates IP autostatic routes on an interface
    
Arguments:


Return Value:

    NO_ERROR

--*/

{
    TAG_TYPE    rgTags[] = {TOKEN_NAME, TRUE,FALSE};
    DWORD       dwErr, dwSize, dwTagType = -1;
    WCHAR       rgwcIfName[MAX_INTERFACE_NAME_LEN+1];

    if (dwArgCount != 3)
    {
        //
        // Need the name of the interface
        //

        return ERROR_INVALID_SYNTAX;
    }

    dwErr = MatchTagsInCmdLine(g_hModule,
                        ppwcArguments,
                        dwCurrentIndex,
                        dwArgCount,
                        rgTags,
                        sizeof(rgTags)/sizeof(TAG_TYPE),
                        &dwTagType);

    if(dwErr isnot NO_ERROR)
    {
        if(dwErr is ERROR_INVALID_OPTION_TAG)
        {
            return ERROR_INVALID_SYNTAX;
        }

        return dwErr;
    }

    if(dwTagType isnot 0)
    {
        return ERROR_INVALID_SYNTAX;
    }

    dwSize = sizeof(rgwcIfName);

    IpmontrGetIfNameFromFriendlyName(ppwcArguments[dwCurrentIndex],
                              rgwcIfName,
                              &dwSize);

    dwErr = UpdateAutoStaticRoutes(rgwcIfName);

    return dwErr;
}



// (almost) borrowed from netsh\if\utils.c
// compares dwAddress against all valid masks (all 33 of them!) till a match
BOOL ValidMask(DWORD dwAddress)
{
    DWORD i, dwMask;

    dwAddress = ntohl(dwAddress); // dwAddress is in network byte order
    for (i=0, dwMask=0;  i<33; (dwMask = ((dwMask>>1) + 0x80000000)), i++)
    {
        if (dwAddress == dwMask)
            return TRUE;
    }

    return FALSE;
}



DWORD
IpAddDelIfFilter(
    PWCHAR    *ppwcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    BOOL      bAdd
    )

/*++

Routine Description:

    Gets options for add/del interface filters

Arguments:
    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg 
    bAdd            - To add or to delete

Return Value:

    NO_ERROR
    
--*/

{
    FILTER_INFO        fi;
    DWORD              dwBitVector = 0, dwNumParsed = 0;
    DWORD              dwErr = NO_ERROR,dwRes;
    PDWORD             pdwTagType;
    DWORD              dwNumOpt, dwStatus = (DWORD) -1;
    DWORD              dwNumTags = 11, dwNumArg, i, j, dwFilterType;
    WCHAR              wszIfName[MAX_INTERFACE_NAME_LEN + 1] = L"\0";
    BOOL               bTags = FALSE, bOkay = TRUE;
    TAG_TYPE           pttTags[] = {{TOKEN_NAME,TRUE,FALSE},
                                    {TOKEN_FILTER_TYPE,TRUE,FALSE},
                                    {TOKEN_SOURCE_ADDRESS,TRUE,FALSE},
                                    {TOKEN_SOURCE_MASK,TRUE,FALSE},
                                    {TOKEN_DEST_ADDRESS,TRUE,FALSE},
                                    {TOKEN_DEST_MASK,TRUE,FALSE},
                                    {TOKEN_PROTOCOL,TRUE,FALSE},
                                    {TOKEN_SOURCE_PORT,TRUE,FALSE},
                                    {TOKEN_DEST_PORT,TRUE,FALSE},
                                    {TOKEN_TYPE,TRUE,FALSE},
                                    {TOKEN_CODE,TRUE,FALSE}};

    if (dwCurrentIndex >= dwArgCount)
    {
        //
        // No arguments specified
        //

        return ERROR_SHOW_USAGE;
    }

    ZeroMemory(&fi, sizeof(fi));
    
    dwNumArg = dwArgCount - dwCurrentIndex;

    pdwTagType = HeapAlloc(GetProcessHeap(),
                           0,
                           dwNumArg * sizeof(DWORD));

    if (pdwTagType is NULL)
    {
        DisplayMessage(g_hModule, MSG_IP_NOT_ENOUGH_MEMORY);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    dwErr = MatchTagsInCmdLine(g_hModule, ppwcArguments,
                        dwCurrentIndex,
                        dwArgCount,
                        pttTags,
                        dwNumTags,
                        pdwTagType);

    if (dwErr isnot NO_ERROR)
    {
        if (dwErr is ERROR_INVALID_OPTION_TAG)
        {
            dwErr = ERROR_INVALID_SYNTAX; // show usage
        }

        HeapFree(GetProcessHeap(),0,pdwTagType);
        return dwErr;
    }

    bTags = TRUE;        

    for ( i = 0; i < dwNumArg; i++)
    {
        switch (pdwTagType[i])
        {
            case 0 :
            {
                DWORD BufLen = sizeof(wszIfName);
                GetInterfaceName(ppwcArguments[i + dwCurrentIndex],
                                 wszIfName,
                                 BufLen,
                                 &dwNumParsed);

                // no filters allowed on INTERNAL/LOOPBACK interfaces
                if (!_wcsicmp(wszIfName, L"internal") or
                    !_wcsicmp(wszIfName, L"loopback"))
                {
                    DisplayMessage(g_hModule,
                                   MSG_IP_BAD_INTERFACE_TYPE,
                                   wszIfName);
                    dwErr = ERROR_INVALID_PARAMETER;
                    i = dwNumArg;
                }
                    
                break;
            }

            case 1:
            {
                TOKEN_VALUE    rgEnums[] = 
                    {{TOKEN_VALUE_INPUT, IP_IN_FILTER_INFO},
                     {TOKEN_VALUE_OUTPUT, IP_OUT_FILTER_INFO},
                     {TOKEN_VALUE_DIAL, IP_DEMAND_DIAL_FILTER_INFO}};

                //
                // Tag FILTERTYPE
                //

                dwErr = MatchEnumTag(g_hModule, 
                                     ppwcArguments[i + dwCurrentIndex],
                                     sizeof(rgEnums)/sizeof(TOKEN_VALUE), 
                                     rgEnums,
                                     &dwRes);

                if(dwErr != NO_ERROR)
                {
                    DispTokenErrMsg(g_hModule, MSG_IP_BAD_OPTION_VALUE,
                                    pttTags[pdwTagType[i]].pwszTag,
                                    ppwcArguments[i + dwCurrentIndex]);

                    DisplayMessage( g_hModule,
                                    MSG_IP_BAD_OPTION_ENUMERATION,
                                    pttTags[pdwTagType[i]].pwszTag );
                    
                    for (i=0; i<sizeof(rgEnums)/sizeof(TOKEN_VALUE); i++) 
                    {
                        DisplayMessageT( L"  %1!s!\n", rgEnums[i].pwszToken );
                    }

                    i = dwNumArg;
                    dwErr = NO_ERROR;
                    bOkay = FALSE;
                    break;
                }    

                dwFilterType = dwRes;

                break;
            }

            case 2:
            {
                dwErr = GetIpAddress(ppwcArguments[i + dwCurrentIndex], &fi.dwSrcAddr);
                
                if(dwErr is ERROR_INVALID_PARAMETER)
                {
                    DisplayMessage(g_hModule,  MSG_IP_BAD_IP_ADDR,
                                    ppwcArguments[i + dwCurrentIndex]);

                    DispTokenErrMsg(g_hModule, MSG_IP_BAD_OPTION_VALUE,
                                    pttTags[pdwTagType[i]].pwszTag,
                                    ppwcArguments[i + dwCurrentIndex]);
                
                    dwErr = ERROR_INVALID_PARAMETER;
                    i = dwNumArg;
                    break;
                }

                //
                // Get the src mask too.
                //

                if (pdwTagType[i+1] != 3)
                {
                    //
                    // Addr Mask pair not present
                    //
                    dwErr = ERROR_INVALID_SYNTAX;
                    i = dwNumArg;
                    break;
                }

                dwErr = GetIpAddress(ppwcArguments[i + 1 + dwCurrentIndex], 
                                     &fi.dwSrcMask);

                if ((dwErr is ERROR_INVALID_PARAMETER)  or
                    (!ValidMask(fi.dwSrcMask))          or
                    ((fi.dwSrcAddr & fi.dwSrcMask) isnot fi.dwSrcAddr))
                {
                    DisplayMessage(g_hModule,  MSG_IP_BAD_IP_ADDR,
                                    ppwcArguments[i + 1 + dwCurrentIndex]);

                    DispTokenErrMsg(g_hModule, MSG_IP_BAD_OPTION_VALUE,
                                    pttTags[pdwTagType[i + 1]].pwszTag,
                                    ppwcArguments[i + dwCurrentIndex + 1]);

                    dwErr = ERROR_INVALID_PARAMETER;

                    i = dwNumArg;

                    break;
                }

                i++;
                
                break;
            }

            case 4 :
            {
                dwErr = GetIpAddress(ppwcArguments[i + dwCurrentIndex], 
                                     &fi.dwDstAddr);
            
                if(dwErr is ERROR_INVALID_PARAMETER)
                {
                    DisplayMessage(g_hModule,  MSG_IP_BAD_IP_ADDR,
                                    ppwcArguments[i + dwCurrentIndex]);
                    
                    DispTokenErrMsg(g_hModule, MSG_IP_BAD_OPTION_VALUE,
                                    pttTags[pdwTagType[i]].pwszTag,
                                    ppwcArguments[i + dwCurrentIndex]);

                    dwErr = ERROR_INVALID_PARAMETER;

                    i = dwNumArg;

                    break;
                }

                //
                // Get the dst mask too.
                //

                if (pdwTagType[i+1] != 5)
                {
                    //
                    // Addr Mask pair not present
                    //
                    dwErr = ERROR_INVALID_SYNTAX;
                    i = dwNumArg;
                    break;
                }

                dwErr = GetIpAddress(ppwcArguments[i + 1 + dwCurrentIndex], 
                                     &fi.dwDstMask);

                
                if ((dwErr is ERROR_INVALID_PARAMETER)  or
                    (!ValidMask(fi.dwDstMask))          or
                    ((fi.dwDstAddr & fi.dwDstMask) isnot fi.dwDstAddr))
                {
                    DisplayMessage(g_hModule,  MSG_IP_BAD_IP_ADDR,
                                    ppwcArguments[i + 1 + dwCurrentIndex]);

                    DispTokenErrMsg(g_hModule, MSG_IP_BAD_OPTION_VALUE,
                                    pttTags[pdwTagType[i + 1]].pwszTag,
                                    ppwcArguments[i + 1 + dwCurrentIndex]);

                    dwErr = ERROR_INVALID_PARAMETER;

                    i = dwNumArg;

                    break;
                }

                i++;

                break;
            }

            case 6:
            {
                TOKEN_VALUE    rgEnums[] =
                {
                    {TOKEN_VALUE_ANY,       FILTER_PROTO_ANY},
                    {TOKEN_VALUE_TCP,       FILTER_PROTO_TCP},
                    {TOKEN_VALUE_TCP_ESTAB, FILTER_PROTO_TCP},
                    {TOKEN_VALUE_UDP,       FILTER_PROTO_UDP},
                    {TOKEN_VALUE_ICMP,      FILTER_PROTO_ICMP}
                };
                    
                if (MatchEnumTag(g_hModule,
                                 ppwcArguments[i + dwCurrentIndex],
                                 sizeof(rgEnums)/sizeof(TOKEN_VALUE),
                                 rgEnums,
                                 &dwRes) != NO_ERROR)
                {
                    //
                    // In this case see if its a valid value
                    //
                    dwRes = wcstoul(ppwcArguments[i + dwCurrentIndex],
                                    NULL,
                                    10);

                    if((dwRes < 1) ||
                       (dwRes > 255))
                    {
                        DispTokenErrMsg(g_hModule, 
                                        MSG_IP_BAD_OPTION_VALUE,
                                        pttTags[pdwTagType[i]].pwszTag,
                                        ppwcArguments[i + dwCurrentIndex]);

                        DisplayMessage( g_hModule,
                                        MSG_IP_BAD_OPTION_ENUMERATION,
                                        pttTags[pdwTagType[i]].pwszTag );
                    
                        for (i=0; i<sizeof(rgEnums)/sizeof(TOKEN_VALUE); i++) 
                        {
                            DisplayMessageT( L"  %1!s!\n", rgEnums[i].pwszToken );
                        }

                        i = dwNumArg;
                        dwErr = NO_ERROR;
                        bOkay = FALSE;
                        break;
                    }
                }

                fi.dwProtocol = dwRes;

                switch (fi.dwProtocol)
                {
                    case FILTER_PROTO_ANY :
                        //
                        // We are done
                        //
                        fi.wSrcPort = fi.wDstPort = 0;
                        
                        break;

                    case FILTER_PROTO_TCP :
                        // TCP and TCP_ESTABLISHED have same protocol number
                        if (!MatchToken(ppwcArguments[i + dwCurrentIndex],
                                        TOKEN_VALUE_TCP))
                        {
                            fi.fLateBound |= TCP_ESTABLISHED_FLAG;
                        }
                        
                        // continue processing as we could for UDP...
                        
                    case FILTER_PROTO_UDP :
                        //
                        // Get the src and dst ports too
                        //
                        
                        if (i + 2 >= dwNumArg)
                        {
                            dwErr = ERROR_INVALID_SYNTAX;
                            i = dwNumArg;
                            break;
                        }
                            
                        if (bTags &&
                            (pdwTagType[i+1] != 7 || pdwTagType[i+2] != 8))
                        {
                            dwErr = ERROR_INVALID_SYNTAX;
                            i = dwNumArg;
                            break;
                        }

                        fi.wSrcPort =
                            htons((WORD)wcstoul(ppwcArguments[i + 1 + dwCurrentIndex],
                                          NULL, 
                                          10));

                        fi.wDstPort = 
                            htons((WORD)wcstoul(ppwcArguments[i + 2 + dwCurrentIndex],
                                          NULL, 
                                          10));

                        i += 2;

                        break;

                    case FILTER_PROTO_ICMP :

                        //
                        // Get the src and dst ports too
                        //

                        if (i + 2 >= dwNumArg)
                        {
                            dwErr = ERROR_INVALID_SYNTAX;
                            i = dwNumArg;
                            break;
                        }

                        // src and dest ports acted upon as type and code
                        if (bTags &&
                            (pdwTagType[i+1] != 7 || pdwTagType[i+2] != 8) &&
                            (pdwTagType[i+1] != 9 || pdwTagType[i+2] != 10))
                        {
                            dwErr = ERROR_INVALID_SYNTAX;
                            i = dwNumArg;
                            break;
                        }

                        fi.wSrcPort = (BYTE)wcstoul(ppwcArguments[i + 1 + dwCurrentIndex], NULL, 10);

                        fi.wDstPort = (BYTE)wcstoul(ppwcArguments[i + 2 + dwCurrentIndex], NULL, 10);

                        i += 2;

                        break;


                    default:
                    {
                        //    
                        // any 'other' protocol
                        //
                        fi.wSrcPort = fi.wDstPort = 0;
                        break;
                    }   
                }                  

                break;
            }
            
            default:
            {
                i = dwNumArg;
                dwErr = ERROR_INVALID_SYNTAX;
                break;
            }
        }
    }

    HeapFree(GetProcessHeap(), 0, pdwTagType);

    switch(dwErr)
    {
        case NO_ERROR :
            break;

        default:
            return dwErr;
    }

    if (!bOkay)
    {
        return NO_ERROR;
    }

    //
    // Make sure all parameters are present
    //

    if ( !pttTags[0].bPresent ||
         !pttTags[1].bPresent ||
         !pttTags[2].bPresent ||
         !pttTags[3].bPresent ||
         !pttTags[4].bPresent ||
         !pttTags[5].bPresent ||
         !pttTags[6].bPresent )
    {
        DisplayMessage(g_hModule, MSG_CANT_FIND_EOPT);

        return ERROR_INVALID_SYNTAX;
    }
         
    dwErr = AddDelFilterInfo(fi,
                             wszIfName,
                             dwFilterType,
                             bAdd);

    return dwErr;
}

DWORD
HandleIpAddIfFilter(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )

/*++

Routine Description:

    Gets options for add interface filters

Arguments:

    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg 

Return Value:

    NO_ERROR
    
--*/
{
    return IpAddDelIfFilter(ppwcArguments,
                            dwCurrentIndex,
                            dwArgCount,
                            TRUE);
    
}

DWORD
HandleIpDelIfFilter(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )

/*++

Routine Description:

    Gets options for del interface filters

Arguments:

    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg 

Return Value:

    NO_ERROR
    
--*/
{
    return IpAddDelIfFilter(ppwcArguments,
                            dwCurrentIndex,
                            dwArgCount,
                            FALSE);
}

DWORD
IpAddSetDelRtmRoute(
    PWCHAR    *ppwcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwCommand
    )

/*++

Routine Description:

    Gets options for add/del routes over interfaces.
    These operations are performed directly to RTM
    and do not involve the registry. As persistence
    is not involved, we need the router to be running.

Arguments:
    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg 
    dwCommand       - To add, set, or delete

Return Value:

    NO_ERROR
    
--*/

{
    INTERFACE_ROUTE_INFO route;
    DWORD              dwNumParsed, dwErr, dwRes;
    DWORD              dwNumOpt, dwStatus = (DWORD) -1;
    DWORD              dwNumArg, i;
    WCHAR              wszIfName[MAX_INTERFACE_NAME_LEN + 1] = L"\0";
    TAG_TYPE           pttTags[] = {{TOKEN_DEST,TRUE,FALSE},
                                    {TOKEN_MASK,FALSE,FALSE},
                                    {TOKEN_NAMEINDEX,FALSE,FALSE},
                                    {TOKEN_NHOP,FALSE,FALSE},
                                    {TOKEN_PREFERENCE,FALSE,FALSE},
                                    {TOKEN_METRIC,FALSE,FALSE},
                                    {TOKEN_VIEW,FALSE,FALSE}};
    enum idx {DEST, MASK, NAMEINDEX, NHOP, PREFERENCE, METRIC, VIEW};
    DWORD              pdwTagType[sizeof(pttTags)/sizeof(TAG_TYPE)];
    DWORD              dwMaxArgs;
    DWORD              dwIfClass;
    DWORD              dwFlags;
    PINTERFACE_ROUTE_INFO pTable = NULL;

    //
    // We can add non persistent routes only if router is running
    //

    CHECK_ROUTER_RUNNING();

    ZeroMemory(&route,
               sizeof(route));

    route.dwRtInfoProto   = PROTO_IP_NETMGMT; // default proto
    route.dwRtInfoPreference = 0; // default preference = protocol default
    route.dwRtInfoMetric1 = 1; // default metric
    route.dwRtInfoMetric2 = MIB_IPROUTE_METRIC_UNUSED;
    route.dwRtInfoMetric3 = MIB_IPROUTE_METRIC_UNUSED;
    route.dwRtInfoViewSet = RTM_VIEW_MASK_UCAST | RTM_VIEW_MASK_MCAST;

    // Do generic processing

    dwErr = PreHandleCommand( ppwcArguments,
                              dwCurrentIndex,
                              dwArgCount,
                              pttTags,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              1,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              pdwTagType );

    if (dwErr)
    {
        return dwErr;
    }

    dwNumArg = dwArgCount - dwCurrentIndex;

    //
    // At this point, the arg array contains only values (either because
    // the tags werent present, or because that info has now been split out)
    // So we go through each of the each of the arguments, look up its tag
    // type in the tag array, switch on the type of tag it is and then
    // process accordingly.
    //
    
    for (i = 0; i < dwNumArg; i++)
    {
        switch (pdwTagType[i])
        {
        case DEST: // DEST
        {
                dwErr = GetIpPrefix(ppwcArguments[i + dwCurrentIndex], 
                                    &route.dwRtInfoDest,
                                    &route.dwRtInfoMask);
                break;
        }

        case MASK: // MASK
        {
                dwErr = GetIpMask(ppwcArguments[i + dwCurrentIndex], 
                                  &route.dwRtInfoMask);
                break;
        }

        case NAMEINDEX : // INDEX or NAME
        {
            PWCHAR endptr = NULL;
            DWORD BufLen;

            //
            // Initially consider the user input to be the friendly name of the 
            // interface            
            // If we fail to get the interface name from this friendly name 
            // then we shall try considering the user as an index
            //
            route.dwRtInfoIfIndex = 0;
                
            BufLen = sizeof(wszIfName);
            dwErr = GetInterfaceName(ppwcArguments[i + dwCurrentIndex],
                             wszIfName,
                             BufLen,
                             &dwNumParsed);

            if (dwErr != NO_ERROR)
            {
                
                // If it starts with '0x', this is a hex index
                // else if it starts with 0, this is an 0ctal index
                // else it is decimal or an interface name
                //


                if ((ppwcArguments[i + dwCurrentIndex][0] == L'0') &&
                    (ppwcArguments[i + dwCurrentIndex][1] == L'x'))
                {
                    route.dwRtInfoIfIndex = 
                        wcstoul(ppwcArguments[i + dwCurrentIndex],
                            &endptr,
                            16);
                }
                else if ( ppwcArguments[i + dwCurrentIndex][0] == L'0')
                {
                    route.dwRtInfoIfIndex = 
                        wcstoul(ppwcArguments[i + dwCurrentIndex],
                            &endptr,
                            8);
                }
                else
                {
                    route.dwRtInfoIfIndex = 
                        wcstoul(ppwcArguments[i + dwCurrentIndex],
                            &endptr,
                            10);
                }

                //
                // If all the characters in the field were not used while doing the 
                // conversion, then we know that the input was not purely 
                /// numeric, and is thus invalid as an index value
                //
                
                if (*endptr != L'\0')
                {
                    DisplayMessage(g_hModule, EMSG_CANT_MATCH_NAME);
                    return ERROR_INVALID_PARAMETER;
                }
            }

            break;
        }

        case NHOP: // NHOP
        {
                dwErr = GetIpAddress(ppwcArguments[i + dwCurrentIndex], 
                                     &route.dwRtInfoNextHop);
                break;
        }

        case PREFERENCE:
        {
                route.dwRtInfoPreference =
                    wcstoul(ppwcArguments[i + dwCurrentIndex],
                             NULL,
                             10);
                break;
        }

        case METRIC: // METRIC
        {
                route.dwRtInfoMetric1 =
                    wcstoul(ppwcArguments[i + dwCurrentIndex],
                             NULL,
                             10);
                break;
        }

        case VIEW:
        {
            TOKEN_VALUE rgMaskEnums[] = {
                { TOKEN_VALUE_UNICAST,   RTM_VIEW_MASK_UCAST },
                { TOKEN_VALUE_MULTICAST, RTM_VIEW_MASK_MCAST },
                { TOKEN_VALUE_BOTH,      RTM_VIEW_MASK_UCAST
                  |RTM_VIEW_MASK_MCAST } };

                dwErr = MatchEnumTag( g_hModule,
                                      ppwcArguments[i + dwCurrentIndex],
                                      sizeof(rgMaskEnums)/sizeof(TOKEN_VALUE),
                                      rgMaskEnums,
                                      &route.dwRtInfoViewSet);

                if (dwErr isnot NO_ERROR)
                {
                    DispTokenErrMsg( g_hModule,
                                     MSG_IP_BAD_OPTION_VALUE,
                                     pttTags[pdwTagType[i]].pwszTag,
                                     ppwcArguments[i + dwCurrentIndex] );

                    i = dwArgCount;

                    return ERROR_INVALID_PARAMETER;
                }

                break;
        }
        }
    }

    if (dwErr)
    {
        return dwErr;
    }

    if (route.dwRtInfoDest & ~route.dwRtInfoMask)
    {
        // Mask contains bits not in address
        DisplayMessage(g_hModule, EMSG_PREFIX_ERROR);
        return ERROR_INVALID_PARAMETER;
    }

    if (!pttTags[NAMEINDEX].bPresent)
    {
        //
        // Neither NAME nor INDEX - adding with a nexthop
        //

        PMIB_IPADDRTABLE AddrTable;
        PMIB_IPADDRROW   AddrEntry;
        MIB_OPAQUE_QUERY Query;
        PMIB_OPAQUE_INFO Info;
        DWORD            dwQuerySize;
        DWORD            dwEntrySize;
        INT              iFirstMatch;
        UINT             Count;

        if (!pttTags[NHOP].bPresent)
        {
            DisplayMessage(g_hModule, EMSG_CANT_FIND_NAME_OR_NHOP);
            return ERROR_INVALID_SYNTAX;
        }

        //
        // Search for the interface that matches nexthop
        //

        dwQuerySize = sizeof(MIB_OPAQUE_QUERY) - sizeof(DWORD);

        Query.dwVarId = IP_ADDRTABLE;

        dwErr = MibGet(PID_IP,
                       IPRTRMGR_PID,
                       (PVOID) &Query,
                       dwQuerySize,
                       (PVOID *) &Info,
                       &dwEntrySize);

        if (dwErr != NO_ERROR)
        {
            DisplayMessage(g_hModule,  MSG_IP_DIM_ERROR, dwErr);
            return ERROR_SUPPRESS_OUTPUT;
        }
        
        if (Info is NULL)
        {
            DisplayMessage(g_hModule, EMSG_CANT_FIND_INDEX);
            return ERROR_INVALID_PARAMETER;
        }
            
        AddrTable = (PMIB_IPADDRTABLE)Info->rgbyData;

        iFirstMatch = -1;

        for (Count = 0; Count < AddrTable->dwNumEntries; Count++)
        {
            AddrEntry = &AddrTable->table[Count];

            if ((route.dwRtInfoNextHop & AddrEntry->dwMask) ==
                (AddrEntry->dwAddr & AddrEntry->dwMask))
            {
                if (iFirstMatch != -1)
                {
                    //
                    // We already matched an interface
                    // [Ambiguous next hop description]
                    //

                    MprAdminMIBBufferFree((PVOID)Info);
                    DisplayMessage(g_hModule, EMSG_AMBIGUOUS_INDEX_FROM_NHOP);
                    return ERROR_INVALID_PARAMETER;
                }

                iFirstMatch = Count;
            }
        }
            
        if (iFirstMatch == -1)
        {
            //
            // Could not find the direct nexthop
            //

            MprAdminMIBBufferFree((PVOID)Info);
            DisplayMessage(g_hModule, EMSG_CANT_FIND_INDEX);
            return ERROR_INVALID_PARAMETER;
        }

        //
        // Found the interface used to reach nexthop
        //

        route.dwRtInfoIfIndex = AddrTable->table[iFirstMatch].dwIndex;

        MprAdminMIBBufferFree((PVOID)Info);
    }

    if (route.dwRtInfoIfIndex)
    {
        //
        // Check if this index has a public exported name
        //

        dwErr = GetGuidFromIfIndex(g_hMIBServer,
                           route.dwRtInfoIfIndex,
                           wszIfName,
                           MAX_INTERFACE_NAME_LEN);
        if ( dwErr != NO_ERROR )
        {
            DisplayMessage(g_hModule, EMSG_CANT_FIND_INDEX);
            return ERROR_INVALID_PARAMETER;
        }
    }
     
    if (wszIfName[0] != L'\0')
    {
        //
        // NAME specified, or derived from INDEX above
        //
            
        dwErr = GetInterfaceClass(wszIfName, &dwIfClass);

        //
        // If we get an error, we will skip remaining
        // checks which will be performed by iprtrmgr
        //

        if (dwErr == NO_ERROR)
        {
            if (dwIfClass is IFCLASS_LOOPBACK)
            {
                return ERROR_INVALID_SYNTAX;
            }

            if (!pttTags[NHOP].bPresent)
            {
                // Make sure interface is p2p
                if (dwIfClass isnot IFCLASS_P2P)
                {
                    DisplayMessage(g_hModule, EMSG_NEED_NHOP);
                    return ERROR_INVALID_PARAMETER;
                }
            }
        }            
    }
    else
    {
        DisplayMessage(g_hModule, EMSG_CANT_MATCH_NAME);
        return ERROR_INVALID_PARAMETER;
    }    
    

    //
    // If it is a set, we should not overwrite things not specified
    //

    dwFlags = ALL_FIELDS_SPECIFIED;

    if (dwCommand == SET_COMMAND)
    {
        if (!pttTags[PREFERENCE].bPresent) dwFlags |= PREF_NOT_SPECIFIED;
        if (!pttTags[METRIC].bPresent)     dwFlags |= METRIC_NOT_SPECIFIED;
        if (!pttTags[VIEW].bPresent)       dwFlags |= VIEW_NOT_SPECIFIED;
    }

    return AddSetDelRtmRouteInfo(&route, wszIfName, dwCommand, dwFlags);
}

DWORD
HandleIpAddRtmRoute(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return IpAddSetDelRtmRoute(ppwcArguments,
                               dwCurrentIndex,
                               dwArgCount,
                               ADD_COMMAND);
}

DWORD
HandleIpDelRtmRoute(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return IpAddSetDelRtmRoute(ppwcArguments,
                               dwCurrentIndex,
                               dwArgCount,
                               DELETE_COMMAND);
}

DWORD
HandleIpSetRtmRoute(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return IpAddSetDelRtmRoute(ppwcArguments,
                               dwCurrentIndex,
                               dwArgCount,
                               SET_COMMAND);
}

DWORD
IpAddSetDelPersistentRoute(
    PWCHAR    *ppwcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwCommand
    )

/*++

Routine Description:

    Gets options for add/del routes over interfaces.
    These operations are performed directly to the
    registry and so these routes are persistent. If
    the router is running, they go into the RTM too.

Arguments:
    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg 
    dwCommand       - To add, set, or delete

Return Value:

    NO_ERROR
    
--*/

{
    INTERFACE_ROUTE_INFO route;
    DWORD              dwNumParsed, dwErr, dwRes;
    DWORD              dwNumOpt, dwStatus = (DWORD) -1;
    DWORD              dwNumArg, i;
    WCHAR              wszIfName[MAX_INTERFACE_NAME_LEN + 1] = L"\0";
    WCHAR              *pwszIfNameOnCmdLine = NULL;
    TAG_TYPE           pttTags[] = {{TOKEN_DEST,TRUE,FALSE},
                                    {TOKEN_MASK,FALSE,FALSE},
                                    {TOKEN_NAME,FALSE,FALSE},
                                    {TOKEN_NHOP,FALSE,FALSE},
                                    {TOKEN_PROTOCOL,FALSE,FALSE},
                                    {TOKEN_PREFERENCE,FALSE,FALSE},
                                    {TOKEN_METRIC,FALSE,FALSE},
                                    {TOKEN_VIEW,FALSE,FALSE}};
    enum idx {DEST, MASK, NAME, NHOP, PROTO, PREFERENCE, METRIC, VIEW};
    DWORD              pdwTagType[sizeof(pttTags)/sizeof(TAG_TYPE)];
    DWORD              dwMaxArgs;
    DWORD              dwIfClass;
    DWORD              dwFlags;
    PINTERFACE_ROUTE_INFO pTable = NULL;

    ZeroMemory(&route,
               sizeof(route));

    route.dwRtInfoProto   = PROTO_IP_NT_STATIC_NON_DOD; // default proto
    route.dwRtInfoPreference = 0; // default preference = protocol default
    route.dwRtInfoMetric1 = 1; // default metric
    route.dwRtInfoMetric2 = MIB_IPROUTE_METRIC_UNUSED;
    route.dwRtInfoMetric3 = MIB_IPROUTE_METRIC_UNUSED;
    route.dwRtInfoViewSet = RTM_VIEW_MASK_UCAST | RTM_VIEW_MASK_MCAST;

    // Do generic processing

    dwErr = PreHandleCommand( ppwcArguments,
                              dwCurrentIndex,
                              dwArgCount,
                              pttTags,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              1,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              pdwTagType );

    if (dwErr)
    {
        return dwErr;
    }

    dwNumArg = dwArgCount - dwCurrentIndex;

    //
    // At this point, the arg array contains only values (either because
    // the tags werent present, or because that info has now been split out)
    // So we go through each of the each of the arguments, look up its tag
    // type in the tag array, switch on the type of tag it is and then
    // process accordingly.
    //
    
    for (i = 0; i < dwNumArg; i++)
    {
        switch (pdwTagType[i])
        {
        case DEST: // DEST
        {
                dwErr = GetIpPrefix(ppwcArguments[i + dwCurrentIndex], 
                                    &route.dwRtInfoDest,
                                    &route.dwRtInfoMask);
                break;
        }

        case MASK: // MASK
        {
                dwErr = GetIpMask(ppwcArguments[i + dwCurrentIndex], 
                                  &route.dwRtInfoMask);
                break;
        }

        case NAME : // NAME
        {
                DWORD BufLen = sizeof(wszIfName);
                pwszIfNameOnCmdLine = ppwcArguments[i + dwCurrentIndex];
                GetInterfaceName(ppwcArguments[i + dwCurrentIndex],
                                 wszIfName,
                                 BufLen,
                                 &dwNumParsed);
                break;
        }

        case NHOP: // NHOP
        {
                dwErr = GetIpAddress(ppwcArguments[i + dwCurrentIndex], 
                                     &route.dwRtInfoNextHop);
                break;
        }

        case PROTO : // PROTO
        {
                TOKEN_VALUE    rgEnums[] = 
                {/*{TOKEN_VALUE_AUTOSTATIC, PROTO_IP_NT_AUTOSTATIC},*/
                 {TOKEN_VALUE_STATIC, PROTO_IP_NT_STATIC},
                 {TOKEN_VALUE_NONDOD, PROTO_IP_NT_STATIC_NON_DOD}};

                dwErr = MatchEnumTag(g_hModule,
                                     ppwcArguments[i + dwCurrentIndex],
                                     sizeof(rgEnums)/sizeof(TOKEN_VALUE),
                                     rgEnums,
                                     &dwRes);

                if (dwErr != NO_ERROR)
                {
                    DispTokenErrMsg(g_hModule,
                                    MSG_IP_BAD_OPTION_VALUE,
                                    pttTags[pdwTagType[i]].pwszTag,
                                    ppwcArguments[i + dwCurrentIndex]);

                    DisplayMessage( g_hModule,
                                    MSG_IP_BAD_OPTION_ENUMERATION,
                                    pttTags[pdwTagType[i]].pwszTag );
                    
                    for (i=0; i<sizeof(rgEnums)/sizeof(TOKEN_VALUE); i++) 
                    {
                        DisplayMessageT( L"  %1!s!\n", rgEnums[i].pwszToken );
                    }

                    return ERROR_SUPPRESS_OUTPUT;
                }    

                route.dwRtInfoProto = dwRes;
                
                break;
        }

        case PREFERENCE:
        {
                route.dwRtInfoPreference =
                    wcstoul(ppwcArguments[i + dwCurrentIndex],
                             NULL,
                             10);
                break;
        }

        case METRIC:
        {
                route.dwRtInfoMetric1 =
                    wcstoul(ppwcArguments[i + dwCurrentIndex],
                             NULL,
                             10);
                break;
        }

        case VIEW:
        {
            TOKEN_VALUE rgMaskEnums[] = {
                { TOKEN_VALUE_UNICAST,   RTM_VIEW_MASK_UCAST },
                { TOKEN_VALUE_MULTICAST, RTM_VIEW_MASK_MCAST },
                { TOKEN_VALUE_BOTH,      RTM_VIEW_MASK_UCAST
                                        |RTM_VIEW_MASK_MCAST } };

                dwErr = MatchEnumTag( g_hModule,
                                      ppwcArguments[i + dwCurrentIndex],
                                      sizeof(rgMaskEnums)/sizeof(TOKEN_VALUE),
                                      rgMaskEnums,
                                      &route.dwRtInfoViewSet);

                if (dwErr isnot NO_ERROR)
                {
                    DispTokenErrMsg( g_hModule,
                                     MSG_IP_BAD_OPTION_VALUE,
                                     pttTags[pdwTagType[i]].pwszTag,
                                     ppwcArguments[i + dwCurrentIndex] );

                    i = dwArgCount;

                    return ERROR_SUPPRESS_OUTPUT;
                }

                break;
        }
        }
    }

    if (dwErr)
    {
        return dwErr;
    }

    if (route.dwRtInfoDest & ~route.dwRtInfoMask)
    {
        // Mask contains bits not in address
        DisplayMessage(g_hModule, EMSG_PREFIX_ERROR);
        return ERROR_SUPPRESS_OUTPUT;
    }

    if (!pttTags[NAME].bPresent)
    {
        // Need if name to add persistent route
        DisplayMessage(g_hModule, EMSG_CANT_FIND_NAME);
        return ERROR_SUPPRESS_OUTPUT;
    }
     
    dwErr = GetInterfaceClass(wszIfName, &dwIfClass);

    if (dwErr)
    {
        DisplayMessage(g_hModule, EMSG_CANT_GET_IF_INFO,
                       pwszIfNameOnCmdLine,
                       dwErr);

        return ERROR_SUPPRESS_OUTPUT;
    }
            
    if (dwIfClass is IFCLASS_LOOPBACK)
    {
        return ERROR_INVALID_SYNTAX;
    }

    if (!pttTags[NHOP].bPresent)
    {
        // Make sure interface is p2p
        if (dwIfClass isnot IFCLASS_P2P)
        {
            DisplayMessage(g_hModule, EMSG_NEED_NHOP);
            return ERROR_SUPPRESS_OUTPUT;
        }
    }

    if (dwIfClass is IFCLASS_P2P)
    { 
        if (!pttTags[PROTO].bPresent)
        {
            // if not explicitly specified, change protocol to static
            route.dwRtInfoProto = PROTO_IP_NT_STATIC; // default proto
        }

        // Make sure nhop is not specified.
        if (pttTags[NHOP].bPresent)
        {
            // if class is p2p, then nhop specification is not allowed
            DisplayMessage(g_hModule, EMSG_P2P_WITH_NHOP, 
                                pwszIfNameOnCmdLine);
            return ERROR_SUPPRESS_OUTPUT;
        }
    } 
    else
    {
        // make sure we didn't try to set static on a non-P2P interface
        if (route.dwRtInfoProto is PROTO_IP_NT_STATIC)
        {
            return ERROR_INVALID_PARAMETER;
        }
    }

    //
    // If it is a set, we should not overwrite things not specified
    //

    dwFlags = ALL_FIELDS_SPECIFIED;

    if (dwCommand == SET_COMMAND)
    {
        if (!pttTags[PREFERENCE].bPresent) dwFlags |= PREF_NOT_SPECIFIED;
        if (!pttTags[METRIC].bPresent)     dwFlags |= METRIC_NOT_SPECIFIED;
        if (!pttTags[VIEW].bPresent)       dwFlags |= VIEW_NOT_SPECIFIED;
    }

    return AddSetDelPersistentRouteInfo(&route, wszIfName, dwCommand, dwFlags);
}


DWORD
HandleIpAddPersistentRoute(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return IpAddSetDelPersistentRoute(ppwcArguments,
                                      dwCurrentIndex,
                                      dwArgCount,
                                      ADD_COMMAND);
}

DWORD
HandleIpDelPersistentRoute(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return IpAddSetDelPersistentRoute(ppwcArguments,
                                      dwCurrentIndex,
                                      dwArgCount,
                                      DELETE_COMMAND);
}

DWORD
HandleIpSetPersistentRoute(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return IpAddSetDelPersistentRoute(ppwcArguments,
                                      dwCurrentIndex,
                                      dwArgCount,
                                      SET_COMMAND);
}

DWORD
HandleIpAddRoutePref(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )


/*++

Routine Description:

    Gets options for adding route preferences

Arguments:

    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg 

Return Value:

    NO_ERROR
    
--*/

{

    PPROTOCOL_METRIC            ppm;
    DWORD                       dwBitVector = 0, dwNumPref,dwPrefIndex;
    DWORD                       dwErr = NO_ERROR,dwRes;
    PDWORD                      pdwTagType;
    DWORD                       dwNumTags = 2, dwNumArg, i, dwAddr;
    TAG_TYPE                    pttTags[] = {{TOKEN_PROTOCOL, TRUE,FALSE},
                                             {TOKEN_PREF_LEVEL, TRUE,FALSE}};


    if (dwCurrentIndex >= dwArgCount)
    {
        //
        // No arguments specified
        //

        return ERROR_SHOW_USAGE;
    }
 
    dwNumArg = dwArgCount - dwCurrentIndex;

    pdwTagType = HeapAlloc(GetProcessHeap(),
                           0,
                           dwNumArg * sizeof(DWORD));

    if (pdwTagType is NULL)
    {
        DisplayMessage(g_hModule, MSG_IP_NOT_ENOUGH_MEMORY);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    dwErr = MatchTagsInCmdLine(g_hModule, ppwcArguments,
                        dwCurrentIndex,
                        dwArgCount,
                        pttTags,
                        dwNumTags,
                        pdwTagType);

    if (dwErr isnot NO_ERROR)
    {
        HeapFree(GetProcessHeap(),0,pdwTagType);

        if (dwErr is ERROR_INVALID_OPTION_TAG)
        {
            dwErr = ERROR_INVALID_SYNTAX; // show usage
        }

        return dwErr;
    }

    dwNumPref = dwNumArg / 2 + dwNumArg % 2;

    ppm = HeapAlloc(GetProcessHeap(),
                    0,
                    dwNumPref * sizeof(PROTOCOL_METRIC));

    if (ppm is NULL)
    {
        HeapFree(GetProcessHeap(),0,pdwTagType);

        DisplayMessage(g_hModule, MSG_IP_NOT_ENOUGH_MEMORY);
        return ERROR_SUPPRESS_OUTPUT;
    }


    for ( i = 0, dwPrefIndex = 0; i < dwNumArg; i++)
    {
        switch (pdwTagType[i])
        {
            case 0:
            {
                //
                // TAG = PROTOCOL
                //

                dwRes = MatchRoutingProtoTag(ppwcArguments[i + dwCurrentIndex]);

                if (dwRes == (DWORD) -1)
                {
                    DispTokenErrMsg(g_hModule, 
                                    MSG_IP_BAD_OPTION_VALUE,
                                    pttTags[pdwTagType[i]].pwszTag,
                                    ppwcArguments[i + dwCurrentIndex]);
 
                    i = dwNumArg;
                    dwErr = ERROR_SUPPRESS_OUTPUT;
                    break;
                }

                ppm[dwPrefIndex].dwProtocolId = dwRes;

                //
                // Get the metric too
                //

                if (pdwTagType[i+1] == 1)
                {
                    ppm[dwPrefIndex].dwMetric =
                        wcstoul(ppwcArguments[i + 1 +dwCurrentIndex],NULL,10);

                    if (ppm[dwPrefIndex].dwMetric==0
                        && wcscmp(ppwcArguments[i + 1 +dwCurrentIndex], L"0")!=0)
                    {
                        dwErr = ERROR_INVALID_SYNTAX;
                        i = dwNumArg;
                        break;
                    }

                    i++;
                    dwPrefIndex++;
                }
                else
                {
                    //
                    // the range is not an addr mask pair.
                    // So ignore the addr (i.e. don't increment dwRangeIndex)
                    //
                    dwErr = ERROR_INVALID_SYNTAX;
                    i = dwNumArg;
                    break;
                }

                break;
            }

            default :
            {
                  
                i = dwNumArg;
                dwErr = ERROR_INVALID_SYNTAX;
                break;
            }
        }
    }


    HeapFree(GetProcessHeap(), 0, pdwTagType);

    switch(dwErr)
    {
        case NO_ERROR :
            break;

        default:
            return dwErr;
    }

    if (dwPrefIndex)
    {
        //
        // Add route pref
        //

        dwRes = AddDeleteRoutePrefLevel(ppm,
                                        dwPrefIndex,
                                        TRUE);
            
    }

    HeapFree(GetProcessHeap(), 0, ppm);

    return dwErr;
}

DWORD
HandleIpDelRoutePref(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description:

    Gets options for deleting route preferences

Arguments:

    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg 

Return Value:

    NO_ERROR
    
--*/
{
    PPROTOCOL_METRIC            ppm;
    DWORD                       dwBitVector = 0, dwNumPref,dwPrefIndex;
    DWORD                       dwErr = NO_ERROR,dwRes;
    TAG_TYPE                    pttTags[] = {{TOKEN_PROTOCOL,TRUE,FALSE}};

    PDWORD                      pdwTagType;
    DWORD                       dwNumTags = 1, dwNumArg, i, dwAddr;

    if (dwCurrentIndex >= dwArgCount)
    {
        //
        // No arguments specified
        //

        return ERROR_SHOW_USAGE;
    }

    dwNumArg = dwArgCount - dwCurrentIndex;

    pdwTagType = HeapAlloc(GetProcessHeap(),
                           0,
                           dwNumArg * sizeof(DWORD));

    if (pdwTagType is NULL)
    {
        DisplayMessage(g_hModule, MSG_IP_NOT_ENOUGH_MEMORY);
        return ERROR_SUPPRESS_OUTPUT;
    }

    dwErr = MatchTagsInCmdLine(g_hModule, ppwcArguments,
                        dwCurrentIndex,
                        dwArgCount,
                        pttTags,
                        dwNumTags,
                        pdwTagType);

    if (dwErr isnot NO_ERROR)
    {
        HeapFree(GetProcessHeap(),0,pdwTagType);
        if (dwErr is ERROR_INVALID_OPTION_TAG)
        {
            dwErr = ERROR_INVALID_SYNTAX; // show usage
        }
        return dwErr;
    }

    dwNumPref = dwNumArg;

    ppm = HeapAlloc(GetProcessHeap(),
                    0,
                    dwNumPref * sizeof(PROTOCOL_METRIC));

    if (ppm is NULL)
    {
        HeapFree(GetProcessHeap(),0,pdwTagType);

        DisplayMessage(g_hModule, MSG_IP_NOT_ENOUGH_MEMORY);
        return ERROR_SUPPRESS_OUTPUT;
    }


    for ( i = 0, dwPrefIndex = 0; i < dwNumArg; i++)
    {
        switch (pdwTagType[i])
        {
            case 0:
            {

                //
                // TAG = PROTOCOL
                //

                dwRes = MatchRoutingProtoTag(ppwcArguments[i + dwCurrentIndex]);

                if (dwRes == (DWORD) -1)
                {
                    DispTokenErrMsg(g_hModule, MSG_IP_BAD_OPTION_VALUE,
                                    pttTags[pdwTagType[i]].pwszTag,
                                    ppwcArguments[i + dwCurrentIndex]);
 
                    i = dwNumArg;
                    dwErr = ERROR_SUPPRESS_OUTPUT;
                    break;
                }

                ppm[dwPrefIndex++].dwProtocolId = dwRes;

                break;
            }

            default :
            {
                i = dwNumArg;

                dwErr = ERROR_INVALID_SYNTAX;

                break;
            }
        }
    }


    HeapFree(GetProcessHeap(), 0, pdwTagType);

    switch(dwErr)
    {
        case NO_ERROR :
            break;

        default:
            return dwErr;
    }

    if (dwPrefIndex)
    {
        //
        // Add route pref
        //

        dwRes = AddDeleteRoutePrefLevel(ppm,
                                        dwPrefIndex,
                                        FALSE);
            
    }

    HeapFree(GetProcessHeap(), 0, ppm);

    return dwErr;
}

DWORD
HandleIpSetRoutePref(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description:

    Gets options for setting route preferences

Arguments:

    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg 

Return Value:

    NO_ERROR
    
--*/
{
    PROTOCOL_METRIC             pm;
    DWORD                       dwBitVector = 0, dwNumPref,dwPrefIndex;
    DWORD                       dwErr = NO_ERROR,dwRes;
    TAG_TYPE                    pttTags[] = {{TOKEN_PROTOCOL, TRUE,FALSE},
                                             {TOKEN_PREF_LEVEL, TRUE,FALSE}};
    PDWORD                      pdwTagType;
    DWORD                       dwNumTags = 2, dwNumArg, i, dwAddr;


    if (dwCurrentIndex >= dwArgCount)
    {
        //
        // No arguments specified
        //

        return ERROR_SHOW_USAGE;
    }

    dwNumArg = dwArgCount - dwCurrentIndex;

    pdwTagType = HeapAlloc(GetProcessHeap(),
                           0,
                           dwNumArg * sizeof(DWORD));

    if (pdwTagType is NULL)
    {
        DisplayMessage(g_hModule, MSG_IP_NOT_ENOUGH_MEMORY);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    dwErr = MatchTagsInCmdLine(g_hModule, ppwcArguments,
                        dwCurrentIndex,
                        dwArgCount,
                        pttTags,
                        dwNumTags,
                        pdwTagType);

    if (dwErr isnot NO_ERROR)
    {
        HeapFree(GetProcessHeap(),0,pdwTagType);
        if (dwErr is ERROR_INVALID_OPTION_TAG)
        {
            return ERROR_INVALID_SYNTAX; // show usage
        } 
        return dwErr;
    }

    for ( i = 0, dwPrefIndex = 0; i < dwNumArg; i++)
    {
        switch (pdwTagType[i])
        {
            case 0: // PROTOCOL

                dwRes = MatchRoutingProtoTag(ppwcArguments[i + dwCurrentIndex]);

                if (dwRes == (DWORD) -1)
                {
                    DispTokenErrMsg(g_hModule, MSG_IP_BAD_OPTION_VALUE,
                                    pttTags[pdwTagType[i]].pwszTag,
                                    ppwcArguments[i + dwCurrentIndex]);
                    i = dwNumArg;
                    dwErr = ERROR_SUPPRESS_OUTPUT;
                    break;
                }

                pm.dwProtocolId = dwRes;

                //
                // Get the metric too
                //

                if (pdwTagType[i+1] == 1)
                {
                    pm.dwMetric =
                        wcstoul(ppwcArguments[i + 1 +dwCurrentIndex],NULL,10);

                    if (pm.dwMetric==0 
                        && wcscmp(ppwcArguments[i + 1 +dwCurrentIndex], L"0")!=0)
                    {
                        dwErr = ERROR_INVALID_SYNTAX;
                        i = dwNumArg;
                        break;
                    }

                    i++;
                    dwPrefIndex++;
                }
                else
                {
                    dwErr = ERROR_INVALID_SYNTAX;
                    i = dwNumArg;
                    break;
                }

                break;

            default :
                i = dwNumArg;
                dwErr = ERROR_INVALID_SYNTAX;
                break;
        }
    }


    HeapFree(GetProcessHeap(), 0, pdwTagType);

    switch(dwErr)
    {
        case NO_ERROR :
            break;

        default:
            return dwErr;
    }

    dwErr = SetRoutePrefLevel(pm);

    return dwErr;
}


DWORD
HandleIpSetLogLevel(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description:

    Gets options for setting global parameter namely logging level

Arguments:

    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg 

Return Value:

    NO_ERROR
    
--*/
{
    DWORD                       dwErr = NO_ERROR;
    TAG_TYPE                    pttTags[] = {{TOKEN_LOG_LEVEL,TRUE,FALSE}};
    PDWORD                      pdwTagType;
    DWORD                       dwNumTags = 1, dwNumArg, i, dwAddr;
    DWORD                       dwLoggingLevel = (DWORD) -1;
    BOOL                        bOkay = TRUE;
    
    if (dwCurrentIndex >= dwArgCount)
    {
        //
        // No arguments specified
        //

        return ERROR_SHOW_USAGE;
    }

    dwNumArg = dwArgCount - dwCurrentIndex;

    pdwTagType = HeapAlloc(GetProcessHeap(),
                           0,
                           dwNumArg * sizeof(DWORD));

    if (pdwTagType is NULL)
    {
        DisplayMessage(g_hModule, MSG_IP_NOT_ENOUGH_MEMORY);
        return ERROR_SUPPRESS_OUTPUT;
    }

    dwErr = MatchTagsInCmdLine(g_hModule, ppwcArguments,
                        dwCurrentIndex,
                        dwArgCount,
                        pttTags,
                        dwNumTags,
                        pdwTagType);

    if (dwErr isnot NO_ERROR)
    {
        HeapFree(GetProcessHeap(),0,pdwTagType);
        if (dwErr is ERROR_INVALID_OPTION_TAG)
        {
            return ERROR_INVALID_SYNTAX;
        }
        return dwErr;
    }

    for ( i = 0; i < dwNumArg; i++)
    {
        switch (pdwTagType[i])
        {
            case 0: // LOGLEVEL
            {
                TOKEN_VALUE    rgEnums[] = 
                    {{TOKEN_VALUE_NONE, IPRTR_LOGGING_NONE},
                     {TOKEN_VALUE_ERROR, IPRTR_LOGGING_ERROR},
                     {TOKEN_VALUE_WARN, IPRTR_LOGGING_WARN},
                     {TOKEN_VALUE_INFO, IPRTR_LOGGING_INFO}};

                dwErr = MatchEnumTag(g_hModule,
                                     ppwcArguments[i + dwCurrentIndex],
                                     sizeof(rgEnums)/sizeof(TOKEN_VALUE),
                                     rgEnums,
                                     &dwLoggingLevel);

                if (dwErr != NO_ERROR)
                {
                    DispTokenErrMsg(g_hModule, 
                                    MSG_IP_BAD_OPTION_VALUE,
                                    pttTags[pdwTagType[i]].pwszTag,
                                    ppwcArguments[i + dwCurrentIndex]);

                    DisplayMessage( g_hModule,
                                    MSG_IP_BAD_OPTION_ENUMERATION,
                                    pttTags[pdwTagType[i]].pwszTag );
                    
                    for (i=0; i<4; i++) 
                    {
                        DisplayMessageT( L"  %1!s!\n", rgEnums[i].pwszToken );
                    }

                    i = dwNumArg;

                    dwErr = ERROR_SUPPRESS_OUTPUT;
    
                    bOkay = FALSE;

                    break;
                }

                break;
            }

            default :
            {
                i = dwNumArg;

                dwErr = ERROR_INVALID_SYNTAX;

                break;
            }
        }
    }


    HeapFree(GetProcessHeap(), 0, pdwTagType);

    switch(dwErr)
    {
        case NO_ERROR :
            break;

        default:
            return dwErr;
    }

    if (!bOkay)
    {
        return NO_ERROR;
    }

    dwErr = SetGlobalConfigInfo(dwLoggingLevel);

    return dwErr;
}

DWORD
HandleIpSetIfFilter(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )

/*++

Routine Description:

    Gets options for setting interface filter parameters

Arguments:

    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg 

Return Value:

    NO_ERROR
    
--*/
{
    DWORD              dwNumParsed = 0;
    DWORD              dwErr = NO_ERROR,dwRes;
    TAG_TYPE           pttTags[] = {{TOKEN_NAME,TRUE,FALSE},
                                    {TOKEN_FILTER_TYPE,FALSE,FALSE},
                                    {TOKEN_ACTION,FALSE,FALSE},
                                    {TOKEN_FRAGCHECK,FALSE,FALSE}};
    PDWORD             pdwTagType;
    DWORD              dwNumOpt;
    DWORD              dwNumTags = 4, dwNumArg, i, j;
    WCHAR              wszIfName[MAX_INTERFACE_NAME_LEN + 1] = L"\0";
    DWORD              dwFilterType, dwAction;
    BOOL               bFragCheck, bOkay = TRUE;
    
    if (dwCurrentIndex >= dwArgCount)
    {
        //
        // No arguments specified
        //

        return ERROR_SHOW_USAGE;
    }

    dwNumArg = dwArgCount - dwCurrentIndex;

    pdwTagType = HeapAlloc(GetProcessHeap(),
                           0,
                           dwNumArg * sizeof(DWORD));

    if (pdwTagType is NULL)
    {
        DisplayMessage(g_hModule, MSG_IP_NOT_ENOUGH_MEMORY);

        return ERROR_SUPPRESS_OUTPUT;
    }

    dwErr = MatchTagsInCmdLine(g_hModule, ppwcArguments,
                        dwCurrentIndex,
                        dwArgCount,
                        pttTags,
                        dwNumTags,
                        pdwTagType);

    if (dwErr isnot NO_ERROR)
    {
        HeapFree(GetProcessHeap(),0,pdwTagType);
        if (dwErr is ERROR_INVALID_OPTION_TAG)
        {
            return ERROR_INVALID_SYNTAX; // show usage
        }
        return dwErr;
    }

    for ( i = 0; i < dwNumArg; i++)
    {
        switch (pdwTagType[i])
        {
            case 0 :
            {
                DWORD BufLen = sizeof(wszIfName);
                GetInterfaceName(ppwcArguments[i + dwCurrentIndex],
                                 wszIfName,
                                 BufLen,
                                 &dwNumParsed);
    
                // no filters allowed on INTERNAL/LOOPBACK interfaces
                if (!_wcsicmp(wszIfName, L"internal") or
                    !_wcsicmp(wszIfName, L"loopback"))
                {
                    DisplayMessage(g_hModule,
                                   MSG_IP_BAD_INTERFACE_TYPE,
                                   wszIfName);
                    dwErr = ERROR_SUPPRESS_OUTPUT;
                    i = dwNumArg;
                }
                    
                break;
            }

            case 1:
            {
                TOKEN_VALUE    rgEnums[] =
                    {{TOKEN_VALUE_INPUT, IP_IN_FILTER_INFO},
                     {TOKEN_VALUE_OUTPUT, IP_OUT_FILTER_INFO},
                     {TOKEN_VALUE_DIAL, IP_DEMAND_DIAL_FILTER_INFO}};

                //
                // Tag TYPE
                //

                dwErr = MatchEnumTag(g_hModule,
                                     ppwcArguments[i + dwCurrentIndex],
                                     sizeof(rgEnums)/sizeof(TOKEN_VALUE),
                                     rgEnums,
                                     &dwFilterType);

                if (dwErr != NO_ERROR)
                {
                    DispTokenErrMsg(g_hModule, MSG_IP_BAD_OPTION_VALUE,
                                    pttTags[pdwTagType[i]].pwszTag,
                                    ppwcArguments[i + dwCurrentIndex]);

                    DisplayMessage( g_hModule,
                                    MSG_IP_BAD_OPTION_ENUMERATION,
                                    pttTags[pdwTagType[i]].pwszTag );
                    
                    for (i=0; i<sizeof(rgEnums)/sizeof(TOKEN_VALUE); i++) 
                    {
                        DisplayMessageT( L"  %1!s!\n", rgEnums[i].pwszToken );
                    }

                    i = dwNumArg;
                    bOkay = FALSE;
                    dwErr = ERROR_SUPPRESS_OUTPUT;
                    break;
                }    

                break;
            }

            case 2:
            {
                TOKEN_VALUE    rgEnums[] = 
                    {{TOKEN_VALUE_DROP, PF_ACTION_DROP},
                     {TOKEN_VALUE_FORWARD, PF_ACTION_FORWARD}};

                //
                // Tag ACTION
                //

                dwErr = MatchEnumTag(g_hModule,
                                     ppwcArguments[i + dwCurrentIndex],
                                     sizeof(rgEnums)/sizeof(TOKEN_VALUE),
                                     rgEnums,
                                     &dwAction);

                if (dwErr != NO_ERROR)
                {
                    DispTokenErrMsg(g_hModule, 
                                    MSG_IP_BAD_OPTION_VALUE,
                                    pttTags[pdwTagType[i]].pwszTag,
                                    ppwcArguments[i + dwCurrentIndex]);

                    DisplayMessage( g_hModule,
                                    MSG_IP_BAD_OPTION_ENUMERATION,
                                    pttTags[pdwTagType[i]].pwszTag );
                    
                    for (i=0; i<sizeof(rgEnums)/sizeof(TOKEN_VALUE); i++) 
                    {
                        DisplayMessageT( L"  %1!s!\n", rgEnums[i].pwszToken );
                    }

                    i = dwNumArg;

                    dwErr = ERROR_SUPPRESS_OUTPUT;
                    bOkay = FALSE;

                    break;
                }    

                break;
            }

            case 3:
            {
                TOKEN_VALUE    rgEnums[] =
                    {{TOKEN_VALUE_ENABLE, TRUE},
                     {TOKEN_VALUE_DISABLE, FALSE}};

                //
                // TAG = FRAGCHK
                //

                dwErr = MatchEnumTag(g_hModule,
                                     ppwcArguments[i + dwCurrentIndex],
                                     sizeof(rgEnums)/sizeof(TOKEN_VALUE),
                                     rgEnums,
                                     &dwRes);

                
                if (dwErr != NO_ERROR)
                {
                    DispTokenErrMsg(g_hModule, 
                                    MSG_IP_BAD_OPTION_VALUE,
                                    pttTags[pdwTagType[i]].pwszTag,
                                    ppwcArguments[i + dwCurrentIndex]);

                    DisplayMessage( g_hModule,
                                    MSG_IP_BAD_OPTION_ENUMERATION,
                                    pttTags[pdwTagType[i]].pwszTag );
                    
                    for (i=0; i<sizeof(rgEnums)/sizeof(TOKEN_VALUE); i++) 
                    {
                        DisplayMessageT( L"  %1!s!\n", rgEnums[i].pwszToken );
                    }

                    i = dwNumArg;

                    dwErr = ERROR_SUPPRESS_OUTPUT;
                    bOkay = FALSE;

                    break;
                }    

                bFragCheck = (dwRes) ? TRUE : FALSE;
                
                break;
            }

            default:
            {
                i = dwNumArg;

                dwErr = ERROR_INVALID_SYNTAX;

                break;
            }
        }
    }

    HeapFree(GetProcessHeap(), 0, pdwTagType);

    switch(dwErr)
    {
        case NO_ERROR :
            break;

        default:
            return dwErr;
    }

    if (!bOkay)
    {
        return NO_ERROR;
    }

    if (!pttTags[0].bPresent ||
        (pttTags[1].bPresent && !pttTags[2].bPresent) ||
        (!pttTags[1].bPresent && pttTags[2].bPresent))
    {
       return ERROR_INVALID_SYNTAX; // show usage
    }

    if (pttTags[3].bPresent)
    {
        dwErr = SetFragCheckInfo(wszIfName, bFragCheck);
    }

    if (dwErr isnot NO_ERROR)
    {
        return dwErr;
    }
    
    if (pttTags[1].bPresent)
    {
        dwErr = SetFilterInfo(wszIfName, dwFilterType, dwAction);
    }

    return dwErr;
}

DWORD
IpAddSetDelInterface(
    PWCHAR    *ppwcArguments,
    DWORD      dwCurrentIndex,
    DWORD      dwArgCount,
    DWORD      dwAction
    )

/*++

Routine Description:

    Gets options for setting interface parameters

Arguments:

    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg 

Return Value:

    NO_ERROR
    
--*/

{
    DWORD              dwBitVector = 0, dwNumParsed = 0;
    DWORD              dwErr = NO_ERROR, dwRes;
    TAG_TYPE           pttTags[] = {
        {TOKEN_NAME,             TRUE, FALSE},
        {TOKEN_STATUS,           FALSE,FALSE}};
    BOOL               bOkay = TRUE;
    DWORD              pdwTagType[sizeof(pttTags)/sizeof(TAG_TYPE)];
    DWORD              dwNumOpt;
    DWORD              dwStatus = IF_ADMIN_STATUS_UP;
    DWORD              dwNumTags = 2, dwNumArg, i, j;
    WCHAR              wszIfName[MAX_INTERFACE_NAME_LEN + 1] = L"\0";
    DWORD   dwMaxArgs = (dwAction is DELETE_COMMAND)? 1 
                         : sizeof(pttTags)/sizeof(TAG_TYPE);

    // Do generic processing

    dwErr = PreHandleCommand( ppwcArguments,
                              dwCurrentIndex,
                              dwArgCount,
                              pttTags,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              1,
                              dwMaxArgs,
                              pdwTagType );

    if (dwErr)
    {
        return dwErr;
    }

    dwNumArg = dwArgCount - dwCurrentIndex;

    for (i=0; i<dwNumArg; i++)
    {
        switch (pdwTagType[i])
        {
            case 0: // NAME
            {
                DWORD BufLen = sizeof(wszIfName);
                GetInterfaceName(ppwcArguments[i + dwCurrentIndex],
                                 wszIfName,
                                 BufLen,
                                 &dwNumParsed);
                break;
            }

            case 1: // STATE
            {
                TOKEN_VALUE    rgEnums[] = 
                    {{TOKEN_VALUE_ENABLE, IF_ADMIN_STATUS_UP},
                     {TOKEN_VALUE_DISABLE, IF_ADMIN_STATUS_DOWN}};

                dwErr = MatchEnumTag(g_hModule,
                                     ppwcArguments[i + dwCurrentIndex],
                                     sizeof(rgEnums)/sizeof(TOKEN_VALUE),
                                     rgEnums,
                                     &dwStatus);

                if (dwErr isnot NO_ERROR)
                {
                    DispTokenErrMsg(g_hModule, 
                                    MSG_IP_BAD_OPTION_VALUE,
                                    pttTags[pdwTagType[i]].pwszTag,
                                    ppwcArguments[i + dwCurrentIndex]);

                    DisplayMessage( g_hModule,
                                    MSG_IP_BAD_OPTION_ENUMERATION,
                                    pttTags[pdwTagType[i]].pwszTag );
                    
                    for (i=0; i<sizeof(rgEnums)/sizeof(TOKEN_VALUE); i++) 
                    {
                        DisplayMessageT( L"  %1!s!\n", rgEnums[i].pwszToken );
                    }

                    i = dwNumArg;

                    dwErr = ERROR_SUPPRESS_OUTPUT;
                    bOkay = FALSE;

                    break;
                }    

                break;
            }
        }
    }

    if (!bOkay)
    {
        return NO_ERROR;
    }

    if (dwAction is DELETE_COMMAND)
    {
        dwErr = DeleteInterfaceInfo(wszIfName);
        if (dwErr isnot NO_ERROR)
        {
            return dwErr;
        }
        return ERROR_OKAY;
    }

    if (dwStatus is IF_ADMIN_STATUS_DOWN)
    {
        DWORD dwIfType;

        // Make sure we support disabling this interface

        dwErr = GetInterfaceInfo(wszIfName, NULL, NULL, &dwIfType);

        if (dwErr == NO_ERROR)
        {
            if (dwIfType isnot ROUTER_IF_TYPE_DEDICATED)
            {
                DisplayMessage( g_hModule, MSG_IP_CANT_DISABLE_INTERFACE );
                return ERROR_SUPPRESS_OUTPUT;
            }
        }
    }

    if (dwAction is ADD_COMMAND)
    {
        dwErr = AddInterfaceInfo(wszIfName);
    }

    dwErr = UpdateInterfaceStatusInfo(dwAction,
                                      wszIfName,
                                      dwStatus);
    
    if (dwErr isnot NO_ERROR)
    {
        return dwErr;
    }

    return ERROR_OKAY;
}

DWORD
HandleIpAddInterface(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )

{
    return IpAddSetDelInterface( ppwcArguments, 
                                 dwCurrentIndex, 
                                 dwArgCount, 
                                 ADD_COMMAND);
}

DWORD
HandleIpSetInterface(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )

{
    return IpAddSetDelInterface( ppwcArguments, 
                                 dwCurrentIndex, 
                                 dwArgCount, 
                                 SET_COMMAND );
}

DWORD
HandleIpDelInterface(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )

{
    return IpAddSetDelInterface( ppwcArguments, 
                                 dwCurrentIndex, 
                                 dwArgCount, 
                                 DELETE_COMMAND);
}

DWORD
HandleIpShowRoutePref(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )

/*++

Routine Description:


Arguments:

    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg 

Return Value:

    NO_ERROR
    
--*/
{
    //
    // No options expected
    //

    return ShowRoutePref(NULL);
}


DWORD
HandleIpShowLogLevel(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )

/*++

Routine Description:

Arguments:

    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg 

Return Value:

    NO_ERROR
    
--*/
{
    //
    // No options expected
    //

    if (dwCurrentIndex != dwArgCount)
    {
        return ERROR_SHOW_USAGE;
    }
    
    return ShowIpGlobal(NULL);
}

DWORD
HandleIpShowProtocol(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )

/*++

Routine Description:

Arguments:

    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg 

Return Value:

    NO_ERROR
    
--*/
{
    //
    // No options expected
    //

    return ShowIpProtocol();
}

DWORD
IpShowSingleInterfaceInfo(
    IN     LPCWSTR   pwszInterfaceName,
    IN     DWORD     dwInfoType,
    IN     DWORD     dwFormat,
    IN OUT PDWORD    pdwNumRows
    )
{
    switch(dwInfoType)
    {
        case SHOW_IF_FILTER:
        {
            return ShowIpIfFilter(NULL, dwFormat, pwszInterfaceName, pdwNumRows);
        }

        case SHOW_INTERFACE:
        {
            return ShowIpInterface(dwFormat, pwszInterfaceName, pdwNumRows);
        }

        case SHOW_PERSISTENTROUTE:
        {
            return ShowIpPersistentRoute(NULL, pwszInterfaceName, pdwNumRows);
        }

        default:
        {
            return ERROR_INVALID_PARAMETER;
        }
    }
}

DWORD
IpShowInterfaceInfo(
    PWCHAR    *ppwcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwInfoType
    )
/*++

Routine Description:

    Gets options for showing various interface information
    
Arguments:

    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg 
    dwInfoType      - The type of info to display

Return Value:

    NO_ERROR
    
--*/
{    
    DWORD       dwErr, dwTotal;
    TAG_TYPE    pttTags[] = {{TOKEN_NAME,FALSE,FALSE}};
    WCHAR       wszInterfaceName[MAX_INTERFACE_NAME_LEN + 1] = L"\0";
    DWORD       rgdwTagType[sizeof(pttTags)/sizeof(TAG_TYPE)];
    DWORD       dwCount, i, j, dwNumOpt;
    DWORD       dwNumTags = 1, dwNumArg, dwNumParsed;
    DWORD       dwSize, dwRes, dwNumRows = 0;
    PMPR_INTERFACE_0 pmi0;

    // Do generic processing

    dwErr = PreHandleCommand( ppwcArguments,
                              dwCurrentIndex,
                              dwArgCount,
                              pttTags,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              0,
                              1,
                              rgdwTagType );
                              
    if (dwErr isnot NO_ERROR)
    {
        return dwErr;
    }

    // If interface specified, show info for specified interface only.

    for (i=0; i<dwArgCount-dwCurrentIndex; i++)
    {
        switch (rgdwTagType[i])
        {
            case 0: // NAME
            {
                DWORD BufLen = sizeof(wszInterfaceName);
                GetInterfaceName( ppwcArguments[i + dwCurrentIndex],
                                  wszInterfaceName,
                                  BufLen,
                                  &dwNumParsed);

                dwErr = IpShowSingleInterfaceInfo(wszInterfaceName, 
                                                  dwInfoType,
                                                  FORMAT_VERBOSE,
                                                  &dwNumRows);

                if (!dwNumRows)
                {
                    DisplayMessage( g_hModule, MSG_IP_NO_ENTRIES );
                    dwErr = ERROR_SUPPRESS_OUTPUT;
                }

                return dwErr;
            }
        }
    }

    // No Interface specified.  Enumerate interfaces and show
    // info for each interface.

    dwErr = IpmontrInterfaceEnum((PBYTE *) &pmi0, &dwCount, &dwTotal);
    if (dwErr isnot NO_ERROR)
    {
        return dwErr;
    }

    for (i=0; i<dwCount && dwErr is NO_ERROR; i++)
    {
        dwErr = IpShowSingleInterfaceInfo( pmi0[i].wszInterfaceName, 
                                           dwInfoType,
                                           FORMAT_TABLE,
                                           &dwNumRows );
        if (dwErr is ERROR_NO_SUCH_INTERFACE)
        {
            dwErr = NO_ERROR;
        }
    }

    if (!dwNumRows)
    {
        DisplayMessage( g_hModule, MSG_IP_NO_ENTRIES );
    }

    return dwErr;
}

DWORD
HandleIpShowIfFilter(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )

/*++

Routine Description:

Arguments:

    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg 

Return Value:

    NO_ERROR
    
--*/

{
    return IpShowInterfaceInfo(ppwcArguments,
                               dwCurrentIndex,
                               dwArgCount,
                               SHOW_IF_FILTER);
}

DWORD
HandleIpShowInterface(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )


/*++

Routine Description:

Arguments:

    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg 

Return Value:

    NO_ERROR
    
--*/

{
    return IpShowInterfaceInfo(ppwcArguments,
                               dwCurrentIndex,
                               dwArgCount,
                               SHOW_INTERFACE);
}

DWORD
HandleIpShowPersistentRoute(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )


/*++

Routine Description:

    Handler for show ip route. We just call the main interface info display
    handler

Arguments:

    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg

Return Value:

    NO_ERROR

--*/

{
    DisplayMessage(g_hModule, MSG_IP_PERSISTENT_CONFIG);

    return IpShowInterfaceInfo(ppwcArguments,
                               dwCurrentIndex,
                               dwArgCount,
                               SHOW_PERSISTENTROUTE);
}


#ifdef KSL_IPINIP
DWORD
HandleIpAddIpIpTunnel(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )

/*++

Routine Description:

Arguments:

    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg

Return Value:

    NO_ERROR

--*/

{
    return IpAddSetIpIpTunnel(ppwcArguments,
                              dwCurrentIndex,
                              dwArgCount,
                              TRUE);
}

DWORD
HandleIpSetIpIpTunnel(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )

/*++

Routine Description:

Arguments:

    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg

Return Value:

    NO_ERROR

--*/

{
    return IpAddSetIpIpTunnel(ppwcArguments,
                              dwCurrentIndex,
                              dwArgCount,
                              FALSE);
}

DWORD
IpAddSetIpIpTunnel(
    PWCHAR    *ppwcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    BOOL      bAdd
    )

{
    DWORD       dwNumArgs, dwErr, dwNumParsed;

    TAG_TYPE    rgTags[] = {{TOKEN_NAME,      TRUE, FALSE},
                            {TOKEN_LOCALADDR, TRUE, FALSE},
                            {TOKEN_REMADDR,   TRUE, FALSE},
                            {TOKEN_TTL,       FALSE,FALSE}};

    WCHAR       rgwcIfName[MAX_INTERFACE_NAME_LEN + 1];
    DWORD       rgdwTagType[sizeof(rgTags)/sizeof(TAG_TYPE)];
    ULONG       i;
    PWCHAR      pwszIfName;

    IPINIP_CONFIG_INFO  ConfigInfo;

    dwNumArgs = dwArgCount - dwCurrentIndex;

    if((dwCurrentIndex > dwArgCount) or
       (dwNumArgs isnot 4))
    {
        //
        // No arguments specified
        //
        
        return ERROR_SHOW_USAGE;
    }

    dwErr = MatchTagsInCmdLine(g_hModule,
                               ppwcArguments,
                               dwCurrentIndex,
                               dwArgCount,
                               rgTags,
                               sizeof(rgTags)/sizeof(TAG_TYPE),
                               rgdwTagType);

    if (dwErr isnot NO_ERROR)
    {
        if (dwErr is ERROR_INVALID_OPTION_TAG)
        {
            return ERROR_INVALID_SYNTAX;
        }

        return dwErr;
    }

    for(i = 0; i < dwNumArgs; i ++)
    {
        switch (rgdwTagType[i])
        {
            case 0 : // NAME
            {
                DWORD BufLen = sizeof(rgwcIfName);
                dwErr = GetInterfaceName(ppwcArguments[i + dwCurrentIndex],
                                         rgwcIfName,
                                         BufLen,
                                         &dwNumParsed);

                if(bAdd)
                {
                    if(dwErr is NO_ERROR)
                    {
                        return ERROR_OBJECT_ALREADY_EXISTS;
                    }
 
                    pwszIfName = ppwcArguments[i + dwCurrentIndex];
                }
                else
                {
                    if(dwErr isnot NO_ERROR)
                    {
                        return dwErr;
                    }

                    pwszIfName = rgwcIfName;
                }

                break;
            }

            case 1:
            {
                //
                // Tag for localaddr
                //

                dwErr = GetIpAddress(ppwcArguments[i + dwCurrentIndex], 
                                     &ConfigInfo.dwLocalAddress);

                break;
            }

            case 2:
            {
                //
                // Tag for remoteaddr
                //

                dwErr = GetIpAddress(ppwcArguments[i + dwCurrentIndex], 
                                     &ConfigInfo.dwRemoteAddress);

                break;
            }

            case 3:
            {
                //
                // Tag for ttl
                //

                ConfigInfo.byTtl =
                    LOBYTE(LOWORD(wcstoul(ppwcArguments[i + dwCurrentIndex],
                                          NULL,
                                          10)));

                break;
            }

            default:
            {
                i = dwNumArgs;

                dwErr = ERROR_INVALID_SYNTAX;

                break;
            }
        }
    }

    switch(dwErr)
    {
        case NO_ERROR:
        {
            break;
        }

        default:
        {
            return dwErr;
        }
    }

    for(i = 0; i < dwNumArgs; i++)
    {
        if(!rgTags[i].bPresent)
        {
            DisplayMessage(g_hModule, 
                           MSG_CANT_FIND_EOPT);

            return ERROR_INVALID_SYNTAX;
        }
    }

    dwErr = AddSetIpIpTunnelInfo(pwszIfName,
                                 &ConfigInfo);

    return dwErr;
}
#endif //KSL_IPINIP 

DWORD
IpDump(
    IN  LPCWSTR     pwszRouter,
    IN  LPWSTR     *ppwcArguments,
    IN  DWORD       dwArgCount,
    IN  LPCVOID     pvData
    )
{
    DumpIpInformation((HANDLE)-1);

    return NO_ERROR;
}

#if 0
DWORD
HandleIpInstall(
    PWCHAR    pwszMachine,
    PWCHAR    *ppwcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    PVOID     pvData,
    BOOL      *pbDone
    )
{
    // XXX DLLPath, ProtocolId

    // XXX set default info here
    // global info block (what is this?)
    // protocol priority block (no need?)
    // multicast boundaries block (no need)

    return NO_ERROR;
}

DWORD
HandleIpUninstall(
    PWCHAR    pwszMachine,
    PWCHAR    *ppwcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    PVOID     pvData,
    BOOL      *pbDone
    )
{
    PMPR_INTERFACE_0  pmi0;
    DWORD             dwCount, dwTotal, i, dwErr;

    // Remove global info
    // XXX

    // Remove interface info
    
    dwErr = IpmontrInterfaceEnum((PBYTE *) &pmi0, &dwCount, &dwTotal);
    if (dwErr is NO_ERROR)
    {
        for (i=0; i<dwCount; i++)
        { 
            DeleteInterfaceInfo(pmi0[i].wszInterfaceName);
        }
    }

    return NO_ERROR;
}
#endif

DWORD
HandleIpReset(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    PMPR_INTERFACE_0  pmi0;
    DWORD             dwCount, dwTotal, i, dwErr, dwSize, dwBlkSize;
    DWORD             dwNumProtocols;
    GLOBAL_INFO       gi;
    PPRIORITY_INFO    pPriInfo;
    PPROTOCOL_METRIC  pProtocolMetrics;
    RTR_INFO_BLOCK_HEADER *pInfoHdr;
    RTR_INFO_BLOCK_HEADER *pLocalInfoHdr;

    PROTOCOL_METRIC   defaultProtocolMetrics[] = 
                            {
                                {PROTO_IP_LOCAL,                1},
                                {PROTO_IP_NT_STATIC,            3},
                                {PROTO_IP_NT_STATIC_NON_DOD,    5},
                                {PROTO_IP_NT_AUTOSTATIC,        7},
                                {PROTO_IP_NETMGMT,              10},
                                {PROTO_IP_OSPF,                 110},
                                {PROTO_IP_RIP,                  120}
                            };

    PROTOCOL_METRIC   defaultProtocolMetricsNT4[] = 
                            {
                                {PROTO_IP_LOCAL,                1},
                                {PROTO_IP_NETMGMT,              2},
                                {PROTO_IP_OSPF,                 3},
                                {PROTO_IP_RIP,                  4},
                                {PROTO_IP_IGMP,                 5}
                            };

    // delete all blocks except the IP_GLOBAL_INFO
    dwErr = ValidateGlobalInfo(&pInfoHdr);
    if (dwErr is NO_ERROR)
    {
        // Copy to a local buffer just in case the APIs modify it as we go
        dwSize = sizeof(RTR_INFO_BLOCK_HEADER) * pInfoHdr->TocEntriesCount;
        pLocalInfoHdr = MALLOC(dwSize);
        if (pLocalInfoHdr is NULL)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        memcpy(pLocalInfoHdr, pInfoHdr, dwSize);

        // Set Global and RoutePref info
        {
                dwBlkSize         = sizeof(GLOBAL_INFO);
                dwCount           = 1;
                gi.bFilteringOn   = FALSE;
                gi.dwLoggingLevel = IPRTR_LOGGING_ERROR;
                dwErr = IpmontrSetInfoBlockInGlobalInfo(IP_GLOBAL_INFO,
                                                 (PBYTE) &gi,
                                                 dwBlkSize,
                                                 dwCount);
        }

        {
                // Based on the router version, calculate the number 
                // of protocols etc.
                // TODO: currently assuming >=NT5. Should find out the router
                // version somehow
                dwNumProtocols    =
                    sizeof(defaultProtocolMetrics)/sizeof(PROTOCOL_METRIC);
                pProtocolMetrics  = defaultProtocolMetrics;

                dwBlkSize         = SIZEOF_PRIORITY_INFO(dwNumProtocols);
                dwCount           = 1;

                // Allocate buffer to hold the Priority Information
                pPriInfo = MALLOC(dwBlkSize);
                if (pPriInfo is NULL)
                {
                    return ERROR_NOT_ENOUGH_MEMORY;
                }

                pPriInfo->dwNumProtocols = dwNumProtocols; 
                memcpy(
                        pPriInfo->ppmProtocolMetric, 
                        pProtocolMetrics, 
                        dwNumProtocols * sizeof(PROTOCOL_METRIC));

                dwErr = IpmontrSetInfoBlockInGlobalInfo(IP_PROT_PRIORITY_INFO,
                                                 (PBYTE) pPriInfo,
                                                 dwBlkSize,
                                                 dwCount);

                FREE(pPriInfo); 
        }

        for (i=0; i<pLocalInfoHdr->TocEntriesCount; i++)
        {
            switch (pLocalInfoHdr->TocEntry[i].InfoType)
            {
            case IP_GLOBAL_INFO:
            case IP_PROT_PRIORITY_INFO:
                // already done
                break;

            default:
                IpmontrDeleteInfoBlockFromGlobalInfo(
                    pLocalInfoHdr->TocEntry[i].InfoType );
                break;
            }
        }

        FREE(pLocalInfoHdr);
    }

    // Delete all interface info
    dwErr = IpmontrInterfaceEnum((PBYTE *) &pmi0, &dwCount, &dwTotal);
    if (dwErr is NO_ERROR)
    {
        for (i=0; i<dwCount; i++)
        { 
            DeleteInterfaceInfo(pmi0[i].wszInterfaceName);
        }
    }

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ip\ipmon\mprip.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    routing\monitor2\ip\mprip.h

Abstract:

    Prototypes for functions exported by mprip.c

Revision History:

    Anand Mahalingam         7/29/98  Created

--*/


VOID
FreeInfoBuffer(
    IN  PVOID   pvBuffer
    );

DWORD
WINAPI
IpmontrDeleteInfoBlockFromGlobalInfo(
    IN  DWORD   dwRoutingProtId
    );

DWORD
WINAPI
IpmontrDeleteInfoBlockFromInterfaceInfo(
    IN  LPCWSTR  pwszIfName,
    IN  DWORD    dwRoutingProtId
    );

DWORD
WINAPI
IpmontrDeleteProtocol(
    IN  DWORD dwRoutingProtId
    );

DWORD
WINAPI
IpmontrGetInfoBlockFromGlobalInfo(
    IN  DWORD   dwType,
    OUT PBYTE   *ppbInfoBlk, OPTIONAL
    OUT PDWORD  pdwSize,
    OUT PDWORD  pdwCount
    );

DWORD
WINAPI
IpmontrGetInfoBlockFromInterfaceInfo(
    IN  LPCWSTR pwszIfName,
    IN  DWORD   dwType,
    OUT PBYTE   *ppbInfoBlk,
    OUT PDWORD  pdwSize,
    OUT PDWORD  pdwCount,
    OUT PDWORD  pdwIfType
    );

DWORD
WINAPI
IpmontrSetInfoBlockInGlobalInfo(
    IN    DWORD    dwType,
    IN    PBYTE    pbInfoBlk,
    IN    DWORD    dwSize,
    IN    DWORD    dwCount
    );

DWORD
WINAPI
IpmontrSetInfoBlockInInterfaceInfo(
    IN    LPCWSTR   pwszIfName,
    IN    DWORD     dwType,
    IN    PBYTE     pbInfoBlk,
    IN    DWORD     dwSize,
    IN    DWORD     dwCount
    );

DWORD WINAPI
IpmontrGetInterfaceType(
    IN    LPCWSTR   pwszIfName,
    OUT   PDWORD    pdwIfType
    );

DWORD 
WINAPI
GetInterfaceName(
    IN  LPCWSTR ptcArgument,
    OUT LPWSTR  pwszIfName,
    IN  DWORD   dwSizeOfIfName,
    OUT PDWORD  pdwNumParsed
    );

DWORD
WINAPI
GetInterfaceDescription(
    IN      LPCWSTR    pwszIfName,
    OUT     LPWSTR     pwszIfDesc,
    OUT     PDWORD     pdwNumParsed
    );

DWORD
WINAPI
InterfaceEnum(
    OUT    PBYTE               *ppb,
    OUT    PDWORD              pdwCount,
    OUT    PDWORD              pdwTotal
    );

DWORD
WINAPI
MatchRoutingProtoTag(
    IN  LPCWSTR pwszToken
    );

BOOL
WINAPI
IsRouterRunning(
    VOID
    );

DWORD
MibGet(
    DWORD   dwTransportId,
    DWORD   dwRoutingPid,
    LPVOID  lpInEntry,
    DWORD   dwInEntrySize,
    LPVOID *lplpOutEntry,
    LPDWORD lpdwOutEntrySize
    );

DWORD
MibGetFirst(
    DWORD   dwTransportId,
    DWORD   dwRoutingPid,
    LPVOID  lpInEntry,
    DWORD   dwInEntrySize,
    LPVOID *lplpOutEntry,
    LPDWORD lpdwOutEntrySize
    );

DWORD
MibGetNext(
    DWORD   dwTransportId,
    DWORD   dwRoutingPid,
    LPVOID  lpInEntry,
    DWORD   dwInEntrySize,
    LPVOID *lplpOutEntry,
    LPDWORD lpdwOutEntrySize
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ip\ipmon\mprip.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    routing\monitor2\ip\mprip.c

Abstract:

    Functions to modify transport header (global and interface)
    This file now contains all the function exported by ipmon.dll to
    the helpers

Revision History:

    Anand Mahalingam         7/29/98  Created
    AmritanR

--*/

#include "precomp.h"
#include <time.h>
#pragma hdrstop

#define MaxIfDisplayLength 1024
#define SetErrorType(pdw)   *(pdw) = IsRouterRunning()?ERROR_ADMIN:ERROR_CONFIG

BOOL    g_bRouterRunning;
ULONG   g_ulNumChecks;

VOID
FreeInfoBuffer(
    IN  PVOID   pvBuffer
    )
{
    HeapFree(GetProcessHeap(),
             0,
             pvBuffer);
    
}


DWORD
WINAPI
IpmontrSetInfoBlockInGlobalInfo(
    IN  DWORD   dwType,
    IN  PBYTE   pbInfoBlk,
    IN  DWORD   dwSize,
    IN  DWORD   dwCount
    )

/*++

Routine Description:

    Called to Set or Add an info block to the Global Info

Arguments:

    pbInfoBlk  - Info block to be added
    dwType     - Type of the info block
    dwSize     - Size of each item in the info block
    dwCount    - Number of items in the info block
    
Return Value:

    NO_ERROR
    
--*/

{
    PRTR_INFO_BLOCK_HEADER    pOldInfo, pNewInfo;
    DWORD                     dwErr;
   
    //
    // Get/update global info
    //
 
    dwErr = ValidateGlobalInfo(&pOldInfo);

    if(dwErr isnot NO_ERROR)
    {
        return dwErr;
    }

    if(MprInfoBlockExists(pOldInfo,
                          dwType))
    {   
        //
        // The block already exists. So call set to replace it
        //
        
        dwErr = MprInfoBlockSet(pOldInfo,
                                dwType,
                                dwSize,
                                dwCount,
                                pbInfoBlk,
                                &pNewInfo);
    }
    else
    {
        //
        // No info currently, add it
        //
        
        dwErr = MprInfoBlockAdd(pOldInfo,
                                dwType,
                                dwSize,
                                dwCount,
                                pbInfoBlk,
                                &pNewInfo);
    }

    //
    // Dont need the old info
    //
    
    FREE_BUFFER(pOldInfo);

    if(dwErr isnot NO_ERROR)
    {
        if(!g_bCommit)
        {
            g_tiTransport.pibhInfo = NULL;
            
            g_tiTransport.bValid   = FALSE;
        }
        
        return dwErr;
    }


    //
    // If in commit mode, set it to the router/registry
    // Otherwise update the local copy
    //

    if(g_bCommit)
    {
        dwErr = SetGlobalInfo(pNewInfo);

        FREE_BUFFER(pNewInfo);
    }
    else
    {
        ASSERT(g_tiTransport.bValid);

        g_tiTransport.pibhInfo = pNewInfo;

        dwErr = NO_ERROR;
    }

    return dwErr;
}

DWORD
WINAPI
IpmontrSetInfoBlockInInterfaceInfo(
    IN  LPCWSTR pwszIfName,
    IN  DWORD   dwType,
    IN  PBYTE   pbInfoBlk,
    IN  DWORD   dwSize,
    IN  DWORD   dwCount
    )

/*++

Routine Description:

    Adds or Sets and infoblock in the interface info

Arguments:

    pwszIfName - interface name
    pbInfoBlk  - Info block to be added
    dwType     - Type of the info block
    dwSize     - Size of each item in the info block
    dwCount    - Number of items in the info block
    
Return Value:

    NO_ERROR
    
--*/
{

    PRTR_INFO_BLOCK_HEADER    pOldInfo, pNewInfo;
    DWORD                     dwErr;
    PINTERFACE_STORE          pii;
    
    pii = NULL;
   
    //
    // Get/Update the interface info
    //
 
    dwErr = ValidateInterfaceInfo(pwszIfName,
                                  &pOldInfo,
                                  NULL,
                                  &pii);
            
    if(dwErr isnot NO_ERROR)
    {
        return dwErr;
    }


    if(MprInfoBlockExists(pOldInfo,
                          dwType))
    {
        //
        // The block already exists call Set to replace
        //

        dwErr = MprInfoBlockSet(pOldInfo,
                                dwType,
                                dwSize,
                                dwCount,
                                pbInfoBlk,
                                &pNewInfo);

    }
    else
    {
        dwErr = MprInfoBlockAdd(pOldInfo,
                                dwType,
                                dwSize,
                                dwCount,
                                pbInfoBlk,
                                &pNewInfo);
    }

    FREE_BUFFER(pOldInfo);

    if(dwErr isnot NO_ERROR)
    {
        //
        // Some error - invalidate info
        //

        if(!g_bCommit)
        {
            ASSERT(pii);
            ASSERT(pii->bValid);
        
            pii->pibhInfo = NULL;
            pii->bValid   = FALSE;
        }

        return dwErr;
    }

    if(g_bCommit)
    {
        //
        // Set to router/registry
        //

        dwErr = SetInterfaceInfo(pNewInfo,
                                 pwszIfName);

        FREE_BUFFER(pNewInfo);
    }
    else
    {
        //
        // Update local copy with new info (old one has been freed)
        //

        ASSERT(pii);
        ASSERT(pii->bValid);

        pii->pibhInfo = pNewInfo;
        pii->bValid   = TRUE;

        dwErr = NO_ERROR;
    }

    return dwErr;
}            


DWORD
WINAPI
IpmontrDeleteInfoBlockFromGlobalInfo(
    IN  DWORD   dwType
    )
    
/*++

Routine Description:

    Deletes an infoblock from the global info.
    The Infoblock is deleted by setting its Size and Count to 0

Arguments:

    dwType  - Id of Protocol to be added
    
Return Value:

    NO_ERROR
    
--*/

{
    DWORD                  dwErr = NO_ERROR;
    PRTR_INFO_BLOCK_HEADER pOldInfo, pNewInfo;

    dwErr = ValidateGlobalInfo(&pOldInfo);
    
    if(dwErr isnot NO_ERROR)
    {
        return dwErr;
    }
    
    if(!MprInfoBlockExists(pOldInfo,
                           dwType))
    {
        if(g_bCommit)
        {
            //
            // Arent saving a local copy so free this info
            //

            FREE_BUFFER(pOldInfo);
        }

        return NO_ERROR;
    }

    //
    // The router manager will only delete config info if we set
    // the size to 0.  However, we don't want to write 0-size
    // blocks to the registry, so we will strip them out when
    // we write to the registry.
    //

    dwErr = MprInfoBlockSet(pOldInfo,
                            dwType,
                            0,
                            0,
                            NULL,
                            &pNewInfo);

    FREE_BUFFER(pOldInfo);

    if(dwErr isnot NO_ERROR)
    {
        if(!g_bCommit)
        {
            ASSERT(g_tiTransport.bValid);

            g_tiTransport.pibhInfo = NULL;
            g_tiTransport.bValid   = FALSE;
        }
            
        return dwErr;
    }

    if(g_bCommit)
    {
        dwErr = SetGlobalInfo(pNewInfo);

        FREE_BUFFER(pNewInfo);
    }
    else
    {
        ASSERT(g_tiTransport.bValid);
        
        g_tiTransport.pibhInfo = pNewInfo;

        dwErr = NO_ERROR;
    }
    
    return dwErr;
}

DWORD
WINAPI
IpmontrDeleteInfoBlockFromInterfaceInfo(
    IN  LPCWSTR pwszIfName,
    IN  DWORD   dwType
    )
    
/*++

Routine Description:

    Deletes an info block from the interface info. The info block is
    deleted by setting its Size and Count to 0

Arguments:

    pwszIfName       - Interface on which to add the protocol
    dwType  - Id of Protocol to be added
    
Return Value:

    NO_ERROR
    
--*/

{
    DWORD                  dwErr;
    PRTR_INFO_BLOCK_HEADER pOldInfo, pNewInfo;
    PINTERFACE_STORE       pii;
   
    pii = NULL;

    dwErr = ValidateInterfaceInfo(pwszIfName,
                                  &pOldInfo,
                                  NULL,
                                  &pii);
            
    if (dwErr isnot NO_ERROR)
    {
        return dwErr;
    }

    if(!MprInfoBlockExists(pOldInfo,
                           dwType))
    {
        if (g_bCommit)
        {
            FREE_BUFFER(pOldInfo);
        }
        
        return NO_ERROR;
    }

    //
    // If it does exist, remove it
    // This creates a new block
    // HACKHACK - Again we can interchangeably use info that is allocated
    // by GetXxx functions and MprInfoBlock functions since both allocations
    // are from ProcessHeap()
    //

    //
    // The router manager will only delete config info if we set
    // the size to 0.  However, we don't want to write 0-size
    // blocks to the registry, so we will strip them out when
    // we write to the registry.
    //

    dwErr = MprInfoBlockSet(pOldInfo,
                            dwType,
                            0,
                            0,
                            NULL,
                            &pNewInfo);

    //
    // One way or another, done with the old info
    //

    FREE_BUFFER(pOldInfo);

    if(dwErr isnot NO_ERROR)
    {
        if(!g_bCommit)
        {
            ASSERT(pii);
            ASSERT(pii->bValid);
        
            pii->pibhInfo = NULL;
            pii->bValid   = FALSE;
        }

        return dwErr;
    }

    if(g_bCommit)
    {
        dwErr = SetInterfaceInfo(pNewInfo,
                                 pwszIfName);

        FREE_BUFFER(pNewInfo);
    }
    else
    {
        ASSERT(pii);
        ASSERT(pii->bValid);

        pii->pibhInfo = pNewInfo;
        pii->bValid   = TRUE;

        dwErr = NO_ERROR;
    }

    return dwErr;
}

DWORD
WINAPI
IpmontrDeleteProtocol(
    IN  DWORD   dwProtoId
    )

/*++

Routine Description:

    Deletes Protocol from a transport

Arguments:

    dwProtoId   - Id of Protocol to be deleted

Return Value:

    NO_ERROR

--*/

{
    DWORD               dwRes;
    PMPR_INTERFACE_0    pmi0;
    DWORD               dwCnt, dwTot, dwInd, dwCount, dwErrType;

    SetErrorType(&dwErrType);

    do
    {
        //
        // Protocol being deleted globally, so remove from
        // all interfaces.
        //

        dwRes = IpmontrInterfaceEnum((PBYTE *) &pmi0,
                              &dwCnt,
                              &dwTot);

        if(dwRes != NO_ERROR)
        {
            DisplayMessage(g_hModule, dwErrType, dwRes);
            break;
        }

        if (pmi0 == NULL)
        {
            dwCnt = 0;
        }

        for (dwInd = 0; dwInd < dwCnt; dwInd++)
        {
            
            dwRes =
                IpmontrDeleteInfoBlockFromInterfaceInfo(pmi0[dwInd].wszInterfaceName,
                                                 dwProtoId);

            if (dwRes is ERROR_NOT_ENOUGH_MEMORY)
            {
                break;
            }
        }

        //
        // Remove protocol from global info
        //
        
        dwRes = IpmontrDeleteInfoBlockFromGlobalInfo(dwProtoId);

        if (dwRes != NO_ERROR)
        {
            break;
        }

    } while(FALSE);

    if (pmi0)
    {
        HeapFree(GetProcessHeap(), 0, pmi0);
    }

    return dwRes;
}


DWORD
WINAPI
IpmontrGetInfoBlockFromGlobalInfo(
    IN  DWORD   dwType,
    OUT BYTE    **ppbInfoBlk, OPTIONAL
    OUT PDWORD  pdwSize,      OPTIONAL
    OUT PDWORD  pdwCount      OPTIONAL
    )

/*++

Routine Description:

    Gets the info block from global info. If we get a zero sized block
    we return ERROR_NOT_FOUND so as to not configure the caller

Arguments:

    dwType     - Type of the info block
    ppbInfoBlk - ptr to info block
    pdwSize    - size of each item in block
    pdwCount   - number of items in block
    
Return Value:

    NO_ERROR
    ERROR_NOT_FOUND if the block doesnt exist.
    
--*/

{

    PRTR_INFO_BLOCK_HEADER    pInfo;
    DWORD                     dwErr;
    BOOL                      *pbValid;
    PBYTE                     pbyTmp = NULL;
    DWORD                     dwSize, dwCnt;

    if(ppbInfoBlk)
    {
        *ppbInfoBlk = NULL;
    }

    if(pdwSize)
    {
        *pdwSize = 0;
    }

    if(pdwCount)
    {
        *pdwCount = 0;
    }

    dwErr = ValidateGlobalInfo(&pInfo);
    
    if(dwErr isnot NO_ERROR)
    {
        return dwErr;
    }
    
    dwErr = MprInfoBlockFind(pInfo,
                             dwType,
                             &dwSize,
                             &dwCnt,
                             &pbyTmp);

    if(dwErr is NO_ERROR)
    {
        if(dwSize is 0)
        {
            if(g_bCommit)
            {
                FREE_BUFFER(pInfo);
            }

            return ERROR_NOT_FOUND;
        }

        if(ppbInfoBlk)
        {
            *ppbInfoBlk = HeapAlloc(GetProcessHeap(),
                                    0,
                                    dwSize * dwCnt);

            if(*ppbInfoBlk is NULL)
            {
                if(g_bCommit)
                {
                    FREE_BUFFER(pInfo);
                }
                
                return ERROR_NOT_ENOUGH_MEMORY;
            }
            
            CopyMemory(*ppbInfoBlk,
                       pbyTmp,
                       dwSize * dwCnt);
        }
            
        if(pdwSize)
        {
            *pdwSize = dwSize;
        }
        
        if(pdwCount)
        {
            *pdwCount = dwCnt;
        }
    }

    if(g_bCommit)
    {
        FREE_BUFFER(pInfo);
    }
        
    return dwErr;
}

DWORD
WINAPI
IpmontrGetInfoBlockFromInterfaceInfo(
    IN  LPCWSTR pwszIfName,
    IN  DWORD   dwType,
    OUT BYTE    **ppbInfoBlk,   OPTIONAL
    OUT PDWORD  pdwSize,        OPTIONAL
    OUT PDWORD  pdwCount,       OPTIONAL
    OUT PDWORD  pdwIfType       OPTIONAL
    )

/*++

Routine Description:

    Gets the info block from interface transport header

Arguments:

    pwszIfName - Interface Name
    dwType     - Type of the info block
    ppbInfoBlk - ptr to info block
    pdwSize    - size of each item in block
    pdwCount   - number of items in block
    pdwIfType  - interface type
    
Return Value:

    NO_ERROR
    ERROR_NOT_FOUND
    
--*/
{
    PRTR_INFO_BLOCK_HEADER    pInfo, *ppInfo;
    
    DWORD   dwErr;
    PBYTE   pbTmp, pbyTmp;
    DWORD   dwSize, dwCount;

    if(ppbInfoBlk)
    {
        *ppbInfoBlk = NULL;
    }

    if(pdwSize)
    {
        *pdwSize = 0;
    }

    if(pdwCount)
    {
        *pdwCount = 0;
    }

    //
    // If the user doesnt want any info, size or count, then we can optimize 
    // a bit by passing NULL to validate
    //

    if(((ULONG_PTR)ppbInfoBlk | (ULONG_PTR)pdwSize | (ULONG_PTR)pdwCount))
    {
        ppInfo = &pInfo;
    }
    else
    {
        ppInfo = NULL;
    }

    dwErr = ValidateInterfaceInfo(pwszIfName,
                                  ppInfo,
                                  pdwIfType,
                                  NULL);
            
    if((dwErr isnot NO_ERROR) or 
       (ppInfo is NULL))
    {
        //
        // If the user had an error or only wanted the ifType we are done
        //

        return dwErr;
    }

    //
    // Return protocol block info.
    //

    dwErr = MprInfoBlockFind(pInfo,
                             dwType,
                             &dwSize,
                             &dwCount,
                             &pbyTmp);

    if(dwErr is NO_ERROR)
    {
        if(dwSize is 0)
        {
            if(g_bCommit)
            {
                FREE_BUFFER(pInfo);
            }

            return ERROR_NOT_FOUND;
        }

        if(ppbInfoBlk)
        {
            *ppbInfoBlk = HeapAlloc(GetProcessHeap(),
                                    0,
                                    dwSize * dwCount);

            if(*ppbInfoBlk is NULL)
            {
                if(g_bCommit)
                {
                    FREE_BUFFER(pInfo);
                }
                    
                return ERROR_NOT_ENOUGH_MEMORY;
            }

            CopyMemory(*ppbInfoBlk,
                       pbyTmp,
                       dwSize * dwCount);

            if(pdwSize)
            {
                *pdwSize = dwSize;
            }

            if(pdwCount)
            {
                *pdwCount = dwCount;
            }
        }
    }

    if(g_bCommit)
    {
        FREE_BUFFER(pInfo);
    }
    

    return dwErr;
}

DWORD WINAPI
IpmontrGetInterfaceType(
    IN    LPCWSTR   pwszIfName,
    OUT   PDWORD    pdwIfType
    )
{
    return GetInterfaceInfo(pwszIfName,
                            NULL,
                            NULL,
                            pdwIfType);
}

DWORD 
WINAPI
GetInterfaceName(
    IN  LPCWSTR ptcArgument,
    OUT LPWSTR  pwszIfName,
    IN  DWORD   dwSizeOfIfName,
    OUT PDWORD  pdwNumParsed
    )
/*++
Description:
    Convert a friendly name to an interface name

Arguments:

    ptcArgument     - Buffer holding the Friendly Name of an interface
    pwszIfName      - Buffer to hold the Guid Interface Name
    dwSizeOfIfName  - Size (in Bytes) of the pwszIfName
    pdwNumParsed    - 
--*/
{
    DWORD dwErr;

    dwErr = IpmontrGetIfNameFromFriendlyName( 
                ptcArgument, 
                pwszIfName, 
                &dwSizeOfIfName );

    *pdwNumParsed = (dwErr is NO_ERROR)? 1 : 0;

    return dwErr;
}

DWORD
WINAPI
GetInterfaceDescription(
    IN      LPCWSTR    pwszIfName,
    OUT     LPWSTR     pwszIfDesc,
    OUT     PDWORD     pdwNumParsed
    )
{
    DWORD rc,dwSize;
    WCHAR IfNamBuffer[MaxIfDisplayLength];
    DWORD dwLen = (DWORD) wcslen(pwszIfName);

    if ( !dwLen || dwLen > MAX_INTERFACE_NAME_LEN )
    {
        *pdwNumParsed = 0;
        return ERROR_INVALID_PARAMETER;
    }

    dwSize = sizeof(IfNamBuffer); 
    //======================================
    // Translate the Interface Name
    //======================================
    rc = IpmontrGetFriendlyNameFromIfName(pwszIfName, IfNamBuffer, &dwSize);

    if (rc == NO_ERROR)
    {
        wcscpy(pwszIfDesc,IfNamBuffer);
        *pdwNumParsed = 1;
    }
    else
    {
        *pdwNumParsed = 0;
    }
    
    return rc;
}

DWORD 
WINAPI
IpmontrInterfaceEnum(
    OUT    PBYTE               *ppb,
    OUT    PDWORD              pdwCount,
    OUT    PDWORD              pdwTotal
    )
{
    DWORD               dwRes;
    PMPR_INTERFACE_0    pmi0;

#ifdef READROUTERINFO
    if(!IsRouterRunning())
#endif
    {
        dwRes = MprConfigInterfaceEnum(g_hMprConfig,
                                       0,
                                       (LPBYTE*) &pmi0,
                                       (DWORD) -1,
                                       pdwCount,
                                       pdwTotal,
                                       NULL);

        if(dwRes == NO_ERROR)
        {
            *ppb = (PBYTE)pmi0;
        }
    }
#ifdef READROUTERINFO    
    else
    {
        dwRes = MprAdminInterfaceEnum(g_hMprAdmin,
                                      0,
                                      (LPBYTE*) &pmi0,
                                      (DWORD) -1,
                                      pdwCount,
                                      pdwTotal,
                                      NULL);

    
        if(dwRes == NO_ERROR)
        {
            *ppb = HeapAlloc(GetProcessHeap(),
                             0,
                             sizeof(MPR_INTERFACE_0) * (*pdwCount));

    
            if(*ppb == NULL)
            {
                DisplayMessage(g_hModule, MSG_IP_NOT_ENOUGH_MEMORY);

                return ERROR_NOT_ENOUGH_MEMORY;
            }

            CopyMemory(*ppb, pmi0, sizeof(MPR_INTERFACE_0) * (*pdwCount));

            MprAdminBufferFree(pmi0);

        }
    }
#endif

    return dwRes;
}

DWORD
WINAPI
MatchRoutingProtoTag(
    IN  LPCWSTR  pwszToken
    )

/*++

Routine Description:

    Gets the protocol ID corresponding to a protocol tag.

Arguments:

    pwszArg - protocol token

Return Value:

    Protocol Id or (DWORD)-1

--*/

{
    DWORD   dwRes, dwErr;

    TOKEN_VALUE rgEnums[] ={{TOKEN_VALUE_RIP, PROTO_IP_RIP},
                         {TOKEN_VALUE_OSPF, PROTO_IP_OSPF},
                         {TOKEN_VALUE_AUTOSTATIC, PROTO_IP_NT_AUTOSTATIC},
                         {TOKEN_VALUE_STATIC, PROTO_IP_NT_STATIC},
                         {TOKEN_VALUE_NETMGMT, PROTO_IP_NETMGMT},
                         {TOKEN_VALUE_LOCAL, PROTO_IP_LOCAL},
                         {TOKEN_VALUE_NONDOD, PROTO_IP_NT_STATIC_NON_DOD}};

    if (iswdigit(pwszToken[0]))
    {
        return wcstoul(pwszToken, NULL, 10);
    }
    
    dwErr = MatchEnumTag(g_hModule,
                         pwszToken,
                         sizeof(rgEnums)/sizeof(TOKEN_VALUE),
                         rgEnums,
                         &dwRes);

    if(dwErr != NO_ERROR)
    {
        return (DWORD)-1;
    }

    return dwRes;
}

BOOL
WINAPI
IsRouterRunning(
    VOID
    )

/*++

Routine Description:

    Gets the protocol ID corresponding to a protocol tag.

Arguments:

    pwszArg - protocol token

Return Value:

    Protocol Id or (DWORD)-1

--*/

{
    DWORD   dwErr;

    //
    // Check at most once per second
    //
    // We don't care about wrapping, we just need a fast way to
    // get some identifier of the current "second".
    //

    static time_t dwPreviousTime = 0;
    time_t        dwCurrentTime;
    time(&dwCurrentTime);

    if (dwCurrentTime == dwPreviousTime)
    {
        return g_bRouterRunning;
    }

    dwPreviousTime = dwCurrentTime;

    if(MprAdminIsServiceRunning(g_pwszRouter))
    {
        if(g_bRouterRunning)
        {
            return TRUE;
        }

        dwErr = MprAdminServerConnect(g_pwszRouter,
                                      &g_hMprAdmin);

        if(dwErr isnot NO_ERROR)
        {
            DisplayError(NULL,
                         dwErr);

            DisplayMessage(g_hModule,
                           MSG_IP_CAN_NOT_CONNECT_DIM,
                           dwErr);

            return FALSE;
        }

        dwErr = MprAdminMIBServerConnect(g_pwszRouter,
                                         &g_hMIBServer);

        if(dwErr isnot NO_ERROR)
        {
            DisplayError(NULL,
                         dwErr);

            DisplayMessage(g_hModule,
                           MSG_IP_CAN_NOT_CONNECT_DIM,
                           dwErr);

            MprAdminServerDisconnect(g_hMprAdmin);

            g_hMprAdmin = NULL;

            return FALSE;
        }

        g_bRouterRunning = TRUE;
    }
    else
    {
        if(g_bRouterRunning)
        {
            g_bRouterRunning = FALSE;
            g_hMprAdmin      = NULL;
            g_hMIBServer     = NULL;
        }
    }

    return g_bRouterRunning; 
}

DWORD
MibGetFirst(
    DWORD   dwTransportId,
    DWORD   dwRoutingPid,
    LPVOID  lpInEntry,
    DWORD   dwInEntrySize,
    LPVOID *lplpOutEntry,
    LPDWORD lpdwOutEntrySize
    )
{
    DWORD dwErr;

    dwErr = MprAdminMIBEntryGetFirst( g_hMIBServer,
                                      dwTransportId,
                                      dwRoutingPid,
                                      lpInEntry,
                                      dwInEntrySize,
                                      lplpOutEntry,
                                      lpdwOutEntrySize );

    if (dwErr is RPC_S_INVALID_BINDING)
    {
        g_bRouterRunning = FALSE;
        g_hMprAdmin      = NULL;
        g_hMIBServer     = NULL;
    }

    return dwErr;
}

DWORD
MibGetNext(
    DWORD   dwTransportId,
    DWORD   dwRoutingPid,
    LPVOID  lpInEntry,
    DWORD   dwInEntrySize,
    LPVOID *lplpOutEntry,
    LPDWORD lpdwOutEntrySize
    )
{
    DWORD dwErr;

    dwErr = MprAdminMIBEntryGetNext( g_hMIBServer,
                                     dwTransportId,
                                     dwRoutingPid,
                                     lpInEntry,
                                     dwInEntrySize,
                                     lplpOutEntry,
                                     lpdwOutEntrySize );

    if (dwErr is RPC_S_INVALID_BINDING)
    {
        g_bRouterRunning = FALSE;
        g_hMprAdmin      = NULL;
        g_hMIBServer     = NULL;
    }

    return dwErr;
}

DWORD
MibGet(
    DWORD   dwTransportId,
    DWORD   dwRoutingPid,
    LPVOID  lpInEntry,
    DWORD   dwInEntrySize,
    LPVOID *lplpOutEntry,
    LPDWORD lpdwOutEntrySize
    )
{
    DWORD dwErr;

    dwErr = MprAdminMIBEntryGet( g_hMIBServer,
                                 dwTransportId,
                                 dwRoutingPid,
                                 lpInEntry,
                                 dwInEntrySize,
                                 lplpOutEntry,
                                 lpdwOutEntrySize );

    if (dwErr is RPC_S_INVALID_BINDING)
    {
        g_bRouterRunning = FALSE;
        g_hMprAdmin      = NULL;
        g_hMIBServer     = NULL;
    }

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ip\ipmon\routing.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:
     net\routing\netsh\ip\ipmon\routing.h

Abstract:

     Prototype for fns called in routing.c

Author:

     Dave Thaler         3/03/99

--*/

extern const GUID g_RoutingGuid;
extern const GUID g_NetshGuid;

NS_HELPER_START_FN RoutingStartHelper;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ip\ipmon\remras.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0268 */
/* at Wed Jun 02 22:49:58 1999
 */
/* Compiler settings for remras.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __remras_h__
#define __remras_h__

/* Forward Declarations */ 

#ifndef __IRemoteNetworkConfig_FWD_DEFINED__
#define __IRemoteNetworkConfig_FWD_DEFINED__
typedef interface IRemoteNetworkConfig IRemoteNetworkConfig;
#endif 	/* __IRemoteNetworkConfig_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __IRemoteNetworkConfig_INTERFACE_DEFINED__
#define __IRemoteNetworkConfig_INTERFACE_DEFINED__

/* interface IRemoteNetworkConfig */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IRemoteNetworkConfig;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("66A2DB1B-D706-11d0-A37B-00C04FC9DA04")
    IRemoteNetworkConfig : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE UpgradeRouterConfig( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetUserConfig( 
            /* [in] */ LPCOLESTR pszService,
            /* [in] */ LPCOLESTR pszNewGroup) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRemoteNetworkConfigVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRemoteNetworkConfig __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRemoteNetworkConfig __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRemoteNetworkConfig __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UpgradeRouterConfig )( 
            IRemoteNetworkConfig __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetUserConfig )( 
            IRemoteNetworkConfig __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszService,
            /* [in] */ LPCOLESTR pszNewGroup);
        
        END_INTERFACE
    } IRemoteNetworkConfigVtbl;

    interface IRemoteNetworkConfig
    {
        CONST_VTBL struct IRemoteNetworkConfigVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRemoteNetworkConfig_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRemoteNetworkConfig_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRemoteNetworkConfig_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRemoteNetworkConfig_UpgradeRouterConfig(This)	\
    (This)->lpVtbl -> UpgradeRouterConfig(This)

#define IRemoteNetworkConfig_SetUserConfig(This,pszService,pszNewGroup)	\
    (This)->lpVtbl -> SetUserConfig(This,pszService,pszNewGroup)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRemoteNetworkConfig_UpgradeRouterConfig_Proxy( 
    IRemoteNetworkConfig __RPC_FAR * This);


void __RPC_STUB IRemoteNetworkConfig_UpgradeRouterConfig_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteNetworkConfig_SetUserConfig_Proxy( 
    IRemoteNetworkConfig __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszService,
    /* [in] */ LPCOLESTR pszNewGroup);


void __RPC_STUB IRemoteNetworkConfig_SetUserConfig_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRemoteNetworkConfig_INTERFACE_DEFINED__ */



#ifdef __cplusplus

class DECLSPEC_UUID("1AA7F844-C7F5-11d0-A376-00C04FC9DA04")
RemoteRouterConfig;
#endif
#endif /* __REMRRASLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ip\ipmon\route.h ===
#define ALL_FIELDS_SPECIFIED  0x00

#define PREF_NOT_SPECIFIED    0x01
#define METRIC_NOT_SPECIFIED  0x02
#define VIEW_NOT_SPECIFIED    0x04

#define FIELDS_NOT_SPECIFIED  0x0F

DWORD
AddSetDelRtmRouteInfo(
    IN  PINTERFACE_ROUTE_INFO pRoute,
    IN  LPCWSTR               pwszIfName,
    IN  DWORD                 dwCommand,
    IN  DWORD                 dwFlags
    );

DWORD
AddSetDelPersistentRouteInfo(
    IN  PINTERFACE_ROUTE_INFO pRoute,
    IN  LPCWSTR               pwszIfName,
    IN  DWORD                 dwCommand,
    IN  DWORD                 dwFlags
    );

DWORD
AddRoute(
    IN      PINTERFACE_ROUTE_INFO  pOldTable,
    IN      PINTERFACE_ROUTE_INFO  pRoute,
    IN      DWORD                  dwIfType,
    IN OUT  PDWORD                 pdwCount,
    OUT     INTERFACE_ROUTE_INFO **ppNewTable
    );

DWORD
SetRoute(
    IN      PINTERFACE_ROUTE_INFO pTable,
    IN      PINTERFACE_ROUTE_INFO pRoute,
    IN      DWORD                 dwIfType,
    IN      DWORD                 dwFlags,
    IN OUT  PDWORD                pdwCount
    );

DWORD
DeleteRoute(
    IN      PINTERFACE_ROUTE_INFO  pOldTable,
    IN      PINTERFACE_ROUTE_INFO  pRoute,
    IN      DWORD                  dwIfType,
    IN OUT  PDWORD                 pdwCount,
    OUT     INTERFACE_ROUTE_INFO **ppNewTable
    );

BOOL
IsRoutePresent(
    IN  PINTERFACE_ROUTE_INFO pTable,
    IN  PINTERFACE_ROUTE_INFO pRoute,
    IN  DWORD                 dwIfType,
    IN  ULONG                 ulCount,
    OUT PULONG                pulIndex
    );

DWORD
ShowIpPersistentRoute(
    IN     HANDLE  hFile,  OPTIONAL
    IN     LPCWSTR pwszIfName,
    IN OUT PDWORD  pdwNumRows
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ip\ipmon\route.c ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    routing\netsh\ip\route.c

--*/

#include "precomp.h"
#pragma hdrstop

DWORD
AddSetDelRtmRouteInfo(
    IN  PINTERFACE_ROUTE_INFO pRoute,
    IN  LPCWSTR               pwszIfName,
    IN  DWORD                 dwCommand,
    IN  DWORD                 dwFlags
    )

/*++

Routine Description:

    Adds/deletes normal (read as non persistant)
    routes on interfaces.

Arguments:

    pRoute        - route to add/set/delete
    pwszIfName    -  Interface Name
    dwCommand     -  Add, set, or delete
    
Return Value:

    NO_ERROR
    
--*/

{
    ULONG                 dwOutEntrySize;
    DWORD                 dwRes, i;
    PMIB_IPDESTTABLE      lpTable;
    PMIB_IPDESTROW        pEntry = NULL;
    MIB_OPAQUE_QUERY      QueryBuff[3]; // more than enough
    MIB_OPAQUE_QUERY     *pQuery = QueryBuff;
    PMIB_OPAQUE_INFO      pInfo;
    DEFINE_MIB_BUFFER(pRouteInfo, MIB_IPDESTROW, pRouteRow);

    if (!pRoute->dwRtInfoIfIndex)
    {
        //
        // Get the interface index from friendly name
        //

        dwRes = IpmontrGetIfIndexFromFriendlyName(g_hMIBServer,
                                                  pwszIfName,
                                                  &pRoute->dwRtInfoIfIndex);
        if (dwRes != NO_ERROR)
        {
            return dwRes;
        }

        //
        // The interface probably is disconnected
        //

        if (pRoute->dwRtInfoIfIndex == 0)
        {
            DisplayMessage(g_hModule, EMSG_INTERFACE_INVALID_OR_DISC);
            return ERROR_INVALID_PARAMETER;
        }
    }

    //
    // Use MprAdmin api to add, del or set entry
    //

    switch(dwCommand) 
    {
    case ADD_COMMAND:
    case SET_COMMAND:

        //
        // Does this route already exist in the router ?
        //

        // Get all this protocol routes on dest

        pQuery->dwVarId = ROUTE_MATCHING;

        pQuery->rgdwVarIndex[0] = pRoute->dwRtInfoDest;
        pQuery->rgdwVarIndex[1] = pRoute->dwRtInfoMask;
        pQuery->rgdwVarIndex[2] = RTM_VIEW_MASK_ANY;
        pQuery->rgdwVarIndex[3] = pRoute->dwRtInfoProto;

        pInfo = NULL;

        dwRes = MibGet(PID_IP,
                       IPRTRMGR_PID,
                       (PVOID) pQuery,
                       sizeof(MIB_OPAQUE_QUERY) + 3 * sizeof(DWORD),
                       (PVOID *) &pInfo,
                       &dwOutEntrySize);

        if ( dwRes isnot NO_ERROR )
        {
            DisplayMessage(g_hModule,  MSG_IP_DIM_ERROR, dwRes );
            return dwRes;
        }

        if ( pInfo isnot NULL )
        {
            //
            // Search for a matching route 
            //

            BOOL bFound = FALSE;
            
            lpTable = (PMIB_IPDESTTABLE)(pInfo->rgbyData);

            for (i=0; i<lpTable->dwNumEntries; i++)
            {
                pEntry = &lpTable->table[i];

                if ((pEntry->dwForwardIfIndex == pRoute->dwRtInfoIfIndex) &&
                    (pEntry->dwForwardNextHop == pRoute->dwRtInfoNextHop))
                {
                    bFound = TRUE;
                    break;
                }
            }
            if (!bFound)
                pEntry = NULL;

                
            if (i == lpTable->dwNumEntries)
            {
                //
                // No matching route found - quit if set
                //

                if (dwCommand == SET_COMMAND)
                {
                    MprAdminMIBBufferFree((PVOID)pInfo);
                    return ERROR_NOT_FOUND;
                }
            }
            else
            {
                //
                // A matching route found - quit if add
                //

                if (dwCommand == ADD_COMMAND)
                {
                    MprAdminMIBBufferFree((PVOID)pInfo);
                    return ERROR_OBJECT_ALREADY_EXISTS;
                }
            }
        }
        else
        {
            //
            // No matching routes found - quit if set
            //

            if (dwCommand == SET_COMMAND)
            {
                return ERROR_NOT_FOUND;
            }
        }

        //
        // Convert the route to a ip route row format
        //

        pRouteInfo->dwId = ROUTE_MATCHING;

        pRouteRow->dwForwardDest       = pRoute->dwRtInfoDest;
        pRouteRow->dwForwardMask       = pRoute->dwRtInfoMask;
        pRouteRow->dwForwardPolicy     = 0;
        pRouteRow->dwForwardNextHop    = pRoute->dwRtInfoNextHop;
        pRouteRow->dwForwardIfIndex    = pRoute->dwRtInfoIfIndex;
        pRouteRow->dwForwardType       = 0;
        pRouteRow->dwForwardProto      = pRoute->dwRtInfoProto;
        pRouteRow->dwForwardAge        = INFINITE;
        pRouteRow->dwForwardNextHopAS  = 0;
        pRouteRow->dwForwardMetric1    = pRoute->dwRtInfoMetric1;
        pRouteRow->dwForwardMetric2    = pRoute->dwRtInfoMetric2;
        pRouteRow->dwForwardMetric3    = pRoute->dwRtInfoMetric3;
        pRouteRow->dwForwardMetric4    = MIB_IPROUTE_METRIC_UNUSED;
        pRouteRow->dwForwardMetric5    = MIB_IPROUTE_METRIC_UNUSED;
        pRouteRow->dwForwardPreference = pRoute->dwRtInfoPreference;
        pRouteRow->dwForwardViewSet    = pRoute->dwRtInfoViewSet;

        if (dwCommand == ADD_COMMAND)
        {
            dwRes = MprAdminMIBEntryCreate(g_hMIBServer,
                                           PID_IP,
                                           IPRTRMGR_PID,
                                           (PVOID)pRouteInfo,
                                           MIB_INFO_SIZE(MIB_IPDESTROW));
        }
        else
        {
            if ((dwFlags & FIELDS_NOT_SPECIFIED) && pEntry)
            {
                //
                // Get the old preference, metric, or view
                //

                if (dwFlags & PREF_NOT_SPECIFIED)
                {
                    pRouteRow->dwForwardPreference = pEntry->dwForwardPreference;
                }

                if (dwFlags & METRIC_NOT_SPECIFIED)
                {
                    pRouteRow->dwForwardMetric1 = pEntry->dwForwardMetric1;
                }

                if (dwFlags & VIEW_NOT_SPECIFIED)
                {
                    pRouteRow->dwForwardViewSet = pEntry->dwForwardViewSet;
                }
            }

            dwRes = MprAdminMIBEntrySet(g_hMIBServer,
                                        PID_IP,
                                        IPRTRMGR_PID,
                                        (PVOID)pRouteInfo,
                                        MIB_INFO_SIZE(MIB_IPDESTROW));
        }

        // Free the old route information obtained
        if (pInfo)
        {
            MprAdminMIBBufferFree((PVOID)pInfo);
        }

        break;
        
    case DELETE_COMMAND:
    {
        DWORD               rgdwInfo[6];
        PMIB_OPAQUE_QUERY   pIndex = (PMIB_OPAQUE_QUERY)rgdwInfo;

        pIndex->dwVarId = ROUTE_MATCHING;

        pIndex->rgdwVarIndex[0]  = pRoute->dwRtInfoDest;
        pIndex->rgdwVarIndex[1]  = pRoute->dwRtInfoMask;
        pIndex->rgdwVarIndex[2]  = pRoute->dwRtInfoIfIndex;
        pIndex->rgdwVarIndex[3]  = pRoute->dwRtInfoNextHop;
        pIndex->rgdwVarIndex[4]  = pRoute->dwRtInfoProto;

        dwRes = MprAdminMIBEntryDelete(g_hMIBServer,
                                       PID_IP,
                                       IPRTRMGR_PID,
                                       (PVOID)pIndex,
                                       sizeof(rgdwInfo));
        break;
    }

    default:
        dwRes = ERROR_INVALID_PARAMETER;
    }
    
    return dwRes;
}


DWORD
AddSetDelPersistentRouteInfo(
    IN  PINTERFACE_ROUTE_INFO pRoute,
    IN  LPCWSTR               pwszIfName,
    IN  DWORD                 dwCommand,
    IN  DWORD                 dwFlags
    )

/*++

Routine Description:

    Adds/deletes persitant routes on interfaces.

Arguments:

    route         - route to add/set/delete
    pwszIfName    -  Interface Name
    dwCommand     -  Add, set, or delete
    
Return Value:

    ERROR_OKAY
    
--*/

{
    DWORD                 dwRes;
    PINTERFACE_ROUTE_INFO pOldTable, pNewTable;
    DWORD                 dwIfType, dwSize, dwCount;

    pNewTable = NULL;
   
    do
    {
        dwRes = IpmontrGetInfoBlockFromInterfaceInfo(pwszIfName,
                                                     IP_ROUTE_INFO,
                                                     (PBYTE *) &pOldTable,
                                                     &dwSize,
                                                     &dwCount,
                                                     &dwIfType);

        if((dwRes is ERROR_NOT_FOUND) &&
           dwCommand is ADD_COMMAND)
        {
            //
            // No route info but we are asked to add
            //
            
            pOldTable   = NULL;
            dwRes       = NO_ERROR;
            dwCount     = 0;
        }
        
        if(dwRes isnot NO_ERROR)
        {
            break;
        }

        //
        // These take the old table and return a new one in its stead
        //
        
        switch(dwCommand) 
        {
        case ADD_COMMAND:
            dwRes = AddRoute(pOldTable,
                             pRoute,
                             dwIfType,
                             &dwCount,
                             &pNewTable);
            break;
        
        case DELETE_COMMAND:
            dwRes = DeleteRoute(pOldTable,
                                pRoute,
                                dwIfType,
                                &dwCount,
                                &pNewTable);
            break;

        case SET_COMMAND:

            dwRes = SetRoute(pOldTable,
                             pRoute,
                             dwIfType,
                             dwFlags,
                             &dwCount);

            pNewTable = pOldTable;
            pOldTable = NULL;

            break;
        }
            
        if(dwRes != NO_ERROR)
        {
            break;
        }

        //
        // Set the new info back
        //
        
        dwRes = IpmontrSetInfoBlockInInterfaceInfo(pwszIfName,
                                                  IP_ROUTE_INFO,
                                                  (PBYTE)pNewTable,
                                                  sizeof(INTERFACE_ROUTE_INFO),
                                                  dwCount);
        
        
        if(dwRes != NO_ERROR)
        {
            break;
        }
        
        
        pNewTable = NULL;
        
 
    } while ( FALSE );

    if(pOldTable)
    {
        FREE_BUFFER(pOldTable);
    }
        

    if(pNewTable)
    {
        HeapFree(GetProcessHeap(),
                 0,
                 pNewTable);

        pNewTable = NULL;
    }


    switch(dwRes)
    {
        case NO_ERROR:
        {
            dwRes = ERROR_OKAY;
            break;
        }

        case ERROR_NOT_FOUND:
        {
            WCHAR  wszBuffer[MAX_INTERFACE_NAME_LEN+1];
            DWORD  dwSizeTemp = sizeof(wszBuffer);
            IpmontrGetFriendlyNameFromIfName( pwszIfName, wszBuffer, &dwSizeTemp);

            DisplayMessage(g_hModule, EMSG_IP_NO_ROUTE_INFO, wszBuffer);

            dwRes = ERROR_SUPPRESS_OUTPUT;

            break;
        }
        
        case ERROR_NOT_ENOUGH_MEMORY:
        {
            DisplayMessage(g_hModule, MSG_IP_NOT_ENOUGH_MEMORY);

            dwRes = ERROR_SUPPRESS_OUTPUT;
            
            break;
        }
    }
    
    return dwRes;
}

DWORD
SetRoute( 
    IN      PINTERFACE_ROUTE_INFO pTable,
    IN      PINTERFACE_ROUTE_INFO pRoute,
    IN      DWORD                 dwIfType,
    IN      DWORD                 dwFlags,
    IN OUT  PDWORD                pdwCount
    )
{
    ULONG   ulIndex, i;
    
    //
    // If the count is 0, the function will return false
    // and we will error out
    //
    
    if(!IsRoutePresent(pTable,
                       pRoute,
                       dwIfType,
                       *pdwCount,
                       &ulIndex))
    {
        return ERROR_NOT_FOUND;
    }

    if (dwFlags & FIELDS_NOT_SPECIFIED)
    {
        //
        // Preserve the old values if not specified
        //

        if (dwFlags & PREF_NOT_SPECIFIED)
        {
            pRoute->dwRtInfoPreference = pTable[ulIndex].dwRtInfoPreference;
        }

        if (dwFlags & METRIC_NOT_SPECIFIED)
        {
            pRoute->dwRtInfoMetric1 = pTable[ulIndex].dwRtInfoMetric1;
        }

        if (dwFlags & VIEW_NOT_SPECIFIED)
        {
            pRoute->dwRtInfoViewSet = pTable[ulIndex].dwRtInfoViewSet;
        }
    }

    pTable[ulIndex] = *pRoute;

    return NO_ERROR;
}

DWORD
AddRoute( 
    IN      PINTERFACE_ROUTE_INFO  pOldTable,
    IN      PINTERFACE_ROUTE_INFO  pRoute,
    IN      DWORD                  dwIfType,
    IN OUT  PDWORD                 pdwCount, 
    OUT     INTERFACE_ROUTE_INFO **ppNewTable
    )

/*++

Routine Description:

    Adds a route to the current info

Arguments:

Return Value:

    NO_ERROR
    
--*/

{
    ULONG   ulIndex, i;

    
    if(IsRoutePresent(pOldTable,
                      pRoute,
                      dwIfType,
                      *pdwCount,
                      &ulIndex))
    {
        return ERROR_OBJECT_ALREADY_EXISTS;
            
    }

    //
    // Just create a block with size n + 1
    //
    
    *ppNewTable = HeapAlloc(GetProcessHeap(),
                            0,
                            ((*pdwCount) + 1) * sizeof(INTERFACE_ROUTE_INFO));
    
    if(*ppNewTable is NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    for(i = 0; i < *pdwCount; i++)
    {
        //
        // structure copy
        //
        
        (*ppNewTable)[i] = pOldTable[i];
    } 

    //
    // copy the new route
    //

    
    (*ppNewTable)[i] = *pRoute;
        
    *pdwCount += 1;
    
    return NO_ERROR;
}

DWORD
DeleteRoute( 
    IN      PINTERFACE_ROUTE_INFO  pOldTable,
    IN      PINTERFACE_ROUTE_INFO  pRoute,
    IN      DWORD                  dwIfType,
    IN OUT  PDWORD                 pdwCount,
    OUT     INTERFACE_ROUTE_INFO **ppNewTable
    )

/*++

Routine Description:

    Deletes a route from an interface

Arguments:

Return Value:

    NO_ERROR
    
--*/

{
    ULONG   ulIndex, i, j;
    
    //
    // If the count is 0, the function will return false
    // and we will error out
    //
    
    if(!IsRoutePresent(pOldTable,
                       pRoute,
                       dwIfType,
                       *pdwCount,
                       &ulIndex))
    {
        return ERROR_NOT_FOUND;
    }


    //
    // If the count is 1
    //
    
    *pdwCount -= 1;
        
    if(*pdwCount is 0)
    {
        *ppNewTable = NULL;

        return NO_ERROR;
    }

    
    //
    // delete the route
    //

    *ppNewTable = HeapAlloc(GetProcessHeap(),
                            0,
                            (*pdwCount) * sizeof(INTERFACE_ROUTE_INFO));
    
    if(*ppNewTable is NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    i = j = 0;
    
    while(i <= *pdwCount)
    {
        if(i == ulIndex)
        {
            i++;
            continue;
        }
        
        //
        // structure copy
        //
        
        (*ppNewTable)[j] = pOldTable[i];

        i++;
        j++;
    } 

    return NO_ERROR;
}


BOOL
IsRoutePresent(
    IN  PINTERFACE_ROUTE_INFO pTable,
    IN  PINTERFACE_ROUTE_INFO pRoute,
    IN  DWORD                 dwIfType,
    IN  ULONG                 ulCount,
    OUT PULONG                pulIndex
    )

/*++

Routine Description:

    Checks to see if interface is already present

Arguments:

Return Value:

    NO_ERROR
    
--*/

{
    ULONG   i;
    BOOL    bDontMatchNHop;

    if((dwIfType is ROUTER_IF_TYPE_DEDICATED) or
       (dwIfType is ROUTER_IF_TYPE_INTERNAL))
    {
        bDontMatchNHop = FALSE;
    }
    else
    {
        bDontMatchNHop = TRUE;
    }

    // Do this check just to keep the prefix checker happy
    if (pTable is NULL)
    {
        return FALSE;
    }
    
    for(i = 0; i < ulCount; i++)
    {
        if((pTable[i].dwRtInfoDest is pRoute->dwRtInfoDest) and
           (pTable[i].dwRtInfoMask is pRoute->dwRtInfoMask) and
#if 0
           (pTable[i].dwRtInfoProto is pRoute->dwRtInfoProto) and
#endif
           (bDontMatchNHop or
            (pTable[i].dwRtInfoNextHop is pRoute->dwRtInfoNextHop)))
        {
            *pulIndex = i;

            return TRUE;
        }
    }

    return FALSE;
}


DWORD
ShowIpPersistentRoute(
    IN     HANDLE  hFile,  OPTIONAL
    IN     LPCWSTR pwszIfName,
    IN OUT PDWORD  pdwNumRows
    )

/*++

Routine Description:

    Show the static (persistent) routes on the interface

Arguments:

    pwszIfName - Interface name

Return Value:

    NO_ERROR

--*/

{
    PINTERFACE_ROUTE_INFO pRoutes;

    DWORD   dwErr, dwBlkSize, dwCount, dwIfType, dwNumParsed, i;
    DWORD   dwIfClass;
    WCHAR   wszNextHop[ADDR_LENGTH + 1];
    WCHAR   wszIfDesc[MAX_INTERFACE_NAME_LEN + 1];
    PWCHAR  pwszProto, pwszToken, pwszQuoted;
    WCHAR   wszViews[3];

    dwErr = GetInterfaceDescription(pwszIfName,
                                    wszIfDesc,
                                    &dwNumParsed);

    if (!dwNumParsed)
    {
        wcscpy(wszIfDesc, pwszIfName);
    }

    //
    // Retrieve the routes
    //

    dwErr = IpmontrGetInfoBlockFromInterfaceInfo(pwszIfName,
                                                 IP_ROUTE_INFO,
                                                 (PBYTE *) &pRoutes,
                                                 &dwBlkSize,
                                                 &dwCount,
                                                 &dwIfType);

    //
    // If no IP_ROUTE_INFO block is found for this interface,
    // don't print anything and return NO_ERROR
    //

    if (dwErr == ERROR_NOT_FOUND)
    {
        return NO_ERROR;
    }
  
    if (dwErr != NO_ERROR)
    {
        return dwErr;
    }

    if((pRoutes == NULL) ||
       (dwCount == 0))
    {
        return NO_ERROR;
    }


    dwErr = GetInterfaceClass(pwszIfName, &dwIfClass);

    if (dwErr != NO_ERROR)
    {
        DisplayMessage(g_hModule, EMSG_CANT_GET_IF_INFO,
                       wszIfDesc,
                       dwErr);

        return dwErr;
    }


    if(hFile == NULL)
    {
        if (*pdwNumRows is 0)
        {
            DisplayMessage(g_hModule, MSG_RTR_ROUTE_HDR);
        }

        pwszQuoted = NULL;
    }
    else
    {
        pwszQuoted = MakeQuotedString(wszIfDesc);
    }

    for(i = 0; i < dwCount; i++)
    {
        wszViews[0] = (pRoutes[i].dwRtInfoViewSet & RTM_VIEW_MASK_UCAST)? 'U':' ';
        wszViews[1] = (pRoutes[i].dwRtInfoViewSet & RTM_VIEW_MASK_MCAST)? 'M':' ';
        wszViews[2] = '\0';

        switch(pRoutes[i].dwRtInfoProto)
        {
            case PROTO_IP_NT_AUTOSTATIC:
            {
                pwszProto = MakeString(g_hModule, STRING_NT_AUTOSTATIC);
                pwszToken = TOKEN_VALUE_AUTOSTATIC;
    
                break;
            }

            case PROTO_IP_NT_STATIC:
            {
                pwszProto = MakeString(g_hModule, STRING_STATIC);
                pwszToken = TOKEN_VALUE_STATIC;
    
                break;
            }

            case PROTO_IP_NT_STATIC_NON_DOD:
            {
                pwszProto = MakeString(g_hModule, STRING_NONDOD);
                pwszToken = TOKEN_VALUE_NONDOD;
    
                break;
            }

            default:
            {
                pwszProto = MakeString(g_hModule, STRING_PROTO_UNKNOWN);
                pwszToken = NULL;
 
                break;
            }
        }

        MakeUnicodeIpAddr(wszNextHop,
                          inet_ntoa(*((struct in_addr *)&(pRoutes[i].dwRtInfoNextHop))));

        if(hFile)
        {
            if(pwszToken)
            {
                WCHAR   wszMask[ADDR_LENGTH + 1], wszDest[ADDR_LENGTH + 1];
                PWCHAR  pwszView = NULL;

                MakeUnicodeIpAddr(wszDest,
                                  inet_ntoa(*((struct in_addr *)&(pRoutes[i].dwRtInfoDest))));
                MakeUnicodeIpAddr(wszMask,
                                  inet_ntoa(*((struct in_addr *)&(pRoutes[i].dwRtInfoMask))));

                switch (pRoutes[i].dwRtInfoViewSet)
                { 
                case RTM_VIEW_MASK_UCAST: pwszView=TOKEN_VALUE_UNICAST  ; break;
                case RTM_VIEW_MASK_MCAST: pwszView=TOKEN_VALUE_MULTICAST; break;
                case RTM_VIEW_MASK_UCAST
                    |RTM_VIEW_MASK_MCAST: pwszView=TOKEN_VALUE_BOTH; break;
                }

                if (pwszView)
                {
                    if ( dwIfClass == IFCLASS_P2P ) {

                        DisplayMessageT( DMP_IP_ADDSET_P2P_PERSISTENTROUTE,
                                         wszDest,
                                         wszMask,
                                         pwszQuoted,
                                         pwszToken,
                                         pRoutes[i].dwRtInfoPreference,
                                         pRoutes[i].dwRtInfoMetric1,
                                         pwszView );
                                         
                    }
                    else {
                        DisplayMessageT( DMP_IP_ADDSET_PERSISTENTROUTE,
                                         wszDest,
                                         wszMask,
                                         pwszQuoted,
                                         wszNextHop,
                                         pwszToken,
                                         pRoutes[i].dwRtInfoPreference,
                                         pRoutes[i].dwRtInfoMetric1,
                                         pwszView );
                    }
                }
            }
        }
        else
        {
            WCHAR wcszBuffer[80];

            MakePrefixStringW( wcszBuffer,
                               pRoutes[i].dwRtInfoDest,
                               pRoutes[i].dwRtInfoMask );

            DisplayMessage(g_hModule,
                           MSG_RTR_ROUTE_INFO,
                           wcszBuffer,
                           pwszProto,
                           pRoutes[i].dwRtInfoPreference,
                           pRoutes[i].dwRtInfoMetric1,
                           wszNextHop,
                           wszViews,
                           wszIfDesc);

            (*pdwNumRows)++;
        }
      
        FreeString(pwszProto); 
    }

    if(pwszQuoted)
    {
        FreeQuotedString(pwszQuoted);
    }

    HeapFree(GetProcessHeap(), 
             0, 
             pRoutes);

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ip\ipmon\routing.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    routing\netsh\ip\ipmon\routing.c

Abstract:

    Routing Command dispatcher.

Revision History:

    Dave Thaler              3/03/99  Created

--*/

#include "precomp.h"

const GUID g_RoutingGuid = ROUTING_GUID;
const GUID g_NetshGuid   = NETSH_ROOT_GUID;
PWCHAR g_pwszRouter      = NULL;

HRESULT RouterReset(LPCTSTR pszMachineName);

NS_CONTEXT_DUMP_FN     RoutingDump;
NS_CONTEXT_CONNECT_FN  RoutingConnect;

FN_HANDLE_CMD HandleRoutingReset;

DWORD                ParentVersion;
BOOL                 g_bRoutingDirty = FALSE;

CMD_ENTRY g_RoutingCmds[] =
{
    CREATE_CMD_ENTRY(IP_RESET, HandleRoutingReset),
};

ULONG g_ulRoutingNumTopCmds = sizeof(g_RoutingCmds)/sizeof(CMD_ENTRY);

DWORD
WINAPI
RoutingStartHelper(
    IN CONST GUID *pguidParent,
    IN DWORD       dwVersion
    )
{
    DWORD dwErr;
    NS_CONTEXT_ATTRIBUTES attMyAttributes;

    ParentVersion         = dwVersion;

    ZeroMemory(&attMyAttributes, sizeof(attMyAttributes));

    attMyAttributes.pwszContext   = L"routing";
    attMyAttributes.guidHelper    = g_RoutingGuid;
    attMyAttributes.dwVersion     = 1;
    attMyAttributes.dwFlags       = 0;
    attMyAttributes.ulNumTopCmds  = g_ulRoutingNumTopCmds;
    attMyAttributes.pTopCmds      = (CMD_ENTRY (*)[])&g_RoutingCmds;
    attMyAttributes.ulNumGroups   = 0; 
    attMyAttributes.pCmdGroups    = NULL;
    attMyAttributes.pfnCommitFn   = NULL; // RoutingCommit;
    attMyAttributes.pfnDumpFn     = RoutingDump;
    attMyAttributes.pfnConnectFn  = RoutingConnect;

    dwErr = RegisterContext( &attMyAttributes );

    return dwErr;
}

DWORD
HandleRoutingReset(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    // Call KennT's "router upgrade" function
    RouterReset( g_pwszRouter );

    return NO_ERROR;
}

DWORD
ConnectToRouter(
    IN  LPCWSTR  pwszRouter
    )
{
    DWORD    rc;

    if (g_pwszRouter != pwszRouter)
    {
        if (g_hMprConfig)
        {
            MprConfigServerDisconnect(g_hMprConfig);
            g_hMprConfig = NULL;
        }

        if (g_hMprAdmin)
        {
            MprAdminServerDisconnect(g_hMprAdmin);
            g_hMprAdmin = NULL;
        }

        if (g_hMIBServer)
        {
            MprAdminMIBServerDisconnect(g_hMIBServer);
            g_hMIBServer = NULL;
        }

        if (g_pwszRouter)
        {
            FREE(g_pwszRouter);
            g_pwszRouter = NULL;
        }

        if (pwszRouter)
        {
            g_pwszRouter = MALLOC((wcslen(pwszRouter)+1)*sizeof(WCHAR));
            if (g_pwszRouter)
            {
                wcscpy(g_pwszRouter, pwszRouter);
            }
            else
            {
                return ERROR_NOT_ENOUGH_MEMORY;
            }
        }
    }

    if (!g_hMprConfig)
    {
        //
        // first time connecting to router config
        //

        rc = MprConfigServerConnect ((LPWSTR)pwszRouter,
                                     &g_hMprConfig);

        if (rc isnot NO_ERROR)
        {
            //
            // cannot connect to router config.
            //
            return ERROR_CONNECT_REMOTE_CONFIG;
        }
    }

    //
    // Check to see if router is running. If so, get the handles
    //

    do
    {
        if (MprAdminIsServiceRunning((LPWSTR)pwszRouter))
        {
            if (MprAdminServerConnect((LPWSTR)pwszRouter, &g_hMprAdmin) == NO_ERROR)
            {
                DEBUG("Got admin handle");
                if (MprAdminMIBServerConnect ((LPWSTR)pwszRouter,
                                              &g_hMIBServer) == NO_ERROR)
                {
                    DEBUG("Got server handle");
                    break;
                }
                else
                {
                    MprAdminServerDisconnect (g_hMprAdmin);
                }
            }
        }
        g_hMprAdmin = g_hMIBServer = NULL;

    } while (FALSE);

    return NO_ERROR;
}

DWORD WINAPI
RoutingConnect(
    IN  LPCWSTR  pwszRouter
    )
{
    // If context info is dirty, reregister it
    if (g_bRoutingDirty)
    {
        RoutingStartHelper(NULL, ParentVersion);
    }

    return ConnectToRouter(pwszRouter);
}

DWORD
RoutingDump(
    IN  LPCWSTR     pwszRouter,
    IN  WCHAR     **ppwcArguments,
    IN  DWORD       dwArgCount,
    IN  PVOID       pvData
    )
{    
    DWORD dwErr;

    dwErr = ConnectToRouter(pwszRouter);

    // Dump routing information
    DisplayMessage( g_hModule, DMP_ROUTING_HEADER_COMMENTS);
    DisplayMessageT(DMP_ROUTING_HEADER);
    DisplayMessageT(DMP_POPD);

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ip\ipmon\rtmv2.c ===
#include "precomp.h"
#pragma hdrstop

#define DEFAULT_VIEW_MASK RTM_VIEW_MASK_UCAST|RTM_VIEW_MASK_MCAST // both
#define DEFAULT_VIEW_ID   RTM_VIEW_ID_UCAST
#define DEFAULT_ADDR      0                   // 0.0.0.0
#define DEFAULT_MASK      0                   // 0.0.0.0
#define DEFAULT_PROTO     RTM_BEST_PROTOCOL

DWORD
HandleIpShowRtmDestinations(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    TAG_TYPE            pttTags[] = {{TOKEN_OPERATOR,    FALSE,FALSE},
                                     {TOKEN_DEST,        FALSE,FALSE},
                                     {TOKEN_MASK,        FALSE,FALSE},
                                     {TOKEN_VIEW,        FALSE,FALSE},
                                     {TOKEN_PROTOCOL,    FALSE,FALSE}};
    DWORD               pdwTagType[sizeof(pttTags)/sizeof(TAG_TYPE)];
    DWORD               dwErr, i, dwOperator = DEST_LONGER;
    DWORD               dwViewMask = DEFAULT_VIEW_MASK;
    DWORD               dwProtocol = DEFAULT_PROTO;
    IPV4_ADDRESS        ipMask     = DEFAULT_MASK;
    IPV4_ADDRESS        ipAddress  = DEFAULT_ADDR;
    MIB_OPAQUE_QUERY    QueryBuff[3]; // more than enough
    MIB_OPAQUE_QUERY   *pQuery = QueryBuff;
    DWORD               dwOutEntrySize, dwCount;
    PMIB_OPAQUE_INFO    pRpcInfo;
    PMIB_IPDESTTABLE    lprpcTable;
    WCHAR               wcszBuffer[80], wcszNHop[80];
    WCHAR               wcszName[MAX_INTERFACE_NAME_LEN+1];
    WCHAR               wszViews[3];

    //
    // We can show non persistent info only if router is running
    //

    CHECK_ROUTER_RUNNING();

    // Do generic processing

    dwErr = PreHandleCommand( ppwcArguments,
                              dwCurrentIndex,
                              dwArgCount,
                              pttTags,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              0,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              pdwTagType );

    if (dwErr)
    {
        return dwErr;
    }

    dwArgCount -= dwCurrentIndex;

    for (i=0; i<dwArgCount; i++) 
    {
        switch(pdwTagType[i])
        {
            case 0: // OPERATOR
            {
                TOKEN_VALUE rgEnums[] ={{ TOKEN_VALUE_MATCHING, DEST_MATCHING},
                                        { TOKEN_VALUE_LONGER,   DEST_LONGER },
                                        { TOKEN_VALUE_SHORTER,  DEST_SHORTER}};

                dwErr = MatchEnumTag( g_hModule,
                                      ppwcArguments[i + dwCurrentIndex],
                                      sizeof(rgEnums)/sizeof(TOKEN_VALUE),
                                      rgEnums,
                                      &dwOperator);

                if (dwErr isnot NO_ERROR)
                {
                    DispTokenErrMsg( g_hModule,
                                     MSG_IP_BAD_OPTION_VALUE,
                                     pttTags[pdwTagType[i]].pwszTag,
                                     ppwcArguments[i + dwCurrentIndex] );

                    return ERROR_INVALID_PARAMETER;
                }

                break;
            }

            case 1: // ADDR
            {
                dwErr = GetIpPrefix( ppwcArguments[i+dwCurrentIndex],
                                     &ipAddress,
                                     &ipMask );

                if (dwErr is ERROR_INVALID_PARAMETER)
                {
                    DisplayMessage( g_hModule,  MSG_IP_BAD_IP_ADDR,
                                    ppwcArguments[i + dwCurrentIndex]);

                    DispTokenErrMsg(g_hModule, MSG_IP_BAD_OPTION_VALUE,
                                    pttTags[pdwTagType[i]].pwszTag,
                                    ppwcArguments[i + dwCurrentIndex]);
                    i = dwArgCount;
                    break;
                }
                break;
            }

            case 2: // MASK
            {
                dwErr = GetIpMask( ppwcArguments[i+dwCurrentIndex],
                                   &ipMask );

                if (dwErr is ERROR_INVALID_PARAMETER)
                {
                    DisplayMessage( g_hModule,  MSG_IP_BAD_IP_ADDR,
                                    ppwcArguments[i + dwCurrentIndex]);

                    DispTokenErrMsg(g_hModule, MSG_IP_BAD_OPTION_VALUE,
                                    pttTags[pdwTagType[i]].pwszTag,
                                    ppwcArguments[i + dwCurrentIndex]);
                    i = dwArgCount;
                    break;
                }
                break;
            }

            case 3: // VIEW
            {
                TOKEN_VALUE rgMaskEnums[] = {
                 { TOKEN_VALUE_UNICAST,   RTM_VIEW_MASK_UCAST },
                 { TOKEN_VALUE_MULTICAST, RTM_VIEW_MASK_MCAST },
                 { TOKEN_VALUE_BOTH,      RTM_VIEW_MASK_UCAST
                                         |RTM_VIEW_MASK_MCAST   } };

                dwErr = MatchEnumTag( g_hModule,
                                      ppwcArguments[i + dwCurrentIndex],
                                      sizeof(rgMaskEnums)/sizeof(TOKEN_VALUE),
                                      rgMaskEnums,
                                      &dwViewMask);

                if (dwErr isnot NO_ERROR)
                {
                    DispTokenErrMsg( g_hModule,
                                     MSG_IP_BAD_OPTION_VALUE,
                                     pttTags[pdwTagType[i]].pwszTag,
                                     ppwcArguments[i + dwCurrentIndex] );

                    i = dwArgCount;
                    
                    return ERROR_INVALID_PARAMETER;
                }

                break;
            }

            case 4: // PROTO
            {
                dwProtocol = 
                    MatchRoutingProtoTag(ppwcArguments[i + dwCurrentIndex]);
                break;
            }
        }
    }

    if (dwErr isnot NO_ERROR)
    {
        return dwErr;
    }

    // Compose MIB query

    pQuery->dwVarId = dwOperator;
    pQuery->rgdwVarIndex[0] = ipAddress;
    pQuery->rgdwVarIndex[1] = ipMask;
    pQuery->rgdwVarIndex[2] = dwViewMask;
    pQuery->rgdwVarIndex[3] = dwProtocol;

    dwErr = MibGet(              PID_IP,
                                 IPRTRMGR_PID,
                                 (PVOID) pQuery,
                                 sizeof(MIB_OPAQUE_QUERY) + 3*sizeof(DWORD),
                                 (PVOID *) &pRpcInfo,
                                 &dwOutEntrySize );

    if ( dwErr isnot NO_ERROR )
    {
        DisplayMessage(g_hModule,  MSG_IP_DIM_ERROR, dwErr );
        return dwErr;
    }

    if ( pRpcInfo is NULL )
    {
        DisplayMessage(g_hModule, MSG_IP_NO_ENTRIES );
        return dwErr;
    }

    // Display info
    lprpcTable = (PMIB_IPDESTTABLE)(pRpcInfo->rgbyData);
    dwCount = lprpcTable->dwNumEntries;

    DisplayMessage( g_hModule, MSG_RTR_ROUTE_HDR );

    for (i=0; i<dwCount; i++)
    {
        DWORD BufLen = sizeof(wcszName);
        
        MakePrefixStringW( wcszBuffer, 
                           lprpcTable->table[i].dwForwardDest,
                           lprpcTable->table[i].dwForwardMask );

        if (IpmontrGetFriendlyNameFromIfIndex( g_hMIBServer,
                                    lprpcTable->table[i].dwForwardIfIndex,
                                    wcszName,
                                    BufLen ) != NO_ERROR)
        {
            //
            // If we do not have a name for this index, display index
            //

            swprintf( wcszName, 
                      L"0x%x",
                      lprpcTable->table[i].dwForwardIfIndex );
        }


        MakeAddressStringW( wcszNHop,
                            lprpcTable->table[i].dwForwardNextHop );

        wszViews[0] = (lprpcTable->table[i].dwForwardViewSet & RTM_VIEW_MASK_UCAST)? 'U':' ';
        wszViews[1] = (lprpcTable->table[i].dwForwardViewSet & RTM_VIEW_MASK_MCAST)? 'M':' ';
        wszViews[2] = '\0';

        DisplayMessage( g_hModule, MSG_RTR_ROUTE_INFO,
                         wcszBuffer,
                         GetProtoProtoString( 
                            PROTO_TYPE_UCAST, 
                            0, 
                            lprpcTable->table[i].dwForwardProto ),
                         lprpcTable->table[i].dwForwardPreference,
                         lprpcTable->table[i].dwForwardMetric1,
                         wcszNHop,
                         wszViews,
                         wcszName );
    }

    MprAdminMIBBufferFree( (PVOID) pRpcInfo );

    return dwErr;
}

DWORD
HandleIpShowRtmRoutes(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    TAG_TYPE            pttTags[] = {{TOKEN_OPERATOR,    FALSE,FALSE},
                                     {TOKEN_DEST,        FALSE,FALSE},
                                     {TOKEN_MASK,        FALSE,FALSE},
                                     {TOKEN_VIEW,        FALSE,FALSE},
                                     {TOKEN_PROTOCOL,    FALSE,FALSE}};
    DWORD               pdwTagType[sizeof(pttTags)/sizeof(TAG_TYPE)];
    DWORD               dwErr, i, dwOperator = ROUTE_LONGER;
    DWORD               dwViewMask = DEFAULT_VIEW_MASK;
    DWORD               dwProtocol = DEFAULT_PROTO;
    IPV4_ADDRESS        ipMask     = DEFAULT_MASK;
    IPV4_ADDRESS        ipAddress  = DEFAULT_ADDR;
    MIB_OPAQUE_QUERY    QueryBuff[3]; // more than enough
    MIB_OPAQUE_QUERY   *pQuery = QueryBuff;
    DWORD               dwOutEntrySize, dwCount;
    PMIB_OPAQUE_INFO    pRpcInfo;
    PMIB_IPDESTTABLE    lprpcTable;
    WCHAR               wcszBuffer[80], wcszNHop[80];
    WCHAR               wcszName[MAX_INTERFACE_NAME_LEN+1];
    WCHAR               wszViews[3];

    //
    // We can show non persistent info only if router is running
    //

    CHECK_ROUTER_RUNNING();

    // Do generic processing

    dwErr = PreHandleCommand( ppwcArguments,
                              dwCurrentIndex,
                              dwArgCount,
                              pttTags,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              0,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              pdwTagType );

    if (dwErr)
    {
        return dwErr;
    }

    dwArgCount -= dwCurrentIndex;

    for (i=0; i<dwArgCount; i++) 
    {
        switch(pdwTagType[i])
        {
            case 0: // OPERATOR
            {
                TOKEN_VALUE rgEnums[] ={{ TOKEN_VALUE_MATCHING,ROUTE_MATCHING},
                                        { TOKEN_VALUE_LONGER,  ROUTE_LONGER },
                                        { TOKEN_VALUE_SHORTER, ROUTE_SHORTER}};

                dwErr = MatchEnumTag( g_hModule,
                                      ppwcArguments[i + dwCurrentIndex],
                                      sizeof(rgEnums)/sizeof(TOKEN_VALUE),
                                      rgEnums,
                                      &dwOperator);

                if (dwErr isnot NO_ERROR)
                {
                    DispTokenErrMsg( g_hModule,
                                     MSG_IP_BAD_OPTION_VALUE,
                                     pttTags[pdwTagType[i]].pwszTag,
                                     ppwcArguments[i + dwCurrentIndex] );

                    return ERROR_INVALID_PARAMETER;
                }

                break;
            }

            case 1: // ADDR
            {
                dwErr = GetIpPrefix( ppwcArguments[i+dwCurrentIndex],
                                     &ipAddress,
                                     &ipMask );

                if (dwErr is ERROR_INVALID_PARAMETER)
                {
                    DisplayMessage( g_hModule,  MSG_IP_BAD_IP_ADDR,
                                    ppwcArguments[i + dwCurrentIndex]);

                    DispTokenErrMsg(g_hModule, MSG_IP_BAD_OPTION_VALUE,
                                    pttTags[pdwTagType[i]].pwszTag,
                                    ppwcArguments[i + dwCurrentIndex]);
                    i = dwArgCount;
                    break;
                }
                break;
            }

            case 2: // MASK
            {
                dwErr = GetIpMask( ppwcArguments[i+dwCurrentIndex],
                                   &ipMask );

                if (dwErr is ERROR_INVALID_PARAMETER)
                {
                    DisplayMessage( g_hModule,  MSG_IP_BAD_IP_ADDR,
                                    ppwcArguments[i + dwCurrentIndex]);

                    DispTokenErrMsg(g_hModule, MSG_IP_BAD_OPTION_VALUE,
                                    pttTags[pdwTagType[i]].pwszTag,
                                    ppwcArguments[i + dwCurrentIndex]);
                    i = dwArgCount;
                    break;
                }
                break;
            }

            case 3: // VIEW
            {
                TOKEN_VALUE rgMaskEnums[] = {
                 { TOKEN_VALUE_UNICAST,   RTM_VIEW_MASK_UCAST },
                 { TOKEN_VALUE_MULTICAST, RTM_VIEW_MASK_MCAST },
                 { TOKEN_VALUE_BOTH,      RTM_VIEW_MASK_UCAST
                                         |RTM_VIEW_MASK_MCAST   } };

                dwErr = MatchEnumTag( g_hModule,
                                      ppwcArguments[i + dwCurrentIndex],
                                      sizeof(rgMaskEnums)/sizeof(TOKEN_VALUE),
                                      rgMaskEnums,
                                      &dwViewMask);

                if (dwErr isnot NO_ERROR)
                {
                    DispTokenErrMsg( g_hModule,
                                     MSG_IP_BAD_OPTION_VALUE,
                                     pttTags[pdwTagType[i]].pwszTag,
                                     ppwcArguments[i + dwCurrentIndex] );

                    i = dwArgCount;
                    
                    return ERROR_INVALID_PARAMETER;
                }

                break;
            }

            case 4: // PROTO
            {
                dwProtocol = 
                    MatchRoutingProtoTag(ppwcArguments[i + dwCurrentIndex]);

                break;
            }
        }
    }

    if (dwErr isnot NO_ERROR)
    {
        return dwErr;
    }

    // Compose MIB query

    pQuery->dwVarId = dwOperator;
    pQuery->rgdwVarIndex[0] = ipAddress;
    pQuery->rgdwVarIndex[1] = ipMask;
    pQuery->rgdwVarIndex[2] = dwViewMask;
    pQuery->rgdwVarIndex[3] = dwProtocol;

    dwErr = MibGet(              PID_IP,
                                 IPRTRMGR_PID,
                                 (PVOID) pQuery,
                                 sizeof(MIB_OPAQUE_QUERY) + 3*sizeof(DWORD),
                                 (PVOID *) &pRpcInfo,
                                 &dwOutEntrySize );

    if ( dwErr isnot NO_ERROR )
    {
        DisplayMessage(g_hModule,  MSG_IP_DIM_ERROR, dwErr );
        return dwErr;
    }

    if ( pRpcInfo is NULL )
    {
        DisplayMessage(g_hModule,  MSG_IP_NO_ENTRIES );
        return dwErr;
    }

    // Display info
    lprpcTable = (PMIB_IPDESTTABLE)(pRpcInfo->rgbyData);
    dwCount = lprpcTable->dwNumEntries;

    DisplayMessage( g_hModule, MSG_RTR_ROUTE_HDR );

    for (i=0; i<dwCount; i++)
    {
        DWORD BufLen = sizeof(wcszName);
        
        MakePrefixStringW( wcszBuffer, 
                           lprpcTable->table[i].dwForwardDest,
                           lprpcTable->table[i].dwForwardMask );

        if (IpmontrGetFriendlyNameFromIfIndex( g_hMIBServer,
                                    lprpcTable->table[i].dwForwardIfIndex,
                                    wcszName,
                                    BufLen ) != NO_ERROR)
        {
            //
            // If we do not have a name for this index, display index
            //

            swprintf( wcszName, 
                      L"0x%x",
                      lprpcTable->table[i].dwForwardIfIndex );
        }

        MakeAddressStringW( wcszNHop,
                            lprpcTable->table[i].dwForwardNextHop );

        wszViews[0] = (lprpcTable->table[i].dwForwardViewSet & RTM_VIEW_MASK_UCAST)? 'U':' ';
        wszViews[1] = (lprpcTable->table[i].dwForwardViewSet & RTM_VIEW_MASK_MCAST)? 'M':' ';
        wszViews[2] = '\0';

        DisplayMessage(  g_hModule, 
                         MSG_RTR_ROUTE_INFO, 
                         wcszBuffer,
                         GetProtoProtoString( 
                            PROTO_TYPE_UCAST, 
                            0, 
                            lprpcTable->table[i].dwForwardProto ),
                         lprpcTable->table[i].dwForwardPreference,
                         lprpcTable->table[i].dwForwardMetric1,
                         wcszNHop,
                         wszViews,
                         wcszName );
    }

    MprAdminMIBBufferFree( (PVOID) pRpcInfo );

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ip\ipmon\rtrreset.c ===
//
// This code obtained from KennT  2-June-1999
//
#include "precomp.h"
#pragma hdrstop

// Use the C macros for simpler coding
#define COBJMACROS
#include "remras.h"
#include <objbase.h>

// {1AA7F844-C7F5-11d0-A376-00C04FC9DA04}
const GUID CLSID_RemoteRouterConfig
    = { 0x1aa7f844, 0xc7f5, 0x11d0, { 0xa3, 0x76, 0x0, 0xc0, 0x4f, 0xc9, 0xda, 0x4 } };

// {66A2DB1b-D706-11d0-A37B-00C04FC9DA04}
const GUID IID_IRemoteNetworkConfig = 
    { 0x66a2db1b, 0xd706, 0x11d0, { 0xa3, 0x7b, 0x0, 0xc0, 0x4f, 0xc9, 0xda, 0x4 } };


HRESULT CoCreateRouterConfig(LPCTSTR pszMachine,
							 REFIID riid,
							 IUnknown **ppUnk);
HRESULT RouterReset(LPCTSTR pszMachineName);


#ifdef STANDALONE
void main(int argc, char *argv[])
{
    LPCTSTR pszMachineName = NULL;
    HRESULT hr;
    
    if (argc > 1)
        pszMachineName = argv[1];

    hr = RouterReset(pszMachineName);

    printf("hr=%d\n", hr);
}
#endif

HRESULT RouterReset(LPCTSTR pszMachineName)
{
    IRemoteNetworkConfig *  pNetwork = NULL;
    HRESULT                 hr = S_OK;

    // CoInitialize unless it's already been done
    // ----------------------------------------------------------------
    
    if (CoInitialize(NULL) == S_OK)
    {
        // Create the router configuration object
        // ------------------------------------------------------------
        hr = CoCreateRouterConfig(pszMachineName,
                                  &IID_IRemoteNetworkConfig,
                                  (IUnknown **) &pNetwork);
                                  

        if (hr == S_OK)
        {
            // Ok we succeeded in creating the object, now let's
            // have it do the upgrade.
            // --------------------------------------------------------
            IRemoteNetworkConfig_UpgradeRouterConfig(pNetwork);
            IRemoteNetworkConfig_Release(pNetwork);
            pNetwork = NULL;
        }

        CoUninitialize();
    }

    return hr;
}


/*!--------------------------------------------------------------------------
	CoCreateRouterConfig
        -
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT CoCreateRouterConfig(LPCTSTR pszMachine,
                             REFIID riid,
							 IUnknown **ppUnk)
{
	HRESULT		hr = S_OK;
	MULTI_QI	qi;

	*ppUnk = NULL;

    if ((pszMachine == NULL) || (*pszMachine == 0))
	{
        // Hmmm.. this points to a security hole, can anyone
        // create this object?  I need to check for the proper
        // access rights.
        // ------------------------------------------------------------
		hr = CoCreateInstance(&CLSID_RemoteRouterConfig,
							  NULL,
							  CLSCTX_SERVER,
							  riid,
							  (LPVOID *) &(qi.pItf));
	}
	else
	{
		qi.pIID = riid;
		qi.pItf = NULL;
		qi.hr = 0;

		hr = CoCreateInstanceEx(&CLSID_RemoteRouterConfig,
								NULL,
								CLSCTX_SERVER,
								NULL,
								1,
								&qi);
	}

    if (hr == S_OK)
	{
		*ppUnk = qi.pItf;
		qi.pItf = NULL;
	}
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ip\ipmon\showmib.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:
     net\routing\monitor\ip\showmib.h   

Abstract:

    

Author:

     Anand Mahalingam    7/10/98

Revision History:


--*/

#ifndef __IPMON_SHOWMIB_H__
#define __IPMON_SHOWMIB_H__

#define MAX_NUM_INDICES 6

typedef
DWORD
(*PGET_OPT_FN)(
    IN    PTCHAR   *pptcArguments,
    IN    DWORD    dwCurrentIndex,
    OUT   PDWORD   pdwIndices,
    OUT   PDWORD   pdwNumParsed 
    );

typedef struct _MIB_OBJECT_PARSER
{
    PWCHAR         pwszMIBObj;
    DWORD          dwMinOptArg;
    PGET_OPT_FN    pfnMIBObjParser;
} MIB_OBJECT_PARSER,*PMIB_OBJECT_PARSER;

DWORD
GetMIBIfIndex(
    IN    PTCHAR   *pptcArguments,
    IN    DWORD    dwCurrentIndex,
    OUT   PDWORD   pdwIndices,
    OUT   PDWORD   pdwNumParsed 
);

DWORD
GetMIBIpAddress(
    IN    PTCHAR    *pptcArguments,
    IN    DWORD    dwCurrentIndex,
    OUT   PDWORD   pdwIndices,
    OUT   PDWORD   pdwNumParsed 
);

    
DWORD
GetMIBIpFwdIndex(
    IN    PTCHAR    *pptcArguments,
    IN    DWORD    dwCurrentIndex,
    OUT   PDWORD   pdwIndices,
    OUT   PDWORD   pdwNumParsed 
);

DWORD
GetMIBIpNetIndex(
    IN    PTCHAR    *pptcArguments,
    IN    DWORD    dwCurrentIndex,
    OUT   PDWORD   pdwIndices,
    OUT   PDWORD   pdwNumParsed 
);

DWORD
GetMIBTcpConnIndex(
    IN    PTCHAR    *pptcArguments,
    IN    DWORD    dwCurrentIndex,
    OUT   PDWORD   pdwIndices,
    OUT   PDWORD   pdwNumParsed 
);

DWORD
GetMIBUdpConnIndex(
    IN    PTCHAR    *pptcArguments,
    IN    DWORD    dwCurrentIndex,
    OUT   PDWORD   pdwIndices,
    OUT   PDWORD   pdwNumParsed 
);


extern MIB_OBJECT_PARSER    MIBObjectMap[];
extern ULONG                g_ulNumMibObjects;
extern HANDLE               g_hConsole;

typedef
VOID
(PRINT_FN)(
    IN MIB_SERVER_HANDLE hMibServer,
    IN PMIB_OPAQUE_INFO  pInfo
    );

PRINT_FN PrintIpForwardTable;
PRINT_FN PrintIpForwardRow;

VOID
PrintMfeTable(
    MIB_SERVER_HANDLE hMibServer,
    PMIB_OPAQUE_INFO prpcInfo,
    PDWORD           pdwLastGrp,
    PDWORD           pdwLastSrc,
    PDWORD           pdwLastSrcMask,
    DWORD            dwRangeGrp,
    DWORD            dwRangeGrpMask,
    DWORD            dwRangeSrc,
    DWORD            dwRangeSrcMask,
    DWORD            dwType,
    PBOOL            pbDone
    );

VOID
PrintMfeStatsTable(
    MIB_SERVER_HANDLE hMibServer,
    PMIB_OPAQUE_INFO prpcInfo,
    PDWORD           pdwLastGrp,
    PDWORD           pdwLastSrc,
    PDWORD           pdwLastSrcMask,
    DWORD            dwRangeGrp,
    DWORD            dwRangeGrpMask,
    DWORD            dwRangeSrc,
    DWORD            dwRangeSrcMask,
    DWORD            dwType,
    PBOOL            pbDone,
    BOOL             bStatsAll
);

DWORD
GetMfe(
    MIB_SERVER_HANDLE   hMIBServer,
    BOOL                bIndexPresent,
    PTCHAR             *pptcAruments,
    DWORD               dwNumArg,
    BOOL                bIncludeStats
);

DWORD
GetPrintDestinationInfo(
    MIB_SERVER_HANDLE   hMprMIB,
    BOOL                bIndexPresent,
    PWCHAR             *ppwcArguments,
    DWORD               dwArgCount
    );

DWORD
GetPrintRouteInfo(
    MIB_SERVER_HANDLE   hMprMIB,
    BOOL                bIndexPresent,
    PWCHAR             *ppwcArguments,
    DWORD               dwArgCount
    );

void cls(HANDLE hConsole);

BOOL WINAPI HandlerRoutine(
    DWORD dwCtrlType   //  control signal type
    );


#define PRINT_IPADDR(x) \
    ((x)&0x000000ff),(((x)&0x0000ff00)>>8),(((x)&0x00ff0000)>>16),(((x)&0xff000000)>>24)

typedef PRINT_FN *PPRINT_FN;

typedef struct _MAGIC_TABLE
{
    DWORD      dwId;
    PPRINT_FN  pfnPrintFunction;
}MAGIC_TABLE, *PMAGIC_TABLE;

extern MAGIC_TABLE    MIBVar[];

#define IGMP_GETMODE_EXACT  0
#define IGMP_GETMODE_FIRST  1
#define IGMP_GETMODE_NEXT   2

#define DISPLAYLEN_PHYSADDR 3*MAXLEN_PHYSADDR + 8

#ifdef UNICODE
#define MakeUnicodePhysAddr(ptszUnicode,pszAddr,dwLen)      \
{                                                           \
    CHAR __szTemp[DISPLAYLEN_PHYSADDR + 1];                 \
    DWORD __i,__dwTempLen;                                  \
    __dwTempLen = (((dwLen) <= MAXLEN_PHYSADDR) ? (dwLen) : MAXLEN_PHYSADDR); \
    for(__i = 0; __i < __dwTempLen; __i++)                  \
    {                                                       \
        sprintf(&(__szTemp[3*__i]),"%02X-",pszAddr[__i]);   \
    }                                                       \
    MultiByteToWideChar(GetConsoleOutputCP(),                             \
                        0,                                  \
                        (__szTemp),                         \
                        -1,                                 \
                        (ptszUnicode),                      \
                        3*__i);                             \
    ptszUnicode[(3*__i) - 1] = TEXT('\0');                  \
}
#else
#define MakeUnicodePhysAddr(ptszUnicode,pszAddr,dwLen)      \
{                                                           \
    CHAR __szTemp[DISPLAYLEN_PHYSADDR + 1];                 \
    DWORD __i,__dwTempLen;                                  \
    __dwTempLen = (((dwLen) <= MAXLEN_PHYSADDR) ? (dwLen) : MAXLEN_PHYSADDR); \
    for(__i = 0; __i < __dwTempLen; __i++)                  \
    {                                                       \
        sprintf(&(__szTemp[3*__i]),"%02X-",pszAddr[__i]);   \
    }                                                       \
    strncpy((ptszUnicode),__szTemp,3*__i);                  \
    ptszUnicode[(3*__i) - 1] = TEXT('\0');                  \
}
#endif //UNICODE

FN_HANDLE_CMD HandleIpMibShowObject;

#endif // __IPMON_SHOWMIB_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ip\ipmon\showmib.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:
     net\routing\netsh\ip\showmib.c    

Abstract:

    Fns to parse and show MIB information

Author:

     v raman

Revision History:

     Anand Mahalingam
--*/

#include "precomp.h"
#pragma hdrstop

enum MFETYPES 
{
    NegativeMfe = 0, PositiveMfe, Both
};


HANDLE g_hConsole, g_hStdOut;

MIB_OBJECT_PARSER   MIBObjectMap[] =
{
//  {TOKEN_MIB_OBJECT_IPFORWARD,3,GetMIBIpFwdIndex},
    {TOKEN_MIB_OBJECT_MFE,0,NULL},
    {TOKEN_MIB_OBJECT_MFESTATS,0,NULL},
    {TOKEN_MIB_OBJECT_BOUNDARY,0,NULL},
    {TOKEN_MIB_OBJECT_SCOPE,0,NULL},
    {TOKEN_MIB_OBJECT_RTMDESTINATIONS,0,NULL},
    {TOKEN_MIB_OBJECT_RTMROUTES,0,NULL}
};

ULONG   g_ulNumMibObjects = sizeof(MIBObjectMap)/sizeof(MIB_OBJECT_PARSER);

MAGIC_TABLE    MIBVar[] = {
//  {IP_FORWARDROW, PrintIpForwardRow},
//  {IP_FORWARDTABLE, PrintIpForwardTable},
    {MCAST_MFE, NULL},
    {MCAST_MFE, NULL},
    {MCAST_MFE_STATS, NULL},
    {MCAST_MFE_STATS, NULL},
    {MCAST_BOUNDARY, NULL},
    {MCAST_BOUNDARY, NULL},
    {MCAST_SCOPE, NULL},
    {MCAST_SCOPE, NULL},
    {0, NULL}, // destinations, unused
    {0, NULL}, // destinations, unused
    {0, NULL}, // routes, unused
    {0, NULL}, // routes, unused
};

#if 0
DWORD
GetMIBIpFwdIndex(
    IN    PTCHAR    *ppwcArguments,
    IN    DWORD    dwCurrentIndex,
    OUT   PDWORD   pdwIndices,
    OUT   PDWORD   pdwNumParsed 
    )
/*++

Routine Description:

    Gets the IP forward index

Arguments:

    ppwcArguments  - Argument array
    dwCurrentIndex - Index of the first argument in array
    pdwIndices     - Indices specified in command
    pdwNumParsed   - Number of indices in command
    
Return Value:

    NO_ERROR
    
--*/
{
    DWORD dwErr = GetIpAddress(ppwcArguments[dwCurrentIndex], &pdwIndices[0]);

    if (dwErr isnot NO_ERROR)
    {
        return dwErr;
    }

    pdwIndices[1] = _tcstoul(ppwcArguments[dwCurrentIndex + 1],NULL,10);

    dwErr = GetIpAddress(ppwcArguments[dwCurrentIndex + 2], &pdwIndices[2]);

    pdwIndices[3] = 0;

    *pdwNumParsed = 4;

    return dwErr;
}
#endif

DWORD
HandleIpMibShowObject(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description:

    Parses command to get MIB object and optional parameters

Arguments:

Return Value:

--*/
{
    DWORD                dwIndices[MAX_NUM_INDICES];
    DWORD                dwNumParsed = 0;
    PMIB_OPAQUE_QUERY    pQuery = NULL;
    PMIB_OPAQUE_INFO     pRpcInfo;
    DWORD                dwQuerySize;
    BOOL                 bFound = FALSE,bOptPresent = FALSE;
    DWORD                dwRefreshRate;
    DWORD                dwOutEntrySize;
    DWORD                i,dwResult = NO_ERROR,dwErr;
    DWORD                dwMIBIndex, dwIndex;
    BOOL                 bIndex = FALSE, dwType;
    DWORD                dwRR = 0, dwInd = 0;
    HANDLE               hMib;
    

    
    if ( ! IsRouterRunning() )
    {
        if (g_pwszRouter)
        {
            DisplayMessage(g_hModule, 
                           MSG_IP_REMOTE_ROUTER_NOT_RUNNING, 
                           g_pwszRouter);
        } 
        else 
        {
            DisplayMessage(g_hModule, 
                           MSG_IP_LOCAL_ROUTER_NOT_RUNNING);
        }

        return NO_ERROR;
    }
    
    //
    // Match MIB object
    //

    ppwcArguments += (dwCurrentIndex-1);
    dwArgCount    -= (dwCurrentIndex-1);
    dwCurrentIndex = 1;

    //DEBUG2("In IP MIB Show : %s\n",ppwcArguments[0]);

    for (i = 0; i < sizeof(MIBObjectMap)/sizeof(MIB_OBJECT_PARSER); i++)
    {
        if (MatchToken(ppwcArguments[0],MIBObjectMap[i].pwszMIBObj))
        {
            dwIndex = i;
            bFound = TRUE;
        
            DEBUG("found");
        
            break;
        }
    
    }
    
    if (!bFound)
    {
        return ERROR_CMD_NOT_FOUND;
    }


    if (!MatchToken( MIBObjectMap[dwIndex].pwszMIBObj,
                 TOKEN_MIB_OBJECT_RTMDESTINATIONS)
     && !MatchToken( MIBObjectMap[dwIndex].pwszMIBObj,
                 TOKEN_MIB_OBJECT_RTMROUTES))
    {
        dwErr = GetMibTagToken(&ppwcArguments[1],
                               dwArgCount - 1,
                               MIBObjectMap[dwIndex].dwMinOptArg,
                               &dwRR,
                               &bIndex,
                               &dwInd);

	    if (dwErr isnot NO_ERROR)
	    {
	        return ERROR_INVALID_SYNTAX;
	    }
    }

    
    if (bIndex)
    {
        dwMIBIndex = dwIndex * 2;
        bOptPresent = TRUE;
    }
    else
    {
        dwMIBIndex = dwIndex * 2 + 1;
    }

    //
    // Convert refresh rate to msec
    //
    
    dwRR *= 1000;

    if (!InitializeConsole(&dwRR, &hMib, &g_hConsole))
    {
        return ERROR_INIT_DISPLAY;
    }

    //
    // Query the MIB
    //

    pQuery = NULL;

    for ( ; ; )
    {
        if(dwRR)
        {
            DisplayMessageToConsole(g_hModule,
                              g_hConsole,
                              MSG_CTRL_C_TO_QUIT);
        }

        if (MatchToken(MIBObjectMap[dwIndex].pwszMIBObj, 
                       TOKEN_MIB_OBJECT_BOUNDARY))
        {
            dwResult = GetPrintBoundaryInfo(g_hMIBServer);
        }

        else if (MIBVar[ dwMIBIndex ].dwId is MCAST_MFE)
        {
            //
            // Call the special function
            //

            GetMfe( 
                g_hMIBServer, bIndex, ppwcArguments + 1, dwArgCount - 1, FALSE 
                );
        }

        else if(MIBVar[ dwMIBIndex ].dwId is MCAST_MFE_STATS)
        {
            //
            // Call the special function
            //
    
            GetMfe( 
                g_hMIBServer, bIndex, ppwcArguments + 1, dwArgCount - 1, TRUE
                );
        }
        else
        {
            //
            // For all else, the generic one is just fine
            //
    
            if (!(dwMIBIndex % 2))
            {
                (*MIBObjectMap[dwIndex].pfnMIBObjParser)(ppwcArguments,
                                                         1,
                                                         dwIndices,
                                                         &dwNumParsed);
            }

            dwQuerySize = ( sizeof( MIB_OPAQUE_QUERY ) - sizeof( DWORD ) ) + 
                (dwNumParsed) * sizeof(DWORD);
        
            pQuery = (PMIB_OPAQUE_QUERY)HeapAlloc(GetProcessHeap(),
                                                  0,
                                                  dwQuerySize);
    
    
            if (pQuery is NULL)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                DisplayMessage(g_hModule, MSG_IP_NOT_ENOUGH_MEMORY);
        
                return dwErr;
            }

            pQuery->dwVarId = MIBVar[dwMIBIndex].dwId;
    
            for( i = 0; i < dwNumParsed; i++ )
            {
                pQuery->rgdwVarIndex[i] = dwIndices[i];
            }
        
            dwResult = MibGet(             PID_IP,
                                           IPRTRMGR_PID,
                                           (PVOID) pQuery,
                                           dwQuerySize,
                                           (PVOID *) &pRpcInfo,
                                           &dwOutEntrySize );
    
            if ( dwResult isnot NO_ERROR )
            {
                DisplayMessage(g_hModule,  MSG_IP_DIM_ERROR, dwResult );
                return dwResult;
            }
        
            if ( pRpcInfo is NULL )
            {
                DisplayMessage(g_hModule,  MSG_IP_NO_ENTRIES );
                return dwResult;
            }

            (*MIBVar[dwMIBIndex].pfnPrintFunction)(g_hMIBServer, pRpcInfo);

            MprAdminMIBBufferFree( (PVOID) pRpcInfo );
        }
    
        if(pQuery != NULL )
        {
            HeapFree(GetProcessHeap(),0,pQuery);
        }

        if (!RefreshConsole(hMib, g_hConsole, dwRR))
        {
            break;
        }
    }
    
    return dwResult;
}
    
#if 0
VOID 
PrintIpForwardTable(
    MIB_SERVER_HANDLE hMibServer,
    PMIB_OPAQUE_INFO prpcInfo
    )
/*++

Routine Description:

    Prints IP forward table.

Arguments:

Return Value:

--*/
{
    WCHAR wszFriendlyName[MAX_INTERFACE_NAME_LEN + 1];
    PMIB_IPFORWARDTABLE lprpcTable = (PMIB_IPFORWARDTABLE)(prpcInfo->rgbyData);
    TCHAR               tszMask[ADDR_LENGTH + 1],
                        tszDest[ADDR_LENGTH + 1],
                        tszNextHop[ADDR_LENGTH + 1];
    PTCHAR              ptszType, ptszProto;
    DWORD               i, dwErr = NO_ERROR;

    DisplayMessageToConsole(g_hModule, g_hConsole,MSG_MIB_FORWARD_HDR);
    
    if(lprpcTable->dwNumEntries is 0)
    {
        DisplayMessageToConsole(g_hModule, g_hConsole,MSG_IP_NO_ENTRIES);
        return;
    }
    
    for(i = 0; i < lprpcTable->dwNumEntries; i++)
    {
        switch(lprpcTable->table[i].dwForwardProto)
        {
            case MIB_IPPROTO_LOCAL:
            {
                ptszProto = MakeString(g_hModule, STRING_LOCAL);
                break;
            }
            case MIB_IPPROTO_NETMGMT:
            {
                ptszProto = MakeString(g_hModule, STRING_NETMGMT);
                break;
            }
            case MIB_IPPROTO_ICMP:
            {
                ptszProto = MakeString(g_hModule, STRING_ICMP);
                break;
            }
            case MIB_IPPROTO_EGP:
            {
                ptszProto = MakeString(g_hModule, STRING_EGP);
                break;
            }
            case MIB_IPPROTO_GGP:
            {
                ptszProto = MakeString(g_hModule, STRING_GGP);
                break;
            }
            case MIB_IPPROTO_HELLO:
            {
                ptszProto = MakeString(g_hModule, STRING_HELLO);
                break;
            }
            case MIB_IPPROTO_RIP:
            {
                ptszProto = MakeString(g_hModule, STRING_RIP);
                break;
            }
            case MIB_IPPROTO_IS_IS:
            {
                ptszProto = MakeString(g_hModule, STRING_IS_IS);
                break;
            }
            case MIB_IPPROTO_ES_IS:
            {
                ptszProto = MakeString(g_hModule, STRING_ES_IS);
                break;
            }
            case MIB_IPPROTO_CISCO:
            {
                ptszProto = MakeString(g_hModule, STRING_CISCO);
                break;
            }
            case MIB_IPPROTO_BBN:
            {
                ptszProto = MakeString(g_hModule, STRING_BBN);
                break;
            }
            case MIB_IPPROTO_OSPF:
            {
                ptszProto = MakeString(g_hModule, STRING_OSPF);
                break;
            }
            case MIB_IPPROTO_BGP:
            {
                ptszProto = MakeString(g_hModule, STRING_BGP);
                break;
            }
            case MIB_IPPROTO_OTHER:
            default:
            {
                ptszProto = MakeString(g_hModule, STRING_OTHER);
                break;
            }
        }
    
        switch(lprpcTable->table[i].dwForwardType)
        {
            case MIB_IPROUTE_TYPE_INVALID:
            {
                ptszType = MakeString(g_hModule, STRING_INVALID);
                break;
            }
            case MIB_IPROUTE_TYPE_DIRECT:
            {
                ptszType = MakeString(g_hModule, STRING_DIRECT);
                break;
            }
            case MIB_IPROUTE_TYPE_INDIRECT:
            {
                ptszType = MakeString(g_hModule, STRING_INDIRECT);
                break;
            }
            case MIB_IPROUTE_TYPE_OTHER:
            default:
            {
                ptszType = MakeString(g_hModule, STRING_OTHER);
                break;
            }
        }
    
        MakeUnicodeIpAddr(tszDest, 
                          inet_ntoa(*((struct in_addr *)
                                      (&lprpcTable->table[i].dwForwardDest))));
        MakeUnicodeIpAddr(tszMask, 
                          inet_ntoa(*((struct in_addr *)
                                      (&lprpcTable->table[i].dwForwardMask))));
        MakeUnicodeIpAddr(tszNextHop, 
                          inet_ntoa(*((struct in_addr *)
                                   (&lprpcTable->table[i].dwForwardNextHop))));

        {
            DWORD BufLen = sizeof(wszFriendlyName);

            dwErr = IpmontrGetFriendlyNameFromIfIndex( 
                          hMibServer,
                          lprpcTable->table[i].dwForwardIfIndex,
                          wszFriendlyName,
                          BufLen );
        }
        
        DisplayMessageToConsole(g_hModule, g_hConsole,MSG_MIB_FORWARD_ENTRY,
                          tszDest,
                          tszMask,
                          lprpcTable->table[i].dwForwardPolicy,
                          tszNextHop,
                          wszFriendlyName,
                          ptszType,
                          ptszProto,
                          lprpcTable->table[i].dwForwardAge,
                          lprpcTable->table[i].dwForwardNextHopAS,
                          lprpcTable->table[i].dwForwardMetric1,
                          lprpcTable->table[i].dwForwardMetric2,
                          lprpcTable->table[i].dwForwardMetric3,
                          lprpcTable->table[i].dwForwardMetric4,
                          lprpcTable->table[i].dwForwardMetric5);
        
        FreeString(ptszType);
        FreeString(ptszProto);
    }
}

VOID 
PrintIpForwardRow(
    MIB_SERVER_HANDLE hMibServer,
    PMIB_OPAQUE_INFO prpcInfo
    )
/*++

Routine Description:

    Prints Ip forward table row.

Arguments:

Return Value:

--*/
{
    WCHAR             wszFriendlyName[MAX_INTERFACE_NAME_LEN + 1];
    PMIB_IPFORWARDROW ireRow = (PMIB_IPFORWARDROW)(prpcInfo->rgbyData);
    TCHAR             tszMask[ADDR_LENGTH + 1],
                      tszDest[ADDR_LENGTH + 1],
                      tszNextHop[ADDR_LENGTH + 1];
    PTCHAR            ptszType, ptszProto;
    DWORD             dwErr = NO_ERROR;
    
    DisplayMessageToConsole(g_hModule, g_hConsole,MSG_MIB_FORWARD_HDR);
    
    switch(ireRow->dwForwardProto)
    {
        case MIB_IPPROTO_LOCAL:
        {
            ptszProto = MakeString(g_hModule, STRING_LOCAL);
            break;
        }
        case MIB_IPPROTO_NETMGMT:
        {
            ptszProto = MakeString(g_hModule, STRING_NETMGMT);
            break;
        }
        case MIB_IPPROTO_ICMP:
        {
            ptszProto = MakeString(g_hModule, STRING_ICMP);
            break;
        }
        case MIB_IPPROTO_EGP:
        {
            ptszProto = MakeString(g_hModule, STRING_EGP);
            break;
        }
        case MIB_IPPROTO_GGP:
        {
            ptszProto = MakeString(g_hModule, STRING_GGP);
            break;
        }
        case MIB_IPPROTO_HELLO:
        {
            ptszProto = MakeString(g_hModule, STRING_HELLO);
            break;
        }
        case MIB_IPPROTO_RIP:
        {
            ptszProto = MakeString(g_hModule, STRING_RIP);
            break;
        }
        case MIB_IPPROTO_IS_IS:
        {
            ptszProto = MakeString(g_hModule, STRING_IS_IS);
            break;
        }
        case MIB_IPPROTO_ES_IS:
        {
            ptszProto = MakeString(g_hModule, STRING_ES_IS);
            break;
        }
        case MIB_IPPROTO_CISCO:
        {
            ptszProto = MakeString(g_hModule, STRING_CISCO);
            break;
        }
        case MIB_IPPROTO_BBN:
        {
            ptszProto = MakeString(g_hModule, STRING_BBN);
            break;
        }
        case MIB_IPPROTO_OSPF:
        {
            ptszProto = MakeString(g_hModule, STRING_OSPF);
            break;
        }
        case MIB_IPPROTO_BGP:
        {
            ptszProto = MakeString(g_hModule, STRING_BGP);
            break;
        }
        case MIB_IPPROTO_OTHER:
        default:
        {
            ptszProto = MakeString(g_hModule, STRING_OTHER);
            break;
        }
    }
    
    switch(ireRow->dwForwardType)
    {
        case MIB_IPROUTE_TYPE_INVALID:
        {
            ptszType = MakeString(g_hModule, STRING_INVALID);
            break;
        }
        case MIB_IPROUTE_TYPE_DIRECT:
        {
            ptszType = MakeString(g_hModule, STRING_DIRECT);
            break;
        }
        case MIB_IPROUTE_TYPE_INDIRECT:
        {
            ptszType = MakeString(g_hModule, STRING_INDIRECT);
            break;
        }
        case MIB_IPROUTE_TYPE_OTHER:
        default:
        {
            ptszType = MakeString(g_hModule, STRING_OTHER);
            break;
        }
    }
    
    MakeUnicodeIpAddr(tszDest,
                      inet_ntoa(*((struct in_addr *)
                                  (&ireRow->dwForwardDest))));
    MakeUnicodeIpAddr(tszMask,
                      inet_ntoa(*((struct in_addr *)
                                  (&ireRow->dwForwardMask))));
    MakeUnicodeIpAddr(tszNextHop,
                      inet_ntoa(*((struct in_addr *)
                                  (&ireRow->dwForwardNextHop))));

    {
        DWORD BufLen = sizeof(wszFriendlyName);
        dwErr = IpmontrGetFriendlyNameFromIfIndex( hMibServer,
                                        ireRow->dwForwardIfIndex,
                                        wszFriendlyName,
                                        BufLen );
    }
    
    DisplayMessageToConsole(g_hModule, g_hConsole,MSG_MIB_FORWARD_ENTRY,
                      tszDest,
                      tszMask,
                      ireRow->dwForwardPolicy,
                      tszNextHop,
                      wszFriendlyName,
                      ptszType,
                      ptszProto,
                      ireRow->dwForwardAge,
                      ireRow->dwForwardNextHopAS,
                      ireRow->dwForwardMetric1,
                      ireRow->dwForwardMetric2,
                      ireRow->dwForwardMetric3,
                      ireRow->dwForwardMetric4,
                      ireRow->dwForwardMetric5);
    
    FreeString(ptszType);
    FreeString(ptszProto);
    
}
#endif

VOID
PrintMfeTable(
    MIB_SERVER_HANDLE           hMibServer,
    PMIB_OPAQUE_INFO            prpcInfo,
    PDWORD                      pdwLastGrp,
    PDWORD                      pdwLastSrc,
    PDWORD                      pdwLastSrcMask,
    DWORD                       dwRangeGrp,
    DWORD                       dwRangeGrpMask,
    DWORD                       dwRangeSrc,
    DWORD                       dwRangeSrcMask,
    DWORD                       dwType,
    PBOOL                       pbDone
    )
/*++

Routine Description:

    Prints MFE table information.

Arguments:

Return Value:

--*/
{
    WCHAR               wszFriendlyName[MAX_INTERFACE_NAME_LEN + 1];
    INT                 iCmp;
    DWORD               i, j, dwErr = NO_ERROR;
    TCHAR               ptszSource[ADDR_LENGTH + 1];
    TCHAR               ptszGroup[ADDR_LENGTH + 1];
    TCHAR               ptszUpstrm[ADDR_LENGTH + 1];
    TCHAR               ptszBuffer[80];
    TCHAR               ptszIf[18 + 1];
    
    PMIB_MFE_TABLE      pTable;
    PMIB_IPMCAST_MFE    pmimm;
    

    pTable = ( PMIB_MFE_TABLE )( prpcInfo-> rgbyData );

    if ( pTable->dwNumEntries is 0 )
    {
        DisplayMessageToConsole( g_hModule, g_hConsole,MSG_MIB_NO_MFES );

        return;
    }

    
    pmimm = pTable-> table;

    for( i = 0; i < pTable->dwNumEntries; i++ )
    {
        *pdwLastGrp = pmimm-> dwGroup;

        *pdwLastSrc = pmimm-> dwSource ;

        *pdwLastSrcMask = pmimm-> dwSrcMask ;
        

        //
        // Check if the MFEs are in the range provided 
        //
        
        if ( dwRangeGrp && dwRangeGrpMask &&
             ( ( dwRangeGrp & dwRangeGrpMask ) != 
               ( pmimm-> dwGroup & dwRangeGrpMask ) ) )
        {
            *pbDone = TRUE;
            break;
        }

        if ( dwRangeSrc && dwRangeSrcMask &&
             ( ( dwRangeSrc & dwRangeSrcMask ) !=
               ( pmimm-> dwSource & dwRangeSrcMask ) ) )
        {
            continue;
        }
        
        if ( ( dwType == Both ) ||
             ( ( dwType == PositiveMfe ) && ( pmimm-> ulNumOutIf ) ) ||
             ( ( dwType == NegativeMfe ) && ( !pmimm-> ulNumOutIf ) ) )
        {
            MakePrefixStringW( ptszGroup, pmimm-> dwGroup, 0xFFFFFFFF );

            MakePrefixStringW( ptszSource, pmimm-> dwSource, pmimm-> dwSrcMask );

            MakeAddressStringW( ptszUpstrm, pmimm-> dwUpStrmNgbr );

            {
                DWORD BufLen = sizeof(wszFriendlyName);
                IpmontrGetFriendlyNameFromIfIndex( 
                   hMibServer, pmimm-> dwInIfIndex, wszFriendlyName,
                   BufLen 
                   );
            }
            
            if ( wcslen(wszFriendlyName) < 18 )
            {
                #pragma prefast(suppress:69, "Inefficient use of wsprintf: dont need")
                wsprintf( ptszIf, L"%-18.18s", wszFriendlyName );
            }

            else
            {
                wsprintf(
                    ptszIf, L"%-12.12s...%-3.3s", wszFriendlyName, 
                    &wszFriendlyName[wcslen(wszFriendlyName) - 3]
                    );
            }
            
            wsprintf( 
                ptszBuffer, L"\n%18.18s %18.18s %-6.6s %-18.18s %15.15s",
                ptszGroup, ptszSource,
                GetProtoProtoString( 
                    PROTO_TYPE_MCAST, 0, 
                    pmimm-> dwInIfProtocol
                    ),
                ptszIf, ptszUpstrm
                );
                
            DisplayMessageToConsole(
                g_hModule, g_hConsole, MSG_MIB_MFE, ptszBuffer
                );

            for (j = 0; j < pmimm-> ulNumOutIf; j++)
            {
                DWORD BufLen = sizeof(wszFriendlyName);
                IpmontrGetFriendlyNameFromIfIndex( 
                    hMibServer, pmimm-> rgmioOutInfo[j].dwOutIfIndex, 
                    wszFriendlyName,
                    BufLen
                    );

                if ( wcslen(wszFriendlyName) < 18 )
                {
                    #pragma prefast(suppress:69, "Inefficient use of wsprintf: dont need")
                    wsprintf( ptszIf, L"%-18.18s", wszFriendlyName );
                }

                else
                {
                    wsprintf(
                        ptszIf, L"%-12.12s...%-3.3s", wszFriendlyName, 
                        &wszFriendlyName[wcslen(wszFriendlyName) - 3]
                        );
                }

                MakeAddressStringW( ptszUpstrm, pmimm-> rgmioOutInfo[j].dwNextHopAddr );
                
                wsprintf(
                    ptszBuffer,
                    L"\n                                             %-18.18s %15.15s",
                    ptszIf, ptszUpstrm
                    );
                    
                DisplayMessageToConsole(
                    g_hModule, g_hConsole, MSG_MIB_MFE, ptszBuffer
                    );
            }
        }
        
        pmimm = (PMIB_IPMCAST_MFE)
            ((PBYTE) pmimm + SIZEOF_MIB_MFE( pmimm-> ulNumOutIf ));
    }
}

//----------------------------------------------------------------------------
// PrintMfeStatsTable
//
//
//----------------------------------------------------------------------------

VOID
PrintMfeStatsTable(
    MIB_SERVER_HANDLE           hMibServer,
    PMIB_OPAQUE_INFO            prpcInfo,
    PDWORD                      pdwLastGrp,
    PDWORD                      pdwLastSrc,
    PDWORD                      pdwLastSrcMask,
    DWORD                       dwRangeGrp,
    DWORD                       dwRangeGrpMask,
    DWORD                       dwRangeSrc,
    DWORD                       dwRangeSrcMask,
    DWORD                       dwType,
    PBOOL                       pbDone,
    BOOL                        bStatsAll
    )
/*++

Routine Description:

    Prints MFE stats table information.

Arguments:

Return Value:

--*/
{
    WCHAR                       wszFriendlyName[MAX_INTERFACE_NAME_LEN + 1];

    INT                         iCmp;
    
    DWORD                       i, j, dwIndex, dwErr = NO_ERROR, 
                                dwNextMfe;
    
    TCHAR                       ptszSource[ ADDR_LENGTH + 1 ], 
                                ptszGroup[ ADDR_LENGTH + 1 ],
                                ptszSrcMask[ ADDR_LENGTH + 1 ],
                                ptszUpstrm[ ADDR_LENGTH + 1 ],
                                ptszIf[ 18 + 1 ];
                                
    TCHAR                       ptszBuffer[ 256 ];
                    
    ULONG                       ulCurrLen, ulStringLen;
    
    PTCHAR                      ptcString;
    
    PMIB_MFE_STATS_TABLE        pTable;

    PMIB_IPMCAST_MFE_STATS      pmims;

    PMIB_IPMCAST_OIF_STATS      pmimos;


    //
    // get stats table
    //
    
    pTable = (PMIB_MFE_STATS_TABLE)( prpcInfo->rgbyData );

    if ( pTable->dwNumEntries is 0 )
    {
        //
        // no MFEs present.
        //

        return;
    }


    pmims = pTable-> table;
    
    //
    // Display MFE
    // - display header and incoming stats
    // - display multiple outgoing stats
    //

    for (i = 0; i < pTable->dwNumEntries; i++)
    {
        *pdwLastGrp = pmims-> dwGroup;
        
        *pdwLastSrc = pmims-> dwSource;
        
        *pdwLastSrcMask = pmims-> dwSrcMask;
        

        //
        // Check if the MFEs are in the range provided 
        //
        
        if ( dwRangeGrp && dwRangeGrpMask &&
             ( ( dwRangeGrp & dwRangeGrpMask ) != 
               ( pmims-> dwGroup & dwRangeGrpMask ) ) )
        {
            *pbDone = TRUE;
            break;
        }

        if ( dwRangeSrc && dwRangeSrcMask &&
             ( ( dwRangeSrc & dwRangeSrcMask ) !=
               ( pmims-> dwSource & dwRangeSrcMask ) ) )
        {
            pmims = (PMIB_IPMCAST_MFE_STATS)
                ((PBYTE) pmims + 
                    (bStatsAll) ?
                    SIZEOF_MIB_MFE_STATS_EX( pmims-> ulNumOutIf ) :
                    SIZEOF_MIB_MFE_STATS( pmims-> ulNumOutIf ));
                
            continue;
        }

        
        if ( ( dwType == Both ) ||
             ( ( dwType == PositiveMfe ) && ( pmims-> ulNumOutIf ) ) ||
             ( ( dwType == NegativeMfe ) && ( !pmims-> ulNumOutIf ) ) )
        {
            DWORD BufLen;

            MakePrefixStringW( ptszGroup, pmims-> dwGroup, 0xFFFFFFFF );

            MakePrefixStringW( ptszSource, pmims-> dwSource, pmims-> dwSrcMask );

            MakeAddressStringW( ptszUpstrm, pmims-> dwUpStrmNgbr );

            BufLen = sizeof(wszFriendlyName);
            IpmontrGetFriendlyNameFromIfIndex( 
                hMibServer, pmims-> dwInIfIndex, wszFriendlyName,
                BufLen 
                );

            if ( wcslen(wszFriendlyName) < 14 )
            {
                #pragma prefast(suppress:69, "Inefficient use of wsprintf: dont need")
                wsprintf( ptszIf, L"%-14.14s", wszFriendlyName );
            }

            else
            {
                wsprintf(
                    ptszIf, L"%-8.8s...%-3.3s", wszFriendlyName, 
                    &wszFriendlyName[wcslen(wszFriendlyName) - 3]
                    );
            }

            if (bStatsAll)
            {
                PMIB_IPMCAST_MFE_STATS_EX pmimsex =
                    (PMIB_IPMCAST_MFE_STATS_EX) pmims;
                
                wsprintf( 
                    ptszBuffer, L"\n%18.18s %18.18s %-6.6s %-14.14s %15.15s " 
                    L"%10d %10d %10d %10d %10d %10d %10d %10d %10d %10d",
                    ptszGroup, ptszSource,
                    GetProtoProtoString( 
                        PROTO_TYPE_MCAST, 0, 
                        pmimsex-> dwInIfProtocol
                        ),
                    ptszIf, ptszUpstrm,
                    pmimsex-> ulInPkts, pmimsex-> ulInOctets,
                    pmimsex-> ulPktsDifferentIf, pmimsex-> ulQueueOverflow,
                    pmimsex-> ulUninitMfe, pmimsex-> ulNegativeMfe,
                    pmimsex-> ulNegativeMfe, pmimsex-> ulInDiscards,
                    pmimsex-> ulInHdrErrors, pmimsex-> ulTotalOutPackets
                    );

                 pmimos = pmimsex-> rgmiosOutStats;
            }
            else
            {
                wsprintf( 
                    ptszBuffer, L"\n%18.18s %18.18s %-14.14s %15.15s %10d",
                    ptszGroup, ptszSource,
                    ptszIf, ptszUpstrm,
                    pmims-> ulInPkts
                    );

                pmimos = pmims-> rgmiosOutStats;
            }

            
            DisplayMessageToConsole(g_hModule, g_hConsole,
                              MSG_MIB_MFESTATS,
                              ptszBuffer);

            //
            // Display outgoing statistics
            //

            if ( pmims-> ulNumOutIf )
            {
                //
                // for each outgoing interface show outgoing interface stats
                //
                
                for ( j = 0; j < pmims-> ulNumOutIf; j++ )
                {
                    BufLen = sizeof(wszFriendlyName);

                    IpmontrGetFriendlyNameFromIfIndex( 
                        hMibServer, pmimos[j].dwOutIfIndex, 
                        wszFriendlyName,
                        BufLen
                        );

                    if ( wcslen(wszFriendlyName) < 14 )
                    {
                        #pragma prefast(suppress:69, "Inefficient use of wsprintf: dont need")
                        wsprintf( ptszIf, L"%-14.14s", wszFriendlyName );
                    }

                    else
                    {
                        wsprintf(
                            ptszIf, L"%-8.8s...%-3.3s", wszFriendlyName, 
                            &wszFriendlyName[wcslen(wszFriendlyName) - 3]
                            );
                    }

                    MakeAddressStringW( ptszUpstrm, pmimos[j].dwNextHopAddr );

                    if (!bStatsAll)
                    {
                        wsprintf(
                            ptszBuffer,
                            L"\n                                      %-14.14s %15.15s %10d",
                            ptszIf, ptszUpstrm, 
                            pmimos[j].ulOutPackets
                            );
                    }

                    else
                    {
                        wsprintf(
                            ptszBuffer,
                            L"\n                                             %-14.14s %15.15s %10d %10d %10d %10d",
                            ptszIf, ptszUpstrm, 
                            pmimos[j].ulOutPackets, 
                            pmimos[j].ulOutDiscards, 
                            pmimos[j].ulTtlTooLow,
                            pmimos[j].ulFragNeeded
                            );
                    }
                    
                    DisplayMessageToConsole(
                        g_hModule, g_hConsole,
                        MSG_MIB_MFESTATS,
                        ptszBuffer);
                }
            }
        }
        
        dwNextMfe = bStatsAll ?
            SIZEOF_MIB_MFE_STATS_EX( pmims-> ulNumOutIf ) :
            SIZEOF_MIB_MFE_STATS( pmims-> ulNumOutIf );

        pmims = (PMIB_IPMCAST_MFE_STATS)
                    (((PBYTE) pmims) + dwNextMfe);
    }

    return;
}



//----------------------------------------------------------------------------
// PrintMfeStatsTable
//
//
//----------------------------------------------------------------------------

DWORD
GetMfe(
    MIB_SERVER_HANDLE   hMprMIB,
    BOOL                bIndexPresent,
    PWCHAR             *ppwcArguments,
    DWORD               dwArgCount,
    BOOL                bIncludeStats
    )
/*++

Routine Description:

    Gets MFE stats information.

Arguments:

Return Value:

--*/
{
    TAG_TYPE             pttTags[] = {{TOKEN_GROUP_ADDRESS,  FALSE, FALSE},
                                      {TOKEN_GROUP_MASK,     FALSE, FALSE},
                                      {TOKEN_SOURCE_ADDRESS, FALSE, FALSE},
                                      {TOKEN_SOURCE_MASK,    FALSE, FALSE},
                                      {TOKEN_TYPE,           FALSE, FALSE},
                                      {TOKEN_STATS,          FALSE, FALSE}};

    DWORD                pdwTagType[sizeof(pttTags)/sizeof(TAG_TYPE)];
    DWORD                dwErr, dwOutEntrySize = 0, dwQuerySize,
                         dwLastGroup = 0, dwLastSource = 0, 
                         dwLastSrcMask = 0, i,
                         dwRangeGroup = 0, dwRangeGrpMask = 0,
                         dwRangeSource = 0, dwRangeSrcMask = 0, 
                         dwNumParsed;
    DWORD                dwType = Both;
    DWORD                dwCurrentIndex = 0;

    BOOL                 bDone = FALSE, bStatsAll = FALSE;
    
    PMIB_OPAQUE_INFO     pRpcInfo = NULL;

    PMIB_MFE_STATS_TABLE pTable = NULL;

    PMIB_OPAQUE_QUERY    pQuery;

    // Do generic processing

    dwErr = PreHandleCommand( ppwcArguments,
                              dwCurrentIndex,
                              dwArgCount,
                              pttTags,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              0,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              pdwTagType );

    if (dwErr)
    {
        return dwErr;
    }

    for (i=0; i<dwArgCount; i++)
    {
        switch(pdwTagType[i])
        {
            case 0: // GRPADDR
            {
                dwErr = GetIpPrefix( ppwcArguments[i+dwCurrentIndex],
                                     &dwRangeGroup,
                                     &dwRangeGrpMask );

                if (dwErr is ERROR_INVALID_PARAMETER)
                {
                    DisplayMessage( g_hModule,  MSG_IP_BAD_IP_ADDR,
                                    ppwcArguments[i + dwCurrentIndex]);

                    DispTokenErrMsg(g_hModule, MSG_IP_BAD_OPTION_VALUE,
                                    pttTags[pdwTagType[i]].pwszTag,
                                    ppwcArguments[i + dwCurrentIndex]);
                    i = dwArgCount;
                    break;
                }
                break;
            }

            case 1: // GRPMASK
            {
                dwErr = GetIpMask( ppwcArguments[i+dwCurrentIndex],
                                   &dwRangeGrpMask );

                if (dwErr is ERROR_INVALID_PARAMETER)
                {
                    DisplayMessage( g_hModule,  MSG_IP_BAD_IP_ADDR,
                                    ppwcArguments[i + dwCurrentIndex]);

                    DispTokenErrMsg(g_hModule, MSG_IP_BAD_OPTION_VALUE,
                                    pttTags[pdwTagType[i]].pwszTag,
                                    ppwcArguments[i + dwCurrentIndex]);
                    i = dwArgCount;
                    break;
                }
                break;
            }

            case 2: // SRCADDR
            {
                dwErr = GetIpPrefix( ppwcArguments[i+dwCurrentIndex],
                                     &dwRangeSource,
                                     &dwRangeSrcMask );

                if (dwErr is ERROR_INVALID_PARAMETER)
                {
                    DisplayMessage( g_hModule,  MSG_IP_BAD_IP_ADDR,
                                    ppwcArguments[i + dwCurrentIndex]);

                    DispTokenErrMsg(g_hModule, MSG_IP_BAD_OPTION_VALUE,
                                    pttTags[pdwTagType[i]].pwszTag,
                                    ppwcArguments[i + dwCurrentIndex]);
                    i = dwArgCount;
                    break;
                }
                break;
            }

            case 3: // SRCMASK
            {
                dwErr = GetIpMask( ppwcArguments[i+dwCurrentIndex],
                                   &dwRangeSrcMask );

                if (dwErr is ERROR_INVALID_PARAMETER)
                {
                    DisplayMessage( g_hModule,  MSG_IP_BAD_IP_ADDR,
                                    ppwcArguments[i + dwCurrentIndex]);

                    DispTokenErrMsg(g_hModule, MSG_IP_BAD_OPTION_VALUE,
                                    pttTags[pdwTagType[i]].pwszTag,
                                    ppwcArguments[i + dwCurrentIndex]);
                    i = dwArgCount;
                    break;
                }
                break;
            }

            case 4: // TYPE
            {
                TOKEN_VALUE rgEnums[] =
                {
                    { TOKEN_VALUE_POSITIVE, PositiveMfe },
                    { TOKEN_VALUE_NEGATIVE, NegativeMfe },
                    { TOKEN_VALUE_BOTH,     Both }
                };

                dwErr = MatchEnumTag( g_hModule,
                                      ppwcArguments[i + dwCurrentIndex],
                                      sizeof(rgEnums)/sizeof(TOKEN_VALUE),
                                      rgEnums,
                                      &dwType);

                if (dwErr isnot NO_ERROR)
                {
                    DispTokenErrMsg( g_hModule,
                                     MSG_IP_BAD_OPTION_VALUE,
                                     pttTags[pdwTagType[i]].pwszTag,
                                     ppwcArguments[i + dwCurrentIndex] );

                    return ERROR_INVALID_PARAMETER;
                }

                break;
            }

            case 5: // STATS
            {
                TOKEN_VALUE rgEnums[] =
                {
                    { TOKEN_VALUE_ALL, TRUE },
                };

                dwErr = MatchEnumTag( g_hModule,
                                      ppwcArguments[i + dwCurrentIndex],
                                      sizeof(rgEnums)/sizeof(TOKEN_VALUE),
                                      rgEnums,
                                      &bStatsAll);

                if (dwErr isnot NO_ERROR)
                {
                    DispTokenErrMsg( g_hModule,
                                     MSG_IP_BAD_OPTION_VALUE,
                                     pttTags[pdwTagType[i]].pwszTag,
                                     ppwcArguments[i + dwCurrentIndex] );

                    return ERROR_INVALID_PARAMETER;
                }

                break;
            }


        }
    }

    if (dwErr isnot NO_ERROR)
    {
        return dwErr;
    }

    do {
        //
        // allocate and setup query structure
        //
        
        dwQuerySize = sizeof( MIB_OPAQUE_QUERY ) + 2 * sizeof(DWORD);
        
        pQuery = (PMIB_OPAQUE_QUERY) HeapAlloc(
                                        GetProcessHeap(), 0, dwQuerySize
                                        );
        
        if ( pQuery == NULL )
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;

            DisplayMessageToConsole(g_hModule, g_hConsole, ERROR_CONFIG, dwErr );

            break;
        }

        
        pQuery->dwVarId = ( bIncludeStats ) ? 
                            ( ( bStatsAll ) ? 
                                MCAST_MFE_STATS_EX : MCAST_MFE_STATS ) :
                                MCAST_MFE;
        
        pQuery->rgdwVarIndex[ 0 ] = dwRangeGroup & dwRangeGrpMask;
        pQuery->rgdwVarIndex[ 1 ] = dwRangeSource;
        pQuery->rgdwVarIndex[ 2 ] = dwRangeSrcMask;
        

        if (bIncludeStats)
        {
            DisplayMessageToConsole(
                g_hModule, g_hConsole, 
                bStatsAll ? MSG_MIB_MFESTATS_ALL_HDR : MSG_MIB_MFESTATS_HDR
                );
        }

        else
        {
            DisplayMessageToConsole(g_hModule, g_hConsole, MSG_MIB_MFE_HDR );
        }
    

        while ((dwErr = MibGetNext(             PID_IP,
                                                IPRTRMGR_PID,
                                                (PVOID) pQuery,
                                                dwQuerySize,
                                                (PVOID *) &pRpcInfo,
                                                &dwOutEntrySize))
               == NO_ERROR )
        {
            //
            // if no MFEs are present quit
            //

            pTable = (PMIB_MFE_STATS_TABLE)( pRpcInfo->rgbyData );

            if ( pTable->dwNumEntries is 0 )
            {
                break;
            }


            //
            // print the MFEs
            //

            if ( bIncludeStats )
            {
                PrintMfeStatsTable(  hMprMIB,
                    pRpcInfo, &dwLastGroup, &dwLastSource, &dwLastSrcMask,
                    dwRangeGroup, dwRangeGrpMask, dwRangeSource, 
                    dwRangeSrcMask, dwType, &bDone, bStatsAll
                    );
            }

            else
            {
                PrintMfeTable(  hMprMIB,
                    pRpcInfo, &dwLastGroup, &dwLastSource, &dwLastSrcMask,
                    dwRangeGroup, dwRangeGrpMask, dwRangeSource, 
                    dwRangeSrcMask, dwType, &bDone
                    );
            }
        
            MprAdminMIBBufferFree( pRpcInfo );

            pRpcInfo = NULL;

            dwOutEntrySize = 0;


            //
            // Check if we are done
            //

            if ( bDone )
            {
                break;
            }
            
            //
            // set up the next query
            //
            
            pQuery->rgdwVarIndex[ 0 ] = dwLastGroup;
            pQuery->rgdwVarIndex[ 1 ] = dwLastSource;
            pQuery->rgdwVarIndex[ 2 ] = dwLastSrcMask;
        }

        if ( dwErr != NO_ERROR && dwErr != ERROR_NO_MORE_ITEMS && dwErr != ERROR_NOT_FOUND )
        {
            DisplayError(NULL, dwErr );
        }
        
    } while ( FALSE );

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ip\ipmon\strdefs.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:


Abstract:

    NOTE - DONT USE 15000-15999    

Author:

    Amritansh Raghav  01/25/1996

Revision History:

    V Raman         05/15/1996      Rearranged stringtable ids.
        
--*/

#ifndef __STRDEFS_H__
#define __STRDEFS_H__

#define MSG_NULL                                1001

#define HLP_IP_HELP1                            8301
#define HLP_IP_HELP1_EX                         8302
#define HLP_IP_HELP2                            8301
#define HLP_IP_HELP2_EX                         8302
#define HLP_IP_RESET                            8309
#define HLP_IP_RESET_EX                         8310
#define HLP_IP_INSTALL                          8313
#define HLP_IP_INSTALL_EX                       8314
#define HLP_IP_UNINSTALL                        8315
#define HLP_IP_UNINSTALL_EX                     8316
#define HLP_IP_DUMP                             8317
#define HLP_IP_DUMP_EX                          8318
#define HLP_IP_UPDATE                           8319
#define HLP_IP_UPDATE_EX                        8320
#define HLP_GROUP_ADD                           8321
#define HLP_GROUP_DELETE                        8323
#define HLP_GROUP_SET                           8325
#define HLP_GROUP_SHOW                          8327


#define HLP_IP_ADD_PROTOPREF                    9200
#define HLP_IP_ADD_PROTOPREF_EX                 9201
#define HLP_IP_DEL_PROTOPREF                    9202
#define HLP_IP_DEL_PROTOPREF_EX                 9203
#define HLP_IP_SET_PROTOPREF                    9204
#define HLP_IP_SET_PROTOPREF_EX                 9205
#define HLP_IP_SHOW_PROTOPREF                   9206
#define HLP_IP_SHOW_PROTOPREF_EX                9207

#define HLP_IP_ADD_IF_FILTER                    9210
#define HLP_IP_ADD_IF_FILTER_EX                 9211
#define HLP_IP_DEL_IF_FILTER                    9212
#define HLP_IP_DEL_IF_FILTER_EX                 9213
#define HLP_IP_SET_IF_FILTER                    9214
#define HLP_IP_SET_IF_FILTER_EX                 9215
#define HLP_IP_SHOW_IF_FILTER                   9216
#define HLP_IP_SHOW_IF_FILTER_EX                9217

#define HLP_IP_ADD_PERSISTENTROUTE              9220
#define HLP_IP_ADD_PERSISTENTROUTE_EX           9221
#define HLP_IP_DEL_PERSISTENTROUTE              9222
#define HLP_IP_DEL_PERSISTENTROUTE_EX           9223
#define HLP_IP_SET_PERSISTENTROUTE              9224
#define HLP_IP_SET_PERSISTENTROUTE_EX           9225
#define HLP_IP_SHOW_PERSISTENTROUTE             9226
#define HLP_IP_SHOW_PERSISTENTROUTE_EX          9227

#define HLP_IP_ADD_IPIPTUNNEL                   9230
#define HLP_IP_ADD_IPIPTUNNEL_EX                9231
#define HLP_IP_SET_IPIPTUNNEL                   9234
#define HLP_IP_SET_IPIPTUNNEL_EX                9235

#define HLP_IP_SET_LOGLEVEL                     9244
#define HLP_IP_SET_LOGLEVEL_EX                  9245
#define HLP_IP_SHOW_LOGLEVEL                    9246
#define HLP_IP_SHOW_LOGLEVEL_EX                 9247

#define HLP_IP_ADD_INTERFACE                    9250
#define HLP_IP_ADD_INTERFACE_EX                 9251
#define HLP_IP_DEL_INTERFACE                    9252
#define HLP_IP_DEL_INTERFACE_EX                 9253
#define HLP_IP_SET_INTERFACE                    9254
#define HLP_IP_SET_INTERFACE_EX                 9255
#define HLP_IP_SHOW_INTERFACE                   9256
#define HLP_IP_SHOW_INTERFACE_EX                9257

#define HLP_IP_SHOW_PROTOCOL                    9266
#define HLP_IP_SHOW_PROTOCOL_EX                 9267

#define HLP_IP_ADD_SCOPE                        9270
#define HLP_IP_ADD_SCOPE_EX                     9271
#define HLP_IP_DEL_SCOPE                        9272
#define HLP_IP_DEL_SCOPE_EX                     9273
#define HLP_IP_SET_SCOPE                        9274
#define HLP_IP_SET_SCOPE_EX                     9275
#define HLP_IP_SHOW_SCOPE                       9276
#define HLP_IP_SHOW_SCOPE_EX                    9277

#define HLP_IP_ADD_BOUNDARY                     9280
#define HLP_IP_ADD_BOUNDARY_EX                  9281
#define HLP_IP_DEL_BOUNDARY                     9282
#define HLP_IP_DEL_BOUNDARY_EX                  9283
#define HLP_IP_SHOW_BOUNDARY                    9286
#define HLP_IP_SHOW_BOUNDARY_EX                 9287

#define HLP_IP_SHOW_HELPER                      9296
#define HLP_IP_SHOW_HELPER_EX                   9297

#define HLP_IPMIB_SHOW_RTMDEST                  9316
#define HLP_IPMIB_SHOW_RTMDEST_EX               9317
#define HLP_IPMIB_SHOW_MFESTATS                 9318
#define HLP_IPMIB_SHOW_MFESTATS_EX              9319
#define HLP_IPMIB_SHOW_MFE                      9320
#define HLP_IPMIB_SHOW_MFE_EX                   9321
#define HLP_IPMIB_SHOW_RTMROUTE                 9326
#define HLP_IPMIB_SHOW_RTMROUTE_EX              9327
#define HLP_IPMIB_SHOW_BOUNDARY                 9330
#define HLP_IPMIB_SHOW_BOUNDARY_EX              9331
#define HLP_IPMIB_SHOW_SCOPE                    9332
#define HLP_IPMIB_SHOW_SCOPE_EX                 9333

#define HLP_IP_ADD_RTMROUTE                     9340
#define HLP_IP_ADD_RTMROUTE_EX                  9341
#define HLP_IP_DEL_RTMROUTE                     9342
#define HLP_IP_DEL_RTMROUTE_EX                  9343
#define HLP_IP_SET_RTMROUTE                     9344
#define HLP_IP_SET_RTMROUTE_EX                  9345

//
// Messages used to dump config - these closely follow the
// set/add help messages
//

#define DMP_IP_HEADER_COMMENTS                  9411
#define DMP_IP_FOOTER_COMMENTS                  9412
#define DMP_ROUTING_HEADER_COMMENTS             9413

// Output messages
    // Router messages
        // interface messages
#define MSG_RTR_INTERFACE_HDR                   20001
#define MSG_RTR_INTERFACE_PROTOCOL_HDR          20003
#define MSG_RTR_INTERFACE_IPIP_INFO             20005
#define MSG_RTR_ROUTE_HDR                       20006
#define MSG_RTR_ROUTE_INFO                      20007

        // Filter messages
#define MSG_RTR_FILTER_HDR                      20101
#define MSG_RTR_FILTER_INFO                     20102
#define MSG_RTR_FILTER_HDR1                     20103
#define MSG_RTR_FILTER_HDR2                     20104
#define MSG_RTR_FILTER_INFO2                    20105

        // Multicast scope boundary messages
#define MSG_RTR_SCOPE_HDR                       20251
#define MSG_RTR_SCOPE_INFO                      20252
#define MSG_RTR_BOUNDARY_HDR                    20253
#define MSG_RTR_BOUNDARY_INFO_0                 20254
#define MSG_RTR_BOUNDARY_INFO_1                 20255
#define MSG_RTR_BOUNDARY_INFO_2                 20256

#define MSG_RTR_PRIO_INFO_HDR                   20304
#define MSG_RTR_PRIO_INFO                       20305


    // MIB messages
#define MSG_MIB_MFE_HDR                         21025
#define MSG_MIB_MFE                             21026

#define MSG_MIB_MFESTATS_HDR                    21028
#define MSG_MIB_MFESTATS_ALL_HDR                21029
#define MSG_MIB_MFESTATS                        21030


#define MSG_MIB_BOUNDARY_HDR                    21055
#define MSG_MIB_BOUNDARY_INFO                   21056
#define MSG_MIB_SCOPE_HDR                       21057
#define MSG_MIB_SCOPE_INFO                      21058

#define MSG_IP_BAD_IP_ADDR                      21503
#define MSG_IP_BAD_IP_MASK                      21505
#define MSG_CANT_FIND_EOPT                      21507
#define MSG_NO_INTERFACE                        21512
#define MSG_IP_NO_FILTER_FOR_FRAG               21521
#define MSG_SHOW_HELPER_HDR                     21528
#define MSG_SHOW_HELPER_INFO                    21529

#define MSG_IP_FRAG_CHECK                       21601
#define MSG_IP_GLOBAL_HDR                       21602
#define MSG_IP_LOG_LEVEL                        21603
#define MSG_IP_PROTOCOL_HDR                     21604
#define MSG_IP_NO_PROTOCOL                      21605
#define MSG_IP_INTERFACE_HDR                    21606
#define MSG_IP_NO_INTERFACE                     21607
#define MSG_IP_IF_STATUS                        21608
#define MSG_IP_INTERFACE_INFO                   21609
#define MSG_IP_IF_ENTRY                         21610
#define MSG_IP_IF_HEADER                        21611
#define MSG_IP_PERSISTENT_ROUTER                21612
#define MSG_IP_PERSISTENT_CONFIG                21613

#define EMSG_IP_NO_STATUS_INFO                  25005
#define EMSG_IP_NO_PRIO_INFO                    25006
#define EMSG_IP_NO_FILTER_INFO                  25007
#define EMSG_IP_NO_IF_STATUS_INFO               25009
#define EMSG_IP_NO_ROUTE_INFO                   25010
#define EMSG_NEED_NHOP                          25011
#define EMSG_P2P_WITH_NHOP                      25012
#define EMSG_SCOPE_NAME_TOO_LONG                25016
#define EMSG_CANT_CREATE_IF                     25020
#define EMSG_CANT_SET_IF_INFO                   25021
#define EMSG_CANT_GET_IF_INFO                   25023
#define EMSG_AMBIGUOUS_SCOPE_NAME               25024
#define EMSG_INVALID_ADDR                       25025
#define EMSG_PREFIX_ERROR                       25026
#define EMSG_CANT_FIND_NAME                     25027
#define EMSG_CANT_MATCH_NAME                    25028
#define EMSG_CANT_FIND_INDEX                    25029
#define EMSG_INTERFACE_INVALID_OR_DISC          25030
#define EMSG_CANT_FIND_NAME_OR_NHOP             25031
#define EMSG_AMBIGUOUS_INDEX_FROM_NHOP          25032
#define ERROR_CONFIG                            25033
#define ERROR_ADMIN                             25034

// Strings
    // Router if types
#define STRING_DEDICATED                        26001
#define STRING_HOME_ROUTER                      26002
#define STRING_FULL_ROUTER                      26003
#define STRING_CLIENT                           26004
#define STRING_INTERNAL                         26005

    // Interface types
#define STRING_OTHER                            30001
#define STRING_LOOPBACK                         30006
#define STRING_TUNNEL                           30131

    // Protocol types
#define STRING_UNICAST                          32500
#define STRING_MULTICAST                        32501
#define STRING_GENERAL                          32503

    // Router info block types
#define STRING_IN_FILTER                        32511
#define STRING_OUT_FILTER                       32512
#define STRING_GLOBAL_INFO                      32513
#define STRING_IF_STATUS                        32514
#define STRING_ROUTE_INFO                       32515
#define STRING_PROT_PRIORITY                    32516
#define STRING_RTRDISC                          32517
#define STRING_DD_FILTER                        32518
#define STRING_MC_HEARTBEAT                     32519
#define STRING_MC_BOUNDARY                      32520
#define STRING_IPIP                             32521
#define STRING_IF_FILTER                        32522
#define STRING_MC_LIMIT                         32523

    //  Protocols
#define STRING_LOCAL                            33002
#define STRING_NETMGMT                          33003
#define STRING_ICMP                             33004
#define STRING_EGP                              33005
#define STRING_GGP                              33006
#define STRING_HELLO                            33007
#define STRING_RIP                              33008
#define STRING_IS_IS                            33009
#define STRING_ES_IS                            33010
#define STRING_CISCO                            33011
#define STRING_BBN                              33012
#define STRING_OSPF                             33013
#define STRING_BGP                              33014
#define STRING_BOOTP                            33015
#define STRING_TCP                              33016
#define STRING_TCP_ESTAB                        33017
#define STRING_UDP                              33018
#define STRING_IGMP                             33019
#define STRING_STATIC                           33020
#define STRING_NT_AUTOSTATIC                    33021
#define STRING_NONDOD                           33022
#define STRING_PROTO_ANY                        33023
#define STRING_PROTO_UNKNOWN                    33024
#define STRING_NAT                              33025
#define STRING_DNS_PROXY                        33026
#define STRING_DHCP_ALLOCATOR                   33027
#define STRING_DIFFSERV                         33028
#define STRING_VRRP                             33029

#define STRING_INVALID                          34002
#define STRING_DIRECT                           34003
#define STRING_INDIRECT                         34004

    // Miscellaneous strings
#define STRING_ENABLED                          38003
#define STRING_DISABLED                         38004

#define STRING_INPUT                            38031
#define STRING_OUTPUT                           38032
#define STRING_DIAL                             38033

#define STRING_DROP                             38041
#define STRING_FORWARD                          38042

#define STRING_LOGGING_NONE                     38051
#define STRING_LOGGING_ERROR                    38052
#define STRING_LOGGING_WARN                     38053
#define STRING_LOGGING_INFO                     38054

// Error messages
#define MSG_IP_NO_ROUTE_INFO                    60003
#define MSG_IP_DIM_ERROR                        60005
#define MSG_IP_IF_IS_TUNNEL                     60010
#define MSG_IP_LOCAL_ROUTER_NOT_RUNNING         60011
#define MSG_IP_REMOTE_ROUTER_NOT_RUNNING        60013
#define MSG_IP_CAN_NOT_CONNECT_DIM              60014
#define MSG_IP_NO_ENTRIES                       60015
#define MSG_IP_CORRUPT_INFO                     60016
#define MSG_IP_RESTART_ROUTER                   60017
#define MSG_IP_NOT_ENOUGH_MEMORY                60024
#define MSG_IP_BAD_OPTION_VALUE                 60025
#define MSG_IP_BAD_INTERFACE_TYPE               60032


#define MSG_IP_NO_INPUT_FILTER                  60026
#define MSG_IP_NO_OUTPUT_FILTER                 60027
#define MSG_IP_NO_FILTER_INFO                   60029
#define MSG_IP_NO_DIAL_FILTER                   60030
#define MSG_IP_BAD_OPTION_ENUMERATION           60031
#define MSG_CTRL_C_TO_QUIT                      60062
#define MSG_IP_CANT_DISABLE_INTERFACE           60063

#define MSG_IP_NO_PREF_FOR_PROTOCOL_ID          60121       
#define MSG_IP_PROTO_PREF_LEVEL_EXISTS          60122
#define MSG_IP_PROTO_PREF_LEVEL_NOT_FOUND       60123

//
// Error messages for mib calls
//

#define MSG_MIB_NO_MFES                         62001


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ip\ipmon\utils.h ===
DWORD
GetMibTagToken(
    IN  LPWSTR *ppwcArguments,
    IN  DWORD   dwArgCount,
    IN  DWORD   dwNumIndices,
    OUT PDWORD  pdwRR,
    OUT PBOOL   pbIndex,
    OUT PDWORD  pdwIndex
    );

DWORD
GetIpAddress(
    IN  LPCWSTR       pptcArg,
    OUT PIPV4_ADDRESS ipAddress
    );

DWORD
GetIpMask(
    IN  LPCWSTR       pptcArg,
    OUT PIPV4_ADDRESS ipMask
    );

DWORD
GetIpPrefix(
    IN  LPCWSTR       pptcArg,
    OUT PIPV4_ADDRESS ipAddress,
    OUT PIPV4_ADDRESS ipMask
    );

#define DispTokenErrMsg(hModule, dwMsgId, pwszTag, pwszValue) \
        DisplayMessage( hModule, dwMsgId, pwszValue, pwszTag)

BYTE
MaskToMaskLen(
    IPV4_ADDRESS dwMask
    );

VOID
MakeAddressStringW(
    OUT LPWSTR       pwcPrefixStr,
    IN  IPV4_ADDRESS ipAddr
    );

VOID
MakePrefixStringW(
    OUT LPWSTR       pwcPrefixStr,
    IN  IPV4_ADDRESS ipAddr,
    IN  IPV4_ADDRESS ipMask
    );

DWORD
GetGuidFromIfIndex(
    IN  MIB_SERVER_HANDLE hMibServer,
    IN  DWORD             dwIfIndex,
    OUT LPWSTR            pwszBuffer,
    IN  DWORD             dwBufferSize
    );

DWORD
IpmontrGetFriendlyNameFromIfIndex(
    IN  MIB_SERVER_HANDLE hMibServer,
    IN  DWORD             dwIfIndex,
    OUT LPWSTR            pwszBuffer,
    IN  DWORD             dwBufferSize
    );

DWORD
GetIfIndexFromGuid(
    IN  MIB_SERVER_HANDLE hMibServer,
    IN  LPCWSTR           pwszGuid,
    OUT PDWORD            pdwIfIndex
    );

DWORD
IpmontrGetIfIndexFromFriendlyName(
    IN  MIB_SERVER_HANDLE hMibServer,
    IN  LPCWSTR           pwszFriendlyName,
    OUT PDWORD            pdwIfIndex
    );

DWORD
IpmontrGetFriendlyNameFromIfName(
    IN  LPCWSTR pwszName,
    OUT LPWSTR  pwszBuffer,
    IN  PDWORD  pdwBufSize
    );

DWORD
IpmontrGetIfNameFromFriendlyName(
    IN  LPCWSTR pwszName,
    OUT LPWSTR  pwszBuffer,
    IN  PDWORD pdwBufSize
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ip\preview\common.h ===
extern ULONG StartedCommonInitialization, CompletedCommonInitialization ;
extern HANDLE g_hModule;
extern MIB_SERVER_HANDLE g_hMibServer;

typedef
DWORD
(GET_OPT_FN)(
    IN    LPCWSTR  *ppwcArguments,
    IN    DWORD    dwCurrentIndex,
    IN    DWORD    dwArgCount,
    OUT   PDWORD   pdwIndices,
    OUT   PDWORD   pdwNumParsed
    );

typedef GET_OPT_FN *PGET_OPT_FN;

typedef struct _MIB_OBJECT_PARSER
{
    PWCHAR         pwszMIBObj;
    DWORD          dwMinOptArg;
    DWORD          dwNumArgs;
    PGET_OPT_FN    pfnMIBObjParser;
//  DWORD          dwShortCmdHelpToken;
//  DWORD          dwCmdHelpToken;
} MIB_OBJECT_PARSER,*PMIB_OBJECT_PARSER;

#define CREATE_MIB_ENTRY(t,m,f)   {TOKEN_##t, HLP_##t, HLP_##t##_EX, m,f}

BOOL
IsProtocolInstalled(
    DWORD  dwProtoId,
    WCHAR *pwszName
    );

DWORD
GetMIBIfIndex(
    IN    PTCHAR   *pptcArguments,
    IN    DWORD    dwCurrentIndex,
    OUT   PDWORD   pdwIndices,
    OUT   PDWORD   pdwNumParsed
    );

typedef DWORD IPV4_ADDRESS;

extern VALUE_STRING CommonBooleanStringArray[];
extern VALUE_TOKEN  CommonBooleanTokenArray[];
#define COMMON_BOOLEAN_SIZE 2

extern VALUE_STRING CommonLoggingStringArray[];
extern VALUE_TOKEN  CommonLoggingTokenArray[];
#define COMMON_LOGGING_SIZE 4

#define VERIFY_INSTALLED(x,y) \
        if (!IsProtocolInstalled(x,y))  \
        { \
            return NO_ERROR; \
        }

#define \
IP_TO_TSTR(str,addr) \
    swprintf( \
        (str), \
        TEXT("%d.%d.%d.%d"), \
        ((PUCHAR)addr)[0], \
        ((PUCHAR)addr)[1], \
        ((PUCHAR)addr)[2], \
        ((PUCHAR)addr)[3] \
        )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ip\ipmon\utils.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    routing\monitor2\ip\utils.c

Abstract:

     Utility functions

Revision History:

    Anand Mahalingam         7/10/98  Created

--*/

#include "precomp.h"
#pragma hdrstop

DWORD
GetMibTagToken(
    IN  LPWSTR *ppwcArguments,
    IN  DWORD   dwArgCount,
    IN  DWORD   dwNumIndices,
    OUT PDWORD  pdwRR,
    OUT PBOOL   pbIndex,
    OUT PDWORD  pdwIndex
    )

/*++

Routine Description:

    Looks for indices and refresh rate arguments in the command. If index
    tag is present, it would be of the form index= index1 index2 ....
    The index= is removed by this function. So is rr= if it is there in
    the command. If pdwRR is 0 then, no refresh sought.
    
Arguments:

    ppwcArguments  - The argument array. Each argument has tag=value form
    dwCurrentIndex - ppwcArguments[dwCurrentIndex] is first arg.
    dwArgCount     - ppwcArguments[dwArgCount - 1] is last arg.
    pttTagToken    - Array of tag token ids that are allowed in the args
    dwNumTags      - Size of pttTagToken
    pdwOut         - Array identifying the type of each argument.

Return Value:

    NO_ERROR, ERROR_INVALID_PARAMETER, ERROR_INVALID_OPTION_TAG
    
--*/
{
    DWORD    i;
    BOOL     bTag;

    if (dwArgCount is 0)
    {
        *pdwRR = 0;
        *pbIndex = FALSE;
        
        return NO_ERROR;
    }

    if (dwArgCount < dwNumIndices)
    {
        //
        // No index
        //
        
        *pbIndex = FALSE;

        if (dwArgCount > 1)
        {
            *pdwRR = 0;
            
            return ERROR_INVALID_PARAMETER;
        }
        
        //
        // No Index specified. Make sure refresh rate is specified
        // with tag.
        //

        if (_wcsnicmp(ppwcArguments[0],L"RR=",3) == 0)
        {
            //
            // get the refresh rate
            //

            *pdwRR = wcstoul(&ppwcArguments[0][3], NULL, 10);
        }
        else
        {
            return ERROR_INVALID_PARAMETER;
        }
    }
    else
    {
        //
        // Check for index tag
        //

        if (_wcsnicmp(ppwcArguments[0],L"INDEX=",6) == 0)
        {
            *pbIndex = TRUE;
            *pdwIndex = 0;

            //
            // remove tag and see if refresh rate is specified
            //

            wcscpy(ppwcArguments[0], &ppwcArguments[0][6]);

            if (dwArgCount > dwNumIndices)
            {
                //
                // Make sure that argument has RR tag
                //

                if (_wcsnicmp(ppwcArguments[dwNumIndices],L"RR=",3) == 0)
                {
                    //
                    // get the refresh rate
                    //

                    *pdwRR = wcstoul(&ppwcArguments[dwNumIndices][3], NULL , 10);
                }
                else
                {
                    return ERROR_INVALID_PARAMETER;
                }
            }
            else
            {
                //
                // No refresh rate specified
                //

                *pdwRR = 0;
                return NO_ERROR;
            }
        }
        else
        {
            //
            // Not index tag, See if it has an RR tag
            // 

            if (_wcsnicmp(ppwcArguments[0],L"RR=",3) == 0)
            {
                //
                // get the refresh rate
                //

                *pdwRR = wcstoul(&ppwcArguments[0][3], NULL , 10);

                //
                // See if the index follows
                //

                if (dwArgCount > dwNumIndices)
                {
                    if (dwArgCount > 1)
                    {
                        if (_wcsnicmp(ppwcArguments[1],L"INDEX=",6) == 0)
                        {
                            wcscpy(ppwcArguments[1], &ppwcArguments[1][6]);
                            *pbIndex = TRUE;
                            *pdwIndex = 1;
                            
                            return NO_ERROR;
                        }
                        else
                        {
                            *pdwRR = 0;
                            return ERROR_INVALID_PARAMETER;
                        }
                    }
                    else
                    {
                        return NO_ERROR;
                    }
                }
            }
            //
            // No RR Tag either
            //
            else if (dwArgCount > dwNumIndices)
            {
                //
                // Assume ppwcArguments[dwNumIndices] is the refresh rate
                //

                *pdwRR = wcstoul(ppwcArguments[dwNumIndices], NULL , 10);

                if (dwNumIndices != 0)
                {
                    *pbIndex = TRUE;
                    *pdwIndex = 0;
                }
            }
            else
            {
                //
                // only index present with no tag
                //
                *pbIndex = TRUE;
                *pdwIndex = 0;
            }
        }
    }

    return NO_ERROR;
}

DWORD
GetIpPrefix(
    IN  LPCWSTR       ppwcArg,
    OUT PIPV4_ADDRESS pipAddress,
    OUT PIPV4_ADDRESS pipMask
    )
{
    CHAR     pszIpAddr[ADDR_LENGTH+1], *p;
    DWORD    dwDots;

    // Accept "default" as a special case

    if (MatchToken( ppwcArg, TOKEN_DEFAULT))
    {
        *pipAddress = *pipMask = 0;
        return NO_ERROR;
    }

    // Make sure all characters are legal [/0-9.]

    if (ppwcArg[ wcsspn(ppwcArg, L"/0123456789.") ])
    {
        return ERROR_INVALID_PARAMETER;
    }

    WideCharToMultiByte(GetConsoleOutputCP(),
                        0,
                        ppwcArg,
                        -1,
                        pszIpAddr,
                        ADDR_LENGTH,
                        NULL,
                        NULL);

    pszIpAddr[ADDR_LENGTH] = '\0';

    p = strchr( pszIpAddr, '/' );
    if (p)
    {
        ULONG ulLen = (atoi(p+1));
        *pipMask = (ulLen)? htonl(~0 << (32 - ulLen)) : 0;
        *p = 0;
    }
    else
    {
        *pipMask = ~0;
    }

    // If less than three dots were specified, append .0 until there are
    for (dwDots=0, p=strchr(pszIpAddr, '.'); p; dwDots++,p=strchr(p+1,'.'));
    while (dwDots < 3) {
        strcat(pszIpAddr, ".0");
        dwDots++;
    }

    *pipAddress = (DWORD) inet_addr(pszIpAddr);

    return NO_ERROR;
}

DWORD
GetIpMask(
    IN  LPCWSTR       ppwcArg,
    OUT PIPV4_ADDRESS pipAddress
    )
/*++

Routine Description:

    Gets the ip address from the string.
    
Arguments:

    pwszIpAddr - Ip address string
    pipAddress - IP address
    
Return Value:
    
    NO_ERROR, ERROR_INVALID_PARAMETER
    
--*/
{
    CHAR     pszIpAddr[ADDR_LENGTH+1];

    // Make sure all characters are legal [/0-9.]

    if (ppwcArg[ wcsspn(ppwcArg, L"/0123456789.") ])
    {
        return ERROR_INVALID_PARAMETER;
    }

    WideCharToMultiByte(GetConsoleOutputCP(),
                        0,
                        ppwcArg,
                        -1,
                        pszIpAddr,
                        ADDR_LENGTH,
                        NULL,
                        NULL);

    pszIpAddr[ADDR_LENGTH] = '\0';

    if (pszIpAddr[0] is '/')
    {
        ULONG ulLen = (atoi(pszIpAddr+1));
        *pipAddress = (ulLen)? htonl(~0 << (32 - ulLen)) : 0;
    }
    else
    {
        *pipAddress = (DWORD) inet_addr(pszIpAddr);
    }

    return NO_ERROR;
}



DWORD
GetIpAddress(
    IN  LPCWSTR         pwszArgument,
    OUT PIPV4_ADDRESS   pipAddress
    )
/*++

Routine Description
    Gets the ip address from the string.

Arguments
    pwszArgument        argument specifing an ip address
    pipAddress          ip address

Return Value
    NO_ERROR            if success
    Failure code        o/w

--*/
{
    CHAR    pszAddress[ADDR_LENGTH + 1];
    DWORD   dwAddress   = 0;
    PCHAR   pcNext      = NULL;
    ULONG   ulCount     = 0;

    // ensure all characters are legal [0-9.]
    if (pwszArgument[wcsspn(pwszArgument, L"0123456789.")])
        return ERROR_INVALID_PARAMETER;

    // convert to an ansi string
    sprintf(pszAddress, "%S", pwszArgument);

    // ensure there are 3 '.' (periods)
    for (pcNext = pszAddress, ulCount = 0; *pcNext != '\0'; pcNext++)
        if (*pcNext is '.')
            ulCount++;
    if (ulCount != 3)
        return ERROR_INVALID_PARAMETER;

    dwAddress = (DWORD) inet_addr(pszAddress);
    // return an error if dwAddress is INADDR_NONE (255.255.255.255)
    // and the address specified isn't 255.255.255.255 (INADDR_NONE)
    if ((dwAddress is INADDR_NONE) and
        strcmp(pszAddress, "255.255.255.255"))
        return ERROR_INVALID_PARAMETER;

    *pipAddress = dwAddress;

    return NO_ERROR;
}



BYTE
MaskToMaskLen(
    IPV4_ADDRESS dwMask
    )
{
    register int i;

    dwMask = ntohl(dwMask);

    for (i=0; i<32 && !(dwMask & (1<<i)); i++);

    return 32-i;
}

VOID
MakeAddressStringW(
    OUT LPWSTR       pwcPrefixStr,
    IN  IPV4_ADDRESS ipAddr
    )
{
    swprintf( pwcPrefixStr,
              L"%d.%d.%d.%d",
              PRINT_IPADDR(ipAddr) );
}

VOID
MakePrefixStringW(
    OUT LPWSTR       pwcPrefixStr,
    IN  IPV4_ADDRESS ipAddr,
    IN  IPV4_ADDRESS ipMask
    )
{
    swprintf( pwcPrefixStr,
              L"%d.%d.%d.%d/%d",
              PRINT_IPADDR(ipAddr),
              MaskToMaskLen(ipMask) );
}

DWORD
GetIfIndexFromGuid(
    IN  MIB_SERVER_HANDLE hMibServer,
    IN  LPCWSTR           pwszGuid,
    OUT PDWORD            pdwIfIndex
    )
{
    MIB_OPAQUE_QUERY  Query;
    PMIB_IFTABLE      pIfTable;
    DWORD             dwErr, dwOutEntrySize;
    PMIB_OPAQUE_INFO  pRpcInfo;
    DWORD             dwCount, i;

    Query.dwVarId         = IF_TABLE;
    Query.rgdwVarIndex[0] = 0;

    dwErr = MibGet(             PID_IP,
                                IPRTRMGR_PID,
                                (PVOID) &Query,
                                sizeof(Query),
                                (PVOID *) &pRpcInfo,
                                &dwOutEntrySize );

    if (dwErr isnot NO_ERROR)
    {
        return dwErr;
    }

    pIfTable = (PMIB_IFTABLE)(pRpcInfo->rgbyData);

    dwCount = pIfTable->dwNumEntries;

    *pdwIfIndex = 0;

    for (i=0; i<dwCount; i++) 
    {
        if (!wcscmp(pIfTable->table[i].wszName, pwszGuid))
        {
            *pdwIfIndex = pIfTable->table[i].dwIndex;

            break;
        }
    }

    MprAdminMIBBufferFree( (PVOID) pRpcInfo );

    return NO_ERROR;
}

DWORD
GetGuidFromIfIndex(
    IN  MIB_SERVER_HANDLE hMibServer,
    IN  DWORD             dwIfIndex,
    OUT LPWSTR            pwszBuffer,
    IN  DWORD             dwBufferSize
    )
{
    MIB_OPAQUE_QUERY  Query;
    PMIB_IFROW        pIfRow;
    DWORD             dwErr, dwOutEntrySize;
    PMIB_OPAQUE_INFO  pRpcInfo;

    Query.dwVarId         = IF_ROW;
    Query.rgdwVarIndex[0] = dwIfIndex;

    dwErr = MibGet(             PID_IP,
                                IPRTRMGR_PID,
                                (PVOID) &Query,
                                sizeof(Query),
                                (PVOID *) &pRpcInfo,
                                &dwOutEntrySize );

    if (dwErr isnot NO_ERROR)
    {
        return dwErr;
    }

    pIfRow = (PMIB_IFROW)(pRpcInfo->rgbyData);

    wcscpy( pwszBuffer, pIfRow->wszName );

    MprAdminMIBBufferFree( (PVOID) pRpcInfo );

    return NO_ERROR;
}

DWORD
IpmontrGetFriendlyNameFromIfIndex(
    IN  MIB_SERVER_HANDLE hMibServer,
    IN  DWORD             dwIfIndex,
    OUT LPWSTR            pwszBuffer,
    IN  DWORD             dwBufferSize
    )
/*++

Routine Description:

    Gets friendly Interface name from Interface index

Arguments:

    hMibServer      - Handle to the MIB server
    dwIfIndex       - Interface index
    pwszBuffer      - Buffer that will be holding the friendly interface name
    dwBufferSize    - Size (in Bytes) of the pwszBuffer

--*/
{
    WCHAR        wszGuid[MAX_INTERFACE_NAME_LEN + 1];
    DWORD        dwErr, BufLen;

    BufLen = sizeof(wszGuid);
    dwErr = GetGuidFromIfIndex(hMibServer, dwIfIndex, wszGuid, BufLen);

    if (dwErr isnot NO_ERROR)
    {
        return dwErr;
    }

    return IpmontrGetFriendlyNameFromIfName( wszGuid, pwszBuffer, &dwBufferSize );
}

DWORD
IpmontrGetIfIndexFromFriendlyName(
    IN  MIB_SERVER_HANDLE hMibServer,
    IN  LPCWSTR           pwszFriendlyName,
    OUT PDWORD            pdwIfIndex
    )
{
    WCHAR        wszGuid[MAX_INTERFACE_NAME_LEN + 1];
    DWORD        dwErr, dwSize = sizeof(wszGuid);
    
    dwErr = IpmontrGetIfNameFromFriendlyName( pwszFriendlyName,
                                       wszGuid,
                                       &dwSize );

    if (dwErr isnot NO_ERROR)
    {
        return dwErr;
    }

    return GetIfIndexFromGuid( hMibServer, wszGuid, pdwIfIndex );
}

DWORD 
IpmontrGetFriendlyNameFromIfName(
    IN  LPCWSTR pwszName, 
    OUT LPWSTR  pwszBuffer, 
    IN  PDWORD  pdwBufSize
    )
/*++
Description:
    Defines function to map a guid interface name to an unique descriptive
    name describing that interface.

Arguments:

    pwszName        - Buffer holding a Guid Interface Name 
    pwszBuffer      - Buffer to hold the Friendly Name
    pdwBufferSize   - pointer to the Size (in Bytes) of the pwszBuffer
--*/
{
    return NsGetFriendlyNameFromIfName( g_hMprConfig,
                                        pwszName,
                                        pwszBuffer,
                                        pdwBufSize );
}

DWORD
IpmontrGetIfNameFromFriendlyName(
    IN  LPCWSTR pwszName,
    OUT LPWSTR  pwszBuffer,
    IN  PDWORD  pdwBufSize
    )
/*++
Description:
    Defines function to map a friendly interface name to a guid interface
    name.

Arguments:

    pwszName        - Buffer holding a Friendly Interface Name 
    pwszBuffer      - Buffer to hold Guid Interface Name
    pdwBufferSize   - pointer to the Size (in Bytes) of the pwszBuffer

Returns:
    NO_ERROR, ERROR_NO_SUCH_INTERFACE
--*/
{
    return NsGetIfNameFromFriendlyName( g_hMprConfig,
                                        pwszName,
                                        pwszBuffer,
                                        pdwBufSize );
}

#ifdef KSL_IPINIP
DWORD
IpmontrCreateInterface(
    IN  LPCWSTR pwszMachineName,
    IN  LPCWSTR pwszInterfaceName,
    IN  DWORD   dwLocalAddress,
    IN  DWORD   dwRemoteAddress,
    IN  BYTE    byTtl
    )
/*++

Description: TODO This function is really really really ugly and does
    not belong in Netsh.  There needs to be a system API to do this,
    but there isn't one right now so we have to workaround it by copying
    all this crud here.  This code is stolen from netsh\if\routerdb.c
    RtrInterfaceAddIpip() which is also really really really ugly.
--*/
{
    DWORD                   dwErr = ERROR_CAN_NOT_COMPLETE;
    GUID                    Guid; 
    GUID                   *pGuid = &Guid;
    MPR_IPINIP_INTERFACE_0  NameInfo;
    MPR_INTERFACE_0         IfInfo;
    HANDLE                  hIfCfg;
    HANDLE                  hIfAdmin;
    IPINIP_CONFIG_INFO      info;

    // Initialize
    //
    ZeroMemory(&IfInfo, sizeof(IfInfo));
    IfInfo.fEnabled = TRUE;
    IfInfo.dwIfType = ROUTER_IF_TYPE_TUNNEL1;

    wcscpy(IfInfo.wszInterfaceName, pwszInterfaceName);

    info.dwLocalAddress  = dwLocalAddress;
    info.dwRemoteAddress = dwRemoteAddress;
    info.byTtl           = byTtl;
    dwErr = AddSetIpIpTunnelInfo(pwszInterfaceName, &info);

    if(dwErr isnot NO_ERROR)
    {
        //
        // Tear down the mapping
        //

        MprSetupIpInIpInterfaceFriendlyNameDelete(NULL, pGuid);
    }

    return dwErr;
}

DWORD
IpmontrDeleteInterface(
    IN  LPCWSTR pwszMachineName,
    IN  LPCWSTR pwszInterfaceName
    )
/*++
Description: TODO This function is really really really ugly and does
    not belong in Netsh.  There needs to be a system API to do this,
    but there isn't one right now so we have to workaround it by copying
    all this crud here.  This code is stolen from netsh\if\routerdb.c
    RtrInterfaceDelete() which is also really really really ugly.
Called by: HandleMsdpDeletePeer()
--*/
{
    DWORD              dwErr = ERROR_CAN_NOT_COMPLETE;
    DWORD              dwSize;
    HANDLE             hIfCfg, hIfAdmin;
    GUID               Guid;
    MPR_INTERFACE_0   *pIfInfo;

    do {
        dwErr = MprConfigInterfaceGetHandle(g_hMprConfig,
                                            (LPWSTR)pwszInterfaceName,
                                            &hIfCfg);

        if(dwErr isnot NO_ERROR)
        {
            break;
        }

        dwErr = MprConfigInterfaceGetInfo(g_hMprConfig,
                                          hIfCfg,
                                          0,
                                          (PBYTE *)&pIfInfo,
                                          &dwSize);

        if(dwErr isnot NO_ERROR)
        {
            break;
        }

        if(pIfInfo->dwIfType isnot ROUTER_IF_TYPE_TUNNEL1)
        {
            MprConfigBufferFree(pIfInfo);

            dwErr = ERROR_INVALID_PARAMETER;

            break;
        }
#ifdef KSL_IPINIP
        dwErr = MprConfigInterfaceDelete(g_hMprConfig,
                                         hIfCfg);

        MprConfigBufferFree(pIfInfo);

        if(dwErr isnot NO_ERROR)
        {
            break;
        }

        dwErr = ConvertStringToGuid(pwszInterfaceName,
                                    (USHORT)(wcslen(pwszInterfaceName) * sizeof(WCHAR)),
                                    &Guid);

        if(dwErr isnot NO_ERROR)
        {
            break;
        }

        dwErr = MprSetupIpInIpInterfaceFriendlyNameDelete((LPWSTR)pwszMachineName,
                                                          &Guid);

        if(IsRouterRunning())
        {
            dwErr = MprAdminInterfaceGetHandle(g_hMprAdmin,
                                               (LPWSTR)pwszInterfaceName,
                                               &hIfAdmin,
                                               FALSE);

            if(dwErr isnot NO_ERROR)
            {
                break;
            }

            dwErr = MprAdminInterfaceDelete(g_hMprAdmin,
                                            hIfAdmin);
        }
#endif //KSL_IPINIP

    } while (FALSE);

    return dwErr;
}
#endif //KSL_IPINIP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ip\preview\common.c ===
#include "precomp.h"
#pragma hdrstop

// {8854ff10-d504-11d2-b1ff-00104bc54139}
static const GUID g_MyGuid = 
{ 0x8854ff10, 0xd504, 0x11d2, { 0xb1, 0xff, 0x0, 0x10, 0x4b, 0xc5, 0x41, 0x39 } };

static const GUID g_IpGuid = IPMONTR_GUID;

#define IPPREVIEW_HELPER_VERSION 1

// shell functions

HANDLE g_hModule;
MIB_SERVER_HANDLE g_hMibServer;

VALUE_STRING CommonBooleanStringArray[] = {
    TRUE,  STRING_ENABLED,
    FALSE, STRING_DISABLED
};

VALUE_TOKEN CommonBooleanTokenArray[] = {
    TRUE,  TOKEN_OPT_VALUE_ENABLE,
    FALSE, TOKEN_OPT_VALUE_DISABLE
};

VALUE_STRING CommonLoggingStringArray[] = {
    VRRP_LOGGING_NONE,  STRING_LOGGING_NONE,
    VRRP_LOGGING_ERROR, STRING_LOGGING_ERROR,
    VRRP_LOGGING_WARN,  STRING_LOGGING_WARN,
    VRRP_LOGGING_INFO,  STRING_LOGGING_INFO
};

VALUE_TOKEN CommonLoggingTokenArray[] = {
    VRRP_LOGGING_NONE,  TOKEN_OPT_VALUE_NONE,
    VRRP_LOGGING_ERROR, TOKEN_OPT_VALUE_ERROR,
    VRRP_LOGGING_WARN,  TOKEN_OPT_VALUE_WARN,
    VRRP_LOGGING_INFO,  TOKEN_OPT_VALUE_INFO
};

BOOL WINAPI
DllMain(
    HINSTANCE hInstDll,
    DWORD fdwReason,
    LPVOID pReserved
    )
{
    HANDLE     hDll;
    
    switch (fdwReason)
    {
        case DLL_PROCESS_ATTACH:
        {
            // printf("Trying to attach\n");
            
            g_hModule = hInstDll;

            DisableThreadLibraryCalls(hInstDll);

            break;
        }
        case DLL_PROCESS_DETACH:
        {
            //
            // Clean up any structures used for commit
            //
            
            break;
        }

        default:
        {
            break;
        }
    }

    return TRUE;
}

DWORD WINAPI
IpprvwmonStartHelper(
    IN CONST GUID *pguidParent,
    IN DWORD       dwVersion
    )
{
    DWORD dwErr;
    IP_CONTEXT_ATTRIBUTES attMyAttributes;

    ZeroMemory(&attMyAttributes, sizeof(attMyAttributes));

    // If you add any more contexts, then this should be converted
    // to use an array instead of duplicating code!

    attMyAttributes.pwszContext = L"vrrp";
    attMyAttributes.guidHelper  = g_MyGuid;
    attMyAttributes.dwVersion   = 1;
    attMyAttributes.dwFlags     = 0;
    attMyAttributes.pfnDumpFn   = VrrpDump;
    attMyAttributes.ulNumTopCmds= g_VrrpTopCmdCount;
    attMyAttributes.pTopCmds    = (CMD_ENTRY (*)[])&g_VrrpTopCmdTable;
    attMyAttributes.ulNumGroups = g_VrrpCmdGroupCount;
    attMyAttributes.pCmdGroups  = (CMD_GROUP_ENTRY (*)[])&g_VrrpCmdGroupTable;

    dwErr = RegisterContext( &attMyAttributes );

    attMyAttributes.pwszContext = L"msdp";
    attMyAttributes.dwVersion   = 1;
    attMyAttributes.dwFlags     = 0;
    attMyAttributes.pfnDumpFn   = MsdpDump;
    attMyAttributes.ulNumTopCmds= g_MsdpTopCmdCount;
    attMyAttributes.pTopCmds    = (CMD_ENTRY (*)[])&g_MsdpTopCmdTable;
    attMyAttributes.ulNumGroups = g_MsdpCmdGroupCount;
    attMyAttributes.pCmdGroups  = (CMD_GROUP_ENTRY (*)[])&g_MsdpCmdGroupTable;

    dwErr = RegisterContext( &attMyAttributes );
    
    return dwErr;
}

DWORD WINAPI
InitHelperDll(
    IN  DWORD              dwNetshVersion,
    OUT PNS_DLL_ATTRIBUTES pDllTable
    )
{
    DWORD dwErr;
    NS_HELPER_ATTRIBUTES attMyAttributes;

    pDllTable->dwVersion = NETSH_VERSION_50;
    pDllTable->pfnStopFn = NULL;

    // Register helpers.  We could either register 1 helper which
    // registers three contexts, or we could register 3 helpers
    // which each register one context.  There's only a difference
    // if we support sub-helpers, which this DLL does not.
    // If we later support sub-helpers, then it's better to have
    // 3 helpers so that sub-helpers can register with 1 of them,
    // since it registers with a parent helper, not a parent context.
    // For now, we just use a single 3-context helper for efficiency.

    ZeroMemory( &attMyAttributes, sizeof(attMyAttributes) );

    attMyAttributes.guidHelper         = g_MyGuid;
    attMyAttributes.dwVersion          = IPPREVIEW_HELPER_VERSION;
    attMyAttributes.pfnStart           = IpprvwmonStartHelper;
    attMyAttributes.pfnStop            = NULL;

    dwErr = RegisterHelper( &g_IpGuid, &attMyAttributes );

    return dwErr;
}

BOOL
IsProtocolInstalled(
    DWORD  dwProtoId,
    WCHAR *pwszName
    )
{
    PVOID       pvStart;
    DWORD       dwCount, dwBlkSize, dwRes;

    dwRes = IpmontrGetInfoBlockFromGlobalInfo(dwProtoId,
                                       (PBYTE *) NULL,
                                       &dwBlkSize,
                                       &dwCount);

    if (dwRes isnot NO_ERROR)
    {
        DisplayError(g_hModule, EMSG_PROTO_NOT_INSTALLED, pwszName);
        return FALSE;
    }

    return TRUE;
}

DWORD
GetMIBIfIndex(
    IN    PTCHAR   *pptcArguments,
    IN    DWORD    dwCurrentIndex,
    OUT   PDWORD   pdwIndices,
    OUT   PDWORD   pdwNumParsed
    )
/*++

Routine Description:

    Gets the interface index.

Arguments:

    pptcArguments  - Argument array
    dwCurrentIndex - Index of the first argument in array
    pdwIndices     - Indices specified in command
    pdwNumParsed   - Number of indices in command

Return Value:

    NO_ERROR

--*/
{
    DWORD dwErr = NO_ERROR;

    *pdwNumParsed = 1;

    // If index was specified just use it

    if (iswdigit(pptcArguments[dwCurrentIndex][0]))
    {
        pdwIndices[0] = _tcstoul(pptcArguments[dwCurrentIndex],NULL,10);

        return NO_ERROR;
    }

    // Try converting a friendly name to an ifindex

    return IpmontrGetIfIndexFromFriendlyName( g_hMibServer,
                                       pptcArguments[dwCurrentIndex],
                                       &pdwIndices[0] );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ip\preview\ipprodefs.h ===
#define ptszDelimiter L"="

//-----------------------------------------------------------------------------
//  Macros to faciltate address list (DWORD list) access
//-----------------------------------------------------------------------------

#define     GET_SERVER_INDEX( list, count, addr, index )                    \
{                                                                           \
    DWORD   __dwInd = 0;                                                    \
    for ( ; __dwInd < count; __dwInd++ )                                    \
        if ( list[ __dwInd ] == addr ) { break; }                           \
    index = __dwInd;                                                        \
}

#define     DELETE_SERVER_ADDR( list1, list2, count, index )                \
{                                                                           \
    DWORD   __dwInd1 = 0, __dwInd2 = 0;                                     \
    for ( ; __dwInd1 < count; __dwInd1++ )                                  \
    {                                                                       \
        if ( __dwInd1 == index ) { continue; }                              \
        list2[ __dwInd2++ ] = list1[ __dwInd1 ];                            \
    }                                                                       \
}

//-----------------------------------------------------------------------------
//  Macros to faciltate RIP filter list access
//-----------------------------------------------------------------------------

#define     GET_FILTER_INDEX( list, count, filt, index )                    \
{                                                                           \
    DWORD   __dwInd = 0;                                                    \
    for ( ; __dwInd < count; __dwInd++ )                                    \
        if ( ( list[ __dwInd ].RF_LoAddress == filt.RF_LoAddress ) &&       \
             ( list[ __dwInd ].RF_HiAddress == filt.RF_HiAddress ) )        \
        {                                                                   \
            break;                                                          \
        }                                                                   \
    index = __dwInd;                                                        \
}

#define     DELETE_FILTER( list1, list2, count, index )                     \
    DELETE_SERVER_ADDR( list1, list2, count, index )

#define IsHelpToken(pwszToken)\
    (MatchToken(pwszToken, CMD_HELP1)  \
    || MatchToken(pwszToken, CMD_HELP2))

#define     GetDispString(gModule, val, str, count, table)                  \
{                                                                           \
    DWORD   __dwInd = 0;                                                    \
    for( ; __dwInd < (count); __dwInd += 2 )                                \
    {                                                                       \
        if ( (val) != (table)[ __dwInd ] ) { continue; }                    \
        (str) = MakeString( (gModule), (table)[ __dwInd + 1 ] );            \
        break;                                                              \
    }                                                                       \
    if ( __dwInd >= (count) ) { (str) = MakeString( (gModule), STRING_UNKNOWN ); } \
}

//
// mcast addr: 224.0.0.0 < group <240.0.0.0
//

#define IS_MCAST_ADDR(Group) \
    ( (0x000000E0!=(Group))  \
      && (0x000000E0 <= ((Group)&0x000000FF) ) \
      && (0x000000F0 >  ((Group)&0x000000FF) ) )

#define HEAP_FREE_NOT_NULL(ptr) {\
    if (ptr) HeapFree(GetProcessHeap(), 0, (ptr));}

#define HEAP_FREE(ptr) { \
    HeapFree(GetProcessHeap(), 0, ptr);}

#define GET_TOKEN_PRESENT(tokenMask) (dwBitVector & tokenMask)
#define SET_TOKEN_PRESENT(tokenMask) (dwBitVector |= tokenMask)

#define MAX_NUM_INDICES 6
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ip\preview\ipprvwdefs.h ===
#define ptszDelimiter L"="

//-----------------------------------------------------------------------------
//  Macros to faciltate address list (DWORD list) access
//-----------------------------------------------------------------------------

#define     GET_SERVER_INDEX( list, count, addr, index )                    \
{                                                                           \
    DWORD   __dwInd = 0;                                                    \
    for ( ; __dwInd < count; __dwInd++ )                                    \
        if ( list[ __dwInd ] == addr ) { break; }                           \
    index = __dwInd;                                                        \
}

#define     DELETE_SERVER_ADDR( list1, list2, count, index )                \
{                                                                           \
    DWORD   __dwInd1 = 0, __dwInd2 = 0;                                     \
    for ( ; __dwInd1 < count; __dwInd1++ )                                  \
    {                                                                       \
        if ( __dwInd1 == index ) { continue; }                              \
        list2[ __dwInd2++ ] = list1[ __dwInd1 ];                            \
    }                                                                       \
}

//-----------------------------------------------------------------------------
//  Macros to faciltate RIP filter list access
//-----------------------------------------------------------------------------

#define     GET_FILTER_INDEX( list, count, filt, index )                    \
{                                                                           \
    DWORD   __dwInd = 0;                                                    \
    for ( ; __dwInd < count; __dwInd++ )                                    \
        if ( ( list[ __dwInd ].RF_LoAddress == filt.RF_LoAddress ) &&       \
             ( list[ __dwInd ].RF_HiAddress == filt.RF_HiAddress ) )        \
        {                                                                   \
            break;                                                          \
        }                                                                   \
    index = __dwInd;                                                        \
}

#define     DELETE_FILTER( list1, list2, count, index )                     \
    DELETE_SERVER_ADDR( list1, list2, count, index )

#define IsHelpToken(pwszToken)\
    (MatchToken(pwszToken, CMD_HELP1)  \
    || MatchToken(pwszToken, CMD_HELP2))

#define     GetDispString(gModule, val, str, count, table)                  \
{                                                                           \
    DWORD   __dwInd = 0;                                                    \
    for( ; __dwInd < (count); __dwInd += 2 )                                \
    {                                                                       \
        if ( (val) != (table)[ __dwInd ] ) { continue; }                    \
        (str) = MakeString( (gModule), (table)[ __dwInd + 1 ] );            \
        break;                                                              \
    }                                                                       \
    if ( __dwInd >= (count) ) { (str) = MakeString( (gModule), STRING_UNKNOWN ); } \
}

//
// mcast addr: 224.0.0.0 < group <240.0.0.0
//

#define IS_MCAST_ADDR(Group) \
    ( (0x000000E0!=(Group))  \
      && (0x000000E0 <= ((Group)&0x000000FF) ) \
      && (0x000000F0 >  ((Group)&0x000000FF) ) )

#define HEAP_FREE_NOT_NULL(ptr) {\
    if (ptr) HeapFree(GetProcessHeap(), 0, (ptr));}

#define HEAP_FREE(ptr) { \
    HeapFree(GetProcessHeap(), 0, ptr);}

#define GET_TOKEN_PRESENT(tokenMask) (dwBitVector & tokenMask)
#define SET_TOKEN_PRESENT(tokenMask) (dwBitVector |= tokenMask)

#define MAX_NUM_INDICES 6
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ip\preview\msdp.h ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    net\routing\netsh\ip\protocols\msdphlp.h

Abstract:

    MSDP Command dispatcher declarations

Author:

    Peeyush Ranjan (peeyushr)   1-Mar-1999

Revision History:

--*/

#ifndef _NETSH_MSDPHLP_H_
#define _NETSH_MSDPHLP_H_

extern CMD_ENTRY g_MsdpAddCmdTable[];
extern CMD_ENTRY g_MsdpDelCmdTable[];
extern CMD_ENTRY g_MsdpSetCmdTable[];
extern CMD_ENTRY g_MsdpShowCmdTable[];


extern CMD_GROUP_ENTRY g_MsdpCmdGroupTable[];
extern ULONG g_MsdpCmdGroupCount;
extern CMD_ENTRY g_MsdpTopCmdTable[];
extern ULONG g_MsdpTopCmdCount;

NS_CONTEXT_DUMP_FN  MsdpDump;

extern VALUE_STRING MsdpEncapsStringArray[];
extern VALUE_TOKEN  MsdpEncapsTokenArray[];
#define MSDP_ENCAPS_SIZE 1

#endif // _NETSH_MSDPHLP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ip\preview\msdp.c ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    net\routing\netsh\ip\protocols\msdp.c

Abstract:

    This module contains code for dispatching commands
    received for the Multicast Source Discovery Protocol.
    The implementation of the commands is elsewhere,
    in msdpopt.c.

Author

    Dave Thaler (dthaler)  21-May-1999

Revision History:

    Based loosely on net\routing\netsh\ip\protocols\nathlp.c by AboladeG

--*/

#include "precomp.h"
#pragma hdrstop


CMD_ENTRY g_MsdpAddCmdTable[] =
{
    CREATE_CMD_ENTRY(MSDP_ADD_PEER, HandleMsdpAddPeer),
};

CMD_ENTRY g_MsdpDeleteCmdTable[] =
{
    CREATE_CMD_ENTRY(MSDP_DELETE_PEER, HandleMsdpDeletePeer),
};

CMD_ENTRY g_MsdpSetCmdTable[] =
{
    CREATE_CMD_ENTRY(MSDP_SET_GLOBAL, HandleMsdpSetGlobal),
    CREATE_CMD_ENTRY(MSDP_SET_PEER,   HandleMsdpSetPeer)
};

CMD_ENTRY g_MsdpShowCmdTable[] =
{
    CREATE_CMD_ENTRY(MSDP_SHOW_SA,          HandleMsdpMibShowObject),
    CREATE_CMD_ENTRY(MSDP_SHOW_GLOBAL,      HandleMsdpShowGlobal),
    CREATE_CMD_ENTRY(MSDP_SHOW_GLOBALSTATS, HandleMsdpMibShowObject),
    CREATE_CMD_ENTRY(MSDP_SHOW_PEER,        HandleMsdpShowPeer),
    CREATE_CMD_ENTRY(MSDP_SHOW_PEERSTATS,   HandleMsdpMibShowObject)
};

CMD_GROUP_ENTRY g_MsdpCmdGroupTable[] =
{
    CREATE_CMD_GROUP_ENTRY(GROUP_ADD,    g_MsdpAddCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_DELETE, g_MsdpDeleteCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_SET,    g_MsdpSetCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_SHOW,   g_MsdpShowCmdTable)
};

ULONG g_MsdpCmdGroupCount =
    sizeof(g_MsdpCmdGroupTable) / sizeof(g_MsdpCmdGroupTable[0]);

CMD_ENTRY g_MsdpTopCmdTable[] =
{
    CREATE_CMD_ENTRY(INSTALL,   HandleMsdpInstall),
    CREATE_CMD_ENTRY(UNINSTALL, HandleMsdpUninstall),
};

ULONG g_MsdpTopCmdCount =
    sizeof(g_MsdpTopCmdTable) / sizeof(g_MsdpTopCmdTable[0]);

DWORD
MsdpDump(
    PWCHAR  pwszMachine,
    WCHAR   **ppwcArguments,
    DWORD   dwArgCount,
    PVOID   pvData
    )
{
    g_hMibServer = (MIB_SERVER_HANDLE)pvData;

    DisplayMessage(g_hModule,DMP_MSDP_HEADER);
    DisplayMessageT(DMP_MSDP_PUSHD);
    DisplayMessageT(DMP_UNINSTALL);

    //
    // Show the global info commands
    //

    ShowMsdpGlobalInfo(FORMAT_DUMP);

    ShowMsdpPeerInfo(FORMAT_DUMP, NULL, NULL);

    DisplayMessageT(DMP_POPD);
    DisplayMessage(g_hModule, DMP_MSDP_FOOTER);

    return NO_ERROR;
} // MSDPDump
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ip\preview\msdpcfg.h ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    net\routing\netsh\ip\protocols\msdpcfg.h

Abstract:

    MSDP configuration declarations

Author:

    Dave Thaler (peeyushr)   1-Mar-1999

Revision History:

--*/

#ifndef _NETSH_MSDPCFG_H_
#define _NETSH_MSDPCFG_H_

#define MSDP_IPADDR_LENGTH  16
#define MAX_MESSAGE_SIZE    256

#define MSDP_INTF_VRID_MASK     0x00000001
#define MSDP_INTF_IPADDR_MASK   0x00000002
#define MSDP_INTF_AUTH_MASK     0x00000004
#define MSDP_INTF_PASSWD_MASK   0x00000008
#define MSDP_INTF_ADVT_MASK     0x00000010
#define MSDP_INTF_PRIO_MASK     0x00000020
#define MSDP_INTF_PREEMPT_MASK  0x00000040

DWORD
GetMsdpGlobalConfig(
    OUT PMSDP_GLOBAL_CONFIG *ppGlobalInfo
    );

DWORD
SetMsdpGlobalConfig(
    OUT PMSDP_GLOBAL_CONFIG pGlobalInfo
    );

DWORD
MakeMsdpGlobalConfig(
    OUT PUCHAR* GlobalInfo,
    OUT PULONG GlobalInfoSize
    );

DWORD
CreateMsdpGlobalConfig(
    OUT PMSDP_GLOBAL_CONFIG* GlobalInfo,
    IN  DWORD LoggingLevel
    );

ULONG
MakeMsdpIPv4PeerConfig(
    PMSDP_IPV4_PEER_CONFIG *ppPeer
    );

DWORD
SetMsdpInterfaceConfig(
    PWCHAR                 pwszInterfaceName,
    PMSDP_IPV4_PEER_CONFIG pConfigInfo
    );

DWORD
GetMsdpInterfaceConfig(
    PWCHAR                  pwszInterfaceName,
    PMSDP_IPV4_PEER_CONFIG *ppConfigInfo
    );

DWORD
ShowMsdpGlobalInfo(
    IN DWORD dwFormat
    );

DWORD
ShowMsdpPeerInfo(
    DWORD  dwFormat,
    PWCHAR pwszPeerAddress,
    PWCHAR pwszPeerName
    );

DWORD
UpdateMsdpGlobalInfo(
    PMSDP_GLOBAL_CONFIG GlobalInfo
    );

DWORD
UpdateMsdpPeerInfo(
    PWCHAR                 PeerName,
    PMSDP_IPV4_PEER_CONFIG PeerInfo,
    ULONG                  BitVector,
    BOOL                   AddPeer
    );

DWORD
MsdpAddIPv4PeerInterface(
    IN LPCWSTR                pwszMachineName,
    IN LPCWSTR                pwszInterfaceName, 
    IN PMSDP_IPV4_PEER_CONFIG pPeer
    );

DWORD
MsdpDeletePeerInterface(
    IN  LPCWSTR pwszMachineName,
    IN  LPCWSTR pwszInterfaceName
    );

DWORD
GetMsdpPeerInfoSize(
    PMSDP_IPV4_PEER_CONFIG PeerInfo
    );

//
// IP address conversion macros:
//    
//  calls inet_ntoa directly on a DWORD, by casting it as an IN_ADDR.
//
#define INET_NTOA(dw) inet_ntoa( *(PIN_ADDR)&(dw) )

#define FORMAT_TABLE       1
#define FORMAT_VERBOSE     2
#define FORMAT_DUMP        3

#endif  // _NETSH_MSDPCFG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ip\preview\msdpmib.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:
     net\routing\netsh\ip\protocols\msdpmib.h   

Abstract:

    Include for msdpmib.c

Author:

     Dave Thaler        11/03/99

Revision History:


--*/

#ifndef _MSDPMIB_H_
#define _MSDPMIB_H_

DWORD
GetMsdpMIBIfIndex(
    IN OUT LPWSTR  *pptcArguments,
    IN     DWORD    dwCurrentIndex,
    OUT    PDWORD   pdwIndices,
    OUT    PDWORD   pdwNumParsed 
);

DWORD
GetMsdpMIBIpAddress(
    IN OUT LPWSTR  *pptcArguments,
    IN     DWORD    dwCurrentIndex,
    IN     DWORD    dwArgCount,
    OUT    PDWORD   pdwIndices,
    OUT    PDWORD   pdwNumParsed 
);

DWORD
GetMsdpMIBSAIndex(
    IN OUT  LPWSTR  *ppwcArguments,
    IN      DWORD    dwCurrentIndex,
    IN      DWORD    dwArgCount,
    OUT     PDWORD   pdwIndices,
    OUT     PDWORD   pdwNumParsed
    );

typedef
VOID
(MSDP_PRINT_FN)(
    PMIB_OPAQUE_INFO pgodInfo,
    DWORD            dwFormat
    );

typedef MSDP_PRINT_FN *PMSDP_PRINT_FN;

MSDP_PRINT_FN PrintMsdpGlobalStats;
MSDP_PRINT_FN PrintMsdpPeerStats;
MSDP_PRINT_FN PrintMsdpSA;

typedef struct _MSDP_MAGIC_TABLE
{
    DWORD           dwId;
    PMSDP_PRINT_FN  pfnPrintFunction;
    ULONG           ulIndexBytes;
}MSDP_MAGIC_TABLE, *PMSDP_MAGIC_TABLE;

FN_HANDLE_CMD HandleMsdpMibShowObject;

#endif //_MSDPMIB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ip\preview\msdpopt.h ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    net\routing\netsh\ip\protocols\vrrpopt.h

Abstract:

    MSDP Command dispatcher declarations

Author:

    Dave Thaler (dthaler)   21-May-1999

Revision History:

--*/


#ifndef _NETSH_MSDPOPT_H_
#define _NETSH_MSDPOPT_H_

FN_HANDLE_CMD HandleMsdpAddPeer;
FN_HANDLE_CMD HandleMsdpDeletePeer;
FN_HANDLE_CMD HandleMsdpSetPeer;
FN_HANDLE_CMD HandleMsdpShowPeer;
FN_HANDLE_CMD HandleMsdpSetGlobal;
FN_HANDLE_CMD HandleMsdpShowGlobal;
FN_HANDLE_CMD HandleMsdpInstall;
FN_HANDLE_CMD HandleMsdpUninstall;

#endif // _NETSH_MSDPOPT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ip\preview\msdpopt.c ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    net\routing\netsh\ip\protocols\msdpopt.c

Abstract:

    MSDP command options implementation.
    This module contains handlers for the configuration commands
    supported by the MSDP Protocol.

Author:

    Dave Thaler (dthaler)   21-May-1999

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include <ipcmp.h>

#define MALLOC(x) HeapAlloc(GetProcessHeap(), 0, (x))
#define FREE(x)   HeapFree(GetProcessHeap(), 0, (x))

//
// Forward declarations
//

ULONG
QueryTagArray(
    IN  PTCHAR   ppwszArgumentArray[],
    IN  ULONG    ululArgumentCount,
    IN  TAG_TYPE pttTagTypeArray[],
    IN  ULONG    ulTagTypeCount,
    OUT PULONG*  ppulTagArray
    );

ULONG
ValidateTagTypeArray(
    IN  TAG_TYPE pttTagTypeArray[],
    IN  ULONG    ulTagTypeCount
    );


DWORD
HandleMsdpAddPeer(
    PWCHAR  pwszMachineName,
    PTCHAR* ArgumentArray,
    DWORD   ulArgumentIndex,
    DWORD   ulArgumentCount,
    DWORD   dwFlags,
    PVOID   pvData,
    BOOL*   CommandDone
    )
{
    ULONG    ulArgumentsLeft;
    ULONG    BitVector;
    DWORD    dwErr;
    ULONG    ulErrorIndex = 0;
    ULONG    i;
    PULONG   pulTagArray;
    ULONG    InfoSize;
    DWORD    dwBufferSize = MAX_INTERFACE_NAME_LEN + 1;
    WCHAR    wszInterfaceName[MAX_INTERFACE_NAME_LEN + 1];
    TAG_TYPE TagTypeArray[] = { { TOKEN_OPT_NAME,         NS_REQ_PRESENT,  FALSE },
                                { TOKEN_OPT_REMADDR,      NS_REQ_PRESENT,  FALSE },
                                { TOKEN_OPT_LOCALADDR,    NS_REQ_PRESENT,  FALSE },
                                { TOKEN_OPT_KEEPALIVE,    NS_REQ_ZERO, FALSE },
                                { TOKEN_OPT_CONNECTRETRY, NS_REQ_ZERO, FALSE },
                                { TOKEN_OPT_CACHING,      NS_REQ_ZERO, FALSE },
                                { TOKEN_OPT_DEFAULTPEER,  NS_REQ_ZERO, FALSE },
                                { TOKEN_OPT_ENCAPSMETHOD, NS_REQ_ZERO, FALSE },
                              };
    PMSDP_IPV4_PEER_CONFIG pPeer = NULL;

    VERIFY_INSTALLED(MS_IP_MSDP, L"MSDP");

    if (ulArgumentIndex >= ulArgumentCount) { 
        return ERROR_SHOW_USAGE; 
    }
    ulArgumentsLeft = ulArgumentCount - ulArgumentIndex;

    //
    // We convert the optional tags into an array of 'TagTypeArray' indices
    // which guide is in our scanning of the argument list.
    // Since the tags are optional, this process may result in no tags at all,
    // in which case we assume that arguments are specified in exactly the order
    // given in 'TagTypeArray' above.
    //

    dwErr = QueryTagArray( &ArgumentArray[ulArgumentIndex],
                           ulArgumentsLeft,
                           TagTypeArray,
                           NUM_TAGS_IN_TABLE(TagTypeArray),
                           &pulTagArray );
    if (dwErr) { return dwErr; }

    BitVector = 0;

    do {
        dwErr = MakeMsdpIPv4PeerConfig(&pPeer);
        if (dwErr isnot NO_ERROR) 
        {
            break;
        }

        //
        // We now scan the argument list, converting the arguments
        // into information in our 'VrouterGiven' structure.
        //

        for (i = 0; i < ulArgumentsLeft; i++) {
            switch(pulTagArray ? pulTagArray[i] : i) {
                case 0: { // name
                    wcscpy(wszInterfaceName, ArgumentArray[i+ulArgumentIndex]);
                    break;
                }
                case 1: { // remaddr
                    pPeer->ipRemoteAddress = GetIpAddress(
                                          ArgumentArray[i + ulArgumentIndex]);
                    break;
                }
                case 2: { // localaddr
                    pPeer->ipLocalAddress = GetIpAddress(
                                          ArgumentArray[i + ulArgumentIndex]);
                    break;
                }
                case 3: { // keepalive
                    if (!MatchToken(ArgumentArray[i+ulArgumentIndex],
                                    TOKEN_OPT_VALUE_DEFAULT))
                    {
                        pPeer->ulKeepAlive = _tcstoul(
                                          ArgumentArray[i + ulArgumentIndex],
                                          NULL, 10);
                        pPeer->dwConfigFlags |= MSDP_PEER_CONFIG_KEEPALIVE;
                    }
                    break;
                }
                case 4: { // connectretry
                    if (!MatchToken(ArgumentArray[i+ulArgumentIndex],
                                    TOKEN_OPT_VALUE_DEFAULT))
                    {
                        pPeer->ulConnectRetry = _tcstoul(
                                          ArgumentArray[i + ulArgumentIndex],
                                          NULL, 10);
                        pPeer->dwConfigFlags |= MSDP_PEER_CONFIG_CONNECTRETRY;
                    }
                    break;
                }
                case 5: { // caching
                    DWORD dwValue;
                    TOKEN_VALUE TokenArray[] = {
                        { TOKEN_OPT_VALUE_NO,  FALSE },
                        { TOKEN_OPT_VALUE_YES, TRUE }
                    };
                    pPeer->dwConfigFlags &= ~MSDP_PEER_CONFIG_CACHING;
                    dwErr = MatchEnumTag( g_hModule,
                                          ArgumentArray[i + ulArgumentIndex],
                                          NUM_TOKENS_IN_TABLE(TokenArray),
                                          TokenArray,
                                          &dwValue );
                    if (dwErr isnot NO_ERROR)
                    {
                        dwErr = ERROR_INVALID_PARAMETER;
                        break;
                    }
                    if (dwValue is TRUE)
                    {
                        pPeer->dwConfigFlags |= MSDP_PEER_CONFIG_CACHING;
                    }
                    break;
                }
                case 6: { // defaultpeer
                    DWORD dwValue;
                    TOKEN_VALUE TokenArray[] = {
                        { TOKEN_OPT_VALUE_NO,  FALSE },
                        { TOKEN_OPT_VALUE_YES, TRUE }
                    };
                    pPeer->dwConfigFlags &= ~MSDP_PEER_CONFIG_DEFAULTPEER;
                    dwErr = MatchEnumTag( g_hModule,
                                          ArgumentArray[i + ulArgumentIndex],
                                          NUM_TOKENS_IN_TABLE(TokenArray),
                                          TokenArray,
                                          &dwValue );
                    if (dwErr isnot NO_ERROR)
                    {
                        dwErr = ERROR_INVALID_PARAMETER;
                        break;
                    }
                    if (dwValue is TRUE)
                    {
                        pPeer->dwConfigFlags |= MSDP_PEER_CONFIG_DEFAULTPEER;
                    }
                    break;
                }
                case 7: { // encapsulation
                    DWORD dwValue;
                    dwErr = MatchEnumTag( g_hModule,
                                          ArgumentArray[i + ulArgumentIndex],
                                          MSDP_ENCAPS_SIZE,
                                          (PTOKEN_VALUE)MsdpEncapsTokenArray,
                                          &dwValue );
                    if (dwErr isnot NO_ERROR)
                    {
                        dwErr = ERROR_INVALID_PARAMETER;
                        break;
                    }
                    pPeer->dwEncapsMethod = dwValue;
                    break;
                }
            }
        }

        if (dwErr isnot NO_ERROR)
        {
            break;
        }

        // higher IP is passive.  Setting this bit has no effect
        // except on the "show peer" report when the router isn't running.
        if (ntohl(pPeer->ipLocalAddress) > ntohl(pPeer->ipRemoteAddress))
        {
            pPeer->dwConfigFlags |= MSDP_PEER_CONFIG_PASSIVE;
        }
    
        //
        // Update the configuration with the new settings.
        // Note that the update routine may perform additional validation
        // in the process of reconciling the new settings
        // with any existing settings.
        //
        dwErr = MsdpAddIPv4PeerInterface(pwszMachineName,
                                         wszInterfaceName, pPeer );
    } while (FALSE);

    if (pPeer)
    {
        FREE(pPeer);
    }

    if (pulTagArray)
    {
        FREE(pulTagArray);
    }
    if (dwErr is NO_ERROR)
    {
        dwErr = ERROR_OKAY;
    }

    return dwErr;
}


DWORD
HandleMsdpDeletePeer(
    PWCHAR  pwszMachineName,
    PTCHAR* ArgumentArray,
    DWORD   ulArgumentIndex,
    DWORD   ulArgumentCount,
    DWORD   dwFlags,
    PVOID   pvData,
    BOOL*   CommandDone
    )
{
    ULONG  ulArgumentsLeft;
    ULONG  BitVector;
    DWORD  dwErr;
    ULONG  ulErrorIndex = 0;
    ULONG  i;
    PULONG pulTagArray;
    ULONG  InfoSize;
    WCHAR  wszInterfaceName[MAX_INTERFACE_NAME_LEN + 1];
    DWORD  dwBufferSize = sizeof(wszInterfaceName);

    TAG_TYPE TagTypeArray[] = { { TOKEN_OPT_NAME, NS_REQ_PRESENT, FALSE }
                              };

    VERIFY_INSTALLED(MS_IP_MSDP, L"MSDP");

    if (ulArgumentIndex >= ulArgumentCount) { 
        return ERROR_SHOW_USAGE; 
    }
    ulArgumentsLeft = ulArgumentCount - ulArgumentIndex;

    //
    // We convert the optional tags into an array of 'TagTypeArray' indices
    // which guide is in our scanning of the argument list.
    // Since the tags are optional, this process may result in no tags at all,
    // in which case we assume that arguments are specified in exactly the order
    // given in 'TagTypeArray' above.
    //

    dwErr = QueryTagArray( &ArgumentArray[ulArgumentIndex],
                           ulArgumentsLeft,
                           TagTypeArray,
                           NUM_TAGS_IN_TABLE(TagTypeArray),
                           &pulTagArray );
    if (dwErr) { return dwErr; }

    BitVector = 0;

    for (i = 0; i < ulArgumentsLeft; i++) {
        switch(pulTagArray ? pulTagArray[i] : i) {
            case 0: { // name
                IpmontrGetIfNameFromFriendlyName(
                                         ArgumentArray[i + ulArgumentIndex],
                                         wszInterfaceName,
                                         &dwBufferSize);
                break;
            }
        }
    }

    dwErr = IpmontrDeleteInterface( pwszMachineName, wszInterfaceName );
    if (dwErr is NO_ERROR)
    {
        dwErr = ERROR_OKAY;
    }
    
    return dwErr;
}

DWORD
HandleMsdpInstall(
    PWCHAR  pwszMachineName,
    PTCHAR* ArgumentArray,
    DWORD   ulArgumentIndex,
    DWORD   ulArgumentCount,
    DWORD   dwFlags,
    PVOID   pvData,
    BOOL*   CommandDone
    )
{
    DWORD  dwErr = ERROR_OKAY;
    PUCHAR pGlobalInfo;
    ULONG  ulLength;

    if (ulArgumentIndex != ulArgumentCount) { 
        return ERROR_SHOW_USAGE; 
    }

    //
    // To install MSDP, we construct the default configuration
    // and add it to the global configuration for the router.
    //
    dwErr = MakeMsdpGlobalConfig(&pGlobalInfo, &ulLength);
    if (dwErr isnot NO_ERROR) {
        DisplayError(g_hModule, dwErr);
    } else {
        dwErr = IpmontrSetInfoBlockInGlobalInfo( MS_IP_MSDP,
                                          pGlobalInfo,
                                          ulLength,
                                          1 );
        FREE(pGlobalInfo);
        if (dwErr is NO_ERROR) {
            dwErr = ERROR_OKAY;
        } else {
            DisplayError(g_hModule, dwErr);
        }
    }

    return dwErr;
}

DWORD
HandleMsdpSetGlobal(
    PWCHAR  pwszMachineName,
    PTCHAR* ArgumentArray,
    ULONG   ulArgumentIndex,
    ULONG   ulArgumentCount,
    DWORD   dwFlags,
    PVOID   pvData,
    BOOL*   CommandDone
    )
{
    ULONG               ulArgumentsLeft;
    DWORD               dwErr;
    PULONG              pulTagArray = NULL;
    DWORD               dwLoggingLevel, dwAcceptAll;
    ULONG               i, ulTemp;
    ULONG               ulErrorIndex;
    PMSDP_GLOBAL_CONFIG pGlobalInfo = NULL;
    
    TAG_TYPE TagTypeArray[] = { { TOKEN_OPT_LOGGINGLEVEL, FALSE, FALSE },
                                { TOKEN_OPT_KEEPALIVE,    FALSE, FALSE },
                                { TOKEN_OPT_SAHOLDDOWN,   FALSE, FALSE },
                                { TOKEN_OPT_CONNECTRETRY, FALSE, FALSE },
                                { TOKEN_OPT_ACCEPTALL,    FALSE, FALSE },
                                { TOKEN_OPT_CACHELIFETIME,FALSE, FALSE },
                              };

    VERIFY_INSTALLED(MS_IP_MSDP, L"MSDP");
    
    if (ulArgumentIndex >= ulArgumentCount) {
        return ERROR_SHOW_USAGE;
    }
    
    ulArgumentsLeft = ulArgumentCount - ulArgumentIndex;

    //
    // We convert the optional tags into an array of 'TagTypeArray' indices
    // which guide us in our scanning of the argument list.
    // Since the tags are optional, this process may result in no tags at all,
    // in which case we assume that arguments are specified in exactly the order
    // given in 'TagTypeArray' above.
    //

    dwErr = QueryTagArray( &ArgumentArray[ulArgumentIndex],
                           ulArgumentsLeft,
                           TagTypeArray,
                           NUM_TAGS_IN_TABLE(TagTypeArray),
                           &pulTagArray );
    if (dwErr) { return dwErr; }

    do {
        dwErr = GetMsdpGlobalConfig( &pGlobalInfo );
        if (dwErr isnot NO_ERROR)
        {
            break;
        }

        for (i = 0; i < ulArgumentsLeft; i++) {
            switch(pulTagArray ? pulTagArray[i] : i) {
                case 0: { // loglevel
                    TOKEN_VALUE TokenArray[] = {
                        { TOKEN_OPT_VALUE_NONE,  MSDP_LOGGING_NONE },
                        { TOKEN_OPT_VALUE_ERROR, MSDP_LOGGING_ERROR },
                        { TOKEN_OPT_VALUE_WARN,  MSDP_LOGGING_WARN },
                        { TOKEN_OPT_VALUE_INFO,  MSDP_LOGGING_INFO }
                    };
                    dwErr = MatchEnumTag( g_hModule,
                                          ArgumentArray[i + ulArgumentIndex],
                                          NUM_TOKENS_IN_TABLE(TokenArray),
                                          TokenArray,
                                          &pGlobalInfo->dwLoggingLevel );
                    if (dwErr) {
                        dwErr = ERROR_INVALID_PARAMETER;
                        ulErrorIndex = i;
                        i = ulArgumentsLeft;
                        break;
                    }                                
                    
                    TagTypeArray[pulTagArray ? pulTagArray[i] : i].bPresent = TRUE;
                    break;
                }
                case 1: { // keepalive
                    pGlobalInfo->ulDefKeepAlive = _tcstoul(
                                          ArgumentArray[i + ulArgumentIndex],
                                          NULL, 10);
                    break;
                }
                case 2: { // SA holddown
                    pGlobalInfo->ulSAHolddown = _tcstoul(
                                          ArgumentArray[i + ulArgumentIndex],
                                          NULL, 10);
                    break;
                }
                case 3: { // connectretry
                    pGlobalInfo->ulDefConnectRetry = _tcstoul(
                                          ArgumentArray[i + ulArgumentIndex],
                                          NULL, 10);
                    break;
                }
                case 4: { // acceptall
                    TOKEN_VALUE TokenArray[] = {
                        { TOKEN_OPT_VALUE_DISABLE, FALSE },
                        { TOKEN_OPT_VALUE_ENABLE,  TRUE }
                    };
                    pGlobalInfo->dwFlags &= ~MSDP_GLOBAL_FLAG_ACCEPT_ALL;
                    dwErr = MatchEnumTag( g_hModule,
                                          ArgumentArray[i + ulArgumentIndex],
                                          NUM_TOKENS_IN_TABLE(TokenArray),
                                          TokenArray,
                                          &dwAcceptAll );
                    if (dwErr isnot NO_ERROR)
                    {
                        dwErr = ERROR_INVALID_PARAMETER;
                        break;
                    }
                    if (dwAcceptAll is TRUE)
                    {
                        pGlobalInfo->dwFlags |= MSDP_GLOBAL_FLAG_ACCEPT_ALL;
                    }
                    break;
                }
                case 5: { // cachelifetime
                    ulTemp = _tcstoul( ArgumentArray[i + ulArgumentIndex],
                                       NULL, 10);

                    if ((ulTemp>0) and (ulTemp<MSDP_MIN_CACHE_LIFETIME))
                    {
                        DisplayMessage(g_hModule, EMSG_BAD_OPTION_VALUE,
                                       ArgumentArray[i + ulArgumentIndex],
                                       TOKEN_OPT_CACHELIFETIME);
                        dwErr = ERROR_SUPPRESS_OUTPUT;
                        break;
                    }
                    pGlobalInfo->ulCacheLifetime = ulTemp;
                    break;
                }
            }
        }
        
        if (dwErr isnot NO_ERROR)
        {
            break;
        }

        dwErr = SetMsdpGlobalConfig(pGlobalInfo);

    } while (FALSE);

    if (pulTagArray)
    {
        FREE(pulTagArray);
    }
    if (pGlobalInfo) 
    { 
        FREE(pGlobalInfo); 
    }

    if (dwErr is NO_ERROR)
    {
        dwErr = ERROR_OKAY;
    }
    return dwErr;
}

DWORD
HandleMsdpSetPeer(
    PWCHAR  pwszMachineName,
    PTCHAR* ArgumentArray,
    DWORD   ulArgumentIndex,
    DWORD   ulArgumentCount,
    DWORD   dwCmdFlags,
    PVOID   pvData,
    BOOL*   CommandDone
    )
{
    IPV4_ADDRESS           ipLocalAddress, ipRemoteAddress;
    ULONG                  ulKeepAlive=0, ulSAPeriod=0, ulConnectRetry=0;
    DWORD                  dwEncapsMethod=0;
    DWORD                  dwErr = NO_ERROR;
    DWORD                  dwFlags = 0, dwFlagsMask = 0;
    ULONG                  ulArgumentsLeft;
    ULONG                  i;
    PMSDP_IPV4_PEER_CONFIG pPeer = NULL;
    PULONG                 pulTagArray;
    WCHAR                  wszInterfaceName[MAX_INTERFACE_NAME_LEN + 1];
    DWORD                  dwBufferSize = sizeof(wszInterfaceName);
    TAG_TYPE TagTypeArray[] = { { TOKEN_OPT_NAME,         NS_REQ_PRESENT,  FALSE },
                                { TOKEN_OPT_REMADDR,      NS_REQ_ZERO, FALSE },
                                { TOKEN_OPT_LOCALADDR,    NS_REQ_ZERO, FALSE },
                                { TOKEN_OPT_KEEPALIVE,    NS_REQ_ZERO, FALSE },
                                { TOKEN_OPT_CONNECTRETRY, NS_REQ_ZERO, FALSE },
                                { TOKEN_OPT_CACHING,      NS_REQ_ZERO, FALSE },
                                { TOKEN_OPT_DEFAULTPEER,  NS_REQ_ZERO, FALSE },
                                { TOKEN_OPT_ENCAPSMETHOD, NS_REQ_ZERO, FALSE },
                              };

    VERIFY_INSTALLED(MS_IP_MSDP, L"MSDP");

    if (ulArgumentIndex >= ulArgumentCount) { 
        return ERROR_SHOW_USAGE; 
    }
    ulArgumentsLeft = ulArgumentCount - ulArgumentIndex;

    //
    // We convert the optional tags into an array of 'TagTypeArray' indices
    // which guide is in our scanning of the argument list.
    // Since the tags are optional, this process may result in no tags at all,
    // in which case we assume that arguments are specified in exactly the order
    // given in 'TagTypeArray' above.
    //

    dwErr = QueryTagArray( &ArgumentArray[ulArgumentIndex],
                           ulArgumentsLeft,
                           TagTypeArray,
                           NUM_TAGS_IN_TABLE(TagTypeArray),
                           &pulTagArray );
    if (dwErr) { return dwErr; }

    do {
        for (i = 0; i < ulArgumentsLeft; i++) {
            switch(pulTagArray ? pulTagArray[i] : i) {
                case 0: { // name
                    IpmontrGetIfNameFromFriendlyName( 
                                             ArgumentArray[i + ulArgumentIndex],
                                             wszInterfaceName,
                                             &dwBufferSize);
                    break;
                }
                case 1: { // remaddr
                    ipRemoteAddress = GetIpAddress(
                                          ArgumentArray[i + ulArgumentIndex]);
                    break;
                }
                case 2: { // localaddr
                    ipLocalAddress = GetIpAddress(
                                          ArgumentArray[i + ulArgumentIndex]);
                    break;
                }
                case 3: { // keepalive
                    dwFlagsMask |= MSDP_PEER_CONFIG_KEEPALIVE;
                    if (!MatchToken(ArgumentArray[i+ulArgumentIndex],
                                    TOKEN_OPT_VALUE_DEFAULT))
                    {
                        ulKeepAlive = _tcstoul(
                                          ArgumentArray[i + ulArgumentIndex],
                                          NULL, 10);
                        dwFlags     |= MSDP_PEER_CONFIG_KEEPALIVE;
                    }
                    break;
                }
                case 4: { // connectretry
                    dwFlagsMask |= MSDP_PEER_CONFIG_CONNECTRETRY;
                    if (!MatchToken(ArgumentArray[i+ulArgumentIndex],
                                    TOKEN_OPT_VALUE_DEFAULT))
                    {
                        ulConnectRetry = _tcstoul(
                                          ArgumentArray[i + ulArgumentIndex],
                                          NULL, 10);
                        dwFlags     |= MSDP_PEER_CONFIG_CONNECTRETRY;
                    }
                    break;
                }
                case 5: { // caching
                    DWORD dwValue;
                    TOKEN_VALUE TokenArray[] = {
                        { TOKEN_OPT_VALUE_NO,  FALSE },
                        { TOKEN_OPT_VALUE_YES, TRUE }
                    };
                    dwFlagsMask |= MSDP_PEER_CONFIG_CONNECTRETRY;
                    dwErr = MatchEnumTag( g_hModule,
                                          ArgumentArray[i + ulArgumentIndex],
                                          NUM_TOKENS_IN_TABLE(TokenArray),
                                          TokenArray,
                                          &dwValue );
                    if (dwErr isnot NO_ERROR)
                    {
                        dwErr = ERROR_INVALID_PARAMETER;
                        break;
                    }
                    if (dwValue is TRUE)
                    {
                        dwFlags |= MSDP_PEER_CONFIG_CACHING;
                    }
                    break;
                }
                case 6: { // defaultpeer
                    DWORD dwValue;
                    TOKEN_VALUE TokenArray[] = {
                        { TOKEN_OPT_VALUE_NO,  FALSE },
                        { TOKEN_OPT_VALUE_YES, TRUE }
                    };
                    dwFlagsMask |= MSDP_PEER_CONFIG_DEFAULTPEER;
                    dwErr = MatchEnumTag( g_hModule,
                                          ArgumentArray[i + ulArgumentIndex],
                                          NUM_TOKENS_IN_TABLE(TokenArray),
                                          TokenArray,
                                          &dwValue );
                    if (dwErr isnot NO_ERROR)
                    {
                        dwErr = ERROR_INVALID_PARAMETER;
                        break;
                    }
                    if (dwValue is TRUE)
                    {
                        dwFlags |= MSDP_PEER_CONFIG_DEFAULTPEER;
                    }
                    break;
                }
                case 7: { // encapsulation
                    DWORD dwValue;
                    TOKEN_VALUE TokenArray[] = {
                        { TOKEN_OPT_VALUE_NONE, MSDP_ENCAPS_NONE },
                    };
                    dwErr = MatchEnumTag( g_hModule,
                                          ArgumentArray[i + ulArgumentIndex],
                                          NUM_TOKENS_IN_TABLE(TokenArray),
                                          TokenArray,
                                          &dwValue );
                    if (dwErr isnot NO_ERROR)
                    {
                        dwErr = ERROR_INVALID_PARAMETER;
                        break;
                    }
                    dwEncapsMethod = dwValue;
                    break;
                }
            }
        }

        if (dwErr isnot NO_ERROR)
        {
            break;
        }
        
        // Locate peer
        dwErr = GetMsdpInterfaceConfig(wszInterfaceName, &pPeer);
        if (dwErr isnot NO_ERROR)
        {
            break;
        }

        // Update fields
        if (TagTypeArray[1].bPresent)
        {
            pPeer->ipRemoteAddress = ipRemoteAddress;
        }
        if (TagTypeArray[2].bPresent)
        {
            pPeer->ipLocalAddress = ipLocalAddress;
        }
        if (TagTypeArray[3].bPresent)
        {
            pPeer->ulKeepAlive = ulKeepAlive;
        }
        if (TagTypeArray[4].bPresent)
        {
            pPeer->ulConnectRetry = ulConnectRetry;
        }
        if (TagTypeArray[5].bPresent)
        {
            pPeer->dwEncapsMethod = dwEncapsMethod;
        }
        pPeer->dwConfigFlags = (pPeer->dwConfigFlags & ~dwFlagsMask) | dwFlags;

        // higher IP is passive.  Setting bit has no effect except on
        // the "show peer" output when the router isn't running.
        if (ntohl(pPeer->ipLocalAddress) > ntohl(pPeer->ipRemoteAddress))
        {
            pPeer->dwConfigFlags |= MSDP_PEER_CONFIG_PASSIVE;
        }
        else
        {
            pPeer->dwConfigFlags &= ~MSDP_PEER_CONFIG_PASSIVE;
        }
    
        // Update the configuration with the new settings.
        dwErr = SetMsdpInterfaceConfig(wszInterfaceName, pPeer);
    } while (FALSE);

    if (pPeer)
    {
        FREE(pPeer);
    }

    if (pulTagArray)
    {
        FREE(pulTagArray);
    }

    if (dwErr is NO_ERROR)
    {
        dwErr = ERROR_OKAY;
    }

    return dwErr;
}

DWORD
HandleMsdpShowGlobal(
    PWCHAR  pwszMachineName,
    PTCHAR* ArgumentArray,
    DWORD   ulArgumentIndex,
    DWORD   ulArgumentCount,
    DWORD   dwFlags,
    PVOID   pvData,
    BOOL*   CommandDone
    )
{
    VERIFY_INSTALLED(MS_IP_MSDP, L"MSDP");

    if (ulArgumentIndex != ulArgumentCount) { 
        return ERROR_SHOW_USAGE; 
    }

    ShowMsdpGlobalInfo(FORMAT_VERBOSE);

    return NO_ERROR;
}

DWORD
HandleMsdpShowPeer(
    PWCHAR  pwszMachineName,
    PTCHAR* ArgumentArray,
    DWORD   ulArgumentIndex,
    DWORD   ulArgumentCount,
    DWORD   dwFlags,
    PVOID   pvData,
    BOOL*   CommandDone
    )
{
    ULONG    ulArgumentsLeft;
    DWORD    dwErr = NO_ERROR;
    PULONG   pulTagArray = NULL;
    TAG_TYPE TagTypeArray[] = { { TOKEN_OPT_REMADDR, NS_REQ_ZERO, FALSE },
                                { TOKEN_OPT_NAME,    NS_REQ_ZERO, FALSE },
                              };

    VERIFY_INSTALLED(MS_IP_MSDP, L"MSDP");

    if (ulArgumentIndex is ulArgumentCount)
    {
        return ShowMsdpPeerInfo(FORMAT_TABLE, NULL, NULL);
    }

    if (ulArgumentIndex > ulArgumentCount) {
        return ERROR_SHOW_USAGE;
    }
    ulArgumentsLeft = ulArgumentCount - ulArgumentIndex;

    //
    // We convert the optional tags into an array of 'TagTypeArray' indices
    // which guide is in our scanning of the argument list.
    // Since the tags are optional, this process may result in no tags 
    // at all, in which case we assume that arguments are specified in 
    // exactly the order given in 'TagTypeArray' above.
    //

    dwErr = QueryTagArray( &ArgumentArray[ulArgumentIndex],
                           ulArgumentsLeft,
                           TagTypeArray,
                           NUM_TAGS_IN_TABLE(TagTypeArray),
                           &pulTagArray );
    if (dwErr) { return dwErr; }

    if (!pulTagArray) {
        dwErr = ShowMsdpPeerInfo(FORMAT_VERBOSE,NULL,NULL);
    } else if (pulTagArray[0] is 0) { // address
        dwErr = ShowMsdpPeerInfo(FORMAT_VERBOSE,
                                 ArgumentArray[ulArgumentIndex],
                                 NULL);
    } else if (pulTagArray[0] is 1) { // name
        dwErr = ShowMsdpPeerInfo(FORMAT_VERBOSE,
                                 NULL,
                                 ArgumentArray[ulArgumentIndex]);
    } else {
        dwErr = ERROR_SHOW_USAGE;
    }

    if (pulTagArray) { FREE(pulTagArray); }
    return dwErr;                
}

DWORD
HandleMsdpUninstall(
    PWCHAR  pwszMachineName,
    PTCHAR* ArgumentArray,
    DWORD   ulArgumentIndex,
    DWORD   ulArgumentCount,
    DWORD   dwFlags,
    PVOID   pvData,
    BOOL*   CommandDone
    )
{
    DWORD               dwErr, dwTotal;
    ULONG               ulNumInterfaces, i;
    PMPR_INTERFACE_0    pmi0 = NULL;

    if (ulArgumentIndex isnot ulArgumentCount) 
    { 
        return ERROR_SHOW_USAGE; 
    }

    // First delete all peers.  We need to do this ourselves since 
    // IpmontrDeleteProtocol won't delete the peer interfaces.

    dwErr = IpmontrInterfaceEnum((PBYTE *) &pmi0,
                                 &ulNumInterfaces,
                                 &dwTotal);
    if (dwErr isnot NO_ERROR)
    {
        return dwErr;
    }

    for (i=0; i<ulNumInterfaces; i++)
    {
        dwErr = IpmontrDeleteInterface( pwszMachineName, 
                                        pmi0[i].wszInterfaceName );
    }

    if (pmi0)
    {
        FREE(pmi0);
    }

    dwErr = IpmontrDeleteProtocol(MS_IP_MSDP);
    if (dwErr is NO_ERROR)
    {
        dwErr = ERROR_OKAY;
    }
    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ip\preview\msdpcfg.c ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    routing\netsh\ip\protocols\msdpcfg.c

Abstract:

    Multicast Source Discovery Protocol configuration implementation.
    This module contains configuration routines which are relied upon
    by msdpopt.c. The routines retrieve, update, and display
    the configuration for the MSDP protocol.

    This file also contains default configuration settings
    for MSDP.

    N.B. The display routines require special attention since display
    may result in a list of commands sent to a 'dump' file, or in a
    textual presentation of the configuration to a console window.
    In the latter case, we use non-localizable output routines to generate
    a script-like description of the configuration. In the former case,
    we use localizable routines to generate a human-readable description.

Author:

    Dave Thaler (dthaler)  21-May-1999

Revision History:

--*/


#include "precomp.h"
#pragma hdrstop

#ifndef HAVE_INTSOCK
# include <nhapi.h>
# include <rpc.h>
#endif

#define MSDP_DEFAULT_KEEPALIVE       30  // suggested value in RFC 1771
#define MSDP_DEFAULT_SAHOLDDOWN      30  // should be 30 per MSDP spec
#define MSDP_DEFAULT_CONNECTRETRY   120  // suggested value in RFC 1771
#define MSDP_DEFAULT_CACHE_LIFETIME 120  // should be >=90 seconds per MSDP spec
#define MSDP_DEFAULT_ENCAPSULATION  MSDP_ENCAPS_NONE // XXX

#define MALLOC(x)    HeapAlloc(GetProcessHeap(), 0, (x))
#define REALLOC(x,y) HeapReAlloc(GetProcessHeap(), 0, (x), (y))
#define FREE(x)      HeapFree(GetProcessHeap(), 0, (x))

static  MSDP_GLOBAL_CONFIG g_MsdpGlobalDefault =
{
    MSDP_LOGGING_ERROR,
    0, // flags
    MSDP_DEFAULT_KEEPALIVE,
    MSDP_DEFAULT_CONNECTRETRY,
    MSDP_DEFAULT_CACHE_LIFETIME,
    MSDP_DEFAULT_SAHOLDDOWN
};

typedef enum {
    CommonLoggingIndex = 0,
    CommonBooleanIndex,
    MsdpEncapsIndex
} DISPLAY_VALUE_INDEX;

VALUE_STRING MsdpEncapsStringArray[] = {
    MSDP_ENCAPS_NONE,  STRING_NONE,
};

VALUE_TOKEN MsdpEncapsTokenArray[] = {
    MSDP_ENCAPS_NONE,  TOKEN_OPT_VALUE_NONE,
};

static PUCHAR g_pMsdpGlobalDefault = (PUCHAR)&g_MsdpGlobalDefault;

static MSDP_IPV4_PEER_CONFIG g_MsdpPeerDefault = 
{ 
    0, 0, 0, 0, 0, MSDP_ENCAPS_DEFAULT
};

//
// Forward declarations
//
ULONG
ValidateMsdpPeerInfo(
    PMSDP_IPV4_PEER_CONFIG PeerInfo
    );

//
// What follows are the arrays used to map values to strings and
// to map values to tokens. These, respectively, are used in the case
// where we are displaying to a 'dump' file and to a console window.
//
VALUE_STRING MsdpGlobalLoggingStringArray[] = {
    MSDP_LOGGING_NONE,  STRING_LOGGING_NONE,
    MSDP_LOGGING_ERROR, STRING_LOGGING_ERROR,
    MSDP_LOGGING_WARN,  STRING_LOGGING_WARN,
    MSDP_LOGGING_INFO,  STRING_LOGGING_INFO
};

VALUE_TOKEN MsdpGlobalLoggingTokenArray[] = {
    MSDP_LOGGING_NONE,  TOKEN_OPT_VALUE_NONE,
    MSDP_LOGGING_ERROR, TOKEN_OPT_VALUE_ERROR,
    MSDP_LOGGING_WARN,  TOKEN_OPT_VALUE_WARN,
    MSDP_LOGGING_INFO,  TOKEN_OPT_VALUE_INFO
};

//
// Allocate a global info block containing the default information
//
// Called by: HandleMsdpInstall()
//
ULONG
MakeMsdpGlobalConfig(
    OUT PUCHAR* ppGlobalInfo,
    OUT PULONG  pulGlobalInfoSize
    )
{
    *pulGlobalInfoSize = sizeof(MSDP_GLOBAL_CONFIG);
    *ppGlobalInfo = MALLOC(*pulGlobalInfoSize);
    if (!*ppGlobalInfo) {
        DisplayMessage(g_hModule, EMSG_NOT_ENOUGH_MEMORY);
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    CopyMemory(*ppGlobalInfo, g_pMsdpGlobalDefault, sizeof(MSDP_GLOBAL_CONFIG));
    return NO_ERROR;
}

#if 0
//
// Update global parameters
//
// Called by: HandleMsdpSetGlobal()
//
ULONG
CreateMsdpGlobalInfo(
    OUT PMSDP_GLOBAL_CONFIG* pGlobalInfo,
    IN  DWORD                dwLoggingLevel
    )
{
    DWORD dwGlobalInfoSize;
    dwGlobalInfoSize = sizeof(PMSDP_GLOBAL_CONFIG);
    *pGlobalInfo = MALLOC(dwGlobalInfoSize);
    if (!*pGlobalInfo) {
        DisplayMessage(g_hModule, EMSG_NOT_ENOUGH_MEMORY);
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    CopyMemory(*pGlobalInfo, g_pMsdpGlobalDefault, dwGlobalInfoSize);
    (*pGlobalInfo)->dwLoggingLevel = dwLoggingLevel;

    return NO_ERROR;
}
#endif

//
// Called by: MsdpHandleAddPeer()
//
ULONG
MakeMsdpIPv4PeerConfig(
    OUT PMSDP_IPV4_PEER_CONFIG *ppPeer
    )
{
    ULONG ulSize = sizeof(MSDP_IPV4_PEER_CONFIG);

    *ppPeer = MALLOC(ulSize);
    if (!*ppPeer) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    CopyMemory(*ppPeer, &g_MsdpPeerDefault, ulSize);
    return NO_ERROR;
}

DWORD
MsdpAddIPv4PeerInterface(
    IN  LPCWSTR                pwszMachineName,
    IN  LPCWSTR                pwszInterfaceName,
    IN  PMSDP_IPV4_PEER_CONFIG pPeer
    )
{
    return NO_ERROR;
// support of ipinip taken out. if you want to support msdp, then you need ipinip
#if 0
    DWORD               dwErr = NO_ERROR;
    
    do {
        dwErr = IpmontrCreateInterface(pwszMachineName, pwszInterfaceName,
                                       pPeer->ipLocalAddress,
                                       pPeer->ipRemoteAddress,
                                       1);
        if (dwErr isnot NO_ERROR)
        {
            break;
        }

        dwErr = SetMsdpInterfaceConfig( pwszInterfaceName, pPeer );
    } while (FALSE);

    return dwErr;
#endif
}

#if 0
DWORD
MsdpAddIPv4PeerConfig(
    IN  PMSDP_IPV4_PEER_CONFIG pPeer
    )
{
    PMSDP_GLOBAL_CONFIG pGlobal = NULL, pNewGlobal;
    DWORD               dwErr;
    ULONG               ulV4PeerCount, ulSize, i;
    PMSDP_FAMILY_CONFIG pFamily;
    
    do {
        dwErr = GetMsdpGlobalConfig( &pGlobal );
        if (dwErr isnot NO_ERROR)
        {
            break;
        }

        pFamily = MSDP_FIRST_FAMILY(pGlobal);

        // Check for duplicate
        for (i=0; (i<pFamily->usNumPeers) and 
        (pFamily->pPeer[i].ipRemoteAddress isnot pPeer->ipRemoteAddress); i++);
        if (i<pFamily->usNumPeers)
        {
            dwErr = ERROR_OBJECT_ALREADY_EXISTS;
            break;
        }

        ulV4PeerCount = pFamily->usNumPeers++;
        ulSize = MSDP_GLOBAL_CONFIG_SIZE(ulV4PeerCount+1);
        pNewGlobal = REALLOC( pGlobal, ulSize );
        if (!pNewGlobal)
        {
            dwErr = GetLastError();
            break;
        }
        pGlobal = pNewGlobal;
        pFamily = MSDP_FIRST_FAMILY(pGlobal);

        memcpy( &pFamily->pPeer[ulV4PeerCount], 
                pPeer, 
                sizeof(MSDP_IPV4_PEER_CONFIG) );

        // DisplayMessageT(L"remoteaddr=%1!x!\n", 
        // pFamily->pPeer[ulV4PeerCount].ipRemoteAddress);

        dwErr = SetMsdpGlobalConfig( pGlobal );
    } while (FALSE);

    if (pGlobal)
    {
        FREE(pGlobal);
    }

    return dwErr;
}
#endif

#if 0
// 
// Called by: XXX
//
ULONG
MakeMsdpFamilyInfo(
    IN OUT PUCHAR pFamily
    )
{
    //
    // Always assume that the space has been preassigned
    //
    if (!pFamily) {
        return ERROR_INVALID_PARAMETER;
    }
    CopyMemory(pFamily,&g_MsdpFamilyDefault,sizeof(g_MsdpFamilyDefault));
    return NO_ERROR;    
}
#endif

PTCHAR
MsdpQueryValueString(
    DWORD               dwFormat,
    DISPLAY_VALUE_INDEX Index,
    ULONG               Value
    )
{
    ULONG         Count;
    DWORD         dwErr;
    PTCHAR        String = NULL;
    PVALUE_STRING StringArray;
    PVALUE_TOKEN  TokenArray;
    switch (Index) {
        case CommonLoggingIndex:
            Count = COMMON_LOGGING_SIZE;
            StringArray = CommonLoggingStringArray;
            TokenArray = CommonLoggingTokenArray;
            break;
        case CommonBooleanIndex:
            Count = COMMON_BOOLEAN_SIZE;
            StringArray = CommonBooleanStringArray;
            TokenArray = CommonBooleanTokenArray;
            break;
        case MsdpEncapsIndex:
            Count = MSDP_ENCAPS_SIZE;
            StringArray = MsdpEncapsStringArray;
            TokenArray = MsdpEncapsTokenArray;
            break;
        default:
            return NULL;
    }
    dwErr = GetAltDisplayString( g_hModule,
                                 (HANDLE)(dwFormat is FORMAT_DUMP),
                                 Value,
                                 TokenArray,
                                 StringArray,
                                 Count,
                                 &String );
    return (dwErr)? NULL : String;
}

DWORD
GetMsdpInterfaceConfig(
    IN  LPCWSTR                 pwszInterfaceName,
    OUT PMSDP_IPV4_PEER_CONFIG *ppConfigInfo
    )
{
    DWORD dwErr, dwIfType;
    ULONG ulSize, ulCount;

    //
    // Retrieve the interface configuration for MSDP
    //
    dwErr = IpmontrGetInfoBlockFromInterfaceInfo( pwszInterfaceName,
                                                  MS_IP_MSDP,
                                                  (PUCHAR*)ppConfigInfo,
                                                  &ulSize,
                                                  &ulCount,
                                                  &dwIfType );
    if (dwErr isnot NO_ERROR) {
        return dwErr;
    } else if (!(ulCount * ulSize)) {
        return ERROR_NOT_FOUND; 
    }

    return NO_ERROR;
}

DWORD
GetMsdpGlobalConfig(
    PMSDP_GLOBAL_CONFIG *ppGlobalInfo
    )
{
    DWORD dwErr;
    ULONG ulSize, ulCount;

    //
    // Retrieve the global configuration for MSDP,
    //
    dwErr = IpmontrGetInfoBlockFromGlobalInfo( MS_IP_MSDP,
                                        (PUCHAR*)ppGlobalInfo,
                                        &ulSize,
                                        &ulCount );
    if (dwErr isnot NO_ERROR) {
        return dwErr;
    } else if (!(ulCount * ulSize)) {
        return ERROR_NOT_FOUND; 
    }

    return NO_ERROR;
}

DWORD
SetMsdpInterfaceConfig(
    PWCHAR                 pwszInterfaceName,
    PMSDP_IPV4_PEER_CONFIG pConfigInfo
    )
{
    DWORD dwErr;
    ULONG ulSize, ulV4PeerCount;
    WCHAR wszIfName[MAX_INTERFACE_NAME_LEN+1];
    
    ulSize = sizeof(wszIfName);
    dwErr = IpmontrGetIfNameFromFriendlyName(pwszInterfaceName,
                                             wszIfName,
                                             &ulSize);
    if (dwErr isnot NO_ERROR)
    {
        return dwErr;
    }

    //
    // Save the interface configuration for MSDP
    //
    ulSize = sizeof(MSDP_IPV4_PEER_CONFIG);
    dwErr = IpmontrSetInfoBlockInInterfaceInfo( wszIfName,
                                                MS_IP_MSDP,
                                                (PUCHAR)pConfigInfo,
                                                ulSize,
                                                1 );
    return dwErr;
}

DWORD
SetMsdpGlobalConfig(
    PMSDP_GLOBAL_CONFIG pGlobalInfo
    )
{
    DWORD dwErr;
    ULONG ulSize;

    //
    // Save the global configuration for MSDP,
    //
    ulSize = sizeof(MSDP_GLOBAL_CONFIG);
    dwErr = IpmontrSetInfoBlockInGlobalInfo( MS_IP_MSDP,
                                      (PUCHAR)pGlobalInfo,
                                      ulSize,
                                      1 );
    return dwErr;
}

ULONG
ShowMsdpGlobalInfo(
    DWORD dwFormat
    )
{
    ULONG               ulCount = 0;
    DWORD               dwErr;
    PMSDP_GLOBAL_CONFIG pGlobalInfo = NULL;
    ULONG               i;
    PWCHAR              pwszLoggingLevel = NULL,
                        pwszAcceptAll = NULL;
    ULONG               ulSize;

    do {
        dwErr = GetMsdpGlobalConfig(&pGlobalInfo);
        if (dwErr) {
            break;
        }

        pwszLoggingLevel = MsdpQueryValueString( dwFormat, 
                                                 CommonLoggingIndex,
                                                 pGlobalInfo->dwLoggingLevel );

        pwszAcceptAll    = MsdpQueryValueString( dwFormat, 
                                                 CommonBooleanIndex,
                        (pGlobalInfo->dwFlags & MSDP_GLOBAL_FLAG_ACCEPT_ALL) );

        if (dwFormat is FORMAT_DUMP) 
        {
            DisplayMessageT( DMP_INSTALL );
            DisplayMessageT( DMP_MSDP_SET_GLOBAL );

            if (pwszLoggingLevel) {
                DisplayMessageT( DMP_MSDP_STRING_ARGUMENT,
                                 TOKEN_OPT_LOGGINGLEVEL, pwszLoggingLevel );
            }

            DisplayMessageT( DMP_MSDP_INTEGER_ARGUMENT,
                             TOKEN_OPT_KEEPALIVE, pGlobalInfo->ulDefKeepAlive);
            DisplayMessageT( DMP_MSDP_INTEGER_ARGUMENT,
                             TOKEN_OPT_SAHOLDDOWN,pGlobalInfo->ulSAHolddown);
            DisplayMessageT( DMP_MSDP_INTEGER_ARGUMENT,
                             TOKEN_OPT_CONNECTRETRY, 
                             pGlobalInfo->ulDefConnectRetry);
            DisplayMessageT( DMP_MSDP_STRING_ARGUMENT,
                             TOKEN_OPT_ACCEPTALL, 
                             pwszAcceptAll);
            DisplayMessageT( DMP_MSDP_INTEGER_ARGUMENT,
                             TOKEN_OPT_CACHELIFETIME,
                             pGlobalInfo->ulCacheLifetime);
            DisplayMessageT( MSG_NEWLINE );
        } 
        else 
        {
            DisplayMessage( g_hModule,
                            MSG_MSDP_GLOBAL_INFO,
                            pwszLoggingLevel,
                            pGlobalInfo->ulDefKeepAlive,     
                            pGlobalInfo->ulSAHolddown,     
                            pGlobalInfo->ulDefConnectRetry,
                            pwszAcceptAll,
                            pGlobalInfo->ulCacheLifetime );
        }
    } while(FALSE);
    
    if (pwszLoggingLevel) { FREE(pwszLoggingLevel); }
    if (pGlobalInfo) { FREE(pGlobalInfo); }
    if ((dwFormat isnot FORMAT_DUMP) and (dwErr isnot NO_ERROR)) 
    {
        if (dwErr == ERROR_NOT_FOUND) {
            DisplayMessage(g_hModule, EMSG_PROTO_NO_GLOBAL_INFO);
        } else {
            DisplayError(g_hModule, dwErr);
        }
    }
    return dwErr;
}

ULONG
MsdpPeerKeepAlive(
    IN PMSDP_GLOBAL_CONFIG    pGlobal, 
    IN PMSDP_IPV4_PEER_CONFIG pPeer
    )
{
    if (pPeer->dwConfigFlags & MSDP_PEER_CONFIG_KEEPALIVE)
    {
        return pPeer->ulKeepAlive;
    }
    return pGlobal->ulDefKeepAlive;
}

ULONG
MsdpPeerConnectRetry(
    IN PMSDP_GLOBAL_CONFIG    pGlobal, 
    IN PMSDP_IPV4_PEER_CONFIG pPeer
    )
{
    if (pPeer->dwConfigFlags & MSDP_PEER_CONFIG_CONNECTRETRY)
    {
        return pPeer->ulConnectRetry;
    }
    return pGlobal->ulDefConnectRetry;
}

PWCHAR
MsdpPeerFlags(
    IN PMSDP_IPV4_PEER_CONFIG pPeer
    )
{
    static WCHAR wszString[33];

    wszString[0] = (pPeer->dwConfigFlags & MSDP_PEER_CONFIG_CONNECTRETRY)? L'R' : L' ';
    wszString[1] = (pPeer->dwConfigFlags & MSDP_PEER_CONFIG_KEEPALIVE)   ? L'K' : L' ';
    wszString[2] = (pPeer->dwConfigFlags & MSDP_PEER_CONFIG_CACHING)     ? L'C' : L' ';
    wszString[3] = (pPeer->dwConfigFlags & MSDP_PEER_CONFIG_DEFAULTPEER) ? L'D' : L' ';
    wszString[4] = (pPeer->dwConfigFlags & MSDP_PEER_CONFIG_PASSIVE)     ? L'P' : L' ';
    wszString[5] = 0;

    return wszString;
}

//
// Called by: HandleMsdpShowPeer()
//
DWORD
ShowMsdpPeerInfo(
    IN DWORD  dwFormat,
    IN LPCWSTR pwszPeerAddress OPTIONAL,
    IN LPCWSTR pwszPeerName    OPTIONAL
    )
{
    DWORD                  dwErr, dwTotal;
    PMSDP_IPV4_PEER_CONFIG pPeer;
    ULONG                  i, ulNumInterfaces, ulCount = 0;
    WCHAR                  wszRemoteAddress[20];
    WCHAR                  wszLocalAddress[20];
    PWCHAR                 pwszEncapsMethod;
    PMPR_INTERFACE_0       pmi0 = NULL;
    PMSDP_GLOBAL_CONFIG    pGlobalInfo = NULL;
    WCHAR                  wszFriendlyName[MAX_INTERFACE_NAME_LEN+1];
    DWORD                  dwSize = sizeof(wszFriendlyName);

    dwErr = GetMsdpGlobalConfig(&pGlobalInfo);
    if (dwErr isnot NO_ERROR) 
    {
        return dwErr;
    }

    do {
        //
        // Retrieve the peer's configuration
        // and format it to the output file or console.
        //
        dwErr = IpmontrInterfaceEnum((PBYTE *) &pmi0, 
                                     &ulNumInterfaces,
                                     &dwTotal);
        if (dwErr isnot NO_ERROR)
        {
            return dwErr;
        }

        for (i=0; i<ulNumInterfaces; i++)
        {
            dwErr = IpmontrGetFriendlyNameFromIfName(pmi0[i].wszInterfaceName,
                        wszFriendlyName, &dwSize);

            if (pwszPeerName
             and wcscmp(pwszPeerName, wszFriendlyName)) 
            {
                continue;
            }

            dwErr = GetMsdpInterfaceConfig(pmi0[i].wszInterfaceName, &pPeer);
            if (dwErr isnot NO_ERROR)
            {
                continue;
            }

            IP_TO_TSTR(wszRemoteAddress, &pPeer->ipRemoteAddress);

            if (pwszPeerAddress
             and wcscmp(pwszPeerAddress, wszRemoteAddress)) 
            {
                FREE(pPeer);
                continue;
            }

            if ((ulCount is 0) and (dwFormat is FORMAT_TABLE))
            {
                DisplayMessage( g_hModule, MSG_MSDP_PEER_HEADER );
            }

            IP_TO_TSTR(wszLocalAddress,  &pPeer->ipLocalAddress);

            pwszEncapsMethod = MsdpQueryValueString( dwFormat, 
                                                     MsdpEncapsIndex,
                                                     pPeer->dwEncapsMethod );

            if (dwFormat is FORMAT_DUMP) {
                DisplayMessageT(DMP_MSDP_ADD_PEER);
                DisplayMessageT(DMP_MSDP_STRING_ARGUMENT,
                                TOKEN_OPT_NAME, wszFriendlyName);
                DisplayMessageT(DMP_MSDP_STRING_ARGUMENT,
                                TOKEN_OPT_REMADDR,   wszRemoteAddress);
                if (pPeer->ipLocalAddress)
                {
                    DisplayMessageT(DMP_MSDP_STRING_ARGUMENT,
                                    TOKEN_OPT_LOCALADDR, wszLocalAddress);
                }
                if (pPeer->dwConfigFlags & MSDP_PEER_CONFIG_KEEPALIVE)
                {
                    DisplayMessageT(DMP_MSDP_INTEGER_ARGUMENT,
                                    TOKEN_OPT_KEEPALIVE, pPeer->ulKeepAlive);
                }
                if (pPeer->dwConfigFlags & MSDP_PEER_CONFIG_CONNECTRETRY)
                {
                    DisplayMessageT(DMP_MSDP_INTEGER_ARGUMENT,
                                    TOKEN_OPT_CONNECTRETRY, 
                                    pPeer->ulConnectRetry);
                }
                if (pPeer->dwConfigFlags & MSDP_PEER_CONFIG_CACHING)
                {
                    DisplayMessageT(DMP_MSDP_STRING_ARGUMENT,
                                    TOKEN_OPT_CACHING, 
                                    TOKEN_OPT_VALUE_YES);
                }
                if (pPeer->dwConfigFlags & MSDP_PEER_CONFIG_DEFAULTPEER)
                {
                    DisplayMessageT(DMP_MSDP_STRING_ARGUMENT,
                                    TOKEN_OPT_DEFAULTPEER, 
                                    TOKEN_OPT_VALUE_YES);
                }
                if (pPeer->dwEncapsMethod isnot MSDP_DEFAULT_ENCAPSULATION)
                {
                    DisplayMessageT(DMP_MSDP_STRING_ARGUMENT,
                                    TOKEN_OPT_ENCAPSMETHOD,
                                    pwszEncapsMethod);
                }
                DisplayMessageT(MSG_NEWLINE);
            } else {
                DWORD dwId = (dwFormat is FORMAT_TABLE)? MSG_MSDP_PEER_INFO :
                                                         MSG_MSDP_PEER_INFO_EX;
                DisplayMessage( g_hModule, 
                                dwId,
                                wszRemoteAddress,
                                wszLocalAddress,
                                MsdpPeerKeepAlive(pGlobalInfo, pPeer),
                                MsdpPeerConnectRetry(pGlobalInfo, pPeer),
                                MsdpPeerFlags(pPeer),
                                pwszEncapsMethod,
                                wszFriendlyName);
            }
            FREE(pPeer);

            ulCount++;
        }
    } while(FALSE);

    FREE(pGlobalInfo);

    if ((dwFormat isnot FORMAT_DUMP) && dwErr) {
        if (dwErr == ERROR_NOT_FOUND) {
            DisplayMessage(g_hModule, EMSG_PROTO_NO_IF_INFO);
        } else {
            DisplayError(g_hModule, dwErr);
        }
    }
    if (pmi0)
    {
        FREE(pmi0);
    }
    if ((dwFormat is FORMAT_TABLE) and (ulCount is 0) and (dwErr is NO_ERROR))
    {
        DisplayMessage(g_hModule, MSG_MSDP_NO_PEER_INFO);
    }
    return dwErr;
}

#if 0
ULONG
UpdateMsdpGlobalInfo(
    PMSDP_GLOBAL_CONFIG GlobalInfo    
    )
{
    ULONG Count;
    ULONG Error;
    PMSDP_GLOBAL_CONFIG NewGlobalInfo = NULL;
    PMSDP_GLOBAL_CONFIG OldGlobalInfo = NULL;
    ULONG Size;
    
    do {
        //
        // Retrieve the existing global configuration.
        //
        Error =
            IpmontrGetInfoBlockFromGlobalInfo(
                MS_IP_MSDP,
                (PUCHAR*)&OldGlobalInfo,
                &Size,
                &Count
                );
        if (Error) {
            break;
        } else if (!(Count * Size)) {
            Error = ERROR_NOT_FOUND; break;
        }

        //
        // Allocate a new structure, copy to it the original configuration,
        //

        NewGlobalInfo = MALLOC(Count * Size);
        if (!NewGlobalInfo) { Error = ERROR_NOT_ENOUGH_MEMORY; break; }
        CopyMemory(NewGlobalInfo, OldGlobalInfo, Count * Size);
        
        //
        // Based on the changes requested, change the NewGlobalInfo.
        // Since for MSDP there is only the logging level to change, we just set that.
        //
        
        NewGlobalInfo->dwLoggingLevel = GlobalInfo->dwLoggingLevel;
        
        Error =
            IpmontrSetInfoBlockInGlobalInfo(
                MS_IP_MSDP,
                (PUCHAR)NewGlobalInfo,
                FIELD_OFFSET(IP_NAT_GLOBAL_INFO, Header) +
                Size,
                1
                );
    } while(FALSE);
    if (NewGlobalInfo) { FREE(NewGlobalInfo); }
    if (OldGlobalInfo) { FREE(OldGlobalInfo); }
    if (Error == ERROR_NOT_FOUND) {
        DisplayMessage(g_hModule, EMSG_PROTO_NO_GLOBAL_INFO);
    } else if (Error) {
        DisplayError(g_hModule, Error);
    }
    return Error;
}
#endif

#if 0
ULONG
UpdateMsdpPeerInfo(
    PWCHAR              PeerName,
    PMSDP_FAMILY_CONFIG pFamily,
    ULONG               BitVector,
    BOOL                AddPeer
    )
{
    ULONG Count;
    ULONG Error;
    PMSDP_IPV4_PEER_CONFIG NewPeerInfo = NULL;
    PMSDP_IPV4_PEER_CONFIG OldPeerInfo = NULL;
    ULONG Size;
    ROUTER_INTERFACE_TYPE Type;
    ULONG i;

    if (!AddPeer && !BitVector) { return NO_ERROR; }
    do {
        //
        // Retrieve the existing interface configuration.
        // We will update this block below, as well as adding to or removing
        // from it depending on the flags specified in 'BitVector'.
        //
        Error =
            GetInfoBlockFromPeerInfo(
                PeerName,
                MS_IP_MSDP,
                (PUCHAR*)&OldPeerInfo,
                &Size,
                &Count,
                &Type
                );
        if (Error) {
            //
            // No existing configuration is found. This is an error unless
            // we are adding the interface anew, in which case we just
            // create for ourselves a block containing the default settings.
            //
            if (!AddPeer) {
                break;
            } else {
                Error = GetPeerType(PeerName, &Type);
                if (Error) {
                    break;
                } else {
                    Count = 1;
                    Error =
                        MakeMsdpPeerInfo(
                            Type, (PUCHAR*)&OldPeerInfo, &Size
                            );
                    if (Error) { break; }
                }
            }
        } else {
            //
            // There is configuration on the interface. If it is empty this is
            // an error. If this is an add interface, and the info exists, it is
            // an error.
            //
            if (!(Count * Size) && !AddPeer) {
                Error = ERROR_NOT_FOUND; break;
            }
            else if (AddPeer) {
                //
                // We were asked to add an interface which already exists
                //
                DisplayMessage(g_hModule, EMSG_INTERFACE_EXISTS, PeerName);
                Error = ERROR_INVALID_PARAMETER;
                break;
            }
                    
        }

        if (!BitVector) {
            //
            // Just add this interface without any additional info.
            //
            DWORD OldSize;
            if (NewPeerInfo == NULL){
                NewPeerInfo = MALLOC((OldSize=GetMsdpPeerInfoSize(OldPeerInfo))+
                                          sizeof(MSDP_VROUTER_CONFIG));
                if (!NewPeerInfo) {
                    DisplayMessage(g_hModule, EMSG_NOT_ENOUGH_MEMORY);
                    Error = ERROR_NOT_ENOUGH_MEMORY;
                    break;                        
                }
            }
            CopyMemory(NewPeerInfo,OldPeerInfo,OldSize);
        }
        else{
            if (!AddPeer || (OldPeerInfo->VrouterCount != 0)) {
                //
                // There is a prexisting VRID set. Check for this VRID in the list and then
                // update it if required.
                //
                ASSERT(BitVector & MSDP_INTF_VRID_MASK);
                for (i = 0, PVrouter = MSDP_FIRST_VROUTER_CONFIG(OldPeerInfo);
                     i < OldPeerInfo->VrouterCount; 
                     i++, PVrouter = MSDP_NEXT_VROUTER_CONFIG(PVrouter)) {
                    if (PVrouter->VRID == VRouterInfo->VRID) {
                        break;
                    }
                }
                if (i == OldPeerInfo->VrouterCount) {
                    //
                    // This is a new VRID, Add it.
                    //
                    DWORD OldSize;

                    //
                    // The IP address should be valid or else this is a set op.
                    //
                    if (!(BitVector & MSDP_INTF_IPADDR_MASK)){
                        DisplayMessage(
                            g_hModule, EMSG_INVALID_VRID,
                            VRouterInfo->VRID
                            );
                        Error = ERROR_INVALID_PARAMETER;
                        break;
                    }

                    if (NewPeerInfo == NULL){
                        NewPeerInfo = MALLOC((OldSize=GetMsdpPeerInfoSize(
                                                OldPeerInfo))+
                                                sizeof(MSDP_VROUTER_CONFIG));
                        if (!NewPeerInfo) {
                            DisplayMessage(g_hModule, EMSG_NOT_ENOUGH_MEMORY);
                            Error = ERROR_NOT_ENOUGH_MEMORY;
                            break;                        
                        }
                    }
                    CopyMemory(NewPeerInfo, OldPeerInfo, OldSize);
                    PVrouter = (PMSDP_VROUTER_CONFIG)((PBYTE)NewPeerInfo+OldSize);
                    CopyMemory(PVrouter,VRouterInfo,sizeof(MSDP_VROUTER_CONFIG));
                    NewPeerInfo->VrouterCount++;

                    //
                    // Check if we own the IP address given. If yes, set the priority.
                    //
                    PVrouter->ConfigPriority = 
                        FoundIpAddress(PVrouter->IPAddress[0]) ? 255 : 100;
                } 
                else{
                    //
                    //  This is an old VRID. Its priority should not need to be changed.
                    //
                    DWORD Offset, OldSize;

                    if(BitVector & MSDP_INTF_IPADDR_MASK) {
                        if ( ((PVrouter->ConfigPriority != 255) && 
                              (FoundIpAddress(VRouterInfo->IPAddress[0]))
                             )
                             ||
                             ((PVrouter->ConfigPriority == 255) && 
                              (!FoundIpAddress(VRouterInfo->IPAddress[0])))
                             ) {
                            DisplayMessage(g_hModule, EMSG_BAD_OPTION_VALUE);
                            Error = ERROR_INVALID_PARAMETER;
                            break;                        
                        }
                        //
                        // Add this IP address to the VRID specified.
                        //
                        if (NewPeerInfo == NULL){
                            NewPeerInfo = MALLOC((OldSize = GetMsdpPeerInfoSize(
                                                        OldPeerInfo))+
                                                        sizeof(DWORD));
                            if (!NewPeerInfo) {
                                DisplayMessage(g_hModule, EMSG_NOT_ENOUGH_MEMORY);
                                Error = ERROR_NOT_ENOUGH_MEMORY;
                                break;                        
                            }
                        }
                        //
                        // Shift all the VROUTER configs after the PVrouter by 1 DWORD.
                        //
                        Offset = (PUCHAR) MSDP_NEXT_VROUTER_CONFIG(PVrouter) - 
                                 (PUCHAR) OldPeerInfo;
                        CopyMemory(NewPeerInfo, OldPeerInfo, OldSize);
                        for (i = 0, PVrouter = MSDP_FIRST_VROUTER_CONFIG(NewPeerInfo);
                             i < NewPeerInfo->VrouterCount; 
                             i++, PVrouter = MSDP_NEXT_VROUTER_CONFIG(PVrouter)) {
                            if (PVrouter->VRID == VRouterInfo->VRID) {
                                break;
                            }
                        }
                        ASSERT(i < NewPeerInfo->VrouterCount);
                        PVrouter->IPAddress[PVrouter->IPCount++] = VRouterInfo->IPAddress[0];
    
                        ASSERT(((PUCHAR)NewPeerInfo+Offset+sizeof(DWORD)) == 
                               (PUCHAR) MSDP_NEXT_VROUTER_CONFIG(PVrouter));
    
                        CopyMemory(MSDP_NEXT_VROUTER_CONFIG(PVrouter), 
                                   OldPeerInfo+Offset, OldSize-Offset);
                    } else {
                        //
                        // Set the new info block as the old info block and point to the
                        // vrouter block
                        //
                        if (NewPeerInfo == NULL){
                            NewPeerInfo = MALLOC((OldSize = GetMsdpPeerInfoSize(
                                                        OldPeerInfo)));
                            if (!NewPeerInfo) {
                                DisplayMessage(g_hModule, EMSG_NOT_ENOUGH_MEMORY);
                                Error = ERROR_NOT_ENOUGH_MEMORY;
                                break;                        
                            }
                        }
                        CopyMemory(NewPeerInfo, OldPeerInfo, OldSize);
                        for (i = 0, PVrouter = MSDP_FIRST_VROUTER_CONFIG(NewPeerInfo);
                             i < NewPeerInfo->VrouterCount; 
                             i++, PVrouter = MSDP_NEXT_VROUTER_CONFIG(PVrouter)) {
                            if (PVrouter->VRID == VRouterInfo->VRID) {
                                break;
                            }
                        }
                        ASSERT(i < NewPeerInfo->VrouterCount);
                    }

                    if (BitVector & MSDP_INTF_AUTH_MASK) {
                        PVrouter->AuthenticationType = VRouterInfo->AuthenticationType;
                    }
                    if (BitVector & MSDP_INTF_PASSWD_MASK) {
                        CopyMemory(PVrouter->AuthenticationData, 
                                   VRouterInfo->AuthenticationData, 
                                   MSDP_MAX_AUTHKEY_SIZE);
                    }
                    if (BitVector & MSDP_INTF_ADVT_MASK) {
                        PVrouter->AdvertisementPeer= VRouterInfo->AdvertisementPeer
                    }
                    if (BitVector & MSDP_INTF_PRIO_MASK) {
                        PVrouter->ConfigPriority = VRouterInfo->ConfigPriority;
                    }
                    if (BitVector & MSDP_INTF_PREEMPT_MASK) {
                        PVrouter->PreemptMode = VRouterInfo->PreemptMode;
                    }
                }
            }
        }

        ValidateMsdpPeerInfo(NewPeerInfo);

        Error =
            SetInfoBlockInPeerInfo(
                PeerName,
                MS_IP_MSDP,
                (PUCHAR)NewPeerInfo,
                GetMsdpPeerInfoSize(NewPeerInfo),
                1
                );
    } while(FALSE);
    if (NewPeerInfo) { FREE(NewPeerInfo); }
    if (OldPeerInfo) { FREE(OldPeerInfo); }
    if (Error == ERROR_NOT_FOUND) {
        DisplayMessage(g_hModule, EMSG_PROTO_NO_IF_INFO);
    } else if (Error) {
        DisplayError(g_hModule, Error);
    }
    return Error;
}
#endif

#if 0
DWORD
MsdpDeleteIPv4PeerConfig(
    IPV4_ADDRESS ipAddr
    )
/*++
Called by: HandleMsdpDeletePeer()
--*/
{
    DWORD                  dwErr   = NO_ERROR;
    ULONG                  ulV4PeerCount;

    PMSDP_IPV4_PEER_CONFIG NewPeerInfo = NULL;
    PMSDP_IPV4_PEER_CONFIG OldPeerInfo = NULL;
    ULONG Size;
    ULONG i;

    do {
        dwErr = GetMsdpGlobalConfig(&pGlobal);
        if (dwErr isnot NO_ERROR) {
            break;
        }

        pFamily = MSDP_FIRST_FAMILY(pGlobal);
        for (i=0; (i < pFamily->usNumPeers) 
               && (pFamily->pPeer[i].ipRemoteAddress isnot ipAddr); i++);
        if (i is pFamily->usNumPeers)
        {
            return ERROR_NOT_FOUND;        
        }

        // Shift every after 'i' up one position (overlapping copy)
        i++;
        memcpy( &pFamily->pPeer[i-1], 
                &pFamily->pPeer[i],
                (pFamily->usNumPeers-i) * sizeof(MSDP_IPV4_PEER_CONFIG) );

        pFamily->usNumPeers--;

        dwErr = SetMsdpGlobalConfig( pGlobal );
    } while (FALSE);

    if (pGlobal)
    {
        FREE(pGlobal);
    }

    return dwErr;
}
#endif

ULONG
ValidateMsdpPeerInfo(
    PMSDP_IPV4_PEER_CONFIG PeerInfo
    )
{
    return NO_ERROR;
}

#if 0
DWORD
GetMsdpPeerInfoSize(
    PMSDP_IPV4_PEER_CONFIG PeerInfo
    )
{
    DWORD Size = 0;
    ULONG i;
    PMSDP_VROUTER_CONFIG pvr;

    Size += sizeof(PeerInfo->VrouterCount);

    for (i = 0, pvr = MSDP_FIRST_VROUTER_CONFIG(PeerInfo);
         i < PeerInfo->VrouterCount;
         i++,pvr = MSDP_NEXT_VROUTER_CONFIG(pvr)) {
        Size += MSDP_VROUTER_CONFIG_SIZE(pvr);
    }

    return Size;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ip\preview\precomp.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntddser.h>

#include <windows.h>

#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <memory.h>
#include <malloc.h>
#include <tchar.h>
#include <winsock2.h>

#include <fltdefs.h>
#include <rtutils.h>
#include <mprerror.h>
#include <routprot.h>
#include <ipinfoid.h>
#include <iprtrmib.h>
#include <rtinfo.h>
#include <iprtinfo.h>
#include <priopriv.h>
#include <ipriprm.h>
#include <ipbootp.h>
#include <ospf_cfg.h>
#include <mprapi.h>
#include <ipinfoid.h>
#include <igmprm.h>
#include <ipnat.h>
#include <ipnathlp.h>
#include <snmp.h>

#include <macros.h>
#include <netsh.h>
#include <ipmontr.h>
#include <vrrprm.h>
#include <iphlpapi.h>

#include "ipprodefs.h"
#include "common.h"
#include "utils.h"
#include "strdefs.h"
#include "prstring.h"
#include "vrrphlp.h"
#include "vrrphlpcfg.h"
#include "vrrphlpopt.h"

#include "msdprm.h"
#include "msdp.h"
#include "msdpopt.h"
#include "msdpcfg.h"
#include "msdpmib.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ip\preview\msdpmib.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:
     net\routing\netsh\ip\protocols\msdpmib.c    

Abstract:

     Functions to get and display MSDP MIB information.

Author:

     Dave Thaler   11/03/99

Revision History:


--*/

#include "precomp.h"
#pragma hdrstop

#define FREE(x)   HeapFree(GetProcessHeap(), 0, (x))

ULONG
QueryTagArray(
    PTCHAR ArgumentArray[],
    ULONG ArgumentCount,
    TAG_TYPE TagTypeArray[],
    ULONG TagTypeCount,
    OUT PULONG* TagArray
    );

//
// Flag for printing header
//
BOOL    g_bMsdpFirst = TRUE;
HANDLE  g_hConsole, g_hStdOut;

// This can have the other fields pfn etc
MIB_OBJECT_PARSER   MsdpMIBObjectMap[] =
{
    {TOKEN_MSDP_MIB_OBJECT_GLOBALSTATS,0,0,NULL},
    {TOKEN_MSDP_MIB_OBJECT_PEERSTATS,  1,1,GetMsdpMIBIpAddress},
    {TOKEN_MSDP_MIB_OBJECT_SA,         0,2,GetMsdpMIBSAIndex},
};
#define MAX_MSDP_MIB_OBJECTS (sizeof(MsdpMIBObjectMap)/sizeof(MIB_OBJECT_PARSER))

MSDP_MAGIC_TABLE    MsdpMIBVar[] = {
    {MIBID_MSDP_GLOBAL,            PrintMsdpGlobalStats, 0},
    {MIBID_MSDP_IPV4_PEER_ENTRY,   PrintMsdpPeerStats,   4},
    {MIBID_MSDP_SA_CACHE_ENTRY,    PrintMsdpSA,          8},
};

DWORD
GetMsdpMIBIpAddress(
    IN    LPCWSTR *ppwcArguments,
    IN    ULONG    ulArgumentIndex,
    IN    ULONG    ulArgumentCount,
    OUT   PDWORD   pdwIndices,
    OUT   PDWORD   pdwNumParsed 
    )
/*++

Routine Description:

    Gets the index IP address for peer Mib variable.

Arguments:

    ppwcArguments  - Argument array
    ulArgumentIndex - Index of the first argument in array
    pdwIndices     - Indices specified in command
    pdwNumParsed   - Number of indices in command
    
Return Value:

    NO_ERROR
    
--*/
{
    DWORD    dwErr;
    ULONG    i;
    PULONG   pulTagArray;
    ULONG    ulArgumentsLeft = ulArgumentCount - ulArgumentIndex;
    TAG_TYPE TagTypeArray[] = { { TOKEN_OPT_REMADDR, FALSE, FALSE }
                              };

    *pdwNumParsed = 0;

    if (ulArgumentsLeft < 1) 
    {
        return NO_ERROR;
    }

    dwErr = QueryTagArray( &ppwcArguments[ulArgumentIndex],
                           ulArgumentsLeft,
                           TagTypeArray,
                           NUM_TAGS_IN_TABLE(TagTypeArray),
                           &pulTagArray );

    if (dwErr is NO_ERROR) {
        for (i=0; i<ulArgumentsLeft; i++) {
            switch(pulTagArray ? pulTagArray[i] : i) {
                case 0: { // remaddr
                    pdwIndices[0] = GetIpAddress(ppwcArguments[i+
                                     ulArgumentIndex]);
                    (*pdwNumParsed)++;
                    break;
                }
            }
        }
    } else {
        dwErr = ERROR_SHOW_USAGE;
    }

    if (pulTagArray) { FREE(pulTagArray); }
    return dwErr;
}

DWORD
GetMsdpMIBSAIndex(
    IN    LPCWSTR *ppwcArguments,
    IN    ULONG    ulArgumentIndex,
    IN    ULONG    ulArgumentCount,
    OUT   PDWORD   pdwIndices,
    OUT   PDWORD   pdwNumParsed 
    )
{
    DWORD    dwErr;
    ULONG    i;
    ULONG    ulArgumentsLeft = ulArgumentCount - ulArgumentIndex;
    PULONG   pulTagArray;
    TAG_TYPE TagTypeArray[] = { { TOKEN_OPT_GROUPADDR, FALSE, FALSE },
                                { TOKEN_OPT_SOURCEADDR, FALSE, FALSE },
                              };

    *pdwNumParsed = 0;

    if (ulArgumentsLeft < 1) 
    {
        return NO_ERROR;
    }

    dwErr = QueryTagArray( &ppwcArguments[ulArgumentIndex],
                           ulArgumentsLeft,
                           TagTypeArray,
                           NUM_TAGS_IN_TABLE(TagTypeArray),
                           &pulTagArray );

    if (dwErr is NO_ERROR) {
        for (i=0; i<ulArgumentsLeft; i++) {
            switch(pulTagArray ? pulTagArray[i] : i) {
                case 0: { // grpaddr
                    pdwIndices[0] = GetIpAddress(ppwcArguments[i+
                                     ulArgumentIndex]);
                    (*pdwNumParsed)++;
                    break;
                }
                case 1: { // srcaddr
                    pdwIndices[1] = GetIpAddress(ppwcArguments[i+
                                     ulArgumentIndex]);
                    (*pdwNumParsed)++;
                    break;
                }
            }
        }
    }

    if (pulTagArray) { FREE(pulTagArray); }
    return dwErr;
}

PWCHAR
GetTceStateString(
    DWORD     dwState
    )
{
    PWCHAR        pwszStr;
    static WCHAR  buff[80];
    VALUE_STRING  ppsList[] = {{MSDP_STATE_IDLE,        STRING_IDLE},
                               {MSDP_STATE_CONNECT,     STRING_CONNECT},
                               {MSDP_STATE_ACTIVE,      STRING_ACTIVE},
                               {MSDP_STATE_OPENSENT,    STRING_OPENSENT},
                               {MSDP_STATE_OPENCONFIRM, STRING_OPENCONFIRM},
                               {MSDP_STATE_ESTABLISHED, STRING_ESTABLISHED},
                              };
    DWORD         dwNum = sizeof(ppsList)/sizeof(VALUE_STRING), i;
    DWORD         dwMsgId = 0;

    for (i=0; i<dwNum; i++)
    {
        if (dwState is ppsList[i].dwValue)
        {
            dwMsgId = ppsList[i].dwStringId;
            break;
        }
    }

    if (dwMsgId)
    {
        pwszStr = MakeString( g_hModule, dwMsgId);
        wcscpy(buff, pwszStr);
        FreeString(pwszStr);
    }
    else
    {
        wsprintf(buff, L"%d", dwState);
    }

    return buff;
}

DWORD
HandleMsdpMibShowObject(
    PWCHAR    pwszMachine,
    PWCHAR    *ppwcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    MIB_SERVER_HANDLE hMibServer,
    BOOL      *pbDone
    )
/*++

Routine Description:

    Parses command to get MIB object and optional parameters

Arguments:

Return Value:

--*/
{
    DWORD                dwIndices[MAX_NUM_INDICES];
    DWORD                dwNumParsed = 0;
    MIB_OPAQUE_QUERY     rgQueryBuff[2];
    PMIB_OPAQUE_QUERY    pQuery = rgQueryBuff;
    PMIB_OPAQUE_INFO     pRpcInfo;
    DWORD                dwQuerySize;
    BOOL                 bFound = FALSE,bOptPresent = FALSE;
    DWORD                dwRefreshRate;
    DWORD                dwOutEntrySize;
    DWORD                i,dwResult,dwErr;
    DWORD                dwMIBIndex, dwIndex;
    BOOL                 bIndex = FALSE, dwType;
    DWORD                dwRR = 0, dwInd = 0;
    HANDLE               hMib;
    DWORD                dwDisplayInfoId, dwDisplayInfoType, dwOptVar;
    DWORD                dwOutSize;

    VERIFY_INSTALLED(MS_IP_MSDP, L"MSDP");

    //
    // Match MIB object
    //

    g_hMibServer = hMibServer;

    ppwcArguments += (dwCurrentIndex-1);
    dwArgCount    -= (dwCurrentIndex-1);
    dwCurrentIndex = 1;

    DEBUG1("In MSDP MIB Show : %s\n",ppwcArguments[0]);

    for (i = 0; i < MAX_MSDP_MIB_OBJECTS; i++)
    {
        if (MatchToken(ppwcArguments[0],MsdpMIBObjectMap[i].pwszMIBObj))
        {
            dwIndex = i;
            bFound = TRUE;
        
            DEBUG("found");
            
            break;
        }
    
    }
    
    if (!bFound)
    {
        return ERROR_CMD_NOT_FOUND;
    }

#if 0
    if ((dwArgCount > 1) && IsHelpToken(ppwcArguments[1]))
    {
        DisplayMessage(g_hModule,
                       MsdpMIBObjectMap[i].dwCmdHelpToken,
                       MsdpMIBObjectMap[i].pwszMIBObj);
        return NO_ERROR;
    }
#endif

    if (MsdpMIBObjectMap[dwIndex].pfnMIBObjParser)
    {
        dwErr = (*MsdpMIBObjectMap[dwIndex].pfnMIBObjParser)(ppwcArguments,
                                                             1 + dwInd,
                                                             dwArgCount,
                                                             dwIndices,
                                                             &dwNumParsed);
    
        if (dwErr isnot NO_ERROR) 
        {
            return dwErr;
        }
    }

    //
    // Convert refresh rate to msec
    //
    
    dwRR *= 1000;
    
    dwMIBIndex = dwIndex;
    
    pQuery->dwVarId = MsdpMIBVar[dwMIBIndex].dwId;

    if (!InitializeConsole(&dwRR, &hMib, &g_hConsole))
    {
        return ERROR_INIT_DISPLAY;
    }

    for ( ; ; )
    {
        if(dwRR)
        {
            DisplayMessageToConsole(g_hModule, g_hConsole, MSG_CTRL_C_TO_QUIT);
        }

        // See if we just need to do a GET
        if (dwNumParsed is MsdpMIBObjectMap[dwIndex].dwNumArgs) 
        {
            pQuery->rgdwVarIndex[0] = 0;
            for (i=0; i<MsdpMIBObjectMap[dwIndex].dwNumArgs; i++)
            {
                pQuery->rgdwVarIndex[i] = dwIndices[i];
            }
            
            dwResult = MprAdminMIBEntryGet(hMibServer,
                                           PID_IP,
                                           MS_IP_MSDP,
                                           (LPVOID) pQuery,
                                           sizeof(MIB_OPAQUE_QUERY)
                            + MsdpMIBVar[dwMIBIndex].ulIndexBytes-sizeof(DWORD),
                                           (LPVOID *) &pRpcInfo,
                                           &dwOutSize );
    
            if (( dwResult isnot NO_ERROR ) and (dwResult isnot ERROR_NOT_FOUND))
            {
                DisplayMessageToConsole( g_hModule, g_hConsole, MSG_IP_DIM_ERROR, dwResult );
                break;
            }
    
            if ( pRpcInfo is NULL )
            {
                break;
            }

            (*MsdpMIBVar[dwMIBIndex].pfnPrintFunction)(pRpcInfo, FORMAT_VERBOSE);
    
            MprAdminMIBBufferFree( (PVOID) pRpcInfo );
        }
        else if (dwNumParsed is 0)
        {
            // Display All
            g_bMsdpFirst = TRUE;
    
            dwResult = MprAdminMIBEntryGetFirst(hMibServer,
                                                PID_IP,
                                                MS_IP_MSDP,
                                                (LPVOID) pQuery,
                                                sizeof(MIB_OPAQUE_INFO)
                            + MsdpMIBVar[dwMIBIndex].ulIndexBytes-sizeof(DWORD),
                                                (LPVOID *) &pRpcInfo,
                                                &dwOutSize );
    
            if (( dwResult isnot NO_ERROR ) and (dwResult isnot ERROR_NO_MORE_ITEMS))
            {
                DisplayMessageToConsole( g_hModule, g_hConsole, MSG_IP_DIM_ERROR, dwResult );
                break;
            }
    
            if ( pRpcInfo is NULL )
            {
                DisplayMessageToConsole( g_hModule, g_hConsole, MSG_IP_NO_ENTRIES );
                break;
            }

            (*MsdpMIBVar[dwMIBIndex].pfnPrintFunction)(pRpcInfo, FORMAT_TABLE);

            g_bMsdpFirst = FALSE;

            do
            {
                // pQuery->rgdwVarIndex[0] = pRpcInfo->IMGOD_IfIndex;

                //
                // prepare for next request
                //

                CopyMemory(pQuery->rgdwVarIndex, pRpcInfo->rgbyData, 
                           MsdpMIBVar[dwMIBIndex].ulIndexBytes );
            
                MprAdminMIBBufferFree( (PVOID) pRpcInfo );
                pRpcInfo = NULL;
    
                DEBUG2("calling next with index %d", pQuery->rgdwVarIndex[0]);

                dwResult = MprAdminMIBEntryGetNext(hMibServer,
                                                   PID_IP,
                                                   MS_IP_MSDP,
                                                   (LPVOID) pQuery,
                                                   sizeof(MIB_OPAQUE_QUERY)
                            + MsdpMIBVar[dwMIBIndex].ulIndexBytes-sizeof(DWORD),
                                                   (LPVOID *) &pRpcInfo,
                                                   &dwOutSize );
        
                if (dwResult is ERROR_NO_MORE_ITEMS)
                {
                    g_bMsdpFirst = TRUE;
                    return dwResult;
                }


                if ( dwResult isnot NO_ERROR )
                {
                    g_bMsdpFirst = TRUE;
                    break;
                }
    
                if ( pRpcInfo is NULL )
                {
                    g_bMsdpFirst = TRUE;
                    break;
                }

                if (pQuery->dwVarId isnot pRpcInfo->dwId)
                {
                    g_bMsdpFirst = TRUE;
                    break;
                }
        
                (*MsdpMIBVar[dwMIBIndex].pfnPrintFunction)(pRpcInfo, FORMAT_TABLE);
        
            } while (1);
        } 
        else 
        {
            // partially-specified index
    
            g_bMsdpFirst = TRUE;

            pQuery->rgdwVarIndex[0] = 0;
            for (i=0; i<dwNumParsed; i++)
            {
                pQuery->rgdwVarIndex[i] = dwIndices[i];
            }
            for (; i<MsdpMIBObjectMap[dwIndex].dwNumArgs; i++)
            {
                pQuery->rgdwVarIndex[i] = 0;
            }

            do
            {
                dwResult = MprAdminMIBEntryGetNext(hMibServer,
                                                   PID_IP,
                                                   MS_IP_MSDP,
                                                   (LPVOID) pQuery,
                                                   sizeof(MIB_OPAQUE_QUERY)
                            + MsdpMIBVar[dwMIBIndex].ulIndexBytes-sizeof(DWORD),
                                                   (LPVOID *) &pRpcInfo,
                                                   &dwOutSize );

                if (dwResult is NO_ERROR)
                {
                    // See if we've gone too far
                    for (i=0; i<dwNumParsed; i++) 
                    {
                        // All index fields are DWORDs
                        if (memcmp(pQuery->rgdwVarIndex, pRpcInfo->rgbyData,
                                   dwNumParsed * sizeof(DWORD)))
                        {
                            dwResult = ERROR_NO_MORE_ITEMS;
                            break;
                        }
                    }
                }
        
                if (dwResult is ERROR_NO_MORE_ITEMS)
                {
                    g_bMsdpFirst = TRUE;
                    return dwResult;
                }


                if ( dwResult isnot NO_ERROR )
                {
                    g_bMsdpFirst = TRUE;
                    break;
                }
    
                if ( pRpcInfo is NULL )
                {
                    g_bMsdpFirst = TRUE;
                    break;
                }

                if (pQuery->dwVarId isnot pRpcInfo->dwId)
                {
                    g_bMsdpFirst = TRUE;
                    break;
                }
        
                (*MsdpMIBVar[dwMIBIndex].pfnPrintFunction)(pRpcInfo, FORMAT_TABLE);

                //
                // prepare for next request
                //

                CopyMemory(pQuery->rgdwVarIndex, pRpcInfo->rgbyData, 
                           MsdpMIBVar[dwMIBIndex].ulIndexBytes );

                MprAdminMIBBufferFree( (PVOID) pRpcInfo );
                pRpcInfo = NULL;
                g_bMsdpFirst = FALSE;
        
            } while (1);
        }

        if (!RefreshConsole(hMib, g_hConsole, dwRR))
        {
            break;
        }
    }

    return dwResult;
}
    
VOID 
PrintMsdpGlobalStats(
    PMIB_OPAQUE_INFO pRpcInfo,
    DWORD            dwFormat
    )
/*++

Routine Description:

    Prints msdp global statistics

Arguments:

Return Value:

--*/
{
    WCHAR wszRouterId[20];

    PMSDP_GLOBAL_ENTRY pEntry = (PMSDP_GLOBAL_ENTRY)(pRpcInfo->rgbyData);
    
    IP_TO_TSTR(wszRouterId, &pEntry->dwRouterId);

    DisplayMessageToConsole(g_hModule,g_hConsole,MSG_MSDP_GLOBAL_STATS,
                      pEntry->ulNumSACacheEntries,
                      wszRouterId);
}

VOID 
PrintMsdpSA(
    PMIB_OPAQUE_INFO pRpcInfo,
    DWORD            dwFormat
    )
{
    PMSDP_SA_CACHE_ENTRY psa;
    WCHAR wszGroupAddress[20];
    WCHAR wszSourceAddress[20];
    WCHAR wszOriginAddress[20];
    WCHAR wszLearnedFromAddress[20];
    WCHAR wszRPFPeerAddress[20];
    DWORD dwId = (dwFormat is FORMAT_TABLE)? MSG_MSDP_SA_INFO :
                                             MSG_MSDP_SA_INFO_EX;

    if (g_bMsdpFirst && (dwFormat is FORMAT_TABLE))
    {
        DisplayMessageToConsole(g_hModule,g_hConsole,MSG_MSDP_SA_INFO_HEADER);
    }

    psa = (PMSDP_SA_CACHE_ENTRY)(pRpcInfo->rgbyData);

    IP_TO_TSTR(wszGroupAddress,       &psa->ipGroupAddr);
    IP_TO_TSTR(wszSourceAddress,      &psa->ipSourceAddr);
    IP_TO_TSTR(wszOriginAddress,      &psa->ipOriginRP);
    IP_TO_TSTR(wszLearnedFromAddress, &psa->ipPeerLearnedFrom);
    IP_TO_TSTR(wszRPFPeerAddress,     &psa->ipRPFPeer);

    DisplayMessageToConsole(g_hModule, g_hConsole, 
                      dwId,
                      wszGroupAddress,
                      wszSourceAddress,
                      wszOriginAddress,
                      wszLearnedFromAddress,
                      wszRPFPeerAddress,
                      psa->ulInSAs,
                      psa->ulUpTime/100,
                      psa->ulExpiryTime/100);
}

VOID 
PrintMsdpPeerStats(
    PMIB_OPAQUE_INFO pRpcInfo,
    DWORD            dwFormat
    )
/*++

Routine Description:

    Prints msdp neighbor stats

Arguments:

Return Value:

--*/
{
    PMSDP_IPV4_PEER_ENTRY pPeer;
    WCHAR wszAddr[ADDR_LENGTH + 1];

    if (g_bMsdpFirst && (dwFormat is FORMAT_TABLE))
    {
        DisplayMessageToConsole(g_hModule,g_hConsole,MSG_MSDP_PEER_STATS_HEADER);
    }

    pPeer = (PMSDP_IPV4_PEER_ENTRY)(pRpcInfo->rgbyData);

    MakeUnicodeIpAddr(wszAddr, inet_ntoa(*((struct in_addr *)
                                           (&pPeer->ipRemoteAddress))));

    DisplayMessageToConsole(g_hModule, g_hConsole, 
                      (dwFormat is FORMAT_TABLE)? MSG_MSDP_PEER_STATS
                                                : MSG_MSDP_PEER_STATS_EX, 
                      wszAddr,
                      GetTceStateString(pPeer->dwState),
                      pPeer->ulRPFFailures,
                      pPeer->ulInSAs,
                      pPeer->ulOutSAs,
                      pPeer->ulInSARequests,
                      pPeer->ulOutSARequests,
                      pPeer->ulInSAResponses,
                      pPeer->ulOutSAResponses,
                      pPeer->ulInControlMessages,
                      pPeer->ulOutControlMessages,
                      pPeer->ulFsmEstablishedTransitions,
                      pPeer->ulFsmEstablishedTime,
                      pPeer->ulInMessageElapsedTime);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ip\preview\prstring.h ===
#define MSG_HELP_START L"%1!-14s! - "
#define MSG_NEWLINE _T("\n")


#define TOKEN_ROUTER                           _T("router")
#define TOKEN_MIB                              _T("mib")

    // tokens for commands
#define TOKEN_COMMAND_ADD                      _T("add")
#define TOKEN_COMMAND_DELETE                   _T("delete")
#define TOKEN_COMMAND_SET                      _T("set")
#define TOKEN_COMMAND_SHOW                     _T("show")
#define TOKEN_COMMAND_SHOW_HELPER              _T("show helper")
#define TOKEN_COMMAND_HELP                      _T("help")
#define TOKEN_COMMAND_INSTALL                  _T("install")
#define TOKEN_COMMAND_UNINSTALL                _T("uninstall")

#define TOKEN_COMMAND_HELP1                     _T("/?")
#define TOKEN_COMMAND_HELP2                     _T("-?")

    // Global option tokens used by multiple protocols
#define TOKEN_OPT_LOGGINGLEVEL                 L"loglevel"

    // MSDP options
#define TOKEN_OPT_KEEPALIVE                    L"keepalive"
#define TOKEN_OPT_SAHOLDDOWN                   L"saholddown"
#define TOKEN_OPT_CONNECTRETRY                 L"connectretry"
#define TOKEN_OPT_LOCALADDR                    L"localaddr"
#define TOKEN_OPT_REMADDR                      L"remoteaddr"
#define TOKEN_OPT_ACCEPTALL                    L"acceptall"
#define TOKEN_OPT_CACHELIFETIME                L"cachelifetime"
#define TOKEN_OPT_CACHING                      L"caching"
#define TOKEN_OPT_DEFAULTPEER                  L"defaultpeer"
#define TOKEN_OPT_GROUPADDR                    L"grpaddr"
#define TOKEN_OPT_SOURCEADDR                   L"srcaddr"
#define TOKEN_OPT_ENCAPSMETHOD                 L"encapsulation"

        // interface options
#define TOKEN_OPT_INTERFACE_NAME               _T("NAME")
#define TOKEN_OPT_INTERFACE_STATUS             _T("STATE")
#define TOKEN_OPT_DISCOVERY                    _T("DISC")
#define TOKEN_OPT_MIN_DISC_INTERVAL            _T("MININT")
#define TOKEN_OPT_MAX_DISC_INTERVAL            _T("MAXINT")
#define TOKEN_OPT_LIFETIME                     _T("LIFE")
#define TOKEN_OPT_LEVEL                        _T("LEVEL")
#define TOKEN_OPT_TTL                          _T("TTL")

        // protocol options
#define TOKEN_OPT_SERVER                       _T("SERVER")
#define TOKEN_OPT_LOG_LEVEL                    _T("LOGLEVEL")
#define TOKEN_OPT_AUTHENTICATION               _T("AUTH")
#define TOKEN_OPT_PASSWORD                     _T("PASSWORD")
#define TOKEN_OPT_PEER_MODE                    _T("PEERMODE")

            // VRRP Interface options
#define TOKEN_OPT_NAME                         _T("NAME=")
#define TOKEN_OPT_VRID                         _T("VRID=")
#define TOKEN_OPT_IPADDRESS                    _T("IPADDR=")
#define TOKEN_OPT_AUTH                         _T("AUTH=")
#define TOKEN_OPT_PASSWD                       _T("PASSWD=")
#define TOKEN_OPT_ADVTINTERVAL                 _T("ADVTINTERVAL=")
#define TOKEN_OPT_PRIO                         _T("PRIORITY=")
#define TOKEN_OPT_PREEMPT                      _T("PREEMPT=")
            
        // Route Options
#define TOKEN_OPT_NEXT_HOP                     _T("NEXTHOP=")

        // overloaded options
#define TOKEN_OPT_TYPE                         _T("TYPE")
#define TOKEN_OPT_METRIC                       _T("METRIC")
#define TOKEN_OPT_PROTOCOL                     _T("PROTO")
#define TOKEN_OPT_PREF_LEVEL                   _T("PREFLEVEL")

    // Miscellaneous options
#define TOKEN_OPT_INDEX                        _T("INDEX=")
#define TOKEN_OPT_HELP1                        _T("/?")
#define TOKEN_OPT_HELP2                        _T("-?")
#define TOKEN_OPT_GLOBAL                       _T("GLOBAL")


    // Option values
        // Interface types
#define TOKEN_OPT_VALUE_LAN                    _T("LAN")
#define TOKEN_OPT_VALUE_WAN                    _T("WAN")

        // Router types
#define TOKEN_OPT_VALUE_CLIENT                 _T("CLIENT")
#define TOKEN_OPT_VALUE_HOME                   _T("HOME")
#define TOKEN_OPT_VALUE_FULL                   _T("FULL")
#define TOKEN_OPT_VALUE_DEDICATED              _T("DEDICATED")
#define TOKEN_OPT_VALUE_INTERNAL               _T("INTERNAL")

        // Protocol types
#define TOKEN_OPT_VALUE_RTRMGR                 _T("ROUTERMANAGER")
#define TOKEN_OPT_VALUE_RIP                    _T("RIP")
#define TOKEN_OPT_VALUE_OSPF                   _T("OSPF")
#define TOKEN_OPT_VALUE_BOOTP                  _T("BOOTP")
#define TOKEN_OPT_VALUE_IGMP                   _T("IGMP")
#define TOKEN_OPT_VALUE_AUTO_DHCP              _T("AUTODHCP")
#define TOKEN_OPT_VALUE_DNS_PROXY              _T("DNSPROXY")
#define TOKEN_OPT_VALUE_VRRP                   _T("VRRP")

#define TOKEN_OPT_VALUE_TCP                    _T("TCP")
#define TOKEN_OPT_VALUE_UDP                    _T("UDP")
#define TOKEN_OPT_VALUE_ICMP                   _T("ICMP")
#define TOKEN_OPT_VALUE_NETMGMT                _T("SNMP")
#define TOKEN_OPT_VALUE_LOCAL                  _T("LOCAL")
#define TOKEN_OPT_VALUE_STATIC                 _T("STATIC")
#define TOKEN_OPT_VALUE_AUTOSTATIC             _T("AUTOSTATIC")
#define TOKEN_OPT_VALUE_NONDOD                 _T("NONDOD")
#define TOKEN_OPT_VALUE_ANY                    _T("ANY")


        // Igmp protocol types
#define TOKEN_OPT_VALUE_IGMPRTRV1              _T("IGMPRTRV1")
#define TOKEN_OPT_VALUE_IGMPRTRV2              _T("IGMPRTRV2")
#define TOKEN_OPT_VALUE_IGMPPROXY              _T("IGMPPROXY")

#define TOKEN_OPT_VALUE_TRUE                   _T("TRUE")
#define TOKEN_OPT_VALUE_FALSE                  _T("FALSE")
#define TOKEN_OPT_VALUE_HOST_JOIN              _T("HOSTJOIN")
#define TOKEN_OPT_VALUE_MGM_ONLY_JOIN          _T("MGMONLYJOIN")


        // Accept/Announce types
#define TOKEN_OPT_VALUE_RIP1                   _T("RIP1")
#define TOKEN_OPT_VALUE_RIP1_COMPAT            _T("RIP1COMPAT")
#define TOKEN_OPT_VALUE_RIP2                   _T("RIP2")

        // log level types
#define TOKEN_OPT_VALUE_ERROR                  _T("ERROR")
#define TOKEN_OPT_VALUE_WARN                   _T("WARN")
#define TOKEN_OPT_VALUE_INFO                   _T("INFO")

        // unicast peer modes
#define TOKEN_OPT_VALUE_ALSO                   _T("ALSO")
#define TOKEN_OPT_VALUE_ONLY                   _T("ONLY")

        // filter modes
#define TOKEN_OPT_VALUE_INCLUDE                _T("INCLUDE")
#define TOKEN_OPT_VALUE_EXCLUDE                _T("EXCLUDE")

        // Misc. option vlues
#define TOKEN_OPT_VALUE_INPUT                  _T("INPUT")
#define TOKEN_OPT_VALUE_OUTPUT                 _T("OUTPUT")
#define TOKEN_OPT_VALUE_DIAL                   _T("DIAL")

#define TOKEN_OPT_VALUE_ENABLE                 L"enable"
#define TOKEN_OPT_VALUE_DISABLE                L"disable"
#define TOKEN_OPT_VALUE_DEFAULT                L"default"

#define TOKEN_OPT_VALUE_YES                    _T("YES")
#define TOKEN_OPT_VALUE_NO                     _T("NO")

#define TOKEN_OPT_VALUE_NONE                   _T("NONE")
#define TOKEN_OPT_VALUE_PASSWORD               _T("PASSWORD")

#define TOKEN_OPT_VALUE_DROP                   _T("DROP")
#define TOKEN_OPT_VALUE_FORWARD                _T("FORWARD")
#define TOKEN_OPT_VALUE_ACCEPT                 _T("ACCEPT")

#define TOKEN_OPT_VALUE_DEMAND                 _T("DEMAND")
#define TOKEN_OPT_VALUE_PERIODIC               _T("PERIODIC")

#define TOKEN_OPT_VALUE_NBMA                   _T("NBMA")
#define TOKEN_OPT_VALUE_POINT_TO_POINT         _T("P2P")
#define TOKEN_OPT_VALUE_BROADCAST              _T("BROADCAST")

#define TOKEN_OPT_VALUE_ADDRESSONLY            _T("ADDRESSONLY")
#define TOKEN_OPT_VALUE_PRIVATE                _T("PRIVATE")

#define TOKEN_OPT_VALUE_AUTH_NONE              _T("NONE")
#define TOKEN_OPT_VALUE_AUTH_SIMPLE_PASSWORD    _T("SIMPLEPASSWD")
#define TOKEN_OPT_VALUE_AUTH_MD5                _T("MD5")

    // Commands for configuring the various protocols

    // tokens for commands required by most protocols

#define CMD_GROUP_ADD                          _T("add")
#define CMD_GROUP_DELETE                       _T("delete")
#define CMD_GROUP_SET                          _T("set")
#define CMD_GROUP_SHOW                         _T("show")

#define CMD_SHOW_HELPER                        _T("show helper")
#define CMD_INSTALL                            _T("install")
#define CMD_UNINSTALL                          _T("uninstall")
#define CMD_DUMP                               _T("dump")
#define CMD_HELP1                              _T("help")
#define CMD_HELP2                              _T("?")
#define CMD_MIB                                _T("mib")
#define CMD_ADD_HELPER                         _T("add helper")
#define CMD_DEL_HELPER                         _T("delete helper")

    // VRRP commands
#define CMD_VRRP_ADD_INTERFACE                 L"add interface"
#define CMD_VRRP_ADD_VRID                      L"add VRID"
#define CMD_VRRP_DELETE_INTERFACE              L"delete interface"
#define CMD_VRRP_DELETE_VRID                   L"delete VRID"
#define CMD_VRRP_SET_GLOBAL                    L"set global"
#define CMD_VRRP_SET_INTERFACE                 L"set interface"
#define CMD_VRRP_SHOW_GLOBAL                   L"show global"
#define CMD_VRRP_SHOW_INTERFACE                L"show interface"

    // MSDP commands
#define CMD_MSDP_ADD_PEER                      L"add peer"
#define CMD_MSDP_DELETE_PEER                   L"delete peer"
#define CMD_MSDP_SET_PEER                      L"set peer"
#define CMD_MSDP_SHOW_PEER                     L"show peer"
#define CMD_MSDP_SHOW_PEERSTATS                L"show peerstats"
#define CMD_MSDP_SET_GLOBAL                    L"set global"
#define CMD_MSDP_SHOW_GLOBAL                   L"show global"
#define CMD_MSDP_SHOW_GLOBALSTATS              L"show globalstats"
#define CMD_MSDP_SHOW_SA                       L"show sa"

    // Tokens for MSDP MIB
#define TOKEN_MSDP_MIB_OBJECT_PEERSTATS        L"peerstats"
#define TOKEN_MSDP_MIB_OBJECT_GLOBALSTATS      L"globalstats"
#define TOKEN_MSDP_MIB_OBJECT_SA               L"sa"

    // Common dump commands

#define DMP_POPD        L"popd\n"
#define DMP_INSTALL     L"install\n"
#define DMP_UNINSTALL   L"uninstall\n"

    // MSDP commands

#define DMP_MSDP_PUSHD             L"pushd routing ip msdp\n"
#define DMP_MSDP_SET_GLOBAL        L"set global"
#define DMP_MSDP_ADD_PEER          L"add peer"
#define DMP_MSDP_STRING_ARGUMENT   L" %1!s!=%2!s!"
#define DMP_MSDP_INTEGER_ARGUMENT  L" %1!s!=%2!d!"

    // VRRP commands
    //
#define DMP_VRRP_INSTALL _T("\
install\n")

#define DMP_VRRP_PUSHD L"\
pushd routing ip vrrp\n"

#define DMP_VRRP_SET_GLOBAL _T("\
set global %1!s!=%2!s!\n")

#define DMP_VRRP_ADD_INTERFACE _T("\
add interface %1!s!\"%2!s!\"\n")

#define DMP_VRRP_ADD_VRID _T("\
add vrid %1!s!\"%2!s!\" %3!s!%4!d! %5!s!%6!s!\n")

#define DMP_VRRP_SET_INTERFACE _T("\
set interface \
%1!s!\"%2!s!\" \
%3!s!%4!d! \
%5!s!%6!s! \
%7!s!%8!d!-%9!d!-%10!d!-%11!d!-%12!d!-%13!d!-%14!d!-%15!d! \
%16!s!%17!d! \
%18!s!%19!d! \
%20!s!%21!s! \n")

#define DMP_VRRP_UNINSTALL _T("\
uninstall\n")

    // Ospf dump commands

#define DMP_OSPF_PUSHD L"\
pushd ip ospf\n"

#define DMP_OSPF_INSTALL _T("\
install\n")

#define DMP_OSPF_UNINSTALL _T("\
uninstall\n")

#define DMP_OSPF_SET_GLOBAL _T("\
set global routerid=%1!s! asborder=%2!d! loglevel=%3!s!\n\n")

#define DMP_OSPF_DELETE_INTERFACE _T("\
delete interface name=%1!s!\n")

#define DMP_OSPF_ADD_INTERFACE _T("\
add interface name=%1!s!\n")

#define DMP_OSPF_SET_INTERFACE _T("\
set interface name=%1!s!\
 ifaddr=%2!s!\
 ifmask=%3!s!\
 iftype=%4!s!\
 prio=%5!d!\
 transdelay=%6!d!\
 retrans=%7!d!\
 hello=%8!d!\
 dead=%9!d!\
 poll=%10!d!\
 metric=%11!d!\
 password=%12!s!\
 mtu=%13!d!\n\n")

#define DMP_OSPF_ADD_AREA _T("\
add area areaid=%1!s!\n\n")

#define DMP_OSPF_DELETE_AREA _T("\
delete area areaid=%1!s!\n")

#define DMP_OSPF_SET_AREA _T("\
set area areaid=%1!s!\
 auth=%2!s!\
 importas=%3!s!\
 metric=%4!d!\
 sumad=%5!s!\n\n")

#define DMP_OSPF_ADD_NEIGHBOR _T("\
add neighbor name=%1!s! ifaddr=%2!s! nbraddr=%3!s! nbrprio=%4!d!\n")

#define DMP_OSPF_DELETE_NEIGHBOR _T("\
delete neighbor name=%1!s! ifaddr=%2!s! nbraddr=%3!s!\n")

#define DMP_OSPF_ADD_VIRTUAL_INTERFACE _T("\
add neighbor name=%1!s! ifaddr=%2!s! nbraddr=%3!s!\n")

#define DMP_OSPF_DELETE_VIRTUAL_INTERFACE _T("\
delete virtif transareaid=%1!s! virtnbrid=%2!s!\n")

#define DMP_OSPF_SET_VIRTUAL_INTERFACE _T("\
set virtif transareaid=%1!s! virtnbrid=%2!s!\
 transdelay=%3!d! retrans=%4!d! hello=%5!d!\
 dead=%6!d! password=%7!s!\n")

    // Ospf hlp commands

#define CMD_OSPF_ADD_AREA_RANGE                _T("add range")
#define CMD_OSPF_ADD_AREA                      _T("add area")
#define CMD_OSPF_ADD_VIRTIF                    _T("add virtif")
#define CMD_OSPF_ADD_IF_NBR                    _T("add neighbor")
#define CMD_OSPF_ADD_IF                        _T("add interface")
#define CMD_OSPF_ADD                       _T("add")

#define CMD_OSPF_DEL_AREA_RANGE                _T("delete range")
#define CMD_OSPF_DEL_AREA                      _T("delete area")
#define CMD_OSPF_DEL_VIRTIF                    _T("delete virtif")
#define CMD_OSPF_DEL_IF_NBR                    _T("delete neighbor")
#define CMD_OSPF_DEL_IF                        _T("delete interface")
#define CMD_OSPF_DEL                       _T("delete")

#define CMD_OSPF_SET_AREA                      _T("set area")
#define CMD_OSPF_SET_VIRTIF                    _T("set virtif")
#define CMD_OSPF_SET_IF                        _T("set interface")
#define CMD_OSPF_SET_GLOBAL                    _T("set global")

#define CMD_OSPF_SHOW_GLOBAL                   _T("show global")
#define CMD_OSPF_SHOW_AREA                     _T("show area")
#define CMD_OSPF_SHOW_VIRTIF                   _T("show virtif")
#define CMD_OSPF_SHOW_IF                       _T("show interface")
#define CMD_OSPF_SHOW                          _T("show")
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ip\preview\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ippromon.rc
//
#define VER_PRODUCTVER                  0074

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ip\preview\vrrphlp.h ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    net\routing\netsh\ip\protocols\vrrphlp.h

Abstract:

    VRRP Command dispatcher declarations

Author:

    Peeyush Ranjan (peeyushr)   1-Mar-1999

Revision History:

--*/

#ifndef _NETSH_VRRPHLP_H_
#define _NETSH_VRRPHLP_H_

extern CMD_ENTRY g_VrrpAddCmdTable[];
extern CMD_ENTRY g_VrrpDelCmdTable[];
extern CMD_ENTRY g_VrrpSetCmdTable[];
extern CMD_ENTRY g_VrrpShowCmdTable[];


extern CMD_GROUP_ENTRY g_VrrpCmdGroupTable[];
extern ULONG g_VrrpCmdGroupCount;
extern CMD_ENTRY g_VrrpTopCmdTable[];
extern ULONG g_VrrpTopCmdCount;

NS_CONTEXT_DUMP_FN  VrrpDump;

#endif // _NETSH_VRRPHLP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ip\preview\utils.h ===
#define DispTokenErrMsg(hModule, dwMsgId, pwszTag, pwszValue) \
        DisplayMessage( hModule, dwMsgId, pwszValue, pwszTag)



DWORD
GetDisplayStringT (
    IN  HANDLE  hModule,
    IN  DWORD   dwValue,
    IN  PVALUE_TOKEN ptvTable,
    IN  DWORD   dwNumArgs,
    OUT PWCHAR  *ppwszString
    );

DWORD
GetDisplayString (
    IN  HANDLE  hModule,
    IN  DWORD   dwValue,
    IN  PVALUE_STRING ptvTable,
    IN  DWORD   dwNumArgs,
    OUT PWCHAR  *ppwszString
    );

DWORD
GetAltDisplayString(
    IN  HANDLE        hModule, 
    IN  HANDLE        hFile,
    IN  DWORD         dwValue,
    IN  PVALUE_TOKEN  vtTable,
    IN  PVALUE_STRING vsTable,
    IN  DWORD         dwNumArgs,
    OUT PTCHAR       *pptszString);

DWORD
GetInfoBlockFromInterfaceInfoEx(
    IN  LPCWSTR pwszIfName,
    IN  DWORD   dwType,
    OUT BYTE    **ppbInfoBlk,   OPTIONAL
    OUT PDWORD  pdwSize,        OPTIONAL
    OUT PDWORD  pdwCount,       OPTIONAL
    OUT PDWORD  pdwIfType       OPTIONAL
    );

DWORD
GetIpAddress(
    PTCHAR    pptcArg
    );

DWORD
GetMibTagToken(
    IN  LPWSTR *ppwcArguments,
    IN  DWORD   dwArgCount,
    IN  DWORD   dwNumIndices,
    OUT PDWORD  pdwRR,
    OUT PBOOL   pbIndex,
    OUT PDWORD  pdwIndex
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ip\preview\vrrphlp.c ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    net\routing\netsh\ip\protocols\vrrphlp.c

Abstract:

    This module contains code for dispatching commands
    received for the Virtual Router Redundancy Protocol.
    The implementation of the commands is elsewhere,
    in vrrphlpopt.c and vrrphlpcfg.c.

Author

    Peeyush Ranjan (peeyushr)   1-Mar-1999

Revision History:

    Based loosely on net\routing\netsh\ip\protocols\nathlp.c by AboladeG

--*/

#include "precomp.h"
#pragma hdrstop



CMD_ENTRY g_VrrpAddCmdTable[] =
{
    CREATE_CMD_ENTRY(VRRP_ADD_INTERFACE, HandleVrrpAddInterface),
    CREATE_CMD_ENTRY(VRRP_ADD_VRID,     HandleVrrpAddVRID)
};

CMD_ENTRY g_VrrpDeleteCmdTable[] =
{
    CREATE_CMD_ENTRY(VRRP_DELETE_INTERFACE, HandleVrrpDeleteInterface),
    CREATE_CMD_ENTRY(VRRP_DELETE_VRID,      HandleVrrpDeleteVRID)
};

CMD_ENTRY g_VrrpSetCmdTable[] =
{
    CREATE_CMD_ENTRY(VRRP_SET_INTERFACE, HandleVrrpSetInterface),
    CREATE_CMD_ENTRY(VRRP_SET_GLOBAL, HandleVrrpSetGlobal)
};

CMD_ENTRY g_VrrpShowCmdTable[] =
{
    CREATE_CMD_ENTRY(VRRP_SHOW_GLOBAL, HandleVrrpShowGlobal),
    CREATE_CMD_ENTRY(VRRP_SHOW_INTERFACE, HandleVrrpShowInterface)
};

CMD_GROUP_ENTRY g_VrrpCmdGroupTable[] =
{
    CREATE_CMD_GROUP_ENTRY(GROUP_ADD, g_VrrpAddCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_DELETE, g_VrrpDeleteCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_SET, g_VrrpSetCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_SHOW, g_VrrpShowCmdTable)
};

ULONG g_VrrpCmdGroupCount =
    sizeof(g_VrrpCmdGroupTable) / sizeof(g_VrrpCmdGroupTable[0]);

CMD_ENTRY g_VrrpTopCmdTable[] =
{
    CREATE_CMD_ENTRY(INSTALL, HandleVrrpInstall),
    CREATE_CMD_ENTRY(UNINSTALL, HandleVrrpUninstall),
};

ULONG g_VrrpTopCmdCount =
    sizeof(g_VrrpTopCmdTable) / sizeof(g_VrrpTopCmdTable[0]);


DWORD
VrrpDump(
    IN  LPCWSTR     pwszRouter,
    IN  WCHAR     **ppwcArguments,
    IN  DWORD       dwArgCount,
    IN  PVOID       pvData
    )
{
    g_hMibServer = (MIB_SERVER_HANDLE)pvData;

    return DumpVrrpInformation();
} // VRRPDump
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ip\preview\strdefs.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:


Abstract:

    

Author:

    Amritansh Raghav  01/25/1996

Revision History:

    V Raman            05/15/1996        Rearranged stringtable ids.
        
--*/

#ifndef __STRDEFS_H__
#define __STRDEFS_H__


// The string table entries that are identified here are arranged  
// in a hierachy as follows

    // Command line tokens
        // command class
        // commands
        // command objects
            // Router command objects
            // MIB comand objects
        // command option tags
            // interface options
            // filter options
            // Protocol Options
                // OSPF options
                // RIP options
                // Igmp options
            // Route options
        // Micellaneous options
        // Option values
            // Interface types
            // Router discovery types
            // Protocol types
            // Accept/Announce types
            // Misc. option values

    // command usage messages
        // show command usage 
        // add command usage 
        // delete command usage 
        // set command usage 

    // Output messages
        // Router messages
            // Interface messages
            // Filter messages
            // Route messages
            // Global info. messages
            // OSPF messages
        // MIB messages

    // Strings
        // Interface Types
        // TCP constants
        // TCP states
        // Protocol types
        // IP Route types
        // IP net types
        // Interface types
        // transmission types
        // Miscellaneous strings
        
    // Error Messages

#define MSG_NULL                                1000

#define MAX_ROUTER_OBJECTS                      \
    (TOKEN_RTR_OBJECT_IPIPTUNNEL - TOKEN_RTR_OBJECT_INTERFACE + 1)

#define MAX_MIB_OBJECTS                         \
    (TOKEN_MIB_OBJECT_MFESTATS - TOKEN_MIB_OBJECT_INTERFACE + 1)

#define DMP_MSDP_HEADER                         7050
#define DMP_MSDP_FOOTER                         7051
#define DMP_MSDP_INTERFACE_HEADER               7052

#define DMP_VRRP_HEADER                         7101
#define DMP_VRRP_FOOTER                         7102
#define DMP_VRRP_INTERFACE_HEADER               7103

// commmon hlp messages

#define HLP_HELP                                8400
#define HLP_HELP_EX                             8401
#define HLP_HELP1                               HLP_HELP
#define HLP_HELP1_EX                            HLP_HELP_EX
#define HLP_HELP2                               HLP_HELP
#define HLP_HELP2_EX                            HLP_HELP_EX
#define HLP_SHOW_HELPER                         8412
#define HLP_SHOW_HELPER_EX                      8413
#define HLP_INSTALL                             8414
#define HLP_INSTALL_EX                          8415
#define HLP_UNINSTALL                           8416
#define HLP_UNINSTALL_EX                        8417
#define HLP_DUMP                                8418
#define HLP_DUMP_EX                             8419
#define HLP_GROUP_ADD                           8420
#define HLP_GROUP_DELETE                        8421
#define HLP_GROUP_SET                           8422
#define HLP_GROUP_SHOW                          8423
#define HLP_ADD_HELPER                          8424
#define HLP_ADD_HELPER_EX                       8425
#define HLP_DEL_HELPER                          8426
#define HLP_DEL_HELPER_EX                       8427


// rip add hlp

#define HLP_RIP_ADD_PF                          9000
#define HLP_RIP_ADD_PF_EX                       9001
#define HLP_RIP_ADD_IF_ACCF                     9002
#define HLP_RIP_ADD_IF_ACCF_EX                  9003
#define HLP_RIP_ADD_IF_ANNF                     9004
#define HLP_RIP_ADD_IF_ANNF_EX                  9005
#define HLP_RIP_ADD_IF_NBR                      9006
#define HLP_RIP_ADD_IF_NBR_EX                   9007
#define HLP_RIP_ADD_IF                          9008
#define HLP_RIP_ADD_IF_EX                       9009

// rip delete hlp

#define HLP_RIP_DEL_PF                          9020
#define HLP_RIP_DEL_PF_EX                       9021
#define HLP_RIP_DEL_IF_ACCF                     9022
#define HLP_RIP_DEL_IF_ACCF_EX                  9023
#define HLP_RIP_DEL_IF_ANNF                     9024
#define HLP_RIP_DEL_IF_ANNF_EX                  9025
#define HLP_RIP_DEL_IF_NBR                      9026
#define HLP_RIP_DEL_IF_NBR_EX                   9027
#define HLP_RIP_DEL_IF                          9028
#define HLP_RIP_DEL_IF_EX                       9029

// rip set hlp

#define HLP_RIP_SET_IF                          9040
#define HLP_RIP_SET_IF_EX                       9041
#define HLP_RIP_SET_GLOBAL                      9042
#define HLP_RIP_SET_GLOBAL_EX                   9043

// rip show hlp

#define HLP_RIP_SHOW_IF                         9050
#define HLP_RIP_SHOW_IF_EX                      9051
#define HLP_RIP_SHOW_GLOBAL                     9052
#define HLP_RIP_SHOW_GLOBAL_EX                  9053

#define HLP_IP_ADD_IF                           9200
#define HLP_IP_ADD_PROTO                        9201
#define HLP_IP_ADD_ROUTEPREF                    9203
#define HLP_IP_ADD_IF_FILTER                    9204

#define HLP_IP_DEL_IF                           9210
#define HLP_IP_DEL_PROTO                        9211
#define HLP_IP_DEL_ROUTEPREF                    9212
#define HLP_IP_DEL_IF_FILTER                    9213

#define HLP_IP_SET_IF                           9220
#define HLP_IP_SET_ROUTEPREF                    9221
#define HLP_IP_SET_IF_FILTER                    9222
#define HLP_IP_SET                              9223

#define HLP_IP_SHOW_IF_FILTER                   9230
#define HLP_IP_SHOW_IF                          9231
#define HLP_IP_SHOW_ROUTEPREF                   9232
#define HLP_IP_SHOW_PROTOCOL                    9233
#define HLP_IP_SHOW                             9234

// BOOTP help messages

#define HLP_BOOTP_ADD                           9401
#define HLP_BOOTP_ADD_EX                        9402
#define HLP_BOOTP_ADD_IF                        9403
#define HLP_BOOTP_ADD_IF_EX                     9404
#define HLP_BOOTP_ADD_DHCP_SERVER               9405
#define HLP_BOOTP_ADD_DHCP_SERVER_EX            9406

#define HLP_BOOTP_DEL                           9411
#define HLP_BOOTP_DEL_EX                        9412
#define HLP_BOOTP_DEL_IF                        9413
#define HLP_BOOTP_DEL_IF_EX                     9414
#define HLP_BOOTP_DEL_DHCP_SERVER               9415
#define HLP_BOOTP_DEL_DHCP_SERVER_EX            9416

#define HLP_BOOTP_SET_GLOBAL                    9421
#define HLP_BOOTP_SET_GLOBAL_EX                 9422
#define HLP_BOOTP_SET_IF                        9423
#define HLP_BOOTP_SET_IF_EX                     9424

#define HLP_BOOTP_SHOW_GLOBAL                   9431
#define HLP_BOOTP_SHOW_GLOBAL_EX                9432
#define HLP_BOOTP_SHOW_IF                       9433
#define HLP_BOOTP_SHOW_IF_EX                    9434

// DHCP allocator help messages
#define HLP_AUTODHCP_ADD_EXCLUSION              9441
#define HLP_AUTODHCP_ADD_EXCLUSION_EX           9442
#define HLP_AUTODHCP_DELETE_EXCLUSION           9443
#define HLP_AUTODHCP_DELETE_EXCLUSION_EX        9444
#define HLP_AUTODHCP_SET_GLOBAL                 9445
#define HLP_AUTODHCP_SET_GLOBAL_EX              9446
#define HLP_AUTODHCP_SET_INTERFACE              9447
#define HLP_AUTODHCP_SET_INTERFACE_EX           9448
#define HLP_AUTODHCP_SHOW_GLOBAL                9449
#define HLP_AUTODHCP_SHOW_GLOBAL_EX             9450
#define HLP_AUTODHCP_SHOW_INTERFACE             9451
#define HLP_AUTODHCP_SHOW_INTERFACE_EX          9452

// DNS proxy help messages
#define HLP_DNSPROXY_SET_GLOBAL                 9461
#define HLP_DNSPROXY_SET_GLOBAL_EX              9462
#define HLP_DNSPROXY_SET_INTERFACE              9463
#define HLP_DNSPROXY_SET_INTERFACE_EX           9464
#define HLP_DNSPROXY_SHOW_GLOBAL                9465
#define HLP_DNSPROXY_SHOW_GLOBAL_EX             9466
#define HLP_DNSPROXY_SHOW_INTERFACE             9467
#define HLP_DNSPROXY_SHOW_INTERFACE_EX          9468

// NAT help messages
#define HLP_NAT_ADD_ADDRESS_MAPPING             9471
#define HLP_NAT_ADD_ADDRESS_MAPPING_EX          9472
#define HLP_NAT_ADD_ADDRESS_RANGE               9473
#define HLP_NAT_ADD_ADDRESS_RANGE_EX            9474
#define HLP_NAT_ADD_PORT_MAPPING                9475
#define HLP_NAT_ADD_PORT_MAPPING_EX             9476
#define HLP_NAT_DELETE_ADDRESS_MAPPING          9477
#define HLP_NAT_DELETE_ADDRESS_MAPPING_EX       9478
#define HLP_NAT_DELETE_ADDRESS_RANGE            9479
#define HLP_NAT_DELETE_ADDRESS_RANGE_EX         9480
#define HLP_NAT_DELETE_PORT_MAPPING             9481
#define HLP_NAT_DELETE_PORT_MAPPING_EX          9482
#define HLP_NAT_SET_GLOBAL                      9483
#define HLP_NAT_SET_GLOBAL_EX                   9484
#define HLP_NAT_SET_INTERFACE                   9485
#define HLP_NAT_SET_INTERFACE_EX                9486
#define HLP_NAT_SHOW_GLOBAL                     9487
#define HLP_NAT_SHOW_GLOBAL_EX                  9488
#define HLP_NAT_ADD_INTERFACE                   9489
#define HLP_NAT_ADD_INTERFACE_EX                9490
#define HLP_NAT_DELETE_INTERFACE                9491
#define HLP_NAT_DELETE_INTERFACE_EX             9492
#define HLP_NAT_SHOW_INTERFACE                  9493
#define HLP_NAT_SHOW_INTERFACE_EX               9494

// VRRP help messages
#define HLP_VRRP_ADD_INTERFACE                  9501
#define HLP_VRRP_ADD_INTERFACE_EX               9502
#define HLP_VRRP_DELETE_INTERFACE               9503
#define HLP_VRRP_DELETE_INTERFACE_EX            9504
#define HLP_VRRP_SET_GLOBAL                     9505
#define HLP_VRRP_SET_GLOBAL_EX                  9506
#define HLP_VRRP_SET_INTERFACE                  9507
#define HLP_VRRP_SET_INTERFACE_EX               9508
#define HLP_VRRP_SHOW_GLOBAL                    9509
#define HLP_VRRP_SHOW_GLOBAL_EX                 9510
#define HLP_VRRP_SHOW_INTERFACE                 9511
#define HLP_VRRP_SHOW_INTERFACE_EX              9512
#define HLP_VRRP_ADD_VRID                       9513
#define HLP_VRRP_ADD_VRID_EX                    9514
#define HLP_VRRP_DELETE_VRID                    9515
#define HLP_VRRP_DELETE_VRID_EX                 9516

// MSDP help messages
#define HLP_MSDP_ADD_PEER                       9601
#define HLP_MSDP_ADD_PEER_EX                    9602
#define HLP_MSDP_DELETE_PEER                    9603
#define HLP_MSDP_DELETE_PEER_EX                 9604
#define HLP_MSDP_SET_PEER                       9605
#define HLP_MSDP_SET_PEER_EX                    9606
#define HLP_MSDP_SHOW_PEER                      9607
#define HLP_MSDP_SHOW_PEER_EX                   9608

#define HLP_MSDP_SET_GLOBAL                     9615
#define HLP_MSDP_SET_GLOBAL_EX                  9616
#define HLP_MSDP_SHOW_GLOBAL                    9617
#define HLP_MSDP_SHOW_GLOBAL_EX                 9618

#define HLP_MSDP_SHOW_PEERSTATS                 9627
#define HLP_MSDP_SHOW_PEERSTATS_EX              9628

#define HLP_MSDP_SHOW_GLOBALSTATS               9637
#define HLP_MSDP_SHOW_GLOBALSTATS_EX            9638

#define HLP_MSDP_SHOW_SA                        9647
#define HLP_MSDP_SHOW_SA_EX                     9648

// Command usage messages
#define MSG_IP_USAGE                            10001
#define MSG_ROUTER_USAGE                        10002
#define MSG_MIB_USAGE                           10003
#define MSG_HELP_USAGE                          10004
#define MSG_HELPER_USAGE                        10005

// Output messages

        // MSDP messages
#define MSG_MSDP_GLOBAL_INFO                    20501
#define MSG_MSDP_PEER_HEADER                    20502
#define MSG_MSDP_PEER_INFO                      20503
#define MSG_MSDP_PEER_INFO_EX                   20504
#define MSG_MSDP_NO_PEER_INFO                   20505
#define MSG_MSDP_GLOBAL_STATS                   20506
#define MSG_MSDP_PEER_STATS_HEADER              20507
#define MSG_MSDP_PEER_STATS                     20508
#define MSG_MSDP_PEER_STATS_EX                  20509
#define MSG_MSDP_SA_INFO_HEADER                 20510
#define MSG_MSDP_SA_INFO                        20511
#define MSG_MSDP_SA_INFO_EX                     20512

        // VRRP messages    
#define MSG_VRRP_GLOBAL_INFO                    20831
#define MSG_VRRP_INTERFACE_INFO                 20832
#define MSG_VRRP_VRID_INFO                      20833
#define EMSG_INVALID_VRID                       20834

     // !@#
#define MSG_UNIDENTIFIED_MIB                    21500
#define MSG_INSUFFICIENT_ARGS                   21501
#define MSG_IP_ADDR_NOT_FOUND                   21502
#define MSG_IP_BAD_IP_ADDR                      21503
#define MSG_CANNOT_SET_INFO                     21504
#define MSG_IF_NBR_NOT_FOUND                    21506
#define MSG_CANT_FIND_EOPT                      21507
#define MSG_ERR_UPDATE                          21508
#define MSG_BAD_CMD                             21509
#define MSG_IP_BAD_SYNTAX                       21510
#define MSG_PROTOCOL_NOT_IN_TRANSPORT           21511
#define EMSG_NO_INTERFACE                       21512
#define MSG_NO_ENTRY_PT                         21514
#define MSG_DLL_LOAD_FAILED                     21515
#define MSG_NO_HELPER                           21516
#define MSG_NO_HELPERS                          21517
#define MSG_CREATE_CONSOLE_FAILED               21518
#define MSG_IF_NAME_HDR                         21519
#define MSG_RTR_STOPPED                         21520
#define MSG_IP_NO_FILTER_FOR_FRAG               21521
#define MSG_IP_TAG_NOT_PRESENT                  21522
#define MSG_IP_INVALID_TAG                      21523
#define EMSG_TAG_ALREADY_PRESENT                21524
#define EMSG_INTERFACE_EXISTS                   21525
#define EMSG_PROTO_NOT_INSTALLED                21526
#define MSG_IP_BAD_IP_MASK                      21527
#define MSG_CTRL_C_TO_QUIT                      21530

#define MSG_RIP_MIB_OPT                         21551
#define MSG_BOOTP_MIB_OPT                       21552

#define MSG_IP_RIP_ADD_USAGE                    21750
#define MSG_IP_RIP_ADD_IF_USAGE                 21751
#define MSG_IP_RIP_ADD_PEER_USAGE               21752
#define MSG_IP_RIP_ADD_ACCFILTER_USAGE          21753 
#define MSG_IP_RIP_ADD_ANNFILTER_USAGE          21754
#define MSG_IP_RIP_ADD_NEIGHBOR_USAGE           21755
#define MSG_IP_RIP_DEL_USAGE                    21756
#define MSG_IP_RIP_DEL_IF_USAGE                 21757
#define MSG_IP_RIP_DEL_PEER_USAGE               21758
#define MSG_IP_RIP_DEL_ACCFILTER_USAGE          21759 
#define MSG_IP_RIP_DEL_ANNFILTER_USAGE          21760
#define MSG_IP_RIP_DEL_NEIGHBOR_USAGE           21761

    // RIP MIB
#define MSG_RIP_MIB_GS                          22000
#define MSG_RIP_MIB_PS                          22001
#define MSG_RIP_MIB_PS_HDR                      22002
#define MSG_RIP_MIB_IFSTATS                     22003
#define MSG_RIP_MIB_IFSTATS_HDR                 22004
#define MSG_RIP_MIB_IFBIND_HDR                  22005
#define MSG_RIP_MIB_IFBIND                      22006
#define MSG_RIP_MIB_IFBIND_ADDR                 22007
#define MSG_RIP_MIB_LINE                        22008


    // DHCP relay agent messages
    
#define MSG_BOOTP_MIB_GC                        22051
#define MSG_BOOTP_MIB_DHCP_SERVER_HEADER        22052
#define MSG_BOOTP_MIB_DHCP_SERVER               22053
#define MSG_BOOTP_MIB_IF_CONFIG                 22054
#define MSG_BOOTP_MIB_IF_BINDING                22055
#define MSG_BOOTP_MIB_IF_ADDRESS_HEADER         22056
#define MSG_BOOTP_MIB_IF_ADDRESS                22057
#define MSG_BOOTP_MIB_IF_STATS                  22058


#define EMSG_PROTO_NO_GLOBAL_INFO               25010           
#define EMSG_PROTO_NO_IF_INFO                   25011
#define EMSG_IP_INVALID_PARAMETER               25030
#define EMSG_RSVD_KEYWORD                       25031

// BOOTP msg strings

#define MSG_IP_BOOTP_ADD_USAGE                  26001
#define MSG_IP_BOOTP_DEL_USAGE                  26002
#define MSG_IP_BOOTP_ADD_IF_USAGE               26003
#define MSG_IP_BOOTP_DEL_IF_USAGE               26004
#define MSG_IP_BOOTP_ADD_DHCP_SERVER_USAGE      26005
#define MSG_IP_BOOTP_DEL_DHCP_SERVER_USAGE      26006
#define MSG_IP_BOOTP_SET_GLOBAL_USAGE           26007
#define MSG_IP_BOOTP_SET_IF_USAGE               26008
#define MSG_IP_BOOTP_SHOW_GLOBAL_USAGE          26009
#define MSG_IP_BOOTP_SHOW_IF_USAGE              26010

// Strings

    // Protocol types
#define STRING_PROTO_OTHER                      33001
#define STRING_PROTO_LOCAL                      33002
#define STRING_PROTO_NETMGMT                    33003
#define STRING_PROTO_RIP                        33008
#define STRING_PROTO_OSPF                       33013
#define STRING_PROTO_BOOTP                      33015
#define STRING_PROTO_IGMP                       33017

    // transmission types
#define STRING_BROADCAST                        37001
#define STRING_NBMA                             37002
#define STRING_PT2PT                            37003

    // Miscellaneous strings
#define STRING_CREATED                          38001
#define STRING_DELETED                          38002
#define STRING_ENABLED                          38003
#define STRING_DISABLED                         38004
#define STRING_DEFAULT_ENABLED                  38005
#define STRING_DEFAULT_DISABLED                 38006

#define STRING_ON                               38010
#define STRING_OFF                              38012
#define STRING_YES                              38013
#define STRING_NO                               38014
#define STRING_Y                                38015
#define STRING_N                                38016
#define STRING_NONE                             38017

#define STRING_INPUT                            38031
#define STRING_OUTPUT                           38032
#define STRING_DIAL                             38033

#define STRING_DROP                             38041
#define STRING_FORWARD                          38042
#define STRING_ACCEPT                           38043

#define STRING_LOGGING_NONE                     38051
#define STRING_LOGGING_ERROR                    38052
#define STRING_LOGGING_WARN                     38053
#define STRING_LOGGING_INFO                     38054

#define STRING_FILTER_INCLUDE                   38061
#define STRING_FILTER_EXCLUDE                   38062

#define STRING_BOUND                            38071
#define STRING_BOUND_ENABLED                    38072
#define STRING_UNBOUND                          38073

//rip
#define STRING_RIP1                             38081
#define STRING_RIP1COMPAT                       38082
#define STRING_RIP2                             38083

#define STRING_PEER_ALSO                        38091
#define STRING_PEER_ONLY                        38092

#define STRING_PERIODIC                         38101
#define STRING_DEMAND                           38102

#define STRING_RIP_IF_ENABLED                   38103
#define STRING_RIP_IF_BOUND                     38104

#define STRING_FULL_XLATE                       38201
#define STRING_ADDRESS_XLATE                    38202
#define STRING_PRIVATE_XLATE                    38203
#define STRING_INBOUND                          38204
#define STRING_OUTBOUND                         38205
#define STRING_DEFAULT_INTERFACE                38206
#define STRING_TCP                              38207
#define STRING_UDP                              38208

#define STRING_AUTH_NONE                        38211
#define STRING_AUTH_SIMPLEPASSWD                38212
#define STRING_AUTH_IPHEADER                    38213

// TCP Connection Engine states
#define STRING_IDLE                             40000
#define STRING_CONNECT                          40001
#define STRING_ACTIVE                           40002
#define STRING_OPENSENT                         40003
#define STRING_OPENCONFIRM                      40004
#define STRING_ESTABLISHED                      40005


#define STRING_UNKNOWN                          50001




// Error messages
#define MSG_IP_CANNOT_GET_INTERFACE_INFO        60001
#define MSG_IP_NO_INTERFACE_INFO                60002
#define MSG_IP_NO_ROUTE_INFO                    60003
#define MSG_IP_INVALID_OPTION_LENGTH            60005
#define MSG_IP_DIM_ERROR                        60006
#define MSG_IP_PARAMETER_ERROR                  60007
#define MSG_IP_NO_CMD                           60008
#define MSG_IP_NOT_ENOUGH_PARAMETERS            60009
#define MSG_IP_CAN_NOT_QUERY_ROUTER             60012
#define MSG_IP_ROUTER_NOT_RUNNING               60013
#define MSG_IP_CAN_NOT_CONNECT_DIM              60014
#define MSG_IP_NO_ENTRIES                       60015
#define EMSG_CORRUPT_INFO                       60016
#define MSG_IP_NO_GLOBAL_INFO                   60017
#define MSG_IP_CAN_NOT_GET_GLOBAL_INFO          60018
#define MSG_IP_NO_RTRPRIO_INFO                  60019
#define MSG_IP_NO_RTR_DISC_INFO                 60020
#define MSG_IP_NO_CONNECT_CONFIG                60021
#define MSG_IP_CONFIG_ERROR                     60022
#define MSG_IP_ADMIN_ERROR                      60023
#define EMSG_NOT_ENOUGH_MEMORY                  60024
#define EMSG_BAD_OPTION_VALUE                   60025
#define MSG_IP_NO_INPUT_FILTER                  60026
#define MSG_IP_NO_OUTPUT_FILTER                 60027

#define MSG_IP_SPECIFY_INTERFACE                60061
#define MSG_IP_MODE_ONLY_FOR_DNSPROXY           60062

#define MSG_IP_AREA_NOT_SPECIFIED               60101
#define MSG_IP_TRANSIT_AREA_NOT_SPECIFIED       60102
#define MSG_IP_AREA_NOT_FOUND                   60103

#define MSG_IP_INTERFACE_NOT_SPECIFIED          60111
#define MSG_IP_INTERFACE_NOT_FOUND              60112

#define MSG_IP_NEIGHBOR_NOT_SPECIFIED           60113
#define MSG_IP_NEIGHBOR_NOT_FOUND               60114

#define MSG_IP_NO_PREF_FOR_PROTOCOL_ID          60121       
#define MSG_IP_ROUTE_PREF_LEVEL_EXISTS          60122
#define MSG_IP_ROUTE_PREF_LEVEL_NOT_FOUND       60123


#define MSG_IP_AREA_NO_BACKBONE                 60201
#define MSG_IP_VI_NO_BACKBONE                   60202
#define MSG_IP_BAD_TRANSIT_AREA                 60203
#define MSG_IP_STUB_TRANSIT_AREA                60204
#define MSG_IP_TRANSIT_AREA_NOT_FOUND           60205
#define MSG_IP_BAD_RANGE                        60206
#define MSG_IP_NO_GLOBAL_PARAM                  60207
#define MSG_IP_NO_AREA                          60208

#define MSG_IP_NAT_NO_ADDRESS_POOL              60251
#define MSG_IP_NAT_NO_ADDRESS_RANGE             60252
#define MSG_IP_NAT_ADDRESS_MAPPING_NEEDS_RANGE  60253
#define MSG_IP_NAT_PORT_MAPPING_NEEDS_RANGE     60254
#define MSG_IP_NAT_BAD_RANGE_END                60255
#define MSG_IP_AUTODHCP_BAD_EXCLUSION           60256
#define MSG_IP_NAT_ADDRESS_MAPPING_INVALID      60257
#define MSG_IP_NAT_PORT_MAPPING_INVALID         60258

// igmp
#define EMSG_STATIC_MGM_GROUP_FOR_PROXY         60301
#define EMSG_STATIC_GROUP_EXISTS                60302
#define EMSG_STATIC_GROUP_NOT_FOUND             60303

#define MSG_IP_AREA_DELETED                     61001

//
// Error messages for mib calls
//

#define HLP_RIP_MIB_OBJECT_STATS                63001
#define HLP_RIP_MIB_OBJECT_STATS_EX             63002
#define HLP_RIP_MIB_OBJECT_IFSTATS              63003
#define HLP_RIP_MIB_OBJECT_IFSTATS_EX           63004
#define HLP_RIP_MIB_OBJECT_IFBINDING            63005
#define HLP_RIP_MIB_OBJECT_IFBINDING_EX         63006
#define HLP_RIP_MIB_OBJECT_PEERSTATS            63007
#define HLP_RIP_MIB_OBJECT_PEERSTATS_EX         63008

#define HLP_BOOTP_MIB_OBJECT_GLOBAL_CONFIG      63301
#define HLP_BOOTP_MIB_OBJECT_GLOBAL_CONFIG_EX   63302
#define HLP_BOOTP_MIB_OBJECT_IF_CONFIG          63303
#define HLP_BOOTP_MIB_OBJECT_IF_CONFIG_EX       63304
#define HLP_BOOTP_MIB_OBJECT_IF_BINDING         63305
#define HLP_BOOTP_MIB_OBJECT_IF_BINDING_EX      63306
#define HLP_BOOTP_MIB_OBJECT_IF_STATS           63307
#define HLP_BOOTP_MIB_OBJECT_IF_STATS_EX        63308

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ip\preview\utils.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    routing\monitor2\ip\utils.c

Abstract:

     Utility functions

Revision History:

    Anand Mahalingam         7/10/98  Created

--*/

#include "precomp.h"
#pragma hdrstop

#define MIB_REFRESH_EVENT   L"MIBEvent"

DWORD
GetDisplayStringT (
    IN  HANDLE  hModule,
    IN  DWORD   dwValue,
    IN  PVALUE_TOKEN ptvTable,
    IN  DWORD   dwNumArgs,
    OUT PWCHAR  *ppwszString
    )
{
    DWORD i, dwErr = NO_ERROR ;

    for (i=0;  i<dwNumArgs;  i++)
    {
        if ( dwValue == ptvTable[i].dwValue )
        {
            *ppwszString = HeapAlloc( GetProcessHeap(), 0,
                 (wcslen(ptvTable[i].pwszToken)+1) * sizeof(WCHAR) );
                                    
            wcscpy(*ppwszString, ptvTable[i].pwszToken);
            break;
        }
    }

    if (i == dwNumArgs)
        *ppwszString = MakeString( hModule, STRING_UNKNOWN ) ;

    if (!ppwszString)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY ;
        DisplayError( hModule, dwErr ) ;
    }
    
    return dwErr ;
}

DWORD
GetDisplayString (
    IN  HANDLE  hModule,
    IN  DWORD   dwValue,
    IN  PVALUE_STRING ptvTable,
    IN  DWORD   dwNumArgs,
    OUT PWCHAR  *ppwszString
    )
{
    DWORD i, dwErr = NO_ERROR ;

    for (i=0;  i<dwNumArgs;  i++)
    {
        if ( dwValue == ptvTable[i].dwValue )
        {
            *ppwszString = MakeString( hModule, ptvTable[i].dwStringId ) ;
            break;
        }
    }

    if (i == dwNumArgs)
        *ppwszString = MakeString( hModule, STRING_UNKNOWN ) ;

    if (!ppwszString)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY ;
        DisplayError( hModule, dwErr ) ;
    }
    
    return dwErr ;
}

DWORD
GetAltDisplayString(
    HANDLE        hModule, 
    HANDLE        hFile,
    DWORD         dwValue,
    PVALUE_TOKEN  vtTable,
    PVALUE_STRING vsTable,
    DWORD         dwNumArgs,
    PTCHAR       *pptszString)
{
    if (hFile) 
    {
        return GetDisplayStringT(hModule,
                dwValue,
                vtTable,
                dwNumArgs,
                pptszString) ;
    } 
    else 
    {
        return GetDisplayString(hModule,
                dwValue,
                vsTable,
                dwNumArgs,
                pptszString) ;
    }
}
    
#if 0
DWORD
DispTokenErrMsg(
    IN  HANDLE  hModule,
    IN  DWORD   dwMsgId,
    IN  DWORD   dwTagId,
    IN  LPCWSTR pwszValue
    )
/*++

Routine Description:

    Displays error message with token arguments.

Arguments:

    dwMsgId  - Message to be printed
    dwTagId  - The tag string id
    pwszValue - the value specified for the tag in the command

Return Value:

    NO_ERROR

--*/

{
    PWCHAR    pwszTag;

    pwszTag = MakeString(hModule,
                         dwTagId);

    DisplayMessage(hModule,
                   dwMsgId,
                   pwszValue,
                   pwszTag);

    FreeString(pwszTag);

    return NO_ERROR;
}
#endif

DWORD
GetMibTagToken(
    IN    LPCWSTR   *ppwcArguments,
    IN    DWORD     dwArgCount,
    IN    DWORD     dwNumIndices,
    OUT   PDWORD    pdwRR,
    OUT   PBOOL     pbIndex,
    OUT   PDWORD    pdwIndex
    )
/*++

Routine Description:

    Looks for indices and refresh rate arguments in the command. If index
    tag is present, it would be of the form index= index1 index2 ....
    The index= is removed by this function. So is rr= if it is there in
    the command. If pdwRR is 0 then, no refresh sought.
    
Arguments:

    pptcArguments  - The argument array. Each argument has tag=value form
    dwCurrentIndex - pptcArguments[dwCurrentIndex] is first arg.
    dwArgCount     - pptcArguments[dwArgCount - 1] is last arg.
    pttTagToken    - Array of tag token ids that are allowed in the args
    dwNumTags      - Size of pttTagToken
    pdwOut         - Array identifying the type of each argument.

Return Value:

    NO_ERROR, ERROR_INVALID_PARAMETER, ERROR_INVALID_OPTION_TAG
    
--*/
{
    DWORD    i;
    BOOL     bTag;

    if (dwArgCount is 0)
    {
        *pdwRR = 0;
        *pbIndex = FALSE;
        
        return NO_ERROR;
    }

    if (dwArgCount < dwNumIndices)
    {
        //
        // No index
        //
        
        *pbIndex = FALSE;

        if (dwArgCount > 1)
        {
            *pdwRR = 0;
            
            return ERROR_INVALID_PARAMETER;
        }
        
        //
        // No Index specified. Make sure refresh rate is specified
        // with tag.
        //

        if (_wcsnicmp(ppwcArguments[0],L"RR=",3) == 0)
        {
            //
            // remove tag and get the refresh rate
            //

            wcscpy(ppwcArguments[0], &ppwcArguments[0][3]);

            *pdwRR = wcstoul(ppwcArguments[0], NULL, 10);
        }
        else
        {
            return ERROR_INVALID_PARAMETER;
        }
    }
    else
    {
        //
        // Check for index tag
        //

        if (_wcsnicmp(ppwcArguments[0],L"INDEX=",6) == 0)
        {
            *pbIndex = TRUE;
            *pdwIndex = 0;

            //
            // remove tag and see if refresh rate is specified
            //

            wcscpy(ppwcArguments[0], &ppwcArguments[0][6]);

            if (dwArgCount > dwNumIndices)
            {
                //
                // Make sure that argument has RR tag
                //

                if (_wcsnicmp(ppwcArguments[dwNumIndices],L"RR=",3) == 0)
                {
                    //
                    // remove tag and get the refresh rate
                    //

                    wcscpy(ppwcArguments[dwNumIndices],
                           &ppwcArguments[dwNumIndices][3]);

                    *pdwRR = wcstoul(ppwcArguments[dwNumIndices], NULL , 10);
                }
                else
                {
                    return ERROR_INVALID_PARAMETER;
                }
            }
            else
            {
                //
                // No refresh rate specified
                //

                *pdwRR = 0;
                return NO_ERROR;
            }
        }
        else
        {
            //
            // Not index tag, See if it has an RR tag
            // 

            if (_wcsnicmp(ppwcArguments[0],L"RR=",3) == 0)
            {
                //
                // remove tag and get the refresh rate
                //

                wcscpy(ppwcArguments[0], &ppwcArguments[0][3]);

                *pdwRR = wcstoul(ppwcArguments[0], NULL , 10);

                //
                // See if the index follows
                //

                if (dwArgCount > dwNumIndices)
                {
                    if (dwArgCount > 1)
                    {
                        if (_wcsnicmp(ppwcArguments[1],L"INDEX=",6) == 0)
                        {
                            wcscpy(ppwcArguments[1], &ppwcArguments[1][6]);
                            *pbIndex = TRUE;
                            *pdwIndex = 1;
                            
                            return NO_ERROR;
                        }
                        else
                        {
                            *pdwRR = 0;
                            return ERROR_INVALID_PARAMETER;
                        }
                    }
                    else
                    {
                        return NO_ERROR;
                    }
                }
            }
            //
            // No RR Tag either
            //
            else if (dwArgCount > dwNumIndices)
            {
                //
                // Assume ppwcArguments[dwNumIndices] is the refresh rate
                //

                *pdwRR = wcstoul(ppwcArguments[dwNumIndices], NULL , 10);

                if (dwNumIndices != 0)
                {
                    *pbIndex = TRUE;
                    *pdwIndex = 0;
                }
            }
            else
            {
                //
                // only index present with no tag
                //
                *pbIndex = TRUE;
                *pdwIndex = 0;
            }
        }
    }

    return NO_ERROR;
}

DWORD
GetIpAddress(
    PTCHAR    pptcArg
    )
/*++

Routine Description:

    Gets the ip address from the string.
    
Arguments:

    pwszIpAddr - Ip address string
    
Return Value:
    
    ip address
    
--*/
{
    CHAR     pszIpAddr[ADDR_LENGTH+1];

    WideCharToMultiByte(GetConsoleOutputCP(),
                        0,
                        pptcArg,
                        -1,
                        pszIpAddr,
                        ADDR_LENGTH,
                        NULL,
                        NULL);

    pszIpAddr[ADDR_LENGTH] = '\0';
                
    return (DWORD) inet_addr(pszIpAddr);
}          

BOOL WINAPI HandlerRoutine(
    DWORD dwCtrlType   //  control signal type
    )
{
    HANDLE hMib;
    
    if (dwCtrlType == CTRL_C_EVENT)
    {
        hMib = OpenEvent(EVENT_ALL_ACCESS,FALSE,MIB_REFRESH_EVENT);

        SetEvent(hMib);
    }

    return TRUE;
    
}



DWORD
GetInfoBlockFromInterfaceInfoEx(
    IN  LPCWSTR pwszIfName,
    IN  DWORD   dwType,
    OUT BYTE    **ppbInfoBlk,   OPTIONAL
    OUT PDWORD  pdwSize,        OPTIONAL
    OUT PDWORD  pdwCount,       OPTIONAL
    OUT PDWORD  pdwIfType       OPTIONAL
    )
/*++

Routine Description:
    calls GetInfoBlockFromInterfaceInfo and dumps error message if there is an
    error.

--*/
{
    DWORD dwErr;
    
    //
    // get current interface config
    //
    
    dwErr = IpmontrGetInfoBlockFromInterfaceInfo(pwszIfName,
                                            dwType,
                                            ppbInfoBlk,
                                            pdwSize,
                                            pdwCount,
                                            pdwIfType);
                                   
    switch(dwErr)
    {
        case NO_ERROR:
            break;

        case ERROR_NOT_FOUND:
            DisplayMessage(g_hModule,EMSG_PROTO_NO_IF_INFO);
            break;

        case ERROR_INVALID_PARAMETER:
            DisplayMessage(g_hModule,EMSG_CORRUPT_INFO);
            break;
            
        case ERROR_NOT_ENOUGH_MEMORY:
            DisplayMessage(g_hModule,EMSG_NOT_ENOUGH_MEMORY);
            break;

        default:
            DisplayError(g_hModule, dwErr);
            break;
    }

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ip\preview\vrrphlpcfg.c ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    routing\netsh\ip\protocols\vrrphlpcfg.c

Abstract:

    Virtual Router Redundancy Protocol configuration implementation.
    This module contains configuration routines which are relied upon
    by vrrphlpopt.c. The routines retrieve, update, and display
    the configuration for the VRRP protocol.

    This file also contains default configuration settings
    for VRRP.

    N.B. The display routines require special attention since display
    may result in a list of commands sent to a 'dump' file, or in a
    textual presentation of the configuration to a console window.
    In the latter case, we use non-localizable output routines to generate
    a script-like description of the configuration. In the former case,
    we use localizable routines to generate a human-readable description.

Author:

    Peeyush Ranjan (peeyushr)   3-Mar-1999

Revision History:

--*/


#include "precomp.h"
#pragma hdrstop


#define Malloc(x) HeapAlloc(GetProcessHeap(), 0, (x))
#define Free(x) HeapFree(GetProcessHeap(), 0, (x))

static  VRRP_GLOBAL_CONFIG
g_VrrpGlobalDefault =
{
    VRRP_LOGGING_ERROR
};

static PUCHAR g_pVrrpGlobalDefault = (PUCHAR)&g_VrrpGlobalDefault;

static VRRP_IF_CONFIG g_VrrpInterfaceDefault = 
{ 
    0
};

static VRRP_VROUTER_CONFIG g_VrrpVrouterDefault = 
{
    1,
    100,
    1,
    1,
    0,
    0,
    {0,0,0,0,0,0,0,0
    },
    0
};


//
// Forward declarations
//
ULONG
ValidateVrrpInterfaceInfo(
    PVRRP_IF_CONFIG InterfaceInfo
    );

BOOL
FoundIpAddress(
    DWORD IPAddress
    );

//
// What follows are the arrays used to map values to strings and
// to map values to tokens. These, respectively, are used in the case
// where we are displaying to a 'dump' file and to a console window.
//
VALUE_STRING VrrpGlobalLogginStringArray[] = {
    VRRP_LOGGING_NONE, STRING_LOGGING_NONE,
    VRRP_LOGGING_ERROR, STRING_LOGGING_ERROR,
    VRRP_LOGGING_WARN, STRING_LOGGING_WARN,
    VRRP_LOGGING_INFO, STRING_LOGGING_INFO
};

VALUE_TOKEN VrrpGlobalLogginTokenArray[] = {
    VRRP_LOGGING_NONE, TOKEN_OPT_VALUE_NONE,
    VRRP_LOGGING_ERROR, TOKEN_OPT_VALUE_ERROR,
    VRRP_LOGGING_WARN, TOKEN_OPT_VALUE_WARN,
    VRRP_LOGGING_INFO, TOKEN_OPT_VALUE_INFO
};

VALUE_STRING VrrpAuthModeStringArray[] = {
    VRRP_AUTHTYPE_NONE, STRING_AUTH_NONE,
    VRRP_AUTHTYPE_PLAIN, STRING_AUTH_SIMPLEPASSWD,
    VRRP_AUTHTYPE_IPHEAD, STRING_AUTH_IPHEADER
};

VALUE_TOKEN VrrpAuthModeTokenArray[] = {
    VRRP_AUTHTYPE_NONE, TOKEN_OPT_VALUE_AUTH_NONE,
    VRRP_AUTHTYPE_PLAIN, TOKEN_OPT_VALUE_AUTH_SIMPLE_PASSWORD,
    VRRP_AUTHTYPE_IPHEAD, TOKEN_OPT_VALUE_AUTH_MD5
};

VALUE_STRING VrrpPreemptModeStringArray[] = {
    TRUE, STRING_ENABLED,
    FALSE, STRING_DISABLED
};

VALUE_TOKEN VrrpPreemptModeTokenArray[] = {
    TRUE, TOKEN_OPT_VALUE_ENABLE,
    FALSE,TOKEN_OPT_VALUE_DISABLE
};

typedef enum {
    VrrpGlobalLoggingModeIndex,
    VrrpAuthModeIndex,
    VrrpPreemptModeIndex
} DISPLAY_VALUE_INDEX;




PTCHAR
QueryValueString(
    HANDLE FileHandle,
    DISPLAY_VALUE_INDEX Index,
    ULONG Value
    )
{
    ULONG Count;
    ULONG Error;
    PTCHAR String = NULL;
    PVALUE_STRING StringArray;
    PVALUE_TOKEN TokenArray;
    switch (Index) {
        case VrrpGlobalLoggingModeIndex:
            Count = NUM_VALUES_IN_TABLE(VrrpGlobalLogginStringArray);
            StringArray = VrrpGlobalLogginStringArray;
            TokenArray = VrrpGlobalLogginTokenArray;
            break;
        case VrrpAuthModeIndex:
            Count = NUM_VALUES_IN_TABLE(VrrpAuthModeStringArray);
            StringArray = VrrpAuthModeStringArray;
            TokenArray = VrrpAuthModeTokenArray;
            break;
        case VrrpPreemptModeIndex:
            Count = NUM_VALUES_IN_TABLE(VrrpPreemptModeStringArray);
            StringArray = VrrpPreemptModeStringArray;
            TokenArray = VrrpPreemptModeTokenArray;
            break;
         default:
            return NULL;
    }
    Error =
        GetAltDisplayString(
            g_hModule,
            FileHandle,
            Value,
            TokenArray,
            StringArray,
            Count,
            &String
            );
    return Error ? NULL : String;
}



ULONG
MakeVrrpGlobalInfo(
    OUT PUCHAR* GlobalInfo,
    OUT PULONG GlobalInfoSize
    )
{
    *GlobalInfoSize = sizeof(VRRP_GLOBAL_CONFIG);
    *GlobalInfo = Malloc(*GlobalInfoSize);
    if (!*GlobalInfo) {
        DisplayMessage(g_hModule, EMSG_NOT_ENOUGH_MEMORY);
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    CopyMemory(*GlobalInfo, g_pVrrpGlobalDefault, *GlobalInfoSize);
    return NO_ERROR;
}

ULONG
CreateVrrpGlobalInfo(
    OUT PVRRP_GLOBAL_CONFIG* GlobalInfo,
    IN  DWORD LoggingLevel
    )
{
    DWORD GlobalInfoSize;
    GlobalInfoSize = sizeof(PVRRP_GLOBAL_CONFIG);
    *GlobalInfo = Malloc(GlobalInfoSize);
    if (!*GlobalInfo) {
        DisplayMessage(g_hModule, EMSG_NOT_ENOUGH_MEMORY);
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    CopyMemory(*GlobalInfo, g_pVrrpGlobalDefault, GlobalInfoSize);
    (*GlobalInfo)->LoggingLevel = LoggingLevel;

    return NO_ERROR;
}

ULONG
MakeVrrpInterfaceInfo(
    ROUTER_INTERFACE_TYPE InterfaceType,
    OUT PUCHAR* InterfaceInfo,
    OUT PULONG InterfaceInfoSize
    )
{
    //
    //Why is this check done?
    //            
    if (InterfaceType != ROUTER_IF_TYPE_DEDICATED) {
        return ERROR_INVALID_PARAMETER;
    }

    *InterfaceInfoSize = sizeof(VRRP_IF_CONFIG);
    *InterfaceInfo = Malloc(*InterfaceInfoSize);
    if (!*InterfaceInfo) {
        DisplayMessage(g_hModule, EMSG_NOT_ENOUGH_MEMORY);
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    CopyMemory(*InterfaceInfo, &g_VrrpInterfaceDefault, *InterfaceInfoSize);
    return NO_ERROR;
}

ULONG
MakeVrrpVRouterInfo(
    IN OUT PUCHAR VRouterInfo
    )
{
    //
    // Always assumed that the space has been preassigned
    //
    if (!VRouterInfo) {
        return ERROR_INVALID_PARAMETER;
    }
    CopyMemory(VRouterInfo,&g_VrrpVrouterDefault,sizeof(g_VrrpVrouterDefault));
    return NO_ERROR;    
}


ULONG
ShowVrrpGlobalInfo(
    HANDLE FileHandle
    )
{
    ULONG Count = 0;
    ULONG Error;
    PVRRP_GLOBAL_CONFIG GlobalInfo = NULL;
    ULONG i;
    PTCHAR LoggingLevel = NULL;
    ULONG Size;
    do {
        //
        // Retrieve the global configuration for the VRRP,
        // and format its contents to the output file or console.
        //
        Error =
            IpmontrGetInfoBlockFromGlobalInfo(
                MS_IP_VRRP,
                (PUCHAR*)&GlobalInfo,
                &Size,
                &Count
                );
        if (Error) {
            break;
        } else if (!(Count * Size)) {
            Error = ERROR_NOT_FOUND; break;
        }
        LoggingLevel =
            QueryValueString(
                FileHandle, VrrpGlobalLoggingModeIndex, GlobalInfo->LoggingLevel
                );
        if (!LoggingLevel) { break; }
        if (FileHandle) {
            DisplayMessageT(DMP_VRRP_INSTALL);
            DisplayMessageT(
                DMP_VRRP_SET_GLOBAL,
                TOKEN_OPT_LOGGINGLEVEL, LoggingLevel
                );
        } else {
            DisplayMessage(
                g_hModule,
                MSG_VRRP_GLOBAL_INFO,
                LoggingLevel
                );
        }
    } while(FALSE);
    
    if (LoggingLevel) { Free(LoggingLevel); }
    if (GlobalInfo) { Free(GlobalInfo); }
    if (!FileHandle && Error) {
        if (Error == ERROR_NOT_FOUND) {
            DisplayMessage(g_hModule, EMSG_PROTO_NO_GLOBAL_INFO);
        } else {
            DisplayError(g_hModule, Error);
        }
    }
    return Error;
}

ULONG
ShowVrrpAllInterfaceInfo(
    HANDLE FileHandle
    )
{
    DWORD               dwErr, dwCount, dwTotal;
    DWORD               dwNumParsed, i, dwNumBlocks=1, dwSize, dwIfType;
    PBYTE               pBuffer;
    PMPR_INTERFACE_0    pmi0;
    WCHAR               wszIfDesc[MAX_INTERFACE_NAME_LEN + 1];

    //
    // dump vrrp config for all interfaces
    //

    dwErr = IpmontrInterfaceEnum((PBYTE *) &pmi0,
                          &dwCount,
                          &dwTotal);

    if(dwErr != NO_ERROR)
    {
        DisplayError(g_hModule,
                     dwErr);
        return dwErr;
    }

    for(i = 0; i < dwCount; i++)
    {
        // make sure that vrrp is configured on that interface

        dwErr = IpmontrGetInfoBlockFromInterfaceInfo(pmi0[i].wszInterfaceName,
                                            MS_IP_VRRP,
                                            &pBuffer,
                                            &dwSize,
                                            &dwNumBlocks,
                                            &dwIfType);
        if (dwErr != NO_ERROR) {
            continue;
        }
        else {
            HEAP_FREE(pBuffer) ;
        }


        ShowVrrpInterfaceInfo(FileHandle, pmi0[i].wszInterfaceName);
    }
    return NO_ERROR;
}

ULONG
ShowVrrpInterfaceInfo(
    HANDLE FileHandle,
    PWCHAR InterfaceName
    )
{
    ULONG Count = 0;
    ULONG Error;
    PVRRP_IF_CONFIG InterfaceInfo;
    PTCHAR AuthType = NULL;
    ULONG Size;
    ULONG dwLength;
    TCHAR Title[MAX_INTERFACE_NAME_LEN + 1];
    ROUTER_INTERFACE_TYPE Type;
    ULONG Index;
    ULONG IPIndex;
    BYTE Password[VRRP_MAX_AUTHKEY_SIZE];
    PTCHAR IPAddresses = NULL;
    TCHAR Address[VRRP_IPADDR_LENGTH+1];
    PVRRP_VROUTER_CONFIG PVrouter;
    PTCHAR PreemptMode = NULL;

    do {
        //
        // Retrieve the interface's configuration
        // and format it to the output file or console.
        //
        Error =
            IpmontrGetInfoBlockFromInterfaceInfo(
                InterfaceName,
                MS_IP_VRRP,
                (PUCHAR*)&InterfaceInfo,
                &Size,
                &Count,
                &Type
                );
        if (Error) {
            break;
        } else if (!(Count * Size)) {
            Error = ERROR_NOT_FOUND; break;
        }
        Size = sizeof(Title);
        Error = IpmontrGetFriendlyNameFromIfName(InterfaceName, Title, &Size);
        if (Error) {
            Error = ERROR_NO_SUCH_INTERFACE;
            break;
        }             
        if (FileHandle) {
            DisplayMessage(g_hModule, DMP_VRRP_INTERFACE_HEADER, Title);
            DisplayMessageT(DMP_VRRP_ADD_INTERFACE,
                           TOKEN_OPT_NAME, Title);
            if (InterfaceInfo->VrouterCount) {                
                for (Index = 0 , PVrouter = VRRP_FIRST_VROUTER_CONFIG(InterfaceInfo);
                     Index < InterfaceInfo->VrouterCount; 
                     Index++ , PVrouter = VRRP_NEXT_VROUTER_CONFIG(PVrouter)) {
                    for (IPIndex = 0; IPIndex < PVrouter->IPCount;
                         IPIndex++) {
                        IP_TO_TSTR(Address,
                                   &PVrouter->IPAddress[IPIndex]
                                   );
                        DisplayMessageT(
                            DMP_VRRP_ADD_VRID,
                            TOKEN_OPT_NAME, Title,
                            TOKEN_OPT_VRID, PVrouter->VRID,
                            TOKEN_OPT_IPADDRESS, Address
                            );
                    }

                    AuthType =
                        QueryValueString(
                            FileHandle, VrrpAuthModeIndex, 
                            PVrouter->AuthenticationType
                            );
                    if (!AuthType) {
                        Error = ERROR_INVALID_PARAMETER;
                        break;
                    }
                    CopyMemory(Password,PVrouter->AuthenticationData,
                               VRRP_MAX_AUTHKEY_SIZE);
                    DisplayMessageT(
                        DMP_VRRP_SET_INTERFACE,
                        TOKEN_OPT_NAME, Title,
                        TOKEN_OPT_VRID, PVrouter->VRID,
                        TOKEN_OPT_AUTH, 
                        (PVrouter->AuthenticationType == VRRP_AUTHTYPE_NONE) ? 
                        TOKEN_OPT_VALUE_AUTH_NONE : ((PVrouter->AuthenticationType 
                        == VRRP_AUTHTYPE_PLAIN) ? TOKEN_OPT_VALUE_AUTH_SIMPLE_PASSWORD :
                        TOKEN_OPT_VALUE_AUTH_MD5 ) ,
                        TOKEN_OPT_PASSWD, Password[0], Password[1], Password[2],
                        Password[3], Password[4], Password[5],Password[6], Password[7],
                        TOKEN_OPT_ADVTINTERVAL, PVrouter->AdvertisementInterval,
                        TOKEN_OPT_PRIO,PVrouter->ConfigPriority,
                        TOKEN_OPT_PREEMPT, PVrouter->PreemptMode? TOKEN_OPT_VALUE_ENABLE :
                                           TOKEN_OPT_VALUE_DISABLE
                        );
                }
            }
        } else {
            DisplayMessage(g_hModule, MSG_VRRP_INTERFACE_INFO,Title, 
                           InterfaceInfo->VrouterCount);
            for (Index = 0, PVrouter = VRRP_FIRST_VROUTER_CONFIG(InterfaceInfo);
                 Index < InterfaceInfo->VrouterCount; 
                 Index++, PVrouter = VRRP_NEXT_VROUTER_CONFIG(PVrouter)) {
               AuthType =
                  QueryValueString(
                      FileHandle, VrrpAuthModeIndex, 
                      PVrouter->AuthenticationType
                      );
               if (!AuthType) {
                   Error = ERROR_INVALID_PARAMETER;
                   break;
               }
               CopyMemory(Password,PVrouter->AuthenticationData,
                          VRRP_MAX_AUTHKEY_SIZE);
               //
               // Allocate space for each IP address, a space+comma each and also a 
               // null terminator
               //
               IPAddresses = Malloc(dwLength = (((VRRP_IPADDR_LENGTH+2)*sizeof(TCHAR)*
                                    PVrouter->IPCount)+1));
               if (!IPAddresses) {
                   DisplayMessage(g_hModule, EMSG_NOT_ENOUGH_MEMORY);

                   //
                   // Set AuthType to 0 which will cause a break from the outer loop
                   //

                   AuthType = 0;
                   Error = ERROR_NOT_ENOUGH_MEMORY;
                   break;                        
               }
               ZeroMemory(IPAddresses,dwLength);
               //
               // Now build the IP address list from the addresses given
               //
               for (IPIndex = 0; IPIndex < PVrouter->IPCount; IPIndex++ ) {
                   IP_TO_TSTR(Address,&PVrouter->IPAddress[IPIndex]);
                   wcscat(IPAddresses,Address);
                   if (IPIndex != (ULONG)(PVrouter->IPCount-1)) {
                       wcscat(IPAddresses,L", ");
                   }
               }
               PreemptMode =
               QueryValueString(
                   FileHandle,
                   VrrpPreemptModeIndex,
                   PVrouter->PreemptMode
                   );
               if (!PreemptMode) { break; }

               DisplayMessage(
                    g_hModule,
                    MSG_VRRP_VRID_INFO,
                    PVrouter->VRID,
                    IPAddresses,
                    AuthType,
                    Password[0], Password[1], Password[2], Password[3],
                    Password[4], Password[5], Password[6], Password[7],
                    PVrouter->AdvertisementInterval,
                    PVrouter->ConfigPriority,
                    PreemptMode
                    );
            }
        }
        if (!AuthType) {
            break;
        }
        Error = NO_ERROR;
    } while(FALSE);
    if (AuthType) { Free(AuthType); }
    Free(InterfaceInfo);
    if (IPAddresses) Free(IPAddresses);
    if (!FileHandle && Error) {
        if (Error == ERROR_NOT_FOUND) {
            DisplayMessage(g_hModule, EMSG_PROTO_NO_IF_INFO);
        } else {
            DisplayError(g_hModule, Error);
        }
    }
    return Error;
}

ULONG
UpdateVrrpGlobalInfo(
    PVRRP_GLOBAL_CONFIG GlobalInfo    
    )
{
    ULONG Count;
    ULONG Error;
    PVRRP_GLOBAL_CONFIG NewGlobalInfo = NULL;
    PVRRP_GLOBAL_CONFIG OldGlobalInfo = NULL;
    ULONG Size;
    
    do {
        //
        // Retrieve the existing global configuration.
        //
        Error =
            IpmontrGetInfoBlockFromGlobalInfo(
                MS_IP_VRRP,
                (PUCHAR*)&OldGlobalInfo,
                &Size,
                &Count
                );
        if (Error) {
            break;
        } else if (!(Count * Size)) {
            Error = ERROR_NOT_FOUND; break;
        }

        //
        // Allocate a new structure, copy to it the original configuration,
        //

        NewGlobalInfo = Malloc(Count * Size);
        if (!NewGlobalInfo) { Error = ERROR_NOT_ENOUGH_MEMORY; break; }
        CopyMemory(NewGlobalInfo, OldGlobalInfo, Count * Size);
        
        //
        // Based on the changes requested, change the NewGlobalInfo.
        // Since for VRRP there is only the logging level to change, we just set that.
        //
        
        NewGlobalInfo->LoggingLevel = GlobalInfo->LoggingLevel;
        
        Error =
            IpmontrSetInfoBlockInGlobalInfo(
                MS_IP_VRRP,
                (PUCHAR)NewGlobalInfo,
                FIELD_OFFSET(IP_NAT_GLOBAL_INFO, Header) +
                Count * Size,
                1
                );
    } while(FALSE);
    if (NewGlobalInfo) { Free(NewGlobalInfo); }
    if (OldGlobalInfo) { Free(OldGlobalInfo); }
    if (Error == ERROR_NOT_FOUND) {
        DisplayMessage(g_hModule, EMSG_PROTO_NO_GLOBAL_INFO);
    } else if (Error) {
        DisplayError(g_hModule, Error);
    }
    return Error;
}


ULONG
UpdateVrrpInterfaceInfo(
    PWCHAR InterfaceName,
    PVRRP_VROUTER_CONFIG VRouterInfo,
    ULONG BitVector,
    BOOL AddInterface
    )
{
    ULONG Count;
    ULONG Error;
    PVRRP_IF_CONFIG NewInterfaceInfo = NULL;
    PVRRP_IF_CONFIG OldInterfaceInfo = NULL;
    PVRRP_VROUTER_CONFIG PVrouter = NULL;
    ULONG Size;
    ROUTER_INTERFACE_TYPE Type;
    ULONG i;

    if (!AddInterface && !BitVector) { return NO_ERROR; }
    do {
        //
        // Retrieve the existing interface configuration.
        // We will update this block below, as well as adding to or removing
        // from it depending on the flags specified in 'BitVector'.
        //
        Error =
            IpmontrGetInfoBlockFromInterfaceInfo(
                InterfaceName,
                MS_IP_VRRP,
                (PUCHAR*)&OldInterfaceInfo,
                &Size,
                &Count,
                &Type
                );
        if (Error) {
            //
            // No existing configuration is found. This is an error unless
            // we are adding the interface anew, in which case we just
            // create for ourselves a block containing the default settings.
            //
            if (!AddInterface) {
                break;
            } else {
                Error = IpmontrGetInterfaceType(InterfaceName, &Type);
                if (Error) {
                    break;
                } else {
                    Count = 1;
                    Error =
                        MakeVrrpInterfaceInfo(
                            Type, (PUCHAR*)&OldInterfaceInfo, &Size
                            );
                    if (Error) { break; }
                }
            }
        } else {
            //
            // There is configuration on the interface. If it is empty this is
            // an error. If this is an add interface, and the info exists, it is
            // an error.
            //
            if (!(Count * Size) && !AddInterface) {
                Error = ERROR_NOT_FOUND; break;
            }
            else if (AddInterface) {
                //
                // We were asked to add an interface which already exists
                //
                DisplayMessage(g_hModule, EMSG_INTERFACE_EXISTS, InterfaceName);
                Error = ERROR_INVALID_PARAMETER;
                break;
            }
                    
        }

        if (!BitVector) {
            //
            // Just add this interface without any additional info.
            //
            DWORD OldSize;
            if (NewInterfaceInfo == NULL){
                NewInterfaceInfo = Malloc((OldSize=GetVrrpIfInfoSize(OldInterfaceInfo))+
                                          sizeof(VRRP_VROUTER_CONFIG));
                if (!NewInterfaceInfo) {
                    DisplayMessage(g_hModule, EMSG_NOT_ENOUGH_MEMORY);
                    Error = ERROR_NOT_ENOUGH_MEMORY;
                    break;                        
                }
            }
            CopyMemory(NewInterfaceInfo,OldInterfaceInfo,OldSize);
        }
        else{
            if (!AddInterface || (OldInterfaceInfo->VrouterCount != 0)) {
                //
                // There is a prexisting VRID set. Check for this VRID in the list and then
                // update it if required.
                //
                ASSERT(BitVector & VRRP_INTF_VRID_MASK);
                for (i = 0, PVrouter = VRRP_FIRST_VROUTER_CONFIG(OldInterfaceInfo);
                     i < OldInterfaceInfo->VrouterCount; 
                     i++, PVrouter = VRRP_NEXT_VROUTER_CONFIG(PVrouter)) {
                    if (PVrouter->VRID == VRouterInfo->VRID) {
                        break;
                    }
                }
                if (i == OldInterfaceInfo->VrouterCount) {
                    //
                    // This is a new VRID, Add it.
                    //
                    DWORD OldSize;

                    //
                    // The IP address should be valid or else this is a set op.
                    //
                    if (!(BitVector & VRRP_INTF_IPADDR_MASK)){
                        DisplayMessage(
                            g_hModule, EMSG_INVALID_VRID,
                            VRouterInfo->VRID
                            );
                        Error = ERROR_INVALID_PARAMETER;
                        break;
                    }

                    if (NewInterfaceInfo == NULL){
                        NewInterfaceInfo = Malloc((OldSize=GetVrrpIfInfoSize(
                                                OldInterfaceInfo))+
                                                sizeof(VRRP_VROUTER_CONFIG));
                        if (!NewInterfaceInfo) {
                            DisplayMessage(g_hModule, EMSG_NOT_ENOUGH_MEMORY);
                            Error = ERROR_NOT_ENOUGH_MEMORY;
                            break;                        
                        }
                    }
                    CopyMemory(NewInterfaceInfo, OldInterfaceInfo, OldSize);
                    PVrouter = (PVRRP_VROUTER_CONFIG)((PBYTE)NewInterfaceInfo+OldSize);
                    CopyMemory(PVrouter,VRouterInfo,sizeof(VRRP_VROUTER_CONFIG));
                    NewInterfaceInfo->VrouterCount++;

                    //
                    // Check if we own the IP address given. If yes, set the priority.
                    //
                    PVrouter->ConfigPriority = 
                        FoundIpAddress(PVrouter->IPAddress[0]) ? 255 : 100;
                } 
                else{
                    //
                    //  This is an old VRID. Its priority should not need to be changed.
                    //
                    DWORD Offset, OldSize;

                    if(BitVector & VRRP_INTF_IPADDR_MASK) {
                        if ( ((PVrouter->ConfigPriority != 255) && 
                              (FoundIpAddress(VRouterInfo->IPAddress[0]))
                             )
                             ||
                             ((PVrouter->ConfigPriority == 255) && 
                              (!FoundIpAddress(VRouterInfo->IPAddress[0])))
                             ) {
                            DisplayMessage(g_hModule, EMSG_BAD_OPTION_VALUE);
                            Error = ERROR_INVALID_PARAMETER;
                            break;                        
                        }
                        //
                        // Add this IP address to the VRID specified.
                        //
                        if (NewInterfaceInfo == NULL){
                            NewInterfaceInfo = Malloc((OldSize = GetVrrpIfInfoSize(
                                                        OldInterfaceInfo))+
                                                        sizeof(DWORD));
                            if (!NewInterfaceInfo) {
                                DisplayMessage(g_hModule, EMSG_NOT_ENOUGH_MEMORY);
                                Error = ERROR_NOT_ENOUGH_MEMORY;
                                break;                        
                            }
                        }
                        //
                        // Shift all the VROUTER configs after the PVrouter by 1 DWORD.
                        //
                        Offset = (PUCHAR) VRRP_NEXT_VROUTER_CONFIG(PVrouter) - 
                                 (PUCHAR) OldInterfaceInfo;
                        CopyMemory(NewInterfaceInfo, OldInterfaceInfo, OldSize);
                        for (i = 0, PVrouter = VRRP_FIRST_VROUTER_CONFIG(NewInterfaceInfo);
                             i < NewInterfaceInfo->VrouterCount; 
                             i++, PVrouter = VRRP_NEXT_VROUTER_CONFIG(PVrouter)) {
                            if (PVrouter->VRID == VRouterInfo->VRID) {
                                break;
                            }
                        }
                        ASSERT(i < NewInterfaceInfo->VrouterCount);
                        PVrouter->IPAddress[PVrouter->IPCount++] = VRouterInfo->IPAddress[0];
    
                        ASSERT(((PUCHAR)NewInterfaceInfo+Offset+sizeof(DWORD)) == 
                               (PUCHAR) VRRP_NEXT_VROUTER_CONFIG(PVrouter));
    
                        CopyMemory(VRRP_NEXT_VROUTER_CONFIG(PVrouter), 
                                   OldInterfaceInfo+Offset, OldSize-Offset);
                    } else {
                        //
                        // Set the new info block as the old info block and point to the
                        // vrouter block
                        //
                        if (NewInterfaceInfo == NULL){
                            NewInterfaceInfo = Malloc((OldSize = GetVrrpIfInfoSize(
                                                        OldInterfaceInfo)));
                            if (!NewInterfaceInfo) {
                                DisplayMessage(g_hModule, EMSG_NOT_ENOUGH_MEMORY);
                                Error = ERROR_NOT_ENOUGH_MEMORY;
                                break;                        
                            }
                        }
                        CopyMemory(NewInterfaceInfo, OldInterfaceInfo, OldSize);
                        for (i = 0, PVrouter = VRRP_FIRST_VROUTER_CONFIG(NewInterfaceInfo);
                             i < NewInterfaceInfo->VrouterCount; 
                             i++, PVrouter = VRRP_NEXT_VROUTER_CONFIG(PVrouter)) {
                            if (PVrouter->VRID == VRouterInfo->VRID) {
                                break;
                            }
                        }
                        ASSERT(i < NewInterfaceInfo->VrouterCount);
                    }

                    if (BitVector & VRRP_INTF_AUTH_MASK) {
                        PVrouter->AuthenticationType = VRouterInfo->AuthenticationType;
                    }
                    if (BitVector & VRRP_INTF_PASSWD_MASK) {
                        CopyMemory(PVrouter->AuthenticationData, 
                                   VRouterInfo->AuthenticationData, 
                                   VRRP_MAX_AUTHKEY_SIZE);
                    }
                    if (BitVector & VRRP_INTF_ADVT_MASK) {
                        PVrouter->AdvertisementInterval = VRouterInfo->AdvertisementInterval;
                    }
                    if (BitVector & VRRP_INTF_PRIO_MASK) {
                        PVrouter->ConfigPriority = VRouterInfo->ConfigPriority;
                    }
                    if (BitVector & VRRP_INTF_PREEMPT_MASK) {
                        PVrouter->PreemptMode = VRouterInfo->PreemptMode;
                    }
                }
            }
        }

        ValidateVrrpInterfaceInfo(NewInterfaceInfo);

        Error =
            IpmontrSetInfoBlockInInterfaceInfo(
                InterfaceName,
                MS_IP_VRRP,
                (PUCHAR)NewInterfaceInfo,
                GetVrrpIfInfoSize(NewInterfaceInfo),
                1
                );
    } while(FALSE);
    if (NewInterfaceInfo) { Free(NewInterfaceInfo); }
    if (OldInterfaceInfo) { Free(OldInterfaceInfo); }
    if (Error == ERROR_NOT_FOUND) {
        DisplayMessage(g_hModule, EMSG_PROTO_NO_IF_INFO);
    } else if (Error) {
        DisplayError(g_hModule, Error);
    }
    return Error;
}

ULONG
DeleteVrrpInterfaceInfo(
    PWCHAR InterfaceName,
    PVRRP_VROUTER_CONFIG VRouterInfo,
    ULONG BitVector,
    BOOL DeleteInterface
    )
{
    ULONG Count;
    ULONG Error;
    PVRRP_IF_CONFIG NewInterfaceInfo = NULL;
    PVRRP_IF_CONFIG OldInterfaceInfo = NULL;
    PVRRP_VROUTER_CONFIG PVrouter = NULL;
    ULONG Size;
    ROUTER_INTERFACE_TYPE Type;
    ULONG i;

    if (!DeleteInterface && !BitVector) { return NO_ERROR; }
    do {
        //
        // Retrieve the existing interface configuration.
        // We will update this block below, as well as adding to or removing
        // from it depending on the flags specified in 'BitVector'.
        //
        Error =
            IpmontrGetInfoBlockFromInterfaceInfo(
                InterfaceName,
                MS_IP_VRRP,
                (PUCHAR*)&OldInterfaceInfo,
                &Size,
                &Count,
                &Type
                );
        if (Error) {
            //
            // No existing configuration is found. This is an error. 
            //
            break;    
        }
        if (DeleteInterface) {
            //
            // Just delete this interface
            //
            Error = IpmontrDeleteInfoBlockFromInterfaceInfo(
                InterfaceName,
                MS_IP_VRRP
                );
            break;
        } else {
            DWORD OldSize;
            PVRRP_VROUTER_CONFIG PVrouterNew;
            //
            // Look for the VRID and delete it.
            //
            for (i = 0, PVrouter = VRRP_FIRST_VROUTER_CONFIG(OldInterfaceInfo);
                 i < OldInterfaceInfo->VrouterCount; 
                 i++, PVrouter = VRRP_NEXT_VROUTER_CONFIG(PVrouter)) {
                if (PVrouter->VRID == VRouterInfo->VRID) {
                    break;
                }
            }
            if (i >= OldInterfaceInfo->VrouterCount) {
                DisplayMessage(g_hModule, EMSG_BAD_OPTION_VALUE);
                Error = ERROR_INVALID_PARAMETER;
                break;
            }
            
            NewInterfaceInfo = Malloc((OldSize=GetVrrpIfInfoSize(OldInterfaceInfo))-
                                      VRRP_VROUTER_CONFIG_SIZE(PVrouter));
            if (!NewInterfaceInfo) {
                DisplayMessage(g_hModule, EMSG_NOT_ENOUGH_MEMORY);
                Error = ERROR_NOT_ENOUGH_MEMORY;
                break;                        
            }
            NewInterfaceInfo->VrouterCount = OldInterfaceInfo->VrouterCount - 1;
            PVrouterNew = VRRP_FIRST_VROUTER_CONFIG(NewInterfaceInfo);
            for (i = 0, PVrouter = VRRP_FIRST_VROUTER_CONFIG(OldInterfaceInfo);
                 i < OldInterfaceInfo->VrouterCount; 
                 i++, PVrouter = VRRP_NEXT_VROUTER_CONFIG(PVrouter)) {
                if (PVrouter->VRID == VRouterInfo->VRID) {
                    continue;
                }
                CopyMemory(PVrouterNew,PVrouter,VRRP_VROUTER_CONFIG_SIZE(PVrouter));
                PVrouterNew = VRRP_NEXT_VROUTER_CONFIG(PVrouterNew);
            }
                        
            ValidateVrrpInterfaceInfo(NewInterfaceInfo);

            Error =
                IpmontrSetInfoBlockInInterfaceInfo(
                    InterfaceName,
                    MS_IP_VRRP,
                    (PUCHAR)NewInterfaceInfo,
                    GetVrrpIfInfoSize(NewInterfaceInfo),
                    1
                    );
        }
    
    } while(FALSE);
    if (NewInterfaceInfo) { Free(NewInterfaceInfo); }
    if (OldInterfaceInfo) { Free(OldInterfaceInfo); }
    if (Error == ERROR_NOT_FOUND) {
        DisplayMessage(g_hModule, EMSG_PROTO_NO_IF_INFO);
    } else if (Error) {
        DisplayError(g_hModule, Error);
    }
    return Error;
}


ULONG
ValidateVrrpInterfaceInfo(
    PVRRP_IF_CONFIG InterfaceInfo
    )
{
    return NO_ERROR;
}

DWORD
GetVrrpIfInfoSize(
    PVRRP_IF_CONFIG InterfaceInfo
    )
{
    DWORD Size = 0;
    ULONG i;
    PVRRP_VROUTER_CONFIG pvr;

    Size += sizeof(InterfaceInfo->VrouterCount);

    for (i = 0, pvr = VRRP_FIRST_VROUTER_CONFIG(InterfaceInfo);
         i < InterfaceInfo->VrouterCount;
         i++,pvr = VRRP_NEXT_VROUTER_CONFIG(pvr)) {
        Size += VRRP_VROUTER_CONFIG_SIZE(pvr);
    }

    return Size;
}

BOOL
FoundIpAddress(
    DWORD IPAddress
    )
{
    PMIB_IPADDRTABLE pTable = NULL;
    DWORD            Size  = 0;
    ULONG            i;
    BOOL             Result;

    GetIpAddrTable( pTable, &Size, TRUE);
    pTable = Malloc(Size);
    if (!pTable) {
        DisplayMessage(g_hModule, EMSG_NOT_ENOUGH_MEMORY);
        return FALSE;
    }
    if (GetIpAddrTable(pTable,&Size,TRUE) != NO_ERROR){
        return FALSE;
    }

    for (i = 0; i < pTable->dwNumEntries; i++) {
        if (pTable->table[i].dwAddr == IPAddress)
            break;
    }

    Result = (i < pTable->dwNumEntries);

    Free(pTable);

    return Result;

}

ULONG
SetArpRetryCount(
    DWORD Value
    )
{
    HKEY     hKey = NULL;
    DWORD    dwDisp;
    ULONG    dwErr = NO_ERROR;

    do
    {
        dwErr = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                       L"System\\CurrentControlSet\\Services\\Tcpip\\Parameters",
                        0,NULL,REG_OPTION_NON_VOLATILE,KEY_ALL_ACCESS,NULL,
                        &hKey, &dwDisp);
        if (dwErr != ERROR_SUCCESS) {
            break;
        }
        dwErr = RegSetValueEx(hKey, L"ArpRetryCount", 0, REG_DWORD, (LPBYTE) &Value, 
                            sizeof(DWORD));
    } while (0);

    if (hKey) {
        RegCloseKey(hKey);
    }
    if (dwErr == ERROR_SUCCESS) {
        dwErr = NO_ERROR;
    }
    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ip\preview\vrrphlpcfg.h ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    net\routing\netsh\ip\protocols\vrrpcfg.h

Abstract:

    VRRP configuration declarations

Author:

    Peeyush Ranjan (peeyushr)   1-Mar-1999

Revision History:

--*/

#ifndef _NETSH_VRRPHLPCFG_H_
#define _NETSH_VRRPHLPCFG_H_

#define VRRP_IPADDR_LENGTH  16
#define MAX_MESSAGE_SIZE    256

#define VRRP_INTF_VRID_MASK     0x00000001
#define VRRP_INTF_IPADDR_MASK   0x00000002
#define VRRP_INTF_AUTH_MASK     0x00000004
#define VRRP_INTF_PASSWD_MASK   0x00000008
#define VRRP_INTF_ADVT_MASK     0x00000010
#define VRRP_INTF_PRIO_MASK     0x00000020
#define VRRP_INTF_PREEMPT_MASK  0x00000040

ULONG
MakeVrrpGlobalInfo(
    OUT PUCHAR* GlobalInfo,
    OUT PULONG GlobalInfoSize
    );

ULONG
CreateVrrpGlobalInfo(
    OUT PVRRP_GLOBAL_CONFIG* GlobalInfo,
    IN  DWORD LoggingLevel
    );

ULONG
MakeVrrpInterfaceInfo(
    ROUTER_INTERFACE_TYPE InterfaceType,
    OUT PUCHAR* InterfaceInfo,
    OUT PULONG InterfaceInfoSize
    );

ULONG
MakeVrrpVRouterInfo(
    IN PUCHAR VRouterInfo
    );

ULONG
ShowVrrpGlobalInfo(
    HANDLE FileHandle
    );

ULONG
ShowVrrpAllInterfaceInfo(
    HANDLE FileHandle
    );

ULONG
ShowVrrpInterfaceInfo(
    HANDLE FileHandle,
    PWCHAR InterfaceName
    );

ULONG
UpdateVrrpGlobalInfo(
    PVRRP_GLOBAL_CONFIG GlobalInfo
    );

ULONG
UpdateVrrpInterfaceInfo(
    PWCHAR InterfaceName,
    PVRRP_VROUTER_CONFIG VRouterInfo,
    ULONG BitVector,
    BOOL AddInterface
    );

DWORD
GetVrrpIfInfoSize(
    PVRRP_IF_CONFIG InterfaceInfo
    );

ULONG
DeleteVrrpInterfaceInfo(
    PWCHAR InterfaceName,
    PVRRP_VROUTER_CONFIG VRouterInfo,
    ULONG BitVector,
    BOOL DeleteInterface
    );

ULONG
SetArpRetryCount(
    DWORD Value
    );

//
// IP address conversion macros:
//    
//  calls inet_ntoa directly on a DWORD, by casting it as an IN_ADDR.
//
#define INET_NTOA(dw) inet_ntoa( *(PIN_ADDR)&(dw) )

BOOL
FoundIpAddress(
    DWORD IPAddress
    );

#endif  // _NETSH_VRRPHLPCFG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ip\sample\common.h ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    sample\common.h

Abstract:

    The file contains the header for common.c,
    the main file for the IPSAMPLEMON helper DLL.
    
--*/

// constants...

#define SAMPLE_HELPER_VERSION       1



// globals...

// variables
extern HANDLE                       g_hModule;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ip\preview\vrrphlpopt.h ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    net\routing\netsh\ip\protocols\vrrpopt.h

Abstract:

    VRRP Command dispatcher declarations

Author:

    Peeyush Ranjan (peeyushr)   1-Mar-1999

Revision History:

--*/


#ifndef _NETSH_VRRPHLPOPT_H_
#define _NETSH_VRRPHLPOPT_H_

FN_HANDLE_CMD HandleVrrpAddVRID;
FN_HANDLE_CMD HandleVrrpAddInterface;
FN_HANDLE_CMD HandleVrrpDeleteInterface;
FN_HANDLE_CMD HandleVrrpDeleteVRID;
FN_HANDLE_CMD HandleVrrpSetInterface;
FN_HANDLE_CMD HandleVrrpSetGlobal;
FN_HANDLE_CMD HandleVrrpShowGlobal;
FN_HANDLE_CMD HandleVrrpShowInterface;
FN_HANDLE_CMD HandleVrrpInstall;
FN_HANDLE_CMD HandleVrrpUninstall;

DWORD
DumpVrrpInformation(VOID);

#endif // _NETSH_VRRPHLPOPT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ip\sample\common.c ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    sample\common.c

Abstract:

    The file contains interactions with netsh and functions common across
    all contexts registered by this helper DLL (IPSAMPLEMON).

--*/

#include "precomp.h"
#pragma hdrstop

// statics
static const GUID g_IpGuid = IPMONTR_GUID;

// generate a new GUID for each helper (uuidgen)
// aedb0ad8-1496-11d3-8005-08002bc35d9c
static const GUID g_MyGuid = 
{ 0xaedb0ad8, 0x1496, 0x11d3, {0x80, 0x5, 0x8, 0x0, 0x2b, 0xc3, 0x5d, 0x9c} };



// globals...

// variables                        
HANDLE                              g_hModule;      // set by DllMain 

DWORD
WINAPI
IpsamplemonStartHelper(
    IN  CONST   GUID        *pguidParent,
    IN          DWORD       dwVersion
    )
/*++

Routine Description
    Registers contexts.  Called by netsh to start helper.

Arguments
    pguidParent         GUID of parent helper (IPMON)
    dwVersion           Version number of parent helper

Return Value

    Error code returned from registering last context.

--*/    
{
    DWORD                   dwErr;

    // the following types depend on the parent helper (IPMON)
    IP_CONTEXT_ATTRIBUTES   icaMyAttributes;
    
    // register the SAMPLE context
    SampleInitialize();         // initialize sample's global information
    ZeroMemory(&icaMyAttributes, sizeof(icaMyAttributes));
    
    icaMyAttributes.guidHelper  = g_MyGuid;             // context's helper
    icaMyAttributes.dwVersion   = g_ceSample.dwVersion;
    icaMyAttributes.pwszContext = g_ceSample.pwszName;
    icaMyAttributes.pfnDumpFn   = g_ceSample.pfnDump;
    icaMyAttributes.ulNumTopCmds= g_ceSample.ulNumTopCmds;
    icaMyAttributes.pTopCmds    = (CMD_ENTRY (*)[])
        g_ceSample.pTopCmds;
    icaMyAttributes.ulNumGroups = g_ceSample.ulNumGroupCmds;
    icaMyAttributes.pCmdGroups  = (CMD_GROUP_ENTRY (*)[])
        g_ceSample.pGroupCmds;

    dwErr = RegisterContext(&icaMyAttributes);

    return dwErr;
}



DWORD
WINAPI
InitHelperDll(
    IN  DWORD              dwNetshVersion,
    OUT PNS_DLL_ATTRIBUTES pDllTable
    )
/*++

Routine Description
    Registers helper.  Called by netsh.

Arguments
    pUtilityTable           netsh functions
    pDllTable               DLL attributes

Return Value
    Error code returned from registering helper.

--*/
{
    DWORD                   dwErr;
    NS_HELPER_ATTRIBUTES    nhaMyAttributes;

    pDllTable->dwVersion                        = NETSH_VERSION_50;
    pDllTable->pfnStopFn                        = NULL;

    // Register helper.  One option is to register a single helper that
    // registers a context for each protocol supported.  Alternatively we
    // could register a different helper for each protocol, where each
    // helper registers a single context.  There's only a difference if we
    // support sub-helpers.  Since a sub-helper registers with a parent
    // helper, not a parent context, it is valid in every context its
    // parent helper registers.

    ZeroMemory(&nhaMyAttributes, sizeof(NS_HELPER_ATTRIBUTES));

    // attributes of this helper

    // version
    nhaMyAttributes.guidHelper                  = g_MyGuid;
    nhaMyAttributes.dwVersion                   = SAMPLE_HELPER_VERSION;

    // start function
    nhaMyAttributes.pfnStart                    = IpsamplemonStartHelper;

    // define stop function if need to perform cleanup before unload
    nhaMyAttributes.pfnStop                     = NULL;
    
    dwErr = RegisterHelper(&g_IpGuid, // GUID of parent helper (IPMON)
                           &nhaMyAttributes);

    return dwErr;
}



BOOL
WINAPI
DllMain(
    IN  HINSTANCE           hInstance,
    IN  DWORD               dwReason,
    IN  PVOID               pvImpLoad
    )
/*++

Routine Description
    DLL entry and exit point handler.

Arguments
    hInstance   Instance handle of DLL
    dwReason    Reason function called
    pvImpLoad   Implicitly loaded DLL?

Return Value
    TRUE        Successfully loaded DLL

--*/
{
    switch(dwReason)
    {
        case DLL_PROCESS_ATTACH:
            g_hModule = hInstance;
            DisableThreadLibraryCalls(hInstance);
            break;

        case DLL_PROCESS_DETACH:
            break;

        default:

            break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ip\sample\precomp.h ===
#define MAX_DLL_NAME 48

#include <windows.h>            // Include file for Windows applications
#include <winsock2.h>           // Interface to WinSock 2 API
#include <routprot.h>           // Interface to Router Manager
#include <iprtrmib.h>           // Interface to IP Router Manager's MIB
#include <netsh.h>              // Definitions needed by helper DLLs
#include <ipmontr.h>            // For helper DLLs registering under IPMONTR
#include <stdlib.h>

#include "ipsamplerm.h"         // Definitions and declarations for IPSAMPLE

#include "strdefs.h"
#include "prstring.h"
#include "common.h"
#include "utils.h"
#include "sample.h"
#include "samplecfg.h"
#include "samplegetopt.h"
#include "samplemib.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ip\preview\vrrphlpopt.c ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    net\routing\netsh\ip\protocols\vrrphlpopt.c

Abstract:

    VRRP command options implementation.
    This module contains handlers for the configuration commands
    supported by the VRRP Protocol.

Author:

    Peeyush Ranjan (peeyushr)   1-Mar-1999

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include <ipcmp.h>

#define Malloc(x) HeapAlloc(GetProcessHeap(), 0, (x))
#define Free(x) HeapFree(GetProcessHeap(), 0, (x))

//
// Forward declarations
//

ULONG
QueryTagArray(
    PTCHAR ArgumentArray[],
    ULONG ArgumentCount,
    TAG_TYPE TagTypeArray[],
    ULONG TagTypeCount,
    OUT PULONG* TagArray
    );

ULONG
ValidateTagTypeArray(
    TAG_TYPE TagTypeArray[],
    ULONG TagTypeCount
    );


DWORD
HandleVrrpAddVRID(
    PWCHAR MachineName,
    PTCHAR* ArgumentArray,
    DWORD ArgumentIndex,
    DWORD ArgumentCount,
    DWORD CmdFlags,
    PVOID Data,
    BOOL* CommandDone
    )
{
    ULONG ArgumentsLeft;
    ULONG BitVector;
    ULONG Error;
    ULONG ErrorIndex = 0;
    ULONG i;
    VRRP_VROUTER_CONFIG VRouterGiven;
    PULONG TagArray;
    WCHAR InterfaceName[MAX_INTERFACE_NAME_LEN + 1];
    ULONG InfoSize;

    TAG_TYPE TagTypeArray[] = {
        { TOKEN_OPT_INTERFACE_NAME, TRUE, FALSE },
        { TOKEN_OPT_VRID, TRUE, FALSE },
        { TOKEN_OPT_IPADDRESS, TRUE, FALSE }
    };

    VERIFY_INSTALLED(MS_IP_VRRP, L"VRRP");

    if (ArgumentIndex >= ArgumentCount) { return ERROR_SHOW_USAGE; }
    ArgumentsLeft = ArgumentCount - ArgumentIndex;

    //
    // We convert the optional tags into an array of 'TagTypeArray' indices
    // which guide is in our scanning of the argument list.
    // Since the tags are optional, this process may result in no tags at all,
    // in which case we assume that arguments are specified in exactly the order
    // given in 'TagTypeArray' above.
    //

    Error =
        QueryTagArray(
            &ArgumentArray[ArgumentIndex],
            ArgumentsLeft,
            TagTypeArray,
            NUM_TAGS_IN_TABLE(TagTypeArray),
            &TagArray
            );
    if (Error) { return Error; }

    BitVector = 0;
    
    //
    // Make the default info
    //
    //
    MakeVrrpVRouterInfo((PUCHAR) &VRouterGiven);

    // We now scan the argument list, converting the arguments
    // into information in our 'VrouterGiven' structure.
    //

    for (i = 0; i < ArgumentsLeft; i++) {
        switch(TagArray ? TagArray[i] : i) {
            case 0: {
                ULONG Length = sizeof(InterfaceName);
                Error =
                    IpmontrGetIfNameFromFriendlyName(
                        ArgumentArray[i + ArgumentIndex], InterfaceName, &Length
                        );
                if (Error) {
                    DisplayMessage(
                        g_hModule, EMSG_NO_INTERFACE,
                        ArgumentArray[i + ArgumentIndex]
                        );
                    Error = ERROR_NO_SUCH_INTERFACE;
                    i = ArgumentsLeft;
                    break;
                }
                TagTypeArray[TagArray ? TagArray[i] : i].bPresent = TRUE;
                break;
            }
            case 1: {
                ULONG VRIDGiven;
                VRIDGiven = _tcstoul(ArgumentArray[i + ArgumentIndex], NULL, 10);
                
                if (VRIDGiven > 255) {
                    DisplayMessage(
                        g_hModule, EMSG_INVALID_VRID,
                        VRIDGiven
                        );
                    Error = ERROR_INVALID_PARAMETER;
                    i = ArgumentsLeft;
                    break;
                }
                VRouterGiven.VRID = (BYTE) VRIDGiven;  
                BitVector |= VRRP_INTF_VRID_MASK;
                    
                TagTypeArray[TagArray ? TagArray[i] : i].bPresent = TRUE;
                break;
            }
            case 2: { 
                ULONG AddressSpecified;
                //
                // If the IP address has been specified, the VRID should have been
                // specified already
                //
                if (!(BitVector & VRRP_INTF_VRID_MASK)){
                    Error = ERROR_INVALID_SYNTAX;
                    i = ArgumentsLeft;
                    break;
                }

                AddressSpecified = GetIpAddress(ArgumentArray[i + ArgumentIndex]);
                if (!AddressSpecified || AddressSpecified == INADDR_NONE) {
                    DisplayMessage(
                        g_hModule,
                        MSG_IP_BAD_IP_ADDR,
                        ArgumentArray[i + ArgumentIndex]
                        );
                    Error = ERROR_INVALID_PARAMETER;
                    ErrorIndex = i;
                    i = ArgumentsLeft;
                    break;
                }
                VRouterGiven.IPCount = 1;                           
                VRouterGiven.IPAddress[0] = AddressSpecified;
                BitVector |= VRRP_INTF_IPADDR_MASK;
                TagTypeArray[TagArray ? TagArray[i] : i].bPresent = TRUE;
                break;
            }
            default: {
                i = ArgumentsLeft;
                Error = ERROR_INVALID_SYNTAX;
            }
        }
    }
    
    if (!Error) {
        //
        // Ensure that all required parameters are present.
        //
        Error =
            ValidateTagTypeArray(TagTypeArray, NUM_TAGS_IN_TABLE(TagTypeArray));
    }
    if (Error == ERROR_TAG_ALREADY_PRESENT) {
        DisplayMessage(g_hModule, EMSG_TAG_ALREADY_PRESENT);
    } else if (Error == ERROR_INVALID_PARAMETER && TagArray) {
        DispTokenErrMsg(
            g_hModule,
            EMSG_BAD_OPTION_VALUE,
            TagTypeArray[TagArray[ErrorIndex]],
            ArgumentArray[ErrorIndex + ArgumentIndex]
            );
    } else if (!Error && (BitVector)) {
        //
        // Update the configuration with the new settings.
        // Note that the update routine may perform additional validation
        // in the process of reconciling the new settings
        // with any existing settings.
        //
        Error =
            UpdateVrrpInterfaceInfo(
                InterfaceName, &VRouterGiven, BitVector, FALSE
                );
    }
    
    return Error;
}

DWORD
HandleVrrpAddInterface(
    PWCHAR MachineName,
    PTCHAR* ArgumentArray,
    DWORD ArgumentIndex,
    DWORD ArgumentCount,
    DWORD CmdFlags,
    PVOID Data,
    BOOL* CommandDone
    )
{
    ULONG ArgumentsLeft;
    ULONG BitVector;
    ULONG Error;
    ULONG ErrorIndex = 0;
    ULONG i;
    VRRP_VROUTER_CONFIG VRouterGiven;
    PULONG TagArray;
    WCHAR InterfaceName[MAX_INTERFACE_NAME_LEN + 1];
    ULONG InfoSize;

    TAG_TYPE TagTypeArray[] = {
        { TOKEN_OPT_INTERFACE_NAME, TRUE, FALSE },
        { TOKEN_OPT_VRID, FALSE, FALSE },
        { TOKEN_OPT_IPADDRESS, FALSE, FALSE }
    };

    VERIFY_INSTALLED(MS_IP_VRRP, L"VRRP");

    if (ArgumentIndex >= ArgumentCount) { return ERROR_SHOW_USAGE; }
    ArgumentsLeft = ArgumentCount - ArgumentIndex;

    //
    // We convert the optional tags into an array of 'TagTypeArray' indices
    // which guide is in our scanning of the argument list.
    // Since the tags are optional, this process may result in no tags at all,
    // in which case we assume that arguments are specified in exactly the order
    // given in 'TagTypeArray' above.
    //

    Error =
        QueryTagArray(
            &ArgumentArray[ArgumentIndex],
            ArgumentsLeft,
            TagTypeArray,
            NUM_TAGS_IN_TABLE(TagTypeArray),
            &TagArray
            );
    if (Error) { return Error; }

    BitVector = 0;

    //
    // We now scan the argument list, converting the arguments
    // into information in our 'VrouterGiven' structure.
    //

    for (i = 0; i < ArgumentsLeft; i++) {
        switch(TagArray ? TagArray[i] : i) {
            case 0: {
                ULONG Length = sizeof(InterfaceName);
                Error =
                    IpmontrGetIfNameFromFriendlyName(
                        ArgumentArray[i + ArgumentIndex], InterfaceName, &Length
                        );
                if (Error) {
                    DisplayMessage(
                        g_hModule, EMSG_NO_INTERFACE,
                        ArgumentArray[i + ArgumentIndex]
                        );
                    Error = ERROR_NO_SUCH_INTERFACE;
                    i = ArgumentsLeft;
                    break;
                }
                TagTypeArray[TagArray ? TagArray[i] : i].bPresent = TRUE;
                break;
            }
            case 1: {
                ULONG VRIDGiven;
                VRIDGiven = _tcstoul(ArgumentArray[i + ArgumentIndex], NULL, 10);
                
                if (VRIDGiven > 255) {
                    DisplayMessage(
                        g_hModule, EMSG_INVALID_VRID,
                        VRIDGiven
                        );
                    Error = ERROR_NO_SUCH_INTERFACE;
                    i = ArgumentsLeft;
                    break;
                }
                VRouterGiven.VRID = (BYTE) VRIDGiven;  
                BitVector |= VRRP_INTF_VRID_MASK;
                    
                TagTypeArray[TagArray ? TagArray[i] : i].bPresent = TRUE;
                break;
            }
            case 2: { 
                ULONG AddressSpecified;
                //
                // If the IP address has been specified, the VRID should have been
                // specified already
                //
                if (!(BitVector & VRRP_INTF_VRID_MASK)){
                    Error = ERROR_INVALID_SYNTAX;
                    i = ArgumentsLeft;
                    break;
                }

                AddressSpecified = GetIpAddress(ArgumentArray[i + ArgumentIndex]);
                if (!AddressSpecified || AddressSpecified == INADDR_NONE) {
                    DisplayMessage(
                        g_hModule,
                        MSG_IP_BAD_IP_ADDR,
                        ArgumentArray[i + ArgumentIndex]
                        );
                    Error = ERROR_INVALID_PARAMETER;
                    ErrorIndex = i;
                    i = ArgumentsLeft;
                    break;
                }
                           
                VRouterGiven.IPCount = 1;
                VRouterGiven.IPAddress[0] = AddressSpecified;
                BitVector |= VRRP_INTF_IPADDR_MASK;
                TagTypeArray[TagArray ? TagArray[i] : i].bPresent = TRUE;
                break;
            }
            default: {
                i = ArgumentsLeft;
                Error = ERROR_INVALID_SYNTAX;
            }
        }
    }
    if ((BitVector) && (!(BitVector & VRRP_INTF_VRID_MASK) 
                     || !(BitVector & VRRP_INTF_IPADDR_MASK))) {
        //
        // You can either have no VRID, or both VRID and IP address, not only one of them
        //
        Error = ERROR_INVALID_SYNTAX;
    }

    if (!Error) {
        //
        // Ensure that all required parameters are present.
        //
        Error =
            ValidateTagTypeArray(TagTypeArray, NUM_TAGS_IN_TABLE(TagTypeArray));
    }
    if (Error == ERROR_TAG_ALREADY_PRESENT) {
        DisplayMessage(g_hModule, EMSG_TAG_ALREADY_PRESENT);
    } else if (Error == ERROR_INVALID_PARAMETER && TagArray) {
        DispTokenErrMsg(
            g_hModule,
            EMSG_BAD_OPTION_VALUE,
            TagTypeArray[TagArray[ErrorIndex]],
            ArgumentArray[ErrorIndex + ArgumentIndex]
            );
    } else if (!Error) {
        //
        // Update the configuration with the new settings.
        // Note that the update routine may perform additional validation
        // in the process of reconciling the new settings
        // with any existing settings.
        //
        Error =
            UpdateVrrpInterfaceInfo(
                InterfaceName, &VRouterGiven, BitVector, TRUE
                );
    }
    
    return Error;
}


DWORD
HandleVrrpDeleteInterface(
    PWCHAR MachineName,
    PTCHAR* ArgumentArray,
    DWORD ArgumentIndex,
    DWORD ArgumentCount,
    DWORD CmdFlags,
    PVOID Data,
    BOOL* CommandDone
    )
{
    ULONG ArgumentsLeft;
    ULONG BitVector;
    ULONG Error;
    ULONG ErrorIndex = 0;
    ULONG i;
    VRRP_VROUTER_CONFIG VRouterGiven;
    PULONG TagArray;
    WCHAR InterfaceName[MAX_INTERFACE_NAME_LEN + 1];
    ULONG InfoSize;

    TAG_TYPE TagTypeArray[] = {
        { TOKEN_OPT_INTERFACE_NAME, TRUE, FALSE }
    };

    VERIFY_INSTALLED(MS_IP_VRRP, L"VRRP");

    if (ArgumentIndex >= ArgumentCount) { return ERROR_SHOW_USAGE; }
    ArgumentsLeft = ArgumentCount - ArgumentIndex;

    //
    // We convert the optional tags into an array of 'TagTypeArray' indices
    // which guide is in our scanning of the argument list.
    // Since the tags are optional, this process may result in no tags at all,
    // in which case we assume that arguments are specified in exactly the order
    // given in 'TagTypeArray' above.
    //

    Error =
        QueryTagArray(
            &ArgumentArray[ArgumentIndex],
            ArgumentsLeft,
            TagTypeArray,
            NUM_TAGS_IN_TABLE(TagTypeArray),
            &TagArray
            );
    if (Error) { return Error; }

    BitVector = 0;

    //
    // We now scan the argument list, converting the arguments
    // into information in our 'VrouterGiven' structure.
    //

    for (i = 0; i < ArgumentsLeft; i++) {
        switch(TagArray ? TagArray[i] : i) {
            case 0: {
                ULONG Length = sizeof(InterfaceName);
                Error =
                    IpmontrGetIfNameFromFriendlyName(
                        ArgumentArray[i + ArgumentIndex], InterfaceName, &Length
                        );
                if (Error) {
                    DisplayMessage(
                        g_hModule, EMSG_NO_INTERFACE,
                        ArgumentArray[i + ArgumentIndex]
                        );
                    Error = ERROR_NO_SUCH_INTERFACE;
                    i = ArgumentsLeft;
                    break;
                }
                TagTypeArray[TagArray ? TagArray[i] : i].bPresent = TRUE;
                break;
            }
            default: {
                i = ArgumentsLeft;
                Error = ERROR_INVALID_SYNTAX;
            }
        }
    }

    if (!Error) {
        //
        // Ensure that all required parameters are present.
        //
        Error =
            ValidateTagTypeArray(TagTypeArray, NUM_TAGS_IN_TABLE(TagTypeArray));
    }
    if (Error == ERROR_TAG_ALREADY_PRESENT) {
        DisplayMessage(g_hModule, EMSG_TAG_ALREADY_PRESENT);
    } else if (Error == ERROR_INVALID_PARAMETER && TagArray) {
        DispTokenErrMsg(
            g_hModule,
            EMSG_BAD_OPTION_VALUE,
            TagTypeArray[TagArray[ErrorIndex]],
            ArgumentArray[ErrorIndex + ArgumentIndex]
            );
    } else if (!Error) {
        //
        // Update the configuration with the new settings.
        // Note that the update routine may perform additional validation
        // in the process of reconciling the new settings
        // with any existing settings.
        //
        Error =
            DeleteVrrpInterfaceInfo(
                InterfaceName, &VRouterGiven, BitVector, TRUE
                );
    }
    
    return Error;
}


DWORD
HandleVrrpDeleteVRID(
    PWCHAR MachineName,
    PTCHAR* ArgumentArray,
    DWORD ArgumentIndex,
    DWORD ArgumentCount,
    DWORD CmdFlags,
    PVOID Data,
    BOOL* CommandDone
    )
{
    ULONG ArgumentsLeft;
    ULONG BitVector;
    ULONG Error;
    ULONG ErrorIndex = 0;
    ULONG i;
    VRRP_VROUTER_CONFIG VRouterGiven;
    PULONG TagArray;
    WCHAR InterfaceName[MAX_INTERFACE_NAME_LEN + 1];
    ULONG InfoSize;

    TAG_TYPE TagTypeArray[] = {
        { TOKEN_OPT_INTERFACE_NAME, TRUE, FALSE },
        { TOKEN_OPT_VRID, TRUE, FALSE }
    };

    VERIFY_INSTALLED(MS_IP_VRRP, L"VRRP");

    if (ArgumentIndex >= ArgumentCount) { return ERROR_SHOW_USAGE; }
    ArgumentsLeft = ArgumentCount - ArgumentIndex;

    //
    // We convert the optional tags into an array of 'TagTypeArray' indices
    // which guide is in our scanning of the argument list.
    // Since the tags are optional, this process may result in no tags at all,
    // in which case we assume that arguments are specified in exactly the order
    // given in 'TagTypeArray' above.
    //

    Error =
        QueryTagArray(
            &ArgumentArray[ArgumentIndex],
            ArgumentsLeft,
            TagTypeArray,
            NUM_TAGS_IN_TABLE(TagTypeArray),
            &TagArray
            );
    if (Error) { return Error; }

    BitVector = 0;

    //
    // We now scan the argument list, converting the arguments
    // into information in our 'VrouterGiven' structure.
    //

    for (i = 0; i < ArgumentsLeft; i++) {
        switch(TagArray ? TagArray[i] : i) {
            case 0: {
                ULONG Length = sizeof(InterfaceName);
                Error =
                    IpmontrGetIfNameFromFriendlyName(
                        ArgumentArray[i + ArgumentIndex], InterfaceName, &Length
                        );
                if (Error) {
                    DisplayMessage(
                        g_hModule, EMSG_NO_INTERFACE,
                        ArgumentArray[i + ArgumentIndex]
                        );
                    Error = ERROR_NO_SUCH_INTERFACE;
                    i = ArgumentsLeft;
                    break;
                }
                TagTypeArray[TagArray ? TagArray[i] : i].bPresent = TRUE;
                break;
            }
        case 1: {
            ULONG Length = sizeof(InterfaceName);
            DWORD VRIDGiven;
            VRIDGiven = _tcstoul(ArgumentArray[i + ArgumentIndex], NULL, 10);

            if (VRIDGiven > 255) {
                DisplayMessage(
                    g_hModule, EMSG_INVALID_VRID,
                    VRIDGiven
                    );
                Error = ERROR_NO_SUCH_INTERFACE;
                i = ArgumentsLeft;
                break;
            }
            VRouterGiven.VRID = (BYTE) VRIDGiven;  
            BitVector |= VRRP_INTF_VRID_MASK;

            TagTypeArray[TagArray ? TagArray[i] : i].bPresent = TRUE;
            break;
            }
            default: {
                i = ArgumentsLeft;
                Error = ERROR_INVALID_SYNTAX;
            }
        }
    }

    if (!Error) {
        //
        // Ensure that all required parameters are present.
        //
        Error =
            ValidateTagTypeArray(TagTypeArray, NUM_TAGS_IN_TABLE(TagTypeArray));
    }
    if (Error == ERROR_TAG_ALREADY_PRESENT) {
        DisplayMessage(g_hModule, EMSG_TAG_ALREADY_PRESENT);
    } else if (Error == ERROR_INVALID_PARAMETER && TagArray) {
        DispTokenErrMsg(
            g_hModule,
            EMSG_BAD_OPTION_VALUE,
            TagTypeArray[TagArray[ErrorIndex]],
            ArgumentArray[ErrorIndex + ArgumentIndex]
            );
    } else if (!Error && (BitVector)) {
        //
        // Update the configuration with the new settings.
        // Note that the update routine may perform additional validation
        // in the process of reconciling the new settings
        // with any existing settings.
        //
        Error =
            DeleteVrrpInterfaceInfo(
                InterfaceName, &VRouterGiven, BitVector, FALSE
                );
    }
    
    return Error;
}


DWORD
DumpVrrpInformation(VOID)
{
    PMPR_INTERFACE_0 Array;
    ULONG Count = 0;
    ULONG Error;
    ULONG i;
    PUCHAR Information;
    ULONG Length;
    ULONG Total;
    ULONG Type;
        
    DisplayMessage(g_hModule,DMP_VRRP_HEADER);
    DisplayMessageT(DMP_VRRP_PUSHD);
    DisplayMessageT(DMP_VRRP_UNINSTALL);
    //
    // Show the global info commands
    //

    ShowVrrpGlobalInfo(INVALID_HANDLE_VALUE);
    //
    // Now show every interface
    //
    Error = IpmontrInterfaceEnum((PUCHAR*)&Array, &Count, &Total);
    if (Error) {
        DisplayError(g_hModule, Error);
        return NO_ERROR;
    }
    for (i = 0; i < Count; i++) {
        Error =
            IpmontrGetInfoBlockFromInterfaceInfo(
                Array[i].wszInterfaceName,
                MS_IP_VRRP,
                &Information,
                &Length,
                &Total,
                &Type
                );
        if (!Error) {
            Free(Information);
            ShowVrrpInterfaceInfo(INVALID_HANDLE_VALUE, Array[i].wszInterfaceName);
        }
    }

    DisplayMessageT(DMP_POPD);
    DisplayMessage(g_hModule, DMP_VRRP_FOOTER);
    
    Free(Array);
    return NO_ERROR;
}


DWORD
HandleVrrpInstall(
    PWCHAR MachineName,
    PTCHAR* ArgumentArray,
    DWORD ArgumentIndex,
    DWORD ArgumentCount,
    DWORD CmdFlags,
    PVOID Data,
    BOOL* CommandDone
    )
{
    ULONG Error;
    PUCHAR GlobalInfo;
    ULONG Length;
    if (ArgumentIndex != ArgumentCount) { return ERROR_SHOW_USAGE; }
    //
    // To install the VRRP, we construct the default configuration
    // and add it to the global configuration for the router.
    //
    Error = MakeVrrpGlobalInfo(&GlobalInfo, &Length);
    if (Error) {
        DisplayError(g_hModule, Error);
    } else {
        Error =
            IpmontrSetInfoBlockInGlobalInfo(
                MS_IP_VRRP,
                GlobalInfo,
                Length,
                1
                );
        Free(GlobalInfo);
        if (!Error) {
            DEBUG("Added VRRP");
        } else {
            DisplayError(g_hModule, Error);
        }
        Error = SetArpRetryCount(0);
    }
    return Error;
}

DWORD
HandleVrrpSetGlobal(
    PWCHAR MachineName,
    PTCHAR* ArgumentArray,
    DWORD ArgumentIndex,
    DWORD ArgumentCount,
    DWORD CmdFlags,
    PVOID Data,
    BOOL* CommandDone
    )
{
    ULONG ArgumentsLeft;
    ULONG Error;
    PULONG TagArray;
    PVRRP_GLOBAL_CONFIG pVrrpNewGlobalConfig;
    DWORD LoggingLevel;
    ULONG i;
    ULONG ErrorIndex;
    
    TAG_TYPE TagTypeArray[] = {
        { TOKEN_OPT_LOGGINGLEVEL, FALSE, FALSE }
    };
        
    VERIFY_INSTALLED(MS_IP_VRRP, L"VRRP");
    
    if (ArgumentIndex >= ArgumentCount) {
        return ERROR_SHOW_USAGE;
    }
    
    ArgumentsLeft = ArgumentCount - ArgumentIndex;

    //
    // We convert the optional tags into an array of 'TagTypeArray' indices
    // which guide is in our scanning of the argument list.
    // Since the tags are optional, this process may result in no tags at all,
    // in which case we assume that arguments are specified in exactly the order
    // given in 'TagTypeArray' above.
    //

    Error =
        QueryTagArray(
            &ArgumentArray[ArgumentIndex],
            ArgumentsLeft,
            TagTypeArray,
            NUM_TAGS_IN_TABLE(TagTypeArray),
            &TagArray
            );
    if (Error) { return Error; }

    for (i = 0; i < ArgumentsLeft; i++) {
        switch(TagArray ? TagArray[i] : i) {
            case 0: {
                TOKEN_VALUE TokenArray[] = {
                    { TOKEN_OPT_VALUE_NONE, VRRP_LOGGING_NONE },
                    { TOKEN_OPT_VALUE_ERROR, VRRP_LOGGING_ERROR },
                    { TOKEN_OPT_VALUE_WARN, VRRP_LOGGING_WARN },
                    { TOKEN_OPT_VALUE_INFO, VRRP_LOGGING_INFO }
                };
                Error =
                    MatchEnumTag(
                        g_hModule,
                        ArgumentArray[i + ArgumentIndex],
                        NUM_TOKENS_IN_TABLE(TokenArray),
                        TokenArray,
                        &LoggingLevel
                        );
                if (Error) {
                    Error = ERROR_INVALID_PARAMETER;
                    ErrorIndex = i;
                    i = ArgumentsLeft;
                    break;
                }                                
                
                TagTypeArray[TagArray ? TagArray[i] : i].bPresent = TRUE;
                break;
            }
            default: {
                i = ArgumentsLeft;
                Error = ERROR_INVALID_SYNTAX;
            }
        }
    }
        
    if (!Error) {
        //
        // Ensure that all required parameters are present.
        //
        Error =
            ValidateTagTypeArray(TagTypeArray, NUM_TAGS_IN_TABLE(TagTypeArray));
    }
    if (Error == ERROR_TAG_ALREADY_PRESENT) {
        DisplayMessage(g_hModule, EMSG_TAG_ALREADY_PRESENT);
    } else if (Error == ERROR_INVALID_PARAMETER && TagArray) {
        DispTokenErrMsg(
            g_hModule,
            EMSG_BAD_OPTION_VALUE,
            TagTypeArray[TagArray[ErrorIndex]],
            ArgumentArray[ErrorIndex + ArgumentIndex]
            );
    } else if (!Error){
        Error = CreateVrrpGlobalInfo(&pVrrpNewGlobalConfig,LoggingLevel);
        
        if (!Error) {
            //
            // Update the configuration with the new settings.
            // Note that the update routine may perform additional validation
            // in the process of reconciling the new settings
            // with any existing settings.
            //
            Error = UpdateVrrpGlobalInfo(pVrrpNewGlobalConfig);
            Free(pVrrpNewGlobalConfig);
        }
    }
    return NO_ERROR;
}

DWORD
HandleVrrpSetInterface(
    PWCHAR MachineName,
    PTCHAR* ArgumentArray,
    DWORD ArgumentIndex,
    DWORD ArgumentCount,
    DWORD CmdFlags,
    PVOID Data,
    BOOL* CommandDone
    )
{
    ULONG ArgumentsLeft;
    ULONG BitVector;
    ULONG Error;
    ULONG ErrorIndex = 0;
    ULONG i;
    VRRP_VROUTER_CONFIG VrouterInfo;
    PULONG TagArray;
    WCHAR InterfaceName[MAX_INTERFACE_NAME_LEN + 1];
    TAG_TYPE TagTypeArray[] = {
        { TOKEN_OPT_INTERFACE_NAME, TRUE, FALSE },
        { TOKEN_OPT_VRID, TRUE, FALSE },
        { TOKEN_OPT_AUTH, FALSE, FALSE},
        { TOKEN_OPT_PASSWD, FALSE, FALSE},
        { TOKEN_OPT_ADVTINTERVAL, FALSE, FALSE},
        { TOKEN_OPT_PRIO, FALSE, FALSE},
        { TOKEN_OPT_PREEMPT, FALSE, FALSE}
    };

    VERIFY_INSTALLED(MS_IP_VRRP, L"VRRP");

    if (ArgumentIndex >= ArgumentCount) {
        return ERROR_SHOW_USAGE;
    }
    ArgumentsLeft = ArgumentCount - ArgumentIndex;

    //
    // We convert the optional tags into an array of 'TagTypeArray' indices
    // which guide is in our scanning of the argument list.
    // Since the tags are optional, this process may result in no tags at all,
    // in which case we assume that arguments are specified in exactly the order
    // given in 'TagTypeArray' above.
    //

    Error =
        QueryTagArray(
            &ArgumentArray[ArgumentIndex],
            ArgumentsLeft,
            TagTypeArray,
            NUM_TAGS_IN_TABLE(TagTypeArray),
            &TagArray
            );
    if (Error) { return Error; }

    BitVector = 0;
    ZeroMemory(&VrouterInfo, sizeof(VrouterInfo));

    //
    // We now scan the argument list, converting the arguments
    // into information in our 'VrouterInfo' structure.
    //

    for (i = 0; i < ArgumentsLeft; i++) {
        switch(TagArray ? TagArray[i] : i) {
            case 0: {
                ULONG Length = sizeof(InterfaceName);
                Error =
                    IpmontrGetIfNameFromFriendlyName(
                        ArgumentArray[i + ArgumentIndex], InterfaceName, &Length
                        );
                if (Error) {
                    DisplayMessage(
                        g_hModule, EMSG_NO_INTERFACE,
                        ArgumentArray[i + ArgumentIndex]
                        );
                    Error = ERROR_NO_SUCH_INTERFACE;
                    i = ArgumentsLeft;
                    break;
                }
                TagTypeArray[TagArray ? TagArray[i] : i].bPresent = TRUE;
                break;
            }
            case 1:{  
                BYTE VRIDGiven;

                VRIDGiven = 
                    (UCHAR)_tcstoul(ArgumentArray[i + ArgumentIndex], NULL, 10);
                
                if (VRIDGiven > 255) {
                    DisplayMessage(
                        g_hModule, EMSG_INVALID_VRID,
                        VRIDGiven
                        );
                    Error = ERROR_INVALID_PARAMETER;
                    i = ArgumentsLeft;
                    break;
                }
                VrouterInfo.VRID = (BYTE) VRIDGiven;  
                BitVector |= VRRP_INTF_VRID_MASK;
                TagTypeArray[TagArray ? TagArray[i] : i].bPresent = TRUE;
                break;
            }
            case 2:{
            TOKEN_VALUE TokenArray[] = {
                    { TOKEN_OPT_VALUE_AUTH_NONE, VRRP_AUTHTYPE_NONE },
                    { TOKEN_OPT_VALUE_AUTH_SIMPLE_PASSWORD, VRRP_AUTHTYPE_PLAIN },
                    { TOKEN_OPT_VALUE_AUTH_MD5, VRRP_AUTHTYPE_IPHEAD }
                };
            DWORD dwAuthType;     

                Error =
                    MatchEnumTag(
                        g_hModule,
                        ArgumentArray[i + ArgumentIndex],
                        NUM_TOKENS_IN_TABLE(TokenArray),
                        TokenArray,
                        &dwAuthType
                        );
                VrouterInfo.AuthenticationType = (BYTE) dwAuthType;
                if (Error) {
                    Error = ERROR_INVALID_PARAMETER;
                    ErrorIndex = i;
                    i = ArgumentsLeft;
                    break;
                }                                
                BitVector |= VRRP_INTF_AUTH_MASK;

                TagTypeArray[TagArray ? TagArray[i] : i].bPresent = TRUE;
                break;
            }
            case 3:{
                UINT    Index;
                UINT    PassByte;
                PTCHAR  Token;
				PTCHAR  Password;

#if 0
                //
                // Allocate more space for the tokenizing NULL
                //

				Password = Malloc((2+_tcslen(ArgumentArray[i + ArgumentIndex])) * 
                                  sizeof(TCHAR));

                if (!Password) {
                    Error = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }
                _tcscpy(Password,ArgumentArray[i + ArgumentIndex]);

                ZeroMemory(VrouterInfo.AuthenticationData,VRRP_MAX_AUTHKEY_SIZE);
                Token = _tcstok(Password,L"-");
                for (Index = 0; Index < VRRP_MAX_AUTHKEY_SIZE; Index++) {
                    PassByte = _tcstoul(Token, NULL, 10);
                    if (PassByte > 255) {
                        Error = ERROR_INVALID_PARAMETER;
                        i = ArgumentsLeft;
                        break;
                    }
                    VrouterInfo.AuthenticationData[Index] = PassByte & 0xff;
                    Token = _tcstok(NULL,"-");
                    if (!Token) {
                        break;
                    }
                }
                Free(Password);
                if (Error) {
                    break;
                }
#else
				Password = ArgumentArray[i + ArgumentIndex];
                for (Index = 0; Index < VRRP_MAX_AUTHKEY_SIZE; Index++) {
                    PassByte = _tcstoul(Password, NULL, 10);
                    if (PassByte > 255) {
                        Error = ERROR_INVALID_PARAMETER;
                        i = ArgumentsLeft;
                        break;
                    }
                    VrouterInfo.AuthenticationData[Index] = PassByte & 0xff;
                    Password = _tcschr(Password,_T('-'));
                    if (!Password) {
                        break;
                    }
					Password ++;
                }
#endif

                BitVector |= VRRP_INTF_PASSWD_MASK;
                TagTypeArray[TagArray ? TagArray[i] : i].bPresent = TRUE;
                break;
            }
            case 4:{
                BYTE AdvtIntvl;
                AdvtIntvl = (UCHAR)
                    _tcstoul(ArgumentArray[i + ArgumentIndex], NULL, 10);
                
                if (AdvtIntvl > 255) {
                    Error = ERROR_INVALID_PARAMETER;
                    i = ArgumentsLeft;
                    break;
                }
                VrouterInfo.AdvertisementInterval = (BYTE) AdvtIntvl;  
                BitVector |= VRRP_INTF_ADVT_MASK;
                TagTypeArray[TagArray ? TagArray[i] : i].bPresent = TRUE;
                break;
            }
            case 5:{
                BYTE ConfigPrio;
                ConfigPrio = (UCHAR)
                    _tcstoul(ArgumentArray[i + ArgumentIndex], NULL, 10);
    
                if (ConfigPrio > 255) {
                    Error = ERROR_INVALID_PARAMETER;
                    i = ArgumentsLeft;
                    break;
                }
                VrouterInfo.ConfigPriority = (BYTE) ConfigPrio;  
                BitVector |= VRRP_INTF_PRIO_MASK;
                TagTypeArray[TagArray ? TagArray[i] : i].bPresent = TRUE;
                break;
            }
            case 6:{
                TOKEN_VALUE TokenArray[] = {
                        { TOKEN_OPT_VALUE_ENABLE, TRUE },
                        { TOKEN_OPT_VALUE_DISABLE, FALSE }
                    };
                Error =
                    MatchEnumTag(
                        g_hModule,
                        ArgumentArray[i + ArgumentIndex],
                        NUM_TOKENS_IN_TABLE(TokenArray),
                        TokenArray,
                        &VrouterInfo.PreemptMode
                        );
                if (Error) {
                    Error = ERROR_INVALID_PARAMETER;
                    ErrorIndex = i;
                    i = ArgumentsLeft;
                    break;
                }                                
                BitVector |= VRRP_INTF_PREEMPT_MASK;

                TagTypeArray[TagArray ? TagArray[i] : i].bPresent = TRUE;
                break;
            }
        }
    }
    if (!Error) {
        //
        // Ensure that all required parameters are present.
        //
        Error =
            ValidateTagTypeArray(TagTypeArray, NUM_TAGS_IN_TABLE(TagTypeArray));
    }
    if (Error == ERROR_TAG_ALREADY_PRESENT) {
        DisplayMessage(g_hModule, EMSG_TAG_ALREADY_PRESENT);
    } else if (Error == ERROR_INVALID_PARAMETER && TagArray) {
        DispTokenErrMsg(
            g_hModule,
            EMSG_BAD_OPTION_VALUE,
            TagTypeArray[TagArray[ErrorIndex]],
            ArgumentArray[ErrorIndex + ArgumentIndex]
            );
    } else if (!Error && (BitVector)) {
        //
        // Update the configuration with the new settings.
        // Note that the update routine may perform additional validation
        // in the process of reconciling the new settings
        // with any existing settings.
        //
        Error =
            UpdateVrrpInterfaceInfo(
                InterfaceName, &VrouterInfo, BitVector, FALSE
                );
    }
    if (TagArray) { Free(TagArray); }
    return Error; 
}

DWORD
HandleVrrpShowGlobal(
    PWCHAR MachineName,
    PTCHAR* ArgumentArray,
    DWORD ArgumentIndex,
    DWORD ArgumentCount,
    DWORD CmdFlags,
    PVOID Data,
    BOOL* CommandDone
    )
{
    if (ArgumentIndex != ArgumentCount) { return ERROR_SHOW_USAGE; }
    ShowVrrpGlobalInfo(NULL);
    return NO_ERROR;
}

DWORD
HandleVrrpShowInterface(
    PWCHAR MachineName,
    PTCHAR* ArgumentArray,
    DWORD ArgumentIndex,
    DWORD ArgumentCount,
    DWORD CmdFlags,
    PVOID Data,
    BOOL* CommandDone
    )
{
    ULONG ArgumentsLeft;
    ULONG Error;
    PULONG TagArray;
    WCHAR InterfaceName[MAX_INTERFACE_NAME_LEN + 1];
    TAG_TYPE TagTypeArray[] = {
        { TOKEN_OPT_INTERFACE_NAME, TRUE, FALSE }
    };

    VERIFY_INSTALLED(MS_IP_VRRP, L"VRRP");

    if (ArgumentIndex >= ArgumentCount) {
        return ERROR_SHOW_USAGE;
    }
    ArgumentsLeft = ArgumentCount - ArgumentIndex;

    //
    // We convert the optional tags into an array of 'TagTypeArray' indices
    // which guide is in our scanning of the argument list.
    // Since the tags are optional, this process may result in no tags at all,
    // in which case we assume that arguments are specified in exactly the order
    // given in 'TagTypeArray' above.
    //

    Error =
        QueryTagArray(
            &ArgumentArray[ArgumentIndex],
            ArgumentsLeft,
            TagTypeArray,
            NUM_TAGS_IN_TABLE(TagTypeArray),
            &TagArray
            );
    if (Error) { return Error; }

    //
    // If any tags were specified, the only one present must refer
    // to the interface name which is index '0' in 'TagTypeArray'.
    // If no tags were specified, we assume the argument is an interface name,
    // and we retrieve its friendly name in order to delete it.
    //

    if (TagArray && TagArray[0] != 0) {
        Free(TagArray);
        return ERROR_SHOW_USAGE;
    } else {
        ULONG Length = sizeof(InterfaceName);
        Error =
            IpmontrGetIfNameFromFriendlyName(
                ArgumentArray[ArgumentIndex], InterfaceName, &Length
                );
    }
    if (!Error) {
           Error = ShowVrrpInterfaceInfo(NULL, InterfaceName);
    }
    if (TagArray) { Free(TagArray); }
    return Error;                
}


DWORD
HandleVrrpUninstall(
    PWCHAR MachineName,
    PTCHAR* ArgumentArray,
    DWORD ArgumentIndex,
    DWORD ArgumentCount,
    DWORD CmdFlags,
    PVOID Data,
    BOOL* CommandDone
    )
{
    ULONG Error;
    if (ArgumentIndex != ArgumentCount) { return ERROR_SHOW_USAGE; }
    Error = IpmontrDeleteProtocol(MS_IP_VRRP);
    if (!Error) { DEBUG("Deleted VRRP"); }
    Error = SetArpRetryCount(3);
    return Error;
}

ULONG
QueryTagArray(
    PTCHAR ArgumentArray[],
    ULONG ArgumentCount,
    TAG_TYPE TagTypeArray[],
    ULONG TagTypeCount,
    OUT PULONG* TagArray
    )
{
    ULONG Error;
    ULONG i;

    if (!_tcsstr(ArgumentArray[0], ptszDelimiter)) {
        *TagArray = NULL;
        return NO_ERROR;
    }

    *TagArray = Malloc(ArgumentCount * sizeof(ULONG));
    if (!*TagArray) {
        DisplayMessage(g_hModule, EMSG_NOT_ENOUGH_MEMORY);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    Error = 
        MatchTagsInCmdLine(
            g_hModule,
            ArgumentArray,
            0,
            ArgumentCount,
            TagTypeArray,
            TagTypeCount,
            *TagArray
            );
    if (Error) {
        Free(*TagArray);
        *TagArray = NULL;
        if (Error == ERROR_INVALID_OPTION_TAG) {
            return ERROR_INVALID_SYNTAX;
        }
        return ERROR_INVALID_PARAMETER;
    }

    return NO_ERROR;
}

ULONG
ValidateTagTypeArray(
    TAG_TYPE TagTypeArray[],
    ULONG TagTypeCount
    )
{
    ULONG i;
    //
    // Verify that all required tokens are present.
    //
    for (i = 0; i < TagTypeCount; i++) {
        if ((TagTypeArray[i].dwRequired & NS_REQ_PRESENT)
         && !TagTypeArray[i].bPresent) {
            return ERROR_INVALID_SYNTAX;
        }
    }
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ip\sample\prstring.h ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    sample\prstring.h

Abstract:

    The file contains definitions of command line option tag strings.

--*/

////////////////////////////////////////
// TOKENS
////////////////////////////////////////

#define TOKEN_SAMPLE                        L"sample"

#define MSG_HELP_START                      L"%1!-14s! - "

// Loglevels
#define TOKEN_NONE                          L"NONE"
#define TOKEN_ERROR                         L"ERROR"
#define TOKEN_WARN                          L"WARN"
#define TOKEN_INFO                          L"INFO"

// Tokens for sample global options
#define TOKEN_LOGLEVEL                      L"loglevel"

// Tokens for sample interface options
#define TOKEN_NAME                          L"name"
#define TOKEN_METRIC                        L"metric"

// Tokens for sample mib commands
#define TOKEN_GLOBALSTATS                   L"globalstats"
#define TOKEN_IFSTATS                       L"ifstats"
#define TOKEN_IFBINDING                     L"ifbinding"

#define TOKEN_INDEX                         L"index"
#define TOKEN_RR                            L"rr"



////////////////////////////////////////
// Configuration commands
////////////////////////////////////////

// Commands supported by most protocols
#define CMD_INSTALL                         L"install"
#define CMD_UNINSTALL                       L"uninstall"
#define CMD_DUMP                            L"dump"
#define CMD_HELP1                           L"help"
#define CMD_HELP2                           L"?"

#define CMD_GROUP_ADD                       L"add"
#define CMD_GROUP_DELETE                    L"delete"
#define CMD_GROUP_SET                       L"set"
#define CMD_GROUP_SHOW                      L"show"


// Commands supported by SAMPLE

// add commands
#define CMD_SAMPLE_ADD_IF                   L"interface"


// delete commands
#define CMD_SAMPLE_DEL_IF                   L"interface"


// set commands
#define CMD_SAMPLE_SET_GLOBAL               L"global"
#define CMD_SAMPLE_SET_IF                   L"interface"


// show commands
#define CMD_SAMPLE_SHOW_GLOBAL              L"global"
#define CMD_SAMPLE_SHOW_IF                  L"interface"
#define CMD_SAMPLE_MIB_SHOW_STATS           L"globalstats"
#define CMD_SAMPLE_MIB_SHOW_IFSTATS         L"ifstats"
#define CMD_SAMPLE_MIB_SHOW_IFBINDING       L"ifbinding"



////////////////////////////////////////
// Dump information
////////////////////////////////////////

#define DMP_POPD                            L"popd\n"
#define DMP_SAMPLE_PUSHD                    L"pushd routing ip sample\n"

#define DMP_SAMPLE_INSTALL                  L"install\n"
#define DMP_SAMPLE_UNINSTALL                L"uninstall\n"

#define DMP_SAMPLE_ADD_INTERFACE            L"\
add interface name=%1!s! metric=%2!u!\n"
#define DMP_SAMPLE_SET_GLOBAL               L"\
set global loglevel=%1!s!\n"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ip\sample\ipsamplerm.h ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    ipsamplerm.h

Abstract:

    The file contains type definitions and declarations for SAMPLE, the
    sample ip protocol, used by the IP Router Manager.

--*/

#ifndef _IPSAMPLERM_H_
#define _IPSAMPLERM_H_


// useful for variable sized structs
#undef  ANY_SIZE
#define ANY_SIZE 0



//----------------------------------------------------------------------------
// CONSTANT AND MACRO DECLARATIONS
//----------------------------------------------------------------------------

#define PROTO_IP_SAMPLE 200
#define MS_IP_SAMPLE    \
PROTOCOL_ID(PROTO_TYPE_UCAST, PROTO_VENDOR_MS0, PROTO_IP_SAMPLE)

#define SAMPLE_PROTOCOL_MULTICAST_GROUP ((DWORD)0x640000E0) // 224.0.0.100
    
    
//----------------------------------------------------------------------------
// constants identifying IPSAMPLE's MIB tables
//----------------------------------------------------------------------------

#define IPSAMPLE_GLOBAL_STATS_ID        0
#define IPSAMPLE_GLOBAL_CONFIG_ID       1
#define IPSAMPLE_IF_STATS_ID            2
#define IPSAMPLE_IF_CONFIG_ID           3
#define IPSAMPLE_IF_BINDING_ID          4


//----------------------------------------------------------------------------
// constants used for the field IPSAMPLE_GLOBAL_CONFIG::dwLoggingLevel
//----------------------------------------------------------------------------

#define IPSAMPLE_LOGGING_NONE           0
#define IPSAMPLE_LOGGING_ERROR          1
#define IPSAMPLE_LOGGING_WARN           2
#define IPSAMPLE_LOGGING_INFO           3



//----------------------------------------------------------------------------
// constants used for the field IPSAMPLE_IF_CONFIG::ulMetric
//----------------------------------------------------------------------------

#define IPSAMPLE_METRIC_INFINITE        16

    
    
//----------------------------------------------------------------------------
// constants used to construct the field IPSAMPLE_IF_BINDING::dwState
//----------------------------------------------------------------------------
    
#define IPSAMPLE_STATE_ACTIVE           0x00000001
#define IPSAMPLE_STATE_BOUND            0x00000002
    


//----------------------------------------------------------------------------
// STRUCTURE DEFINITIONS
//----------------------------------------------------------------------------



//----------------------------------------------------------------------------
// struct:      IPSAMPLE_GLOBAL_STATS
//
// This MIB entry stores global statistics for IPSAMPLE;
// There is only one instance, so this entry has no index.
//
// This structure is read-only.
//----------------------------------------------------------------------------

typedef struct _IPSAMPLE_GLOBAL_STATS
{
    ULONG       ulNumInterfaces; // # interfaces added
} IPSAMPLE_GLOBAL_STATS, *PIPSAMPLE_GLOBAL_STATS;



//----------------------------------------------------------------------------
// struct:      IPSAMPLE_GLOBAL_CONFIG
//
// This MIB entry stores global configuration for IPSAMPLE
// There is only one instance, so this entry has no index.
//----------------------------------------------------------------------------

typedef struct _IPSAMPLE_GLOBAL_CONFIG
{
    DWORD       dwLoggingLevel;
} IPSAMPLE_GLOBAL_CONFIG, *PIPSAMPLE_GLOBAL_CONFIG;



//----------------------------------------------------------------------------
// struct:      IPSAMPLE_IF_STATS
//
// This MIB entry stores per-interface statistics for IPSAMPLE.
//
// This structure is read-only.
//----------------------------------------------------------------------------

typedef struct _IPSAMPLE_IF_STATS
{
    ULONG       ulNumPackets;   // # packets sent out this interface
} IPSAMPLE_IF_STATS, *PIPSAMPLE_IF_STATS;



//----------------------------------------------------------------------------
// struct:      IPSAMPLE_IF_CONFIG
//
// This MIB entry describes per-interface configuration.
// All IP address fields must be in network order.
//----------------------------------------------------------------------------

typedef struct _IPSAMPLE_IF_CONFIG
{
    ULONG       ulMetric;
} IPSAMPLE_IF_CONFIG, *PIPSAMPLE_IF_CONFIG;



//----------------------------------------------------------------------------
// struct:      IPSAMPLE_IF_BINDING
//
// This MIB entry contains the table of IP addresses to which each
// interface is bound.  All IP addresses are in network order.
//
// THIS STRUCTURE IS VARIABLE LENGTH:
//
//  The base structure contains of the field ulCount, which gives the
//  number of IP addresses to which the indexed interface is bound.  The
//  IP addresses themselves follow the base structure, and are given as
//  IPSAMPLE_IP_ADDRESS structures.
//
// This MIB entry is read-only.
//----------------------------------------------------------------------------

typedef struct _IPSAMPLE_IF_BINDING
{
    DWORD       dwState;
    ULONG       ulCount;
} IPSAMPLE_IF_BINDING, *PIPSAMPLE_IF_BINDING;




//----------------------------------------------------------------------------
// struct:      IPSAMPLE_IP_ADDRESS
//
// This structure is used for storing interface bindings.  A series of
// structures of this type follows the IPSAMPLE_IF_BINDING structure
// (described above).
//
// Both fields are IP address fields in network-order.
//----------------------------------------------------------------------------

typedef struct _IPSAMPLE_IP_ADDRESS
{
    DWORD       dwAddress;
    DWORD       dwMask;
} IPSAMPLE_IP_ADDRESS, *PIPSAMPLE_IP_ADDRESS;



//----------------------------------------------------------------------------
// macros for manipulating the variable-length IPSAMPLE_IF_BINDING structure
//
// IPSAMPLE_IF_BINDING_SIZE computes the size of a binding structure.
//
// IPSAMPLE_IF_ADDRESS_TABLE computes the starting address in a binding
//      struct of the series of IPSAMPLE_IP_ADDRESS structures which are
//      the bindings for the interface in question.
//
// e.g.
//      PIPSAMPLE_IF_BINDING piibSource, piibDest;
//
//      piibDest = malloc(IPSAMPLE_IF_BINDING_SIZE(piibSource));
//      memcpy(piibDest, piibSource, IPSAMPLE_IF_BINDING_SIZE(piibSource));
//
// e.g.
//      ULONG                   i;
//      PIPSAMPLE_IF_BINDING    piib;
//      PIPSAMPLE_IP_ADDRESS    *piia;
//
//      piia = IPSAMPLE_IF_ADDRESS_TABLE(piib);
//      for (i = 0; i < piib->ulCount; i++)
//      {
//          printf("%s-", inet_ntoa(*(struct in_addr *)&piia->dwAddress));
//          printf("%s\n", inet_ntoa(*(struct in_addr *)&piia->dwMask));
//      }
//----------------------------------------------------------------------------

#define IPSAMPLE_IF_BINDING_SIZE(bind)                          \
    (sizeof(IPSAMPLE_IF_BINDING) +                              \
     (bind)->ulCount * sizeof(IPSAMPLE_IP_ADDRESS))

#define IPSAMPLE_IF_ADDRESS_TABLE(bind)                         \
    ((PIPSAMPLE_IP_ADDRESS)((bind) + 1))

        

//----------------------------------------------------------------------------
// The following structures are used to query the MIB and get back a
// response.  The TypeID field is one of the IDs #defined above.  The
// IfIndex is used to reference an interface table entry .  For sample
// it corresponds to an ip address, and hence is a single DWORD for now.
// In general the index could be a variable size array of DWORDs.
//----------------------------------------------------------------------------

        

//----------------------------------------------------------------------------
// struct:      IPSAMPLE_MIB_SET_INPUT_DATA
//
// This is passed as input data for MibSet.
// Note that only global config and interface config can be set.
//----------------------------------------------------------------------------

typedef struct _IPSAMPLE_MIB_SET_INPUT_DATA
{
    DWORD       IMSID_TypeID;
    DWORD       IMSID_IfIndex;
    DWORD       IMSID_BufferSize;
    BYTE        IMSID_Buffer[ANY_SIZE];
} IPSAMPLE_MIB_SET_INPUT_DATA, *PIPSAMPLE_MIB_SET_INPUT_DATA;



//----------------------------------------------------------------------------
// struct:      IPSAMPLE_MIB_GET_INPUT_DATA
//
// This is passed as input data for MibGet, MibGetFirst, MibGetNext.  All
// tables are readable.  All IP addresses must be in network order.
//----------------------------------------------------------------------------

typedef struct _IPSAMPLE_MIB_GET_INPUT_DATA
{
    DWORD   IMGID_TypeID;
    DWORD   IMGID_IfIndex;
} IPSAMPLE_MIB_GET_INPUT_DATA, *PIPSAMPLE_MIB_GET_INPUT_DATA;



//----------------------------------------------------------------------------
// struct:      IPSAMPLE_MIB_GET_OUTPUT_DATA
//
// This is written into the output data by MibGet, MibGetFirst, MibGetNext.
//----------------------------------------------------------------------------

typedef struct _IPSAMPLE_MIB_GET_OUTPUT_DATA
{
    DWORD   IMGOD_TypeID;
    DWORD   IMGOD_IfIndex;

    BYTE    IMGOD_Buffer[ANY_SIZE];
} IPSAMPLE_MIB_GET_OUTPUT_DATA, *PIPSAMPLE_MIB_GET_OUTPUT_DATA;

#endif // _IPSAMPLERM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ip\sample\sample.c ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    sample\sample.c

Abstract:

    The file contains the command dispatcher for the sample IP protocol.
    
--*/

#include "precomp.h"
#pragma hdrstop


// global information for the sample context
CONTEXT_ENTRY                   g_ceSample;

////////////////////////////////////////
// Configuration Data For Sample
////////////////////////////////////////

// default global configuration
static IPSAMPLE_GLOBAL_CONFIG   isDefaultGlobal =
{
    IPSAMPLE_LOGGING_INFO               // tag LOGLEVEL
};

// default interface configuration
static IPSAMPLE_IF_CONFIG       isDefaultInterface =
{
    0                                   // tag METRIC
};


// table of ADD commands
static CMD_ENTRY                isAddCmdTable[] =
{
    CREATE_CMD_ENTRY(SAMPLE_ADD_IF,             HandleSampleAddIf),
};

// table of DELETE commands
static CMD_ENTRY                isDeleteCmdTable[] =
{
    CREATE_CMD_ENTRY(SAMPLE_DEL_IF,             HandleSampleDelIf),
};

// table of SET commands
static CMD_ENTRY                isSetCmdTable[] =
{
    CREATE_CMD_ENTRY(SAMPLE_SET_GLOBAL,         HandleSampleSetGlobal),
    CREATE_CMD_ENTRY(SAMPLE_SET_IF,             HandleSampleSetIf),
};

// table of SHOW commands
static CMD_ENTRY                isShowCmdTable[] =
{
    CREATE_CMD_ENTRY(SAMPLE_SHOW_GLOBAL,        HandleSampleShowGlobal),
    CREATE_CMD_ENTRY(SAMPLE_SHOW_IF,            HandleSampleShowIf),
    CREATE_CMD_ENTRY(SAMPLE_MIB_SHOW_STATS,     HandleSampleMibShowObject),
    CREATE_CMD_ENTRY(SAMPLE_MIB_SHOW_IFSTATS,   HandleSampleMibShowObject),
    CREATE_CMD_ENTRY(SAMPLE_MIB_SHOW_IFBINDING, HandleSampleMibShowObject),
};

// table of above group commands
static CMD_GROUP_ENTRY          isGroupCmds[] = 
{
    CREATE_CMD_GROUP_ENTRY(GROUP_ADD,           isAddCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_DELETE,        isDeleteCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_SET,           isSetCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_SHOW,          isShowCmdTable),
};


// table of top commands (non group)
static CMD_ENTRY                isTopCmds[] =
{
    CREATE_CMD_ENTRY(INSTALL,                   HandleSampleInstall),
    CREATE_CMD_ENTRY(UNINSTALL,                 HandleSampleUninstall),
};


// dump function
DWORD
WINAPI
SampleDump(
    IN  LPCWSTR pwszMachine,
    IN  WCHAR   **ppwcArguments,
    IN  DWORD   dwArgCount,
    IN  PVOID   pvData
    )
{
    DWORD   dwErr;
    HANDLE  hFile = (HANDLE)-1;

    DisplayMessage(g_hModule, DMP_SAMPLE_HEADER);
    DisplayMessageT(DMP_SAMPLE_PUSHD);
    DisplayMessageT(DMP_SAMPLE_UNINSTALL);

    // dump SAMPLE global configuration
    SgcShow(FORMAT_DUMP) ;
    // dump SAMPLE configuration for all interfaces
    SicShowAll(FORMAT_DUMP) ;

    DisplayMessageT(DMP_POPD);
    DisplayMessage(g_hModule, DMP_SAMPLE_FOOTER);

    return NO_ERROR;
}



VOID
SampleInitialize(
    )
/*++

Routine Description
    Initialize sample's information.  Called by IpsamplemonStartHelper.

Arguments
    None

Return Value
    None

--*/
{
    // context version
    g_ceSample.dwVersion        = SAMPLE_CONTEXT_VERSION;

    // context identifying string
    g_ceSample.pwszName         = TOKEN_SAMPLE;
    
    // top level (non group) commands
    g_ceSample.ulNumTopCmds     = sizeof(isTopCmds)/sizeof(CMD_ENTRY);
    g_ceSample.pTopCmds         = isTopCmds;
            
    // group commands
    g_ceSample.ulNumGroupCmds   = sizeof(isGroupCmds)/sizeof(CMD_GROUP_ENTRY);
    g_ceSample.pGroupCmds       = isGroupCmds;

    // default configuration
    g_ceSample.pDefaultGlobal   = (PBYTE) &isDefaultGlobal;
    g_ceSample.pDefaultInterface= (PBYTE) &isDefaultInterface;

    // dump function
    g_ceSample.pfnDump          = SampleDump;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ip\sample\sample.h ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    sample\sample.h

Abstract:

    The file contains the header for sample.c,
    the command dispatcher for the sample IP protocol.

--*/

// functions...
VOID
SampleInitialize(
    );



// typedefs...
typedef struct _CONTEXT_ENTRY   // global information for a context
{
    // context' version
    DWORD               dwVersion;

    // context' identifying string
    PWSTR               pwszName;

    // top level (non group) commands
    ULONG               ulNumTopCmds;
    CMD_ENTRY           *pTopCmds;

    // group commands
    ULONG               ulNumGroupCmds;
    CMD_GROUP_ENTRY     *pGroupCmds;

    // default configuration
    PBYTE               pDefaultGlobal;
    PBYTE               pDefaultInterface;

    // dump function
    PNS_CONTEXT_DUMP_FN pfnDump;
} CONTEXT_ENTRY, *PCONTEXT_ENTRY;



// globals...

// information for the sample context
CONTEXT_ENTRY                           g_ceSample;



// constants...

// context's version
#define SAMPLE_CONTEXT_VERSION          1

// parameters passed to set global...
#define SAMPLE_LOG_MASK                 0x00000001

// parameters passed to add/set interface
#define SAMPLE_IF_METRIC_MASK           0x00000001
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ip\sample\samplegetopt.c ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    sample\samplegetopt.c

Abstract:

    The file contains functions to handle SAMPLE commands.

    All command handlers take the following parameters...
    pwszMachineName     
    *ppwcArguments      argument array
    dwCurrentIndex      ppwcArguments[dwCurrentIndex] is the first argument
    dwArgCount          ppwcArguments[dwArgCount - 1] is the last argument
    dwFlags
    hMibServer
    *pbDone

    
    The handlers return the following values
    Success...
    NO_ERROR                command succeeded, don't display another message.
    ERROR_OKAY              command succeeded, display "Ok." message.

    Failure...
    ERROR_SUPPRESS_OUTPUT   command failed, don't display another message.
    ERROR_SHOW_USAGE        display extended help for the command.
    ERROR_INVALID_SYNTAX    display invalid syntax message and extended help.

    
    The command handlers call the following function to parse arguments
    PreprocessCommand(
        IN  HANDLE    hModule,          // handle passed to DllMain
        IN  PCHAR     *ppwcArguments,   // argument array
        IN  DWORD     dwCurrentIndex,   // ppwcArguments[dwCurrentIndex]: first
        IN  DWORD     dwArgCount,       // ppwcArguments[dwArgCount-1]  : last
        IN  TAG_TYPE  *pttTags,         // legal tags
        IN  DWORD     dwTagCount,       // # entries in pttTags
        IN  DWORD     dwMinArgs,        // min # arguments required
        IN  DWORD     dwMaxArgs,        // max # arguments required
        OUT DWORD     *pdwTagType       // output
        )
    The preprocessor performs the following functions
    . ensures the number of tags present is valid.
    . ensures there are no duplicate or unrecognized tags.
    . ensures every 'required' tag is present.
    . leaves the tag index of each argument in pdwTagType.
    . removes 'tag='  from each argument.

    
    For tags that take a specific set of values, this function is called
    MatchEnumTag(
        IN  HANDLE          hModule,    // handle passed to DllMain
        IN  LPWSTR          pwcArgument,// argument to process 
        IN  DWORD           dwNumValues,// number of possible values 
        IN  PTOKEN_VALUE    pEnumTable, // array of possible values
        OUT PDWORD          pdwValue    // output
        )
    This performs the following functions
    . matches argument with the set of values specified.
    . returns corresponding value.
        
--*/

#include "precomp.h"
#pragma hdrstop

DWORD
WINAPI
HandleSampleSetGlobal(
    IN      LPCWSTR                 pwszMachineName,
    IN OUT  LPWSTR                 *ppwcArguments,
    IN      DWORD                   dwCurrentIndex,
    IN      DWORD                   dwArgCount,
    IN      DWORD                   dwFlags,
    IN      MIB_SERVER_HANDLE       hMibServer,
    IN      BOOL                    *pbDone
    )
/*++

Routine Description:
    Gets options for SET GLOBAL

--*/
{
    DWORD                   dwErr = NO_ERROR;
    
    TAG_TYPE                pttTags[] =
    {
        {TOKEN_LOGLEVEL,    FALSE,  FALSE}  // LOGLEVEL tag optional
    };
    DWORD                   pdwTagType[NUM_TAGS_IN_TABLE(pttTags)];
    DWORD                   dwNumArg;
    ULONG                   i;
    
    IPSAMPLE_GLOBAL_CONFIG  igcGlobalConfiguration;
    DWORD                   dwBitVector = 0;
    

    // SAMPLE should be installed for this command to complete
    VerifyInstalled(MS_IP_SAMPLE, STRING_PROTO_SAMPLE);

    // preprocess the command
    dwErr = PreprocessCommand(g_hModule,
                              ppwcArguments,
                              dwCurrentIndex,
                              dwArgCount,
                              pttTags,
                              NUM_TAGS_IN_TABLE(pttTags),
                              0,
                              NUM_TAGS_IN_TABLE(pttTags),
                              pdwTagType);
    if (dwErr isnot NO_ERROR)
        return dwErr;

    // process all arguments
    dwNumArg = dwArgCount - dwCurrentIndex;
    for (i = 0; i < dwNumArg; i++)
    {
        switch (pdwTagType[i])
        {
            case 0 :
            {
                // tag LOGLEVEL
                DWORD       dwLogLevel;
                TOKEN_VALUE rgtvEnums[] = 
                {
                    {TOKEN_NONE,    IPSAMPLE_LOGGING_NONE},
                    {TOKEN_ERROR,   IPSAMPLE_LOGGING_ERROR},
                    {TOKEN_WARN,    IPSAMPLE_LOGGING_WARN},
                    {TOKEN_INFO,    IPSAMPLE_LOGGING_INFO}
                };
                
                dwErr = MatchEnumTag(g_hModule,
                                     ppwcArguments[i + dwCurrentIndex],
                                     NUM_TOKENS_IN_TABLE(rgtvEnums),
                                     rgtvEnums,
                                     &dwLogLevel);                
                if (dwErr isnot NO_ERROR)
                {
                    dwErr = ERROR_INVALID_PARAMETER;
                    break;
                }    

                igcGlobalConfiguration.dwLoggingLevel = dwLogLevel;
                dwBitVector |= SAMPLE_LOG_MASK;
                break;
            }
            
            default:
            {
                dwErr = ERROR_INVALID_SYNTAX;
                break;
            }
        } // switch

        if (dwErr isnot NO_ERROR)
            break ;
    } // for


    // process error
    if (dwErr isnot NO_ERROR)
    {
        ProcessError();
        return dwErr;
    }
    
    // update SAMPLE global configuration
    if (dwBitVector)
        dwErr = SgcUpdate(&igcGlobalConfiguration, dwBitVector);

    return (dwErr is NO_ERROR) ? ERROR_OKAY : dwErr ;
}



DWORD
WINAPI
HandleSampleShowGlobal(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description:
    Gets options for SHOW GLOBAL
    
--*/
{
    // SAMPLE should be installed for this command to complete
    VerifyInstalled(MS_IP_SAMPLE, STRING_PROTO_SAMPLE);

    // does not expect any arguments. report error if any specified.
    if (dwCurrentIndex isnot dwArgCount)
        return ERROR_INVALID_SYNTAX;

    // show SAMPLE global configuration
    return SgcShow(FORMAT_VERBOSE);
}



DWORD
GetInterfaceOptions(
    IN  PWCHAR                  *ppwcArguments,
    IN  DWORD                   dwCurrentIndex,
    IN  DWORD                   dwArgCount,
    OUT PWCHAR                  pwszInterfaceGuid,
    OUT PIPSAMPLE_IF_CONFIG     piicNew,
    OUT DWORD                   *pdwBitVector
    )
/*++

Routine Description:
    Gets options for SET INTERFACE and ADD INTERFACE.

Arguments:
    pwszInterfaceGuid           guid for the specified interface. Size of this
                                buffer should be
                                (MAX_INTERFACE_NAME_LEN+1)*sizeof(WCHAR)
    piicNew                     configuration containing changed values
    pdwBitVector                which values have changed

--*/
{
    DWORD                   dwErr = NO_ERROR;
    
    TAG_TYPE                pttTags[] =
    {
        {TOKEN_NAME,        TRUE,   FALSE}, // NAME tag required 
        {TOKEN_METRIC,      FALSE,  FALSE}, // METRIC tag optional
    };
    DWORD                   pdwTagType[NUM_TAGS_IN_TABLE(pttTags)];
    DWORD                   dwNumArg;
    DWORD                   dwBufferSize = MAX_INTERFACE_NAME_LEN + 1;
    ULONG                   i;
    
    // dwBufferSize is the size of the pwszInterfaceGuid buffer. 
    // All invocations of this api should pass in a 
    // (MAX_INTERFACE_NAME_LEN+1) element array of WCHARs as 
    // the pwszInterfaceGuid parameter.
    dwBufferSize = (MAX_INTERFACE_NAME_LEN + 1)*sizeof(WCHAR);

    // preprocess the command
    dwErr = PreprocessCommand(g_hModule,
                              ppwcArguments,
                              dwCurrentIndex,
                              dwArgCount,
                              pttTags,
                              NUM_TAGS_IN_TABLE(pttTags),
                              1,
                              NUM_TAGS_IN_TABLE(pttTags),
                              pdwTagType);
    if (dwErr isnot NO_ERROR)
        return dwErr;

    // process all arguments
    dwNumArg = dwArgCount - dwCurrentIndex;
    for (i = 0; i < dwNumArg; i++)
    {
        switch (pdwTagType[i])
        {
            case 0 :
            {
                // tag NAME
                dwErr = InterfaceGuidFromName(
                    ppwcArguments[i+dwCurrentIndex],
                    pwszInterfaceGuid,
                    &dwBufferSize);
                break;
            }
            
            case 1:
            {
                // tag METRIC
                piicNew->ulMetric = wcstoul(ppwcArguments[i+dwCurrentIndex],
                                            NULL,
                                            10);
                *pdwBitVector |= SAMPLE_IF_METRIC_MASK;
                break;
            }
            
            default:
            {
                dwErr = ERROR_INVALID_SYNTAX;
                break;
            }
        } // switch

        if (dwErr isnot NO_ERROR)
            break ;
    } // for

    
    // process error
    if (dwErr isnot NO_ERROR)
        ProcessError();

    return dwErr;
}



DWORD
WINAPI
HandleSampleAddIf(
    IN  PWCHAR                  pwszMachineName,
    IN  PWCHAR                  *ppwcArguments,
    IN  DWORD                   dwCurrentIndex,
    IN  DWORD                   dwArgCount,
    IN  DWORD                   dwFlags,
    IN  MIB_SERVER_HANDLE       hMibServer,
    IN  BOOL                    *pbDone
    )
/*++

Routine Description:
    Gets options for ADD INTERFACE 

--*/
{
    DWORD               dwErr = NO_ERROR;
    WCHAR               pwszInterfaceGuid[MAX_INTERFACE_NAME_LEN + 1] = L"\0";
    IPSAMPLE_IF_CONFIG  iicNew;
    DWORD               dwBitVector = 0;

    
    // SAMPLE should be installed for this command to complete
    VerifyInstalled(MS_IP_SAMPLE, STRING_PROTO_SAMPLE);

    // get optional parameters that are also being set
    dwErr = GetInterfaceOptions(ppwcArguments,
                                dwCurrentIndex,
                                dwArgCount,
                                pwszInterfaceGuid,
                                &iicNew,
                                &dwBitVector);
    if (dwErr isnot NO_ERROR)
        return dwErr;
    
    // make sure that the interface does not already exist in the config
    if (IsInterfaceInstalled(pwszInterfaceGuid, MS_IP_SAMPLE))
    {
        DisplayError(g_hModule, EMSG_INTERFACE_EXISTS, pwszInterfaceGuid);
        return ERROR_SUPPRESS_OUTPUT;
    }

    // add SAMPLE interface configuration
    dwErr = SicUpdate(pwszInterfaceGuid, &iicNew, dwBitVector, TRUE);
    
    return (dwErr is NO_ERROR) ? ERROR_OKAY : dwErr;
}



DWORD
WINAPI
HandleSampleDelIf(
    IN  PWCHAR                  pwszMachineName,
    IN  PWCHAR                  *ppwcArguments,
    IN  DWORD                   dwCurrentIndex,
    IN  DWORD                   dwArgCount,
    IN  DWORD                   dwFlags,
    IN  MIB_SERVER_HANDLE       hMibServer,
    IN  BOOL                    *pbDone
    )
/*++

Routine Description:
    Gets options for DELETE INTERFACE 

--*/
{
    DWORD               dwErr = NO_ERROR;
    WCHAR               pwszInterfaceGuid[MAX_INTERFACE_NAME_LEN + 1] = L"\0";
    IPSAMPLE_IF_CONFIG  iicNew;
    DWORD               dwBitVector = 0;

    
    // SAMPLE should be installed for this command to complete
    VerifyInstalled(MS_IP_SAMPLE, STRING_PROTO_SAMPLE);

    // get interface name.
    dwErr = GetInterfaceOptions(ppwcArguments,
                                dwCurrentIndex,
                                dwArgCount,
                                pwszInterfaceGuid,
                                &iicNew,
                                &dwBitVector);

    if (dwErr isnot NO_ERROR)
        return dwErr ;
    if (dwBitVector)            // ensure that no other option is set.
        return ERROR_INVALID_SYNTAX;

    // delete interface
    dwErr = DeleteInterfaceConfiguration(pwszInterfaceGuid, MS_IP_SAMPLE);

    return (dwErr is NO_ERROR) ? ERROR_OKAY : dwErr;
}



DWORD
WINAPI
HandleSampleSetIf(
    IN  PWCHAR                  pwszMachineName,
    IN  PWCHAR                  *ppwcArguments,
    IN  DWORD                   dwCurrentIndex,
    IN  DWORD                   dwArgCount,
    IN  DWORD                   dwFlags,
    IN  MIB_SERVER_HANDLE       hMibServer,
    IN  BOOL                    *pbDone
    )
/*++

Routine Description:
    Gets options for SET INTERFACE 

--*/
{
    DWORD               dwErr = NO_ERROR;
    WCHAR               pwszInterfaceGuid[MAX_INTERFACE_NAME_LEN + 1] = L"\0";
    IPSAMPLE_IF_CONFIG  iicNew;
    DWORD               dwBitVector = 0;


    // SAMPLE should be installed for this command to complete
    VerifyInstalled(MS_IP_SAMPLE, STRING_PROTO_SAMPLE);

    // get parameters being set
    dwErr = GetInterfaceOptions(ppwcArguments,
                                dwCurrentIndex,
                                dwArgCount,
                                pwszInterfaceGuid,
                                &iicNew,
                                &dwBitVector);
    if (dwErr isnot NO_ERROR)
        return dwErr;
    
    // set SAMPLE interface configuration
    dwErr = SicUpdate(pwszInterfaceGuid, &iicNew, dwBitVector, FALSE);
    
    return (dwErr is NO_ERROR) ? ERROR_OKAY : dwErr;
}



DWORD
WINAPI
HandleSampleShowIf(
    IN  PWCHAR                  pwszMachineName,
    IN  PWCHAR                  *ppwcArguments,
    IN  DWORD                   dwCurrentIndex,
    IN  DWORD                   dwArgCount,
    IN  DWORD                   dwFlags,
    IN  MIB_SERVER_HANDLE       hMibServer,
    IN  BOOL                    *pbDone
    )
/*++

Routine Description:
    Gets options for SHOW INTERFACE

--*/
{
    DWORD               dwErr = NO_ERROR;
    WCHAR               pwszInterfaceGuid[MAX_INTERFACE_NAME_LEN + 1] = L"\0";
    IPSAMPLE_IF_CONFIG  iicNew;
    DWORD               dwBitVector = 0;

    
    // SAMPLE should be installed for this command to complete
    VerifyInstalled(MS_IP_SAMPLE, STRING_PROTO_SAMPLE);

    
    // no interface specified, show SAMPLE configuration for all interfaces
    if (dwCurrentIndex is dwArgCount)
        return SicShowAll(FORMAT_TABLE) ;

    
    // get interface name.
    dwErr = GetInterfaceOptions(ppwcArguments,
                                dwCurrentIndex,
                                dwArgCount,
                                pwszInterfaceGuid,
                                &iicNew,
                                &dwBitVector);
    if (dwErr isnot NO_ERROR)
        return dwErr ;
    if (dwBitVector)            // ensure that no other option is set.
        return ERROR_INVALID_SYNTAX;

    // show SAMPLE interface configuration
    return SicShow(FORMAT_VERBOSE, pwszInterfaceGuid) ;
}



DWORD
WINAPI
HandleSampleInstall(
    IN  PWCHAR                  pwszMachineName,
    IN  PWCHAR                  *ppwcArguments,
    IN  DWORD                   dwCurrentIndex,
    IN  DWORD                   dwArgCount,
    IN  DWORD                   dwFlags,
    IN  MIB_SERVER_HANDLE       hMibServer,
    IN  BOOL                    *pbDone
    )
/*++

Routine Description:
    Gets options for INSTALL

--*/
{
    DWORD   dwErr                   = NO_ERROR;
    PBYTE   pbGlobalConfiguration   = NULL;
    DWORD   dwSize;

    // no options expected for install command.
    if (dwCurrentIndex isnot dwArgCount)
        return ERROR_INVALID_SYNTAX;
    
    do                          // breakout loop
    {
        dwErr = SgcMake(&pbGlobalConfiguration, &dwSize);
        if (dwErr isnot NO_ERROR)
            break;

        // add SAMPLE global configuration
        dwErr = SetGlobalConfiguration(MS_IP_SAMPLE,
                                       pbGlobalConfiguration,
                                       dwSize,
                                       1);
        if (dwErr isnot NO_ERROR)
            break;
    }while (FALSE);

    if (pbGlobalConfiguration) FREE(pbGlobalConfiguration);
    
    return (dwErr is NO_ERROR) ? ERROR_OKAY : dwErr;
}



DWORD
WINAPI
HandleSampleUninstall(
    IN  PWCHAR                  pwszMachineName,
    IN  PWCHAR                  *ppwcArguments,
    IN  DWORD                   dwCurrentIndex,
    IN  DWORD                   dwArgCount,
    IN  DWORD                   dwFlags,
    IN  MIB_SERVER_HANDLE       hMibServer,
    IN  BOOL                    *pbDone
    )
/*++

Routine Description:
    Gets options for UNINSTALL
    
--*/
{
    DWORD   dwErr                   = NO_ERROR;
    
    // no options expected for uninstall command.
    if (dwCurrentIndex isnot dwArgCount)
        return ERROR_INVALID_SYNTAX;

    dwErr = DeleteProtocol(MS_IP_SAMPLE);
    
    return (dwErr is NO_ERROR) ? ERROR_OKAY : dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ip\sample\samplegetopt.h ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    sample\samplegetopt.h

Abstract:

    The file contains the include file for samplegetopt.c.

--*/

FN_HANDLE_CMD  HandleSampleAddIf;
FN_HANDLE_CMD  HandleSampleDelIf;
FN_HANDLE_CMD  HandleSampleSetGlobal;
FN_HANDLE_CMD  HandleSampleSetIf;
FN_HANDLE_CMD  HandleSampleShowGlobal;
FN_HANDLE_CMD  HandleSampleShowIf;
FN_HANDLE_CMD  HandleSampleInstall;
FN_HANDLE_CMD  HandleSampleUninstall;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ip\sample\samplecfg.c ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    sample\samplecfg.c

Abstract:

    The file contains functions to change configuration for IP SAMPLE.

--*/

#include "precomp.h"
#pragma hdrstop


DWORD
SgcMake (
    OUT PBYTE                   *ppbStart,
    OUT PDWORD                  pdwSize
    )
/*++
  
Routine Description:
    Creates a SAMPLE global configuration block.
    Callee should take care to deallocate the configuration block once done.
    
Arguments:
    ppbStart                    pointer to the configuration block address
    pdwSize                     pointer to size of the configuration block
    
Return Value:
    NO_ERROR, ERROR_NOT_ENOUGH_MEMORY
    
--*/
{
    *pdwSize = sizeof(IPSAMPLE_GLOBAL_CONFIG);

    *ppbStart = MALLOC(*pdwSize);
    if (*ppbStart is NULL)
        return ERROR_NOT_ENOUGH_MEMORY;
    
    CopyMemory(*ppbStart, g_ceSample.pDefaultGlobal, *pdwSize);
    return NO_ERROR;
}



DWORD
SgcShow (
    IN  FORMAT                  fFormat
    )
/*++

Routine Description:
    Displays SAMPLE global configuration.
    Used for dump as well as show commands.

Arguments:
    hFile                       NULL, or dump file handle

Return Value:
    NO_ERROR
    
--*/
{
    DWORD                       dwErr = NO_ERROR;

    PIPSAMPLE_GLOBAL_CONFIG     pigc = NULL;
    DWORD                       dwBlockSize, dwNumBlocks;
    PWCHAR                      pwszLogLevel = NULL;

    VALUE_TOKEN                 vtLogLevelTable[] =
    {
        IPSAMPLE_LOGGING_NONE,  TOKEN_NONE,
        IPSAMPLE_LOGGING_ERROR, TOKEN_ERROR,
        IPSAMPLE_LOGGING_WARN,  TOKEN_WARN,
        IPSAMPLE_LOGGING_INFO,  TOKEN_INFO
    };
    VALUE_STRING                vsLogLevelTable[] =
    {
        IPSAMPLE_LOGGING_NONE,  STRING_LOGGING_NONE,
        IPSAMPLE_LOGGING_ERROR, STRING_LOGGING_ERROR,
        IPSAMPLE_LOGGING_WARN,  STRING_LOGGING_WARN,
        IPSAMPLE_LOGGING_INFO,  STRING_LOGGING_INFO
    };

    
    do                          // breakout loop
    {
        // get global configuration
        dwErr = GetGlobalConfiguration(MS_IP_SAMPLE,
                                       (PBYTE *) &pigc,
                                       &dwBlockSize,
                                       &dwNumBlocks);
        if (dwErr isnot NO_ERROR)
        {
            if (dwErr is ERROR_NOT_FOUND)
                dwErr = EMSG_PROTO_NO_GLOBAL_CONFIG;
            break;
        }

        // getting logging mode string
        dwErr = GetString(g_hModule,
                          fFormat,
                          pigc->dwLoggingLevel,
                          vtLogLevelTable,
                          vsLogLevelTable,
                          NUM_VALUES_IN_TABLE(vtLogLevelTable),
                          &pwszLogLevel);
        if (dwErr isnot NO_ERROR)
            break;

        // dump or show
        if (fFormat is FORMAT_DUMP)
        {
            // dump SAMPLE global configuration
            DisplayMessageT(DMP_SAMPLE_INSTALL) ;
            DisplayMessageT(DMP_SAMPLE_SET_GLOBAL,
                            pwszLogLevel);
        } else {
            // show SAMPLE global configuration
            DisplayMessage(g_hModule,
                           MSG_SAMPLE_GLOBAL_CONFIG,
                           pwszLogLevel);
        }

        dwErr = NO_ERROR;
    } while (FALSE);

    // deallocate memory
    if (pigc) FREE(pigc);
    if (pwszLogLevel) FreeString(pwszLogLevel);

    if (dwErr isnot NO_ERROR)
    {
        // display error message.  We first search for the error code in
        // the module specified by the caller (if one is specified).  If no
        // module is given, or the error code doesnt exist we look for MPR
        // errors, RAS errors and Win32 errors - in that order.
        if (fFormat isnot FORMAT_DUMP) DisplayError(g_hModule, dwErr);
        dwErr = ERROR_SUPPRESS_OUTPUT;
    }

    return dwErr;
}



DWORD
SgcUpdate (
    IN  PIPSAMPLE_GLOBAL_CONFIG pigcNew,
    IN  DWORD                   dwBitVector
    )
/*++

Routine Description:
    Updates SAMPLE global configuration

Arguments:
    pigcNew                     new values to be set
    dwBitVector                 which fields need to be modified
    
Return Value:
    NO_ERROR, ERROR_NOT_ENOUGH_MEMORY
    
--*/
{
    DWORD                   dwErr = NO_ERROR;
    PIPSAMPLE_GLOBAL_CONFIG pigc = NULL;
    DWORD                   dwBlockSize, dwNumBlocks;


    // no updates required
    if (dwBitVector is 0)
        return NO_ERROR;
    
    do                          // breakout loop
    {
        // get global configuration
        dwErr = GetGlobalConfiguration(MS_IP_SAMPLE,
                                       (PBYTE *) &pigc,
                                       &dwBlockSize,
                                       &dwNumBlocks);
        if (dwErr isnot NO_ERROR)
            break;

        // can be updated in place since only fixed sized fields
        if (dwBitVector & SAMPLE_LOG_MASK)
            pigc->dwLoggingLevel = pigcNew->dwLoggingLevel;

        // set the new configuration
        dwErr = SetGlobalConfiguration(MS_IP_SAMPLE,
                                       (PBYTE) pigc,
                                       dwBlockSize,
                                       dwNumBlocks);
        if (dwErr isnot NO_ERROR)
            break;
    } while (FALSE);

    // deallocate memory
    if (pigc) FREE(pigc);
    
    return dwErr;
}



DWORD
SicMake (
    OUT PBYTE                   *ppbStart,
    OUT PDWORD                  pdwSize
    )
/*++

Routine Description:
    Creates a SAMPLE interface configuration block.
    Callee should take care to deallocate the configuration block once done.

Arguments:
    ppbStart                    pointer to the configuration block address
    pdwSize                     pointer to size of the configuration block
    
Return Value:
    NO_ERROR, ERROR_NOT_ENOUGH_MEMORY
    
--*/
{
    *pdwSize = sizeof(IPSAMPLE_IF_CONFIG);

    *ppbStart = MALLOC(*pdwSize);
    if (*ppbStart is NULL)
        return ERROR_NOT_ENOUGH_MEMORY;

    CopyMemory(*ppbStart, g_ceSample.pDefaultInterface, *pdwSize);

    return NO_ERROR;
}



DWORD
SicShowAll (
    IN  FORMAT                  fFormat
    )
/*++

Routine Description:
    Displays SAMPLE configuration for all interfaces.
    Used for dump as well as show commands.

Arguments:
    fFormat                     TABLE or DUMP
    
--*/
{
    DWORD               dwErr = NO_ERROR;
    BOOL                bSomethingDisplayed = FALSE;

    PMPR_INTERFACE_0    pmi0;
    DWORD               dwCount, dwTotal;

    ULONG               i;


    // enumerate all interfaces
    dwErr = IpmontrInterfaceEnum((PBYTE *) &pmi0, &dwCount, &dwTotal);
    if (dwErr isnot NO_ERROR)
    {
        if (fFormat isnot FORMAT_DUMP) DisplayError(g_hModule, dwErr);
        return ERROR_SUPPRESS_OUTPUT;
    }

    for(i = 0; i < dwCount; i++)
    {
        // make sure that SAMPLE is configured on that interface
        if (IsInterfaceInstalled(pmi0[i].wszInterfaceName, MS_IP_SAMPLE))
        {
            // print table header if first entry
            if (!bSomethingDisplayed and (fFormat is FORMAT_TABLE))
                DisplayMessage(g_hModule, MSG_SAMPLE_IF_CONFIG_HEADER);
            bSomethingDisplayed = TRUE;
            
            SicShow(fFormat, pmi0[i].wszInterfaceName);
        }
    }

    return bSomethingDisplayed ? NO_ERROR : ERROR_OKAY;
}




DWORD
SicShow (
    IN  FORMAT                  fFormat,
    IN  LPCWSTR                 pwszInterfaceGuid
    )
/*++

Routine Description:
    Displays SAMPLE configuration for an interface.
    Used for dump as well as show commands.

Arguments:
    pwszInterfaceGuid           interface name
    
--*/
{
    DWORD               dwErr = NO_ERROR;
    
    PIPSAMPLE_IF_CONFIG piic = NULL;
    DWORD               dwBlockSize, dwNumBlocks, dwIfType;

    PWCHAR  pwszInterfaceName = NULL;

    
    do                          // breakout loop
    {
        // get interface configuration
        dwErr = GetInterfaceConfiguration(pwszInterfaceGuid,
                                          MS_IP_SAMPLE,
                                          (PBYTE *) &piic,
                                          &dwBlockSize,
                                          &dwNumBlocks,
                                          &dwIfType);
        if (dwErr isnot NO_ERROR)
        {
            if (dwErr is ERROR_NOT_FOUND)
                dwErr = EMSG_PROTO_NO_IF_CONFIG;
            break;
        }

        // get quoted friendly name for interface
        dwErr = QuotedInterfaceNameFromGuid(pwszInterfaceGuid,
                                            &pwszInterfaceName);
        if (dwErr isnot NO_ERROR)
            break;

        // dump or show
        switch(fFormat)
        {
            case FORMAT_DUMP:   // dump SAMPLE interface configuration
                DisplayMessage(g_hModule,
                               DMP_SAMPLE_INTERFACE_HEADER,
                               pwszInterfaceName);
                DisplayMessageT(DMP_SAMPLE_ADD_INTERFACE,
                                pwszInterfaceName,
                                piic->ulMetric);
                break;

            case FORMAT_TABLE:  // show sample interface configuration
                DisplayMessage(g_hModule,
                               MSG_SAMPLE_IF_CONFIG_ENTRY,
                               pwszInterfaceName,
                               piic->ulMetric);
                break;
                
            case FORMAT_VERBOSE: // show sample interface configuration
                DisplayMessage(g_hModule,
                               MSG_SAMPLE_IF_CONFIG,
                               pwszInterfaceName,
                               piic->ulMetric);
                break;
        }
    } while (FALSE);

    // deallocate memory
    if (piic) FREE(piic);
    if (pwszInterfaceName)
        FreeQuotedString(pwszInterfaceName);

    // display error message.
    if (dwErr isnot NO_ERROR)
    {
        if (fFormat isnot FORMAT_DUMP) DisplayError(g_hModule, dwErr);
        dwErr = ERROR_SUPPRESS_OUTPUT;
    }
    
    return dwErr;
}



DWORD
SicUpdate (
    IN  LPCWSTR                 pwszInterfaceGuid,
    IN  PIPSAMPLE_IF_CONFIG     piicNew,
    IN  DWORD                   dwBitVector,
    IN  BOOL                    bAdd
    )
/*++

Routine Description:
    Updates SAMPLE interface configuration

Arguments:
    pwszInterfaceGuid           interface name
    piicNew                     the changes to be applied
    dwBitVector                 which fields need to be modified
    bAdd                        interface being added (TRUE) or set (FALSE)
    
Return Value:
    NO_ERROR, ERROR_NOT_ENOUGH_MEMORY
    
--*/
{
    DWORD               dwErr = NO_ERROR;
    PIPSAMPLE_IF_CONFIG piic = NULL;
    DWORD               dwBlockSize, dwNumBlocks, dwIfType;

    do                          // breakout loop
    {
        if (bAdd)
        {
            // create default protocol interface configuration
            dwNumBlocks = 1;
            dwErr = SicMake((PBYTE *)&piic, &dwBlockSize);
            if (dwErr isnot NO_ERROR)
                break;
        } else {
            // get current protocol interface configuration
            dwErr = GetInterfaceConfiguration(pwszInterfaceGuid,
                                              MS_IP_SAMPLE,
                                              (PBYTE *) &piic,
                                              &dwBlockSize,
                                              &dwNumBlocks,
                                              &dwIfType);
            if (dwErr isnot NO_ERROR)
            {
                if (dwErr is ERROR_NOT_FOUND)
                {
                    DisplayError(g_hModule, EMSG_PROTO_NO_IF_CONFIG);
                    dwErr = ERROR_SUPPRESS_OUTPUT;
                }
                break;
            }
        }

        // can be updated in place since only fixed sized fields
        if (dwBitVector & SAMPLE_IF_METRIC_MASK)
            piic->ulMetric = piicNew->ulMetric;

        // set the new configuration
        dwErr = SetInterfaceConfiguration(pwszInterfaceGuid,
                                          MS_IP_SAMPLE,
                                          (PBYTE) piic,
                                          dwBlockSize,
                                          dwNumBlocks);        
        if (dwErr isnot NO_ERROR)
            break;
    } while (FALSE);
    
    // deallocate memory
    if (piic) FREE(piic);
    
    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ip\sample\samplecfg.h ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    sample\samplecfg.h

Abstract:

    The file contains the include file for samplecfg.c.

--*/

// sample global configuration

DWORD
SgcMake (
    OUT PBYTE                   *ppbStart,
    OUT PDWORD                  pdwSize
    );

DWORD
SgcShow (
    IN  FORMAT                  fFormat
    );

DWORD
SgcUpdate (
    IN  PIPSAMPLE_GLOBAL_CONFIG pigcNew,
    IN  DWORD                   dwBitVector
    );



// sample interface configuration

DWORD
SicMake (
    OUT PBYTE                   *ppbStart,
    OUT PDWORD                  pdwSize
    );

DWORD
SicShowAll (
    IN  FORMAT                  fFormat
    );

DWORD
SicShow (
    IN  FORMAT                  fFormat,
    IN  LPCWSTR                 pwszInterfaceGuid
    );

DWORD
SicUpdate (
    IN  PWCHAR                  pwszInterfaceGuid,
    IN  PIPSAMPLE_IF_CONFIG     piicNew,
    IN  DWORD                   dwBitVector,
    IN  BOOL                    bAdd
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ip\sample\samplemib.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    sample\samplemib.h

Abstract:

    Header for samplemib.c

--*/

FN_HANDLE_CMD HandleSampleMibShowObject;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ip\sample\utils.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    sample\utils.c

Abstract:

     The file contains utility functions

--*/

#include "precomp.h"
#pragma hdrstop

BOOL
IsProtocolInstalled(
    IN  DWORD           dwProtocolId,
    IN  DWORD           dwNameId,
    IN  DWORD           dwLogUninstalled
    )
/*++

Routine Description:
    Finds if the protocol is already installed.

Arguments:
    dwProtocolId        - protocol id
    dwNameId            - protocol name
    dwLogUninstalled    - TRUE(if not installed display error)
                          FALSE(if installed display error)
Return Value:
    TRUE if protocol already installed, else FALSE

--*/
{
    DWORD   dwErr       = NO_ERROR;
    WCHAR   *pwszName   = NULL;

    dwErr = IpmontrGetInfoBlockFromGlobalInfo(dwProtocolId,
                                              NULL,
                                              NULL,
                                              NULL);

    pwszName = MakeString(g_hModule, dwNameId);

    if ((dwErr isnot NO_ERROR) and (dwLogUninstalled is TRUE))
    {
        DisplayError(g_hModule, EMSG_PROTO_NOT_INSTALLED, pwszName);
    }
    else if ((dwErr is NO_ERROR) and (dwLogUninstalled is FALSE))
    {
        DisplayError(g_hModule, EMSG_PROTO_INSTALLED, pwszName);
    }
    
    if (pwszName) FreeString(pwszName);

    return (dwErr is NO_ERROR) ? TRUE : FALSE;
}



DWORD
GetIfIndex(
    IN  HANDLE          hMibServer,
    IN  PWCHAR          pwszArgument,
    OUT PDWORD          pdwIfIndex
    )
/*++

Routine Description:
    Gets the interface index.

Arguments:
    hMibServer      - handle to the mib server
    pwszArgument    - argument specifing interface index or name
    pdwIfIndex      - interface index

Return Value:
    NO_ERROR        success
    error code      o/w
    
--*/
{
    DWORD dwErr = NO_ERROR;

    // if index was specified just use it
    if (iswdigit(pwszArgument[0]))
    {
        *pdwIfIndex = wcstoul(pwszArgument, NULL, 10);
        return NO_ERROR;
    }

    // try converting a friendly name to an interface index
    dwErr = InterfaceIndexFromName(hMibServer,
                                   pwszArgument,
                                   pdwIfIndex);
    return (dwErr is NO_ERROR) ? dwErr : ERROR_INVALID_PARAMETER;
}



DWORD
MibGet(
    IN  HANDLE          hMibServer,
    IN  MODE            mMode,
    IN  PVOID           pvIn,
    IN  DWORD           dwInSize,
    OUT PVOID           *ppvOut
    )
/*++

Routine Description:
    Gets the specified mib object.

Arguments:
    hMibServer      - handle to the mib server
    mMode           - mode of access (exact, first, next)
    pvIn            - buffer containing input data
    dwInSize        - size of input data
    ppvOut          - pointer to address of output data buffer
    
Return Value:
    NO_ERROR        success
    error code      o/w
    
--*/
{
    DWORD dwErr         = NO_ERROR;
    DWORD dwOutSize     = 0;
    DWORD (APIENTRY *pfnMprGet) (
        IN      MIB_SERVER_HANDLE       hMibServer,
        IN      DWORD                   dwProtocolId,
        IN      DWORD                   dwRoutingPid,
        IN      LPVOID                  lpInEntry,
        IN      DWORD                   dwInEntrySize,
        OUT     LPVOID*                 lplpOutEntry,
        OUT     LPDWORD                 lpOutEntrySize
        );

    *ppvOut     = NULL;

    switch(mMode)
    {
        case GET_EXACT:
            pfnMprGet = MprAdminMIBEntryGet;
            break;
        case GET_FIRST:
            pfnMprGet = MprAdminMIBEntryGetFirst;
            break;
        case GET_NEXT:
            pfnMprGet = MprAdminMIBEntryGetNext;
            break;
    }
    
    dwErr = (*pfnMprGet) (
        hMibServer,
        PID_IP,
        MS_IP_SAMPLE,
        (LPVOID) pvIn,
        dwInSize,
        (LPVOID *) ppvOut,
        &dwOutSize);

    if (dwErr isnot NO_ERROR)
        return dwErr;
    
    if (*ppvOut is NULL)
        return ERROR_CAN_NOT_COMPLETE;

    return NO_ERROR;
}



DWORD
GetDumpString (
    IN  HANDLE          hModule,
    IN  DWORD           dwValue,
    IN  PVALUE_TOKEN    ptvTable,
    IN  DWORD           dwNumArgs,
    OUT PWCHAR          *pwszString
    )
/*
 * Do not localize display string
 */
{
    DWORD dwErr = NO_ERROR ;
    ULONG i;

    for (i = 0; i < dwNumArgs; i++)
    {
        if (dwValue is ptvTable[i].dwValue)
        {
            *pwszString = MALLOC((wcslen(ptvTable[i].pwszToken) + 1) *
                                 sizeof(WCHAR));
            if (*pwszString)
                wcscpy(*pwszString, ptvTable[i].pwszToken);
            break;
        }
    }

    if (i is dwNumArgs)
        *pwszString = MakeString(hModule, STRING_UNKNOWN) ;

    if (!pwszString)
        dwErr = ERROR_NOT_ENOUGH_MEMORY ;

    return dwErr ;
}



DWORD
GetShowString (
    IN  HANDLE          hModule,
    IN  DWORD           dwValue,
    IN  PVALUE_STRING   ptvTable,
    IN  DWORD           dwNumArgs,
    OUT PWCHAR          *pwszString
    )
/*
 * Localize display string
 */
{
    DWORD dwErr = NO_ERROR ;
    ULONG i;

    for (i = 0; i < dwNumArgs; i++)
    {
        if (dwValue is ptvTable[i].dwValue)
        {
            *pwszString = MakeString(hModule, ptvTable[i].dwStringId) ;
            break;
        }
    }

    if (i is dwNumArgs)
        *pwszString = MakeString(hModule, STRING_UNKNOWN) ;

    if (!pwszString)
        dwErr = ERROR_NOT_ENOUGH_MEMORY ;
    
    return dwErr ;
}



DWORD
GetString (
    IN  HANDLE          hModule, 
    IN  FORMAT          fFormat,
    IN  DWORD           dwValue,
    IN  PVALUE_TOKEN    vtTable,
    IN  PVALUE_STRING   vsTable,
    IN  DWORD           dwNumArgs,
    OUT PWCHAR          *pwszString)
{
    if (fFormat is FORMAT_DUMP) 
    {
        return GetDumpString(hModule,
                                 dwValue,
                                 vtTable,
                                 dwNumArgs,
                                 pwszString) ;
    } 
    else 
    {
        return GetShowString(hModule,
                                dwValue,
                                vsTable,
                                dwNumArgs,
                                pwszString) ;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ip\sample\samplemib.c ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    sample\samplemib.c

Abstract:

    The file contains functions to display SAMPLE ip protocol's MIB.

--*/

#include "precomp.h"
#pragma hdrstop

VOID
PrintGlobalStats(
    IN  HANDLE                          hConsole,
    IN  HANDLE                          hMibServer,
    IN  PVOID                           pvOutput,
    IN  FORMAT                          fFormat
    );

VOID
PrintIfStats(
    IN  HANDLE                          hConsole,
    IN  HANDLE                          hMibServer,
    IN  PVOID                           pvOutput,
    IN  FORMAT                          fFormat
    );

VOID
PrintIfBinding(
    IN  HANDLE                          hConsole,
    IN  HANDLE                          hMibServer,
    IN  PVOID                           pvOutput,
    IN  FORMAT                          fFormat
    );

MIB_OBJECT_ENTRY    rgMibObjectTable[] =
{
    {TOKEN_GLOBALSTATS, IPSAMPLE_GLOBAL_STATS_ID,   NULL,
     0,                                             PrintGlobalStats},
    {TOKEN_IFSTATS,         IPSAMPLE_IF_STATS_ID,   GetIfIndex,
     MSG_SAMPLE_MIB_IFSTATS_HEADER,                 PrintIfStats},
    {TOKEN_IFBINDING,   IPSAMPLE_IF_BINDING_ID, GetIfIndex,
     MSG_SAMPLE_MIB_IFBINDING_HEADER,               PrintIfBinding},
};

#define MAX_MIB_OBJECTS                                     \
(sizeof(rgMibObjectTable) / sizeof(MIB_OBJECT_ENTRY))

#define MAX_GLOBAL_MIB_OBJECTS                              1
    


VOID
PrintGlobalStats(
    IN  HANDLE                          hConsole,
    IN  HANDLE                          hMibServer,
    IN  PVOID                           pvOutput,
    IN  FORMAT                          fFormat    
    )
/*++

Routine Description:
    Prints sample global statistics

--*/
{
    PIPSAMPLE_MIB_GET_OUTPUT_DATA   pimgod          = 
        ((PIPSAMPLE_MIB_GET_OUTPUT_DATA) pvOutput);
    PIPSAMPLE_GLOBAL_STATS          pGlobalStats    =
        ((PIPSAMPLE_GLOBAL_STATS) pimgod->IMGOD_Buffer);
    
    DisplayMessageToConsole(g_hModule,
                      hConsole,
                      MSG_SAMPLE_MIB_GS,
                      pGlobalStats->ulNumInterfaces);
}



VOID
PrintIfStats(
    IN  HANDLE                          hConsole,
    IN  HANDLE                          hMibServer,
    IN  PVOID                           pvOutput,
    IN  FORMAT                          fFormat    
    )
/*++

Routine Description:
    Prints SAMPLE interface statistics

--*/
{
    PIPSAMPLE_MIB_GET_OUTPUT_DATA   pimgod          = 
        ((PIPSAMPLE_MIB_GET_OUTPUT_DATA) pvOutput);
    PIPSAMPLE_IF_STATS              pIfStats        =
        ((PIPSAMPLE_IF_STATS) pimgod->IMGOD_Buffer);
    WCHAR   pwszIfName[MAX_INTERFACE_NAME_LEN + 1]  = L"\0";

    InterfaceNameFromIndex(hMibServer,
                           pimgod->IMGOD_IfIndex,
                           pwszIfName,
                           sizeof(pwszIfName));

    DisplayMessageToConsole(g_hModule,
                      hConsole,
                      (fFormat is FORMAT_VERBOSE)
                      ? MSG_SAMPLE_MIB_IFSTATS
                      : MSG_SAMPLE_MIB_IFSTATS_ENTRY,
                      pwszIfName,
                      pIfStats->ulNumPackets);
}



VOID
PrintIfBinding(
    IN  HANDLE                          hConsole,
    IN  HANDLE                          hMibServer,
    IN  PVOID                           pvOutput,
    IN  FORMAT                          fFormat    
    )
/*++

Routine Description:
    Prints SAMPLE interface binding

--*/
{
    PIPSAMPLE_MIB_GET_OUTPUT_DATA   pimgod          = 
        ((PIPSAMPLE_MIB_GET_OUTPUT_DATA) pvOutput);
    PIPSAMPLE_IF_BINDING            pIfBinding      =
        ((PIPSAMPLE_IF_BINDING) pimgod->IMGOD_Buffer);
    WCHAR   pwszIfName[MAX_INTERFACE_NAME_LEN + 1]  = L"\0";
    PWCHAR  pwszBindState = L"\0", pwszActiveState = L"\0";

    PIPSAMPLE_IP_ADDRESS            pBinding        = NULL;
    WCHAR                           pwszAddress[ADDR_LENGTH + 1] = L"\0",
                                    pwszMask[ADDR_LENGTH + 1] = L"\0";    
    ULONG                           i;
    
    
    InterfaceNameFromIndex(hMibServer,
                           pimgod->IMGOD_IfIndex,
                           pwszIfName,
                           sizeof(pwszIfName));

    pwszBindState = MakeString(g_hModule,
                               ((pIfBinding->dwState&IPSAMPLE_STATE_BOUND)
                                ? STRING_BOUND : STRING_UNBOUND));
    
    pwszActiveState = MakeString(g_hModule,
                                 ((pIfBinding->dwState&IPSAMPLE_STATE_ACTIVE)
                                  ? STRING_ACTIVE : STRING_INACTIVE));

    DisplayMessageToConsole(g_hModule,
                      hConsole,
                      (fFormat is FORMAT_VERBOSE)
                      ? MSG_SAMPLE_MIB_IFBINDING
                      : MSG_SAMPLE_MIB_IFBINDING_ENTRY,
                      pwszIfName,
                      pwszBindState,
                      pwszActiveState);

    pBinding = IPSAMPLE_IF_ADDRESS_TABLE(pIfBinding);

    for(i = 0; i < pIfBinding->ulCount; i++)
    {
        UnicodeIpAddress(pwszAddress, INET_NTOA(pBinding[i].dwAddress));
        UnicodeIpAddress(pwszMask, INET_NTOA(pBinding[i].dwMask));
        DisplayMessageToConsole(g_hModule,
                          hConsole,
                          MSG_SAMPLE_MIB_IFBINDING_ADDR,
                          pwszAddress,
                          pwszMask);
    }

    if (pwszBindState) FreeString(pwszBindState);
    if (pwszActiveState) FreeString(pwszActiveState);
}



DWORD
WINAPI
HandleSampleMibShowObject(
    IN  PWCHAR                  pwszMachineName,
    IN  PWCHAR                  *ppwcArguments,
    IN  DWORD                   dwCurrentIndex,
    IN  DWORD                   dwArgCount,
    IN  DWORD                   dwFlags,
    IN  MIB_SERVER_HANDLE       hMibServer,
    IN  BOOL                    *pbDone
    )
/*++

Routine Description:
    Gets options for SHOW GLOBALSTATS/IFSTATS/IFBINDING
    A single command handler is used for all MIB objects since there is a
    lot common in the way processing takes place.  However feel free to
    write a handler per object if u find the code a bit chaotic.
    
--*/
{
    DWORD                           dwErr       = NO_ERROR;
    TAG_TYPE                        pttAllTags[]   =
    {
        {TOKEN_INDEX,       FALSE,  FALSE}, // INDEX tag optional
        {TOKEN_RR,          FALSE,  FALSE}, // RR tag optional
    };
    DWORD                           pdwTagType[NUM_TAGS_IN_TABLE(pttAllTags)];
    DWORD                           dwNumArg;
    ULONG                           i;
    TAG_TYPE                        *pttTags;
    DWORD                           dwNumTags;
    BOOL                            bGlobalObject           = FALSE;
    DWORD                           dwFirstGlobalArgument   = 1;
    
    DWORD                           dwMibObject;
    BOOL                            bIndexSpecified = FALSE;
    DWORD                           dwIndex         = 0;
    DWORD                           dwRR            = 0;
    
    HANDLE                          hMib, hConsole;
    MODE                            mMode;
    IPSAMPLE_MIB_GET_INPUT_DATA     imgid;
    PIPSAMPLE_MIB_GET_OUTPUT_DATA   pimgod;
    BOOL                            bSomethingDisplayed = FALSE;

    
    // SAMPLE should be installed for this command to complete
    VerifyInstalled(MS_IP_SAMPLE, STRING_PROTO_SAMPLE);

    
    // figure mib object to display
    for (i = 0; i < MAX_MIB_OBJECTS; i++)
        if (MatchToken(ppwcArguments[dwCurrentIndex - 1],
                       rgMibObjectTable[i].pwszObjectName))
            break;

    dwMibObject = i;
    if (dwMibObject is MAX_MIB_OBJECTS)
        return ERROR_CMD_NOT_FOUND;
    bGlobalObject = (dwMibObject < MAX_GLOBAL_MIB_OBJECTS);

    // for global objects, offset tags by index of the first global arguments
    pttTags = pttAllTags
        + bGlobalObject*dwFirstGlobalArgument;
    dwNumTags  = NUM_TAGS_IN_TABLE(pttAllTags)
        - bGlobalObject*dwFirstGlobalArgument,
    dwErr = PreprocessCommand(g_hModule,
                              ppwcArguments,
                              dwCurrentIndex,
                              dwArgCount,
                              pttTags,
                              dwNumTags,
                              0,
                              dwNumTags,
                              pdwTagType);
    if (dwErr isnot NO_ERROR)
        return dwErr;


    // process all arguments
    dwNumArg = dwArgCount - dwCurrentIndex;
    for (i = 0; i < dwNumArg; i++)
    {
        // for global objects, offset tag type by first global argument index
        pdwTagType[i] += bGlobalObject*dwFirstGlobalArgument;
        switch (pdwTagType[i])
        {
            case 0:
                // tag INDEX
                bIndexSpecified = TRUE;
                dwErr = (*rgMibObjectTable[dwMibObject].pfnGetIndex)(
                    hMibServer,
                    ppwcArguments[i+dwCurrentIndex],
                    &dwIndex);
                break;

            case 1:
                // tag RR
                dwRR = wcstoul(ppwcArguments[i+dwCurrentIndex],
                               NULL,
                               10);
                dwRR *= 1000;   // convert refresh rate to milliseconds
                break;

            default:
                dwErr = ERROR_INVALID_SYNTAX;
                break;
        } // switch

        if (dwErr isnot NO_ERROR)
            break ;
    } // for


    // process errors
    if (dwErr isnot NO_ERROR)
    {
        ProcessError();
        return dwErr;
    }


    if (!InitializeConsole(&dwRR, &hMib, &hConsole))
        return ERROR_INIT_DISPLAY;

    // now display the specified mib object
    for(ever)                   // refresh loop
    {
        // initialize to default values
        bSomethingDisplayed = FALSE;
        
        imgid.IMGID_TypeID = rgMibObjectTable[dwMibObject].dwObjectId;
        imgid.IMGID_IfIndex = 0;
        mMode = GET_EXACT;

        // override defaults for interface objects
        if (!bGlobalObject)
        {
            if (bIndexSpecified)
                imgid.IMGID_IfIndex = dwIndex;
            else
                mMode = GET_FIRST;
        }

        for(ever)               // display all interfaces loop
        {
            dwErr = MibGet(hMibServer,
                           mMode,
                           (PVOID) &imgid,
                           sizeof(imgid),
                           &pimgod);
            if (dwErr isnot NO_ERROR)
            {
                if ((mMode is GET_NEXT) and (dwErr is ERROR_NO_MORE_ITEMS))
                    dwErr = NO_ERROR;   // not really an error
                break;
            }

            // print table heading
            if (!bSomethingDisplayed and (mMode isnot GET_EXACT))
            {
                DisplayMessageToConsole(
                    g_hModule,
                    hConsole,
                    rgMibObjectTable[dwMibObject].dwHeaderMessageId);
                bSomethingDisplayed = TRUE;
            }

            (*rgMibObjectTable[dwMibObject].pfnPrint)(hConsole,
                                                      hMibServer,
                                                      (PVOID) pimgod,
                                                      (mMode is GET_EXACT)
                                                      ? FORMAT_VERBOSE
                                                      : FORMAT_TABLE);

            // prepare for next request
            imgid.IMGID_IfIndex = pimgod->IMGOD_IfIndex;
            MprAdminMIBBufferFree(pimgod);
            
            if (mMode is GET_EXACT)
                break;
            else                // prepare for next request
                mMode = GET_NEXT;
        } // display all interfaces 

        if (dwErr isnot NO_ERROR)
        {
            dwErr = bSomethingDisplayed ? NO_ERROR : ERROR_OKAY;
            break;
        }

        if (!RefreshConsole(hMib, hConsole, dwRR))
            break;
    } // refresh
            
    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ip\sample\utils.h ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    sample\utils.h

Abstract:

    The file contains the header for utils.c.
    
--*/


// definitions...
    
#define is      ==
#define isnot   !=
#define or      ||
#define and     &&
#define ever    ;;    

#define GetGlobalConfiguration          IpmontrGetInfoBlockFromGlobalInfo
#define SetGlobalConfiguration          IpmontrSetInfoBlockInGlobalInfo
#define DeleteGlobalConfiguration       IpmontrDeleteInfoBlockFromGlobalInfo

#define GetInterfaceConfiguration       IpmontrGetInfoBlockFromInterfaceInfo
#define SetInterfaceConfiguration       IpmontrSetInfoBlockInInterfaceInfo
#define DeleteInterfaceConfiguration    IpmontrDeleteInfoBlockFromInterfaceInfo

#define InterfaceNameFromGuid           IpmontrGetFriendlyNameFromIfName
#define InterfaceGuidFromName           IpmontrGetIfNameFromFriendlyName
#define InterfaceNameFromIndex          IpmontrGetFriendlyNameFromIfIndex
#define InterfaceIndexFromName          IpmontrGetIfIndexFromFriendlyName

#define DeleteProtocol                  IpmontrDeleteProtocol

    

// typedefs...

typedef enum { GET_EXACT, GET_FIRST, GET_NEXT } MODE;

typedef enum { FORMAT_TABLE, FORMAT_VERBOSE, FORMAT_DUMP } FORMAT;

typedef DWORD (*PGET_INDEX_FUNCTION) (
    IN  HANDLE                          hMibServer,
    IN  PWCHAR                          pwszArgument,
    OUT PDWORD                          pdwIfIndex
    );

typedef VOID (*PPRINT_FUNCTION)(
    IN  HANDLE                          hConsole,
    IN  HANDLE                          hMibServer,
    IN  PVOID                           pvOutput,
    IN  FORMAT                          fFormat
    );

typedef struct _MIB_OBJECT_ENTRY
{
    PWCHAR                              pwszObjectName;
    DWORD                               dwObjectId;
    PGET_INDEX_FUNCTION                 pfnGetIndex;
    DWORD                               dwHeaderMessageId;
    PPRINT_FUNCTION                     pfnPrint;
} MIB_OBJECT_ENTRY, *PMIB_OBJECT_ENTRY;



// macros...

#define VerifyInstalled(dwProtocolId, dwNameId)                         \
{                                                                       \
    if (!IsProtocolInstalled(dwProtocolId, dwNameId, TRUE))             \
        return ERROR_SUPPRESS_OUTPUT;                                   \
}

#define ProcessError()                                                  \
{                                                                       \
    if (dwErr is ERROR_INVALID_PARAMETER)                               \
    {                                                                   \
        DisplayError(g_hModule,                                         \
                     EMSG_BAD_OPTION_VALUE,                             \
                     ppwcArguments[dwCurrentIndex + i],                 \
                     pttTags[pdwTagType[i]].pwszTag);                   \
        dwErr = ERROR_SHOW_USAGE;                                       \
    }                                                                   \
}

#define UnicodeIpAddress(pwszUnicodeIpAddress, pszAsciiIpAddress)       \
MultiByteToWideChar(GetConsoleOutputCP(),                                             \
                    0,                                                  \
                    (pszAsciiIpAddress),                                \
                    -1,                                                 \
                    (pwszUnicodeIpAddress),                             \
                    ADDR_LENGTH + 1)

#define INET_NTOA(x)    (inet_ntoa(*(struct in_addr*)&(x)))    

#define MALLOC(x)       HeapAlloc(GetProcessHeap(), 0, x)

#define FREE(x)         HeapFree(GetProcessHeap(), 0, x)



// inline functions...

BOOL
__inline
IsInterfaceInstalled(
    IN  PWCHAR          pwszInterfaceGuid,
    IN  DWORD           dwProtocolId
    )
{
    DWORD dwErr     = NO_ERROR;
    PBYTE pbBuffer  = NULL;

    dwErr = GetInterfaceConfiguration(pwszInterfaceGuid,
                                      dwProtocolId,
                                      &pbBuffer,
                                      NULL,
                                      NULL,
                                      NULL);
    if (pbBuffer) FREE(pbBuffer);
    return (dwErr is NO_ERROR);
}

DWORD
__inline
QuotedInterfaceNameFromGuid (
    IN  PWCHAR          pwszInterfaceGuid,
    OUT PWCHAR          *ppwszQuotedInterfaceName
    )
{
    DWORD dwErr = NO_ERROR;
    DWORD dwSize = MAX_INTERFACE_NAME_LEN + 1;
    WCHAR pwszInterfaceName[MAX_INTERFACE_NAME_LEN + 1] = L"\0";

    dwErr = InterfaceNameFromGuid(pwszInterfaceGuid,
                                  pwszInterfaceName,
                                  &dwSize);
    if (dwErr is NO_ERROR)
    {
        *ppwszQuotedInterfaceName = MakeQuotedString(pwszInterfaceName);
        if (*ppwszQuotedInterfaceName is NULL)
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
    }

    return dwErr;
}



// functions...

BOOL
IsProtocolInstalled(
    IN  DWORD           dwProtocolId,
    IN  DWORD           dwNameId,
    IN  DWORD           dwLogUninstalled
    );

DWORD
GetIfIndex(
    IN  HANDLE          hMibServer,
    IN  PWCHAR          pwszArgument,
    OUT PDWORD          pdwIfIndex
    );

DWORD
MibGet(
    IN  HANDLE          hMibServer,
    IN  MODE            mMode,
    IN  PVOID           pvIn,
    IN  DWORD           dwInSize,
    OUT PVOID           *ppvOut
    );

DWORD
GetString(
    IN  HANDLE          hModule, 
    IN  FORMAT          fFormat,
    IN  DWORD           dwValue,
    IN  PVALUE_TOKEN    vtTable,
    IN  PVALUE_STRING   vsTable,
    IN  DWORD           dwNumArgs,
    OUT PTCHAR          *pptszString
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ip\sample\strdefs.h ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    sample\strdefs.h

Abstract:

    The file contains definitions for strings defined in resource file.

--*/

#define IPSAMPLELOG_BASE                44000

#define HLP_INSTALL                     (IPSAMPLELOG_BASE + 1)
#define HLP_INSTALL_EX                  (IPSAMPLELOG_BASE + 2)
#define HLP_UNINSTALL                   (IPSAMPLELOG_BASE + 3)
#define HLP_UNINSTALL_EX                (IPSAMPLELOG_BASE + 4)
#define HLP_HELP                        (IPSAMPLELOG_BASE + 5)
#define HLP_HELP_EX                     (IPSAMPLELOG_BASE + 6)
#define HLP_DUMP                        (IPSAMPLELOG_BASE + 7)
#define HLP_DUMP_EX                     (IPSAMPLELOG_BASE + 8)

#define HLP_GROUP_ADD                   (IPSAMPLELOG_BASE + 9)
#define HLP_GROUP_DELETE                (IPSAMPLELOG_BASE + 10)
#define HLP_GROUP_SET                   (IPSAMPLELOG_BASE + 11)
#define HLP_GROUP_SHOW                  (IPSAMPLELOG_BASE + 12)

#define HLP_SAMPLE_ADD_IF               (IPSAMPLELOG_BASE + 13)
#define HLP_SAMPLE_ADD_IF_EX            (IPSAMPLELOG_BASE + 14)

#define HLP_SAMPLE_DEL_IF               (IPSAMPLELOG_BASE + 15)
#define HLP_SAMPLE_DEL_IF_EX            (IPSAMPLELOG_BASE + 16)

#define HLP_SAMPLE_SET_IF               (IPSAMPLELOG_BASE + 17)
#define HLP_SAMPLE_SET_IF_EX            (IPSAMPLELOG_BASE + 18)
#define HLP_SAMPLE_SET_GLOBAL           (IPSAMPLELOG_BASE + 21)
#define HLP_SAMPLE_SET_GLOBAL_EX        (IPSAMPLELOG_BASE + 22)

#define HLP_SAMPLE_SHOW_IF              (IPSAMPLELOG_BASE + 23)
#define HLP_SAMPLE_SHOW_IF_EX           (IPSAMPLELOG_BASE + 24)
#define HLP_SAMPLE_SHOW_GLOBAL          (IPSAMPLELOG_BASE + 27)
#define HLP_SAMPLE_SHOW_GLOBAL_EX       (IPSAMPLELOG_BASE + 28)

#define HLP_SAMPLE_MIB_SHOW_STATS       (IPSAMPLELOG_BASE + 29)
#define HLP_SAMPLE_MIB_SHOW_STATS_EX    (IPSAMPLELOG_BASE + 30)
#define HLP_SAMPLE_MIB_SHOW_IFSTATS     (IPSAMPLELOG_BASE + 31)
#define HLP_SAMPLE_MIB_SHOW_IFSTATS_EX  (IPSAMPLELOG_BASE + 32)
#define HLP_SAMPLE_MIB_SHOW_IFBINDING       (IPSAMPLELOG_BASE + 58)
#define HLP_SAMPLE_MIB_SHOW_IFBINDING_EX    (IPSAMPLELOG_BASE + 59)

#define DMP_SAMPLE_HEADER               (IPSAMPLELOG_BASE + 33)
#define DMP_SAMPLE_FOOTER               (IPSAMPLELOG_BASE + 34)
#define DMP_SAMPLE_INTERFACE_HEADER     (IPSAMPLELOG_BASE + 35)

#define MSG_SAMPLE_GLOBAL_CONFIG        (IPSAMPLELOG_BASE + 36)
#define MSG_SAMPLE_IF_CONFIG            (IPSAMPLELOG_BASE + 37)
#define MSG_SAMPLE_IF_CONFIG_HEADER     (IPSAMPLELOG_BASE + 70)
#define MSG_SAMPLE_IF_CONFIG_ENTRY      (IPSAMPLELOG_BASE + 71)
#define MSG_SAMPLE_MIB_GS               (IPSAMPLELOG_BASE + 39)
#define MSG_SAMPLE_MIB_IFSTATS          (IPSAMPLELOG_BASE + 41)
#define MSG_SAMPLE_MIB_IFSTATS_HEADER   (IPSAMPLELOG_BASE + 72)
#define MSG_SAMPLE_MIB_IFSTATS_ENTRY    (IPSAMPLELOG_BASE + 73)
#define MSG_SAMPLE_MIB_IFBINDING        (IPSAMPLELOG_BASE + 56)
#define MSG_SAMPLE_MIB_IFBINDING_ADDR   (IPSAMPLELOG_BASE + 57)
#define MSG_SAMPLE_MIB_IFBINDING_HEADER (IPSAMPLELOG_BASE + 74)
#define MSG_SAMPLE_MIB_IFBINDING_ENTRY  (IPSAMPLELOG_BASE + 75)

#define STRING_PROTO_SAMPLE             (IPSAMPLELOG_BASE + 60)
#define STRING_LOGGING_NONE             (IPSAMPLELOG_BASE + 42)
#define STRING_LOGGING_ERROR            (IPSAMPLELOG_BASE + 43)
#define STRING_LOGGING_WARN             (IPSAMPLELOG_BASE + 44)
#define STRING_LOGGING_INFO             (IPSAMPLELOG_BASE + 45)
#define STRING_UNKNOWN                  (IPSAMPLELOG_BASE + 46)
#define STRING_BOUND                    (IPSAMPLELOG_BASE + 62)
#define STRING_ACTIVE                   (IPSAMPLELOG_BASE + 63)
#define STRING_UNBOUND                  (IPSAMPLELOG_BASE + 64)
#define STRING_INACTIVE                 (IPSAMPLELOG_BASE + 65)

#define EMSG_PROTO_NO_GLOBAL_CONFIG     (IPSAMPLELOG_BASE + 47)
#define EMSG_PROTO_NO_IF_CONFIG         (IPSAMPLELOG_BASE + 48)
#define EMSG_INTERFACE_EXISTS           (IPSAMPLELOG_BASE + 49)
#define EMSG_PROTO_NOT_INSTALLED        (IPSAMPLELOG_BASE + 50)
#define EMSG_PROTO_INSTALLED            (IPSAMPLELOG_BASE + 51)
#define EMSG_BAD_OPTION_VALUE           (IPSAMPLELOG_BASE + 52)
#define EMSG_RRAS_ERROR                 (IPSAMPLELOG_BASE + 53)
#define EMSG_NO_ENTRIES                 (IPSAMPLELOG_BASE + 54)

#define HLP_HELP1                       HLP_HELP
#define HLP_HELP1_EX                    HLP_HELP_EX
#define HLP_HELP2                       HLP_HELP
#define HLP_HELP2_EX                    HLP_HELP_EX
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ipx\ipxmon\ipxgl.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    ipxgl.c

Abstract:

    IPX Router Console Monitoring and Configuration tool.
    IPX Global configuration.

Author:

    Vadim Eydelman  06/07/1996


--*/
#include "precomp.h"
#pragma hdrstop

DWORD
CfgSetIpxGlInfo (
    IN DWORD    *pLogLevel OPTIONAL
    );

DWORD
AdmSetIpxGlInfo (
    IN DWORD    *pLogLevel OPTIONAL
    );

int APIENTRY 
ShowIpxGl(
    IN    int       argc,
    IN    WCHAR    *argv[],
    IN    BOOL      bDump
    ) 
{
    DWORD        rc;
    LPBYTE      pGlBlock;
    DWORD       sz;
    HANDLE      hTrCfg = NULL;
    PWCHAR      buffer = NULL;

    if ( g_hMprAdmin )
    {
        rc = MprAdminTransportGetInfo(
                g_hMprAdmin, PID_IPX, &pGlBlock, &sz,
                NULL, NULL
                );
        if ( rc == NO_ERROR ) { }
        else
        {
            goto GetFromCfg;
        }
    }

    else 
    {
GetFromCfg:
        rc = MprConfigTransportGetHandle( g_hMprConfig, PID_IPX, &hTrCfg );
        
        if ( rc == NO_ERROR )
        {
            rc = MprConfigTransportGetInfo(
                    g_hMprConfig, hTrCfg, &pGlBlock, &sz, NULL, NULL, NULL
                    );
        }
    }

    if ( rc == NO_ERROR )
    {
        PIPX_TOC_ENTRY pIpxGlToc;

        pIpxGlToc = GetIPXTocEntry (
                    (PIPX_INFO_BLOCK_HEADER)pGlBlock,
                    IPX_GLOBAL_INFO_TYPE
                    );
                    
        if ( pIpxGlToc != NULL )
        {
            PIPX_GLOBAL_INFO    pIpxGlInfo;
            PWCHAR              buffer;

            pIpxGlInfo = (PIPX_GLOBAL_INFO) (pGlBlock+pIpxGlToc->Offset);


            buffer = GetEnumString(
                        g_hModule, pIpxGlInfo->EventLogMask,
                        NUM_VALUES_IN_TABLE( LogLevels ), LogLevels
                        );
                        
            if ( bDump )
            {
                DisplayIPXMessage (g_hModule, MSG_IPX_DUMP_GLOBAL_HEADER);
                    
                DisplayMessageT( DMP_IPX_SET_GLOBAL, buffer );
            }

            else
            {
                DisplayIPXMessage(
                    g_hModule, MSG_IPX_GLOBAL_FMT, buffer
                    );
            }
        }
        
        else 
        {
            DisplayIPXMessage (g_hModule, MSG_ROUTER_INFO_CORRUPTED);
            rc = ERROR_INVALID_DATA;
        }
        
        if (hTrCfg!=NULL)
        {
            MprConfigBufferFree (pGlBlock);
        }
        else
        {
            MprAdminBufferFree (pGlBlock);
        }
    }
    else if (!bDump)
    {
        DisplayError( g_hModule, rc);
    }

    return rc;
}



int APIENTRY 
SetIpxGl (
    IN    int                    argc,
    IN    WCHAR                *argv[]
    ) 
{
    DWORD        rc;

    if ( argc >= 1 )
    {
        int         i;
        unsigned    n;
        PWCHAR      buffer;
        DWORD       logLevel;
        DWORD       *pLogLevel = NULL;
        TOKEN_VALUE LogLevel[] =
        {
            { VAL_NONE, 0 },
            { VAL_ERRORS_ONLY, EVENTLOG_ERROR_TYPE },
            { VAL_ERRORS_AND_WARNINGS, EVENTLOG_ERROR_TYPE | EVENTLOG_WARNING_TYPE },
            { VAL_MAXINFO, 
                EVENTLOG_ERROR_TYPE | EVENTLOG_WARNING_TYPE | EVENTLOG_INFORMATION_TYPE }
        };

        for ( i = 0; i < argc; i++ )
        {
            if ( !_wcsicmp( argv[i], TOKEN_LOGLEVEL ) )
            {
                if ( ( pLogLevel == NULL ) && ( i < argc - 1 ) && 
                     !MatchEnumTag( 
                        g_hModule, argv[ i + 1 ], NUM_TOKENS_IN_TABLE( LogLevel ),
                        LogLevel, &logLevel ) )
                {
                    i += 1;
                    pLogLevel = &logLevel;
                }
                
                else
                {
                    break;
                }
            }
            
            else if ( pLogLevel == NULL ) 
            {
                if ( !MatchEnumTag( 
                        g_hModule, argv[ i ], NUM_TOKENS_IN_TABLE( LogLevel ),
                        LogLevel, &logLevel ) ) 
                {
                    pLogLevel = &logLevel;
                }
                else
                {
                    break;
                }
            }
        }
        
        if ( i == argc )
        {
            rc = CfgSetIpxGlInfo( pLogLevel );
            
            if ( rc == NO_ERROR ) 
            {
                if ( g_hMprAdmin )
                {
                    AdmSetIpxGlInfo( pLogLevel );
                }
            }
        }
        else 
        {
            rc = ERROR_INVALID_SYNTAX;
        }
    }
    else
    {
        rc = ERROR_INVALID_SYNTAX;
    }

    return rc;
}





DWORD
CfgSetIpxGlInfo (
    IN DWORD    *pLogLevel OPTIONAL
    ) 
{
    DWORD   rc;
    HANDLE  hTrCfg;

    rc = MprConfigTransportGetHandle( g_hMprConfig, PID_IPX, &hTrCfg );

    if ( rc == NO_ERROR )
    {
        DWORD   sz;
        LPBYTE  pGlBlock;

        rc = MprConfigTransportGetInfo(
                g_hMprConfig, hTrCfg, &pGlBlock, &sz, NULL, NULL, NULL
                );
                
        if (rc==NO_ERROR) 
        {
            PIPX_TOC_ENTRY pIpxGlToc;

            pIpxGlToc = GetIPXTocEntry (
                            (PIPX_INFO_BLOCK_HEADER)pGlBlock,
                            IPX_GLOBAL_INFO_TYPE
                            );
                            
            if (pIpxGlToc!=NULL) 
            {
                PIPX_GLOBAL_INFO    pIpxGlInfo;

                pIpxGlInfo = (PIPX_GLOBAL_INFO) (pGlBlock+pIpxGlToc->Offset);
                
                if ( pLogLevel )
                {
                    pIpxGlInfo->EventLogMask = *pLogLevel;
                }
                
                rc = MprConfigTransportSetInfo(
                        g_hMprConfig, hTrCfg, pGlBlock, sz, NULL, 0, NULL
                        );
                        
                if (rc==NO_ERROR) 
                {
                    DisplayIPXMessage (g_hModule, MSG_IPXGL_SET_CFG);
                }
                else
                {
                    DisplayError( g_hModule, rc);
                }
            }
            else 
            {             
                DisplayIPXMessage (g_hModule, MSG_ROUTER_INFO_CORRUPTED);
                rc = ERROR_INVALID_DATA;
            }

            MprConfigBufferFree (pGlBlock);
        }
        else
        {
            DisplayError( g_hModule, rc);
        }
    }
    else
    {
        DisplayError( g_hModule, rc);
    }

    return rc;
}




DWORD
AdmSetIpxGlInfo (
    IN DWORD    *pLogLevel OPTIONAL
    )
{
    DWORD    rc;
    LPBYTE    pGlBlock;
    DWORD   sz;

    rc = MprAdminTransportGetInfo(
            g_hMprAdmin, PID_IPX, &pGlBlock, &sz, NULL, NULL
            );

    if (rc==NO_ERROR) 
    {
        PIPX_TOC_ENTRY pIpxGlToc;

        pIpxGlToc = GetIPXTocEntry (
                        (PIPX_INFO_BLOCK_HEADER)pGlBlock,
                        IPX_GLOBAL_INFO_TYPE
                        );
                        
        if (pIpxGlToc!=NULL)
        {
            PIPX_GLOBAL_INFO    pIpxGlInfo;

            pIpxGlInfo = (PIPX_GLOBAL_INFO) (pGlBlock+pIpxGlToc->Offset);
            
            if (pLogLevel)
            {
                pIpxGlInfo->EventLogMask = *pLogLevel;
            }

            rc = MprAdminTransportSetInfo(
                    g_hMprAdmin, PID_IPX, pGlBlock, sz, NULL, 0
                    );

            if (rc==NO_ERROR) 
            {
                DisplayIPXMessage (g_hModule,
                        MSG_IPXGL_SET_ADM);
            }
            else
            {
                DisplayError( g_hModule, rc);
            }
        }
        else 
        {             
            DisplayIPXMessage (g_hModule, MSG_ROUTER_INFO_CORRUPTED);
            rc = ERROR_INVALID_DATA;
        }
        MprAdminBufferFree (pGlBlock);
    }
    else
    {
        DisplayError( g_hModule, rc);
    }

    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ipx\ipxmon\ipxhandle.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    routing\netsh\ipx\ipxhandle.c

Abstract:

    IPX Command handler.

Revision History:

    V Raman                     12/2/98  Created

--*/


#ifndef __IPXHANDLE_H__
#define __IPXHANDLE_H__


//
// Handle static route operations
//

FN_HANDLE_CMD HandleIpxAddRoute;
FN_HANDLE_CMD HandleIpxDelRoute;
FN_HANDLE_CMD HandleIpxSetRoute;
FN_HANDLE_CMD HandleIpxShowRoute;

//
// Handle static service operations
//

FN_HANDLE_CMD HandleIpxAddService;
FN_HANDLE_CMD HandleIpxDelService;
FN_HANDLE_CMD HandleIpxSetService;
FN_HANDLE_CMD HandleIpxShowService;

//
// Handle packet filter operations
//

FN_HANDLE_CMD HandleIpxAddFilter;
FN_HANDLE_CMD HandleIpxDelFilter;
FN_HANDLE_CMD HandleIpxSetFilter;
FN_HANDLE_CMD HandleIpxShowFilter;

//
// Handle interface operations
//

FN_HANDLE_CMD HandleIpxAddInterface;
FN_HANDLE_CMD HandleIpxDelInterface;
FN_HANDLE_CMD HandleIpxSetInterface;
FN_HANDLE_CMD HandleIpxShowInterface;

//
// Handle loglevel operations
//

FN_HANDLE_CMD HandleIpxSetLoglevel;
FN_HANDLE_CMD HandleIpxShowLoglevel;

//
// Other misc operations
//

FN_HANDLE_CMD HandleIpxUpdate;

//
// Route and Service Table display
//

FN_HANDLE_CMD HandleIpxShowRouteTable;
FN_HANDLE_CMD HandleIpxShowServiceTable;

NS_CONTEXT_DUMP_FN  IpxDump;

VOID
DumpIpxInformation(
    IN     LPCWSTR    pwszMachineName,
    IN OUT LPWSTR    *ppwcArguments,
    IN     DWORD      dwArgCount,
    IN     MIB_SERVER_HANDLE hMibServer
    );

//
// operations enumerations
//

typedef enum _IPX_OPERATION
{
    IPX_OPERATION_ADD,
    IPX_OPERATION_DELETE,
    IPX_OPERATION_SET,
    IPX_OPERATION_SHOW
    
} IPX_OPERATION;


#endif // __IPXHANDLE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ipx\ipxmon\ipxgl.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    ipxgl.h

Abstract:

    IPX Router Console Monitoring and Configuration tool.
    IPX Global configuration.

Author:

    Vadim Eydelman  06/07/1996


--*/
#ifndef _IPXMON_IPXGL_
#define _IPXMON_IPXGL_

int APIENTRY 
ShowIpxGl (
    IN    int                   argc,
    IN    WCHAR                *argv[],
    IN    BOOL                  bDump
    );

int APIENTRY 
SetIpxGl (
    IN    int                   argc,
    IN    WCHAR                *argv[]
    );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ipx\ipxmon\ipxhandle.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    routing\netsh\ipx\ipxhandle.c

Abstract:

    IPX Command handler.

Revision History:

    V Raman                     12/2/98  Created

--*/

#include "precomp.h"
#pragma hdrstop


DWORD
HandleIpxInterface(
    IN OUT  LPWSTR          *ppwcArguments,
    IN      DWORD           dwCurrentIndex,
    IN      DWORD           dwArgCount,
    IN      IPX_OPERATION   ioOP
);

DWORD
HandleIpxStaticRoute(
    IN OUT  LPWSTR          *ppwcArguments,
    IN      DWORD           dwCurrentIndex,
    IN      DWORD           dwArgCount,
    IN      IPX_OPERATION   ioOP
);

DWORD
HandleIpxStaticService(
    IN OUT  LPWSTR          *ppwcArguments,
    IN      DWORD           dwCurrentIndex,
    IN      DWORD           dwArgCount,
    IN      IPX_OPERATION   ioOP
);

DWORD
HandleIpxTrafficFilters(
    IN OUT  LPWSTR          *ppwcArguments,
    IN      DWORD           dwCurrentIndex,
    IN      DWORD           dwArgCount,
    IN      IPX_OPERATION   ioOP
);

//
// Handle static route operations
//

DWORD
HandleIpxAddRoute(
    IN      LPCWSTR     pwszMachineName,
    IN OUT  LPWSTR      *ppwcArguments,
    IN      DWORD       dwCurrentIndex,
    IN      DWORD       dwArgCount,
    IN      DWORD       dwFlags,
    IN      LPCVOID       pvData,
    OUT     PBOOL       pbDone
    )
/*++

Routine Description :

    This function handles addition of static IPX routes by
    mapping the parameters to those required by the corresp.
    routemon routine.


Arguments :

    ppwcArguments - list of arguments to the add route command

    dwCurrentIndex - index of current argument in the argument table

    dwArgCount - Number of arguments in the argument table

    pbDone - As yet undetermined


Return Value

    NO_ERROR - Success

--*/
{
    return HandleIpxStaticRoute( 
                ppwcArguments, dwCurrentIndex, dwArgCount, IPX_OPERATION_ADD
                );
}


DWORD
HandleIpxDelRoute(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :

    This function handles deletion of static IPX routes by
    mapping the parameters to those required by the corresp.
    routemon routine.


Arguments :

    ppwcArguments - list of arguments to the add route command

    dwCurrentIndex - index of current argument in the argument table

    dwArgCount - Number of arguments in the argument table

    pbDone - As yet undetermined


Return Value

    NO_ERROR - Success

--*/
{
    return HandleIpxStaticRoute( 
                ppwcArguments, dwCurrentIndex, dwArgCount, IPX_OPERATION_DELETE
                );
}




DWORD
HandleIpxSetRoute(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :

    This function handles update of static IPX routes by
    mapping the parameters to those required by the corresp.
    routemon routine.


Arguments :

    ppwcArguments - list of arguments to the add route command

    dwCurrentIndex - index of current argument in the argument table

    dwArgCount - Number of arguments in the argument table

    pbDone - As yet undetermined


Return Value

    NO_ERROR - Success

--*/
{
    return HandleIpxStaticRoute( 
                ppwcArguments, dwCurrentIndex, dwArgCount, IPX_OPERATION_SET
                );
}



DWORD
HandleIpxShowRoute(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :

    This function handles display of static IPX routes by
    mapping the parameters to those required by the corresp.
    routemon routine.


Arguments :

    ppwcArguments - list of arguments to the add route command

    dwCurrentIndex - index of current argument in the argument table

    dwArgCount - Number of arguments in the argument table

    pbDone - As yet undetermined


Return Value

    NO_ERROR - Success

--*/
{
    return HandleIpxStaticRoute( 
                ppwcArguments, dwCurrentIndex, dwArgCount, IPX_OPERATION_SHOW
                );
}




DWORD
HandleIpxStaticRoute(
    IN OUT  LPWSTR          *ppwcOldArguments,
    IN      DWORD           dwCurrentIndex,
    IN      DWORD           dwOldArgCount,
    IN      IPX_OPERATION   ioOP
)
/*++

Routine Description :

    This routine munges the command line and invokes the appropriate
    routemon routine to handle static route operations
    
Arguments :
    ppwcArguments - command line argument array
    dwCurrentIndex - current argument under consideration
    dwArgCount - Number of arguments in ppwcArguments
    bAdd - flag indicating whether IPX is being added or deleted

Return Value :

--*/
{
    DWORD   dwErr;
    BOOL    bFreeNewArg = FALSE;
    PWCHAR  pwszIfName;
    DWORD   dwArgCount = dwOldArgCount;
    PWCHAR *ppwcArguments = NULL;
    
    //
    // Check if name= option is specified
    //

    pwszIfName = TOKEN_INTERFACE_NAME;

    if ( pwszIfName == NULL )
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;

        DisplayError( g_hModule, dwErr );

        return dwErr;
    }

  do {
    // Munge arguments into old format
    dwErr = MungeArguments(
            ppwcOldArguments, dwOldArgCount, (PBYTE *) &ppwcArguments,
            &dwArgCount, &bFreeNewArg
            );
    if (dwErr) 
    {
        break;
    }


    if ( ( dwCurrentIndex < dwArgCount ) &&
           !_wcsnicmp( 
                ppwcArguments[ dwCurrentIndex ], pwszIfName, wcslen( pwszIfName )
            ) )
    {
        //
        // ok name= option tag specified, remove it and the following space
        //

        wcscpy( 
            ppwcArguments[ dwCurrentIndex ], 
            &ppwcArguments[ dwCurrentIndex ][ wcslen( pwszIfName ) + 2 ]
            );
    }


    //
    // Now invoke the original routemon routine with what looks
    // like an appriate command line
    //

    switch ( ioOP )
    {
        case IPX_OPERATION_ADD :
        
            dwErr = CreateStRt( 
                        dwArgCount - dwCurrentIndex, 
                        ppwcArguments + dwCurrentIndex
                        );
            break;

        
        case IPX_OPERATION_DELETE :
        
            dwErr = DeleteStRt( 
                        dwArgCount - dwCurrentIndex, 
                        ppwcArguments + dwCurrentIndex 
                        );

            break;


        case IPX_OPERATION_SET :
        
            dwErr = SetStRt( 
                        dwArgCount - dwCurrentIndex, 
                        ppwcArguments + dwCurrentIndex 
                        );

            break;


        case IPX_OPERATION_SHOW :
        
            dwErr = ShowStRt( 
                        dwArgCount - dwCurrentIndex, 
                        ppwcArguments + dwCurrentIndex,
                        FALSE
                        );

            break;

    }

  } while (FALSE);

    if ( bFreeNewArg )
    {
        FreeArgTable( dwOldArgCount, ppwcArguments );
    }

    return dwErr;
}


//
// Handle static service operations
//

DWORD
HandleIpxAddService(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :

    This function handles addition of static IPX services by
    mapping the parameters to those required by the corresp.
    routemon routine.


Arguments :

    ppwcArguments - list of arguments to the add route command

    dwCurrentIndex - index of current argument in the argument table

    dwArgCount - Number of arguments in the argument table

    pbDone - As yet undetermined


Return Value

    NO_ERROR - Success

--*/
{
    return HandleIpxStaticService( 
                ppwcArguments, dwCurrentIndex, dwArgCount, IPX_OPERATION_ADD
                );
}


DWORD
HandleIpxDelService(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :

    This function handles deletion of static IPX services by
    mapping the parameters to those required by the corresp.
    routemon routine.


Arguments :

    ppwcArguments - list of arguments to the add route command

    dwCurrentIndex - index of current argument in the argument table

    dwArgCount - Number of arguments in the argument table

    pbDone - As yet undetermined


Return Value

    NO_ERROR - Success

--*/
{
    return HandleIpxStaticService( 
                ppwcArguments, dwCurrentIndex, dwArgCount, IPX_OPERATION_DELETE
                );
}



DWORD
HandleIpxSetService(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :

    This function handles update of static IPX services by
    mapping the parameters to those required by the corresp.
    routemon routine.


Arguments :

    ppwcArguments - list of arguments to the add route command

    dwCurrentIndex - index of current argument in the argument table

    dwArgCount - Number of arguments in the argument table

    pbDone - As yet undetermined


Return Value

    NO_ERROR - Success

--*/
{
    return HandleIpxStaticService( 
                ppwcArguments, dwCurrentIndex, dwArgCount, IPX_OPERATION_SET
                );
}


DWORD
HandleIpxShowService(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :

    This function handles display of static IPX services by
    mapping the parameters to those required by the corresp.
    routemon routine.


Arguments :

    ppwcArguments - list of arguments to the add route command

    dwCurrentIndex - index of current argument in the argument table

    dwArgCount - Number of arguments in the argument table

    pbDone - As yet undetermined


Return Value

    NO_ERROR - Success

--*/
{
    return HandleIpxStaticService( 
                ppwcArguments, dwCurrentIndex, dwArgCount, IPX_OPERATION_SHOW
                );
}



DWORD
HandleIpxStaticService(
    IN OUT  LPWSTR          *ppwcOldArguments,
    IN      DWORD           dwCurrentIndex,
    IN      DWORD           dwOldArgCount,
    IN      IPX_OPERATION   ioOP
)

/*++

Routine Description :

    This routine munges the command line and invokes the appropriate
    routemon routine to handle static service operations
    
Arguments :
    ppwcArguments - command line argument array
    dwCurrentIndex - current argument under consideration
    dwArgCount - Number of arguments in ppwcArguments
    bAdd - flag indicating whether IPX is being added or deleted

Return Value :

--*/
{
    DWORD   dwErr;
    BOOL    bFreeNewArg = FALSE;
    PWCHAR  pwszIfName;
    DWORD   dwArgCount = dwOldArgCount;
    PWCHAR *ppwcArguments = NULL;
    
    //
    // Check if name= option is specified
    //

    pwszIfName = TOKEN_INTERFACE_NAME;

    if ( pwszIfName == NULL )
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;

        DisplayError( g_hModule, dwErr );

        return dwErr;
    }

  do {
    // Munge arguments into old format
    dwErr = MungeArguments(
            ppwcOldArguments, dwOldArgCount, (PBYTE *) &ppwcArguments,
            &dwArgCount, &bFreeNewArg
            );
    if (dwErr)
    {
        break;
    }

    if ( ( dwCurrentIndex < dwArgCount ) &&
           !_wcsnicmp( 
                ppwcArguments[ dwCurrentIndex ], pwszIfName, wcslen( pwszIfName ) 
            ) )
    {
        //
        // ok name= option tag specified, remove it and the following space
        //

        wcscpy( 
            ppwcArguments[ dwCurrentIndex ], 
            &ppwcArguments[ dwCurrentIndex ][ wcslen( pwszIfName ) + 2 ]
            );
    }


    //
    // Now invoke the original routemon routine with what looks
    // like an appriate command line
    //

    switch ( ioOP )
    {
        case IPX_OPERATION_ADD :
        
            dwErr = CreateStSvc( 
                        dwArgCount - dwCurrentIndex, 
                        ppwcArguments + dwCurrentIndex
                        );
            break;

        
        case IPX_OPERATION_DELETE :
        
            dwErr = DeleteStSvc( 
                        dwArgCount - dwCurrentIndex, 
                        ppwcArguments + dwCurrentIndex 
                        );

            break;


        case IPX_OPERATION_SET :
        
            dwErr = SetStSvc( 
                        dwArgCount - dwCurrentIndex, 
                        ppwcArguments + dwCurrentIndex 
                        );

            break;


        case IPX_OPERATION_SHOW :
        
            dwErr = ShowStSvc( 
                        dwArgCount - dwCurrentIndex, 
                        ppwcArguments + dwCurrentIndex,
                        FALSE
                        );

            break;

    }

  } while (FALSE);

    if ( bFreeNewArg )
    {
        FreeArgTable( dwOldArgCount, ppwcArguments );
    }

    return dwErr;
}



//
// Handle packet filter operations
//

DWORD
HandleIpxAddFilter(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :

    This function handles addition of IPX traffic filters by
    mapping the parameters to those required by the corresp.
    routemon routine.


Arguments :

    ppwcArguments - list of arguments to the add route command

    dwCurrentIndex - index of current argument in the argument table

    dwArgCount - Number of arguments in the argument table

    pbDone - As yet undetermined


Return Value

    NO_ERROR - Success

--*/
{
    return HandleIpxTrafficFilters( 
                ppwcArguments, dwCurrentIndex, dwArgCount, IPX_OPERATION_ADD
                );
}



DWORD
HandleIpxDelFilter(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :

    This function handles deletion of IPX traffic filters by
    mapping the parameters to those required by the corresp.
    routemon routine.


Arguments :

    ppwcArguments - list of arguments to the add route command

    dwCurrentIndex - index of current argument in the argument table

    dwArgCount - Number of arguments in the argument table

    pbDone - As yet undetermined


Return Value

    NO_ERROR - Success

--*/
{
    return HandleIpxTrafficFilters( 
                ppwcArguments, dwCurrentIndex, dwArgCount, IPX_OPERATION_DELETE
                );
}



DWORD
HandleIpxSetFilter(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :

    This function handles update of IPX traffic filters by
    mapping the parameters to those required by the corresp.
    routemon routine.


Arguments :

    ppwcArguments - list of arguments to the add route command

    dwCurrentIndex - index of current argument in the argument table

    dwArgCount - Number of arguments in the argument table

    pbDone - As yet undetermined


Return Value

    NO_ERROR - Success

--*/
{
    return HandleIpxTrafficFilters( 
                ppwcArguments, dwCurrentIndex, dwArgCount, IPX_OPERATION_SET
                );
}



DWORD
HandleIpxShowFilter(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :

    This function handles display of IPX traffic filters by
    mapping the parameters to those required by the corresp.
    routemon routine.


Arguments :

    ppwcArguments - list of arguments to the add route command

    dwCurrentIndex - index of current argument in the argument table

    dwArgCount - Number of arguments in the argument table

    pbDone - As yet undetermined


Return Value

    NO_ERROR - Success

--*/
{
    return HandleIpxTrafficFilters( 
                ppwcArguments, dwCurrentIndex, dwArgCount, IPX_OPERATION_SHOW
                );
}



DWORD
HandleIpxTrafficFilters(
    IN OUT  LPWSTR          *ppwcOldArguments,
    IN      DWORD           dwCurrentIndex,
    IN      DWORD           dwOldArgCount,
    IN      IPX_OPERATION   ioOP
)
/*++

Routine Description :

    This routine munges the command line and invokes the appropriate
    routemon routine to handle traffic filter operations
    
Arguments :
    ppwcArguments - command line argument array
    dwCurrentIndex - current argument under consideration
    dwArgCount - Number of arguments in ppwcArguments
    bAdd - flag indicating whether IPX is being added or deleted

Return Value :

--*/
{
    DWORD   dwErr;
    BOOL    bFreeNewArg = FALSE;
    PWCHAR  pwszIfName;
    DWORD   dwArgCount = dwOldArgCount;
    PWCHAR *ppwcArguments = NULL;
    
    //
    // Check if name= option is specified
    //

    pwszIfName = TOKEN_INTERFACE_NAME;

    if ( pwszIfName == NULL )
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;

        DisplayError( g_hModule, dwErr );

        return dwErr;
    }

  do {
    // Munge arguments into old format
    dwErr = MungeArguments(
            ppwcOldArguments, dwOldArgCount, (PBYTE *) &ppwcArguments,
            &dwArgCount, &bFreeNewArg
            );
    if (dwErr)
    {
        break;
    }

    if ( ( dwCurrentIndex < dwArgCount ) &&
           !_wcsnicmp( 
             ppwcArguments[ dwCurrentIndex ], pwszIfName, wcslen( pwszIfName ) 
            ) )
    {
        //
        // ok name= option tag specified, remove it and the following space
        //

        wcscpy( 
            ppwcArguments[ dwCurrentIndex ], 
            &ppwcArguments[ dwCurrentIndex ][ wcslen( pwszIfName ) + 2 ]
            );
    }


    //
    // Now invoke the original routemon routine with what looks
    // like an appriate command line
    //

    switch ( ioOP )
    {
        case IPX_OPERATION_ADD :
        
            dwErr = CreateTfFlt( 
                        dwArgCount - dwCurrentIndex, 
                        ppwcArguments + dwCurrentIndex
                        );
            break;

        
        case IPX_OPERATION_DELETE :
        
            dwErr = DeleteTfFlt( 
                        dwArgCount - dwCurrentIndex, 
                        ppwcArguments + dwCurrentIndex 
                        );

            break;


        case IPX_OPERATION_SET :
        
            dwErr = SetTfFlt( 
                        dwArgCount - dwCurrentIndex, 
                        ppwcArguments + dwCurrentIndex 
                        );

            break;


        case IPX_OPERATION_SHOW :
        
            dwErr = ShowTfFlt( 
                        dwArgCount - dwCurrentIndex, 
                        ppwcArguments + dwCurrentIndex,
                        FALSE
                        );

            break;

    }
  } while (FALSE);

    if ( bFreeNewArg )
    {
        FreeArgTable( dwOldArgCount, ppwcArguments );
    }

    return dwErr;
}

//
// Handle interface operations
//

DWORD
HandleIpxAddInterface(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :

    This routine munges the command line and invokes the appropriate
    routemon routine to handle interface addition

Arguments :
    ppwcArguments - command line argument array
    dwCurrentIndex - current argument under consideration
    dwArgCount - Number of arguments in ppwcArguments
    pbDone - Don't know

Return Value :

--*/
{
    return HandleIpxInterface( 
                ppwcArguments, dwCurrentIndex, dwArgCount, IPX_OPERATION_ADD 
                );
}


DWORD
HandleIpxDelInterface(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :

    This routine munges the command line and invokes the appropriate
    routemon routine to handle interface addition

Arguments :
    ppwcArguments - command line argument array
    dwCurrentIndex - current argument under consideration
    dwArgCount - Number of arguments in ppwcArguments
    pbDone - Don't know

Return Value :

--*/
{
    return HandleIpxInterface( 
                ppwcArguments, dwCurrentIndex, dwArgCount, IPX_OPERATION_DELETE 
                );
}


DWORD
HandleIpxSetInterface(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :

    This routine munges the command line and invokes the appropriate
    routemon routine to handle interface addition

Arguments :
    ppwcArguments - command line argument array
    dwCurrentIndex - current argument under consideration
    dwArgCount - Number of arguments in ppwcArguments
    pbDone - Don't know

Return Value :

--*/
{
    return HandleIpxInterface( 
                ppwcArguments, dwCurrentIndex, dwArgCount, IPX_OPERATION_SET 
                );
}


DWORD
HandleIpxShowInterface(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :

    This routine munges the command line and invokes the appropriate
    routemon routine to handle interface addition

Arguments :
    ppwcArguments - command line argument array
    dwCurrentIndex - current argument under consideration
    dwArgCount - Number of arguments in ppwcArguments
    pbDone - Don't know

Return Value :

--*/
{
    return HandleIpxInterface( 
                ppwcArguments, dwCurrentIndex, dwArgCount, IPX_OPERATION_SHOW 
                );
}




DWORD
HandleIpxInterface(
    IN OUT  LPWSTR          *ppwcOldArguments,
    IN      DWORD           dwCurrentIndex,
    IN      DWORD           dwOldArgCount,
    IN      IPX_OPERATION   ioOP
)
/*++

Routine Description :

    This routine munges the command line and invokes the appropriate
    routemon routine to handle interface addition

Arguments :
    ppwcArguments - command line argument array
    dwCurrentIndex - current argument under consideration
    dwArgCount - Number of arguments in ppwcArguments
    bAdd - flag indicating whether IPX is being added or deleted

Return Value :

--*/
{
    DWORD   dwErr;
    BOOL    bFreeNewArg = FALSE;
    PWCHAR  pwszIfName;
    DWORD   dwArgCount = dwOldArgCount;
    PWCHAR *ppwcArguments = NULL;
    
    //
    // Check if name= option is specified
    //

    pwszIfName = TOKEN_INTERFACE_NAME;

    if ( pwszIfName == NULL )
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;

        DisplayError( g_hModule, dwErr );

        return dwErr;
    }

  do {
    // Munge arguments into old format
    dwErr = MungeArguments(
            ppwcOldArguments, dwOldArgCount, (PBYTE *) &ppwcArguments,
            &dwArgCount, &bFreeNewArg
            );
    if (dwErr)
    {
        break;
    }

    if ( ( dwCurrentIndex < dwArgCount ) &&
         !_wcsnicmp( 
            ppwcArguments[ dwCurrentIndex ], pwszIfName, wcslen( pwszIfName ) 
            ) )
    {
        //
        // ok name= option tag specified, remove it and the following space
        //

        wcscpy( 
            ppwcArguments[ dwCurrentIndex ], 
            &ppwcArguments[ dwCurrentIndex ][ wcslen( pwszIfName ) + 2 ]
            );
    }


    //
    // Now invoke the original routemon routine with what looks
    // like an appriate command line
    //

    switch ( ioOP )
    {
        case IPX_OPERATION_ADD :
        
            dwErr = InstallIpx( 
                        dwArgCount - dwCurrentIndex, 
                        ppwcArguments + dwCurrentIndex
                        );
            break;

        
        case IPX_OPERATION_DELETE :
        
            dwErr = RemoveIpx( 
                        dwArgCount - dwCurrentIndex, 
                        ppwcArguments + dwCurrentIndex 
                        );

            break;


        case IPX_OPERATION_SET :
        
            dwErr = SetIpxIf( 
                        dwArgCount - dwCurrentIndex, 
                        ppwcArguments + dwCurrentIndex 
                        );

            break;


        case IPX_OPERATION_SHOW :
        
            dwErr = ShowIpxIf( 
                        dwArgCount - dwCurrentIndex, 
                        ppwcArguments + dwCurrentIndex,
                        FALSE
                        );

            break;

    }
  } while (FALSE);

    if ( bFreeNewArg )
    {
        FreeArgTable( dwOldArgCount, ppwcArguments );
    }

    return dwErr;
}


//
// Handle loglevel operations
//

DWORD
HandleIpxSetLoglevel(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD   dwErr;
    BOOL    bFreeNewArg = FALSE;
    DWORD   dwNewArgCount = dwArgCount;
    PWCHAR *ppwcNewArguments = NULL;

    do {
        // Munge arguments into old format
        dwErr = MungeArguments(
                ppwcArguments, dwArgCount, (PBYTE *) &ppwcNewArguments,
                &dwNewArgCount, &bFreeNewArg
                );
        if (dwErr)
        {
            break;
        }

        dwErr= SetIpxGl( dwNewArgCount - dwCurrentIndex, 
                         ppwcNewArguments + dwCurrentIndex );

    } while (FALSE);

    if ( bFreeNewArg )
    {
        FreeArgTable( dwArgCount, ppwcNewArguments );
    }

    return dwErr;
}


DWORD
HandleIpxShowLoglevel(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return ShowIpxGl( 
            dwArgCount - dwCurrentIndex, 
            ppwcArguments + dwCurrentIndex,
            FALSE
            );
}

DWORD
HandleIpxUpdate(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return NO_ERROR;
}


DWORD
HandleIpxShowRouteTable(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return ShowRoute( 
            dwArgCount - dwCurrentIndex, 
            ppwcArguments + dwCurrentIndex 
            );
}


DWORD
HandleIpxShowServiceTable(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return ShowService( 
            dwArgCount - dwCurrentIndex, 
            ppwcArguments + dwCurrentIndex 
            );
}


DWORD
IpxDump(
    IN      LPCWSTR     pwszRouter,
    IN OUT  LPWSTR     *ppwcArguments,
    IN      DWORD       dwArgCount,
    IN      LPCVOID     pvData
    )
{
    BOOL  bDone;
    DWORD dwErr;

    dwErr = ConnectToRouter(pwszRouter);
    if (dwErr)
    {
        return dwErr;
    }

    DisplayIPXMessage (g_hModule, MSG_IPX_DUMP_HEADER );

    DisplayMessageT( DMP_IPX_HEADER );

    DumpIpxInformation(pwszRouter, ppwcArguments,dwArgCount,g_hMIBServer);

    DisplayMessageT( DMP_IPX_FOOTER );

    DisplayIPXMessage (g_hModule, MSG_IPX_DUMP_FOOTER );

    return NO_ERROR;
}


VOID
DumpIpxInformation(
    IN     LPCWSTR    pwszMachineName,
    IN OUT LPWSTR    *ppwcArguments,
    IN     DWORD      dwArgCount,
    IN     MIB_SERVER_HANDLE hMibServer
    )
{
    DWORD dwErr, dwRead = 0, dwTot = 0, i;
    PMPR_INTERFACE_0 IfList;
    WCHAR   IfDisplayName[ MAX_INTERFACE_NAME_LEN + 1 ];   
    DWORD   dwSize = sizeof(IfDisplayName);
    PWCHAR  argv[1];
    //
    // dump globals
    //
    
    ShowIpxGl( 0, NULL, TRUE );


    //
    // dump interfaces
    //
    
    ShowIpxIf( 0, NULL, TRUE );


    //
    // enumerate interfaces
    //

    if ( g_hMprAdmin )
    {
        dwErr = MprAdminInterfaceEnum(
                    g_hMprAdmin, 0, (unsigned char **)&IfList, MAXULONG, &dwRead,
                    &dwTot,NULL
                    );
    }

    else
    {
        dwErr = MprConfigInterfaceEnum(
                    g_hMprConfig, 0, (unsigned char **)&IfList, MAXULONG, &dwRead,
                    &dwTot,NULL
                    );
    }
    
    if ( dwErr != NO_ERROR )
    {
        DisplayError( g_hModule, dwErr);
        return;
    }


    //
    // enumerate filters on each interface
    //

    DisplayIPXMessage (g_hModule, MSG_IPX_DUMP_TRAFFIC_FILTER_HEADER );
    
    for ( i = 0; i < dwRead; i++ )
    {
        dwErr = IpmontrGetFriendlyNameFromIfName(
                    IfList[i].wszInterfaceName, IfDisplayName, &dwSize
                );   

        if ( dwErr == NO_ERROR )
        {
            argv[0] = IfDisplayName;
            
            ShowTfFlt( 1, argv, TRUE );
        }
    }
    
    
    //
    // Enumerate static routes on each interface
    //

    DisplayIPXMessage (g_hModule, MSG_IPX_DUMP_STATIC_ROUTE_HEADER );
    
    for ( i = 0; i < dwRead; i++ )
    {
        dwErr = IpmontrGetFriendlyNameFromIfName(
                    IfList[i].wszInterfaceName, IfDisplayName, &dwSize
                );   

        if ( dwErr == NO_ERROR )
        {
            argv[0] = IfDisplayName;
            
            ShowStRt( 1, argv, TRUE );
        }
    }
    

    //
    // Enumerate static services on each interface
    //

    DisplayIPXMessage (g_hModule, MSG_IPX_DUMP_STATIC_SERVICE_HEADER );
    
    for ( i = 0; i < dwRead; i++ )
    {
        dwErr = IpmontrGetFriendlyNameFromIfName(
                    IfList[i].wszInterfaceName, IfDisplayName, &dwSize
                );   

        if ( dwErr == NO_ERROR )
        {
            argv[0] = IfDisplayName;
            
            ShowStSvc( 1, argv, TRUE );
        }
    }


    if ( g_hMprAdmin )
    {
        MprAdminBufferFree( IfList );
    }
    else
    {
        MprConfigBufferFree( IfList );
    }   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ipx\ipxmon\ipxifs.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    ipxifs.h

Abstract:

    IPX Router Console Monitoring and Configuration tool.
    IPX Interface configuration and monitoring. Header File

Author:

    Vadim Eydelman  06/07/1996


--*/
#ifndef _IPXMON_IPXIFS_
#define _IPXMON_IPXIFS_

DWORD
APIENTRY 
HelpIpxIf(
    IN    DWORD         argc,
    IN    LPCWSTR      *argv
    );


DWORD
APIENTRY 
ShowIpxIf(
    IN    DWORD         argc,
    IN    LPCWSTR      *argv,
    IN    BOOL          bDump
    );


DWORD
APIENTRY 
SetIpxIf(
    IN    DWORD         argc,
    IN    LPCWSTR      *argv
    );


DWORD
APIENTRY 
InstallIpx(
    IN    DWORD         argc,
    IN    LPCWSTR      *argv
    );


DWORD
APIENTRY 
RemoveIpx(
    IN    DWORD         argc,
    IN    LPCWSTR      *argv
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ipx\ipxmon\makefile.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ipx\ipxmon\ipxmon.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:
     net\routing\netsh\ipx\ipxmon.h   

Abstract:

     Prototype for fns called in ipxmon.c

Author:

     V Raman        Created     7/10/98

--*/

#ifndef __IPXMON_H__
#define __IPXMON_H__

//
// Handle to DLL
//

extern HANDLE g_hModule;

//
// handles to router
//

extern HANDLE g_hMprConfig;

extern HANDLE g_hMprAdmin;

extern HANDLE g_hMIBServer;


//
// Commit mode
//

extern BOOL g_bCommit;

//
// Router name
//

extern PWCHAR g_pwszRouter;

//
// global stuff used in multiple files
//

extern CMD_ENTRY g_IpxCmds[];

extern ULONG g_ulNumTopCmds;

extern ULONG g_ulNumGroups;

extern CMD_GROUP_ENTRY g_IpxCmdGroups[];

//
// Helper functions passed in by the SHELL
//

NS_DLL_STOP_FN StopHelperDll;

DWORD
ConnectToRouter(
    IN  LPCWSTR  pwszRouter
    );

DWORD
MungeArguments(
    IN OUT  LPWSTR    *ppwcArguments,
    IN      DWORD       dwArgCount,
       OUT  PBYTE      *ppbNewArg,
       OUT  PDWORD      pdwNewArgCount,
       OUT  PBOOL       pbFreeArg
    );

VOID
FreeArgTable(
    IN     DWORD         dwArgCount,
    IN OUT LPWSTR        *ppwcArgs
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ipx\ipxmon\ipxstrng.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    routing\netsh\ipx\ipxstrng.h

Abstract:

    Definitions for non-localizable strings.

Revision History:

    V Raman                     1/20/99  Created

--*/

//
// Option TAG strings
//

#define TOKEN_INTERFACE_NAME        L"name="
#define TOKEN_ADMINSTATE            L"admstate="

#define TOKEN_WANPROTOCOL           L"wanprotocol="
#define TOKEN_ADVERTISE             L"advertise="
#define TOKEN_LISTEN                L"listen="
#define TOKEN_GNSREPLY              L"gnsreply="
#define TOKEN_UPDATEMODE            L"updatemode="
#define TOKEN_INTERVAL              L"interval="
#define TOKEN_AGEMULTIPLIER         L"agemultiplier="

#define TOKEN_BCASTACCEPT           L"bcastaccept="
#define TOKEN_BCASTDELIVER          L"bcastdeliver="

#define TOKEN_NEXTHOPMACADDRESS     L"nexthopmacaddress="
#define TOKEN_TICKS                 L"ticks="
#define TOKEN_HOPS                  L"hops="
#define TOKEN_NETWORK               L"network="
#define TOKEN_NODE                  L"node="
#define TOKEN_SOCKET                L"socket="
#define TOKEN_SRCNET                L"srcnet="
#define TOKEN_SRCNODE               L"srcnode="
#define TOKEN_SRCSOCKET             L"srcsocket="
#define TOKEN_DSTNET                L"dstnet="
#define TOKEN_DSTNODE               L"dstnode="
#define TOKEN_DSTSOCKET             L"dstsocket="
#define TOKEN_PKTTYPE               L"pkttype="
#define TOKEN_LOGPACKETS            L"log"

#define TOKEN_IPXGLOBAL             L"global"
#define TOKEN_LOGLEVEL              L"loglevel="


//
// Option value strings
//

#define VAL_ENABLED                 L"Enabled"
#define VAL_DISABLED                L"Disabled"

#define VAL_STANDARD                L"Standard"
#define VAL_NONE                    L"None"
#define VAL_AUTOSTATIC              L"Autostatic"
#define VAL_STATICONLY              L"StaticOnly"
#define VAL_ONLYWHENUP              L"OnlyWhenUp"

#define VAL_PERMIT                  L"Permit"
#define VAL_DENY                    L"Deny"

#define VAL_INPUT                   L"Input"
#define VAL_OUTPUT                  L"Output"

#define VAL_NULLFILTER              L"NULL"

#define VAL_UP                      L"Up"
#define VAL_DOWN                    L"Down"

#define VAL_SLEEPING                L"Sleeping"

#define VAL_CLIENT                  L"Client"
#define VAL_DEDICATED               L"Dedicated"
#define VAL_WANROUTER               L"Demand Dial"
#define VAL_INTERNAL                L"Internal"
#define VAL_HOMEROUTER              L"Demand Dial"

#define VAL_DIALOUT                 L"Dial-Out"

#define VAL_OTHER                   L"Other"

#define VAL_LOCAL                   L"Local"
#define VAL_STATIC                  L"Static"
#define VAL_RIP                     L"RIP"
#define VAL_SAP                     L"SAP"
#define VAL_PPP                     L"PPP"

#define VAL_IPXWAN                  L"IPXWAN"

#define VAL_DIALINCLIENT            L"Dial-in"

#define VAL_ANYNAME                 L"*"

#define VAL_ANYNETWORK              L"xxxxxxxx"
#define VAL_ANYNODE                 L"xxxxxxxxxxxx"
#define VAL_ANYSOCKET               L"xxxx"
#define VAL_ANYPKTTYPE              L"xx"

#define VAL_YES                     L"Yes"
#define VAL_NO                      L"No"

#define VAL_ERRORS_ONLY             L"Errors_Only"
#define VAL_ERRORS_AND_WARNINGS     L"Warnings_And_Errors"
#define VAL_MAXINFO                 L"Maximum_Information"
#define VAL_NA                      L"N/A"


//
// Command strings
//

#define CMD_GROUP_ADD               L"add"
#define CMD_GROUP_DELETE            L"delete"
#define CMD_GROUP_SET               L"set"
#define CMD_GROUP_SHOW              L"show"

#define CMD_IPX_DUMP                L"dump"
#define CMD_IPX_HELP1               L"?"
#define CMD_IPX_HELP2               L"help"
#define CMD_IPX_UPDATE              L"update"

#define CMD_IPX_ADD_ROUTE           L"staticroute"
#define CMD_IPX_ADD_SERVICE         L"staticservice"
#define CMD_IPX_ADD_FILTER          L"filter"
#define CMD_IPX_ADD_INTERFACE       L"interface"
#define CMD_IPX_ADD_HELPER          L"helper"

#define CMD_IPX_DELETE_ROUTE        L"staticroute"
#define CMD_IPX_DELETE_SERVICE      L"staticservice"
#define CMD_IPX_DELETE_FILTER       L"filter"
#define CMD_IPX_DELETE_INTERFACE    L"interface"
#define CMD_IPX_DELETE_HELPER       L"helper"

#define CMD_IPX_SET_ROUTE           L"staticroute"
#define CMD_IPX_SET_SERVICE         L"staticservice"
#define CMD_IPX_SET_FILTER          L"filter"
#define CMD_IPX_SET_INTERFACE       L"interface"
#define CMD_IPX_SET_GLOBAL          L"global"

#define CMD_IPX_SHOW_ROUTE          L"staticroute"
#define CMD_IPX_SHOW_SERVICE        L"staticservice"
#define CMD_IPX_SHOW_FILTER         L"filter"
#define CMD_IPX_SHOW_INTERFACE      L"interface"
#define CMD_IPX_SHOW_GLOBAL         L"global"
#define CMD_IPX_SHOW_ROUTETABLE     L"route"
#define CMD_IPX_SHOW_SERVICETABLE   L"service"
    

//
// IPX DMP Commands
//

#define DMP_IPX_HEADER              L"\
\npushd routing ipx"

#define DMP_IPX_FOOTER              L"\
\n\npopd"

#define DMP_IPX_SET_GLOBAL          L"\
\nset global loglevel=%1!s!"


//
// Dump interface
//

#define DMP_IPX_ADD_INTERFACE       L"\
\nadd interface \"%1!s!\""

#define DMP_IPX_SET_INTERFACE   L"\
\nset interface \"%1!s!\" admstate=%2!s!"

#define DMP_IPX_SET_WAN_INTERFACE   L"\
\nset interface \"%1!s!\" admstate=%2!s! wanprotocol=%3!s!"

#define DMP_IPX_DEL_INTERFACE       L"\
\ndelete interface \"%1!s!\""


//
// dump filters
//

#define DMP_IPX_ADD_FILTER          L"\
\nadd filter %1!s!"

#define DMP_IPX_SET_FILTER          L"\
\nset filter \"%1!s!\" %2!s! %3!s!"


//
// dump static routes
//

#define DMP_IPX_ADD_STATIC_ROUTE    L"\
\nadd staticroute \"%1!s!\" 0x%2!.2x!%3!.2x!%4!.2x!%5!.2x! \
nexthopmacaddress = 0x%6!.2x!%7!.2x!%8!.2x!%9!.2x!%10!.2x!%11!.2x! ticks = %12!3.3d! \
hops = %13!2.3d!"
             
//
// dump static services
//

#define DMP_IPX_ADD_STATIC_SERVICE  L"\
\nadd staticservice \"%1!s!\" %2!.4x! %3!s! network = 0x%4!.2x!%5!.2x!%6!.2x!%7!.2x! \
node = 0x%8!.2x!%9!.2x!%10!.2x!%11!.2x!%12!.2x!%13!.2x! socket = 0x%14!.2x!%15!.2x! hops = %16!d!"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ipx\ipxmon\ipxifs.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    ipxifs.c

Abstract:

    IPX Router Console Monitoring and Configuration tool.
    IPX Interface configuration and monitoring.

Author:

    Vadim Eydelman  06/07/1996


--*/

#include "precomp.h"
#pragma hdrstop

DWORD
MIBGetIpxIf(
    PWCHAR      InterfaceNameA
    );


DWORD
CfgGetIpxIf(
    LPWSTR      InterfaceNameW
    );


DWORD
MIBEnumIpxIfs(
    BOOL bDump
    );


DWORD
CfgEnumIpxIfs(
    BOOL bDump
    );


DWORD
CfgSetIpxIf(
    LPWSTR          InterfaceNameW,
    PULONG          pAdminState     OPTIONAL,
    PULONG          pWANProtocol    OPTIONAL
    );


DWORD
AdmSetIpxIf(
    LPWSTR          InterfaceNameW,
    PULONG          pAdminState     OPTIONAL,
    PULONG          pWANProtocol    OPTIONAL
    );

DWORD
GetIpxClientIf(
    PWCHAR          InterfaceNameW,
    UINT            msg,
    BOOL            bDump
    );

DWORD
CfgGetFltNames(
    LPWSTR          InterfaceNameW,
    LPWSTR         *FltInNameW,
    LPWSTR         *FltOutNameW
    );

PIPX_IF_INFO 
GetIpxNbInterface(
    HANDLE          hIf, 
    LPBYTE          *pIfBlock,
    PIPXWAN_IF_INFO *ppIfWanBlock
    );

    

DWORD
APIENTRY 
HelpIpxIf(
    IN      DWORD       argc,
    IN      LPCWSTR    *argv
    )
/*++

Routine Description :

    This function displays help for NETSH IPX interface commands
    
Arguments :

    argc - Number of arguments

    argv - Argument array

Return value :

    0   - success
    
--*/
{
    DisplayIPXMessage (g_hModule, MSG_IPX_HELP_IPXIF );
    return 0;
}



DWORD
APIENTRY 
ShowIpxIf (
    IN      DWORD       argc,
    IN      LPCWSTR    *argv,
    IN      BOOL        bDump
    )
/*++

Routine Description :

    This routine displays IPX interface information
    
Arguments :

    argc - Number of arguments

    argv - Argument array

Return value :

    
--*/
{
    DWORD   rc;
    PWCHAR  buffer = NULL;    


    //
    // if interface name specified
    //
    
    if ( argc < 1 )
    {
        PWCHAR buffer;
        
        if ( g_hMIBServer )
        {
            //
            // enumerate and display the interface via the MIB server
            //
            
            rc = MIBEnumIpxIfs ( bDump );
            
            if ( rc == NO_ERROR )
            {
                //
                // Display RAs server interface IPX info. 
                //
                
                rc = GetIpxClientIf(
                        VAL_DIALINCLIENT, MSG_CLIENT_IPXIF_MIB_TABLE_FMT,
                        bDump
                        );
            }
            else 
            {
                //
                // Router not running ?  Fallback to  router config
                //
                
                DisplayIPXMessage (g_hModule, MSG_REGISTRY_FALLBACK );
                
                goto EnumerateThroughCfg;
            }
        }
        
        else 
        {
        
EnumerateThroughCfg:

            //
            // enumerate and display the interface via the router config
            //
            
            rc = CfgEnumIpxIfs ( bDump );
            
            if ( rc == NO_ERROR )
            {
                //
                // Display RAs server interface IPX info. 
                //
                
                rc = GetIpxClientIf(
                        VAL_DIALINCLIENT, MSG_CLIENT_IPXIF_CFG_TABLE_FMT,
                        bDump
                        );
            }
        }

    }
    
    else 
    {
        //
        // Display IPX info for a specific interface
        //
        
        WCHAR       InterfaceName[ MAX_INTERFACE_NAME_LEN + 1 ];
        DWORD       dwSize = sizeof(InterfaceName);


        if ( !_wcsicmp( argv[0], VAL_DIALINCLIENT ) )
        {
            //
            // Display RAs server interface IPX info. 
            //

            rc = GetIpxClientIf( VAL_DIALINCLIENT, MSG_CLIENT_IPXIF_CFG_SCREEN_FMT, bDump );
        }
        
        else if ( g_hMIBServer) 
        {
            //======================================
            // Translate the Interface name
            //======================================
            
            rc = IpmontrGetIfNameFromFriendlyName(
                    argv[ 0 ], InterfaceName, &dwSize
                    );

            if ( rc != NO_ERROR )
            {
                DisplayError( g_hModule, rc );
            }

            else
            {
                rc = MIBGetIpxIf ( InterfaceName );
            
                if ( rc != NO_ERROR )
                {
                    goto GetIfFromCfg;
                }
            }
        }
        else 
        {
        
GetIfFromCfg:
            //======================================
            // Translate the Interface Name

            //======================================
            
            rc = IpmontrGetIfNameFromFriendlyName(
                    argv[ 0 ], InterfaceName, &dwSize
                    );
                    
            if ( rc != NO_ERROR )
            {
                DisplayError( g_hModule, rc );
            }

            else
            {
                rc = CfgGetIpxIf ( InterfaceName );
            }
        }
    }

    return rc;
}


DWORD
APIENTRY 
SetIpxIf(
    IN      DWORD       argc,
    IN      LPCWSTR    *argv
    )
/*++

Routine Description :

    This routine update the IPX settings for an interface.
    
Arguments :

    argc - Number of arguments

    argv - Argument array

Return value :


--*/
{
    DWORD       rc;
    PWCHAR      buffer = NULL;
    WCHAR       InterfaceName[ MAX_INTERFACE_NAME_LEN + 1 ];
    DWORD       dwSize = sizeof(InterfaceName);


    //
    // If interface name is specified
    //
    
    if ( argc >= 1 ) 
    {
        unsigned    count;
        BOOLEAN     client = FALSE;


        //
        // Check if the dial in interface is specified
        //
        
        if ( !_wcsicmp( argv[0], VAL_DIALINCLIENT ) )
        {
            client = TRUE;
        }
        
        else
        {
            count = wcslen( argv[ 0 ] );
        }

        if ( client || 
             ( ( count > 0 ) && ( count <= MAX_INTERFACE_NAME_LEN ) ) )
        {
            DWORD   i;
            ULONG   adminState, WANProtocol;
            PULONG  pAdminState = NULL, pWANProtocol = NULL;
            LPBYTE  pFltInBlock, pFltOutBlock;

            for ( i = 1; i < argc; i++ )
            {
                //
                // get admin state value if specified
                //
                
                if ( !_wcsicmp( argv[ i ], TOKEN_ADMINSTATE ) )
                {
                    if ( ( pAdminState == NULL ) && ( i < argc - 1 ) && 
                         !MatchEnumTag(
                            g_hModule, argv[ i + 1 ], 
                            NUM_TOKENS_IN_TABLE( AdminStates ), 
                            AdminStates, &adminState
                            ) )
                    {
                        i += 1;
                        pAdminState = &adminState;
                    }
                    
                    else
                    {
                        break;
                    }
                }


                //
                // get WAN protocol value if specified
                //
                
                else if ( !_wcsicmp( argv[ i ], TOKEN_WANPROTOCOL ) )
                {
                    if ( ( pWANProtocol == NULL ) && ( i < argc - 1 ) && 
                         !MatchEnumTag( 
                            g_hModule, argv[ i + 1 ],
                            NUM_TOKENS_IN_TABLE( WANProtocols ), 
                            WANProtocols, &WANProtocol
                            ) )
                    {
                        i += 1;
                        pWANProtocol = &WANProtocol;
                    }
                    
                    else
                    {
                        break;
                    }
                }


                //
                // Not a tag.  if Adminstate not specified then the first
                // option is Admin State
                //
                
                else if ( pAdminState == NULL )
                {
                    if ( !MatchEnumTag(
                            g_hModule, argv[ i ], 
                            NUM_TOKENS_IN_TABLE( AdminStates ), 
                            AdminStates, &adminState
                            ) )
                    {
                        pAdminState = &adminState;
                    }
                    
                    else
                    {
                        break;
                    }
                }

                //
                // Try WAN protocol last
                //
                
                else if ( pWANProtocol == NULL )
                {
                    if ( !MatchEnumTag(
                            g_hModule, argv[ i ],
                            NUM_TOKENS_IN_TABLE( AdminStates ), 
                            WANProtocols, &WANProtocol
                            ) )
                    {
                        pWANProtocol = &WANProtocol;
                    }
                    
                    else
                    {
                        break;
                    }
                }

                //
                // If none of these, quit
                //
                
                else
                {
                    break;
                }
            }


            if ( i == argc )
            {
                if ( !client )
                {
                    DWORD rc2;
                    
                    //======================================
                    // Translate the Interface Name
                    //======================================
                    
                    rc = IpmontrGetIfNameFromFriendlyName(
                            argv[ 0 ], InterfaceName, &dwSize 
                            );

                    if ( rc == NO_ERROR )
                    {
                        //
                        // Set to router config
                        //
                        
                        rc2 = CfgSetIpxIf( 
                                InterfaceName, pAdminState, pWANProtocol 
                                );
                                
                        if ( rc2 == NO_ERROR )
                        {
                            DisplayIPXMessage (g_hModule, MSG_IPXIF_SET_CFG, argv[0] );

                            //
                            // set to router service
                            //
                            
                            if ( g_hMprAdmin )
                            {
                                rc = AdmSetIpxIf( 
                                        InterfaceName, pAdminState, pWANProtocol
                                        );

                                if ( rc == NO_ERROR )
                                {
                                    DisplayIPXMessage (g_hModule, MSG_IPXIF_SET_ADM, argv[0] );
                                }
                            }
                        }
                        
                        else
                        {
                            rc = rc2;
                        }
                    }
                }
                
                else
                {
                    //
                    // set to router config and then to router service
                    //
                    
                    if ( ( rc = CfgSetIpxIf( NULL, pAdminState, pWANProtocol ) )
                            == NO_ERROR ) 
                    {
                        DisplayIPXMessage (g_hModule, MSG_CLIENT_IPXIF_SET_CFG );
                        
                        if ( g_hMprAdmin )
                        {
                            rc = AdmSetIpxIf(
                                    NULL, pAdminState, pWANProtocol
                                    );

                            if ( rc == NO_ERROR )
                            {
                                DisplayIPXMessage (g_hModule, MSG_CLIENT_IPXIF_SET_ADM );
                            }
                        }
                    }
                }
            }
            
            else 
            {
                DisplayIPXMessage (g_hModule, MSG_IPX_HELP_IPXIF );
                rc = ERROR_INVALID_PARAMETER;
            }
        }
        
        else
        {
            DisplayIPXMessage (g_hModule, MSG_INVALID_INTERFACE_NAME );
            rc = ERROR_INVALID_PARAMETER;
        }
    }
    
    else 
    {
        DisplayIPXMessage (g_hModule, MSG_IPX_HELP_IPXIF );
        rc = ERROR_INVALID_PARAMETER;
    }

    if ( buffer )
    {
        FreeString( buffer );
    }
    
    return rc;
}




DWORD
APIENTRY 
InstallIpx(
    IN      DWORD       argc,
    IN      LPCWSTR    *argv
    )
/*++

Routine Description :

    This routine adds IPX interface configuration to an interface
    
Arguments :

    argc - Number of arguments

    argv - Argument array

Return value :

--*/

{
    DWORD        rc;

    if ( argc >= 1 )
    {
        WCHAR    InterfaceName[ MAX_INTERFACE_NAME_LEN + 1 ];
        unsigned count = sizeof(InterfaceName);
        

        //
        // Get If name
        //
        
        rc = IpmontrGetIfNameFromFriendlyName( argv[ 0 ], InterfaceName, &count );

        if ( rc != NO_ERROR )
        {
            count = 0;
        }
        
        if ( ( count > 0 ) && 
             ( count <= (MAX_INTERFACE_NAME_LEN+1)*sizeof(WCHAR) ) )
        {
            //
            // default interface info consists of 
            //  - IPX_IF_INFO
            //  - IPXWAN_IF_INFO
            //  - IPX_ADAPTER_INFO
            //  - RIP_IF_CONFIG
            //  - SAP_IF_CONFIG
            //
            
            LPBYTE block;
            ULONG  blockSize = 
                    FIELD_OFFSET (IPX_INFO_BLOCK_HEADER, TocEntry)
                    + sizeof (IPX_TOC_ENTRY)*5
                    + sizeof (IPX_IF_INFO)
                    + sizeof (IPXWAN_IF_INFO)
                    + sizeof (IPX_ADAPTER_INFO)
                    + FIELD_OFFSET (RIP_IF_CONFIG, RipIfFilters.RouteFilter)
                    + FIELD_OFFSET (SAP_IF_CONFIG, SapIfFilters.ServiceFilter);


            block = (LPBYTE) GlobalAlloc( GPTR, blockSize );
            
            if ( block != NULL )
            {
                HANDLE                  hIfCfg;
                PIPX_INFO_BLOCK_HEADER  hdr = (PIPX_INFO_BLOCK_HEADER)block;
                PIPX_IF_INFO            ipx = (PIPX_IF_INFO)&hdr->TocEntry[5];
                PIPXWAN_IF_INFO         wan = (PIPXWAN_IF_INFO)&ipx[1];
                PIPX_ADAPTER_INFO       adp = (PIPX_ADAPTER_INFO)&wan[1];
                PRIP_IF_CONFIG          rip = (PRIP_IF_CONFIG)&adp[1];
                PSAP_IF_CONFIG          sap = 
                    (PSAP_IF_CONFIG)&rip->RipIfFilters.RouteFilter;


                //
                // build infoblock for IPX interface info, with default values
                //
                
                hdr->Version = IPX_ROUTER_VERSION_1;
                hdr->Size = blockSize;
                hdr->TocEntriesCount = 5;

                hdr->TocEntry[0].InfoType = IPX_INTERFACE_INFO_TYPE;
                hdr->TocEntry[0].InfoSize = sizeof (IPX_IF_INFO);
                hdr->TocEntry[0].Count = 1;
                hdr->TocEntry[0].Offset = (ULONG) ((LPBYTE)ipx-block);
                ipx->AdminState = ADMIN_STATE_ENABLED;
                ipx->NetbiosAccept = ADMIN_STATE_DISABLED;
                ipx->NetbiosDeliver = ADMIN_STATE_DISABLED;

                hdr->TocEntry[1].InfoType = IPXWAN_INTERFACE_INFO_TYPE;
                hdr->TocEntry[1].InfoSize = sizeof (IPXWAN_IF_INFO);
                hdr->TocEntry[1].Count = 1;
                hdr->TocEntry[1].Offset = (ULONG) ((LPBYTE)wan-block);
                wan->AdminState = ADMIN_STATE_DISABLED;

                hdr->TocEntry[2].InfoType = IPX_ADAPTER_INFO_TYPE;
                hdr->TocEntry[2].InfoSize = sizeof (IPX_ADAPTER_INFO);
                hdr->TocEntry[2].Count = 1;
                hdr->TocEntry[2].Offset = (ULONG) ((LPBYTE)adp-block);
                adp->PacketType = AUTO_DETECT_PACKET_TYPE;
                adp->AdapterName[0] = 0;

                hdr->TocEntry[3].InfoType = IPX_PROTOCOL_RIP;
                hdr->TocEntry[3].InfoSize = FIELD_OFFSET (RIP_IF_CONFIG, RipIfFilters.RouteFilter);
                hdr->TocEntry[3].Count = 1;
                hdr->TocEntry[3].Offset = (ULONG) ((LPBYTE)rip-block);
                rip->RipIfInfo.AdminState = ADMIN_STATE_ENABLED;
                rip->RipIfInfo.UpdateMode = IPX_NO_UPDATE;
                rip->RipIfInfo.PacketType = IPX_STANDARD_PACKET_TYPE;
                rip->RipIfInfo.Supply = ADMIN_STATE_ENABLED;
                rip->RipIfInfo.Listen = ADMIN_STATE_ENABLED;
                rip->RipIfInfo.PeriodicUpdateInterval = 0;
                rip->RipIfInfo.AgeIntervalMultiplier = 0;
                rip->RipIfFilters.SupplyFilterCount = 0;
                rip->RipIfFilters.SupplyFilterAction = IPX_ROUTE_FILTER_DENY;
                rip->RipIfFilters.ListenFilterCount = 0;
                rip->RipIfFilters.ListenFilterAction = IPX_ROUTE_FILTER_DENY;

                hdr->TocEntry[4].InfoType = IPX_PROTOCOL_SAP;
                hdr->TocEntry[4].InfoSize = FIELD_OFFSET (SAP_IF_CONFIG, SapIfFilters.ServiceFilter);
                hdr->TocEntry[4].Count = 1;
                hdr->TocEntry[4].Offset = (ULONG) ((LPBYTE)sap-block);
                sap->SapIfInfo.AdminState = ADMIN_STATE_ENABLED;
                sap->SapIfInfo.UpdateMode = IPX_NO_UPDATE;
                sap->SapIfInfo.PacketType = IPX_STANDARD_PACKET_TYPE;
                sap->SapIfInfo.Supply = ADMIN_STATE_ENABLED;
                sap->SapIfInfo.Listen = ADMIN_STATE_ENABLED;
                sap->SapIfInfo.GetNearestServerReply = ADMIN_STATE_ENABLED;
                sap->SapIfInfo.PeriodicUpdateInterval = 0;
                sap->SapIfInfo.AgeIntervalMultiplier = 0;
                sap->SapIfFilters.SupplyFilterCount = 0;
                sap->SapIfFilters.SupplyFilterAction = IPX_SERVICE_FILTER_DENY;
                sap->SapIfFilters.ListenFilterCount = 0;
                sap->SapIfFilters.ListenFilterAction = IPX_SERVICE_FILTER_DENY;


                //
                // Get handle to interface config
                //
                
                rc = MprConfigInterfaceGetHandle(
                        g_hMprConfig, InterfaceName, &hIfCfg
                        );
                        
                if ( rc == NO_ERROR )
                {
                    PMPR_INTERFACE_0    pRi0;
                    DWORD                sz;

                    //
                    // retrieve interface info from handle
                    //
                    
                    rc = MprConfigInterfaceGetInfo(
                            g_hMprConfig, hIfCfg, 0, (LPBYTE *)&pRi0, &sz
                            );
                            
                    if ( rc == NO_ERROR )
                    {
                        //
                        // IPX is always present on LAN interfaces.  It can
                        // only be added to WAN interfaces
                        //
                        
                        if ( pRi0->dwIfType == ROUTER_IF_TYPE_FULL_ROUTER )
                        {
                            HANDLE    hIfTrCfg;

                            //
                            // Add IPX to interface config
                            //
                            
                            rc = MprConfigInterfaceTransportAdd (
                                    g_hMprConfig,
                                    hIfCfg,
                                    PID_IPX,
                                    NULL,
                                    block, blockSize,
                                    &hIfTrCfg
                                    );
                                    
                            if ( rc == NO_ERROR )
                            {
                                DisplayIPXMessage(
                                    g_hModule, MSG_IPXIF_ADD_CFG, InterfaceName
                                    );
                                    
                                if ( g_hMprAdmin )
                                {
                                    HANDLE hIfAdm;

                                    //
                                    // Router service is up.  DO the same
                                    // for it
                                    //
                                    
                                    rc = MprAdminInterfaceGetHandle(
                                            g_hMprAdmin, InterfaceName, 
                                            &hIfAdm, FALSE
                                            );
                                            
                                    if ( rc == NO_ERROR )
                                    {
                                        rc = MprAdminInterfaceTransportAdd(
                                                g_hMprAdmin,
                                                hIfAdm,
                                                PID_IPX,
                                                block, blockSize
                                                );
                                                
                                        if ( rc == NO_ERROR )
                                        {
                                            DisplayIPXMessage(
                                                g_hModule,
                                                MSG_IPXIF_ADD_ADM,
                                                InterfaceName
                                                );
                                        }
                                        
                                        else
                                        {
                                            DisplayError( g_hModule, rc );
                                        }
                                    }
                                    
                                    else
                                    {
                                        DisplayError( g_hModule, rc );
                                    }
                                }
                            }
                            else
                            {
                                DisplayError( g_hModule, rc );
                            }
                        }
                        else 
                        {
                            DisplayIPXMessage (g_hModule, MSG_IPXIF_NOT_ROUTER );
                            rc = ERROR_INVALID_PARAMETER;
                        }
                        
                        MprConfigBufferFree( pRi0 );
                    }
                    else
                    {
                        DisplayError( g_hModule, rc );
                    }
                }
                
                else 
                if ( ( rc == ERROR_FILE_NOT_FOUND ) ||
                     ( rc == ERROR_NO_MORE_ITEMS ) )
                {
                    DisplayError( g_hModule, ERROR_NO_SUCH_INTERFACE);
                }
                else
                {
                    DisplayError( g_hModule, rc );
                }
                GlobalFree (block);
            }
            
            else 
            {
                rc = GetLastError ();

                if (rc != NO_ERROR )
                {
                    rc = ERROR_NOT_ENOUGH_MEMORY;
                }
                
                DisplayError( g_hModule, rc );
            }
        }
        else 
        {
            DisplayIPXMessage (g_hModule, MSG_INVALID_INTERFACE_NAME );
            rc = ERROR_INVALID_PARAMETER;
        }
    }
    else 
    {
        DisplayIPXMessage (g_hModule, MSG_IPX_HELP_IPXIF );
        rc = ERROR_INVALID_PARAMETER;
    }
    
    return rc;
}

DWORD
APIENTRY 
RemoveIpx(
    IN      DWORD       argc,
    IN      LPCWSTR    *argv
    )
/*++

Routine Description :

    This routine removes IPX from a demand dial interface

    
Arguments :

    argc - Number of arguments

    argv - Argument array


Return value :

--*/

{
    DWORD        rc;

    if ( argc >= 1 )
    {
        WCHAR    InterfaceName[ MAX_INTERFACE_NAME_LEN + 1 ];
        unsigned count = sizeof(InterfaceName);
        

        //
        // Get interface name
        //
        
        rc = IpmontrGetIfNameFromFriendlyName( argv[ 0 ], InterfaceName, &count );

        if ( rc != NO_ERROR )
        {
            count = 0;
        }

        
        if ( ( count > 0 ) && 
             ( count <= (MAX_INTERFACE_NAME_LEN+1)*sizeof(WCHAR) ) )
        {
            //
            // remove IPX from demand-dial interface config
            //
            
            HANDLE  hIfCfg;
            
            rc = MprConfigInterfaceGetHandle(
                    g_hMprConfig, InterfaceName, &hIfCfg
                    );
                    
            if ( rc == NO_ERROR )
            {
                PMPR_INTERFACE_0    pRi0;
                DWORD                sz;

                rc = MprConfigInterfaceGetInfo(
                        g_hMprConfig,
                        hIfCfg,
                        0,
                        (LPBYTE *)&pRi0,
                        &sz
                        );
                        
                if ( rc == NO_ERROR )
                {
                    if ( pRi0->dwIfType == ROUTER_IF_TYPE_FULL_ROUTER )
                    {
                        HANDLE    hIfTrCfg;
                        
                        rc = MprConfigInterfaceTransportGetHandle(
                                g_hMprConfig,
                                hIfCfg,
                                PID_IPX,
                                &hIfTrCfg 
                                );
                                
                        if ( rc == NO_ERROR )
                        {
                            rc = MprConfigInterfaceTransportRemove(
                                    g_hMprConfig,
                                    hIfCfg,
                                    hIfTrCfg
                                    );
                                    
                            if ( rc == NO_ERROR )
                            {
                                DisplayIPXMessage(
                                    g_hModule, MSG_IPXIF_DEL_CFG, InterfaceName
                                    );
                                    
                                if ( g_hMprAdmin )
                                {
                                    //
                                    // remove IPX from demand-dial interface 
                                    // in the router service
                                    //
            
                                    HANDLE hIfAdm;
                                    rc = MprAdminInterfaceGetHandle(
                                            g_hMprAdmin, InterfaceName, 
                                            &hIfAdm, FALSE
                                            );
                                            
                                    if ( rc == NO_ERROR )
                                    {
                                        rc = MprAdminInterfaceTransportRemove(
                                                g_hMprAdmin, hIfAdm, PID_IPX
                                                );
                                                
                                        if ( rc == NO_ERROR )
                                        {
                                            DisplayIPXMessage(
                                                g_hModule, MSG_IPXIF_DEL_ADM, 
                                                InterfaceName
                                                );
                                        }
                                        else
                                        {
                                            DisplayError( g_hModule, rc);
                                        }
                                    }
                                    else if ( ( rc == ERROR_FILE_NOT_FOUND ) || 
                                              ( rc == ERROR_NO_MORE_ITEMS ) )
                                    {
                                        DisplayIPXMessage( 
                                            g_hModule, 
                                            MSG_NO_IPX_ON_INTERFACE_ADM 
                                            );
                                    }
                                    else
                                    {
                                        DisplayError( g_hModule, rc );
                                    }
                                }
                            }
                            
                            else
                            {
                                DisplayError( g_hModule, rc );
                            }
                        }
                        
                        else 
                        if ( ( rc == ERROR_FILE_NOT_FOUND ) || 
                             ( rc == ERROR_NO_MORE_ITEMS ) )
                        {
                            DisplayIPXMessage (g_hModule, MSG_NO_IPX_ON_INTERFACE_CFG );
                        }
                        else
                        {
                            DisplayError( g_hModule, rc);
                        }
                    }
                    
                    else 
                    {
                        DisplayIPXMessage ( g_hModule, MSG_IPXIF_NOT_ROUTER );
                        
                        rc = ERROR_INVALID_PARAMETER;
                    }
                    
                    MprConfigBufferFree( pRi0 );
                }
                else
                {
                    DisplayError( g_hModule, rc);
                }
            }
            else if ( ( rc == ERROR_FILE_NOT_FOUND ) ||
                      ( rc == ERROR_NO_MORE_ITEMS ) )
            {
                DisplayError( g_hModule, ERROR_NO_SUCH_INTERFACE );
            }
            else
            {
                DisplayError( g_hModule, rc);
            }
        }
        else 
        {
            DisplayIPXMessage (g_hModule, MSG_INVALID_INTERFACE_NAME );
            rc = ERROR_INVALID_PARAMETER;
        }
    }
    else
    {
        DisplayIPXMessage (g_hModule, MSG_IPX_HELP_IPXIF );
        rc = ERROR_INVALID_PARAMETER;
    }
    
    return rc;
}



PIPX_IF_INFO 
GetIpxInterface(
    HANDLE hIf, 
    LPBYTE *pIfBlock
    )
/*++

Routine Description :

    This routine retrieves the IPX_INTERFACE_INFO_TYPE block in the
    interface configuration.  The interface conf. is retrieved from 
    the router.
    
Arguments :

    hIf - Handle to the interface config.

    pIfBlock - Buffer to return requested info.
    
Return value :

--*/

{
    DWORD dwSize;
    DWORD dwErr;
    PIPX_TOC_ENTRY pIpxToc;
    
    dwErr = MprAdminInterfaceTransportGetInfo(
                g_hMprAdmin, hIf, PID_IPX, pIfBlock, &dwSize
                );

    if ( dwErr != NO_ERROR )
    {
        return NULL;
    }

    pIpxToc = GetIPXTocEntry (
                (PIPX_INFO_BLOCK_HEADER)( *pIfBlock ),
                IPX_INTERFACE_INFO_TYPE
                );
                
    if ( !pIpxToc )
    {
        return NULL;
    }
    
    return (PIPX_IF_INFO)( ( *pIfBlock ) + ( pIpxToc->Offset ) );
}


BOOL 
IsIpxInterface(
    HANDLE hIf, 
    LPDWORD lpdwEnabled
    )
/*++

Routine Description :

    This routine checks if the specified interface is enabled for IPX 
    on the router.  
    
Arguments :

    hIf - Handle to the interface config. 

    lpdwEnabled - On return contains the admin state.
    
Return value :

    
--*/
{
    PIPX_INTERFACE            pIf;
    DWORD dwSize;
    DWORD dwErr;
    BOOL ret;
    
    dwErr = MprAdminInterfaceTransportGetInfo(
                g_hMprAdmin, hIf, PID_IPX, (LPBYTE*)&pIf, &dwSize
                );

    if ( dwErr == NO_ERROR )
    {
        ret = TRUE;
        
        if ( lpdwEnabled )
        {
            *lpdwEnabled = pIf->AdminState;
        }
    }
    
    else
    {
        ret = FALSE;
    }
    
    MprAdminBufferFree( (LPBYTE) pIf );

    return ret;
}


DWORD
MIBGetIpxIf (
    PWCHAR      InterfaceName
    ) 
/*++

Routine Description :

    This routine retrives the interface configuration for the specified
    interface from the router.

    
Arguments :

    InterfaceName - Name of interface for which config is requested.
    

Return value :

--*/
{
    INT                     i;
    DWORD                   rc;
    DWORD                   sz;
    IPX_MIB_GET_INPUT_DATA  MibGetInputData;
    PIPX_INTERFACE          pIf;
    WCHAR                   IfDisplayName[ MAX_INTERFACE_NAME_LEN + 1 ];
    

    MibGetInputData.TableId = IPX_INTERFACE_TABLE;
    
    rc = GetIpxInterfaceIndex(
            g_hMIBServer, InterfaceName,
            &MibGetInputData.MibIndex.InterfaceTableIndex.InterfaceIndex
            );
            
    if ( rc == NO_ERROR )
    {
        rc = MprAdminMIBEntryGet(
                g_hMIBServer, PID_IPX, IPX_PROTOCOL_BASE, &MibGetInputData,
                sizeof( IPX_MIB_GET_INPUT_DATA ), (LPVOID *)&pIf, &sz
                );
                
        if ( rc == NO_ERROR && pIf)
        {
            PWCHAR buffer[4];
            
            //======================================
            // Translate the Interface Name
            //======================================
            sz = sizeof(IfDisplayName);
            
            rc = IpmontrGetFriendlyNameFromIfName(
                    InterfaceName, IfDisplayName, &sz
                    );

            if ( rc == NO_ERROR )
            {
                buffer[ 0 ] = GetEnumString( 
                                g_hModule, pIf->InterfaceType, 
                                NUM_VALUES_IN_TABLE( IpxInterfaceTypes ),
                                IpxInterfaceTypes 
                              );

                buffer[ 1 ] = ( pIf-> InterfaceType == IF_TYPE_LAN ) || 
                              ( pIf-> InterfaceType == IF_TYPE_INTERNAL ) ?
                              VAL_NA :
                              GetEnumString( 
                                g_hModule, pIf->EnableIpxWanNegotiation,
                                NUM_VALUES_IN_TABLE( WANProtocols ),
                                WANProtocols
                                );

                buffer[ 2 ] = GetEnumString(
                                g_hModule, pIf->AdminState, 
                                NUM_VALUES_IN_TABLE( AdminStates ),
                                AdminStates
                                );
                                
                buffer[ 3 ] = GetEnumString(
                                g_hModule, pIf->IfStats.IfOperState, 
                                NUM_VALUES_IN_TABLE( OperStates ),
                                OperStates
                                );

                if ( buffer[ 0 ] && buffer[ 1 ] && buffer[ 2 ] && buffer[ 3 ] )
                {
                    DisplayIPXMessage(
                        g_hModule, MSG_IPXIF_MIB_SCREEN_FMT, IfDisplayName,
                        buffer[ 0 ], buffer[ 1 ], buffer[ 2 ], buffer[3],
                        pIf->NetNumber[0], pIf->NetNumber[1],
                        pIf->NetNumber[2], pIf->NetNumber[3],
                        pIf->MacAddress[0], pIf->MacAddress[1],
                        pIf->MacAddress[2], pIf->MacAddress[3],
                        pIf->MacAddress[4], pIf->MacAddress[5],
                        pIf->IfStats.InHdrErrors,
                        pIf->IfStats.InFiltered,
                        pIf->IfStats.InNoRoutes, 
                        pIf->IfStats.InDiscards, 
                        pIf->IfStats.InDelivers, 
                        pIf->IfStats.OutFiltered,
                        pIf->IfStats.OutDiscards,
                        pIf->IfStats.OutDelivers
                        );
                }

                MprAdminMIBBufferFree (pIf);
            }

            else
            {
                DisplayError( g_hModule, rc );
            }

        }
        else
        {
            DisplayError( g_hModule, rc);
        }
    }
    else
    {
        DisplayError( g_hModule, rc);
    }
    
    return rc;
}


DWORD
CfgGetIpxIf(
    LPWSTR    InterfaceNameW
    ) 
/*++

Routine Description :

    This routine retrives the interface configuration for the specified
    interface from the router configuration.

    
Arguments :

    InterfaceName - Name of interface for which config is requested.
    

Return value :

--*/
{
    DWORD   rc, i;
    DWORD   sz;
    HANDLE  hIfCfg;
    WCHAR   IfDisplayName[ MAX_INTERFACE_NAME_LEN + 1 ];


    //
    // get handle to interface config
    //
    
    rc = MprConfigInterfaceGetHandle (
            g_hMprConfig, InterfaceNameW, &hIfCfg
            );
            
    if ( rc == NO_ERROR )
    {
        PMPR_INTERFACE_0    pRi0;

        
        rc = MprConfigInterfaceGetInfo(
                g_hMprConfig, hIfCfg, 0, (LPBYTE *)&pRi0, &sz
                );
                
        if ( rc == NO_ERROR )
        {
            HANDLE  hIfTrCfg;

            rc = MprConfigInterfaceTransportGetHandle(
                    g_hMprConfig, hIfCfg, PID_IPX,  &hIfTrCfg
                    );
                    
            if ( rc == NO_ERROR )
            {
                LPBYTE    pIfBlock;
                
                rc = MprConfigInterfaceTransportGetInfo (
                        g_hMprConfig, hIfCfg, hIfTrCfg, &pIfBlock, &sz
                        );
                        
                if (rc == NO_ERROR)
                {
                    PIPX_TOC_ENTRY pIpxToc;
                    PIPX_TOC_ENTRY pIpxWanToc;

                    pIpxToc = GetIPXTocEntry(
                                (PIPX_INFO_BLOCK_HEADER)pIfBlock, 
                                IPX_INTERFACE_INFO_TYPE
                                );

                    pIpxWanToc = GetIPXTocEntry(
                                    (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                                    IPXWAN_INTERFACE_INFO_TYPE
                                    );
                                    
                    if ( ( pIpxToc != NULL ) && ( pIpxWanToc != NULL ) )
                    {
                        PIPX_IF_INFO    pIpxInfo;
                        PIPXWAN_IF_INFO pIpxWanInfo;
                        PWCHAR           buffer[3];

                        pIpxInfo = (PIPX_IF_INFO)
                                (pIfBlock+pIpxToc->Offset);
                                
                        pIpxWanInfo = (PIPXWAN_IF_INFO)
                                (pIfBlock+pIpxWanToc->Offset);
                                
                        //======================================
                        // Translate the Interface Name
                        //======================================
                        sz = sizeof(IfDisplayName);
                        
                        rc = IpmontrGetFriendlyNameFromIfName(
                                InterfaceNameW, IfDisplayName, &sz
                                );

                        if ( rc == NO_ERROR )
                        {
                            buffer[ 0 ] = GetEnumString(
                                            g_hModule, pRi0->dwIfType,
                                            NUM_VALUES_IN_TABLE( RouterInterfaceTypes ),
                                            RouterInterfaceTypes
                                            );

                            buffer[ 1 ] = GetEnumString(
                                            g_hModule, pIpxInfo->AdminState,
                                            NUM_VALUES_IN_TABLE( AdminStates ),
                                            AdminStates
                                            );


                            buffer[ 2 ] = ( pRi0-> dwIfType == ROUTER_IF_TYPE_DEDICATED ) ?
                                          VAL_NA :
                                          GetEnumString( 
                                            g_hModule, pIpxWanInfo->AdminState,
                                            NUM_VALUES_IN_TABLE( WANProtocols ),
                                            WANProtocols
                                            );

                            if ( buffer[ 0 ] && buffer[ 1 ] && buffer[ 2 ] )
                            {
                                //======================================
                                DisplayIPXMessage (g_hModule,
                                    MSG_IPXIF_CFG_SCREEN_FMT, IfDisplayName,
                                    buffer[0], buffer[1], buffer[2]
                                    );
                            }
                         }
                    }
                    else 
                    {
                        DisplayIPXMessage (g_hModule, MSG_INTERFACE_INFO_CORRUPTED );
                        rc = ERROR_INVALID_DATA;
                    }
                }
                else 
                {
                    DisplayError( g_hModule, rc );
                }
                
                MprConfigBufferFree( pIfBlock );
            }
            
            else if ( ( rc == ERROR_FILE_NOT_FOUND ) || 
                      ( rc == ERROR_NO_MORE_ITEMS ) )
            {
                DisplayIPXMessage (g_hModule, MSG_NO_IPX_ON_INTERFACE_CFG );
            }
            else 
            {
                DisplayError( g_hModule, rc );
            }
            
            MprConfigBufferFree (pRi0);
        }
    }
    else if ( ( rc == ERROR_FILE_NOT_FOUND ) || 
              ( rc == ERROR_NO_MORE_ITEMS ) )
    {
        DisplayError( g_hModule, ERROR_NO_SUCH_INTERFACE );
    }
    else
    {
        DisplayError( g_hModule, rc );
    }
    
    return rc;
}


DWORD
GetIpxClientIf (
    PWCHAR  InterfaceName,
    UINT    msg,
    BOOL    bDump
    ) 
/*++

Routine Description :

    This routine retrives the interface configuration for the dialin
    interface from the router service/config as specified.

    
Arguments :

    InterfaceName - Name of interface for which config is requested.
    
    msg - Format of display output 
    

Return value :

--*/
{
    DWORD   rc, i;
    LPBYTE  pClBlock = NULL, pAdmClBlock = NULL;
    LPWSTR  FltInNameW = NULL, FltOutNameW = NULL;
    HANDLE  hTrCfg;


    rc = MprConfigTransportGetHandle( g_hMprConfig, PID_IPX, &hTrCfg );
    
    if ( rc == NO_ERROR )
    {
        DWORD    sz;

        rc = MprConfigTransportGetInfo( 
                g_hMprConfig, hTrCfg, NULL, NULL, &pClBlock, &sz, NULL
                );
                
        if ( rc == NO_ERROR )
        {
            PIPX_TOC_ENTRY pIpxToc;
            PIPX_TOC_ENTRY pIpxWanToc;

            if ( g_hMprAdmin ) 
            {
                DWORD   rc1;
                DWORD   sz;
                
                rc1 = MprAdminTransportGetInfo(
                        g_hMprAdmin, PID_IPX, NULL, NULL, &pAdmClBlock, &sz
                        );
                        
                if ( rc1 == NO_ERROR ) 
                {
                    MprConfigBufferFree( pClBlock );
                    pClBlock = pAdmClBlock;
                }
                
                else 
                {
                    pAdmClBlock = NULL;
                    DisplayError( g_hModule, rc1 );
                }
            }

            
            pIpxToc = GetIPXTocEntry(
                        (PIPX_INFO_BLOCK_HEADER) pClBlock, IPX_INTERFACE_INFO_TYPE
                        );
                        
            pIpxWanToc = GetIPXTocEntry (
                            (PIPX_INFO_BLOCK_HEADER)pClBlock, IPXWAN_INTERFACE_INFO_TYPE
                            );
                            
            if ( ( pIpxToc != NULL ) && ( pIpxWanToc != NULL ) )
            {
                PIPX_IF_INFO    pIpxInfo;
                PIPXWAN_IF_INFO pIpxWanInfo;
                PWCHAR          buffer[3];
                
                pIpxInfo = ( PIPX_IF_INFO ) ( pClBlock + pIpxToc-> Offset );
                pIpxWanInfo = ( PIPXWAN_IF_INFO ) ( pClBlock + pIpxWanToc-> Offset );

                buffer[ 2 ] = GetEnumString(
                                g_hModule, pIpxInfo->AdminState,
                                NUM_VALUES_IN_TABLE( AdminStates ), AdminStates
                                );

                buffer[ 0 ] = GetEnumString(
                                g_hModule, ROUTER_IF_TYPE_CLIENT,
                                NUM_VALUES_IN_TABLE( RouterInterfaceTypes ), 
                                RouterInterfaceTypes
                                );

                buffer[ 1 ] = GetEnumString(
                                g_hModule, pIpxWanInfo->AdminState,
                                NUM_VALUES_IN_TABLE( WANProtocols ), 
                                WANProtocols
                                );

                if ( bDump )
                {
                    DisplayMessageT( 
                        DMP_IPX_SET_WAN_INTERFACE, InterfaceName, buffer[ 2 ],
                        buffer[ 1 ]
                        );
                }

                else
                {
                    DisplayIPXMessage(
                        g_hModule, msg, buffer[2], buffer[ 0 ], buffer[ 1 ],
                        InterfaceName
                        );
                }
            }
            else 
            {
                if ( !bDump )
                {
                    DisplayIPXMessage (g_hModule, MSG_INTERFACE_INFO_CORRUPTED );
                }
                
                rc = ERROR_INVALID_DATA;
            }
            
            if ( pAdmClBlock != NULL )
            {
                MprAdminBufferFree( pClBlock );
            }
            else
            {
                MprConfigBufferFree( pClBlock );
            }
        }
        else
        {
             if ( !bDump )
             {
                DisplayError( g_hModule, rc );
             }
        }
    }
    else if ( ( rc == ERROR_FILE_NOT_FOUND ) || 
              ( rc == ERROR_NO_MORE_ITEMS ) )
    {
        if ( !bDump )
        {
            DisplayIPXMessage (g_hModule, MSG_NO_IPX_IN_ROUTER_CFG );
        }
    }
    else
    {
        if ( !bDump )
        {
            DisplayError( g_hModule, rc );
        }
    }

    return rc;
}

// Error reporting
void PrintErr(DWORD err)
{
    WCHAR buf[1024];
    FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM,NULL,err,0,buf,1024,NULL);
    wprintf(buf);
    wprintf(L"\n");
}



DWORD
MIBEnumIpxIfs(
    BOOL        bDump
    )
/*++

Routine Description :

    This routine enumerates the interfaces from the router service and
    displays them.

    
Arguments :

    InterfaceName - Name of interface for which config is requested.
    
    msg - Format of display output 
    

Return value :

--*/
{
    PMPR_INTERFACE_0 IfList=NULL;
    DWORD dwErr=0, dwRead, dwTot,i, j;
    PWCHAR buffer[4];
    LPBYTE pszBuf = NULL;
    WCHAR IfDisplayName[ MAX_INTERFACE_NAME_LEN + 1 ];
    PIPX_IF_INFO pIf;
    PIPXWAN_IF_INFO pWanIf;
    DWORD dwSize = sizeof(IfDisplayName);

    if ( !bDump )
    {
        DisplayIPXMessage (g_hModule, MSG_IPXIF_MIB_TABLE_HDR );
    }
    
    dwErr = MprAdminInterfaceEnum(
                g_hMprAdmin, 0, (unsigned char **)&IfList, MAXULONG, &dwRead,
                &dwTot,NULL
                );
                
    if ( dwErr != NO_ERROR )
    {
        return dwErr;
    }

    if ( dwRead && bDump )
    {
        //
        // If interface are present and this is a dump command
        // display dump header.
        //
        
        DisplayIPXMessage (g_hModule, MSG_IPX_DUMP_IF_HEADER);
    }

    
    for ( i = 0; i < dwRead; i++ )
    {
        if ( ( pIf = GetIpxNbInterface( IfList[i].hInterface, &pszBuf, &pWanIf ) ) 
             != NULL )
        {
            //======================================
            // Translate the Interface Name
            //======================================
            
            dwErr = IpmontrGetFriendlyNameFromIfName(
                        IfList[i].wszInterfaceName,
                       IfDisplayName, &dwSize
                       );

            if ( dwErr == NO_ERROR )
            {
                buffer[ 0 ] = GetEnumString(
                                g_hModule, IfList[i].dwIfType,
                                NUM_VALUES_IN_TABLE( InterfaceTypes ),
                                InterfaceTypes
                                );

                buffer[ 1 ] = GetEnumString(
                                g_hModule, pIf->AdminState,
                                NUM_VALUES_IN_TABLE( AdminStates ),
                                AdminStates
                                );

                buffer[ 2 ] = GetEnumString(
                                g_hModule, IfList[i].dwConnectionState,
                                NUM_VALUES_IN_TABLE( InterfaceStates ),
                                InterfaceStates
                                );

                if ( bDump )
                {
                    if ( IfList[i].dwIfType == ROUTER_IF_TYPE_FULL_ROUTER )
                    {
                        DisplayMessageT( 
                            DMP_IPX_ADD_INTERFACE, IfDisplayName
                            );

                        //
                        // Whistler bug 299007 ipxmontr.dll prefast warnings
                        //

                        buffer[ 3 ] = GetEnumString( 
                                        g_hModule, pWanIf->AdminState,
                                        NUM_VALUES_IN_TABLE( WANProtocols ),
                                        WANProtocols
                                        );

                        DisplayMessageT(
                            DMP_IPX_SET_WAN_INTERFACE, IfDisplayName, buffer[ 1 ],
                            buffer[ 3 ]
                            );
                    }

                    else
                    {
                        DisplayMessageT(
                            DMP_IPX_SET_INTERFACE, IfDisplayName, buffer[ 1 ]
                            );
                    }
                }

                else
                {
                    DisplayIPXMessage(
                        g_hModule, MSG_IPXIF_MIB_TABLE_FMT,
                        buffer[2], buffer[1], L"", buffer[0],
                        IfDisplayName
                        );
                }
            }
        }
        MprAdminBufferFree (pszBuf);
    }

    MprAdminBufferFree( IfList );
    return NO_ERROR;
}



DWORD
CfgEnumIpxIfs (
    BOOL   bDump
    ) 
/*++

Routine Description :

    This routine enumerates the interfaces from the router configuration and
    displays them.

    
Arguments :


Return value :

--*/
{
    DWORD   rc = NO_ERROR;
    DWORD   read, total, processed=0, i, j;
    DWORD   hResume = 0;
    DWORD   sz;
    WCHAR   IfDisplayName[ MAX_INTERFACE_NAME_LEN + 1 ];   
    PMPR_INTERFACE_0    pRi0;
    DWORD   dwSize = sizeof(IfDisplayName);


    if ( !bDump )
    {
        DisplayIPXMessage (g_hModule, MSG_IPXIF_CFG_TABLE_HDR );
    }
    
    
    do 
    {
        rc = MprConfigInterfaceEnum(
                g_hMprConfig,  0, (LPBYTE *)&pRi0, MAXULONG, &read, &total,
                &hResume
                );
                
        if ( rc == NO_ERROR )
        {
            if ( read && bDump )
            {
                //
                // If interface are present and this is a dump command
                // display dump header.
                //
                
                DisplayIPXMessage (g_hModule, MSG_IPX_DUMP_IF_HEADER);
            }

            
            for ( i = 0; i < read; i++ )
            {
                HANDLE        hIfTrCfg;

                rc = MprConfigInterfaceTransportGetHandle (
                        g_hMprConfig,  pRi0[i].hInterface, PID_IPX,
                        &hIfTrCfg
                        );
                        
                if ( rc == NO_ERROR )
                {
                    LPBYTE    pIfBlock;
                    rc = MprConfigInterfaceTransportGetInfo(
                            g_hMprConfig, pRi0[i].hInterface, hIfTrCfg,
                            &pIfBlock, &sz
                            );
                            
                    if (rc == NO_ERROR) 
                    {
                        PIPX_TOC_ENTRY pIpxToc;
                        PIPX_TOC_ENTRY pIpxWanToc;

                        pIpxToc = GetIPXTocEntry(
                                    (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                                    IPX_INTERFACE_INFO_TYPE
                                    );
                                    
                        pIpxWanToc = GetIPXTocEntry (
                                    (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                                    IPXWAN_INTERFACE_INFO_TYPE
                                    );
                                    
                        if ( ( pIpxToc != NULL ) && ( pIpxWanToc != NULL ) )
                        {
                            PIPX_IF_INFO    pIpxInfo;
                            PIPXWAN_IF_INFO pIpxWanInfo;
                            PWCHAR           buffer[3];

                            pIpxInfo = (PIPX_IF_INFO) (pIfBlock+pIpxToc->Offset);
                            
                            pIpxWanInfo = (PIPXWAN_IF_INFO) (pIfBlock+pIpxWanToc->Offset);

                            //======================================
                            // Translate the Interface Name
                            //======================================
                            rc = IpmontrGetFriendlyNameFromIfName(
                                    pRi0[i].wszInterfaceName,
                                    IfDisplayName, &dwSize
                                    );

                            if ( rc == NO_ERROR )
                            {
                                //======================================
                                
                                buffer[ 0 ] = GetEnumString(
                                                g_hModule, pRi0[i].dwIfType,
                                                NUM_VALUES_IN_TABLE( RouterInterfaceTypes ),
                                                RouterInterfaceTypes
                                                );

                                buffer[ 2 ] = GetEnumString(
                                                g_hModule, pIpxInfo->AdminState,
                                                NUM_VALUES_IN_TABLE( AdminStates ),
                                                AdminStates
                                                );


                                buffer[ 1 ] = ( pRi0[i].dwIfType == ROUTER_IF_TYPE_DEDICATED ) ||
                                              ( pRi0[i].dwIfType == ROUTER_IF_TYPE_INTERNAL ) ?
                                              VAL_NA :
                                              GetEnumString( 
                                                g_hModule, pIpxWanInfo->AdminState,
                                                NUM_VALUES_IN_TABLE( WANProtocols ),
                                                WANProtocols
                                                );

                                if ( buffer[ 0 ] && buffer[ 1 ] && buffer[ 2 ] )
                                {
                                    if ( bDump )
                                    {
                                        if ( pRi0[i].dwIfType == ROUTER_IF_TYPE_FULL_ROUTER )                                            
                                        {
                                            DisplayMessageT( 
                                                DMP_IPX_ADD_INTERFACE, IfDisplayName
                                                );
                                                
                                            DisplayMessageT(
                                                DMP_IPX_SET_WAN_INTERFACE, IfDisplayName, buffer[ 2 ],
                                                buffer[ 1 ]
                                                );
                                        }

                                        else
                                        {
                                            DisplayMessageT(
                                                DMP_IPX_SET_INTERFACE, IfDisplayName, buffer[ 2 ]
                                                );
                                        }
                                    }

                                    else
                                    {
                                        DisplayIPXMessage(
                                            g_hModule, MSG_IPXIF_CFG_TABLE_FMT,
                                            buffer[2], buffer[0], buffer[1], 
                                            IfDisplayName
                                            );
                                    }
                                }
                            }
                        }
                        else
                        {
                            rc = ERROR_INVALID_DATA;

                            if ( !bDump )
                            {
                                DisplayIPXMessage (g_hModule, MSG_INTERFACE_INFO_CORRUPTED );
                            }
                        }
                    }
                    
                    else if ( rc != ERROR_NO_MORE_ITEMS ) 
                    {
                        if ( !bDump )
                        {
                            DisplayError( g_hModule, rc);
                        }
                    }
                }
                else 
                {
                    //DisplayError( g_hModule, rc);    // This is not needed
                }
            }
            
            processed += read;
            MprConfigBufferFree( pRi0 );
        }
        else 
        {
            DisplayError( g_hModule, rc );
            break;
        }
        
    } while ( processed < total );

    return rc;
}


DWORD
CfgSetIpxIf (
    LPWSTR        InterfaceNameW,
    PULONG        pAdminState       OPTIONAL,
    PULONG        pWANProtocol      OPTIONAL
    ) 
/*++

Routine Description :

    This routine updates the interface setting in the router configuration.

    
Arguments :

    InterfaceNameW - Name of interface being updated

    pAdminState - New value for adminstate

    pWANProtocol - New value for WAN protocol

Return value :

--*/

{
    DWORD        rc;
    DWORD        sz;
    HANDLE        hTrCfg;
    HANDLE        hIfCfg;
    HANDLE        hIfTrCfg;
    LPBYTE        pIfBlock;


    if ( InterfaceNameW != NULL )
    {
        rc = MprConfigInterfaceGetHandle( 
                g_hMprConfig, InterfaceNameW, &hIfCfg 
                );
                
        if ( rc == NO_ERROR )
        {
            rc = MprConfigInterfaceTransportGetHandle(
                    g_hMprConfig, hIfCfg, PID_IPX, &hIfTrCfg
                    );
                    
            if ( rc == NO_ERROR )
            {
                rc = MprConfigInterfaceTransportGetInfo(
                        g_hMprConfig, hIfCfg, hIfTrCfg, &pIfBlock, &sz
                        );
            }
        }
    }
    
    else 
    {
        rc = MprConfigTransportGetHandle( g_hMprConfig, PID_IPX, &hTrCfg );
        
        if ( rc == NO_ERROR )
        {
            rc = MprConfigTransportGetInfo(
                    g_hMprConfig, hTrCfg, NULL, NULL, &pIfBlock, &sz, NULL
                    );
        }
    }

    if ( rc == NO_ERROR ) 
    {
        PIPX_TOC_ENTRY pIpxToc;
        PIPX_TOC_ENTRY pIpxWanToc;

        pIpxToc = GetIPXTocEntry(
                    (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                    IPX_INTERFACE_INFO_TYPE
                    );
                    
        pIpxWanToc = GetIPXTocEntry(
                    (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                    IPXWAN_INTERFACE_INFO_TYPE
                    );
                    
        if ( ( pIpxToc != NULL ) && ( pIpxWanToc != NULL ) )
        {
            PIPX_IF_INFO    pIpxInfo;
            PIPXWAN_IF_INFO    pIpxWanInfo;

            pIpxInfo = (PIPX_IF_INFO) (pIfBlock+pIpxToc->Offset);
            
            pIpxWanInfo = (PIPXWAN_IF_INFO) (pIfBlock+pIpxWanToc->Offset);
            

            if ( ARGUMENT_PRESENT( pAdminState ) )
            {
                pIpxInfo->AdminState = *pAdminState;
            }
            
            if ( ARGUMENT_PRESENT( pWANProtocol ) )
            {
                pIpxWanInfo->AdminState = *pWANProtocol;
            }

            if ( InterfaceNameW != NULL )
            {
                rc = MprConfigInterfaceTransportSetInfo(
                        g_hMprConfig, hIfCfg, hIfTrCfg, pIfBlock, sz
                        );
            }
            
            else
            {
                rc = MprConfigTransportSetInfo(
                        g_hMprConfig, hTrCfg, NULL, 0, pIfBlock, sz, NULL
                        );
            }
            
            if ( rc != NO_ERROR )
            {
                DisplayError( g_hModule, rc );
            }
        }
        else 
        {
            DisplayIPXMessage (g_hModule, MSG_INTERFACE_INFO_CORRUPTED );
            rc = ERROR_INVALID_DATA;
        }
        
        MprConfigBufferFree( pIfBlock );
    }
    
    else
    {
        DisplayError( g_hModule, rc );
    }

    return rc;
}


DWORD
AdmSetIpxIf (
    LPWSTR        InterfaceNameW,
    PULONG        pAdminState       OPTIONAL,
    PULONG        pWANProtocol      OPTIONAL
    ) 
/*++

Routine Description :

    This routine updates the interface setting in the router service.

    
Arguments :

    InterfaceNameW - Name of interface being updated

    pAdminState - New value for adminstate

    pWANProtocol - New value for WAN protocol

Return value :

--*/

{
    DWORD        rc;
    DWORD        sz;
    HANDLE        hIfAdm;
    LPBYTE        pIfBlock;
 
    if ( InterfaceNameW != NULL )
    {
        rc = MprAdminInterfaceGetHandle(
                g_hMprAdmin, InterfaceNameW, &hIfAdm, FALSE
                );
                
        if ( rc == NO_ERROR ) 
        {
            rc = MprAdminInterfaceTransportGetInfo(
                    g_hMprAdmin, hIfAdm, PID_IPX, &pIfBlock, &sz
                    );
        }
    }
    
    else 
    {
        rc = MprAdminTransportGetInfo(
                g_hMprAdmin, PID_IPX, NULL, NULL, &pIfBlock, &sz
                );
                
        if ( rc == NO_ERROR )
        {
            if ( pIfBlock == NULL ) { return rc; }
        }
    }

    if ( rc == NO_ERROR )
    {
        PIPX_TOC_ENTRY pIpxToc;
        PIPX_TOC_ENTRY pIpxWanToc;

        pIpxToc = GetIPXTocEntry(
                    (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                    IPX_INTERFACE_INFO_TYPE
                    );
                    
        pIpxWanToc = GetIPXTocEntry(
                        (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                        IPXWAN_INTERFACE_INFO_TYPE
                        );
                         
        if ( ( pIpxToc != NULL ) && ( pIpxWanToc != NULL ) )
        {
            PIPX_IF_INFO    pIpxInfo;
            PIPXWAN_IF_INFO pIpxWanInfo;
            

            pIpxInfo = (PIPX_IF_INFO) (pIfBlock + pIpxToc-> Offset);
            pIpxWanInfo = (PIPXWAN_IF_INFO) (pIfBlock + pIpxWanToc-> Offset);

            if ( ARGUMENT_PRESENT( pAdminState ) ) 
            {
                pIpxInfo->AdminState = *pAdminState;
            }
            
            if (ARGUMENT_PRESENT( pWANProtocol) )
            {
                pIpxWanInfo->AdminState = *pWANProtocol;
            }

            if ( InterfaceNameW != NULL )
            {
                rc = MprAdminInterfaceTransportSetInfo(
                        g_hMprAdmin, hIfAdm, PID_IPX, pIfBlock,
                        ((PIPX_INFO_BLOCK_HEADER)pIfBlock)->Size
                        );
            }
            else
            {
                rc = MprAdminTransportSetInfo(
                        g_hMprAdmin, PID_IPX, NULL, 0, pIfBlock,
                        ((PIPX_INFO_BLOCK_HEADER)pIfBlock)->Size
                        );
            }

            
            if ( rc != NO_ERROR )
            {
                DisplayError( g_hModule, rc);
            }
        }
        
        else
        {
            DisplayIPXMessage (g_hModule, MSG_INTERFACE_INFO_CORRUPTED );
            rc = ERROR_INVALID_DATA;
        }
        
        MprAdminBufferFree( pIfBlock );
    }
    
    else 
    {
        DisplayError( g_hModule, rc );
    }

    return rc;
}


PIPX_IF_INFO
GetIpxNbInterface(
    HANDLE hIf, 
    LPBYTE *pIfBlock,
    PIPXWAN_IF_INFO *ppWanIf
    ) 
{
    DWORD dwSize;
    DWORD dwErr;
    PIPX_TOC_ENTRY pIpxToc;

    dwErr = MprAdminInterfaceTransportGetInfo(
                g_hMprAdmin, hIf, PID_IPX, pIfBlock, &dwSize
                );

    if ( dwErr != NO_ERROR )
    {
        return NULL;
    }


    pIpxToc = GetIPXTocEntry(
                (PIPX_INFO_BLOCK_HEADER)(*pIfBlock),
                IPXWAN_INTERFACE_INFO_TYPE
                );

    if ( pIpxToc )
    {
        *ppWanIf = (PIPXWAN_IF_INFO) ((*pIfBlock)+(pIpxToc->Offset));
    }
    
    pIpxToc = GetIPXTocEntry (
                (PIPX_INFO_BLOCK_HEADER)(*pIfBlock),
                IPX_INTERFACE_INFO_TYPE
                );
                
    if (!pIpxToc)
    {
        return NULL;
    }

    return (PIPX_IF_INFO)((*pIfBlock)+(pIpxToc->Offset));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ipx\ipxmon\ipxstrs.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ipxstrs.rc
//

//
// help messages mapped to routemon message Ids
//

#define HLP_GROUP_ADD                   1701
#define HLP_GROUP_DELETE                1702
#define HLP_GROUP_SET                   1703
#define HLP_GROUP_SHOW                  1704

#define HLP_IPX_ADD_EX                  1900
#define HLP_IPX_DELETE_EX               1901
#define HLP_IPX_SET_EX                  1902
#define HLP_IPX_SHOW_EX                 1903

#define HLP_IPX_DUMP                    1711
#define HLP_IPX_HELP1                   1712
#define HLP_IPX_HELP2                   HLP_IPX_HELP1
#define HLP_IPX_UPDATE                  1716

#define HLP_IPX_DUMP_EX                 1721
#define HLP_IPX_HELP1_EX                MSG_IPX_HELP
#define HLP_IPX_HELP2_EX                MSG_IPX_HELP
#define HLP_IPX_UPDATE_EX               1726


#define HLP_IPX_ADD_ROUTE               1731
#define HLP_IPX_ADD_SERVICE             1732
#define HLP_IPX_ADD_FILTER              1733
#define HLP_IPX_ADD_INTERFACE           1734

#define HLP_IPX_ADD_ROUTE_EX            HLP_IPX_ADD_EX
#define HLP_IPX_ADD_SERVICE_EX          HLP_IPX_ADD_EX
#define HLP_IPX_ADD_FILTER_EX           HLP_IPX_ADD_EX
#define HLP_IPX_ADD_INTERFACE_EX        HLP_IPX_ADD_EX


#define HLP_IPX_DELETE_ROUTE            1751
#define HLP_IPX_DELETE_SERVICE          1752
#define HLP_IPX_DELETE_FILTER           1753
#define HLP_IPX_DELETE_INTERFACE        1754

#define HLP_IPX_DELETE_ROUTE_EX         HLP_IPX_DELETE_EX
#define HLP_IPX_DELETE_SERVICE_EX       HLP_IPX_DELETE_EX
#define HLP_IPX_DELETE_FILTER_EX        HLP_IPX_DELETE_EX
#define HLP_IPX_DELETE_INTERFACE_EX     HLP_IPX_DELETE_EX


#define HLP_IPX_SET_ROUTE               1771
#define HLP_IPX_SET_SERVICE             1772
#define HLP_IPX_SET_FILTER              1773
#define HLP_IPX_SET_INTERFACE           1774
#define HLP_IPX_SET_GLOBAL              1775

#define HLP_IPX_SET_ROUTE_EX            HLP_IPX_SET_EX
#define HLP_IPX_SET_SERVICE_EX          HLP_IPX_SET_EX
#define HLP_IPX_SET_FILTER_EX           HLP_IPX_SET_EX
#define HLP_IPX_SET_INTERFACE_EX        HLP_IPX_SET_EX
#define HLP_IPX_SET_GLOBAL_EX           1785


#define HLP_IPX_SHOW_ROUTE              1791
#define HLP_IPX_SHOW_SERVICE            1792
#define HLP_IPX_SHOW_FILTER             1793
#define HLP_IPX_SHOW_INTERFACE          1795
#define HLP_IPX_SHOW_GLOBAL             1796
#define HLP_IPX_SHOW_ROUTETABLE         1797
#define HLP_IPX_SHOW_SERVICETABLE       1798

#define HLP_IPX_SHOW_ROUTE_EX           HLP_IPX_SHOW_EX
#define HLP_IPX_SHOW_SERVICE_EX         HLP_IPX_SHOW_EX
#define HLP_IPX_SHOW_FILTER_EX          HLP_IPX_SHOW_EX
#define HLP_IPX_SHOW_INTERFACE_EX       HLP_IPX_SHOW_EX
#define HLP_IPX_SHOW_GLOBAL_EX          HLP_IPX_SHOW_EX
#define HLP_IPX_SHOW_ROUTETABLE_EX      HLP_IPX_SHOW_EX
#define HLP_IPX_SHOW_SERVICETABLE_EX    HLP_IPX_SHOW_EX

#define HLP_HELP_START                  1811
#define HLP_HELP_START1                 1812
#define HLP_HELPER_HELP                 1813
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ipx\ipxmon\ipxutil.c ===
#include "precomp.h"
#pragma hdrstop


TOKEN_VALUE InterfaceTypes[ 5 ] =
{
    { VAL_CLIENT,       ROUTER_IF_TYPE_CLIENT },
    { VAL_HOMEROUTER,   ROUTER_IF_TYPE_HOME_ROUTER },
    { VAL_WANROUTER,    ROUTER_IF_TYPE_FULL_ROUTER },
    { VAL_DEDICATED,    ROUTER_IF_TYPE_DEDICATED },
    { VAL_INTERNAL,     ROUTER_IF_TYPE_INTERNAL }
};

TOKEN_VALUE InterfaceStates[ 3 ] = 
{
    { VAL_DOWN,         ROUTER_IF_STATE_DISCONNECTED },
    { VAL_DOWN,         ROUTER_IF_STATE_CONNECTING },
    { VAL_UP,           ROUTER_IF_STATE_CONNECTED }
};

TOKEN_VALUE InterfaceEnableStatus[ 2 ] =
{
    { VAL_ENABLED,      FALSE },
    { VAL_DISABLED,     TRUE }
};


TOKEN_VALUE AdminStates[ 2 ] = 
{
    { VAL_DISABLED,     ADMIN_STATE_DISABLED },
    { VAL_ENABLED,      ADMIN_STATE_ENABLED }
};

TOKEN_VALUE OperStates[ 3 ] =
{
    { VAL_DOWN,         OPER_STATE_DOWN },
    { VAL_UP,           OPER_STATE_UP     },
    { VAL_SLEEPING,     OPER_STATE_SLEEPING }
};

TOKEN_VALUE IpxInterfaceTypes[ 8 ] = 
{
    { VAL_OTHER,        IF_TYPE_OTHER },
    { VAL_DEDICATED,    IF_TYPE_LAN },
    { VAL_WANROUTER,    IF_TYPE_WAN_ROUTER },
    { VAL_CLIENT,       IF_TYPE_WAN_WORKSTATION },
    { VAL_INTERNAL,     IF_TYPE_INTERNAL },
    { VAL_HOMEROUTER,   IF_TYPE_PERSONAL_WAN_ROUTER },
    { VAL_DIALOUT,      IF_TYPE_ROUTER_WORKSTATION_DIALOUT },
    { VAL_DIALOUT,      IF_TYPE_STANDALONE_WORKSTATION_DIALOUT }
};

TOKEN_VALUE RouterInterfaceTypes[ 5 ] =
{
    { VAL_CLIENT,       ROUTER_IF_TYPE_CLIENT },
    { VAL_HOMEROUTER,   ROUTER_IF_TYPE_HOME_ROUTER },
    { VAL_WANROUTER,    ROUTER_IF_TYPE_FULL_ROUTER },
    { VAL_DEDICATED,    ROUTER_IF_TYPE_DEDICATED },
    { VAL_INTERNAL,     ROUTER_IF_TYPE_INTERNAL }
};

TOKEN_VALUE NbDeliverStates[ 4 ] =
{
    { VAL_DISABLED,     ADMIN_STATE_DISABLED },
    { VAL_ENABLED,      ADMIN_STATE_DISABLED },
    { VAL_STATICONLY,   ADMIN_STATE_ENABLED_ONLY_FOR_NETBIOS_STATIC_ROUTING },
    { VAL_ONLYWHENUP,   ADMIN_STATE_ENABLED_ONLY_FOR_OPER_STATE_UP}
};


TOKEN_VALUE UpdateModes[ 3 ] =
{
    { VAL_STANDARD,     IPX_STANDARD_UPDATE },
    { VAL_NONE,         IPX_NO_UPDATE },
    { VAL_AUTOSTATIC,   IPX_AUTO_STATIC_UPDATE }
};

TOKEN_VALUE IpxProtocols[ 4 ] =
{
    { VAL_LOCAL,        IPX_PROTOCOL_LOCAL },
    { VAL_STATIC,       IPX_PROTOCOL_STATIC },
    { VAL_RIP,          IPX_PROTOCOL_RIP },
    { VAL_SAP,          IPX_PROTOCOL_SAP }
};  

TOKEN_VALUE TfFilterActions[ 2 ] = 
{
    { VAL_PERMIT,       IPX_TRAFFIC_FILTER_ACTION_PERMIT },
    { VAL_DENY,         IPX_TRAFFIC_FILTER_ACTION_DENY }
};

TOKEN_VALUE RipFilterActions[ 2 ] = 
{
    { VAL_PERMIT,       IPX_ROUTE_FILTER_PERMIT },
    { VAL_DENY,         IPX_ROUTE_FILTER_DENY }
};


TOKEN_VALUE SapFilterActions[ 2 ] =
{
    { VAL_PERMIT,       IPX_SERVICE_FILTER_PERMIT },
    { VAL_DENY,         IPX_SERVICE_FILTER_DENY }
};


TOKEN_VALUE WANProtocols[ 2 ] = 
{
    { VAL_PPP, ADMIN_STATE_DISABLED },
    { VAL_IPXWAN, ADMIN_STATE_ENABLED }
};

TOKEN_VALUE FilterModes[ 2 ] = 
{
    { VAL_INPUT,        INPUT_FILTER },
    { VAL_OUTPUT,       OUTPUT_FILTER }
};

TOKEN_VALUE LogLevels[ 4 ] = 
{
    { VAL_NONE ,        0 },
    { VAL_ERRORS_ONLY , EVENTLOG_ERROR_TYPE },
    { VAL_ERRORS_AND_WARNINGS,  EVENTLOG_ERROR_TYPE | EVENTLOG_WARNING_TYPE },
    { VAL_MAXINFO, 
        EVENTLOG_ERROR_TYPE | EVENTLOG_WARNING_TYPE | EVENTLOG_INFORMATION_TYPE }
};


DWORD
GetIpxInterfaceIndex(
    IN          MIB_SERVER_HANDLE   hRouterMIB,
    IN          LPCWSTR             InterfaceName,
    OUT         ULONG              *InterfaceIndex
    )
/*++

Routine Description :

    This routine retrives the index of an interface given its name.

Arguments :

    hRouterMIB - Handle to the router service

    InterfaceName - Name of interface for which index is required

    InterfaceIndex - On return contains the interface of the interface
                     if found.

Return values :

    
--*/
{

    IPX_MIB_GET_INPUT_DATA  MibGetInputData;
    DWORD                   IfSize = sizeof(IPX_INTERFACE);
    PIPX_INTERFACE          Ifp;
    DWORD                   rc;
    UCHAR                   InterfaceNameA[ MAX_INTERFACE_NAME_LEN + 1 ];

    
    //
    // Convert interface name to Ansi
    //

    wcstombs( InterfaceNameA, InterfaceName, MAX_INTERFACE_NAME_LEN );

    MibGetInputData.TableId = IPX_INTERFACE_TABLE;

    //
    // Begin enumerating interfaces
    //
    
    rc = MprAdminMIBEntryGetFirst(
            hRouterMIB, PID_IPX, IPX_PROTOCOL_BASE, &MibGetInputData,
            sizeof( IPX_MIB_GET_INPUT_DATA ), (LPVOID *) &Ifp,
            &IfSize
            );

    //
    // until a match is found or there are no more interfaces
    //
    
    while ( rc == NO_ERROR )
    {
        //
        // Is this the interface
        //
        
        if ( _stricmp( (LPSTR)InterfaceNameA, (LPSTR) Ifp->InterfaceName) == 0 )
        {
            *InterfaceIndex = Ifp->InterfaceIndex;
            
            MprAdminMIBBufferFree (Ifp);
            
            break;
        }
        else 
        {
            MibGetInputData.MibIndex.InterfaceTableIndex.InterfaceIndex = 
                Ifp->InterfaceIndex;
                
            MprAdminMIBBufferFree (Ifp);
        }
        
        rc = MprAdminMIBEntryGetNext(
                hRouterMIB, PID_IPX, IPX_PROTOCOL_BASE, &MibGetInputData,
                sizeof(IPX_MIB_GET_INPUT_DATA), (LPVOID *)&Ifp, &IfSize
                );
    }

    if ( rc == ERROR_NO_MORE_ITEMS )
    {
        rc = ERROR_NO_SUCH_INTERFACE;
    }
    
    return rc;
}

DWORD
GetIpxInterfaceName (
    IN      MIB_SERVER_HANDLE   hRouterMIB,
    IN      ULONG               InterfaceIndex,
    OUT     LPWSTR              InterfaceName
    ) 
/*++

Routine Description :

    This routine retrives the index of an interface given its name.

Arguments :

    hRouterMIB - Handle to the router service

    InterfaceName - Name of interface for which index is required

    InterfaceIndex - On return contains the interface of the interface
                     if found.

Return values :

    
--*/
{
    IPX_MIB_GET_INPUT_DATA  MibGetInputData;
    DWORD                   IfSize = sizeof( IPX_INTERFACE );
    PIPX_INTERFACE          Ifp;
    DWORD                   rc;


    MibGetInputData.TableId = IPX_INTERFACE_TABLE;
    
    MibGetInputData.MibIndex.InterfaceTableIndex.InterfaceIndex = 
        InterfaceIndex;
    
    rc = MprAdminMIBEntryGet(
            hRouterMIB, PID_IPX, IPX_PROTOCOL_BASE, &MibGetInputData,
            sizeof(IPX_MIB_GET_INPUT_DATA), (LPVOID *)&Ifp, &IfSize
            );
            
    if ( rc == NO_ERROR )
    {
        mbstowcs( 
            InterfaceName, (LPSTR)Ifp->InterfaceName,
            IPX_INTERFACE_ANSI_NAME_LEN
            );

        MprAdminMIBBufferFree( Ifp );
    }
    
    else if ( rc == ERROR_NO_MORE_ITEMS )
    {
        rc = ERROR_NO_SUCH_INTERFACE;
    }
    
    return rc;
}



/*++
*******************************************************************
        G e t I P X T o c E n t r y

Routine Description:
    Returns pointer to entry in Router Table Of Context
Arguments:
    pInterfaceInfo    - pointer to table of content
    InfoEntryType    - type of entry to look for
Return Value:
    Pointer to entry in table of content
    NULL if there is no such entry in the table
Remarks:
*******************************************************************
--*/
PIPX_TOC_ENTRY
GetIPXTocEntry(
    IN PIPX_INFO_BLOCK_HEADER   pInterfaceInfo,
    IN ULONG                    InfoEntryType
    ) 
{
    UINT            i;
    PIPX_TOC_ENTRY  pTocEntry;

    if (pInterfaceInfo)
    {
        for ( i = 0, pTocEntry = pInterfaceInfo->TocEntry;
              i < pInterfaceInfo->TocEntriesCount;
              i++, pTocEntry++) 
        {
            if (pTocEntry->InfoType == InfoEntryType) 
            {
                return pTocEntry;
            }
        }
    }

    SetLastError( ERROR_FILE_NOT_FOUND );
    
    return NULL;
}


DWORD
AddIPXInfoEntry (
    IN PIPX_INFO_BLOCK_HEADER       pOldBlock,
    IN ULONG                        InfoType,
    IN ULONG                        InfoSize,
    IN PVOID                        Info,
    IN PINFO_CMP_PROC               InfoEqualCB OPTIONAL,
    OUT PIPX_INFO_BLOCK_HEADER     *pNewBlock
) 
{
    ULONG                    i, entriesCount = 1;
    PIPX_TOC_ENTRY           pTocEntry;
    PIPX_INFO_BLOCK_HEADER   pBlock;
    ULONG                    newBlockSize = 
                                InfoSize + sizeof( IPX_INFO_BLOCK_HEADER );
    BOOLEAN                  done = FALSE;
    DWORD                    rc;


    if ( pOldBlock != NULL ) 
    {
        ASSERT (pOldBlock->Version==IPX_ROUTER_VERSION_1);
        
        for ( i=0, pTocEntry = pOldBlock->TocEntry;
              i < pOldBlock->TocEntriesCount;
              i++, pTocEntry++) 
        {
            newBlockSize += pTocEntry->InfoSize*pTocEntry->Count;
            
            if (pTocEntry->InfoType == InfoType) 
            {
                ULONG    j;
                LPBYTE    pInfo = (LPBYTE)pOldBlock+pTocEntry->Offset;

                ASSERT (pTocEntry->InfoSize == InfoSize);
                
                for (j=0; j<pTocEntry->Count; j++, pInfo+=InfoSize) 
                {
                    BOOL    found;
                    
                    if (InfoEqualCB!=NULL)
                    {
                        found = (*InfoEqualCB) (pInfo, Info);
                    }
                    else
                    {
                        found = memcmp (pInfo, Info, InfoSize)==0;
                    }
                    
                    if (found)
                    {
                        return ERROR_ALREADY_EXISTS;
                    }
                }
            }
            
            else 
            {
                entriesCount += 1;
                newBlockSize += sizeof (IPX_TOC_ENTRY);
            }
        }
    }
    
    pBlock = (PIPX_INFO_BLOCK_HEADER)GlobalAlloc (GPTR, newBlockSize);
    
    if ( pBlock != NULL ) 
    {
        ULONG   dstOffset = 
                    FIELD_OFFSET (IPX_INFO_BLOCK_HEADER,TocEntry[entriesCount]);
                    
        PIPX_TOC_ENTRY    dstToc = pBlock->TocEntry;


        pBlock->Version = IPX_ROUTER_VERSION_1;
        pBlock->Size = newBlockSize;
        pBlock->TocEntriesCount = entriesCount;
        
        if (pOldBlock!=NULL) 
        {
            for (i=0, pTocEntry = pOldBlock->TocEntry; 
                 i<pOldBlock->TocEntriesCount; i++, pTocEntry++) 
            {
                *dstToc = *pTocEntry;
                dstToc->Offset = dstOffset;

                memcpy ((PUCHAR)pBlock+dstOffset,
                        (PUCHAR)pOldBlock+pTocEntry->Offset,
                        pTocEntry->InfoSize*pTocEntry->Count);

                dstOffset += dstToc->InfoSize*dstToc->Count;

                if (dstToc->InfoType==InfoType) 
                {
                    memcpy ((PUCHAR)pBlock+dstOffset, Info, InfoSize);
                    dstToc->Count += 1;
                    dstOffset += InfoSize;
                    done = TRUE;
                }
                dstToc += 1;
            }
        }

        if (!done) 
        {
            dstToc->InfoType = InfoType;
            dstToc->InfoSize = InfoSize;
            dstToc->Count = 1;
            dstToc->Offset = dstOffset;
            memcpy ((PUCHAR)pBlock+dstOffset, Info, InfoSize);
        }
        
        *pNewBlock = pBlock;
        rc = NO_ERROR;
    }
    else
    {
        rc = ERROR_NOT_ENOUGH_MEMORY;
    }
    
    return rc;
}

DWORD
DeleteIPXInfoEntry (
    IN PIPX_INFO_BLOCK_HEADER   pOldBlock,
    IN ULONG                    InfoType,
    IN ULONG                    InfoSize,
    IN PVOID                    Info,
    IN PINFO_CMP_PROC           InfoEqualCB OPTIONAL,
    IN PIPX_INFO_BLOCK_HEADER  *pNewBlock
)
{
    ULONG           i, entriesCount = 1, j;
    PIPX_TOC_ENTRY  pTocEntry, dstToc;
    ULONG           newBlockSize = sizeof (IPX_INFO_BLOCK_HEADER)-InfoSize;
    ULONG           dstOffset;
    BOOLEAN         found = FALSE;
    
    if (pOldBlock == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }
    
    ASSERT (pOldBlock->Version==IPX_ROUTER_VERSION_1);

    for ( i=0, pTocEntry = pOldBlock->TocEntry;
          i<pOldBlock->TocEntriesCount;
          i++, pTocEntry++) 
    {
        newBlockSize += pTocEntry->InfoSize*pTocEntry->Count;
        
        if (pTocEntry->InfoType == InfoType) 
        {
            LPBYTE    pInfo = (LPBYTE)pOldBlock+pTocEntry->Offset;

            ASSERT (pTocEntry->InfoSize == InfoSize);
            
            for (j=0; j<pTocEntry->Count; j++, pInfo+=InfoSize) 
            {
                if ( InfoEqualCB != NULL )
                {
                    found = (BOOLEAN) (*InfoEqualCB) (pInfo, Info);
                }
                else
                {
                    found = memcmp (pInfo, Info, InfoSize)==0;
                }
                
                if (found) 
                {
                    if (pTocEntry->Count==1) 
                    {
                        entriesCount -= 1;
                        newBlockSize -= sizeof (IPX_TOC_ENTRY);
                    }
                    break;
                }
            }

            if (!found)
            {
                return ERROR_FILE_NOT_FOUND;
            }
        }

        else 
        {
            entriesCount += 1;
            newBlockSize += sizeof (IPX_TOC_ENTRY);
        }
    }

    if (!found)
    {
        return ERROR_FILE_NOT_FOUND;
    }

    for ( i=0, dstToc = pTocEntry = pOldBlock->TocEntry; 
          i < pOldBlock->TocEntriesCount; i++, pTocEntry++) 
    {
        if (pTocEntry->InfoType==InfoType) 
        {
            if (pTocEntry->Count>1) 
            {
                pTocEntry->Count -= 1;
                dstToc += 1;
            }
        }
        else
        {
            if (dstToc!=pTocEntry) 
            {
                ASSERT (dstToc<pTocEntry);
                *dstToc = *pTocEntry;
            }
            dstToc += 1;
        }
    }

    dstOffset = FIELD_OFFSET (IPX_INFO_BLOCK_HEADER,TocEntry[entriesCount]);
    
    for (i=0, pTocEntry = pOldBlock->TocEntry; 
         i<entriesCount; i++, pTocEntry++) 
    {
        if (pTocEntry->InfoType==InfoType) 
        {
            ULONG    newInfoSize = InfoSize*j;

            if ( j > 0 )
            {
                if (dstOffset!=pTocEntry->Offset) 
                {
                    ASSERT (dstOffset<pTocEntry->Offset);
                    memmove ((PUCHAR)pOldBlock+dstOffset,
                            (PUCHAR)pOldBlock+pTocEntry->Offset,
                            newInfoSize);
                }
            }

            if ( j < pTocEntry->Count )
            {
                memmove ((PUCHAR)pOldBlock+dstOffset+newInfoSize,
                        (PUCHAR)pOldBlock+pTocEntry->Offset+newInfoSize+InfoSize,
                        InfoSize*(pTocEntry->Count-j));
                newInfoSize += InfoSize*(pTocEntry->Count-j);
            }
            
            pTocEntry->Offset = dstOffset;
            dstOffset += newInfoSize;
        }
        else
        {
            if (dstOffset!=pTocEntry->Offset) 
            {
                ASSERT (dstOffset<pTocEntry->Offset);
                memmove ((PUCHAR)pOldBlock+dstOffset,
                        (PUCHAR)pOldBlock+pTocEntry->Offset,
                        pTocEntry->InfoSize*pTocEntry->Count);
                pTocEntry->Offset = dstOffset;
            }
            dstOffset += pTocEntry->InfoSize*pTocEntry->Count;
        }
    }

    pOldBlock->Size = newBlockSize;
    pOldBlock->TocEntriesCount = entriesCount;

    *pNewBlock = pOldBlock;
    return NO_ERROR;
}
    
DWORD
UpdateIPXInfoEntry (
    IN PIPX_INFO_BLOCK_HEADER   pOldBlock,
    IN ULONG                    InfoType,
    IN ULONG                    InfoSize,
    IN PVOID                    OldInfo     OPTIONAL,
    IN PVOID                    NewInfo,
    IN PINFO_CMP_PROC           InfoEqualCB OPTIONAL,
    OUT PIPX_INFO_BLOCK_HEADER *pNewBlock
    ) 
{
    ULONG                    i, j, entriesCount = 1;
    PIPX_TOC_ENTRY           pTocEntry;
    PIPX_INFO_BLOCK_HEADER   pBlock;
    ULONG                    newBlockSize = 
                                InfoSize+sizeof (IPX_INFO_BLOCK_HEADER);
    BOOLEAN                  done = FALSE;
    DWORD                    rc;



    ASSERT (pOldBlock->Version==IPX_ROUTER_VERSION_1);

    for ( i=0, pTocEntry = pOldBlock->TocEntry;
          i < pOldBlock->TocEntriesCount;
          i++, pTocEntry++) 
    {
        if (pTocEntry->InfoType == InfoType) 
        {
            LPBYTE    pInfo = (LPBYTE)pOldBlock+pTocEntry->Offset;
            
            if (OldInfo!=NULL) 
            {
                ASSERT (pTocEntry->InfoSize == InfoSize);
                
                for (j=0; j<pTocEntry->Count; j++, pInfo+=InfoSize) 
                {
                    BOOLEAN    found;

                    if (InfoEqualCB!=NULL)
                    {
                        found = (BOOLEAN) (*InfoEqualCB) (pInfo, OldInfo);
                    }
                    else
                    {
                        found = memcmp (pInfo, OldInfo, InfoSize)==0;
                    }

                    if (found) 
                    {
                        memcpy (pInfo, NewInfo, InfoSize);
                        *pNewBlock = pOldBlock;
                        return NO_ERROR;
                    }
                }
            }
            
            else
            {
                ASSERT (pTocEntry->Count==1);

                if (pTocEntry->InfoSize==InfoSize) 
                {
                    memcpy (pInfo, NewInfo, InfoSize);
                    *pNewBlock = pOldBlock;
                    return NO_ERROR;
                }    

                newBlockSize -= pTocEntry->InfoSize+sizeof (IPX_INFO_BLOCK_HEADER);
            }
        }
        else 
        {
            entriesCount += 1;
            newBlockSize += sizeof (IPX_TOC_ENTRY)+pTocEntry->InfoSize*pTocEntry->Count;
        }
    }

    
    pBlock = (PIPX_INFO_BLOCK_HEADER)GlobalAlloc (GPTR, newBlockSize);

    if ( pBlock != NULL ) 
    {
        ULONG    dstOffset = FIELD_OFFSET (IPX_INFO_BLOCK_HEADER,TocEntry[entriesCount]);
        PIPX_TOC_ENTRY    dstToc = pBlock->TocEntry;

        pBlock->Version = IPX_ROUTER_VERSION_1;
        pBlock->Size = newBlockSize;
        pBlock->TocEntriesCount = entriesCount;
        
        for (i=0, pTocEntry = pOldBlock->TocEntry; 
             i<pOldBlock->TocEntriesCount; i++, pTocEntry++) 
        {
            *dstToc = *pTocEntry;
            dstToc->Offset = dstOffset;

            if (dstToc->InfoType==InfoType) 
            {
                if (pTocEntry->InfoSize==InfoSize) 
                {
                    memcpy ((PUCHAR)pBlock+dstOffset,
                        (PUCHAR)pOldBlock+pTocEntry->Offset,
                        pTocEntry->InfoSize*pTocEntry->Count);

                    dstOffset += dstToc->InfoSize*dstToc->Count;

                    memcpy ((PUCHAR)pBlock+dstOffset, NewInfo, InfoSize);

                    dstOffset += InfoSize;
                    dstToc->Count += 1;
                }
                else
                {
                    memcpy ((PUCHAR)pBlock+dstOffset, NewInfo, InfoSize);
                    dstToc->InfoSize = InfoSize;
                    dstOffset += InfoSize;
                }
                
                done = TRUE;
            }
            else
            {
                memcpy ((PUCHAR)pBlock+dstOffset,
                    (PUCHAR)pOldBlock+pTocEntry->Offset,
                    pTocEntry->InfoSize*pTocEntry->Count);

                dstOffset += dstToc->InfoSize*dstToc->Count;
            }
            
            dstToc += 1;
        }

        if (!done) 
        {
            dstToc->InfoType = InfoType;
            dstToc->InfoSize = InfoSize;
            dstToc->Count = 1;
            dstToc->Offset = dstOffset;
            memcpy ((PUCHAR)pBlock+dstOffset, NewInfo, InfoSize);
        }
        
        *pNewBlock = pBlock;
        rc = NO_ERROR;
    }
    
    else
    {
        rc = ERROR_NOT_ENOUGH_MEMORY;
    }
    
    return rc;
}



DWORD
UpdateRipFilter (
    IN    PIPX_INFO_BLOCK_HEADER    pOldBlock,
    IN    BOOLEAN                    Output, 
    IN    PRIP_ROUTE_FILTER_INFO    pOldFilter OPTIONAL,
    IN    PRIP_ROUTE_FILTER_INFO    pNewFilter OPTIONAL,
    OUT    PIPX_INFO_BLOCK_HEADER    *pNewBlock
    ) {
    ULONG                    i,j;
    PIPX_TOC_ENTRY            pTocEntry, dstToc;
    PIPX_INFO_BLOCK_HEADER    pBlock;
    ULONG                    newBlockSize = FIELD_OFFSET (IPX_INFO_BLOCK_HEADER, TocEntry);
    BOOLEAN                    found = FALSE;
    PRIP_ROUTE_FILTER_INFO    pRfInfo;
    ULONG                    supplyCount, listenCount, count, newCount;
    PRIP_IF_CONFIG            pRipCfg;
    ULONG                    dstOffset;


    ASSERT (pOldBlock->Version==IPX_ROUTER_VERSION_1);

    for (i=0, pTocEntry = pOldBlock->TocEntry;
            i<pOldBlock->TocEntriesCount;
                i++, pTocEntry++) {
        if (pTocEntry->InfoType == IPX_PROTOCOL_RIP) {
            found = TRUE;
            pRipCfg = (PRIP_IF_CONFIG)((LPBYTE)pOldBlock+pTocEntry->Offset);
            supplyCount = pRipCfg->RipIfFilters.SupplyFilterCount;
            listenCount = pRipCfg->RipIfFilters.ListenFilterCount;

            if (Output) {
                pRfInfo = &pRipCfg->RipIfFilters.RouteFilter[0];
                count = supplyCount;
            }
            else {
                pRfInfo = &pRipCfg->RipIfFilters.RouteFilter[
                                pRipCfg->RipIfFilters.SupplyFilterCount];
                count = listenCount;
            }
            newCount = count;

            if (ARGUMENT_PRESENT (pNewFilter)) {
                for (j=0; j<count; j++) {
                    if (memcmp (&pRfInfo[j],pNewFilter,sizeof (*pNewFilter))==0)
                        return ERROR_ALREADY_EXISTS;
                }
                newBlockSize += sizeof (*pNewFilter);
                newCount += 1;
            }

            if (ARGUMENT_PRESENT (pOldFilter)) {
                for (j=0; j<count; j++) {
                    if (memcmp (&pRfInfo[j],pOldFilter,sizeof (*pOldFilter))==0)
                        break;
                }
                if (j>=count)
                    return ERROR_FILE_NOT_FOUND;
                newBlockSize -= sizeof (*pNewFilter);
                newCount -= 1;
            }
            else
                j = count;

        }

        newBlockSize += sizeof (IPX_TOC_ENTRY)+pTocEntry->InfoSize*pTocEntry->Count;
    }

    if (!found)
        return ERROR_FILE_NOT_FOUND;

    if ((newBlockSize>pOldBlock->Size)
            || !ARGUMENT_PRESENT (pOldFilter)) {
        pBlock = (PIPX_INFO_BLOCK_HEADER)GlobalAlloc (GPTR, newBlockSize);
        if (pBlock==NULL)
            return ERROR_NOT_ENOUGH_MEMORY;
        pBlock->Version = IPX_ROUTER_VERSION_1;
        pBlock->TocEntriesCount = pOldBlock->TocEntriesCount;
        dstToc = pBlock->TocEntry;
    }
    else
        pBlock = pOldBlock;

    dstOffset = FIELD_OFFSET (IPX_INFO_BLOCK_HEADER,
                                TocEntry[pBlock->TocEntriesCount]);
    for (i=0, pTocEntry = pOldBlock->TocEntry;
            i<pOldBlock->TocEntriesCount;
                i++, pTocEntry++, dstToc++) {
        if (pTocEntry->InfoType == IPX_PROTOCOL_RIP) {
            ULONG    curOffset = 
                        FIELD_OFFSET (RIP_IF_CONFIG, RipIfFilters.RouteFilter);
            if (pBlock!=pOldBlock) {
                memcpy ((LPBYTE)pBlock+dstOffset,
                        pRipCfg,
                        curOffset);
            }
            else if (dstOffset!=pTocEntry->Offset) {
                ASSERT (dstOffset<pTocEntry->Offset);
                memmove ((LPBYTE)pBlock+dstOffset,
                        pRipCfg,
                        curOffset);
            }

            if (Output) {
                if (j>0) {
                    if (pBlock!=pOldBlock) {
                        memcpy ((LPBYTE)pBlock+dstOffset+curOffset,
                                            pRfInfo, j*sizeof (pRfInfo[0]));
                    }
                    else if (dstOffset!=pTocEntry->Offset) {
                        ASSERT (dstOffset<pTocEntry->Offset);
                        memmove ((LPBYTE)pBlock+dstOffset+curOffset,
                                            pRfInfo, j*sizeof (pRfInfo[0]));
                    }
                    curOffset += j*sizeof (pRfInfo[0]);
                }
                if (ARGUMENT_PRESENT (pNewFilter)) {
                    memcpy ((LPBYTE)pBlock+dstOffset+curOffset,
                            pNewFilter,
                            sizeof (*pNewFilter));
                    curOffset += sizeof (*pNewFilter);
                }

                if (ARGUMENT_PRESENT (pOldFilter))
                    j += 1;


                if (j<count) {
                    if (pBlock!=pOldBlock) {
                        memcpy ((LPBYTE)pBlock+dstOffset+curOffset,
                                    &pRfInfo[j], (count-j)*sizeof (pRfInfo[0]));
                    }
                    else if ((dstOffset!=pTocEntry->Offset)
                            || !ARGUMENT_PRESENT (pNewFilter)) {
                        ASSERT (dstOffset<pTocEntry->Offset);
                        memmove ((LPBYTE)pBlock+dstOffset+curOffset,
                                    &pRfInfo[j], (count-j)*sizeof (pRfInfo[0]));
                    }
                    curOffset += (count-j)*sizeof (pRfInfo[0]);
                }
                if (pBlock!=pOldBlock) {
                    memcpy ((LPBYTE)pBlock+dstOffset+curOffset,
                            &pRipCfg->RipIfFilters.RouteFilter[supplyCount],
                            listenCount*sizeof (pRipCfg->RipIfFilters.RouteFilter[0]));
                }
                else if ((dstOffset!=pTocEntry->Offset)
                        || !ARGUMENT_PRESENT (pNewFilter)) {
                    memmove ((LPBYTE)pBlock+dstOffset+curOffset,
                            &pRipCfg->RipIfFilters.RouteFilter[supplyCount],
                            listenCount*sizeof (pRipCfg->RipIfFilters.RouteFilter[0]));
                }
                curOffset += listenCount*sizeof (pRipCfg->RipIfFilters.RouteFilter[0]);
                ((PRIP_IF_CONFIG)((LPBYTE)pBlock+dstOffset))->RipIfFilters.SupplyFilterCount = newCount;
                if ((newCount==1) && (count==0))
                    ((PRIP_IF_CONFIG)((LPBYTE)pBlock+dstOffset))->RipIfFilters.SupplyFilterAction = IPX_ROUTE_FILTER_DENY;

            }
            else {
                if (pBlock!=pOldBlock) {
                    memcpy ((LPBYTE)pBlock+dstOffset+curOffset,
                            &pRipCfg->RipIfFilters.RouteFilter[0],
                            supplyCount*sizeof (pRipCfg->RipIfFilters.RouteFilter[0]));
                }
                else if (dstOffset!=pTocEntry->Offset) {
                    ASSERT (dstOffset<pTocEntry->Offset);
                    memmove ((LPBYTE)pBlock+dstOffset+curOffset,
                            &pRipCfg->RipIfFilters.RouteFilter[0],
                            supplyCount*sizeof (pRipCfg->RipIfFilters.RouteFilter[0]));
                }
                curOffset += supplyCount*sizeof (pRipCfg->RipIfFilters.RouteFilter[0]);
                if (j>0) {
                    if (pBlock!=pOldBlock) {
                        memcpy ((LPBYTE)pBlock+dstOffset+curOffset,
                                            pRfInfo, j*sizeof (pRfInfo[0]));
                    }
                    else if (dstOffset!=pTocEntry->Offset) {
                        ASSERT (dstOffset<pTocEntry->Offset);
                        memmove ((LPBYTE)pBlock+dstOffset+curOffset,
                                            pRfInfo, j*sizeof (pRfInfo[0]));
                    }
                    curOffset += j*sizeof (pRfInfo[0]);
                }

                if (ARGUMENT_PRESENT (pNewFilter)) {
                    memcpy ((LPBYTE)pBlock+dstOffset+curOffset,
                            pNewFilter,
                            sizeof (*pNewFilter));
                    curOffset += sizeof (*pNewFilter);
                }

                if (ARGUMENT_PRESENT (pOldFilter))
                    j += 1;

                if (j<count) {
                    if (pBlock!=pOldBlock) {
                        memcpy ((LPBYTE)pBlock+dstOffset+curOffset,
                                    &pRfInfo[j], (count-j)*sizeof (pRfInfo[0]));
                    }
                    else if ((dstOffset!=pTocEntry->Offset)
                                || !ARGUMENT_PRESENT (pNewFilter)) {
                        ASSERT (dstOffset<pTocEntry->Offset);
                        memmove ((LPBYTE)pBlock+dstOffset+curOffset,
                                    &pRfInfo[j], (count-j)*sizeof (pRfInfo[0]));
                    }
                    curOffset += (count-j)*sizeof (pRfInfo[0]);
                }
                ((PRIP_IF_CONFIG)((LPBYTE)pBlock+dstOffset))->RipIfFilters.ListenFilterCount = newCount;
                if ((newCount==1) && (count==0))
                    ((PRIP_IF_CONFIG)((LPBYTE)pBlock+dstOffset))->RipIfFilters.ListenFilterAction = IPX_ROUTE_FILTER_DENY;
            }

            if (pBlock!=pOldBlock) {
                *dstToc = *pTocEntry;
                dstToc->Offset = dstOffset;
                dstToc->InfoSize = curOffset;
            }
            else {
                pTocEntry->Offset = dstOffset;
                pTocEntry->InfoSize = curOffset;
            }

            dstOffset += curOffset;
        }
        else {
            if (pBlock!=pOldBlock) {
                memcpy ((PUCHAR)pBlock+dstOffset,
                    (PUCHAR)pOldBlock+pTocEntry->Offset,
                    pTocEntry->InfoSize*pTocEntry->Count);
                *dstToc = *pTocEntry;
                dstToc->Offset = dstOffset;
            }
            else if (dstOffset!=pTocEntry->Offset) {
                ASSERT (dstOffset<pTocEntry->Offset);
                memmove ((PUCHAR)pBlock+dstOffset,
                    (PUCHAR)pOldBlock+pTocEntry->Offset,
                    pTocEntry->InfoSize*pTocEntry->Count);
                pTocEntry->Offset = dstOffset;
            }
            dstOffset += pTocEntry->InfoSize*pTocEntry->Count;
        }
    }

    pBlock->Size = newBlockSize;
    *pNewBlock = pBlock;
    return NO_ERROR;
}



DWORD
UpdateSapFilter (
    IN    PIPX_INFO_BLOCK_HEADER        pOldBlock,
    IN    BOOLEAN                        Output, 
    IN    PSAP_SERVICE_FILTER_INFO    pOldFilter OPTIONAL,
    IN    PSAP_SERVICE_FILTER_INFO    pNewFilter OPTIONAL,
    OUT    PIPX_INFO_BLOCK_HEADER        *pNewBlock
    ) {
    ULONG                        i,j;
    PIPX_TOC_ENTRY                pTocEntry, dstToc;
    PIPX_INFO_BLOCK_HEADER        pBlock;
    ULONG                        newBlockSize = FIELD_OFFSET (IPX_INFO_BLOCK_HEADER, TocEntry);
    BOOLEAN                        found = FALSE;
    PSAP_SERVICE_FILTER_INFO    pSfInfo;
    ULONG                        supplyCount, listenCount, count, newCount;
    PSAP_IF_CONFIG                pSapCfg;
    ULONG                        dstOffset;


    ASSERT (pOldBlock->Version==IPX_ROUTER_VERSION_1);

    for (i=0, pTocEntry = pOldBlock->TocEntry;
            i<pOldBlock->TocEntriesCount;
                i++, pTocEntry++) {
        if (pTocEntry->InfoType == IPX_PROTOCOL_SAP) {
            found = TRUE;
            pSapCfg = (PSAP_IF_CONFIG)((LPBYTE)pOldBlock+pTocEntry->Offset);
            supplyCount = pSapCfg->SapIfFilters.SupplyFilterCount;
            listenCount = pSapCfg->SapIfFilters.ListenFilterCount;

            if (Output) {
                pSfInfo = &pSapCfg->SapIfFilters.ServiceFilter[0];
                count = supplyCount;
            }
            else {
                pSfInfo = &pSapCfg->SapIfFilters.ServiceFilter[
                                pSapCfg->SapIfFilters.SupplyFilterCount];
                count = listenCount;
            }
            newCount = count;

            if (ARGUMENT_PRESENT (pNewFilter)) {
                for (j=0; j<count; j++) {
                    if ((pSfInfo[j].ServiceType==pNewFilter->ServiceType)
                            && (strncmp ((LPSTR)pSfInfo[j].ServiceName, 
                                    (LPSTR)pNewFilter->ServiceName,
                                    sizeof (pNewFilter->ServiceName))==0))
                        break;
                }
                if (j<count)
                    return ERROR_CAN_NOT_COMPLETE;
                newBlockSize += sizeof (*pNewFilter);
                newCount += 1;
            }

            if (ARGUMENT_PRESENT (pOldFilter)) {
                for (j=0; j<count; j++) {
                    if ((pSfInfo[j].ServiceType==pOldFilter->ServiceType)
                            && (strncmp ((LPSTR)pSfInfo[j].ServiceName, 
                                    (LPSTR)pOldFilter->ServiceName,
                                    sizeof (pOldFilter->ServiceName))==0))
                        break;
                }
                if (j>=count)
                    return ERROR_CAN_NOT_COMPLETE;
                newBlockSize -= sizeof (*pNewFilter);
                newCount -= 1;
            }
            else
                j = count;
        }

        newBlockSize += sizeof (IPX_TOC_ENTRY)+pTocEntry->InfoSize*pTocEntry->Count;
    }

    if (!found)
        return ERROR_CAN_NOT_COMPLETE;

    if ((newBlockSize>pOldBlock->Size)
            || !ARGUMENT_PRESENT (pOldFilter)) {
        pBlock = (PIPX_INFO_BLOCK_HEADER)GlobalAlloc (GPTR, newBlockSize);
        if (pBlock==NULL)
            return ERROR_NOT_ENOUGH_MEMORY;
        pBlock->Version = IPX_ROUTER_VERSION_1;
        pBlock->TocEntriesCount = pOldBlock->TocEntriesCount;
        dstToc = pBlock->TocEntry;
    }
    else
        pBlock = pOldBlock;

    dstOffset = FIELD_OFFSET (IPX_INFO_BLOCK_HEADER,
                                TocEntry[pBlock->TocEntriesCount]);
    for (i=0, pTocEntry = pOldBlock->TocEntry;
            i<pOldBlock->TocEntriesCount;
                i++, pTocEntry++, dstToc++) {
        if (pTocEntry->InfoType == IPX_PROTOCOL_SAP) {
            ULONG    curOffset = 
                        FIELD_OFFSET (SAP_IF_CONFIG, SapIfFilters.ServiceFilter);
            if (pBlock!=pOldBlock) {
                memcpy ((LPBYTE)pBlock+dstOffset,
                        pSapCfg,
                        curOffset);
            }
            else if (dstOffset!=pTocEntry->Offset) {
                ASSERT (dstOffset<pTocEntry->Offset);
                memmove ((LPBYTE)pBlock+dstOffset,
                        pSapCfg,
                        curOffset);
            }


            if (Output) {
                if (j>0) {
                    if (pBlock!=pOldBlock) {
                        memcpy ((LPBYTE)pBlock+dstOffset+curOffset,
                                        pSfInfo, j*sizeof (pSfInfo[0]));
                    }
                    else if (dstOffset!=pTocEntry->Offset) {
                        ASSERT (dstOffset<pTocEntry->Offset);
                        memmove ((LPBYTE)pBlock+dstOffset+curOffset,
                                        pSfInfo, j*sizeof (pSfInfo[0]));
                    }
                    curOffset += j*sizeof (pSfInfo[0]);
                }
                if (ARGUMENT_PRESENT (pNewFilter)) {
                    memcpy ((LPBYTE)pBlock+dstOffset+curOffset,
                            pNewFilter,
                            sizeof (*pNewFilter));
                    curOffset += sizeof (*pNewFilter);
                }

                if (ARGUMENT_PRESENT (pOldFilter))
                    j += 1;


                if (j<count) {
                    if (pBlock!=pOldBlock) {
                        memcpy ((LPBYTE)pBlock+dstOffset+curOffset,
                                    &pSfInfo[j], (count-j)*sizeof (pSfInfo[0]));
                    }
                    else if ((dstOffset!=pTocEntry->Offset)
                            || !ARGUMENT_PRESENT (pNewFilter)) {
                        ASSERT (dstOffset<pTocEntry->Offset);
                        memmove ((LPBYTE)pBlock+dstOffset+curOffset,
                                    &pSfInfo[j], (count-j)*sizeof (pSfInfo[0]));
                    }
                    curOffset += (count-j)*sizeof (pSfInfo[0]);
                }
                if (pBlock!=pOldBlock) {
                    memcpy ((LPBYTE)pBlock+dstOffset+curOffset,
                            &pSapCfg->SapIfFilters.ServiceFilter[supplyCount],
                            listenCount*sizeof (pSapCfg->SapIfFilters.ServiceFilter[0]));
                }
                else if ((dstOffset!=pTocEntry->Offset)
                        || !ARGUMENT_PRESENT (pNewFilter)) {
                    ASSERT (dstOffset<pTocEntry->Offset);
                    memmove ((LPBYTE)pBlock+dstOffset+curOffset,
                            &pSapCfg->SapIfFilters.ServiceFilter[supplyCount],
                            listenCount*sizeof (pSapCfg->SapIfFilters.ServiceFilter[0]));
                }
                curOffset += listenCount*sizeof (pSapCfg->SapIfFilters.ServiceFilter[0]);
                ((PSAP_IF_CONFIG)((LPBYTE)pBlock+dstOffset))->SapIfFilters.SupplyFilterCount = newCount;
                if ((newCount==1) && (count==0))
                    ((PSAP_IF_CONFIG)((LPBYTE)pBlock+dstOffset))->SapIfFilters.SupplyFilterAction = IPX_SERVICE_FILTER_DENY;
            }
            else {
                if (pBlock!=pOldBlock) {
                    memcpy ((LPBYTE)pBlock+dstOffset+curOffset,
                            &pSapCfg->SapIfFilters.ServiceFilter[0],
                            supplyCount*sizeof (pSapCfg->SapIfFilters.ServiceFilter[0]));
                }
                else if (dstOffset!=pTocEntry->Offset) {
                    ASSERT (dstOffset<pTocEntry->Offset);
                    memmove ((LPBYTE)pBlock+dstOffset+curOffset,
                            &pSapCfg->SapIfFilters.ServiceFilter[0],
                            supplyCount*sizeof (pSapCfg->SapIfFilters.ServiceFilter[0]));
                }
                curOffset += supplyCount*sizeof (pSapCfg->SapIfFilters.ServiceFilter[0]);
                if (j>0) {
                    if (pBlock!=pOldBlock) {
                        memcpy ((LPBYTE)pBlock+dstOffset+curOffset,
                                        pSfInfo, j*sizeof (pSfInfo[0]));
                    }
                    else if (dstOffset!=pTocEntry->Offset) {
                        ASSERT (dstOffset<pTocEntry->Offset);
                        memmove ((LPBYTE)pBlock+dstOffset+curOffset,
                                        pSfInfo, j*sizeof (pSfInfo[0]));
                    }
                    curOffset += j*sizeof (pSfInfo[0]);
                }

                if (ARGUMENT_PRESENT (pNewFilter)) {
                    memcpy ((LPBYTE)pBlock+dstOffset+curOffset,
                            pNewFilter,
                            sizeof (*pNewFilter));
                    curOffset += sizeof (*pNewFilter);
                }

                if (ARGUMENT_PRESENT (pOldFilter))
                    j += 1;

                if (j<count) {
                    if (pBlock!=pOldBlock) {
                        memcpy ((LPBYTE)pBlock+dstOffset+curOffset,
                                    &pSfInfo[j], (count-j)*sizeof (pSfInfo[0]));
                    }
                    else if ((dstOffset!=pTocEntry->Offset)
                            || !ARGUMENT_PRESENT (pNewFilter)) {
                        ASSERT (dstOffset<pTocEntry->Offset);
                        memmove ((LPBYTE)pBlock+dstOffset+curOffset,
                                    &pSfInfo[j], (count-j)*sizeof (pSfInfo[0]));
                    }
                    curOffset += (count-j)*sizeof (pSfInfo[0]);
                }
                ((PSAP_IF_CONFIG)((LPBYTE)pBlock+dstOffset))->SapIfFilters.ListenFilterCount = newCount;
                if ((newCount==1) && (count==0))
                    ((PSAP_IF_CONFIG)((LPBYTE)pBlock+dstOffset))->SapIfFilters.ListenFilterAction = IPX_SERVICE_FILTER_DENY;
            }

            if (pBlock!=pOldBlock) {
                *dstToc = *pTocEntry;
                dstToc->Offset = dstOffset;
                dstToc->InfoSize = curOffset;
            }
            else {
                pTocEntry->Offset = dstOffset;
                pTocEntry->InfoSize = curOffset;
            }

            dstOffset += curOffset;
        }
        else {
            if (pBlock!=pOldBlock) {
                memcpy ((PUCHAR)pBlock+dstOffset,
                    (PUCHAR)pOldBlock+pTocEntry->Offset,
                    pTocEntry->InfoSize*pTocEntry->Count);
                *dstToc = *pTocEntry;
                dstToc->Offset = dstOffset;
            }
            else if (dstOffset!=pTocEntry->Offset) {
                ASSERT (dstOffset<pTocEntry->Offset);
                memmove ((PUCHAR)pBlock+dstOffset,
                    (PUCHAR)pOldBlock+pTocEntry->Offset,
                    pTocEntry->InfoSize*pTocEntry->Count);
                pTocEntry->Offset = dstOffset;
            }
            dstOffset += pTocEntry->InfoSize*pTocEntry->Count;
        }
    }

    pBlock->Size = newBlockSize;
    *pNewBlock = pBlock;
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ipx\ipxmon\ipxutil.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    utils.h

Abstract:

    IPX Router Console Monitoring and Configuration tool.
    Utility routines. Header File

Author:

    V Raman         12/15/1998


--*/
#ifndef _IPXMON_UTILS_
#define _IPXMON_UTILS_

extern TOKEN_VALUE InterfaceTypes[5];
extern TOKEN_VALUE InterfaceStates[3];
extern TOKEN_VALUE InterfaceEnableStatus[2];

extern TOKEN_VALUE AdminStates[2];
extern TOKEN_VALUE OperStates[3];
extern TOKEN_VALUE IpxInterfaceTypes[8];
extern TOKEN_VALUE RouterInterfaceTypes[5];
extern TOKEN_VALUE NbDeliverStates[4];
extern TOKEN_VALUE UpdateModes[3];
extern TOKEN_VALUE IpxProtocols[4];
extern TOKEN_VALUE TfFilterActions[2];
extern TOKEN_VALUE WANProtocols[2];
extern TOKEN_VALUE FilterModes[2];
extern TOKEN_VALUE LogLevels[4];

#define INPUT_FILTER    1
#define OUTPUT_FILTER   2

//
// This will be removed when the router is modified to use MprInfo api's
//

typedef RTR_INFO_BLOCK_HEADER IPX_INFO_BLOCK_HEADER, *PIPX_INFO_BLOCK_HEADER;
typedef RTR_TOC_ENTRY IPX_TOC_ENTRY, *PIPX_TOC_ENTRY;


DWORD
GetIpxInterfaceIndex (
    IN      MIB_SERVER_HANDLE       hRouterMIB,
    IN      LPCWSTR                 InterfaceName,
    OUT     ULONG                  *InterfaceIndex
    );

DWORD
GetIpxInterfaceName (
    IN     MIB_SERVER_HANDLE       hRouterMIB,
    IN     ULONG                   InterfaceIndex,
    OUT    LPWSTR                  InterfaceName
    );

PIPX_TOC_ENTRY
GetIPXTocEntry (
    IN      PIPX_INFO_BLOCK_HEADER  pInterfaceInfo,
    IN      ULONG                   InfoEntryType
    );


typedef BOOL (*PINFO_CMP_PROC) (PVOID Info1, PVOID Info2);


DWORD
AddIPXInfoEntry (
    IN      PIPX_INFO_BLOCK_HEADER  pOldBlock,
    IN      ULONG                   InfoType,
    IN      ULONG                   InfoSize,
    IN      PVOID                   Info,
    IN      PINFO_CMP_PROC          InfoEqualCB OPTIONAL,
        OUT PIPX_INFO_BLOCK_HEADER *pNewBlock
    );

DWORD
DeleteIPXInfoEntry (
    IN      PIPX_INFO_BLOCK_HEADER  pOldBlock,
    IN      ULONG                   InfoType,
    IN      ULONG                   InfoSize,
    IN      PVOID                   Info,
    IN      PINFO_CMP_PROC          InfoEqualCB OPTIONAL,
    IN      PIPX_INFO_BLOCK_HEADER *pNewBlock
    );

DWORD
UpdateIPXInfoEntry (
    IN      PIPX_INFO_BLOCK_HEADER  pOldBlock,
    IN      ULONG                   InfoType,
    IN      ULONG                   InfoSize,
    IN      PVOID                   OldInfo    OPTIONAL,
    IN      PVOID                   NewInfo,
    IN      PINFO_CMP_PROC          InfoEqualCB OPTIONAL,
    OUT     PIPX_INFO_BLOCK_HEADER *pNewBlock
    );

DWORD
UpdateRipFilter (
    IN      PIPX_INFO_BLOCK_HEADER  pOldBlock,
    IN      BOOLEAN                 Output, 
    IN      PRIP_ROUTE_FILTER_INFO  pOldFilter OPTIONAL,
    IN      PRIP_ROUTE_FILTER_INFO  pNewFilter OPTIONAL,
    OUT     PIPX_INFO_BLOCK_HEADER *pNewBlock
    );

DWORD
UpdateSapFilter (
    IN      PIPX_INFO_BLOCK_HEADER  pOldBlock,
    IN      BOOLEAN                 Output, 
    IN      PSAP_SERVICE_FILTER_INFO pOldFilter OPTIONAL,
    IN      PSAP_SERVICE_FILTER_INFO pNewFilter OPTIONAL,
    OUT     PIPX_INFO_BLOCK_HEADER *pNewBlock
    );

#define DisplayIPXMessage DisplayMessageM

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ipx\ipxmon\ipxmontr.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    routing\netsh\ipx\ipxmon\ipxmon.c

Abstract:

    IPX Command dispatcher.

Revision History:

    V Raman                     11/25/98  Created

--*/

#include "precomp.h"
#pragma hdrstop

//
// Guid for IPMON.DLL
//
// {b1641451-84b8-11d2-b940-3078302c2030}
//

static const GUID g_MyGuid = IPXMONTR_GUID;


//
// Well known ROUTING guid
//

static const GUID g_RoutingGuid = ROUTING_GUID;

//
// IPX monitor version
//

#define IPX_HELPER_VERSION 1

//
// random wrapper macros
//

#define MALLOC(x)    HeapAlloc( GetProcessHeap(), 0, x )
#define REALLOC(x,y) HeapReAlloc( GetProcessHeap(), 0, x, y )
#define FREE(x)      HeapFree( GetProcessHeap(), 0, x )

//
// The table of Add, Delete, Set and Show Commands for IPX RTR MGR
// To add a command to one of the command groups, just add the
// CMD_ENTRY to the correct table. To add a new cmd group, create its
// cmd table and then add the group entry to group table
//

//
// The commands are prefix-matched with the command-line, in sequential
// order. So a command like 'ADD INTERFACE FILTER' must come before
// the command 'ADD INTERFACE' in the table.  Likewise,
// a command like 'ADD ROUTE' must come before the command 
// 'ADD ROUTEPREF' in the table.
//

CMD_ENTRY  g_IpxAddCmdTable[] = 
{
    CREATE_CMD_ENTRY( IPX_ADD_ROUTE,        HandleIpxAddRoute),
    CREATE_CMD_ENTRY( IPX_ADD_SERVICE,      HandleIpxAddService ),
    CREATE_CMD_ENTRY( IPX_ADD_FILTER,       HandleIpxAddFilter ),
    CREATE_CMD_ENTRY( IPX_ADD_INTERFACE,    HandleIpxAddInterface )
};


CMD_ENTRY  g_IpxDelCmdTable[] = 
{
    CREATE_CMD_ENTRY( IPX_DELETE_ROUTE,     HandleIpxDelRoute ),
    CREATE_CMD_ENTRY( IPX_DELETE_SERVICE,   HandleIpxDelService ),
    CREATE_CMD_ENTRY( IPX_DELETE_FILTER,    HandleIpxDelFilter ),
    CREATE_CMD_ENTRY( IPX_DELETE_INTERFACE, HandleIpxDelInterface )
};


CMD_ENTRY g_IpxSetCmdTable[] = 
{
    CREATE_CMD_ENTRY( IPX_SET_ROUTE,        HandleIpxSetRoute ),
    CREATE_CMD_ENTRY( IPX_SET_SERVICE,      HandleIpxSetService ),
    CREATE_CMD_ENTRY( IPX_SET_FILTER,       HandleIpxSetFilter ),
    CREATE_CMD_ENTRY( IPX_SET_INTERFACE,    HandleIpxSetInterface ),
    CREATE_CMD_ENTRY( IPX_SET_GLOBAL,       HandleIpxSetLoglevel )
};


CMD_ENTRY g_IpxShowCmdTable[] = 
{
    CREATE_CMD_ENTRY( IPX_SHOW_ROUTE,       HandleIpxShowRoute ),
    CREATE_CMD_ENTRY( IPX_SHOW_SERVICE,     HandleIpxShowService),
    CREATE_CMD_ENTRY( IPX_SHOW_FILTER,      HandleIpxShowFilter ),
    CREATE_CMD_ENTRY( IPX_SHOW_INTERFACE,   HandleIpxShowInterface ),
    CREATE_CMD_ENTRY( IPX_SHOW_GLOBAL,      HandleIpxShowLoglevel ),
    CREATE_CMD_ENTRY( IPX_SHOW_ROUTETABLE,  HandleIpxShowRouteTable ),
    CREATE_CMD_ENTRY( IPX_SHOW_SERVICETABLE,HandleIpxShowServiceTable ),
};


CMD_GROUP_ENTRY g_IpxCmdGroups[] = 
{
    CREATE_CMD_GROUP_ENTRY( GROUP_ADD,      g_IpxAddCmdTable ),
    CREATE_CMD_GROUP_ENTRY( GROUP_DELETE,   g_IpxDelCmdTable ),
    CREATE_CMD_GROUP_ENTRY( GROUP_SET,      g_IpxSetCmdTable ),
    CREATE_CMD_GROUP_ENTRY( GROUP_SHOW,     g_IpxShowCmdTable )
};

ULONG   g_ulNumGroups = sizeof(g_IpxCmdGroups)/sizeof(CMD_GROUP_ENTRY);



//
// Top level commands
//

CMD_ENTRY g_IpxCmds[] = 
{
    CREATE_CMD_ENTRY( IPX_UPDATE,   HandleIpxUpdate )
};

ULONG g_ulNumTopCmds = sizeof(g_IpxCmds)/sizeof(CMD_ENTRY);

//
// Handle to this DLL
//

HANDLE g_hModule;


//
// Handle to router being administered
//

HANDLE g_hMprConfig;
HANDLE g_hMprAdmin;
HANDLE g_hMIBServer;


//
// Commit mode
//

BOOL   g_bCommit;

DWORD                  ParentVersion;
BOOL                   g_bIpxDirty = FALSE;
NS_CONTEXT_CONNECT_FN  IpxConnect;
NS_CONTEXT_SUBENTRY_FN IpxSubEntry;

//
// Variable that stores whether or not the helper has been
// initialized
//

ULONG   g_ulInitCount;


//
// Router name
//

PWCHAR  g_pwszRouter = NULL;


//
// Prototype declarations for functions in this file
//

DWORD
WINAPI
IpxUnInit(
    IN  DWORD   dwReserved
    );

BOOL
IsHelpToken(
    PWCHAR  pwszToken
    );
    

BOOL
IA64VersionCheck
(
    IN  UINT     CIMOSType,                   // WMI: Win32_OperatingSystem  OSType
	IN  UINT     CIMOSProductSuite,           // WMI: Win32_OperatingSystem  OSProductSuite
    IN  LPCWSTR  CIMOSVersion,                // WMI: Win32_OperatingSystem  Version
    IN  LPCWSTR  CIMOSBuildNumber,            // WMI: Win32_OperatingSystem  BuildNumber
    IN  LPCWSTR  CIMServicePackMajorVersion,  // WMI: Win32_OperatingSystem  ServicePackMajorVersion
    IN  LPCWSTR  CIMServicePackMinorVersion,  // WMI: Win32_OperatingSystem  ServicePackMinorVersion
	IN  UINT     CIMProcessorArchitecture,    // WMI: Win32_Processor        Architecture
	IN  DWORD    dwReserved
)
{
    if (CIMProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL) // IA64=6 (x86 == 0)
        return TRUE;
    else
        return FALSE;
}



DWORD
WINAPI
IpxStartHelper(
    IN CONST GUID *pguidParent,
    IN DWORD       dwVersion
    )
/*++

Routine Description :

    Registers the contexts supported by this helper 

Arguements :

    pguidParent - NETSH guid

Return value :

    Don't know

--*/
{
    DWORD dwErr;
    NS_CONTEXT_ATTRIBUTES attMyAttributes;
    PNS_PRIV_CONTEXT_ATTRIBUTES  pNsPrivContextAttributes;

    pNsPrivContextAttributes = MALLOC(sizeof(NS_PRIV_CONTEXT_ATTRIBUTES));
    if (!pNsPrivContextAttributes)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    
    ParentVersion         = dwVersion;

    ZeroMemory( &attMyAttributes, sizeof(NS_CONTEXT_ATTRIBUTES));
    ZeroMemory(pNsPrivContextAttributes, sizeof(NS_PRIV_CONTEXT_ATTRIBUTES));
    
    attMyAttributes.pwszContext = L"ipx";
    attMyAttributes.guidHelper  = g_MyGuid;
    attMyAttributes.dwVersion   = 1;
    attMyAttributes.dwFlags     = 0;
    attMyAttributes.ulNumTopCmds  = g_ulNumTopCmds;
    attMyAttributes.pTopCmds      = (CMD_ENTRY (*)[])&g_IpxCmds;
    attMyAttributes.ulNumGroups   = g_ulNumGroups;
    attMyAttributes.pCmdGroups    = (CMD_GROUP_ENTRY (*)[])&g_IpxCmdGroups;
    attMyAttributes.pfnCommitFn = NULL;
    attMyAttributes.pfnDumpFn   = IpxDump;
    attMyAttributes.pfnConnectFn= IpxConnect;
    attMyAttributes.pfnOsVersionCheck = IA64VersionCheck;

    pNsPrivContextAttributes->pfnEntryFn    = NULL;
    pNsPrivContextAttributes->pfnSubEntryFn = IpxSubEntry;
    attMyAttributes.pReserved     = pNsPrivContextAttributes;

    dwErr = RegisterContext( &attMyAttributes );

    return dwErr;
}


DWORD
WINAPI
InitHelperDll(
    IN  DWORD               dwNetshVersion,
    OUT PNS_DLL_ATTRIBUTES  pDllTable
    )
/*++

Routine Description :

    initialize this helper DLL

    
Arguements :

    pUtilityTable - List of helper functions from the SHELL

    pDllTable - Callbacks into this helper DLL passed back to the shell

    
Return value :

    NO_ERROR - Success
    
--*/
{
    DWORD                   dwErr;
    NS_HELPER_ATTRIBUTES    attMyAttributes;


    //
    // See if this is the first time we are being called
    //

    if ( InterlockedIncrement( &g_ulInitCount ) isnot 1 )
    {
        return NO_ERROR;
    }


    //
    // Connect to router config.  Also serves as a check to
    // see if the router is configured on the machine
    //
    
    dwErr = MprConfigServerConnect( NULL, &g_hMprConfig );

    if( dwErr isnot NO_ERROR )
    {
        DisplayError( NULL, dwErr );

        return dwErr;
    }

    pDllTable->dwVersion        = NETSH_VERSION_50;
    pDllTable->pfnStopFn        = StopHelperDll;


    //
    // Register helpers
    //
    
    ZeroMemory( &attMyAttributes, sizeof(attMyAttributes) );
    attMyAttributes.guidHelper         = g_MyGuid;
    attMyAttributes.dwVersion          = IPX_HELPER_VERSION;
    attMyAttributes.pfnStart           = IpxStartHelper;
    attMyAttributes.pfnStop            = NULL;

    RegisterHelper( &g_RoutingGuid, &attMyAttributes );

    return NO_ERROR;
}


DWORD
WINAPI
StopHelperDll(
    IN  DWORD   dwReserved
    )
/*++

Routine Description :

Arguements :

Return value :

--*/
{
    if ( InterlockedDecrement( &g_ulInitCount ) isnot 0 )
    {
        return NO_ERROR;
    }
    
#if 0
    IpxCommit(NETSH_FLUSH);
#endif
   
    return NO_ERROR;
}



BOOL 
WINAPI
IpxDllEntry(
    HINSTANCE   hInstDll,
    DWORD       fdwReason,
    LPVOID      pReserved
    )
/*++

Routine Description :

Arguements :

Return value :

--*/
{

    switch (fdwReason)
    {
        case DLL_PROCESS_ATTACH:
        {
            g_hModule = hInstDll;

            DisableThreadLibraryCalls(hInstDll);

            break;
        }
        case DLL_PROCESS_DETACH:
        {
            
            break;
        }

        default:
        {
            break;
        }
    }

    return TRUE;
}

DWORD 
ConnectToRouter(
    IN  LPCWSTR  pwszRouter
    )
{
    DWORD    rc, dwErr;

    if (g_pwszRouter != pwszRouter)
    {
        if (g_hMprConfig)
        {
            MprConfigServerDisconnect(g_hMprConfig);
            g_hMprConfig = NULL;
        }

        if (g_hMprAdmin)
        {
            MprAdminServerDisconnect(g_hMprAdmin);
            g_hMprAdmin = NULL;
        }

        if (g_hMIBServer)
        {
            MprAdminMIBServerDisconnect(g_hMIBServer);
            g_hMIBServer = NULL;
        }
    }

    //
    // Connect to router config if required 
    // (when is this ever required)
    //
    
    if ( !g_hMprConfig )
    {
        dwErr = MprConfigServerConnect( (LPWSTR)pwszRouter, &g_hMprConfig );

        if ( dwErr isnot NO_ERROR )
        {
            return ERROR_CONNECT_REMOTE_CONFIG;
        }
    }


    //
    // Check to see if router is running. If so, get the handles
    //

    do
    {
        if ( MprAdminIsServiceRunning( (LPWSTR)pwszRouter ) )
        {
            if ( MprAdminServerConnect( (LPWSTR)pwszRouter, &g_hMprAdmin ) == 
                    NO_ERROR )
            {
                if ( MprAdminMIBServerConnect( (LPWSTR)pwszRouter, &g_hMIBServer ) ==
                        NO_ERROR )
                {
                    // DEBUG("Got server handle");
                    break;
                }
                
                else
                {
                    MprAdminServerDisconnect( g_hMprAdmin );
                }
            }
        }
        
        g_hMprAdmin = g_hMIBServer = NULL;
        
    } while (FALSE);

    return NO_ERROR;
}

DWORD WINAPI
IpxConnect(
    IN  LPCWSTR  pwszRouter
    )
{
    // If context info is dirty, reregister it
    if (g_bIpxDirty)
    {
        IpxStartHelper(NULL, ParentVersion);
    }

    return ConnectToRouter(pwszRouter);
}

BOOL
IsHelpToken(
    PWCHAR  pwszToken
    )
/*++

Routine Description :

Arguements :

Return value :

--*/
{
    if( MatchToken( pwszToken, CMD_IPX_HELP1 ) )
    {
        return TRUE;
    }
    
    if( MatchToken( pwszToken, CMD_IPX_HELP2 ) )
    {
        return TRUE;
    }
    
    return FALSE;
}


BOOL
IsReservedKeyWord(
    PWCHAR  pwszToken
    )
/*++

Routine Description :

Arguements :

Return value :

--*/
{
    return FALSE;
}



DWORD
MungeArguments(
    IN OUT  LPWSTR     *ppwcArguments,
    IN      DWORD       dwArgCount,
    OUT     PBYTE      *ppbNewArg,
    OUT     PDWORD      pdwNewArgCount,
    OUT     PBOOL       pbFreeArg
    )
/*++

Routine Description :

    To conform to the routemon style of command line, the netsh command line
    is munged.  Munging involves adding a space after the '=' for each 
    "Option=Value" pair on the command line to convert it to "Option= Value".

    In addition, the first command line arguement is set to the process name
    "netsh" and all the remaining arguements are shifted one down.  Again
    for conformance reasons.
    
Arguements :

    ppwcArguments - Current argument list

    dwArgCount - Number of args in ppwcArguments

    pbNewArg - Pointer to a buffer that will contain the munged arglist

    pdwNewArgCount - New argument count after munging

    pbFreeArg - TRUE if pbNewArg needs to be freed by the invoker.
    

Return value :

    NO_ERROR - Success

    ERROR_NOT_ENOUGH_MEMORY - Memory alloc failed

--*/
{

    DWORD   dwIndex, dwInd, dwErr;

    BOOL    bPresent = FALSE;

    PWCHAR  *ppwcArgs;

    
    
    *pbFreeArg = FALSE;


    //
    // Scan arguement list to see if any are of the form "Option=Value"
    //

    for ( dwIndex = 0; dwIndex < dwArgCount; dwIndex++ )
    {
        if ( wcsstr( ppwcArguments[ dwIndex ], NETSH_ARG_DELIMITER ) )
        {
            //
            // there is an = in this arguement
            //

            bPresent = TRUE;

            break;
        }
    }
    

    //
    // if none of the args have an '=', then return the arg. list as is
    //

    if ( !bPresent )
    {
        *ppbNewArg = (PBYTE) ppwcArguments;

        return NO_ERROR;
    }

    

    //
    // Args. of the form "option=value" are present
    //

    ppwcArgs = (PWCHAR *) HeapAlloc( 
                            GetProcessHeap(), 0, 2 * dwArgCount * sizeof( PWCHAR )
                            );

    if ( ppwcArgs == NULL )
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }


    ZeroMemory( ppwcArgs, 2 * dwArgCount * sizeof( PWCHAR ) );

    
    //
    // Copy args that do not have an '=' as is
    //

    for ( dwInd = 0; dwInd < dwIndex; dwInd++ )
    {
        DWORD dwLen =  ( wcslen( ppwcArguments[ dwInd ] ) + 1 ) * sizeof( WCHAR );
        
        ppwcArgs[ dwInd ] = (PWCHAR) HeapAlloc(
                                        GetProcessHeap(), 0, 
                                        ( wcslen( ppwcArguments[ dwInd ] ) + 1 )
                                        * sizeof( WCHAR )
                                        );

        if ( ppwcArgs[ dwInd ] == NULL )
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;

            goto cleanup;
        }

        wcscpy( ppwcArgs[ dwInd ], ppwcArguments[ dwInd ] );
    }


    //
    // Convert args. of the form "option=value" to the form "option= value".  
    // The space is what its all about
    //

    for ( dwInd = dwIndex; dwIndex < dwArgCount; dwInd++, dwIndex++ )
    {
        //
        // Check if this arg. has an '=' sign
        //

        if ( wcsstr( ppwcArguments[ dwIndex ], NETSH_ARG_DELIMITER ) )
        {
            //
            // arg is of the form "option=value" 
            //
            // break it into 2 arguments of the form
            //  arg(i) == option=
            //  argv(i+1) == value
            //

            PWCHAR  pw1, pw2;

            DWORD dwLen;

            
            pw1 = wcstok( ppwcArguments[ dwIndex ], NETSH_ARG_DELIMITER );

            pw2 = wcstok( NULL, NETSH_ARG_DELIMITER );

            dwLen = ( wcslen( pw1 ) + 2 ) * sizeof( WCHAR );
            
            dwLen = ( wcslen( pw2 ) + 1 ) * sizeof( WCHAR );
            
            
            ppwcArgs[ dwInd ] = (PWCHAR) HeapAlloc( 
                                            GetProcessHeap(), 0,
                                            ( wcslen( pw1 ) + 2 ) * sizeof( WCHAR )
                                            );

            ppwcArgs[ dwInd + 1] = (PWCHAR) HeapAlloc( 
                                                GetProcessHeap(), 0,
                                                ( wcslen( pw2 ) + 1 ) * sizeof( WCHAR )
                                                );


            if ( ( ppwcArgs[ dwInd ] == NULL ) ||
                 ( ppwcArgs[ dwInd + 1 ] == NULL ) )

            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;

                goto cleanup;
            }

            wcscpy( ppwcArgs[ dwInd ], pw1 );

            wcscat( ppwcArgs[ dwInd++ ], NETSH_ARG_DELIMITER );

            wcscpy( ppwcArgs[ dwInd ], pw2 );

            (*pdwNewArgCount)++;
        }

        else
        {
            //
            // no = in this arg, copy as is
            //

            ppwcArgs[ dwInd ] = (PWCHAR) HeapAlloc( 
                                            GetProcessHeap(), 0,
                                            ( wcslen( ppwcArguments[ dwIndex ] ) + 1 )
                                            * sizeof( WCHAR )
                                            );
                                            
            if ( ppwcArgs[ dwInd ] == NULL )

            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;

                goto cleanup;
            }

            wcscpy( ppwcArgs[ dwInd ], ppwcArguments[ dwIndex ] );
        }
    }

    *pbFreeArg = TRUE;

    *ppbNewArg = (PBYTE) ppwcArgs;

    return NO_ERROR;



cleanup :

    //
    // Error.  Free all allocations
    //
    
    for ( dwInd = 0; dwInd < 2 * dwArgCount; dwInd++ )
    {
        if ( ppwcArgs[ dwInd ] )
        {
            HeapFree( GetProcessHeap(), 0, ppwcArgs[ dwInd ] );
        }
    }

    if ( ppwcArgs )
    {
        HeapFree( GetProcessHeap(), 0, ppwcArgs );
    }

    return dwErr;
}


VOID
FreeArgTable(
    IN     DWORD     dwArgCount,
    IN OUT LPWSTR   *ppwcArgs
    )
/*++

Routine Description :

    Frees the allocations for the argument table
    
Arguments :

    dwArgCount - number of arguments in ppwcArguments
    ppwcArgs - Table of arguments

Return Value :
    
--*/
{
    DWORD dwInd;

    for ( dwInd = 0; dwInd < 2 * dwArgCount; dwInd++ )
    {
        if ( ppwcArgs[ dwInd ] )
        {
            HeapFree( GetProcessHeap(), 0, ppwcArgs[ dwInd ] );
        }
    }

    if ( ppwcArgs )
    {
        HeapFree( GetProcessHeap(), 0, ppwcArgs );
    }
}

DWORD
GetTagToken(
    IN      HANDLE      hModule,
    IN OUT  LPWSTR     *ppwcArguments,
    IN      DWORD       dwCurrentIndex,
    IN      DWORD       dwArgCount,
    IN      PTAG_TYPE   pttTagToken,
    IN      DWORD       dwNumTags,
    OUT     PDWORD      pdwOut
    )

/*++

Routine Description:

    Identifies each argument based on its tag. It assumes that each argument
    has a tag. It also removes tag= from each argument.

Arguments:

    ppwcArguments  - The argument array. Each argument has tag=value form
    dwCurrentIndex - ppwcArguments[dwCurrentIndex] is first arg.
    dwArgCount     - ppwcArguments[dwArgCount - 1] is last arg.
    pttTagToken    - Array of tag token ids that are allowed in the args
    dwNumTags      - Size of pttTagToken
    pdwOut         - Array identifying the type of each argument.

Return Value:

    NO_ERROR, ERROR_INVALID_PARAMETER, ERROR_INVALID_OPTION_TAG
    
--*/

{
    DWORD      i,j,len;
    PWCHAR     pwcTag,pwcTagVal,pwszArg;
    BOOL       bFound = FALSE;

    //
    // This function assumes that every argument has a tag
    // It goes ahead and removes the tag.
    //

    for (i = dwCurrentIndex; i < dwArgCount; i++)
    {
        len = wcslen(ppwcArguments[i]);

        if (len is 0)
        {
            //
            // something wrong with arg
            //

            pdwOut[i] = (DWORD) -1;
            continue;
        }

        pwszArg = HeapAlloc(GetProcessHeap(),0,(len + 1) * sizeof(WCHAR));

        if (pwszArg is NULL)
        {
            DisplayError(g_hModule, ERROR_NOT_ENOUGH_MEMORY);

            return ERROR_NOT_ENOUGH_MEMORY;
        }

        wcscpy(pwszArg, ppwcArguments[i]);

        pwcTag = wcstok(pwszArg, NETSH_ARG_DELIMITER);

        //
        // Got the first part
        // Now if next call returns NULL then there was no tag
        // 

        pwcTagVal = wcstok((PWCHAR)NULL,  NETSH_ARG_DELIMITER);

        if (pwcTagVal is NULL)
        {
            // DisplayMessage(g_hModule, MSG_IP_TAG_NOT_PRESENT, ppwcArguments[i] );
            HeapFree(GetProcessHeap(),0,pwszArg);
            return ERROR_INVALID_PARAMETER;
        }

        //
        // Got the tag. Now try to match it
        //
        
        bFound = FALSE;
        pdwOut[i - dwCurrentIndex] = (DWORD) -1;

        for ( j = 0; j < dwNumTags; j++)
        {
            if (MatchToken(pwcTag, pttTagToken[j].pwszTag))
            {
                //
                // Tag matched
                //
                
                bFound = TRUE;
                pdwOut[i - dwCurrentIndex] = j;
                break;
            }
        }

        if (bFound)
        {
            //
            // Remove tag from the argument
            //

            wcscpy(ppwcArguments[i], pwcTagVal);
        }
        else
        {
            //DisplayMessage(g_hModule, MSG_IP_INVALID_TAG, pwcTag);
            HeapFree(GetProcessHeap(),0,pwszArg);
            return ERROR_INVALID_OPTION_TAG;
        }
        
        HeapFree(GetProcessHeap(),0,pwszArg);
    }

    return NO_ERROR;
}

DWORD WINAPI
IpxSubEntry(
    IN      const NS_CONTEXT_ATTRIBUTES *pSubContext,
    IN      LPCWSTR                      pwszMachine,
    IN OUT  LPWSTR                      *ppwcArguments,
    IN      DWORD                        dwArgCount,
    IN      DWORD                        dwFlags,
    IN      PVOID                        pvData,
    OUT     LPWSTR                       pwcNewContext
    )
{
    DWORD                  dwErr, 
                           dwNewArgCount = dwArgCount;
    PWCHAR                *ppwcNewArg = NULL;
    BOOL                   bFreeNewArg;
    PNS_PRIV_CONTEXT_ATTRIBUTES pNsPrivContextAttributes = pSubContext->pReserved;

    dwErr = MungeArguments( ppwcArguments,
                            dwArgCount,
                            (PBYTE*) &ppwcNewArg,
                            &dwNewArgCount,
                            &bFreeNewArg );

    if (dwErr isnot NO_ERROR )
    {
        return dwErr;
    }

    if ( (pNsPrivContextAttributes) && (pNsPrivContextAttributes->pfnEntryFn) )
    {
        dwErr = (*pNsPrivContextAttributes->pfnEntryFn)( pwszMachine,
                                         ppwcNewArg,
                                         dwNewArgCount,
                                         dwFlags,
                                         g_hMIBServer,
                                         pwcNewContext );
    }
    else
    {
        dwErr = GenericMonitor(pSubContext,
                               pwszMachine,
                               ppwcNewArg,
                               dwNewArgCount,
                               dwFlags,
                               g_hMIBServer,
                               pwcNewContext );
    }

    if ( bFreeNewArg )
    {
        FreeArgTable( dwArgCount, ppwcNewArg );
    }

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ipx\ipxmon\routes.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    routes.h

Abstract:

    IPX Router Console Monitoring and Configuration tool.
    Route monitoring. Header File

Author:

    Vadim Eydelman  06/07/1996


--*/
#ifndef _IPXMON_ROUTES_
#define _IPXMON_ROUTES_

DWORD 
APIENTRY 
HelpRoute (
    IN    int                   argc,
    IN    WCHAR                *argv[]
    );

DWORD 
APIENTRY 
ShowRoute (
    IN    int                   argc,
    IN    WCHAR                *argv[]
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ipx\ipxmon\routes.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    routes.c

Abstract:

    IPX Router Console Monitoring and Configuration tool.
    Route Table monitoring.

Author:

    Vadim Eydelman  06/07/1996


--*/
#include "precomp.h"
#pragma hdrstop


DWORD
APIENTRY 
HelpRoute(
    IN    int                   argc,
    IN    WCHAR                *argv[]
    ) 
{
    DisplayIPXMessage (g_hModule, MSG_IPX_HELP_ROUTE);
    return 0;
}

DWORD
APIENTRY 
ShowRoute (
    IN    int                   argc,
    IN    WCHAR                *argv[]
    ) 
{
    DWORD rc;
    PWCHAR  InterfaceNameW = NULL;

    if (g_hMIBServer) 
    {
        IPX_MIB_GET_INPUT_DATA  MibGetInputData;
        PIPX_ROUTE              pRt;
        DWORD                   sz;

        MibGetInputData.TableId = IPX_DEST_TABLE;

        if (argc == 0)
        {
            DisplayIPXMessage (g_hModule, MSG_ROUTE_TABLE_HDR);
            
            rc = MprAdminMIBEntryGetFirst(
                    g_hMIBServer, PID_IPX, IPX_PROTOCOL_BASE, 
                    &MibGetInputData, sizeof(IPX_MIB_GET_INPUT_DATA),
                    (LPVOID *)&pRt, &sz
                    );

            while (rc == NO_ERROR) 
            {
                DWORD   rc1 = NO_ERROR;
                
                if ( pRt && pRt->InterfaceIndex != GLOBAL_INTERFACE_INDEX )
                {
                    InterfaceNameW = HeapAlloc( 
                                        GetProcessHeap(), 0,
                                        ( MAX_INTERFACE_NAME_LEN + 1 ) *
                                        sizeof( WCHAR )
                                        );

                    if ( InterfaceNameW )
                    {
                        rc1 = GetIpxInterfaceName(
                                g_hMIBServer, pRt->InterfaceIndex, InterfaceNameW
                                );
                    }
                    else
                    {
                        rc1 = ERROR_NOT_ENOUGH_MEMORY;
                    }
                }
                
                else
                {
                    InterfaceNameW = VAL_DIALINCLIENT;

                    if ( InterfaceNameW == NULL )
                    {
                        rc1 = ERROR_NOT_ENOUGH_MEMORY;
                    }
                }

                
                if (rc1==NO_ERROR) 
                {
                    PWCHAR  buffer;
                    WCHAR   IfDispName[ MAX_INTERFACE_NAME_LEN + 1 ];
                    DWORD   dwSize = sizeof(IfDispName);
                    
                    //======================================
                    // Translate the Interface Name
                    //======================================

                    rc = IpmontrGetFriendlyNameFromIfName(
                            InterfaceNameW, IfDispName, &dwSize
                            );

                    if ( rc == NO_ERROR )
                    {
                        buffer = GetEnumString(
                                    g_hModule, pRt->Protocol,
                                    NUM_TOKENS_IN_TABLE( IpxProtocols ),
                                    IpxProtocols
                                    );

                        DisplayIPXMessage(
                            g_hModule, MSG_ROUTE_TABLE_FMT,
                            pRt->Network[0], pRt->Network[1],
                            pRt->Network[2], pRt->Network[3],
                            IfDispName, pRt->NextHopMacAddress[0], 
                            pRt->NextHopMacAddress[1], pRt->NextHopMacAddress[2], 
                            pRt->NextHopMacAddress[3], pRt->NextHopMacAddress[4], 
                            pRt->NextHopMacAddress[5], pRt->TickCount,
                            pRt->HopCount, buffer
                            );
                    }
                }
                
                else
                {
                    DisplayError (g_hModule, rc1);
                }
                
                memcpy(
                    MibGetInputData.MibIndex.RoutingTableIndex.Network,
                    pRt->Network,
                    sizeof (MibGetInputData.MibIndex.RoutingTableIndex.Network)
                    );
                    
                if ( InterfaceNameW )
                {
                    if ( pRt->InterfaceIndex != GLOBAL_INTERFACE_INDEX )
                    {
                        HeapFree( GetProcessHeap(), 0, InterfaceNameW );
                    }

                    else
                    {
                        FreeString( InterfaceNameW );
                    }
                }
                
                InterfaceNameW = NULL;

                MprAdminBufferFree (pRt);

                
                rc = MprAdminMIBEntryGetNext(
                        g_hMIBServer, PID_IPX, IPX_PROTOCOL_BASE,
                        &MibGetInputData, sizeof(IPX_MIB_GET_INPUT_DATA),
                        (LPVOID *)&pRt, &sz
                        );
            }
            
            if (rc==ERROR_NO_MORE_ITEMS)
            {
                rc = NO_ERROR;
            }
            else
            {
                DisplayError (g_hModule, rc);
            }
        }
        
        else if (argc==1) 
        {
            UINT        n;
            ULONG       val4;
            
            if ((swscanf (argv[0], L"%8lx%n", &val4, &n)==1)
                    && (n==wcslen (argv[0]))) 
            {
                MibGetInputData.MibIndex.RoutingTableIndex.Network[0] = (BYTE)(val4>>24);
                MibGetInputData.MibIndex.RoutingTableIndex.Network[1] = (BYTE)(val4>>16);
                MibGetInputData.MibIndex.RoutingTableIndex.Network[2] = (BYTE)(val4>>8);
                MibGetInputData.MibIndex.RoutingTableIndex.Network[3] = (BYTE)val4;

                rc = MprAdminMIBEntryGet(
                        g_hMIBServer, PID_IPX, IPX_PROTOCOL_BASE, &MibGetInputData,
                        sizeof(IPX_MIB_GET_INPUT_DATA), (LPVOID *)&pRt, &sz
                        );
                        
                if ( rc==NO_ERROR )
                {
                    if ( pRt && pRt->InterfaceIndex != GLOBAL_INTERFACE_INDEX )
                    {
                        InterfaceNameW = HeapAlloc( 
                                            GetProcessHeap(), 0,
                                            ( MAX_INTERFACE_NAME_LEN + 1 ) *
                                            sizeof( WCHAR )
                                            );

                        if ( InterfaceNameW )
                        {
                            rc = GetIpxInterfaceName(
                                    g_hMIBServer, pRt->InterfaceIndex, InterfaceNameW
                                    );
                        }
                        else
                        {
                            rc = ERROR_NOT_ENOUGH_MEMORY;
                        }
                    }
                    
                    else
                    {
                        InterfaceNameW = VAL_DIALINCLIENT;

                        if ( InterfaceNameW == NULL )
                        {
                            rc = ERROR_NOT_ENOUGH_MEMORY;
                        }
                    }

                    if (rc == NO_ERROR)
                    {
                        PWCHAR  buffer;
                        WCHAR   IfDispName[ MAX_INTERFACE_NAME_LEN + 1 ];
                        DWORD   dwSize = sizeof(IfDispName);
                        
                        //======================================
                        // Translate the Interface Name
                        //======================================

                        rc = IpmontrGetFriendlyNameFromIfName(
                                InterfaceNameW, IfDispName, &dwSize
                                );

                        if ( rc == NO_ERROR )
                        {
                            buffer = GetEnumString(
                                        g_hModule, pRt->Protocol,
                                        NUM_TOKENS_IN_TABLE( IpxProtocols ),
                                        IpxProtocols
                                        );

                            DisplayIPXMessage(
                                g_hModule, MSG_ROUTE_SCREEN_FMT,
                                pRt->Network[0], pRt->Network[1],
                                pRt->Network[2], pRt->Network[3],
                                InterfaceNameW,
                                pRt->NextHopMacAddress[0], pRt->NextHopMacAddress[1],
                                pRt->NextHopMacAddress[2], pRt->NextHopMacAddress[3],
                                pRt->NextHopMacAddress[4], pRt->NextHopMacAddress[5],
                                pRt->TickCount, pRt->HopCount,
                                buffer
                                );
                        }
                    }
                    
                    else
                    {
                        DisplayError (g_hModule, rc);
                    }
                    
                    if ( InterfaceNameW )
                    {
                        if ( pRt->InterfaceIndex != GLOBAL_INTERFACE_INDEX )
                        {
                            HeapFree( GetProcessHeap(), 0, InterfaceNameW );
                        }
                    }
                    
                    InterfaceNameW = NULL;

                    MprAdminMIBBufferFree( pRt );
                }
                    
                else
                {
                    DisplayError (g_hModule, rc);
                }
            }
            else
            {
                DisplayIPXMessage (g_hModule, MSG_IPX_HELP_ROUTE);
                rc = ERROR_INVALID_PARAMETER;
            }
        }
        else
        {
            DisplayIPXMessage (g_hModule, MSG_IPX_HELP_ROUTE);
            rc = ERROR_INVALID_PARAMETER;
        }
    }
    else
    {
        rc = ERROR_ROUTER_STOPPED;
        DisplayError (g_hModule, rc);
    }

    if ( InterfaceNameW )
    {
        
    }
    
    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ipx\ipxmon\services.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    services.h

Abstract:

    IPX Router Console Monitoring and Configuration tool.
    Service table monitoring. Header File

Author:

    Vadim Eydelman  06/07/1996


--*/
#ifndef _IPXMON_SERVICES_
#define _IPXMON_SERVICES_

DWORD
APIENTRY 
HelpService (
    IN    int                   argc,
    IN    WCHAR                *argv[]
    );

DWORD
APIENTRY 
ShowService (
    IN    int                   argc,
    IN    WCHAR                *argv[]
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ipx\ipxmon\precomp.h ===
#define MAX_DLL_NAME 48

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntddser.h>

#include <windows.h>

#include <stdio.h>
#include <stdlib.h>
#include <memory.h>
#include <malloc.h>
#include <tchar.h>

#include <mprerror.h>
#include <mprapi.h>
#include <dim.h>
#include <routprot.h>
#include <rtinfo.h>
#include <ipxrtdef.h>

#include <netsh.h>
#include <netshp.h>
#include <macros.h>
#include <ipmontr.h> // for routing context information
#include <ipxmontr.h>

#include "ipxstrng.h"
#include "ipxutil.h"
#include "ipxmsgs.h"
#include "ipxstrs.h"
#include "ipxhandle.h"
#include "ipxmon.h"
#include "ipxifs.h"
#include "ipxgl.h"
#include "routes.h"
#include "services.h"
#include "stroutes.h"
#include "stsvcs.h"
#include "tfflts.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ipx\ipxmon\stroutes.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    stroutes.h

Abstract:

    IPX Router Console Monitoring and Configuration tool.
    Static Route configuration and monitoring. Header File

Author:

    Vadim Eydelman  06/07/1996


--*/
#ifndef _IPXMON_STROUTES_
#define _IPXMON_STROUTES_

int APIENTRY 
HelpStRt (
    IN    int                    argc,
    IN    WCHAR                *argv[]
    );

int APIENTRY 
ShowStRt (
    IN    int                    argc,
    IN    WCHAR                *argv[],
    IN    BOOL                  bDump
    );

int APIENTRY 
SetStRt (
    IN    int                    argc,
    IN    WCHAR                *argv[]
    );

int APIENTRY 
CreateStRt (
    IN    int                    argc,
    IN    WCHAR                *argv[]
    );

int APIENTRY 
DeleteStRt (
    IN    int                    argc,
    IN    WCHAR                *argv[]
    );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ipx\ipxmon\services.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    services.c

Abstract:

    IPX Router Console Monitoring and Configuration tool.
    Service Table monitoring.

Author:

    Vadim Eydelman  06/07/1996


--*/
#include "precomp.h"
#pragma hdrstop


DWORD
APIENTRY 
HelpService (
    IN    int                   argc,
    IN    WCHAR                *argv[]
    )
{
    DisplayIPXMessage (g_hModule, MSG_IPX_HELP_SERVICE);
    return 0;
}


DWORD
APIENTRY 
ShowService (
    IN    int                   argc,
    IN    WCHAR                *argv[]
    )
{
    DWORD        rc;

    if (g_hMIBServer)
    {
        IPX_MIB_GET_INPUT_DATA  MibGetInputData;
        PIPX_SERVICE            pSv;
        DWORD                   sz;

        MibGetInputData.TableId = IPX_SERV_TABLE;

        if (argc <= 2) 
        {
            if (argc > 0) 
            {
                ULONG   val;
                UINT    n;
                
                if ( (swscanf (argv[0], L"%4x%n", &val, &n) == 1)
                     && (n == wcslen (argv[0]))) 
                {
                    MibGetInputData.MibIndex.ServicesTableIndex.ServiceType = (USHORT)val;
                    
                    if (argc > 1) 
                    {
                        UINT    count;

                        count = wcstombs(
                                    MibGetInputData.MibIndex.ServicesTableIndex.ServiceName,
                                    argv[1],
                                    sizeof (MibGetInputData.MibIndex.ServicesTableIndex.ServiceName)
                                    );

                        if ((count > 0) && 
                            (count < sizeof (MibGetInputData.MibIndex.ServicesTableIndex.ServiceName))) 
                        {
                            rc = MprAdminMIBEntryGet(
                                    g_hMIBServer, PID_IPX, IPX_PROTOCOL_BASE, &MibGetInputData,
                                    sizeof(IPX_MIB_GET_INPUT_DATA), (LPVOID * ) & pSv, &sz
                                    );
                                    
                            if (rc == NO_ERROR && pSv) 
                            {
                                WCHAR    InterfaceName[ MAX_INTERFACE_NAME_LEN + 1 ];
                                WCHAR    IfName[ MAX_INTERFACE_NAME_LEN + 1 ];
                                DWORD    dwSize = sizeof(IfName);
                                
                                rc = GetIpxInterfaceName(
                                        g_hMIBServer, pSv->InterfaceIndex, InterfaceName
                                        );
                                        
                                if (rc == NO_ERROR) 
                                {
                                    PWCHAR   buffer;

                                    //======================================
                                    // Translate the Interface Name
                                    //======================================

                                    rc = IpmontrGetFriendlyNameFromIfName( InterfaceName, IfName, &dwSize );

                                    if ( rc != NO_ERROR )
                                    {
                                        DisplayIPXMessage(
                                            g_hModule, MSG_SERVICE_SCREEN_FMT, pSv->Server.Type,
                                            pSv->Server.Name, IfName, pSv->Server.HopCount,
                                            pSv->Server.Network[0], pSv->Server.Network[1],
                                            pSv->Server.Network[2], pSv->Server.Network[3],
                                            pSv->Server.Node[0], pSv->Server.Node[1],
                                            pSv->Server.Node[2], pSv->Server.Node[3],
                                            pSv->Server.Node[4], pSv->Server.Node[5],
                                            pSv->Server.Socket[0], pSv->Server.Socket[1],
                                            GetEnumString( 
                                                g_hModule, pSv->Protocol, 
                                                NUM_TOKENS_IN_TABLE( IpxProtocols ),
                                                IpxProtocols
                                                )
                                            );
                                     }
                                }
                                else
                                {
                                    DisplayError( g_hModule, rc);
                                }
                            }

                            else
                            {
                                DisplayError( g_hModule, rc);
                            }

                            MprAdminMIBBufferFree (pSv);
                        }
                        else 
                        {
                            rc = ERROR_INVALID_PARAMETER;
                            DisplayIPXMessage (g_hModule, MSG_IPX_HELP_SERVICE);
                        }
                        
                        goto Exit;
                    }
                    else 
                    {
                        MibGetInputData.MibIndex.ServicesTableIndex.ServiceName[0] = 0;
                        
                        rc = MprAdminMIBEntryGetNext(
                                g_hMIBServer, PID_IPX, IPX_PROTOCOL_BASE, 
                                &MibGetInputData, sizeof(IPX_MIB_GET_INPUT_DATA),
                                (LPVOID * ) & pSv, &sz
                                );
                    }
                }
                else 
                {
                    rc = ERROR_INVALID_PARAMETER;
                    DisplayIPXMessage (g_hModule, MSG_IPX_HELP_SERVICE);
                    goto Exit;
                }
            }

            else
            {
                rc = MprAdminMIBEntryGetFirst(
                        g_hMIBServer, PID_IPX, IPX_PROTOCOL_BASE, &MibGetInputData,
                        sizeof(IPX_MIB_GET_INPUT_DATA), (LPVOID * ) & pSv, &sz
                        );
            }
            
            DisplayIPXMessage (g_hModule, MSG_SERVICE_TABLE_HDR);
            
            while ( (pSv)
                    && (rc == NO_ERROR)
                    && ((argc == 0)
                        || (MibGetInputData.MibIndex.ServicesTableIndex.ServiceType
                                == pSv->Server.Type))) 
                 
            {
                WCHAR   InterfaceName[ MAX_INTERFACE_NAME_LEN + 1 ];
                WCHAR   IfName[ MAX_INTERFACE_NAME_LEN + 1 ];
                DWORD   rc1, dwSize = sizeof(IfName);
                
                rc1 = GetIpxInterfaceName(
                        g_hMIBServer, pSv->InterfaceIndex, InterfaceName
                        );
                        
                if (rc1 == NO_ERROR) 
                {
                    PWCHAR  buffer;

                    rc1 = IpmontrGetFriendlyNameFromIfName( InterfaceName, IfName, &dwSize );

                    if ( rc1 == NO_ERROR )
                    {
                        DisplayIPXMessage(
                            g_hModule, MSG_SERVICE_TABLE_FMT,
                            pSv->Server.Type, pSv->Server.Name,
                            IfName, pSv->Server.HopCount,
                            GetEnumString( 
                                g_hModule, pSv->Protocol, 
                                NUM_TOKENS_IN_TABLE( IpxProtocols ),
                                IpxProtocols
                                )
                            );
                    }
                }
                
                else
                {
                    DisplayError( g_hModule, rc1);
                }
                
                MibGetInputData.MibIndex.ServicesTableIndex.ServiceType = pSv->Server.Type;
                
                strncpy( 
                    MibGetInputData.MibIndex.ServicesTableIndex.ServiceName,
                    pSv->Server.Name,
                    sizeof (MibGetInputData.MibIndex.ServicesTableIndex.ServiceName)
                    );
                    
                MprAdminBufferFree (pSv);
                
                rc = MprAdminMIBEntryGetNext(
                        g_hMIBServer, PID_IPX, IPX_PROTOCOL_BASE, &MibGetInputData,
                        sizeof(IPX_MIB_GET_INPUT_DATA), (LPVOID * ) & pSv, &sz
                        );
            }

            
            if (rc == NO_ERROR)
            {
                NOTHING;
            }
            
            else if (rc == ERROR_NO_MORE_ITEMS)
            {
                rc = NO_ERROR;
            }
            else
            {
                DisplayError( g_hModule, rc);
            }
        }
        else 
        {
            DisplayIPXMessage (g_hModule, MSG_IPX_HELP_SERVICE);
            rc = ERROR_INVALID_PARAMETER;
        }
    }
    else 
    {
        rc = ERROR_ROUTER_STOPPED;
        DisplayError( g_hModule, rc);
    }

Exit:
    return rc ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ipx\ipxmon\stroutes.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    stroutes.c

Abstract:

    IPX Router Console Monitoring and Configuration tool.
    Static Route configuration and monitoring.

Author:

    Vadim Eydelman  06/07/1996


--*/
#include "precomp.h"
#pragma hdrstop

#define OPERATION_DEL_STATICROUTE    (-1)
#define OPERATION_SET_STATICROUTE    0
#define OPERATION_ADD_STATICROUTE    1

DWORD
UpdateStRtInfo (
    LPBYTE          pIfBlock,
    PUCHAR          Network,
    PUCHAR          pNextHop    OPTIONAL,
    PUSHORT         pTicks      OPTIONAL,
    PUSHORT         pHops       OPTIONAL
);

DWORD
AdmSetStRt (
    int             operation,
    LPWSTR          InterfaceNameW,
    PUCHAR          Network,
    PUCHAR          pNexHop         OPTIONAL,
    PUSHORT         pTicks          OPTIONAL,
    PUSHORT         pHops           OPTIONAL
);

DWORD
CfgSetStRt (
    int             operation,
    LPWSTR          InterfaceNameW,
    PUCHAR          Network,
    PUCHAR          pNexHop         OPTIONAL,
    PUSHORT         pTicks          OPTIONAL,
    PUSHORT         pHops           OPTIONAL
);



int    
APIENTRY 
HelpStRt(
    IN    int                   argc,
    IN    WCHAR                *argv[]
) 
{
    DisplayIPXMessage (g_hModule, MSG_IPX_HELP_STATICROUTE);
    return 0;
}


int
APIENTRY 
ShowStRt(
    IN    int                   argc,
    IN    WCHAR                *argv[],
    IN    BOOL                  bDump
) 
{
    WCHAR   IfName[ MAX_INTERFACE_NAME_LEN + 1 ];     
    DWORD   rc, dwSize = sizeof(IfName);


    if (argc > 0) 
    {
        unsigned    count;

#define InterfaceNameW argv[0]
        count = wcslen (InterfaceNameW);

        //======================================
        // Translate the Interface Name
        //======================================

        rc = IpmontrGetIfNameFromFriendlyName(
                InterfaceNameW, IfName, &dwSize
                );
                
        if ((count > 0) && (count <= MAX_INTERFACE_NAME_LEN)) 
        {
            LPBYTE      pIfBlock;
            BOOLEAN     fRouter = FALSE;
            UCHAR       Network[4];

            if (argc > 1) 
            {
                ULONG   val4;
                UINT    n;
                
                if ((argc == 2)
                     && ( swscanf (argv[1], L"%8lx%n", &val4, &n) == 1)
                     && (n == wcslen (argv[1]))) 
                {
                    Network[0] = (BYTE)(val4 >> 24);
                    Network[1] = (BYTE)(val4 >> 16);
                    Network[2] = (BYTE)(val4 >> 8);
                    Network[3] = (BYTE)val4;
                }
                else 
                {
                    if ( !bDump )
                    {
                        DisplayIPXMessage (g_hModule, MSG_IPX_HELP_STATICROUTE);
                    }
                    
                    rc = ERROR_INVALID_PARAMETER;
                    goto Exit;
                }
            }
            else
            {
                if ( !bDump )
                {
                    DisplayIPXMessage (g_hModule, MSG_STATICROUTE_TABLE_HDR);
                }
            }


            if (g_hMprAdmin) 
            {
                HANDLE hIfAdm;
                
                rc = MprAdminInterfaceGetHandle(
                        g_hMprAdmin, IfName, &hIfAdm, FALSE
                        );
                        
                if (rc == NO_ERROR) 
                {
                    DWORD   sz;
                    rc = MprAdminInterfaceTransportGetInfo(
                            g_hMprAdmin, hIfAdm, PID_IPX, &pIfBlock, &sz
                            );
                }
                
                if (rc == NO_ERROR)
                {
                    fRouter = TRUE;
                }
                else 
                {
                    if ( !bDump )
                    {
                        DisplayError( g_hModule, rc);
                    }
                    goto GetFromCfg;
                }
            }
            
            else 
            {
                HANDLE        hIfCfg;
GetFromCfg:
                rc = MprConfigInterfaceGetHandle(
                        g_hMprConfig, IfName, &hIfCfg
                        );
                        
                if (rc == NO_ERROR) 
                {
                    HANDLE    hIfTrCfg;
                    rc = MprConfigInterfaceTransportGetHandle(
                            g_hMprConfig, hIfCfg, PID_IPX, &hIfTrCfg
                            );
                            
                    if (rc == NO_ERROR) 
                    {
                        DWORD    sz;
                        rc = MprConfigInterfaceTransportGetInfo(
                                g_hMprConfig, hIfCfg, hIfTrCfg, &pIfBlock, &sz
                                );
                    }
                }
            }

            
            if (rc == NO_ERROR) 
            {
                PIPX_TOC_ENTRY pSrToc;

                pSrToc = GetIPXTocEntry (
                            (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                            IPX_STATIC_ROUTE_INFO_TYPE
                            );
                            
                if (pSrToc != NULL) 
                {
                    PIPX_STATIC_ROUTE_INFO  pSrInfo;
                    UINT                    i;

                    pSrInfo = (PIPX_STATIC_ROUTE_INFO)
                                (pIfBlock + pSrToc->Offset);
                                
                    for (i = 0; i < pSrToc->Count; i++, pSrInfo++) 
                    {
                        if (argc > 1) 
                        {
                            if (memcmp (Network, pSrInfo->Network, sizeof (Network))
                                == 0) 
                            {
                                DisplayIPXMessage(
                                    g_hModule,
                                    MSG_STATICROUTE_SCREEN_FMT,
                                    pSrInfo->Network[0], pSrInfo->Network[1],
                                    pSrInfo->Network[2], pSrInfo->Network[3],
                                    pSrInfo->NextHopMacAddress[0], 
                                    pSrInfo->NextHopMacAddress[1],
                                    pSrInfo->NextHopMacAddress[2],
                                    pSrInfo->NextHopMacAddress[3],
                                    pSrInfo->NextHopMacAddress[4], 
                                    pSrInfo->NextHopMacAddress[5],
                                    pSrInfo->TickCount, pSrInfo->HopCount
                                    );
                                break;
                            }
                        }
                        else 
                        {
                            if ( bDump )
                            {
                                DisplayMessageT(
                                    DMP_IPX_ADD_STATIC_ROUTE, InterfaceNameW,
                                    pSrInfo->Network[0], pSrInfo->Network[1],
                                    pSrInfo->Network[2], pSrInfo->Network[3],
                                    pSrInfo->NextHopMacAddress[0], 
                                    pSrInfo->NextHopMacAddress[1],
                                    pSrInfo->NextHopMacAddress[2],
                                    pSrInfo->NextHopMacAddress[3],
                                    pSrInfo->NextHopMacAddress[4], 
                                    pSrInfo->NextHopMacAddress[5],
                                    pSrInfo->TickCount, pSrInfo->HopCount
                                    );
                            }

                            else
                            {
                                DisplayIPXMessage(
                                    g_hModule, MSG_STATICROUTE_TABLE_FMT,
                                    pSrInfo->Network[0], pSrInfo->Network[1],
                                    pSrInfo->Network[2], pSrInfo->Network[3],
                                    pSrInfo->NextHopMacAddress[0], 
                                    pSrInfo->NextHopMacAddress[1],
                                    pSrInfo->NextHopMacAddress[2],
                                    pSrInfo->NextHopMacAddress[3],
                                    pSrInfo->NextHopMacAddress[4], 
                                    pSrInfo->NextHopMacAddress[5],
                                    pSrInfo->TickCount, pSrInfo->HopCount
                                    );
                            }
                        }
                    }
                    
                    if ((argc > 1) && (i >= pSrToc->Count)) 
                    {
                        rc = ERROR_NOT_FOUND;
                        
                        if ( !bDump )
                        {
                            DisplayError( g_hModule, rc );
                        }
                    }
                }
                else 
                {
                    rc = ERROR_NOT_FOUND;
                    
                    if ( !bDump )
                    {
                        DisplayIPXMessage (g_hModule, MSG_STATICROUTE_NONE_FOUND );
                    }
                }
                
                if (fRouter)
                {
                    MprAdminBufferFree (pIfBlock);
                }
                else
                {
                    MprConfigBufferFree (pIfBlock);
                }
            }
            
            else
            {
                if ( !bDump )
                {
                    DisplayError( g_hModule, rc);
                }
            }
        }
        else 
        {
            if ( !bDump )
            {
                DisplayIPXMessage (g_hModule, MSG_INVALID_INTERFACE_NAME);
            }
            
            rc = ERROR_INVALID_PARAMETER;
        }
    }

    else 
    {
        if ( !bDump )
        {
            DisplayIPXMessage (g_hModule, MSG_IPX_HELP_STATICROUTE);
        }
        
        rc = ERROR_INVALID_PARAMETER;
    }

Exit:
    return rc ;


#undef InterfaceNameW
}


int
APIENTRY 
SetStRt (
    IN    int                   argc,
    IN    WCHAR                *argv[]
) 
{
    DWORD   rc = NO_ERROR, rc2;
    WCHAR   IfName[ MAX_INTERFACE_NAME_LEN + 1 ];     
    DWORD   dwSize = sizeof(IfName);

    
    if (argc > 1) 
    {
        unsigned    count;

#define InterfaceNameW argv[0]
        count = wcslen (InterfaceNameW);

        //======================================
        // Translate the Interface Name
        //======================================

        rc2 = IpmontrGetIfNameFromFriendlyName(
                InterfaceNameW, IfName, &dwSize
                );

        if ((count > 0) && (count <= MAX_INTERFACE_NAME_LEN)) 
        {
            ULONG        val4;
            ULONGLONG   val8;
            UINT        n;
            UCHAR        Network[4];

            if (( swscanf (argv[1], L"%8lx%n", &val4, &n) == 1)
                 && (n == wcslen (argv[1]))) 
            {
                int     i;
                UCHAR   nextHop[6];
                USHORT  ticks, hops;
                PUCHAR  pNextHop = NULL;
                PUSHORT pTicks = NULL, pHops = NULL;
                
                Network[0] = (BYTE)(val4 >> 24);
                Network[1] = (BYTE)(val4 >> 16);
                Network[2] = (BYTE)(val4 >> 8);
                Network[3] = (BYTE)val4;

                for (i = 2; i < argc; i++) 
                {
                    if ( !_wcsicmp( argv[i], TOKEN_NEXTHOPMACADDRESS ) ) 
                    {
                        if ((pNextHop == NULL)
                             && (i < argc - 1)
                             && ( swscanf (argv[i+1], L"%12I64x%n", &val8, &n) == 1)
                             && ( n == wcslen( argv[i+1] ))) 
                        {
                            i += 1;
                            nextHop[0] = (BYTE)(val8 >> 40);
                            nextHop[1] = (BYTE)(val8 >> 32);
                            nextHop[2] = (BYTE)(val8 >> 24);
                            nextHop[3] = (BYTE)(val8 >> 16);
                            nextHop[4] = (BYTE)(val8 >> 8);
                            nextHop[5] = (BYTE)val8;
                            pNextHop = nextHop;
                        }
                        else
                        {
                            break;
                        }
                    }
                    
                    else if ( !_wcsicmp( argv[i], TOKEN_TICKS ) )
                    {
                        if ( (pTicks == NULL) && (i < argc - 1)
                             && ( swscanf ( argv[i+1], L"%hd%n", &ticks, &n) == 1)
                             && (n == wcslen (argv[i+1]))) 
                        {
                            i += 1;
                            pTicks = &ticks;
                        }
                        else
                        {
                            break;
                        }
                    }

                    
                    else if ( !_wcsicmp ( argv[i], TOKEN_HOPS ) )
                    {
                        if ((pHops == NULL)
                             && (i < argc - 1)
                             && ( swscanf (argv[i+1], L"%hd%n", &hops, &n) == 1)
                             && (n == wcslen (argv[i+1]))) 
                        {
                            i += 1;
                            pHops = &hops;
                        }
                        else
                        {
                            break;
                        }
                    }

                    
                    else if (pNextHop == NULL) 
                    {
                        if (( swscanf (argv[i], L"%12I64x%n", &val8, &n) == 1)
                             && (n == wcslen (argv[i]))) 
                        {
                            nextHop[0] = (BYTE)(val8 >> 40);
                            nextHop[1] = (BYTE)(val8 >> 32);
                            nextHop[2] = (BYTE)(val8 >> 24);
                            nextHop[3] = (BYTE)(val8 >> 16);
                            nextHop[4] = (BYTE)(val8 >> 8);
                            nextHop[5] = (BYTE)val8;
                            pNextHop = nextHop;
                        }
                        else
                        {
                            break;
                        }
                    }
                    

                    else if (pTicks == NULL) 
                    {
                        if (( swscanf (argv[i], L"%hd%n", &ticks, &n) == 1)
                             && (n == wcslen (argv[i]))) 
                        {
                            pTicks = &ticks;
                        }
                        else
                        {
                            break;
                        }
                    }

                    
                    else if (pHops == NULL) 
                    {
                        if (( swscanf (argv[i], L"%hd%n", &hops, &n) == 1)
                             && (n == wcslen (argv[i]))) 
                        {
                            pHops = &hops;
                        }
                        else
                        {
                            break;
                        }
                    }
                    else
                    {
                        break;
                    }
                }

                
                if (i == argc) 
                {
                    if (g_hMprAdmin)
                    {
                        rc = AdmSetStRt(
                                OPERATION_SET_STATICROUTE, IfName, Network, 
                                pNextHop, pTicks, pHops
                                );
                    }
                    else
                    {
                        rc = NO_ERROR;
                    }

                    
                    if (rc == NO_ERROR)
                    {
                        rc = CfgSetStRt(
                                OPERATION_SET_STATICROUTE, IfName, Network,
                                pNextHop, pTicks, pHops
                                );
                    }
                }

                else
                {
                    DisplayIPXMessage (g_hModule, MSG_IPX_HELP_STATICROUTE);
                }
            }

            else
            {
                DisplayIPXMessage (g_hModule, MSG_IPX_HELP_STATICROUTE);
            }
        }
        else 
        {
            DisplayIPXMessage (g_hModule, MSG_INVALID_INTERFACE_NAME);
            rc = ERROR_INVALID_PARAMETER;
        }
    }
    else 
    {
        DisplayIPXMessage (g_hModule, MSG_IPX_HELP_STATICROUTE);
        rc = ERROR_INVALID_PARAMETER;
    }


    return rc ;

#undef InterfaceNameW
}


int
APIENTRY 
CreateStRt (
    IN    int                   argc,
    IN    WCHAR                *argv[]
) 
{

    DWORD   rc = NO_ERROR, rc2;
    WCHAR   IfName[ MAX_INTERFACE_NAME_LEN + 1 ];     
    DWORD   dwSize = sizeof(IfName);

    BOOL    bArgsCount,                 //does the argument count match
            AdjNH, AdjTicks, AdjHops;   //adjust for option names



    bArgsCount = FALSE;
    AdjNH = AdjTicks = AdjHops = 0;

    if (argc > 5) 
    {
        if ( !_wcsicmp( argv[2], TOKEN_NEXTHOPMACADDRESS ) )
        {
            AdjNH = 1;
        }
        
        if (argc > 5 + AdjNH) 
        {
            if ( !_wcsicmp( argv[3+AdjNH], TOKEN_TICKS ) )
            {
                AdjTicks = 1;
            }
        }


        if (argc > 5 + AdjNH + AdjTicks) 
        {
            if ( !_wcsicmp( argv[4+AdjNH+AdjTicks], TOKEN_HOPS ) )
            {
                AdjHops = 1;
            }
        }


        bArgsCount = (argc == (5 + AdjNH + AdjTicks + AdjHops)) ? TRUE : FALSE;

        // make the adjustment cumulative
        AdjTicks += AdjNH;
        AdjHops += AdjTicks;
    }


    if ( (argc == 5) || (bArgsCount) ) 
    {
        unsigned    count;


#define InterfaceNameW argv[0]
        count = wcslen (InterfaceNameW);


        //======================================
        // Translate the Interface Name
        //======================================

        rc2 = IpmontrGetIfNameFromFriendlyName( InterfaceNameW, IfName, &dwSize );

        if ((count > 0) && (count <= MAX_INTERFACE_NAME_LEN)) 
        {
            UINT        n;
            ULONG       val4;
            ULONGLONG   val8;
            UCHAR        Network[4], NextHop[6];
            USHORT        Ticks, Hops;

            if (( swscanf (argv[1], L"%8lx%n", &val4, &n) == 1)
                 && (n == wcslen (argv[1]))) 
            {
                Network[0] = (BYTE)(val4 >> 24);
                Network[1] = (BYTE)(val4 >> 16);
                Network[2] = (BYTE)(val4 >> 8);
                Network[3] = (BYTE)val4;
                
                if (( swscanf (argv[2+AdjNH], L"%12I64x%n", &val8, &n) == 1)
                     && (n == wcslen (argv[2+AdjNH]))) 
                {
                    NextHop[0] = (BYTE)(val8 >> 40);
                    NextHop[1] = (BYTE)(val8 >> 32);
                    NextHop[2] = (BYTE)(val8 >> 24);
                    NextHop[3] = (BYTE)(val8 >> 16);
                    NextHop[4] = (BYTE)(val8 >> 8);
                    NextHop[5] = (BYTE)val8;
                    
                    if (( swscanf (argv[3+AdjTicks], L"%hd%n", &Ticks, &n) == 1)
                         && (n == wcslen (argv[3+AdjTicks]))) 
                    {
                        if (( swscanf (argv[4+AdjHops], L"%hd%n", &Hops,&n) == 1)
                             && (n == wcslen (argv[4+AdjHops]))) 
                        {
                            if (g_hMprAdmin)
                            {
                                rc = AdmSetStRt(
                                        OPERATION_ADD_STATICROUTE, IfName, 
                                        Network, NextHop, &Ticks, &Hops
                                        );
                            }
                            else
                            {
                                rc = NO_ERROR;
                            }

                            
                            if (rc == NO_ERROR)
                            {
                                rc = CfgSetStRt(
                                        OPERATION_ADD_STATICROUTE, IfName,
                                        Network, NextHop, &Ticks, &Hops
                                        );
                            }
                        }
                        else 
                        {
                            rc = ERROR_INVALID_PARAMETER;
                            DisplayIPXMessage (g_hModule, MSG_IPX_HELP_STATICROUTE);
                        }
                    }
                    else 
                    {
                        rc = ERROR_INVALID_PARAMETER;
                        DisplayIPXMessage (g_hModule, MSG_IPX_HELP_STATICROUTE);
                    }
                }
                else 
                {
                    rc = ERROR_INVALID_PARAMETER;
                    DisplayIPXMessage (g_hModule, MSG_IPX_HELP_STATICROUTE);
                }
            }
        }
        else 
        {
            DisplayIPXMessage (g_hModule, MSG_INVALID_INTERFACE_NAME);
            rc = ERROR_INVALID_PARAMETER;
        }
    }
    
    else 
    {
        DisplayIPXMessage (g_hModule, MSG_IPX_HELP_STATICROUTE);
        rc = ERROR_INVALID_PARAMETER;
    }

    return rc ;


#undef InterfaceNameW
}


int
APIENTRY 
DeleteStRt(
    IN    int                   argc,
    IN    WCHAR                *argv[]
) 
{
    DWORD   rc, rc2;
    WCHAR   IfName[ MAX_INTERFACE_NAME_LEN + 1 ];     
    DWORD   dwSize = sizeof(IfName);
    
    if (argc == 2) 
    {
        unsigned    count;


#define InterfaceNameW argv[0]
        count = wcslen (InterfaceNameW);

        //======================================
        // Translate the Interface Name
        //======================================

        rc2 = IpmontrGetIfNameFromFriendlyName( InterfaceNameW, IfName, &dwSize );

        if ((count > 0) && (count <= MAX_INTERFACE_NAME_LEN)) 
        {
            UINT    n;
            ULONG   val4;
            UCHAR   Network[4];

            if (( swscanf (argv[1], L"%8x%n", &val4, &n) == 1)
                 && (n == wcslen (argv[1]))) 
            {
                Network[0] = (BYTE)(val4 >> 24);
                Network[1] = (BYTE)(val4 >> 16);
                Network[2] = (BYTE)(val4 >> 8);
                Network[3] = (BYTE)val4;
                
                if (g_hMprAdmin)
                {
                    rc = AdmSetStRt(
                            OPERATION_DEL_STATICROUTE, IfName, Network,
                            NULL, NULL, NULL
                            );
                }
                else
                {
                    rc = NO_ERROR;
                }

                
                if (rc == NO_ERROR)
                {
                    rc = CfgSetStRt(
                            OPERATION_DEL_STATICROUTE, IfName, Network,
                            NULL, NULL, NULL
                            );
                }
            }
            else 
            {
                rc = ERROR_INVALID_PARAMETER;
                DisplayIPXMessage (g_hModule, MSG_IPX_HELP_STATICROUTE);
            }
        }
        else 
        {
            rc = ERROR_INVALID_PARAMETER;
            DisplayIPXMessage (g_hModule, MSG_INVALID_INTERFACE_NAME);
        }
    }
    else 
    {
        rc = ERROR_INVALID_PARAMETER;
        DisplayIPXMessage (g_hModule, MSG_IPX_HELP_STATICROUTE);
    }

    return rc ;


#undef InterfaceNameW
}


BOOL
StRtEqual (
    PVOID    info1,
    PVOID    info2
) 
{
#define StRt1 ((PIPX_STATIC_ROUTE_INFO)info1)
#define StRt2 ((PIPX_STATIC_ROUTE_INFO)info2)

    return memcmp (StRt1->Network, StRt2->Network, 4) == 0;

#undef StRt1
#undef StRt2
}


DWORD
AdmSetStRt (
    int             operation,
    LPWSTR          InterfaceNameW,
    PUCHAR          Network,
    PUCHAR          pNextHop         OPTIONAL,
    PUSHORT         pTicks          OPTIONAL,
    PUSHORT         pHops           OPTIONAL
) 
{
    DWORD   rc;
    WCHAR   IfDispName[ MAX_INTERFACE_NAME_LEN + 1 ];     
    DWORD   dwSize = sizeof(IfDispName);

    HANDLE  hIfAdm;
    
    rc = MprAdminInterfaceGetHandle(
            g_hMprAdmin, InterfaceNameW, &hIfAdm, FALSE
            );
            
    if (rc == NO_ERROR) 
    {
        LPBYTE  pIfBlock;
        DWORD   sz;
        
        rc = MprAdminInterfaceTransportGetInfo(
                g_hMprAdmin, hIfAdm, PID_IPX, &pIfBlock, &sz
                );
                
        if ( rc == NO_ERROR ) 
        {
            UINT    msg;
            LPBYTE    pNewBlock;

            switch (operation) 
            {
                case OPERATION_SET_STATICROUTE:
                
                    rc = UpdateStRtInfo(
                            pIfBlock, Network, pNextHop, pTicks, pHops
                            );
                            
                    pNewBlock = pIfBlock;
                    msg = MSG_STATICROUTE_SET_ADM;
                    
                    break;
                    
                case OPERATION_ADD_STATICROUTE:
                {
                    IPX_STATIC_ROUTE_INFO    SrInfo;
                    
                    memcpy (SrInfo.Network, Network, sizeof (SrInfo.Network));
                    memcpy (SrInfo.NextHopMacAddress, pNextHop, sizeof (SrInfo.NextHopMacAddress));
                    
                    SrInfo.TickCount = *pTicks;
                    SrInfo.HopCount = *pHops;
                    
                    rc = AddIPXInfoEntry (
                            (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                            IPX_STATIC_ROUTE_INFO_TYPE,
                            sizeof (SrInfo), &SrInfo, StRtEqual,
                            (PIPX_INFO_BLOCK_HEADER * ) & pNewBlock
                            );
                    msg = MSG_STATICROUTE_CREATED_ADM;

                    break;

                }

                case OPERATION_DEL_STATICROUTE:
                {
                    IPX_STATIC_ROUTE_INFO    SrInfo;
                    
                    memcpy (SrInfo.Network, Network, sizeof (SrInfo.Network));
                    
                    rc = DeleteIPXInfoEntry (
                            (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                            IPX_STATIC_ROUTE_INFO_TYPE,
                            sizeof (SrInfo), &SrInfo, StRtEqual,
                            (PIPX_INFO_BLOCK_HEADER * ) &pNewBlock
                            );
                            
                    msg = MSG_STATICROUTE_DELETED_ADM;

                    break;

                }
            }

            if (rc == NO_ERROR) 
            {
                rc = MprAdminInterfaceTransportSetInfo(
                        g_hMprAdmin, hIfAdm, PID_IPX, pNewBlock,
                        ((PIPX_INFO_BLOCK_HEADER)pNewBlock)->Size
                        );
                        
                if (pNewBlock != pIfBlock)
                {
                    GlobalFree (pNewBlock);
                }
                
                if (rc == NO_ERROR) 
                {
                    DWORD rc2;
                    
                    //======================================
                    // Translate the Interface Name
                    //======================================

                    rc2 = IpmontrGetFriendlyNameFromIfName(
                            InterfaceNameW, IfDispName, &dwSize
                            );
                            
                    if ( rc2 == NO_ERROR )
                    {
                        DisplayIPXMessage (g_hModule, msg, IfDispName );
                    }
                }
                else
                {
                    DisplayError( g_hModule, rc);
                }
            }

            else
            {
                DisplayError( g_hModule, rc);
            }

            MprAdminBufferFree (pIfBlock);
        }
    }
    
    else
    {
        DisplayError( g_hModule, rc);
    }

    return rc;
}


DWORD
CfgSetStRt (
    int             operation,
    LPWSTR          InterfaceNameW,
    PUCHAR          Network,
    PUCHAR          pNextHop        OPTIONAL,
    PUSHORT         pTicks          OPTIONAL,
    PUSHORT         pHops           OPTIONAL
) 
{
    DWORD   rc;
    WCHAR   IfName[ MAX_INTERFACE_NAME_LEN + 1 ];     
    DWORD   dwSize = sizeof(IfName);
    HANDLE  hIfCfg;
    
    rc = MprConfigInterfaceGetHandle(
            g_hMprConfig, InterfaceNameW, &hIfCfg
            );
            
    if (rc == NO_ERROR) 
    {
        HANDLE    hIfTrCfg;
            
        rc = MprConfigInterfaceTransportGetHandle(
                g_hMprConfig, hIfCfg, PID_IPX, &hIfTrCfg
                );
                
        if (rc == NO_ERROR) 
        {
            LPBYTE  pIfBlock;
            DWORD   sz;
            LPBYTE  pNewBlock;
            
            rc = MprConfigInterfaceTransportGetInfo(
                    g_hMprConfig, hIfCfg, hIfTrCfg, &pIfBlock, &sz
                    );
                    
            if (rc == NO_ERROR) 
            {
                UINT    msg;
                
                switch (operation) 
                {
                    case OPERATION_SET_STATICROUTE:
                    
                        rc = UpdateStRtInfo(
                                pIfBlock, Network, pNextHop, pTicks,
                                pHops
                                );

                        pNewBlock = pIfBlock;
                        msg = MSG_STATICROUTE_SET_CFG;
                        
                        break;
                        
                    case OPERATION_ADD_STATICROUTE:
                    {
                        IPX_STATIC_ROUTE_INFO    SrInfo;
                        
                        memcpy (SrInfo.Network, Network, sizeof (SrInfo.Network));
                        memcpy (SrInfo.NextHopMacAddress, pNextHop,
                            sizeof (SrInfo.NextHopMacAddress));
                            
                        SrInfo.TickCount = *pTicks;
                        SrInfo.HopCount = *pHops;
                        
                        rc = AddIPXInfoEntry (
                                (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                                IPX_STATIC_ROUTE_INFO_TYPE,
                                sizeof (SrInfo), &SrInfo,
                                StRtEqual,
                                (PIPX_INFO_BLOCK_HEADER * ) & pNewBlock
                                );
                                
                        msg = MSG_STATICROUTE_CREATED_CFG;
                        break;
                        
                    }
                    
                    case OPERATION_DEL_STATICROUTE:
                    {
                        IPX_STATIC_ROUTE_INFO    SrInfo;
                        
                        memcpy (SrInfo.Network, Network, sizeof (SrInfo.Network));
                        
                        rc = DeleteIPXInfoEntry (
                                (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                                IPX_STATIC_ROUTE_INFO_TYPE,
                                sizeof (SrInfo), &SrInfo,
                                StRtEqual, (PIPX_INFO_BLOCK_HEADER * ) & pNewBlock
                                );
                                
                        msg = MSG_STATICROUTE_DELETED_CFG;

                        break;

                    }
                }

                
                if (rc == NO_ERROR) 
                {
                    rc = MprConfigInterfaceTransportSetInfo(
                            g_hMprConfig, hIfCfg, hIfTrCfg, pNewBlock,
                            ((PIPX_INFO_BLOCK_HEADER)pNewBlock)->Size
                            );
                            
                    if (pNewBlock != pIfBlock)
                    {
                        GlobalFree (pNewBlock);
                    }
                    
                    if (rc == NO_ERROR) 
                    {
                        DWORD rc2;
                        
                        rc2 = IpmontrGetFriendlyNameFromIfName(
                                InterfaceNameW, IfName, &dwSize
                                );
                    
                        if ( rc2 == NO_ERROR )
                        {
                            DisplayIPXMessage (g_hModule, msg, IfName );
                        }
                    }
                    
                    else
                    {
                        DisplayError( g_hModule, rc);
                    }
                }
                
                else
                {
                    DisplayError( g_hModule, rc);
                }
                
                MprConfigBufferFree (pIfBlock);
            }
            else
            {
                DisplayError( g_hModule, rc);
            }
        }
        else
        {
            DisplayError( g_hModule, rc);
        }
    }
    else
    {
        DisplayError( g_hModule, rc);
    }

    return rc;
}


DWORD
UpdateStRtInfo (
    LPBYTE      pIfBlock,
    PUCHAR      Network,
    PUCHAR      pNextHop    OPTIONAL,
    PUSHORT     pTicks      OPTIONAL,
    PUSHORT     pHops       OPTIONAL
) 
{
    DWORD            rc;
    PIPX_TOC_ENTRY   pSrToc;


    pSrToc = GetIPXTocEntry(
                (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                IPX_STATIC_ROUTE_INFO_TYPE
                );
                
    if (pSrToc != NULL) 
    {
        PIPX_STATIC_ROUTE_INFO    pSrInfo;
        UINT                    i;

        pSrInfo = (PIPX_STATIC_ROUTE_INFO) (pIfBlock + pSrToc->Offset);
        
        for (i = 0; i < pSrToc->Count; i++, pSrInfo++) 
        {
            if (memcmp (Network, pSrInfo->Network, sizeof (Network)) == 0)
            break;
        }
        
        if (i < pSrToc->Count) 
        {
            if (ARGUMENT_PRESENT (pNextHop))
            {
                memcpy (pSrInfo->NextHopMacAddress, pNextHop,
                    sizeof (pSrInfo->NextHopMacAddress));
            }
            
            if (ARGUMENT_PRESENT (pTicks))
            {
                pSrInfo->TickCount = *pTicks;
            }
            
            if (ARGUMENT_PRESENT (pHops))
            {
                pSrInfo->HopCount = *pHops;
            }
            
            rc = NO_ERROR;
        }
        else
        {
            rc = ERROR_FILE_NOT_FOUND;
        }
    }
    else
    {
        rc = ERROR_FILE_NOT_FOUND;
    }

    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ipx\ipxmon\stsvcs.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    stsvcs.c

Abstract:

    IPX Router Console Monitoring and Configuration tool.
    Static Service configuration and monitoring.

Author:

    Vadim Eydelman  06/07/1996


--*/
#include "precomp.h"
#pragma hdrstop

#define OPERATION_DEL_STATICSERVICE    (-1)
#define OPERATION_SET_STATICSERVICE    0
#define OPERATION_ADD_STATICSERVICE    1

DWORD
AdmSetStSvc (
    int         operation,
    LPWSTR      InterfaceNameW,
    USHORT      Type,
    PUCHAR      Name,
    PUCHAR      pNetwork        OPTIONAL,
    PUCHAR      pNode           OPTIONAL,
    PUCHAR      pSocket         OPTIONAL,
    PUSHORT     pHops           OPTIONAL
);

DWORD
CfgSetStSvc (
    int         operation,
    LPWSTR      InterfaceNameW,
    USHORT      Type,
    PUCHAR      Name,
    PUCHAR      pNetwork        OPTIONAL,
    PUCHAR      pNode           OPTIONAL,
    PUCHAR      pSocket         OPTIONAL,
    PUSHORT     pHops           OPTIONAL
);

DWORD
UpdateStSvcInfo(
    LPBYTE      pIfBlock,
    USHORT      Type,
    PUCHAR      Name,
    PUCHAR      pNetwork        OPTIONAL,
    PUCHAR      pNode           OPTIONAL,
    PUCHAR      pSocket         OPTIONAL,
    PUSHORT     pHops           OPTIONAL
);



int
APIENTRY 
HelpStSvc (
    IN    int                   argc,
    IN    WCHAR                *argv[]
) 
{
    DisplayIPXMessage (g_hModule, MSG_IPX_HELP_STATICSERVICE);
    return 0;
}


int
APIENTRY 
ShowStSvc (
    IN    int                   argc,
    IN    WCHAR                *argv[],
    IN    BOOL                  bDump
) 
{

    DWORD       rc, rc2;
    WCHAR       IfName[ MAX_INTERFACE_NAME_LEN + 1 ];
    DWORD       dwSize = sizeof(IfName);

    
    if (argc > 0) 
    {
        unsigned    count;
        
#define InterfaceNameW argv[0]
        count = wcslen (InterfaceNameW);


        //======================================
        // Translate the Interface Name
        //======================================

        rc2 = IpmontrGetIfNameFromFriendlyName( InterfaceNameW, IfName, &dwSize );
        
        if ( (count > 0) && (count <= MAX_INTERFACE_NAME_LEN) ) 
        {
            LPBYTE   pIfBlock;
            BOOLEAN  fRouter = FALSE;
            USHORT   Type;
            UCHAR    Name[48];

            if (argc > 1) 
            {
                UINT        n;
                UINT        count;
                
                if ((argc == 3)
                     && (swscanf (argv[1], L"%4x%n", &Type, &n) == 1)
                     && (n == wcslen (argv[1]))
                     && ((count = wcstombs (Name, argv[2], sizeof(Name))
                    ) > 0)
                     && (count < sizeof (Name))) 
                {
                    NOTHING;
                }
                else 
                {
                    rc = ERROR_INVALID_PARAMETER;
                    
                    if ( !bDump )
                    {
                        DisplayIPXMessage (g_hModule, MSG_IPX_HELP_STATICSERVICE);
                    }
                    goto Exit;
                }
            }
            else
            {
                if ( !bDump )
                {
                    DisplayIPXMessage (g_hModule, MSG_STATICSERVICE_TABLE_HDR);
                }
            }

            if (g_hMprAdmin) 
            {
                HANDLE hIfAdm;
                
                rc = MprAdminInterfaceGetHandle(
                        g_hMprAdmin, IfName, &hIfAdm, FALSE
                        );
                        
                if (rc == NO_ERROR) 
                {
                    DWORD   sz;
                    
                    rc = MprAdminInterfaceTransportGetInfo(
                            g_hMprAdmin, hIfAdm, PID_IPX, &pIfBlock, &sz
                            );
                }
                
                if (rc == NO_ERROR)
                {
                    fRouter = TRUE;
                }
                
                else 
                {
                    if ( !bDump )
                    {
                        DisplayError( g_hModule, rc);
                    }
                    
                    goto GetFromCfg;
                }
            }
            else 
            {
            
                HANDLE        hIfCfg;
GetFromCfg:
                rc = MprConfigInterfaceGetHandle(
                        g_hMprConfig, IfName, &hIfCfg
                        );
                        
                if (rc == NO_ERROR) 
                {
                    HANDLE hIfTrCfg;
                    
                    rc = MprConfigInterfaceTransportGetHandle(
                            g_hMprConfig, hIfCfg, PID_IPX, &hIfTrCfg
                            );
                            
                    if (rc == NO_ERROR) 
                    {
                        DWORD    sz;
                        
                        rc = MprConfigInterfaceTransportGetInfo(
                                g_hMprConfig, hIfCfg, hIfTrCfg, &pIfBlock, &sz
                                );
                    }
                }
            }

            if (rc == NO_ERROR) 
            {
                PIPX_TOC_ENTRY pSsToc;

                pSsToc = GetIPXTocEntry(
                            (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                            IPX_STATIC_SERVICE_INFO_TYPE
                            );
                            
                if (pSsToc != NULL) 
                {
                    PIPX_STATIC_SERVICE_INFO    pSsInfo;
                    UINT                        i;

                    pSsInfo = (PIPX_STATIC_SERVICE_INFO)
                                    (pIfBlock + pSsToc->Offset);
                                    
                    for (i = 0; i < pSsToc->Count; i++, pSsInfo++) 
                    {
                        if (argc > 1) 
                        {
                            if ((Type == pSsInfo->Type)
                                 && (_stricmp (Name, pSsInfo->Name) == 0)) 
                            {
                                DisplayIPXMessage(
                                    g_hModule, MSG_STATICSERVICE_SCREEN_FMT,
                                    pSsInfo->Type, pSsInfo->Name, 
                                    pSsInfo->HopCount, pSsInfo->Network[0], 
                                    pSsInfo->Network[1], pSsInfo->Network[2],
                                    pSsInfo->Network[3],
                                    pSsInfo->Node[0], pSsInfo->Node[1],
                                    pSsInfo->Node[2], pSsInfo->Node[3],
                                    pSsInfo->Node[4], pSsInfo->Node[5],
                                    pSsInfo->Socket[0], pSsInfo->Socket[1]
                                    );
                                    
                                break;
                            }
                        }
                        else 
                        {
                            if ( bDump )
                            {
                                WCHAR Name[ 48 + 1];

                                //
                                // Whistler bug 299007 ipxmontr.dll prefast warnings
                                //

                                mbstowcs(
                                    Name,
                                    pSsInfo->Name,
                                    sizeof( Name ) / sizeof(WCHAR) );

                                DisplayMessageT(
                                    DMP_IPX_ADD_STATIC_SERVICE, InterfaceNameW,
                                    pSsInfo->Type, Name, 
                                    pSsInfo->Network[0], pSsInfo->Network[1], 
                                    pSsInfo->Network[2], pSsInfo->Network[3],
                                    pSsInfo->Node[0], pSsInfo->Node[1],
                                    pSsInfo->Node[2], pSsInfo->Node[3],
                                    pSsInfo->Node[4], pSsInfo->Node[5],
                                    pSsInfo->Socket[0], pSsInfo->Socket[1],
                                    pSsInfo->HopCount
                                    );
                            }

                            else
                            {
                                DisplayIPXMessage(
                                    g_hModule, MSG_STATICSERVICE_TABLE_FMT,
                                    pSsInfo->Type, pSsInfo->Name, 
                                    pSsInfo->HopCount
                                    );
                            }
                        }
                    }
                    
                    if ( (argc > 1) && (i >= pSsToc->Count) ) 
                    {
                        rc = ERROR_FILE_NOT_FOUND;
                        if ( !bDump )
                        {
                            DisplayIPXMessage (g_hModule, MSG_STATICSERVICE_NONE_FOUND);
                        }
                    }
                }
                
                else 
                {
                    rc = ERROR_FILE_NOT_FOUND;
                    if ( !bDump )
                    {
                        DisplayIPXMessage (g_hModule, MSG_STATICSERVICE_NONE_FOUND);
                    }
                }
                
                if (fRouter)
                {
                    MprAdminBufferFree (pIfBlock);
                }
                else
                {
                    MprConfigBufferFree (pIfBlock);
                }
            }
            else
            {
                if ( !bDump )
                {
                    DisplayError( g_hModule, rc);
                }
            }
        }
        else 
        {
            rc = ERROR_INVALID_PARAMETER;
            if ( !bDump )
            {
                DisplayIPXMessage (g_hModule, MSG_INVALID_INTERFACE_NAME);
            }
        }
    }
    else 
    {
        rc = ERROR_INVALID_PARAMETER;
        if ( !bDump )
        {
            DisplayIPXMessage (g_hModule, MSG_IPX_HELP_STATICSERVICE);
        }
    }

Exit:
    return rc ;

#undef InterfaceNameW
}


int
APIENTRY 
SetStSvc (
    IN    int                   argc,
    IN    WCHAR                *argv[]
) 
{
    DWORD       rc = NO_ERROR, rc2;
    WCHAR       IfName[ MAX_INTERFACE_NAME_LEN + 1 ];
    DWORD       dwSize = sizeof(IfName);

    if (argc > 2) 
    {
        unsigned    count;

#define InterfaceNameW argv[0]
        count = wcslen (InterfaceNameW);


        //======================================
        // Translate the Interface Name
        //======================================
            rc2 = IpmontrGetIfNameFromFriendlyName(
                    InterfaceNameW, IfName, &dwSize
                    );
                    
        if ( (count > 0) && (count <= MAX_INTERFACE_NAME_LEN) ) 
        {
            UINT    n;
            USHORT  Type;
            UCHAR   Name[48];
            
            if ( (swscanf (argv[1], L"%4hx%n", &Type, &n) == 1 )
                 && (n == wcslen (argv[1]))
                 && ((count = wcstombs (Name, argv[2], sizeof(Name))) > 0)
                 && (count < sizeof (Name))) 
            {
                int    i;
                USHORT      val2;
                ULONG       val4;
                ULONGLONG   val8;
                UCHAR       network[4], node[6], socket[2];
                USHORT      hops;
                PUCHAR      pNetwork = NULL, pNode = NULL, pSocket = NULL;
                PUSHORT     pHops = NULL;


                for ( i = 3; i < argc; i++ ) 
                {
                    if ( !_wcsicmp( argv[i], TOKEN_NETWORK ) )
                    {
                        if ((pNetwork == NULL)
                             && (i < argc - 1)
                             && (swscanf (argv[i+1], L"%8lx%n", &val4, &n) == 1)
                             && (n == wcslen (argv[i+1]))) 
                        {
                            i += 1;
                            network[0] = (BYTE)(val4 >> 24);
                            network[1] = (BYTE)(val4 >> 16);
                            network[2] = (BYTE)(val4 >> 8);
                            network[3] = (BYTE)val4;
                            pNetwork = network;
                        }
                        else
                        {
                            break;
                        }
                    }
                    
                    else if ( !_wcsicmp( argv[i], TOKEN_NODE ) )
                    {
                        if ((pNode == NULL)
                             && (i < argc - 1)
                             && (swscanf (argv[i+1], L"%12I64x%n", &val8,
                             &n) == 1)
                             && (n == wcslen (argv[i+1]))) 
                        {
                            i += 1;
                            node[0] = (BYTE)(val8 >> 40);
                            node[1] = (BYTE)(val8 >> 32);
                            node[2] = (BYTE)(val8 >> 24);
                            node[3] = (BYTE)(val8 >> 16);
                            node[4] = (BYTE)(val8 >> 8);
                            node[5] = (BYTE)val8;
                            pNode = node;
                        }
                        else
                        {
                            break;
                        }
                    }

                    
                    else if ( !_wcsicmp( argv[i], TOKEN_SOCKET ) )
                    {
                        if ((pSocket == NULL)
                             && (i < argc - 1)
                             && (swscanf (argv[i+1], L"%4hx%n", &val2, &n) == 1)
                             && (n == wcslen (argv[i+1]))) 
                        {
                            i += 1;
                            socket[0] = (BYTE)(val2 >> 8);
                            socket[1] = (BYTE)val2;
                            pSocket = socket;
                        }
                        else
                        {
                            break;
                        }
                    }
                    
                    else if ( !_wcsicmp( argv[i], TOKEN_HOPS ) ) 
                    {
                        if ((pHops == NULL)
                             && (i < argc - 1)
                             && (swscanf (argv[i+1], L"%hd%n", &hops, &n) == 1)
                             && (n == wcslen (argv[i+1]))) 
                        {
                            i += 1;
                            pHops = &hops;
                        }
                        else
                        {
                            break;
                        }
                    }

                    else if (pNetwork == NULL) 
                    {
                        if ((swscanf (argv[i], L"%8lx%n", &val4, &n) == 1)
                             && (n == wcslen (argv[i]))) 
                        {
                            network[0] = (BYTE)(val4 >> 24);
                            network[1] = (BYTE)(val4 >> 16);
                            network[2] = (BYTE)(val4 >> 8);
                            network[3] = (BYTE)val4;
                            pNetwork = network;
                        }
                        else
                        {
                            break;
                        }
                    }
                    
                    else if (pNode == NULL) 
                    {
                        if ((swscanf (argv[i], L"%12I64x%n", &val8, &n) == 1)
                             && (n == wcslen (argv[i]))) 
                        {
                            node[0] = (BYTE)(val8 >> 40);
                            node[1] = (BYTE)(val8 >> 32);
                            node[2] = (BYTE)(val8 >> 24);
                            node[3] = (BYTE)(val8 >> 16);
                            node[4] = (BYTE)(val8 >> 8);
                            node[5] = (BYTE)val8;
                            pNode = node;
                        }
                        else
                        {
                            break;
                        }
                    }
                    
                    else if (pSocket == NULL) 
                    {
                        if ((swscanf (argv[i], L"%4hx%n", &val2, &n) == 1)
                             && (n == wcslen (argv[i]))) 
                        {
                            socket[0] = (BYTE)(val2 >> 8);
                            socket[1] = (BYTE)val2;
                            pSocket = socket;
                        }
                        else
                        {
                            break;
                        }
                    }
                    
                    else if (pHops == NULL) 
                    {
                        if ((swscanf (argv[i], L"%hd%n", &hops, &n) == 1)
                             && (n == wcslen (argv[i]))) 
                        {
                            pHops = &hops;
                        }
                        else
                        {
                            break;
                        }
                    }
                    else
                    {
                        break;
                    }
                }
                
                if (i == argc) 
                {
                    if (g_hMprAdmin)
                    {
                        rc = AdmSetStSvc(
                                OPERATION_SET_STATICSERVICE, IfName,
                                 Type, Name, pNetwork, pNode, pSocket, pHops
                                 );
                    }
                    else
                    {
                        rc = NO_ERROR;
                    }
                    
                    if (rc == NO_ERROR)
                    {
                        rc = CfgSetStSvc(
                                OPERATION_SET_STATICSERVICE, IfName,
                                Type, Name, pNetwork, pNode, pSocket, pHops
                                );
                    }
                }

                else
                {
                    DisplayIPXMessage (g_hModule, MSG_IPX_HELP_STATICSERVICE);
                }
            }

            else
            {
                DisplayIPXMessage (g_hModule, MSG_IPX_HELP_STATICSERVICE);
            }
        }
        else 
        {
            DisplayIPXMessage (g_hModule, MSG_INVALID_INTERFACE_NAME);
            rc = ERROR_INVALID_PARAMETER;
        }
    }
    else 
    {
        DisplayIPXMessage (g_hModule, MSG_IPX_HELP_STATICSERVICE);
        rc = ERROR_INVALID_PARAMETER;
    }

    return rc ;

#undef InterfaceNameW
}


int
APIENTRY 
CreateStSvc (
    IN    int                   argc,
    IN    WCHAR                *argv[]
) 
{
    DWORD       rc = NO_ERROR, rc2;
    WCHAR       IfName[ MAX_INTERFACE_NAME_LEN + 1 ];
    DWORD       dwSize = sizeof(IfName);

    if (argc >= 7) 
    {
        unsigned    count;
        
#define InterfaceNameW argv[0]
        count = wcslen (InterfaceNameW);

        //======================================
        // Translate the Interface Name
        //======================================

        rc2 = IpmontrGetIfNameFromFriendlyName(
                InterfaceNameW, IfName, &dwSize
                );
                
        if ( (count > 0) && (count <= MAX_INTERFACE_NAME_LEN) ) 
        {
            UINT        n;
            USHORT      val2;
            ULONG       val4;
            ULONGLONG   val8;
            USHORT      Type;
            UCHAR       Name[48];
            UCHAR       Network[4], Node[6], Socket[2];
            USHORT      Hops;


            if ((swscanf (argv[1], L"%4hx%n", &Type, &n) == 1)
                 && (n == wcslen (argv[1]))
                 && ((count =  wcstombs (Name, argv[2], sizeof(Name))) > 0)
                 && (count < sizeof (Name))) 
            {
                if ((swscanf (argv[3], L"%8lx%n", &val4, &n) == 1)
                     && (n == wcslen (argv[3]))) 
                {
                    Network[0] = (BYTE)(val4 >> 24);
                    Network[1] = (BYTE)(val4 >> 16);
                    Network[2] = (BYTE)(val4 >> 8);
                    Network[3] = (BYTE)val4;
                    
                    if ((swscanf (argv[4], L"%12I64x%n", &val8, &n) == 1)
                         && (n == wcslen (argv[4]))) 
                    {
                        Node[0] = (BYTE)(val8 >> 40);
                        Node[1] = (BYTE)(val8 >> 32);
                        Node[2] = (BYTE)(val8 >> 24);
                        Node[3] = (BYTE)(val8 >> 16);
                        Node[4] = (BYTE)(val8 >> 8);
                        Node[5] = (BYTE)val8;
                        
                        if ((swscanf (argv[5], L"%4hx%n", &val2, &n) == 1)
                             && (n == wcslen (argv[5]))) 
                        {
                            Socket[0] = (BYTE)(val2 >> 8);
                            Socket[1] = (BYTE)val2;
                            
                            if ((swscanf (argv[6], L"%hd%n", &Hops, &n) == 1)
                                 && (n == wcslen (argv[6]))) 
                            {
                                if (g_hMprAdmin)
                                {
                                    rc = AdmSetStSvc(
                                            OPERATION_ADD_STATICSERVICE, IfName,
                                            Type, Name, Network, Node, Socket, &Hops
                                            );
                                }
                                else
                                {
                                    rc = NO_ERROR;
                                }
                                
                                if (rc == NO_ERROR)
                                {
                                    rc = CfgSetStSvc(
                                            OPERATION_ADD_STATICSERVICE, IfName,
                                            Type, Name, Network, Node, Socket, &Hops
                                            );
                                }
                            }
                            else 
                            {
                                rc = ERROR_INVALID_PARAMETER;
                                DisplayIPXMessage (g_hModule, MSG_IPX_HELP_STATICSERVICE);
                            }
                        }
                        else 
                        {
                            rc = ERROR_INVALID_PARAMETER;
                            DisplayIPXMessage (g_hModule, MSG_IPX_HELP_STATICSERVICE);
                        }
                    }
                    else 
                    {
                        rc = ERROR_INVALID_PARAMETER;
                        DisplayIPXMessage (g_hModule, MSG_IPX_HELP_STATICSERVICE);
                    }
                }
                else 
                {
                    rc = ERROR_INVALID_PARAMETER;
                    DisplayIPXMessage (g_hModule, MSG_IPX_HELP_STATICSERVICE);
                }
            }
        }
        else 
        {
            DisplayIPXMessage (g_hModule, MSG_INVALID_INTERFACE_NAME);
            rc = ERROR_INVALID_PARAMETER;
        }
    }
    else 
    {
        DisplayIPXMessage (g_hModule, MSG_IPX_HELP_STATICSERVICE);
        rc = ERROR_INVALID_PARAMETER;
    }
    
    return rc ;
    
#undef InterfaceNameW
}


int
APIENTRY 
DeleteStSvc (
    IN    int                   argc,
    IN    WCHAR                *argv[]
) 
{
    DWORD       rc, rc2;
    WCHAR       IfName[ MAX_INTERFACE_NAME_LEN + 1 ];
    DWORD       dwSize = sizeof(IfName);

    if (argc >= 3) 
    {
        unsigned    count;

#define InterfaceNameW argv[0]
        count = wcslen (InterfaceNameW);

        //======================================
        // Translate the Interface Name
        //======================================

        rc2 = IpmontrGetIfNameFromFriendlyName(
                InterfaceNameW, IfName, &dwSize
                );

        if ((count > 0) && (count <= MAX_INTERFACE_NAME_LEN)) 
        {
            UINT    n;
            USHORT    Type;
            UCHAR    Name[48];

            if ((swscanf (argv[1], L"%4hx%n", &Type, &n) == 1)
                 && (n == wcslen (argv[1]))
                 && ((count = wcstombs (Name, argv[2], sizeof(Name)) ) > 0)
                 && (count < sizeof (Name))) 
            {
                if (g_hMprAdmin)
                {
                    rc = AdmSetStSvc(
                            OPERATION_DEL_STATICSERVICE, IfName, 
                            Type, Name, NULL, NULL, NULL, NULL
                            );
                }
                else
                {
                    rc = NO_ERROR;
                }
                
                if (rc == NO_ERROR)
                {
                    rc = CfgSetStSvc(
                            OPERATION_DEL_STATICSERVICE, IfName,
                            Type, Name, NULL, NULL, NULL, NULL
                            );
                }
            }
            else 
            {
                rc = ERROR_INVALID_PARAMETER;
                DisplayIPXMessage (g_hModule, MSG_IPX_HELP_STATICSERVICE);
            }
        }
        else 
        {
            rc = ERROR_INVALID_PARAMETER;
            DisplayIPXMessage (g_hModule, MSG_INVALID_INTERFACE_NAME);
        }
    }
    else 
    {
        rc = ERROR_INVALID_PARAMETER;
        DisplayIPXMessage (g_hModule, MSG_IPX_HELP_STATICSERVICE);
    }

    return rc ;

#undef InterfaceNameW
}


BOOL
StSvcEqual (
    PVOID    info1,
    PVOID    info2
) 
{

#define StSvc1 ((PIPX_STATIC_SERVICE_INFO)info1)
#define StSvc2 ((PIPX_STATIC_SERVICE_INFO)info2)

    return (StSvc1->Type == StSvc2->Type)
     && (_stricmp (StSvc1->Name, StSvc2->Name) == 0);

#undef StSvc1
#undef StSvc2

}


DWORD
AdmSetStSvc (
    int         operation,
    LPWSTR      InterfaceNameW,
    USHORT      Type,
    PUCHAR      Name,
    PUCHAR      pNetwork        OPTIONAL,
    PUCHAR      pNode           OPTIONAL,
    PUCHAR      pSocket         OPTIONAL,
    PUSHORT     pHops           OPTIONAL
) 
{
    DWORD   rc;
    WCHAR   IfName[ MAX_INTERFACE_NAME_LEN + 1 ];
    DWORD   dwSize = sizeof(IfName);
    HANDLE  hIfAdm;
    
    rc = MprAdminInterfaceGetHandle(
            g_hMprAdmin, InterfaceNameW, &hIfAdm, FALSE
            );
            
    if (rc == NO_ERROR) 
    {
        LPBYTE  pIfBlock;
        DWORD   sz;

        
        rc = MprAdminInterfaceTransportGetInfo(
                g_hMprAdmin, hIfAdm, PID_IPX, &pIfBlock, &sz
                );
                
        if ( rc == NO_ERROR ) 
        {
            UINT    msg;
            LPBYTE  pNewBlock;

            switch (operation) 
            {
                case OPERATION_SET_STATICSERVICE:
                
                    rc = UpdateStSvcInfo(
                            pIfBlock, Type, Name, pNetwork, pNode, pSocket, pHops
                            );
                            
                    pNewBlock = pIfBlock;
                    msg = MSG_STATICSERVICE_SET_ADM;
                    
                    break;
                    
                case OPERATION_ADD_STATICSERVICE:
                {
                    IPX_STATIC_SERVICE_INFO    SsInfo;
                    
                    SsInfo.Type = Type;
                    strcpy (SsInfo.Name, Name);
                    SsInfo.HopCount = *pHops;
                    
                    memcpy (SsInfo.Network, pNetwork, sizeof (SsInfo.Network));
                    memcpy (SsInfo.Node, pNode,    sizeof (SsInfo.Node));
                    memcpy (SsInfo.Socket, pSocket,    sizeof (SsInfo.Socket));
                    
                    rc = AddIPXInfoEntry(
                            (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                            IPX_STATIC_SERVICE_INFO_TYPE,
                            sizeof (SsInfo), &SsInfo, StSvcEqual,
                            (PIPX_INFO_BLOCK_HEADER * ) & pNewBlock
                            );
                            
                    msg = MSG_STATICSERVICE_CREATED_ADM;
                    
                    break;
                }        
                case OPERATION_DEL_STATICSERVICE:
                {
                    IPX_STATIC_SERVICE_INFO    SsInfo;
                    
                    SsInfo.Type = Type;
                    strcpy (SsInfo.Name, Name);
                    
                    rc = DeleteIPXInfoEntry (
                            (PIPX_INFO_BLOCK_HEADER)pIfBlock, 
                            IPX_STATIC_SERVICE_INFO_TYPE, sizeof (SsInfo),
                            &SsInfo, StSvcEqual,
                            (PIPX_INFO_BLOCK_HEADER * ) & pNewBlock
                            );
                            
                    msg = MSG_STATICSERVICE_DELETED_ADM;
                    
                    break;
                }
            }

            if (rc == NO_ERROR) 
            {
                rc = MprAdminInterfaceTransportSetInfo(
                        g_hMprAdmin, hIfAdm, PID_IPX, pNewBlock,
                        ((PIPX_INFO_BLOCK_HEADER)pNewBlock)->Size
                        );
                        
                if (pNewBlock != pIfBlock)
                {
                    GlobalFree (pNewBlock);
                }
                
                if (rc == NO_ERROR) 
                {
                    DWORD rc2;
                    
                    //======================================
                    // Translate the Interface Name
                    //======================================

                    rc2 = IpmontrGetFriendlyNameFromIfName(
                            InterfaceNameW, IfName, &dwSize
                            );

                    if ( rc2 == NO_ERROR )
                    {
                        DisplayIPXMessage (g_hModule, msg, IfName);
                    }
                }
                else
                {
                    DisplayError( g_hModule, rc);
                }
            }
            
            else
            {
                DisplayError( g_hModule, rc);
            }

            MprAdminBufferFree (pIfBlock);
        }
    }
    
    else
    {
        DisplayError( g_hModule, rc);
    }

    return rc;
}


DWORD
CfgSetStSvc (
    int         operation,
    LPWSTR      InterfaceNameW,
    USHORT      Type,
    PUCHAR      Name,
    PUCHAR      pNetwork        OPTIONAL,
    PUCHAR      pNode           OPTIONAL,
    PUCHAR      pSocket         OPTIONAL,
    PUSHORT     pHops           OPTIONAL
) 
{
    DWORD       rc;
    WCHAR       IfName[ MAX_INTERFACE_NAME_LEN + 1 ];
    DWORD       dwSize = sizeof(IfName);
    HANDLE      hIfCfg;

    rc = MprConfigInterfaceGetHandle(
            g_hMprConfig, InterfaceNameW, &hIfCfg
            );
            
    if (rc == NO_ERROR) 
    {
        HANDLE    hIfTrCfg;
        
        rc = MprConfigInterfaceTransportGetHandle(
                g_hMprConfig, hIfCfg, PID_IPX, &hIfTrCfg
                );
                
        if (rc == NO_ERROR) 
        {
            LPBYTE   pIfBlock;
            DWORD    sz;
            
            rc = MprConfigInterfaceTransportGetInfo(
                    g_hMprConfig, hIfCfg, hIfTrCfg, &pIfBlock, &sz
                    );
                    
            if (rc == NO_ERROR) 
            {
                LPBYTE  pNewBlock;
                UINT    msg;
                
                switch (operation) 
                {
                    case OPERATION_SET_STATICSERVICE:

                        rc = UpdateStSvcInfo(
                                pIfBlock, Type, Name, pNetwork, pNode, pSocket, pHops
                                );
                                
                        pNewBlock = pIfBlock;
                        msg = MSG_STATICSERVICE_SET_CFG;
                        
                        break;
                        
                    case OPERATION_ADD_STATICSERVICE:
                    {
                        IPX_STATIC_SERVICE_INFO    SsInfo;
                        
                        SsInfo.Type = Type;
                        strcpy (SsInfo.Name, Name);
                        
                        memcpy (SsInfo.Network, pNetwork, sizeof (SsInfo.Network));
                        memcpy (SsInfo.Node, pNode,    sizeof (SsInfo.Node));
                        memcpy (SsInfo.Socket, pSocket,    sizeof (SsInfo.Socket));
                        
                        SsInfo.HopCount = *pHops;
                        
                        rc = AddIPXInfoEntry(
                                (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                                IPX_STATIC_SERVICE_INFO_TYPE,
                                sizeof (SsInfo), &SsInfo, StSvcEqual,
                                (PIPX_INFO_BLOCK_HEADER * ) & pNewBlock
                                );
                                
                        msg = MSG_STATICSERVICE_CREATED_CFG;
                        
                        break;
                    }
                    
                    case OPERATION_DEL_STATICSERVICE:
                    {
                        IPX_STATIC_SERVICE_INFO    SsInfo;
                        
                        SsInfo.Type = Type;
                        strcpy (SsInfo.Name, Name);
                        
                        rc = DeleteIPXInfoEntry (
                                (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                                IPX_STATIC_SERVICE_INFO_TYPE,
                                sizeof (SsInfo), &SsInfo, StSvcEqual,
                                (PIPX_INFO_BLOCK_HEADER * ) & pNewBlock
                                );
                                
                        msg = MSG_STATICSERVICE_DELETED_CFG;
                        break;
                    }
                }

                
                if (rc == NO_ERROR) 
                {
                    rc = MprConfigInterfaceTransportSetInfo(
                            g_hMprConfig, hIfCfg, hIfTrCfg, pNewBlock,
                            ((PIPX_INFO_BLOCK_HEADER)pNewBlock)->Size
                            );
                            
                    if (pNewBlock != pIfBlock)
                    {
                        GlobalFree (pNewBlock);
                    }
                    
                    if (rc == NO_ERROR) 
                    {
                        DWORD rc2;
                        
                        //======================================
                        // Translate the Interface Name
                        //======================================
                        
                        rc2 = IpmontrGetFriendlyNameFromIfName(
                                InterfaceNameW, IfName, &dwSize
                                );

                        if ( rc2 == NO_ERROR )
                        {
                            DisplayIPXMessage (g_hModule, msg, IfName );
                        }
                    }
                    else
                    {
                        DisplayError( g_hModule, rc);
                    }
                }
                else
                {
                    DisplayError( g_hModule, rc);
                }

                MprConfigBufferFree (pIfBlock);
            }
            
            else
            {
                DisplayError( g_hModule, rc);
            }
        }
        else
        {
            DisplayError( g_hModule, rc);
        }
    }

    else
    {
        DisplayError( g_hModule, rc);
    }

    return rc;
}


DWORD
UpdateStSvcInfo(
    LPBYTE        pIfBlock,
    USHORT        Type,
    PUCHAR        Name,
    PUCHAR        pNetwork  OPTIONAL,
    PUCHAR        pNode     OPTIONAL,
    PUCHAR        pSocket   OPTIONAL,
    PUSHORT       pHops     OPTIONAL
) 
{
    DWORD            rc;
    PIPX_TOC_ENTRY    pSsToc;

    pSsToc = GetIPXTocEntry(
                (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                IPX_STATIC_SERVICE_INFO_TYPE
                );
                
    if (pSsToc != NULL) 
    {
        PIPX_STATIC_SERVICE_INFO    pSsInfo;
        UINT                        i;

        pSsInfo = (PIPX_STATIC_SERVICE_INFO)
                    (pIfBlock + pSsToc->Offset);
                    
        for (i = 0; i < pSsToc->Count; i++, pSsInfo++) 
        {
            if ((Type == pSsInfo->Type)
                 && (_stricmp (Name, pSsInfo->Name) == 0))
            break;
        }

        
        if (i < pSsToc->Count) 
        {
            if (ARGUMENT_PRESENT (pNetwork))
            memcpy (pSsInfo->Network, pNetwork,
                sizeof (pSsInfo->Network));
            if (ARGUMENT_PRESENT (pNode))
            memcpy (pSsInfo->Node, pNode,
                sizeof (pSsInfo->Node));
            if (ARGUMENT_PRESENT (pSocket))
            memcpy (pSsInfo->Socket, pSocket,
                sizeof (pSsInfo->Socket));
            if (ARGUMENT_PRESENT (pHops))
            pSsInfo->HopCount = *pHops;
            rc = NO_ERROR;
        }
        else
        {
            rc = ERROR_FILE_NOT_FOUND;
        }
    }

    else
    {
        rc = ERROR_FILE_NOT_FOUND;
    }

    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ipx\ipxmon\stsvcs.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    stsvcs.h

Abstract:

    IPX Router Console Monitoring and Configuration tool.
    Static Service configuration and monitoring. Header File

Author:

    Vadim Eydelman  06/07/1996


--*/
#ifndef _IPXMON_STSVCS_
#define _IPXMON_STSVCS_

int APIENTRY 
HelpStSvc (
    IN    int                    argc,
    IN    WCHAR                *argv[]
    );

int APIENTRY 
ShowStSvc (
    IN    int                    argc,
    IN    WCHAR                *argv[],
    IN    BOOL                  bDump
    );

int APIENTRY 
SetStSvc (
    IN    int                    argc,
    IN    WCHAR                *argv[]
    );

int APIENTRY 
CreateStSvc (
    IN    int                    argc,
    IN    WCHAR                *argv[]
    );

int APIENTRY 
DeleteStSvc (
    IN    int                    argc,
    IN    WCHAR                *argv[]
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ipx\protocols\makefile.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ipx\ipxmon\tfflts.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    tfflts.h

Abstract:

    IPX Router Console Monitoring and Configuration tool.
    TF filter configuration and monitoring. Header File

Author:

    Vadim Eydelman  06/07/1996


--*/
#ifndef _IPXMON_TFFLTS_
#define _IPXMON_TFFLTS_

int APIENTRY 
HelpTfFlt (
    IN    int                    argc,
    IN    WCHAR                *argv[]
    );

int APIENTRY 
ShowTfFlt (
    IN    int                    argc,
    IN    WCHAR                *argv[],
    IN    BOOL                  bDump
    );

int APIENTRY 
SetTfFlt (
    IN    int                    argc,
    IN    WCHAR                *argv[]
    );

int APIENTRY 
CreateTfFlt (
    IN    int                    argc,
    IN    WCHAR                *argv[]
    );

int APIENTRY 
DeleteTfFlt (
    IN    int                    argc,
    IN    WCHAR                *argv[]
    );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ipx\ipxmon\tfflts.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    tfflts.c

Abstract:

    IPX Router Console Monitoring and Configuration tool.
    Traffic Filters configuration and monitoring.

Author:

    Vadim Eydelman  06/07/1996


--*/
#include "precomp.h"
#pragma hdrstop

#define OPERATION_DEL_TRAFFICFILTER    (-1)
#define OPERATION_SET_TRAFFICFILTER    0
#define OPERATION_ADD_TRAFFICFILTER    1



DWORD
ReadTfFltDef (
    int                         argc,
    WCHAR                      *argv[],
    PIPX_TRAFFIC_FILTER_INFO    pTfFlt
);

BOOL
TfFltEqual (
    PVOID    Info1,
    PVOID    Info2
);

VOID
PrintTrafficFilterInfo (
    PIPX_TRAFFIC_FILTER_GLOBAL_INFO pTfGlb,
    PIPX_TRAFFIC_FILTER_INFO        pTfFlt,
    ULONG                           count,
    PWCHAR                          wszIfName,
    PWCHAR                          wszMode,
    BOOL                            bDump
);

DWORD
AdmSetTfFlt (
    int                         operation,
    LPWSTR                      InterfaceNameW,
    ULONG                       Action,
    ULONG                       Mode,
    PIPX_TRAFFIC_FILTER_INFO    TfFlt
);

DWORD
CfgSetTfFlt (
    int                         operation,
    LPWSTR                      InterfaceNameW,
    ULONG                       Action,
    ULONG                       Mode,
    PIPX_TRAFFIC_FILTER_INFO    TfFlt
);



int
APIENTRY 
HelpTfFlt (
    IN    int                   argc,
    IN    WCHAR                *argv[]
)
{
    DisplayIPXMessage (g_hModule, MSG_IPX_HELP_TRAFFICFILTER);
    return 0;
}


int
APIENTRY 
ShowTfFlt (
    IN    int                   argc,
    IN    WCHAR                *argv[],
    IN    BOOL                  bDump
)
{
    WCHAR   IfName[ MAX_INTERFACE_NAME_LEN + 1 ];
    DWORD   rc, dwSize = sizeof(IfName);

    if (argc > 0)
    {
        LPBYTE      pIfBlock;
        BOOLEAN     fRouter = FALSE, fClient = FALSE;
        ULONG       mode = 0;
        PWCHAR      buffer[2];
        unsigned    count;

#define InterfaceNameW argv[0]
        count = wcslen (InterfaceNameW);


        if ( ( count > 0 ) && ( count <= MAX_INTERFACE_NAME_LEN ) )
        {
            fClient = FALSE;
        }
        else        
        {
            if ( !bDump )
            {
                DisplayIPXMessage (g_hModule, MSG_INVALID_INTERFACE_NAME);
            }
            rc = ERROR_INVALID_PARAMETER;
            goto Exit;
        }

        if (argc > 1)
        {
            UINT    n;

            if ( (argc == 2) && 
                 !MatchEnumTag( 
                    g_hModule, argv[1], NUM_TOKENS_IN_TABLE( FilterModes ),
                    FilterModes, &mode
                    ) ) 
            {
                NOTHING;
            }
            else 
            {
                if ( !bDump )
                {
                    DisplayIPXMessage (g_hModule, MSG_IPX_HELP_TRAFFICFILTER );
                }
                rc = ERROR_INVALID_PARAMETER;
                goto Exit;
            }
        }

        if (g_hMprAdmin) 
        {
            if (fClient) 
            {
                DWORD   sz;
                
                rc = MprAdminTransportGetInfo (
                        g_hMprAdmin, PID_IPX, NULL, NULL, &pIfBlock, &sz
                        );

                if (rc == NO_ERROR) 
                {
                    fRouter = TRUE;
                }
                else 
                {
                    if ( !bDump )
                    {
                        DisplayError( g_hModule, rc );
                    }
                    goto GetFromCfg;
                }
            }

            else 
            {
                HANDLE        hIfAdm;

                //======================================
                // Translate the Interface Name
                //======================================

                rc = IpmontrGetIfNameFromFriendlyName(
                        InterfaceNameW, IfName, &dwSize
                        );

                if ( rc == NO_ERROR )
                {
                    //======================================
                    rc = MprAdminInterfaceGetHandle(
                            g_hMprAdmin, IfName, &hIfAdm, FALSE 
                            );
                            
                    if (rc == NO_ERROR) 
                    {
                        DWORD   sz;
                        
                        rc = MprAdminInterfaceTransportGetInfo(
                                g_hMprAdmin, hIfAdm, PID_IPX, &pIfBlock, &sz
                                );
                    }
                    
                    if (rc == NO_ERROR)
                    {
                        fRouter = TRUE;
                    }
                    else 
                    {
                        if ( !bDump )
                        {
                            DisplayError( g_hModule, rc);
                        }
                        goto GetFromCfg;
                    }
                }

                else
                {
                    if ( !bDump )
                    {
                        DisplayError( g_hModule, rc );
                    }
                }
            }
        }
        
        else 
        {
        
GetFromCfg:
            if (fClient) 
            {
                HANDLE  hTrCfg;
                
                rc = MprConfigTransportGetHandle(
                        g_hMprConfig, PID_IPX, &hTrCfg 
                        );
                        
                if (rc == NO_ERROR) 
                {
                    DWORD   sz;
                    
                    rc = MprConfigTransportGetInfo(
                            g_hMprConfig, hTrCfg, NULL, NULL, &pIfBlock, 
                            &sz, NULL
                            );
                }
            }
            
            else 
            {
                HANDLE        hIfCfg;
                
                //======================================
                // Translate the Interface Name
                //======================================
                
                rc = IpmontrGetIfNameFromFriendlyName(
                        InterfaceNameW, IfName, &dwSize
                        );

                if ( rc == NO_ERROR )
                {
                    rc = MprConfigInterfaceGetHandle(
                            g_hMprConfig, IfName, &hIfCfg 
                            );
                            
                    if (rc == NO_ERROR) 
                    {
                        HANDLE    hIfTrCfg;
                        
                        rc = MprConfigInterfaceTransportGetHandle(
                                g_hMprConfig, hIfCfg, PID_IPX, &hIfTrCfg
                                );
                                
                        if (rc == NO_ERROR) 
                        {
                            DWORD    sz;
                            
                            rc = MprConfigInterfaceTransportGetInfo(
                                    g_hMprConfig, hIfCfg, hIfTrCfg, &pIfBlock, &sz
                                    );
                        }
                    }
                }
                else
                {
                    if ( !bDump )
                    {
                        DisplayError( g_hModule, rc );
                    }
                }
            }
        }


        if ( rc == NO_ERROR ) 
        {
            PIPX_TOC_ENTRY    pTfToc;
            PIPX_TOC_ENTRY    pTfGlToc;

            if ((mode == 0) || (mode == OUTPUT_FILTER)) 
            {
            
                pTfToc = GetIPXTocEntry (
                            (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                            IPX_OUT_TRAFFIC_FILTER_INFO_TYPE
                            );
                            
                pTfGlToc = GetIPXTocEntry (
                            (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                            IPX_OUT_TRAFFIC_FILTER_GLOBAL_INFO_TYPE
                            );
                            
                if ((pTfToc != NULL) && (pTfGlToc != NULL)) 
                {
                    PIPX_TRAFFIC_FILTER_GLOBAL_INFO pTfGlb = 
                        (PIPX_TRAFFIC_FILTER_GLOBAL_INFO)                        
                            (pIfBlock + pTfGlToc->Offset);

                    buffer[ 0 ] = GetEnumString(
                                    g_hModule, OUTPUT_FILTER, 
                                    NUM_TOKENS_IN_TABLE( FilterModes ),
                                    FilterModes
                                    );
                                        
                    buffer[ 1 ] = GetEnumString(
                                    g_hModule, pTfGlb->FilterAction,
                                    NUM_TOKENS_IN_TABLE( TfFilterActions ),
                                    TfFilterActions
                                    );

                    if ( buffer[ 0 ] && buffer [ 1 ] )
                    {
                        if ( bDump )
                        {
                            DisplayMessageT( 
                                DMP_IPX_SET_FILTER, InterfaceNameW,
                                buffer[0], buffer[1]
                                );
                        }

                        else
                        {
                            DisplayIPXMessage (
                                g_hModule, MSG_TRAFFICFILTER_TABLE_HDR,
                                buffer[0], buffer[1]
                                );
                        }
                        
                        PrintTrafficFilterInfo (
                            (PIPX_TRAFFIC_FILTER_GLOBAL_INFO)
                                (pIfBlock + pTfGlToc->Offset),
                            (PIPX_TRAFFIC_FILTER_INFO)
                                (pIfBlock + pTfToc->Offset),
                            pTfToc->Count,
                            InterfaceNameW,
                            buffer[ 0 ],
                            bDump
                            );
                    }
                }
                
                else 
                {
                    buffer[ 0 ] = GetEnumString(
                                    g_hModule, OUTPUT_FILTER, 
                                    NUM_TOKENS_IN_TABLE( FilterModes ),
                                    FilterModes
                                    );

                    buffer[ 1 ] = VAL_DENY;
                    
                    if ( buffer[ 0 ] && buffer[ 1 ] )
                    {
                        if ( bDump )
                        {
                            DisplayMessageT( 
                                DMP_IPX_SET_FILTER, InterfaceNameW,
                                buffer[ 0 ], buffer[ 1 ]
                                );
                        }

                        else
                        {
                            DisplayIPXMessage(
                                g_hModule, MSG_TRAFFICFILTER_TABLE_HDR,
                                buffer[0], buffer[1]
                                );
                        }
                    }
                }
            }

            
            if ((mode == 0) || (mode == INPUT_FILTER)) 
            {
                pTfToc = GetIPXTocEntry(
                            (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                            IPX_IN_TRAFFIC_FILTER_INFO_TYPE
                            );
                            
                pTfGlToc = GetIPXTocEntry(
                            (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                            IPX_IN_TRAFFIC_FILTER_GLOBAL_INFO_TYPE
                            );
                            
                if ((pTfToc != NULL) && (pTfGlToc != NULL)) 
                {
                    PIPX_TRAFFIC_FILTER_GLOBAL_INFO pTfGlb = 
                        (PIPX_TRAFFIC_FILTER_GLOBAL_INFO)
                            (pIfBlock + pTfGlToc->Offset);
                            
                    buffer[ 0 ] = GetEnumString(
                                    g_hModule, INPUT_FILTER, 
                                    NUM_TOKENS_IN_TABLE( FilterModes ),
                                    FilterModes
                                    );

                    buffer[ 1 ] = GetEnumString(
                                    g_hModule, pTfGlb->FilterAction,
                                    NUM_TOKENS_IN_TABLE( TfFilterActions ),
                                    TfFilterActions
                                    );
                    
                    if ( buffer[ 0 ] && buffer[ 1 ] )
                    {
                        if ( bDump )
                        {
                            DisplayMessageT( 
                                DMP_IPX_SET_FILTER, InterfaceNameW,
                                buffer[0], buffer[1]
                                );
                        }

                        else
                        {
                            DisplayIPXMessage(
                                g_hModule, MSG_TRAFFICFILTER_TABLE_HDR,
                                buffer[0], buffer[1]
                                );
                        }
                        
                        PrintTrafficFilterInfo (
                            (PIPX_TRAFFIC_FILTER_GLOBAL_INFO)
                                (pIfBlock + pTfGlToc->Offset),
                            (PIPX_TRAFFIC_FILTER_INFO)
                                (pIfBlock + pTfToc->Offset),
                            pTfToc->Count,
                            InterfaceNameW,
                            buffer[ 0 ],
                            bDump
                            );
                    }
                }
                else 
                {
                    buffer[ 0 ] = GetEnumString(
                                    g_hModule, INPUT_FILTER, 
                                    NUM_TOKENS_IN_TABLE( FilterModes ),
                                    FilterModes
                                    );
                                    
                    buffer[ 1 ] = VAL_DENY;
                                    
                    
                    if ( buffer[ 0 ] && buffer[ 1 ] )
                    {
                        if ( bDump )
                        {
                            DisplayMessageT( 
                                DMP_IPX_SET_FILTER, InterfaceNameW,
                                buffer[ 0 ], buffer[ 1 ]
                                );
                        }

                        else
                        {
                            DisplayIPXMessage(
                                g_hModule, MSG_TRAFFICFILTER_TABLE_HDR,
                                buffer[0], buffer[1]
                                );
                        }
                    }
                }
            }

            if (fRouter)
            {
                MprAdminBufferFree (pIfBlock);
            }
            else
            {
                MprConfigBufferFree (pIfBlock);
            }
        }
        else
        {
            if ( !bDump )
            {
                DisplayError( g_hModule, rc);
            }
        }
    }
    else 
    {
        if ( !bDump )
        {
            DisplayIPXMessage (g_hModule, MSG_IPX_HELP_TRAFFICFILTER);
        }
        rc = ERROR_INVALID_PARAMETER;
    }
Exit:
    return rc ;

#undef InterfaceNameW
}



int
APIENTRY 
SetTfFlt (
    IN    int                   argc,
    IN    WCHAR                *argv[]
) 
{
    DWORD        rc = NO_ERROR;

    
    if (argc == 3) 
    {
        BOOL        fClient;
        ULONG       mode, action;
        unsigned    count;
        PWCHAR       buffer;

#define InterfaceNameW argv[0]
        count = wcslen (InterfaceNameW);


#if 0   // Disable client interface filters for BETA
        if (_wcsicmp (argv[0],
            GetString (g_hModule, VAL_DIALINCLIENT, buffer)) == 0) 
        {
            fClient = TRUE;
        }
#endif
        if ( ( count > 0 ) && ( count <= MAX_INTERFACE_NAME_LEN ) ) 
        {
            fClient = FALSE;
        }
        else 
        {
            DisplayIPXMessage (g_hModule, MSG_INVALID_INTERFACE_NAME);
            rc = ERROR_INVALID_PARAMETER;
            goto Exit;
        }

        if ( !MatchEnumTag( 
                g_hModule, argv[1], NUM_TOKENS_IN_TABLE( FilterModes ),
                FilterModes, &mode
                ) &&
            !MatchEnumTag( 
                g_hModule, argv[2], NUM_TOKENS_IN_TABLE( TfFilterActions ),
                TfFilterActions, &action
                ) ) 
        {
            if (g_hMprAdmin)
            {
                rc = AdmSetTfFlt(
                        OPERATION_SET_TRAFFICFILTER,
                        fClient ? NULL : InterfaceNameW, action,
                        mode, NULL
                        );
            }
            else
            {
                rc = NO_ERROR;
            }
            
            if (rc == NO_ERROR)
            {
                rc = CfgSetTfFlt(
                        OPERATION_SET_TRAFFICFILTER,
                        fClient ? NULL : InterfaceNameW, action,
                        mode, NULL
                        );
            }
        }
        else 
        {
            rc = ERROR_INVALID_PARAMETER;
            DisplayIPXMessage (g_hModule, MSG_IPX_HELP_TRAFFICFILTER);
        }
    }
    
    else 
    {
        DisplayIPXMessage (g_hModule, MSG_IPX_HELP_TRAFFICFILTER);
        rc = ERROR_INVALID_PARAMETER;
    }

Exit:
    return (rc == NO_ERROR) ? 0 : 1;

#undef InterfaceNameW
}


int
APIENTRY 
CreateTfFlt (
    IN    int                   argc,
    IN    WCHAR                *argv[]
) 
{
    DWORD        rc = NO_ERROR;
    
    if (argc > 1) 
    {
        IPX_TRAFFIC_FILTER_INFO TfFlt;
        ULONG                   mode;
        BOOL                    fClient;
        PWCHAR                  buffer;
        unsigned                count;

        
#define InterfaceNameW argv[0]
        count = wcslen (InterfaceNameW);
        
#if 0   // Disable client interface filters for BETA
        if (_wcsicmp (argv[0],
            GetString (g_hModule, VAL_DIALINCLIENT, buffer)) == 0) 
        {
            fClient = TRUE;
        }
        else
#endif

        if ((count > 0) && (count <= MAX_INTERFACE_NAME_LEN)) 
        {
            fClient = FALSE;
        }
        else 
        {
            DisplayIPXMessage (g_hModule, MSG_INVALID_INTERFACE_NAME);
            rc = ERROR_INVALID_PARAMETER;
            goto Exit;
        }


        if ( !MatchEnumTag( 
                g_hModule, argv[1], NUM_TOKENS_IN_TABLE( FilterModes ),
                FilterModes, &mode
                ) &&
                
              ( ReadTfFltDef( argc - 2, &argv[2], &TfFlt) == NO_ERROR ) ) 
        {
            if (g_hMprAdmin)
            {
                rc = AdmSetTfFlt(
                        OPERATION_ADD_TRAFFICFILTER,
                        fClient ? NULL : InterfaceNameW,
                        IPX_TRAFFIC_FILTER_ACTION_DENY,
                        mode, &TfFlt
                        );
            }
            
            else
            {
                rc = NO_ERROR;
            }

            
            if (rc == NO_ERROR)
            {
                rc = CfgSetTfFlt(
                        OPERATION_ADD_TRAFFICFILTER,
                        fClient ? NULL : InterfaceNameW,
                        IPX_TRAFFIC_FILTER_ACTION_DENY,
                        mode, &TfFlt
                        );
            }
        }
        else 
        {
            DisplayIPXMessage (g_hModule, MSG_IPX_HELP_TRAFFICFILTER);
        }
    }
    else 
    {
        DisplayIPXMessage (g_hModule, MSG_IPX_HELP_TRAFFICFILTER);
        rc = ERROR_INVALID_PARAMETER;
    }

Exit:
    return rc ;

#undef InterfaceNameW

}


int    
APIENTRY 
DeleteTfFlt (
    IN    int                   argc,
    IN    WCHAR                *argv[]
) 
{
    DWORD        rc = NO_ERROR;
    if (argc > 1) 
    {
        IPX_TRAFFIC_FILTER_INFO TfFlt;
        ULONG                   mode;
        BOOL                    fClient;
        PWCHAR                   buffer;
        unsigned    count;


#define InterfaceNameW argv[0]
        count = wcslen (InterfaceNameW);

#if 0   // Disable client interface filters for BETA
        if (_tcsicmp (argv[0],
            GetString (g_hModule, VAL_DIALINCLIENT, buffer)) == 0) 
        {
            fClient = TRUE;
        }
#endif

        if ( (count > 0) && (count <= MAX_INTERFACE_NAME_LEN) ) 
        {
            fClient = FALSE;
        }
        else 
        {
            DisplayIPXMessage (g_hModule, MSG_INVALID_INTERFACE_NAME);
            rc = ERROR_INVALID_PARAMETER;
            goto Exit;
        }

        if ( !MatchEnumTag( 
                g_hModule, argv[1], NUM_TOKENS_IN_TABLE( FilterModes ),
                FilterModes, &mode
                ) &&
             ( ReadTfFltDef (argc - 2, &argv[2], &TfFlt) == NO_ERROR ) ) 
        {
            if (g_hMprAdmin)
            {
                rc = AdmSetTfFlt(
                        OPERATION_DEL_TRAFFICFILTER, 
                        fClient ? NULL : InterfaceNameW,
                        IPX_TRAFFIC_FILTER_ACTION_DENY,
                        mode, &TfFlt
                        );
            }

            else
            {
                rc = NO_ERROR;
            }
            
            if (rc == NO_ERROR)
            {
                rc = CfgSetTfFlt(
                        OPERATION_DEL_TRAFFICFILTER,
                        fClient ? NULL : InterfaceNameW,
                        IPX_TRAFFIC_FILTER_ACTION_DENY,
                        mode, &TfFlt
                        );
            }
        }
        else 
        {
            DisplayIPXMessage (g_hModule, MSG_IPX_HELP_TRAFFICFILTER);
        }
    }
    else 
    {
        DisplayIPXMessage (g_hModule, MSG_IPX_HELP_TRAFFICFILTER);
        rc = ERROR_INVALID_PARAMETER;
    }
Exit:
    return rc ;

#undef InterfaceNameW
}



DWORD
ReadTfFltDef (
    int                         argc,
    WCHAR                      *argv[],
    PIPX_TRAFFIC_FILTER_INFO    pTfFlt
) 
{
    UINT                n;
    USHORT              val2;
    ULONG               val41, val42;
    ULONGLONG           val8;
    int    i;


    pTfFlt->FilterDefinition = 0;

    for (i = 0; i < argc; i++) 
    {
        if ( !_wcsicmp( argv[i], TOKEN_SRCNET ) )
        {
            if (!(pTfFlt->FilterDefinition & IPX_TRAFFIC_FILTER_ON_SRCNET)
                 && (i < argc - 2)
                 && ( swscanf (argv[i+1], L"%8lx%n", &val41, &n) == 1)
                 && (n == wcslen (argv[i+1]))
                 && ( swscanf (argv[i+2], L"%8lx%n", &val42, &n) == 1)
                 && (n == wcslen (argv[i+2]))
                 && ((val41 & val42) == val41)) 
            {
                i += 2;
                pTfFlt->SourceNetwork[0] = (BYTE)(val41 >> 24);
                pTfFlt->SourceNetwork[1] = (BYTE)(val41 >> 16);
                pTfFlt->SourceNetwork[2] = (BYTE)(val41 >> 8);
                pTfFlt->SourceNetwork[3] = (BYTE)val41;
                pTfFlt->SourceNetworkMask[0] = (BYTE)(val42 >> 24);
                pTfFlt->SourceNetworkMask[1] = (BYTE)(val42 >> 16);
                pTfFlt->SourceNetworkMask[2] = (BYTE)(val42 >> 8);
                pTfFlt->SourceNetworkMask[3] = (BYTE)val42;
                pTfFlt->FilterDefinition |= IPX_TRAFFIC_FILTER_ON_SRCNET;
            }
            else
            {
                break;
            }
        }
        
        else if ( !_wcsicmp (argv[i], TOKEN_SRCNODE ) ) 
        {
            if (!(pTfFlt->FilterDefinition & IPX_TRAFFIC_FILTER_ON_SRCNODE)
                 && (i < argc - 1)
                 && (swscanf (argv[i+1], L"%I64x%n", &val8, &n) == 1)
                 && (n == wcslen (argv[i+1]))) 
            {
                i += 1;
                pTfFlt->SourceNode[0] = (BYTE)(val8 >> 40);
                pTfFlt->SourceNode[1] = (BYTE)(val8 >> 32);
                pTfFlt->SourceNode[2] = (BYTE)(val8 >> 24);
                pTfFlt->SourceNode[3] = (BYTE)(val8 >> 16);
                pTfFlt->SourceNode[4] = (BYTE)(val8 >> 8);
                pTfFlt->SourceNode[5] = (BYTE)val8;
                pTfFlt->FilterDefinition |= IPX_TRAFFIC_FILTER_ON_SRCNODE;
            }
            else
            {
                break;
            }
        }
        
        else if ( !_wcsicmp (argv[i], TOKEN_SRCSOCKET ))
        {
            if (!(pTfFlt->FilterDefinition & IPX_TRAFFIC_FILTER_ON_SRCSOCKET)
                 && (i < argc - 1)
                 && (swscanf (argv[i+1], L"%4hx%n", &val2, &n) == 1)
                 && (n == wcslen (argv[i+1]))) 
            {
                i += 1;
                pTfFlt->SourceSocket[0] = (BYTE)(val2 >> 8);
                pTfFlt->SourceSocket[1] = (BYTE)val2;
                pTfFlt->FilterDefinition |= IPX_TRAFFIC_FILTER_ON_SRCSOCKET;
            }
            else
            {
                break;
            }
        }
        else if ( !_wcsicmp (argv[i], TOKEN_DSTNET ) )
        {
            if (!(pTfFlt->FilterDefinition & IPX_TRAFFIC_FILTER_ON_DSTNET)
                 && (i < argc - 2)
                 && (swscanf (argv[i+1], L"%8lx%n", &val41, &n) == 1)
                 && (n == wcslen (argv[i+1]))
                 && (swscanf (argv[i+2], L"%8lx%n", &val42, &n) == 1)
                 && (n == wcslen (argv[i+2]))
                 && ((val41 & val42) == val41)) 
            {
                i += 2;
                pTfFlt->DestinationNetwork[0] = (BYTE)(val41 >> 24);
                pTfFlt->DestinationNetwork[1] = (BYTE)(val41 >> 16);
                pTfFlt->DestinationNetwork[2] = (BYTE)(val41 >> 8);
                pTfFlt->DestinationNetwork[3] = (BYTE)val41;
                pTfFlt->DestinationNetworkMask[0] = (BYTE)(val42 >> 24);
                pTfFlt->DestinationNetworkMask[1] = (BYTE)(val42 >> 16);
                pTfFlt->DestinationNetworkMask[2] = (BYTE)(val42 >> 8);
                pTfFlt->DestinationNetworkMask[3] = (BYTE)val42;
                pTfFlt->FilterDefinition |= IPX_TRAFFIC_FILTER_ON_DSTNET;
            }
            else
            {
                break;
            }
        }
        
        else if ( !_wcsicmp( argv[i], TOKEN_DSTNODE ) )
        {
            if (!(pTfFlt->FilterDefinition & IPX_TRAFFIC_FILTER_ON_DSTNODE)
                 && (swscanf (argv[i+1], L"%I64x%n", &val8, &n) == 1)
                 && (n == wcslen (argv[i+1]))) 
            {
                i += 1;
                pTfFlt->DestinationNode[0] = (BYTE)(val8 >> 40);
                pTfFlt->DestinationNode[1] = (BYTE)(val8 >> 32);
                pTfFlt->DestinationNode[2] = (BYTE)(val8 >> 24);
                pTfFlt->DestinationNode[3] = (BYTE)(val8 >> 16);
                pTfFlt->DestinationNode[4] = (BYTE)(val8 >> 8);
                pTfFlt->DestinationNode[5] = (BYTE)val8;
                pTfFlt->FilterDefinition |= IPX_TRAFFIC_FILTER_ON_DSTNODE;
            }
            else
            {
                break;
            }
        }
        else if ( !_wcsicmp (argv[i], TOKEN_DSTSOCKET )) 
        {
            if (!(pTfFlt->FilterDefinition & IPX_TRAFFIC_FILTER_ON_DSTSOCKET)
                 && (i < argc - 1)
                 && (swscanf (argv[i+1], L"%4hx%n", &val2, &n) == 1)
                 && (n == wcslen (argv[i+1]))) 
            {
                i += 1;
                pTfFlt->DestinationSocket[0] = (BYTE)(val2 >> 8);
                pTfFlt->DestinationSocket[1] = (BYTE)val2;
                pTfFlt->FilterDefinition |= IPX_TRAFFIC_FILTER_ON_DSTSOCKET;
            }
            else
            {
                break;
            }
        }
        
        else if ( !_wcsicmp (argv[i], TOKEN_PKTTYPE)) 
        {
            if (!(pTfFlt->FilterDefinition & IPX_TRAFFIC_FILTER_ON_PKTTYPE)
                 && (i < argc - 1)
                 && (swscanf (argv[i+1], L"%2hx%n", &val2, &n) == 1)
                 && (n == wcslen (argv[i+1]))) 
            {
                i += 1;
                pTfFlt->PacketType = (BYTE)val2;
                pTfFlt->FilterDefinition |= IPX_TRAFFIC_FILTER_ON_PKTTYPE;
            }
            else
            {
                break;
            }
        }
        else if ( !_wcsicmp (argv[i], TOKEN_LOGPACKETS )) 
        {
            if (!(pTfFlt->FilterDefinition & IPX_TRAFFIC_FILTER_LOG_MATCHES))
            {
                pTfFlt->FilterDefinition |= IPX_TRAFFIC_FILTER_LOG_MATCHES;
            }
            else
            {
                break;
            }
        }
        else if (!(pTfFlt->FilterDefinition & IPX_TRAFFIC_FILTER_ON_SRCNET)) 
        {
            if ((i < argc - 1)
                 && (swscanf (argv[i], L"%8lx%n", &val41, &n) == 1)
                 && (n == wcslen (argv[i]))
                 && (swscanf (argv[i+1], L"%8lx%n", &val42, &n) == 1)
                 && (n == wcslen (argv[i+1]))
                 && ((val41 & val42) == val41)) 
            {
                i += 1;
                pTfFlt->SourceNetwork[0] = (BYTE)(val41 >> 24);
                pTfFlt->SourceNetwork[1] = (BYTE)(val41 >> 16);
                pTfFlt->SourceNetwork[2] = (BYTE)(val41 >> 8);
                pTfFlt->SourceNetwork[3] = (BYTE)val41;
                pTfFlt->SourceNetworkMask[0] = (BYTE)(val42 >> 24);
                pTfFlt->SourceNetworkMask[1] = (BYTE)(val42 >> 16);
                pTfFlt->SourceNetworkMask[2] = (BYTE)(val42 >> 8);
                pTfFlt->SourceNetworkMask[3] = (BYTE)val42;
                pTfFlt->FilterDefinition |= IPX_TRAFFIC_FILTER_ON_SRCNET;
            }
            else
            {
                break;
            }
        }
        else if (!(pTfFlt->FilterDefinition & IPX_TRAFFIC_FILTER_ON_SRCNODE)) 
        {
            if ((swscanf (argv[i], L"%12I64x%n", &val8, &n) == 1)
                 && (n == wcslen (argv[i]))) 
            {
                pTfFlt->SourceNode[0] = (BYTE)(val8 >> 40);
                pTfFlt->SourceNode[1] = (BYTE)(val8 >> 32);
                pTfFlt->SourceNode[2] = (BYTE)(val8 >> 24);
                pTfFlt->SourceNode[3] = (BYTE)(val8 >> 16);
                pTfFlt->SourceNode[4] = (BYTE)(val8 >> 8);
                pTfFlt->SourceNode[5] = (BYTE)val8;
                pTfFlt->FilterDefinition |= IPX_TRAFFIC_FILTER_ON_SRCNODE;
            }
            else
            {
                break;
            }
        }
        else if (!(pTfFlt->FilterDefinition & IPX_TRAFFIC_FILTER_ON_SRCSOCKET)) 
        {
            if ((swscanf (argv[i], L"%4hx%n", &val2, &n) == 1)
                 && (n == wcslen (argv[i]))) 
            {
                pTfFlt->SourceSocket[0] = (BYTE)(val2 >> 8);
                pTfFlt->SourceSocket[1] = (BYTE)val2;
                pTfFlt->FilterDefinition |= IPX_TRAFFIC_FILTER_ON_SRCSOCKET;
            }
            else
            {
                break;
            }
        }
        else if (!(pTfFlt->FilterDefinition & IPX_TRAFFIC_FILTER_ON_DSTNET)) 
        {
            if ((i < argc - 1)
                 && (swscanf (argv[i], L"%8lx%n", &val41, &n) == 1)
                 && (n == wcslen (argv[i]))
                 && (swscanf (argv[i+1], L"%8lx%n", &val42, &n) == 1)
                 && (n == wcslen (argv[i+1]))
                 && ((val41 & val42) == val41)) 
            {
                i += 1;
                pTfFlt->DestinationNetwork[0] = (BYTE)(val41 >> 24);
                pTfFlt->DestinationNetwork[1] = (BYTE)(val41 >> 16);
                pTfFlt->DestinationNetwork[2] = (BYTE)(val41 >> 8);
                pTfFlt->DestinationNetwork[3] = (BYTE)val41;
                pTfFlt->DestinationNetworkMask[0] = (BYTE)(val42 >> 24);
                pTfFlt->DestinationNetworkMask[1] = (BYTE)(val42 >> 16);
                pTfFlt->DestinationNetworkMask[2] = (BYTE)(val42 >> 8);
                pTfFlt->DestinationNetworkMask[3] = (BYTE)val42;
                pTfFlt->FilterDefinition |= IPX_TRAFFIC_FILTER_ON_DSTNET;
            }
            else
            {
                break;
            }
        }
        else if (!(pTfFlt->FilterDefinition & IPX_TRAFFIC_FILTER_ON_DSTNODE)) 
        {
            if ((swscanf (argv[i], L"%12I64x%n", &val8, &n) == 1)
                 && (n == wcslen (argv[i]))) 
            {
                pTfFlt->DestinationNode[0] = (BYTE)(val8 >> 40);
                pTfFlt->DestinationNode[1] = (BYTE)(val8 >> 32);
                pTfFlt->DestinationNode[2] = (BYTE)(val8 >> 24);
                pTfFlt->DestinationNode[3] = (BYTE)(val8 >> 16);
                pTfFlt->DestinationNode[4] = (BYTE)(val8 >> 8);
                pTfFlt->DestinationNode[5] = (BYTE)val8;
                pTfFlt->FilterDefinition |= IPX_TRAFFIC_FILTER_ON_DSTNODE;
            }
            else
            {
                break;
            }
        }
        else if (!(pTfFlt->FilterDefinition & IPX_TRAFFIC_FILTER_ON_DSTSOCKET)) 
        {
            if ((swscanf (argv[i], L"%4hx%n", &val2, &n) == 1)
                 && (n == wcslen (argv[i]))) 
            {
                pTfFlt->DestinationSocket[0] = (BYTE)(val2 >> 8);
                pTfFlt->DestinationSocket[1] = (BYTE)val2;
                pTfFlt->FilterDefinition |= IPX_TRAFFIC_FILTER_ON_DSTSOCKET;
            }
            else
            {
                break;
            }
        }
        else if (!(pTfFlt->FilterDefinition & IPX_TRAFFIC_FILTER_ON_PKTTYPE)) 
        {
            if ((swscanf (argv[i], L"%2hx%n", &val2, &n) == 1)
                 && (n == wcslen (argv[i]))) 
            {
                pTfFlt->PacketType = (BYTE)val2;
                pTfFlt->FilterDefinition |= IPX_TRAFFIC_FILTER_ON_PKTTYPE;
            }
            else
            {
                break;
            }
        }
        else
        {
            break;
        }
    }

    if (i == argc)
    {
        return NO_ERROR;
    }
    else
    {
        return ERROR_INVALID_PARAMETER;
    }
}


VOID
PrintTrafficFilterInfo (
    PIPX_TRAFFIC_FILTER_GLOBAL_INFO     pTfGlb,
    PIPX_TRAFFIC_FILTER_INFO            pTfFlt,
    ULONG                               count,
    PWCHAR                              wszIfName,
    PWCHAR                              wszMode,
    BOOL                                bDump
) 
{
    WCHAR   wszDumpString[ 512 ];
    WCHAR   wszDumpBuffer[ 64 ];
    WCHAR   buffer[10][128];
    PWCHAR  pBuffer[ 10 ];
    UINT    i, j;


    for ( i = 0; i < count; i++, pTfFlt++ ) 
    {
        ZeroMemory( pBuffer, 10 * sizeof( PWCHAR ) );
        ZeroMemory( wszDumpString, 512 * sizeof( WCHAR ) );
        swprintf( wszDumpString, L"\"%s\" %s ", wszIfName, wszMode );

        if (pTfFlt->FilterDefinition & IPX_TRAFFIC_FILTER_ON_SRCNET) 
        {
            pBuffer[ 0 ] = &buffer[ 0 ][ 0 ];
            pBuffer[ 1 ] = &buffer[ 1 ][ 0 ];
            
            swprintf (pBuffer[0], L"%.2x%.2x%.2x%.2x",
                pTfFlt->SourceNetwork[0], pTfFlt->SourceNetwork[1],
                pTfFlt->SourceNetwork[2], pTfFlt->SourceNetwork[3]
                );
            swprintf (pBuffer[1], L"%.2x%.2x%.2x%.2x",
                pTfFlt->SourceNetworkMask[0], pTfFlt->SourceNetworkMask[1],
                pTfFlt->SourceNetworkMask[2], pTfFlt->SourceNetworkMask[3]
                );

            if ( bDump )
            {
                swprintf( wszDumpBuffer, L"srcnet = 0x%s 0x%s ", pBuffer[0], pBuffer[1] );
                wcscat( wszDumpString, wszDumpBuffer );
            }
        }
        else 
        {
            pBuffer[ 0 ] = VAL_ANYNETWORK ;
            pBuffer[ 1 ] = VAL_ANYNETWORK ;
        }

        
        if (pTfFlt->FilterDefinition & IPX_TRAFFIC_FILTER_ON_SRCNODE)
        {
            pBuffer[ 2 ] = &buffer[ 2 ][ 0 ];
            
            swprintf (pBuffer[2], L"%.2x%.2x%.2x%.2x%.2x%.2x",
                pTfFlt->SourceNode[0], pTfFlt->SourceNode[1],
                pTfFlt->SourceNode[2], pTfFlt->SourceNode[3],
                pTfFlt->SourceNode[4], pTfFlt->SourceNode[5]
                );
                
            if ( bDump )
            {
                swprintf( wszDumpBuffer, L"srcnode = 0x%s ", pBuffer[2] );
                wcscat( wszDumpString, wszDumpBuffer );
            }

        }
        else
        {
            pBuffer[ 2 ] = VAL_ANYNODE;
        }

        
        if (pTfFlt->FilterDefinition & IPX_TRAFFIC_FILTER_ON_SRCSOCKET)
        {
            pBuffer[ 3 ] = &buffer[ 3 ][ 0 ];
            
            swprintf (pBuffer[3], L"%.2x%.2x",
                pTfFlt->SourceSocket[0], pTfFlt->SourceSocket[1]
                );
                
            if ( bDump )
            {
                swprintf( wszDumpBuffer, L"srcsocket = 0x%s ", pBuffer[3] );
                wcscat( wszDumpString, wszDumpBuffer );
            }

        }
        else
        {
            pBuffer[ 3 ] = VAL_ANYSOCKET ;
        }

        
        if (pTfFlt->FilterDefinition & IPX_TRAFFIC_FILTER_ON_DSTNET) 
        {
            pBuffer[ 4 ] = &buffer[ 4 ][ 0 ];
            pBuffer[ 5 ] = &buffer[ 5 ][ 0 ];
            
            swprintf(
                pBuffer[4], L"%.2x%.2x%.2x%.2x",
                pTfFlt->DestinationNetwork[0], pTfFlt->DestinationNetwork[1],
                pTfFlt->DestinationNetwork[2], pTfFlt->DestinationNetwork[3]
                );
                
            swprintf (pBuffer[5], L"%.2x%.2x%.2x%.2x",
                pTfFlt->DestinationNetworkMask[0], pTfFlt->DestinationNetworkMask[1],
                pTfFlt->DestinationNetworkMask[2], pTfFlt->DestinationNetworkMask[3]
                );

            if ( bDump )
            {
                swprintf( wszDumpBuffer, L"dstnet = 0x%s 0x%s ", pBuffer[4], pBuffer[5] );
                wcscat( wszDumpString, wszDumpBuffer );
            }
        }
        else 
        {
            pBuffer[ 4 ] = VAL_ANYNETWORK;
            pBuffer[ 5 ] = VAL_ANYNETWORK;
        }

        
        if (pTfFlt->FilterDefinition & IPX_TRAFFIC_FILTER_ON_DSTNODE)
        {
            pBuffer[ 6 ] = &buffer[ 6 ][ 0 ];
            
            swprintf (pBuffer[6], L"%.2x%.2x%.2x%.2x%.2x%.2x",
                pTfFlt->DestinationNode[0], pTfFlt->DestinationNode[1],
                pTfFlt->DestinationNode[2], pTfFlt->DestinationNode[3],
                pTfFlt->DestinationNode[4], pTfFlt->DestinationNode[5]
                );
                
            if ( bDump )
            {
                swprintf( wszDumpBuffer, L"dstnode = 0x%s ", pBuffer[6] );
                wcscat( wszDumpString, wszDumpBuffer );
            }
        }
        else
        {
            pBuffer[ 6 ] = VAL_ANYNODE;
        }
        
        if (pTfFlt->FilterDefinition & IPX_TRAFFIC_FILTER_ON_DSTSOCKET)
        {
            pBuffer[ 7 ] = &buffer[ 7 ][ 0 ];
            
            swprintf(pBuffer[7], L"%.2x%.2x",
                pTfFlt->DestinationSocket[0], pTfFlt->DestinationSocket[1]
                );
                
            if ( bDump )
            {
                swprintf( wszDumpBuffer, L"dstsocket = 0x%s ", pBuffer[7] );
                wcscat( wszDumpString, wszDumpBuffer );
            }
        }
        else
        {
            pBuffer[ 7 ] = VAL_ANYSOCKET;
        }


        if (pTfFlt->FilterDefinition & IPX_TRAFFIC_FILTER_ON_PKTTYPE)
        {
            pBuffer[ 8 ] = &buffer[ 8 ][ 0 ];
            swprintf (pBuffer[8], L"%.2x", pTfFlt->PacketType);
            
            if ( bDump )
            {
                swprintf( wszDumpBuffer, L"pkttype = 0x%s ", pBuffer[8] );
                wcscat( wszDumpString, wszDumpBuffer );
            }

        }
        else
        {
            pBuffer[ 8 ] = VAL_ANYPKTTYPE;
        }

        
        if (pTfFlt->FilterDefinition & IPX_TRAFFIC_FILTER_LOG_MATCHES)
        {
            pBuffer[ 9 ] = VAL_YES;

            if ( bDump )
            {
                swprintf( wszDumpBuffer, L"log" );
                wcscat( wszDumpString, wszDumpBuffer );
            }
        }
        else
        {
            pBuffer[ 9 ] = VAL_NO;
        }

        if ( bDump )
        {
            DisplayMessageT( DMP_IPX_ADD_FILTER, wszDumpString );
        }
        else
        {
            DisplayIPXMessage (
                g_hModule, MSG_TRAFFICFILTER_TABLE_FMT,
                pBuffer[0], pBuffer[1], pBuffer[2], pBuffer[3], pBuffer[4], pBuffer[5],
                pBuffer[6], pBuffer[7], pBuffer[8], pBuffer[9]
                );
        }
    }
}



DWORD
AdmSetTfFlt (
    int                         operation,
    LPWSTR                      InterfaceNameW,
    ULONG                       Action,
    ULONG                       Mode,
    PIPX_TRAFFIC_FILTER_INFO    TfFlt
) 
{
    DWORD       rc;
    HANDLE      hIfAdm;
    LPBYTE      pIfBlock;
    DWORD       sz;
    WCHAR       IfName[ MAX_INTERFACE_NAME_LEN + 1 ];
    DWORD       dwSize = sizeof(IfName);

    

    if ( InterfaceNameW != NULL ) 
    {
        //======================================
        // Translate the Interface Name
        //======================================

        rc = IpmontrGetIfNameFromFriendlyName(
                InterfaceNameW, IfName, &dwSize
                );

        if ( rc == NO_ERROR )
        {
            rc = MprAdminInterfaceGetHandle(
                    g_hMprAdmin, IfName, &hIfAdm, FALSE
                    );
                    
            if (rc == NO_ERROR) 
            {
                rc = MprAdminInterfaceTransportGetInfo(
                        g_hMprAdmin, hIfAdm, PID_IPX, &pIfBlock, &sz
                        );
            }
        }
    }
    
    else 
    {
        rc = MprAdminTransportGetInfo (
                g_hMprAdmin, PID_IPX, NULL, NULL, &pIfBlock, &sz
                );
    }

    if (rc == NO_ERROR) 
    {
        UINT    msg;
        LPBYTE  pNewBlock = NULL;

        switch (operation) 
        {

        case OPERATION_ADD_TRAFFICFILTER:

            rc = AddIPXInfoEntry (
                    (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                    (Mode == OUTPUT_FILTER) ? IPX_OUT_TRAFFIC_FILTER_INFO_TYPE :
                                              IPX_IN_TRAFFIC_FILTER_INFO_TYPE,
                    sizeof (*TfFlt),
                    TfFlt,
                    TfFltEqual,
                    (PIPX_INFO_BLOCK_HEADER * ) & pNewBlock
                    );
                    
            if (rc == NO_ERROR) 
            {
                if (GetIPXTocEntry ((PIPX_INFO_BLOCK_HEADER)pIfBlock,
                    (Mode == OUTPUT_FILTER)
                     ? IPX_OUT_TRAFFIC_FILTER_GLOBAL_INFO_TYPE
                     : IPX_IN_TRAFFIC_FILTER_GLOBAL_INFO_TYPE) == NULL) 
                {
                    IPX_TRAFFIC_FILTER_GLOBAL_INFO  GlInfo;
                    LPBYTE                          pNewNewBlock;
                    
                    GlInfo.FilterAction = IPX_TRAFFIC_FILTER_ACTION_DENY;
                    
                    rc = AddIPXInfoEntry (
                            (PIPX_INFO_BLOCK_HEADER)pNewBlock,
                            (Mode == OUTPUT_FILTER) ? IPX_OUT_TRAFFIC_FILTER_GLOBAL_INFO_TYPE :
                                                      IPX_IN_TRAFFIC_FILTER_GLOBAL_INFO_TYPE,
                            sizeof (GlInfo),
                            &GlInfo,
                            NULL,
                            (PIPX_INFO_BLOCK_HEADER * ) & pNewNewBlock
                            );
                            
                    if (rc == NO_ERROR) 
                    {
                        if (pNewBlock != pNewNewBlock) 
                        {
                            if (pNewBlock != pIfBlock)
                            {
                              GlobalFree (pNewBlock);
                            }
                            pNewBlock = pNewNewBlock;
                        }
                    }
                    else 
                    {
                        if (pNewBlock != pIfBlock)
                        {
                            GlobalFree (pNewBlock);
                        }
                    }

                }
            }
            
            if (InterfaceNameW != NULL)
            {
                msg = MSG_TRAFFICFILTER_CREATED_ADM;
            }
            else
            {
                msg = MSG_CLIENT_TRAFFICFILTER_CREATED_ADM;
            }
            break;

            
        case OPERATION_SET_TRAFFICFILTER:
        {
            PIPX_TOC_ENTRY    pTfGlToc;

            pTfGlToc = GetIPXTocEntry (
                        (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                        (Mode == OUTPUT_FILTER)
                         ? IPX_OUT_TRAFFIC_FILTER_GLOBAL_INFO_TYPE
                         : IPX_IN_TRAFFIC_FILTER_GLOBAL_INFO_TYPE
                         );
                         
            if (pTfGlToc != NULL) 
            {
                PIPX_TRAFFIC_FILTER_GLOBAL_INFO    pTfGlb;

                pTfGlb = (PIPX_TRAFFIC_FILTER_GLOBAL_INFO)
                                (pIfBlock + pTfGlToc->Offset);
                pTfGlb->FilterAction = Action;
            }
            
            if (InterfaceNameW != NULL)
            {
                msg = MSG_TRAFFICFILTER_SET_ADM;
            }
            else
            {
                msg = MSG_CLIENT_TRAFFICFILTER_SET_ADM;
            }
            
            pNewBlock = pIfBlock;

            break;
        }
            
        case OPERATION_DEL_TRAFFICFILTER:

            rc = DeleteIPXInfoEntry (
                    (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                    (Mode == OUTPUT_FILTER)
                     ? IPX_OUT_TRAFFIC_FILTER_INFO_TYPE
                     : IPX_IN_TRAFFIC_FILTER_INFO_TYPE,
                    sizeof (*TfFlt),
                    TfFlt,
                    TfFltEqual,
                    (PIPX_INFO_BLOCK_HEADER * ) & pNewBlock
                    );
                    
            if (InterfaceNameW != NULL)
            {
                msg = MSG_TRAFFICFILTER_DELETED_ADM;
            }
            else
            {
                msg = MSG_CLIENT_TRAFFICFILTER_DELETED_ADM;
            }

            // Whistler bug 247549 netsh routing ipx set/add filter produces
            // error, "Cannot complete function"
            //
            pNewBlock = pIfBlock;

            break;
        }

        if (rc == NO_ERROR) 
        {
            if ( InterfaceNameW != NULL )
            {
                if (pNewBlock)
                {
                    rc = MprAdminInterfaceTransportSetInfo (
                            g_hMprAdmin, hIfAdm, PID_IPX, pNewBlock,
                            ((PIPX_INFO_BLOCK_HEADER)pNewBlock)->Size
                            );
                }                            
                else
                {
                    rc = ERROR_CAN_NOT_COMPLETE;
                }
            }
            else
            {
                if (pNewBlock)
                {
                    rc = MprAdminTransportSetInfo (
                            g_hMprAdmin, PID_IPX, NULL, 0, pNewBlock,
                            ((PIPX_INFO_BLOCK_HEADER)pNewBlock)->Size
                            );
                }
                else
                {
                    rc = ERROR_CAN_NOT_COMPLETE;
                }
            }
            
            if (pNewBlock != pIfBlock)
            {
                GlobalFree (pNewBlock);
            }
            
            if (rc == NO_ERROR)
            {
                DisplayIPXMessage (g_hModule, msg, InterfaceNameW);
            }
            else
            {
                DisplayError( g_hModule, rc);
            }
        }
        else
        {
            DisplayError( g_hModule, rc);
        }
        
        MprAdminBufferFree (pIfBlock);
    }
    
    else
    {
        DisplayError( g_hModule, rc);
    }

    return rc;
}


DWORD
CfgSetTfFlt (
    int operation,
    LPWSTR                      InterfaceNameW,
    ULONG                       Action,
    ULONG                       Mode,
    PIPX_TRAFFIC_FILTER_INFO    TfFlt
) 
{
    DWORD       rc;
    HANDLE      hIfCfg;
    HANDLE      hIfTrCfg;
    HANDLE      hTrCfg;
    LPBYTE      pIfBlock;
    DWORD       sz;
    WCHAR       IfName[ MAX_INTERFACE_NAME_LEN + 1 ];
    DWORD       dwSize = sizeof(IfName);

    if (InterfaceNameW != NULL) 
    {
        //======================================
        // Translate the Interface Name
        //======================================

        rc = IpmontrGetIfNameFromFriendlyName(
                InterfaceNameW, IfName, &dwSize
                );

        if ( rc == NO_ERROR )
        {
            rc = MprConfigInterfaceGetHandle (
                    g_hMprConfig, IfName, &hIfCfg
                    );
                    
            if (rc == NO_ERROR) 
            {
                rc = MprConfigInterfaceTransportGetHandle (
                        g_hMprConfig, hIfCfg, PID_IPX, &hIfTrCfg
                        );
                        
                if (rc == NO_ERROR) 
                {
                    rc = MprConfigInterfaceTransportGetInfo (
                            g_hMprConfig, hIfCfg, hIfTrCfg, &pIfBlock, &sz
                            );
                }
            }
        }
    }
    else 
    {
        rc = MprConfigTransportGetHandle (
                g_hMprConfig, PID_IPX, &hTrCfg
                );
                
        if (rc == NO_ERROR) 
        {
            rc = MprConfigTransportGetInfo (
                    g_hMprConfig, hTrCfg, NULL, NULL, &pIfBlock, &sz, NULL
                    );
        }
    }

    
    if (rc == NO_ERROR) 
    {
        UINT                    msg;
        LPBYTE                    pNewBlock = NULL;

        switch (operation) 
        {
        case OPERATION_ADD_TRAFFICFILTER:

            rc = AddIPXInfoEntry (
                    (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                    (Mode == OUTPUT_FILTER)
                     ? IPX_OUT_TRAFFIC_FILTER_INFO_TYPE
                     : IPX_IN_TRAFFIC_FILTER_INFO_TYPE,
                    sizeof (*TfFlt),
                    TfFlt,
                    TfFltEqual,
                    (PIPX_INFO_BLOCK_HEADER * ) & pNewBlock
                    );

            if (rc == NO_ERROR) 
            {
                if (GetIPXTocEntry ((PIPX_INFO_BLOCK_HEADER)pIfBlock,
                    (Mode == OUTPUT_FILTER)
                     ? IPX_OUT_TRAFFIC_FILTER_GLOBAL_INFO_TYPE
                     : IPX_IN_TRAFFIC_FILTER_GLOBAL_INFO_TYPE) == NULL) 
                {
                    IPX_TRAFFIC_FILTER_GLOBAL_INFO  GlInfo;
                    LPBYTE                          pNewNewBlock;
                    
                    GlInfo.FilterAction = IPX_TRAFFIC_FILTER_ACTION_DENY;
                    
                    rc = AddIPXInfoEntry (
                            (PIPX_INFO_BLOCK_HEADER)pNewBlock,
                            (Mode == OUTPUT_FILTER)
                             ? IPX_OUT_TRAFFIC_FILTER_GLOBAL_INFO_TYPE
                             : IPX_IN_TRAFFIC_FILTER_GLOBAL_INFO_TYPE,
                            sizeof (GlInfo),
                            &GlInfo,
                            NULL,
                            (PIPX_INFO_BLOCK_HEADER * ) & pNewNewBlock
                            );
                            
                    if (rc == NO_ERROR) 
                    {
                        if (pNewBlock != pNewNewBlock) 
                        {
                            if (pNewBlock != pIfBlock)
                            {
                                GlobalFree (pNewBlock);
                            }
                            
                            pNewBlock = pNewNewBlock;
                        }
                    }
                    else 
                    {
                        if (pNewBlock != pIfBlock)
                        {
                            GlobalFree (pNewBlock);
                        }
                    }

                }
            }
            
            if (InterfaceNameW != NULL)
            {
                msg = MSG_TRAFFICFILTER_CREATED_CFG;
            }
            else
            {
                msg = MSG_CLIENT_TRAFFICFILTER_CREATED_CFG;
            }
            
            break;

            
        case OPERATION_SET_TRAFFICFILTER:
        {
            PIPX_TOC_ENTRY    pTfGlToc;

            pTfGlToc = GetIPXTocEntry (
                        (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                        (Mode == OUTPUT_FILTER)
                        ? IPX_OUT_TRAFFIC_FILTER_GLOBAL_INFO_TYPE
                        : IPX_IN_TRAFFIC_FILTER_GLOBAL_INFO_TYPE
                        );
                        
            if (pTfGlToc != NULL) 
            {
                PIPX_TRAFFIC_FILTER_GLOBAL_INFO    pTfGlb;

                pTfGlb = (PIPX_TRAFFIC_FILTER_GLOBAL_INFO)
                            (pIfBlock + pTfGlToc->Offset);
                pTfGlb->FilterAction = Action;
            }
            
            if (InterfaceNameW != NULL)
            {
                msg = MSG_TRAFFICFILTER_SET_CFG;
            }
            else
            {
                msg = MSG_CLIENT_TRAFFICFILTER_SET_CFG;
            }
            
            pNewBlock = pIfBlock;

            break;
        }
            
        case OPERATION_DEL_TRAFFICFILTER:

            rc = DeleteIPXInfoEntry (
                    (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                    (Mode == OUTPUT_FILTER)
                     ? IPX_OUT_TRAFFIC_FILTER_INFO_TYPE
                     : IPX_IN_TRAFFIC_FILTER_INFO_TYPE,
                    sizeof (*TfFlt),
                    TfFlt,
                    TfFltEqual,
                    (PIPX_INFO_BLOCK_HEADER * ) & pNewBlock
                    );

            if (InterfaceNameW != NULL)
            {
                msg = MSG_TRAFFICFILTER_DELETED_CFG;
            }
            else
            {
                msg = MSG_CLIENT_TRAFFICFILTER_DELETED_CFG;
            }

            // Whistler bug 247549 netsh routing ipx set/add filter produces
            // error, "Cannot complete function"
            //
            pNewBlock = pIfBlock;
            
            break;
        }

        
        if (rc == NO_ERROR) 
        {
            if (InterfaceNameW != NULL)
            {
                // Whistler bug 247549 netsh routing ipx set/add filter produces
                // error, "Cannot complete function"
                //
                if (pNewBlock)
                {
                    rc = MprConfigInterfaceTransportSetInfo (
                            g_hMprConfig, hIfCfg, hIfTrCfg, pNewBlock,
                            ((PIPX_INFO_BLOCK_HEADER)pNewBlock)->Size
                            );
                }
                else
                {
                    rc = ERROR_CAN_NOT_COMPLETE;
                }
            }
            else
            {
                // Whistler bug 247549 netsh routing ipx set/add filter produces
                // error, "Cannot complete function"
                //
                if (pNewBlock)
                {
                    rc = MprConfigTransportSetInfo (
                            g_hMprConfig, hTrCfg, NULL, 0, pNewBlock,
                            ((PIPX_INFO_BLOCK_HEADER)pNewBlock)->Size,
                            NULL
                            );
                }
                else
                {
                    rc = ERROR_CAN_NOT_COMPLETE;
                }
            }
            
            if (pNewBlock != pIfBlock)
            {
                GlobalFree (pNewBlock);
            }

            
            if (rc == NO_ERROR)
            {
                DisplayIPXMessage (g_hModule, msg, InterfaceNameW);
            }
            else
            {
                DisplayError( g_hModule, rc);
            }
        }
        
        else
        {
            DisplayError( g_hModule, rc);
        }
        
        MprConfigBufferFree (pIfBlock);
    }
    
    else
    {
        DisplayError( g_hModule, rc);
    }

    return rc;
}





BOOL
TfFltEqual (
PVOID    Info1,
PVOID    Info2
) 
{

#define f1 ((PIPX_TRAFFIC_FILTER_INFO)Info1)
#define f2 ((PIPX_TRAFFIC_FILTER_INFO)Info2)

    ULONG    fd;
    
    return ((fd = f1->FilterDefinition) == f2->FilterDefinition)
     && (!(fd & IPX_TRAFFIC_FILTER_ON_SRCNET)
         || ((memcmp (f1->SourceNetwork, f2->SourceNetwork, 4) == 0)
         && (memcmp (f1->SourceNetworkMask, f2->SourceNetworkMask, 4) == 0)))
     && (!(fd & IPX_TRAFFIC_FILTER_ON_SRCNODE)
         || (memcmp (f1->SourceNode, f2->SourceNode, 6) == 0))
     && (!(fd & IPX_TRAFFIC_FILTER_ON_SRCSOCKET)
         || (memcmp (f1->SourceSocket, f2->SourceSocket, 2) == 0))
     && (!(fd & IPX_TRAFFIC_FILTER_ON_DSTNET)
         || ((memcmp (f1->DestinationNetwork, f2->DestinationNetwork, 4) == 0)
         && (memcmp (f1->DestinationNetworkMask, f2->DestinationNetworkMask,
        4) == 0)))
     && (!(fd & IPX_TRAFFIC_FILTER_ON_DSTNODE)
         || (memcmp (f1->DestinationNode, f2->DestinationNode, 6) == 0))
     && (!(fd & IPX_TRAFFIC_FILTER_ON_DSTSOCKET)
         || (memcmp (f1->DestinationSocket, f2->DestinationSocket, 2) == 0))
     && (!(fd & IPX_TRAFFIC_FILTER_ON_PKTTYPE)
         || (f1->PacketType == f2->PacketType));

#undef f2
#undef f1
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ipx\protocols\common.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    routing\netsh\ipx\protocols\common.h

Abstract:


Revision History:

    V Raman                 1/5/99  Created

--*/


#ifndef _IPXMON_COMMON_H_
#define _IPXMON_COMMON_H_


#define IsHelpToken(pwszToken)\
    (MatchToken(pwszToken, TOKEN_HELP1)  \
    || MatchToken(pwszToken, TOKEN_HELP2) \
    || MatchToken(pwszToken, TOKEN_HELP3))

extern ULONG StartedCommonInitialization, CompletedCommonInitialization ;

extern HANDLE g_hModule;

extern HANDLE g_hMprConfig;
extern HANDLE g_hMprAdmin;
extern HANDLE g_hMIBServer;

NS_CONTEXT_DUMP_FN IpxRipDump;
NS_CONTEXT_DUMP_FN IpxSapDump;
NS_CONTEXT_DUMP_FN IpxNbDump;

extern ULONG g_ulIpxRipNumGroups;
extern ULONG g_ulIpxSapNumGroups;
extern ULONG g_ulIpxNbNumGroups;

extern CMD_GROUP_ENTRY g_IpxRipCmdGroups[];
extern CMD_GROUP_ENTRY g_IpxSapCmdGroups[];
extern CMD_GROUP_ENTRY g_IpxNbCmdGroups[];

DWORD WINAPI
ConnectToRouter(
    IN LPCWSTR pwszRouter
);

#define DisplayIPXMessage DisplayMessageM

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ipx\protocols\common.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    common.c

Abstract:

    Common initialization functions for IPXPROMN.DLL
    
Author:

    V Raman     1/5/1998


--*/


#include "precomp.h"
#pragma hdrstop

//
// GUID for IPXPROMN.DLL
//
// {d3fcba3a-a4e9-11d2-b944-00c04fc2ab1c}
//

static const GUID g_MyGuid = 
{ 
    0xd3fcba3a, 0xa4e9, 0x11d2, 
    
    { 
        0xb9, 0x44, 0x0, 0xc0, 0x4f, 0xc2, 0xab, 0x1c 
    } 
};


static const GUID g_IpxGuid = IPXMONTR_GUID;

#define IPXPROMON_HELPER_VERSION 1

//
// ipxmon functions
//

PIM_DEL_INFO_BLK_IF     DeleteInfoBlockFromInterfaceInfo ;
PIM_DEL_INFO_BLK_GLOBAL DeleteInfoBlockFromGlobalInfo ;
PIM_DEL_PROTO           DeleteProtocol ;
PIM_GET_INFO_BLK_GLOBAL GetInfoBlockFromGlobalInfo ;
PIM_GET_INFO_BLK_IF     GetInfoBlockFromInterfaceInfo ;
PIM_SET_INFO_BLK_GLOBAL SetInfoBlockInGlobalInfo ;
PIM_SET_INFO_BLK_IF     SetInfoBlockInInterfaceInfo ;
PIM_IF_ENUM             InterfaceEnum ;
PIM_GET_IF_TYPE         GetInterfaceType ;
PIM_PROTO_LIST          GetProtocolList ;
PIM_ROUTER_STATUS       IsRouterRunning ;
PIM_MATCH_ROUT_PROTO    MatchRoutingProtoTag ;

ULONG StartedCommonInitialization, CompletedCommonInitialization ;

HANDLE g_hModule;

//
// Handle to router being administered
//

HANDLE g_hMprConfig;
HANDLE g_hMprAdmin;
HANDLE g_hMIBServer;

BOOL 
WINAPI
DllMain(
    HINSTANCE hInstDll,
    DWORD fdwReason,
    LPVOID pReserved
    )
{
    HANDLE     hDll;
    
    switch (fdwReason)
    {
        case DLL_PROCESS_ATTACH:
        {
            // printf("Trying to attach\n");
            
            g_hModule = hInstDll;

            DisableThreadLibraryCalls(hInstDll);

            break;
        }
        case DLL_PROCESS_DETACH:
        {
            //
            // Clean up any structures used for commit
            //
            
            break;
        }

        default:
        {
            break;
        }
    }

    return TRUE;
}

BOOL
IA64VersionCheck
(
    IN  UINT     CIMOSType,                   
        IN  UINT     CIMOSProductSuite,       
    IN  LPCWSTR  CIMOSVersion,                
    IN  LPCWSTR  CIMOSBuildNumber,            
    IN  LPCWSTR  CIMServicePackMajorVersion,  
    IN  LPCWSTR  CIMServicePackMinorVersion,  
        IN  UINT     CIMProcessorArchitecture,
        IN  DWORD    dwReserved
)
{
    if (CIMProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL)// IA64=6 (x86 == 0)
        return TRUE;
    else
        return FALSE;
}


DWORD 
WINAPI
IpxpromonStartHelper(
    IN CONST GUID *pguidParent,
    IN DWORD       dwVersion
    )
{
    DWORD dwErr;
    
    NS_CONTEXT_ATTRIBUTES attMyAttributes;
    //
    // If you add any more contexts, then this should be converted
    // to use an array instead of duplicating code!
    //


    //
    // Register the RIP context
    //

    ZeroMemory(&attMyAttributes, sizeof(attMyAttributes));

    attMyAttributes.pwszContext = L"rip";
    attMyAttributes.guidHelper  = g_MyGuid;
    attMyAttributes.dwVersion   = 1;
    attMyAttributes.dwFlags     = 0;
    attMyAttributes.ulNumTopCmds= 0;
    attMyAttributes.pTopCmds    = NULL;
    attMyAttributes.ulNumGroups = g_ulIpxRipNumGroups;
    attMyAttributes.pCmdGroups  = (CMD_GROUP_ENTRY (*)[])&g_IpxRipCmdGroups;
    attMyAttributes.pfnDumpFn   = IpxRipDump;
    attMyAttributes.pfnConnectFn= ConnectToRouter;
    attMyAttributes.pfnOsVersionCheck = IA64VersionCheck;
    
    dwErr = RegisterContext( &attMyAttributes );
                
    //
    // Register the SAP context
    //

    ZeroMemory(&attMyAttributes, sizeof(attMyAttributes));
    attMyAttributes.pwszContext = L"sap";
    attMyAttributes.guidHelper  = g_MyGuid;
    attMyAttributes.dwVersion   = 1;
    attMyAttributes.dwFlags     = 0;
    attMyAttributes.ulNumTopCmds= 0;
    attMyAttributes.pTopCmds    = NULL;
    attMyAttributes.ulNumGroups = g_ulIpxSapNumGroups;
    attMyAttributes.pCmdGroups  = (CMD_GROUP_ENTRY (*)[])&g_IpxSapCmdGroups;
    attMyAttributes.pfnDumpFn   = IpxSapDump;
    attMyAttributes.pfnConnectFn= ConnectToRouter;
    attMyAttributes.pfnOsVersionCheck = IA64VersionCheck;

    dwErr = RegisterContext( &attMyAttributes );


    //
    // Register the NB context
    //

    ZeroMemory(&attMyAttributes, sizeof(attMyAttributes));
    attMyAttributes.pwszContext = L"netbios";
    attMyAttributes.guidHelper  = g_MyGuid;
    attMyAttributes.dwVersion   = 1;
    attMyAttributes.dwFlags     = 0;
    attMyAttributes.ulNumTopCmds= 0;
    attMyAttributes.pTopCmds    = NULL;
    attMyAttributes.ulNumGroups = g_ulIpxNbNumGroups;
    attMyAttributes.pCmdGroups  = (CMD_GROUP_ENTRY (*)[])&g_IpxNbCmdGroups;
    attMyAttributes.pfnDumpFn   = IpxNbDump;
    attMyAttributes.pfnConnectFn= ConnectToRouter;
    attMyAttributes.pfnOsVersionCheck = IA64VersionCheck;

    dwErr = RegisterContext( &attMyAttributes );
    
    return dwErr;
}


DWORD WINAPI
InitHelperDll(
    IN  DWORD              dwNetshVersion,
    OUT PNS_DLL_ATTRIBUTES pDllTable
    )
{
    DWORD dwErr;
    NS_HELPER_ATTRIBUTES attMyAttributes;

    pDllTable->dwVersion = NETSH_VERSION_50;
    pDllTable->pfnStopFn = NULL;

    //
    // Register helpers.  We could either register 1 helper which
    // registers three contexts, or we could register 3 helpers
    // which each register one context.  There's only a difference
    // if we support sub-helpers, which this DLL does not.
    // If we later support sub-helpers, then it's better to have
    // 3 helpers so that sub-helpers can register with 1 of them,
    // since it registers with a parent helper, not a parent context.
    // For now, we just use a single 3-context helper for efficiency.
    //

    ZeroMemory( &attMyAttributes, sizeof(attMyAttributes) );
    attMyAttributes.guidHelper         = g_MyGuid;
    attMyAttributes.dwVersion          = IPXPROMON_HELPER_VERSION;
    attMyAttributes.pfnStart           = IpxpromonStartHelper;
    attMyAttributes.pfnStop            = NULL;

    dwErr = RegisterHelper( &g_IpxGuid, &attMyAttributes );

    return dwErr;
}


DWORD WINAPI
ConnectToRouter(
    IN LPCWSTR pwszRouter
    )
{
    DWORD dwErr;
    
    //
    // Connect to router config if required
    // (when is this ever required)
    //

    if ( !g_hMprConfig )
    {
        dwErr = MprConfigServerConnect( (LPWSTR)pwszRouter, &g_hMprConfig );

        if ( dwErr isnot NO_ERROR )
        {
            return ERROR_CONNECT_REMOTE_CONFIG;
        }
    }


    //
    // Check to see if router is running. If so, get the handles
    //

    do
    {
        if ( MprAdminIsServiceRunning( (LPWSTR)pwszRouter ) )
        {
            if ( MprAdminServerConnect( (LPWSTR)pwszRouter, &g_hMprAdmin ) ==
                    NO_ERROR )
            {
                if ( MprAdminMIBServerConnect( (LPWSTR)pwszRouter, &g_hMIBServer ) ==
                        NO_ERROR )
                {
                    // DEBUG("Got server handle");
                    break;
                }

                else
                {
                    MprAdminServerDisconnect( g_hMprAdmin );
                }
            }
        }

        g_hMprAdmin = g_hMIBServer = NULL;

    } while (FALSE);


   return NO_ERROR;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ipx\protocols\ipxstrs.h ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    net\routing\netsh\ipx\protocols\ipxstrs.h


Abstract:

    Definitions for resource Ids of help strings
--*/


#include "ipxmsgs.h"

//
// help tokens
//

#define HLP_GROUP_ADD                   1595
#define HLP_GROUP_DELETE                1596
#define HLP_GROUP_SET                   1597
#define HLP_GROUP_SHOW                  1598

#define HLP_IPX_RIPIF                   1400
#define HLP_IPX_SAPIF                   1401
#define HLP_IPX_NBIF                    1402
#define HLP_IPX_NBNAME                  1403
#define HLP_IPX_RIPFILTER               1404
#define HLP_IPX_SAPFILTER               1405
#define HLP_IPX_RIPGL                   1406
#define HLP_IPX_SAPGL                   1407

//
// RIP help
//

#define HLP_IPXRIP_DUMP                 1599
#define HLP_IPXRIP_HELP1                1600
#define HLP_IPXRIP_HELP2                HLP_IPXRIP_HELP1
#define HLP_IPXRIP_HELP3                HLP_IPXRIP_HELP1
#define HLP_IPXRIP_HELP4                HLP_IPXRIP_HELP1

#define HLP_IPXRIP_ADD_FILTER           1601
#define HLP_IPXRIP_DEL_FILTER           1602
#define HLP_IPXRIP_SET_FILTER           1603
#define HLP_IPXRIP_SHOW_FILTER          1604

#define HLP_IPXRIP_SET_INTERFACE        1610
#define HLP_IPXRIP_SHOW_INTERFACE       1611

#define HLP_IPXRIP_SET_GLOBAL           1621
#define HLP_IPXRIP_SHOW_GLOBAL          1622


//
// SAP help
//

#define HLP_IPXSAP_DUMP                 HLP_IPXRIP_DUMP
#define HLP_IPXSAP_HELP1                HLP_IPXRIP_HELP1
#define HLP_IPXSAP_HELP2                HLP_IPXSAP_HELP1
#define HLP_IPXSAP_HELP3                HLP_IPXSAP_HELP1
#define HLP_IPXSAP_HELP4                HLP_IPXSAP_HELP1

#define HLP_IPXSAP_ADD_FILTER           HLP_IPXRIP_ADD_FILTER
#define HLP_IPXSAP_DEL_FILTER           HLP_IPXRIP_DEL_FILTER
#define HLP_IPXSAP_SET_FILTER           HLP_IPXRIP_SET_FILTER
#define HLP_IPXSAP_SHOW_FILTER          HLP_IPXRIP_SHOW_FILTER

#define HLP_IPXSAP_SET_INTERFACE        HLP_IPXRIP_SET_INTERFACE
#define HLP_IPXSAP_SHOW_INTERFACE       HLP_IPXRIP_SHOW_INTERFACE

#define HLP_IPXSAP_SET_GLOBAL           HLP_IPXRIP_SET_GLOBAL
#define HLP_IPXSAP_SHOW_GLOBAL          HLP_IPXRIP_SHOW_GLOBAL


//
// NB help
//

#define HLP_IPXNB_DUMP                  HLP_IPXRIP_DUMP
#define HLP_IPXNB_HELP1                 HLP_IPXRIP_HELP1
#define HLP_IPXNB_HELP2                 HLP_IPXNB_HELP1
#define HLP_IPXNB_HELP3                 HLP_IPXNB_HELP1
#define HLP_IPXNB_HELP4                 HLP_IPXNB_HELP1

#define HLP_IPXNB_ADD_NAME              1661
#define HLP_IPXNB_DEL_NAME              1662
#define HLP_IPXNB_SHOW_NAME             1663

#define HLP_IPXNB_SET_INTERFACE         HLP_IPXRIP_SET_INTERFACE
#define HLP_IPXNB_SHOW_INTERFACE        HLP_IPXRIP_SHOW_INTERFACE


//
// Help displays
//

#define HLP_HELP_START                  1681
#define HLP_HELP_START1                 1682


//
// extended help tokens
//

//
// RIP extended help
//

#define HLP_IPXRIP_DUMP_EX              1701
#define HLP_IPXRIP_HELP1_EX             1702
#define HLP_IPXRIP_HELP2_EX             HLP_IPXRIP_HELP1_EX
#define HLP_IPXRIP_HELP3_EX             HLP_IPXRIP_HELP1_EX
#define HLP_IPXRIP_HELP4_EX             HLP_IPXRIP_HELP1_EX

#define HLP_IPXRIP_ADD_FILTER_EX        HLP_IPX_RIPFILTER
#define HLP_IPXRIP_DEL_FILTER_EX        HLP_IPX_RIPFILTER
#define HLP_IPXRIP_SET_FILTER_EX        HLP_IPX_RIPFILTER
#define HLP_IPXRIP_SHOW_FILTER_EX       HLP_IPX_RIPFILTER

#define HLP_IPXRIP_SET_INTERFACE_EX     HLP_IPX_RIPIF
#define HLP_IPXRIP_SHOW_INTERFACE_EX    HLP_IPX_RIPIF

#define HLP_IPXRIP_SET_GLOBAL_EX        HLP_IPX_RIPGL
#define HLP_IPXRIP_SHOW_GLOBAL_EX       HLP_IPX_RIPGL


//
// SAP extended help
//

#define HLP_IPXSAP_DUMP_EX              HLP_IPXRIP_DUMP_EX
#define HLP_IPXSAP_HELP1_EX             HLP_IPXRIP_HELP1_EX
#define HLP_IPXSAP_HELP2_EX             HLP_IPXSAP_HELP1_EX
#define HLP_IPXSAP_HELP3_EX             HLP_IPXSAP_HELP1_EX
#define HLP_IPXSAP_HELP4_EX             HLP_IPXSAP_HELP1_EX

#define HLP_IPXSAP_ADD_FILTER_EX        HLP_IPX_SAPFILTER
#define HLP_IPXSAP_DEL_FILTER_EX        HLP_IPX_SAPFILTER
#define HLP_IPXSAP_SET_FILTER_EX        HLP_IPX_SAPFILTER
#define HLP_IPXSAP_SHOW_FILTER_EX       HLP_IPX_SAPFILTER

#define HLP_IPXSAP_SET_INTERFACE_EX     HLP_IPX_SAPIF
#define HLP_IPXSAP_SHOW_INTERFACE_EX    HLP_IPX_SAPIF

#define HLP_IPXSAP_SET_GLOBAL_EX        HLP_IPX_SAPGL
#define HLP_IPXSAP_SHOW_GLOBAL_EX       HLP_IPX_SAPGL


//
// NB extended help
//

#define HLP_IPXNB_DUMP_EX               HLP_IPXRIP_DUMP_EX
#define HLP_IPXNB_HELP1_EX              HLP_IPXRIP_HELP1_EX
#define HLP_IPXNB_HELP2_EX              HLP_IPXNB_HELP1_EX
#define HLP_IPXNB_HELP3_EX              HLP_IPXNB_HELP1_EX
#define HLP_IPXNB_HELP4_EX              HLP_IPXNB_HELP1_EX


#define HLP_IPXNB_ADD_NAME_EX           HLP_IPX_NBNAME
#define HLP_IPXNB_DEL_NAME_EX           HLP_IPX_NBNAME
#define HLP_IPXNB_SHOW_NAME_EX          HLP_IPX_NBNAME

#define HLP_IPXNB_SET_INTERFACE_EX      HLP_IPX_NBIF
#define HLP_IPXNB_SHOW_INTERFACE_EX     HLP_IPX_NBIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ipx\protocols\nbifs.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    nbifs.c

Abstract:

    IPX Router Console Monitoring and Configuration tool.
    NBIPX Interface configuration and monitoring.

Author:

    Vadim Eydelman  06/07/1996


--*/

#include "precomp.h"
#pragma hdrstop


DWORD
MIBGetNbIpxIf(
    PWCHAR      InterfaceNameW,
    HANDLE      hFile
);

DWORD
CfgGetNbIpxIf (
    LPWSTR      InterfaceNameW,
    HANDLE      hFile
);

DWORD
MIBEnumNbIpxIfs (
    VOID
);

DWORD
CfgEnumNbIpxIfs (
    VOID
);

DWORD
CfgSetNbIpxIf (
    LPWSTR      InterfaceNameW,
    PULONG      pAccept         OPTIONAL,
    PULONG      pDeliver        OPTIONAL
);

DWORD
AdmSetNbIpxIf (
    LPWSTR      InterfaceNameW,
    PULONG      pAccept         OPTIONAL,
    PULONG      pDeliver        OPTIONAL
);

DWORD
GetNbIpxClientIf (
    PWCHAR      InterfaceNameW,
    UINT        msg,
    HANDLE      hFile
);



DWORD
APIENTRY 
HelpNbIf (
    IN    int                   argc,
    IN    WCHAR                *argv[]
) 
{
    DisplayMessage (g_hModule, HLP_IPX_NBIF);
    return 0;
}


DWORD
APIENTRY 
ShowNbIf (
    IN    int                   argc,
    IN    WCHAR                *argv[],
    IN    HANDLE                hFile
) 
{
    WCHAR   IfName[ MAX_INTERFACE_NAME_LEN ];
    DWORD   rc, dwSize = sizeof(IfName);

    
    if (argc < 1) 
    {
        if (g_hMIBServer) 
        {
            rc = MIBEnumNbIpxIfs ();
            
            if (rc == NO_ERROR)
            {
                rc = GetNbIpxClientIf (
                        VAL_DIALINCLIENT,
                        MSG_CLIENT_NBIF_MIB_TABLE_FMT,
                        NULL
                        );
            }
            else 
            {
                if ( !hFile ) { DisplayIPXMessage (g_hModule, MSG_REGISTRY_FALLBACK); }
                goto EnumerateThroughCfg;
            }
        }
        
        else 
        {
EnumerateThroughCfg:

            rc = CfgEnumNbIpxIfs ();
            
            if (rc == NO_ERROR)
            {
                rc = GetNbIpxClientIf (
                        VAL_DIALINCLIENT,
                        MSG_CLIENT_NBIF_CFG_TABLE_FMT,
                        NULL
                        );
            }
        }
    }

    else 
    {
        unsigned    count;

#define InterfaceNameW argv[0]
        count = wcslen( InterfaceNameW );

        if ( !_wcsicmp( argv[0], VAL_DIALINCLIENT ) )
        {
            rc = GetNbIpxClientIf(
                    VAL_DIALINCLIENT, MSG_CLIENT_NBIF_CFG_SCREEN_FMT, hFile
                    );
        }
        
        else if ((count > 0) && (count <= MAX_INTERFACE_NAME_LEN)) 
        {
            if (g_hMIBServer) 
            {
                //======================================
                // Translate the Interface Name
                //======================================

                rc = IpmontrGetIfNameFromFriendlyName(
                        InterfaceNameW, IfName, &dwSize
                        );

                if ( rc == NO_ERROR )
                {
                    rc = MIBGetNbIpxIf ( IfName, hFile );
                    
                    if (rc != NO_ERROR) 
                    {
                        if ( !hFile ) { DisplayIPXMessage (g_hModule, MSG_REGISTRY_FALLBACK); }
                        goto GetIfFromCfg;
                    }
                }
                else
                {
                    if ( !hFile ) { DisplayError( g_hModule, rc ); }
                }
            }
            else 
            {
GetIfFromCfg:
                //======================================
                // Translate the Interface Name
                //======================================

                rc = IpmontrGetIfNameFromFriendlyName(
                        InterfaceNameW, IfName, &dwSize
                        );

                if ( rc == NO_ERROR )
                {
                    rc = CfgGetNbIpxIf ( IfName, hFile );
                }
                
                else
                {
                    if ( !hFile ) { DisplayError( g_hModule, rc ); }
                }
            }
        }
        else 
        {
            if ( !hFile ) { DisplayIPXMessage (g_hModule, MSG_INVALID_INTERFACE_NAME); }
            rc = ERROR_INVALID_PARAMETER;
        }
    }

    return rc;
    
#undef InterfaceNameW
}


DWORD
APIENTRY 
SetNbIf (
    IN    int                   argc,
    IN    WCHAR                *argv[]
) 
{
    LPWSTR      InterfaceNameW;
    WCHAR       IfName[ MAX_INTERFACE_NAME_LEN + 1 ];
    DWORD       rc, dwSize = sizeof(IfName);


    if (argc >= 1) 
    {
        unsigned    count;
        BOOLEAN     client = FALSE;

        
#define InterfaceNameW argv[0]

        if ( !_wcsicmp( argv[0],VAL_DIALINCLIENT ) )
        {
            client = TRUE;
        }
        else
        {
            count = wcslen (InterfaceNameW);
        }

        if (client || ((count > 0) && (count <= MAX_INTERFACE_NAME_LEN))) 
        {
            int     i;
            ULONG   accept, deliver;
            PULONG  pAccept = NULL, pDeliver = NULL;
            

            for ( i = 1; i < argc; i++ ) 
            {
                if ( !_wcsicmp( argv[i], TOKEN_BCASTACCEPT ) ) 
                {
                    if ( (pAccept == NULL) && (i < argc - 1) && 
                         !MatchEnumTag(
                            g_hModule, argv[i+1], NUM_TOKENS_IN_TABLE( AdminStates ),
                            AdminStates, &accept
                            ) ) 
                    {
                        i += 1;
                        pAccept = &accept;
                        continue;
                    }
                    else
                    {
                        break;
                    }
                }
                
                if ( !_wcsicmp( argv[i], TOKEN_BCASTDELIVER ) )
                {
                    if ( (pDeliver == NULL) && (i < argc - 1) && 
                         !MatchEnumTag (g_hModule, argv[i+1], 
                            NUM_TOKENS_IN_TABLE( NbDeliverStates ), 
                            NbDeliverStates, &deliver) ) 
                    {
                        i += 1;
                        pDeliver = &deliver;
                        continue;
                    }
                    else
                    {
                        break;
                    }
                }
                
                if (pAccept == NULL) 
                {
                    if ( !MatchEnumTag( 
                            g_hModule, argv[ i ], NUM_TOKENS_IN_TABLE( AdminStates ),
                            AdminStates, &accept
                            )) 
                    {
                        pAccept = &accept;
                    }
                    
                    else
                    {
                        break;
                    }
                }
                
                else if (pDeliver == NULL) 
                {
                    if ( !MatchEnumTag( 
                            g_hModule, argv[i], NUM_TOKENS_IN_TABLE( NbDeliverStates ),
                            NbDeliverStates, &deliver
                            ) ) 
                    {
                        pDeliver = &deliver;
                    }
                    else
                    {
                        break;
                    }
                }
                else
                {
                    break;
                }
            }

            
            if (i == argc) 
            {
                if (!client) 
                {
                    DWORD rc2;
                    
                    //======================================
                    // Translate the Interface Name
                    //======================================
                    
                    rc = IpmontrGetIfNameFromFriendlyName(
                            InterfaceNameW, IfName, &dwSize
                            );

                    if ( rc == NO_ERROR )
                    {
                        rc2 = CfgSetNbIpxIf( IfName, pAccept, pDeliver);
                        
                        if (rc2 == NO_ERROR) 
                        {
                            if (g_hMprAdmin) 
                            {
                                rc = AdmSetNbIpxIf( IfName, pAccept, pDeliver );
                            }
                        }
                        else
                        {
                            rc = rc2;
                        }
                    }

                    else
                    {
                        DisplayError( g_hModule, rc );
                    }
                }
                else 
                {
                    rc = CfgSetNbIpxIf (NULL, pAccept, pDeliver);
                    
                    if (rc == NO_ERROR) 
                    {
                        if (g_hMprAdmin)
                        {
                            rc = AdmSetNbIpxIf (NULL, pAccept, pDeliver);
                        }
                    }
                }
            }
            else 
            {
                DisplayMessage (g_hModule, HLP_IPX_NBIF);
                rc = ERROR_INVALID_PARAMETER;
            }
        }

        else 
        {
            DisplayIPXMessage (g_hModule, MSG_INVALID_INTERFACE_NAME);
            rc = ERROR_INVALID_PARAMETER;
        }
    }

    else 
    {
        DisplayMessage (g_hModule, HLP_IPX_NBIF);
        rc = ERROR_INVALID_PARAMETER;
    }

    return rc;
    
#undef InterfaceNameW
}


DWORD
MIBGetNbIpxIf (
    PWCHAR      InterfaceNameW,
    HANDLE      hFile
) 
{
    DWORD                   rc, i;
    DWORD                   sz;
    IPX_MIB_GET_INPUT_DATA  MibGetInputData;
    PIPX_INTERFACE          pIf;
    WCHAR                   IfName[ MAX_INTERFACE_NAME_LEN + 1 ];
    DWORD                   dwSize = sizeof(IfName); 

    MibGetInputData.TableId = IPX_INTERFACE_TABLE;
    
    rc = GetIpxInterfaceIndex (
            g_hMIBServer, InterfaceNameW,
            &MibGetInputData.MibIndex.InterfaceTableIndex.InterfaceIndex
            );
            
    if (rc == NO_ERROR) 
    {
        rc = MprAdminMIBEntryGet(
                g_hMIBServer, PID_IPX, IPX_PROTOCOL_BASE, &MibGetInputData,
                sizeof(IPX_MIB_GET_INPUT_DATA), (LPVOID * ) & pIf, &sz
                );
                
        if (rc == NO_ERROR && pIf) 
        {
            PWCHAR        buffer[2];

            //======================================
            // Translate the Interface Name
            //======================================

            rc = IpmontrGetFriendlyNameFromIfName( InterfaceNameW, IfName, &dwSize );

            if ( rc == NO_ERROR )
            {
                buffer[ 0 ] = GetEnumString( 
                                g_hModule, pIf->NetbiosAccept, 
                                NUM_TOKENS_IN_TABLE( AdminStates ),
                                AdminStates
                                );

                buffer[ 1 ] = GetEnumString(
                                g_hModule, pIf->NetbiosDeliver,
                                NUM_TOKENS_IN_TABLE( NbDeliverStates ),
                                NbDeliverStates
                                );

                if ( buffer[ 0 ] && buffer[ 1 ] )
                {
                    if ( hFile )
                    {
                        DisplayMessageT(
                            DMP_IPX_NB_SET_INTERFACE, IfName, buffer[ 0 ],
                            buffer[ 1 ]
                            );
                    }

                    else
                    {
                        DisplayIPXMessage(
                            g_hModule, MSG_NBIF_MIB_SCREEN_FMT,
                            IfName, buffer[ 0 ], buffer[ 1 ],
                            pIf->IfStats.NetbiosReceived,
                            pIf->IfStats.NetbiosSent
                            );
                    }
                }
            }
            
            MprAdminMIBBufferFree (pIf);
        }
        else 
        {
            if ( !hFile ) { DisplayError( g_hModule, rc); }
        }
    }

    else 
    {
        if ( !hFile ) { DisplayError( g_hModule, rc); }
    }
    
    return rc;
}


DWORD
CfgGetNbIpxIf (
    LPWSTR    InterfaceNameW,
    HANDLE      hFile
) 
{
    DWORD        rc;
    DWORD        sz;
    HANDLE       hIfCfg;
    WCHAR        IfName[ MAX_INTERFACE_NAME_LEN + 1 ];
    DWORD        dwSize = sizeof(IfName);

    rc = MprConfigInterfaceGetHandle (
            g_hMprConfig, InterfaceNameW, &hIfCfg
            );
            
    if ( rc == NO_ERROR ) 
    {
        HANDLE  hIfTrCfg;

        rc = MprConfigInterfaceTransportGetHandle (
                g_hMprConfig, hIfCfg, PID_IPX, &hIfTrCfg
                );
                
        if (rc == NO_ERROR) 
        {
            LPBYTE pIfBlock;
            
            rc = MprConfigInterfaceTransportGetInfo (
                    g_hMprConfig, hIfCfg, hIfTrCfg, &pIfBlock, &sz
                    );
                    
            if (rc == NO_ERROR) 
            {
                PIPX_TOC_ENTRY pIpxToc;

                pIpxToc = GetIPXTocEntry (
                            (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                            IPX_INTERFACE_INFO_TYPE);
                            
                if (pIpxToc != NULL) 
                {
                    DWORD           i;
                    PIPX_IF_INFO    pIpxInfo;
                    PWCHAR          buffer[2];

                    pIpxInfo = (PIPX_IF_INFO) (pIfBlock + pIpxToc->Offset);

                    //======================================
                    // Translate the Interface Name
                    //======================================

                    rc = IpmontrGetFriendlyNameFromIfName( InterfaceNameW, IfName, &dwSize );

                    if ( rc == NO_ERROR )
                    {
                        buffer[ 0 ] = GetEnumString( 
                                        g_hModule, pIpxInfo->NetbiosAccept, 
                                        NUM_TOKENS_IN_TABLE( AdminStates ),
                                        AdminStates
                                        );

                        buffer[ 1 ] = GetEnumString(
                                        g_hModule, pIpxInfo->NetbiosDeliver,
                                        NUM_TOKENS_IN_TABLE( NbDeliverStates ),
                                        NbDeliverStates
                                        );

                        if ( buffer[ 0 ] && buffer[ 1 ] )
                        {
                            if ( hFile )
                            {
                                DisplayMessageT(
                                    DMP_IPX_NB_SET_INTERFACE, IfName, buffer[ 0 ],
                                    buffer[ 1 ]
                                    );
                            }

                            else
                            {
                                DisplayIPXMessage(
                                    g_hModule, MSG_NBIF_CFG_SCREEN_FMT,
                                    IfName, buffer[ 0 ], buffer[ 1 ]
                                    );
                            }
                        }
                    }
                }
                else 
                {
                    if ( !hFile ) { DisplayIPXMessage (g_hModule, MSG_INTERFACE_INFO_CORRUPTED); }
                    rc = ERROR_INVALID_DATA;
                }
            }
            
            else if ((rc == ERROR_FILE_NOT_FOUND) || (rc == ERROR_NO_MORE_ITEMS))
            {
                if ( !hFile ) { DisplayIPXMessage (g_hModule, MSG_NO_IPX_ON_INTERFACE_CFG); }
            }
            
            else 
            {
                if ( !hFile ) { DisplayError( g_hModule, rc); }
            }
        }
        else 
        {
            if ( !hFile ) { DisplayError( g_hModule, rc); }
        }
    }

    else if ((rc == ERROR_FILE_NOT_FOUND) || (rc == ERROR_NO_MORE_ITEMS))
    {
        if ( !hFile ) { DisplayError( g_hModule, ERROR_NO_SUCH_INTERFACE); }
    }
    else 
    {
        if ( !hFile ) { DisplayError( g_hModule, rc); }
    }

    return rc;
}


DWORD
GetNbIpxClientIf (
    PWCHAR          InterfaceName,
    UINT            msg,
    HANDLE          hFile
) 
{
    DWORD   rc;
    LPBYTE  pClBlock;
    HANDLE  hTrCfg;

    hTrCfg = NULL;
    
    if (g_hMprAdmin) 
    {
        DWORD   sz;
        
        rc = MprAdminTransportGetInfo(
                g_hMprAdmin, PID_IPX, NULL, NULL, &pClBlock, &sz
                );
                
        if (rc == NO_ERROR) 
        {
        }
        
        else 
        {
            if ((rc == ERROR_FILE_NOT_FOUND) || (rc == ERROR_NO_MORE_ITEMS))
            {
                if ( !hFile ) { DisplayIPXMessage (g_hModule, MSG_NO_IPX_IN_ROUTER_ADM); }
            }
            
            else
            {
                if ( !hFile ) { DisplayError( g_hModule, rc); }
            }
            
            if ( !hFile ) { DisplayIPXMessage (g_hModule, MSG_REGISTRY_FALLBACK); }
            goto GetFromCfg;
        }
    }
    
    else 
    {
GetFromCfg:

        rc = MprConfigTransportGetHandle (
                g_hMprConfig, PID_IPX, &hTrCfg
                );
                
        if (rc == NO_ERROR) 
        {
            DWORD    sz;

            rc = MprConfigTransportGetInfo (
                    g_hMprConfig, hTrCfg, NULL, NULL, &pClBlock, &sz, NULL
                    );
                    
            if (rc == NO_ERROR)
            {
                NOTHING;
            }
            else
            {
                if ( !hFile ) { DisplayError( g_hModule, rc); }
            }
        }
        
        else 
        {
            if ((rc == ERROR_FILE_NOT_FOUND) || (rc == ERROR_NO_MORE_ITEMS))
            {
                if ( !hFile ) { DisplayIPXMessage (g_hModule, MSG_NO_IPX_IN_ROUTER_ADM); }
            }
            
            else
            {
                if ( !hFile ) { DisplayError( g_hModule, rc); }
            }
        }
    }

    
    if (rc == NO_ERROR) 
    {
        DWORD   i;
        PIPX_TOC_ENTRY pIpxToc;

        pIpxToc = GetIPXTocEntry(
                    (PIPX_INFO_BLOCK_HEADER)pClBlock,
                    IPX_INTERFACE_INFO_TYPE
                    );
                    
        if (pIpxToc != NULL) 
        {
            PIPX_IF_INFO    pIpxInfo;
            PWCHAR          buffer[2];
            
            pIpxInfo = (PIPX_IF_INFO) (pClBlock + pIpxToc->Offset);

            buffer[ 0 ] = GetEnumString( 
                            g_hModule, 
                            pIpxInfo->NetbiosAccept, 
                            NUM_TOKENS_IN_TABLE( AdminStates ),
                            AdminStates
                            );

            buffer[ 1 ] = GetEnumString(
                            g_hModule, pIpxInfo->NetbiosDeliver,
                            NUM_TOKENS_IN_TABLE( NbDeliverStates ),
                            NbDeliverStates
                            );

            if ( buffer[ 0 ] && buffer[ 1 ] )
            {
                if ( hFile )
                {
                    DisplayMessageT(
                        DMP_IPX_NB_SET_INTERFACE, InterfaceName, buffer[ 0 ],
                        buffer[ 1 ]
                        );
                }

                else
                {
                    DisplayIPXMessage(
                        g_hModule, msg, InterfaceName,
                        buffer[ 0 ], buffer[ 1 ]
                        );
                }
            }
        }
        
        else 
        {
            if ( !hFile ) { DisplayIPXMessage (g_hModule, MSG_INTERFACE_INFO_CORRUPTED); }
            rc = ERROR_INVALID_DATA;
        }
        
        if (hTrCfg != NULL)
        {
            MprConfigBufferFree (pClBlock);
        }
        else
        {
            MprAdminBufferFree (pClBlock);
        }
    }
    
    return rc;
}


PIPX_IF_INFO 
GetIpxNbInterface(
    HANDLE          hIf, 
    LPBYTE         *pIfBlock
    ) 
{
    DWORD dwSize;
    DWORD dwErr;
    PIPX_TOC_ENTRY pIpxToc;

    dwErr = MprAdminInterfaceTransportGetInfo(
                g_hMprAdmin, hIf, PID_IPX, pIfBlock, &dwSize
                );

    if (dwErr != NO_ERROR)
    {
        return NULL;
    }


    pIpxToc = GetIPXTocEntry(
                (PIPX_INFO_BLOCK_HEADER)(*pIfBlock), 
                IPX_INTERFACE_INFO_TYPE
                );
                
    if (!pIpxToc)
    {
        return NULL;
    }

    return (PIPX_IF_INFO)((*pIfBlock) + (pIpxToc->Offset));

//  return (PIPX_IF_INFO)GetIPXTocEntry((PIPX_INFO_BLOCK_HEADER)(*pIfBlock),IPX_INTERFACE_INFO_TYPE);
}


DWORD
MIBEnumNbIpxIfs(
    VOID
    ) 
{
    PMPR_INTERFACE_0 IfList = NULL;

    DWORD dwErr = 0, dwRead, dwTot, i, j, rc;

    PWCHAR buffer[4];

    PIPX_IF_INFO pIpxInfo = NULL;

    LPBYTE buf = NULL;

    WCHAR IfName[ MAX_INTERFACE_NAME_LEN + 1 ];
    DWORD dwSize = sizeof(IfName);

    DisplayIPXMessage ( g_hModule, MSG_NBIF_MIB_TABLE_HDR );

    dwErr = MprAdminInterfaceEnum(
                g_hMprAdmin, 0, (unsigned char **) & IfList, MAXULONG, 
                &dwRead, &dwTot, NULL
                );
                
    if (dwErr != NO_ERROR)
    {
        return dwErr;
    }

    for (i = 0; i < dwRead; i++) 
    {
        if ((pIpxInfo = GetIpxNbInterface(IfList[i].hInterface, &buf)) != NULL) 
        {
            //======================================
            // Translate the Interface Name
            //======================================

            rc = IpmontrGetFriendlyNameFromIfName( IfList[i].wszInterfaceName, IfName, &dwSize );

            if ( rc == NO_ERROR )
            {
                buffer[ 0 ] = GetEnumString( 
                                g_hModule, pIpxInfo->NetbiosAccept, 
                                NUM_TOKENS_IN_TABLE( AdminStates ),
                                AdminStates
                                );

                buffer[ 1 ] = GetEnumString(
                                g_hModule, pIpxInfo->NetbiosDeliver,
                                NUM_TOKENS_IN_TABLE( NbDeliverStates ),
                                NbDeliverStates
                                );

                if ( buffer[ 0 ] && buffer[ 1 ] )
                {
                    DisplayIPXMessage(
                        g_hModule, MSG_NBIF_MIB_TABLE_FMT,
                        IfName, buffer[ 0 ], buffer[ 1 ]
                        );
                }
            }
        }
        
        if (buf)
        {
            MprAdminBufferFree(buf);
        }

        buf = NULL;
    }

    return NO_ERROR;
}


/*
DWORD
MIBEnumNbIpxIfs (
    VOID
    ) {
    DWORD                    rc;
    DWORD                    sz;
    IPX_MIB_GET_INPUT_DATA    MibGetInputData;
    PIPX_INTERFACE            pIf;

    DisplayIPXMessage (g_hModule, MSG_NBIF_MIB_TABLE_HDR);
    MibGetInputData.TableId = IPX_INTERFACE_TABLE;
    rc = MprAdminMIBEntryGetFirst (
                g_hMIBServer,
                PID_IPX,
                IPX_PROTOCOL_BASE,
                &MibGetInputData,
                sizeof(IPX_MIB_GET_INPUT_DATA),
                (LPVOID *)&pIf,
                &sz);
    while (rc==NO_ERROR) {
        WCHAR        buffer[2][MAX_VALUE];
        HANDLE      hIfCfg;
        WCHAR       InterfaceNameW[MAX_INTERFACE_NAME_LEN+1];
        pIf->InterfaceName[47]=0;
        mbstowcs (InterfaceNameW, pIf->InterfaceName,  sizeof (InterfaceNameW));

        //======================================
        // Translate the Interface Name
        //======================================
        if ((rc=(*(Params->IfName2DescA))(pIf->InterfaceName,
                                    Params->IfNamBufferA,
                                      &Params->IfNamBufferLength)) != NO_ERROR) {
                return rc;
        }
        //======================================
        if (MprConfigInterfaceGetHandle (
                        g_hMprConfig,
                        InterfaceNameW,
                        &hIfCfg)==NO_ERROR) {
            DisplayIPXMessage (g_hModule,
                MSG_NBIF_MIB_TABLE_FMT,
                pIf->InterfaceName,   //Params->IfNamBufferA, 
                GetValueString (g_hModule, Utils, AdminStates,
                        pIf->NetbiosAccept, buffer[0]),
                GetValueString (g_hModule, Utils, NbDeliverStates,
                        pIf->NetbiosDeliver, buffer[1])
                );
        }
        MibGetInputData.MibIndex.InterfaceTableIndex.InterfaceIndex
                = pIf->InterfaceIndex;
        MprAdminMIBBufferFree (pIf);
        rc = MprAdminMIBEntryGetNext (
                    g_hMIBServer,
                    PID_IPX,
                    IPX_PROTOCOL_BASE,
                    &MibGetInputData,
                    sizeof(IPX_MIB_GET_INPUT_DATA),
                    (LPVOID *)&pIf,
                    &sz);
    }
    if (rc==ERROR_NO_MORE_ITEMS)
        return NO_ERROR;
    else {
        if (rc==NO_ERROR)
            rc = ERROR_GEN_FAILURE;
        DisplayError( g_hModule, rc);
        return rc;
    }
}
*/


DWORD
CfgEnumNbIpxIfs (
    VOID
) 
{
    DWORD               rc = NO_ERROR;
    DWORD               read, total, processed = 0, i, j;
    DWORD               hResume = 0;
    DWORD               sz;
    PMPR_INTERFACE_0    pRi0;
    WCHAR               IfName[ MAX_INTERFACE_NAME_LEN + 1 ];
    DWORD               dwSize = sizeof(IfName);

    DisplayIPXMessage (g_hModule, MSG_NBIF_CFG_TABLE_HDR);
    
    do 
    {
        rc = MprConfigInterfaceEnum (
                g_hMprConfig, 0, (LPBYTE * ) & pRi0, MAXULONG, &read,
                &total, &hResume
                );
                
        if ( rc == NO_ERROR ) 
        {
            for (i = 0; i < read; i++) 
            {
                HANDLE  hIfTrCfg;

                rc = MprConfigInterfaceTransportGetHandle(
                        g_hMprConfig, pRi0[i].hInterface, PID_IPX, &hIfTrCfg
                        );
                        
                if (rc == NO_ERROR) 
                {
                    LPBYTE    pIfBlock;
                    
                    rc = MprConfigInterfaceTransportGetInfo (
                            g_hMprConfig, pRi0[i].hInterface, hIfTrCfg, 
                            &pIfBlock, &sz
                            );
                            
                    if (rc == NO_ERROR) 
                    {
                        PIPX_TOC_ENTRY pIpxToc;

                        pIpxToc = GetIPXTocEntry(
                                    (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                                    IPX_INTERFACE_INFO_TYPE
                                    );
                                    
                        if (pIpxToc != NULL) 
                        {
                            PIPX_IF_INFO    pIpxInfo;
                            PWCHAR          buffer[2];

                            pIpxInfo = (PIPX_IF_INFO) (pIfBlock + pIpxToc->Offset);

                            //======================================
                            // Translate the Interface Name
                            //======================================

                            rc = IpmontrGetFriendlyNameFromIfName( 
                                    pRi0[i].wszInterfaceName, IfName, &dwSize 
                                    );

                            if ( rc == NO_ERROR )
                            {
                                buffer[ 0 ] = GetEnumString( 
                                                g_hModule, pIpxInfo->NetbiosAccept, 
                                                NUM_TOKENS_IN_TABLE( AdminStates ),
                                                AdminStates
                                                );

                                buffer[ 1 ] = GetEnumString(
                                                g_hModule, pIpxInfo->NetbiosDeliver,
                                                NUM_TOKENS_IN_TABLE( NbDeliverStates ),
                                                NbDeliverStates
                                                );

                                if ( buffer[ 0 ] && buffer[ 1 ] )
                                {
                                    DisplayIPXMessage(
                                        g_hModule, MSG_NBIF_CFG_TABLE_FMT,
                                        IfName, buffer[ 0 ], buffer[ 1 ]
                                        );
                                }
                            }
                        }
                        else 
                        {
                            DisplayIPXMessage (g_hModule, MSG_INTERFACE_INFO_CORRUPTED);
                            rc = ERROR_INVALID_DATA;
                        }
                    }
                    else if (rc != ERROR_NO_MORE_ITEMS) 
                    {
                        // No IPX installed
                        DisplayError( g_hModule, rc);
                    }
                }
                else 
                {
                    //DisplayError( g_hModule, rc);
                    rc = NO_ERROR;
                }
            }
            
            processed += read;
            MprConfigBufferFree (pRi0);
        }
        else 
        {
            DisplayError( g_hModule, rc);
            break;
        }
        
    } while (processed < total);

    return rc;
}


DWORD
CfgSetNbIpxIf (
    LPWSTR        InterfaceNameW,
    PULONG        pAccept         OPTIONAL,
    PULONG        pDeliver        OPTIONAL
) 
{
    DWORD        rc;
    DWORD        sz;
    HANDLE       hTrCfg;
    HANDLE       hIfCfg;
    HANDLE       hIfTrCfg;
    LPBYTE       pIfBlock;


    if (InterfaceNameW != NULL) 
    {
        rc = MprConfigInterfaceGetHandle(
                g_hMprConfig, InterfaceNameW, &hIfCfg
                );
                
        if (rc == NO_ERROR) 
        {
            rc = MprConfigInterfaceTransportGetHandle (
                    g_hMprConfig, hIfCfg, PID_IPX, &hIfTrCfg
                    );
                    
            if (rc == NO_ERROR) 
            {
                rc = MprConfigInterfaceTransportGetInfo (
                        g_hMprConfig, hIfCfg, hIfTrCfg, &pIfBlock, &sz
                        );
            }
        }
    }
    
    else 
    {
        rc = MprConfigTransportGetHandle (
                g_hMprConfig, PID_IPX, &hTrCfg
                );
                
        if (rc == NO_ERROR) 
        {
            rc = MprConfigTransportGetInfo (
                    g_hMprConfig, hTrCfg, NULL, NULL, &pIfBlock, &sz, NULL
                    );
        }
    }

    if (rc == NO_ERROR) 
    {
        PIPX_TOC_ENTRY pIpxToc;

        pIpxToc = GetIPXTocEntry (
                    (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                    IPX_INTERFACE_INFO_TYPE
                    );
                    
        if (pIpxToc != NULL) 
        {
            PIPX_IF_INFO    pIpxInfo;

            pIpxInfo = (PIPX_IF_INFO) (pIfBlock + pIpxToc->Offset);

            if (ARGUMENT_PRESENT (pAccept))
            {
                pIpxInfo->NetbiosAccept = *pAccept;
            }
            
            if (ARGUMENT_PRESENT (pDeliver))
            {
                pIpxInfo->NetbiosDeliver = *pDeliver;
            }

            if (InterfaceNameW != NULL)
            {
                rc = MprConfigInterfaceTransportSetInfo (
                    g_hMprConfig, hIfCfg, hIfTrCfg, pIfBlock, sz
                    );
            }
            else
            {
                rc = MprConfigTransportSetInfo (
                        g_hMprConfig, hTrCfg, NULL, 0, pIfBlock, sz, NULL
                        );
            }
            
            if (rc == NO_ERROR) 
            {
                if (InterfaceNameW != NULL)
                {
                    DisplayIPXMessage (g_hModule, MSG_NBIF_SET_CFG, InterfaceNameW );
                }
            }
            else
            {
                DisplayIPXMessage (g_hModule, MSG_CLIENT_NBIF_SET_CFG );
            }
        }
        else 
        {
            DisplayIPXMessage (g_hModule, MSG_INTERFACE_INFO_CORRUPTED);
            rc = ERROR_INVALID_DATA;
        }
        
        MprConfigBufferFree (pIfBlock);
    }
    
    else
    {
        DisplayError( g_hModule, rc);
    }

    return rc;
}


DWORD
AdmSetNbIpxIf (
    LPWSTR        InterfaceNameW,
    PULONG        pAccept         OPTIONAL,
    PULONG        pDeliver        OPTIONAL
) 
{
    DWORD       rc;
    DWORD       sz;
    HANDLE      hIfAdm;
    LPBYTE       pIfBlock;

    if (InterfaceNameW != NULL) 
    {
        rc = MprAdminInterfaceGetHandle (
                g_hMprAdmin, InterfaceNameW, &hIfAdm, FALSE
                );
                
        if (rc == NO_ERROR) 
        {
            rc = MprAdminInterfaceTransportGetInfo (
                    g_hMprAdmin, hIfAdm, PID_IPX, &pIfBlock, &sz
                    );
        }
    }
    
    else 
    {
        rc = MprAdminTransportGetInfo (
                g_hMprAdmin, PID_IPX, NULL, NULL, &pIfBlock, &sz
                );
                
        if (rc == NO_ERROR) 
        {
            if (pIfBlock == NULL)
            return rc;
        }
    }


    if (rc == NO_ERROR) 
    {
        PIPX_TOC_ENTRY pIpxToc;

        pIpxToc = GetIPXTocEntry (
                    (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                    IPX_INTERFACE_INFO_TYPE
                    );
                    
        if (pIpxToc != NULL) 
        {
            PIPX_IF_INFO    pIpxInfo;

            pIpxInfo = (PIPX_IF_INFO)(pIfBlock + pIpxToc->Offset);

            if (ARGUMENT_PRESENT (pAccept))
            {
                pIpxInfo->NetbiosAccept = *pAccept;
            }
            
            if (ARGUMENT_PRESENT (pDeliver))
            {
                pIpxInfo->NetbiosDeliver = *pDeliver;
            }

            if (InterfaceNameW != NULL)
            {
                rc = MprAdminInterfaceTransportSetInfo (
                        g_hMprAdmin, hIfAdm, PID_IPX, pIfBlock,
                        ((PIPX_INFO_BLOCK_HEADER)pIfBlock)->Size
                        );
            }
            
            else
            {
                rc = MprAdminTransportSetInfo (
                    g_hMprAdmin, PID_IPX, NULL, 0, pIfBlock,
                    ((PIPX_INFO_BLOCK_HEADER)pIfBlock)->Size
                    );
            }

            if (rc == NO_ERROR) 
            {
                if (InterfaceNameW != NULL)
                {
                    DisplayIPXMessage (
                        g_hModule,MSG_NBIF_SET_ADM, InterfaceNameW
                        );
                }
                
                else
                {
                    DisplayIPXMessage (g_hModule, MSG_CLIENT_NBIF_SET_ADM);
                }
            }
            
            else
            {
                DisplayError( g_hModule, rc);
            }
        }
        else 
        {
            DisplayIPXMessage (g_hModule, MSG_INTERFACE_INFO_CORRUPTED);
            rc = ERROR_INVALID_DATA;
        }
        
            MprAdminBufferFree (pIfBlock);
    }
    else 
    {
        DisplayError( g_hModule, rc);
    }

    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ipx\protocols\nb.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    nb.c

Abstract:

    IPX Router Console Monitoring and Configuration tool.
    NB Command dispatcher.

Author:

    V Raman     1/5/1998

--*/

#include "precomp.h"
#pragma hdrstop

FN_HANDLE_CMD HandleIpxNbAddName;
FN_HANDLE_CMD HandleIpxNbDelName;
FN_HANDLE_CMD HandleIpxNbShowName;
FN_HANDLE_CMD HandleIpxNbSetInterface;
FN_HANDLE_CMD HandleIpxNbShowInterface;

//
// Table of add, delete, set and show commands for IPXNB
//

//
// The commands are prefix-matched with the command-line, in sequential
// order. So a command like 'ADD INTERFACE FILTER' must come before
// the command 'ADD INTERFACE' in the table.
//

CMD_ENTRY   g_IpxNbAddCmdTable[] =
{
    CREATE_CMD_ENTRY( IPXNB_ADD_NAME, HandleIpxNbAddName )
};


CMD_ENTRY   g_IpxNbDelCmdTable[] =
{
    CREATE_CMD_ENTRY( IPXNB_DEL_NAME, HandleIpxNbDelName )
};


CMD_ENTRY   g_IpxNbSetCmdTable[] =
{
    CREATE_CMD_ENTRY( IPXNB_SET_INTERFACE, HandleIpxNbSetInterface )
};


CMD_ENTRY   g_IpxNbShowCmdTable[] =
{
    CREATE_CMD_ENTRY( IPXNB_SHOW_NAME, HandleIpxNbShowName ),
    CREATE_CMD_ENTRY( IPXNB_SHOW_INTERFACE, HandleIpxNbShowInterface )
};


//
// Command groups
//

CMD_GROUP_ENTRY g_IpxNbCmdGroups[] =
{
    CREATE_CMD_GROUP_ENTRY( GROUP_ADD, g_IpxNbAddCmdTable ),
    CREATE_CMD_GROUP_ENTRY( GROUP_DELETE, g_IpxNbDelCmdTable ),
    CREATE_CMD_GROUP_ENTRY( GROUP_SET, g_IpxNbSetCmdTable ),
    CREATE_CMD_GROUP_ENTRY( GROUP_SHOW, g_IpxNbShowCmdTable )
};


ULONG g_ulIpxNbNumGroups = 
        sizeof( g_IpxNbCmdGroups ) / sizeof( CMD_GROUP_ENTRY );



//
// functions to handle top level functions
//

DWORD
HandleIpxNbDump(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD dwErr, dwRead = 0, dwTot = 0, i;
    PMPR_INTERFACE_0 IfList;
    WCHAR IfDisplayName[ MAX_INTERFACE_NAME_LEN + 1 ];
    PWCHAR argv[1];
    DWORD dwSize = sizeof(IfDisplayName);


    DisplayIPXMessage (g_hModule, MSG_IPX_NB_DUMP_HEADER);

    DisplayMessageT( DMP_IPX_NB_HEADER );

    //
    // enumerate interfaces
    //

    if ( g_hMprAdmin )
    {
        dwErr = MprAdminInterfaceEnum(
                    g_hMprAdmin, 0, (unsigned char **)&IfList, MAXULONG, &dwRead,
                    &dwTot,NULL
                    );
    }

    else
    {
        dwErr = MprConfigInterfaceEnum(
                    g_hMprConfig, 0, (unsigned char **)&IfList, MAXULONG, &dwRead,
                    &dwTot,NULL
                    );
    }

    if ( dwErr != NO_ERROR )
    {
        return dwErr;
    }


    //
    // enumerate interface settings on each interface
    //


    for ( i = 0; i < dwRead; i++ )
    {
        dwErr = IpmontrGetFriendlyNameFromIfName(
                    IfList[i].wszInterfaceName, IfDisplayName, &dwSize
                );

        if ( dwErr == NO_ERROR )
        {
            argv[0] = IfDisplayName;

            ShowNbIf( 1, argv, (HANDLE)-1 );
            
            ShowNbName( 1, argv, (HANDLE)-1 );
        }
    }
    
    DisplayMessageT( DMP_IPX_NB_FOOTER );
    
    DisplayIPXMessage (g_hModule, MSG_IPX_NB_DUMP_FOOTER);


    if ( g_hMprAdmin )
    {
        MprAdminBufferFree( IfList );
    }
    else
    {
        MprConfigBufferFree( IfList );
    }
    
    return NO_ERROR;
}


//
// Functions to handle IPX NB Filter add/del/set/show
//



DWORD
HandleIpxNbAddName(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return CreateNbName( 
            dwArgCount - dwCurrentIndex, ppwcArguments + dwCurrentIndex 
            );
}



DWORD
HandleIpxNbDelName(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return DeleteNbName( 
            dwArgCount - dwCurrentIndex, ppwcArguments + dwCurrentIndex 
            );
}



DWORD
HandleIpxNbSetInterface(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return SetNbIf( 
            dwArgCount - dwCurrentIndex, ppwcArguments + dwCurrentIndex 
            );
}



DWORD
HandleIpxNbShowInterface(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return ShowNbIf( 
            dwArgCount - dwCurrentIndex, ppwcArguments + dwCurrentIndex, NULL
            );
}




DWORD
HandleIpxNbShowName(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return ShowNbName( 
            dwArgCount - dwCurrentIndex, ppwcArguments + dwCurrentIndex, NULL
            );
}



DWORD
IpxNbDump(
    IN      LPCWSTR     pwszRouter,
    IN OUT  LPWSTR     *ppwcArguments,
    IN      DWORD       dwArgCount,
    IN      LPCVOID     pvData
    )
{
    ConnectToRouter(pwszRouter);
    
    //g_hMIBServer = (MIB_SERVER_HANDLE)pvData;

    return HandleIpxNbDump(pwszRouter, ppwcArguments, 1, dwArgCount, 0,
                           pvData, NULL );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ipx\protocols\ipxstrng.h ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    net\routing\netsh\ipx\protocols\ipxstrng.h


Abstract:

    Non-localizable string definitions


History:

    V Raman                 Created     1/21/99

--*/

//
// Command line - option tags
//

#define TOKEN_LOGLEVEL          L"loglevel="
#define TOKEN_ADMINSTATE        L"admstate="
#define TOKEN_ADVERTISE         L"advertise="
#define TOKEN_LISTEN            L"listen="
#define TOKEN_GNSREPLY          L"gnsreply="
#define TOKEN_UPDATEMODE        L"updatemode="
#define TOKEN_INTERVAL          L"interval="
#define TOKEN_AGEMULTIPLIER     L"agemultiplier="
#define TOKEN_BCASTACCEPT       L"bcastaccept="
#define TOKEN_BCASTDELIVER      L"bcastdeliver="


//
// Command line - option values
//

#define VAL_ENABLED             L"Enabled"
#define VAL_DISABLED            L"Disabled"
#define VAL_STANDARD            L"Standard"
#define VAL_NONE                L"None"
#define VAL_AUTOSTATIC          L"Autostatic"
#define VAL_STATICONLY          L"StaticOnly"
#define VAL_ONLYWHENUP          L"OnlyWhenUp"
#define VAL_PERMIT              L"Permit"
#define VAL_DENY                L"Deny"
#define VAL_INPUT               L"Input"
#define VAL_OUTPUT              L"Output"
#define VAL_UP                  L"Up"
#define VAL_DOWN                L"Down"
#define VAL_SLEEPING            L"Sleeping"
#define VAL_CLIENT              L"Client"
#define VAL_ERRORS_ONLY         L"Errors_Only"
#define VAL_ERRORS_AND_WARNINGS L"Warnings_And_Errors"
#define VAL_MAXINFO             L"Maximum_Information"

#define VAL_DEDICATED           L"Dedicated"
#define VAL_WANROUTER           L"Demand Dial"
#define VAL_INTERNAL            L"Internal"
#define VAL_HOMEROUTER          L"Demand Dial"    

#define VAL_DIALINCLIENT        L"Dial-in"
#define VAL_DIALOUT             L"Dial-Out"

#define VAL_LOCAL               L"Local"
#define VAL_STATIC              L"Static"
#define VAL_RIP                 L"RIP"
#define VAL_SAP                 L"SAP"
    
#define VAL_ANYNAME             L"*"
#define VAL_OTHER               L"Other"

//
// help tokens
//

#define TOKEN_HELP1             L"?"
#define TOKEN_HELP2             L"HELP"

//
// Command line - command names
//

#define CMD_GROUP_ADD           L"add"
#define CMD_GROUP_DELETE        L"delete"
#define CMD_GROUP_SET           L"set"
#define CMD_GROUP_SHOW          L"show"

//
// RIP tokens
//

#define CMD_IPXRIP_DUMP         L"dump"
#define CMD_IPXRIP_HELP1        L"?"
#define CMD_IPXRIP_HELP2        L"help"
#define CMD_IPXRIP_HELP3        L"/?"
#define CMD_IPXRIP_HELP4        L"-?"

#define CMD_IPXRIP_ADD_FILTER   L"filter"
#define CMD_IPXRIP_DEL_FILTER   L"filter"
#define CMD_IPXRIP_SET_FILTER   L"filter"
#define CMD_IPXRIP_SHOW_FILTER  L"filter"

#define CMD_IPXRIP_SET_INTERFACE    L"interface"
#define CMD_IPXRIP_SHOW_INTERFACE   L"interface"

#define CMD_IPXRIP_SET_GLOBAL   L"global"
#define CMD_IPXRIP_SHOW_GLOBAL  L"global"

#define CMD_IPXNB_ADD_NAME      L"nbname"
#define CMD_IPXNB_DEL_NAME      L"nbname"
#define CMD_IPXNB_SHOW_NAME     L"nbname"

//
// SAP tokens
//

#define CMD_IPXSAP_DUMP                 CMD_IPXRIP_DUMP
#define CMD_IPXSAP_HELP1                CMD_IPXRIP_HELP1
#define CMD_IPXSAP_HELP2                CMD_IPXRIP_HELP2
#define CMD_IPXSAP_HELP3                CMD_IPXRIP_HELP3
#define CMD_IPXSAP_HELP4                CMD_IPXRIP_HELP4


#define CMD_IPXSAP_ADD_FILTER           CMD_IPXRIP_ADD_FILTER
#define CMD_IPXSAP_DEL_FILTER           CMD_IPXRIP_DEL_FILTER
#define CMD_IPXSAP_SET_FILTER           CMD_IPXRIP_SET_FILTER
#define CMD_IPXSAP_SHOW_FILTER          CMD_IPXRIP_SHOW_FILTER

#define CMD_IPXSAP_SET_INTERFACE        CMD_IPXRIP_SET_INTERFACE
#define CMD_IPXSAP_SHOW_INTERFACE       CMD_IPXRIP_SHOW_INTERFACE

#define CMD_IPXSAP_SET_GLOBAL           CMD_IPXRIP_SET_GLOBAL
#define CMD_IPXSAP_SHOW_GLOBAL          CMD_IPXRIP_SHOW_GLOBAL

//
// NB tokens
//

#define CMD_IPXNB_DUMP                  CMD_IPXRIP_DUMP
#define CMD_IPXNB_HELP1                 CMD_IPXRIP_HELP1
#define CMD_IPXNB_HELP2                 CMD_IPXRIP_HELP2
#define CMD_IPXNB_HELP3                 CMD_IPXRIP_HELP3
#define CMD_IPXNB_HELP4                 CMD_IPXRIP_HELP4

#define CMD_IPXNB_SET_INTERFACE         CMD_IPXRIP_SET_INTERFACE
#define CMD_IPXNB_SHOW_INTERFACE        CMD_IPXRIP_SHOW_INTERFACE


//
// RIP dump statements
//

#define DMP_IPX_RIP_HEADER              L"\
\npushd routing ipx rip"

#define DMP_IPX_RIP_FOOTER              L"\
\npopd\n"

#define DMP_IPX_RIP_SET_GLOBAL          L"\
\nset global loglevel = %1!s!"

#define DMP_IPX_RIP_SET_FILTER          L"\
\nset filter \"%1!s!\" %2!s! %3!s!"

#define DMP_IPX_RIP_SET_INTERFACE       L"\
\nset interface \"%1!s!\" admstate = %2!s! advertise = %3!s! listen = %4!s! \
updatemode = %5!s! interval = %6!d! agemultiplier = %7!d!"

#define DMP_IPX_RIP_ADD_FILTER          L"\
\nadd filter \"%1!s!\" %2!s! 0x%3!.2x!%4!.2x!%5!.2x!%6!.2x! 0x%7!.2x!%8!.2x!%9!.2x!%10!.2x!"


//
// SAP dump statements
//

#define DMP_IPX_SAP_HEADER              L"\
\npushd routing ipx sap"

#define DMP_IPX_SAP_FOOTER              L"\
\npopd\n"

#define DMP_IPX_SAP_SET_GLOBAL          L"\
\nset global loglevel = %1!s!"

#define DMP_IPX_SAP_SET_INTERFACE       L"\
\nset interface \"%1!s!\" admstate = %2!s! advertise = %3!s! listen = %4!s! \
gnsreply = %5!s! updatemode = %6!s! interval = %7!d! agemultiplier = %8!d!"

#define DMP_IPX_SAP_SET_FILTER          L"\
\nset filter \"%1!s!\" %2!s! %3!s!"

#define DMP_IPX_SAP_ADD_FILTER          L"\
\nadd filter \"%1!s!\" %2!s! 0x%3!x! %4!s!"



//
// NB dump statements
//

#define DMP_IPX_NB_HEADER               L"\
\npushd routing ipx netbios"

#define DMP_IPX_NB_FOOTER               L"\
\npopd\n"

#define DMP_IPX_NB_SET_INTERFACE        L"\
\nset interface \"%1!s!\" bcastaccept = %2!s! bcastdeliver = %3!s!"

#define DMP_IPX_NB_ADD_NAME             L"\
\nadd filter \"%1!s!\" %2!hs!! 0x%3!x!"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ipx\protocols\nbifs.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    nbifs.h

Abstract:

    IPX Router Console Monitoring and Configuration tool.
    NBIPX Interface configuration and monitoring. Header File

Author:

    Vadim Eydelman  06/07/1996


--*/
#ifndef _IPXMON_NBIFS_
#define _IPXMON_NBIFS_

DWORD
APIENTRY 
HelpNbIf (
    IN    int                    argc,
    IN    WCHAR                *argv[]
    );

DWORD
APIENTRY 
ShowNbIf (
    IN    int                    argc,
    IN    WCHAR                *argv[],
    IN    HANDLE                hFile
    );

DWORD
APIENTRY 
SetNbIf (
    IN    int                    argc,
    IN    WCHAR                *argv[]
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ipx\protocols\nbnames.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    nbnames.h

Abstract:

    IPX Router Console Monitoring and Configuration tool.
    NetBIOS name configuration and monitoring. Header File

Author:

    Vadim Eydelman  06/07/1996


--*/
#ifndef _IPXMON_NBNAMES_
#define _IPXMON_NBNAMES_

DWORD
APIENTRY 
HelpNbName (
    IN    int                   argc,
    IN    WCHAR                *argv[]
    );

DWORD
APIENTRY 
ShowNbName (
    IN    int                   argc,
    IN    WCHAR                *argv[],
    IN    HANDLE                hFile
    );

DWORD
APIENTRY 
CreateNbName (
    IN    int                   argc,
    IN    WCHAR                *argv[]
    );

DWORD
APIENTRY 
DeleteNbName (
    IN    int                   argc,
    IN    WCHAR                *argv[]
    );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ipx\protocols\nbnames.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    nbnames.c

Abstract:

    IPX Router Console Monitoring and Configuration tool.
    NetBIOS name configuration and monitoring.

Author:

    Vadim Eydelman  06/07/1996


--*/
#include "precomp.h"
#pragma hdrstop

#define OPERATION_DEL_NBNAME    (-1)
#define OPERATION_ADD_NBNAME    1


DWORD
AdmSetNbName (
    int     operation,
    LPWSTR  InterfaceNameW,
    PUCHAR  NbName,
    PWCHAR  IfName
);

DWORD
CfgSetNbName (
    int     operation,
    LPWSTR  InterfaceNameW,
    PUCHAR  NbName,
    PWCHAR  IfName
);


DWORD
APIENTRY
HelpNbName (
    IN  int                     argc,
    IN  WCHAR                  *argv[]
) 
{
    DisplayMessage (g_hModule, HLP_IPX_NBNAME);
    return 0;
}


DWORD
APIENTRY
ShowNbName (
    IN  int                     argc,
    IN  WCHAR                  *argv[],
    IN  HANDLE                  hFile
) 
{
    WCHAR IfName[ MAX_INTERFACE_NAME_LEN + 1 ];
    DWORD rc, dwSize = sizeof(IfName);
    
    
    if (argc > 0) 
    {
        unsigned count;
        
#define InterfaceNameW argv[0]
        count = wcslen (InterfaceNameW);

        rc = IpmontrGetIfNameFromFriendlyName( 
                InterfaceNameW, IfName, &dwSize
                );
        
        if ( rc != NO_ERROR )
        {
            if ( !hFile ) { DisplayIPXMessage (g_hModule, MSG_INVALID_INTERFACE_NAME); }
            return ERROR_INVALID_PARAMETER;
        }
        
        if ((count > 0) && (count <= MAX_INTERFACE_NAME_LEN)) 
        {
            LPBYTE  pIfBlock;
            BOOLEAN fRouter = FALSE;

            if ( !hFile ) { DisplayIPXMessage (g_hModule, MSG_NBNAME_TABLE_HDR); }

            if (g_hMprAdmin) 
            {
                HANDLE  hIfAdm;
                
                rc = MprAdminInterfaceGetHandle (
                        g_hMprAdmin, IfName, &hIfAdm, FALSE
                        );
                        
                if (rc == NO_ERROR) 
                {
                    DWORD   sz;
                    
                    rc = MprAdminInterfaceTransportGetInfo (
                            g_hMprAdmin, hIfAdm, PID_IPX, &pIfBlock, &sz
                            );
                }
                
                if (rc == NO_ERROR)
                {
                    fRouter = TRUE;
                }
                else 
                {
                    if ( !hFile ) { DisplayError( g_hModule, rc); }
                    goto GetFromCfg;
                }
            }
            
            else 
            {
                
                HANDLE      hIfCfg;
GetFromCfg:
                rc = MprConfigInterfaceGetHandle (
                        g_hMprConfig, IfName, &hIfCfg
                        );
                        
                if (rc == NO_ERROR) 
                {
                    HANDLE  hIfTrCfg;
                    
                    rc = MprConfigInterfaceTransportGetHandle (
                            g_hMprConfig, hIfCfg, PID_IPX, &hIfTrCfg
                            );
                            
                    if (rc == NO_ERROR) 
                    {
                        DWORD   sz;
                        
                        rc = MprConfigInterfaceTransportGetInfo (
                                g_hMprConfig, hIfCfg, hIfTrCfg, &pIfBlock, &sz
                                );
                    }
                }
            }

            
            if (rc == NO_ERROR) 
            {
                PIPX_TOC_ENTRY pNnToc;

                pNnToc = GetIPXTocEntry (
                            (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                            IPX_STATIC_NETBIOS_NAME_INFO_TYPE
                            );
                            
                if (pNnToc != NULL) 
                {
                    PIPX_STATIC_NETBIOS_NAME_INFO   pNnInfo;
                    UINT                            i;

                    pNnInfo = (PIPX_STATIC_NETBIOS_NAME_INFO)
                                    (pIfBlock + pNnToc->Offset);
                                    
                    for (i = 0; i < pNnToc->Count; i++, pNnInfo++) 
                    {
                        if ( hFile )
                        {
                            UCHAR ucType = pNnInfo->Name[15];

                            pNnInfo->Name[15] = '\0';
                            
                            DisplayMessageT(
                                DMP_IPX_NB_ADD_NAME, InterfaceNameW,
                                pNnInfo->Name, pNnInfo->Name[15]
                                );
                        }

                        else
                        {
                            DisplayIPXMessage (g_hModule,
                                MSG_NBNAME_TABLE_FMT,
                                pNnInfo->Name, pNnInfo->Name[15]
                                );
                        }
                    }
                }
                else 
                {
                    rc = ERROR_FILE_NOT_FOUND;
                    if ( !hFile ) { DisplayError( g_hModule, rc); }
                }
                
                if (fRouter)
                {
                    MprAdminBufferFree (pIfBlock);
                }
                else
                {
                    MprConfigBufferFree (pIfBlock);
                }
            }
            
            else
            {
                if ( !hFile ) { DisplayError( g_hModule, rc); }
            }
        }
        
        else 
        {
            if ( !hFile ) { DisplayIPXMessage (g_hModule, MSG_INVALID_INTERFACE_NAME); }
            rc = ERROR_INVALID_PARAMETER;
        }
    }
    else 
    {
        if ( !hFile ) { DisplayMessage (g_hModule, HLP_IPX_NBNAME); }
        rc = ERROR_INVALID_PARAMETER;
    }
    
//Exit:
    return rc;
    
#undef InterfaceNameW
}



DWORD
APIENTRY
CreateNbName (
    IN  int                     argc,
    IN  WCHAR                  *argv[]
) 
{
    WCHAR IfName[ MAX_INTERFACE_NAME_LEN + 1 ];
    DWORD rc, dwSize = sizeof(IfName);
    
    
    if ((argc == 2) || (argc == 3)) 
    {
        unsigned    count;

#define InterfaceNameW argv[0]
        count = wcslen (InterfaceNameW);


        rc = IpmontrGetIfNameFromFriendlyName( 
                InterfaceNameW, IfName, &dwSize
                );
        
        if ( rc != NO_ERROR )
        {
            DisplayIPXMessage (g_hModule, MSG_INVALID_INTERFACE_NAME);
            return ERROR_INVALID_PARAMETER;
        }
        

        if ((count > 0) && (count <= MAX_INTERFACE_NAME_LEN)) 
        {
            UINT    val, n;
            UCHAR   NbName[16];

            memset (NbName, ' ', sizeof (NbName));
            
            if ( (swscanf (argv[1], L"%16hc%n", NbName, &n) == 1) && 
                 (n == wcslen (argv[1])) && 
                 ( (argc < 3) || 
                   ( (swscanf (argv[2], L"%2x%n", &val, &n) == 1) && 
                   ( n == wcslen (argv[2]) ) ) )
                ) 
            {

                if (argc < 3)
                {
                    val = NbName[15];
                }
                
                NbName[15] = 0;
                _strupr (NbName);
                NbName[15] = (UCHAR) val;

                if (g_hMprAdmin)
                {
                    rc = AdmSetNbName(
                            OPERATION_ADD_NBNAME, IfName, NbName,
                            InterfaceNameW
                            );
                }
                else
                {
                    rc = NO_ERROR;
                }
                
                if (rc == NO_ERROR)
                {
                    rc = CfgSetNbName (
                            OPERATION_ADD_NBNAME, IfName, NbName,
                            InterfaceNameW
                            );
                }
            }
            
            else 
            {
                rc = ERROR_INVALID_PARAMETER;
                DisplayMessage (g_hModule, HLP_IPX_NBNAME);
            }
        }
        else 
        {
            DisplayIPXMessage (g_hModule, MSG_INVALID_INTERFACE_NAME);
            rc = ERROR_INVALID_PARAMETER;
        }
    }
    else 
    {
        DisplayMessage (g_hModule, HLP_IPX_NBNAME);
        rc = ERROR_INVALID_PARAMETER;
    }
    
    return rc;
    
#undef InterfaceNameW
}


DWORD
APIENTRY
DeleteNbName(
    IN  int                  argc,
    IN  WCHAR               *argv[]
) 
{
    WCHAR IfName[ MAX_INTERFACE_NAME_LEN + 1 ];
    DWORD rc, dwSize = sizeof(IfName);
    
    if ((argc == 2) || (argc == 3)) 
    {
        unsigned    count;

#define InterfaceNameW argv[0]
        count = wcslen (InterfaceNameW);

        rc = IpmontrGetIfNameFromFriendlyName( 
                InterfaceNameW, IfName, &dwSize
                );
        
        if ( rc != NO_ERROR )
        {
            DisplayIPXMessage (g_hModule, MSG_INVALID_INTERFACE_NAME);
            return ERROR_INVALID_PARAMETER;
        }
        

        if ((count > 0) && (count <= MAX_INTERFACE_NAME_LEN)) 
        {
            UINT    val, n;
            UCHAR   NbName[16];

            memset (NbName, ' ', sizeof (NbName));
            
            if ( (swscanf (argv[1], L"%16hc%n", NbName, &n) == 1) && 
                 (n == wcslen (argv[1])) && 
                 ( (argc < 3) || 
                   ( (swscanf (argv[2], L"%2x%n", &val, &n) == 1) && 
                   ( n == wcslen (argv[2]))) ) )
            {

                if (argc < 3)
                {
                    val = NbName[15];
                }
                
                NbName[15] = 0;
                _strupr (NbName);
                NbName[15] = (UCHAR) val;

                if (g_hMprAdmin)
                {
                    rc = AdmSetNbName(
                            OPERATION_DEL_NBNAME, IfName, NbName,
                            InterfaceNameW
                            );
                }
                else
                {
                    rc = NO_ERROR;
                }
                
                if (rc == NO_ERROR)
                {
                    rc = CfgSetNbName(
                            OPERATION_DEL_NBNAME, IfName, NbName,
                            InterfaceNameW
                            );
                }
            }
            else 
            {
                rc = ERROR_INVALID_PARAMETER;
                DisplayMessage (g_hModule, HLP_IPX_NBNAME);
            }
        }
        else 
        {
            DisplayIPXMessage (g_hModule, MSG_INVALID_INTERFACE_NAME);
            rc = ERROR_INVALID_PARAMETER;
        }
    }
    else 
    {
        DisplayMessage (g_hModule, HLP_IPX_NBNAME);
        rc = ERROR_INVALID_PARAMETER;
    }

    return rc;
    
#undef InterfaceNameW
}


BOOL
NbNameEqual (
    PVOID   info1,
    PVOID   info2
) 
{
#define NbName1 ((PIPX_STATIC_NETBIOS_NAME_INFO)info1)
#define NbName2 ((PIPX_STATIC_NETBIOS_NAME_INFO)info2)

    return ( _strnicmp (NbName1->Name, NbName2->Name, 15) == 0) && 
             (NbName1->Name[15] == NbName2->Name[15] );
             
#undef NbName1
#undef NbName2
}


DWORD
AdmSetNbName (
    int     operation,
    LPWSTR  InterfaceNameW,
    PUCHAR  NbName,
    PWCHAR  IfName
) 
{
    DWORD       rc;
    HANDLE      hIfAdm;
    
    rc = MprAdminInterfaceGetHandle (
            g_hMprAdmin, InterfaceNameW, &hIfAdm, FALSE 
            );
            
    if (rc == NO_ERROR) 
    {
        LPBYTE  pIfBlock;
        DWORD   sz;
        
        rc = MprAdminInterfaceTransportGetInfo (
                g_hMprAdmin, hIfAdm, PID_IPX, &pIfBlock, &sz
                );
                
        if (rc == NO_ERROR) 
        {
            UINT                    msg;
            LPBYTE                  pNewBlock;

            switch (operation) 
            {
            case OPERATION_ADD_NBNAME:
            
                rc = AddIPXInfoEntry (
                        (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                        IPX_STATIC_NETBIOS_NAME_INFO_TYPE,
                        sizeof (IPX_STATIC_NETBIOS_NAME_INFO),
                        NbName, NbNameEqual,
                        (PIPX_INFO_BLOCK_HEADER * ) & pNewBlock
                        );
                        
                msg = MSG_NBNAME_CREATED_ADM;
                
                break;

            case OPERATION_DEL_NBNAME:
            
                rc = DeleteIPXInfoEntry (
                        (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                        IPX_STATIC_NETBIOS_NAME_INFO_TYPE,
                        sizeof (IPX_STATIC_NETBIOS_NAME_INFO),
                        NbName, NbNameEqual, 
                        (PIPX_INFO_BLOCK_HEADER * ) & pNewBlock
                        );
                        
                msg = MSG_NBNAME_DELETED_ADM;
                
                break;
            }

            if (rc == NO_ERROR) 
            {
                if (pIfBlock != pNewBlock) 
                {
                    MprAdminBufferFree (pIfBlock);
                    pIfBlock = pNewBlock;
                }

                rc = MprAdminInterfaceTransportSetInfo (
                        g_hMprAdmin, hIfAdm, PID_IPX, pIfBlock,
                        ((PIPX_INFO_BLOCK_HEADER)pIfBlock)->Size
                        );
                        
                if (rc == NO_ERROR)
                {
                    DisplayIPXMessage (g_hModule, msg, IfName);
                }
                else
                {
                    DisplayError( g_hModule, rc);
                }
            }
            else
            {
                DisplayError( g_hModule, rc);
            }

            MprAdminBufferFree (pIfBlock);
        }
    }
    else
    {
        DisplayError( g_hModule, rc);
    }

    return rc;
}


DWORD
CfgSetNbName (
    int     operation,
    LPWSTR  InterfaceNameW,
    PUCHAR  NbName,
    PWCHAR  IfName
) 
{
    DWORD       rc;
    HANDLE      hIfCfg;

    rc = MprConfigInterfaceGetHandle (
            g_hMprConfig, InterfaceNameW, &hIfCfg
            );
            
    if (rc == NO_ERROR) 
    {
        HANDLE  hIfTrCfg;
        
        rc = MprConfigInterfaceTransportGetHandle (
                g_hMprConfig, hIfCfg, PID_IPX, &hIfTrCfg
                );
                
        if (rc == NO_ERROR) 
        {
            LPBYTE  pIfBlock;
            DWORD   sz;
            
            rc = MprConfigInterfaceTransportGetInfo (
                    g_hMprConfig, hIfCfg, hIfTrCfg, &pIfBlock, &sz
                    );
                    
            if (rc == NO_ERROR) 
            {
                UINT                    msg;
                LPBYTE                  pNewBlock;

                switch (operation) 
                {
                case OPERATION_ADD_NBNAME:

                    rc = AddIPXInfoEntry (
                            (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                            IPX_STATIC_NETBIOS_NAME_INFO_TYPE,
                            sizeof (IPX_STATIC_NETBIOS_NAME_INFO),
                            NbName, NbNameEqual,
                            (PIPX_INFO_BLOCK_HEADER * ) & pNewBlock
                            );
                            
                    msg = MSG_NBNAME_CREATED_CFG;
                    break;
                    
                case OPERATION_DEL_NBNAME:

                    rc = DeleteIPXInfoEntry (
                            (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                            IPX_STATIC_NETBIOS_NAME_INFO_TYPE,
                            sizeof (IPX_STATIC_NETBIOS_NAME_INFO),
                            NbName, NbNameEqual,
                            (PIPX_INFO_BLOCK_HEADER * ) & pNewBlock
                            );
                            
                    msg = MSG_NBNAME_DELETED_CFG;
                    break;
                }

                if (rc == NO_ERROR) 
                {
                    rc = MprConfigInterfaceTransportSetInfo (
                            g_hMprConfig, hIfCfg, hIfTrCfg, pNewBlock,
                            ((PIPX_INFO_BLOCK_HEADER)pNewBlock)->Size
                            );
                            
                    if (pNewBlock != pIfBlock)
                    {
                        GlobalFree (pNewBlock);
                    }
                    
                    if (rc == NO_ERROR)
                    {
                        DisplayIPXMessage (g_hModule, msg, IfName );
                    }
                    else
                    {
                        DisplayError( g_hModule, rc);
                    }
                }
                
                else
                {
                    DisplayError( g_hModule, rc);
                }

                MprConfigBufferFree (pIfBlock);
            }
            
            else
            {
                DisplayError( g_hModule, rc);
            }
        }
        
        else
        {
            DisplayError( g_hModule, rc);
        }
    }

    else
    {
        DisplayError( g_hModule, rc);
    }

    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ipx\protocols\precomp.h ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    precomp.h

Abstract:
    Precompiled header that includes all the necessary header files.

--*/

#define MAX_DLL_NAME 48

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntddser.h>

#include <windows.h>

#include <stdio.h>
#include <stdlib.h>
#include <memory.h>
#include <malloc.h>
#include <tchar.h>

#include <mprerror.h>
#include <mprapi.h>
#include <dim.h>
#include <routprot.h>
#include <rtinfo.h>
#include <ipxrtdef.h>

#include <netsh.h>
#include <netshp.h>
#include <macros.h>
#include <ipmontr.h>
#include <ipxmontr.h>

#include "ipxstrng.h"
#include "utils.h"
#include "common.h"
#include "ipxmsgs.h"
#include "ipxstrs.h"
#include "ripgl.h"
#include "ripifs.h"
#include "ripflts.h"
#include "sapgl.h"
#include "sapifs.h"
#include "sapflts.h"
#include "nbnames.h"
#include "nbifs.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ipx\protocols\ripgl.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    ripgl.h

Abstract:

    IPX Router Console Monitoring and Configuration tool.
    RIP Global configuration.

Author:

    Vadim Eydelman  06/07/1996


--*/
#ifndef _IPXMON_RIPGL_
#define _IPXMON_RIPGL_

DWORD
APIENTRY 
HelpRipGl (
    IN    int                   argc,
    IN    WCHAR                *argv[]
    );

DWORD
APIENTRY 
ShowRipGl (
    IN    int                   argc,
    IN    WCHAR                *argv[],
    IN    HANDLE                hFile
    );

DWORD
APIENTRY 
SetRipGl (
    IN    int                   argc,
    IN    WCHAR                *argv[]
    );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ipx\protocols\ripflts.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    ripflts.c

Abstract:

    IPX Router Console Monitoring and Configuration tool.
    RIP Filters configuration and monitoring.

Author:

    Vadim Eydelman  06/07/1996


--*/
#include "precomp.h"
#pragma hdrstop

#define OPERATION_DEL_RIPFILTER    (-1)
#define OPERATION_SET_RIPFILTER    0
#define OPERATION_ADD_RIPFILTER    1


DWORD
AdmSetRipFlt (
    int                     operation,
    LPWSTR                  InterfaceNameW,
    ULONG                   Action,
    ULONG                   Mode,
    PRIP_ROUTE_FILTER_INFO  RipFilter
    );

DWORD
CfgSetRipFlt (
    int                     operation,
    LPWSTR                  InterfaceNameW,
    ULONG                   Action,
    ULONG                   Mode,
    PRIP_ROUTE_FILTER_INFO  RipFilter
    );

DWORD
SetRipFltAction (
    LPBYTE                  pIfBlock,
    BOOLEAN                 Output,
    ULONG                   Action
    );

DWORD
APIENTRY 
HelpRipFlt (
    IN      int                   argc,
    IN      WCHAR                *argv[]
) 
{
    DisplayMessage (g_hModule, HLP_IPX_RIPFILTER );
    return 0;
}


DWORD
APIENTRY 
ShowRipFlt (
    IN      int                   argc,
    IN      WCHAR                *argv[],
    IN      HANDLE                hFile
) 
{
    DWORD        rc;

    if (argc > 0) 
    {
        PWCHAR      buffer[2];
        LPBYTE      pIfBlock;
        BOOLEAN     fRouter = FALSE, fClient;
        ULONG       mode = 0;
        unsigned    count;
        WCHAR       IfName[ MAX_INTERFACE_NAME_LEN + 1 ];
        DWORD       dwSize = sizeof(IfName);
        
#define InterfaceNameW argv[0]
        count = wcslen (InterfaceNameW);


        if ( !_wcsicmp( argv[0], VAL_DIALINCLIENT ) )
        {
            fClient = TRUE;
        }
        
        else if ((count > 0) && (count <= MAX_INTERFACE_NAME_LEN)) 
        {
            fClient = FALSE;
        }
        
        else 
        {
            if ( !hFile ) { DisplayIPXMessage (g_hModule, MSG_INVALID_INTERFACE_NAME); }
            rc = ERROR_INVALID_PARAMETER;
            goto Exit;
        }
        

        if (argc > 1) 
        {
            UINT        n;

            if ( (argc == 2) && 
                 !MatchEnumTag(
                    g_hModule, argv[1], NUM_TOKENS_IN_TABLE( FilterModes ), 
                    FilterModes, &mode
                    ) ) 
            {
                NOTHING;
            }
            else 
            {
                if ( !hFile ) { DisplayMessage (g_hModule, HLP_IPX_RIPFILTER); }
                rc = ERROR_INVALID_PARAMETER;
                goto Exit;
            }
        }

        if (g_hMprAdmin) 
        {
            if (fClient) 
            {
                DWORD   sz;
                
                rc = MprAdminTransportGetInfo(
                        g_hMprAdmin, PID_IPX, NULL, NULL, &pIfBlock, &sz
                        );
                        
                if (rc == NO_ERROR) 
                {
                    fRouter = TRUE;
                }
                else 
                {
                    if ( !hFile ) { DisplayError( g_hModule, rc); }
                    goto GetFromCfg;
                }
            }
            
            else 
            {
                HANDLE        hIfAdm;

                //======================================
                // Translate the Interface Name
                //======================================

                rc = IpmontrGetIfNameFromFriendlyName(
                        InterfaceNameW, IfName, &dwSize
                        );

                if ( rc == NO_ERROR )
                {
                    rc = MprAdminInterfaceGetHandle(
                            g_hMprAdmin, IfName, &hIfAdm, FALSE
                            );
                            
                    if (rc == NO_ERROR) 
                    {
                        DWORD   sz;
                        
                        rc = MprAdminInterfaceTransportGetInfo(
                                g_hMprAdmin, hIfAdm, PID_IPX, &pIfBlock, &sz
                                );
                    }
                    
                    if (rc == NO_ERROR)
                    {
                        fRouter = TRUE;
                    }
                    else 
                    {
                        if ( !hFile ) { DisplayError( g_hModule, rc ); }
                        goto GetFromCfg;
                    }
                }
            }
        }
        
        else 
        {
GetFromCfg:

            if (fClient) 
            {
                HANDLE        hTrCfg;
                
                rc = MprConfigTransportGetHandle (
                        g_hMprConfig, PID_IPX, &hTrCfg
                        );
                        
                if (rc == NO_ERROR) 
                {
                    DWORD   sz;
                    
                    rc = MprConfigTransportGetInfo (
                            g_hMprConfig, hTrCfg, NULL, NULL, &pIfBlock, &sz, 
                            NULL
                            );
                }
            }

            else 
            {
                HANDLE  hIfCfg;

                //======================================
                // Translate the Interface Name
                //======================================

                rc = IpmontrGetIfNameFromFriendlyName(
                        InterfaceNameW, IfName, &dwSize
                        );

                if ( rc == NO_ERROR )
                {
                    rc = MprConfigInterfaceGetHandle(
                            g_hMprConfig, IfName, &hIfCfg
                            );
                            
                    if (rc == NO_ERROR) 
                    {
                        HANDLE hIfTrCfg;
                        
                        rc = MprConfigInterfaceTransportGetHandle(
                               g_hMprConfig, hIfCfg, PID_IPX, &hIfTrCfg
                               );
                               
                        if (rc == NO_ERROR) 
                        {
                            DWORD sz;
                            
                            rc = MprConfigInterfaceTransportGetInfo(
                                    g_hMprConfig, hIfCfg, hIfTrCfg, &pIfBlock, &sz
                                    );
                        }
                    }
                }
            }
        }

        
        if (rc == NO_ERROR) 
        {
            PIPX_TOC_ENTRY pRipToc;

            pRipToc = GetIPXTocEntry(
                        (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                        IPX_PROTOCOL_RIP
                        );
                        
            if (pRipToc != NULL) 
            {
                PRIP_IF_CONFIG    pRipCfg;
                UINT            i;

                pRipCfg = (PRIP_IF_CONFIG)
                            (pIfBlock + pRipToc->Offset);
                            
                if ( (mode == 0) || (mode == OUTPUT_FILTER) ) 
                {
                    if (pRipCfg->RipIfFilters.SupplyFilterCount > 0) 
                    {
                        PRIP_ROUTE_FILTER_INFO pRipFilter =
                                &pRipCfg->RipIfFilters.RouteFilter[0];

                        buffer[ 0 ] = VAL_OUTPUT;

                        buffer[ 1 ] = GetEnumString( 
                                        g_hModule, 
                                        pRipCfg->RipIfFilters.SupplyFilterAction,
                                        NUM_TOKENS_IN_TABLE( RipFilterActions ),
                                        RipFilterActions
                                        );

                        if ( buffer[ 0 ] && buffer[ 1 ] )
                        {
                            if ( hFile )
                            {
                                DisplayMessageT(
                                    DMP_IPX_RIP_SET_FILTER, InterfaceNameW,
                                    buffer[ 0 ], buffer[ 1 ]
                                    );
                            }

                            else
                            {
                                DisplayIPXMessage(
                                    g_hModule, MSG_RIPFILTER_TABLE_HDR,
                                    buffer[ 0 ], buffer[1]
                                    );
                            }
                            

                            for ( i = 0; 
                                  i < pRipCfg->RipIfFilters.SupplyFilterCount; 
                                  i++, pRipFilter++ ) 
                            {
                                if ( hFile )
                                {
                                    DisplayMessageT(
                                        DMP_IPX_RIP_ADD_FILTER, InterfaceNameW,
                                        buffer[0], 
                                        pRipFilter->Network[0], pRipFilter->Network[1],
                                        pRipFilter->Network[2], pRipFilter->Network[3],
                                        pRipFilter->Mask[0], pRipFilter->Mask[1],
                                        pRipFilter->Mask[2], pRipFilter->Mask[3]
                                        );
                                }

                                else
                                {
                                    DisplayIPXMessage (g_hModule,
                                        MSG_RIPFILTER_TABLE_FMT,
                                        pRipFilter->Network[0], pRipFilter->Network[1],
                                        pRipFilter->Network[2], pRipFilter->Network[3],
                                        pRipFilter->Mask[0], pRipFilter->Mask[1],
                                        pRipFilter->Mask[2], pRipFilter->Mask[3]
                                        );
                                }
                            }
                        }

                        else
                        {
                            rc = ERROR_NOT_ENOUGH_MEMORY;
                            if ( !hFile ) { DisplayMessage (g_hModule, rc ); }
                        }
                    }

                    else 
                    {
                        if ( hFile )
                        {
                            DisplayMessageT(
                                DMP_IPX_RIP_SET_FILTER, InterfaceNameW, VAL_OUTPUT,
                                VAL_DENY
                                );
                        }

                        else
                        {
                            DisplayIPXMessage(
                                g_hModule, MSG_RIPFILTER_TABLE_HDR,
                                VAL_OUTPUT, VAL_DENY
                                );
                        }
                    }
                }


                if ((mode == 0) || (mode == INPUT_FILTER)) 
                {
                    if (pRipCfg->RipIfFilters.ListenFilterCount > 0) 
                    {
                        PRIP_ROUTE_FILTER_INFO pRipFilter
                            = &pRipCfg->RipIfFilters.RouteFilter[
                                            pRipCfg->RipIfFilters.SupplyFilterCount
                                            ];

                        buffer[ 0 ] = VAL_INPUT;

                        buffer[ 1 ] = GetEnumString( 
                                        g_hModule, 
                                        pRipCfg->RipIfFilters.ListenFilterAction,
                                        NUM_TOKENS_IN_TABLE( RipFilterActions ),
                                        RipFilterActions
                                        );

                        if ( buffer[ 0 ] && buffer[ 1 ] )
                        {
                            
                            if ( hFile )
                            {
                                DisplayMessageT(
                                    DMP_IPX_RIP_SET_FILTER, InterfaceNameW,
                                    buffer[ 0 ], buffer[ 1 ]
                                    );
                            }

                            else
                            {
                                DisplayIPXMessage(
                                    g_hModule, MSG_RIPFILTER_TABLE_HDR,
                                    buffer[ 0 ], buffer[1]
                                    );
                            }
                            
                            for ( i = 0; 
                                  i < pRipCfg->RipIfFilters.ListenFilterCount; 
                                  i++, pRipFilter++ ) 
                            {
                                if ( hFile )
                                {
                                    DisplayMessageT(
                                        DMP_IPX_RIP_ADD_FILTER, InterfaceNameW,
                                        buffer[0], 
                                        pRipFilter->Network[0], pRipFilter->Network[1],
                                        pRipFilter->Network[2], pRipFilter->Network[3],
                                        pRipFilter->Mask[0], pRipFilter->Mask[1],
                                        pRipFilter->Mask[2], pRipFilter->Mask[3]
                                        );
                                }

                                else
                                {
                                    DisplayIPXMessage (g_hModule,
                                        MSG_RIPFILTER_TABLE_FMT,
                                        pRipFilter->Network[0], pRipFilter->Network[1],
                                        pRipFilter->Network[2], pRipFilter->Network[3],
                                        pRipFilter->Mask[0], pRipFilter->Mask[1],
                                        pRipFilter->Mask[2], pRipFilter->Mask[3]
                                        );
                                }
                            }
                        }
                        else
                        {
                            rc = ERROR_NOT_ENOUGH_MEMORY;
                            if ( !hFile ) { DisplayMessage (g_hModule, rc ); }
                        }
                    }

                    else 
                    {
                        if ( hFile )
                        {
                            DisplayMessageT(
                                DMP_IPX_RIP_SET_FILTER, InterfaceNameW, VAL_INPUT,
                                VAL_DENY
                                );
                        }

                        else
                        {
                            DisplayIPXMessage(
                                g_hModule, MSG_RIPFILTER_TABLE_HDR,
                                VAL_INPUT, VAL_DENY
                                );
                        }
                    }
                }
            }
            else 
            {
                rc = ERROR_FILE_NOT_FOUND;
                if ( !hFile ) { DisplayError( g_hModule, rc); }
            }
            
            if (fRouter)
            {
                MprAdminBufferFree (pIfBlock);
            }
            else
            {
                MprConfigBufferFree (pIfBlock);
            }
        }
        
        else
        {
            if ( !hFile ) { DisplayError( g_hModule, rc); }
        }
    }
    else 
    {
        if ( !hFile ) { DisplayMessage (g_hModule, HLP_IPX_RIPFILTER); }
        rc = ERROR_INVALID_PARAMETER;
    }
    
Exit:
    return rc;
    
#undef InterfaceNameW
}



DWORD
APIENTRY 
SetRipFlt(
    IN    int                   argc,
    IN    WCHAR                *argv[]
) 
{
    DWORD rc;
    
    if (argc == 3) 
    {

        PWCHAR                  buffer;
        ULONG                   mode, action;
        UINT                    n;
        RIP_ROUTE_FILTER_INFO   RipFilter;
        BOOLEAN                 fClient;
        unsigned                count;

        
#define InterfaceNameW argv[0]
        count = wcslen (InterfaceNameW);


        if ( !_wcsicmp( argv[0], VAL_DIALINCLIENT ) ) 
        {
            fClient = TRUE;
        }
        else if ((count > 0) && (count <= MAX_INTERFACE_NAME_LEN)) 
        {
            fClient = FALSE;
        }
        else 
        {
            DisplayIPXMessage (g_hModule, MSG_INVALID_INTERFACE_NAME );
            rc = ERROR_INVALID_PARAMETER;
            goto Exit;
        }

        
        if ( !MatchEnumTag( 
                g_hModule, argv[1], NUM_TOKENS_IN_TABLE( FilterModes ),
                FilterModes, &mode 
                ) &&
             !MatchEnumTag(
                g_hModule, argv[2], NUM_TOKENS_IN_TABLE( RipFilterActions ),
                RipFilterActions, &action
                ) ) 
        {

            if (g_hMprAdmin)
            {
                rc = AdmSetRipFlt(
                        OPERATION_SET_RIPFILTER,
                        fClient ? NULL : InterfaceNameW,
                        action,
                        mode, NULL
                        );
            }
            else
            {
                rc = NO_ERROR;
            }
            
            if (rc == NO_ERROR)
            {
                rc = CfgSetRipFlt(
                        OPERATION_SET_RIPFILTER,
                        fClient ? NULL : InterfaceNameW,
                        action, mode, NULL
                        );
            }
        }
        else 
        {
            rc = ERROR_INVALID_PARAMETER;
            DisplayMessage (g_hModule, HLP_IPX_RIPFILTER);
        }
    }
    else 
    {
        DisplayMessage (g_hModule, HLP_IPX_RIPFILTER);
        rc = ERROR_INVALID_PARAMETER;
    }
    
Exit:
    return rc;
    
#undef InterfaceNameW
}


DWORD
APIENTRY 
CreateRipFlt(
    IN      int                   argc,
    IN      WCHAR                *argv[]
) 
{
    DWORD        rc;

    if (argc == 4) 
    {
        PWCHAR                  buffer = NULL;
        ULONG                   mode;
        UINT                    n;
        ULONG                   val41, val42;
        RIP_ROUTE_FILTER_INFO   RipFilter;
        BOOLEAN                 fClient;
        unsigned                count;

        
#define InterfaceNameW argv[0]
        count = wcslen (InterfaceNameW);

        if ( !_wcsicmp( argv[0], VAL_DIALINCLIENT ) ) 
        {
            fClient = TRUE;
        }
        else if ((count > 0) && (count <= MAX_INTERFACE_NAME_LEN)) 
        {
            fClient = FALSE;
        }
        else 
        {
            DisplayIPXMessage (g_hModule, MSG_INVALID_INTERFACE_NAME);
            rc = ERROR_INVALID_PARAMETER;
            goto Exit;
        }

        
        if ( !MatchEnumTag(
                g_hModule, argv[1], NUM_TOKENS_IN_TABLE( FilterModes ),
                FilterModes, &mode
                )
             && (swscanf (argv[2], L"%8lx%n", &val41, &n) == 1)
             && (n == wcslen (argv[2]))
             && (swscanf (argv[3], L"%8lx%n", &val42, &n) == 1)
             && (n == wcslen (argv[3]))
             && ((val41 & val42) == val41)) 
        {

            RipFilter.Network[0] = (BYTE)(val41 >> 24);
            RipFilter.Network[1] = (BYTE)(val41 >> 16);
            RipFilter.Network[2] = (BYTE)(val41 >> 8);
            RipFilter.Network[3] = (BYTE)val41;

            RipFilter.Mask[0] = (BYTE)(val42 >> 24);
            RipFilter.Mask[1] = (BYTE)(val42 >> 16);
            RipFilter.Mask[2] = (BYTE)(val42 >> 8);
            RipFilter.Mask[3] = (BYTE)val42;
            
            if (g_hMprAdmin)
            {
                rc = AdmSetRipFlt(
                        OPERATION_ADD_RIPFILTER,
                        fClient ? NULL : InterfaceNameW,
                        IPX_ROUTE_FILTER_PERMIT,
                        mode, &RipFilter
                        );
            }
            else
            {
                rc = NO_ERROR;
            }
            
            if (rc == NO_ERROR)
            {
                rc = CfgSetRipFlt(
                        OPERATION_ADD_RIPFILTER,
                        fClient ? NULL : InterfaceNameW,
                        IPX_ROUTE_FILTER_PERMIT,
                        mode, &RipFilter
                        );
            }
        }
        else 
        {
            rc = ERROR_INVALID_PARAMETER;
            DisplayIPXMessage (g_hModule, HLP_IPX_RIPFILTER);
        }

    }
    else 
    {
        DisplayMessage (g_hModule, HLP_IPX_RIPFILTER);
        rc = ERROR_INVALID_PARAMETER;
    }

Exit:
    return rc;
    
#undef InterfaceNameW
}


DWORD
APIENTRY 
DeleteRipFlt (
    IN    int                   argc,
    IN    WCHAR                *argv[]
) 
{
    DWORD rc;
    
    if (argc == 4) 
    {
        PWCHAR                  buffer = NULL;
        ULONG                   mode;
        UINT                    n;
        ULONG                   val41, val42;
        RIP_ROUTE_FILTER_INFO   RipFilter;
        BOOLEAN                 fClient;
        unsigned                count;
        
#define InterfaceNameW argv[0]
        count = wcslen (InterfaceNameW);

        if ( !_wcsicmp( argv[0], VAL_DIALINCLIENT ) ) 
        {
            fClient = TRUE;
        }
        else if ((count > 0) && (count <= MAX_INTERFACE_NAME_LEN)) 
        {
            fClient = FALSE;
        }
        else 
        {
            DisplayIPXMessage (g_hModule, MSG_INVALID_INTERFACE_NAME);
            rc = ERROR_INVALID_PARAMETER;
            goto Exit;
        }

        
        if ( !MatchEnumTag(
                g_hModule, argv[1], NUM_TOKENS_IN_TABLE( FilterModes ),
                FilterModes, &mode
                )
             && (swscanf (argv[2], L"%8lx%n", &val41, &n) == 1)
             && (n == wcslen (argv[2]))
             && (swscanf (argv[3], L"%8lx%n", &val42, &n) == 1)
             && (n == wcslen (argv[3]))
             && ((val41 & val42) == val41)) 
        {
            RipFilter.Network[0] = (BYTE)(val41 >> 24);
            RipFilter.Network[1] = (BYTE)(val41 >> 16);
            RipFilter.Network[2] = (BYTE)(val41 >> 8);
            RipFilter.Network[3] = (BYTE)val41;

            RipFilter.Mask[0] = (BYTE)(val42 >> 24);
            RipFilter.Mask[1] = (BYTE)(val42 >> 16);
            RipFilter.Mask[2] = (BYTE)(val42 >> 8);
            RipFilter.Mask[3] = (BYTE)val42;
            
            if (g_hMprAdmin)
            {
                rc = AdmSetRipFlt(
                        OPERATION_DEL_RIPFILTER,
                        fClient ? NULL : InterfaceNameW,
                        IPX_ROUTE_FILTER_PERMIT,
                        mode, &RipFilter
                        );
            }
            
            else
            {
                rc = NO_ERROR;
            }

            
            if (rc == NO_ERROR)
            {
                rc = CfgSetRipFlt(
                        OPERATION_DEL_RIPFILTER,
                        fClient ? NULL : InterfaceNameW,
                        IPX_ROUTE_FILTER_PERMIT,
                        mode, &RipFilter
                        );
            }
        }
        else 
        {
            rc = ERROR_INVALID_PARAMETER;
            DisplayMessage (g_hModule, HLP_IPX_RIPFILTER);
        }
    }
    else 
    {
        DisplayMessage (g_hModule, HLP_IPX_RIPFILTER);
        rc = ERROR_INVALID_PARAMETER;
    }
Exit:
    return rc;
    
#undef InterfaceNameW
}


DWORD
AdmSetRipFlt(
    int                     operation,
    LPWSTR                  InterfaceNameW,
    ULONG                   Action,
    ULONG                   Mode,
    PRIP_ROUTE_FILTER_INFO  RipFilter
    ) 
{
    DWORD       rc;
    HANDLE      hIfAdm;
    LPBYTE      pIfBlock;
    DWORD       sz;
    WCHAR       IfName[ MAX_INTERFACE_NAME_LEN + 1 ];
    DWORD       dwSize = sizeof(IfName);

    if (InterfaceNameW != NULL) 
    {

        //======================================
        // Translate the Interface Name
        //======================================
        
        rc = IpmontrGetIfNameFromFriendlyName(
                InterfaceNameW, IfName, &dwSize
                );

        if ( rc == NO_ERROR )
        {
            rc = MprAdminInterfaceGetHandle(
                    g_hMprAdmin, IfName, &hIfAdm,FALSE
                    );
                    
            if (rc == NO_ERROR)
            {
                rc = MprAdminInterfaceTransportGetInfo(
                        g_hMprAdmin, hIfAdm, PID_IPX, &pIfBlock, &sz
                        );
            }
        }
    }
    
    else 
    {
        rc = MprAdminTransportGetInfo (
                g_hMprAdmin, PID_IPX, NULL, NULL, &pIfBlock, &sz
                );
    }

    
    if (rc == NO_ERROR) 
    {
        UINT                msg;
        LPBYTE              pNewBlock;

        switch (operation) 
        {
        case OPERATION_ADD_RIPFILTER:
        
            rc = UpdateRipFilter (
                    (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                    (BOOLEAN)(Mode == OUTPUT_FILTER),
                    NULL, RipFilter,
                    (PIPX_INFO_BLOCK_HEADER * ) & pNewBlock
                    );
                    
            if (InterfaceNameW != NULL)
            {
                msg = MSG_RIPFILTER_CREATED_ADM;
            }
            else
            {
                msg = MSG_CLIENT_RIPFILTER_CREATED_ADM;
            }
            
            break;

            
        case OPERATION_SET_RIPFILTER:
        
            rc = SetRipFltAction(
                    pIfBlock, (BOOLEAN)(Mode == OUTPUT_FILTER), Action
                    );
                    
            if (InterfaceNameW != NULL)
            {
                msg = MSG_RIPFILTER_SET_ADM;
            }
            else
            {
                msg = MSG_CLIENT_RIPFILTER_SET_ADM;
            }
            
            pNewBlock = pIfBlock;
            
            break;
            
        case OPERATION_DEL_RIPFILTER:
        
            rc = UpdateRipFilter (
                    (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                    (BOOLEAN)(Mode == OUTPUT_FILTER),
                    RipFilter, NULL, (PIPX_INFO_BLOCK_HEADER * ) & pNewBlock
                    );
                    
            if (InterfaceNameW != NULL)
            {
                msg = MSG_RIPFILTER_SET_ADM;
            }
            else
            {
                msg = MSG_CLIENT_RIPFILTER_SET_ADM;
            }
            
            break;
        }

        if (rc == NO_ERROR) 
        {
            if (InterfaceNameW != NULL)
            {
                rc = MprAdminInterfaceTransportSetInfo (
                        g_hMprAdmin, hIfAdm, PID_IPX, pNewBlock,
                        ((PIPX_INFO_BLOCK_HEADER)pNewBlock)->Size
                        );
            }
            else
            {
                rc = MprAdminTransportSetInfo (
                        g_hMprAdmin, PID_IPX, NULL, 0, pNewBlock,
                        ((PIPX_INFO_BLOCK_HEADER)pNewBlock)->Size
                        );
            }
            
            if (pNewBlock != pIfBlock)
            {
                GlobalFree (pNewBlock);
            }
            
            if (rc == NO_ERROR)
            {
                DisplayIPXMessage (g_hModule, msg, InterfaceNameW);
            }
            else
            {
                DisplayError( g_hModule, rc);
            }
        }
        else
        {
            DisplayError( g_hModule, rc);
        }

        MprAdminBufferFree (pIfBlock);
    }
    else
    {
        DisplayError( g_hModule, rc);
    }

    return rc;
}


DWORD
CfgSetRipFlt(
    int                     operation,
    LPWSTR                  InterfaceNameW,
    ULONG                   Action,
    ULONG                   Mode,
    PRIP_ROUTE_FILTER_INFO  RipFilter
    ) 
{
    DWORD           rc;
    HANDLE          hIfCfg;
    HANDLE          hIfTrCfg;
    HANDLE          hTrCfg;
    LPBYTE          pIfBlock;
    DWORD           sz;
    WCHAR           IfName[ MAX_INTERFACE_NAME_LEN + 1 ];
    DWORD           dwSize = sizeof(IfName);
    
    if (InterfaceNameW != NULL) 
    {
        //======================================
        // Translate the Interface Name
        //======================================
        
        rc = IpmontrGetIfNameFromFriendlyName(
                InterfaceNameW, IfName, &dwSize
                );

        if ( rc == NO_ERROR )
        {
            rc = MprConfigInterfaceGetHandle(
                    g_hMprConfig, IfName, &hIfCfg
                    );
            if ( rc == NO_ERROR ) 
            {
                rc = MprConfigInterfaceTransportGetHandle(
                        g_hMprConfig, hIfCfg, PID_IPX, &hIfTrCfg
                        );
                        
                if (rc == NO_ERROR)
                {
                    rc = MprConfigInterfaceTransportGetInfo(
                            g_hMprConfig, hIfCfg, hIfTrCfg, &pIfBlock, &sz
                            );
                }
            }

        }
    }
    
    else 
    {
        rc = MprConfigTransportGetHandle(
                g_hMprConfig, PID_IPX, &hTrCfg
                );
                
        if (rc == NO_ERROR) 
        {
            rc = MprConfigTransportGetInfo (
                    g_hMprConfig, hTrCfg, NULL, NULL, &pIfBlock, &sz, NULL
                    );
        }
    }

    
    if (rc == NO_ERROR) 
    {
        UINT    msg;
        LPBYTE  pNewBlock;

        switch (operation) 
        {
        case OPERATION_ADD_RIPFILTER:

            rc = UpdateRipFilter(
                    (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                    (BOOLEAN)(Mode == OUTPUT_FILTER),
                    NULL,
                    RipFilter,
                    (PIPX_INFO_BLOCK_HEADER * ) & pNewBlock
                    );
                    
            if (InterfaceNameW != NULL)
            {
                msg = MSG_RIPFILTER_CREATED_ADM;
            }
            else
            {
                msg = MSG_CLIENT_RIPFILTER_CREATED_ADM;
            }
            
            break;
            
        case OPERATION_SET_RIPFILTER:

            rc = SetRipFltAction(
                    pIfBlock,
                    (BOOLEAN)(Mode == OUTPUT_FILTER),
                    Action
                    );
                    
            if (InterfaceNameW != NULL)
            {
                msg = MSG_RIPFILTER_SET_ADM;
            }
            else
            {
                msg = MSG_CLIENT_RIPFILTER_SET_ADM;
            }
            
            pNewBlock = pIfBlock;
            break;
            

        case OPERATION_DEL_RIPFILTER:
        
            rc = UpdateRipFilter(
                    (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                    (BOOLEAN)(Mode == OUTPUT_FILTER),
                    RipFilter, NULL,
                    (PIPX_INFO_BLOCK_HEADER * ) & pNewBlock
                    );
                    
            if (InterfaceNameW != NULL)
            {
                msg = MSG_RIPFILTER_DELETED_ADM;
            }
            else
            {
                msg = MSG_CLIENT_RIPFILTER_DELETED_ADM;
            }
            
            break;
        }

        if (rc == NO_ERROR) 
        {
            if (InterfaceNameW != NULL)
            {
                rc = MprConfigInterfaceTransportSetInfo (
                        g_hMprConfig, hIfCfg, hIfTrCfg, pNewBlock,
                        ((PIPX_INFO_BLOCK_HEADER)pNewBlock)->Size
                        );
            }
            else
            {
                rc = MprConfigTransportSetInfo (
                        g_hMprConfig, hTrCfg, NULL, 0, pNewBlock,
                        ((PIPX_INFO_BLOCK_HEADER)pNewBlock)->Size,
                        NULL
                        );
            }
            
            if (pNewBlock != pIfBlock)
            {
                GlobalFree (pNewBlock);
            }
            
            if (rc == NO_ERROR)
            {
                DisplayIPXMessage (g_hModule, msg, InterfaceNameW);
            }
            else
            {
                DisplayError( g_hModule, rc);
            }
        }
        
        else
        {
            DisplayError( g_hModule, rc);
        }

        MprConfigBufferFree (pIfBlock);
    }

    else
    {
        DisplayError( g_hModule, rc);
    }

    return rc;
}


DWORD
SetRipFltAction(
    LPBYTE      pIfBlock,
    BOOLEAN     Output,
    ULONG       Action
    ) 
{
    DWORD            rc;
    PIPX_TOC_ENTRY    pRipToc;

    pRipToc = GetIPXTocEntry (
                (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                IPX_PROTOCOL_RIP
                );
    if (pRipToc != NULL) 
    {
        PRIP_IF_CONFIG    pRipCfg;

        pRipCfg = (PRIP_IF_CONFIG)
                    (pIfBlock + pRipToc->Offset);
                    
        if (Output)
        {
            pRipCfg->RipIfFilters.SupplyFilterAction = Action;
        }
        else
        {
            pRipCfg->RipIfFilters.ListenFilterAction = Action;
        }
        
        rc = NO_ERROR;
    }
    
    else
    {
        rc = ERROR_INVALID_DATA;
    }

    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ipx\protocols\ripflts.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    ripflts.h

Abstract:

    IPX Router Console Monitoring and Configuration tool.
    RIP filter configuration and monitoring. Header File

Author:

    Vadim Eydelman  06/07/1996


--*/
#ifndef _IPXMON_RIPFLTS_
#define _IPXMON_RIPFLTS_

DWORD
APIENTRY 
HelpRipFlt (
    IN    int                    argc,
    IN    WCHAR                *argv[]
    );

DWORD
APIENTRY 
ShowRipFlt (
    IN    int                    argc,
    IN    WCHAR                *argv[],
    IN      HANDLE                hFile
    );

DWORD
APIENTRY 
SetRipFlt (
    IN    int                    argc,
    IN    WCHAR                *argv[]
    );

DWORD
APIENTRY 
CreateRipFlt (
    IN    int                    argc,
    IN    WCHAR                *argv[]
    );

DWORD
APIENTRY 
DeleteRipFlt (
    IN    int                    argc,
    IN    WCHAR                *argv[]
    );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ipx\protocols\rip.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    rip.c

Abstract:

    IPX Router Console Monitoring and Configuration tool.
    RIP Command dispatcher.

Author:

    V Raman     1/5/1998

--*/

#include "precomp.h"
#pragma hdrstop


FN_HANDLE_CMD HandleIpxRipAddFilter;
FN_HANDLE_CMD HandleIpxRipDelFilter;
FN_HANDLE_CMD HandleIpxRipSetFilter;
FN_HANDLE_CMD HandleIpxRipShowFilter;
FN_HANDLE_CMD HandleIpxRipSetInterface;
FN_HANDLE_CMD HandleIpxRipShowInterface;
FN_HANDLE_CMD HandleIpxRipSetGlobal;
FN_HANDLE_CMD HandleIpxRipShowGlobal;

//
// Table of add, delete, set and show commands for IPXRIP
//

//
// The commands are prefix-matched with the command-line, in sequential
// order. So a command like 'ADD INTERFACE FILTER' must come before
// the command 'ADD INTERFACE' in the table.
//

CMD_ENTRY   g_IpxRipAddCmdTable[] =
{
    CREATE_CMD_ENTRY( IPXRIP_ADD_FILTER, HandleIpxRipAddFilter )
};


CMD_ENTRY   g_IpxRipDelCmdTable[] =
{
    CREATE_CMD_ENTRY( IPXRIP_DEL_FILTER, HandleIpxRipDelFilter )
};


CMD_ENTRY   g_IpxRipSetCmdTable[] =
{
    CREATE_CMD_ENTRY( IPXRIP_SET_GLOBAL, HandleIpxRipSetGlobal ),
    CREATE_CMD_ENTRY( IPXRIP_SET_INTERFACE, HandleIpxRipSetInterface ),
    CREATE_CMD_ENTRY( IPXRIP_SET_FILTER, HandleIpxRipSetFilter )
};


CMD_ENTRY   g_IpxRipShowCmdTable[] =
{
    CREATE_CMD_ENTRY( IPXRIP_SHOW_GLOBAL, HandleIpxRipShowGlobal ),
    CREATE_CMD_ENTRY( IPXRIP_SHOW_INTERFACE, HandleIpxRipShowInterface ),
    CREATE_CMD_ENTRY( IPXRIP_SHOW_FILTER, HandleIpxRipShowFilter )
};


//
// Command groups
//

CMD_GROUP_ENTRY g_IpxRipCmdGroups[] =
{
    CREATE_CMD_GROUP_ENTRY( GROUP_ADD, g_IpxRipAddCmdTable ),
    CREATE_CMD_GROUP_ENTRY( GROUP_DELETE, g_IpxRipDelCmdTable ),
    CREATE_CMD_GROUP_ENTRY( GROUP_SET, g_IpxRipSetCmdTable ),
    CREATE_CMD_GROUP_ENTRY( GROUP_SHOW, g_IpxRipShowCmdTable )
};


ULONG g_ulIpxRipNumGroups = 
        sizeof( g_IpxRipCmdGroups ) / sizeof( CMD_GROUP_ENTRY );



//
// functions to handle top level functions
//

DWORD
HandleIpxRipDump(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD dwErr, dwRead = 0, dwTot = 0, i;
    PMPR_INTERFACE_0 IfList;
    WCHAR IfDisplayName[ MAX_INTERFACE_NAME_LEN + 1 ];
    PWCHAR argv[1];
    DWORD dwSize = sizeof(IfDisplayName);


    DisplayIPXMessage (g_hModule, MSG_IPX_RIP_DUMP_HEADER);

    DisplayMessageT( DMP_IPX_RIP_HEADER );

    ShowRipGl(0, NULL, (HANDLE)-1);


    //
    // enumerate interfaces
    //

    if ( g_hMprAdmin )
    {
        dwErr = MprAdminInterfaceEnum(
                    g_hMprAdmin, 0, (unsigned char **)&IfList, MAXULONG, &dwRead,
                    &dwTot,NULL
                    );
    }

    else
    {
        dwErr = MprConfigInterfaceEnum(
                    g_hMprConfig, 0, (unsigned char **)&IfList, MAXULONG, &dwRead,
                    &dwTot,NULL
                    );
    }

    if ( dwErr != NO_ERROR )
    {
        return dwErr;
    }


    //
    // enumerate filters on each interface
    //


    for ( i = 0; i < dwRead; i++ )
    {
        dwErr = IpmontrGetFriendlyNameFromIfName(
                    IfList[i].wszInterfaceName, IfDisplayName, &dwSize
                );

        if ( dwErr == NO_ERROR )
        {
            argv[0] = IfDisplayName;

            ShowRipIf( 1, argv, (HANDLE)-1 );
            
            ShowRipFlt( 1, argv, (HANDLE)-1 );
        }
    }
    
    
    DisplayMessageT( DMP_IPX_RIP_FOOTER );
    
    DisplayIPXMessage (g_hModule, MSG_IPX_RIP_DUMP_FOOTER);


    if ( g_hMprAdmin )
    {
        MprAdminBufferFree( IfList );
    }
    else
    {
        MprConfigBufferFree( IfList );
    }

    
    return NO_ERROR;
}

//
// Functions to handle IPX RIP Filter add/del/set/show
//



DWORD
HandleIpxRipAddFilter(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return CreateRipFlt( 
            dwArgCount - dwCurrentIndex, ppwcArguments + dwCurrentIndex 
            );
}



DWORD
HandleIpxRipDelFilter(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return DeleteRipFlt( 
            dwArgCount - dwCurrentIndex, ppwcArguments + dwCurrentIndex 
            );
}



DWORD
HandleIpxRipSetFilter(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return SetRipFlt( 
            dwArgCount - dwCurrentIndex, ppwcArguments + dwCurrentIndex 
            );
}



DWORD
HandleIpxRipShowFilter(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return ShowRipFlt( 
            dwArgCount - dwCurrentIndex, ppwcArguments + dwCurrentIndex, NULL
            );
}




DWORD
HandleIpxRipSetInterface(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return SetRipIf( 
            dwArgCount - dwCurrentIndex, ppwcArguments + dwCurrentIndex 
            );
}



DWORD
HandleIpxRipShowInterface(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return ShowRipIf( 
            dwArgCount - dwCurrentIndex, ppwcArguments + dwCurrentIndex, NULL
            );
}



DWORD
HandleIpxRipSetGlobal(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return SetRipGl( 
            dwArgCount - dwCurrentIndex, ppwcArguments + dwCurrentIndex 
            );
}



DWORD
HandleIpxRipShowGlobal(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return ShowRipGl( 
            dwArgCount - dwCurrentIndex, ppwcArguments + dwCurrentIndex, NULL
            );
}



DWORD
IpxRipDump(
    IN      LPCWSTR     pwszRouter,
    IN OUT  LPWSTR     *ppwcArguments,
    IN      DWORD       dwArgCount,
    IN      LPCVOID     pvData
    )
{
    ConnectToRouter(pwszRouter);

    //g_hMIBServer = (MIB_SERVER_HANDLE)pvData;

    return HandleIpxRipDump(pwszRouter, ppwcArguments, dwArgCount,
                            0, 0, pvData, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ipx\protocols\ripgl.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    ripgl.c

Abstract:

    IPX Router Console Monitoring and Configuration tool.
    RIP Global configuration.

Author:

    Vadim Eydelman  06/07/1996


--*/
#include "precomp.h"
#pragma hdrstop


DWORD
CfgSetRipGlInfo(
    IN DWORD    *pLogLevel OPTIONAL
);

DWORD
AdmSetRipGlInfo(
    IN DWORD    *pLogLevel OPTIONAL
);


DWORD
APIENTRY 
HelpRipGl (
    IN    int               argc,
    IN    WCHAR            *argv[]
) 
{
    DisplayMessage (g_hModule, HLP_IPX_RIPGL );
    return 0;
}


DWORD
APIENTRY 
ShowRipGl (
    IN    int               argc,
    IN    WCHAR            *argv[],
    IN    HANDLE            hFile
) 
{
    DWORD        rc;
    LPBYTE      pGlBlock;
    DWORD       sz;
    HANDLE      hTrCfg = NULL;

    if (g_hMprAdmin) 
    {
        rc = MprAdminTransportGetInfo(
                g_hMprAdmin, PID_IPX, &pGlBlock, &sz, NULL, NULL
                );
                
        if (rc == NO_ERROR)
        {
        }
        else
        {
            goto GetFromCfg;
        }
    }
    
    else 
    {
GetFromCfg:

        rc = MprConfigTransportGetHandle (
                g_hMprConfig, PID_IPX, &hTrCfg
                );
                
        if (rc == NO_ERROR) 
        {
            rc = MprConfigTransportGetInfo (
                    g_hMprConfig, hTrCfg, &pGlBlock, &sz,
                    NULL, NULL, NULL
                    );
        }
    }

    if (rc == NO_ERROR) 
    {
        PIPX_TOC_ENTRY pRipGlToc;

        pRipGlToc = GetIPXTocEntry (
                        (PIPX_INFO_BLOCK_HEADER)pGlBlock,
                        IPX_PROTOCOL_RIP
                        );
                        
        if ( pRipGlToc != NULL ) 
        {
            PRIP_GLOBAL_INFO    pRipGlInfo;
            PWCHAR              buffer;

            pRipGlInfo = (PRIP_GLOBAL_INFO)
                            (pGlBlock + pRipGlToc->Offset);

            buffer = GetEnumString(
                        g_hModule, pRipGlInfo->EventLogMask, 
                        NUM_TOKENS_IN_TABLE( LogLevels ),
                        LogLevels
                        );

            if ( buffer )
            {
                if ( hFile )
                {
                    DisplayMessageT( DMP_IPX_RIP_SET_GLOBAL, buffer );
                }

                else
                {
                    DisplayIPXMessage(
                        g_hModule, MSG_RIP_GLOBAL_FMT, buffer
                        );
                }
            }
            else
            {
                rc = ERROR_NOT_ENOUGH_MEMORY;
                if ( !hFile )
                {
                    DisplayError( g_hModule, rc );
                }
            }
        }
        else 
        {
            rc = ERROR_INVALID_DATA;
            if ( !hFile )
            {
                DisplayIPXMessage (g_hModule, MSG_ROUTER_INFO_CORRUPTED);
            }
        }
        
        if (hTrCfg != NULL)
        {
            MprConfigBufferFree (pGlBlock);
        }
        else
        {
            MprAdminBufferFree (pGlBlock);
        }
    }
    
    else
    {
        if ( !hFile )
        {
            DisplayError( g_hModule, rc );
        }
    }

    return rc;
}


DWORD
APIENTRY 
SetRipGl (
    IN    int                   argc,
    IN    WCHAR                *argv[]
) 
{
    DWORD        rc;

    if (argc >= 1) 
    {
        int         i;
        unsigned    n;
        DWORD       logLevel;
        DWORD       * pLogLevel = NULL;

        for (i = 0; i < argc; i++) 
        {
            if ( !_wcsicmp( argv[i], TOKEN_LOGLEVEL ) ) 
            {
                if ( (pLogLevel == NULL)
                     && (i < argc - 1)
                     && !MatchEnumTag( g_hModule, argv[i+1], 
                        NUM_TOKENS_IN_TABLE( LogLevels ), LogLevels,
                        &logLevel) ) 
                {
                    i += 1;
                    pLogLevel = &logLevel;
                    continue;
                }
                else
                {
                    break;
                }
            }

            if (pLogLevel == NULL) 
            {
                if (!MatchEnumTag( g_hModule, argv[i], 
                        NUM_TOKENS_IN_TABLE( LogLevels ), LogLevels,
                        &logLevel) ) 
                {
                    pLogLevel = &logLevel;
                }
            }
            else
            {
                break;
            }
        }

        
        if (i == argc) 
        {
            rc = CfgSetRipGlInfo (pLogLevel);
            
            if (rc == NO_ERROR) 
            {
                if (g_hMprAdmin) { AdmSetRipGlInfo (pLogLevel); }
            }
        }
        else 
        {
            DisplayMessage (g_hModule, HLP_IPX_RIPGL);
            rc = ERROR_INVALID_PARAMETER;
        }
    }
    else 
    {
        DisplayMessage (g_hModule, HLP_IPX_RIPGL);
        rc = ERROR_INVALID_PARAMETER;
    }
    
    return rc;
}


DWORD
CfgSetRipGlInfo (
    IN DWORD    *pLogLevel OPTIONAL
) 
{
    DWORD   rc;
    HANDLE  hTrCfg;

    rc = MprConfigTransportGetHandle(
            g_hMprConfig, PID_IPX, &hTrCfg
            );
            
    if (rc == NO_ERROR) 
    {
        DWORD   sz;
        LPBYTE  pGlBlock;

        rc = MprConfigTransportGetInfo(
                g_hMprConfig, hTrCfg, &pGlBlock, &sz, NULL, NULL, NULL
                );
                
        if ( rc == NO_ERROR ) 
        {
            PIPX_TOC_ENTRY pRipGlToc;

            pRipGlToc = GetIPXTocEntry(
                            (PIPX_INFO_BLOCK_HEADER)pGlBlock,
                            IPX_PROTOCOL_RIP
                            );
                            
            if (pRipGlToc != NULL) 
            {
                PRIP_GLOBAL_INFO    pRipGlInfo;

                pRipGlInfo = (PRIP_GLOBAL_INFO)
                                (pGlBlock + pRipGlToc->Offset);
                                
                if (pLogLevel)
                {
                    pRipGlInfo->EventLogMask = *pLogLevel;
                }
                
                rc = MprConfigTransportSetInfo(
                        g_hMprConfig, hTrCfg, pGlBlock, sz, NULL, 0, NULL
                        );
                        
                if (rc == NO_ERROR) 
                {
                    DisplayIPXMessage(
                        g_hModule, MSG_RIPGL_SET_CFG
                        );
                }
                else
                {
                    DisplayError( g_hModule, rc );
                }
            }
            else 
            {
                DisplayIPXMessage (g_hModule, MSG_ROUTER_INFO_CORRUPTED);
                rc = ERROR_INVALID_DATA;
            }
            
            MprConfigBufferFree (pGlBlock);
        }
        else
        {
            DisplayError( g_hModule, rc);
        }
    }
    else
    {
        DisplayError( g_hModule, rc);
    }

    return rc;
}




DWORD
AdmSetRipGlInfo (
IN DWORD    *pLogLevel OPTIONAL
) 
{
    DWORD    rc;
    LPBYTE    pGlBlock;
    DWORD   sz;

    rc = MprAdminTransportGetInfo(
            g_hMprAdmin, PID_IPX, &pGlBlock, &sz, NULL, NULL
            );
            
    if (rc == NO_ERROR) 
    {
        PIPX_TOC_ENTRY pRipGlToc;

        pRipGlToc = GetIPXTocEntry(
                        (PIPX_INFO_BLOCK_HEADER)pGlBlock,
                        IPX_PROTOCOL_RIP
                        );
                        
        if ( pRipGlToc != NULL ) 
        {
            PRIP_GLOBAL_INFO    pRipGlInfo;

            pRipGlInfo = (PRIP_GLOBAL_INFO)
                            (pGlBlock + pRipGlToc->Offset);
                            
            if (pLogLevel)
            {
                pRipGlInfo->EventLogMask = *pLogLevel;
            }

            rc = MprAdminTransportSetInfo(
                    g_hMprAdmin, PID_IPX, pGlBlock, sz, NULL, 0
                    );

            if (rc == NO_ERROR) 
            {
                DisplayIPXMessage (g_hModule, MSG_RIPGL_SET_ADM );
            }
            else
            {
                DisplayError( g_hModule, rc);
            }
        }
        else 
        {
            DisplayIPXMessage (g_hModule, MSG_ROUTER_INFO_CORRUPTED);
            rc = ERROR_INVALID_DATA;
        }
        
            MprConfigBufferFree (pGlBlock);
    }
    
    else
    {
        DisplayError( g_hModule, rc);
    }

    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ipx\protocols\ripifs.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    ripifs.h

Abstract:

    IPX Router Console Monitoring and Configuration tool.
    RIP Interface configuration and monitoring. Header File

Author:

    Vadim Eydelman  06/07/1996


--*/
#ifndef _IPXMON_RIPIFS_
#define _IPXMON_RIPIFS_

DWORD
APIENTRY 
HelpRipIf (
    IN    int                   argc,
    IN    WCHAR                *argv[]
    );

DWORD
APIENTRY 
ShowRipIf (
    IN    int                   argc,
    IN    WCHAR                *argv[],
    IN    HANDLE                hFile
    );

DWORD
APIENTRY 
SetRipIf (
    IN    int                   argc,
    IN    WCHAR                *argv[]
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ipx\protocols\sap.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    sap.c

Abstract:

    IPX Router Console Monitoring and Configuration tool.
    SAP Command dispatcher.

Author:

    V Raman     1/5/1998

--*/

#include "precomp.h"
#pragma hdrstop

FN_HANDLE_CMD HandleIpxSapAddFilter;
FN_HANDLE_CMD HandleIpxSapDelFilter;
FN_HANDLE_CMD HandleIpxSapSetFilter;
FN_HANDLE_CMD HandleIpxSapShowFilter;
FN_HANDLE_CMD HandleIpxSapSetInterface;
FN_HANDLE_CMD HandleIpxSapShowInterface;
FN_HANDLE_CMD HandleIpxSapSetGlobal;
FN_HANDLE_CMD HandleIpxSapShowGlobal;

//
// Table of add, delete, set and show commands for IPXSAP
//

//
// The commands are prefix-matched with the command-line, in sequential
// order. So a command like 'ADD INTERFACE FILTER' must come before
// the command 'ADD INTERFACE' in the table.
//

CMD_ENTRY   g_IpxSapAddCmdTable[] =
{
    CREATE_CMD_ENTRY( IPXSAP_ADD_FILTER, HandleIpxSapAddFilter )
};


CMD_ENTRY   g_IpxSapDelCmdTable[] =
{
    CREATE_CMD_ENTRY( IPXSAP_DEL_FILTER, HandleIpxSapDelFilter )
};


CMD_ENTRY   g_IpxSapSetCmdTable[] =
{
    CREATE_CMD_ENTRY( IPXSAP_SET_GLOBAL, HandleIpxSapSetGlobal ),
    CREATE_CMD_ENTRY( IPXSAP_SET_INTERFACE, HandleIpxSapSetInterface ),
    CREATE_CMD_ENTRY( IPXSAP_SET_FILTER, HandleIpxSapSetFilter )
};


CMD_ENTRY   g_IpxSapShowCmdTable[] =
{
    CREATE_CMD_ENTRY( IPXSAP_SHOW_GLOBAL, HandleIpxSapShowGlobal ),
    CREATE_CMD_ENTRY( IPXSAP_SHOW_INTERFACE, HandleIpxSapShowInterface ),
    CREATE_CMD_ENTRY( IPXSAP_SHOW_FILTER, HandleIpxSapShowFilter )
};


//
// Command groups
//

CMD_GROUP_ENTRY g_IpxSapCmdGroups[] =
{
    CREATE_CMD_GROUP_ENTRY( GROUP_ADD, g_IpxSapAddCmdTable ),
    CREATE_CMD_GROUP_ENTRY( GROUP_DELETE, g_IpxSapDelCmdTable ),
    CREATE_CMD_GROUP_ENTRY( GROUP_SET, g_IpxSapSetCmdTable ),
    CREATE_CMD_GROUP_ENTRY( GROUP_SHOW, g_IpxSapShowCmdTable )
};


ULONG g_ulIpxSapNumGroups = 
        sizeof( g_IpxSapCmdGroups ) / sizeof( CMD_GROUP_ENTRY );




//
// functions to handle top level functions
//

DWORD
HandleIpxSapDump(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD dwErr, dwRead = 0, dwTot = 0, i;
    PMPR_INTERFACE_0 IfList;
    WCHAR IfDisplayName[ MAX_INTERFACE_NAME_LEN + 1 ];
    PWCHAR argv[1];
    DWORD dwSize = sizeof(IfDisplayName);


    DisplayIPXMessage (g_hModule, MSG_IPX_SAP_DUMP_HEADER);

    DisplayMessageT( DMP_IPX_SAP_HEADER );

    ShowSapGl(0, NULL, (HANDLE)-1);


    //
    // enumerate interfaces
    //

    if ( g_hMprAdmin )
    {
        dwErr = MprAdminInterfaceEnum(
                    g_hMprAdmin, 0, (unsigned char **)&IfList, MAXULONG, &dwRead,
                    &dwTot,NULL
                    );
    }

    else
    {
        dwErr = MprConfigInterfaceEnum(
                    g_hMprConfig, 0, (unsigned char **)&IfList, MAXULONG, &dwRead,
                    &dwTot,NULL
                    );
    }

    if ( dwErr != NO_ERROR )
    {
        return dwErr;
    }


    //
    // enumerate filters on each interface
    //


    for ( i = 0; i < dwRead; i++ )
    {
        dwErr = IpmontrGetFriendlyNameFromIfName(
                    IfList[i].wszInterfaceName, IfDisplayName, &dwSize
                );

        if ( dwErr == NO_ERROR )
        {
            argv[0] = IfDisplayName;

            ShowSapIf( 1, argv, (HANDLE)-1 );
            
            ShowSapFlt( 1, argv, (HANDLE)-1 );
        }
    }
    
    
    DisplayMessageT( DMP_IPX_SAP_FOOTER );
    
    DisplayIPXMessage (g_hModule, MSG_IPX_SAP_DUMP_FOOTER);


    if ( g_hMprAdmin )
    {
        MprAdminBufferFree( IfList );
    }
    else
    {
        MprConfigBufferFree( IfList );
    }

    return NO_ERROR;
}

//
// Functions to handle IPX SAP Filter add/del/set/show
//



DWORD
HandleIpxSapAddFilter(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return CreateSapFlt( 
            dwArgCount - dwCurrentIndex, ppwcArguments + dwCurrentIndex 
            );
}



DWORD
HandleIpxSapDelFilter(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return DeleteSapFlt( 
            dwArgCount - dwCurrentIndex, ppwcArguments + dwCurrentIndex 
            );
}



DWORD
HandleIpxSapSetFilter(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return SetSapFlt( 
            dwArgCount - dwCurrentIndex, ppwcArguments + dwCurrentIndex 
            );
}



DWORD
HandleIpxSapShowFilter(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return ShowSapFlt( 
            dwArgCount - dwCurrentIndex, ppwcArguments + dwCurrentIndex, NULL
            );
}




DWORD
HandleIpxSapSetInterface(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return SetSapIf( 
            dwArgCount - dwCurrentIndex, ppwcArguments + dwCurrentIndex 
            );
}



DWORD
HandleIpxSapShowInterface(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return ShowSapIf( 
            dwArgCount - dwCurrentIndex, ppwcArguments + dwCurrentIndex, NULL
            );
}



DWORD
HandleIpxSapSetGlobal(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return SetSapGl( 
            dwArgCount - dwCurrentIndex, ppwcArguments + dwCurrentIndex 
            );
}



DWORD
HandleIpxSapShowGlobal(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return ShowSapGl( 
            dwArgCount - dwCurrentIndex, ppwcArguments + dwCurrentIndex, NULL
            );
}



DWORD
IpxSapDump(
    IN      LPCWSTR     pwszRouter,
    IN OUT  LPWSTR     *ppwcArguments,
    IN      DWORD       dwArgCount,
    IN      LPCVOID     pvData
    )
{
    ConnectToRouter(pwszRouter);

    //g_hMIBServer = (MIB_SERVER_HANDLE)pvData;

    return HandleIpxSapDump(pwszRouter, ppwcArguments, dwArgCount,
                            0, 0, pvData, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ipx\protocols\ripifs.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    ripifs.c

Abstract:

    IPX Router Console Monitoring and Configuration tool.
    RIP Interface configuration and monitoring.

Author:

    Vadim Eydelman  06/07/1996


--*/
#include "precomp.h"
#pragma hdrstop

DWORD
MIBGetRipIf(
    PWCHAR      InterfaceNamew,
    HANDLE      hFile
);

DWORD
CfgGetRipIf(
    PWCHAR      InterfaceNameW,
    HANDLE      hFile
);

DWORD
MIBEnumRipIfs(
    VOID
);

DWORD
CfgEnumRipIfs(
    VOID
);


DWORD
CfgSetRipIf (
    LPWSTR        InterfaceNameW,
    PULONG        pAdminState       OPTIONAL,
    PULONG        pAdvertise        OPTIONAL,
    PULONG        pListen           OPTIONAL,
    PULONG        pUpdateMode       OPTIONAL,
    PULONG        pInterval         OPTIONAL,
    PULONG        pAgeMultiplier    OPTIONAL,
    PWCHAR        IfName
    );

DWORD
AdmSetRipIf (
    LPWSTR        InterfaceNameW,
    PULONG        pAdminState       OPTIONAL,
    PULONG        pUpdateMode       OPTIONAL,
    PULONG        pInterval         OPTIONAL,
    PULONG        pAdvertise        OPTIONAL,
    PULONG        pListen           OPTIONAL,
    PULONG        pAgeMultiplier    OPTIONAL,
    PWCHAR        IfName
    );

DWORD
GetRipClientIf(
    PWCHAR        InterfaceNameW,
    UINT          msg,
    HANDLE        hFile
    );



DWORD
APIENTRY 
HelpRipIf (
    IN    int                   argc,
    IN    WCHAR                *argv[]
) 
{
    DisplayMessage (g_hModule, HLP_IPX_RIPIF);
    return 0;
}


DWORD
APIENTRY 
ShowRipIf (
    IN    int                   argc,
    IN    WCHAR                *argv[],
    IN    HANDLE                hFile
) 
{
    DWORD rc;
    
    if (argc < 1) 
    {
        if ( g_hMIBServer ) 
        {
            rc = MIBEnumRipIfs (  );
            
            if (rc == NO_ERROR)
            {
                rc = GetRipClientIf( 
                        VAL_DIALINCLIENT,
                        MSG_CLIENT_RIPIF_MIB_TABLE_FMT,
                        NULL
                        );
            }
            else
            {
                goto EnumerateThroughCfg;
            }
        }
        
        else 
        {
EnumerateThroughCfg:

            rc = CfgEnumRipIfs ( );
            
            if (rc == NO_ERROR)
            {
                rc = GetRipClientIf(
                        VAL_DIALINCLIENT,
                        MSG_CLIENT_RIPIF_CFG_TABLE_FMT,
                        NULL
                        );
            }
        }
    }
    
    else 
    {
        WCHAR       IfName[ MAX_INTERFACE_NAME_LEN + 1 ];
        unsigned    count, dwSize = sizeof(IfName);

#define InterfaceNameW argv[0]

        count = wcslen( InterfaceNameW );
        
        if ( !_wcsicmp( argv[0], VAL_DIALINCLIENT ) )
        {
            rc = GetRipClientIf(
                    VAL_DIALINCLIENT, MSG_CLIENT_RIPIF_CFG_SCREEN_FMT,
                    hFile
                    );
        }
        
        else if ((count > 0) && (count <= MAX_INTERFACE_NAME_LEN)) 
        {
            if (g_hMIBServer) 
            {
                //======================================
                // Translate the Interface Name
                //======================================
                
                rc = IpmontrGetIfNameFromFriendlyName(
                        InterfaceNameW, IfName, &dwSize
                        );

                if ( rc == NO_ERROR )
                {
                    rc = MIBGetRipIf( IfName, hFile );
                }
                
                if (rc != NO_ERROR) 
                {
                    goto GetIfFromCfg;
                }
            }
            
            else 
            {
GetIfFromCfg:
                //======================================
                // Translate the Interface Name
                //======================================
                rc = IpmontrGetIfNameFromFriendlyName(
                        InterfaceNameW, IfName, &dwSize
                        );

                if ( rc == NO_ERROR )
                {
                    rc = CfgGetRipIf( IfName, hFile );
                }
            }
        }
        
        else 
        {
            if (hFile)
            {
                DisplayIPXMessage (g_hModule, MSG_INVALID_INTERFACE_NAME);
            }
            
            rc = ERROR_INVALID_PARAMETER;
        }
    }

    return rc;
    
#undef InterfaceNameW
}


DWORD
APIENTRY 
SetRipIf(
    IN    int                   argc,
    IN    WCHAR                *argv[]
) 
{
    DWORD        rc;


    if (argc >= 1) 
    {
        unsigned    count;
        BOOLEAN     client = FALSE;
        
#define InterfaceNameW argv[0]

        if ( !_wcsicmp( argv[0], VAL_DIALINCLIENT ) )
        {
            client = TRUE;
        }
        else
        {
            count = wcslen (InterfaceNameW);
        }

        if (client || ((count > 0) && (count <= MAX_INTERFACE_NAME_LEN))) 
        {
            int         i;
            unsigned    n;
            ULONG       adminState, updateMode, interval, ageMultiplier,
                        advertise, listen;
                        
            PULONG      pAdminState = NULL, pUpdateMode = NULL, pInterval = NULL,
                        pAgeMultiplier = NULL, pAdvertise = NULL, pListen = NULL;


            for (i = 1; i < argc; i++) 
            {
                if ( !_wcsicmp( argv[i], TOKEN_ADMINSTATE ) ) 
                {
                    if ((pAdminState == NULL)
                         && (i < argc - 1)
                         && !MatchEnumTag( g_hModule, argv[i+1], 
                                NUM_TOKENS_IN_TABLE( AdminStates ),
                                AdminStates, &adminState)) 
                    {
                        i += 1;
                        pAdminState = &adminState;
                        continue;
                    }
                    else
                    {
                        break;
                    }
                }

                
                if ( !_wcsicmp( argv[i], TOKEN_ADVERTISE ) ) 
                {
                    if ((pAdvertise == NULL)
                         && (i < argc - 1)
                         && !MatchEnumTag( g_hModule, argv[i+1], 
                                NUM_TOKENS_IN_TABLE( AdminStates ),
                                AdminStates, &advertise)) 
                    {
                        i += 1;
                        pAdvertise = &advertise;
                        continue;
                    }
                    else
                    {
                        break;
                    }
                }

                
                if ( !_wcsicmp( argv[i], TOKEN_LISTEN ) ) 
                {
                    if ((pListen == NULL)
                         && (i < argc - 1)
                         && !MatchEnumTag( g_hModule, argv[i+1], 
                                NUM_TOKENS_IN_TABLE( AdminStates ),
                                AdminStates, &listen)) 
                    {
                        i += 1;
                        pListen = &listen;
                        continue;
                    }
                    else
                    {
                        break;
                    }
                }
                

                if ( !_wcsicmp( argv[i], TOKEN_UPDATEMODE ) ) 
                {
                    if ((pUpdateMode == NULL)
                         && (i < argc - 1)
                         && !MatchEnumTag( g_hModule, argv[i+1], 
                                NUM_TOKENS_IN_TABLE( UpdateModes ),
                                UpdateModes, &updateMode
                                )) 
                    {
                        i += 1;
                        pUpdateMode = &updateMode;
                        continue;
                    }
                }


                if ( !_wcsicmp( argv[i], TOKEN_INTERVAL ) ) 

                {
                    if ((pInterval == NULL)
                         && (i < argc - 1)
                         && (swscanf (argv[i+1], L"%ld%n", &interval, &n) == 1)
                         && (n == wcslen(argv[i+1]))) 
                    {
                        i += 1;
                        pInterval = &interval;
                        continue;
                    }
                    else
                    {
                        break;
                    }
                }
                

                if ( !_wcsicmp( argv[i], TOKEN_AGEMULTIPLIER ) ) 
                {
                    if ((pAgeMultiplier == NULL)
                         && (i < argc - 1)
                         && (swscanf (argv[i+1], L"%ld%n", &ageMultiplier, &n) == 1)
                         && (n == wcslen(argv[i+1]))) 
                    {
                        i += 1;
                        pAgeMultiplier = &ageMultiplier;
                        continue;
                    }
                    else
                    {
                        break;
                    }
                }


                if (pAdminState == NULL) 
                {
                    if ( !MatchEnumTag (g_hModule, argv[i], 
                            NUM_TOKENS_IN_TABLE( AdminStates ),
                            AdminStates, &adminState)) 
                    {
                        pAdminState = &adminState;
                    }
                    else
                    {
                        break;
                    }
                }
                
                else if (pAdvertise == NULL) 
                {
                    if ( !MatchEnumTag (g_hModule, argv[i], 
                            NUM_TOKENS_IN_TABLE( AdminStates ),
                            AdminStates, &advertise)) 
                    {
                        pAdvertise = &advertise;
                    }
                    else
                    {
                        break;
                    }
                }
                
                else if (pListen == NULL) 
                {
                    if ( !MatchEnumTag (g_hModule, argv[i], 
                            NUM_TOKENS_IN_TABLE( AdminStates ),
                            AdminStates, &listen)) 
                    {
                        pListen = &listen;
                    }
                    else
                    {
                        break;
                    }
                }
                
                else if (pUpdateMode == NULL) 
                {
                    if ( !MatchEnumTag (g_hModule, argv[i], 
                            NUM_TOKENS_IN_TABLE( UpdateModes ),
                            UpdateModes, &updateMode)) 
                    {
                        pUpdateMode = &updateMode;
                    }
                    else
                    {
                        break;
                    }
                }
                
                else if (pInterval == NULL) 
                {
                    if ((swscanf ( argv[i], L"%ld%n", &interval, &n) == 1)
                         && (n == wcslen(argv[i]))) 
                    {
                        pInterval = &interval;
                    }
                    else
                    {
                        break;
                    }
                }
                
                else if (pAgeMultiplier == NULL) 
                {
                    if ( (swscanf (argv[i], L"%ld%n", &ageMultiplier, &n) == 1) && 
                         (n == wcslen(argv[i]) ) )
                    {
                        pAgeMultiplier = &ageMultiplier;
                    }
                    else
                    {
                        break;
                    }
                }
                
                else
                {
                    break;
                }
            }
            

            if (i == argc) 
            {
                if (!client) 
                {
                    WCHAR IfName[ MAX_INTERFACE_NAME_LEN + 1 ];
                    DWORD rc2, dwSize = sizeof(IfName);
                    
                    //======================================
                    // Translate the Interface Name
                    //======================================
                    
                    rc = IpmontrGetIfNameFromFriendlyName(
                            InterfaceNameW, IfName, &dwSize
                            );
                            
                    if ( rc == NO_ERROR )
                    {
                        rc2 = CfgSetRipIf(
                                IfName, pAdminState, pAdvertise, pListen,
                                pUpdateMode, pInterval, pAgeMultiplier,
                                InterfaceNameW
                                );
                                
                        if (rc2 == NO_ERROR) 
                        {
                            if (g_hMprAdmin) 
                            {
                                rc = AdmSetRipIf(
                                        IfName, pAdminState, pAdvertise,
                                        pListen, pUpdateMode, pInterval, 
                                        pAgeMultiplier, InterfaceNameW
                                        );
                            }
                        }
                        
                        else
                        {
                            rc = rc2;
                        }
                    }
                }
                
                else 
                {
                    rc = CfgSetRipIf(
                            NULL, pAdminState, pAdvertise, pListen,
                            pUpdateMode, pInterval, pAgeMultiplier,
                            InterfaceNameW
                            );
                            
                    if (rc == NO_ERROR) 
                    {
                        if (g_hMprAdmin) 
                        {
                            rc = AdmSetRipIf(
                                    NULL, pAdminState, pAdvertise, pListen,
                                    pUpdateMode, pInterval, pAgeMultiplier,
                                    InterfaceNameW
                                    );
                        }
                    }
                }
            }
            else 
            {
                DisplayMessage (g_hModule, HLP_IPX_RIPIF);
                rc = ERROR_INVALID_PARAMETER;
            }
        }
        else 
        {
            DisplayIPXMessage (g_hModule, MSG_INVALID_INTERFACE_NAME);
            rc = ERROR_INVALID_PARAMETER;
        }
    }
    else 
    {
        DisplayMessage (g_hModule, HLP_IPX_RIPIF);
        rc = ERROR_INVALID_PARAMETER;
    }

    return rc;
    
#undef InterfaceNameW
}


DWORD
MIBGetRipIf (
    PWCHAR      InterfaceNameW,
    HANDLE      hFile
) 
{
    DWORD                    rc;
    DWORD                    sz;
    RIP_MIB_GET_INPUT_DATA   MibGetInputData;
    PRIP_INTERFACE           pIf;
    WCHAR                    IfName[ MAX_INTERFACE_NAME_LEN + 1 ];
    DWORD                    dwSize = sizeof(IfName);

    MibGetInputData.TableId = RIP_INTERFACE_TABLE;
    
    rc = GetIpxInterfaceIndex(
            g_hMIBServer, InterfaceNameW,
            &MibGetInputData.InterfaceIndex
            );
            
    if (rc == NO_ERROR) 
    {
        rc = MprAdminMIBEntryGet(
                g_hMIBServer, PID_IPX, IPX_PROTOCOL_RIP, &MibGetInputData,
                sizeof(RIP_MIB_GET_INPUT_DATA), (LPVOID * ) & pIf, &sz
                );
                
        if (rc == NO_ERROR) 
        {
            DWORD   i;
            PWCHAR  buffer[5];
            
            //======================================
            // Translate the Interface Name
            //======================================
            
            rc = IpmontrGetFriendlyNameFromIfName(
                    InterfaceNameW, IfName, &dwSize
                    );

            if ( rc == NO_ERROR )
            {
                buffer[ 0 ] = GetEnumString(
                                g_hModule, pIf->RipIfInfo.AdminState,
                                NUM_TOKENS_IN_TABLE( AdminStates ),
                                AdminStates
                                );

                buffer[ 1 ] = GetEnumString(
                                g_hModule, pIf->RipIfInfo.Supply,
                                NUM_TOKENS_IN_TABLE( AdminStates ),
                                AdminStates
                                );

                buffer[ 2 ] = GetEnumString(
                                g_hModule, pIf->RipIfInfo.Listen,
                                NUM_TOKENS_IN_TABLE( AdminStates ),
                                AdminStates
                                );

                buffer[ 3 ] = GetEnumString(
                                g_hModule, pIf->RipIfInfo.UpdateMode,
                                NUM_TOKENS_IN_TABLE( UpdateModes ),
                                UpdateModes
                                );

                buffer[ 4 ] = GetEnumString(
                                g_hModule, pIf->RipIfStats.RipIfOperState,
                                NUM_TOKENS_IN_TABLE( OperStates ),
                                OperStates
                                );
                
                if ( buffer [ 0 ] && buffer[ 1 ] && buffer[ 2 ] &&
                     buffer[ 3 ] && buffer[ 4 ] )
                {
                    if ( hFile )
                    {
                        DisplayMessageT(
                            DMP_IPX_RIP_SET_INTERFACE, IfName,
                            buffer[ 0 ], buffer[1], buffer[ 2 ],
                            buffer[3], pIf->RipIfInfo.PeriodicUpdateInterval,
                            pIf->RipIfInfo.AgeIntervalMultiplier
                            );

                    }

                    else
                    {
                        DisplayIPXMessage(
                            g_hModule, MSG_RIPIF_MIB_SCREEN_FMT,
                            IfName, buffer[ 0 ], buffer[1], buffer[ 2 ],
                            buffer[3], pIf->RipIfInfo.PeriodicUpdateInterval,
                            pIf->RipIfInfo.AgeIntervalMultiplier,
                            buffer[4], pIf->RipIfStats.RipIfInputPackets,
                            pIf->RipIfStats.RipIfOutputPackets
                            );
                    }
                }

                else
                {
                    rc = ERROR_NOT_ENOUGH_MEMORY;
                    if ( !hFile )
                        DisplayError( g_hModule, rc );
                }
            }
            
            MprAdminMIBBufferFree( pIf );
        }
        else 
        {
            if ( !hFile )
                DisplayError( g_hModule, rc);
        }
    }
    else 
    {
        if ( !hFile )
            DisplayError( g_hModule, rc);
    }

    return rc;
}


DWORD
CfgGetRipIf (
    LPWSTR    InterfaceNameW,
    HANDLE    hFile
) 
{
    DWORD        rc;
    DWORD        sz;
    HANDLE       hIfCfg;
    WCHAR        IfName[ MAX_INTERFACE_NAME_LEN + 1 ];
    DWORD        dwSize = sizeof(IfName);

    rc = MprConfigInterfaceGetHandle(
            g_hMprConfig, InterfaceNameW, &hIfCfg
            );
            
    if (rc == NO_ERROR) 
    {
        HANDLE  hIfTrCfg;

        rc = MprConfigInterfaceTransportGetHandle(
                g_hMprConfig, hIfCfg, PID_IPX, &hIfTrCfg
                );
                
        if (rc == NO_ERROR) 
        {
            LPBYTE pIfBlock;
            
            rc = MprConfigInterfaceTransportGetInfo(
                    g_hMprConfig, hIfCfg, hIfTrCfg, &pIfBlock, &sz
                    );
                    
            if (rc == NO_ERROR) 
            {
                PIPX_TOC_ENTRY pRipToc;

                pRipToc = GetIPXTocEntry(
                            (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                            IPX_PROTOCOL_RIP
                            );
                            
                if (pRipToc != NULL) 
                {
                    PRIP_IF_CONFIG  pRipCfg;
                    PWCHAR          buffer[4];
                    DWORD           i;

                    pRipCfg = (PRIP_IF_CONFIG)
                                (pIfBlock + pRipToc->Offset);

                    //======================================
                    // Translate the Interface Name
                    //======================================
                    
                    rc = IpmontrGetFriendlyNameFromIfName(
                            InterfaceNameW, IfName, &dwSize
                            );

                    if ( rc == NO_ERROR )
                    {
                        buffer[ 0 ] = GetEnumString(
                                        g_hModule, pRipCfg->RipIfInfo.AdminState,
                                        NUM_TOKENS_IN_TABLE( AdminStates ),
                                        AdminStates
                                        );

                        buffer[ 1 ] = GetEnumString(
                                        g_hModule, pRipCfg->RipIfInfo.Supply,
                                        NUM_TOKENS_IN_TABLE( AdminStates ),
                                        AdminStates
                                        );

                        buffer[ 2 ] = GetEnumString(
                                        g_hModule, pRipCfg->RipIfInfo.Listen,
                                        NUM_TOKENS_IN_TABLE( AdminStates ),
                                        AdminStates
                                        );

                        buffer[ 3 ] = GetEnumString(
                                        g_hModule, pRipCfg->RipIfInfo.UpdateMode,
                                        NUM_TOKENS_IN_TABLE( UpdateModes ),
                                        UpdateModes
                                        );

                        //======================================
                        
                        if ( buffer [ 0 ] && buffer[ 1 ] && buffer[ 2 ] &&
                             buffer[ 3 ] )
                        {
                            if ( hFile )
                            {
                                DisplayMessageT(
                                    DMP_IPX_RIP_SET_INTERFACE, IfName,
                                    buffer[ 0 ], buffer[1], buffer[ 2 ],
                                    buffer[3], pRipCfg->RipIfInfo.PeriodicUpdateInterval,
                                    pRipCfg->RipIfInfo.AgeIntervalMultiplier
                                    );
                            }

                            else
                            {
                                DisplayIPXMessage(
                                    g_hModule, MSG_RIPIF_CFG_SCREEN_FMT,
                                    IfName, buffer[0], buffer[1], 
                                    buffer[2], buffer[3],
                                    pRipCfg->RipIfInfo.PeriodicUpdateInterval,
                                    pRipCfg->RipIfInfo.AgeIntervalMultiplier
                                    );
                            }
                        }
                        else
                        {
                            rc = ERROR_NOT_ENOUGH_MEMORY;
                            if ( !hFile ) { DisplayError( g_hModule, rc ); }
                        }
                    }
                    
                    else
                    {
                        if ( !hFile ) { DisplayError( g_hModule, rc ); }
                    }                    
                }
                else 
                {
                    if ( !hFile ) { DisplayIPXMessage (g_hModule, MSG_INTERFACE_INFO_CORRUPTED); }
                    rc = ERROR_INVALID_DATA;
                }
            }
            else 
            {
                if ( !hFile ) { DisplayError( g_hModule, rc); }
            }
        }
        else 
        {
            if ( !hFile ) { DisplayError( g_hModule, rc); }
        }
    }
    else 
    {
        if ( !hFile ) { DisplayError( g_hModule, rc); }
    }

    return rc;
}


DWORD
GetRipClientIf(
    LPWSTR      InterfaceName,
    UINT        msg,
    HANDLE      hFile
    ) 
{
    DWORD    rc;
    LPBYTE   pClBlock;
    HANDLE   hTrCfg;
    DWORD    sz;

    hTrCfg = NULL;
    
    if (g_hMprAdmin) 
    {
        rc = MprAdminTransportGetInfo(
                g_hMprAdmin, PID_IPX, NULL, NULL, &pClBlock, &sz
                );
        if (rc == NO_ERROR) 
        {
            NOTHING;
        }
        else 
        {
            if ( !hFile ) { DisplayError( g_hModule, rc); }
            goto GetFromCfg;
        }
    }
    
    else 
    {
GetFromCfg:

        rc = MprConfigTransportGetHandle(
                g_hMprConfig, PID_IPX, &hTrCfg
                );
                
        if (rc == NO_ERROR) 
        {
            rc = MprConfigTransportGetInfo(
                    g_hMprConfig, hTrCfg, NULL, NULL, &pClBlock, &sz, NULL
                    );
                    
            if (rc == NO_ERROR)
            {
                NOTHING;
            }
            else
            {
                if ( !hFile ) { DisplayError( g_hModule, rc); }
            }
        }
        
        else
        {
            if ( !hFile ) { DisplayError( g_hModule, rc); }
        }
    }

    
    if (rc == NO_ERROR) 
    {
        PIPX_TOC_ENTRY pRipToc;

        pRipToc = GetIPXTocEntry(
                    (PIPX_INFO_BLOCK_HEADER)pClBlock,
                    IPX_PROTOCOL_RIP
                    );

        if ( pRipToc != NULL ) 
        {
            PRIP_IF_CONFIG  pRipCfg;
            PWCHAR          buffer[4];
            DWORD           i;

            pRipCfg = (PRIP_IF_CONFIG)
                        (pClBlock + pRipToc->Offset);

            buffer[ 0 ] = GetEnumString(
                            g_hModule, pRipCfg->RipIfInfo.AdminState,
                            NUM_TOKENS_IN_TABLE( AdminStates ),
                            AdminStates
                            );

            buffer[ 1 ] = GetEnumString(
                            g_hModule, pRipCfg->RipIfInfo.Supply,
                            NUM_TOKENS_IN_TABLE( AdminStates ),
                            AdminStates
                            );

            buffer[ 2 ] = GetEnumString(
                            g_hModule, pRipCfg->RipIfInfo.Listen,
                            NUM_TOKENS_IN_TABLE( AdminStates ),
                            AdminStates
                            );

            buffer[ 3 ] = GetEnumString(
                            g_hModule, pRipCfg->RipIfInfo.UpdateMode,
                            NUM_TOKENS_IN_TABLE( UpdateModes ),
                            UpdateModes
                            );

            switch (msg) 
            {
            case MSG_CLIENT_RIPIF_MIB_TABLE_FMT:
            case MSG_CLIENT_RIPIF_CFG_TABLE_FMT:

                if ( buffer[ 3 ] && buffer[ 0 ] )
                {
                    DisplayIPXMessage(
                        g_hModule, msg, InterfaceName,
                        buffer[3], buffer[0]
                        );
                }
                else
                {
                    rc = ERROR_NOT_ENOUGH_MEMORY;
                    DisplayError( g_hModule, rc );
                }
                
                break;

                
            case MSG_CLIENT_RIPIF_MIB_SCREEN_FMT:
            case MSG_CLIENT_RIPIF_CFG_SCREEN_FMT:

                if (  buffer[ 0 ] && buffer[ 1 ] && buffer[ 2 ] && buffer[ 3 ] )
                {
                    if ( hFile )
                    {
                        DisplayMessageT(
                            DMP_IPX_RIP_SET_INTERFACE, InterfaceName,
                            buffer[ 0 ], buffer[1], buffer[ 2 ],
                            buffer[3], pRipCfg->RipIfInfo.PeriodicUpdateInterval,
                            pRipCfg->RipIfInfo.AgeIntervalMultiplier
                            );
                    }

                    else
                    {
                        DisplayIPXMessage(
                            g_hModule, msg, InterfaceName,
                            buffer[0], buffer[1], buffer[2], buffer[3],
                            pRipCfg->RipIfInfo.PeriodicUpdateInterval,
                            pRipCfg->RipIfInfo.AgeIntervalMultiplier
                            );
                    }
                }
                
                else
                {
                    rc = ERROR_NOT_ENOUGH_MEMORY;
                    if ( !hFile ) { DisplayError( g_hModule, rc ); }
                }
                
                break;
            }
        }
        else 
        {

            if ( !hFile ) { DisplayIPXMessage (g_hModule, MSG_INTERFACE_INFO_CORRUPTED); }
            rc = ERROR_INVALID_DATA;
        }
        
        if (hTrCfg != NULL)
        {
            MprConfigBufferFree (pClBlock);
        }
        else
        {
            MprAdminBufferFree (pClBlock);
        }
    }

    return rc;
}


/*
BOOL IsIpxRipInterface(HANDLE hIf) {
    LPBYTE    pIfBlock;
    DWORD dwSize;
    DWORD dwErr;
    BOOL ret;
    PIPX_TOC_ENTRY pRipToc;
    
    dwErr = MprAdminInterfaceTransportGetInfo(
                            g_hMprAdmin,
                            hIf,
                            PID_IPX,
                            &pIfBlock,
                            &dwSize);

    if (dwErr==NO_ERROR)
        ret=TRUE;
    else
        ret=FALSE;

    if (ret) {
        pRipToc = GetIPXTocEntry((PIPX_INFO_BLOCK_HEADER)pIfBlock,IPX_PROTOCOL_RIP);
        if (pRipToc!=NULL)
            ret=TRUE;
        else 
            ret=FALSE;
    }

    MprAdminBufferFree(pIfBlock);

    return ret;
}

DWORD
MIBEnumRipIfs (VOID) {
    PMPR_INTERFACE_0 IfList=NULL;
    DWORD dwErr=0, dwRead, dwTot,i;
    WCHAR buffer[4][MAX_VALUE];

    DisplayIPXMessage (g_hModule, MSG_RIPIF_MIB_TABLE_HDR);
    
    dwErr=MprAdminInterfaceEnum(g_hMprAdmin,0,(unsigned char **)&IfList,4096,&dwRead,&dwTot,NULL);
    if (dwErr!=NO_ERROR)
        return dwErr;

    for (i=0; i<dwRead; i++) {
        if (IsIpxRipInterface(IfList[i].hInterface)) {
            //======================================
            // Translate the Interface Name
            //======================================
            if ((dwErr=(*(Params->IfName2DescW))(IfList[i].wszInterfaceName,
                                        Params->IfNamBuffer,
                                          &Params->IfNamBufferLength)) != NO_ERROR) {
                    return dwErr;
            }
            wcstombs(Params->IfNamBufferA,Params->IfNamBuffer,Params->IfNamBufferLength);
            //======================================
            //printf("Ifname= %s\n",Params->IfNamBufferA);
            DisplayIPXMessage (g_hModule,
                MSG_RIPIF_MIB_TABLE_FMT,
                GetValueString (g_hModule, Utils, InterfaceStates,
                        IfList[i].dwConnectionState, buffer[3]),
                GetValueString (g_hModule, Utils, InterfaceEnableStatus,
                        IfList[i].fEnabled ? 0 : 1, buffer[2]),
                GetValueString (g_hModule, Utils, InterfaceTypes,
                        IfList[i].dwIfType, buffer[0]),
                Params->IfNamBufferA);
        }
    }

    return NO_ERROR;
}
*/
/*

DWORD
MIBEnumRipIfs (
    VOID
    ) {
    DWORD                    rc;
    DWORD                    sz;
    RIP_MIB_GET_INPUT_DATA    MibGetInputData;
    PRIP_INTERFACE            pIf;

    DisplayIPXMessage (g_hModule, MSG_RIPIF_MIB_TABLE_HDR);
    MibGetInputData.TableId = RIP_INTERFACE_TABLE;
    rc = MprAdminMIBEntryGetFirst (
                g_hMIBServer,
                PID_IPX,
                IPX_PROTOCOL_RIP,
                &MibGetInputData,
                sizeof(RIP_MIB_GET_INPUT_DATA),
                (LPVOID *)&pIf,
                &sz);
    while (rc==NO_ERROR) {
        //CHAR        InterfaceNameA[IPX_INTERFACE_ANSI_NAME_LEN+1];
        CHAR        InterfaceNameA[MAX_INTERFACE_NAME_LEN+1];
        DWORD        rc1;
        //rc1 = GetIpxInterfaceName (g_hMIBServer,
        //                    pIf->InterfaceIndex,
        //                    InterfaceNameA);
        rc1=(*(Params->IfInd2IfNameA))(pIf->InterfaceIndex, InterfaceNameA, &(Params->IfNamBufferLength));
        if (rc1==NO_ERROR) {
            WCHAR        buffer[3][MAX_VALUE];
            HANDLE      hIfCfg;
            WCHAR       InterfaceNameW[MAX_INTERFACE_NAME_LEN+1];
            mbstowcs (InterfaceNameW, InterfaceNameA,  sizeof (InterfaceNameW));

            if (MprConfigInterfaceGetHandle (
                            g_hMprConfig,
                            InterfaceNameW,
                            &hIfCfg)==NO_ERROR) {
                //======================================
                // Translate the Interface Name
                //======================================
                if ((rc=(*(Params->IfName2DescA))(InterfaceNameA,
                                            Params->IfNamBufferA,
                                              &Params->IfNamBufferLength)) != NO_ERROR) {
                        return rc;
                }
                //======================================
                DisplayIPXMessage (g_hModule,
                    MSG_RIPIF_MIB_TABLE_FMT,
                    Params->IfNamBufferA, //InterfaceNameA,
                    GetValueString (g_hModule, Utils, UpdateModes,
                            pIf->RipIfInfo.UpdateMode, buffer[0]),
                    GetValueString (g_hModule, Utils, AdminStates,
                            pIf->RipIfInfo.AdminState, buffer[1]),
                    GetValueString (g_hModule, Utils, OperStates,
                            pIf->RipIfStats.RipIfOperState, buffer[2])
                    );
            }
        }
        else
            DisplayError( g_hModule, rc1);
        MibGetInputData.InterfaceIndex
                = pIf->InterfaceIndex;
        MprAdminMIBBufferFree (pIf);
        rc = MprAdminMIBEntryGetNext (
                    g_hMIBServer,
                    PID_IPX,
                    IPX_PROTOCOL_RIP,
                    &MibGetInputData,
                    sizeof(RIP_MIB_GET_INPUT_DATA),
                    (LPVOID *)&pIf,
                    &sz);
    }
    if (rc==ERROR_NO_MORE_ITEMS)
        return NO_ERROR;
    else {
        DisplayError( g_hModule, rc);
        return rc;
    }
}
*/



PRIP_IF_CONFIG 
GetIpxRipInterface(
    HANDLE          hIf, 
    LPBYTE         *pIfBlock
) 
{
    DWORD dwSize;
    DWORD dwErr;
    PIPX_TOC_ENTRY pIpxToc;

    dwErr = MprAdminInterfaceTransportGetInfo(
                g_hMprAdmin, hIf, PID_IPX, pIfBlock, &dwSize
                );

    if (dwErr != NO_ERROR)
    {
        return NULL;
    }

    pIpxToc = GetIPXTocEntry(
                (PIPX_INFO_BLOCK_HEADER)(*pIfBlock), 
                IPX_PROTOCOL_RIP
                );
                
    if (!pIpxToc)
    {
        return NULL;
    }

    return (PRIP_IF_CONFIG)((*pIfBlock) + (pIpxToc->Offset));
}



DWORD
MIBEnumRipIfs (
    VOID
) 
{
    PMPR_INTERFACE_0 IfList = NULL;
    DWORD dwErr = 0, dwRead, dwTot, i, j, rc;
    PWCHAR buffer[4];
    LPBYTE buf = NULL;
    WCHAR IfName[ MAX_INTERFACE_NAME_LEN + 1 ];
    PRIP_IF_CONFIG pRipCfg;
    DWORD dwSize = sizeof(IfName); 

    DisplayIPXMessage (g_hModule, MSG_RIPIF_MIB_TABLE_HDR);

    dwErr = MprAdminInterfaceEnum(
                g_hMprAdmin, 0, (unsigned char **) & IfList,
                MAXULONG, &dwRead, &dwTot, NULL
                );
                
    if (dwErr != NO_ERROR)
    {
        return dwErr;
    }

    for (i = 0; i < dwRead; i++) 
    {
        if ( (pRipCfg = GetIpxRipInterface(IfList[i].hInterface, &buf)) != NULL ) 
        {
            //======================================
            // Translate the Interface Name
            //======================================
            
            dwErr = IpmontrGetFriendlyNameFromIfName(
                        IfList[i].wszInterfaceName,
                        IfName, &dwSize
                        );
                        
            if ( dwErr == NO_ERROR )
            {
                buffer[ 0 ] = GetEnumString(
                                g_hModule, pRipCfg->RipIfInfo.AdminState,
                                NUM_TOKENS_IN_TABLE( AdminStates ),
                                AdminStates
                                );

                buffer[ 1 ] = GetEnumString(
                                g_hModule, pRipCfg->RipIfInfo.UpdateMode,
                                NUM_TOKENS_IN_TABLE( UpdateModes ),
                                UpdateModes
                                );

                buffer[ 2 ] = GetEnumString(
                                g_hModule, IfList[i].dwConnectionState,
                                NUM_TOKENS_IN_TABLE( InterfaceStates ),
                                InterfaceStates
                                );
                                
                if (  buffer[ 0 ] && buffer[ 1 ] && buffer[ 2 ] )
                {
                    DisplayIPXMessage(
                        g_hModule, MSG_RIPIF_MIB_TABLE_FMT,
                        buffer[ 2 ], buffer[ 0 ], buffer[ 1 ],
                        IfName
                        );
                }
                else
                {
                    rc = ERROR_NOT_ENOUGH_MEMORY;
                    DisplayError( g_hModule, rc );
                }
            }

            else
            {
                DisplayError( g_hModule, rc );
            }
        }
        
        if (buf)
        {
            MprAdminBufferFree(buf);
        }
        
        buf = NULL;
    }

    return NO_ERROR;
}





DWORD
CfgEnumRipIfs (
    VOID
) 
{
    DWORD                rc = NO_ERROR;
    DWORD                read, total, processed = 0, i;
    DWORD                hResume = 0;
    DWORD                sz;
    PMPR_INTERFACE_0     pRi0;
    WCHAR                IfName[ MAX_INTERFACE_NAME_LEN + 1 ];
    DWORD                dwSize = sizeof(IfName);

    DisplayIPXMessage (g_hModule, MSG_RIPIF_CFG_TABLE_HDR);
    do 
    {
        rc = MprConfigInterfaceEnum (
                g_hMprConfig, 0, (LPBYTE * ) & pRi0, MAXULONG, &read,
                &total, &hResume
                );
                
        if (rc == NO_ERROR) 
        {
            for (i = 0; i < read; i++) 
            {
                HANDLE        hIfTrCfg;

                rc = MprConfigInterfaceTransportGetHandle (
                        g_hMprConfig, pRi0[i].hInterface, PID_IPX, &hIfTrCfg
                        );
                        
                if (rc == NO_ERROR) 
                {
                    LPBYTE    pIfBlock;
                    
                    rc = MprConfigInterfaceTransportGetInfo(
                            g_hMprConfig, pRi0[i].hInterface, hIfTrCfg,
                            &pIfBlock, &sz
                            );
                            
                    if (rc == NO_ERROR) 
                    {
                        PIPX_TOC_ENTRY pRipToc;

                        pRipToc = GetIPXTocEntry(
                                    (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                                    IPX_PROTOCOL_RIP
                                    );
                                    
                        if (pRipToc != NULL) 
                        {
                            PRIP_IF_CONFIG  pRipCfg;
                            PWCHAR          buffer[2];

                            pRipCfg = (PRIP_IF_CONFIG)
                                        (pIfBlock + pRipToc->Offset);

                            //======================================
                            // Translate the Interface Name
                            //======================================

                            rc = IpmontrGetFriendlyNameFromIfName( 
                                    pRi0[i].wszInterfaceName,
                                    IfName, &dwSize
                                    );

                            if ( rc == NO_ERROR )
                            {
                                buffer[ 0 ] = GetEnumString(
                                                g_hModule, pRipCfg->RipIfInfo.AdminState,
                                                NUM_TOKENS_IN_TABLE( AdminStates ),
                                                AdminStates
                                                );

                                buffer[ 1 ] = GetEnumString(
                                                g_hModule, pRipCfg->RipIfInfo.UpdateMode,
                                                NUM_TOKENS_IN_TABLE( UpdateModes ),
                                                UpdateModes
                                                );

                                if ( buffer [ 0 ] && buffer [ 1 ] )
                                {
                                    DisplayIPXMessage(
                                        g_hModule, MSG_RIPIF_CFG_TABLE_FMT,
                                        buffer[ 0 ], buffer[ 1 ],
                                        IfName
                                        );
                                }

                                else
                                {
                                    rc = ERROR_NOT_ENOUGH_MEMORY;
                                    DisplayError( g_hModule, rc );
                                }
                            }

                            else
                            {
                                DisplayError( g_hModule, rc );
                            }
                        }
                        else 
                        {
                            DisplayIPXMessage (g_hModule, MSG_INTERFACE_INFO_CORRUPTED);
                            rc = ERROR_INVALID_DATA;
                        }
                    }
                    
                    else
                    {
                        DisplayError( g_hModule, rc);
                    }
                }
                else 
                {
                    //DisplayError( g_hModule, rc);
                }
            }
            
            processed += read;
            MprConfigBufferFree (pRi0);
        }
        else 
        {
            DisplayError( g_hModule, rc);
            break;
        }
        
    } while (processed < total);

    return rc;
}


DWORD
CfgSetRipIf (
    LPWSTR        InterfaceNameW,
    PULONG        pAdminState        OPTIONAL,
    PULONG        pAdvertise        OPTIONAL,
    PULONG        pListen            OPTIONAL,
    PULONG        pUpdateMode        OPTIONAL,
    PULONG        pInterval        OPTIONAL,
    PULONG        pAgeMultiplier    OPTIONAL,
    PWCHAR        IfName
) 
{
    DWORD        rc;
    DWORD        sz;
    HANDLE        hTrCfg;
    HANDLE        hIfCfg;
    HANDLE        hIfTrCfg;
    LPBYTE        pIfBlock;


    if (InterfaceNameW != NULL) 
    {
        rc = MprConfigInterfaceGetHandle (
                g_hMprConfig, InterfaceNameW, &hIfCfg
                );
                
        if (rc == NO_ERROR) 
        {
            rc = MprConfigInterfaceTransportGetHandle (
                    g_hMprConfig, hIfCfg, PID_IPX, &hIfTrCfg
                    );
                    
            if (rc == NO_ERROR) 
            {
                rc = MprConfigInterfaceTransportGetInfo(
                        g_hMprConfig, hIfCfg, hIfTrCfg, &pIfBlock, &sz
                        );
            }
        }
    }
    else 
    {
        rc = MprConfigTransportGetHandle (
                g_hMprConfig, PID_IPX, &hTrCfg
                );
                
        if (rc == NO_ERROR) 
        {
            rc = MprConfigTransportGetInfo (
                    g_hMprConfig, hTrCfg, NULL, NULL, &pIfBlock, &sz, NULL
                    );
        }
    }

    if (rc == NO_ERROR) 
    {
        PIPX_TOC_ENTRY pRipToc;

        pRipToc = GetIPXTocEntry (
                    (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                    IPX_PROTOCOL_RIP
                    );
                    
        if (pRipToc != NULL) 
        {
            PRIP_IF_CONFIG    pRipCfg;

            pRipCfg = (PRIP_IF_CONFIG)
                        (pIfBlock + pRipToc->Offset);

            if (ARGUMENT_PRESENT (pAdminState))
            {
                pRipCfg->RipIfInfo.AdminState = *pAdminState;
            }

            if (ARGUMENT_PRESENT (pAdvertise))
            {
                pRipCfg->RipIfInfo.Supply = *pAdvertise;
            }

            if (ARGUMENT_PRESENT (pListen))
            {
                pRipCfg->RipIfInfo.Listen = *pListen;
            }

            if (ARGUMENT_PRESENT (pUpdateMode))
            {
                pRipCfg->RipIfInfo.UpdateMode = *pUpdateMode;
            }

            if (ARGUMENT_PRESENT (pInterval))
            {
                pRipCfg->RipIfInfo.PeriodicUpdateInterval = *pInterval;
            }

            if (ARGUMENT_PRESENT (pAgeMultiplier))
            {
                pRipCfg->RipIfInfo.AgeIntervalMultiplier = *pAgeMultiplier;
            }

            if (InterfaceNameW != NULL)
            {
                rc = MprConfigInterfaceTransportSetInfo (
                        g_hMprConfig, hIfCfg, hIfTrCfg, pIfBlock, sz
                        );
            }
            
            else
            {
                rc = MprConfigTransportSetInfo (
                        g_hMprConfig, hTrCfg, NULL, 0, pIfBlock, sz, NULL
                        );
            }
            
            if (rc == NO_ERROR) 
            {
                if (InterfaceNameW != NULL)
                {
                    DisplayIPXMessage (
                        g_hModule, MSG_RIPIF_SET_CFG, IfName
                        );
                }
                
                else
                {
                    DisplayIPXMessage (
                        g_hModule, MSG_CLIENT_RIPIF_SET_CFG
                        );
                }
            }
            else
            {
                DisplayError( g_hModule, rc);
            }
        }
        else 
        {
            DisplayIPXMessage (g_hModule, MSG_INTERFACE_INFO_CORRUPTED);
            rc = ERROR_INVALID_DATA;
        }
        
        MprConfigBufferFree (pIfBlock);
    }

    else
    {
        DisplayError( g_hModule, rc);
    }

    return rc;
}


DWORD
AdmSetRipIf (
    LPWSTR        InterfaceNameW,
    PULONG        pAdminState        OPTIONAL,
    PULONG        pAdvertise        OPTIONAL,
    PULONG        pListen            OPTIONAL,
    PULONG        pUpdateMode        OPTIONAL,
    PULONG        pInterval        OPTIONAL,
    PULONG        pAgeMultiplier    OPTIONAL,
    PWCHAR        IfName
) 
{
    DWORD        rc;
    DWORD        sz;
    HANDLE        hIfAdm;
    LPBYTE        pIfBlock;

    if (InterfaceNameW != NULL) 
    {
        rc = MprAdminInterfaceGetHandle (
                g_hMprAdmin, InterfaceNameW, &hIfAdm, FALSE
                );
                
        if (rc == NO_ERROR) 
        {
            rc = MprAdminInterfaceTransportGetInfo (
                    g_hMprAdmin, hIfAdm, PID_IPX, &pIfBlock, &sz
                    );
        }
    }
    
    else 
    {
        rc = MprAdminTransportGetInfo (
                g_hMprAdmin, PID_IPX, NULL, NULL, &pIfBlock, &sz
                );
    }


    if (rc == NO_ERROR) 
    {
        PIPX_TOC_ENTRY pRipToc;

        pRipToc = GetIPXTocEntry (
                    (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                    IPX_PROTOCOL_RIP
                    );
                    
        if (pRipToc != NULL) 
        {
            PRIP_IF_CONFIG    pRipCfg;

            pRipCfg = (PRIP_IF_CONFIG)
                        (pIfBlock + pRipToc->Offset);

            if (ARGUMENT_PRESENT (pAdminState))
            {
                pRipCfg->RipIfInfo.AdminState = *pAdminState;
            }

            if (ARGUMENT_PRESENT (pAdvertise))
            {
                pRipCfg->RipIfInfo.Supply = *pAdvertise;
            }

            if (ARGUMENT_PRESENT (pListen))
            {
                pRipCfg->RipIfInfo.Listen = *pListen;
            }

            if (ARGUMENT_PRESENT (pUpdateMode))
            {
                pRipCfg->RipIfInfo.UpdateMode = *pUpdateMode;
            }

            if (ARGUMENT_PRESENT (pInterval))
            {
                pRipCfg->RipIfInfo.PeriodicUpdateInterval = *pInterval;
            }

            if (ARGUMENT_PRESENT (pAgeMultiplier))
            {
                pRipCfg->RipIfInfo.AgeIntervalMultiplier = *pAgeMultiplier;
            }

            if (InterfaceNameW != NULL)
            {
                rc = MprAdminInterfaceTransportSetInfo (
                    g_hMprAdmin,
                    hIfAdm,
                    PID_IPX,
                    pIfBlock,
                    ((PIPX_INFO_BLOCK_HEADER)pIfBlock)->Size
                    );
            }
            
            else
            {
                rc = MprAdminTransportSetInfo (
                    g_hMprAdmin,
                    PID_IPX,
                    NULL, 0,
                    pIfBlock,
                    ((PIPX_INFO_BLOCK_HEADER)pIfBlock)->Size
                    );
            }


            if (rc == NO_ERROR) 
            {
                if (InterfaceNameW != NULL)
                {
                    DisplayIPXMessage (
                        g_hModule, MSG_RIPIF_SET_ADM, IfName
                        );
                }
                else
                {
                    DisplayIPXMessage(
                        g_hModule, MSG_CLIENT_RIPIF_SET_ADM
                        );
                }
            }
            
            else
            {
                DisplayError( g_hModule, rc);
            }
        }
        else 
        {
            DisplayIPXMessage (g_hModule, MSG_INTERFACE_INFO_CORRUPTED);
            rc = ERROR_INVALID_DATA;
        }
        
        MprAdminBufferFree (pIfBlock);
    }
    else 
    {
        DisplayError( g_hModule, rc);
    }

    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ipx\protocols\sapgl.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    sapgl.h

Abstract:

    IPX Router Console Monitoring and Configuration tool.
    SAP Global configuration.

Author:

    Vadim Eydelman  06/07/1996


--*/
#ifndef _IPXMON_SAPGL_
#define _IPXMON_SAPGL_

DWORD
APIENTRY 
HelpSapGl (
    IN    int                   argc,
    IN    WCHAR                *argv[]
    );

DWORD
APIENTRY 
ShowSapGl (
    IN    int                   argc,
    IN    WCHAR                *argv[],
    IN    HANDLE                hFile
    );

DWORD
APIENTRY 
SetSapGl (
    IN    int                    argc,
    IN    WCHAR                *argv[]
    );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ipx\protocols\sapflts.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    sapflts.h

Abstract:

    IPX Router Console Monitoring and Configuration tool.
    SAP filter configuration and monitoring. Header File

Author:

    Vadim Eydelman  06/07/1996


--*/
#ifndef _IPXMON_SAPFLTS_
#define _IPXMON_SAPFLTS_

DWORD
APIENTRY 
HelpSapFlt (
    IN    int                    argc,
    IN    WCHAR                *argv[]
    );

DWORD
APIENTRY 
ShowSapFlt (
    IN    int                    argc,
    IN    WCHAR                *argv[],
    IN    HANDLE                hFile
    );

DWORD
APIENTRY 
SetSapFlt (
    IN    int                    argc,
    IN    WCHAR                *argv[]
    );

DWORD
APIENTRY 
CreateSapFlt (
    IN    int                    argc,
    IN    WCHAR                *argv[]
    );

DWORD
APIENTRY 
DeleteSapFlt (
    IN    int                    argc,
    IN    WCHAR                *argv[]
    );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ipx\protocols\sapflts.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    sapflts.c

Abstract:

    IPX Router Console Monitoring and Configuration tool.
    SAP Filters configuration and monitoring.

Author:

    Vadim Eydelman  06/07/1996


--*/
#include "precomp.h"
#pragma hdrstop

#define OPERATION_DEL_SAPFILTER    (-1)
#define OPERATION_SET_SAPFILTER    0
#define OPERATION_ADD_SAPFILTER    1


DWORD
AdmSetSapFlt(
    int                         operation,
    LPWSTR                      InterfaceNameW,
    ULONG                       Action,
    ULONG                       Mode,
    PSAP_SERVICE_FILTER_INFO    SapFilter
);

DWORD
CfgSetSapFlt (
    int                         operation,
    LPWSTR                      InterfaceNameW,
    ULONG                       Action,
    ULONG                       Mode,
    PSAP_SERVICE_FILTER_INFO    SapFilter
);

DWORD
SetSapFltAction (
    LPBYTE                      pIfBlock,
    BOOLEAN                     Output,
    ULONG                       Action
);


DWORD
APIENTRY 
HelpSapFlt (
    IN    int                   argc,
    IN    WCHAR                *argv[]
) 
{
    DisplayMessage (g_hModule, HLP_IPX_SAPFILTER);
    return 0;
}


DWORD
APIENTRY 
ShowSapFlt (
    IN    int                   argc,
    IN    WCHAR                *argv[],
    IN    HANDLE                hFile
) 
{
    DWORD        rc, i;

    if (argc > 0) 
    {
        PWCHAR      buffer[2];
        LPBYTE      pIfBlock;
        BOOLEAN     fRouter = FALSE, fClient = FALSE;
        ULONG       mode = 0;
        unsigned    count;
        WCHAR       IfName[ MAX_INTERFACE_NAME_LEN + 1 ];
        DWORD       dwSize = sizeof(IfName);
        
#define InterfaceNameW argv[0]
        count = wcslen (InterfaceNameW);

        if ( !_wcsicmp( argv[0], VAL_DIALINCLIENT ) )
        {
            fClient = TRUE;
        }
        else if ((count > 0) && (count <= MAX_INTERFACE_NAME_LEN)) 
        {
            fClient = FALSE;
        }
        else 
        {
            if ( !hFile ) { DisplayIPXMessage (g_hModule, MSG_INVALID_INTERFACE_NAME); }
            rc = ERROR_INVALID_PARAMETER;
            goto Exit;
        }

        if (argc > 1) 
        {
            UINT    n;
            
            if ( (argc == 2) && 
                 !MatchEnumTag(
                    g_hModule, argv[1], NUM_TOKENS_IN_TABLE( FilterModes ),
                    FilterModes, &mode
                    ) ) 
            {
                NOTHING;
            }
            
            else 
            {
                if ( !hFile ) { DisplayMessage (g_hModule, HLP_IPX_SAPFILTER); }
                rc = ERROR_INVALID_PARAMETER;
                goto Exit;
            }
        }

        if (g_hMprAdmin) 
        {
            if (fClient) 
            {
                DWORD   sz;

                rc = MprAdminTransportGetInfo(
                        g_hMprAdmin, PID_IPX, NULL, NULL, &pIfBlock, &sz
                        );
                        
                if (rc == NO_ERROR) 
                {
                    fRouter = TRUE;
                }
                else 
                {
                    if ( !hFile ) { DisplayError( g_hModule, rc); }
                    goto GetFromCfg;
                }
            }
            
            else 
            {
                HANDLE        hIfAdm;
                
                //======================================
                // Translate the Interface Name
                //======================================

                rc = IpmontrGetIfNameFromFriendlyName(
                        InterfaceNameW, IfName, &dwSize
                        );

                if ( rc == NO_ERROR )
                {
                    rc = MprAdminInterfaceGetHandle (
                            g_hMprAdmin, IfName, &hIfAdm, FALSE
                            );
                            
                    if (rc == NO_ERROR) 
                    {
                        DWORD   sz;
                        
                        rc = MprAdminInterfaceTransportGetInfo (
                                g_hMprAdmin, hIfAdm, PID_IPX, &pIfBlock, &sz
                                );
                    }
                    
                    if (rc == NO_ERROR)
                    {
                        fRouter = TRUE;
                    }
                    else 
                    {
                        if ( !hFile ) { DisplayError( g_hModule, rc); }
                        goto GetFromCfg;
                    }
                }
            }
        }
        
        else 
        {
        
GetFromCfg:
            if (fClient) 
            {
                HANDLE  hTrCfg;
                
                rc = MprConfigTransportGetHandle (
                        g_hMprConfig, PID_IPX, &hTrCfg
                        );
                        
                if (rc == NO_ERROR) 
                {
                    DWORD   sz;
                    
                    rc = MprConfigTransportGetInfo (
                            g_hMprConfig, hTrCfg, NULL, NULL, &pIfBlock, &sz, NULL
                            );
                }
            }
            
            else 
            {
                HANDLE        hIfCfg;

                rc = IpmontrGetIfNameFromFriendlyName(
                        InterfaceNameW, IfName, &dwSize
                        );

                if ( rc == NO_ERROR )
                {
                    rc = MprConfigInterfaceGetHandle (
                            g_hMprConfig, IfName, &hIfCfg
                            );
                            
                    if (rc == NO_ERROR) 
                    {
                        HANDLE hIfTrCfg;
                        
                        rc = MprConfigInterfaceTransportGetHandle (
                                g_hMprConfig, hIfCfg, PID_IPX, &hIfTrCfg
                                );
                                
                        if (rc == NO_ERROR) 
                        {
                            DWORD    sz;
                            rc = MprConfigInterfaceTransportGetInfo (
                                    g_hMprConfig, hIfCfg, hIfTrCfg, &pIfBlock, &sz
                                    );
                        }
                    }
                    
                    else
                    {
                        if ( !hFile ) { DisplayError( g_hModule, rc ); }
                    }
                }
                
                else
                {
                    if ( !hFile ) { DisplayError( g_hModule, rc ); }
                }
            }
        }

        
        if ( rc == NO_ERROR ) 
        {
            PIPX_TOC_ENTRY pSapToc;

            pSapToc = GetIPXTocEntry(
                        (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                        IPX_PROTOCOL_SAP
                        );
                        
            if (pSapToc != NULL) 
            {
                PSAP_IF_CONFIG  pSapCfg;
                UINT            i;

                pSapCfg = (PSAP_IF_CONFIG) (pIfBlock + pSapToc->Offset);
                
                if ((mode == 0) || (mode == OUTPUT_FILTER)) 
                {
                    if (pSapCfg->SapIfFilters.SupplyFilterCount > 0) 
                    {
                        PSAP_SERVICE_FILTER_INFO    pSapFilter =
                            &pSapCfg->SapIfFilters.ServiceFilter[0];
                             
                        buffer[ 1 ] = GetEnumString(
                                        g_hModule, pSapCfg->SapIfFilters.SupplyFilterAction,
                                        NUM_TOKENS_IN_TABLE( SapFilterActions ),
                                        SapFilterActions
                                        );
                
                        if ( buffer[ 1 ] )
                        {
                            if ( hFile )
                            {
                                DisplayMessageT(
                                    DMP_IPX_SAP_SET_FILTER, InterfaceNameW,
                                    VAL_OUTPUT, buffer[ 1 ]
                                    );
                            }

                            else
                            {
                                DisplayIPXMessage(
                                    g_hModule, MSG_SAPFILTER_TABLE_HDR,
                                    VAL_OUTPUT, buffer[ 1 ]
                                    );
                            }
                        }

                        
                        for (i = 0; i < pSapCfg->SapIfFilters.SupplyFilterCount; i++, pSapFilter++) 
                        {
                            if ( pSapFilter->ServiceName[0] )
                            {
                                WCHAR   wszServiceName[ 48 + 1 ];
                            
                                mbstowcs( wszServiceName, pSapFilter->ServiceName, 48 );
                                
                                if ( hFile )
                                {
                                    DisplayMessageT(
                                        DMP_IPX_SAP_ADD_FILTER, InterfaceNameW,
                                        VAL_OUTPUT, pSapFilter->ServiceType, 
                                        wszServiceName
                                        );
                                }

                                else
                                {
                                    DisplayIPXMessage (
                                        g_hModule, MSG_SAPFILTER_TABLE_FMT,
                                        pSapFilter->ServiceType, wszServiceName
                                        );
                                }
                            }

                            else
                            {
                                if ( hFile )
                                {
                                    DisplayMessageT(
                                        DMP_IPX_SAP_ADD_FILTER, InterfaceNameW,
                                        VAL_OUTPUT, pSapFilter->ServiceType, 
                                        VAL_ANYNAME
                                        );
                                }

                                else
                                {
                                    DisplayIPXMessage (
                                        g_hModule, MSG_SAPFILTER_TABLE_FMT,
                                        pSapFilter->ServiceType, VAL_ANYNAME
                                        );
                                }
                            }
                        }
                    }
                    
                    else 
                    {
                        if ( hFile )
                        {
                            DisplayMessageT(
                                DMP_IPX_SAP_SET_FILTER, InterfaceNameW,
                                VAL_OUTPUT, VAL_DENY
                                );
                        }

                        else
                        {
                            DisplayIPXMessage(
                                g_hModule, MSG_SAPFILTER_TABLE_HDR,
                                VAL_OUTPUT, VAL_DENY
                                );
                        }
                    }
                }

                if ((mode == 0) || (mode == INPUT_FILTER)) 
                {
                    if (pSapCfg->SapIfFilters.ListenFilterCount > 0) 
                    {
                        PWCHAR  bufferW = NULL;
                        
                        PSAP_SERVICE_FILTER_INFO pSapFilter
                             = &pSapCfg->SapIfFilters.ServiceFilter[
                                            pSapCfg->SapIfFilters.SupplyFilterCount
                                            ];

                        buffer[ 1 ] = GetEnumString(
                                        g_hModule, pSapCfg->SapIfFilters.ListenFilterAction,
                                        NUM_TOKENS_IN_TABLE( SapFilterActions ),
                                        SapFilterActions
                                        );

                
                        if ( buffer[ 1 ] )
                        {
                            if ( hFile )
                            {
                                DisplayMessageT(
                                    DMP_IPX_SAP_SET_FILTER, InterfaceNameW,
                                    VAL_INPUT, buffer[ 1 ]
                                    );
                            }

                            else
                            {
                                DisplayIPXMessage(
                                    g_hModule, MSG_SAPFILTER_TABLE_HDR,
                                    VAL_INPUT, buffer[1]
                                    );
                            }
                        }

                        for ( i = 0; 
                              i < pSapCfg->SapIfFilters.ListenFilterCount; 
                              i++, pSapFilter++ ) 
                        {
                            if ( pSapFilter->ServiceName[0] )
                            {
                                WCHAR   wszServiceName[ 48 + 1 ];
                            
                                mbstowcs( wszServiceName, pSapFilter->ServiceName, 48 );
                                
                                if ( hFile )
                                {
                                    DisplayMessageT(
                                        DMP_IPX_SAP_ADD_FILTER, InterfaceNameW,
                                        VAL_INPUT, pSapFilter->ServiceType, 
                                        wszServiceName
                                        );
                                }

                                else
                                {
                                    DisplayIPXMessage (
                                        g_hModule, MSG_SAPFILTER_TABLE_FMT,
                                        pSapFilter->ServiceType, wszServiceName
                                        );
                                }
                            }

                            else
                            {
                                if ( hFile )
                                {
                                    DisplayMessageT(
                                        DMP_IPX_SAP_ADD_FILTER, InterfaceNameW,
                                        VAL_INPUT, pSapFilter->ServiceType, 
                                        VAL_ANYNAME
                                        );
                                }

                                else
                                {
                                    DisplayIPXMessage (
                                        g_hModule, MSG_SAPFILTER_TABLE_FMT,
                                        pSapFilter->ServiceType, VAL_ANYNAME
                                        );
                                }
                            }
                        }
                    }
                    
                    else 
                    {
                        if ( hFile )
                        {
                            DisplayMessageT(
                                DMP_IPX_SAP_SET_FILTER, InterfaceNameW,
                                VAL_INPUT, VAL_DENY
                                );
                        }

                        else
                        {
                            DisplayIPXMessage(
                                g_hModule, MSG_SAPFILTER_TABLE_HDR,
                                VAL_INPUT, VAL_DENY
                                );
                        }
                    }
                }
            }
            else 
            {
                rc = ERROR_FILE_NOT_FOUND;
                if ( !hFile ) { DisplayError( g_hModule, rc); }
            }
            
            if (fRouter)
            {
                MprAdminBufferFree (pIfBlock);
            }
            else
            {
                MprConfigBufferFree (pIfBlock);
            }
        }
        else
        {
            if ( !hFile ) { DisplayError( g_hModule, rc); }
        }
    }
    
    else 
    {
        if ( !hFile ) { DisplayMessage (g_hModule, HLP_IPX_SAPFILTER); }
        rc = ERROR_INVALID_PARAMETER;
    }

Exit:

    return rc;
    
#undef InterfaceNameW
}


VOID
ConvertToUpper(
    OUT UCHAR   *strDst,
    IN UCHAR    *strSrc,
    IN DWORD    count
) 
{

    DWORD i;

    for (i = 0; i < count; i++)
    {
#if defined(UNICODE) || defined (_UNICODE)

    strDst[i] = (UCHAR)toupper(strSrc[i]);
    
#else

    strDst[i] = (UCHAR)toupper(strSrc[i]);
    
#endif
    }
}


DWORD
APIENTRY 
CreateSapFlt (
    IN    int                    argc,
    IN    WCHAR                *argv[]
) 
{
    DWORD rc;
    

    if ( argc == 4 ) 
    {
        PWCHAR                  buffer = NULL;
        ULONG                   mode;
        UINT                    n;
        SAP_SERVICE_FILTER_INFO SapFilter;
        BOOLEAN                 fClient;
        unsigned                count;

        
#define InterfaceNameW argv[0]
        count = wcslen (InterfaceNameW);

        if ( !_wcsicmp( argv[0], VAL_DIALINCLIENT ) ) 
        {
            fClient = TRUE;
        }
        else if ((count > 0) && (count <= MAX_INTERFACE_NAME_LEN)) 
        {
            fClient = FALSE;
        }
        else 
        {
            DisplayIPXMessage (g_hModule, MSG_INVALID_INTERFACE_NAME);
            rc = ERROR_INVALID_PARAMETER;
            goto Exit;
        }


        if ( !MatchEnumTag( g_hModule, argv[1], NUM_TOKENS_IN_TABLE( FilterModes ),
                FilterModes, &mode ) && 
             ( swscanf (argv[2], L"%4hx%n", &SapFilter.ServiceType, &n) == 1 ) &&
             ( n == wcslen (argv[2]) ) ) 
        {

            count = wcstombs(
                        SapFilter.ServiceName, 
                        argv[3], sizeof(SapFilter.ServiceName)
                        );

            if ( (count > 0) && (count < sizeof (SapFilter.ServiceName)) ) 
            {

                ConvertToUpper(SapFilter.ServiceName, SapFilter.ServiceName, count);

                if (strcmp (SapFilter.ServiceName, "*") == 0)
                {
                    SapFilter.ServiceName[0] = 0;
                }

                if (g_hMprAdmin)
                {
                    rc = AdmSetSapFlt(
                            OPERATION_ADD_SAPFILTER,
                            fClient ? NULL : InterfaceNameW,
                            IPX_SERVICE_FILTER_PERMIT,
                            mode, &SapFilter
                            );
                }
                else
                {
                    rc = NO_ERROR;
                }
                
                if (rc == NO_ERROR)
                {
                    rc = CfgSetSapFlt (
                            OPERATION_ADD_SAPFILTER,
                            fClient ? NULL : InterfaceNameW,
                            IPX_SERVICE_FILTER_PERMIT,
                            mode, &SapFilter
                            );
                }
            }
            else 
            {
                rc = ERROR_INVALID_PARAMETER;
                DisplayMessage (g_hModule, HLP_IPX_SAPFILTER);
            }
        }
        else 
        {
            rc = ERROR_INVALID_PARAMETER;
            DisplayMessage (g_hModule, HLP_IPX_SAPFILTER);
        }
    }
    else 
    {
        DisplayMessage (g_hModule, HLP_IPX_SAPFILTER);
        rc = ERROR_INVALID_PARAMETER;
    }
    
Exit:
    return rc;
    
#undef InterfaceNameW
}


DWORD
APIENTRY 
SetSapFlt (
    IN    int                   argc,
    IN    WCHAR                *argv[]
) 
{
    DWORD   rc;
    
    if (argc == 3) 
    {
        PWCHAR                  buffer = NULL;
        ULONG                   mode, action;
        UINT                    n;
        SAP_SERVICE_FILTER_INFO SapFilter;
        BOOLEAN                 fClient;
        unsigned                count;

        
#define InterfaceNameW argv[0]
        count = wcslen (InterfaceNameW);


        if ( !_wcsicmp( argv[0], VAL_DIALINCLIENT ) ) 
        {
            fClient = TRUE;
        }
        else if ((count > 0) && (count <= MAX_INTERFACE_NAME_LEN)) 
        {
            fClient = FALSE;
        }
        else 
        {
            DisplayIPXMessage (g_hModule, MSG_INVALID_INTERFACE_NAME);
            rc = ERROR_INVALID_PARAMETER;
            goto Exit;
        }
        
        if ( !MatchEnumTag(
                g_hModule, argv[1], NUM_TOKENS_IN_TABLE( FilterModes ), FilterModes, &mode
                ) &&
             !MatchEnumTag(
                g_hModule, argv[2], NUM_TOKENS_IN_TABLE( SapFilterActions ), 
                SapFilterActions, &action
                ) ) 
        {

            if ( g_hMprAdmin )
            {
                rc = AdmSetSapFlt (
                        OPERATION_SET_SAPFILTER,
                        fClient ? NULL : InterfaceNameW,
                        action, mode, NULL
                        );
            }
            
            else
            {
                rc = NO_ERROR;
            }
            
            if (rc == NO_ERROR)
            {
                rc = CfgSetSapFlt(
                        OPERATION_SET_SAPFILTER,
                        fClient ? NULL : InterfaceNameW,
                        action, mode, NULL
                        );
            }
        }
        else 
        {
            rc = ERROR_INVALID_PARAMETER;
            DisplayMessage (g_hModule, HLP_IPX_SAPFILTER);
        }
    }

    else 
    {
        DisplayMessage (g_hModule, HLP_IPX_SAPFILTER);
        rc = ERROR_INVALID_PARAMETER;
    }

Exit:
    return rc;
    
#undef InterfaceNameW
}


DWORD
APIENTRY 
DeleteSapFlt (
    IN    int                   argc,
    IN    WCHAR                *argv[]
) 
{
    DWORD   rc;
    
    if (argc == 4) 
    {
        ULONG                   mode;
        UINT                    n;
        SAP_SERVICE_FILTER_INFO SapFilter;
        BOOLEAN                 fClient;
        unsigned                count;
        
#define InterfaceNameW argv[0]
        count = wcslen( InterfaceNameW );

        if ( !_wcsicmp( argv[0], VAL_DIALINCLIENT ) ) 
        {
            fClient = TRUE;
        }
        else if ((count > 0) && (count <= MAX_INTERFACE_NAME_LEN)) 
        {
            fClient = FALSE;
        }
        else 
        {
            DisplayIPXMessage (g_hModule, MSG_INVALID_INTERFACE_NAME);
            rc = ERROR_INVALID_PARAMETER;
            goto Exit;
        }


        if ( !MatchEnumTag (g_hModule, argv[1], NUM_TOKENS_IN_TABLE( FilterModes ),
                FilterModes, &mode ) && 
             ( swscanf (argv[2], L"%4hx%n", &SapFilter.ServiceType, &n) == 1 ) && 
             ( n == wcslen (argv[2])) ) 
        {

            count = wcstombs(
                        SapFilter.ServiceName, argv[3], sizeof(SapFilter.ServiceName)
                        );

            if ( (count > 0) && (count < sizeof (SapFilter.ServiceName)) ) 
            {
                ConvertToUpper(SapFilter.ServiceName, SapFilter.ServiceName, count);

                if (strcmp (SapFilter.ServiceName, "*") == 0)
                {
                    SapFilter.ServiceName[0] = 0;
                }

                if (g_hMprAdmin)
                {
                    rc = AdmSetSapFlt(
                            OPERATION_DEL_SAPFILTER, fClient ? NULL : InterfaceNameW,
                            IPX_SERVICE_FILTER_PERMIT, mode, &SapFilter
                            );
                }
                else
                {
                    rc = NO_ERROR;
                }
                
                if (rc == NO_ERROR)
                {
                    rc = CfgSetSapFlt(
                            OPERATION_DEL_SAPFILTER, fClient ? NULL : InterfaceNameW,
                            IPX_SERVICE_FILTER_PERMIT, mode, &SapFilter
                            );
                }
            }
            else 
            {
                rc = ERROR_INVALID_PARAMETER;
                DisplayMessage (g_hModule, HLP_IPX_SAPFILTER);
            }
        }
        else 
        {
            rc = ERROR_INVALID_PARAMETER;
            DisplayMessage (g_hModule, HLP_IPX_SAPFILTER);
        }
    }
    
    else 
    {
        DisplayMessage (g_hModule, HLP_IPX_SAPFILTER);
        rc = ERROR_INVALID_PARAMETER;
    }
    
Exit:

    return rc;
    
#undef InterfaceNameW
}


DWORD
AdmSetSapFlt (
    int                         operation,
    LPWSTR                      InterfaceNameW,
    ULONG                       Action,
    ULONG                       Mode,
    PSAP_SERVICE_FILTER_INFO    SapFilter
) 
{
    DWORD        rc;
    HANDLE       hIfAdm;
    LPBYTE       pIfBlock;
    DWORD        sz;
    WCHAR        IfName[ MAX_INTERFACE_NAME_LEN + 1 ];
    DWORD        dwSize = sizeof(IfName);

    if (InterfaceNameW != NULL) 
    {
        //======================================
        // Translate the Interface Name
        //======================================

        rc = IpmontrGetIfNameFromFriendlyName(
                InterfaceNameW, IfName, &dwSize
                );
                
        if ( rc == NO_ERROR )
        {
            rc = MprAdminInterfaceGetHandle (
                    g_hMprAdmin, IfName, &hIfAdm, FALSE
                    );
                    
            if (rc == NO_ERROR) 
            {
                rc = MprAdminInterfaceTransportGetInfo (
                        g_hMprAdmin, hIfAdm, PID_IPX, &pIfBlock, &sz
                        );
            }
        }
    }
    else 
    {
        rc = MprAdminTransportGetInfo (
                g_hMprAdmin, PID_IPX, NULL, NULL, &pIfBlock, &sz
                );
    }
    

    if (rc == NO_ERROR) 
    {
        UINT        msg;
        LPBYTE      pNewBlock;

        switch (operation) 
        {
            case OPERATION_ADD_SAPFILTER:
            
                rc = UpdateSapFilter (
                        (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                        (BOOLEAN)(Mode == OUTPUT_FILTER),
                        NULL, SapFilter,
                        (PIPX_INFO_BLOCK_HEADER * ) & pNewBlock
                        );
                        
                if (InterfaceNameW != NULL)
                {
                    msg = MSG_SAPFILTER_CREATED_ADM;
                }
                else
                {
                    msg = MSG_SAPFILTER_CREATED_ADM;
                }

                break;
                
            case OPERATION_SET_SAPFILTER:

                rc = SetSapFltAction (
                        pIfBlock, (BOOLEAN)(Mode == OUTPUT_FILTER), Action
                        );
                        
                if (InterfaceNameW != NULL)
                {
                    msg = MSG_SAPFILTER_SET_ADM;
                }
                else
                {
                    msg = MSG_CLIENT_SAPFILTER_SET_ADM;
                }
                
                pNewBlock = pIfBlock;
                break;
                
            case OPERATION_DEL_SAPFILTER:
            
                rc = UpdateSapFilter (
                        (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                        (BOOLEAN)(Mode == OUTPUT_FILTER),
                        SapFilter, NULL, 
                        (PIPX_INFO_BLOCK_HEADER * ) & pNewBlock
                        );
                        
                if (InterfaceNameW != NULL)
                {
                    msg = MSG_SAPFILTER_DELETED_ADM;
                }
                else
                {
                    msg = MSG_CLIENT_SAPFILTER_DELETED_ADM;
                }
                
                break;
            }

        if (rc == NO_ERROR) 
        {
            if (InterfaceNameW != NULL)
            {
                rc = MprAdminInterfaceTransportSetInfo (
                        g_hMprAdmin, hIfAdm, PID_IPX, pNewBlock, 
                        ((PIPX_INFO_BLOCK_HEADER)pNewBlock)->Size
                        );
            }
            
            else
            {
                rc = MprAdminTransportSetInfo (
                        g_hMprAdmin, PID_IPX, NULL, 0, pNewBlock,
                        ((PIPX_INFO_BLOCK_HEADER)pNewBlock)->Size
                        );
            }
            
            if (pNewBlock != pIfBlock)
            {
                GlobalFree (pNewBlock);
            }
            
            if (rc == NO_ERROR)
            {
                DisplayIPXMessage (g_hModule, msg, InterfaceNameW);
            }
            else
            {
                DisplayError( g_hModule, rc);
            }
        }
        
        else
        {
            DisplayError( g_hModule, rc);
        }

        MprAdminBufferFree (pIfBlock);
    }
    
    else
    {
        DisplayError( g_hModule, rc);
    }

    return rc;
}


DWORD
CfgSetSapFlt (
    int                         operation,
    LPWSTR                      InterfaceNameW,
    ULONG                       Action,
    ULONG                       Mode,
    PSAP_SERVICE_FILTER_INFO    SapFilter
) 
{
    DWORD       rc;
    HANDLE      hIfCfg;
    HANDLE      hIfTrCfg;
    HANDLE      hTrCfg;
    LPBYTE      pIfBlock;
    DWORD       sz;
    WCHAR       IfName[ MAX_INTERFACE_NAME_LEN + 1 ];
    DWORD       dwSize = sizeof(IfName);

    if (InterfaceNameW != NULL) 
    {
        //======================================
        // Translate the Interface Name
        //======================================
        
        rc = IpmontrGetIfNameFromFriendlyName(
                InterfaceNameW, IfName, &dwSize
                );
                
        if ( rc == NO_ERROR )
        {
            rc = MprConfigInterfaceGetHandle(
                    g_hMprConfig, IfName, &hIfCfg
                    );
        }
    
        if (rc == NO_ERROR) 
        {
            rc = MprConfigInterfaceTransportGetHandle (
                    g_hMprConfig, hIfCfg, PID_IPX, &hIfTrCfg
                    );
                    
            if (rc == NO_ERROR)
            {
                rc = MprConfigInterfaceTransportGetInfo(
                        g_hMprConfig, hIfCfg, hIfTrCfg, &pIfBlock, &sz
                        );
            }
        }
    }
    
    else 
    {
        rc = MprConfigTransportGetHandle (
                g_hMprConfig, PID_IPX, &hTrCfg
                );
                
        if (rc == NO_ERROR) 
        {
            rc = MprConfigTransportGetInfo (
                    g_hMprConfig, hTrCfg, NULL, NULL, &pIfBlock, &sz, NULL
                    );
        }
    }
    

    if (rc == NO_ERROR) 
    {
        UINT    msg;
        LPBYTE  pNewBlock;

        switch (operation) 
        {
        case OPERATION_ADD_SAPFILTER:
        
            rc = UpdateSapFilter (
                    (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                    (BOOLEAN)(Mode == OUTPUT_FILTER),
                    NULL, SapFilter,
                    (PIPX_INFO_BLOCK_HEADER * ) & pNewBlock
                    );
                    
            if (InterfaceNameW != NULL)
            {
                msg = MSG_SAPFILTER_CREATED_ADM;
            }
            else
            {
                msg = MSG_CLIENT_SAPFILTER_CREATED_ADM;
            }
            
            break;
            
        case OPERATION_SET_SAPFILTER:

            rc = SetSapFltAction (
                    pIfBlock, (BOOLEAN)(Mode == OUTPUT_FILTER), Action
                    );
                    
            if (InterfaceNameW != NULL)
            {
                msg = MSG_SAPFILTER_SET_ADM;
            }
            else
            {
                msg = MSG_CLIENT_SAPFILTER_SET_ADM;
            }
            
            pNewBlock = pIfBlock;
            break;
            
        case OPERATION_DEL_SAPFILTER:

            rc = UpdateSapFilter(
                    (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                    (BOOLEAN)(Mode == OUTPUT_FILTER),
                    SapFilter, NULL,
                    (PIPX_INFO_BLOCK_HEADER * ) & pNewBlock
                    );
                    
            if (InterfaceNameW != NULL)
            {
                msg = MSG_SAPFILTER_DELETED_ADM;
            }
            else
            {
                msg = MSG_CLIENT_SAPFILTER_DELETED_ADM;
            }
            
            break;
        }


        if (rc == NO_ERROR) 
        {
            if (InterfaceNameW != NULL)
            {
                rc = MprConfigInterfaceTransportSetInfo (
                        g_hMprConfig, hIfCfg, hIfTrCfg, pNewBlock,
                        ((PIPX_INFO_BLOCK_HEADER)pNewBlock)->Size
                        );
            }
            
            else
            {
                rc = MprConfigTransportSetInfo (
                        g_hMprConfig, hTrCfg, NULL, 0, pNewBlock,
                        ((PIPX_INFO_BLOCK_HEADER)pNewBlock)->Size,
                        NULL
                        );
            }
            
            if (pNewBlock != pIfBlock)
            {
                GlobalFree (pNewBlock);
            }
            
            if (rc == NO_ERROR)
            {
                DisplayIPXMessage (g_hModule, msg, InterfaceNameW);
            }
            else
            {
                DisplayError( g_hModule, rc);
            }
        }
        else
        {
            DisplayError( g_hModule, rc);
        }

        MprConfigBufferFree (pIfBlock);
    }
    
    else
    {
        DisplayError( g_hModule, rc);
    }

    return rc;
}


DWORD
SetSapFltAction (
    LPBYTE          pIfBlock,
    BOOLEAN         Output,
    ULONG           Action
) 
{
    DWORD           rc;
    PIPX_TOC_ENTRY  pSapToc;

    pSapToc = GetIPXTocEntry (
                (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                IPX_PROTOCOL_SAP
                );
                
    if (pSapToc != NULL) 
    {
        PSAP_IF_CONFIG    pSapCfg;

        pSapCfg = (PSAP_IF_CONFIG)
                    (pIfBlock + pSapToc->Offset);
                    
        if (Output)
        {
            pSapCfg->SapIfFilters.SupplyFilterAction = Action;
        }
        else
        {
            pSapCfg->SapIfFilters.ListenFilterAction = Action;
        }
        
        rc = NO_ERROR;
    }
    
    else
    {
        rc = ERROR_INVALID_DATA;
    }

    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ipx\protocols\sapgl.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    sapgl.c

Abstract:

    IPX Router Console Monitoring and Configuration tool.
    SAP Global configuration.

Author:

    Vadim Eydelman  06/07/1996


--*/
#include "precomp.h"
#pragma hdrstop


DWORD
CfgSetSapGlInfo(
    IN DWORD    *pLogLevel OPTIONAL
);

DWORD
AdmSetSapGlInfo (
    IN DWORD    *pLogLevel OPTIONAL
);


DWORD
APIENTRY 
HelpSapGl (
    IN    int                   argc,
    IN    WCHAR                *argv[]
) 
{
    DisplayMessage (g_hModule, HLP_IPX_SAPGL);
    return 0;
}


DWORD
APIENTRY 
ShowSapGl (
    IN    int                   argc,
    IN    WCHAR                *argv[],
    IN    HANDLE                hFile
) 
{
    DWORD       rc;
    LPBYTE      pGlBlock;
    DWORD       sz;
    HANDLE      hTrCfg = NULL;

    if (g_hMprAdmin) 
    {
        rc = MprAdminTransportGetInfo(
                g_hMprAdmin, PID_IPX, &pGlBlock, &sz, NULL, NULL
                );
                
        if (rc == NO_ERROR)
        {
        }
        else
        {
            goto GetFromCfg;
        }
    }
    
    else 
    {
GetFromCfg:

        rc = MprConfigTransportGetHandle (
                g_hMprConfig, PID_IPX, &hTrCfg
                );
                
        if (rc == NO_ERROR) 
        {
            rc = MprConfigTransportGetInfo (
                    g_hMprConfig, hTrCfg, &pGlBlock, &sz, NULL, NULL, NULL
                    );
        }
    }


    if (rc == NO_ERROR) 
    {
        PIPX_TOC_ENTRY pSapGlToc;

        pSapGlToc = GetIPXTocEntry (
                        (PIPX_INFO_BLOCK_HEADER)pGlBlock,
                        IPX_PROTOCOL_SAP
                        );
                        
        if ( pSapGlToc != NULL ) 
        {
            PSAP_GLOBAL_INFO    pSapGlInfo;
            PWCHAR              buffer;

            pSapGlInfo = (PSAP_GLOBAL_INFO)
                            (pGlBlock + pSapGlToc->Offset);

            buffer = GetEnumString(
                        g_hModule, pSapGlInfo->EventLogMask,
                        NUM_TOKENS_IN_TABLE( LogLevels ),
                        LogLevels
                        );

            if ( buffer )
            {
                if ( hFile )
                {
                    DisplayMessageT( DMP_IPX_SAP_SET_GLOBAL, buffer );
                }

                else
                {
                    DisplayIPXMessage(
                        g_hModule, MSG_SAP_GLOBAL_FMT,buffer
                        );
                }
            }
        }
        else 
        {
            if ( !hFile ) { DisplayIPXMessage (g_hModule, MSG_ROUTER_INFO_CORRUPTED); }
            rc = ERROR_INVALID_DATA;
        }
        
        if (hTrCfg != NULL)
        {
            MprConfigBufferFree (pGlBlock);
        }
        
        else
        {
            MprAdminBufferFree (pGlBlock);
        }
    }
    
    else
    {
        if ( !hFile ) { DisplayError( g_hModule, rc ); }
    }

    return rc;
}


DWORD
APIENTRY 
SetSapGl(
    IN    int                   argc,
    IN    WCHAR                *argv[]
) 
{
    DWORD        rc;

    if (argc >= 1) 
    {
        int         i;
        unsigned    n;
        DWORD       logLevel;
        DWORD       *pLogLevel = NULL;


        for (i = 0; i < argc; i++) 
        {
            if ( !_wcsicmp (argv[i], TOKEN_LOGLEVEL ) )
            {
                if ( (pLogLevel == NULL) && (i < argc - 1) && 
                     !MatchEnumTag( g_hModule,  argv[i+1], NUM_TOKENS_IN_TABLE( LogLevels ),
                        LogLevels, &logLevel ) ) 
                {
                    i += 1;
                    pLogLevel = &logLevel;
                    continue;
                }
                else
                {
                    break;
                }
            }
            
            if (pLogLevel == NULL) 
            {
                if ( !MatchEnumTag( g_hModule, argv[i], NUM_TOKENS_IN_TABLE( LogLevels ),
                        LogLevels, &logLevel ) ) 
                {
                    pLogLevel = &logLevel;
                }
                else
                {
                    break;
                }
            }
        }
        
        if (i == argc) 
        {
            rc = CfgSetSapGlInfo (pLogLevel);

            if (rc == NO_ERROR) 
            {
                if (g_hMprAdmin)
                {
                    AdmSetSapGlInfo (pLogLevel);
                }
            }
        }
        else 
        {
            DisplayMessage (g_hModule, HLP_IPX_SAPGL);
            rc = ERROR_INVALID_PARAMETER;
        }
    }
    else 
    {
        DisplayMessage (g_hModule, HLP_IPX_SAPGL);
        rc = ERROR_INVALID_PARAMETER;
    }
    
    return rc;
}





DWORD
CfgSetSapGlInfo (
    IN DWORD    *pLogLevel OPTIONAL
) 
{
    DWORD   rc;
    HANDLE  hTrCfg;

    rc = MprConfigTransportGetHandle (
            g_hMprConfig, PID_IPX, &hTrCfg
            );
            
    if (rc == NO_ERROR) 
    {
        DWORD   sz;
        LPBYTE  pGlBlock;

        rc = MprConfigTransportGetInfo (
                g_hMprConfig, hTrCfg, &pGlBlock, &sz, NULL, NULL, NULL
                );
                
        if (rc == NO_ERROR) 
        {
            PIPX_TOC_ENTRY pSapGlToc;

            pSapGlToc = GetIPXTocEntry (
                            (PIPX_INFO_BLOCK_HEADER)pGlBlock,
                            IPX_PROTOCOL_SAP
                            );
                            
            if (pSapGlToc != NULL) 
            {
                PSAP_GLOBAL_INFO    pSapGlInfo;

                pSapGlInfo = (PSAP_GLOBAL_INFO)
                                (pGlBlock + pSapGlToc->Offset);
                                
                if (pLogLevel)
                {
                    pSapGlInfo->EventLogMask = *pLogLevel;
                }
                
                rc = MprConfigTransportSetInfo (
                        g_hMprConfig, hTrCfg, pGlBlock, sz, NULL, 0, NULL
                        );
                        
                if (rc == NO_ERROR) 
                {
                    DisplayIPXMessage (g_hModule, MSG_SAPGL_SET_CFG );
                }
                else
                {
                    DisplayError( g_hModule, rc );
                }
            }
            else 
            {
                DisplayIPXMessage (g_hModule, MSG_ROUTER_INFO_CORRUPTED);
                rc = ERROR_INVALID_DATA;
            }
            
            MprConfigBufferFree (pGlBlock);
        }
        else
        {
            DisplayError( g_hModule, rc);
        }
    }
    else
    {
        DisplayError( g_hModule, rc );
    }

    return rc;
}




DWORD
AdmSetSapGlInfo (
IN DWORD    *pLogLevel OPTIONAL
) 
{
    DWORD    rc;
    LPBYTE    pGlBlock;
    DWORD   sz;

    rc = MprAdminTransportGetInfo(
            g_hMprAdmin, PID_IPX, &pGlBlock, &sz, NULL, NULL
            );
            
    if (rc == NO_ERROR) 
    {
        PIPX_TOC_ENTRY pSapGlToc;

        pSapGlToc = GetIPXTocEntry (
                        (PIPX_INFO_BLOCK_HEADER)pGlBlock,
                        IPX_PROTOCOL_SAP
                        );
                        
        if (pSapGlToc != NULL) 
        {
            PSAP_GLOBAL_INFO    pSapGlInfo;

            pSapGlInfo = (PSAP_GLOBAL_INFO)
                            (pGlBlock + pSapGlToc->Offset);
                            
            if (pLogLevel)
            {
                pSapGlInfo->EventLogMask = *pLogLevel;
            }

            rc = MprAdminTransportSetInfo(
                    g_hMprAdmin, PID_IPX, pGlBlock, sz, NULL, 0
                    );

            if (rc == NO_ERROR) 
            {
                DisplayIPXMessage (g_hModule, MSG_SAPGL_SET_ADM );
            }
            else
            {
                DisplayError( g_hModule, rc);
            }
        }
        
        else 
        {
            DisplayIPXMessage (g_hModule, MSG_ROUTER_INFO_CORRUPTED);
            rc = ERROR_INVALID_DATA;
        }

        MprConfigBufferFree (pGlBlock);
    }

    else
    {
        DisplayError( g_hModule, rc);
    }

    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ipx\protocols\sapifs.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    sapifs.h

Abstract:

    IPX Router Console Monitoring and Configuration tool.
    SAP Interface configuration and monitoring. Header File

Author:

    Vadim Eydelman  06/07/1996


--*/
#ifndef _IPXMON_SAPIFS_
#define _IPXMON_SAPIFS_

DWORD
APIENTRY 
HelpSapIf (
    IN    int                   argc,
    IN    WCHAR                *argv[]
    );

DWORD
APIENTRY 
ShowSapIf (
    IN    int                   argc,
    IN    WCHAR                *argv[],
    IN    HANDLE                hFile
    );

DWORD
APIENTRY 
SetSapIf (
    IN    int                   argc,
    IN    WCHAR                *argv[]
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ipx\protocols\sapifs.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    sapifs.c

Abstract:

    IPX Router Console Monitoring and Configuration tool.
    SAP Interface configuration and monitoring.

Author:

    Vadim Eydelman  06/07/1996


--*/

#include "precomp.h"
#pragma hdrstop

DWORD
MIBGetSapIf(
    PWCHAR      InterfaceNamew,
    HANDLE      hFile
);

DWORD
CfgGetSapIf (
    PWCHAR      InterfaceNameW,
    HANDLE      hFile
);

DWORD
MIBEnumSapIfs (
    VOID
);

DWORD
CfgEnumSapIfs (
    VOID
);

DWORD
CfgSetSapIf (
    LPWSTR        InterfaceNameW,
    PULONG        pAdminState        OPTIONAL,
    PULONG        pAdvertise        OPTIONAL,
    PULONG        pListen            OPTIONAL,
    PULONG        pReply            OPTIONAL,
    PULONG        pUpdateMode        OPTIONAL,
    PULONG        pInterval        OPTIONAL,
    PULONG        pAgeMultiplier    OPTIONAL
);

DWORD
AdmSetSapIf (
    LPWSTR        InterfaceNameW,
    PULONG        pAdminState        OPTIONAL,
    PULONG        pUpdateMode        OPTIONAL,
    PULONG        pInterval        OPTIONAL,
    PULONG        pAdvertise        OPTIONAL,
    PULONG        pListen            OPTIONAL,
    PULONG        pReply            OPTIONAL,
    PULONG        pAgeMultiplier    OPTIONAL
);

DWORD
GetSapClientIf (
    PWCHAR        InterfaceNameW,
    UINT          msg,
    HANDLE        hFile
);


DWORD
APIENTRY 
HelpSapIf (
    IN    int                   argc,
    IN    WCHAR                *argv[]
) 
{
    DisplayMessage (g_hModule, HLP_IPX_SAPIF);
    return 0;
}


DWORD
APIENTRY 
ShowSapIf (
    IN    int                   argc,
    IN    WCHAR                *argv[],
    IN    HANDLE                hFile
) 
{
    WCHAR   IfName[ MAX_INTERFACE_NAME_LEN + 1 ];
    DWORD   rc, dwSize = sizeof(IfName);

    
    if (argc < 1) 
    {
        if (g_hMIBServer) 
        {
            rc = MIBEnumSapIfs ();
            
            if (rc == NO_ERROR)
            {
                rc = GetSapClientIf (
                        VAL_DIALINCLIENT,
                        MSG_CLIENT_SAPIF_MIB_TABLE_FMT,
                        NULL
                        );
            }
            else
            {
                goto EnumerateThroughCfg;
            }
        }
        else 
        {
EnumerateThroughCfg:

            rc = CfgEnumSapIfs ();
            
            if (rc == NO_ERROR)
            {
                rc = GetSapClientIf(
                        VAL_DIALINCLIENT,
                        MSG_CLIENT_SAPIF_CFG_TABLE_FMT,
                        NULL
                        );
            }
        }
    }

    else 
    {
        unsigned    count;

#define InterfaceNameW argv[0]
        count = wcslen( InterfaceNameW );


        if ( !_wcsicmp( argv[0], VAL_DIALINCLIENT ) )
        {
            rc = GetSapClientIf(
                    VAL_DIALINCLIENT, MSG_CLIENT_SAPIF_CFG_SCREEN_FMT, hFile
                    );
        }
        
        else if ((count > 0) && (count <= MAX_INTERFACE_NAME_LEN)) 
        {
            if (g_hMIBServer) 
            {
                //======================================
                // Translate the Interface Name
                //======================================

                rc = IpmontrGetIfNameFromFriendlyName(
                        InterfaceNameW, IfName, &dwSize
                        );

                if ( rc == NO_ERROR )
                {
                    rc = MIBGetSapIf (IfName, hFile);
                    if (rc != NO_ERROR) 
                    {
                        goto GetIfFromCfg;
                    }
                }
                
                else
                {
                    if (!hFile) { DisplayError( g_hModule, rc ); }
                }
            }
            else 
            {
GetIfFromCfg:
                //======================================
                // Translate the Interface Name
                //======================================
                
                rc = IpmontrGetIfNameFromFriendlyName(
                        InterfaceNameW, IfName, &dwSize
                        );

                if ( rc == NO_ERROR )
                {
                    rc = CfgGetSapIf (IfName, hFile);
                }
                
                else
                {
                    if ( !hFile ) { DisplayError( g_hModule, rc ); }
                }
            }
        }
        
        else 
        {
            if ( !hFile ) { DisplayIPXMessage (g_hModule, MSG_INVALID_INTERFACE_NAME); }
            rc = ERROR_INVALID_PARAMETER;
        }
    }

    return rc;
    
#undef InterfaceNameW
}


DWORD
APIENTRY 
SetSapIf (
    IN    int                   argc,
    IN    WCHAR                *argv[]
) 
{
    LPWSTR      InterfaceNameW;
    WCHAR       IfName[ MAX_INTERFACE_NAME_LEN + 1 ];
    DWORD       rc, dwSize = sizeof(IfName);


    if ( argc >= 1 ) 
    {
        unsigned    count;
        BOOLEAN     client = FALSE;

#define InterfaceNameW argv[0]

        if ( !_wcsicmp( argv[0], VAL_DIALINCLIENT ) )
        {
            client = TRUE;
        }
        else
        {
            count = wcslen (InterfaceNameW);
        }


        if (client || ((count > 0) && (count <= MAX_INTERFACE_NAME_LEN))) 
        {
            int         i;
            unsigned    n;
            ULONG       adminState, updateMode, interval, ageMultiplier,
                        advertise, listen, reply;
            PULONG      pAdminState = NULL, pUpdateMode = NULL, pInterval = NULL,
                        pAgeMultiplier = NULL, pAdvertise = NULL, pListen = NULL,
                        pReply = NULL;
                        

            for (i = 1; i < argc; i++) 
            {
                if ( !_wcsicmp( argv[i],  TOKEN_ADMINSTATE)) 
                {
                    if ( (pAdminState == NULL) && (i < argc - 1) &&
                         !MatchEnumTag(g_hModule, argv[i+1], NUM_TOKENS_IN_TABLE( AdminStates ),
                            AdminStates, &adminState)) 
                    {
                        i += 1;
                        pAdminState = &adminState;
                        continue;
                    }
                    else
                    {
                        break;
                    }
                }
                
                if ( !_wcsicmp( argv[i], TOKEN_ADVERTISE )) 
                {
                    if ( (pAdvertise == NULL) && (i < argc - 1)&& 
                         !MatchEnumTag (g_hModule, argv[i+1], NUM_TOKENS_IN_TABLE( AdminStates ),
                            AdminStates, &advertise)) 
                    {
                        i += 1;
                        pAdvertise = &advertise;
                        continue;
                    }
                    else
                    {
                        break;
                    }
                }
                
                if ( !_wcsicmp (argv[i], TOKEN_LISTEN )) 
                {
                    if ( (pListen == NULL) && (i < argc - 1) && 
                         !MatchEnumTag (g_hModule, argv[i+1], NUM_TOKENS_IN_TABLE( AdminStates ),
                            AdminStates, &listen)) 
                    {
                        i += 1;
                        pListen = &listen;
                        continue;
                    }
                    else
                    {
                        break;
                    }
                }
                
                if ( !_wcsicmp (argv[i], TOKEN_GNSREPLY )) 
                {
                    if ( (pReply == NULL) && (i < argc - 1) && 
                         !MatchEnumTag (g_hModule, argv[i+1], NUM_TOKENS_IN_TABLE( AdminStates ),
                            AdminStates, &reply)) 
                    {
                        i += 1;
                        pReply = &reply;
                        continue;
                    }
                    else
                    {
                        break;
                    }
                }
                
                if ( !_wcsicmp (argv[i], TOKEN_UPDATEMODE )) 
                {
                    if ( (pUpdateMode == NULL) && (i < argc - 1) && 
                         !MatchEnumTag (g_hModule, argv[i+1], NUM_TOKENS_IN_TABLE( UpdateModes ),
                            UpdateModes, &updateMode)) 
                    {
                        i += 1;
                        pUpdateMode = &updateMode;
                        continue;
                    }
                    else
                    {
                        break;
                    }
                }
                
                if ( !_wcsicmp (argv[i], TOKEN_INTERVAL )) 
                {
                    if ((pInterval == NULL)
                         && (i < argc - 1)
                         && (swscanf (argv[i+1], L"%ld%n", &interval, &n) == 1)
                         && (n == wcslen(argv[i+1]))) 
                    {
                        i += 1;
                        pInterval = &interval;
                        continue;
                    }
                    else
                    {
                        break;
                    }
                }
                
                if ( !_wcsicmp (argv[i], TOKEN_AGEMULTIPLIER )) 
                {
                    if ((pAgeMultiplier == NULL)
                         && (i < argc - 1)
                         && (swscanf (argv[i+1], L"%ld%n", &ageMultiplier, &n) == 1)
                         && (n == wcslen(argv[i+1]))) 
                    {
                        i += 1;
                        pAgeMultiplier = &ageMultiplier;
                        continue;
                    }
                    else
                    {
                        break;
                    }
                }
                
                if (pAdminState == NULL) 
                {
                    if ( !MatchEnumTag (g_hModule, argv[ i ], NUM_TOKENS_IN_TABLE( AdminStates ),
                            AdminStates, &adminState)) 
                    {
                        pAdminState = &adminState;
                    }
                    else
                    {
                        break;
                    }
                }
                
                else if (pAdvertise == NULL) 
                {
                    if ( !MatchEnumTag (g_hModule, argv[ i ], NUM_TOKENS_IN_TABLE( AdminStates ),
                            AdminStates, &advertise)) 
                    {
                        pAdvertise = &advertise;
                    }
                    else
                    {
                        break;
                    }
                }
                
                else if (pListen == NULL) 
                {
                    if ( !MatchEnumTag (g_hModule, argv[ i ], NUM_TOKENS_IN_TABLE( AdminStates ),
                            AdminStates, &listen)) 
                    {
                        pListen = &listen;
                    }
                    else
                    {
                        break;
                    }
                }
                
                else if (pReply == NULL) 
                {
                    if ( !MatchEnumTag (g_hModule, argv[ i ], NUM_TOKENS_IN_TABLE( AdminStates ),
                            AdminStates, &reply)) 
                    {
                        pReply = &reply;
                    }
                    else
                    {
                        break;
                    }
                }
                
                else if (pUpdateMode == NULL) 
                {
                    if ( !MatchEnumTag (g_hModule, argv[ i ], NUM_TOKENS_IN_TABLE( UpdateModes ),
                            UpdateModes, &updateMode)) 
                    {
                        pUpdateMode = &updateMode;
                    }
                    else
                    {
                        break;
                    }
                }
                
                else if (pInterval == NULL) 
                {
                    if ((swscanf (argv[i], L"%ld%n", &interval, &n) == 1)
                         && (n == wcslen(argv[i]))) 
                    {
                        pInterval = &interval;
                    }
                    else
                    {
                        break;
                    }
                }
                
                else if (pAgeMultiplier == NULL) 
                {
                    if ((swscanf (argv[i], L"%ld%n", &ageMultiplier, &n) == 1)
                         && (n == wcslen(argv[i]))) 
                    {
                        pAgeMultiplier = &ageMultiplier;
                    }
                    else
                    {
                        break;
                    }
                }
                
                else
                {
                    break;
                }
            }

            
            if ( i == argc ) 
            {
                if (!client) 
                {
                    DWORD rc2;

                    //======================================
                    // Translate the Interface Name
                    //======================================

                    rc = IpmontrGetIfNameFromFriendlyName(
                            InterfaceNameW, IfName, &dwSize
                            );

                    if ( rc == NO_ERROR )
                    {
                        rc2 = CfgSetSapIf(
                                IfName, pAdminState, pAdvertise, pListen, pReply,
                                pUpdateMode, pInterval, pAgeMultiplier
                                );
                          
                        if (rc2 == NO_ERROR) 
                        {
                            if (g_hMprAdmin) 
                            {
                                rc = AdmSetSapIf(
                                        IfName, pAdminState, pAdvertise, pListen, 
                                        pReply, pUpdateMode, pInterval, 
                                        pAgeMultiplier
                                        );
                            }
                        }
                        else
                        {
                            rc = rc2;
                        }
                    }
                    
                    else
                    {
                        DisplayError( g_hModule, rc );
                    }
                }
                
                else 
                {
                    rc = CfgSetSapIf(
                            NULL, pAdminState, pAdvertise, pListen, pReply,
                            pUpdateMode, pInterval, pAgeMultiplier
                            );
                            
                    if (rc == NO_ERROR) 
                    {
                        if (g_hMprAdmin) 
                        {
                            rc = AdmSetSapIf(
                                    NULL, pAdminState, pAdvertise, pListen, pReply,
                                    pUpdateMode, pInterval, pAgeMultiplier
                                    );
                        }
                    }
                }
            }
            else 
            {
                DisplayMessage (g_hModule, HLP_IPX_SAPIF);
                rc = ERROR_INVALID_PARAMETER;
            }
        }
        else 
        {
            DisplayIPXMessage (g_hModule, MSG_INVALID_INTERFACE_NAME);
            rc = ERROR_INVALID_PARAMETER;
        }
    }
    else 
    {
        DisplayMessage (g_hModule, HLP_IPX_SAPIF);
        rc = ERROR_INVALID_PARAMETER;
    }

    return rc;
    
#undef InterfaceNameW
}





DWORD
MIBGetSapIf(
    PWCHAR      InterfaceNameW,
    HANDLE      hFile
) 
{
    DWORD                   rc;
    DWORD                   sz;
    SAP_MIB_GET_INPUT_DATA  MibGetInputData;
    PSAP_INTERFACE          pIf;
    WCHAR                   IfName[ MAX_INTERFACE_NAME_LEN + 1 ];
    DWORD                   dwSize = sizeof(IfName);

    MibGetInputData.TableId = SAP_INTERFACE_TABLE;
    
    rc = GetIpxInterfaceIndex(
            g_hMIBServer, InterfaceNameW, &MibGetInputData.InterfaceIndex
            );
    if (rc == NO_ERROR) 
    {
        rc = MprAdminMIBEntryGet(
                g_hMIBServer, PID_IPX, IPX_PROTOCOL_SAP, &MibGetInputData,
                sizeof(SAP_MIB_GET_INPUT_DATA), (LPVOID * ) & pIf, &sz
                );
                
        if (rc == NO_ERROR) 
        {
            PWCHAR  buffer[6];
            DWORD   i;

            //======================================
            // Translate the Interface Name
            //======================================

            rc = IpmontrGetFriendlyNameFromIfName(
                    InterfaceNameW, IfName, &dwSize
                    );
            
            if ( rc == NO_ERROR )
            {
                buffer[ 0 ] = GetEnumString(
                                g_hModule, pIf->SapIfInfo.AdminState,
                                NUM_TOKENS_IN_TABLE( AdminStates ),
                                AdminStates
                                );

                buffer[ 1 ] = GetEnumString(
                                g_hModule, pIf->SapIfInfo.Supply,
                                NUM_TOKENS_IN_TABLE( AdminStates ),
                                AdminStates
                                );

                buffer[ 2 ] = GetEnumString(
                                g_hModule, pIf->SapIfInfo.Listen,
                                NUM_TOKENS_IN_TABLE( AdminStates ),
                                AdminStates
                                );

                buffer[ 3 ] = GetEnumString(
                                g_hModule, pIf->SapIfInfo.GetNearestServerReply,
                                NUM_TOKENS_IN_TABLE( AdminStates ),
                                AdminStates
                                );

                buffer[ 4 ] = GetEnumString(
                                g_hModule, pIf->SapIfInfo.UpdateMode,
                                NUM_TOKENS_IN_TABLE( UpdateModes ),
                                UpdateModes
                                );

                buffer[ 5 ] = GetEnumString(
                                g_hModule, pIf->SapIfStats.SapIfOperState,
                                NUM_TOKENS_IN_TABLE( OperStates ),
                                OperStates
                                );
                
                if ( buffer [ 0 ] && buffer[ 1 ] && buffer[ 2 ] &&
                     buffer[ 3 ] && buffer[ 4 ] && buffer[ 5 ] )
                {
                    if ( hFile )
                    {
                        DisplayMessageT(
                            DMP_IPX_SAP_SET_INTERFACE, IfName, buffer[ 0 ],
                            buffer[ 1 ], buffer[ 2 ], buffer[ 3 ],
                            buffer[ 4 ], pIf->SapIfInfo.PeriodicUpdateInterval,
                            pIf->SapIfInfo.AgeIntervalMultiplier
                            );
                    }

                    else
                    {
                        DisplayIPXMessage(
                            g_hModule, MSG_SAPIF_MIB_SCREEN_FMT,
                            IfName, buffer[ 0 ], buffer[ 1 ],
                            buffer[ 2 ], buffer[ 3 ], buffer[ 4 ],
                            pIf->SapIfInfo.PeriodicUpdateInterval,
                            pIf->SapIfInfo.AgeIntervalMultiplier,
                            buffer[5],
                            pIf->SapIfStats.SapIfInputPackets,
                            pIf->SapIfStats.SapIfOutputPackets
                            );
                    }
                }

                else
                {
                    rc = ERROR_NOT_ENOUGH_MEMORY;
                    if ( !hFile ) { DisplayError( g_hModule, rc ); }
                }

                MprAdminMIBBufferFree (pIf);
            }
            else
            {
                if ( !hFile ) { DisplayError( g_hModule, rc ); }
            }
        }
        else 
        {
            if ( !hFile ) { DisplayError( g_hModule, rc); }
        }
    }
    else 
    {
        if ( !hFile ) { DisplayError( g_hModule, rc); }
    }
    
    return rc;
}



DWORD
CfgGetSapIf (
    PWCHAR      InterfaceNameW,
    HANDLE      hFile
) 
{
    DWORD   rc;
    DWORD   sz;
    HANDLE  hIfCfg;
    WCHAR   IfName[ MAX_INTERFACE_NAME_LEN + 1 ];
    DWORD   dwSize = sizeof(IfName);

    rc = MprConfigInterfaceGetHandle(
            g_hMprConfig, InterfaceNameW, &hIfCfg
            );
            
    if (rc == NO_ERROR) 
    {
        HANDLE        hIfTrCfg;

        rc = MprConfigInterfaceTransportGetHandle (
                g_hMprConfig, hIfCfg, PID_IPX, &hIfTrCfg
                );
                
        if (rc == NO_ERROR) 
        {
            LPBYTE    pIfBlock;
            
            rc = MprConfigInterfaceTransportGetInfo (
                    g_hMprConfig, hIfCfg, hIfTrCfg, &pIfBlock, &sz
                    );
                    
            if (rc == NO_ERROR) 
            {
                PIPX_TOC_ENTRY pSapToc;

                pSapToc = GetIPXTocEntry (
                                (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                                IPX_PROTOCOL_SAP
                                );
                                
                if (pSapToc != NULL) 
                {
                    PSAP_IF_CONFIG  pSapCfg;
                    PWCHAR          buffer[5];
                    DWORD           i;

                    pSapCfg = (PSAP_IF_CONFIG)
                                (pIfBlock + pSapToc->Offset);

                    //======================================
                    // Translate the Interface Name
                    //======================================
                    
                    rc = IpmontrGetFriendlyNameFromIfName(
                            InterfaceNameW, IfName, &dwSize
                            );

                    if ( rc == NO_ERROR )
                    {                        
                        buffer[ 0 ] = GetEnumString(
                                        g_hModule, pSapCfg->SapIfInfo.AdminState,
                                        NUM_TOKENS_IN_TABLE( AdminStates ),
                                        AdminStates
                                        );

                        buffer[ 1 ] = GetEnumString(
                                        g_hModule, pSapCfg->SapIfInfo.Supply,
                                        NUM_TOKENS_IN_TABLE( AdminStates ),
                                        AdminStates
                                        );

                        buffer[ 2 ] = GetEnumString(
                                        g_hModule, pSapCfg->SapIfInfo.Listen,
                                        NUM_TOKENS_IN_TABLE( AdminStates ),
                                        AdminStates
                                        );

                        buffer[ 3 ] = GetEnumString(
                                        g_hModule, pSapCfg->SapIfInfo.GetNearestServerReply,
                                        NUM_TOKENS_IN_TABLE( AdminStates ),
                                        AdminStates
                                        );
                                        
                        buffer[ 4 ] = GetEnumString(
                                        g_hModule, pSapCfg->SapIfInfo.UpdateMode,
                                        NUM_TOKENS_IN_TABLE( UpdateModes ),
                                        UpdateModes
                                        );

                        
                        if ( buffer [ 0 ] && buffer[ 1 ] && buffer[ 2 ] &&
                             buffer[ 3 ] && buffer[ 4 ] )
                        {
                            if ( hFile )
                            {
                                DisplayMessageT(
                                    DMP_IPX_SAP_SET_INTERFACE, IfName, buffer[ 0 ],
                                    buffer[ 1 ], buffer[ 2 ], buffer[ 3 ],
                                    buffer[ 4 ], pSapCfg->SapIfInfo.PeriodicUpdateInterval,
                                    pSapCfg->SapIfInfo.AgeIntervalMultiplier
                                    );
                            }

                            else
                            {
                                DisplayIPXMessage(
                                    g_hModule, MSG_SAPIF_CFG_SCREEN_FMT,
                                    IfName, buffer[0], buffer[1], buffer[2],
                                    buffer[3], buffer[4],
                                    pSapCfg->SapIfInfo.PeriodicUpdateInterval,
                                    pSapCfg->SapIfInfo.AgeIntervalMultiplier
                                    );
                            }
                        }
                        else
                        {
                            rc = ERROR_NOT_ENOUGH_MEMORY;
                            if ( !hFile ) { DisplayError( g_hModule, rc ); }
                        }
                    }
                    else
                    {
                        if ( !hFile ) { DisplayError( g_hModule, rc ); }
                    }
                }
                else 
                {
                    if ( !hFile ) { DisplayIPXMessage (g_hModule, MSG_INTERFACE_INFO_CORRUPTED); }
                    rc = ERROR_INVALID_DATA;
                }
            }
            else 
            {
                if ( !hFile ) { DisplayError( g_hModule, rc); }
            }
        }
        else 
        {
            if ( !hFile ) { DisplayError( g_hModule, rc); }
        }
    }
    else 
    {
        if ( !hFile ) { DisplayError( g_hModule, rc); }
    }

    return rc;
}


DWORD
GetSapClientIf(
    PWCHAR      InterfaceName,
    UINT        msg,
    HANDLE      hFile
) 
{
    DWORD    rc;
    LPBYTE    pClBlock;
    HANDLE    hTrCfg;
    DWORD   sz, i;

    hTrCfg = NULL;
    
    if (g_hMprAdmin) 
    {
        rc = MprAdminTransportGetInfo(
                g_hMprAdmin, PID_IPX, NULL, NULL, &pClBlock, &sz
                );
        if (rc == NO_ERROR) 
        {
            NOTHING;
        }
        else 
        {
            if ( !hFile ) { DisplayError( g_hModule, rc); }
            goto GetFromCfg;
        }
    }

    else 
    {
GetFromCfg:

        rc = MprConfigTransportGetHandle (
                g_hMprConfig, PID_IPX, &hTrCfg
                );
                
        if (rc == NO_ERROR) 
        {
            rc = MprConfigTransportGetInfo (
                    g_hMprConfig, hTrCfg, NULL, NULL, &pClBlock, &sz, NULL
                    );
                    
            if (rc == NO_ERROR)
            {
                NOTHING;
            }

            else
            {
                if ( !hFile ) { DisplayError( g_hModule, rc); }
            }
        }
        
        else
        {
            if ( !hFile ) { DisplayError( g_hModule, rc); }
        }
    }

    
    if (rc == NO_ERROR) 
    {
        PIPX_TOC_ENTRY pSapToc;

        pSapToc = GetIPXTocEntry(
                    (PIPX_INFO_BLOCK_HEADER)pClBlock,
                    IPX_PROTOCOL_SAP
                    );
                    
        if (pSapToc != NULL) 
        {
            PSAP_IF_CONFIG  pSapCfg;
            PWCHAR          buffer[5];

            pSapCfg = (PSAP_IF_CONFIG)
                        (pClBlock + pSapToc->Offset);
                        
            buffer[ 0 ] = GetEnumString(
                            g_hModule, pSapCfg->SapIfInfo.AdminState,
                            NUM_TOKENS_IN_TABLE( AdminStates ),
                            AdminStates
                            );

            buffer[ 1 ] = GetEnumString(
                            g_hModule, pSapCfg->SapIfInfo.Supply,
                            NUM_TOKENS_IN_TABLE( AdminStates ),
                            AdminStates
                            );

            buffer[ 2 ] = GetEnumString(
                            g_hModule, pSapCfg->SapIfInfo.Listen,
                            NUM_TOKENS_IN_TABLE( AdminStates ),
                            AdminStates
                            );

            buffer[ 3 ] = GetEnumString(
                            g_hModule, pSapCfg->SapIfInfo.GetNearestServerReply,
                            NUM_TOKENS_IN_TABLE( AdminStates ),
                            AdminStates
                            );

            buffer[ 4 ] = GetEnumString(
                            g_hModule, pSapCfg->SapIfInfo.UpdateMode,
                            NUM_TOKENS_IN_TABLE( UpdateModes ),
                            UpdateModes
                            );

            switch (msg) 
            {
            case MSG_CLIENT_SAPIF_MIB_TABLE_FMT:
            case MSG_CLIENT_SAPIF_CFG_TABLE_FMT:

                if ( buffer[ 4 ] && buffer[ 0 ] )
                {
                    DisplayIPXMessage(
                        g_hModule, msg, InterfaceName, buffer[ 4 ], buffer[ 0 ]
                        );
                }
                
                else
                {
                    rc = ERROR_NOT_ENOUGH_MEMORY;
                    if ( !hFile ) { DisplayError( g_hModule, rc ); }
                }
                
                break;
                
            case MSG_CLIENT_SAPIF_MIB_SCREEN_FMT:
            case MSG_CLIENT_SAPIF_CFG_SCREEN_FMT:

                if (  buffer[ 0 ] && buffer[ 1 ] && buffer[ 2 ] && buffer[ 3 ] &&
                      buffer[ 4 ] )
                {
                    if ( hFile )
                    {
                        DisplayMessageT(
                            DMP_IPX_SAP_SET_INTERFACE, InterfaceName, buffer[ 0 ],
                            buffer[ 1 ], buffer[ 2 ], buffer[ 3 ],
                            buffer[ 4 ], pSapCfg->SapIfInfo.PeriodicUpdateInterval,
                            pSapCfg->SapIfInfo.AgeIntervalMultiplier
                            );
                    }

                    else
                    {
            
                        DisplayIPXMessage(
                            g_hModule, msg, InterfaceName,
                            buffer[0], buffer[1], buffer[2], buffer[3], buffer[4],
                            pSapCfg->SapIfInfo.PeriodicUpdateInterval,
                            pSapCfg->SapIfInfo.AgeIntervalMultiplier
                            );
                    }
                }
                
                else
                {
                    rc = ERROR_NOT_ENOUGH_MEMORY;
                    if ( !hFile ) { DisplayError( g_hModule, rc ); }
                }
                
                break;
            }
        }

        else 
        {
            if ( !hFile ) { DisplayIPXMessage (g_hModule, MSG_INTERFACE_INFO_CORRUPTED); }
            rc = ERROR_INVALID_DATA;
        }
        
        if (hTrCfg != NULL)
        {
            MprConfigBufferFree (pClBlock);
        }
        else
        {
            MprAdminBufferFree (pClBlock);
        }
    }

    return rc;
}


PSAP_IF_CONFIG 
GetIpxSapInterface(
    HANDLE          hIf, 
    LPBYTE         *pIfBlock
    ) 
{
    DWORD dwSize;
    DWORD dwErr;
    PIPX_TOC_ENTRY pIpxToc;

    dwErr = MprAdminInterfaceTransportGetInfo(
                g_hMprAdmin, hIf, PID_IPX, pIfBlock, &dwSize
                );

    if (dwErr != NO_ERROR)
    {
        return NULL;
    }

    pIpxToc = GetIPXTocEntry ((PIPX_INFO_BLOCK_HEADER)(*pIfBlock), IPX_PROTOCOL_SAP);

    if (!pIpxToc)
    {
        return NULL;
    }

    return (PSAP_IF_CONFIG)((*pIfBlock) + (pIpxToc->Offset));
}


DWORD
MIBEnumSapIfs (VOID) 
{
    PMPR_INTERFACE_0 IfList = NULL;
    DWORD dwErr = 0, dwRead, dwTot, i, j;
    PWCHAR buffer[3];
    LPBYTE buf = NULL;
    PSAP_IF_CONFIG pSapCfg;
    WCHAR IfName[ MAX_INTERFACE_NAME_LEN + 1 ];
    DWORD dwSize = sizeof(IfName);

    DisplayIPXMessage (g_hModule, MSG_SAPIF_MIB_TABLE_HDR);

    dwErr = MprAdminInterfaceEnum(
                g_hMprAdmin, 0, (unsigned char **) & IfList, MAXULONG, 
                &dwRead, &dwTot, NULL
                );
                
    if (dwErr != NO_ERROR)
    {
        return dwErr;
    }

    for (i = 0; i < dwRead; i++) 
    {
        if ((pSapCfg = GetIpxSapInterface(IfList[i].hInterface, &buf)) != NULL) 
        {
            //======================================
            // Translate the Interface Name
            //======================================
            dwErr = IpmontrGetFriendlyNameFromIfName(
                        IfList[i].wszInterfaceName,
                        IfName, &dwSize
                        );
                        
            if ( dwErr == NO_ERROR )
            {
                buffer[ 2 ] = GetEnumString(
                                g_hModule, pSapCfg->SapIfInfo.AdminState,
                                NUM_TOKENS_IN_TABLE( AdminStates ),
                                AdminStates
                                );

                buffer[ 0 ] = GetEnumString(
                                g_hModule, pSapCfg->SapIfInfo.UpdateMode,
                                NUM_TOKENS_IN_TABLE( UpdateModes ),
                                UpdateModes
                                );

                buffer[ 1 ] = GetEnumString(
                                g_hModule, IfList[i].dwConnectionState,
                                NUM_TOKENS_IN_TABLE( InterfaceStates ),
                                InterfaceStates
                                );
                                
                if (  buffer[ 0 ] && buffer[ 1 ] && buffer[ 2 ] )
                {
                    DisplayIPXMessage(
                        g_hModule, MSG_SAPIF_MIB_TABLE_FMT,
                        buffer[1], buffer[2], buffer[0],
                        IfName
                        );
                }
                else
                {
                    dwErr = ERROR_NOT_ENOUGH_MEMORY;
                    DisplayError( g_hModule, dwErr );
                }
            }
        }
    }
    
    if (buf)
    {
        MprAdminBufferFree(buf);
    }

    buf = NULL;

    return NO_ERROR;
}


/*
DWORD
MIBEnumSapIfs (
    VOID
    ) {
    DWORD                    rc;
    DWORD                    sz;
    SAP_MIB_GET_INPUT_DATA    MibGetInputData;
    PSAP_INTERFACE            pIf;

    DisplayIPXMessage (g_hModule, MSG_SAPIF_MIB_TABLE_HDR);
    MibGetInputData.TableId = SAP_INTERFACE_TABLE;
    rc = MprAdminMIBEntryGetFirst (
                g_hMIBServer,
                PID_IPX,
                IPX_PROTOCOL_SAP,
                &MibGetInputData,
                sizeof(SAP_MIB_GET_INPUT_DATA),
                (LPVOID *)&pIf,
                &sz);
    while (rc==NO_ERROR) {
//        CHAR        InterfaceNameA[IPX_INTERFACE_ANSI_NAME_LEN+1];
        CHAR        InterfaceNameA[MAX_INTERFACE_NAME_LEN+1];
        DWORD        rc1;
        //rc1 = GetIpxInterfaceName (g_hMIBServer,
        //                    pIf->InterfaceIndex,
        //                    InterfaceNameA);
        rc1=(*(Params->IfInd2IfNameA))(pIf->InterfaceIndex, InterfaceNameA, &(Params->IfNamBufferLength));

        if (rc1==NO_ERROR) {
            WCHAR        buffer[3][MAX_VALUE];
            HANDLE      hIfCfg;
            WCHAR       InterfaceNameW[MAX_INTERFACE_NAME_LEN+1];
            mbstowcs (InterfaceNameW, InterfaceNameA,  sizeof (InterfaceNameW));

            if (MprConfigInterfaceGetHandle (
                            g_hMprConfig,
                            InterfaceNameW,
                            &hIfCfg)==NO_ERROR) {
                //======================================
                // Translate the Interface Name
                //======================================
                if ((rc=(*(Params->IfName2DescA))(InterfaceNameA,
                                            Params->IfNamBufferA,
                                              &Params->IfNamBufferLength)) != NO_ERROR) {
                        return rc;
                }
                //======================================
                DisplayIPXMessage (g_hModule,
                    MSG_SAPIF_MIB_TABLE_FMT,
                    Params->IfNamBufferA, //InterfaceNameA,
                    GetValueString (g_hModule, Utils, UpdateModes,
                            pIf->SapIfInfo.UpdateMode, buffer[0]),
                    GetValueString (g_hModule, Utils, AdminStates,
                            pIf->SapIfInfo.AdminState, buffer[1]),
                    GetValueString (g_hModule, Utils, OperStates,
                            pIf->SapIfStats.SapIfOperState, buffer[2])
                    );
            }
        }
        else
            DisplayError( g_hModule, rc1);
        MibGetInputData.InterfaceIndex
                = pIf->InterfaceIndex;
        MprAdminMIBBufferFree (pIf);
        rc = MprAdminMIBEntryGetNext (
                    g_hMIBServer,
                    PID_IPX,
                    IPX_PROTOCOL_SAP,
                    &MibGetInputData,
                    sizeof(SAP_MIB_GET_INPUT_DATA),
                    (LPVOID *)&pIf,
                    &sz);
    }
    if (rc==ERROR_NO_MORE_ITEMS)
        return NO_ERROR;
    else {
        DisplayError( g_hModule, rc);
        return rc;
    }
}
*/

DWORD
CfgEnumSapIfs (
    VOID
) 
{
    DWORD               rc = NO_ERROR;
    DWORD               read, total, processed = 0, i, dwErr;
    DWORD               hResume = 0;
    DWORD               sz;
    PMPR_INTERFACE_0    pRi0;
    WCHAR               IfName[ MAX_INTERFACE_NAME_LEN + 1 ];
    DWORD               dwSize = sizeof(IfName);

    DisplayIPXMessage (g_hModule, MSG_SAPIF_CFG_TABLE_HDR);

    do 
    {
        rc = MprConfigInterfaceEnum (
                g_hMprConfig, 0, (LPBYTE * ) & pRi0, MAXULONG, 
                &read, &total, &hResume
                );
                
        if (rc == NO_ERROR) 
        {
            for (i = 0; i < read; i++) 
            {
                HANDLE  hIfTrCfg;

                rc = MprConfigInterfaceTransportGetHandle (
                        g_hMprConfig, pRi0[i].hInterface, PID_IPX, &hIfTrCfg
                        );
                        
                if (rc == NO_ERROR) 
                {
                    LPBYTE    pIfBlock;
                    
                    rc = MprConfigInterfaceTransportGetInfo (
                            g_hMprConfig, pRi0[i].hInterface, hIfTrCfg, &pIfBlock, &sz
                            );
                            
                    if (rc == NO_ERROR) 
                    {
                        PIPX_TOC_ENTRY pSapToc;

                        pSapToc = GetIPXTocEntry (
                                    (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                                    IPX_PROTOCOL_SAP
                                    );
                                    
                        if (pSapToc != NULL) 
                        {
                            PSAP_IF_CONFIG  pSapCfg;
                            PWCHAR          buffer[2];

                            pSapCfg = (PSAP_IF_CONFIG) (pIfBlock + pSapToc->Offset);

                            //======================================
                            // Translate the Interface Name
                            //======================================
                            dwErr = IpmontrGetFriendlyNameFromIfName(
                                        pRi0[i].wszInterfaceName,
                                        IfName, &dwSize
                                        );
                                        
                            if ( dwErr != NO_ERROR )
                            {
                                buffer[ 1 ] = GetEnumString(
                                                g_hModule, pSapCfg->SapIfInfo.AdminState,
                                                NUM_TOKENS_IN_TABLE( AdminStates ),
                                                AdminStates
                                                );

                                buffer[ 0 ] = GetEnumString(
                                                g_hModule, pSapCfg->SapIfInfo.UpdateMode,
                                                NUM_TOKENS_IN_TABLE( UpdateModes ),
                                                UpdateModes
                                                );
                                                
                                if (  buffer[ 0 ] && buffer[ 1 ] )
                                {
                                    DisplayIPXMessage(
                                        g_hModule, MSG_SAPIF_CFG_TABLE_FMT,
                                        IfName, buffer[0], buffer[1]                                        
                                        );
                                }
                                else
                                {
                                    rc = ERROR_NOT_ENOUGH_MEMORY;
                                    DisplayError( g_hModule, rc );
                                }
                            }

                            else
                            {
                                DisplayError( g_hModule, rc );
                            }
                        }
                        else 
                        {
                            DisplayIPXMessage (g_hModule, MSG_INTERFACE_INFO_CORRUPTED);
                            rc = ERROR_INVALID_DATA;
                        }
                    }
                    else
                    {
                        DisplayError( g_hModule, rc);
                    }
                }
                
                else 
                {
                    //DisplayError( g_hModule, rc);
                }
            }
            
            processed += read;
            MprConfigBufferFree (pRi0);
        }
        else 
        {
            DisplayError( g_hModule, rc);
            break;
        }
        
    } while (processed < total);

    return rc;
}


DWORD
CfgSetSapIf (
    LPWSTR        InterfaceNameW,
    PULONG        pAdminState        OPTIONAL,
    PULONG        pAdvertise        OPTIONAL,
    PULONG        pListen            OPTIONAL,
    PULONG        pReply            OPTIONAL,
    PULONG        pUpdateMode        OPTIONAL,
    PULONG        pInterval        OPTIONAL,
    PULONG        pAgeMultiplier    OPTIONAL
) 
{
    DWORD        rc;
    DWORD        sz;
    HANDLE        hTrCfg;
    HANDLE        hIfCfg;
    HANDLE        hIfTrCfg;
    LPBYTE        pIfBlock;

    if (InterfaceNameW != NULL) 
    {
        rc = MprConfigInterfaceGetHandle (
                g_hMprConfig, InterfaceNameW, &hIfCfg
                );
                
        if (rc == NO_ERROR) 
        {
            rc = MprConfigInterfaceTransportGetHandle (
                    g_hMprConfig, hIfCfg, PID_IPX, &hIfTrCfg
                    );
                    
            if (rc == NO_ERROR) 
            {
                rc = MprConfigInterfaceTransportGetInfo (
                        g_hMprConfig, hIfCfg, hIfTrCfg, &pIfBlock, &sz
                        );
            }
        }
    }
    
    else 
    {
        rc = MprConfigTransportGetHandle (
                g_hMprConfig, PID_IPX, &hTrCfg
                );
                
        if (rc == NO_ERROR) 
        {
            rc = MprConfigTransportGetInfo (
                    g_hMprConfig, hTrCfg, NULL, NULL, &pIfBlock, &sz, NULL
                    );
        }
    }

    if (rc == NO_ERROR) 
    {
        PIPX_TOC_ENTRY pSapToc;

        pSapToc = GetIPXTocEntry (
                    (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                    IPX_PROTOCOL_SAP
                    );
                    
        if (pSapToc != NULL) 
        {
            PSAP_IF_CONFIG    pSapCfg;

            pSapCfg = (PSAP_IF_CONFIG) (pIfBlock + pSapToc->Offset);

            if (ARGUMENT_PRESENT (pAdminState))            
            {
                pSapCfg->SapIfInfo.AdminState = *pAdminState;
            }

            if (ARGUMENT_PRESENT (pAdvertise))
            {
                pSapCfg->SapIfInfo.Supply = *pAdvertise;
            }

            if (ARGUMENT_PRESENT (pListen))
            {
                pSapCfg->SapIfInfo.Listen = *pListen;
            }

            if (ARGUMENT_PRESENT (pReply))
            {
                pSapCfg->SapIfInfo.GetNearestServerReply = *pReply;
            }

            if (ARGUMENT_PRESENT (pUpdateMode))
            {
                pSapCfg->SapIfInfo.UpdateMode = *pUpdateMode;
            }

            if (ARGUMENT_PRESENT (pInterval))
            {
                pSapCfg->SapIfInfo.PeriodicUpdateInterval = *pInterval;
            }

            if (ARGUMENT_PRESENT (pAgeMultiplier))
            {
                pSapCfg->SapIfInfo.AgeIntervalMultiplier = *pAgeMultiplier;
            }

            if (InterfaceNameW != NULL)
            {
                rc = MprConfigInterfaceTransportSetInfo (
                        g_hMprConfig, hIfCfg, hIfTrCfg, pIfBlock, sz
                        );
            }
            
            else
            {
                rc = MprConfigTransportSetInfo (
                        g_hMprConfig, hTrCfg, NULL, 0, pIfBlock, sz, NULL
                        );
            }
            
            if (rc == NO_ERROR) 
            {
                if (InterfaceNameW != NULL)
                {
                    DisplayIPXMessage (
                        g_hModule, MSG_SAPIF_SET_CFG, InterfaceNameW
                        );
                }
                
                else
                {
                    DisplayIPXMessage (g_hModule, MSG_CLIENT_SAPIF_SET_CFG);
                }
            }
            
            else
            {
                DisplayError( g_hModule, rc);
            }
        }
        else 
        {
            DisplayIPXMessage (g_hModule, MSG_INTERFACE_INFO_CORRUPTED);
            rc = ERROR_INVALID_DATA;
        }
        
        MprConfigBufferFree (pIfBlock);
    }

    else
    {
        DisplayError( g_hModule, rc);
    }

    return rc;
}


DWORD
AdmSetSapIf (
    LPWSTR        InterfaceNameW,
    PULONG        pAdminState        OPTIONAL,
    PULONG        pAdvertise        OPTIONAL,
    PULONG        pListen            OPTIONAL,
    PULONG        pReply            OPTIONAL,
    PULONG        pUpdateMode        OPTIONAL,
    PULONG        pInterval        OPTIONAL,
    PULONG        pAgeMultiplier    OPTIONAL
) 
{
    DWORD        rc;
    DWORD        sz;
    HANDLE        hIfAdm;
    LPBYTE        pIfBlock;

    if (InterfaceNameW != NULL) 
    {
        rc = MprAdminInterfaceGetHandle (
                g_hMprAdmin, InterfaceNameW, &hIfAdm, FALSE
                );
                
        if (rc == NO_ERROR) 
        {
            rc = MprAdminInterfaceTransportGetInfo (
                    g_hMprAdmin, hIfAdm, PID_IPX, &pIfBlock, &sz
                    );
        }
    }
    
    else 
    {
        rc = MprAdminTransportGetInfo (
                g_hMprAdmin, PID_IPX, NULL, NULL, &pIfBlock, &sz
                );
    }

    if (rc == NO_ERROR) 
    {
        PIPX_TOC_ENTRY pSapToc;

        pSapToc = GetIPXTocEntry (
                    (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                    IPX_PROTOCOL_SAP
                    );
                    
        if (pSapToc != NULL) 
        {
            PSAP_IF_CONFIG    pSapCfg;

            pSapCfg = (PSAP_IF_CONFIG) (pIfBlock + pSapToc->Offset);

            if (ARGUMENT_PRESENT (pAdminState))
            {
                pSapCfg->SapIfInfo.AdminState = *pAdminState;
            }

            if (ARGUMENT_PRESENT (pAdvertise))
            {
                pSapCfg->SapIfInfo.Supply = *pAdvertise;
            }

            if (ARGUMENT_PRESENT (pListen))
            {
                pSapCfg->SapIfInfo.Listen = *pListen;
            }

            if (ARGUMENT_PRESENT (pReply))
            {
                pSapCfg->SapIfInfo.GetNearestServerReply = *pReply;
            }

            if (ARGUMENT_PRESENT (pUpdateMode))
            {
                pSapCfg->SapIfInfo.UpdateMode = *pUpdateMode;
            }

            if (ARGUMENT_PRESENT (pInterval))
            {
                pSapCfg->SapIfInfo.PeriodicUpdateInterval = *pInterval;
            }

            if (ARGUMENT_PRESENT (pAgeMultiplier))
            {
                pSapCfg->SapIfInfo.AgeIntervalMultiplier = *pAgeMultiplier;
            }

            if (InterfaceNameW != NULL)
            {
                rc = MprAdminInterfaceTransportSetInfo (
                        g_hMprAdmin, hIfAdm, PID_IPX, pIfBlock,
                        ((PIPX_INFO_BLOCK_HEADER)pIfBlock)->Size
                        );
            }
            
            else
            {
                rc = MprAdminTransportSetInfo (
                        g_hMprAdmin, PID_IPX, NULL, 0, pIfBlock,
                        ((PIPX_INFO_BLOCK_HEADER)pIfBlock)->Size
                        );
            }


            if (rc == NO_ERROR) 
            {
                if (InterfaceNameW != NULL)
                {
                    DisplayIPXMessage (g_hModule, MSG_SAPIF_SET_ADM, InterfaceNameW);
                }
                
                else
                {
                    DisplayIPXMessage (g_hModule, MSG_CLIENT_SAPIF_SET_ADM);
                }
            }
            
            else
            {
                DisplayError( g_hModule, rc);
            }
        }
        
        else 
        {
            DisplayIPXMessage (g_hModule, MSG_INTERFACE_INFO_CORRUPTED);
            rc = ERROR_INVALID_DATA;
        }
        
        MprAdminBufferFree (pIfBlock);
    }
    
    else 
    {
        DisplayError( g_hModule, rc);
    }

    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ras\client.h ===
/*
    File:   client.h

    Definitions to support netsh commands that manipulate
    ras clients.

*/

FN_HANDLE_CMD    HandleClientShow;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ipx\protocols\utils.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    utils.h

Abstract:

    IPX Router Console Monitoring and Configuration tool.
    Utility routines. Header File

Author:

    Vadim Eydelman  06/07/1996


--*/
#ifndef _IPX_PROMON_UTILS_
#define _IPX_PROMON_UTILS_

extern TOKEN_VALUE InterfaceTypes[5];
extern TOKEN_VALUE InterfaceStates[3];
extern TOKEN_VALUE InterfaceEnableStatus[2];

extern TOKEN_VALUE AdminStates[2];
extern TOKEN_VALUE OperStates[3];
extern TOKEN_VALUE IpxInterfaceTypes[8];
extern TOKEN_VALUE RouterInterfaceTypes[5];
extern TOKEN_VALUE NbDeliverStates[4];
extern TOKEN_VALUE UpdateModes[3];
extern TOKEN_VALUE IpxProtocols[4];
extern TOKEN_VALUE TfFilterActions[2];
extern TOKEN_VALUE RipFilterActions[2];
extern TOKEN_VALUE SapFilterActions[2];
extern TOKEN_VALUE WANProtocols[2];
extern TOKEN_VALUE FilterModes[2];
extern TOKEN_VALUE LogLevels[4];


#define INPUT_FILTER    1
#define OUTPUT_FILTER   2

//
// This will be removed when the router is modified to use MprInfo api's
//

typedef RTR_INFO_BLOCK_HEADER IPX_INFO_BLOCK_HEADER, *PIPX_INFO_BLOCK_HEADER;
typedef RTR_TOC_ENTRY IPX_TOC_ENTRY, *PIPX_TOC_ENTRY;


DWORD
GetIpxInterfaceIndex (
    IN  MIB_SERVER_HANDLE       hRouterMIB,
    IN  LPCWSTR                 InterfaceName,
    OUT ULONG                  *InterfaceIndex
    );

DWORD
GetIpxInterfaceName (
    IN  MIB_SERVER_HANDLE       hRouterMIB,
    IN  ULONG                   InterfaceIndex,
    OUT LPWSTR                  InterfaceName
    );


PIPX_TOC_ENTRY
GetIPXTocEntry (
    IN      PIPX_INFO_BLOCK_HEADER  pInterfaceInfo,
    IN      ULONG                   InfoEntryType
    );


typedef BOOL (*PINFO_CMP_PROC) (PVOID Info1, PVOID Info2);


DWORD
AddIPXInfoEntry (
    IN      PIPX_INFO_BLOCK_HEADER  pOldBlock,
    IN      ULONG                   InfoType,
    IN      ULONG                   InfoSize,
    IN      PVOID                   Info,
    IN      PINFO_CMP_PROC          InfoEqualCB OPTIONAL,
        OUT PIPX_INFO_BLOCK_HEADER *pNewBlock
    );

DWORD
DeleteIPXInfoEntry (
    IN      PIPX_INFO_BLOCK_HEADER  pOldBlock,
    IN      ULONG                   InfoType,
    IN      ULONG          